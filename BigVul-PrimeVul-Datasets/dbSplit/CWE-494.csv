,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
3251,180987,,Remote,Not required,Partial,CVE-2017-13083,https://www.cvedetails.com/cve/CVE-2017-13083/,CWE-494,Medium,Partial,Partial,,2017-10-18,6.8,"Akeo Consulting Rufus prior to version 2.17.1187 does not adequately validate the integrity of updates downloaded over HTTP, allowing an attacker to easily convince a user to execute arbitrary code",2019-10-09,Exec Code ,20,https://github.com/pbatard/rufus/commit/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb,c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb,"[pki] fix https://www.kb.cert.org/vuls/id/403768

* This commit effectively fixes https://www.kb.cert.org/vuls/id/403768 (CVE-2017-13083) as
  it is described per its revision 11, which is the latest revision at the time of this commit,
  by disabling Windows prompts, enacted during signature validation, that allow the user to
  bypass the intended signature verification checks.
* It needs to be pointed out that the vulnerability (""allow(ing) the use of a self-signed
  certificate""), which relies on the end-user actively ignoring a Windows prompt that tells
  them that the update failed the signature validation whilst also advising against running it,
  is being fully addressed, even as the update protocol remains HTTP.
* It also need to be pointed out that the extended delay (48 hours) between the time the
  vulnerability was reported and the moment it is fixed in our codebase has to do with
  the fact that the reporter chose to deviate from standard security practices by not
  disclosing the details of the vulnerability with us, be it publicly or privately,
  before creating the cert.org report. The only advance notification we received was a
  generic note about the use of HTTP vs HTTPS, which, as have established, is not
  immediately relevant to addressing the reported vulnerability.
* Closes #1009
* Note: The other vulnerability scenario described towards the end of #1009, which
  doesn't have to do with the ""lack of CA checking"", will be addressed separately.",1,src/pki.c,"{""sha"": ""625566fc97213bfd8769cc96e0571def9a73ceff"", ""filename"": ""res/localization/rufus.loc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/pbatard/rufus/blob/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/res/localization/rufus.loc"", ""raw_url"": ""https://github.com/pbatard/rufus/raw/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/res/localization/rufus.loc"", ""contents_url"": ""https://api.github.com/repos/pbatard/rufus/contents/res/localization/rufus.loc?ref=c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb"", ""patch"": ""@@ -487,6 +487,9 @@ t MSG_237 \""Bad Blocks: Testing with pattern 0x%02X\""\n # eg. \""Partitioning (MBR)...\""\n t MSG_238 \""Partitioning (%s)...\""\n t MSG_239 \""Deleting partitions...\""\n+t MSG_240 \""The signature for the downloaded update can not be validated. This could mean that your \""\n+\t\""system is improperly configured for signature validation or indicate a malicious download.\\n\\n\""\n+\t\""The download will be deleted. Please check the log for more details.\""\n t MSG_241 \""Downloading: %0.1f%%\""\n t MSG_242 \""Failed to download file.\""\n t MSG_243 \""Checking for Rufus updates...\""""}<_**next**_>{""sha"": ""00d01418916e6adb84abc4894c8e299b67dc9f67"", ""filename"": ""src/pki.c"", ""status"": ""modified"", ""additions"": 27, ""deletions"": 2, ""changes"": 29, ""blob_url"": ""https://github.com/pbatard/rufus/blob/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/src/pki.c"", ""raw_url"": ""https://github.com/pbatard/rufus/raw/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/src/pki.c"", ""contents_url"": ""https://api.github.com/repos/pbatard/rufus/contents/src/pki.c?ref=c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb"", ""patch"": ""@@ -53,7 +53,7 @@ const char* WinPKIErrorString(void)\n \tstatic char error_string[64];\n \tDWORD error_code = GetLastError();\n \n-\tif ((error_code >> 16) != 0x8009)\n+\tif (((error_code >> 16) != 0x8009) && ((error_code >> 16) != 0x800B))\n \t\treturn WindowsErrorString();\n \n \tswitch (error_code) {\n@@ -113,6 +113,12 @@ const char* WinPKIErrorString(void)\n \t\treturn \""Cannot complete usage check.\"";\n \tcase CRYPT_E_NO_TRUSTED_SIGNER:\n \t\treturn \""None of the signers of the cryptographic message or certificate trust list is trusted.\"";\n+\tcase CERT_E_UNTRUSTEDROOT:\n+\t\treturn \""The root certificate is not trusted.\"";\n+\tcase TRUST_E_NOSIGNATURE:\n+\t\treturn \""Not digitally signed.\"";\n+\tcase TRUST_E_EXPLICIT_DISTRUST:\n+\t\treturn \""One of the certificates used was marked as untrusted by the user.\"";\n \tdefault:\n \t\tstatic_sprintf(error_string, \""Unknown PKI error 0x%08lX\"", error_code);\n \t\treturn error_string;\n@@ -268,7 +274,13 @@ LONG ValidateSignature(HWND hDlg, const char* path)\n \t}\n \n \ttrust_data.cbStruct = sizeof(trust_data);\n-\ttrust_data.dwUIChoice = WTD_UI_ALL;\n+\t// NB: WTD_UI_ALL can result in ERROR_SUCCESS even if the signature validation fails,\n+\t// because it still prompts the user to run untrusted software, even after explicitly\n+\t// notifying them that the signature invalid (and of course Microsoft had to make\n+\t// that UI prompt a bit too similar to the other benign prompt you get when running\n+\t// trusted software, which, as per cert.org's assessment, may confuse non-security\n+\t// conscious-users who decide to gloss over these kind of notifications).\n+\ttrust_data.dwUIChoice = WTD_UI_NONE;\n \t// We just downloaded from the Internet, so we should be able to check revocation\n \ttrust_data.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;\n \t// 0x400 = WTD_MOTW  for Windows 8.1 or later\n@@ -278,6 +290,19 @@ LONG ValidateSignature(HWND hDlg, const char* path)\n \n \tr = WinVerifyTrust(NULL, &guid_generic_verify, &trust_data);\n \tsafe_free(trust_file.pcwszFilePath);\n+\tswitch (r) {\n+\tcase ERROR_SUCCESS:\n+\t\tbreak;\n+\tcase TRUST_E_NOSIGNATURE:\n+\t\t// Should already have been reported, but since we have a custom message for it...\n+\t\tuprintf(\""PKI: File does not appear to be signed: %s\"", WinPKIErrorString());\n+\t\tMessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);\n+\t\tbreak;\n+\tdefault:\n+\t\tuprintf(\""PKI: Failed to validate signature: %s\"", WinPKIErrorString());\n+\t\tMessageBoxExU(hDlg, lmprintf(MSG_240), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);\n+\t\tbreak;\n+\t}\n \n \treturn r;\n }""}<_**next**_>{""sha"": ""0d0c2a737770a330bf92cfaf90e79ee5440a834d"", ""filename"": ""src/rufus.rc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/pbatard/rufus/blob/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/src/rufus.rc"", ""raw_url"": ""https://github.com/pbatard/rufus/raw/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/src/rufus.rc"", ""contents_url"": ""https://api.github.com/repos/pbatard/rufus/contents/src/rufus.rc?ref=c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb"", ""patch"": ""@@ -33,7 +33,7 @@ LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL\n IDD_DIALOG DIALOGEX 12, 12, 242, 376\n STYLE DS_SETFONT | DS_MODALFRAME | DS_CENTER | WS_MINIMIZEBOX | WS_POPUP | WS_CAPTION | WS_SYSMENU\n EXSTYLE WS_EX_ACCEPTFILES\n-CAPTION \""Rufus 2.17.1186\""\n+CAPTION \""Rufus 2.17.1187\""\n FONT 8, \""Segoe UI Symbol\"", 400, 0, 0x0\n BEGIN\n     LTEXT           \""Device\"",IDS_DEVICE_TXT,9,6,200,8\n@@ -366,8 +366,8 @@ END\n //\n \n VS_VERSION_INFO VERSIONINFO\n- FILEVERSION 2,17,1186,0\n- PRODUCTVERSION 2,17,1186,0\n+ FILEVERSION 2,17,1187,0\n+ PRODUCTVERSION 2,17,1187,0\n  FILEFLAGSMASK 0x3fL\n #ifdef _DEBUG\n  FILEFLAGS 0x1L\n@@ -384,13 +384,13 @@ BEGIN\n         BEGIN\n             VALUE \""CompanyName\"", \""Akeo Consulting (http://akeo.ie)\""\n             VALUE \""FileDescription\"", \""Rufus\""\n-            VALUE \""FileVersion\"", \""2.17.1186\""\n+            VALUE \""FileVersion\"", \""2.17.1187\""\n             VALUE \""InternalName\"", \""Rufus\""\n             VALUE \""LegalCopyright\"", \""\ufffd 2011-2017 Pete Batard (GPL v3)\""\n             VALUE \""LegalTrademarks\"", \""http://www.gnu.org/copyleft/gpl.html\""\n             VALUE \""OriginalFilename\"", \""rufus.exe\""\n             VALUE \""ProductName\"", \""Rufus\""\n-            VALUE \""ProductVersion\"", \""2.17.1186\""\n+            VALUE \""ProductVersion\"", \""2.17.1187\""\n         END\n     END\n     BLOCK \""VarFileInfo\""""}<_**next**_>{""sha"": ""bdec209f3adda5029f21cfcd8388f144e7bd7a75"", ""filename"": ""src/stdlg.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/pbatard/rufus/blob/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/src/stdlg.c"", ""raw_url"": ""https://github.com/pbatard/rufus/raw/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/src/stdlg.c"", ""contents_url"": ""https://api.github.com/repos/pbatard/rufus/contents/src/stdlg.c?ref=c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb"", ""patch"": ""@@ -1674,8 +1674,12 @@ INT_PTR CALLBACK NewVersionCallback(HWND hDlg, UINT message, WPARAM wParam, LPAR\n \t\t\tcase 2:\t\t// Launch newer version and close this one\n \t\t\t\tSleep(1000);\t// Add a delay on account of antivirus scanners\n \n-\t\t\t\tif (ValidateSignature(hDlg, filepath) != NO_ERROR)\n+\t\t\t\tif (ValidateSignature(hDlg, filepath) != NO_ERROR) {\n+\t\t\t\t\t// Unconditionally delete the download and disable the \""Launch\"" control\n+\t\t\t\t\t_unlinkU(filepath);\n+\t\t\t\t\tEnableWindow(GetDlgItem(hDlg, IDC_DOWNLOAD), FALSE);\n \t\t\t\t\tbreak;\n+\t\t\t\t}\n \n \t\t\t\tmemset(&si, 0, sizeof(si));\n \t\t\t\tmemset(&pi, 0, sizeof(pi));""}","LONG ValidateSignature(HWND hDlg, const char* path)
{
	LONG r;
	WINTRUST_DATA trust_data = { 0 };
	WINTRUST_FILE_INFO trust_file = { 0 };
	GUID guid_generic_verify =	// WINTRUST_ACTION_GENERIC_VERIFY_V2
		{ 0xaac56b, 0xcd44, 0x11d0,{ 0x8c, 0xc2, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } };
	char *signature_name;
	size_t i, len;

	signature_name = GetSignatureName(path);
	if (signature_name == NULL) {
		uprintf(""PKI: Could not get signature name"");
		MessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);
		return TRUST_E_NOSIGNATURE;
	}
	for (i = 0; i < ARRAYSIZE(cert_name); i++) {
		len = strlen(cert_name[i]);
		if (strncmp(signature_name, cert_name[i], len) == 0) {
			if ((len >= strlen(signature_name)) || isspace(signature_name[len]))
				break;
		}
	}
	if (i >= ARRAYSIZE(cert_name)) {
		uprintf(""PKI: Signature '%s' is unexpected..."", signature_name);
		if (MessageBoxExU(hDlg, lmprintf(MSG_285, signature_name), lmprintf(MSG_283),
			MB_YESNO | MB_ICONWARNING | MB_IS_RTL, selected_langid) != IDYES)
			return TRUST_E_EXPLICIT_DISTRUST;
	}

	trust_file.cbStruct = sizeof(trust_file);
	trust_file.pcwszFilePath = utf8_to_wchar(path);
	if (trust_file.pcwszFilePath == NULL) {
		uprintf(""PKI: Unable to convert '%s' to UTF16"", path);
		return ERROR_SEVERITY_ERROR | FAC(FACILITY_CERT) | ERROR_NOT_ENOUGH_MEMORY;
 	}
 
 	trust_data.cbStruct = sizeof(trust_data);
	// NB: WTD_UI_ALL can result in ERROR_SUCCESS even if the signature validation fails,
	// because it still prompts the user to run untrusted software, even after explicitly
	// notifying them that the signature invalid (and of course Microsoft had to make
	// that UI prompt a bit too similar to the other benign prompt you get when running
	// trusted software, which, as per cert.org's assessment, may confuse non-security
	// conscious-users who decide to gloss over these kind of notifications).
	trust_data.dwUIChoice = WTD_UI_NONE;
 	trust_data.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;
	trust_data.dwProvFlags = WTD_REVOCATION_CHECK_CHAIN | 0x400;
	trust_data.dwUnionChoice = WTD_CHOICE_FILE;
	trust_data.pFile = &trust_file;
 
 	r = WinVerifyTrust(NULL, &guid_generic_verify, &trust_data);
 	safe_free(trust_file.pcwszFilePath);
	switch (r) {
	case ERROR_SUCCESS:
		break;
	case TRUST_E_NOSIGNATURE:
		// Should already have been reported, but since we have a custom message for it...
		uprintf(""PKI: File does not appear to be signed: %s"", WinPKIErrorString());
		MessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);
		break;
	default:
		uprintf(""PKI: Failed to validate signature: %s"", WinPKIErrorString());
		MessageBoxExU(hDlg, lmprintf(MSG_240), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);
		break;
	}
 
 	return r;
 }
","LONG ValidateSignature(HWND hDlg, const char* path)
{
	LONG r;
	WINTRUST_DATA trust_data = { 0 };
	WINTRUST_FILE_INFO trust_file = { 0 };
	GUID guid_generic_verify =	// WINTRUST_ACTION_GENERIC_VERIFY_V2
		{ 0xaac56b, 0xcd44, 0x11d0,{ 0x8c, 0xc2, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } };
	char *signature_name;
	size_t i, len;

	signature_name = GetSignatureName(path);
	if (signature_name == NULL) {
		uprintf(""PKI: Could not get signature name"");
		MessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);
		return TRUST_E_NOSIGNATURE;
	}
	for (i = 0; i < ARRAYSIZE(cert_name); i++) {
		len = strlen(cert_name[i]);
		if (strncmp(signature_name, cert_name[i], len) == 0) {
			if ((len >= strlen(signature_name)) || isspace(signature_name[len]))
				break;
		}
	}
	if (i >= ARRAYSIZE(cert_name)) {
		uprintf(""PKI: Signature '%s' is unexpected..."", signature_name);
		if (MessageBoxExU(hDlg, lmprintf(MSG_285, signature_name), lmprintf(MSG_283),
			MB_YESNO | MB_ICONWARNING | MB_IS_RTL, selected_langid) != IDYES)
			return TRUST_E_EXPLICIT_DISTRUST;
	}

	trust_file.cbStruct = sizeof(trust_file);
	trust_file.pcwszFilePath = utf8_to_wchar(path);
	if (trust_file.pcwszFilePath == NULL) {
		uprintf(""PKI: Unable to convert '%s' to UTF16"", path);
		return ERROR_SEVERITY_ERROR | FAC(FACILITY_CERT) | ERROR_NOT_ENOUGH_MEMORY;
 	}
 
 	trust_data.cbStruct = sizeof(trust_data);
	trust_data.dwUIChoice = WTD_UI_ALL;
 	trust_data.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;
	trust_data.dwProvFlags = WTD_REVOCATION_CHECK_CHAIN | 0x400;
	trust_data.dwUnionChoice = WTD_CHOICE_FILE;
	trust_data.pFile = &trust_file;
 
 	r = WinVerifyTrust(NULL, &guid_generic_verify, &trust_data);
 	safe_free(trust_file.pcwszFilePath);
 
 	return r;
 }
",C,"	// NB: WTD_UI_ALL can result in ERROR_SUCCESS even if the signature validation fails,
	// because it still prompts the user to run untrusted software, even after explicitly
	// notifying them that the signature invalid (and of course Microsoft had to make
	// that UI prompt a bit too similar to the other benign prompt you get when running
	// trusted software, which, as per cert.org's assessment, may confuse non-security
	// conscious-users who decide to gloss over these kind of notifications).
	trust_data.dwUIChoice = WTD_UI_NONE;
	switch (r) {
	case ERROR_SUCCESS:
		break;
	case TRUST_E_NOSIGNATURE:
		// Should already have been reported, but since we have a custom message for it...
		uprintf(""PKI: File does not appear to be signed: %s"", WinPKIErrorString());
		MessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);
		break;
	default:
		uprintf(""PKI: Failed to validate signature: %s"", WinPKIErrorString());
		MessageBoxExU(hDlg, lmprintf(MSG_240), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);
		break;
	}
","	trust_data.dwUIChoice = WTD_UI_ALL;
",,"@@ -53,7 +53,7 @@ const char* WinPKIErrorString(void)
 	static char error_string[64];
 	DWORD error_code = GetLastError();
 
-	if ((error_code >> 16) != 0x8009)
+	if (((error_code >> 16) != 0x8009) && ((error_code >> 16) != 0x800B))
 		return WindowsErrorString();
 
 	switch (error_code) {
@@ -113,6 +113,12 @@ const char* WinPKIErrorString(void)
 		return ""Cannot complete usage check."";
 	case CRYPT_E_NO_TRUSTED_SIGNER:
 		return ""None of the signers of the cryptographic message or certificate trust list is trusted."";
+	case CERT_E_UNTRUSTEDROOT:
+		return ""The root certificate is not trusted."";
+	case TRUST_E_NOSIGNATURE:
+		return ""Not digitally signed."";
+	case TRUST_E_EXPLICIT_DISTRUST:
+		return ""One of the certificates used was marked as untrusted by the user."";
 	default:
 		static_sprintf(error_string, ""Unknown PKI error 0x%08lX"", error_code);
 		return error_string;
@@ -268,7 +274,13 @@ LONG ValidateSignature(HWND hDlg, const char* path)
 	}
 
 	trust_data.cbStruct = sizeof(trust_data);
-	trust_data.dwUIChoice = WTD_UI_ALL;
+	// NB: WTD_UI_ALL can result in ERROR_SUCCESS even if the signature validation fails,
+	// because it still prompts the user to run untrusted software, even after explicitly
+	// notifying them that the signature invalid (and of course Microsoft had to make
+	// that UI prompt a bit too similar to the other benign prompt you get when running
+	// trusted software, which, as per cert.org's assessment, may confuse non-security
+	// conscious-users who decide to gloss over these kind of notifications).
+	trust_data.dwUIChoice = WTD_UI_NONE;
 	// We just downloaded from the Internet, so we should be able to check revocation
 	trust_data.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;
 	// 0x400 = WTD_MOTW  for Windows 8.1 or later
@@ -278,6 +290,19 @@ LONG ValidateSignature(HWND hDlg, const char* path)
 
 	r = WinVerifyTrust(NULL, &guid_generic_verify, &trust_data);
 	safe_free(trust_file.pcwszFilePath);
+	switch (r) {
+	case ERROR_SUCCESS:
+		break;
+	case TRUST_E_NOSIGNATURE:
+		// Should already have been reported, but since we have a custom message for it...
+		uprintf(""PKI: File does not appear to be signed: %s"", WinPKIErrorString());
+		MessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);
+		break;
+	default:
+		uprintf(""PKI: Failed to validate signature: %s"", WinPKIErrorString());
+		MessageBoxExU(hDlg, lmprintf(MSG_240), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);
+		break;
+	}
 
 	return r;
 }",rufus,c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb,fe3004d17f6085b4f8e03acaa3e6f0b643c06cb1,1,"LONG ValidateSignature(HWND hDlg, const char* path)
{
	LONG r;
	WINTRUST_DATA trust_data = { 0 };
	WINTRUST_FILE_INFO trust_file = { 0 };
	GUID guid_generic_verify =	// WINTRUST_ACTION_GENERIC_VERIFY_V2
		{ 0xaac56b, 0xcd44, 0x11d0,{ 0x8c, 0xc2, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } };
	char *signature_name;
	size_t i, len;

	// Check the signature name. Make it specific enough (i.e. don't simply check for ""Akeo"")
	// so that, besides hacking our server, it'll place an extra hurdle on any malicious entity
	// into also fooling a C.A. to issue a certificate that passes our test.
	signature_name = GetSignatureName(path);
	if (signature_name == NULL) {
		uprintf(""PKI: Could not get signature name"");
		MessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);
		return TRUST_E_NOSIGNATURE;
	}
	for (i = 0; i < ARRAYSIZE(cert_name); i++) {
		len = strlen(cert_name[i]);
		if (strncmp(signature_name, cert_name[i], len) == 0) {
			// Test for whitespace after the part we match, for added safety
			if ((len >= strlen(signature_name)) || isspace(signature_name[len]))
				break;
		}
	}
	if (i >= ARRAYSIZE(cert_name)) {
		uprintf(""PKI: Signature '%s' is unexpected..."", signature_name);
		if (MessageBoxExU(hDlg, lmprintf(MSG_285, signature_name), lmprintf(MSG_283),
			MB_YESNO | MB_ICONWARNING | MB_IS_RTL, selected_langid) != IDYES)
			return TRUST_E_EXPLICIT_DISTRUST;
	}

	trust_file.cbStruct = sizeof(trust_file);
	trust_file.pcwszFilePath = utf8_to_wchar(path);
	if (trust_file.pcwszFilePath == NULL) {
		uprintf(""PKI: Unable to convert '%s' to UTF16"", path);
		return ERROR_SEVERITY_ERROR | FAC(FACILITY_CERT) | ERROR_NOT_ENOUGH_MEMORY;
 	}
 
 	trust_data.cbStruct = sizeof(trust_data);
//flaw_line_below:
	trust_data.dwUIChoice = WTD_UI_ALL;
//fix_flaw_line_below:
//	// NB: WTD_UI_ALL can result in ERROR_SUCCESS even if the signature validation fails,
//fix_flaw_line_below:
//	// because it still prompts the user to run untrusted software, even after explicitly
//fix_flaw_line_below:
//	// notifying them that the signature invalid (and of course Microsoft had to make
//fix_flaw_line_below:
//	// that UI prompt a bit too similar to the other benign prompt you get when running
//fix_flaw_line_below:
//	// trusted software, which, as per cert.org's assessment, may confuse non-security
//fix_flaw_line_below:
//	// conscious-users who decide to gloss over these kind of notifications).
//fix_flaw_line_below:
//	trust_data.dwUIChoice = WTD_UI_NONE;
 	// We just downloaded from the Internet, so we should be able to check revocation
 	trust_data.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;
 	// 0x400 = WTD_MOTW  for Windows 8.1 or later
	trust_data.dwProvFlags = WTD_REVOCATION_CHECK_CHAIN | 0x400;
	trust_data.dwUnionChoice = WTD_CHOICE_FILE;
	trust_data.pFile = &trust_file;
 
 	r = WinVerifyTrust(NULL, &guid_generic_verify, &trust_data);
 	safe_free(trust_file.pcwszFilePath);
//fix_flaw_line_below:
//	switch (r) {
//fix_flaw_line_below:
//	case ERROR_SUCCESS:
//fix_flaw_line_below:
//		break;
//fix_flaw_line_below:
//	case TRUST_E_NOSIGNATURE:
//fix_flaw_line_below:
//		// Should already have been reported, but since we have a custom message for it...
//fix_flaw_line_below:
//		uprintf(""PKI: File does not appear to be signed: %s"", WinPKIErrorString());
//fix_flaw_line_below:
//		MessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);
//fix_flaw_line_below:
//		break;
//fix_flaw_line_below:
//	default:
//fix_flaw_line_below:
//		uprintf(""PKI: Failed to validate signature: %s"", WinPKIErrorString());
//fix_flaw_line_below:
//		MessageBoxExU(hDlg, lmprintf(MSG_240), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);
//fix_flaw_line_below:
//		break;
//fix_flaw_line_below:
//	}
 
 	return r;
 }
"
3252,180988,,Remote,Not required,Partial,CVE-2017-13083,https://www.cvedetails.com/cve/CVE-2017-13083/,CWE-494,Medium,Partial,Partial,,2017-10-18,6.8,"Akeo Consulting Rufus prior to version 2.17.1187 does not adequately validate the integrity of updates downloaded over HTTP, allowing an attacker to easily convince a user to execute arbitrary code",2019-10-09,Exec Code ,7,https://github.com/pbatard/rufus/commit/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb,c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb,"[pki] fix https://www.kb.cert.org/vuls/id/403768

* This commit effectively fixes https://www.kb.cert.org/vuls/id/403768 (CVE-2017-13083) as
  it is described per its revision 11, which is the latest revision at the time of this commit,
  by disabling Windows prompts, enacted during signature validation, that allow the user to
  bypass the intended signature verification checks.
* It needs to be pointed out that the vulnerability (""allow(ing) the use of a self-signed
  certificate""), which relies on the end-user actively ignoring a Windows prompt that tells
  them that the update failed the signature validation whilst also advising against running it,
  is being fully addressed, even as the update protocol remains HTTP.
* It also need to be pointed out that the extended delay (48 hours) between the time the
  vulnerability was reported and the moment it is fixed in our codebase has to do with
  the fact that the reporter chose to deviate from standard security practices by not
  disclosing the details of the vulnerability with us, be it publicly or privately,
  before creating the cert.org report. The only advance notification we received was a
  generic note about the use of HTTP vs HTTPS, which, as have established, is not
  immediately relevant to addressing the reported vulnerability.
* Closes #1009
* Note: The other vulnerability scenario described towards the end of #1009, which
  doesn't have to do with the ""lack of CA checking"", will be addressed separately.",1,src/pki.c,"{""sha"": ""625566fc97213bfd8769cc96e0571def9a73ceff"", ""filename"": ""res/localization/rufus.loc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/pbatard/rufus/blob/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/res/localization/rufus.loc"", ""raw_url"": ""https://github.com/pbatard/rufus/raw/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/res/localization/rufus.loc"", ""contents_url"": ""https://api.github.com/repos/pbatard/rufus/contents/res/localization/rufus.loc?ref=c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb"", ""patch"": ""@@ -487,6 +487,9 @@ t MSG_237 \""Bad Blocks: Testing with pattern 0x%02X\""\n # eg. \""Partitioning (MBR)...\""\n t MSG_238 \""Partitioning (%s)...\""\n t MSG_239 \""Deleting partitions...\""\n+t MSG_240 \""The signature for the downloaded update can not be validated. This could mean that your \""\n+\t\""system is improperly configured for signature validation or indicate a malicious download.\\n\\n\""\n+\t\""The download will be deleted. Please check the log for more details.\""\n t MSG_241 \""Downloading: %0.1f%%\""\n t MSG_242 \""Failed to download file.\""\n t MSG_243 \""Checking for Rufus updates...\""""}<_**next**_>{""sha"": ""00d01418916e6adb84abc4894c8e299b67dc9f67"", ""filename"": ""src/pki.c"", ""status"": ""modified"", ""additions"": 27, ""deletions"": 2, ""changes"": 29, ""blob_url"": ""https://github.com/pbatard/rufus/blob/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/src/pki.c"", ""raw_url"": ""https://github.com/pbatard/rufus/raw/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/src/pki.c"", ""contents_url"": ""https://api.github.com/repos/pbatard/rufus/contents/src/pki.c?ref=c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb"", ""patch"": ""@@ -53,7 +53,7 @@ const char* WinPKIErrorString(void)\n \tstatic char error_string[64];\n \tDWORD error_code = GetLastError();\n \n-\tif ((error_code >> 16) != 0x8009)\n+\tif (((error_code >> 16) != 0x8009) && ((error_code >> 16) != 0x800B))\n \t\treturn WindowsErrorString();\n \n \tswitch (error_code) {\n@@ -113,6 +113,12 @@ const char* WinPKIErrorString(void)\n \t\treturn \""Cannot complete usage check.\"";\n \tcase CRYPT_E_NO_TRUSTED_SIGNER:\n \t\treturn \""None of the signers of the cryptographic message or certificate trust list is trusted.\"";\n+\tcase CERT_E_UNTRUSTEDROOT:\n+\t\treturn \""The root certificate is not trusted.\"";\n+\tcase TRUST_E_NOSIGNATURE:\n+\t\treturn \""Not digitally signed.\"";\n+\tcase TRUST_E_EXPLICIT_DISTRUST:\n+\t\treturn \""One of the certificates used was marked as untrusted by the user.\"";\n \tdefault:\n \t\tstatic_sprintf(error_string, \""Unknown PKI error 0x%08lX\"", error_code);\n \t\treturn error_string;\n@@ -268,7 +274,13 @@ LONG ValidateSignature(HWND hDlg, const char* path)\n \t}\n \n \ttrust_data.cbStruct = sizeof(trust_data);\n-\ttrust_data.dwUIChoice = WTD_UI_ALL;\n+\t// NB: WTD_UI_ALL can result in ERROR_SUCCESS even if the signature validation fails,\n+\t// because it still prompts the user to run untrusted software, even after explicitly\n+\t// notifying them that the signature invalid (and of course Microsoft had to make\n+\t// that UI prompt a bit too similar to the other benign prompt you get when running\n+\t// trusted software, which, as per cert.org's assessment, may confuse non-security\n+\t// conscious-users who decide to gloss over these kind of notifications).\n+\ttrust_data.dwUIChoice = WTD_UI_NONE;\n \t// We just downloaded from the Internet, so we should be able to check revocation\n \ttrust_data.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;\n \t// 0x400 = WTD_MOTW  for Windows 8.1 or later\n@@ -278,6 +290,19 @@ LONG ValidateSignature(HWND hDlg, const char* path)\n \n \tr = WinVerifyTrust(NULL, &guid_generic_verify, &trust_data);\n \tsafe_free(trust_file.pcwszFilePath);\n+\tswitch (r) {\n+\tcase ERROR_SUCCESS:\n+\t\tbreak;\n+\tcase TRUST_E_NOSIGNATURE:\n+\t\t// Should already have been reported, but since we have a custom message for it...\n+\t\tuprintf(\""PKI: File does not appear to be signed: %s\"", WinPKIErrorString());\n+\t\tMessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);\n+\t\tbreak;\n+\tdefault:\n+\t\tuprintf(\""PKI: Failed to validate signature: %s\"", WinPKIErrorString());\n+\t\tMessageBoxExU(hDlg, lmprintf(MSG_240), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);\n+\t\tbreak;\n+\t}\n \n \treturn r;\n }""}<_**next**_>{""sha"": ""0d0c2a737770a330bf92cfaf90e79ee5440a834d"", ""filename"": ""src/rufus.rc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/pbatard/rufus/blob/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/src/rufus.rc"", ""raw_url"": ""https://github.com/pbatard/rufus/raw/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/src/rufus.rc"", ""contents_url"": ""https://api.github.com/repos/pbatard/rufus/contents/src/rufus.rc?ref=c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb"", ""patch"": ""@@ -33,7 +33,7 @@ LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL\n IDD_DIALOG DIALOGEX 12, 12, 242, 376\n STYLE DS_SETFONT | DS_MODALFRAME | DS_CENTER | WS_MINIMIZEBOX | WS_POPUP | WS_CAPTION | WS_SYSMENU\n EXSTYLE WS_EX_ACCEPTFILES\n-CAPTION \""Rufus 2.17.1186\""\n+CAPTION \""Rufus 2.17.1187\""\n FONT 8, \""Segoe UI Symbol\"", 400, 0, 0x0\n BEGIN\n     LTEXT           \""Device\"",IDS_DEVICE_TXT,9,6,200,8\n@@ -366,8 +366,8 @@ END\n //\n \n VS_VERSION_INFO VERSIONINFO\n- FILEVERSION 2,17,1186,0\n- PRODUCTVERSION 2,17,1186,0\n+ FILEVERSION 2,17,1187,0\n+ PRODUCTVERSION 2,17,1187,0\n  FILEFLAGSMASK 0x3fL\n #ifdef _DEBUG\n  FILEFLAGS 0x1L\n@@ -384,13 +384,13 @@ BEGIN\n         BEGIN\n             VALUE \""CompanyName\"", \""Akeo Consulting (http://akeo.ie)\""\n             VALUE \""FileDescription\"", \""Rufus\""\n-            VALUE \""FileVersion\"", \""2.17.1186\""\n+            VALUE \""FileVersion\"", \""2.17.1187\""\n             VALUE \""InternalName\"", \""Rufus\""\n             VALUE \""LegalCopyright\"", \""\ufffd 2011-2017 Pete Batard (GPL v3)\""\n             VALUE \""LegalTrademarks\"", \""http://www.gnu.org/copyleft/gpl.html\""\n             VALUE \""OriginalFilename\"", \""rufus.exe\""\n             VALUE \""ProductName\"", \""Rufus\""\n-            VALUE \""ProductVersion\"", \""2.17.1186\""\n+            VALUE \""ProductVersion\"", \""2.17.1187\""\n         END\n     END\n     BLOCK \""VarFileInfo\""""}<_**next**_>{""sha"": ""bdec209f3adda5029f21cfcd8388f144e7bd7a75"", ""filename"": ""src/stdlg.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/pbatard/rufus/blob/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/src/stdlg.c"", ""raw_url"": ""https://github.com/pbatard/rufus/raw/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/src/stdlg.c"", ""contents_url"": ""https://api.github.com/repos/pbatard/rufus/contents/src/stdlg.c?ref=c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb"", ""patch"": ""@@ -1674,8 +1674,12 @@ INT_PTR CALLBACK NewVersionCallback(HWND hDlg, UINT message, WPARAM wParam, LPAR\n \t\t\tcase 2:\t\t// Launch newer version and close this one\n \t\t\t\tSleep(1000);\t// Add a delay on account of antivirus scanners\n \n-\t\t\t\tif (ValidateSignature(hDlg, filepath) != NO_ERROR)\n+\t\t\t\tif (ValidateSignature(hDlg, filepath) != NO_ERROR) {\n+\t\t\t\t\t// Unconditionally delete the download and disable the \""Launch\"" control\n+\t\t\t\t\t_unlinkU(filepath);\n+\t\t\t\t\tEnableWindow(GetDlgItem(hDlg, IDC_DOWNLOAD), FALSE);\n \t\t\t\t\tbreak;\n+\t\t\t\t}\n \n \t\t\t\tmemset(&si, 0, sizeof(si));\n \t\t\t\tmemset(&pi, 0, sizeof(pi));""}","const char* WinPKIErrorString(void)
{
 	static char error_string[64];
 	DWORD error_code = GetLastError();
 
	if (((error_code >> 16) != 0x8009) && ((error_code >> 16) != 0x800B))
 		return WindowsErrorString();
 
 	switch (error_code) {
	case NTE_BAD_UID:
		return ""Bad UID."";
	case CRYPT_E_MSG_ERROR:
		return ""An error occurred while performing an operation on a cryptographic message."";
	case CRYPT_E_UNKNOWN_ALGO:
		return ""Unknown cryptographic algorithm."";
	case CRYPT_E_INVALID_MSG_TYPE:
		return ""Invalid cryptographic message type."";
	case CRYPT_E_HASH_VALUE:
		return ""The hash value is not correct"";
	case CRYPT_E_ISSUER_SERIALNUMBER:
		return ""Invalid issuer and/or serial number."";
	case CRYPT_E_BAD_LEN:
		return ""The length specified for the output data was insufficient."";
	case CRYPT_E_BAD_ENCODE:
		return ""An error occurred during encode or decode operation."";
	case CRYPT_E_FILE_ERROR:
		return ""An error occurred while reading or writing to a file."";
	case CRYPT_E_NOT_FOUND:
		return ""Cannot find object or property."";
	case CRYPT_E_EXISTS:
		return ""The object or property already exists."";
	case CRYPT_E_NO_PROVIDER:
		return ""No provider was specified for the store or object."";
	case CRYPT_E_DELETED_PREV:
		return ""The previous certificate or CRL context was deleted."";
	case CRYPT_E_NO_MATCH:
		return ""Cannot find the requested object."";
	case CRYPT_E_UNEXPECTED_MSG_TYPE:
	case CRYPT_E_NO_KEY_PROPERTY:
	case CRYPT_E_NO_DECRYPT_CERT:
		return ""Private key or certificate issue"";
	case CRYPT_E_BAD_MSG:
		return ""Not a cryptographic message."";
	case CRYPT_E_NO_SIGNER:
		return ""The signed cryptographic message does not have a signer for the specified signer index."";
	case CRYPT_E_REVOKED:
		return ""The certificate is revoked."";
	case CRYPT_E_NO_REVOCATION_DLL:
	case CRYPT_E_NO_REVOCATION_CHECK:
	case CRYPT_E_REVOCATION_OFFLINE:
	case CRYPT_E_NOT_IN_REVOCATION_DATABASE:
		return ""Cannot check certificate revocation."";
	case CRYPT_E_INVALID_NUMERIC_STRING:
	case CRYPT_E_INVALID_PRINTABLE_STRING:
	case CRYPT_E_INVALID_IA5_STRING:
	case CRYPT_E_INVALID_X500_STRING:
	case  CRYPT_E_NOT_CHAR_STRING:
		return ""Invalid string."";
	case CRYPT_E_SECURITY_SETTINGS:
		return ""The cryptographic operation failed due to a local security option setting."";
	case CRYPT_E_NO_VERIFY_USAGE_CHECK:
	case CRYPT_E_VERIFY_USAGE_OFFLINE:
 		return ""Cannot complete usage check."";
 	case CRYPT_E_NO_TRUSTED_SIGNER:
 		return ""None of the signers of the cryptographic message or certificate trust list is trusted."";
	case CERT_E_UNTRUSTEDROOT:
		return ""The root certificate is not trusted."";
	case TRUST_E_NOSIGNATURE:
		return ""Not digitally signed."";
	case TRUST_E_EXPLICIT_DISTRUST:
		return ""One of the certificates used was marked as untrusted by the user."";
 	default:
 		static_sprintf(error_string, ""Unknown PKI error 0x%08lX"", error_code);
 		return error_string;
	}
}
","const char* WinPKIErrorString(void)
{
 	static char error_string[64];
 	DWORD error_code = GetLastError();
 
	if ((error_code >> 16) != 0x8009)
 		return WindowsErrorString();
 
 	switch (error_code) {
	case NTE_BAD_UID:
		return ""Bad UID."";
	case CRYPT_E_MSG_ERROR:
		return ""An error occurred while performing an operation on a cryptographic message."";
	case CRYPT_E_UNKNOWN_ALGO:
		return ""Unknown cryptographic algorithm."";
	case CRYPT_E_INVALID_MSG_TYPE:
		return ""Invalid cryptographic message type."";
	case CRYPT_E_HASH_VALUE:
		return ""The hash value is not correct"";
	case CRYPT_E_ISSUER_SERIALNUMBER:
		return ""Invalid issuer and/or serial number."";
	case CRYPT_E_BAD_LEN:
		return ""The length specified for the output data was insufficient."";
	case CRYPT_E_BAD_ENCODE:
		return ""An error occurred during encode or decode operation."";
	case CRYPT_E_FILE_ERROR:
		return ""An error occurred while reading or writing to a file."";
	case CRYPT_E_NOT_FOUND:
		return ""Cannot find object or property."";
	case CRYPT_E_EXISTS:
		return ""The object or property already exists."";
	case CRYPT_E_NO_PROVIDER:
		return ""No provider was specified for the store or object."";
	case CRYPT_E_DELETED_PREV:
		return ""The previous certificate or CRL context was deleted."";
	case CRYPT_E_NO_MATCH:
		return ""Cannot find the requested object."";
	case CRYPT_E_UNEXPECTED_MSG_TYPE:
	case CRYPT_E_NO_KEY_PROPERTY:
	case CRYPT_E_NO_DECRYPT_CERT:
		return ""Private key or certificate issue"";
	case CRYPT_E_BAD_MSG:
		return ""Not a cryptographic message."";
	case CRYPT_E_NO_SIGNER:
		return ""The signed cryptographic message does not have a signer for the specified signer index."";
	case CRYPT_E_REVOKED:
		return ""The certificate is revoked."";
	case CRYPT_E_NO_REVOCATION_DLL:
	case CRYPT_E_NO_REVOCATION_CHECK:
	case CRYPT_E_REVOCATION_OFFLINE:
	case CRYPT_E_NOT_IN_REVOCATION_DATABASE:
		return ""Cannot check certificate revocation."";
	case CRYPT_E_INVALID_NUMERIC_STRING:
	case CRYPT_E_INVALID_PRINTABLE_STRING:
	case CRYPT_E_INVALID_IA5_STRING:
	case CRYPT_E_INVALID_X500_STRING:
	case  CRYPT_E_NOT_CHAR_STRING:
		return ""Invalid string."";
	case CRYPT_E_SECURITY_SETTINGS:
		return ""The cryptographic operation failed due to a local security option setting."";
	case CRYPT_E_NO_VERIFY_USAGE_CHECK:
	case CRYPT_E_VERIFY_USAGE_OFFLINE:
 		return ""Cannot complete usage check."";
 	case CRYPT_E_NO_TRUSTED_SIGNER:
 		return ""None of the signers of the cryptographic message or certificate trust list is trusted."";
 	default:
 		static_sprintf(error_string, ""Unknown PKI error 0x%08lX"", error_code);
 		return error_string;
	}
}
",C,"	if (((error_code >> 16) != 0x8009) && ((error_code >> 16) != 0x800B))
	case CERT_E_UNTRUSTEDROOT:
		return ""The root certificate is not trusted."";
	case TRUST_E_NOSIGNATURE:
		return ""Not digitally signed."";
	case TRUST_E_EXPLICIT_DISTRUST:
		return ""One of the certificates used was marked as untrusted by the user."";
","	if ((error_code >> 16) != 0x8009)
",,"@@ -53,7 +53,7 @@ const char* WinPKIErrorString(void)
 	static char error_string[64];
 	DWORD error_code = GetLastError();
 
-	if ((error_code >> 16) != 0x8009)
+	if (((error_code >> 16) != 0x8009) && ((error_code >> 16) != 0x800B))
 		return WindowsErrorString();
 
 	switch (error_code) {
@@ -113,6 +113,12 @@ const char* WinPKIErrorString(void)
 		return ""Cannot complete usage check."";
 	case CRYPT_E_NO_TRUSTED_SIGNER:
 		return ""None of the signers of the cryptographic message or certificate trust list is trusted."";
+	case CERT_E_UNTRUSTEDROOT:
+		return ""The root certificate is not trusted."";
+	case TRUST_E_NOSIGNATURE:
+		return ""Not digitally signed."";
+	case TRUST_E_EXPLICIT_DISTRUST:
+		return ""One of the certificates used was marked as untrusted by the user."";
 	default:
 		static_sprintf(error_string, ""Unknown PKI error 0x%08lX"", error_code);
 		return error_string;
@@ -268,7 +274,13 @@ LONG ValidateSignature(HWND hDlg, const char* path)
 	}
 
 	trust_data.cbStruct = sizeof(trust_data);
-	trust_data.dwUIChoice = WTD_UI_ALL;
+	// NB: WTD_UI_ALL can result in ERROR_SUCCESS even if the signature validation fails,
+	// because it still prompts the user to run untrusted software, even after explicitly
+	// notifying them that the signature invalid (and of course Microsoft had to make
+	// that UI prompt a bit too similar to the other benign prompt you get when running
+	// trusted software, which, as per cert.org's assessment, may confuse non-security
+	// conscious-users who decide to gloss over these kind of notifications).
+	trust_data.dwUIChoice = WTD_UI_NONE;
 	// We just downloaded from the Internet, so we should be able to check revocation
 	trust_data.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;
 	// 0x400 = WTD_MOTW  for Windows 8.1 or later
@@ -278,6 +290,19 @@ LONG ValidateSignature(HWND hDlg, const char* path)
 
 	r = WinVerifyTrust(NULL, &guid_generic_verify, &trust_data);
 	safe_free(trust_file.pcwszFilePath);
+	switch (r) {
+	case ERROR_SUCCESS:
+		break;
+	case TRUST_E_NOSIGNATURE:
+		// Should already have been reported, but since we have a custom message for it...
+		uprintf(""PKI: File does not appear to be signed: %s"", WinPKIErrorString());
+		MessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);
+		break;
+	default:
+		uprintf(""PKI: Failed to validate signature: %s"", WinPKIErrorString());
+		MessageBoxExU(hDlg, lmprintf(MSG_240), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);
+		break;
+	}
 
 	return r;
 }",rufus,c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb,fe3004d17f6085b4f8e03acaa3e6f0b643c06cb1,1,"const char* WinPKIErrorString(void)
{
 	static char error_string[64];
 	DWORD error_code = GetLastError();
 
//flaw_line_below:
	if ((error_code >> 16) != 0x8009)
//fix_flaw_line_below:
//	if (((error_code >> 16) != 0x8009) && ((error_code >> 16) != 0x800B))
 		return WindowsErrorString();
 
 	switch (error_code) {
	case NTE_BAD_UID:
		return ""Bad UID."";
	case CRYPT_E_MSG_ERROR:
		return ""An error occurred while performing an operation on a cryptographic message."";
	case CRYPT_E_UNKNOWN_ALGO:
		return ""Unknown cryptographic algorithm."";
	case CRYPT_E_INVALID_MSG_TYPE:
		return ""Invalid cryptographic message type."";
	case CRYPT_E_HASH_VALUE:
		return ""The hash value is not correct"";
	case CRYPT_E_ISSUER_SERIALNUMBER:
		return ""Invalid issuer and/or serial number."";
	case CRYPT_E_BAD_LEN:
		return ""The length specified for the output data was insufficient."";
	case CRYPT_E_BAD_ENCODE:
		return ""An error occurred during encode or decode operation."";
	case CRYPT_E_FILE_ERROR:
		return ""An error occurred while reading or writing to a file."";
	case CRYPT_E_NOT_FOUND:
		return ""Cannot find object or property."";
	case CRYPT_E_EXISTS:
		return ""The object or property already exists."";
	case CRYPT_E_NO_PROVIDER:
		return ""No provider was specified for the store or object."";
	case CRYPT_E_DELETED_PREV:
		return ""The previous certificate or CRL context was deleted."";
	case CRYPT_E_NO_MATCH:
		return ""Cannot find the requested object."";
	case CRYPT_E_UNEXPECTED_MSG_TYPE:
	case CRYPT_E_NO_KEY_PROPERTY:
	case CRYPT_E_NO_DECRYPT_CERT:
		return ""Private key or certificate issue"";
	case CRYPT_E_BAD_MSG:
		return ""Not a cryptographic message."";
	case CRYPT_E_NO_SIGNER:
		return ""The signed cryptographic message does not have a signer for the specified signer index."";
	case CRYPT_E_REVOKED:
		return ""The certificate is revoked."";
	case CRYPT_E_NO_REVOCATION_DLL:
	case CRYPT_E_NO_REVOCATION_CHECK:
	case CRYPT_E_REVOCATION_OFFLINE:
	case CRYPT_E_NOT_IN_REVOCATION_DATABASE:
		return ""Cannot check certificate revocation."";
	case CRYPT_E_INVALID_NUMERIC_STRING:
	case CRYPT_E_INVALID_PRINTABLE_STRING:
	case CRYPT_E_INVALID_IA5_STRING:
	case CRYPT_E_INVALID_X500_STRING:
	case  CRYPT_E_NOT_CHAR_STRING:
		return ""Invalid string."";
	case CRYPT_E_SECURITY_SETTINGS:
		return ""The cryptographic operation failed due to a local security option setting."";
	case CRYPT_E_NO_VERIFY_USAGE_CHECK:
	case CRYPT_E_VERIFY_USAGE_OFFLINE:
 		return ""Cannot complete usage check."";
 	case CRYPT_E_NO_TRUSTED_SIGNER:
 		return ""None of the signers of the cryptographic message or certificate trust list is trusted."";
//fix_flaw_line_below:
//	case CERT_E_UNTRUSTEDROOT:
//fix_flaw_line_below:
//		return ""The root certificate is not trusted."";
//fix_flaw_line_below:
//	case TRUST_E_NOSIGNATURE:
//fix_flaw_line_below:
//		return ""Not digitally signed."";
//fix_flaw_line_below:
//	case TRUST_E_EXPLICIT_DISTRUST:
//fix_flaw_line_below:
//		return ""One of the certificates used was marked as untrusted by the user."";
 	default:
 		static_sprintf(error_string, ""Unknown PKI error 0x%08lX"", error_code);
 		return error_string;
	}
}
"
3253,180989,,Remote,Not required,Partial,CVE-2017-13083,https://www.cvedetails.com/cve/CVE-2017-13083/,CWE-494,Medium,Partial,Partial,,2017-10-18,6.8,"Akeo Consulting Rufus prior to version 2.17.1187 does not adequately validate the integrity of updates downloaded over HTTP, allowing an attacker to easily convince a user to execute arbitrary code",2019-10-09,Exec Code ,5,https://github.com/pbatard/rufus/commit/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb,c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb,"[pki] fix https://www.kb.cert.org/vuls/id/403768

* This commit effectively fixes https://www.kb.cert.org/vuls/id/403768 (CVE-2017-13083) as
  it is described per its revision 11, which is the latest revision at the time of this commit,
  by disabling Windows prompts, enacted during signature validation, that allow the user to
  bypass the intended signature verification checks.
* It needs to be pointed out that the vulnerability (""allow(ing) the use of a self-signed
  certificate""), which relies on the end-user actively ignoring a Windows prompt that tells
  them that the update failed the signature validation whilst also advising against running it,
  is being fully addressed, even as the update protocol remains HTTP.
* It also need to be pointed out that the extended delay (48 hours) between the time the
  vulnerability was reported and the moment it is fixed in our codebase has to do with
  the fact that the reporter chose to deviate from standard security practices by not
  disclosing the details of the vulnerability with us, be it publicly or privately,
  before creating the cert.org report. The only advance notification we received was a
  generic note about the use of HTTP vs HTTPS, which, as have established, is not
  immediately relevant to addressing the reported vulnerability.
* Closes #1009
* Note: The other vulnerability scenario described towards the end of #1009, which
  doesn't have to do with the ""lack of CA checking"", will be addressed separately.",1,src/stdlg.c,"{""sha"": ""625566fc97213bfd8769cc96e0571def9a73ceff"", ""filename"": ""res/localization/rufus.loc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/pbatard/rufus/blob/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/res/localization/rufus.loc"", ""raw_url"": ""https://github.com/pbatard/rufus/raw/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/res/localization/rufus.loc"", ""contents_url"": ""https://api.github.com/repos/pbatard/rufus/contents/res/localization/rufus.loc?ref=c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb"", ""patch"": ""@@ -487,6 +487,9 @@ t MSG_237 \""Bad Blocks: Testing with pattern 0x%02X\""\n # eg. \""Partitioning (MBR)...\""\n t MSG_238 \""Partitioning (%s)...\""\n t MSG_239 \""Deleting partitions...\""\n+t MSG_240 \""The signature for the downloaded update can not be validated. This could mean that your \""\n+\t\""system is improperly configured for signature validation or indicate a malicious download.\\n\\n\""\n+\t\""The download will be deleted. Please check the log for more details.\""\n t MSG_241 \""Downloading: %0.1f%%\""\n t MSG_242 \""Failed to download file.\""\n t MSG_243 \""Checking for Rufus updates...\""""}<_**next**_>{""sha"": ""00d01418916e6adb84abc4894c8e299b67dc9f67"", ""filename"": ""src/pki.c"", ""status"": ""modified"", ""additions"": 27, ""deletions"": 2, ""changes"": 29, ""blob_url"": ""https://github.com/pbatard/rufus/blob/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/src/pki.c"", ""raw_url"": ""https://github.com/pbatard/rufus/raw/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/src/pki.c"", ""contents_url"": ""https://api.github.com/repos/pbatard/rufus/contents/src/pki.c?ref=c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb"", ""patch"": ""@@ -53,7 +53,7 @@ const char* WinPKIErrorString(void)\n \tstatic char error_string[64];\n \tDWORD error_code = GetLastError();\n \n-\tif ((error_code >> 16) != 0x8009)\n+\tif (((error_code >> 16) != 0x8009) && ((error_code >> 16) != 0x800B))\n \t\treturn WindowsErrorString();\n \n \tswitch (error_code) {\n@@ -113,6 +113,12 @@ const char* WinPKIErrorString(void)\n \t\treturn \""Cannot complete usage check.\"";\n \tcase CRYPT_E_NO_TRUSTED_SIGNER:\n \t\treturn \""None of the signers of the cryptographic message or certificate trust list is trusted.\"";\n+\tcase CERT_E_UNTRUSTEDROOT:\n+\t\treturn \""The root certificate is not trusted.\"";\n+\tcase TRUST_E_NOSIGNATURE:\n+\t\treturn \""Not digitally signed.\"";\n+\tcase TRUST_E_EXPLICIT_DISTRUST:\n+\t\treturn \""One of the certificates used was marked as untrusted by the user.\"";\n \tdefault:\n \t\tstatic_sprintf(error_string, \""Unknown PKI error 0x%08lX\"", error_code);\n \t\treturn error_string;\n@@ -268,7 +274,13 @@ LONG ValidateSignature(HWND hDlg, const char* path)\n \t}\n \n \ttrust_data.cbStruct = sizeof(trust_data);\n-\ttrust_data.dwUIChoice = WTD_UI_ALL;\n+\t// NB: WTD_UI_ALL can result in ERROR_SUCCESS even if the signature validation fails,\n+\t// because it still prompts the user to run untrusted software, even after explicitly\n+\t// notifying them that the signature invalid (and of course Microsoft had to make\n+\t// that UI prompt a bit too similar to the other benign prompt you get when running\n+\t// trusted software, which, as per cert.org's assessment, may confuse non-security\n+\t// conscious-users who decide to gloss over these kind of notifications).\n+\ttrust_data.dwUIChoice = WTD_UI_NONE;\n \t// We just downloaded from the Internet, so we should be able to check revocation\n \ttrust_data.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;\n \t// 0x400 = WTD_MOTW  for Windows 8.1 or later\n@@ -278,6 +290,19 @@ LONG ValidateSignature(HWND hDlg, const char* path)\n \n \tr = WinVerifyTrust(NULL, &guid_generic_verify, &trust_data);\n \tsafe_free(trust_file.pcwszFilePath);\n+\tswitch (r) {\n+\tcase ERROR_SUCCESS:\n+\t\tbreak;\n+\tcase TRUST_E_NOSIGNATURE:\n+\t\t// Should already have been reported, but since we have a custom message for it...\n+\t\tuprintf(\""PKI: File does not appear to be signed: %s\"", WinPKIErrorString());\n+\t\tMessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);\n+\t\tbreak;\n+\tdefault:\n+\t\tuprintf(\""PKI: Failed to validate signature: %s\"", WinPKIErrorString());\n+\t\tMessageBoxExU(hDlg, lmprintf(MSG_240), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);\n+\t\tbreak;\n+\t}\n \n \treturn r;\n }""}<_**next**_>{""sha"": ""0d0c2a737770a330bf92cfaf90e79ee5440a834d"", ""filename"": ""src/rufus.rc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/pbatard/rufus/blob/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/src/rufus.rc"", ""raw_url"": ""https://github.com/pbatard/rufus/raw/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/src/rufus.rc"", ""contents_url"": ""https://api.github.com/repos/pbatard/rufus/contents/src/rufus.rc?ref=c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb"", ""patch"": ""@@ -33,7 +33,7 @@ LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL\n IDD_DIALOG DIALOGEX 12, 12, 242, 376\n STYLE DS_SETFONT | DS_MODALFRAME | DS_CENTER | WS_MINIMIZEBOX | WS_POPUP | WS_CAPTION | WS_SYSMENU\n EXSTYLE WS_EX_ACCEPTFILES\n-CAPTION \""Rufus 2.17.1186\""\n+CAPTION \""Rufus 2.17.1187\""\n FONT 8, \""Segoe UI Symbol\"", 400, 0, 0x0\n BEGIN\n     LTEXT           \""Device\"",IDS_DEVICE_TXT,9,6,200,8\n@@ -366,8 +366,8 @@ END\n //\n \n VS_VERSION_INFO VERSIONINFO\n- FILEVERSION 2,17,1186,0\n- PRODUCTVERSION 2,17,1186,0\n+ FILEVERSION 2,17,1187,0\n+ PRODUCTVERSION 2,17,1187,0\n  FILEFLAGSMASK 0x3fL\n #ifdef _DEBUG\n  FILEFLAGS 0x1L\n@@ -384,13 +384,13 @@ BEGIN\n         BEGIN\n             VALUE \""CompanyName\"", \""Akeo Consulting (http://akeo.ie)\""\n             VALUE \""FileDescription\"", \""Rufus\""\n-            VALUE \""FileVersion\"", \""2.17.1186\""\n+            VALUE \""FileVersion\"", \""2.17.1187\""\n             VALUE \""InternalName\"", \""Rufus\""\n             VALUE \""LegalCopyright\"", \""\ufffd 2011-2017 Pete Batard (GPL v3)\""\n             VALUE \""LegalTrademarks\"", \""http://www.gnu.org/copyleft/gpl.html\""\n             VALUE \""OriginalFilename\"", \""rufus.exe\""\n             VALUE \""ProductName\"", \""Rufus\""\n-            VALUE \""ProductVersion\"", \""2.17.1186\""\n+            VALUE \""ProductVersion\"", \""2.17.1187\""\n         END\n     END\n     BLOCK \""VarFileInfo\""""}<_**next**_>{""sha"": ""bdec209f3adda5029f21cfcd8388f144e7bd7a75"", ""filename"": ""src/stdlg.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/pbatard/rufus/blob/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/src/stdlg.c"", ""raw_url"": ""https://github.com/pbatard/rufus/raw/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb/src/stdlg.c"", ""contents_url"": ""https://api.github.com/repos/pbatard/rufus/contents/src/stdlg.c?ref=c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb"", ""patch"": ""@@ -1674,8 +1674,12 @@ INT_PTR CALLBACK NewVersionCallback(HWND hDlg, UINT message, WPARAM wParam, LPAR\n \t\t\tcase 2:\t\t// Launch newer version and close this one\n \t\t\t\tSleep(1000);\t// Add a delay on account of antivirus scanners\n \n-\t\t\t\tif (ValidateSignature(hDlg, filepath) != NO_ERROR)\n+\t\t\t\tif (ValidateSignature(hDlg, filepath) != NO_ERROR) {\n+\t\t\t\t\t// Unconditionally delete the download and disable the \""Launch\"" control\n+\t\t\t\t\t_unlinkU(filepath);\n+\t\t\t\t\tEnableWindow(GetDlgItem(hDlg, IDC_DOWNLOAD), FALSE);\n \t\t\t\t\tbreak;\n+\t\t\t\t}\n \n \t\t\t\tmemset(&si, 0, sizeof(si));\n \t\t\t\tmemset(&pi, 0, sizeof(pi));""}","INT_PTR CALLBACK NewVersionCallback(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	char cmdline[] = APPLICATION_NAME "" -w 150"";
	static char* filepath = NULL;
	static int download_status = 0;
	LONG i;
	HWND hNotes;
	STARTUPINFOA si;
	PROCESS_INFORMATION pi;
	HFONT hyperlink_font = NULL;
	EXT_DECL(dl_ext, NULL, __VA_GROUP__(""*.exe""), __VA_GROUP__(lmprintf(MSG_037)));

	switch (message) {
	case WM_INITDIALOG:
		apply_localization(IDD_NEW_VERSION, hDlg);
		download_status = 0;
		SetTitleBarIcon(hDlg);
		CenterDialog(hDlg);
		update_original_proc = (WNDPROC)SetWindowLongPtr(hDlg, GWLP_WNDPROC, (LONG_PTR)update_subclass_callback);
		hNotes = GetDlgItem(hDlg, IDC_RELEASE_NOTES);
		SendMessage(hNotes, EM_AUTOURLDETECT, 1, 0);
		SendMessageA(hNotes, EM_SETTEXTEX, (WPARAM)&friggin_microsoft_unicode_amateurs, (LPARAM)update.release_notes);
		SendMessage(hNotes, EM_SETSEL, -1, -1);
		SendMessage(hNotes, EM_SETEVENTMASK, 0, ENM_LINK);
		SetWindowTextU(GetDlgItem(hDlg, IDC_YOUR_VERSION), lmprintf(MSG_018,
			rufus_version[0], rufus_version[1], rufus_version[2]));
		SetWindowTextU(GetDlgItem(hDlg, IDC_LATEST_VERSION), lmprintf(MSG_019,
			update.version[0], update.version[1], update.version[2]));
		SetWindowTextU(GetDlgItem(hDlg, IDC_DOWNLOAD_URL), update.download_url);
		SendMessage(GetDlgItem(hDlg, IDC_PROGRESS), PBM_SETRANGE, 0, (MAX_PROGRESS<<16) & 0xFFFF0000);
		if (update.download_url == NULL)
			EnableWindow(GetDlgItem(hDlg, IDC_DOWNLOAD), FALSE);
		break;
	case WM_CTLCOLORSTATIC:
		if ((HWND)lParam != GetDlgItem(hDlg, IDC_WEBSITE))
			return FALSE;
		SetBkMode((HDC)wParam, TRANSPARENT);
		CreateStaticFont((HDC)wParam, &hyperlink_font);
		SelectObject((HDC)wParam, hyperlink_font);
		SetTextColor((HDC)wParam, RGB(0,0,125));	// DARK_BLUE
		return (INT_PTR)CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDCLOSE:
		case IDCANCEL:
			if (download_status != 1) {
				reset_localization(IDD_NEW_VERSION);
				safe_free(filepath);
				EndDialog(hDlg, LOWORD(wParam));
			}
			return (INT_PTR)TRUE;
		case IDC_WEBSITE:
			ShellExecuteA(hDlg, ""open"", RUFUS_URL, NULL, NULL, SW_SHOWNORMAL);
			break;
		case IDC_DOWNLOAD:	// Also doubles as abort and launch function
			switch(download_status) {
			case 1:		// Abort
				FormatStatus = ERROR_SEVERITY_ERROR|FAC(FACILITY_STORAGE)|ERROR_CANCELLED;
				download_status = 0;
				break;
 			case 2:		// Launch newer version and close this one
 				Sleep(1000);	// Add a delay on account of antivirus scanners
 
				if (ValidateSignature(hDlg, filepath) != NO_ERROR) {
					// Unconditionally delete the download and disable the ""Launch"" control
					_unlinkU(filepath);
					EnableWindow(GetDlgItem(hDlg, IDC_DOWNLOAD), FALSE);
 					break;
				}
 
 				memset(&si, 0, sizeof(si));
 				memset(&pi, 0, sizeof(pi));
				si.cb = sizeof(si);
				if (!CreateProcessU(filepath, cmdline, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
					PrintInfo(0, MSG_214);
					uprintf(""Failed to launch new application: %s\n"", WindowsErrorString());
				} else {
					PrintInfo(0, MSG_213);
					PostMessage(hDlg, WM_COMMAND, (WPARAM)IDCLOSE, 0);
					PostMessage(hMainDialog, WM_CLOSE, 0, 0);
				}
				break;
			default:	// Download
				if (update.download_url == NULL) {
					uprintf(""Could not get download URL\n"");
					break;
				}
				for (i=(int)strlen(update.download_url); (i>0)&&(update.download_url[i]!='/'); i--);
				dl_ext.filename = &update.download_url[i+1];
				filepath = FileDialog(TRUE, app_dir, &dl_ext, OFN_NOCHANGEDIR);
				if (filepath == NULL) {
					uprintf(""Could not get save path\n"");
					break;
				}
				SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDC_DOWNLOAD), TRUE);
				DownloadFileThreaded(update.download_url, filepath, hDlg);
				break;
			}
			return (INT_PTR)TRUE;
		}
		break;
	case UM_PROGRESS_INIT:
		EnableWindow(GetDlgItem(hDlg, IDCANCEL), FALSE);
		SetWindowTextU(GetDlgItem(hDlg, IDC_DOWNLOAD), lmprintf(MSG_038));
		FormatStatus = 0;
		download_status = 1;
		return (INT_PTR)TRUE;
	case UM_PROGRESS_EXIT:
		EnableWindow(GetDlgItem(hDlg, IDCANCEL), TRUE);
		if (wParam) {
			SetWindowTextU(GetDlgItem(hDlg, IDC_DOWNLOAD), lmprintf(MSG_039));
			download_status = 2;
		} else {
			SetWindowTextU(GetDlgItem(hDlg, IDC_DOWNLOAD), lmprintf(MSG_040));
			download_status = 0;
		}
		return (INT_PTR)TRUE;
	}
	return (INT_PTR)FALSE;
}
","INT_PTR CALLBACK NewVersionCallback(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	char cmdline[] = APPLICATION_NAME "" -w 150"";
	static char* filepath = NULL;
	static int download_status = 0;
	LONG i;
	HWND hNotes;
	STARTUPINFOA si;
	PROCESS_INFORMATION pi;
	HFONT hyperlink_font = NULL;
	EXT_DECL(dl_ext, NULL, __VA_GROUP__(""*.exe""), __VA_GROUP__(lmprintf(MSG_037)));

	switch (message) {
	case WM_INITDIALOG:
		apply_localization(IDD_NEW_VERSION, hDlg);
		download_status = 0;
		SetTitleBarIcon(hDlg);
		CenterDialog(hDlg);
		update_original_proc = (WNDPROC)SetWindowLongPtr(hDlg, GWLP_WNDPROC, (LONG_PTR)update_subclass_callback);
		hNotes = GetDlgItem(hDlg, IDC_RELEASE_NOTES);
		SendMessage(hNotes, EM_AUTOURLDETECT, 1, 0);
		SendMessageA(hNotes, EM_SETTEXTEX, (WPARAM)&friggin_microsoft_unicode_amateurs, (LPARAM)update.release_notes);
		SendMessage(hNotes, EM_SETSEL, -1, -1);
		SendMessage(hNotes, EM_SETEVENTMASK, 0, ENM_LINK);
		SetWindowTextU(GetDlgItem(hDlg, IDC_YOUR_VERSION), lmprintf(MSG_018,
			rufus_version[0], rufus_version[1], rufus_version[2]));
		SetWindowTextU(GetDlgItem(hDlg, IDC_LATEST_VERSION), lmprintf(MSG_019,
			update.version[0], update.version[1], update.version[2]));
		SetWindowTextU(GetDlgItem(hDlg, IDC_DOWNLOAD_URL), update.download_url);
		SendMessage(GetDlgItem(hDlg, IDC_PROGRESS), PBM_SETRANGE, 0, (MAX_PROGRESS<<16) & 0xFFFF0000);
		if (update.download_url == NULL)
			EnableWindow(GetDlgItem(hDlg, IDC_DOWNLOAD), FALSE);
		break;
	case WM_CTLCOLORSTATIC:
		if ((HWND)lParam != GetDlgItem(hDlg, IDC_WEBSITE))
			return FALSE;
		SetBkMode((HDC)wParam, TRANSPARENT);
		CreateStaticFont((HDC)wParam, &hyperlink_font);
		SelectObject((HDC)wParam, hyperlink_font);
		SetTextColor((HDC)wParam, RGB(0,0,125));	// DARK_BLUE
		return (INT_PTR)CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDCLOSE:
		case IDCANCEL:
			if (download_status != 1) {
				reset_localization(IDD_NEW_VERSION);
				safe_free(filepath);
				EndDialog(hDlg, LOWORD(wParam));
			}
			return (INT_PTR)TRUE;
		case IDC_WEBSITE:
			ShellExecuteA(hDlg, ""open"", RUFUS_URL, NULL, NULL, SW_SHOWNORMAL);
			break;
		case IDC_DOWNLOAD:	// Also doubles as abort and launch function
			switch(download_status) {
			case 1:		// Abort
				FormatStatus = ERROR_SEVERITY_ERROR|FAC(FACILITY_STORAGE)|ERROR_CANCELLED;
				download_status = 0;
				break;
 			case 2:		// Launch newer version and close this one
 				Sleep(1000);	// Add a delay on account of antivirus scanners
 
				if (ValidateSignature(hDlg, filepath) != NO_ERROR)
 					break;
 
 				memset(&si, 0, sizeof(si));
 				memset(&pi, 0, sizeof(pi));
				si.cb = sizeof(si);
				if (!CreateProcessU(filepath, cmdline, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
					PrintInfo(0, MSG_214);
					uprintf(""Failed to launch new application: %s\n"", WindowsErrorString());
				} else {
					PrintInfo(0, MSG_213);
					PostMessage(hDlg, WM_COMMAND, (WPARAM)IDCLOSE, 0);
					PostMessage(hMainDialog, WM_CLOSE, 0, 0);
				}
				break;
			default:	// Download
				if (update.download_url == NULL) {
					uprintf(""Could not get download URL\n"");
					break;
				}
				for (i=(int)strlen(update.download_url); (i>0)&&(update.download_url[i]!='/'); i--);
				dl_ext.filename = &update.download_url[i+1];
				filepath = FileDialog(TRUE, app_dir, &dl_ext, OFN_NOCHANGEDIR);
				if (filepath == NULL) {
					uprintf(""Could not get save path\n"");
					break;
				}
				SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDC_DOWNLOAD), TRUE);
				DownloadFileThreaded(update.download_url, filepath, hDlg);
				break;
			}
			return (INT_PTR)TRUE;
		}
		break;
	case UM_PROGRESS_INIT:
		EnableWindow(GetDlgItem(hDlg, IDCANCEL), FALSE);
		SetWindowTextU(GetDlgItem(hDlg, IDC_DOWNLOAD), lmprintf(MSG_038));
		FormatStatus = 0;
		download_status = 1;
		return (INT_PTR)TRUE;
	case UM_PROGRESS_EXIT:
		EnableWindow(GetDlgItem(hDlg, IDCANCEL), TRUE);
		if (wParam) {
			SetWindowTextU(GetDlgItem(hDlg, IDC_DOWNLOAD), lmprintf(MSG_039));
			download_status = 2;
		} else {
			SetWindowTextU(GetDlgItem(hDlg, IDC_DOWNLOAD), lmprintf(MSG_040));
			download_status = 0;
		}
		return (INT_PTR)TRUE;
	}
	return (INT_PTR)FALSE;
}
",C,"				if (ValidateSignature(hDlg, filepath) != NO_ERROR) {
					// Unconditionally delete the download and disable the ""Launch"" control
					_unlinkU(filepath);
					EnableWindow(GetDlgItem(hDlg, IDC_DOWNLOAD), FALSE);
				}
","				if (ValidateSignature(hDlg, filepath) != NO_ERROR)
",,"@@ -1674,8 +1674,12 @@ INT_PTR CALLBACK NewVersionCallback(HWND hDlg, UINT message, WPARAM wParam, LPAR
 			case 2:		// Launch newer version and close this one
 				Sleep(1000);	// Add a delay on account of antivirus scanners
 
-				if (ValidateSignature(hDlg, filepath) != NO_ERROR)
+				if (ValidateSignature(hDlg, filepath) != NO_ERROR) {
+					// Unconditionally delete the download and disable the ""Launch"" control
+					_unlinkU(filepath);
+					EnableWindow(GetDlgItem(hDlg, IDC_DOWNLOAD), FALSE);
 					break;
+				}
 
 				memset(&si, 0, sizeof(si));
 				memset(&pi, 0, sizeof(pi));",rufus,c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb,fe3004d17f6085b4f8e03acaa3e6f0b643c06cb1,1,"INT_PTR CALLBACK NewVersionCallback(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	char cmdline[] = APPLICATION_NAME "" -w 150"";
	static char* filepath = NULL;
	static int download_status = 0;
	LONG i;
	HWND hNotes;
	STARTUPINFOA si;
	PROCESS_INFORMATION pi;
	HFONT hyperlink_font = NULL;
	EXT_DECL(dl_ext, NULL, __VA_GROUP__(""*.exe""), __VA_GROUP__(lmprintf(MSG_037)));

	switch (message) {
	case WM_INITDIALOG:
		apply_localization(IDD_NEW_VERSION, hDlg);
		download_status = 0;
		SetTitleBarIcon(hDlg);
		CenterDialog(hDlg);
		// Subclass the callback so that we can change the cursor
		update_original_proc = (WNDPROC)SetWindowLongPtr(hDlg, GWLP_WNDPROC, (LONG_PTR)update_subclass_callback);
		hNotes = GetDlgItem(hDlg, IDC_RELEASE_NOTES);
		SendMessage(hNotes, EM_AUTOURLDETECT, 1, 0);
		SendMessageA(hNotes, EM_SETTEXTEX, (WPARAM)&friggin_microsoft_unicode_amateurs, (LPARAM)update.release_notes);
		SendMessage(hNotes, EM_SETSEL, -1, -1);
		SendMessage(hNotes, EM_SETEVENTMASK, 0, ENM_LINK);
		SetWindowTextU(GetDlgItem(hDlg, IDC_YOUR_VERSION), lmprintf(MSG_018,
			rufus_version[0], rufus_version[1], rufus_version[2]));
		SetWindowTextU(GetDlgItem(hDlg, IDC_LATEST_VERSION), lmprintf(MSG_019,
			update.version[0], update.version[1], update.version[2]));
		SetWindowTextU(GetDlgItem(hDlg, IDC_DOWNLOAD_URL), update.download_url);
		SendMessage(GetDlgItem(hDlg, IDC_PROGRESS), PBM_SETRANGE, 0, (MAX_PROGRESS<<16) & 0xFFFF0000);
		if (update.download_url == NULL)
			EnableWindow(GetDlgItem(hDlg, IDC_DOWNLOAD), FALSE);
		break;
	case WM_CTLCOLORSTATIC:
		if ((HWND)lParam != GetDlgItem(hDlg, IDC_WEBSITE))
			return FALSE;
		// Change the font for the hyperlink
		SetBkMode((HDC)wParam, TRANSPARENT);
		CreateStaticFont((HDC)wParam, &hyperlink_font);
		SelectObject((HDC)wParam, hyperlink_font);
		SetTextColor((HDC)wParam, RGB(0,0,125));	// DARK_BLUE
		return (INT_PTR)CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDCLOSE:
		case IDCANCEL:
			if (download_status != 1) {
				reset_localization(IDD_NEW_VERSION);
				safe_free(filepath);
				EndDialog(hDlg, LOWORD(wParam));
			}
			return (INT_PTR)TRUE;
		case IDC_WEBSITE:
			ShellExecuteA(hDlg, ""open"", RUFUS_URL, NULL, NULL, SW_SHOWNORMAL);
			break;
		case IDC_DOWNLOAD:	// Also doubles as abort and launch function
			switch(download_status) {
			case 1:		// Abort
				FormatStatus = ERROR_SEVERITY_ERROR|FAC(FACILITY_STORAGE)|ERROR_CANCELLED;
				download_status = 0;
				break;
 			case 2:		// Launch newer version and close this one
 				Sleep(1000);	// Add a delay on account of antivirus scanners
 
//flaw_line_below:
				if (ValidateSignature(hDlg, filepath) != NO_ERROR)
//fix_flaw_line_below:
//				if (ValidateSignature(hDlg, filepath) != NO_ERROR) {
//fix_flaw_line_below:
//					// Unconditionally delete the download and disable the ""Launch"" control
//fix_flaw_line_below:
//					_unlinkU(filepath);
//fix_flaw_line_below:
//					EnableWindow(GetDlgItem(hDlg, IDC_DOWNLOAD), FALSE);
 					break;
//fix_flaw_line_below:
//				}
 
 				memset(&si, 0, sizeof(si));
 				memset(&pi, 0, sizeof(pi));
				si.cb = sizeof(si);
				if (!CreateProcessU(filepath, cmdline, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
					PrintInfo(0, MSG_214);
					uprintf(""Failed to launch new application: %s\n"", WindowsErrorString());
				} else {
					PrintInfo(0, MSG_213);
					PostMessage(hDlg, WM_COMMAND, (WPARAM)IDCLOSE, 0);
					PostMessage(hMainDialog, WM_CLOSE, 0, 0);
				}
				break;
			default:	// Download
				if (update.download_url == NULL) {
					uprintf(""Could not get download URL\n"");
					break;
				}
				for (i=(int)strlen(update.download_url); (i>0)&&(update.download_url[i]!='/'); i--);
				dl_ext.filename = &update.download_url[i+1];
				filepath = FileDialog(TRUE, app_dir, &dl_ext, OFN_NOCHANGEDIR);
				if (filepath == NULL) {
					uprintf(""Could not get save path\n"");
					break;
				}
				// Opening the File Dialog will make us lose tabbing focus - set it back
				SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDC_DOWNLOAD), TRUE);
				DownloadFileThreaded(update.download_url, filepath, hDlg);
				break;
			}
			return (INT_PTR)TRUE;
		}
		break;
	case UM_PROGRESS_INIT:
		EnableWindow(GetDlgItem(hDlg, IDCANCEL), FALSE);
		SetWindowTextU(GetDlgItem(hDlg, IDC_DOWNLOAD), lmprintf(MSG_038));
		FormatStatus = 0;
		download_status = 1;
		return (INT_PTR)TRUE;
	case UM_PROGRESS_EXIT:
		EnableWindow(GetDlgItem(hDlg, IDCANCEL), TRUE);
		if (wParam) {
			SetWindowTextU(GetDlgItem(hDlg, IDC_DOWNLOAD), lmprintf(MSG_039));
			download_status = 2;
		} else {
			SetWindowTextU(GetDlgItem(hDlg, IDC_DOWNLOAD), lmprintf(MSG_040));
			download_status = 0;
		}
		return (INT_PTR)TRUE;
	}
	return (INT_PTR)FALSE;
}
"
