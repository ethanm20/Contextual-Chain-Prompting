,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
145,177881,,Local,Not required,Complete,CVE-2019-12382,https://www.cvedetails.com/cve/CVE-2019-12382/,CWE-476,Low,,,,2019-05-27,4.9,"An issue was discovered in drm_load_edid_firmware in drivers/gpu/drm/drm_edid_load.c in the Linux kernel through 5.1.5. There is an unchecked kstrdup of fwstr, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash).",2019-06-09,DoS,2,https://cgit.freedesktop.org/drm/drm-misc/commit/?id=9f1f1a2dab38d4ce87a13565cf4dc1b73bef3a5f,9f1f1a2dab38d4ce87a13565cf4dc1b73bef3a5f,,0,,,"struct edid *drm_load_edid_firmware(struct drm_connector *connector)
{
	const char *connector_name = connector->name;
	char *edidname, *last, *colon, *fwstr, *edidstr, *fallback = NULL;
	struct edid *edid;

	if (edid_firmware[0] == '\0')
		return ERR_PTR(-ENOENT);

	/*
	 * If there are multiple edid files specified and separated
	 * by commas, search through the list looking for one that
	 * matches the connector.
	 *
	 * If there's one or more that doesn't specify a connector, keep
 	 * the last one found one as a fallback.
 	 */
 	fwstr = kstrdup(edid_firmware, GFP_KERNEL);
	if (!fwstr)
		return ERR_PTR(-ENOMEM);
 	edidstr = fwstr;
 
 	while ((edidname = strsep(&edidstr, "",""))) {
			if (strncmp(connector_name, edidname, colon - edidname))
				continue;
			edidname = colon + 1;
			break;
		}

		if (*edidname != '\0') /* corner case: multiple ',' */
			fallback = edidname;
	}
","struct edid *drm_load_edid_firmware(struct drm_connector *connector)
{
	const char *connector_name = connector->name;
	char *edidname, *last, *colon, *fwstr, *edidstr, *fallback = NULL;
	struct edid *edid;

	if (edid_firmware[0] == '\0')
		return ERR_PTR(-ENOENT);

	/*
	 * If there are multiple edid files specified and separated
	 * by commas, search through the list looking for one that
	 * matches the connector.
	 *
	 * If there's one or more that doesn't specify a connector, keep
 	 * the last one found one as a fallback.
 	 */
 	fwstr = kstrdup(edid_firmware, GFP_KERNEL);
 	edidstr = fwstr;
 
 	while ((edidname = strsep(&edidstr, "",""))) {
			if (strncmp(connector_name, edidname, colon - edidname))
				continue;
			edidname = colon + 1;
			break;
		}

		if (*edidname != '\0') /* corner case: multiple ',' */
			fallback = edidname;
	}
",C,"	if (!fwstr)
		return ERR_PTR(-ENOMEM);
",,5fc537bfd00033a3f813330175f7f12c25957ebf,"@@ -293,6 +293,8 @@ struct edid *drm_load_edid_firmware(struct drm_connector *connector)
 	 * the last one found one as a fallback.
 	 */
 	fwstr = kstrdup(edid_firmware, GFP_KERNEL);
+	if (!fwstr)
+		return ERR_PTR(-ENOMEM);
 	edidstr = fwstr;
 
 	while ((edidname = strsep(&edidstr, "",""))) {",drm,https://cgit.freedesktop.org/drm/drm-misc/tree/drivers/gpu/drm/drm_edid_load.c?id=9f1f1a2dab38d4ce87a13565cf4dc1b73bef3a5f,https://cgit.freedesktop.org/drm/drm-misc/tree/drivers/gpu/drm/drm_edid_load.c?id=5fc537bfd00033a3f813330175f7f12c25957ebf,1,"struct edid *drm_load_edid_firmware(struct drm_connector *connector)
{
	const char *connector_name = connector->name;
	char *edidname, *last, *colon, *fwstr, *edidstr, *fallback = NULL;
	struct edid *edid;

	if (edid_firmware[0] == '\0')
		return ERR_PTR(-ENOENT);

	/*
	 * If there are multiple edid files specified and separated
	 * by commas, search through the list looking for one that
	 * matches the connector.
	 *
	 * If there's one or more that doesn't specify a connector, keep
 	 * the last one found one as a fallback.
 	 */
 	fwstr = kstrdup(edid_firmware, GFP_KERNEL);
//fix_flaw_line_below:
//	if (!fwstr)
//fix_flaw_line_below:
//		return ERR_PTR(-ENOMEM);
 	edidstr = fwstr;
 
 	while ((edidname = strsep(&edidstr, "",""))) {
			if (strncmp(connector_name, edidname, colon - edidname))
				continue;
			edidname = colon + 1;
			break;
		}

		if (*edidname != '\0') /* corner case: multiple ',' */
			fallback = edidname;
	}
"
212,177948,,Remote,Not required,Partial,CVE-2019-9923,https://www.cvedetails.com/cve/CVE-2019-9923/,CWE-476,Low,,,,2019-03-22,5.0,pax_decode_header in sparse.c in GNU Tar before 1.32 had a NULL pointer dereference when parsing certain archives that have malformed extended headers.,2019-04-24,,4,https://git.savannah.gnu.org/cgit/tar.git/commit/?id=cb07844454d8cc9fb21f53ace75975f91185a120,cb07844454d8cc9fb21f53ace75975f91185a120,,0,,,"pax_decode_header (struct tar_sparse_file *file)
{
  if (file->stat_info->sparse_major > 0)
    {
      uintmax_t u;
      char nbuf[UINTMAX_STRSIZE_BOUND];
      union block *blk;
      char *p;
      size_t i;
      off_t start;
      
#define COPY_BUF(b,buf,src) do                                     \
 {                                                                 \
   char *endp = b->buffer + BLOCKSIZE;                             \
   char *dst = buf;                                                \
   do                                                              \
     {                                                             \
       if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \
         {                                                         \
           ERROR ((0, 0, _(""%s: numeric overflow in sparse archive member""), \
	          file->stat_info->orig_file_name));               \
           return false;                                           \
         }                                                         \
       if (src == endp)                                            \
 	 {                                                         \
 	   set_next_block_after (b);                               \
            b = find_next_block ();                                 \
           if (!b)                                                 \
             FATAL_ERROR ((0, 0, _(""Unexpected EOF in archive""))); \
            src = b->buffer;                                        \
 	   endp = b->buffer + BLOCKSIZE;                           \
 	 }                                                         \
   while (*dst++ != '\n');                                         \
   dst[-1] = 0;                                                    \
 } while (0)

      start = current_block_ordinal ();
      set_next_block_after (current_header);
       start = current_block_ordinal ();
       set_next_block_after (current_header);
       blk = find_next_block ();
      if (!blk)
        FATAL_ERROR ((0, 0, _(""Unexpected EOF in archive"")));
       p = blk->buffer;
       COPY_BUF (blk,nbuf,p);
       if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))
	}
      file->stat_info->sparse_map_size = u;
      file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,
					     sizeof (*file->stat_info->sparse_map));
      file->stat_info->sparse_map_avail = 0;
      for (i = 0; i < file->stat_info->sparse_map_size; i++)
	{
	  struct sp_array sp;

	  COPY_BUF (blk,nbuf,p);
	  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))
	    {
	      ERROR ((0, 0, _(""%s: malformed sparse archive member""),
		      file->stat_info->orig_file_name));
	      return false;
	    }
	  sp.offset = u;
	  COPY_BUF (blk,nbuf,p);
	  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))
	    {
	      ERROR ((0, 0, _(""%s: malformed sparse archive member""),
		      file->stat_info->orig_file_name));
	      return false;
	    }
	  sp.numbytes = u;
	  sparse_add_map (file->stat_info, &sp);
	}
      set_next_block_after (blk);

      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);
    }

  return true;
}
","pax_decode_header (struct tar_sparse_file *file)
{
  if (file->stat_info->sparse_major > 0)
    {
      uintmax_t u;
      char nbuf[UINTMAX_STRSIZE_BOUND];
      union block *blk;
      char *p;
      size_t i;
      off_t start;
      
#define COPY_BUF(b,buf,src) do                                     \
 {                                                                 \
   char *endp = b->buffer + BLOCKSIZE;                             \
   char *dst = buf;                                                \
   do                                                              \
     {                                                             \
       if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \
         {                                                         \
           ERROR ((0, 0, _(""%s: numeric overflow in sparse archive member""), \
	          file->stat_info->orig_file_name));               \
           return false;                                           \
         }                                                         \
       if (src == endp)                                            \
 	 {                                                         \
 	   set_next_block_after (b);                               \
            b = find_next_block ();                                 \
            src = b->buffer;                                        \
 	   endp = b->buffer + BLOCKSIZE;                           \
 	 }                                                         \
   while (*dst++ != '\n');                                         \
   dst[-1] = 0;                                                    \
 } while (0)

      start = current_block_ordinal ();
      set_next_block_after (current_header);
       start = current_block_ordinal ();
       set_next_block_after (current_header);
       blk = find_next_block ();
       p = blk->buffer;
       COPY_BUF (blk,nbuf,p);
       if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))
	}
      file->stat_info->sparse_map_size = u;
      file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,
					     sizeof (*file->stat_info->sparse_map));
      file->stat_info->sparse_map_avail = 0;
      for (i = 0; i < file->stat_info->sparse_map_size; i++)
	{
	  struct sp_array sp;

	  COPY_BUF (blk,nbuf,p);
	  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))
	    {
	      ERROR ((0, 0, _(""%s: malformed sparse archive member""),
		      file->stat_info->orig_file_name));
	      return false;
	    }
	  sp.offset = u;
	  COPY_BUF (blk,nbuf,p);
	  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))
	    {
	      ERROR ((0, 0, _(""%s: malformed sparse archive member""),
		      file->stat_info->orig_file_name));
	      return false;
	    }
	  sp.numbytes = u;
	  sparse_add_map (file->stat_info, &sp);
	}
      set_next_block_after (blk);

      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);
    }

  return true;
}
",C,"           if (!b)                                                 \
             FATAL_ERROR ((0, 0, _(""Unexpected EOF in archive""))); \
      if (!blk)
        FATAL_ERROR ((0, 0, _(""Unexpected EOF in archive"")));
",,2f5a57be4bcb4b6e641457ef0fc99bdbe84828ba,"@@ -1267,6 +1267,8 @@ pax_decode_header (struct tar_sparse_file *file)
 	 {                                                         \
 	   set_next_block_after (b);                               \
            b = find_next_block ();                                 \
+           if (!b)                                                 \
+             FATAL_ERROR ((0, 0, _(""Unexpected EOF in archive""))); \
            src = b->buffer;                                        \
 	   endp = b->buffer + BLOCKSIZE;                           \
 	 }                                                         \
@@ -1279,6 +1281,8 @@ pax_decode_header (struct tar_sparse_file *file)
       start = current_block_ordinal ();
       set_next_block_after (current_header);
       blk = find_next_block ();
+      if (!blk)
+        FATAL_ERROR ((0, 0, _(""Unexpected EOF in archive"")));
       p = blk->buffer;
       COPY_BUF (blk,nbuf,p);
       if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))",savannah,https://git.savannah.gnu.org/cgit/tar.git/tree/src/sparse.c?id=cb07844454d8cc9fb21f53ace75975f91185a120,https://git.savannah.gnu.org/cgit/tar.git/tree/src/sparse.c?id=2f5a57be4bcb4b6e641457ef0fc99bdbe84828ba,1,"pax_decode_header (struct tar_sparse_file *file)
{
  if (file->stat_info->sparse_major > 0)
    {
      uintmax_t u;
      char nbuf[UINTMAX_STRSIZE_BOUND];
      union block *blk;
      char *p;
      size_t i;
      off_t start;
      
#define COPY_BUF(b,buf,src) do                                     \
 {                                                                 \
   char *endp = b->buffer + BLOCKSIZE;                             \
   char *dst = buf;                                                \
   do                                                              \
     {                                                             \
       if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \
         {                                                         \
           ERROR ((0, 0, _(""%s: numeric overflow in sparse archive member""), \
	          file->stat_info->orig_file_name));               \
           return false;                                           \
         }                                                         \
       if (src == endp)                                            \
 	 {                                                         \
 	   set_next_block_after (b);                               \
            b = find_next_block ();                                 \
//fix_flaw_line_below:
//           if (!b)                                                 \
//fix_flaw_line_below:
//             FATAL_ERROR ((0, 0, _(""Unexpected EOF in archive""))); \
            src = b->buffer;                                        \
 	   endp = b->buffer + BLOCKSIZE;                           \
 	 }                                                         \
   while (*dst++ != '\n');                                         \
   dst[-1] = 0;                                                    \
 } while (0)

      start = current_block_ordinal ();
      set_next_block_after (current_header);
       start = current_block_ordinal ();
       set_next_block_after (current_header);
       blk = find_next_block ();
//fix_flaw_line_below:
//      if (!blk)
//fix_flaw_line_below:
//        FATAL_ERROR ((0, 0, _(""Unexpected EOF in archive"")));
       p = blk->buffer;
       COPY_BUF (blk,nbuf,p);
       if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))
	}
      file->stat_info->sparse_map_size = u;
      file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,
					     sizeof (*file->stat_info->sparse_map));
      file->stat_info->sparse_map_avail = 0;
      for (i = 0; i < file->stat_info->sparse_map_size; i++)
	{
	  struct sp_array sp;

	  COPY_BUF (blk,nbuf,p);
	  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))
	    {
	      ERROR ((0, 0, _(""%s: malformed sparse archive member""),
		      file->stat_info->orig_file_name));
	      return false;
	    }
	  sp.offset = u;
	  COPY_BUF (blk,nbuf,p);
	  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))
	    {
	      ERROR ((0, 0, _(""%s: malformed sparse archive member""),
		      file->stat_info->orig_file_name));
	      return false;
	    }
	  sp.numbytes = u;
	  sparse_add_map (file->stat_info, &sp);
	}
      set_next_block_after (blk);

      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);
    }

  return true;
}
"
326,178062,,Remote,Not required,Partial,CVE-2017-7511,https://www.cvedetails.com/cve/CVE-2017-7511/,CWE-476,Medium,,,,2017-05-30,4.3,poppler since version 0.17.3 has been vulnerable to NULL pointer dereference in pdfunite triggered by specially crafted documents.,2018-01-18,,7,https://cgit.freedesktop.org/poppler/poppler/commit/?id=5c9b08a875b07853be6c44e43ff5f7f059df666a,5c9b08a875b07853be6c44e43ff5f7f059df666a,,3,,,"int main (int argc, char *argv[])
{
  int objectsCount = 0;
  Guint numOffset = 0;
  std::vector<Object> pages;
  std::vector<Guint> offsets;
  XRef *yRef, *countRef;
  FILE *f;
  OutStream *outStr;
  int i;
  int j, rootNum;
  std::vector<PDFDoc *>docs;
  int majorVersion = 0;
  int minorVersion = 0;
  char *fileName = argv[argc - 1];
  int exitCode;

  exitCode = 99;
  const GBool ok = parseArgs (argDesc, &argc, argv);
  if (!ok || argc < 3 || printVersion || printHelp) {
    fprintf(stderr, ""pdfunite version %s\n"", PACKAGE_VERSION);
    fprintf(stderr, ""%s\n"", popplerCopyright);
    fprintf(stderr, ""%s\n"", xpdfCopyright);
    if (!printVersion) {
      printUsage(""pdfunite"", ""<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>"",
	argDesc);
    }
    if (printVersion || printHelp)
      exitCode = 0;
    return exitCode;
  }
  exitCode = 0;
  globalParams = new GlobalParams();

  for (i = 1; i < argc - 1; i++) {
    GooString *gfileName = new GooString(argv[i]);
    PDFDoc *doc = new PDFDoc(gfileName, NULL, NULL, NULL);
    if (doc->isOk() && !doc->isEncrypted()) {
      docs.push_back(doc);
      if (doc->getPDFMajorVersion() > majorVersion) {
        majorVersion = doc->getPDFMajorVersion();
        minorVersion = doc->getPDFMinorVersion();
      } else if (doc->getPDFMajorVersion() == majorVersion) {
        if (doc->getPDFMinorVersion() > minorVersion) {
          minorVersion = doc->getPDFMinorVersion();
        }
      }
    } else if (doc->isOk()) {
      error(errUnimplemented, -1, ""Could not merge encrypted files ('{0:s}')"", argv[i]);
      return -1;
    } else {
      error(errSyntaxError, -1, ""Could not merge damaged documents ('{0:s}')"", argv[i]);
      return -1;
    }
  }

  if (!(f = fopen(fileName, ""wb""))) {
    error(errIO, -1, ""Could not open file '{0:s}'"", fileName);
    return -1;
  }
  outStr = new FileOutStream(f, 0);

  yRef = new XRef();
  countRef = new XRef();
  yRef->add(0, 65535, 0, gFalse);
  PDFDoc::writeHeader(outStr, majorVersion, minorVersion);

  Object intents;
  Object afObj;
  Object ocObj;
  Object names;
  if (docs.size() >= 1) {
    Object catObj;
    docs[0]->getXRef()->getCatalog(&catObj);
    Dict *catDict = catObj.getDict();
     catDict->lookup(""OutputIntents"", &intents);
     catDict->lookupNF(""AcroForm"", &afObj);
     Ref *refPage = docs[0]->getCatalog()->getPageRef(1);
    if (!afObj.isNull() && refPage) {
       docs[0]->markAcroForm(&afObj, yRef, countRef, 0, refPage->num, refPage->num);
     }
     catDict->lookupNF(""OCProperties"", &ocObj);
    if (!ocObj.isNull() && ocObj.isDict() && refPage) {
       docs[0]->markPageObjects(ocObj.getDict(), yRef, countRef, 0, refPage->num, refPage->num);
     }
     catDict->lookup(""Names"", &names);
    if (!names.isNull() && names.isDict() && refPage) {
       docs[0]->markPageObjects(names.getDict(), yRef, countRef, 0, refPage->num, refPage->num);
     }
     if (intents.isArray() && intents.arrayGetLength() > 0) {
      for (i = 1; i < (int) docs.size(); i++) {
        Object pagecatObj, pageintents;
        docs[i]->getXRef()->getCatalog(&pagecatObj);
        Dict *pagecatDict = pagecatObj.getDict();
        pagecatDict->lookup(""OutputIntents"", &pageintents);
        if (pageintents.isArray() && pageintents.arrayGetLength() > 0) {
          for (j = intents.arrayGetLength() - 1; j >= 0; j--) {
            Object intent;
            intents.arrayGet(j, &intent, 0);
            if (intent.isDict()) {
              Object idf;
              intent.dictLookup(""OutputConditionIdentifier"", &idf);
              if (idf.isString()) {
                GooString *gidf = idf.getString();
                GBool removeIntent = gTrue;
                for (int k = 0; k < pageintents.arrayGetLength(); k++) {
                  Object pgintent;
                  pageintents.arrayGet(k, &pgintent, 0);
                  if (pgintent.isDict()) {
                    Object pgidf;
                    pgintent.dictLookup(""OutputConditionIdentifier"", &pgidf);
                    if (pgidf.isString()) {
                      GooString *gpgidf = pgidf.getString();
                      if (gpgidf->cmp(gidf) == 0) {
                        pgidf.free();
                        removeIntent = gFalse;
                        break;
                      }
                    }
                    pgidf.free();
                  }
                }
                if (removeIntent) {
                  intents.arrayRemove(j);
                  error(errSyntaxWarning, -1, ""Output intent {0:s} missing in pdf {1:s}, removed"",
                   gidf->getCString(), docs[i]->getFileName()->getCString());
                }
              } else {
                intents.arrayRemove(j);
                error(errSyntaxWarning, -1, ""Invalid output intent dict, missing required OutputConditionIdentifier"");
              }
              idf.free();
            } else {
              intents.arrayRemove(j);
            }
            intent.free();
          }
        } else {
          error(errSyntaxWarning, -1, ""Output intents differs, remove them all"");
          intents.free();
          break;
        }
        pagecatObj.free();
        pageintents.free();
      }
    }
    if (intents.isArray() && intents.arrayGetLength() > 0) {
      for (j = intents.arrayGetLength() - 1; j >= 0; j--) {
        Object intent;
        intents.arrayGet(j, &intent, 0);
        if (intent.isDict()) {
          docs[0]->markPageObjects(intent.getDict(), yRef, countRef, numOffset, 0, 0);
        } else {
          intents.arrayRemove(j);
        }
        intent.free();
      }
    }
    catObj.free();
  }
 
   for (i = 0; i < (int) docs.size(); i++) {
     for (j = 1; j <= docs[i]->getNumPages(); j++) {
      if (!docs[i]->getCatalog()->getPage(j)) {
        continue;
      }

       PDFRectangle *cropBox = NULL;
       if (docs[i]->getCatalog()->getPage(j)->isCropped())
         cropBox = docs[i]->getCatalog()->getPage(j)->getCropBox();
      Object page;
      docs[i]->getXRef()->fetch(refPage->num, refPage->gen, &page);
      Dict *pageDict = page.getDict();
      Dict *resDict = docs[i]->getCatalog()->getPage(j)->getResourceDict();
      if (resDict) {
        Object *newResource = new Object();
        newResource->initDict(resDict);
        pageDict->set(""Resources"", newResource);
        delete newResource;
      }
      pages.push_back(page);
      offsets.push_back(numOffset);
      docs[i]->markPageObjects(pageDict, yRef, countRef, numOffset, refPage->num, refPage->num);
      Object annotsObj;
      pageDict->lookupNF(""Annots"", &annotsObj);
      if (!annotsObj.isNull()) {
        docs[i]->markAnnotations(&annotsObj, yRef, countRef, numOffset, refPage->num, refPage->num);
        annotsObj.free();
      }
    }
    Object pageCatObj, pageNames, pageForm;
    docs[i]->getXRef()->getCatalog(&pageCatObj);
    Dict *pageCatDict = pageCatObj.getDict();
    pageCatDict->lookup(""Names"", &pageNames);
    if (!pageNames.isNull() && pageNames.isDict()) {
      if (!names.isDict()) {
        names.free();
        names.initDict(yRef);
      }
      doMergeNameDict(docs[i], yRef, countRef, 0, 0, names.getDict(), pageNames.getDict(), numOffset);
    }
    pageCatDict->lookup(""AcroForm"", &pageForm);
    if (i > 0 && !pageForm.isNull() && pageForm.isDict()) {
      if (afObj.isNull()) {
        pageCatDict->lookupNF(""AcroForm"", &afObj);
      } else if (afObj.isDict()) {
        doMergeFormDict(afObj.getDict(), pageForm.getDict(), numOffset);
      }
    }
    pageForm.free();
    pageNames.free();
    pageCatObj.free();
    objectsCount += docs[i]->writePageObjects(outStr, yRef, numOffset, gTrue);
    numOffset = yRef->getNumObjects() + 1;
  }

  rootNum = yRef->getNumObjects() + 1;
  yRef->add(rootNum, 0, outStr->getPos(), gTrue);
  outStr->printf(""%d 0 obj\n"", rootNum);
  outStr->printf(""<< /Type /Catalog /Pages %d 0 R"", rootNum + 1);
  if (intents.isArray() && intents.arrayGetLength() > 0) {
    outStr->printf("" /OutputIntents ["");
    for (j = 0; j < intents.arrayGetLength(); j++) {
      Object intent;
      intents.arrayGet(j, &intent, 0);
      if (intent.isDict()) {
        PDFDoc::writeObject(&intent, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);
      }
      intent.free();
    }
    outStr->printf(""]"");
  }
  intents.free();
  if (!afObj.isNull()) {
    outStr->printf("" /AcroForm "");
    PDFDoc::writeObject(&afObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);
    afObj.free();
  }
  if (!ocObj.isNull() && ocObj.isDict()) {
    outStr->printf("" /OCProperties "");
    PDFDoc::writeObject(&ocObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);
    ocObj.free();
  }
  if (!names.isNull() && names.isDict()) {
    outStr->printf("" /Names "");
    PDFDoc::writeObject(&names, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);
    names.free();
  }
  outStr->printf("">>\nendobj\n"");
  objectsCount++;

  yRef->add(rootNum + 1, 0, outStr->getPos(), gTrue);
  outStr->printf(""%d 0 obj\n"", rootNum + 1);
  outStr->printf(""<< /Type /Pages /Kids ["");
  for (j = 0; j < (int) pages.size(); j++)
    outStr->printf("" %d 0 R"", rootNum + j + 2);
  outStr->printf("" ] /Count %zd >>\nendobj\n"", pages.size());
  objectsCount++;

  for (i = 0; i < (int) pages.size(); i++) {
    yRef->add(rootNum + i + 2, 0, outStr->getPos(), gTrue);
    outStr->printf(""%d 0 obj\n"", rootNum + i + 2);
    outStr->printf(""<< "");
    Dict *pageDict = pages[i].getDict();
    for (j = 0; j < pageDict->getLength(); j++) {
      if (j > 0)
	outStr->printf("" "");
      const char *key = pageDict->getKey(j);
      Object value;
      pageDict->getValNF(j, &value);
      if (strcmp(key, ""Parent"") == 0) {
        outStr->printf(""/Parent %d 0 R"", rootNum + 1);
      } else {
        outStr->printf(""/%s "", key);
        PDFDoc::writeObject(&value, outStr, yRef, offsets[i], NULL, cryptRC4, 0, 0, 0);
      }
      value.free();
    }
    outStr->printf("" >>\nendobj\n"");
    objectsCount++;
  }
  Goffset uxrefOffset = outStr->getPos();
  Ref ref;
  ref.num = rootNum;
  ref.gen = 0;
  Dict *trailerDict = PDFDoc::createTrailerDict(objectsCount, gFalse, 0, &ref, yRef,
                                                fileName, outStr->getPos());
  PDFDoc::writeXRefTableTrailer(trailerDict, yRef, gTrue, // write all entries according to ISO 32000-1, 7.5.4 Cross-Reference Table: ""For a file that has never been incrementally updated, the cross-reference section shall contain only one subsection, whose object numbering begins at 0.""
                                uxrefOffset, outStr, yRef);
  delete trailerDict;

  outStr->close();
  delete outStr;
  fclose(f);
  delete yRef;
  delete countRef;
  for (j = 0; j < (int) pages.size (); j++) pages[j].free();
  for (i = 0; i < (int) docs.size (); i++) delete docs[i];
  delete globalParams;
  return exitCode;
}
","int main (int argc, char *argv[])
{
  int objectsCount = 0;
  Guint numOffset = 0;
  std::vector<Object> pages;
  std::vector<Guint> offsets;
  XRef *yRef, *countRef;
  FILE *f;
  OutStream *outStr;
  int i;
  int j, rootNum;
  std::vector<PDFDoc *>docs;
  int majorVersion = 0;
  int minorVersion = 0;
  char *fileName = argv[argc - 1];
  int exitCode;

  exitCode = 99;
  const GBool ok = parseArgs (argDesc, &argc, argv);
  if (!ok || argc < 3 || printVersion || printHelp) {
    fprintf(stderr, ""pdfunite version %s\n"", PACKAGE_VERSION);
    fprintf(stderr, ""%s\n"", popplerCopyright);
    fprintf(stderr, ""%s\n"", xpdfCopyright);
    if (!printVersion) {
      printUsage(""pdfunite"", ""<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>"",
	argDesc);
    }
    if (printVersion || printHelp)
      exitCode = 0;
    return exitCode;
  }
  exitCode = 0;
  globalParams = new GlobalParams();

  for (i = 1; i < argc - 1; i++) {
    GooString *gfileName = new GooString(argv[i]);
    PDFDoc *doc = new PDFDoc(gfileName, NULL, NULL, NULL);
    if (doc->isOk() && !doc->isEncrypted()) {
      docs.push_back(doc);
      if (doc->getPDFMajorVersion() > majorVersion) {
        majorVersion = doc->getPDFMajorVersion();
        minorVersion = doc->getPDFMinorVersion();
      } else if (doc->getPDFMajorVersion() == majorVersion) {
        if (doc->getPDFMinorVersion() > minorVersion) {
          minorVersion = doc->getPDFMinorVersion();
        }
      }
    } else if (doc->isOk()) {
      error(errUnimplemented, -1, ""Could not merge encrypted files ('{0:s}')"", argv[i]);
      return -1;
    } else {
      error(errSyntaxError, -1, ""Could not merge damaged documents ('{0:s}')"", argv[i]);
      return -1;
    }
  }

  if (!(f = fopen(fileName, ""wb""))) {
    error(errIO, -1, ""Could not open file '{0:s}'"", fileName);
    return -1;
  }
  outStr = new FileOutStream(f, 0);

  yRef = new XRef();
  countRef = new XRef();
  yRef->add(0, 65535, 0, gFalse);
  PDFDoc::writeHeader(outStr, majorVersion, minorVersion);

  Object intents;
  Object afObj;
  Object ocObj;
  Object names;
  if (docs.size() >= 1) {
    Object catObj;
    docs[0]->getXRef()->getCatalog(&catObj);
    Dict *catDict = catObj.getDict();
     catDict->lookup(""OutputIntents"", &intents);
     catDict->lookupNF(""AcroForm"", &afObj);
     Ref *refPage = docs[0]->getCatalog()->getPageRef(1);
    if (!afObj.isNull()) {
       docs[0]->markAcroForm(&afObj, yRef, countRef, 0, refPage->num, refPage->num);
     }
     catDict->lookupNF(""OCProperties"", &ocObj);
    if (!ocObj.isNull() && ocObj.isDict()) {
       docs[0]->markPageObjects(ocObj.getDict(), yRef, countRef, 0, refPage->num, refPage->num);
     }
     catDict->lookup(""Names"", &names);
    if (!names.isNull() && names.isDict()) {
       docs[0]->markPageObjects(names.getDict(), yRef, countRef, 0, refPage->num, refPage->num);
     }
     if (intents.isArray() && intents.arrayGetLength() > 0) {
      for (i = 1; i < (int) docs.size(); i++) {
        Object pagecatObj, pageintents;
        docs[i]->getXRef()->getCatalog(&pagecatObj);
        Dict *pagecatDict = pagecatObj.getDict();
        pagecatDict->lookup(""OutputIntents"", &pageintents);
        if (pageintents.isArray() && pageintents.arrayGetLength() > 0) {
          for (j = intents.arrayGetLength() - 1; j >= 0; j--) {
            Object intent;
            intents.arrayGet(j, &intent, 0);
            if (intent.isDict()) {
              Object idf;
              intent.dictLookup(""OutputConditionIdentifier"", &idf);
              if (idf.isString()) {
                GooString *gidf = idf.getString();
                GBool removeIntent = gTrue;
                for (int k = 0; k < pageintents.arrayGetLength(); k++) {
                  Object pgintent;
                  pageintents.arrayGet(k, &pgintent, 0);
                  if (pgintent.isDict()) {
                    Object pgidf;
                    pgintent.dictLookup(""OutputConditionIdentifier"", &pgidf);
                    if (pgidf.isString()) {
                      GooString *gpgidf = pgidf.getString();
                      if (gpgidf->cmp(gidf) == 0) {
                        pgidf.free();
                        removeIntent = gFalse;
                        break;
                      }
                    }
                    pgidf.free();
                  }
                }
                if (removeIntent) {
                  intents.arrayRemove(j);
                  error(errSyntaxWarning, -1, ""Output intent {0:s} missing in pdf {1:s}, removed"",
                   gidf->getCString(), docs[i]->getFileName()->getCString());
                }
              } else {
                intents.arrayRemove(j);
                error(errSyntaxWarning, -1, ""Invalid output intent dict, missing required OutputConditionIdentifier"");
              }
              idf.free();
            } else {
              intents.arrayRemove(j);
            }
            intent.free();
          }
        } else {
          error(errSyntaxWarning, -1, ""Output intents differs, remove them all"");
          intents.free();
          break;
        }
        pagecatObj.free();
        pageintents.free();
      }
    }
    if (intents.isArray() && intents.arrayGetLength() > 0) {
      for (j = intents.arrayGetLength() - 1; j >= 0; j--) {
        Object intent;
        intents.arrayGet(j, &intent, 0);
        if (intent.isDict()) {
          docs[0]->markPageObjects(intent.getDict(), yRef, countRef, numOffset, 0, 0);
        } else {
          intents.arrayRemove(j);
        }
        intent.free();
      }
    }
    catObj.free();
  }
 
   for (i = 0; i < (int) docs.size(); i++) {
     for (j = 1; j <= docs[i]->getNumPages(); j++) {
       PDFRectangle *cropBox = NULL;
       if (docs[i]->getCatalog()->getPage(j)->isCropped())
         cropBox = docs[i]->getCatalog()->getPage(j)->getCropBox();
      Object page;
      docs[i]->getXRef()->fetch(refPage->num, refPage->gen, &page);
      Dict *pageDict = page.getDict();
      Dict *resDict = docs[i]->getCatalog()->getPage(j)->getResourceDict();
      if (resDict) {
        Object *newResource = new Object();
        newResource->initDict(resDict);
        pageDict->set(""Resources"", newResource);
        delete newResource;
      }
      pages.push_back(page);
      offsets.push_back(numOffset);
      docs[i]->markPageObjects(pageDict, yRef, countRef, numOffset, refPage->num, refPage->num);
      Object annotsObj;
      pageDict->lookupNF(""Annots"", &annotsObj);
      if (!annotsObj.isNull()) {
        docs[i]->markAnnotations(&annotsObj, yRef, countRef, numOffset, refPage->num, refPage->num);
        annotsObj.free();
      }
    }
    Object pageCatObj, pageNames, pageForm;
    docs[i]->getXRef()->getCatalog(&pageCatObj);
    Dict *pageCatDict = pageCatObj.getDict();
    pageCatDict->lookup(""Names"", &pageNames);
    if (!pageNames.isNull() && pageNames.isDict()) {
      if (!names.isDict()) {
        names.free();
        names.initDict(yRef);
      }
      doMergeNameDict(docs[i], yRef, countRef, 0, 0, names.getDict(), pageNames.getDict(), numOffset);
    }
    pageCatDict->lookup(""AcroForm"", &pageForm);
    if (i > 0 && !pageForm.isNull() && pageForm.isDict()) {
      if (afObj.isNull()) {
        pageCatDict->lookupNF(""AcroForm"", &afObj);
      } else if (afObj.isDict()) {
        doMergeFormDict(afObj.getDict(), pageForm.getDict(), numOffset);
      }
    }
    pageForm.free();
    pageNames.free();
    pageCatObj.free();
    objectsCount += docs[i]->writePageObjects(outStr, yRef, numOffset, gTrue);
    numOffset = yRef->getNumObjects() + 1;
  }

  rootNum = yRef->getNumObjects() + 1;
  yRef->add(rootNum, 0, outStr->getPos(), gTrue);
  outStr->printf(""%d 0 obj\n"", rootNum);
  outStr->printf(""<< /Type /Catalog /Pages %d 0 R"", rootNum + 1);
  if (intents.isArray() && intents.arrayGetLength() > 0) {
    outStr->printf("" /OutputIntents ["");
    for (j = 0; j < intents.arrayGetLength(); j++) {
      Object intent;
      intents.arrayGet(j, &intent, 0);
      if (intent.isDict()) {
        PDFDoc::writeObject(&intent, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);
      }
      intent.free();
    }
    outStr->printf(""]"");
  }
  intents.free();
  if (!afObj.isNull()) {
    outStr->printf("" /AcroForm "");
    PDFDoc::writeObject(&afObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);
    afObj.free();
  }
  if (!ocObj.isNull() && ocObj.isDict()) {
    outStr->printf("" /OCProperties "");
    PDFDoc::writeObject(&ocObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);
    ocObj.free();
  }
  if (!names.isNull() && names.isDict()) {
    outStr->printf("" /Names "");
    PDFDoc::writeObject(&names, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);
    names.free();
  }
  outStr->printf("">>\nendobj\n"");
  objectsCount++;

  yRef->add(rootNum + 1, 0, outStr->getPos(), gTrue);
  outStr->printf(""%d 0 obj\n"", rootNum + 1);
  outStr->printf(""<< /Type /Pages /Kids ["");
  for (j = 0; j < (int) pages.size(); j++)
    outStr->printf("" %d 0 R"", rootNum + j + 2);
  outStr->printf("" ] /Count %zd >>\nendobj\n"", pages.size());
  objectsCount++;

  for (i = 0; i < (int) pages.size(); i++) {
    yRef->add(rootNum + i + 2, 0, outStr->getPos(), gTrue);
    outStr->printf(""%d 0 obj\n"", rootNum + i + 2);
    outStr->printf(""<< "");
    Dict *pageDict = pages[i].getDict();
    for (j = 0; j < pageDict->getLength(); j++) {
      if (j > 0)
	outStr->printf("" "");
      const char *key = pageDict->getKey(j);
      Object value;
      pageDict->getValNF(j, &value);
      if (strcmp(key, ""Parent"") == 0) {
        outStr->printf(""/Parent %d 0 R"", rootNum + 1);
      } else {
        outStr->printf(""/%s "", key);
        PDFDoc::writeObject(&value, outStr, yRef, offsets[i], NULL, cryptRC4, 0, 0, 0);
      }
      value.free();
    }
    outStr->printf("" >>\nendobj\n"");
    objectsCount++;
  }
  Goffset uxrefOffset = outStr->getPos();
  Ref ref;
  ref.num = rootNum;
  ref.gen = 0;
  Dict *trailerDict = PDFDoc::createTrailerDict(objectsCount, gFalse, 0, &ref, yRef,
                                                fileName, outStr->getPos());
  PDFDoc::writeXRefTableTrailer(trailerDict, yRef, gTrue, // write all entries according to ISO 32000-1, 7.5.4 Cross-Reference Table: ""For a file that has never been incrementally updated, the cross-reference section shall contain only one subsection, whose object numbering begins at 0.""
                                uxrefOffset, outStr, yRef);
  delete trailerDict;

  outStr->close();
  delete outStr;
  fclose(f);
  delete yRef;
  delete countRef;
  for (j = 0; j < (int) pages.size (); j++) pages[j].free();
  for (i = 0; i < (int) docs.size (); i++) delete docs[i];
  delete globalParams;
  return exitCode;
}
",CPP,"    if (!afObj.isNull() && refPage) {
    if (!ocObj.isNull() && ocObj.isDict() && refPage) {
    if (!names.isNull() && names.isDict() && refPage) {
      if (!docs[i]->getCatalog()->getPage(j)) {
        continue;
      }

","    if (!afObj.isNull()) {
    if (!ocObj.isNull() && ocObj.isDict()) {
    if (!names.isNull() && names.isDict()) {
",ff05069f34a00d67cdddb033f6240a3407e90057,"@@ -7,7 +7,7 @@
 // Copyright (C) 2011-2015, 2017 Thomas Freitag <Thomas.Freitag@alfa.de>
 // Copyright (C) 2012 Arseny Solokha <asolokha@gmx.com>
 // Copyright (C) 2012 Fabio D'Urso <fabiodurso@hotmail.it>
-// Copyright (C) 2012, 2014 Albert Astals Cid <aacid@kde.org>
+// Copyright (C) 2012, 2014, 2017 Albert Astals Cid <aacid@kde.org>
 // Copyright (C) 2013 Adrian Johnson <ajohnson@redneon.com>
 // Copyright (C) 2013 Hib Eris <hib@hiberis.nl>
 // Copyright (C) 2015 Arthur Stavisky <vovodroid@gmail.com>
@@ -268,15 +268,15 @@ int main (int argc, char *argv[])
     catDict->lookup(""OutputIntents"", &intents);
     catDict->lookupNF(""AcroForm"", &afObj);
     Ref *refPage = docs[0]->getCatalog()->getPageRef(1);
-    if (!afObj.isNull()) {
+    if (!afObj.isNull() && refPage) {
       docs[0]->markAcroForm(&afObj, yRef, countRef, 0, refPage->num, refPage->num);
     }
     catDict->lookupNF(""OCProperties"", &ocObj);
-    if (!ocObj.isNull() && ocObj.isDict()) {
+    if (!ocObj.isNull() && ocObj.isDict() && refPage) {
       docs[0]->markPageObjects(ocObj.getDict(), yRef, countRef, 0, refPage->num, refPage->num);
     }
     catDict->lookup(""Names"", &names);
-    if (!names.isNull() && names.isDict()) {
+    if (!names.isNull() && names.isDict() && refPage) {
       docs[0]->markPageObjects(names.getDict(), yRef, countRef, 0, refPage->num, refPage->num);
     }
     if (intents.isArray() && intents.arrayGetLength() > 0) {
@@ -353,6 +353,10 @@ int main (int argc, char *argv[])
 
   for (i = 0; i < (int) docs.size(); i++) {
     for (j = 1; j <= docs[i]->getNumPages(); j++) {
+      if (!docs[i]->getCatalog()->getPage(j)) {
+        continue;
+      }
+
       PDFRectangle *cropBox = NULL;
       if (docs[i]->getCatalog()->getPage(j)->isCropped())
         cropBox = docs[i]->getCatalog()->getPage(j)->getCropBox();",poppler,https://cgit.freedesktop.org/poppler/poppler/tree/utils/pdfunite.cc?id=5c9b08a875b07853be6c44e43ff5f7f059df666a,https://cgit.freedesktop.org/poppler/poppler/tree/utils/pdfunite.cc?id=ff05069f34a00d67cdddb033f6240a3407e90057,1,"int main (int argc, char *argv[])
///////////////////////////////////////////////////////////////////////////
// Merge PDF files given by arguments 1 to argc-2 and write the result
// to the file specified by argument argc-1.
///////////////////////////////////////////////////////////////////////////
{
  int objectsCount = 0;
  Guint numOffset = 0;
  std::vector<Object> pages;
  std::vector<Guint> offsets;
  XRef *yRef, *countRef;
  FILE *f;
  OutStream *outStr;
  int i;
  int j, rootNum;
  std::vector<PDFDoc *>docs;
  int majorVersion = 0;
  int minorVersion = 0;
  char *fileName = argv[argc - 1];
  int exitCode;

  exitCode = 99;
  const GBool ok = parseArgs (argDesc, &argc, argv);
  if (!ok || argc < 3 || printVersion || printHelp) {
    fprintf(stderr, ""pdfunite version %s\n"", PACKAGE_VERSION);
    fprintf(stderr, ""%s\n"", popplerCopyright);
    fprintf(stderr, ""%s\n"", xpdfCopyright);
    if (!printVersion) {
      printUsage(""pdfunite"", ""<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>"",
	argDesc);
    }
    if (printVersion || printHelp)
      exitCode = 0;
    return exitCode;
  }
  exitCode = 0;
  globalParams = new GlobalParams();

  for (i = 1; i < argc - 1; i++) {
    GooString *gfileName = new GooString(argv[i]);
    PDFDoc *doc = new PDFDoc(gfileName, NULL, NULL, NULL);
    if (doc->isOk() && !doc->isEncrypted()) {
      docs.push_back(doc);
      if (doc->getPDFMajorVersion() > majorVersion) {
        majorVersion = doc->getPDFMajorVersion();
        minorVersion = doc->getPDFMinorVersion();
      } else if (doc->getPDFMajorVersion() == majorVersion) {
        if (doc->getPDFMinorVersion() > minorVersion) {
          minorVersion = doc->getPDFMinorVersion();
        }
      }
    } else if (doc->isOk()) {
      error(errUnimplemented, -1, ""Could not merge encrypted files ('{0:s}')"", argv[i]);
      return -1;
    } else {
      error(errSyntaxError, -1, ""Could not merge damaged documents ('{0:s}')"", argv[i]);
      return -1;
    }
  }

  if (!(f = fopen(fileName, ""wb""))) {
    error(errIO, -1, ""Could not open file '{0:s}'"", fileName);
    return -1;
  }
  outStr = new FileOutStream(f, 0);

  yRef = new XRef();
  countRef = new XRef();
  yRef->add(0, 65535, 0, gFalse);
  PDFDoc::writeHeader(outStr, majorVersion, minorVersion);

  // handle OutputIntents, AcroForm, OCProperties & Names
  Object intents;
  Object afObj;
  Object ocObj;
  Object names;
  if (docs.size() >= 1) {
    Object catObj;
    docs[0]->getXRef()->getCatalog(&catObj);
    Dict *catDict = catObj.getDict();
     catDict->lookup(""OutputIntents"", &intents);
     catDict->lookupNF(""AcroForm"", &afObj);
     Ref *refPage = docs[0]->getCatalog()->getPageRef(1);
//flaw_line_below:
    if (!afObj.isNull()) {
//fix_flaw_line_below:
//    if (!afObj.isNull() && refPage) {
       docs[0]->markAcroForm(&afObj, yRef, countRef, 0, refPage->num, refPage->num);
     }
     catDict->lookupNF(""OCProperties"", &ocObj);
//flaw_line_below:
    if (!ocObj.isNull() && ocObj.isDict()) {
//fix_flaw_line_below:
//    if (!ocObj.isNull() && ocObj.isDict() && refPage) {
       docs[0]->markPageObjects(ocObj.getDict(), yRef, countRef, 0, refPage->num, refPage->num);
     }
     catDict->lookup(""Names"", &names);
//flaw_line_below:
    if (!names.isNull() && names.isDict()) {
//fix_flaw_line_below:
//    if (!names.isNull() && names.isDict() && refPage) {
       docs[0]->markPageObjects(names.getDict(), yRef, countRef, 0, refPage->num, refPage->num);
     }
     if (intents.isArray() && intents.arrayGetLength() > 0) {
      for (i = 1; i < (int) docs.size(); i++) {
        Object pagecatObj, pageintents;
        docs[i]->getXRef()->getCatalog(&pagecatObj);
        Dict *pagecatDict = pagecatObj.getDict();
        pagecatDict->lookup(""OutputIntents"", &pageintents);
        if (pageintents.isArray() && pageintents.arrayGetLength() > 0) {
          for (j = intents.arrayGetLength() - 1; j >= 0; j--) {
            Object intent;
            intents.arrayGet(j, &intent, 0);
            if (intent.isDict()) {
              Object idf;
              intent.dictLookup(""OutputConditionIdentifier"", &idf);
              if (idf.isString()) {
                GooString *gidf = idf.getString();
                GBool removeIntent = gTrue;
                for (int k = 0; k < pageintents.arrayGetLength(); k++) {
                  Object pgintent;
                  pageintents.arrayGet(k, &pgintent, 0);
                  if (pgintent.isDict()) {
                    Object pgidf;
                    pgintent.dictLookup(""OutputConditionIdentifier"", &pgidf);
                    if (pgidf.isString()) {
                      GooString *gpgidf = pgidf.getString();
                      if (gpgidf->cmp(gidf) == 0) {
                        pgidf.free();
                        removeIntent = gFalse;
                        break;
                      }
                    }
                    pgidf.free();
                  }
                }
                if (removeIntent) {
                  intents.arrayRemove(j);
                  error(errSyntaxWarning, -1, ""Output intent {0:s} missing in pdf {1:s}, removed"",
                   gidf->getCString(), docs[i]->getFileName()->getCString());
                }
              } else {
                intents.arrayRemove(j);
                error(errSyntaxWarning, -1, ""Invalid output intent dict, missing required OutputConditionIdentifier"");
              }
              idf.free();
            } else {
              intents.arrayRemove(j);
            }
            intent.free();
          }
        } else {
          error(errSyntaxWarning, -1, ""Output intents differs, remove them all"");
          intents.free();
          break;
        }
        pagecatObj.free();
        pageintents.free();
      }
    }
    if (intents.isArray() && intents.arrayGetLength() > 0) {
      for (j = intents.arrayGetLength() - 1; j >= 0; j--) {
        Object intent;
        intents.arrayGet(j, &intent, 0);
        if (intent.isDict()) {
          docs[0]->markPageObjects(intent.getDict(), yRef, countRef, numOffset, 0, 0);
        } else {
          intents.arrayRemove(j);
        }
        intent.free();
      }
    }
    catObj.free();
  }
 
   for (i = 0; i < (int) docs.size(); i++) {
     for (j = 1; j <= docs[i]->getNumPages(); j++) {
//fix_flaw_line_below:
//      if (!docs[i]->getCatalog()->getPage(j)) {
//fix_flaw_line_below:
//        continue;
//fix_flaw_line_below:
//      }
//fix_flaw_line_below:
//
       PDFRectangle *cropBox = NULL;
       if (docs[i]->getCatalog()->getPage(j)->isCropped())
         cropBox = docs[i]->getCatalog()->getPage(j)->getCropBox();
      Object page;
      docs[i]->getXRef()->fetch(refPage->num, refPage->gen, &page);
      Dict *pageDict = page.getDict();
      Dict *resDict = docs[i]->getCatalog()->getPage(j)->getResourceDict();
      if (resDict) {
        Object *newResource = new Object();
        newResource->initDict(resDict);
        pageDict->set(""Resources"", newResource);
        delete newResource;
      }
      pages.push_back(page);
      offsets.push_back(numOffset);
      docs[i]->markPageObjects(pageDict, yRef, countRef, numOffset, refPage->num, refPage->num);
      Object annotsObj;
      pageDict->lookupNF(""Annots"", &annotsObj);
      if (!annotsObj.isNull()) {
        docs[i]->markAnnotations(&annotsObj, yRef, countRef, numOffset, refPage->num, refPage->num);
        annotsObj.free();
      }
    }
    Object pageCatObj, pageNames, pageForm;
    docs[i]->getXRef()->getCatalog(&pageCatObj);
    Dict *pageCatDict = pageCatObj.getDict();
    pageCatDict->lookup(""Names"", &pageNames);
    if (!pageNames.isNull() && pageNames.isDict()) {
      if (!names.isDict()) {
        names.free();
        names.initDict(yRef);
      }
      doMergeNameDict(docs[i], yRef, countRef, 0, 0, names.getDict(), pageNames.getDict(), numOffset);
    }
    pageCatDict->lookup(""AcroForm"", &pageForm);
    if (i > 0 && !pageForm.isNull() && pageForm.isDict()) {
      if (afObj.isNull()) {
        pageCatDict->lookupNF(""AcroForm"", &afObj);
      } else if (afObj.isDict()) {
        doMergeFormDict(afObj.getDict(), pageForm.getDict(), numOffset);
      }
    }
    pageForm.free();
    pageNames.free();
    pageCatObj.free();
    objectsCount += docs[i]->writePageObjects(outStr, yRef, numOffset, gTrue);
    numOffset = yRef->getNumObjects() + 1;
  }

  rootNum = yRef->getNumObjects() + 1;
  yRef->add(rootNum, 0, outStr->getPos(), gTrue);
  outStr->printf(""%d 0 obj\n"", rootNum);
  outStr->printf(""<< /Type /Catalog /Pages %d 0 R"", rootNum + 1);
  // insert OutputIntents
  if (intents.isArray() && intents.arrayGetLength() > 0) {
    outStr->printf("" /OutputIntents ["");
    for (j = 0; j < intents.arrayGetLength(); j++) {
      Object intent;
      intents.arrayGet(j, &intent, 0);
      if (intent.isDict()) {
        PDFDoc::writeObject(&intent, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);
      }
      intent.free();
    }
    outStr->printf(""]"");
  }
  intents.free();
  // insert AcroForm
  if (!afObj.isNull()) {
    outStr->printf("" /AcroForm "");
    PDFDoc::writeObject(&afObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);
    afObj.free();
  }
  // insert OCProperties
  if (!ocObj.isNull() && ocObj.isDict()) {
    outStr->printf("" /OCProperties "");
    PDFDoc::writeObject(&ocObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);
    ocObj.free();
  }
  // insert Names
  if (!names.isNull() && names.isDict()) {
    outStr->printf("" /Names "");
    PDFDoc::writeObject(&names, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);
    names.free();
  }
  outStr->printf("">>\nendobj\n"");
  objectsCount++;

  yRef->add(rootNum + 1, 0, outStr->getPos(), gTrue);
  outStr->printf(""%d 0 obj\n"", rootNum + 1);
  outStr->printf(""<< /Type /Pages /Kids ["");
  for (j = 0; j < (int) pages.size(); j++)
    outStr->printf("" %d 0 R"", rootNum + j + 2);
  outStr->printf("" ] /Count %zd >>\nendobj\n"", pages.size());
  objectsCount++;

  for (i = 0; i < (int) pages.size(); i++) {
    yRef->add(rootNum + i + 2, 0, outStr->getPos(), gTrue);
    outStr->printf(""%d 0 obj\n"", rootNum + i + 2);
    outStr->printf(""<< "");
    Dict *pageDict = pages[i].getDict();
    for (j = 0; j < pageDict->getLength(); j++) {
      if (j > 0)
	outStr->printf("" "");
      const char *key = pageDict->getKey(j);
      Object value;
      pageDict->getValNF(j, &value);
      if (strcmp(key, ""Parent"") == 0) {
        outStr->printf(""/Parent %d 0 R"", rootNum + 1);
      } else {
        outStr->printf(""/%s "", key);
        PDFDoc::writeObject(&value, outStr, yRef, offsets[i], NULL, cryptRC4, 0, 0, 0);
      }
      value.free();
    }
    outStr->printf("" >>\nendobj\n"");
    objectsCount++;
  }
  Goffset uxrefOffset = outStr->getPos();
  Ref ref;
  ref.num = rootNum;
  ref.gen = 0;
  Dict *trailerDict = PDFDoc::createTrailerDict(objectsCount, gFalse, 0, &ref, yRef,
                                                fileName, outStr->getPos());
  PDFDoc::writeXRefTableTrailer(trailerDict, yRef, gTrue, // write all entries according to ISO 32000-1, 7.5.4 Cross-Reference Table: ""For a file that has never been incrementally updated, the cross-reference section shall contain only one subsection, whose object numbering begins at 0.""
                                uxrefOffset, outStr, yRef);
  delete trailerDict;

  outStr->close();
  delete outStr;
  fclose(f);
  delete yRef;
  delete countRef;
  for (j = 0; j < (int) pages.size (); j++) pages[j].free();
  for (i = 0; i < (int) docs.size (); i++) delete docs[i];
  delete globalParams;
  return exitCode;
}
"
337,178073,,Remote,Not required,Partial,CVE-2016-9294,https://www.cvedetails.com/cve/CVE-2016-9294/,CWE-476,Low,,,,2016-11-11,5.0,"Artifex Software, Inc. MuJS before 5008105780c0b0182ea6eda83ad5598f225be3ee allows context-dependent attackers to conduct ""denial of service (application crash)"" attacks by using the ""malformed labeled break/continue in JavaScript"" approach, related to a ""NULL pointer dereference"" issue affecting the jscompile.c component.",2016-11-29,DoS,5,http://git.ghostscript.com/?p=mujs.git;a=commit;h=5008105780c0b0182ea6eda83ad5598f225be3ee,5008105780c0b0182ea6eda83ad5598f225be3ee,,5,,,"static void cstm(JF, js_Ast *stm)
{
	js_Ast *target;
	int loop, cont, then, end;

	emitline(J, F, stm);

	switch (stm->type) {
	case AST_FUNDEC:
		break;

	case STM_BLOCK:
		cstmlist(J, F, stm->a);
		break;

	case STM_EMPTY:
		if (F->script) {
			emit(J, F, OP_POP);
			emit(J, F, OP_UNDEF);
		}
		break;

	case STM_VAR:
		cvarinit(J, F, stm->a);
		break;

	case STM_IF:
		if (stm->c) {
			cexp(J, F, stm->a);
			then = emitjump(J, F, OP_JTRUE);
			cstm(J, F, stm->c);
			end = emitjump(J, F, OP_JUMP);
			label(J, F, then);
			cstm(J, F, stm->b);
			label(J, F, end);
		} else {
			cexp(J, F, stm->a);
			end = emitjump(J, F, OP_JFALSE);
			cstm(J, F, stm->b);
			label(J, F, end);
		}
		break;

	case STM_DO:
		loop = here(J, F);
		cstm(J, F, stm->a);
		cont = here(J, F);
		cexp(J, F, stm->b);
		emitjumpto(J, F, OP_JTRUE, loop);
		labeljumps(J, F, stm->jumps, here(J,F), cont);
		break;

	case STM_WHILE:
		loop = here(J, F);
		cexp(J, F, stm->a);
		end = emitjump(J, F, OP_JFALSE);
		cstm(J, F, stm->b);
		emitjumpto(J, F, OP_JUMP, loop);
		label(J, F, end);
		labeljumps(J, F, stm->jumps, here(J,F), loop);
		break;

	case STM_FOR:
	case STM_FOR_VAR:
		if (stm->type == STM_FOR_VAR) {
			cvarinit(J, F, stm->a);
		} else {
			if (stm->a) {
				cexp(J, F, stm->a);
				emit(J, F, OP_POP);
			}
		}
		loop = here(J, F);
		if (stm->b) {
			cexp(J, F, stm->b);
			end = emitjump(J, F, OP_JFALSE);
		} else {
			end = 0;
		}
		cstm(J, F, stm->d);
		cont = here(J, F);
		if (stm->c) {
			cexp(J, F, stm->c);
			emit(J, F, OP_POP);
		}
		emitjumpto(J, F, OP_JUMP, loop);
		if (end)
			label(J, F, end);
		labeljumps(J, F, stm->jumps, here(J,F), cont);
		break;

	case STM_FOR_IN:
	case STM_FOR_IN_VAR:
		cexp(J, F, stm->b);
		emit(J, F, OP_ITERATOR);
		loop = here(J, F);
		{
			emit(J, F, OP_NEXTITER);
			end = emitjump(J, F, OP_JFALSE);
			cassignforin(J, F, stm);
			if (F->script) {
				emit(J, F, OP_ROT2);
				cstm(J, F, stm->c);
				emit(J, F, OP_ROT2);
			} else {
				cstm(J, F, stm->c);
			}
			emitjumpto(J, F, OP_JUMP, loop);
		}
		label(J, F, end);
		labeljumps(J, F, stm->jumps, here(J,F), loop);
		break;

	case STM_SWITCH:
		cswitch(J, F, stm->a, stm->b);
		labeljumps(J, F, stm->jumps, here(J,F), 0);
		break;

	case STM_LABEL:
		cstm(J, F, stm->b);
		/* skip consecutive labels */
		while (stm->type == STM_LABEL)
			stm = stm->b;
		/* loops and switches have already been labelled */
		if (!isloop(stm->type) && stm->type != STM_SWITCH)
			labeljumps(J, F, stm->jumps, here(J,F), 0);
		break;
 
        case STM_BREAK:
                if (stm->a) {
                       target = breaktarget(J, F, stm->parent, stm->a->string);
                        if (!target)
                                jsC_error(J, stm, ""break label '%s' not found"", stm->a->string);
                } else {
                       target = breaktarget(J, F, stm->parent, NULL);
                        if (!target)
                                jsC_error(J, stm, ""unlabelled break must be inside loop or switch"");
                }
		cexit(J, F, STM_BREAK, stm, target);
		addjump(J, F, STM_BREAK, target, emitjump(J, F, OP_JUMP));
		break;
 
        case STM_CONTINUE:
                if (stm->a) {
                       target = continuetarget(J, F, stm->parent, stm->a->string);
                        if (!target)
                                jsC_error(J, stm, ""continue label '%s' not found"", stm->a->string);
                } else {
                       target = continuetarget(J, F, stm->parent, NULL);
                        if (!target)
                                jsC_error(J, stm, ""continue must be inside loop"");
                }
		cexit(J, F, STM_CONTINUE, stm, target);
		addjump(J, F, STM_CONTINUE, target, emitjump(J, F, OP_JUMP));
		break;

	case STM_RETURN:
		if (stm->a)
                        cexp(J, F, stm->a);
                else
                        emit(J, F, OP_UNDEF);
               target = returntarget(J, F, stm->parent);
                if (!target)
                        jsC_error(J, stm, ""return not in function"");
                cexit(J, F, STM_RETURN, stm, target);
		emit(J, F, OP_RETURN);
		break;

	case STM_THROW:
		cexp(J, F, stm->a);
		emit(J, F, OP_THROW);
		break;

	case STM_WITH:
		cexp(J, F, stm->a);
		emit(J, F, OP_WITH);
		cstm(J, F, stm->b);
		emit(J, F, OP_ENDWITH);
		break;

	case STM_TRY:
		if (stm->b && stm->c) {
			if (stm->d)
				ctrycatchfinally(J, F, stm->a, stm->b, stm->c, stm->d);
			else
				ctrycatch(J, F, stm->a, stm->b, stm->c);
		} else {
			ctryfinally(J, F, stm->a, stm->d);
		}
		break;

	case STM_DEBUGGER:
		emit(J, F, OP_DEBUGGER);
		break;

	default:
		if (F->script) {
			emit(J, F, OP_POP);
			cexp(J, F, stm);
		} else {
			cexp(J, F, stm);
			emit(J, F, OP_POP);
		}
		break;
	}
}
","static void cstm(JF, js_Ast *stm)
{
	js_Ast *target;
	int loop, cont, then, end;

	emitline(J, F, stm);

	switch (stm->type) {
	case AST_FUNDEC:
		break;

	case STM_BLOCK:
		cstmlist(J, F, stm->a);
		break;

	case STM_EMPTY:
		if (F->script) {
			emit(J, F, OP_POP);
			emit(J, F, OP_UNDEF);
		}
		break;

	case STM_VAR:
		cvarinit(J, F, stm->a);
		break;

	case STM_IF:
		if (stm->c) {
			cexp(J, F, stm->a);
			then = emitjump(J, F, OP_JTRUE);
			cstm(J, F, stm->c);
			end = emitjump(J, F, OP_JUMP);
			label(J, F, then);
			cstm(J, F, stm->b);
			label(J, F, end);
		} else {
			cexp(J, F, stm->a);
			end = emitjump(J, F, OP_JFALSE);
			cstm(J, F, stm->b);
			label(J, F, end);
		}
		break;

	case STM_DO:
		loop = here(J, F);
		cstm(J, F, stm->a);
		cont = here(J, F);
		cexp(J, F, stm->b);
		emitjumpto(J, F, OP_JTRUE, loop);
		labeljumps(J, F, stm->jumps, here(J,F), cont);
		break;

	case STM_WHILE:
		loop = here(J, F);
		cexp(J, F, stm->a);
		end = emitjump(J, F, OP_JFALSE);
		cstm(J, F, stm->b);
		emitjumpto(J, F, OP_JUMP, loop);
		label(J, F, end);
		labeljumps(J, F, stm->jumps, here(J,F), loop);
		break;

	case STM_FOR:
	case STM_FOR_VAR:
		if (stm->type == STM_FOR_VAR) {
			cvarinit(J, F, stm->a);
		} else {
			if (stm->a) {
				cexp(J, F, stm->a);
				emit(J, F, OP_POP);
			}
		}
		loop = here(J, F);
		if (stm->b) {
			cexp(J, F, stm->b);
			end = emitjump(J, F, OP_JFALSE);
		} else {
			end = 0;
		}
		cstm(J, F, stm->d);
		cont = here(J, F);
		if (stm->c) {
			cexp(J, F, stm->c);
			emit(J, F, OP_POP);
		}
		emitjumpto(J, F, OP_JUMP, loop);
		if (end)
			label(J, F, end);
		labeljumps(J, F, stm->jumps, here(J,F), cont);
		break;

	case STM_FOR_IN:
	case STM_FOR_IN_VAR:
		cexp(J, F, stm->b);
		emit(J, F, OP_ITERATOR);
		loop = here(J, F);
		{
			emit(J, F, OP_NEXTITER);
			end = emitjump(J, F, OP_JFALSE);
			cassignforin(J, F, stm);
			if (F->script) {
				emit(J, F, OP_ROT2);
				cstm(J, F, stm->c);
				emit(J, F, OP_ROT2);
			} else {
				cstm(J, F, stm->c);
			}
			emitjumpto(J, F, OP_JUMP, loop);
		}
		label(J, F, end);
		labeljumps(J, F, stm->jumps, here(J,F), loop);
		break;

	case STM_SWITCH:
		cswitch(J, F, stm->a, stm->b);
		labeljumps(J, F, stm->jumps, here(J,F), 0);
		break;

	case STM_LABEL:
		cstm(J, F, stm->b);
		/* skip consecutive labels */
		while (stm->type == STM_LABEL)
			stm = stm->b;
		/* loops and switches have already been labelled */
		if (!isloop(stm->type) && stm->type != STM_SWITCH)
			labeljumps(J, F, stm->jumps, here(J,F), 0);
		break;
 
        case STM_BREAK:
                if (stm->a) {
                       target = breaktarget(J, F, stm, stm->a->string);
                        if (!target)
                                jsC_error(J, stm, ""break label '%s' not found"", stm->a->string);
                } else {
                       target = breaktarget(J, F, stm, NULL);
                        if (!target)
                                jsC_error(J, stm, ""unlabelled break must be inside loop or switch"");
                }
		cexit(J, F, STM_BREAK, stm, target);
		addjump(J, F, STM_BREAK, target, emitjump(J, F, OP_JUMP));
		break;
 
        case STM_CONTINUE:
                if (stm->a) {
                       target = continuetarget(J, F, stm, stm->a->string);
                        if (!target)
                                jsC_error(J, stm, ""continue label '%s' not found"", stm->a->string);
                } else {
                       target = continuetarget(J, F, stm, NULL);
                        if (!target)
                                jsC_error(J, stm, ""continue must be inside loop"");
                }
		cexit(J, F, STM_CONTINUE, stm, target);
		addjump(J, F, STM_CONTINUE, target, emitjump(J, F, OP_JUMP));
		break;

	case STM_RETURN:
		if (stm->a)
                        cexp(J, F, stm->a);
                else
                        emit(J, F, OP_UNDEF);
               target = returntarget(J, F, stm);
                if (!target)
                        jsC_error(J, stm, ""return not in function"");
                cexit(J, F, STM_RETURN, stm, target);
		emit(J, F, OP_RETURN);
		break;

	case STM_THROW:
		cexp(J, F, stm->a);
		emit(J, F, OP_THROW);
		break;

	case STM_WITH:
		cexp(J, F, stm->a);
		emit(J, F, OP_WITH);
		cstm(J, F, stm->b);
		emit(J, F, OP_ENDWITH);
		break;

	case STM_TRY:
		if (stm->b && stm->c) {
			if (stm->d)
				ctrycatchfinally(J, F, stm->a, stm->b, stm->c, stm->d);
			else
				ctrycatch(J, F, stm->a, stm->b, stm->c);
		} else {
			ctryfinally(J, F, stm->a, stm->d);
		}
		break;

	case STM_DEBUGGER:
		emit(J, F, OP_DEBUGGER);
		break;

	default:
		if (F->script) {
			emit(J, F, OP_POP);
			cexp(J, F, stm);
		} else {
			cexp(J, F, stm);
			emit(J, F, OP_POP);
		}
		break;
	}
}
",C,"                       target = breaktarget(J, F, stm->parent, stm->a->string);
                       target = breaktarget(J, F, stm->parent, NULL);
                       target = continuetarget(J, F, stm->parent, stm->a->string);
                       target = continuetarget(J, F, stm->parent, NULL);
               target = returntarget(J, F, stm->parent);
","                       target = breaktarget(J, F, stm, stm->a->string);
                       target = breaktarget(J, F, stm, NULL);
                       target = continuetarget(J, F, stm, stm->a->string);
                       target = continuetarget(J, F, stm, NULL);
               target = returntarget(J, F, stm);
",a5c747f1d40e8d6659a37a8d25f13fb5acf8e767,"@@ -1102,11 +1102,11 @@ static void cstm(JF, js_Ast *stm)
 
        case STM_BREAK:
                if (stm->a) {
-                       target = breaktarget(J, F, stm, stm->a->string);
+                       target = breaktarget(J, F, stm->parent, stm->a->string);
                        if (!target)
                                jsC_error(J, stm, ""break label '%s' not found"", stm->a->string);
                } else {
-                       target = breaktarget(J, F, stm, NULL);
+                       target = breaktarget(J, F, stm->parent, NULL);
                        if (!target)
                                jsC_error(J, stm, ""unlabelled break must be inside loop or switch"");
                }
@@ -1116,11 +1116,11 @@ static void cstm(JF, js_Ast *stm)
 
        case STM_CONTINUE:
                if (stm->a) {
-                       target = continuetarget(J, F, stm, stm->a->string);
+                       target = continuetarget(J, F, stm->parent, stm->a->string);
                        if (!target)
                                jsC_error(J, stm, ""continue label '%s' not found"", stm->a->string);
                } else {
-                       target = continuetarget(J, F, stm, NULL);
+                       target = continuetarget(J, F, stm->parent, NULL);
                        if (!target)
                                jsC_error(J, stm, ""continue must be inside loop"");
                }
@@ -1133,7 +1133,7 @@ static void cstm(JF, js_Ast *stm)
                        cexp(J, F, stm->a);
                else
                        emit(J, F, OP_UNDEF);
-               target = returntarget(J, F, stm);
+               target = returntarget(J, F, stm->parent);
                if (!target)
                        jsC_error(J, stm, ""return not in function"");
                cexit(J, F, STM_RETURN, stm, target);",ghostscript,http://git.ghostscript.com/?p=mujs.git;a=blob;f=jscompile.c;h=e7055fc8a287ce73bbff5b0bd583d10ddfc8b633;hb=e7055fc8a287ce73bbff5b0bd583d10ddfc8b633,http://git.ghostscript.com/?p=mujs.git;a=blob;f=jscompile.c;h=ee1d22f7179ae91ba8de9114cc02f318b8d57b0e;hb=ee1d22f7179ae91ba8de9114cc02f318b8d57b0e,1,"static void cstm(JF, js_Ast *stm)
{
	js_Ast *target;
	int loop, cont, then, end;

	emitline(J, F, stm);

	switch (stm->type) {
	case AST_FUNDEC:
		break;

	case STM_BLOCK:
		cstmlist(J, F, stm->a);
		break;

	case STM_EMPTY:
		if (F->script) {
			emit(J, F, OP_POP);
			emit(J, F, OP_UNDEF);
		}
		break;

	case STM_VAR:
		cvarinit(J, F, stm->a);
		break;

	case STM_IF:
		if (stm->c) {
			cexp(J, F, stm->a);
			then = emitjump(J, F, OP_JTRUE);
			cstm(J, F, stm->c);
			end = emitjump(J, F, OP_JUMP);
			label(J, F, then);
			cstm(J, F, stm->b);
			label(J, F, end);
		} else {
			cexp(J, F, stm->a);
			end = emitjump(J, F, OP_JFALSE);
			cstm(J, F, stm->b);
			label(J, F, end);
		}
		break;

	case STM_DO:
		loop = here(J, F);
		cstm(J, F, stm->a);
		cont = here(J, F);
		cexp(J, F, stm->b);
		emitjumpto(J, F, OP_JTRUE, loop);
		labeljumps(J, F, stm->jumps, here(J,F), cont);
		break;

	case STM_WHILE:
		loop = here(J, F);
		cexp(J, F, stm->a);
		end = emitjump(J, F, OP_JFALSE);
		cstm(J, F, stm->b);
		emitjumpto(J, F, OP_JUMP, loop);
		label(J, F, end);
		labeljumps(J, F, stm->jumps, here(J,F), loop);
		break;

	case STM_FOR:
	case STM_FOR_VAR:
		if (stm->type == STM_FOR_VAR) {
			cvarinit(J, F, stm->a);
		} else {
			if (stm->a) {
				cexp(J, F, stm->a);
				emit(J, F, OP_POP);
			}
		}
		loop = here(J, F);
		if (stm->b) {
			cexp(J, F, stm->b);
			end = emitjump(J, F, OP_JFALSE);
		} else {
			end = 0;
		}
		cstm(J, F, stm->d);
		cont = here(J, F);
		if (stm->c) {
			cexp(J, F, stm->c);
			emit(J, F, OP_POP);
		}
		emitjumpto(J, F, OP_JUMP, loop);
		if (end)
			label(J, F, end);
		labeljumps(J, F, stm->jumps, here(J,F), cont);
		break;

	case STM_FOR_IN:
	case STM_FOR_IN_VAR:
		cexp(J, F, stm->b);
		emit(J, F, OP_ITERATOR);
		loop = here(J, F);
		{
			emit(J, F, OP_NEXTITER);
			end = emitjump(J, F, OP_JFALSE);
			cassignforin(J, F, stm);
			if (F->script) {
				emit(J, F, OP_ROT2);
				cstm(J, F, stm->c);
				emit(J, F, OP_ROT2);
			} else {
				cstm(J, F, stm->c);
			}
			emitjumpto(J, F, OP_JUMP, loop);
		}
		label(J, F, end);
		labeljumps(J, F, stm->jumps, here(J,F), loop);
		break;

	case STM_SWITCH:
		cswitch(J, F, stm->a, stm->b);
		labeljumps(J, F, stm->jumps, here(J,F), 0);
		break;

	case STM_LABEL:
		cstm(J, F, stm->b);
		/* skip consecutive labels */
		while (stm->type == STM_LABEL)
			stm = stm->b;
		/* loops and switches have already been labelled */
		if (!isloop(stm->type) && stm->type != STM_SWITCH)
			labeljumps(J, F, stm->jumps, here(J,F), 0);
		break;
 
        case STM_BREAK:
                if (stm->a) {
//flaw_line_below:
                       target = breaktarget(J, F, stm, stm->a->string);
//fix_flaw_line_below:
//                       target = breaktarget(J, F, stm->parent, stm->a->string);
                        if (!target)
                                jsC_error(J, stm, ""break label '%s' not found"", stm->a->string);
                } else {
//flaw_line_below:
                       target = breaktarget(J, F, stm, NULL);
//fix_flaw_line_below:
//                       target = breaktarget(J, F, stm->parent, NULL);
                        if (!target)
                                jsC_error(J, stm, ""unlabelled break must be inside loop or switch"");
                }
		cexit(J, F, STM_BREAK, stm, target);
		addjump(J, F, STM_BREAK, target, emitjump(J, F, OP_JUMP));
		break;
 
        case STM_CONTINUE:
                if (stm->a) {
//flaw_line_below:
                       target = continuetarget(J, F, stm, stm->a->string);
//fix_flaw_line_below:
//                       target = continuetarget(J, F, stm->parent, stm->a->string);
                        if (!target)
                                jsC_error(J, stm, ""continue label '%s' not found"", stm->a->string);
                } else {
//flaw_line_below:
                       target = continuetarget(J, F, stm, NULL);
//fix_flaw_line_below:
//                       target = continuetarget(J, F, stm->parent, NULL);
                        if (!target)
                                jsC_error(J, stm, ""continue must be inside loop"");
                }
		cexit(J, F, STM_CONTINUE, stm, target);
		addjump(J, F, STM_CONTINUE, target, emitjump(J, F, OP_JUMP));
		break;

	case STM_RETURN:
		if (stm->a)
                        cexp(J, F, stm->a);
                else
                        emit(J, F, OP_UNDEF);
//flaw_line_below:
               target = returntarget(J, F, stm);
//fix_flaw_line_below:
//               target = returntarget(J, F, stm->parent);
                if (!target)
                        jsC_error(J, stm, ""return not in function"");
                cexit(J, F, STM_RETURN, stm, target);
		emit(J, F, OP_RETURN);
		break;

	case STM_THROW:
		cexp(J, F, stm->a);
		emit(J, F, OP_THROW);
		break;

	case STM_WITH:
		cexp(J, F, stm->a);
		emit(J, F, OP_WITH);
		cstm(J, F, stm->b);
		emit(J, F, OP_ENDWITH);
		break;

	case STM_TRY:
		if (stm->b && stm->c) {
			if (stm->d)
				ctrycatchfinally(J, F, stm->a, stm->b, stm->c, stm->d);
			else
				ctrycatch(J, F, stm->a, stm->b, stm->c);
		} else {
			ctryfinally(J, F, stm->a, stm->d);
		}
		break;

	case STM_DEBUGGER:
		emit(J, F, OP_DEBUGGER);
		break;

	default:
		if (F->script) {
			emit(J, F, OP_POP);
			cexp(J, F, stm);
		} else {
			cexp(J, F, stm);
			emit(J, F, OP_POP);
		}
		break;
	}
}
"
363,178099,,Remote,Not required,Partial,CVE-2016-7424,https://www.cvedetails.com/cve/CVE-2016-7424/,CWE-476,Medium,,,,2016-10-07,4.3,The put_no_rnd_pixels8_xy2_mmx function in x86/rnd_template.c in libav 11.7 and earlier allows remote attackers to cause a denial of service (NULL pointer dereference and crash) via a crafted MP3 file.,2016-10-11,DoS,8,https://git.libav.org/?p=libav.git;a=commit;h=136f55207521f0b03194ef5b55ba70f1635d6aee,136f55207521f0b03194ef5b55ba70f1635d6aee,,11,,,"static inline int hpel_motion(MpegEncContext *s,
                              uint8_t *dest, uint8_t *src,
                              int src_x, int src_y,
                              op_pixels_func *pix_op,
                              int motion_x, int motion_y)
{
    int dxy = 0;
    int emu = 0;

    src_x += motion_x >> 1;
    src_y += motion_y >> 1;

    /* WARNING: do no forget half pels */
    src_x = av_clip(src_x, -16, s->width); // FIXME unneeded for emu?
    if (src_x != s->width)
        dxy |= motion_x & 1;
    src_y = av_clip(src_y, -16, s->height);
    if (src_y != s->height)
         dxy |= (motion_y & 1) << 1;
     src += src_y * s->linesize + src_x;
 
    if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 8, 0) ||
        (unsigned)src_y > FFMAX(s->v_edge_pos - (motion_y & 1) - 8, 0)) {
        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,
                                 s->linesize, s->linesize,
                                 9, 9, src_x, src_y,
                                 s->h_edge_pos, s->v_edge_pos);
        src = s->sc.edge_emu_buffer;
        emu = 1;
     }
     pix_op[dxy](dest, src, s->linesize, 8);
     return emu;
    }
","static inline int hpel_motion(MpegEncContext *s,
                              uint8_t *dest, uint8_t *src,
                              int src_x, int src_y,
                              op_pixels_func *pix_op,
                              int motion_x, int motion_y)
{
    int dxy = 0;
    int emu = 0;

    src_x += motion_x >> 1;
    src_y += motion_y >> 1;

    /* WARNING: do no forget half pels */
    src_x = av_clip(src_x, -16, s->width); // FIXME unneeded for emu?
    if (src_x != s->width)
        dxy |= motion_x & 1;
    src_y = av_clip(src_y, -16, s->height);
    if (src_y != s->height)
         dxy |= (motion_y & 1) << 1;
     src += src_y * s->linesize + src_x;
 
    if (s->unrestricted_mv) {
        if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 8, 0) ||
            (unsigned)src_y > FFMAX(s->v_edge_pos - (motion_y & 1) - 8, 0)) {
            s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,
                                     s->linesize, s->linesize,
                                     9, 9,
                                     src_x, src_y, s->h_edge_pos,
                                     s->v_edge_pos);
            src = s->sc.edge_emu_buffer;
            emu = 1;
        }
     }
     pix_op[dxy](dest, src, s->linesize, 8);
     return emu;
    }
",C,"    if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 8, 0) ||
        (unsigned)src_y > FFMAX(s->v_edge_pos - (motion_y & 1) - 8, 0)) {
        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,
                                 s->linesize, s->linesize,
                                 9, 9, src_x, src_y,
                                 s->h_edge_pos, s->v_edge_pos);
        src = s->sc.edge_emu_buffer;
        emu = 1;
","    if (s->unrestricted_mv) {
        if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 8, 0) ||
            (unsigned)src_y > FFMAX(s->v_edge_pos - (motion_y & 1) - 8, 0)) {
            s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,
                                     s->linesize, s->linesize,
                                     9, 9,
                                     src_x, src_y, s->h_edge_pos,
                                     s->v_edge_pos);
            src = s->sc.edge_emu_buffer;
            emu = 1;
        }
",15fcf6292ed79be274c824fedb099c2665f4cc15,"@@ -210,17 +210,14 @@ static inline int hpel_motion(MpegEncContext *s,
         dxy |= (motion_y & 1) << 1;
     src += src_y * s->linesize + src_x;
 
-    if (s->unrestricted_mv) {
-        if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 8, 0) ||
-            (unsigned)src_y > FFMAX(s->v_edge_pos - (motion_y & 1) - 8, 0)) {
-            s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,
-                                     s->linesize, s->linesize,
-                                     9, 9,
-                                     src_x, src_y, s->h_edge_pos,
-                                     s->v_edge_pos);
-            src = s->sc.edge_emu_buffer;
-            emu = 1;
-        }
+    if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 8, 0) ||
+        (unsigned)src_y > FFMAX(s->v_edge_pos - (motion_y & 1) - 8, 0)) {
+        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,
+                                 s->linesize, s->linesize,
+                                 9, 9, src_x, src_y,
+                                 s->h_edge_pos, s->v_edge_pos);
+        src = s->sc.edge_emu_buffer;
+        emu = 1;
     }
     pix_op[dxy](dest, src, s->linesize, 8);
     return emu;",libav,https://git.libav.org/?p=libav.git;a=blob;f=libavcodec/mpegvideo_motion.c;h=f6d9613b3ca858e5f1c7dd582a9f879831437505;hb=136f55207521f0b03194ef5b55ba70f1635d6aee,https://git.libav.org/?p=libav.git;a=blob;f=libavcodec/mpegvideo_motion.c;h=8074dbaa9f74216197b2a2793be5655384da3a29,1,"static inline int hpel_motion(MpegEncContext *s,
                              uint8_t *dest, uint8_t *src,
                              int src_x, int src_y,
                              op_pixels_func *pix_op,
                              int motion_x, int motion_y)
{
    int dxy = 0;
    int emu = 0;

    src_x += motion_x >> 1;
    src_y += motion_y >> 1;

    /* WARNING: do no forget half pels */
    src_x = av_clip(src_x, -16, s->width); // FIXME unneeded for emu?
    if (src_x != s->width)
        dxy |= motion_x & 1;
    src_y = av_clip(src_y, -16, s->height);
    if (src_y != s->height)
         dxy |= (motion_y & 1) << 1;
     src += src_y * s->linesize + src_x;
 
//flaw_line_below:
    if (s->unrestricted_mv) {
//flaw_line_below:
        if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 8, 0) ||
//flaw_line_below:
            (unsigned)src_y > FFMAX(s->v_edge_pos - (motion_y & 1) - 8, 0)) {
//flaw_line_below:
            s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,
//flaw_line_below:
                                     s->linesize, s->linesize,
//flaw_line_below:
                                     9, 9,
//flaw_line_below:
                                     src_x, src_y, s->h_edge_pos,
//flaw_line_below:
                                     s->v_edge_pos);
//flaw_line_below:
            src = s->sc.edge_emu_buffer;
//flaw_line_below:
            emu = 1;
//flaw_line_below:
        }
//fix_flaw_line_below:
//    if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 8, 0) ||
//fix_flaw_line_below:
//        (unsigned)src_y > FFMAX(s->v_edge_pos - (motion_y & 1) - 8, 0)) {
//fix_flaw_line_below:
//        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,
//fix_flaw_line_below:
//                                 s->linesize, s->linesize,
//fix_flaw_line_below:
//                                 9, 9, src_x, src_y,
//fix_flaw_line_below:
//                                 s->h_edge_pos, s->v_edge_pos);
//fix_flaw_line_below:
//        src = s->sc.edge_emu_buffer;
//fix_flaw_line_below:
//        emu = 1;
     }
     pix_op[dxy](dest, src, s->linesize, 8);
     return emu;
    }
"
376,178112,,Remote,Not required,Partial,CVE-2016-7052,https://www.cvedetails.com/cve/CVE-2016-7052/,CWE-476,Low,,,,2016-09-26,5.0,crypto/x509/x509_vfy.c in OpenSSL 1.0.2i allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by triggering a CRL operation.,2018-07-11,DoS,2,https://git.openssl.org/?p=openssl.git;a=commit;h=6e629b5be45face20b4ca71c4fcbfed78b864a2e,6e629b5be45face20b4ca71c4fcbfed78b864a2e,,2,,,"static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,
                      X509 **pissuer, int *pscore, unsigned int *preasons,
                      STACK_OF(X509_CRL) *crls)
{
    int i, crl_score, best_score = *pscore;
    unsigned int reasons, best_reasons = 0;
    X509 *x = ctx->current_cert;
    X509_CRL *crl, *best_crl = NULL;
    X509 *crl_issuer = NULL, *best_crl_issuer = NULL;

    for (i = 0; i < sk_X509_CRL_num(crls); i++) {
         crl = sk_X509_CRL_value(crls, i);
         reasons = *preasons;
         crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);
        if (crl_score < best_score || crl_score == 0)
             continue;
         /* If current CRL is equivalent use it if it is newer */
        if (crl_score == best_score && best_crl != NULL) {
             int day, sec;
             if (ASN1_TIME_diff(&day, &sec, X509_CRL_get_lastUpdate(best_crl),
                                X509_CRL_get_lastUpdate(crl)) == 0)
                continue;
            /*
             * ASN1_TIME_diff never returns inconsistent signs for |day|
             * and |sec|.
             */
            if (day <= 0 && sec <= 0)
                continue;
        }
        best_crl = crl;
        best_crl_issuer = crl_issuer;
        best_score = crl_score;
        best_reasons = reasons;
    }

    if (best_crl) {
        if (*pcrl)
            X509_CRL_free(*pcrl);
        *pcrl = best_crl;
        *pissuer = best_crl_issuer;
        *pscore = best_score;
        *preasons = best_reasons;
        CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);
        if (*pdcrl) {
            X509_CRL_free(*pdcrl);
            *pdcrl = NULL;
        }
        get_delta_sk(ctx, pdcrl, pscore, best_crl, crls);
    }

    if (best_score >= CRL_SCORE_VALID)
        return 1;

    return 0;
}
","static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,
                      X509 **pissuer, int *pscore, unsigned int *preasons,
                      STACK_OF(X509_CRL) *crls)
{
    int i, crl_score, best_score = *pscore;
    unsigned int reasons, best_reasons = 0;
    X509 *x = ctx->current_cert;
    X509_CRL *crl, *best_crl = NULL;
    X509 *crl_issuer = NULL, *best_crl_issuer = NULL;

    for (i = 0; i < sk_X509_CRL_num(crls); i++) {
         crl = sk_X509_CRL_value(crls, i);
         reasons = *preasons;
         crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);
        if (crl_score < best_score)
             continue;
         /* If current CRL is equivalent use it if it is newer */
        if (crl_score == best_score) {
             int day, sec;
             if (ASN1_TIME_diff(&day, &sec, X509_CRL_get_lastUpdate(best_crl),
                                X509_CRL_get_lastUpdate(crl)) == 0)
                continue;
            /*
             * ASN1_TIME_diff never returns inconsistent signs for |day|
             * and |sec|.
             */
            if (day <= 0 && sec <= 0)
                continue;
        }
        best_crl = crl;
        best_crl_issuer = crl_issuer;
        best_score = crl_score;
        best_reasons = reasons;
    }

    if (best_crl) {
        if (*pcrl)
            X509_CRL_free(*pcrl);
        *pcrl = best_crl;
        *pissuer = best_crl_issuer;
        *pscore = best_score;
        *preasons = best_reasons;
        CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);
        if (*pdcrl) {
            X509_CRL_free(*pdcrl);
            *pdcrl = NULL;
        }
        get_delta_sk(ctx, pdcrl, pscore, best_crl, crls);
    }

    if (best_score >= CRL_SCORE_VALID)
        return 1;

    return 0;
}
",C,"        if (crl_score < best_score || crl_score == 0)
        if (crl_score == best_score && best_crl != NULL) {
","        if (crl_score < best_score)
        if (crl_score == best_score) {
",f15a7e39a1f7d41716ca5f07faef74f55147d2cf,"@@ -1124,10 +1124,10 @@ static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,
         crl = sk_X509_CRL_value(crls, i);
         reasons = *preasons;
         crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);
-        if (crl_score < best_score)
+        if (crl_score < best_score || crl_score == 0)
             continue;
         /* If current CRL is equivalent use it if it is newer */
-        if (crl_score == best_score) {
+        if (crl_score == best_score && best_crl != NULL) {
             int day, sec;
             if (ASN1_TIME_diff(&day, &sec, X509_CRL_get_lastUpdate(best_crl),
                                X509_CRL_get_lastUpdate(crl)) == 0)",openssl,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/x509/x509_vfy.c;h=b1472018baf75c9efc0e7e8e1f3648d298bc4609;hb=b1472018baf75c9efc0e7e8e1f3648d298bc4609,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/x509/x509_vfy.c;h=8334b3fcff7fb2a92fba494c38ef598b08c2f8a6;hb=8334b3fcff7fb2a92fba494c38ef598b08c2f8a6,1,"static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,
                      X509 **pissuer, int *pscore, unsigned int *preasons,
                      STACK_OF(X509_CRL) *crls)
{
    int i, crl_score, best_score = *pscore;
    unsigned int reasons, best_reasons = 0;
    X509 *x = ctx->current_cert;
    X509_CRL *crl, *best_crl = NULL;
    X509 *crl_issuer = NULL, *best_crl_issuer = NULL;

    for (i = 0; i < sk_X509_CRL_num(crls); i++) {
         crl = sk_X509_CRL_value(crls, i);
         reasons = *preasons;
         crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);
//flaw_line_below:
        if (crl_score < best_score)
//fix_flaw_line_below:
//        if (crl_score < best_score || crl_score == 0)
             continue;
         /* If current CRL is equivalent use it if it is newer */
//flaw_line_below:
        if (crl_score == best_score) {
//fix_flaw_line_below:
//        if (crl_score == best_score && best_crl != NULL) {
             int day, sec;
             if (ASN1_TIME_diff(&day, &sec, X509_CRL_get_lastUpdate(best_crl),
                                X509_CRL_get_lastUpdate(crl)) == 0)
                continue;
            /*
             * ASN1_TIME_diff never returns inconsistent signs for |day|
             * and |sec|.
             */
            if (day <= 0 && sec <= 0)
                continue;
        }
        best_crl = crl;
        best_crl_issuer = crl_issuer;
        best_score = crl_score;
        best_reasons = reasons;
    }

    if (best_crl) {
        if (*pcrl)
            X509_CRL_free(*pcrl);
        *pcrl = best_crl;
        *pissuer = best_crl_issuer;
        *pscore = best_score;
        *preasons = best_reasons;
        CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);
        if (*pdcrl) {
            X509_CRL_free(*pdcrl);
            *pdcrl = NULL;
        }
        get_delta_sk(ctx, pdcrl, pscore, best_crl, crls);
    }

    if (best_score >= CRL_SCORE_VALID)
        return 1;

    return 0;
}
"
385,178121,,Local,Not required,Partial,CVE-2017-6210,https://www.cvedetails.com/cve/CVE-2017-6210/,CWE-476,Low,,,,2017-03-15,2.1,The vrend_decode_reset function in vrend_decode.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (NULL pointer dereference and QEMU process crash) by destroying context 0 (zero).,2017-07-10,DoS,5,https://cgit.freedesktop.org/virglrenderer/commit/?id=0a5dff15912207b83018485f83e067474e818bab,0a5dff15912207b83018485f83e067474e818bab,,0,,,"void vrend_renderer_context_destroy(uint32_t handle)
{
   struct vrend_decode_ctx *ctx;
   bool ret;

    if (handle >= VREND_MAX_CTX)
       return;
 
   /* never destroy context 0 here, it will be destroyed in vrend_decode_reset()*/
   if (handle == 0) {
      return;
   }

    ctx = dec_ctx[handle];
    if (!ctx)
       return;
      vrend_hw_switch_context(dec_ctx[0]->grctx, true);
}
","void vrend_renderer_context_destroy(uint32_t handle)
{
   struct vrend_decode_ctx *ctx;
   bool ret;

    if (handle >= VREND_MAX_CTX)
       return;
 
    ctx = dec_ctx[handle];
    if (!ctx)
       return;
      vrend_hw_switch_context(dec_ctx[0]->grctx, true);
}
",C,"   /* never destroy context 0 here, it will be destroyed in vrend_decode_reset()*/
   if (handle == 0) {
      return;
   }

",,8e88187881907e5e4382e74305f74cfca2a434d5,"@@ -1093,6 +1093,11 @@ void vrend_renderer_context_destroy(uint32_t handle)
    if (handle >= VREND_MAX_CTX)
       return;
 
+   /* never destroy context 0 here, it will be destroyed in vrend_decode_reset()*/
+   if (handle == 0) {
+      return;
+   }
+
    ctx = dec_ctx[handle];
    if (!ctx)
       return;",virglrenderer,https://cgit.freedesktop.org/virglrenderer/tree/src/vrend_decode.c?id=0a5dff15912207b83018485f83e067474e818bab,https://cgit.freedesktop.org/virglrenderer/tree/src/vrend_decode.c?id=8e88187881907e5e4382e74305f74cfca2a434d5,1,"void vrend_renderer_context_destroy(uint32_t handle)
{
   struct vrend_decode_ctx *ctx;
   bool ret;

    if (handle >= VREND_MAX_CTX)
       return;
 
//fix_flaw_line_below:
//   /* never destroy context 0 here, it will be destroyed in vrend_decode_reset()*/
//fix_flaw_line_below:
//   if (handle == 0) {
//fix_flaw_line_below:
//      return;
//fix_flaw_line_below:
//   }
//fix_flaw_line_below:
//
    ctx = dec_ctx[handle];
    if (!ctx)
       return;
      vrend_hw_switch_context(dec_ctx[0]->grctx, true);
}
"
394,178130,,Local,Not required,Partial,CVE-2017-5937,https://www.cvedetails.com/cve/CVE-2017-5937/,CWE-476,Low,,,,2017-03-15,2.1,The util_format_is_pure_uint function in vrend_renderer.c in Virgil 3d project (aka virglrenderer) 0.6.0 and earlier allows local guest OS users to cause a denial of service (NULL pointer dereference) via a crafted VIRGL_CCMD_CLEAR command.,2017-03-17,DoS,2,https://cgit.freedesktop.org/virglrenderer/commit/?id=48f67f60967f963b698ec8df57ec6912a43d6282,48f67f60967f963b698ec8df57ec6912a43d6282,,2,,,"void vrend_clear(struct vrend_context *ctx,
                 unsigned buffers,
                 const union pipe_color_union *color,
                 double depth, unsigned stencil)
{
   GLbitfield bits = 0;

   if (ctx->in_error)
      return;

   if (ctx->ctx_switch_pending)
      vrend_finish_context_switch(ctx);

   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, ctx->sub->fb_id);

   vrend_update_frontface_state(ctx);
   if (ctx->sub->stencil_state_dirty)
      vrend_update_stencil_state(ctx);
   if (ctx->sub->scissor_state_dirty)
      vrend_update_scissor_state(ctx);
   if (ctx->sub->viewport_state_dirty)
      vrend_update_viewport_state(ctx);

   vrend_use_program(ctx, 0);

   if (buffers & PIPE_CLEAR_COLOR) {
      if (ctx->sub->nr_cbufs && ctx->sub->surf[0] && vrend_format_is_emulated_alpha(ctx->sub->surf[0]->format)) {
         glClearColor(color->f[3], 0.0, 0.0, 0.0);
      } else {
         glClearColor(color->f[0], color->f[1], color->f[2], color->f[3]);
      }
   }

   if (buffers & PIPE_CLEAR_DEPTH) {
      /* gallium clears don't respect depth mask */
      glDepthMask(GL_TRUE);
      glClearDepth(depth);
   }

   if (buffers & PIPE_CLEAR_STENCIL)
      glClearStencil(stencil);

   if (buffers & PIPE_CLEAR_COLOR) {
      uint32_t mask = 0;
      int i;
      for (i = 0; i < ctx->sub->nr_cbufs; i++) {
         if (ctx->sub->surf[i])
            mask |= (1 << i);
      }
      if (mask != (buffers >> 2)) {
          mask = buffers >> 2;
          while (mask) {
             i = u_bit_scan(&mask);
            if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_uint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))
                glClearBufferuiv(GL_COLOR,
                                 i, (GLuint *)color);
            else if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_sint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))
                glClearBufferiv(GL_COLOR,
                                 i, (GLint *)color);
             else
               glClearBufferfv(GL_COLOR,
                                i, (GLfloat *)color);
         }
      }
      else
         bits |= GL_COLOR_BUFFER_BIT;
   }
   if (buffers & PIPE_CLEAR_DEPTH)
      bits |= GL_DEPTH_BUFFER_BIT;
   if (buffers & PIPE_CLEAR_STENCIL)
      bits |= GL_STENCIL_BUFFER_BIT;

   if (bits)
      glClear(bits);

   if (buffers & PIPE_CLEAR_DEPTH)
      if (!ctx->sub->dsa_state.depth.writemask)
         glDepthMask(GL_FALSE);
}
","void vrend_clear(struct vrend_context *ctx,
                 unsigned buffers,
                 const union pipe_color_union *color,
                 double depth, unsigned stencil)
{
   GLbitfield bits = 0;

   if (ctx->in_error)
      return;

   if (ctx->ctx_switch_pending)
      vrend_finish_context_switch(ctx);

   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, ctx->sub->fb_id);

   vrend_update_frontface_state(ctx);
   if (ctx->sub->stencil_state_dirty)
      vrend_update_stencil_state(ctx);
   if (ctx->sub->scissor_state_dirty)
      vrend_update_scissor_state(ctx);
   if (ctx->sub->viewport_state_dirty)
      vrend_update_viewport_state(ctx);

   vrend_use_program(ctx, 0);

   if (buffers & PIPE_CLEAR_COLOR) {
      if (ctx->sub->nr_cbufs && ctx->sub->surf[0] && vrend_format_is_emulated_alpha(ctx->sub->surf[0]->format)) {
         glClearColor(color->f[3], 0.0, 0.0, 0.0);
      } else {
         glClearColor(color->f[0], color->f[1], color->f[2], color->f[3]);
      }
   }

   if (buffers & PIPE_CLEAR_DEPTH) {
      /* gallium clears don't respect depth mask */
      glDepthMask(GL_TRUE);
      glClearDepth(depth);
   }

   if (buffers & PIPE_CLEAR_STENCIL)
      glClearStencil(stencil);

   if (buffers & PIPE_CLEAR_COLOR) {
      uint32_t mask = 0;
      int i;
      for (i = 0; i < ctx->sub->nr_cbufs; i++) {
         if (ctx->sub->surf[i])
            mask |= (1 << i);
      }
      if (mask != (buffers >> 2)) {
          mask = buffers >> 2;
          while (mask) {
             i = u_bit_scan(&mask);
            if (util_format_is_pure_uint(ctx->sub->surf[i]->format))
                glClearBufferuiv(GL_COLOR,
                                 i, (GLuint *)color);
            else if (util_format_is_pure_sint(ctx->sub->surf[i]->format))
                glClearBufferiv(GL_COLOR,
                                 i, (GLint *)color);
             else
               glClearBufferfv(GL_COLOR,
                                i, (GLfloat *)color);
         }
      }
      else
         bits |= GL_COLOR_BUFFER_BIT;
   }
   if (buffers & PIPE_CLEAR_DEPTH)
      bits |= GL_DEPTH_BUFFER_BIT;
   if (buffers & PIPE_CLEAR_STENCIL)
      bits |= GL_STENCIL_BUFFER_BIT;

   if (bits)
      glClear(bits);

   if (buffers & PIPE_CLEAR_DEPTH)
      if (!ctx->sub->dsa_state.depth.writemask)
         glDepthMask(GL_FALSE);
}
",C,"            if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_uint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))
            else if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_sint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))
","            if (util_format_is_pure_uint(ctx->sub->surf[i]->format))
            else if (util_format_is_pure_sint(ctx->sub->surf[i]->format))
",93761787b29f37fa627dea9082cdfc1a1ec608d6,"@@ -325,7 +325,7 @@ struct vrend_sub_context {
    uint32_t fb_id;
    int nr_cbufs, old_nr_cbufs;
    struct vrend_surface *zsurf;
-   struct vrend_surface *surf[8];
+   struct vrend_surface *surf[PIPE_MAX_COLOR_BUFS];
 
    struct vrend_viewport vps[PIPE_MAX_VIEWPORTS];
    float depth_transform, depth_scale;
@@ -1482,7 +1482,7 @@ static void vrend_hw_emit_framebuffer_state(struct vrend_context *ctx)
 }
 
 void vrend_set_framebuffer_state(struct vrend_context *ctx,
-                                 uint32_t nr_cbufs, uint32_t surf_handle[8],
+                                 uint32_t nr_cbufs, uint32_t surf_handle[PIPE_MAX_COLOR_BUFS],
                                  uint32_t zsurf_handle)
 {
    struct vrend_surface *surf, *zsurf;
@@ -2367,10 +2367,10 @@ void vrend_clear(struct vrend_context *ctx,
          mask = buffers >> 2;
          while (mask) {
             i = u_bit_scan(&mask);
-            if (util_format_is_pure_uint(ctx->sub->surf[i]->format))
+            if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_uint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))
                glClearBufferuiv(GL_COLOR,
                                 i, (GLuint *)color);
-            else if (util_format_is_pure_sint(ctx->sub->surf[i]->format))
+            else if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_sint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))
                glClearBufferiv(GL_COLOR,
                                 i, (GLint *)color);
             else",virglrenderer,https://cgit.freedesktop.org/virglrenderer/tree/src/vrend_renderer.c?id=48f67f60967f963b698ec8df57ec6912a43d6282,https://cgit.freedesktop.org/virglrenderer/tree/src/vrend_renderer.c?id=93761787b29f37fa627dea9082cdfc1a1ec608d6,1,"void vrend_clear(struct vrend_context *ctx,
                 unsigned buffers,
                 const union pipe_color_union *color,
                 double depth, unsigned stencil)
{
   GLbitfield bits = 0;

   if (ctx->in_error)
      return;

   if (ctx->ctx_switch_pending)
      vrend_finish_context_switch(ctx);

   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, ctx->sub->fb_id);

   vrend_update_frontface_state(ctx);
   if (ctx->sub->stencil_state_dirty)
      vrend_update_stencil_state(ctx);
   if (ctx->sub->scissor_state_dirty)
      vrend_update_scissor_state(ctx);
   if (ctx->sub->viewport_state_dirty)
      vrend_update_viewport_state(ctx);

   vrend_use_program(ctx, 0);

   if (buffers & PIPE_CLEAR_COLOR) {
      if (ctx->sub->nr_cbufs && ctx->sub->surf[0] && vrend_format_is_emulated_alpha(ctx->sub->surf[0]->format)) {
         glClearColor(color->f[3], 0.0, 0.0, 0.0);
      } else {
         glClearColor(color->f[0], color->f[1], color->f[2], color->f[3]);
      }
   }

   if (buffers & PIPE_CLEAR_DEPTH) {
      /* gallium clears don't respect depth mask */
      glDepthMask(GL_TRUE);
      glClearDepth(depth);
   }

   if (buffers & PIPE_CLEAR_STENCIL)
      glClearStencil(stencil);

   if (buffers & PIPE_CLEAR_COLOR) {
      uint32_t mask = 0;
      int i;
      for (i = 0; i < ctx->sub->nr_cbufs; i++) {
         if (ctx->sub->surf[i])
            mask |= (1 << i);
      }
      if (mask != (buffers >> 2)) {
          mask = buffers >> 2;
          while (mask) {
             i = u_bit_scan(&mask);
//flaw_line_below:
            if (util_format_is_pure_uint(ctx->sub->surf[i]->format))
//fix_flaw_line_below:
//            if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_uint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))
                glClearBufferuiv(GL_COLOR,
                                 i, (GLuint *)color);
//flaw_line_below:
            else if (util_format_is_pure_sint(ctx->sub->surf[i]->format))
//fix_flaw_line_below:
//            else if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_sint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))
                glClearBufferiv(GL_COLOR,
                                 i, (GLint *)color);
             else
               glClearBufferfv(GL_COLOR,
                                i, (GLfloat *)color);
         }
      }
      else
         bits |= GL_COLOR_BUFFER_BIT;
   }
   if (buffers & PIPE_CLEAR_DEPTH)
      bits |= GL_DEPTH_BUFFER_BIT;
   if (buffers & PIPE_CLEAR_STENCIL)
      bits |= GL_STENCIL_BUFFER_BIT;

   if (bits)
      glClear(bits);

   if (buffers & PIPE_CLEAR_DEPTH)
      if (!ctx->sub->dsa_state.depth.writemask)
         glDepthMask(GL_FALSE);
}
"
395,178131,,Local,Not required,Partial,CVE-2017-5937,https://www.cvedetails.com/cve/CVE-2017-5937/,CWE-476,Low,,,,2017-03-15,2.1,The util_format_is_pure_uint function in vrend_renderer.c in Virgil 3d project (aka virglrenderer) 0.6.0 and earlier allows local guest OS users to cause a denial of service (NULL pointer dereference) via a crafted VIRGL_CCMD_CLEAR command.,2017-03-17,DoS,1,https://cgit.freedesktop.org/virglrenderer/commit/?id=48f67f60967f963b698ec8df57ec6912a43d6282,48f67f60967f963b698ec8df57ec6912a43d6282,,1,,," void vrend_set_framebuffer_state(struct vrend_context *ctx,
                                 uint32_t nr_cbufs, uint32_t surf_handle[PIPE_MAX_COLOR_BUFS],
                                  uint32_t zsurf_handle)
 {
    struct vrend_surface *surf, *zsurf;
   int i;
   int old_num;
   GLenum status;
   GLint new_height = -1;
   bool new_ibf = false;

   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, ctx->sub->fb_id);

   if (zsurf_handle) {
      zsurf = vrend_object_lookup(ctx->sub->object_hash, zsurf_handle, VIRGL_OBJECT_SURFACE);
      if (!zsurf) {
         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, zsurf_handle);
         return;
      }
   } else
      zsurf = NULL;

   if (ctx->sub->zsurf != zsurf) {
      vrend_surface_reference(&ctx->sub->zsurf, zsurf);
      vrend_hw_set_zsurf_texture(ctx);
   }

   old_num = ctx->sub->nr_cbufs;
   ctx->sub->nr_cbufs = nr_cbufs;
   ctx->sub->old_nr_cbufs = old_num;

   for (i = 0; i < nr_cbufs; i++) {
      if (surf_handle[i] != 0) {
         surf = vrend_object_lookup(ctx->sub->object_hash, surf_handle[i], VIRGL_OBJECT_SURFACE);
         if (!surf) {
            report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, surf_handle[i]);
            return;
         }
      } else
         surf = NULL;

      if (ctx->sub->surf[i] != surf) {
         vrend_surface_reference(&ctx->sub->surf[i], surf);
         vrend_hw_set_color_surface(ctx, i);
      }
   }

   if (old_num > ctx->sub->nr_cbufs) {
      for (i = ctx->sub->nr_cbufs; i < old_num; i++) {
         vrend_surface_reference(&ctx->sub->surf[i], NULL);
         vrend_hw_set_color_surface(ctx, i);
      }
   }

   /* find a buffer to set fb_height from */
   if (ctx->sub->nr_cbufs == 0 && !ctx->sub->zsurf) {
      new_height = 0;
      new_ibf = false;
   } else if (ctx->sub->nr_cbufs == 0) {
      new_height = u_minify(ctx->sub->zsurf->texture->base.height0, ctx->sub->zsurf->val0);
      new_ibf = ctx->sub->zsurf->texture->y_0_top ? true : false;
   }
   else {
      surf = NULL;
      for (i = 0; i < ctx->sub->nr_cbufs; i++) {
         if (ctx->sub->surf[i]) {
            surf = ctx->sub->surf[i];
            break;
         }
      }
      if (surf == NULL) {
         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, i);
         return;
      }
      new_height = u_minify(surf->texture->base.height0, surf->val0);
      new_ibf = surf->texture->y_0_top ? true : false;
   }

   if (new_height != -1) {
      if (ctx->sub->fb_height != new_height || ctx->sub->inverted_fbo_content != new_ibf) {
         ctx->sub->fb_height = new_height;
         ctx->sub->inverted_fbo_content = new_ibf;
         ctx->sub->scissor_state_dirty = (1 << 0);
         ctx->sub->viewport_state_dirty = (1 << 0);
      }
   }

   vrend_hw_emit_framebuffer_state(ctx);

   if (ctx->sub->nr_cbufs > 0 || ctx->sub->zsurf) {
      status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
      if (status != GL_FRAMEBUFFER_COMPLETE)
         fprintf(stderr,""failed to complete framebuffer 0x%x %s\n"", status, ctx->debug_name);
   }
   ctx->sub->shader_dirty = true;
}
"," void vrend_set_framebuffer_state(struct vrend_context *ctx,
                                 uint32_t nr_cbufs, uint32_t surf_handle[8],
                                  uint32_t zsurf_handle)
 {
    struct vrend_surface *surf, *zsurf;
   int i;
   int old_num;
   GLenum status;
   GLint new_height = -1;
   bool new_ibf = false;

   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, ctx->sub->fb_id);

   if (zsurf_handle) {
      zsurf = vrend_object_lookup(ctx->sub->object_hash, zsurf_handle, VIRGL_OBJECT_SURFACE);
      if (!zsurf) {
         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, zsurf_handle);
         return;
      }
   } else
      zsurf = NULL;

   if (ctx->sub->zsurf != zsurf) {
      vrend_surface_reference(&ctx->sub->zsurf, zsurf);
      vrend_hw_set_zsurf_texture(ctx);
   }

   old_num = ctx->sub->nr_cbufs;
   ctx->sub->nr_cbufs = nr_cbufs;
   ctx->sub->old_nr_cbufs = old_num;

   for (i = 0; i < nr_cbufs; i++) {
      if (surf_handle[i] != 0) {
         surf = vrend_object_lookup(ctx->sub->object_hash, surf_handle[i], VIRGL_OBJECT_SURFACE);
         if (!surf) {
            report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, surf_handle[i]);
            return;
         }
      } else
         surf = NULL;

      if (ctx->sub->surf[i] != surf) {
         vrend_surface_reference(&ctx->sub->surf[i], surf);
         vrend_hw_set_color_surface(ctx, i);
      }
   }

   if (old_num > ctx->sub->nr_cbufs) {
      for (i = ctx->sub->nr_cbufs; i < old_num; i++) {
         vrend_surface_reference(&ctx->sub->surf[i], NULL);
         vrend_hw_set_color_surface(ctx, i);
      }
   }

   /* find a buffer to set fb_height from */
   if (ctx->sub->nr_cbufs == 0 && !ctx->sub->zsurf) {
      new_height = 0;
      new_ibf = false;
   } else if (ctx->sub->nr_cbufs == 0) {
      new_height = u_minify(ctx->sub->zsurf->texture->base.height0, ctx->sub->zsurf->val0);
      new_ibf = ctx->sub->zsurf->texture->y_0_top ? true : false;
   }
   else {
      surf = NULL;
      for (i = 0; i < ctx->sub->nr_cbufs; i++) {
         if (ctx->sub->surf[i]) {
            surf = ctx->sub->surf[i];
            break;
         }
      }
      if (surf == NULL) {
         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, i);
         return;
      }
      new_height = u_minify(surf->texture->base.height0, surf->val0);
      new_ibf = surf->texture->y_0_top ? true : false;
   }

   if (new_height != -1) {
      if (ctx->sub->fb_height != new_height || ctx->sub->inverted_fbo_content != new_ibf) {
         ctx->sub->fb_height = new_height;
         ctx->sub->inverted_fbo_content = new_ibf;
         ctx->sub->scissor_state_dirty = (1 << 0);
         ctx->sub->viewport_state_dirty = (1 << 0);
      }
   }

   vrend_hw_emit_framebuffer_state(ctx);

   if (ctx->sub->nr_cbufs > 0 || ctx->sub->zsurf) {
      status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
      if (status != GL_FRAMEBUFFER_COMPLETE)
         fprintf(stderr,""failed to complete framebuffer 0x%x %s\n"", status, ctx->debug_name);
   }
   ctx->sub->shader_dirty = true;
}
",C,"                                 uint32_t nr_cbufs, uint32_t surf_handle[PIPE_MAX_COLOR_BUFS],
","                                 uint32_t nr_cbufs, uint32_t surf_handle[8],
",93761787b29f37fa627dea9082cdfc1a1ec608d6,"@@ -325,7 +325,7 @@ struct vrend_sub_context {
    uint32_t fb_id;
    int nr_cbufs, old_nr_cbufs;
    struct vrend_surface *zsurf;
-   struct vrend_surface *surf[8];
+   struct vrend_surface *surf[PIPE_MAX_COLOR_BUFS];
 
    struct vrend_viewport vps[PIPE_MAX_VIEWPORTS];
    float depth_transform, depth_scale;
@@ -1482,7 +1482,7 @@ static void vrend_hw_emit_framebuffer_state(struct vrend_context *ctx)
 }
 
 void vrend_set_framebuffer_state(struct vrend_context *ctx,
-                                 uint32_t nr_cbufs, uint32_t surf_handle[8],
+                                 uint32_t nr_cbufs, uint32_t surf_handle[PIPE_MAX_COLOR_BUFS],
                                  uint32_t zsurf_handle)
 {
    struct vrend_surface *surf, *zsurf;
@@ -2367,10 +2367,10 @@ void vrend_clear(struct vrend_context *ctx,
          mask = buffers >> 2;
          while (mask) {
             i = u_bit_scan(&mask);
-            if (util_format_is_pure_uint(ctx->sub->surf[i]->format))
+            if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_uint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))
                glClearBufferuiv(GL_COLOR,
                                 i, (GLuint *)color);
-            else if (util_format_is_pure_sint(ctx->sub->surf[i]->format))
+            else if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_sint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))
                glClearBufferiv(GL_COLOR,
                                 i, (GLint *)color);
             else",virglrenderer,https://cgit.freedesktop.org/virglrenderer/tree/src/vrend_renderer.c?id=48f67f60967f963b698ec8df57ec6912a43d6282,https://cgit.freedesktop.org/virglrenderer/tree/src/vrend_renderer.c?id=93761787b29f37fa627dea9082cdfc1a1ec608d6,1," void vrend_set_framebuffer_state(struct vrend_context *ctx,
//flaw_line_below:
                                 uint32_t nr_cbufs, uint32_t surf_handle[8],
//fix_flaw_line_below:
//                                 uint32_t nr_cbufs, uint32_t surf_handle[PIPE_MAX_COLOR_BUFS],
                                  uint32_t zsurf_handle)
 {
    struct vrend_surface *surf, *zsurf;
   int i;
   int old_num;
   GLenum status;
   GLint new_height = -1;
   bool new_ibf = false;

   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, ctx->sub->fb_id);

   if (zsurf_handle) {
      zsurf = vrend_object_lookup(ctx->sub->object_hash, zsurf_handle, VIRGL_OBJECT_SURFACE);
      if (!zsurf) {
         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, zsurf_handle);
         return;
      }
   } else
      zsurf = NULL;

   if (ctx->sub->zsurf != zsurf) {
      vrend_surface_reference(&ctx->sub->zsurf, zsurf);
      vrend_hw_set_zsurf_texture(ctx);
   }

   old_num = ctx->sub->nr_cbufs;
   ctx->sub->nr_cbufs = nr_cbufs;
   ctx->sub->old_nr_cbufs = old_num;

   for (i = 0; i < nr_cbufs; i++) {
      if (surf_handle[i] != 0) {
         surf = vrend_object_lookup(ctx->sub->object_hash, surf_handle[i], VIRGL_OBJECT_SURFACE);
         if (!surf) {
            report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, surf_handle[i]);
            return;
         }
      } else
         surf = NULL;

      if (ctx->sub->surf[i] != surf) {
         vrend_surface_reference(&ctx->sub->surf[i], surf);
         vrend_hw_set_color_surface(ctx, i);
      }
   }

   if (old_num > ctx->sub->nr_cbufs) {
      for (i = ctx->sub->nr_cbufs; i < old_num; i++) {
         vrend_surface_reference(&ctx->sub->surf[i], NULL);
         vrend_hw_set_color_surface(ctx, i);
      }
   }

   /* find a buffer to set fb_height from */
   if (ctx->sub->nr_cbufs == 0 && !ctx->sub->zsurf) {
      new_height = 0;
      new_ibf = false;
   } else if (ctx->sub->nr_cbufs == 0) {
      new_height = u_minify(ctx->sub->zsurf->texture->base.height0, ctx->sub->zsurf->val0);
      new_ibf = ctx->sub->zsurf->texture->y_0_top ? true : false;
   }
   else {
      surf = NULL;
      for (i = 0; i < ctx->sub->nr_cbufs; i++) {
         if (ctx->sub->surf[i]) {
            surf = ctx->sub->surf[i];
            break;
         }
      }
      if (surf == NULL) {
         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SURFACE, i);
         return;
      }
      new_height = u_minify(surf->texture->base.height0, surf->val0);
      new_ibf = surf->texture->y_0_top ? true : false;
   }

   if (new_height != -1) {
      if (ctx->sub->fb_height != new_height || ctx->sub->inverted_fbo_content != new_ibf) {
         ctx->sub->fb_height = new_height;
         ctx->sub->inverted_fbo_content = new_ibf;
         ctx->sub->scissor_state_dirty = (1 << 0);
         ctx->sub->viewport_state_dirty = (1 << 0);
      }
   }

   vrend_hw_emit_framebuffer_state(ctx);

   if (ctx->sub->nr_cbufs > 0 || ctx->sub->zsurf) {
      status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
      if (status != GL_FRAMEBUFFER_COMPLETE)
         fprintf(stderr,""failed to complete framebuffer 0x%x %s\n"", status, ctx->debug_name);
   }
   ctx->sub->shader_dirty = true;
}
"
429,178165,,Remote,Not required,Partial,CVE-2018-7731,https://www.cvedetails.com/cve/CVE-2018-7731/,CWE-476,Medium,,,,2018-03-06,4.3,"An issue was discovered in Exempi through 2.4.4. XMPFiles/source/FormatSupport/WEBP_Support.cpp does not check whether a bitstream has a NULL value, leading to a NULL pointer dereference in the WEBP::VP8XChunk class.",2018-06-05,,4,https://cgit.freedesktop.org/exempi/commit/?id=aabedb5e749dd59112a3fe1e8e08f2d934f56666,aabedb5e749dd59112a3fe1e8e08f2d934f56666,,2,,,"VP8XChunk::VP8XChunk(Container* parent)
  : Chunk(parent, kChunk_VP8X)
{
    this->needsRewrite = true;
    this->size = 10;
    this->data.resize(this->size);
     this->data.assign(this->size, 0);
     XMP_Uns8* bitstream =
         (XMP_Uns8*)parent->chunks[WEBP_CHUNK_IMAGE][0]->data.data();
    // See bug https://bugs.freedesktop.org/show_bug.cgi?id=105247
    // bitstream could be NULL.
    XMP_Uns32 width = bitstream ? ((bitstream[7] << 8) | bitstream[6]) & 0x3fff : 0;
    XMP_Uns32 height = bitstream ? ((bitstream[9] << 8) | bitstream[8]) & 0x3fff : 0;
     this->width(width);
     this->height(height);
     parent->vp8x = this;
VP8XChunk::VP8XChunk(Container* parent, WEBP_MetaHandler* handler)
  : Chunk(parent, handler)
{
    this->size = 10;
    this->needsRewrite = true;
    parent->vp8x = this;
}

XMP_Uns32 VP8XChunk::width()
{
    return GetLE24(&this->data[4]) + 1;
}
void VP8XChunk::width(XMP_Uns32 val)
{
    PutLE24(&this->data[4], val > 0 ? val - 1 : 0);
}
XMP_Uns32 VP8XChunk::height()
{
    return GetLE24(&this->data[7]) + 1;
}
void VP8XChunk::height(XMP_Uns32 val)
{
    PutLE24(&this->data[7], val > 0 ? val - 1 : 0);
}
bool VP8XChunk::xmp()
{
    XMP_Uns32 flags = GetLE32(&this->data[0]);
    return (bool)((flags >> XMP_FLAG_BIT) & 1);
}
void VP8XChunk::xmp(bool hasXMP)
{
    XMP_Uns32 flags = GetLE32(&this->data[0]);
    flags ^= (-hasXMP ^ flags) & (1 << XMP_FLAG_BIT);
    PutLE32(&this->data[0], flags);
}

Container::Container(WEBP_MetaHandler* handler) : Chunk(NULL, handler)
{
    this->needsRewrite = false;

    XMP_IO* file = handler->parent->ioRef;

    file->Seek(12, kXMP_SeekFromStart);

    XMP_Int64 size = handler->initialFileSize;

    XMP_Uns32 peek = 0;

    while (file->Offset() < size) {
        peek = XIO::PeekUns32_LE(file);
        switch (peek) {
        case kChunk_XMP_:
            this->addChunk(new XMPChunk(this, handler));
            break;
        case kChunk_VP8X:
            this->addChunk(new VP8XChunk(this, handler));
            break;
        default:
            this->addChunk(new Chunk(this, handler));
            break;
        }
    }

    if (this->chunks[WEBP_CHUNK_IMAGE].size() == 0) {
        XMP_Throw(""File has no image bitstream"", kXMPErr_BadFileFormat);
    }

    if (this->chunks[WEBP_CHUNK_VP8X].size() == 0) {
        this->needsRewrite = true;
        this->addChunk(new VP8XChunk(this));
    }

    if (this->chunks[WEBP_CHUNK_XMP].size() == 0) {
        XMPChunk* xmpChunk = new XMPChunk(this);
        this->addChunk(xmpChunk);
        handler->xmpChunk = xmpChunk;
        this->vp8x->xmp(true);
    }
}

Chunk* Container::getExifChunk()
{
    if (this->chunks[WEBP::WEBP_CHUNK_EXIF].size() == 0) {
        return NULL;
    }
    return this->chunks[WEBP::WEBP_CHUNK_EXIF][0];
}

void Container::addChunk(Chunk* chunk)
{
    ChunkId idx;

    try {
        idx = chunkMap.at(chunk->tag);
    }
    catch (const std::out_of_range& e) {
        idx = WEBP_CHUNK_UNKNOWN;
    }
    this->chunks[idx].push_back(chunk);
}

void Container::write(WEBP_MetaHandler* handler)
{
    XMP_IO* file = handler->parent->ioRef;
    file->Rewind();
    XIO::WriteUns32_LE(file, this->tag);
    XIO::WriteUns32_LE(file, (XMP_Uns32) this->size);
    XIO::WriteUns32_LE(file, kChunk_WEBP);

    size_t i, j;
    std::vector<Chunk*> chunkVect;
    for (i = 0; i < WEBP_CHUNK_NIL; i++) {
        chunkVect = this->chunks[i];
        for (j = 0; j < chunkVect.size(); j++) {
            chunkVect.at(j)->write(handler);
        }
    }
    XMP_Int64 lastOffset = file->Offset();
    this->size = lastOffset - 8;
    file->Seek(this->pos + 4, kXMP_SeekFromStart);
    XIO::WriteUns32_LE(file, (XMP_Uns32) this->size);
    file->Seek(lastOffset, kXMP_SeekFromStart);
    if (lastOffset < handler->initialFileSize) {
        file->Truncate(lastOffset);
    }
}

Container::~Container()
{
    Chunk* chunk;
    size_t i;
    std::vector<Chunk*> chunkVect;
    for (i = 0; i < WEBP_CHUNK_NIL; i++) {
        chunkVect = this->chunks[i];
        while (!chunkVect.empty()) {
            chunk = chunkVect.back();
            delete chunk;
            chunkVect.pop_back();
        }
    }
}
}
","VP8XChunk::VP8XChunk(Container* parent)
  : Chunk(parent, kChunk_VP8X)
{
    this->needsRewrite = true;
    this->size = 10;
    this->data.resize(this->size);
     this->data.assign(this->size, 0);
     XMP_Uns8* bitstream =
         (XMP_Uns8*)parent->chunks[WEBP_CHUNK_IMAGE][0]->data.data();
    XMP_Uns32 width = ((bitstream[7] << 8) | bitstream[6]) & 0x3fff;
    XMP_Uns32 height = ((bitstream[9] << 8) | bitstream[8]) & 0x3fff;
     this->width(width);
     this->height(height);
     parent->vp8x = this;
VP8XChunk::VP8XChunk(Container* parent, WEBP_MetaHandler* handler)
  : Chunk(parent, handler)
{
    this->size = 10;
    this->needsRewrite = true;
    parent->vp8x = this;
}

XMP_Uns32 VP8XChunk::width()
{
    return GetLE24(&this->data[4]) + 1;
}
void VP8XChunk::width(XMP_Uns32 val)
{
    PutLE24(&this->data[4], val > 0 ? val - 1 : 0);
}
XMP_Uns32 VP8XChunk::height()
{
    return GetLE24(&this->data[7]) + 1;
}
void VP8XChunk::height(XMP_Uns32 val)
{
    PutLE24(&this->data[7], val > 0 ? val - 1 : 0);
}
bool VP8XChunk::xmp()
{
    XMP_Uns32 flags = GetLE32(&this->data[0]);
    return (bool)((flags >> XMP_FLAG_BIT) & 1);
}
void VP8XChunk::xmp(bool hasXMP)
{
    XMP_Uns32 flags = GetLE32(&this->data[0]);
    flags ^= (-hasXMP ^ flags) & (1 << XMP_FLAG_BIT);
    PutLE32(&this->data[0], flags);
}

Container::Container(WEBP_MetaHandler* handler) : Chunk(NULL, handler)
{
    this->needsRewrite = false;

    XMP_IO* file = handler->parent->ioRef;

    file->Seek(12, kXMP_SeekFromStart);

    XMP_Int64 size = handler->initialFileSize;

    XMP_Uns32 peek = 0;

    while (file->Offset() < size) {
        peek = XIO::PeekUns32_LE(file);
        switch (peek) {
        case kChunk_XMP_:
            this->addChunk(new XMPChunk(this, handler));
            break;
        case kChunk_VP8X:
            this->addChunk(new VP8XChunk(this, handler));
            break;
        default:
            this->addChunk(new Chunk(this, handler));
            break;
        }
    }

    if (this->chunks[WEBP_CHUNK_IMAGE].size() == 0) {
        XMP_Throw(""File has no image bitstream"", kXMPErr_BadFileFormat);
    }

    if (this->chunks[WEBP_CHUNK_VP8X].size() == 0) {
        this->needsRewrite = true;
        this->addChunk(new VP8XChunk(this));
    }

    if (this->chunks[WEBP_CHUNK_XMP].size() == 0) {
        XMPChunk* xmpChunk = new XMPChunk(this);
        this->addChunk(xmpChunk);
        handler->xmpChunk = xmpChunk;
        this->vp8x->xmp(true);
    }
}

Chunk* Container::getExifChunk()
{
    if (this->chunks[WEBP::WEBP_CHUNK_EXIF].size() == 0) {
        return NULL;
    }
    return this->chunks[WEBP::WEBP_CHUNK_EXIF][0];
}

void Container::addChunk(Chunk* chunk)
{
    ChunkId idx;

    try {
        idx = chunkMap.at(chunk->tag);
    }
    catch (const std::out_of_range& e) {
        idx = WEBP_CHUNK_UNKNOWN;
    }
    this->chunks[idx].push_back(chunk);
}

void Container::write(WEBP_MetaHandler* handler)
{
    XMP_IO* file = handler->parent->ioRef;
    file->Rewind();
    XIO::WriteUns32_LE(file, this->tag);
    XIO::WriteUns32_LE(file, (XMP_Uns32) this->size);
    XIO::WriteUns32_LE(file, kChunk_WEBP);

    size_t i, j;
    std::vector<Chunk*> chunkVect;
    for (i = 0; i < WEBP_CHUNK_NIL; i++) {
        chunkVect = this->chunks[i];
        for (j = 0; j < chunkVect.size(); j++) {
            chunkVect.at(j)->write(handler);
        }
    }
    XMP_Int64 lastOffset = file->Offset();
    this->size = lastOffset - 8;
    file->Seek(this->pos + 4, kXMP_SeekFromStart);
    XIO::WriteUns32_LE(file, (XMP_Uns32) this->size);
    file->Seek(lastOffset, kXMP_SeekFromStart);
    if (lastOffset < handler->initialFileSize) {
        file->Truncate(lastOffset);
    }
}

Container::~Container()
{
    Chunk* chunk;
    size_t i;
    std::vector<Chunk*> chunkVect;
    for (i = 0; i < WEBP_CHUNK_NIL; i++) {
        chunkVect = this->chunks[i];
        while (!chunkVect.empty()) {
            chunk = chunkVect.back();
            delete chunk;
            chunkVect.pop_back();
        }
    }
}
}
",CPP,"    // See bug https://bugs.freedesktop.org/show_bug.cgi?id=105247
    // bitstream could be NULL.
    XMP_Uns32 width = bitstream ? ((bitstream[7] << 8) | bitstream[6]) & 0x3fff : 0;
    XMP_Uns32 height = bitstream ? ((bitstream[9] << 8) | bitstream[8]) & 0x3fff : 0;
","    XMP_Uns32 width = ((bitstream[7] << 8) | bitstream[6]) & 0x3fff;
    XMP_Uns32 height = ((bitstream[9] << 8) | bitstream[8]) & 0x3fff;
",2670adad295c49b0fbb277f35340b32ddf7bc80c,"@@ -120,8 +120,10 @@ VP8XChunk::VP8XChunk(Container* parent)
     this->data.assign(this->size, 0);
     XMP_Uns8* bitstream =
         (XMP_Uns8*)parent->chunks[WEBP_CHUNK_IMAGE][0]->data.data();
-    XMP_Uns32 width = ((bitstream[7] << 8) | bitstream[6]) & 0x3fff;
-    XMP_Uns32 height = ((bitstream[9] << 8) | bitstream[8]) & 0x3fff;
+    // See bug https://bugs.freedesktop.org/show_bug.cgi?id=105247
+    // bitstream could be NULL.
+    XMP_Uns32 width = bitstream ? ((bitstream[7] << 8) | bitstream[6]) & 0x3fff : 0;
+    XMP_Uns32 height = bitstream ? ((bitstream[9] << 8) | bitstream[8]) & 0x3fff : 0;
     this->width(width);
     this->height(height);
     parent->vp8x = this;",exempi,https://cgit.freedesktop.org/exempi/tree/XMPFiles/source/FormatSupport/WEBP_Support.cpp?id=aabedb5e749dd59112a3fe1e8e08f2d934f56666,https://cgit.freedesktop.org/exempi/tree/XMPFiles/source/FormatSupport/WEBP_Support.cpp?id=2670adad295c49b0fbb277f35340b32ddf7bc80c,1,"VP8XChunk::VP8XChunk(Container* parent)
  : Chunk(parent, kChunk_VP8X)
{
    this->needsRewrite = true;
    this->size = 10;
    this->data.resize(this->size);
     this->data.assign(this->size, 0);
     XMP_Uns8* bitstream =
         (XMP_Uns8*)parent->chunks[WEBP_CHUNK_IMAGE][0]->data.data();
//flaw_line_below:
    XMP_Uns32 width = ((bitstream[7] << 8) | bitstream[6]) & 0x3fff;
//flaw_line_below:
    XMP_Uns32 height = ((bitstream[9] << 8) | bitstream[8]) & 0x3fff;
//fix_flaw_line_below:
//    // See bug https://bugs.freedesktop.org/show_bug.cgi?id=105247
//fix_flaw_line_below:
//    // bitstream could be NULL.
//fix_flaw_line_below:
//    XMP_Uns32 width = bitstream ? ((bitstream[7] << 8) | bitstream[6]) & 0x3fff : 0;
//fix_flaw_line_below:
//    XMP_Uns32 height = bitstream ? ((bitstream[9] << 8) | bitstream[8]) & 0x3fff : 0;
     this->width(width);
     this->height(height);
     parent->vp8x = this;
VP8XChunk::VP8XChunk(Container* parent, WEBP_MetaHandler* handler)
  : Chunk(parent, handler)
{
    this->size = 10;
    this->needsRewrite = true;
    parent->vp8x = this;
}

XMP_Uns32 VP8XChunk::width()
{
    return GetLE24(&this->data[4]) + 1;
}
void VP8XChunk::width(XMP_Uns32 val)
{
    PutLE24(&this->data[4], val > 0 ? val - 1 : 0);
}
XMP_Uns32 VP8XChunk::height()
{
    return GetLE24(&this->data[7]) + 1;
}
void VP8XChunk::height(XMP_Uns32 val)
{
    PutLE24(&this->data[7], val > 0 ? val - 1 : 0);
}
bool VP8XChunk::xmp()
{
    XMP_Uns32 flags = GetLE32(&this->data[0]);
    return (bool)((flags >> XMP_FLAG_BIT) & 1);
}
void VP8XChunk::xmp(bool hasXMP)
{
    XMP_Uns32 flags = GetLE32(&this->data[0]);
    flags ^= (-hasXMP ^ flags) & (1 << XMP_FLAG_BIT);
    PutLE32(&this->data[0], flags);
}

Container::Container(WEBP_MetaHandler* handler) : Chunk(NULL, handler)
{
    this->needsRewrite = false;

    XMP_IO* file = handler->parent->ioRef;

    file->Seek(12, kXMP_SeekFromStart);

    XMP_Int64 size = handler->initialFileSize;

    XMP_Uns32 peek = 0;

    while (file->Offset() < size) {
        peek = XIO::PeekUns32_LE(file);
        switch (peek) {
        case kChunk_XMP_:
            this->addChunk(new XMPChunk(this, handler));
            break;
        case kChunk_VP8X:
            this->addChunk(new VP8XChunk(this, handler));
            break;
        default:
            this->addChunk(new Chunk(this, handler));
            break;
        }
    }

    if (this->chunks[WEBP_CHUNK_IMAGE].size() == 0) {
        XMP_Throw(""File has no image bitstream"", kXMPErr_BadFileFormat);
    }

    if (this->chunks[WEBP_CHUNK_VP8X].size() == 0) {
        // The file is either in Lossy or Lossless Simple File Format.
        // For simplicity we will always convert it to the Extended File Format.
        this->needsRewrite = true;
        this->addChunk(new VP8XChunk(this));
    }

    if (this->chunks[WEBP_CHUNK_XMP].size() == 0) {
        XMPChunk* xmpChunk = new XMPChunk(this);
        this->addChunk(xmpChunk);
        handler->xmpChunk = xmpChunk;
        this->vp8x->xmp(true);
    }
}

Chunk* Container::getExifChunk()
{
    if (this->chunks[WEBP::WEBP_CHUNK_EXIF].size() == 0) {
        return NULL;
    }
    return this->chunks[WEBP::WEBP_CHUNK_EXIF][0];
}

void Container::addChunk(Chunk* chunk)
{
    ChunkId idx;

    try {
        idx = chunkMap.at(chunk->tag);
    }
    catch (const std::out_of_range& e) {
        idx = WEBP_CHUNK_UNKNOWN;
    }
    this->chunks[idx].push_back(chunk);
}

void Container::write(WEBP_MetaHandler* handler)
{
    XMP_IO* file = handler->parent->ioRef;
    file->Rewind();
    XIO::WriteUns32_LE(file, this->tag);
    XIO::WriteUns32_LE(file, (XMP_Uns32) this->size);
    XIO::WriteUns32_LE(file, kChunk_WEBP);

    size_t i, j;
    std::vector<Chunk*> chunkVect;
    for (i = 0; i < WEBP_CHUNK_NIL; i++) {
        chunkVect = this->chunks[i];
        for (j = 0; j < chunkVect.size(); j++) {
            chunkVect.at(j)->write(handler);
        }
    }
    XMP_Int64 lastOffset = file->Offset();
    this->size = lastOffset - 8;
    file->Seek(this->pos + 4, kXMP_SeekFromStart);
    XIO::WriteUns32_LE(file, (XMP_Uns32) this->size);
    file->Seek(lastOffset, kXMP_SeekFromStart);
    if (lastOffset < handler->initialFileSize) {
        file->Truncate(lastOffset);
    }
}

Container::~Container()
{
    Chunk* chunk;
    size_t i;
    std::vector<Chunk*> chunkVect;
    for (i = 0; i < WEBP_CHUNK_NIL; i++) {
        chunkVect = this->chunks[i];
        while (!chunkVect.empty()) {
            chunk = chunkVect.back();
            delete chunk;
            chunkVect.pop_back();
        }
    }
}
}
"
456,178192,,Remote,Not required,Partial,CVE-2018-6951,https://www.cvedetails.com/cve/CVE-2018-6951/,CWE-476,Low,,,,2018-02-13,5.0,"An issue was discovered in GNU patch through 2.7.6. There is a segmentation fault, associated with a NULL pointer dereference, leading to a denial of service in the intuit_diff_type function in pch.c, aka a ""mangled rename"" issue.",2019-04-17,DoS,2,https://git.savannah.gnu.org/cgit/patch.git/commit/?id=f290f48a621867084884bfff87f8093c15195e6a,f290f48a621867084884bfff87f8093c15195e6a,,1,,,"intuit_diff_type (bool need_header, mode_t *p_file_type)
{
    file_offset this_line = 0;
    file_offset first_command_line = -1;
    char first_ed_command_letter = 0;
    lin fcl_line = 0; /* Pacify 'gcc -W'.  */
    bool this_is_a_command = false;
    bool stars_this_line = false;
    bool extended_headers = false;
    enum nametype i;
    struct stat st[3];
    int stat_errno[3];
    int version_controlled[3];
    enum diff retval;
    mode_t file_type;
    size_t indent = 0;

    for (i = OLD;  i <= INDEX;  i++)
      if (p_name[i]) {
	  free (p_name[i]);
	  p_name[i] = 0;
        }
    for (i = 0; i < ARRAY_SIZE (invalid_names); i++)
	invalid_names[i] = NULL;
    for (i = OLD; i <= NEW; i++)
      if (p_timestr[i])
	{
	  free(p_timestr[i]);
	  p_timestr[i] = 0;
	}
    for (i = OLD; i <= NEW; i++)
      if (p_sha1[i])
	{
	  free (p_sha1[i]);
	  p_sha1[i] = 0;
	}
    p_git_diff = false;
    for (i = OLD; i <= NEW; i++)
      {
	p_mode[i] = 0;
	p_copy[i] = false;
	p_rename[i] = false;
      }

    /* Ed and normal format patches don't have filename headers.  */
    if (diff_type == ED_DIFF || diff_type == NORMAL_DIFF)
      need_header = false;

    version_controlled[OLD] = -1;
    version_controlled[NEW] = -1;
    version_controlled[INDEX] = -1;
    p_rfc934_nesting = 0;
    p_timestamp[OLD].tv_sec = p_timestamp[NEW].tv_sec = -1;
    p_says_nonexistent[OLD] = p_says_nonexistent[NEW] = 0;
    Fseek (pfp, p_base, SEEK_SET);
    p_input_line = p_bline - 1;
    for (;;) {
	char *s;
	char *t;
	file_offset previous_line = this_line;
	bool last_line_was_command = this_is_a_command;
	bool stars_last_line = stars_this_line;
	size_t indent_last_line = indent;
	char ed_command_letter;
	bool strip_trailing_cr;
	size_t chars_read;

	indent = 0;
	this_line = file_tell (pfp);
	chars_read = pget_line (0, 0, false, false);
	if (chars_read == (size_t) -1)
	  xalloc_die ();
	if (! chars_read) {
	    if (first_ed_command_letter) {
					/* nothing but deletes!? */
		p_start = first_command_line;
		p_sline = fcl_line;
		retval = ED_DIFF;
		goto scan_exit;
	    }
	    else {
		p_start = this_line;
		p_sline = p_input_line;
		if (extended_headers)
		  {
		    /* Patch contains no hunks; any diff type will do. */
		    retval = UNI_DIFF;
		    goto scan_exit;
		  }
		return NO_DIFF;
	    }
	}
	strip_trailing_cr = 2 <= chars_read && buf[chars_read - 2] == '\r';
	for (s = buf; *s == ' ' || *s == '\t' || *s == 'X'; s++) {
	    if (*s == '\t')
		indent = (indent + 8) & ~7;
	    else
		indent++;
	}
	if (ISDIGIT (*s))
	  {
	    for (t = s + 1; ISDIGIT (*t) || *t == ',';  t++)
	      /* do nothing */ ;
	    if (*t == 'd' || *t == 'c' || *t == 'a')
	      {
		for (t++;  ISDIGIT (*t) || *t == ',';  t++)
		  /* do nothing */ ;
		for (; *t == ' ' || *t == '\t'; t++)
		  /* do nothing */ ;
		if (*t == '\r')
		  t++;
		this_is_a_command = (*t == '\n');
	      }
	  }
	if (! need_header
	    && first_command_line < 0
	    && ((ed_command_letter = get_ed_command_letter (s))
		|| this_is_a_command)) {
	    first_command_line = this_line;
	    first_ed_command_letter = ed_command_letter;
	    fcl_line = p_input_line;
	    p_indent = indent;		/* assume this for now */
	    p_strip_trailing_cr = strip_trailing_cr;
	}
	if (!stars_last_line && strnEQ(s, ""*** "", 4))
	  {
	    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],
		       &p_timestamp[OLD]);
	    need_header = false;
	  }
	else if (strnEQ(s, ""+++ "", 4))
	  {
	    /* Swap with NEW below.  */
	    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],
		       &p_timestamp[OLD]);
	    need_header = false;
	    p_strip_trailing_cr = strip_trailing_cr;
	  }
	else if (strnEQ(s, ""Index:"", 6))
	  {
	    fetchname (s+6, strippath, &p_name[INDEX], (char **) 0, NULL);
	    need_header = false;
	    p_strip_trailing_cr = strip_trailing_cr;
	  }
	else if (strnEQ(s, ""Prereq:"", 7))
	  {
	    for (t = s + 7;  ISSPACE ((unsigned char) *t);  t++)
	      /* do nothing */ ;
	    revision = t;
	    for (t = revision;  *t;  t++)
	      if (ISSPACE ((unsigned char) *t))
		{
		  char const *u;
		  for (u = t + 1;  ISSPACE ((unsigned char) *u);  u++)
		    /* do nothing */ ;
		  if (*u)
		    {
		      char numbuf[LINENUM_LENGTH_BOUND + 1];
		      say (""Prereq: with multiple words at line %s of patch\n"",
			   format_linenum (numbuf, this_line));
		    }
		  break;
		}
	    if (t == revision)
		revision = 0;
	    else {
		char oldc = *t;
		*t = '\0';
		revision = xstrdup (revision);
		*t = oldc;
	    }
	  }
	else if (strnEQ (s, ""diff --git "", 11))
	  {
	    char const *u;

	    if (extended_headers)
	      {
		p_start = this_line;
		p_sline = p_input_line;
		/* Patch contains no hunks; any diff type will do. */
		retval = UNI_DIFF;
		goto scan_exit;
	      }

	    for (i = OLD; i <= NEW; i++)
	      {
		free (p_name[i]);
		p_name[i] = 0;
	      }
	    if (! ((p_name[OLD] = parse_name (s + 11, strippath, &u))
		   && ISSPACE ((unsigned char) *u)
		   && (p_name[NEW] = parse_name (u, strippath, &u))
		   && (u = skip_spaces (u), ! *u)))
	      for (i = OLD; i <= NEW; i++)
		{
		  free (p_name[i]);
		  p_name[i] = 0;
		}
	    p_git_diff = true;
	    need_header = false;
	  }
	else if (p_git_diff && strnEQ (s, ""index "", 6))
	  {
	    char const *u, *v;
	    if ((u = skip_hex_digits (s + 6))
		&& u[0] == '.' && u[1] == '.'
		&& (v = skip_hex_digits (u + 2))
		&& (! *v || ISSPACE ((unsigned char) *v)))
	      {
		get_sha1(&p_sha1[OLD], s + 6, u);
		get_sha1(&p_sha1[NEW], u + 2, v);
		p_says_nonexistent[OLD] = sha1_says_nonexistent (p_sha1[OLD]);
		p_says_nonexistent[NEW] = sha1_says_nonexistent (p_sha1[NEW]);
		if (*(v = skip_spaces (v)))
		  p_mode[OLD] = p_mode[NEW] = fetchmode (v);
		extended_headers = true;
	      }
	  }
	else if (p_git_diff && strnEQ (s, ""old mode "", 9))
	  {
	    p_mode[OLD] = fetchmode (s + 9);
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""new mode "", 9))
	  {
	    p_mode[NEW] = fetchmode (s + 9);
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""deleted file mode "", 18))
	  {
	    p_mode[OLD] = fetchmode (s + 18);
	    p_says_nonexistent[NEW] = 2;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""new file mode "", 14))
	  {
	    p_mode[NEW] = fetchmode (s + 14);
	    p_says_nonexistent[OLD] = 2;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""rename from "", 12))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_rename[OLD] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""rename to "", 10))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_rename[NEW] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""copy from "", 10))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_copy[OLD] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""copy to "", 8))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_copy[NEW] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""GIT binary patch"", 16))
	  {
	    p_start = this_line;
	    p_sline = p_input_line;
	    retval = GIT_BINARY_DIFF;
	    goto scan_exit;
	  }
	else
	  {
	    for (t = s;  t[0] == '-' && t[1] == ' ';  t += 2)
	      /* do nothing */ ;
	    if (strnEQ(t, ""--- "", 4))
	      {
		struct timespec timestamp;
		timestamp.tv_sec = -1;
		fetchname (t+4, strippath, &p_name[NEW], &p_timestr[NEW],
			   &timestamp);
		need_header = false;
		if (timestamp.tv_sec != -1)
		  {
		    p_timestamp[NEW] = timestamp;
		    p_rfc934_nesting = (t - s) >> 1;
		  }
		p_strip_trailing_cr = strip_trailing_cr;
	      }
	  }
	if (need_header)
	  continue;
	if ((diff_type == NO_DIFF || diff_type == ED_DIFF) &&
	  first_command_line >= 0 &&
	  strEQ(s, "".\n"") ) {
	    p_start = first_command_line;
	    p_sline = fcl_line;
	    retval = ED_DIFF;
	    goto scan_exit;
	}
	if ((diff_type == NO_DIFF || diff_type == UNI_DIFF)
	    && strnEQ(s, ""@@ -"", 4)) {

	    /* 'p_name', 'p_timestr', and 'p_timestamp' are backwards;
	       swap them.  */
	    struct timespec ti = p_timestamp[OLD];
	    p_timestamp[OLD] = p_timestamp[NEW];
	    p_timestamp[NEW] = ti;
	    t = p_name[OLD];
	    p_name[OLD] = p_name[NEW];
	    p_name[NEW] = t;
	    t = p_timestr[OLD];
	    p_timestr[OLD] = p_timestr[NEW];
	    p_timestr[NEW] = t;

	    s += 4;
	    if (s[0] == '0' && !ISDIGIT (s[1]))
	      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;
	    while (*s != ' ' && *s != '\n')
	      s++;
	    while (*s == ' ')
	      s++;
	    if (s[0] == '+' && s[1] == '0' && !ISDIGIT (s[2]))
	      p_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;
	    p_indent = indent;
	    p_start = this_line;
	    p_sline = p_input_line;
	    retval = UNI_DIFF;
	    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)
		   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))
		&& ! p_name[INDEX] && need_header)
	      {
		char numbuf[LINENUM_LENGTH_BOUND + 1];
		say (""missing header for unified diff at line %s of patch\n"",
		     format_linenum (numbuf, p_sline));
	      }
	    goto scan_exit;
	}
	stars_this_line = strnEQ(s, ""********"", 8);
	if ((diff_type == NO_DIFF
	     || diff_type == CONTEXT_DIFF
	     || diff_type == NEW_CONTEXT_DIFF)
	    && stars_last_line && indent_last_line == indent
	    && strnEQ (s, ""*** "", 4)) {
	    s += 4;
	    if (s[0] == '0' && !ISDIGIT (s[1]))
	      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;
	    /* if this is a new context diff the character just before */
	    /* the newline is a '*'. */
	    while (*s != '\n')
		s++;
	    p_indent = indent;
	    p_strip_trailing_cr = strip_trailing_cr;
	    p_start = previous_line;
	    p_sline = p_input_line - 1;
	    retval = (*(s-1) == '*' ? NEW_CONTEXT_DIFF : CONTEXT_DIFF);

	    {
	      /* Scan the first hunk to see whether the file contents
		 appear to have been deleted.  */
	      file_offset saved_p_base = p_base;
	      lin saved_p_bline = p_bline;
	      Fseek (pfp, previous_line, SEEK_SET);
	      p_input_line -= 2;
	      if (another_hunk (retval, false)
		  && ! p_repl_lines && p_newfirst == 1)
		p_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;
	      next_intuit_at (saved_p_base, saved_p_bline);
	    }

	    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)
		   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))
		&& ! p_name[INDEX] && need_header)
	      {
		char numbuf[LINENUM_LENGTH_BOUND + 1];
		say (""missing header for context diff at line %s of patch\n"",
		     format_linenum (numbuf, p_sline));
	      }
	    goto scan_exit;
	}
	if ((diff_type == NO_DIFF || diff_type == NORMAL_DIFF) &&
	  last_line_was_command &&
	  (strnEQ(s, ""< "", 2) || strnEQ(s, ""> "", 2)) ) {
	    p_start = previous_line;
	    p_sline = p_input_line - 1;
	    p_indent = indent;
	    retval = NORMAL_DIFF;
	    goto scan_exit;
	}
    }

  scan_exit:

    /* The old, new, or old and new file types may be defined.  When both
       file types are defined, make sure they are the same, or else assume
       we do not know the file type.  */
    file_type = p_mode[OLD] & S_IFMT;
    if (file_type)
      {
	mode_t new_file_type = p_mode[NEW] & S_IFMT;
	if (new_file_type && file_type != new_file_type)
	  file_type = 0;
      }
    else
      {
	file_type = p_mode[NEW] & S_IFMT;
	if (! file_type)
	  file_type = S_IFREG;
      }
    *p_file_type = file_type;

    /* To intuit 'inname', the name of the file to patch,
       use the algorithm specified by POSIX 1003.1-2001 XCU lines 25680-26599
       (with some modifications if posixly_correct is zero):

       - Take the old and new names from the context header if present,
	 and take the index name from the 'Index:' line if present and
	 if either the old and new names are both absent
	 or posixly_correct is nonzero.
	 Consider the file names to be in the order (old, new, index).
       - If some named files exist, use the first one if posixly_correct
	 is nonzero, the best one otherwise.
       - If patch_get is nonzero, and no named files exist,
	 but an RCS or SCCS master file exists,
	 use the first named file with an RCS or SCCS master.
       - If no named files exist, no RCS or SCCS master was found,
	 some names are given, posixly_correct is zero,
	 and the patch appears to create a file, then use the best name
	 requiring the creation of the fewest directories.
       - Otherwise, report failure by setting 'inname' to 0;
	 this causes our invoker to ask the user for a file name.  */

    i = NONE;

    if (!inname)
      {
	enum nametype i0 = NONE;

	if (! posixly_correct && (p_name[OLD] || p_name[NEW]) && p_name[INDEX])
	  {
	    free (p_name[INDEX]);
	    p_name[INDEX] = 0;
	  }

	for (i = OLD;  i <= INDEX;  i++)
	  if (p_name[i])
	    {
	      if (i0 != NONE && strcmp (p_name[i0], p_name[i]) == 0)
		{
		  /* It's the same name as before; reuse stat results.  */
		  stat_errno[i] = stat_errno[i0];
		  if (! stat_errno[i])
		    st[i] = st[i0];
		}
	      else
		{
		  stat_errno[i] = stat_file (p_name[i], &st[i]);
		  if (! stat_errno[i])
		    {
		      if (lookup_file_id (&st[i]) == DELETE_LATER)
			stat_errno[i] = ENOENT;
		      else if (posixly_correct && name_is_valid (p_name[i]))
			break;
		    }
		}
	      i0 = i;
	    }

	if (! posixly_correct)
	  {
	    /* The best of all existing files. */
	    i = best_name (p_name, stat_errno);

	    if (i == NONE && patch_get)
	      {
		enum nametype nope = NONE;

		for (i = OLD;  i <= INDEX;  i++)
		  if (p_name[i])
		    {
		      char const *cs;
		      char *getbuf;
		      char *diffbuf;
		      bool readonly = (outfile
				       && strcmp (outfile, p_name[i]) != 0);

		      if (nope == NONE || strcmp (p_name[nope], p_name[i]) != 0)
			{
			  cs = (version_controller
			        (p_name[i], readonly, (struct stat *) 0,
				 &getbuf, &diffbuf));
			  version_controlled[i] = !! cs;
			  if (cs)
			    {
			      if (version_get (p_name[i], cs, false, readonly,
					       getbuf, &st[i]))
				stat_errno[i] = 0;
			      else
				version_controlled[i] = 0;

			      free (getbuf);
			      free (diffbuf);

			      if (! stat_errno[i])
				break;
			    }
			}

		      nope = i;
		    }
	      }

	    if (i0 != NONE
		&& (i == NONE || (st[i].st_mode & S_IFMT) == file_type)
		&& maybe_reverse (p_name[i == NONE ? i0 : i], i == NONE,
				  i == NONE || st[i].st_size == 0)
		&& i == NONE)
	      i = i0;

	    if (i == NONE && p_says_nonexistent[reverse])
	      {
		int newdirs[3];
		int newdirs_min = INT_MAX;
		int distance_from_minimum[3];

		for (i = OLD;  i <= INDEX;  i++)
		  if (p_name[i])
		    {
		      newdirs[i] = (prefix_components (p_name[i], false)
				    - prefix_components (p_name[i], true));
		      if (newdirs[i] < newdirs_min)
			newdirs_min = newdirs[i];
		    }

		for (i = OLD;  i <= INDEX;  i++)
		  if (p_name[i])
		    distance_from_minimum[i] = newdirs[i] - newdirs_min;

		/* The best of the filenames which create the fewest directories. */
		i = best_name (p_name, distance_from_minimum);
	      }
	  }
      }

     if ((pch_rename () || pch_copy ())
 	&& ! inname
 	&& ! ((i == OLD || i == NEW) &&
	      p_name[reverse] && p_name[! reverse] &&
	      name_is_valid (p_name[reverse]) &&
 	      name_is_valid (p_name[! reverse])))
       {
 	say (""Cannot %s file without two valid file names\n"", pch_rename () ? ""rename"" : ""copy"");
      }

    if (i == NONE)
      {
	if (inname)
	  {
	    inerrno = stat_file (inname, &instat);
	    if (inerrno || (instat.st_mode & S_IFMT) == file_type)
	      maybe_reverse (inname, inerrno, inerrno || instat.st_size == 0);
	  }
	else
          inerrno = -1;
      }
    else
      {
	inname = xstrdup (p_name[i]);
	inerrno = stat_errno[i];
	invc = version_controlled[i];
	instat = st[i];
      }

    return retval;
}
","intuit_diff_type (bool need_header, mode_t *p_file_type)
{
    file_offset this_line = 0;
    file_offset first_command_line = -1;
    char first_ed_command_letter = 0;
    lin fcl_line = 0; /* Pacify 'gcc -W'.  */
    bool this_is_a_command = false;
    bool stars_this_line = false;
    bool extended_headers = false;
    enum nametype i;
    struct stat st[3];
    int stat_errno[3];
    int version_controlled[3];
    enum diff retval;
    mode_t file_type;
    size_t indent = 0;

    for (i = OLD;  i <= INDEX;  i++)
      if (p_name[i]) {
	  free (p_name[i]);
	  p_name[i] = 0;
        }
    for (i = 0; i < ARRAY_SIZE (invalid_names); i++)
	invalid_names[i] = NULL;
    for (i = OLD; i <= NEW; i++)
      if (p_timestr[i])
	{
	  free(p_timestr[i]);
	  p_timestr[i] = 0;
	}
    for (i = OLD; i <= NEW; i++)
      if (p_sha1[i])
	{
	  free (p_sha1[i]);
	  p_sha1[i] = 0;
	}
    p_git_diff = false;
    for (i = OLD; i <= NEW; i++)
      {
	p_mode[i] = 0;
	p_copy[i] = false;
	p_rename[i] = false;
      }

    /* Ed and normal format patches don't have filename headers.  */
    if (diff_type == ED_DIFF || diff_type == NORMAL_DIFF)
      need_header = false;

    version_controlled[OLD] = -1;
    version_controlled[NEW] = -1;
    version_controlled[INDEX] = -1;
    p_rfc934_nesting = 0;
    p_timestamp[OLD].tv_sec = p_timestamp[NEW].tv_sec = -1;
    p_says_nonexistent[OLD] = p_says_nonexistent[NEW] = 0;
    Fseek (pfp, p_base, SEEK_SET);
    p_input_line = p_bline - 1;
    for (;;) {
	char *s;
	char *t;
	file_offset previous_line = this_line;
	bool last_line_was_command = this_is_a_command;
	bool stars_last_line = stars_this_line;
	size_t indent_last_line = indent;
	char ed_command_letter;
	bool strip_trailing_cr;
	size_t chars_read;

	indent = 0;
	this_line = file_tell (pfp);
	chars_read = pget_line (0, 0, false, false);
	if (chars_read == (size_t) -1)
	  xalloc_die ();
	if (! chars_read) {
	    if (first_ed_command_letter) {
					/* nothing but deletes!? */
		p_start = first_command_line;
		p_sline = fcl_line;
		retval = ED_DIFF;
		goto scan_exit;
	    }
	    else {
		p_start = this_line;
		p_sline = p_input_line;
		if (extended_headers)
		  {
		    /* Patch contains no hunks; any diff type will do. */
		    retval = UNI_DIFF;
		    goto scan_exit;
		  }
		return NO_DIFF;
	    }
	}
	strip_trailing_cr = 2 <= chars_read && buf[chars_read - 2] == '\r';
	for (s = buf; *s == ' ' || *s == '\t' || *s == 'X'; s++) {
	    if (*s == '\t')
		indent = (indent + 8) & ~7;
	    else
		indent++;
	}
	if (ISDIGIT (*s))
	  {
	    for (t = s + 1; ISDIGIT (*t) || *t == ',';  t++)
	      /* do nothing */ ;
	    if (*t == 'd' || *t == 'c' || *t == 'a')
	      {
		for (t++;  ISDIGIT (*t) || *t == ',';  t++)
		  /* do nothing */ ;
		for (; *t == ' ' || *t == '\t'; t++)
		  /* do nothing */ ;
		if (*t == '\r')
		  t++;
		this_is_a_command = (*t == '\n');
	      }
	  }
	if (! need_header
	    && first_command_line < 0
	    && ((ed_command_letter = get_ed_command_letter (s))
		|| this_is_a_command)) {
	    first_command_line = this_line;
	    first_ed_command_letter = ed_command_letter;
	    fcl_line = p_input_line;
	    p_indent = indent;		/* assume this for now */
	    p_strip_trailing_cr = strip_trailing_cr;
	}
	if (!stars_last_line && strnEQ(s, ""*** "", 4))
	  {
	    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],
		       &p_timestamp[OLD]);
	    need_header = false;
	  }
	else if (strnEQ(s, ""+++ "", 4))
	  {
	    /* Swap with NEW below.  */
	    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],
		       &p_timestamp[OLD]);
	    need_header = false;
	    p_strip_trailing_cr = strip_trailing_cr;
	  }
	else if (strnEQ(s, ""Index:"", 6))
	  {
	    fetchname (s+6, strippath, &p_name[INDEX], (char **) 0, NULL);
	    need_header = false;
	    p_strip_trailing_cr = strip_trailing_cr;
	  }
	else if (strnEQ(s, ""Prereq:"", 7))
	  {
	    for (t = s + 7;  ISSPACE ((unsigned char) *t);  t++)
	      /* do nothing */ ;
	    revision = t;
	    for (t = revision;  *t;  t++)
	      if (ISSPACE ((unsigned char) *t))
		{
		  char const *u;
		  for (u = t + 1;  ISSPACE ((unsigned char) *u);  u++)
		    /* do nothing */ ;
		  if (*u)
		    {
		      char numbuf[LINENUM_LENGTH_BOUND + 1];
		      say (""Prereq: with multiple words at line %s of patch\n"",
			   format_linenum (numbuf, this_line));
		    }
		  break;
		}
	    if (t == revision)
		revision = 0;
	    else {
		char oldc = *t;
		*t = '\0';
		revision = xstrdup (revision);
		*t = oldc;
	    }
	  }
	else if (strnEQ (s, ""diff --git "", 11))
	  {
	    char const *u;

	    if (extended_headers)
	      {
		p_start = this_line;
		p_sline = p_input_line;
		/* Patch contains no hunks; any diff type will do. */
		retval = UNI_DIFF;
		goto scan_exit;
	      }

	    for (i = OLD; i <= NEW; i++)
	      {
		free (p_name[i]);
		p_name[i] = 0;
	      }
	    if (! ((p_name[OLD] = parse_name (s + 11, strippath, &u))
		   && ISSPACE ((unsigned char) *u)
		   && (p_name[NEW] = parse_name (u, strippath, &u))
		   && (u = skip_spaces (u), ! *u)))
	      for (i = OLD; i <= NEW; i++)
		{
		  free (p_name[i]);
		  p_name[i] = 0;
		}
	    p_git_diff = true;
	    need_header = false;
	  }
	else if (p_git_diff && strnEQ (s, ""index "", 6))
	  {
	    char const *u, *v;
	    if ((u = skip_hex_digits (s + 6))
		&& u[0] == '.' && u[1] == '.'
		&& (v = skip_hex_digits (u + 2))
		&& (! *v || ISSPACE ((unsigned char) *v)))
	      {
		get_sha1(&p_sha1[OLD], s + 6, u);
		get_sha1(&p_sha1[NEW], u + 2, v);
		p_says_nonexistent[OLD] = sha1_says_nonexistent (p_sha1[OLD]);
		p_says_nonexistent[NEW] = sha1_says_nonexistent (p_sha1[NEW]);
		if (*(v = skip_spaces (v)))
		  p_mode[OLD] = p_mode[NEW] = fetchmode (v);
		extended_headers = true;
	      }
	  }
	else if (p_git_diff && strnEQ (s, ""old mode "", 9))
	  {
	    p_mode[OLD] = fetchmode (s + 9);
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""new mode "", 9))
	  {
	    p_mode[NEW] = fetchmode (s + 9);
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""deleted file mode "", 18))
	  {
	    p_mode[OLD] = fetchmode (s + 18);
	    p_says_nonexistent[NEW] = 2;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""new file mode "", 14))
	  {
	    p_mode[NEW] = fetchmode (s + 14);
	    p_says_nonexistent[OLD] = 2;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""rename from "", 12))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_rename[OLD] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""rename to "", 10))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_rename[NEW] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""copy from "", 10))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_copy[OLD] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""copy to "", 8))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_copy[NEW] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""GIT binary patch"", 16))
	  {
	    p_start = this_line;
	    p_sline = p_input_line;
	    retval = GIT_BINARY_DIFF;
	    goto scan_exit;
	  }
	else
	  {
	    for (t = s;  t[0] == '-' && t[1] == ' ';  t += 2)
	      /* do nothing */ ;
	    if (strnEQ(t, ""--- "", 4))
	      {
		struct timespec timestamp;
		timestamp.tv_sec = -1;
		fetchname (t+4, strippath, &p_name[NEW], &p_timestr[NEW],
			   &timestamp);
		need_header = false;
		if (timestamp.tv_sec != -1)
		  {
		    p_timestamp[NEW] = timestamp;
		    p_rfc934_nesting = (t - s) >> 1;
		  }
		p_strip_trailing_cr = strip_trailing_cr;
	      }
	  }
	if (need_header)
	  continue;
	if ((diff_type == NO_DIFF || diff_type == ED_DIFF) &&
	  first_command_line >= 0 &&
	  strEQ(s, "".\n"") ) {
	    p_start = first_command_line;
	    p_sline = fcl_line;
	    retval = ED_DIFF;
	    goto scan_exit;
	}
	if ((diff_type == NO_DIFF || diff_type == UNI_DIFF)
	    && strnEQ(s, ""@@ -"", 4)) {

	    /* 'p_name', 'p_timestr', and 'p_timestamp' are backwards;
	       swap them.  */
	    struct timespec ti = p_timestamp[OLD];
	    p_timestamp[OLD] = p_timestamp[NEW];
	    p_timestamp[NEW] = ti;
	    t = p_name[OLD];
	    p_name[OLD] = p_name[NEW];
	    p_name[NEW] = t;
	    t = p_timestr[OLD];
	    p_timestr[OLD] = p_timestr[NEW];
	    p_timestr[NEW] = t;

	    s += 4;
	    if (s[0] == '0' && !ISDIGIT (s[1]))
	      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;
	    while (*s != ' ' && *s != '\n')
	      s++;
	    while (*s == ' ')
	      s++;
	    if (s[0] == '+' && s[1] == '0' && !ISDIGIT (s[2]))
	      p_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;
	    p_indent = indent;
	    p_start = this_line;
	    p_sline = p_input_line;
	    retval = UNI_DIFF;
	    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)
		   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))
		&& ! p_name[INDEX] && need_header)
	      {
		char numbuf[LINENUM_LENGTH_BOUND + 1];
		say (""missing header for unified diff at line %s of patch\n"",
		     format_linenum (numbuf, p_sline));
	      }
	    goto scan_exit;
	}
	stars_this_line = strnEQ(s, ""********"", 8);
	if ((diff_type == NO_DIFF
	     || diff_type == CONTEXT_DIFF
	     || diff_type == NEW_CONTEXT_DIFF)
	    && stars_last_line && indent_last_line == indent
	    && strnEQ (s, ""*** "", 4)) {
	    s += 4;
	    if (s[0] == '0' && !ISDIGIT (s[1]))
	      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;
	    /* if this is a new context diff the character just before */
	    /* the newline is a '*'. */
	    while (*s != '\n')
		s++;
	    p_indent = indent;
	    p_strip_trailing_cr = strip_trailing_cr;
	    p_start = previous_line;
	    p_sline = p_input_line - 1;
	    retval = (*(s-1) == '*' ? NEW_CONTEXT_DIFF : CONTEXT_DIFF);

	    {
	      /* Scan the first hunk to see whether the file contents
		 appear to have been deleted.  */
	      file_offset saved_p_base = p_base;
	      lin saved_p_bline = p_bline;
	      Fseek (pfp, previous_line, SEEK_SET);
	      p_input_line -= 2;
	      if (another_hunk (retval, false)
		  && ! p_repl_lines && p_newfirst == 1)
		p_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;
	      next_intuit_at (saved_p_base, saved_p_bline);
	    }

	    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)
		   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))
		&& ! p_name[INDEX] && need_header)
	      {
		char numbuf[LINENUM_LENGTH_BOUND + 1];
		say (""missing header for context diff at line %s of patch\n"",
		     format_linenum (numbuf, p_sline));
	      }
	    goto scan_exit;
	}
	if ((diff_type == NO_DIFF || diff_type == NORMAL_DIFF) &&
	  last_line_was_command &&
	  (strnEQ(s, ""< "", 2) || strnEQ(s, ""> "", 2)) ) {
	    p_start = previous_line;
	    p_sline = p_input_line - 1;
	    p_indent = indent;
	    retval = NORMAL_DIFF;
	    goto scan_exit;
	}
    }

  scan_exit:

    /* The old, new, or old and new file types may be defined.  When both
       file types are defined, make sure they are the same, or else assume
       we do not know the file type.  */
    file_type = p_mode[OLD] & S_IFMT;
    if (file_type)
      {
	mode_t new_file_type = p_mode[NEW] & S_IFMT;
	if (new_file_type && file_type != new_file_type)
	  file_type = 0;
      }
    else
      {
	file_type = p_mode[NEW] & S_IFMT;
	if (! file_type)
	  file_type = S_IFREG;
      }
    *p_file_type = file_type;

    /* To intuit 'inname', the name of the file to patch,
       use the algorithm specified by POSIX 1003.1-2001 XCU lines 25680-26599
       (with some modifications if posixly_correct is zero):

       - Take the old and new names from the context header if present,
	 and take the index name from the 'Index:' line if present and
	 if either the old and new names are both absent
	 or posixly_correct is nonzero.
	 Consider the file names to be in the order (old, new, index).
       - If some named files exist, use the first one if posixly_correct
	 is nonzero, the best one otherwise.
       - If patch_get is nonzero, and no named files exist,
	 but an RCS or SCCS master file exists,
	 use the first named file with an RCS or SCCS master.
       - If no named files exist, no RCS or SCCS master was found,
	 some names are given, posixly_correct is zero,
	 and the patch appears to create a file, then use the best name
	 requiring the creation of the fewest directories.
       - Otherwise, report failure by setting 'inname' to 0;
	 this causes our invoker to ask the user for a file name.  */

    i = NONE;

    if (!inname)
      {
	enum nametype i0 = NONE;

	if (! posixly_correct && (p_name[OLD] || p_name[NEW]) && p_name[INDEX])
	  {
	    free (p_name[INDEX]);
	    p_name[INDEX] = 0;
	  }

	for (i = OLD;  i <= INDEX;  i++)
	  if (p_name[i])
	    {
	      if (i0 != NONE && strcmp (p_name[i0], p_name[i]) == 0)
		{
		  /* It's the same name as before; reuse stat results.  */
		  stat_errno[i] = stat_errno[i0];
		  if (! stat_errno[i])
		    st[i] = st[i0];
		}
	      else
		{
		  stat_errno[i] = stat_file (p_name[i], &st[i]);
		  if (! stat_errno[i])
		    {
		      if (lookup_file_id (&st[i]) == DELETE_LATER)
			stat_errno[i] = ENOENT;
		      else if (posixly_correct && name_is_valid (p_name[i]))
			break;
		    }
		}
	      i0 = i;
	    }

	if (! posixly_correct)
	  {
	    /* The best of all existing files. */
	    i = best_name (p_name, stat_errno);

	    if (i == NONE && patch_get)
	      {
		enum nametype nope = NONE;

		for (i = OLD;  i <= INDEX;  i++)
		  if (p_name[i])
		    {
		      char const *cs;
		      char *getbuf;
		      char *diffbuf;
		      bool readonly = (outfile
				       && strcmp (outfile, p_name[i]) != 0);

		      if (nope == NONE || strcmp (p_name[nope], p_name[i]) != 0)
			{
			  cs = (version_controller
			        (p_name[i], readonly, (struct stat *) 0,
				 &getbuf, &diffbuf));
			  version_controlled[i] = !! cs;
			  if (cs)
			    {
			      if (version_get (p_name[i], cs, false, readonly,
					       getbuf, &st[i]))
				stat_errno[i] = 0;
			      else
				version_controlled[i] = 0;

			      free (getbuf);
			      free (diffbuf);

			      if (! stat_errno[i])
				break;
			    }
			}

		      nope = i;
		    }
	      }

	    if (i0 != NONE
		&& (i == NONE || (st[i].st_mode & S_IFMT) == file_type)
		&& maybe_reverse (p_name[i == NONE ? i0 : i], i == NONE,
				  i == NONE || st[i].st_size == 0)
		&& i == NONE)
	      i = i0;

	    if (i == NONE && p_says_nonexistent[reverse])
	      {
		int newdirs[3];
		int newdirs_min = INT_MAX;
		int distance_from_minimum[3];

		for (i = OLD;  i <= INDEX;  i++)
		  if (p_name[i])
		    {
		      newdirs[i] = (prefix_components (p_name[i], false)
				    - prefix_components (p_name[i], true));
		      if (newdirs[i] < newdirs_min)
			newdirs_min = newdirs[i];
		    }

		for (i = OLD;  i <= INDEX;  i++)
		  if (p_name[i])
		    distance_from_minimum[i] = newdirs[i] - newdirs_min;

		/* The best of the filenames which create the fewest directories. */
		i = best_name (p_name, distance_from_minimum);
	      }
	  }
      }

     if ((pch_rename () || pch_copy ())
 	&& ! inname
 	&& ! ((i == OLD || i == NEW) &&
	      p_name[! reverse] &&
 	      name_is_valid (p_name[! reverse])))
       {
 	say (""Cannot %s file without two valid file names\n"", pch_rename () ? ""rename"" : ""copy"");
      }

    if (i == NONE)
      {
	if (inname)
	  {
	    inerrno = stat_file (inname, &instat);
	    if (inerrno || (instat.st_mode & S_IFMT) == file_type)
	      maybe_reverse (inname, inerrno, inerrno || instat.st_size == 0);
	  }
	else
          inerrno = -1;
      }
    else
      {
	inname = xstrdup (p_name[i]);
	inerrno = stat_errno[i];
	invc = version_controlled[i];
	instat = st[i];
      }

    return retval;
}
",C,"	      p_name[reverse] && p_name[! reverse] &&
	      name_is_valid (p_name[reverse]) &&
","	      p_name[! reverse] &&
",074e2395f81d0ecaa66b71a6c228c70b49db72e5,"@@ -974,7 +974,8 @@ intuit_diff_type (bool need_header, mode_t *p_file_type)
     if ((pch_rename () || pch_copy ())
 	&& ! inname
 	&& ! ((i == OLD || i == NEW) &&
-	      p_name[! reverse] &&
+	      p_name[reverse] && p_name[! reverse] &&
+	      name_is_valid (p_name[reverse]) &&
 	      name_is_valid (p_name[! reverse])))
       {
 	say (""Cannot %s file without two valid file names\n"", pch_rename () ? ""rename"" : ""copy"");",savannah,https://git.savannah.gnu.org/cgit/patch.git/tree/src/pch.c?id=f290f48a621867084884bfff87f8093c15195e6a,https://git.savannah.gnu.org/cgit/patch.git/tree/src/pch.c?id=074e2395f81d0ecaa66b71a6c228c70b49db72e5,1,"intuit_diff_type (bool need_header, mode_t *p_file_type)
{
    file_offset this_line = 0;
    file_offset first_command_line = -1;
    char first_ed_command_letter = 0;
    lin fcl_line = 0; /* Pacify 'gcc -W'.  */
    bool this_is_a_command = false;
    bool stars_this_line = false;
    bool extended_headers = false;
    enum nametype i;
    struct stat st[3];
    int stat_errno[3];
    int version_controlled[3];
    enum diff retval;
    mode_t file_type;
    size_t indent = 0;

    for (i = OLD;  i <= INDEX;  i++)
      if (p_name[i]) {
	  free (p_name[i]);
	  p_name[i] = 0;
        }
    for (i = 0; i < ARRAY_SIZE (invalid_names); i++)
	invalid_names[i] = NULL;
    for (i = OLD; i <= NEW; i++)
      if (p_timestr[i])
	{
	  free(p_timestr[i]);
	  p_timestr[i] = 0;
	}
    for (i = OLD; i <= NEW; i++)
      if (p_sha1[i])
	{
	  free (p_sha1[i]);
	  p_sha1[i] = 0;
	}
    p_git_diff = false;
    for (i = OLD; i <= NEW; i++)
      {
	p_mode[i] = 0;
	p_copy[i] = false;
	p_rename[i] = false;
      }

    /* Ed and normal format patches don't have filename headers.  */
    if (diff_type == ED_DIFF || diff_type == NORMAL_DIFF)
      need_header = false;

    version_controlled[OLD] = -1;
    version_controlled[NEW] = -1;
    version_controlled[INDEX] = -1;
    p_rfc934_nesting = 0;
    p_timestamp[OLD].tv_sec = p_timestamp[NEW].tv_sec = -1;
    p_says_nonexistent[OLD] = p_says_nonexistent[NEW] = 0;
    Fseek (pfp, p_base, SEEK_SET);
    p_input_line = p_bline - 1;
    for (;;) {
	char *s;
	char *t;
	file_offset previous_line = this_line;
	bool last_line_was_command = this_is_a_command;
	bool stars_last_line = stars_this_line;
	size_t indent_last_line = indent;
	char ed_command_letter;
	bool strip_trailing_cr;
	size_t chars_read;

	indent = 0;
	this_line = file_tell (pfp);
	chars_read = pget_line (0, 0, false, false);
	if (chars_read == (size_t) -1)
	  xalloc_die ();
	if (! chars_read) {
	    if (first_ed_command_letter) {
					/* nothing but deletes!? */
		p_start = first_command_line;
		p_sline = fcl_line;
		retval = ED_DIFF;
		goto scan_exit;
	    }
	    else {
		p_start = this_line;
		p_sline = p_input_line;
		if (extended_headers)
		  {
		    /* Patch contains no hunks; any diff type will do. */
		    retval = UNI_DIFF;
		    goto scan_exit;
		  }
		return NO_DIFF;
	    }
	}
	strip_trailing_cr = 2 <= chars_read && buf[chars_read - 2] == '\r';
	for (s = buf; *s == ' ' || *s == '\t' || *s == 'X'; s++) {
	    if (*s == '\t')
		indent = (indent + 8) & ~7;
	    else
		indent++;
	}
	if (ISDIGIT (*s))
	  {
	    for (t = s + 1; ISDIGIT (*t) || *t == ',';  t++)
	      /* do nothing */ ;
	    if (*t == 'd' || *t == 'c' || *t == 'a')
	      {
		for (t++;  ISDIGIT (*t) || *t == ',';  t++)
		  /* do nothing */ ;
		for (; *t == ' ' || *t == '\t'; t++)
		  /* do nothing */ ;
		if (*t == '\r')
		  t++;
		this_is_a_command = (*t == '\n');
	      }
	  }
	if (! need_header
	    && first_command_line < 0
	    && ((ed_command_letter = get_ed_command_letter (s))
		|| this_is_a_command)) {
	    first_command_line = this_line;
	    first_ed_command_letter = ed_command_letter;
	    fcl_line = p_input_line;
	    p_indent = indent;		/* assume this for now */
	    p_strip_trailing_cr = strip_trailing_cr;
	}
	if (!stars_last_line && strnEQ(s, ""*** "", 4))
	  {
	    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],
		       &p_timestamp[OLD]);
	    need_header = false;
	  }
	else if (strnEQ(s, ""+++ "", 4))
	  {
	    /* Swap with NEW below.  */
	    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],
		       &p_timestamp[OLD]);
	    need_header = false;
	    p_strip_trailing_cr = strip_trailing_cr;
	  }
	else if (strnEQ(s, ""Index:"", 6))
	  {
	    fetchname (s+6, strippath, &p_name[INDEX], (char **) 0, NULL);
	    need_header = false;
	    p_strip_trailing_cr = strip_trailing_cr;
	  }
	else if (strnEQ(s, ""Prereq:"", 7))
	  {
	    for (t = s + 7;  ISSPACE ((unsigned char) *t);  t++)
	      /* do nothing */ ;
	    revision = t;
	    for (t = revision;  *t;  t++)
	      if (ISSPACE ((unsigned char) *t))
		{
		  char const *u;
		  for (u = t + 1;  ISSPACE ((unsigned char) *u);  u++)
		    /* do nothing */ ;
		  if (*u)
		    {
		      char numbuf[LINENUM_LENGTH_BOUND + 1];
		      say (""Prereq: with multiple words at line %s of patch\n"",
			   format_linenum (numbuf, this_line));
		    }
		  break;
		}
	    if (t == revision)
		revision = 0;
	    else {
		char oldc = *t;
		*t = '\0';
		revision = xstrdup (revision);
		*t = oldc;
	    }
	  }
	else if (strnEQ (s, ""diff --git "", 11))
	  {
	    char const *u;

	    if (extended_headers)
	      {
		p_start = this_line;
		p_sline = p_input_line;
		/* Patch contains no hunks; any diff type will do. */
		retval = UNI_DIFF;
		goto scan_exit;
	      }

	    for (i = OLD; i <= NEW; i++)
	      {
		free (p_name[i]);
		p_name[i] = 0;
	      }
	    if (! ((p_name[OLD] = parse_name (s + 11, strippath, &u))
		   && ISSPACE ((unsigned char) *u)
		   && (p_name[NEW] = parse_name (u, strippath, &u))
		   && (u = skip_spaces (u), ! *u)))
	      for (i = OLD; i <= NEW; i++)
		{
		  free (p_name[i]);
		  p_name[i] = 0;
		}
	    p_git_diff = true;
	    need_header = false;
	  }
	else if (p_git_diff && strnEQ (s, ""index "", 6))
	  {
	    char const *u, *v;
	    if ((u = skip_hex_digits (s + 6))
		&& u[0] == '.' && u[1] == '.'
		&& (v = skip_hex_digits (u + 2))
		&& (! *v || ISSPACE ((unsigned char) *v)))
	      {
		get_sha1(&p_sha1[OLD], s + 6, u);
		get_sha1(&p_sha1[NEW], u + 2, v);
		p_says_nonexistent[OLD] = sha1_says_nonexistent (p_sha1[OLD]);
		p_says_nonexistent[NEW] = sha1_says_nonexistent (p_sha1[NEW]);
		if (*(v = skip_spaces (v)))
		  p_mode[OLD] = p_mode[NEW] = fetchmode (v);
		extended_headers = true;
	      }
	  }
	else if (p_git_diff && strnEQ (s, ""old mode "", 9))
	  {
	    p_mode[OLD] = fetchmode (s + 9);
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""new mode "", 9))
	  {
	    p_mode[NEW] = fetchmode (s + 9);
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""deleted file mode "", 18))
	  {
	    p_mode[OLD] = fetchmode (s + 18);
	    p_says_nonexistent[NEW] = 2;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""new file mode "", 14))
	  {
	    p_mode[NEW] = fetchmode (s + 14);
	    p_says_nonexistent[OLD] = 2;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""rename from "", 12))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_rename[OLD] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""rename to "", 10))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_rename[NEW] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""copy from "", 10))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_copy[OLD] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""copy to "", 8))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_copy[NEW] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""GIT binary patch"", 16))
	  {
	    p_start = this_line;
	    p_sline = p_input_line;
	    retval = GIT_BINARY_DIFF;
	    goto scan_exit;
	  }
	else
	  {
	    for (t = s;  t[0] == '-' && t[1] == ' ';  t += 2)
	      /* do nothing */ ;
	    if (strnEQ(t, ""--- "", 4))
	      {
		struct timespec timestamp;
		timestamp.tv_sec = -1;
		fetchname (t+4, strippath, &p_name[NEW], &p_timestr[NEW],
			   &timestamp);
		need_header = false;
		if (timestamp.tv_sec != -1)
		  {
		    p_timestamp[NEW] = timestamp;
		    p_rfc934_nesting = (t - s) >> 1;
		  }
		p_strip_trailing_cr = strip_trailing_cr;
	      }
	  }
	if (need_header)
	  continue;
	if ((diff_type == NO_DIFF || diff_type == ED_DIFF) &&
	  first_command_line >= 0 &&
	  strEQ(s, "".\n"") ) {
	    p_start = first_command_line;
	    p_sline = fcl_line;
	    retval = ED_DIFF;
	    goto scan_exit;
	}
	if ((diff_type == NO_DIFF || diff_type == UNI_DIFF)
	    && strnEQ(s, ""@@ -"", 4)) {

	    /* 'p_name', 'p_timestr', and 'p_timestamp' are backwards;
	       swap them.  */
	    struct timespec ti = p_timestamp[OLD];
	    p_timestamp[OLD] = p_timestamp[NEW];
	    p_timestamp[NEW] = ti;
	    t = p_name[OLD];
	    p_name[OLD] = p_name[NEW];
	    p_name[NEW] = t;
	    t = p_timestr[OLD];
	    p_timestr[OLD] = p_timestr[NEW];
	    p_timestr[NEW] = t;

	    s += 4;
	    if (s[0] == '0' && !ISDIGIT (s[1]))
	      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;
	    while (*s != ' ' && *s != '\n')
	      s++;
	    while (*s == ' ')
	      s++;
	    if (s[0] == '+' && s[1] == '0' && !ISDIGIT (s[2]))
	      p_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;
	    p_indent = indent;
	    p_start = this_line;
	    p_sline = p_input_line;
	    retval = UNI_DIFF;
	    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)
		   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))
		&& ! p_name[INDEX] && need_header)
	      {
		char numbuf[LINENUM_LENGTH_BOUND + 1];
		say (""missing header for unified diff at line %s of patch\n"",
		     format_linenum (numbuf, p_sline));
	      }
	    goto scan_exit;
	}
	stars_this_line = strnEQ(s, ""********"", 8);
	if ((diff_type == NO_DIFF
	     || diff_type == CONTEXT_DIFF
	     || diff_type == NEW_CONTEXT_DIFF)
	    && stars_last_line && indent_last_line == indent
	    && strnEQ (s, ""*** "", 4)) {
	    s += 4;
	    if (s[0] == '0' && !ISDIGIT (s[1]))
	      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;
	    /* if this is a new context diff the character just before */
	    /* the newline is a '*'. */
	    while (*s != '\n')
		s++;
	    p_indent = indent;
	    p_strip_trailing_cr = strip_trailing_cr;
	    p_start = previous_line;
	    p_sline = p_input_line - 1;
	    retval = (*(s-1) == '*' ? NEW_CONTEXT_DIFF : CONTEXT_DIFF);

	    {
	      /* Scan the first hunk to see whether the file contents
		 appear to have been deleted.  */
	      file_offset saved_p_base = p_base;
	      lin saved_p_bline = p_bline;
	      Fseek (pfp, previous_line, SEEK_SET);
	      p_input_line -= 2;
	      if (another_hunk (retval, false)
		  && ! p_repl_lines && p_newfirst == 1)
		p_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;
	      next_intuit_at (saved_p_base, saved_p_bline);
	    }

	    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)
		   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))
		&& ! p_name[INDEX] && need_header)
	      {
		char numbuf[LINENUM_LENGTH_BOUND + 1];
		say (""missing header for context diff at line %s of patch\n"",
		     format_linenum (numbuf, p_sline));
	      }
	    goto scan_exit;
	}
	if ((diff_type == NO_DIFF || diff_type == NORMAL_DIFF) &&
	  last_line_was_command &&
	  (strnEQ(s, ""< "", 2) || strnEQ(s, ""> "", 2)) ) {
	    p_start = previous_line;
	    p_sline = p_input_line - 1;
	    p_indent = indent;
	    retval = NORMAL_DIFF;
	    goto scan_exit;
	}
    }

  scan_exit:

    /* The old, new, or old and new file types may be defined.  When both
       file types are defined, make sure they are the same, or else assume
       we do not know the file type.  */
    file_type = p_mode[OLD] & S_IFMT;
    if (file_type)
      {
	mode_t new_file_type = p_mode[NEW] & S_IFMT;
	if (new_file_type && file_type != new_file_type)
	  file_type = 0;
      }
    else
      {
	file_type = p_mode[NEW] & S_IFMT;
	if (! file_type)
	  file_type = S_IFREG;
      }
    *p_file_type = file_type;

    /* To intuit 'inname', the name of the file to patch,
       use the algorithm specified by POSIX 1003.1-2001 XCU lines 25680-26599
       (with some modifications if posixly_correct is zero):

       - Take the old and new names from the context header if present,
	 and take the index name from the 'Index:' line if present and
	 if either the old and new names are both absent
	 or posixly_correct is nonzero.
	 Consider the file names to be in the order (old, new, index).
       - If some named files exist, use the first one if posixly_correct
	 is nonzero, the best one otherwise.
       - If patch_get is nonzero, and no named files exist,
	 but an RCS or SCCS master file exists,
	 use the first named file with an RCS or SCCS master.
       - If no named files exist, no RCS or SCCS master was found,
	 some names are given, posixly_correct is zero,
	 and the patch appears to create a file, then use the best name
	 requiring the creation of the fewest directories.
       - Otherwise, report failure by setting 'inname' to 0;
	 this causes our invoker to ask the user for a file name.  */

    i = NONE;

    if (!inname)
      {
	enum nametype i0 = NONE;

	if (! posixly_correct && (p_name[OLD] || p_name[NEW]) && p_name[INDEX])
	  {
	    free (p_name[INDEX]);
	    p_name[INDEX] = 0;
	  }

	for (i = OLD;  i <= INDEX;  i++)
	  if (p_name[i])
	    {
	      if (i0 != NONE && strcmp (p_name[i0], p_name[i]) == 0)
		{
		  /* It's the same name as before; reuse stat results.  */
		  stat_errno[i] = stat_errno[i0];
		  if (! stat_errno[i])
		    st[i] = st[i0];
		}
	      else
		{
		  stat_errno[i] = stat_file (p_name[i], &st[i]);
		  if (! stat_errno[i])
		    {
		      if (lookup_file_id (&st[i]) == DELETE_LATER)
			stat_errno[i] = ENOENT;
		      else if (posixly_correct && name_is_valid (p_name[i]))
			break;
		    }
		}
	      i0 = i;
	    }

	if (! posixly_correct)
	  {
	    /* The best of all existing files. */
	    i = best_name (p_name, stat_errno);

	    if (i == NONE && patch_get)
	      {
		enum nametype nope = NONE;

		for (i = OLD;  i <= INDEX;  i++)
		  if (p_name[i])
		    {
		      char const *cs;
		      char *getbuf;
		      char *diffbuf;
		      bool readonly = (outfile
				       && strcmp (outfile, p_name[i]) != 0);

		      if (nope == NONE || strcmp (p_name[nope], p_name[i]) != 0)
			{
			  cs = (version_controller
			        (p_name[i], readonly, (struct stat *) 0,
				 &getbuf, &diffbuf));
			  version_controlled[i] = !! cs;
			  if (cs)
			    {
			      if (version_get (p_name[i], cs, false, readonly,
					       getbuf, &st[i]))
				stat_errno[i] = 0;
			      else
				version_controlled[i] = 0;

			      free (getbuf);
			      free (diffbuf);

			      if (! stat_errno[i])
				break;
			    }
			}

		      nope = i;
		    }
	      }

	    if (i0 != NONE
		&& (i == NONE || (st[i].st_mode & S_IFMT) == file_type)
		&& maybe_reverse (p_name[i == NONE ? i0 : i], i == NONE,
				  i == NONE || st[i].st_size == 0)
		&& i == NONE)
	      i = i0;

	    if (i == NONE && p_says_nonexistent[reverse])
	      {
		int newdirs[3];
		int newdirs_min = INT_MAX;
		int distance_from_minimum[3];

		for (i = OLD;  i <= INDEX;  i++)
		  if (p_name[i])
		    {
		      newdirs[i] = (prefix_components (p_name[i], false)
				    - prefix_components (p_name[i], true));
		      if (newdirs[i] < newdirs_min)
			newdirs_min = newdirs[i];
		    }

		for (i = OLD;  i <= INDEX;  i++)
		  if (p_name[i])
		    distance_from_minimum[i] = newdirs[i] - newdirs_min;

		/* The best of the filenames which create the fewest directories. */
		i = best_name (p_name, distance_from_minimum);
	      }
	  }
      }

     if ((pch_rename () || pch_copy ())
 	&& ! inname
 	&& ! ((i == OLD || i == NEW) &&
//flaw_line_below:
	      p_name[! reverse] &&
//fix_flaw_line_below:
//	      p_name[reverse] && p_name[! reverse] &&
//fix_flaw_line_below:
//	      name_is_valid (p_name[reverse]) &&
 	      name_is_valid (p_name[! reverse])))
       {
 	say (""Cannot %s file without two valid file names\n"", pch_rename () ? ""rename"" : ""copy"");
      }

    if (i == NONE)
      {
	if (inname)
	  {
	    inerrno = stat_file (inname, &instat);
	    if (inerrno || (instat.st_mode & S_IFMT) == file_type)
	      maybe_reverse (inname, inerrno, inerrno || instat.st_size == 0);
	  }
	else
          inerrno = -1;
      }
    else
      {
	inname = xstrdup (p_name[i]);
	inerrno = stat_errno[i];
	invc = version_controlled[i];
	instat = st[i];
      }

    return retval;
}
"
457,178193,,Remote,Not required,Partial,CVE-2018-6942,https://www.cvedetails.com/cve/CVE-2018-6942/,CWE-476,Medium,,,,2018-02-13,4.3,An issue was discovered in FreeType 2 through 2.9. A NULL pointer dereference in the Ins_GETVARIATION() function within ttinterp.c could lead to DoS via a crafted font file.,2018-03-16,,10,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=29c759284e305ec428703c9a5831d0b1fc3497ef,29c759284e305ec428703c9a5831d0b1fc3497ef,,2,,,"  Ins_GETVARIATION( TT_ExecContext  exc,
                    FT_Long*        args )
  {
    FT_UInt    num_axes = exc->face->blend->num_axis;
    FT_Fixed*  coords   = exc->face->blend->normalizedcoords;

    FT_UInt  i;


    if ( BOUNDS( num_axes, exc->stackSize + 1 - exc->top ) )
    {
      exc->error = FT_THROW( Stack_Overflow );
       return;
     }
 
    if ( coords )
    {
      for ( i = 0; i < num_axes; i++ )
        args[i] = coords[i] >> 2; /* convert 16.16 to 2.14 format */
    }
    else
    {
      for ( i = 0; i < num_axes; i++ )
        args[i] = 0;
    }
   }
","  Ins_GETVARIATION( TT_ExecContext  exc,
                    FT_Long*        args )
  {
    FT_UInt    num_axes = exc->face->blend->num_axis;
    FT_Fixed*  coords   = exc->face->blend->normalizedcoords;

    FT_UInt  i;


    if ( BOUNDS( num_axes, exc->stackSize + 1 - exc->top ) )
    {
      exc->error = FT_THROW( Stack_Overflow );
       return;
     }
 
    for ( i = 0; i < num_axes; i++ )
      args[i] = coords[i] >> 2; /* convert 16.16 to 2.14 format */
   }
",C,"    if ( coords )
    {
      for ( i = 0; i < num_axes; i++ )
        args[i] = coords[i] >> 2; /* convert 16.16 to 2.14 format */
    }
    else
    {
      for ( i = 0; i < num_axes; i++ )
        args[i] = 0;
    }
","    for ( i = 0; i < num_axes; i++ )
      args[i] = coords[i] >> 2; /* convert 16.16 to 2.14 format */
",f438e069723c1e7a7a226e05f677a5e17e346a67,"@@ -7532,8 +7532,16 @@
       return;
     }
 
-    for ( i = 0; i < num_axes; i++ )
-      args[i] = coords[i] >> 2; /* convert 16.16 to 2.14 format */
+    if ( coords )
+    {
+      for ( i = 0; i < num_axes; i++ )
+        args[i] = coords[i] >> 2; /* convert 16.16 to 2.14 format */
+    }
+    else
+    {
+      for ( i = 0; i < num_axes; i++ )
+        args[i] = 0;
+    }
   }",savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/src/truetype/ttinterp.c?id=29c759284e305ec428703c9a5831d0b1fc3497ef,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/src/truetype/ttinterp.c?id=f438e069723c1e7a7a226e05f677a5e17e346a67,1,"  Ins_GETVARIATION( TT_ExecContext  exc,
                    FT_Long*        args )
  {
    FT_UInt    num_axes = exc->face->blend->num_axis;
    FT_Fixed*  coords   = exc->face->blend->normalizedcoords;

    FT_UInt  i;


    if ( BOUNDS( num_axes, exc->stackSize + 1 - exc->top ) )
    {
      exc->error = FT_THROW( Stack_Overflow );
       return;
     }
 
//flaw_line_below:
    for ( i = 0; i < num_axes; i++ )
//flaw_line_below:
      args[i] = coords[i] >> 2; /* convert 16.16 to 2.14 format */
//fix_flaw_line_below:
//    if ( coords )
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//      for ( i = 0; i < num_axes; i++ )
//fix_flaw_line_below:
//        args[i] = coords[i] >> 2; /* convert 16.16 to 2.14 format */
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//    else
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//      for ( i = 0; i < num_axes; i++ )
//fix_flaw_line_below:
//        args[i] = 0;
//fix_flaw_line_below:
//    }
   }
"
671,178407,,Remote,Not required,Partial,CVE-2016-10218,https://www.cvedetails.com/cve/CVE-2016-10218/,CWE-476,Medium,,,,2017-04-03,4.3,"The pdf14_pop_transparency_group function in base/gdevp14.c in the PDF Transparency module in Artifex Software, Inc. Ghostscript 9.20 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted file.",2017-04-10,DoS,3,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=d621292fb2c8157d9899dcd83fd04dd250e30fe4,d621292fb2c8157d9899dcd83fd04dd250e30fe4,,0,,,"pdf14_pop_transparency_group(gs_gstate *pgs, pdf14_ctx *ctx,
    const pdf14_nonseparable_blending_procs_t * pblend_procs,
    int tos_num_color_comp, cmm_profile_t *curr_icc_profile, gx_device *dev)
{
    pdf14_buf *tos = ctx->stack;
    pdf14_buf *nos = tos->saved;
    pdf14_mask_t *mask_stack = tos->mask_stack;
    pdf14_buf *maskbuf;
    int x0, x1, y0, y1;
    byte *new_data_buf = NULL;
    int num_noncolor_planes, new_num_planes;
    int num_cols, num_rows, nos_num_color_comp;
    bool icc_match;
    gsicc_rendering_param_t rendering_params;
    gsicc_link_t *icc_link;
    gsicc_bufferdesc_t input_buff_desc;
    gsicc_bufferdesc_t output_buff_desc;
    pdf14_device *pdev = (pdf14_device *)dev;
    bool overprint = pdev->overprint;
     gx_color_index drawn_comps = pdev->drawn_comps;
     bool nonicc_conversion = true;
 
    if (nos == NULL)
        return_error(gs_error_unknownerror);  /* Unmatched group pop */

     nos_num_color_comp = nos->parent_color_info_procs->num_components - nos->num_spots;
     tos_num_color_comp = tos_num_color_comp - tos->num_spots;
    if (mask_stack == NULL) {
        maskbuf = NULL;
    } else {
        maskbuf = mask_stack->rc_mask->mask_buf;
    }
    if (nos == NULL)
        return_error(gs_error_rangecheck);
    /* Sanitise the dirty rectangles, in case some of the drawing routines
     * have made them overly large. */
    rect_intersect(tos->dirty, tos->rect);
    rect_intersect(nos->dirty, nos->rect);
    /* dirty = the marked bbox. rect = the entire bounds of the buffer. */
    /* Everything marked on tos that fits onto nos needs to be merged down. */
    y0 = max(tos->dirty.p.y, nos->rect.p.y);
    y1 = min(tos->dirty.q.y, nos->rect.q.y);
    x0 = max(tos->dirty.p.x, nos->rect.p.x);
    x1 = min(tos->dirty.q.x, nos->rect.q.x);
    if (ctx->mask_stack) {
        /* This can occur when we have a situation where we are ending out of
           a group that has internal to it a soft mask and another group.
           The soft mask left over from the previous trans group pop is put
           into ctx->masbuf, since it is still active if another trans group
           push occurs to use it.  If one does not occur, but instead we find
           ourselves popping from a parent group, then this softmask is no
           longer needed.  We will rc_decrement and set it to NULL. */
        rc_decrement(ctx->mask_stack->rc_mask, ""pdf14_pop_transparency_group"");
        if (ctx->mask_stack->rc_mask == NULL ){
            gs_free_object(ctx->memory, ctx->mask_stack, ""pdf14_pop_transparency_group"");
        }
        ctx->mask_stack = NULL;
    }
    ctx->mask_stack = mask_stack;  /* Restore the mask saved by pdf14_push_transparency_group. */
    tos->mask_stack = NULL;        /* Clean the pointer sinse the mask ownership is now passed to ctx. */
    if (tos->idle)
        goto exit;
    if (maskbuf != NULL && maskbuf->data == NULL && maskbuf->alpha == 255)
        goto exit;

#if RAW_DUMP
    /* Dump the current buffer to see what we have. */
    dump_raw_buffer(ctx->stack->rect.q.y-ctx->stack->rect.p.y,
                ctx->stack->rowstride, ctx->stack->n_planes,
                ctx->stack->planestride, ctx->stack->rowstride,
                ""aaTrans_Group_Pop"",ctx->stack->data);
#endif
/* Note currently if a pattern space has transparency, the ICC profile is not used
   for blending purposes.  Instead we rely upon the gray, rgb, or cmyk parent space.
   This is partially due to the fact that pdf14_pop_transparency_group and
   pdf14_push_transparnecy_group have no real ICC interaction and those are the
   operations called in the tile transparency code.  Instead we may want to
   look at pdf14_begin_transparency_group and pdf14_end_transparency group which
   is where all the ICC information is handled.  We will return to look at that later */
    if (nos->parent_color_info_procs->icc_profile != NULL) {
        icc_match = (nos->parent_color_info_procs->icc_profile->hashcode !=
                        curr_icc_profile->hashcode);
    } else {
        /* Let the other tests make the decision if we need to transform */
        icc_match = false;
    }
    /* If the color spaces are different and we actually did do a swap of
       the procs for color */
    if ((nos->parent_color_info_procs->parent_color_mapping_procs != NULL &&
        nos_num_color_comp != tos_num_color_comp) || icc_match) {
        if (x0 < x1 && y0 < y1) {
            /* The NOS blending color space is different than that of the
               TOS.  It is necessary to transform the TOS buffer data to the
               color space of the NOS prior to doing the pdf14_compose_group
               operation.  */
            num_noncolor_planes = tos->n_planes - tos_num_color_comp;
            new_num_planes = num_noncolor_planes + nos_num_color_comp;

            /* See if we are doing ICC based conversion */
            if (nos->parent_color_info_procs->icc_profile != NULL &&
                curr_icc_profile != NULL) {
                /* Use the ICC color management for buffer color conversion */
                /* Define the rendering intents */
                rendering_params.black_point_comp = gsBLACKPTCOMP_ON;
                rendering_params.graphics_type_tag = GS_IMAGE_TAG;
                rendering_params.override_icc = false;
                rendering_params.preserve_black = gsBKPRESNOTSPECIFIED;
                rendering_params.rendering_intent = gsPERCEPTUAL;
                rendering_params.cmm = gsCMM_DEFAULT;
                /* Request the ICC link for the transform that we will need to use */
                /* Note that if pgs is NULL we assume the same color space.  This
                   is due to a call to pop the group from fill_mask when filling
                   with a mask with transparency.  In that case, the parent
                   and the child will have the same color space anyway */
                icc_link = gsicc_get_link_profile(pgs, dev, curr_icc_profile,
                                    nos->parent_color_info_procs->icc_profile,
                                    &rendering_params, pgs->memory, false);
                if (icc_link != NULL) {
                    /* if problem with link we will do non-ICC approach */
                    nonicc_conversion = false;
                    /* If the link is the identity, then we don't need to do
                       any color conversions */
                    if ( !(icc_link->is_identity) ) {
                        /* Before we do any allocations check if we can get away with
                           reusing the existing buffer if it is the same size ( if it is
                           smaller go ahead and allocate).  We could reuse it in this
                           case too.  We need to do a bit of testing to determine what
                           would be best.  */
                        /* FIXME: RJW: Could we get away with just color converting
                         * the area that's actually active (i.e. dirty, not rect)?
                         */
                        if(nos_num_color_comp != tos_num_color_comp) {
                            /* Different size.  We will need to allocate */
                            new_data_buf = gs_alloc_bytes(ctx->memory,
                                                tos->planestride * new_num_planes,
                                                    ""pdf14_pop_transparency_group"");
                            if (new_data_buf == NULL)
                                return_error(gs_error_VMerror);
                            /* Copy over the noncolor planes. */
                            memcpy(new_data_buf + tos->planestride * nos_num_color_comp,
                                   tos->data + tos->planestride * tos_num_color_comp,
                                   tos->planestride * num_noncolor_planes);
                        } else {
                            /* In place color conversion! */
                            new_data_buf = tos->data;
                        }
                        /* Set up the buffer descriptors. Note that pdf14 always has
                           the alpha channels at the back end (last planes).
                           We will just handle that here and let the CMM know
                           nothing about it */
                        num_rows = tos->rect.q.y - tos->rect.p.y;
                        num_cols = tos->rect.q.x - tos->rect.p.x;
                        gsicc_init_buffer(&input_buff_desc, tos_num_color_comp, 1,
                                          false, false, true,
                                          tos->planestride, tos->rowstride,
                                          num_rows, num_cols);
                        gsicc_init_buffer(&output_buff_desc, nos_num_color_comp,
                                          1, false, false, true, tos->planestride,
                                          tos->rowstride, num_rows, num_cols);
                        /* Transform the data. Since the pdf14 device should be
                           using RGB, CMYK or Gray buffers, this transform
                           does not need to worry about the cmap procs of
                           the target device.  Those are handled when we do
                           the pdf14 put image operation */
                        (icc_link->procs.map_buffer)(dev, icc_link, &input_buff_desc,
                                                     &output_buff_desc, tos->data,
                                                     new_data_buf);
                    }
                    /* Release the link */
                    gsicc_release_link(icc_link);
                    /* free the old object if the color spaces were different sizes */
                    if(!(icc_link->is_identity) &&
                        nos_num_color_comp != tos_num_color_comp) {
                        gs_free_object(ctx->memory, tos->data,
                            ""pdf14_pop_transparency_group"");
                        tos->data = new_data_buf;
                    }
                }
            }
            if (nonicc_conversion) {
                /* Non ICC based transform */
                new_data_buf = gs_alloc_bytes(ctx->memory,
                                    tos->planestride * new_num_planes,
                                    ""pdf14_pop_transparency_group"");
                if (new_data_buf == NULL)
                    return_error(gs_error_VMerror);
                gs_transform_color_buffer_generic(tos->data, tos->rowstride,
                            tos->planestride, tos_num_color_comp, tos->rect,
                            new_data_buf, nos_num_color_comp, num_noncolor_planes);
                /* Free the old object */
                gs_free_object(ctx->memory, tos->data,
                                ""pdf14_pop_transparency_group"");
                 tos->data = new_data_buf;
            }
             /* Adjust the plane and channel size now */
             tos->n_chan = nos->n_chan;
             tos->n_planes = nos->n_planes;
#if RAW_DUMP
            /* Dump the current buffer to see what we have. */
            dump_raw_buffer(ctx->stack->rect.q.y-ctx->stack->rect.p.y,
                            ctx->stack->rowstride, ctx->stack->n_chan,
                            ctx->stack->planestride, ctx->stack->rowstride,
                            ""aCMTrans_Group_ColorConv"",ctx->stack->data);
#endif
             /* compose. never do overprint in this case */
            pdf14_compose_group(tos, nos, maskbuf, x0, x1, y0, y1, nos->n_chan,
                 nos->parent_color_info_procs->isadditive,
                 nos->parent_color_info_procs->parent_blending_procs,
                 false, drawn_comps, ctx->memory, dev);
        }
    } else {
        /* Group color spaces are the same.  No color conversions needed */
        if (x0 < x1 && y0 < y1)
            pdf14_compose_group(tos, nos, maskbuf, x0, x1, y0, y1, nos->n_chan,
                                ctx->additive, pblend_procs, overprint,
                                drawn_comps, ctx->memory, dev);
    }
exit:
    ctx->stack = nos;
    /* We want to detect the cases where we have luminosity soft masks embedded
       within one another.  The ""alpha"" channel really needs to be merged into
       the luminosity channel in this case.  This will occur during the mask pop */
    if (ctx->smask_depth > 0 && maskbuf != NULL) {
        /* Set the trigger so that we will blend if not alpha. Since
           we have softmasks embedded in softmasks */
        ctx->smask_blend = true;
    }
    if_debug1m('v', ctx->memory, ""[v]pop buf, idle=%d\n"", tos->idle);
    pdf14_buf_free(tos, ctx->memory);
    return 0;
}
","pdf14_pop_transparency_group(gs_gstate *pgs, pdf14_ctx *ctx,
    const pdf14_nonseparable_blending_procs_t * pblend_procs,
    int tos_num_color_comp, cmm_profile_t *curr_icc_profile, gx_device *dev)
{
    pdf14_buf *tos = ctx->stack;
    pdf14_buf *nos = tos->saved;
    pdf14_mask_t *mask_stack = tos->mask_stack;
    pdf14_buf *maskbuf;
    int x0, x1, y0, y1;
    byte *new_data_buf = NULL;
    int num_noncolor_planes, new_num_planes;
    int num_cols, num_rows, nos_num_color_comp;
    bool icc_match;
    gsicc_rendering_param_t rendering_params;
    gsicc_link_t *icc_link;
    gsicc_bufferdesc_t input_buff_desc;
    gsicc_bufferdesc_t output_buff_desc;
    pdf14_device *pdev = (pdf14_device *)dev;
    bool overprint = pdev->overprint;
     gx_color_index drawn_comps = pdev->drawn_comps;
     bool nonicc_conversion = true;
 
     nos_num_color_comp = nos->parent_color_info_procs->num_components - nos->num_spots;
     tos_num_color_comp = tos_num_color_comp - tos->num_spots;
    if (mask_stack == NULL) {
        maskbuf = NULL;
    } else {
        maskbuf = mask_stack->rc_mask->mask_buf;
    }
    if (nos == NULL)
        return_error(gs_error_rangecheck);
    /* Sanitise the dirty rectangles, in case some of the drawing routines
     * have made them overly large. */
    rect_intersect(tos->dirty, tos->rect);
    rect_intersect(nos->dirty, nos->rect);
    /* dirty = the marked bbox. rect = the entire bounds of the buffer. */
    /* Everything marked on tos that fits onto nos needs to be merged down. */
    y0 = max(tos->dirty.p.y, nos->rect.p.y);
    y1 = min(tos->dirty.q.y, nos->rect.q.y);
    x0 = max(tos->dirty.p.x, nos->rect.p.x);
    x1 = min(tos->dirty.q.x, nos->rect.q.x);
    if (ctx->mask_stack) {
        /* This can occur when we have a situation where we are ending out of
           a group that has internal to it a soft mask and another group.
           The soft mask left over from the previous trans group pop is put
           into ctx->masbuf, since it is still active if another trans group
           push occurs to use it.  If one does not occur, but instead we find
           ourselves popping from a parent group, then this softmask is no
           longer needed.  We will rc_decrement and set it to NULL. */
        rc_decrement(ctx->mask_stack->rc_mask, ""pdf14_pop_transparency_group"");
        if (ctx->mask_stack->rc_mask == NULL ){
            gs_free_object(ctx->memory, ctx->mask_stack, ""pdf14_pop_transparency_group"");
        }
        ctx->mask_stack = NULL;
    }
    ctx->mask_stack = mask_stack;  /* Restore the mask saved by pdf14_push_transparency_group. */
    tos->mask_stack = NULL;        /* Clean the pointer sinse the mask ownership is now passed to ctx. */
    if (tos->idle)
        goto exit;
    if (maskbuf != NULL && maskbuf->data == NULL && maskbuf->alpha == 255)
        goto exit;

#if RAW_DUMP
    /* Dump the current buffer to see what we have. */
    dump_raw_buffer(ctx->stack->rect.q.y-ctx->stack->rect.p.y,
                ctx->stack->rowstride, ctx->stack->n_planes,
                ctx->stack->planestride, ctx->stack->rowstride,
                ""aaTrans_Group_Pop"",ctx->stack->data);
#endif
/* Note currently if a pattern space has transparency, the ICC profile is not used
   for blending purposes.  Instead we rely upon the gray, rgb, or cmyk parent space.
   This is partially due to the fact that pdf14_pop_transparency_group and
   pdf14_push_transparnecy_group have no real ICC interaction and those are the
   operations called in the tile transparency code.  Instead we may want to
   look at pdf14_begin_transparency_group and pdf14_end_transparency group which
   is where all the ICC information is handled.  We will return to look at that later */
    if (nos->parent_color_info_procs->icc_profile != NULL) {
        icc_match = (nos->parent_color_info_procs->icc_profile->hashcode !=
                        curr_icc_profile->hashcode);
    } else {
        /* Let the other tests make the decision if we need to transform */
        icc_match = false;
    }
    /* If the color spaces are different and we actually did do a swap of
       the procs for color */
    if ((nos->parent_color_info_procs->parent_color_mapping_procs != NULL &&
        nos_num_color_comp != tos_num_color_comp) || icc_match) {
        if (x0 < x1 && y0 < y1) {
            /* The NOS blending color space is different than that of the
               TOS.  It is necessary to transform the TOS buffer data to the
               color space of the NOS prior to doing the pdf14_compose_group
               operation.  */
            num_noncolor_planes = tos->n_planes - tos_num_color_comp;
            new_num_planes = num_noncolor_planes + nos_num_color_comp;

            /* See if we are doing ICC based conversion */
            if (nos->parent_color_info_procs->icc_profile != NULL &&
                curr_icc_profile != NULL) {
                /* Use the ICC color management for buffer color conversion */
                /* Define the rendering intents */
                rendering_params.black_point_comp = gsBLACKPTCOMP_ON;
                rendering_params.graphics_type_tag = GS_IMAGE_TAG;
                rendering_params.override_icc = false;
                rendering_params.preserve_black = gsBKPRESNOTSPECIFIED;
                rendering_params.rendering_intent = gsPERCEPTUAL;
                rendering_params.cmm = gsCMM_DEFAULT;
                /* Request the ICC link for the transform that we will need to use */
                /* Note that if pgs is NULL we assume the same color space.  This
                   is due to a call to pop the group from fill_mask when filling
                   with a mask with transparency.  In that case, the parent
                   and the child will have the same color space anyway */
                icc_link = gsicc_get_link_profile(pgs, dev, curr_icc_profile,
                                    nos->parent_color_info_procs->icc_profile,
                                    &rendering_params, pgs->memory, false);
                if (icc_link != NULL) {
                    /* if problem with link we will do non-ICC approach */
                    nonicc_conversion = false;
                    /* If the link is the identity, then we don't need to do
                       any color conversions */
                    if ( !(icc_link->is_identity) ) {
                        /* Before we do any allocations check if we can get away with
                           reusing the existing buffer if it is the same size ( if it is
                           smaller go ahead and allocate).  We could reuse it in this
                           case too.  We need to do a bit of testing to determine what
                           would be best.  */
                        /* FIXME: RJW: Could we get away with just color converting
                         * the area that's actually active (i.e. dirty, not rect)?
                         */
                        if(nos_num_color_comp != tos_num_color_comp) {
                            /* Different size.  We will need to allocate */
                            new_data_buf = gs_alloc_bytes(ctx->memory,
                                                tos->planestride * new_num_planes,
                                                    ""pdf14_pop_transparency_group"");
                            if (new_data_buf == NULL)
                                return_error(gs_error_VMerror);
                            /* Copy over the noncolor planes. */
                            memcpy(new_data_buf + tos->planestride * nos_num_color_comp,
                                   tos->data + tos->planestride * tos_num_color_comp,
                                   tos->planestride * num_noncolor_planes);
                        } else {
                            /* In place color conversion! */
                            new_data_buf = tos->data;
                        }
                        /* Set up the buffer descriptors. Note that pdf14 always has
                           the alpha channels at the back end (last planes).
                           We will just handle that here and let the CMM know
                           nothing about it */
                        num_rows = tos->rect.q.y - tos->rect.p.y;
                        num_cols = tos->rect.q.x - tos->rect.p.x;
                        gsicc_init_buffer(&input_buff_desc, tos_num_color_comp, 1,
                                          false, false, true,
                                          tos->planestride, tos->rowstride,
                                          num_rows, num_cols);
                        gsicc_init_buffer(&output_buff_desc, nos_num_color_comp,
                                          1, false, false, true, tos->planestride,
                                          tos->rowstride, num_rows, num_cols);
                        /* Transform the data. Since the pdf14 device should be
                           using RGB, CMYK or Gray buffers, this transform
                           does not need to worry about the cmap procs of
                           the target device.  Those are handled when we do
                           the pdf14 put image operation */
                        (icc_link->procs.map_buffer)(dev, icc_link, &input_buff_desc,
                                                     &output_buff_desc, tos->data,
                                                     new_data_buf);
                    }
                    /* Release the link */
                    gsicc_release_link(icc_link);
                    /* free the old object if the color spaces were different sizes */
                    if(!(icc_link->is_identity) &&
                        nos_num_color_comp != tos_num_color_comp) {
                        gs_free_object(ctx->memory, tos->data,
                            ""pdf14_pop_transparency_group"");
                        tos->data = new_data_buf;
                    }
                }
            }
            if (nonicc_conversion) {
                /* Non ICC based transform */
                new_data_buf = gs_alloc_bytes(ctx->memory,
                                    tos->planestride * new_num_planes,
                                    ""pdf14_pop_transparency_group"");
                if (new_data_buf == NULL)
                    return_error(gs_error_VMerror);
                gs_transform_color_buffer_generic(tos->data, tos->rowstride,
                            tos->planestride, tos_num_color_comp, tos->rect,
                            new_data_buf, nos_num_color_comp, num_noncolor_planes);
                /* Free the old object */
                gs_free_object(ctx->memory, tos->data,
                                ""pdf14_pop_transparency_group"");
                 tos->data = new_data_buf;
            }
             /* Adjust the plane and channel size now */
             tos->n_chan = nos->n_chan;
             tos->n_planes = nos->n_planes;
#if RAW_DUMP
            /* Dump the current buffer to see what we have. */
            dump_raw_buffer(ctx->stack->rect.q.y-ctx->stack->rect.p.y,
                            ctx->stack->rowstride, ctx->stack->n_chan,
                            ctx->stack->planestride, ctx->stack->rowstride,
                            ""aCMTrans_Group_ColorConv"",ctx->stack->data);
#endif
             /* compose. never do overprint in this case */
            pdf14_compose_group(tos, nos, maskbuf, x0, x1, y0, y1, nos->n_chan,
                 nos->parent_color_info_procs->isadditive,
                 nos->parent_color_info_procs->parent_blending_procs,
                 false, drawn_comps, ctx->memory, dev);
        }
    } else {
        /* Group color spaces are the same.  No color conversions needed */
        if (x0 < x1 && y0 < y1)
            pdf14_compose_group(tos, nos, maskbuf, x0, x1, y0, y1, nos->n_chan,
                                ctx->additive, pblend_procs, overprint,
                                drawn_comps, ctx->memory, dev);
    }
exit:
    ctx->stack = nos;
    /* We want to detect the cases where we have luminosity soft masks embedded
       within one another.  The ""alpha"" channel really needs to be merged into
       the luminosity channel in this case.  This will occur during the mask pop */
    if (ctx->smask_depth > 0 && maskbuf != NULL) {
        /* Set the trigger so that we will blend if not alpha. Since
           we have softmasks embedded in softmasks */
        ctx->smask_blend = true;
    }
    if_debug1m('v', ctx->memory, ""[v]pop buf, idle=%d\n"", tos->idle);
    pdf14_buf_free(tos, ctx->memory);
    return 0;
}
",C,"    if (nos == NULL)
        return_error(gs_error_unknownerror);  /* Unmatched group pop */

",,4bef1a1d32e29b68855616020dbff574b9cda08f,"@@ -1066,6 +1066,9 @@ pdf14_pop_transparency_group(gs_gstate *pgs, pdf14_ctx *ctx,
     gx_color_index drawn_comps = pdev->drawn_comps;
     bool nonicc_conversion = true;
 
+    if (nos == NULL)
+        return_error(gs_error_unknownerror);  /* Unmatched group pop */
+
     nos_num_color_comp = nos->parent_color_info_procs->num_components - nos->num_spots;
     tos_num_color_comp = tos_num_color_comp - tos->num_spots;",ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=base/gdevp14.c;h=fd56ec9751c97366fdda5853f9571a537f94b42e;hb=d621292fb2c8157d9899dcd83fd04dd250e30fe4,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=base/gdevp14.c;h=bec5a07c09d170929a71e623d5e70df9420cc647,1,"pdf14_pop_transparency_group(gs_gstate *pgs, pdf14_ctx *ctx,
    const pdf14_nonseparable_blending_procs_t * pblend_procs,
    int tos_num_color_comp, cmm_profile_t *curr_icc_profile, gx_device *dev)
{
    pdf14_buf *tos = ctx->stack;
    pdf14_buf *nos = tos->saved;
    pdf14_mask_t *mask_stack = tos->mask_stack;
    pdf14_buf *maskbuf;
    int x0, x1, y0, y1;
    byte *new_data_buf = NULL;
    int num_noncolor_planes, new_num_planes;
    int num_cols, num_rows, nos_num_color_comp;
    bool icc_match;
    gsicc_rendering_param_t rendering_params;
    gsicc_link_t *icc_link;
    gsicc_bufferdesc_t input_buff_desc;
    gsicc_bufferdesc_t output_buff_desc;
    pdf14_device *pdev = (pdf14_device *)dev;
    bool overprint = pdev->overprint;
     gx_color_index drawn_comps = pdev->drawn_comps;
     bool nonicc_conversion = true;
 
//fix_flaw_line_below:
//    if (nos == NULL)
//fix_flaw_line_below:
//        return_error(gs_error_unknownerror);  /* Unmatched group pop */
//fix_flaw_line_below:
//
     nos_num_color_comp = nos->parent_color_info_procs->num_components - nos->num_spots;
     tos_num_color_comp = tos_num_color_comp - tos->num_spots;
    if (mask_stack == NULL) {
        maskbuf = NULL;
    } else {
        maskbuf = mask_stack->rc_mask->mask_buf;
    }
    if (nos == NULL)
        return_error(gs_error_rangecheck);
    /* Sanitise the dirty rectangles, in case some of the drawing routines
     * have made them overly large. */
    rect_intersect(tos->dirty, tos->rect);
    rect_intersect(nos->dirty, nos->rect);
    /* dirty = the marked bbox. rect = the entire bounds of the buffer. */
    /* Everything marked on tos that fits onto nos needs to be merged down. */
    y0 = max(tos->dirty.p.y, nos->rect.p.y);
    y1 = min(tos->dirty.q.y, nos->rect.q.y);
    x0 = max(tos->dirty.p.x, nos->rect.p.x);
    x1 = min(tos->dirty.q.x, nos->rect.q.x);
    if (ctx->mask_stack) {
        /* This can occur when we have a situation where we are ending out of
           a group that has internal to it a soft mask and another group.
           The soft mask left over from the previous trans group pop is put
           into ctx->masbuf, since it is still active if another trans group
           push occurs to use it.  If one does not occur, but instead we find
           ourselves popping from a parent group, then this softmask is no
           longer needed.  We will rc_decrement and set it to NULL. */
        rc_decrement(ctx->mask_stack->rc_mask, ""pdf14_pop_transparency_group"");
        if (ctx->mask_stack->rc_mask == NULL ){
            gs_free_object(ctx->memory, ctx->mask_stack, ""pdf14_pop_transparency_group"");
        }
        ctx->mask_stack = NULL;
    }
    ctx->mask_stack = mask_stack;  /* Restore the mask saved by pdf14_push_transparency_group. */
    tos->mask_stack = NULL;        /* Clean the pointer sinse the mask ownership is now passed to ctx. */
    if (tos->idle)
        goto exit;
    if (maskbuf != NULL && maskbuf->data == NULL && maskbuf->alpha == 255)
        goto exit;

#if RAW_DUMP
    /* Dump the current buffer to see what we have. */
    dump_raw_buffer(ctx->stack->rect.q.y-ctx->stack->rect.p.y,
                ctx->stack->rowstride, ctx->stack->n_planes,
                ctx->stack->planestride, ctx->stack->rowstride,
                ""aaTrans_Group_Pop"",ctx->stack->data);
#endif
/* Note currently if a pattern space has transparency, the ICC profile is not used
   for blending purposes.  Instead we rely upon the gray, rgb, or cmyk parent space.
   This is partially due to the fact that pdf14_pop_transparency_group and
   pdf14_push_transparnecy_group have no real ICC interaction and those are the
   operations called in the tile transparency code.  Instead we may want to
   look at pdf14_begin_transparency_group and pdf14_end_transparency group which
   is where all the ICC information is handled.  We will return to look at that later */
    if (nos->parent_color_info_procs->icc_profile != NULL) {
        icc_match = (nos->parent_color_info_procs->icc_profile->hashcode !=
                        curr_icc_profile->hashcode);
    } else {
        /* Let the other tests make the decision if we need to transform */
        icc_match = false;
    }
    /* If the color spaces are different and we actually did do a swap of
       the procs for color */
    if ((nos->parent_color_info_procs->parent_color_mapping_procs != NULL &&
        nos_num_color_comp != tos_num_color_comp) || icc_match) {
        if (x0 < x1 && y0 < y1) {
            /* The NOS blending color space is different than that of the
               TOS.  It is necessary to transform the TOS buffer data to the
               color space of the NOS prior to doing the pdf14_compose_group
               operation.  */
            num_noncolor_planes = tos->n_planes - tos_num_color_comp;
            new_num_planes = num_noncolor_planes + nos_num_color_comp;

            /* See if we are doing ICC based conversion */
            if (nos->parent_color_info_procs->icc_profile != NULL &&
                curr_icc_profile != NULL) {
                /* Use the ICC color management for buffer color conversion */
                /* Define the rendering intents */
                rendering_params.black_point_comp = gsBLACKPTCOMP_ON;
                rendering_params.graphics_type_tag = GS_IMAGE_TAG;
                rendering_params.override_icc = false;
                rendering_params.preserve_black = gsBKPRESNOTSPECIFIED;
                rendering_params.rendering_intent = gsPERCEPTUAL;
                rendering_params.cmm = gsCMM_DEFAULT;
                /* Request the ICC link for the transform that we will need to use */
                /* Note that if pgs is NULL we assume the same color space.  This
                   is due to a call to pop the group from fill_mask when filling
                   with a mask with transparency.  In that case, the parent
                   and the child will have the same color space anyway */
                icc_link = gsicc_get_link_profile(pgs, dev, curr_icc_profile,
                                    nos->parent_color_info_procs->icc_profile,
                                    &rendering_params, pgs->memory, false);
                if (icc_link != NULL) {
                    /* if problem with link we will do non-ICC approach */
                    nonicc_conversion = false;
                    /* If the link is the identity, then we don't need to do
                       any color conversions */
                    if ( !(icc_link->is_identity) ) {
                        /* Before we do any allocations check if we can get away with
                           reusing the existing buffer if it is the same size ( if it is
                           smaller go ahead and allocate).  We could reuse it in this
                           case too.  We need to do a bit of testing to determine what
                           would be best.  */
                        /* FIXME: RJW: Could we get away with just color converting
                         * the area that's actually active (i.e. dirty, not rect)?
                         */
                        if(nos_num_color_comp != tos_num_color_comp) {
                            /* Different size.  We will need to allocate */
                            new_data_buf = gs_alloc_bytes(ctx->memory,
                                                tos->planestride * new_num_planes,
                                                    ""pdf14_pop_transparency_group"");
                            if (new_data_buf == NULL)
                                return_error(gs_error_VMerror);
                            /* Copy over the noncolor planes. */
                            memcpy(new_data_buf + tos->planestride * nos_num_color_comp,
                                   tos->data + tos->planestride * tos_num_color_comp,
                                   tos->planestride * num_noncolor_planes);
                        } else {
                            /* In place color conversion! */
                            new_data_buf = tos->data;
                        }
                        /* Set up the buffer descriptors. Note that pdf14 always has
                           the alpha channels at the back end (last planes).
                           We will just handle that here and let the CMM know
                           nothing about it */
                        num_rows = tos->rect.q.y - tos->rect.p.y;
                        num_cols = tos->rect.q.x - tos->rect.p.x;
                        gsicc_init_buffer(&input_buff_desc, tos_num_color_comp, 1,
                                          false, false, true,
                                          tos->planestride, tos->rowstride,
                                          num_rows, num_cols);
                        gsicc_init_buffer(&output_buff_desc, nos_num_color_comp,
                                          1, false, false, true, tos->planestride,
                                          tos->rowstride, num_rows, num_cols);
                        /* Transform the data. Since the pdf14 device should be
                           using RGB, CMYK or Gray buffers, this transform
                           does not need to worry about the cmap procs of
                           the target device.  Those are handled when we do
                           the pdf14 put image operation */
                        (icc_link->procs.map_buffer)(dev, icc_link, &input_buff_desc,
                                                     &output_buff_desc, tos->data,
                                                     new_data_buf);
                    }
                    /* Release the link */
                    gsicc_release_link(icc_link);
                    /* free the old object if the color spaces were different sizes */
                    if(!(icc_link->is_identity) &&
                        nos_num_color_comp != tos_num_color_comp) {
                        gs_free_object(ctx->memory, tos->data,
                            ""pdf14_pop_transparency_group"");
                        tos->data = new_data_buf;
                    }
                }
            }
            if (nonicc_conversion) {
                /* Non ICC based transform */
                new_data_buf = gs_alloc_bytes(ctx->memory,
                                    tos->planestride * new_num_planes,
                                    ""pdf14_pop_transparency_group"");
                if (new_data_buf == NULL)
                    return_error(gs_error_VMerror);
                gs_transform_color_buffer_generic(tos->data, tos->rowstride,
                            tos->planestride, tos_num_color_comp, tos->rect,
                            new_data_buf, nos_num_color_comp, num_noncolor_planes);
                /* Free the old object */
                gs_free_object(ctx->memory, tos->data,
                                ""pdf14_pop_transparency_group"");
                 tos->data = new_data_buf;
            }
             /* Adjust the plane and channel size now */
             tos->n_chan = nos->n_chan;
             tos->n_planes = nos->n_planes;
#if RAW_DUMP
            /* Dump the current buffer to see what we have. */
            dump_raw_buffer(ctx->stack->rect.q.y-ctx->stack->rect.p.y,
                            ctx->stack->rowstride, ctx->stack->n_chan,
                            ctx->stack->planestride, ctx->stack->rowstride,
                            ""aCMTrans_Group_ColorConv"",ctx->stack->data);
#endif
             /* compose. never do overprint in this case */
            pdf14_compose_group(tos, nos, maskbuf, x0, x1, y0, y1, nos->n_chan,
                 nos->parent_color_info_procs->isadditive,
                 nos->parent_color_info_procs->parent_blending_procs,
                 false, drawn_comps, ctx->memory, dev);
        }
    } else {
        /* Group color spaces are the same.  No color conversions needed */
        if (x0 < x1 && y0 < y1)
            pdf14_compose_group(tos, nos, maskbuf, x0, x1, y0, y1, nos->n_chan,
                                ctx->additive, pblend_procs, overprint,
                                drawn_comps, ctx->memory, dev);
    }
exit:
    ctx->stack = nos;
    /* We want to detect the cases where we have luminosity soft masks embedded
       within one another.  The ""alpha"" channel really needs to be merged into
       the luminosity channel in this case.  This will occur during the mask pop */
    if (ctx->smask_depth > 0 && maskbuf != NULL) {
        /* Set the trigger so that we will blend if not alpha. Since
           we have softmasks embedded in softmasks */
        ctx->smask_blend = true;
    }
    if_debug1m('v', ctx->memory, ""[v]pop buf, idle=%d\n"", tos->idle);
    pdf14_buf_free(tos, ctx->memory);
    return 0;
}
"
919,178655,,Remote,Not required,Partial,CVE-2016-10708,https://www.cvedetails.com/cve/CVE-2016-10708/,CWE-476,Low,,,,2018-01-21,5.0,"sshd in OpenSSH before 7.4 allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via an out-of-sequence NEWKEYS message, as demonstrated by Honggfuzz, related to kex.c and packet.c.",2019-06-26,DoS,2,https://anongit.mindrot.org/openssh.git/commit/?id=28652bca29046f62c7045e933e6b931de1d16737,28652bca29046f62c7045e933e6b931de1d16737,,0,,,"kex_input_newkeys(int type, u_int32_t seq, void *ctxt)
{
	struct ssh *ssh = ctxt;
	struct kex *kex = ssh->kex;
	int r;

	debug(""SSH2_MSG_NEWKEYS received"");
 	ssh_dispatch_set(ssh, SSH2_MSG_NEWKEYS, &kex_protocol_error);
 	if ((r = sshpkt_get_end(ssh)) != 0)
 		return r;
	if ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0)
		return r;
 	kex->done = 1;
 	sshbuf_reset(kex->peer);
 	/* sshbuf_reset(kex->my); */
	kex->name = NULL;
	return 0;
}
","kex_input_newkeys(int type, u_int32_t seq, void *ctxt)
{
	struct ssh *ssh = ctxt;
	struct kex *kex = ssh->kex;
	int r;

	debug(""SSH2_MSG_NEWKEYS received"");
 	ssh_dispatch_set(ssh, SSH2_MSG_NEWKEYS, &kex_protocol_error);
 	if ((r = sshpkt_get_end(ssh)) != 0)
 		return r;
 	kex->done = 1;
 	sshbuf_reset(kex->peer);
 	/* sshbuf_reset(kex->my); */
	kex->name = NULL;
	return 0;
}
",C,"	if ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0)
		return r;
",,492710894acfcc2f173d14d1d45bd2e688df605d,"@@ -1,4 +1,4 @@
-/* $OpenBSD: kex.c,v 1.121 2016/09/12 23:31:27 djm Exp $ */
+/* $OpenBSD: kex.c,v 1.122 2016/09/19 19:02:19 markus Exp $ */
 /*
  * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
  *
@@ -425,6 +425,8 @@ kex_input_newkeys(int type, u_int32_t seq, void *ctxt)
 	ssh_dispatch_set(ssh, SSH2_MSG_NEWKEYS, &kex_protocol_error);
 	if ((r = sshpkt_get_end(ssh)) != 0)
 		return r;
+	if ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0)
+		return r;
 	kex->done = 1;
 	sshbuf_reset(kex->peer);
 	/* sshbuf_reset(kex->my); */",mindrot,https://anongit.mindrot.org/openssh.git/tree/kex.c?id=28652bca29046f62c7045e933e6b931de1d16737,https://anongit.mindrot.org/openssh.git/tree/kex.c?id=492710894acfcc2f173d14d1d45bd2e688df605d,1,"kex_input_newkeys(int type, u_int32_t seq, void *ctxt)
{
	struct ssh *ssh = ctxt;
	struct kex *kex = ssh->kex;
	int r;

	debug(""SSH2_MSG_NEWKEYS received"");
 	ssh_dispatch_set(ssh, SSH2_MSG_NEWKEYS, &kex_protocol_error);
 	if ((r = sshpkt_get_end(ssh)) != 0)
 		return r;
//fix_flaw_line_below:
//	if ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0)
//fix_flaw_line_below:
//		return r;
 	kex->done = 1;
 	sshbuf_reset(kex->peer);
 	/* sshbuf_reset(kex->my); */
	kex->name = NULL;
	return 0;
}
"
920,178656,,Remote,Not required,Partial,CVE-2016-10708,https://www.cvedetails.com/cve/CVE-2016-10708/,CWE-476,Low,,,,2018-01-21,5.0,"sshd in OpenSSH before 7.4 allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via an out-of-sequence NEWKEYS message, as demonstrated by Honggfuzz, related to kex.c and packet.c.",2019-06-26,DoS,1,https://anongit.mindrot.org/openssh.git/commit/?id=28652bca29046f62c7045e933e6b931de1d16737,28652bca29046f62c7045e933e6b931de1d16737,,3,,,"ssh_packet_read_poll2(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)
{
	struct session_state *state = ssh->state;
	u_int padlen, need;
	u_char *cp;
	u_int maclen, aadlen = 0, authlen = 0, block_size;
	struct sshenc *enc   = NULL;
	struct sshmac *mac   = NULL;
	struct sshcomp *comp = NULL;
	int r;

	*typep = SSH_MSG_NONE;

	if (state->packet_discard)
		return 0;

	if (state->newkeys[MODE_IN] != NULL) {
		enc  = &state->newkeys[MODE_IN]->enc;
		mac  = &state->newkeys[MODE_IN]->mac;
		comp = &state->newkeys[MODE_IN]->comp;
		/* disable mac for authenticated encryption */
		if ((authlen = cipher_authlen(enc->cipher)) != 0)
			mac = NULL;
	}
	maclen = mac && mac->enabled ? mac->mac_len : 0;
	block_size = enc ? enc->block_size : 8;
	aadlen = (mac && mac->enabled && mac->etm) || authlen ? 4 : 0;

	if (aadlen && state->packlen == 0) {
		if (cipher_get_length(state->receive_context,
		    &state->packlen, state->p_read.seqnr,
		    sshbuf_ptr(state->input), sshbuf_len(state->input)) != 0)
			return 0;
		if (state->packlen < 1 + 4 ||
		    state->packlen > PACKET_MAX_SIZE) {
#ifdef PACKET_DEBUG
			sshbuf_dump(state->input, stderr);
#endif
			logit(""Bad packet length %u."", state->packlen);
			if ((r = sshpkt_disconnect(ssh, ""Packet corrupt"")) != 0)
				return r;
			return SSH_ERR_CONN_CORRUPT;
		}
		sshbuf_reset(state->incoming_packet);
	} else if (state->packlen == 0) {
		/*
		 * check if input size is less than the cipher block size,
		 * decrypt first block and extract length of incoming packet
		 */
		if (sshbuf_len(state->input) < block_size)
			return 0;
		sshbuf_reset(state->incoming_packet);
		if ((r = sshbuf_reserve(state->incoming_packet, block_size,
		    &cp)) != 0)
			goto out;
		if ((r = cipher_crypt(state->receive_context,
		    state->p_send.seqnr, cp, sshbuf_ptr(state->input),
		    block_size, 0, 0)) != 0)
			goto out;
		state->packlen = PEEK_U32(sshbuf_ptr(state->incoming_packet));
		if (state->packlen < 1 + 4 ||
		    state->packlen > PACKET_MAX_SIZE) {
#ifdef PACKET_DEBUG
			fprintf(stderr, ""input: \n"");
			sshbuf_dump(state->input, stderr);
			fprintf(stderr, ""incoming_packet: \n"");
			sshbuf_dump(state->incoming_packet, stderr);
#endif
			logit(""Bad packet length %u."", state->packlen);
			return ssh_packet_start_discard(ssh, enc, mac, 0,
			    PACKET_MAX_SIZE);
		}
		if ((r = sshbuf_consume(state->input, block_size)) != 0)
			goto out;
	}
	DBG(debug(""input: packet len %u"", state->packlen+4));

	if (aadlen) {
		/* only the payload is encrypted */
		need = state->packlen;
	} else {
		/*
		 * the payload size and the payload are encrypted, but we
		 * have a partial packet of block_size bytes
		 */
		need = 4 + state->packlen - block_size;
	}
	DBG(debug(""partial packet: block %d, need %d, maclen %d, authlen %d,""
	    "" aadlen %d"", block_size, need, maclen, authlen, aadlen));
	if (need % block_size != 0) {
		logit(""padding error: need %d block %d mod %d"",
		    need, block_size, need % block_size);
		return ssh_packet_start_discard(ssh, enc, mac, 0,
		    PACKET_MAX_SIZE - block_size);
	}
	/*
	 * check if the entire packet has been received and
	 * decrypt into incoming_packet:
	 * 'aadlen' bytes are unencrypted, but authenticated.
	 * 'need' bytes are encrypted, followed by either
	 * 'authlen' bytes of authentication tag or
	 * 'maclen' bytes of message authentication code.
	 */
	if (sshbuf_len(state->input) < aadlen + need + authlen + maclen)
		return 0; /* packet is incomplete */
#ifdef PACKET_DEBUG
	fprintf(stderr, ""read_poll enc/full: "");
	sshbuf_dump(state->input, stderr);
#endif
	/* EtM: check mac over encrypted input */
	if (mac && mac->enabled && mac->etm) {
		if ((r = mac_check(mac, state->p_read.seqnr,
		    sshbuf_ptr(state->input), aadlen + need,
		    sshbuf_ptr(state->input) + aadlen + need + authlen,
		    maclen)) != 0) {
			if (r == SSH_ERR_MAC_INVALID)
				logit(""Corrupted MAC on input."");
			goto out;
		}
	}
	if ((r = sshbuf_reserve(state->incoming_packet, aadlen + need,
	    &cp)) != 0)
		goto out;
	if ((r = cipher_crypt(state->receive_context, state->p_read.seqnr, cp,
	    sshbuf_ptr(state->input), need, aadlen, authlen)) != 0)
		goto out;
	if ((r = sshbuf_consume(state->input, aadlen + need + authlen)) != 0)
		goto out;
	if (mac && mac->enabled) {
		/* Not EtM: check MAC over cleartext */
		if (!mac->etm && (r = mac_check(mac, state->p_read.seqnr,
		    sshbuf_ptr(state->incoming_packet),
		    sshbuf_len(state->incoming_packet),
		    sshbuf_ptr(state->input), maclen)) != 0) {
			if (r != SSH_ERR_MAC_INVALID)
				goto out;
			logit(""Corrupted MAC on input."");
			if (need > PACKET_MAX_SIZE)
				return SSH_ERR_INTERNAL_ERROR;
			return ssh_packet_start_discard(ssh, enc, mac,
			    sshbuf_len(state->incoming_packet),
			    PACKET_MAX_SIZE - need);
		}
		/* Remove MAC from input buffer */
		DBG(debug(""MAC #%d ok"", state->p_read.seqnr));
		if ((r = sshbuf_consume(state->input, mac->mac_len)) != 0)
			goto out;
	}
	if (seqnr_p != NULL)
		*seqnr_p = state->p_read.seqnr;
	if (++state->p_read.seqnr == 0)
		logit(""incoming seqnr wraps around"");
	if (++state->p_read.packets == 0)
		if (!(ssh->compat & SSH_BUG_NOREKEY))
			return SSH_ERR_NEED_REKEY;
	state->p_read.blocks += (state->packlen + 4) / block_size;
	state->p_read.bytes += state->packlen + 4;

	/* get padlen */
	padlen = sshbuf_ptr(state->incoming_packet)[4];
	DBG(debug(""input: padlen %d"", padlen));
	if (padlen < 4)	{
		if ((r = sshpkt_disconnect(ssh,
		    ""Corrupted padlen %d on input."", padlen)) != 0 ||
		    (r = ssh_packet_write_wait(ssh)) != 0)
			return r;
		return SSH_ERR_CONN_CORRUPT;
	}

	/* skip packet size + padlen, discard padding */
	if ((r = sshbuf_consume(state->incoming_packet, 4 + 1)) != 0 ||
	    ((r = sshbuf_consume_end(state->incoming_packet, padlen)) != 0))
		goto out;

	DBG(debug(""input: len before de-compress %zd"",
	    sshbuf_len(state->incoming_packet)));
	if (comp && comp->enabled) {
		sshbuf_reset(state->compression_buffer);
		if ((r = uncompress_buffer(ssh, state->incoming_packet,
		    state->compression_buffer)) != 0)
			goto out;
		sshbuf_reset(state->incoming_packet);
		if ((r = sshbuf_putb(state->incoming_packet,
		    state->compression_buffer)) != 0)
			goto out;
		DBG(debug(""input: len after de-compress %zd"",
		    sshbuf_len(state->incoming_packet)));
	}
	/*
	 * get packet type, implies consume.
	 * return length of payload (without type field)
	 */
	if ((r = sshbuf_get_u8(state->incoming_packet, typep)) != 0)
		goto out;
	if (ssh_packet_log_type(*typep))
		debug3(""receive packet: type %u"", *typep);
	if (*typep < SSH2_MSG_MIN || *typep >= SSH2_MSG_LOCAL_MIN) {
		if ((r = sshpkt_disconnect(ssh,
		    ""Invalid ssh2 packet type: %d"", *typep)) != 0 ||
		    (r = ssh_packet_write_wait(ssh)) != 0)
 			return r;
 		return SSH_ERR_PROTOCOL_ERROR;
 	}
	if (*typep == SSH2_MSG_USERAUTH_SUCCESS && !state->server_side)
 		r = ssh_packet_enable_delayed_compress(ssh);
 	else
 		r = 0;
	else
		r = 0;
#ifdef PACKET_DEBUG
	fprintf(stderr, ""read/plain[%d]:\r\n"", *typep);
	sshbuf_dump(state->incoming_packet, stderr);
#endif
	/* reset for next packet */
	state->packlen = 0;

	/* do we need to rekey? */
	if (ssh_packet_need_rekeying(ssh, 0)) {
		debug3(""%s: rekex triggered"", __func__);
		if ((r = kex_start_rekex(ssh)) != 0)
			return r;
	}
 out:
	return r;
}
","ssh_packet_read_poll2(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)
{
	struct session_state *state = ssh->state;
	u_int padlen, need;
	u_char *cp;
	u_int maclen, aadlen = 0, authlen = 0, block_size;
	struct sshenc *enc   = NULL;
	struct sshmac *mac   = NULL;
	struct sshcomp *comp = NULL;
	int r;

	*typep = SSH_MSG_NONE;

	if (state->packet_discard)
		return 0;

	if (state->newkeys[MODE_IN] != NULL) {
		enc  = &state->newkeys[MODE_IN]->enc;
		mac  = &state->newkeys[MODE_IN]->mac;
		comp = &state->newkeys[MODE_IN]->comp;
		/* disable mac for authenticated encryption */
		if ((authlen = cipher_authlen(enc->cipher)) != 0)
			mac = NULL;
	}
	maclen = mac && mac->enabled ? mac->mac_len : 0;
	block_size = enc ? enc->block_size : 8;
	aadlen = (mac && mac->enabled && mac->etm) || authlen ? 4 : 0;

	if (aadlen && state->packlen == 0) {
		if (cipher_get_length(state->receive_context,
		    &state->packlen, state->p_read.seqnr,
		    sshbuf_ptr(state->input), sshbuf_len(state->input)) != 0)
			return 0;
		if (state->packlen < 1 + 4 ||
		    state->packlen > PACKET_MAX_SIZE) {
#ifdef PACKET_DEBUG
			sshbuf_dump(state->input, stderr);
#endif
			logit(""Bad packet length %u."", state->packlen);
			if ((r = sshpkt_disconnect(ssh, ""Packet corrupt"")) != 0)
				return r;
			return SSH_ERR_CONN_CORRUPT;
		}
		sshbuf_reset(state->incoming_packet);
	} else if (state->packlen == 0) {
		/*
		 * check if input size is less than the cipher block size,
		 * decrypt first block and extract length of incoming packet
		 */
		if (sshbuf_len(state->input) < block_size)
			return 0;
		sshbuf_reset(state->incoming_packet);
		if ((r = sshbuf_reserve(state->incoming_packet, block_size,
		    &cp)) != 0)
			goto out;
		if ((r = cipher_crypt(state->receive_context,
		    state->p_send.seqnr, cp, sshbuf_ptr(state->input),
		    block_size, 0, 0)) != 0)
			goto out;
		state->packlen = PEEK_U32(sshbuf_ptr(state->incoming_packet));
		if (state->packlen < 1 + 4 ||
		    state->packlen > PACKET_MAX_SIZE) {
#ifdef PACKET_DEBUG
			fprintf(stderr, ""input: \n"");
			sshbuf_dump(state->input, stderr);
			fprintf(stderr, ""incoming_packet: \n"");
			sshbuf_dump(state->incoming_packet, stderr);
#endif
			logit(""Bad packet length %u."", state->packlen);
			return ssh_packet_start_discard(ssh, enc, mac, 0,
			    PACKET_MAX_SIZE);
		}
		if ((r = sshbuf_consume(state->input, block_size)) != 0)
			goto out;
	}
	DBG(debug(""input: packet len %u"", state->packlen+4));

	if (aadlen) {
		/* only the payload is encrypted */
		need = state->packlen;
	} else {
		/*
		 * the payload size and the payload are encrypted, but we
		 * have a partial packet of block_size bytes
		 */
		need = 4 + state->packlen - block_size;
	}
	DBG(debug(""partial packet: block %d, need %d, maclen %d, authlen %d,""
	    "" aadlen %d"", block_size, need, maclen, authlen, aadlen));
	if (need % block_size != 0) {
		logit(""padding error: need %d block %d mod %d"",
		    need, block_size, need % block_size);
		return ssh_packet_start_discard(ssh, enc, mac, 0,
		    PACKET_MAX_SIZE - block_size);
	}
	/*
	 * check if the entire packet has been received and
	 * decrypt into incoming_packet:
	 * 'aadlen' bytes are unencrypted, but authenticated.
	 * 'need' bytes are encrypted, followed by either
	 * 'authlen' bytes of authentication tag or
	 * 'maclen' bytes of message authentication code.
	 */
	if (sshbuf_len(state->input) < aadlen + need + authlen + maclen)
		return 0; /* packet is incomplete */
#ifdef PACKET_DEBUG
	fprintf(stderr, ""read_poll enc/full: "");
	sshbuf_dump(state->input, stderr);
#endif
	/* EtM: check mac over encrypted input */
	if (mac && mac->enabled && mac->etm) {
		if ((r = mac_check(mac, state->p_read.seqnr,
		    sshbuf_ptr(state->input), aadlen + need,
		    sshbuf_ptr(state->input) + aadlen + need + authlen,
		    maclen)) != 0) {
			if (r == SSH_ERR_MAC_INVALID)
				logit(""Corrupted MAC on input."");
			goto out;
		}
	}
	if ((r = sshbuf_reserve(state->incoming_packet, aadlen + need,
	    &cp)) != 0)
		goto out;
	if ((r = cipher_crypt(state->receive_context, state->p_read.seqnr, cp,
	    sshbuf_ptr(state->input), need, aadlen, authlen)) != 0)
		goto out;
	if ((r = sshbuf_consume(state->input, aadlen + need + authlen)) != 0)
		goto out;
	if (mac && mac->enabled) {
		/* Not EtM: check MAC over cleartext */
		if (!mac->etm && (r = mac_check(mac, state->p_read.seqnr,
		    sshbuf_ptr(state->incoming_packet),
		    sshbuf_len(state->incoming_packet),
		    sshbuf_ptr(state->input), maclen)) != 0) {
			if (r != SSH_ERR_MAC_INVALID)
				goto out;
			logit(""Corrupted MAC on input."");
			if (need > PACKET_MAX_SIZE)
				return SSH_ERR_INTERNAL_ERROR;
			return ssh_packet_start_discard(ssh, enc, mac,
			    sshbuf_len(state->incoming_packet),
			    PACKET_MAX_SIZE - need);
		}
		/* Remove MAC from input buffer */
		DBG(debug(""MAC #%d ok"", state->p_read.seqnr));
		if ((r = sshbuf_consume(state->input, mac->mac_len)) != 0)
			goto out;
	}
	if (seqnr_p != NULL)
		*seqnr_p = state->p_read.seqnr;
	if (++state->p_read.seqnr == 0)
		logit(""incoming seqnr wraps around"");
	if (++state->p_read.packets == 0)
		if (!(ssh->compat & SSH_BUG_NOREKEY))
			return SSH_ERR_NEED_REKEY;
	state->p_read.blocks += (state->packlen + 4) / block_size;
	state->p_read.bytes += state->packlen + 4;

	/* get padlen */
	padlen = sshbuf_ptr(state->incoming_packet)[4];
	DBG(debug(""input: padlen %d"", padlen));
	if (padlen < 4)	{
		if ((r = sshpkt_disconnect(ssh,
		    ""Corrupted padlen %d on input."", padlen)) != 0 ||
		    (r = ssh_packet_write_wait(ssh)) != 0)
			return r;
		return SSH_ERR_CONN_CORRUPT;
	}

	/* skip packet size + padlen, discard padding */
	if ((r = sshbuf_consume(state->incoming_packet, 4 + 1)) != 0 ||
	    ((r = sshbuf_consume_end(state->incoming_packet, padlen)) != 0))
		goto out;

	DBG(debug(""input: len before de-compress %zd"",
	    sshbuf_len(state->incoming_packet)));
	if (comp && comp->enabled) {
		sshbuf_reset(state->compression_buffer);
		if ((r = uncompress_buffer(ssh, state->incoming_packet,
		    state->compression_buffer)) != 0)
			goto out;
		sshbuf_reset(state->incoming_packet);
		if ((r = sshbuf_putb(state->incoming_packet,
		    state->compression_buffer)) != 0)
			goto out;
		DBG(debug(""input: len after de-compress %zd"",
		    sshbuf_len(state->incoming_packet)));
	}
	/*
	 * get packet type, implies consume.
	 * return length of payload (without type field)
	 */
	if ((r = sshbuf_get_u8(state->incoming_packet, typep)) != 0)
		goto out;
	if (ssh_packet_log_type(*typep))
		debug3(""receive packet: type %u"", *typep);
	if (*typep < SSH2_MSG_MIN || *typep >= SSH2_MSG_LOCAL_MIN) {
		if ((r = sshpkt_disconnect(ssh,
		    ""Invalid ssh2 packet type: %d"", *typep)) != 0 ||
		    (r = ssh_packet_write_wait(ssh)) != 0)
 			return r;
 		return SSH_ERR_PROTOCOL_ERROR;
 	}
	if (*typep == SSH2_MSG_NEWKEYS)
		r = ssh_set_newkeys(ssh, MODE_IN);
	else if (*typep == SSH2_MSG_USERAUTH_SUCCESS && !state->server_side)
 		r = ssh_packet_enable_delayed_compress(ssh);
 	else
 		r = 0;
	else
		r = 0;
#ifdef PACKET_DEBUG
	fprintf(stderr, ""read/plain[%d]:\r\n"", *typep);
	sshbuf_dump(state->incoming_packet, stderr);
#endif
	/* reset for next packet */
	state->packlen = 0;

	/* do we need to rekey? */
	if (ssh_packet_need_rekeying(ssh, 0)) {
		debug3(""%s: rekex triggered"", __func__);
		if ((r = kex_start_rekex(ssh)) != 0)
			return r;
	}
 out:
	return r;
}
",C,"	if (*typep == SSH2_MSG_USERAUTH_SUCCESS && !state->server_side)
","	if (*typep == SSH2_MSG_NEWKEYS)
		r = ssh_set_newkeys(ssh, MODE_IN);
	else if (*typep == SSH2_MSG_USERAUTH_SUCCESS && !state->server_side)
",492710894acfcc2f173d14d1d45bd2e688df605d,"@@ -1,4 +1,4 @@
-/* $OpenBSD: packet.c,v 1.237 2016/09/12 01:22:38 deraadt Exp $ */
+/* $OpenBSD: packet.c,v 1.238 2016/09/19 19:02:19 markus Exp $ */
 /*
  * Author: Tatu Ylonen <ylo@cs.hut.fi>
  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
@@ -1907,9 +1907,7 @@ ssh_packet_read_poll2(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)
 			return r;
 		return SSH_ERR_PROTOCOL_ERROR;
 	}
-	if (*typep == SSH2_MSG_NEWKEYS)
-		r = ssh_set_newkeys(ssh, MODE_IN);
-	else if (*typep == SSH2_MSG_USERAUTH_SUCCESS && !state->server_side)
+	if (*typep == SSH2_MSG_USERAUTH_SUCCESS && !state->server_side)
 		r = ssh_packet_enable_delayed_compress(ssh);
 	else
 		r = 0;",mindrot,https://anongit.mindrot.org/openssh.git/tree/packet.c?id=28652bca29046f62c7045e933e6b931de1d16737,https://anongit.mindrot.org/openssh.git/tree/packet.c?id=492710894acfcc2f173d14d1d45bd2e688df605d,1,"ssh_packet_read_poll2(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)
{
	struct session_state *state = ssh->state;
	u_int padlen, need;
	u_char *cp;
	u_int maclen, aadlen = 0, authlen = 0, block_size;
	struct sshenc *enc   = NULL;
	struct sshmac *mac   = NULL;
	struct sshcomp *comp = NULL;
	int r;

	*typep = SSH_MSG_NONE;

	if (state->packet_discard)
		return 0;

	if (state->newkeys[MODE_IN] != NULL) {
		enc  = &state->newkeys[MODE_IN]->enc;
		mac  = &state->newkeys[MODE_IN]->mac;
		comp = &state->newkeys[MODE_IN]->comp;
		/* disable mac for authenticated encryption */
		if ((authlen = cipher_authlen(enc->cipher)) != 0)
			mac = NULL;
	}
	maclen = mac && mac->enabled ? mac->mac_len : 0;
	block_size = enc ? enc->block_size : 8;
	aadlen = (mac && mac->enabled && mac->etm) || authlen ? 4 : 0;

	if (aadlen && state->packlen == 0) {
		if (cipher_get_length(state->receive_context,
		    &state->packlen, state->p_read.seqnr,
		    sshbuf_ptr(state->input), sshbuf_len(state->input)) != 0)
			return 0;
		if (state->packlen < 1 + 4 ||
		    state->packlen > PACKET_MAX_SIZE) {
#ifdef PACKET_DEBUG
			sshbuf_dump(state->input, stderr);
#endif
			logit(""Bad packet length %u."", state->packlen);
			if ((r = sshpkt_disconnect(ssh, ""Packet corrupt"")) != 0)
				return r;
			return SSH_ERR_CONN_CORRUPT;
		}
		sshbuf_reset(state->incoming_packet);
	} else if (state->packlen == 0) {
		/*
		 * check if input size is less than the cipher block size,
		 * decrypt first block and extract length of incoming packet
		 */
		if (sshbuf_len(state->input) < block_size)
			return 0;
		sshbuf_reset(state->incoming_packet);
		if ((r = sshbuf_reserve(state->incoming_packet, block_size,
		    &cp)) != 0)
			goto out;
		if ((r = cipher_crypt(state->receive_context,
		    state->p_send.seqnr, cp, sshbuf_ptr(state->input),
		    block_size, 0, 0)) != 0)
			goto out;
		state->packlen = PEEK_U32(sshbuf_ptr(state->incoming_packet));
		if (state->packlen < 1 + 4 ||
		    state->packlen > PACKET_MAX_SIZE) {
#ifdef PACKET_DEBUG
			fprintf(stderr, ""input: \n"");
			sshbuf_dump(state->input, stderr);
			fprintf(stderr, ""incoming_packet: \n"");
			sshbuf_dump(state->incoming_packet, stderr);
#endif
			logit(""Bad packet length %u."", state->packlen);
			return ssh_packet_start_discard(ssh, enc, mac, 0,
			    PACKET_MAX_SIZE);
		}
		if ((r = sshbuf_consume(state->input, block_size)) != 0)
			goto out;
	}
	DBG(debug(""input: packet len %u"", state->packlen+4));

	if (aadlen) {
		/* only the payload is encrypted */
		need = state->packlen;
	} else {
		/*
		 * the payload size and the payload are encrypted, but we
		 * have a partial packet of block_size bytes
		 */
		need = 4 + state->packlen - block_size;
	}
	DBG(debug(""partial packet: block %d, need %d, maclen %d, authlen %d,""
	    "" aadlen %d"", block_size, need, maclen, authlen, aadlen));
	if (need % block_size != 0) {
		logit(""padding error: need %d block %d mod %d"",
		    need, block_size, need % block_size);
		return ssh_packet_start_discard(ssh, enc, mac, 0,
		    PACKET_MAX_SIZE - block_size);
	}
	/*
	 * check if the entire packet has been received and
	 * decrypt into incoming_packet:
	 * 'aadlen' bytes are unencrypted, but authenticated.
	 * 'need' bytes are encrypted, followed by either
	 * 'authlen' bytes of authentication tag or
	 * 'maclen' bytes of message authentication code.
	 */
	if (sshbuf_len(state->input) < aadlen + need + authlen + maclen)
		return 0; /* packet is incomplete */
#ifdef PACKET_DEBUG
	fprintf(stderr, ""read_poll enc/full: "");
	sshbuf_dump(state->input, stderr);
#endif
	/* EtM: check mac over encrypted input */
	if (mac && mac->enabled && mac->etm) {
		if ((r = mac_check(mac, state->p_read.seqnr,
		    sshbuf_ptr(state->input), aadlen + need,
		    sshbuf_ptr(state->input) + aadlen + need + authlen,
		    maclen)) != 0) {
			if (r == SSH_ERR_MAC_INVALID)
				logit(""Corrupted MAC on input."");
			goto out;
		}
	}
	if ((r = sshbuf_reserve(state->incoming_packet, aadlen + need,
	    &cp)) != 0)
		goto out;
	if ((r = cipher_crypt(state->receive_context, state->p_read.seqnr, cp,
	    sshbuf_ptr(state->input), need, aadlen, authlen)) != 0)
		goto out;
	if ((r = sshbuf_consume(state->input, aadlen + need + authlen)) != 0)
		goto out;
	if (mac && mac->enabled) {
		/* Not EtM: check MAC over cleartext */
		if (!mac->etm && (r = mac_check(mac, state->p_read.seqnr,
		    sshbuf_ptr(state->incoming_packet),
		    sshbuf_len(state->incoming_packet),
		    sshbuf_ptr(state->input), maclen)) != 0) {
			if (r != SSH_ERR_MAC_INVALID)
				goto out;
			logit(""Corrupted MAC on input."");
			if (need > PACKET_MAX_SIZE)
				return SSH_ERR_INTERNAL_ERROR;
			return ssh_packet_start_discard(ssh, enc, mac,
			    sshbuf_len(state->incoming_packet),
			    PACKET_MAX_SIZE - need);
		}
		/* Remove MAC from input buffer */
		DBG(debug(""MAC #%d ok"", state->p_read.seqnr));
		if ((r = sshbuf_consume(state->input, mac->mac_len)) != 0)
			goto out;
	}
	if (seqnr_p != NULL)
		*seqnr_p = state->p_read.seqnr;
	if (++state->p_read.seqnr == 0)
		logit(""incoming seqnr wraps around"");
	if (++state->p_read.packets == 0)
		if (!(ssh->compat & SSH_BUG_NOREKEY))
			return SSH_ERR_NEED_REKEY;
	state->p_read.blocks += (state->packlen + 4) / block_size;
	state->p_read.bytes += state->packlen + 4;

	/* get padlen */
	padlen = sshbuf_ptr(state->incoming_packet)[4];
	DBG(debug(""input: padlen %d"", padlen));
	if (padlen < 4)	{
		if ((r = sshpkt_disconnect(ssh,
		    ""Corrupted padlen %d on input."", padlen)) != 0 ||
		    (r = ssh_packet_write_wait(ssh)) != 0)
			return r;
		return SSH_ERR_CONN_CORRUPT;
	}

	/* skip packet size + padlen, discard padding */
	if ((r = sshbuf_consume(state->incoming_packet, 4 + 1)) != 0 ||
	    ((r = sshbuf_consume_end(state->incoming_packet, padlen)) != 0))
		goto out;

	DBG(debug(""input: len before de-compress %zd"",
	    sshbuf_len(state->incoming_packet)));
	if (comp && comp->enabled) {
		sshbuf_reset(state->compression_buffer);
		if ((r = uncompress_buffer(ssh, state->incoming_packet,
		    state->compression_buffer)) != 0)
			goto out;
		sshbuf_reset(state->incoming_packet);
		if ((r = sshbuf_putb(state->incoming_packet,
		    state->compression_buffer)) != 0)
			goto out;
		DBG(debug(""input: len after de-compress %zd"",
		    sshbuf_len(state->incoming_packet)));
	}
	/*
	 * get packet type, implies consume.
	 * return length of payload (without type field)
	 */
	if ((r = sshbuf_get_u8(state->incoming_packet, typep)) != 0)
		goto out;
	if (ssh_packet_log_type(*typep))
		debug3(""receive packet: type %u"", *typep);
	if (*typep < SSH2_MSG_MIN || *typep >= SSH2_MSG_LOCAL_MIN) {
		if ((r = sshpkt_disconnect(ssh,
		    ""Invalid ssh2 packet type: %d"", *typep)) != 0 ||
		    (r = ssh_packet_write_wait(ssh)) != 0)
 			return r;
 		return SSH_ERR_PROTOCOL_ERROR;
 	}
//flaw_line_below:
	if (*typep == SSH2_MSG_NEWKEYS)
//flaw_line_below:
		r = ssh_set_newkeys(ssh, MODE_IN);
//flaw_line_below:
	else if (*typep == SSH2_MSG_USERAUTH_SUCCESS && !state->server_side)
//fix_flaw_line_below:
//	if (*typep == SSH2_MSG_USERAUTH_SUCCESS && !state->server_side)
 		r = ssh_packet_enable_delayed_compress(ssh);
 	else
 		r = 0;
	else
		r = 0;
#ifdef PACKET_DEBUG
	fprintf(stderr, ""read/plain[%d]:\r\n"", *typep);
	sshbuf_dump(state->incoming_packet, stderr);
#endif
	/* reset for next packet */
	state->packlen = 0;

	/* do we need to rekey? */
	if (ssh_packet_need_rekeying(ssh, 0)) {
		debug3(""%s: rekex triggered"", __func__);
		if ((r = kex_start_rekex(ssh)) != 0)
			return r;
	}
 out:
	return r;
}
"
944,178680,,Remote,Not required,Partial,CVE-2015-9261,https://www.cvedetails.com/cve/CVE-2015-9261/,CWE-476,Medium,,,,2018-07-26,4.3,"huft_build in archival/libarchive/decompress_gunzip.c in BusyBox before 1.27.2 misuses a pointer, causing segfaults and an application crash during an unzip operation on a specially crafted ZIP file.",2019-06-13,,3,https://git.busybox.net/busybox/commit/?id=1de25a6e87e0e627aa34298105a3d17c60a1f44e,1de25a6e87e0e627aa34298105a3d17c60a1f44e,,2,,,"static int huft_build(const unsigned *b, const unsigned n,
			const unsigned s, const unsigned short *d,
			const unsigned char *e, huft_t **t, unsigned *m)
{
	unsigned a;             /* counter for codes of length k */
	unsigned c[BMAX + 1];   /* bit length count table */
	unsigned eob_len;       /* length of end-of-block code (value 256) */
	unsigned f;             /* i repeats in table every f entries */
	int g;                  /* maximum code length */
	int htl;                /* table level */
 	unsigned i;             /* counter, current code */
 	unsigned j;             /* counter */
 	int k;                  /* number of bits in current code */
	const unsigned *p;      /* pointer into c[], b[], or v[] */
 	huft_t *q;              /* points to current table */
 	huft_t r;               /* table entry for structure assignment */
 	huft_t *u[BMAX];        /* table stack */
 	unsigned v[N_MAX];      /* values in order of bit length */
	unsigned v_end;
 	int ws[BMAX + 1];       /* bits decoded stack */
 	int w;                  /* bits decoded */
 	unsigned x[BMAX + 1];   /* bit offsets, then code stack */
	int y;                  /* number of dummy codes added */
	unsigned z;             /* number of entries in current table */

	/* Length of EOB code, if any */
	eob_len = n > 256 ? b[256] : BMAX;

	*t = NULL;

 
 	/* Generate counts for each bit length */
 	memset(c, 0, sizeof(c));
	p = b;
 	i = n;
 	do {
 		c[*p]++; /* assume all entries <= BMAX */
	} while (--i);
	if (c[0] == n) {  /* null input - all zero length codes */
		*m = 0;
		return 2;
	}

	/* Find minimum and maximum length, bound *m by those */
	for (j = 1; (j <= BMAX) && (c[j] == 0); j++)
		continue;
	k = j; /* minimum code length */
	for (i = BMAX; (c[i] == 0) && i; i--)
		continue;
	g = i; /* maximum code length */
	*m = (*m < j) ? j : ((*m > i) ? i : *m);

	/* Adjust last length count to fill out codes, if needed */
	for (y = 1 << j; j < i; j++, y <<= 1) {
		y -= c[j];
		if (y < 0)
			return 2; /* bad input: more codes than bits */
	}
	y -= c[i];
	if (y < 0)
		return 2;
	c[i] += y;

	/* Generate starting offsets into the value table for each length */
	x[1] = j = 0;
	p = c + 1;
	xp = x + 2;
	while (--i) { /* note that i == g from above */
		j += *p++;
		*xp++ = j;
	}
 	}
","static int huft_build(const unsigned *b, const unsigned n,
			const unsigned s, const unsigned short *d,
			const unsigned char *e, huft_t **t, unsigned *m)
{
	unsigned a;             /* counter for codes of length k */
	unsigned c[BMAX + 1];   /* bit length count table */
	unsigned eob_len;       /* length of end-of-block code (value 256) */
	unsigned f;             /* i repeats in table every f entries */
	int g;                  /* maximum code length */
	int htl;                /* table level */
 	unsigned i;             /* counter, current code */
 	unsigned j;             /* counter */
 	int k;                  /* number of bits in current code */
	unsigned *p;            /* pointer into c[], b[], or v[] */
 	huft_t *q;              /* points to current table */
 	huft_t r;               /* table entry for structure assignment */
 	huft_t *u[BMAX];        /* table stack */
 	unsigned v[N_MAX];      /* values in order of bit length */
 	int ws[BMAX + 1];       /* bits decoded stack */
 	int w;                  /* bits decoded */
 	unsigned x[BMAX + 1];   /* bit offsets, then code stack */
	int y;                  /* number of dummy codes added */
	unsigned z;             /* number of entries in current table */

	/* Length of EOB code, if any */
	eob_len = n > 256 ? b[256] : BMAX;

	*t = NULL;

 
 	/* Generate counts for each bit length */
 	memset(c, 0, sizeof(c));
	p = (unsigned *) b; /* cast allows us to reuse p for pointing to b */
 	i = n;
 	do {
 		c[*p]++; /* assume all entries <= BMAX */
	} while (--i);
	if (c[0] == n) {  /* null input - all zero length codes */
		*m = 0;
		return 2;
	}

	/* Find minimum and maximum length, bound *m by those */
	for (j = 1; (j <= BMAX) && (c[j] == 0); j++)
		continue;
	k = j; /* minimum code length */
	for (i = BMAX; (c[i] == 0) && i; i--)
		continue;
	g = i; /* maximum code length */
	*m = (*m < j) ? j : ((*m > i) ? i : *m);

	/* Adjust last length count to fill out codes, if needed */
	for (y = 1 << j; j < i; j++, y <<= 1) {
		y -= c[j];
		if (y < 0)
			return 2; /* bad input: more codes than bits */
	}
	y -= c[i];
	if (y < 0)
		return 2;
	c[i] += y;

	/* Generate starting offsets into the value table for each length */
	x[1] = j = 0;
	p = c + 1;
	xp = x + 2;
	while (--i) { /* note that i == g from above */
		j += *p++;
		*xp++ = j;
	}
 	}
",C,"	const unsigned *p;      /* pointer into c[], b[], or v[] */
	unsigned v_end;
	p = b;
","	unsigned *p;            /* pointer into c[], b[], or v[] */
	p = (unsigned *) b; /* cast allows us to reuse p for pointing to b */
",d683c5c2f1493c2b0856a5f8751508836b0988d5,"@@ -305,11 +305,12 @@ static int huft_build(const unsigned *b, const unsigned n,
 	unsigned i;             /* counter, current code */
 	unsigned j;             /* counter */
 	int k;                  /* number of bits in current code */
-	unsigned *p;            /* pointer into c[], b[], or v[] */
+	const unsigned *p;      /* pointer into c[], b[], or v[] */
 	huft_t *q;              /* points to current table */
 	huft_t r;               /* table entry for structure assignment */
 	huft_t *u[BMAX];        /* table stack */
 	unsigned v[N_MAX];      /* values in order of bit length */
+	unsigned v_end;
 	int ws[BMAX + 1];       /* bits decoded stack */
 	int w;                  /* bits decoded */
 	unsigned x[BMAX + 1];   /* bit offsets, then code stack */
@@ -324,7 +325,7 @@ static int huft_build(const unsigned *b, const unsigned n,
 
 	/* Generate counts for each bit length */
 	memset(c, 0, sizeof(c));
-	p = (unsigned *) b; /* cast allows us to reuse p for pointing to b */
+	p = b;
 	i = n;
 	do {
 		c[*p]++; /* assume all entries <= BMAX */
@@ -365,12 +366,14 @@ static int huft_build(const unsigned *b, const unsigned n,
 	}
 
 	/* Make a table of values in order of bit lengths */
-	p = (unsigned *) b;
+	p = b;
 	i = 0;
+	v_end = 0;
 	do {
 		j = *p++;
 		if (j != 0) {
 			v[x[j]++] = i;
+			v_end = x[j];
 		}
 	} while (++i < n);
 
@@ -432,7 +435,7 @@ static int huft_build(const unsigned *b, const unsigned n,
 
 			/* set up table entry in r */
 			r.b = (unsigned char) (k - w);
-			if (p >= v + n) {
+			if (p >= v + v_end) { // Was ""if (p >= v + n)"" but v[] can be shorter!
 				r.e = 99; /* out of values--invalid code */
 			} else if (*p < s) {
 				r.e = (unsigned char) (*p < 256 ? 16 : 15);	/* 256 is EOB code */",busybox,https://git.busybox.net/busybox/tree/archival/libarchive/decompress_gunzip.c?id=1de25a6e87e0e627aa34298105a3d17c60a1f44e,https://git.busybox.net/busybox/tree/archival/libarchive/decompress_gunzip.c?id=d683c5c2f1493c2b0856a5f8751508836b0988d5,1,"static int huft_build(const unsigned *b, const unsigned n,
			const unsigned s, const unsigned short *d,
			const unsigned char *e, huft_t **t, unsigned *m)
{
	unsigned a;             /* counter for codes of length k */
	unsigned c[BMAX + 1];   /* bit length count table */
	unsigned eob_len;       /* length of end-of-block code (value 256) */
	unsigned f;             /* i repeats in table every f entries */
	int g;                  /* maximum code length */
	int htl;                /* table level */
 	unsigned i;             /* counter, current code */
 	unsigned j;             /* counter */
 	int k;                  /* number of bits in current code */
//flaw_line_below:
	unsigned *p;            /* pointer into c[], b[], or v[] */
//fix_flaw_line_below:
//	const unsigned *p;      /* pointer into c[], b[], or v[] */
 	huft_t *q;              /* points to current table */
 	huft_t r;               /* table entry for structure assignment */
 	huft_t *u[BMAX];        /* table stack */
 	unsigned v[N_MAX];      /* values in order of bit length */
//fix_flaw_line_below:
//	unsigned v_end;
 	int ws[BMAX + 1];       /* bits decoded stack */
 	int w;                  /* bits decoded */
 	unsigned x[BMAX + 1];   /* bit offsets, then code stack */
	int y;                  /* number of dummy codes added */
	unsigned z;             /* number of entries in current table */

	/* Length of EOB code, if any */
	eob_len = n > 256 ? b[256] : BMAX;

	*t = NULL;

 
 	/* Generate counts for each bit length */
 	memset(c, 0, sizeof(c));
//flaw_line_below:
	p = (unsigned *) b; /* cast allows us to reuse p for pointing to b */
//fix_flaw_line_below:
//	p = b;
 	i = n;
 	do {
 		c[*p]++; /* assume all entries <= BMAX */
	} while (--i);
	if (c[0] == n) {  /* null input - all zero length codes */
		*m = 0;
		return 2;
	}

	/* Find minimum and maximum length, bound *m by those */
	for (j = 1; (j <= BMAX) && (c[j] == 0); j++)
		continue;
	k = j; /* minimum code length */
	for (i = BMAX; (c[i] == 0) && i; i--)
		continue;
	g = i; /* maximum code length */
	*m = (*m < j) ? j : ((*m > i) ? i : *m);

	/* Adjust last length count to fill out codes, if needed */
	for (y = 1 << j; j < i; j++, y <<= 1) {
		y -= c[j];
		if (y < 0)
			return 2; /* bad input: more codes than bits */
	}
	y -= c[i];
	if (y < 0)
		return 2;
	c[i] += y;

	/* Generate starting offsets into the value table for each length */
	x[1] = j = 0;
	p = c + 1;
	xp = x + 2;
	while (--i) { /* note that i == g from above */
		j += *p++;
		*xp++ = j;
	}
 	}
"
1746,179482,,Remote,Not required,Complete,CVE-2014-4344,https://www.cvedetails.com/cve/CVE-2014-4344/,CWE-476,Low,,,,2014-08-14,7.8,The acc_ctx_cont function in the SPNEGO acceptor in lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) 1.5.x through 1.12.x before 1.12.2 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an empty continuation token at a certain point during a SPNEGO negotiation.,2017-08-28,DoS ,1,https://github.com/krb5/krb5/commit/a7886f0ed1277c69142b14a2c6629175a6331edc,a7886f0ed1277c69142b14a2c6629175a6331edc,"Fix null deref in SPNEGO acceptor [CVE-2014-4344]

When processing a continuation token, acc_ctx_cont was dereferencing
the initial byte of the token without checking the length.  This could
result in a null dereference.

CVE-2014-4344:

In MIT krb5 1.5 and newer, an unauthenticated or partially
authenticated remote attacker can cause a NULL dereference and
application crash during a SPNEGO negotiation by sending an empty
token as the second or later context token from initiator to acceptor.
The attacker must provide at least one valid context token in the
security context negotiation before sending the empty token.  This can
be done by an unauthenticated attacker by forcing SPNEGO to
renegotiate the underlying mechanism, or by using IAKERB to wrap an
unauthenticated AS-REQ as the first token.

    CVSSv2 Vector: AV:N/AC:L/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[kaduk@mit.edu: CVE summary, CVSSv2 vector]

(cherry picked from commit 524688ce87a15fc75f87efc8c039ba4c7d5c197b)

ticket: 7970
version_fixed: 1.12.2
status: resolved",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""65e1306cdb974a3a24c7890a090c5dc9ac3b54cd"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/a7886f0ed1277c69142b14a2c6629175a6331edc/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/a7886f0ed1277c69142b14a2c6629175a6331edc/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=a7886f0ed1277c69142b14a2c6629175a6331edc"", ""patch"": ""@@ -1442,7 +1442,7 @@ acc_ctx_cont(OM_uint32 *minstat,\n \n \tptr = bufstart = buf->value;\n #define REMAIN (buf->length - (ptr - bufstart))\n-\tif (REMAIN > INT_MAX)\n+\tif (REMAIN == 0 || REMAIN > INT_MAX)\n \t\treturn GSS_S_DEFECTIVE_TOKEN;\n \n \t/*""}","acc_ctx_cont(OM_uint32 *minstat,
	     gss_buffer_t buf,
	     gss_ctx_id_t *ctx,
	     gss_buffer_t *responseToken,
	     gss_buffer_t *mechListMIC,
	     OM_uint32 *negState,
	     send_token_flag *return_token)
{
	OM_uint32 ret, tmpmin;
	gss_OID supportedMech;
	spnego_gss_ctx_id_t sc;
	unsigned int len;
	unsigned char *ptr, *bufstart;

	sc = (spnego_gss_ctx_id_t)*ctx;
	ret = GSS_S_DEFECTIVE_TOKEN;
	*negState = REJECT;
	*minstat = 0;
	supportedMech = GSS_C_NO_OID;
	*return_token = ERROR_TOKEN_SEND;
	*responseToken = *mechListMIC = GSS_C_NO_BUFFER;
 
 	ptr = bufstart = buf->value;
 #define REMAIN (buf->length - (ptr - bufstart))
	if (REMAIN == 0 || REMAIN > INT_MAX)
 		return GSS_S_DEFECTIVE_TOKEN;
 
 	/*
	 * Attempt to work with old Sun SPNEGO.
	 */
	if (*ptr == HEADER_ID) {
		ret = g_verify_token_header(gss_mech_spnego,
					    &len, &ptr, 0, REMAIN);
		if (ret) {
			*minstat = ret;
			return GSS_S_DEFECTIVE_TOKEN;
		}
	}
	if (*ptr != (CONTEXT | 0x01)) {
		return GSS_S_DEFECTIVE_TOKEN;
	}
	ret = get_negTokenResp(minstat, ptr, REMAIN,
			       negState, &supportedMech,
			       responseToken, mechListMIC);
	if (ret != GSS_S_COMPLETE)
		goto cleanup;

	if (*responseToken == GSS_C_NO_BUFFER &&
	    *mechListMIC == GSS_C_NO_BUFFER) {

		ret = GSS_S_DEFECTIVE_TOKEN;
		goto cleanup;
	}
	if (supportedMech != GSS_C_NO_OID) {
		ret = GSS_S_DEFECTIVE_TOKEN;
		goto cleanup;
	}
	sc->firstpass = 0;
	*negState = ACCEPT_INCOMPLETE;
	*return_token = CONT_TOKEN_SEND;
cleanup:
	if (supportedMech != GSS_C_NO_OID) {
		generic_gss_release_oid(&tmpmin, &supportedMech);
	}
	return ret;
#undef REMAIN
}
","acc_ctx_cont(OM_uint32 *minstat,
	     gss_buffer_t buf,
	     gss_ctx_id_t *ctx,
	     gss_buffer_t *responseToken,
	     gss_buffer_t *mechListMIC,
	     OM_uint32 *negState,
	     send_token_flag *return_token)
{
	OM_uint32 ret, tmpmin;
	gss_OID supportedMech;
	spnego_gss_ctx_id_t sc;
	unsigned int len;
	unsigned char *ptr, *bufstart;

	sc = (spnego_gss_ctx_id_t)*ctx;
	ret = GSS_S_DEFECTIVE_TOKEN;
	*negState = REJECT;
	*minstat = 0;
	supportedMech = GSS_C_NO_OID;
	*return_token = ERROR_TOKEN_SEND;
	*responseToken = *mechListMIC = GSS_C_NO_BUFFER;
 
 	ptr = bufstart = buf->value;
 #define REMAIN (buf->length - (ptr - bufstart))
	if (REMAIN > INT_MAX)
 		return GSS_S_DEFECTIVE_TOKEN;
 
 	/*
	 * Attempt to work with old Sun SPNEGO.
	 */
	if (*ptr == HEADER_ID) {
		ret = g_verify_token_header(gss_mech_spnego,
					    &len, &ptr, 0, REMAIN);
		if (ret) {
			*minstat = ret;
			return GSS_S_DEFECTIVE_TOKEN;
		}
	}
	if (*ptr != (CONTEXT | 0x01)) {
		return GSS_S_DEFECTIVE_TOKEN;
	}
	ret = get_negTokenResp(minstat, ptr, REMAIN,
			       negState, &supportedMech,
			       responseToken, mechListMIC);
	if (ret != GSS_S_COMPLETE)
		goto cleanup;

	if (*responseToken == GSS_C_NO_BUFFER &&
	    *mechListMIC == GSS_C_NO_BUFFER) {

		ret = GSS_S_DEFECTIVE_TOKEN;
		goto cleanup;
	}
	if (supportedMech != GSS_C_NO_OID) {
		ret = GSS_S_DEFECTIVE_TOKEN;
		goto cleanup;
	}
	sc->firstpass = 0;
	*negState = ACCEPT_INCOMPLETE;
	*return_token = CONT_TOKEN_SEND;
cleanup:
	if (supportedMech != GSS_C_NO_OID) {
		generic_gss_release_oid(&tmpmin, &supportedMech);
	}
	return ret;
#undef REMAIN
}
",C,"	if (REMAIN == 0 || REMAIN > INT_MAX)
","	if (REMAIN > INT_MAX)
",,"@@ -1442,7 +1442,7 @@ acc_ctx_cont(OM_uint32 *minstat,
 
 	ptr = bufstart = buf->value;
 #define REMAIN (buf->length - (ptr - bufstart))
-	if (REMAIN > INT_MAX)
+	if (REMAIN == 0 || REMAIN > INT_MAX)
 		return GSS_S_DEFECTIVE_TOKEN;
 
 	/*",krb5,a7886f0ed1277c69142b14a2c6629175a6331edc,3a3749e219534415d4c9e449d0d08b047325ae89,1,"acc_ctx_cont(OM_uint32 *minstat,
	     gss_buffer_t buf,
	     gss_ctx_id_t *ctx,
	     gss_buffer_t *responseToken,
	     gss_buffer_t *mechListMIC,
	     OM_uint32 *negState,
	     send_token_flag *return_token)
{
	OM_uint32 ret, tmpmin;
	gss_OID supportedMech;
	spnego_gss_ctx_id_t sc;
	unsigned int len;
	unsigned char *ptr, *bufstart;

	sc = (spnego_gss_ctx_id_t)*ctx;
	ret = GSS_S_DEFECTIVE_TOKEN;
	*negState = REJECT;
	*minstat = 0;
	supportedMech = GSS_C_NO_OID;
	*return_token = ERROR_TOKEN_SEND;
	*responseToken = *mechListMIC = GSS_C_NO_BUFFER;
 
 	ptr = bufstart = buf->value;
 #define REMAIN (buf->length - (ptr - bufstart))
//flaw_line_below:
	if (REMAIN > INT_MAX)
//fix_flaw_line_below:
//	if (REMAIN == 0 || REMAIN > INT_MAX)
 		return GSS_S_DEFECTIVE_TOKEN;
 
 	/*
	 * Attempt to work with old Sun SPNEGO.
	 */
	if (*ptr == HEADER_ID) {
		ret = g_verify_token_header(gss_mech_spnego,
					    &len, &ptr, 0, REMAIN);
		if (ret) {
			*minstat = ret;
			return GSS_S_DEFECTIVE_TOKEN;
		}
	}
	if (*ptr != (CONTEXT | 0x01)) {
		return GSS_S_DEFECTIVE_TOKEN;
	}
	ret = get_negTokenResp(minstat, ptr, REMAIN,
			       negState, &supportedMech,
			       responseToken, mechListMIC);
	if (ret != GSS_S_COMPLETE)
		goto cleanup;

	if (*responseToken == GSS_C_NO_BUFFER &&
	    *mechListMIC == GSS_C_NO_BUFFER) {

		ret = GSS_S_DEFECTIVE_TOKEN;
		goto cleanup;
	}
	if (supportedMech != GSS_C_NO_OID) {
		ret = GSS_S_DEFECTIVE_TOKEN;
		goto cleanup;
	}
	sc->firstpass = 0;
	*negState = ACCEPT_INCOMPLETE;
	*return_token = CONT_TOKEN_SEND;
cleanup:
	if (supportedMech != GSS_C_NO_OID) {
		generic_gss_release_oid(&tmpmin, &supportedMech);
	}
	return ret;
#undef REMAIN
}
"
2279,180015,,Remote,Not required,Partial,CVE-2016-9888,https://www.cvedetails.com/cve/CVE-2016-9888/,CWE-476,Medium,,,,2016-12-08,4.3,An error within the *tar_directory_for_file()* function (gsf-infile-tar.c) in GNOME Structured File Library before 1.14.41 can be exploited to trigger a Null pointer dereference and subsequently cause a crash via a crafted TAR file.,2016-12-14,,3,https://github.com/GNOME/libgsf/commit/95a8351a75758cf10b3bf6abae0b6b461f90d9e5,95a8351a75758cf10b3bf6abae0b6b461f90d9e5,tar: fix crash on broken tar file.,1,gsf/gsf-infile-tar.c,"{""sha"": ""18508ece1c5a99f73bd703ac344be07a87a32491"", ""filename"": ""ChangeLog"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/GNOME/libgsf/blob/95a8351a75758cf10b3bf6abae0b6b461f90d9e5/ChangeLog"", ""raw_url"": ""https://github.com/GNOME/libgsf/raw/95a8351a75758cf10b3bf6abae0b6b461f90d9e5/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/GNOME/libgsf/contents/ChangeLog?ref=95a8351a75758cf10b3bf6abae0b6b461f90d9e5"", ""patch"": ""@@ -1,3 +1,10 @@\n+2016-11-30  Morten Welinder  <terra@gnome.org>\n+\n+\t* gsf/gsf-infile-tar.c (tar_directory_for_file): Handle the case\n+\twhere what we expected to be a directory is a file.  (That implies\n+\ta corrupted tar file.)  Thanks to Behzad Najjarpour Jabbari,\n+\tSecunia Research at Flexera Software for discovering this.\n+\n 2016-08-20  Morten Welinder <terra@gnome.org>\n \n \t* configure.ac: Post-release bump.""}<_**next**_>{""sha"": ""cfc1e43ad8f1dd66824c5c4aa8931b141877b126"", ""filename"": ""NEWS"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/GNOME/libgsf/blob/95a8351a75758cf10b3bf6abae0b6b461f90d9e5/NEWS"", ""raw_url"": ""https://github.com/GNOME/libgsf/raw/95a8351a75758cf10b3bf6abae0b6b461f90d9e5/NEWS"", ""contents_url"": ""https://api.github.com/repos/GNOME/libgsf/contents/NEWS?ref=95a8351a75758cf10b3bf6abae0b6b461f90d9e5"", ""patch"": ""@@ -1,5 +1,8 @@\n libgsf 1.14.41\n \n+Morten:\n+\t* Fix corrupted-tar-file crash.\n+\n --------------------------------------------------------------------------\n libgsf 1.14.40\n ""}<_**next**_>{""sha"": ""17513fe6b9659c3ee93ce61060107033c632c3ec"", ""filename"": ""gsf/gsf-infile-tar.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/GNOME/libgsf/blob/95a8351a75758cf10b3bf6abae0b6b461f90d9e5/gsf/gsf-infile-tar.c"", ""raw_url"": ""https://github.com/GNOME/libgsf/raw/95a8351a75758cf10b3bf6abae0b6b461f90d9e5/gsf/gsf-infile-tar.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/libgsf/contents/gsf/gsf-infile-tar.c?ref=95a8351a75758cf10b3bf6abae0b6b461f90d9e5"", ""patch"": ""@@ -181,9 +181,11 @@ tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)\n \t\t\t\tgsf_infile_child_by_name (GSF_INFILE (dir),\n \t\t\t\t\t\t\t  dirname);\n \t\t\tif (subdir) {\n+\t\t\t\tdir = GSF_IS_INFILE_TAR (subdir)\n+\t\t\t\t\t? GSF_INFILE_TAR (subdir)\n+\t\t\t\t\t: dir;\n \t\t\t\t/* Undo the ref. */\n \t\t\t\tg_object_unref (subdir);\n-\t\t\t\tdir = GSF_INFILE_TAR (subdir);\n \t\t\t} else\n \t\t\t\tdir = tar_create_dir (dir, dirname);\n \t\t}""}","tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)
{
	const char *s = name;

	while (1) {
		const char *s0 = s;
		char *dirname;

		/* Find a directory component, if any.  */
		while (1) {
			if (*s == 0) {
				if (last && s != s0)
					break;
				else
					return dir;
			}
			/* This is deliberately slash-only.  */
			if (*s == '/')
				break;
			s++;
		}

		dirname = g_strndup (s0, s - s0);
		while (*s == '/')
			s++;

		if (strcmp (dirname, ""."") != 0) {
			GsfInput *subdir =
 				gsf_infile_child_by_name (GSF_INFILE (dir),
 							  dirname);
 			if (subdir) {
				dir = GSF_IS_INFILE_TAR (subdir)
					? GSF_INFILE_TAR (subdir)
					: dir;
 				/* Undo the ref. */
 				g_object_unref (subdir);
 			} else
 				dir = tar_create_dir (dir, dirname);
 		}

		g_free (dirname);
	}
}
","tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)
{
	const char *s = name;

	while (1) {
		const char *s0 = s;
		char *dirname;

		/* Find a directory component, if any.  */
		while (1) {
			if (*s == 0) {
				if (last && s != s0)
					break;
				else
					return dir;
			}
			/* This is deliberately slash-only.  */
			if (*s == '/')
				break;
			s++;
		}

		dirname = g_strndup (s0, s - s0);
		while (*s == '/')
			s++;

		if (strcmp (dirname, ""."") != 0) {
			GsfInput *subdir =
 				gsf_infile_child_by_name (GSF_INFILE (dir),
 							  dirname);
 			if (subdir) {
 				/* Undo the ref. */
 				g_object_unref (subdir);
				dir = GSF_INFILE_TAR (subdir);
 			} else
 				dir = tar_create_dir (dir, dirname);
 		}

		g_free (dirname);
	}
}
",C,"				dir = GSF_IS_INFILE_TAR (subdir)
					? GSF_INFILE_TAR (subdir)
					: dir;
","				dir = GSF_INFILE_TAR (subdir);
",,"@@ -181,9 +181,11 @@ tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)
 				gsf_infile_child_by_name (GSF_INFILE (dir),
 							  dirname);
 			if (subdir) {
+				dir = GSF_IS_INFILE_TAR (subdir)
+					? GSF_INFILE_TAR (subdir)
+					: dir;
 				/* Undo the ref. */
 				g_object_unref (subdir);
-				dir = GSF_INFILE_TAR (subdir);
 			} else
 				dir = tar_create_dir (dir, dirname);
 		}",libgsf,95a8351a75758cf10b3bf6abae0b6b461f90d9e5,c15c4ecfef08e6d82a90d5ab33160aa0d558bc9b,1,"tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)
{
	const char *s = name;

	while (1) {
		const char *s0 = s;
		char *dirname;

		/* Find a directory component, if any.  */
		while (1) {
			if (*s == 0) {
				if (last && s != s0)
					break;
				else
					return dir;
			}
			/* This is deliberately slash-only.  */
			if (*s == '/')
				break;
			s++;
		}

		dirname = g_strndup (s0, s - s0);
		while (*s == '/')
			s++;

		if (strcmp (dirname, ""."") != 0) {
			GsfInput *subdir =
 				gsf_infile_child_by_name (GSF_INFILE (dir),
 							  dirname);
 			if (subdir) {
//fix_flaw_line_below:
//				dir = GSF_IS_INFILE_TAR (subdir)
//fix_flaw_line_below:
//					? GSF_INFILE_TAR (subdir)
//fix_flaw_line_below:
//					: dir;
 				/* Undo the ref. */
 				g_object_unref (subdir);
//flaw_line_below:
				dir = GSF_INFILE_TAR (subdir);
 			} else
 				dir = tar_create_dir (dir, dirname);
 		}

		g_free (dirname);
	}
}
"
2329,180065,,Remote,Not required,Complete,CVE-2016-9313,https://www.cvedetails.com/cve/CVE-2016-9313/,CWE-476,Medium,Complete,Complete,,2016-11-27,9.3,"security/keys/big_key.c in the Linux kernel before 4.8.7 mishandles unsuccessful crypto registration in conjunction with successful key-type registration, which allows local users to cause a denial of service (NULL pointer dereference and panic) or possibly have unspecified other impact via a crafted application that uses the big_key data type.",2016-11-29,DoS ,30,https://github.com/torvalds/linux/commit/7df3e59c3d1df4f87fe874c7956ef7a3d2f4d5fb,7df3e59c3d1df4f87fe874c7956ef7a3d2f4d5fb,"KEYS: Sort out big_key initialisation

big_key has two separate initialisation functions, one that registers the
key type and one that registers the crypto.  If the key type fails to
register, there's no problem if the crypto registers successfully because
there's no way to reach the crypto except through the key type.

However, if the key type registers successfully but the crypto does not,
big_key_rng and big_key_blkcipher may end up set to NULL - but the code
neither checks for this nor unregisters the big key key type.

Furthermore, since the key type is registered before the crypto, it is
theoretically possible for the kernel to try adding a big_key before the
crypto is set up, leading to the same effect.

Fix this by merging big_key_crypto_init() and big_key_init() and calling
the resulting function late.  If they're going to be encrypted, we
shouldn't be creating big_keys before we have the facilities to do the
encryption available.  The key type registration is also moved after the
crypto initialisation.

The fix also includes message printing on failure.

If the big_key type isn't correctly set up, simply doing:

	dd if=/dev/zero bs=4096 count=1 | keyctl padd big_key a @s

ought to cause an oops.

Fixes: 13100a72f40f5748a04017e0ab3df4cf27c809ef ('Security: Keys: Big keys stored encrypted')
Signed-off-by: David Howells <dhowells@redhat.com>
cc: Peter Hlavaty <zer0mem@yahoo.com>
cc: Kirill Marinushkin <k.marinushkin@gmail.com>
cc: Artem Savkov <asavkov@redhat.com>
cc: stable@vger.kernel.org
Signed-off-by: James Morris <james.l.morris@oracle.com>",18,security/keys/big_key.c,"{""sha"": ""835c1ab30d01eb9a8e94b411fce09b856772efb9"", ""filename"": ""security/keys/big_key.c"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 27, ""changes"": 59, ""blob_url"": ""https://github.com/torvalds/linux/blob/7df3e59c3d1df4f87fe874c7956ef7a3d2f4d5fb/security/keys/big_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/7df3e59c3d1df4f87fe874c7956ef7a3d2f4d5fb/security/keys/big_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/big_key.c?ref=7df3e59c3d1df4f87fe874c7956ef7a3d2f4d5fb"", ""patch"": ""@@ -9,6 +9,7 @@\n  * 2 of the Licence, or (at your option) any later version.\n  */\n \n+#define pr_fmt(fmt) \""big_key: \""fmt\n #include <linux/init.h>\n #include <linux/seq_file.h>\n #include <linux/file.h>\n@@ -341,44 +342,48 @@ long big_key_read(const struct key *key, char __user *buffer, size_t buflen)\n  */\n static int __init big_key_init(void)\n {\n-\treturn register_key_type(&key_type_big_key);\n-}\n-\n-/*\n- * Initialize big_key crypto and RNG algorithms\n- */\n-static int __init big_key_crypto_init(void)\n-{\n-\tint ret = -EINVAL;\n+\tstruct crypto_skcipher *cipher;\n+\tstruct crypto_rng *rng;\n+\tint ret;\n \n-\t/* init RNG */\n-\tbig_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);\n-\tif (IS_ERR(big_key_rng)) {\n-\t\tbig_key_rng = NULL;\n-\t\treturn -EFAULT;\n+\trng = crypto_alloc_rng(big_key_rng_name, 0, 0);\n+\tif (IS_ERR(rng)) {\n+\t\tpr_err(\""Can't alloc rng: %ld\\n\"", PTR_ERR(rng));\n+\t\treturn PTR_ERR(rng);\n \t}\n \n+\tbig_key_rng = rng;\n+\n \t/* seed RNG */\n-\tret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));\n-\tif (ret)\n-\t\tgoto error;\n+\tret = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));\n+\tif (ret) {\n+\t\tpr_err(\""Can't reset rng: %d\\n\"", ret);\n+\t\tgoto error_rng;\n+\t}\n \n \t/* init block cipher */\n-\tbig_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,\n-\t\t\t\t\t\t 0, CRYPTO_ALG_ASYNC);\n-\tif (IS_ERR(big_key_skcipher)) {\n-\t\tbig_key_skcipher = NULL;\n-\t\tret = -EFAULT;\n-\t\tgoto error;\n+\tcipher = crypto_alloc_skcipher(big_key_alg_name, 0, CRYPTO_ALG_ASYNC);\n+\tif (IS_ERR(cipher)) {\n+\t\tret = PTR_ERR(cipher);\n+\t\tpr_err(\""Can't alloc crypto: %d\\n\"", ret);\n+\t\tgoto error_rng;\n+\t}\n+\n+\tbig_key_skcipher = cipher;\n+\n+\tret = register_key_type(&key_type_big_key);\n+\tif (ret < 0) {\n+\t\tpr_err(\""Can't register type: %d\\n\"", ret);\n+\t\tgoto error_cipher;\n \t}\n \n \treturn 0;\n \n-error:\n+error_cipher:\n+\tcrypto_free_skcipher(big_key_skcipher);\n+error_rng:\n \tcrypto_free_rng(big_key_rng);\n-\tbig_key_rng = NULL;\n \treturn ret;\n }\n \n-device_initcall(big_key_init);\n-late_initcall(big_key_crypto_init);\n+late_initcall(big_key_init);""}","static int __init big_key_crypto_init(void)
	struct crypto_skcipher *cipher;
	struct crypto_rng *rng;
	int ret;
 
	rng = crypto_alloc_rng(big_key_rng_name, 0, 0);
	if (IS_ERR(rng)) {
		pr_err(""Can't alloc rng: %ld\n"", PTR_ERR(rng));
		return PTR_ERR(rng);
 	}
 
	big_key_rng = rng;

 	/* seed RNG */
	ret = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));
	if (ret) {
		pr_err(""Can't reset rng: %d\n"", ret);
		goto error_rng;
	}
 
 	/* init block cipher */
	cipher = crypto_alloc_skcipher(big_key_alg_name, 0, CRYPTO_ALG_ASYNC);
	if (IS_ERR(cipher)) {
		ret = PTR_ERR(cipher);
		pr_err(""Can't alloc crypto: %d\n"", ret);
		goto error_rng;
	}

	big_key_skcipher = cipher;

	ret = register_key_type(&key_type_big_key);
	if (ret < 0) {
		pr_err(""Can't register type: %d\n"", ret);
		goto error_cipher;
 	}
 
 	return 0;
 
error_cipher:
	crypto_free_skcipher(big_key_skcipher);
error_rng:
 	crypto_free_rng(big_key_rng);
 	return ret;
 }
","static int __init big_key_crypto_init(void)
{
	int ret = -EINVAL;
 
	/* init RNG */
	big_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);
	if (IS_ERR(big_key_rng)) {
		big_key_rng = NULL;
		return -EFAULT;
 	}
 
 	/* seed RNG */
	ret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));
	if (ret)
		goto error;
 
 	/* init block cipher */
	big_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,
						 0, CRYPTO_ALG_ASYNC);
	if (IS_ERR(big_key_skcipher)) {
		big_key_skcipher = NULL;
		ret = -EFAULT;
		goto error;
 	}
 
 	return 0;
 
error:
 	crypto_free_rng(big_key_rng);
	big_key_rng = NULL;
 	return ret;
 }
",C,"	struct crypto_skcipher *cipher;
	struct crypto_rng *rng;
	int ret;
	rng = crypto_alloc_rng(big_key_rng_name, 0, 0);
	if (IS_ERR(rng)) {
		pr_err(""Can't alloc rng: %ld\n"", PTR_ERR(rng));
		return PTR_ERR(rng);
	big_key_rng = rng;

	ret = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));
	if (ret) {
		pr_err(""Can't reset rng: %d\n"", ret);
		goto error_rng;
	}
	cipher = crypto_alloc_skcipher(big_key_alg_name, 0, CRYPTO_ALG_ASYNC);
	if (IS_ERR(cipher)) {
		ret = PTR_ERR(cipher);
		pr_err(""Can't alloc crypto: %d\n"", ret);
		goto error_rng;
	}

	big_key_skcipher = cipher;

	ret = register_key_type(&key_type_big_key);
	if (ret < 0) {
		pr_err(""Can't register type: %d\n"", ret);
		goto error_cipher;
error_cipher:
	crypto_free_skcipher(big_key_skcipher);
error_rng:
","{
	int ret = -EINVAL;
	/* init RNG */
	big_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);
	if (IS_ERR(big_key_rng)) {
		big_key_rng = NULL;
		return -EFAULT;
	ret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));
	if (ret)
		goto error;
	big_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,
						 0, CRYPTO_ALG_ASYNC);
	if (IS_ERR(big_key_skcipher)) {
		big_key_skcipher = NULL;
		ret = -EFAULT;
		goto error;
error:
	big_key_rng = NULL;
",,"@@ -9,6 +9,7 @@
  * 2 of the Licence, or (at your option) any later version.
  */
 
+#define pr_fmt(fmt) ""big_key: ""fmt
 #include <linux/init.h>
 #include <linux/seq_file.h>
 #include <linux/file.h>
@@ -341,44 +342,48 @@ long big_key_read(const struct key *key, char __user *buffer, size_t buflen)
  */
 static int __init big_key_init(void)
 {
-	return register_key_type(&key_type_big_key);
-}
-
-/*
- * Initialize big_key crypto and RNG algorithms
- */
-static int __init big_key_crypto_init(void)
-{
-	int ret = -EINVAL;
+	struct crypto_skcipher *cipher;
+	struct crypto_rng *rng;
+	int ret;
 
-	/* init RNG */
-	big_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);
-	if (IS_ERR(big_key_rng)) {
-		big_key_rng = NULL;
-		return -EFAULT;
+	rng = crypto_alloc_rng(big_key_rng_name, 0, 0);
+	if (IS_ERR(rng)) {
+		pr_err(""Can't alloc rng: %ld\n"", PTR_ERR(rng));
+		return PTR_ERR(rng);
 	}
 
+	big_key_rng = rng;
+
 	/* seed RNG */
-	ret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));
-	if (ret)
-		goto error;
+	ret = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));
+	if (ret) {
+		pr_err(""Can't reset rng: %d\n"", ret);
+		goto error_rng;
+	}
 
 	/* init block cipher */
-	big_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,
-						 0, CRYPTO_ALG_ASYNC);
-	if (IS_ERR(big_key_skcipher)) {
-		big_key_skcipher = NULL;
-		ret = -EFAULT;
-		goto error;
+	cipher = crypto_alloc_skcipher(big_key_alg_name, 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(cipher)) {
+		ret = PTR_ERR(cipher);
+		pr_err(""Can't alloc crypto: %d\n"", ret);
+		goto error_rng;
+	}
+
+	big_key_skcipher = cipher;
+
+	ret = register_key_type(&key_type_big_key);
+	if (ret < 0) {
+		pr_err(""Can't register type: %d\n"", ret);
+		goto error_cipher;
 	}
 
 	return 0;
 
-error:
+error_cipher:
+	crypto_free_skcipher(big_key_skcipher);
+error_rng:
 	crypto_free_rng(big_key_rng);
-	big_key_rng = NULL;
 	return ret;
 }
 
-device_initcall(big_key_init);
-late_initcall(big_key_crypto_init);
+late_initcall(big_key_init);",linux,7df3e59c3d1df4f87fe874c7956ef7a3d2f4d5fb,03dab869b7b239c4e013ec82aea22e181e441cfc,1,"static int __init big_key_crypto_init(void)
//flaw_line_below:
{
//flaw_line_below:
	int ret = -EINVAL;
//fix_flaw_line_below:
//	struct crypto_skcipher *cipher;
//fix_flaw_line_below:
//	struct crypto_rng *rng;
//fix_flaw_line_below:
//	int ret;
 
//flaw_line_below:
	/* init RNG */
//flaw_line_below:
	big_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);
//flaw_line_below:
	if (IS_ERR(big_key_rng)) {
//flaw_line_below:
		big_key_rng = NULL;
//flaw_line_below:
		return -EFAULT;
//fix_flaw_line_below:
//	rng = crypto_alloc_rng(big_key_rng_name, 0, 0);
//fix_flaw_line_below:
//	if (IS_ERR(rng)) {
//fix_flaw_line_below:
//		pr_err(""Can't alloc rng: %ld\n"", PTR_ERR(rng));
//fix_flaw_line_below:
//		return PTR_ERR(rng);
 	}
 
//fix_flaw_line_below:
//	big_key_rng = rng;
//fix_flaw_line_below:
//
 	/* seed RNG */
//flaw_line_below:
	ret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));
//flaw_line_below:
	if (ret)
//flaw_line_below:
		goto error;
//fix_flaw_line_below:
//	ret = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));
//fix_flaw_line_below:
//	if (ret) {
//fix_flaw_line_below:
//		pr_err(""Can't reset rng: %d\n"", ret);
//fix_flaw_line_below:
//		goto error_rng;
//fix_flaw_line_below:
//	}
 
 	/* init block cipher */
//flaw_line_below:
	big_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,
//flaw_line_below:
						 0, CRYPTO_ALG_ASYNC);
//flaw_line_below:
	if (IS_ERR(big_key_skcipher)) {
//flaw_line_below:
		big_key_skcipher = NULL;
//flaw_line_below:
		ret = -EFAULT;
//flaw_line_below:
		goto error;
//fix_flaw_line_below:
//	cipher = crypto_alloc_skcipher(big_key_alg_name, 0, CRYPTO_ALG_ASYNC);
//fix_flaw_line_below:
//	if (IS_ERR(cipher)) {
//fix_flaw_line_below:
//		ret = PTR_ERR(cipher);
//fix_flaw_line_below:
//		pr_err(""Can't alloc crypto: %d\n"", ret);
//fix_flaw_line_below:
//		goto error_rng;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	big_key_skcipher = cipher;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	ret = register_key_type(&key_type_big_key);
//fix_flaw_line_below:
//	if (ret < 0) {
//fix_flaw_line_below:
//		pr_err(""Can't register type: %d\n"", ret);
//fix_flaw_line_below:
//		goto error_cipher;
 	}
 
 	return 0;
 
//flaw_line_below:
error:
//fix_flaw_line_below:
//error_cipher:
//fix_flaw_line_below:
//	crypto_free_skcipher(big_key_skcipher);
//fix_flaw_line_below:
//error_rng:
 	crypto_free_rng(big_key_rng);
//flaw_line_below:
	big_key_rng = NULL;
 	return ret;
 }
"
2330,180066,,Remote,Not required,Complete,CVE-2016-9313,https://www.cvedetails.com/cve/CVE-2016-9313/,CWE-476,Medium,Complete,Complete,,2016-11-27,9.3,"security/keys/big_key.c in the Linux kernel before 4.8.7 mishandles unsuccessful crypto registration in conjunction with successful key-type registration, which allows local users to cause a denial of service (NULL pointer dereference and panic) or possibly have unspecified other impact via a crafted application that uses the big_key data type.",2016-11-29,DoS ,0,https://github.com/torvalds/linux/commit/7df3e59c3d1df4f87fe874c7956ef7a3d2f4d5fb,7df3e59c3d1df4f87fe874c7956ef7a3d2f4d5fb,"KEYS: Sort out big_key initialisation

big_key has two separate initialisation functions, one that registers the
key type and one that registers the crypto.  If the key type fails to
register, there's no problem if the crypto registers successfully because
there's no way to reach the crypto except through the key type.

However, if the key type registers successfully but the crypto does not,
big_key_rng and big_key_blkcipher may end up set to NULL - but the code
neither checks for this nor unregisters the big key key type.

Furthermore, since the key type is registered before the crypto, it is
theoretically possible for the kernel to try adding a big_key before the
crypto is set up, leading to the same effect.

Fix this by merging big_key_crypto_init() and big_key_init() and calling
the resulting function late.  If they're going to be encrypted, we
shouldn't be creating big_keys before we have the facilities to do the
encryption available.  The key type registration is also moved after the
crypto initialisation.

The fix also includes message printing on failure.

If the big_key type isn't correctly set up, simply doing:

	dd if=/dev/zero bs=4096 count=1 | keyctl padd big_key a @s

ought to cause an oops.

Fixes: 13100a72f40f5748a04017e0ab3df4cf27c809ef ('Security: Keys: Big keys stored encrypted')
Signed-off-by: David Howells <dhowells@redhat.com>
cc: Peter Hlavaty <zer0mem@yahoo.com>
cc: Kirill Marinushkin <k.marinushkin@gmail.com>
cc: Artem Savkov <asavkov@redhat.com>
cc: stable@vger.kernel.org
Signed-off-by: James Morris <james.l.morris@oracle.com>",2,security/keys/big_key.c,"{""sha"": ""835c1ab30d01eb9a8e94b411fce09b856772efb9"", ""filename"": ""security/keys/big_key.c"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 27, ""changes"": 59, ""blob_url"": ""https://github.com/torvalds/linux/blob/7df3e59c3d1df4f87fe874c7956ef7a3d2f4d5fb/security/keys/big_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/7df3e59c3d1df4f87fe874c7956ef7a3d2f4d5fb/security/keys/big_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/big_key.c?ref=7df3e59c3d1df4f87fe874c7956ef7a3d2f4d5fb"", ""patch"": ""@@ -9,6 +9,7 @@\n  * 2 of the Licence, or (at your option) any later version.\n  */\n \n+#define pr_fmt(fmt) \""big_key: \""fmt\n #include <linux/init.h>\n #include <linux/seq_file.h>\n #include <linux/file.h>\n@@ -341,44 +342,48 @@ long big_key_read(const struct key *key, char __user *buffer, size_t buflen)\n  */\n static int __init big_key_init(void)\n {\n-\treturn register_key_type(&key_type_big_key);\n-}\n-\n-/*\n- * Initialize big_key crypto and RNG algorithms\n- */\n-static int __init big_key_crypto_init(void)\n-{\n-\tint ret = -EINVAL;\n+\tstruct crypto_skcipher *cipher;\n+\tstruct crypto_rng *rng;\n+\tint ret;\n \n-\t/* init RNG */\n-\tbig_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);\n-\tif (IS_ERR(big_key_rng)) {\n-\t\tbig_key_rng = NULL;\n-\t\treturn -EFAULT;\n+\trng = crypto_alloc_rng(big_key_rng_name, 0, 0);\n+\tif (IS_ERR(rng)) {\n+\t\tpr_err(\""Can't alloc rng: %ld\\n\"", PTR_ERR(rng));\n+\t\treturn PTR_ERR(rng);\n \t}\n \n+\tbig_key_rng = rng;\n+\n \t/* seed RNG */\n-\tret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));\n-\tif (ret)\n-\t\tgoto error;\n+\tret = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));\n+\tif (ret) {\n+\t\tpr_err(\""Can't reset rng: %d\\n\"", ret);\n+\t\tgoto error_rng;\n+\t}\n \n \t/* init block cipher */\n-\tbig_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,\n-\t\t\t\t\t\t 0, CRYPTO_ALG_ASYNC);\n-\tif (IS_ERR(big_key_skcipher)) {\n-\t\tbig_key_skcipher = NULL;\n-\t\tret = -EFAULT;\n-\t\tgoto error;\n+\tcipher = crypto_alloc_skcipher(big_key_alg_name, 0, CRYPTO_ALG_ASYNC);\n+\tif (IS_ERR(cipher)) {\n+\t\tret = PTR_ERR(cipher);\n+\t\tpr_err(\""Can't alloc crypto: %d\\n\"", ret);\n+\t\tgoto error_rng;\n+\t}\n+\n+\tbig_key_skcipher = cipher;\n+\n+\tret = register_key_type(&key_type_big_key);\n+\tif (ret < 0) {\n+\t\tpr_err(\""Can't register type: %d\\n\"", ret);\n+\t\tgoto error_cipher;\n \t}\n \n \treturn 0;\n \n-error:\n+error_cipher:\n+\tcrypto_free_skcipher(big_key_skcipher);\n+error_rng:\n \tcrypto_free_rng(big_key_rng);\n-\tbig_key_rng = NULL;\n \treturn ret;\n }\n \n-device_initcall(big_key_init);\n-late_initcall(big_key_crypto_init);\n+late_initcall(big_key_init);""}"," static int __init big_key_init(void)
 {
"," static int __init big_key_init(void)
 {
	return register_key_type(&key_type_big_key);
}
",C,,"	return register_key_type(&key_type_big_key);
}
",,"@@ -9,6 +9,7 @@
  * 2 of the Licence, or (at your option) any later version.
  */
 
+#define pr_fmt(fmt) ""big_key: ""fmt
 #include <linux/init.h>
 #include <linux/seq_file.h>
 #include <linux/file.h>
@@ -341,44 +342,48 @@ long big_key_read(const struct key *key, char __user *buffer, size_t buflen)
  */
 static int __init big_key_init(void)
 {
-	return register_key_type(&key_type_big_key);
-}
-
-/*
- * Initialize big_key crypto and RNG algorithms
- */
-static int __init big_key_crypto_init(void)
-{
-	int ret = -EINVAL;
+	struct crypto_skcipher *cipher;
+	struct crypto_rng *rng;
+	int ret;
 
-	/* init RNG */
-	big_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);
-	if (IS_ERR(big_key_rng)) {
-		big_key_rng = NULL;
-		return -EFAULT;
+	rng = crypto_alloc_rng(big_key_rng_name, 0, 0);
+	if (IS_ERR(rng)) {
+		pr_err(""Can't alloc rng: %ld\n"", PTR_ERR(rng));
+		return PTR_ERR(rng);
 	}
 
+	big_key_rng = rng;
+
 	/* seed RNG */
-	ret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));
-	if (ret)
-		goto error;
+	ret = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));
+	if (ret) {
+		pr_err(""Can't reset rng: %d\n"", ret);
+		goto error_rng;
+	}
 
 	/* init block cipher */
-	big_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,
-						 0, CRYPTO_ALG_ASYNC);
-	if (IS_ERR(big_key_skcipher)) {
-		big_key_skcipher = NULL;
-		ret = -EFAULT;
-		goto error;
+	cipher = crypto_alloc_skcipher(big_key_alg_name, 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(cipher)) {
+		ret = PTR_ERR(cipher);
+		pr_err(""Can't alloc crypto: %d\n"", ret);
+		goto error_rng;
+	}
+
+	big_key_skcipher = cipher;
+
+	ret = register_key_type(&key_type_big_key);
+	if (ret < 0) {
+		pr_err(""Can't register type: %d\n"", ret);
+		goto error_cipher;
 	}
 
 	return 0;
 
-error:
+error_cipher:
+	crypto_free_skcipher(big_key_skcipher);
+error_rng:
 	crypto_free_rng(big_key_rng);
-	big_key_rng = NULL;
 	return ret;
 }
 
-device_initcall(big_key_init);
-late_initcall(big_key_crypto_init);
+late_initcall(big_key_init);",linux,7df3e59c3d1df4f87fe874c7956ef7a3d2f4d5fb,03dab869b7b239c4e013ec82aea22e181e441cfc,1," static int __init big_key_init(void)
 {
//flaw_line_below:
	return register_key_type(&key_type_big_key);
//flaw_line_below:
}
"
2348,180084,,Local,Not required,Complete,CVE-2016-8646,https://www.cvedetails.com/cve/CVE-2016-8646/,CWE-476,Low,,,,2016-11-27,4.9,The hash_accept function in crypto/algif_hash.c in the Linux kernel before 4.3.6 allows local users to cause a denial of service (OOPS) by attempting to trigger use of in-kernel hash algorithms for a socket that has received zero bytes of data.,2018-01-04,DoS ,10,https://github.com/torvalds/linux/commit/4afa5f9617927453ac04b24b584f6c718dfb4f45,4afa5f9617927453ac04b24b584f6c718dfb4f45,"crypto: algif_hash - Only export and import on sockets with data

The hash_accept call fails to work on sockets that have not received
any data.  For some algorithm implementations it may cause crashes.

This patch fixes this by ensuring that we only export and import on
sockets that have received data.

Cc: stable@vger.kernel.org
Reported-by: Harsh Jain <harshjain.prof@gmail.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
Tested-by: Stephan Mueller <smueller@chronox.de>",2,crypto/algif_hash.c,"{""sha"": ""b4c24fe3dcfb5ed575350406c9dd7ece3c006aef"", ""filename"": ""crypto/algif_hash.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 2, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/4afa5f9617927453ac04b24b584f6c718dfb4f45/crypto/algif_hash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4afa5f9617927453ac04b24b584f6c718dfb4f45/crypto/algif_hash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/algif_hash.c?ref=4afa5f9617927453ac04b24b584f6c718dfb4f45"", ""patch"": ""@@ -181,9 +181,14 @@ static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n \tstruct sock *sk2;\n \tstruct alg_sock *ask2;\n \tstruct hash_ctx *ctx2;\n+\tbool more;\n \tint err;\n \n-\terr = crypto_ahash_export(req, state);\n+\tlock_sock(sk);\n+\tmore = ctx->more;\n+\terr = more ? crypto_ahash_export(req, state) : 0;\n+\trelease_sock(sk);\n+\n \tif (err)\n \t\treturn err;\n \n@@ -194,7 +199,10 @@ static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n \tsk2 = newsock->sk;\n \task2 = alg_sk(sk2);\n \tctx2 = ask2->private;\n-\tctx2->more = 1;\n+\tctx2->more = more;\n+\n+\tif (!more)\n+\t\treturn err;\n \n \terr = crypto_ahash_import(&ctx2->req, state);\n \tif (err) {""}","static int hash_accept(struct socket *sock, struct socket *newsock, int flags)
{
	struct sock *sk = sock->sk;
	struct alg_sock *ask = alg_sk(sk);
	struct hash_ctx *ctx = ask->private;
	struct ahash_request *req = &ctx->req;
	char state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];
 	struct sock *sk2;
 	struct alg_sock *ask2;
 	struct hash_ctx *ctx2;
	bool more;
 	int err;
 
	lock_sock(sk);
	more = ctx->more;
	err = more ? crypto_ahash_export(req, state) : 0;
	release_sock(sk);

 	if (err)
 		return err;
 
	err = af_alg_accept(ask->parent, newsock);
	if (err)
		return err;

 	sk2 = newsock->sk;
 	ask2 = alg_sk(sk2);
 	ctx2 = ask2->private;
	ctx2->more = more;

	if (!more)
		return err;
 
 	err = crypto_ahash_import(&ctx2->req, state);
 	if (err) {
		sock_orphan(sk2);
		sock_put(sk2);
	}

	return err;
}
","static int hash_accept(struct socket *sock, struct socket *newsock, int flags)
{
	struct sock *sk = sock->sk;
	struct alg_sock *ask = alg_sk(sk);
	struct hash_ctx *ctx = ask->private;
	struct ahash_request *req = &ctx->req;
	char state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];
 	struct sock *sk2;
 	struct alg_sock *ask2;
 	struct hash_ctx *ctx2;
 	int err;
 
	err = crypto_ahash_export(req, state);
 	if (err)
 		return err;
 
	err = af_alg_accept(ask->parent, newsock);
	if (err)
		return err;

 	sk2 = newsock->sk;
 	ask2 = alg_sk(sk2);
 	ctx2 = ask2->private;
	ctx2->more = 1;
 
 	err = crypto_ahash_import(&ctx2->req, state);
 	if (err) {
		sock_orphan(sk2);
		sock_put(sk2);
	}

	return err;
}
",C,"	bool more;
	lock_sock(sk);
	more = ctx->more;
	err = more ? crypto_ahash_export(req, state) : 0;
	release_sock(sk);

	ctx2->more = more;

	if (!more)
		return err;
","	err = crypto_ahash_export(req, state);
	ctx2->more = 1;
",,"@@ -181,9 +181,14 @@ static int hash_accept(struct socket *sock, struct socket *newsock, int flags)
 	struct sock *sk2;
 	struct alg_sock *ask2;
 	struct hash_ctx *ctx2;
+	bool more;
 	int err;
 
-	err = crypto_ahash_export(req, state);
+	lock_sock(sk);
+	more = ctx->more;
+	err = more ? crypto_ahash_export(req, state) : 0;
+	release_sock(sk);
+
 	if (err)
 		return err;
 
@@ -194,7 +199,10 @@ static int hash_accept(struct socket *sock, struct socket *newsock, int flags)
 	sk2 = newsock->sk;
 	ask2 = alg_sk(sk2);
 	ctx2 = ask2->private;
-	ctx2->more = 1;
+	ctx2->more = more;
+
+	if (!more)
+		return err;
 
 	err = crypto_ahash_import(&ctx2->req, state);
 	if (err) {",linux,4afa5f9617927453ac04b24b584f6c718dfb4f45,271817a3e92c0455bda5856d87eca244ad67d3a2,1,"static int hash_accept(struct socket *sock, struct socket *newsock, int flags)
{
	struct sock *sk = sock->sk;
	struct alg_sock *ask = alg_sk(sk);
	struct hash_ctx *ctx = ask->private;
	struct ahash_request *req = &ctx->req;
	char state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];
 	struct sock *sk2;
 	struct alg_sock *ask2;
 	struct hash_ctx *ctx2;
//fix_flaw_line_below:
//	bool more;
 	int err;
 
//flaw_line_below:
	err = crypto_ahash_export(req, state);
//fix_flaw_line_below:
//	lock_sock(sk);
//fix_flaw_line_below:
//	more = ctx->more;
//fix_flaw_line_below:
//	err = more ? crypto_ahash_export(req, state) : 0;
//fix_flaw_line_below:
//	release_sock(sk);
//fix_flaw_line_below:
//
 	if (err)
 		return err;
 
	err = af_alg_accept(ask->parent, newsock);
	if (err)
		return err;

 	sk2 = newsock->sk;
 	ask2 = alg_sk(sk2);
 	ctx2 = ask2->private;
//flaw_line_below:
	ctx2->more = 1;
//fix_flaw_line_below:
//	ctx2->more = more;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (!more)
//fix_flaw_line_below:
//		return err;
 
 	err = crypto_ahash_import(&ctx2->req, state);
 	if (err) {
		sock_orphan(sk2);
		sock_put(sk2);
	}

	return err;
}
"
2384,180120,,Remote,Not required,Partial,CVE-2016-7132,https://www.cvedetails.com/cve/CVE-2016-7132/,CWE-476,Low,,,,2016-09-11,5.0,"ext/wddx/wddx.c in PHP before 5.6.25 and 7.x before 7.0.10 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) or possibly have unspecified other impact via an invalid wddxPacket XML document that is mishandled in a wddx_deserialize call, as demonstrated by a stray element inside a boolean element, leading to incorrect pop processing.",2018-01-04,DoS ,7,https://github.com/php/php-src/commit/a14fdb9746262549bbbb96abb87338bacd147e1b?w=1,a14fdb9746262549bbbb96abb87338bacd147e1b?w=1,Fix for bug #72790 and bug #72799,3,ext/wddx/wddx.c,"{""sha"": ""a60524bdaf19e37f9326b6111092a6423832dbf3"", ""filename"": ""ext/wddx/tests/bug72790.phpt"", ""status"": ""added"", ""additions"": 35, ""deletions"": 0, ""changes"": 35, ""blob_url"": ""https://github.com/php/php-src/blob/a14fdb9746262549bbbb96abb87338bacd147e1b/ext/wddx/tests/bug72790.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/a14fdb9746262549bbbb96abb87338bacd147e1b/ext/wddx/tests/bug72790.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/tests/bug72790.phpt?ref=a14fdb9746262549bbbb96abb87338bacd147e1b"", ""patch"": ""@@ -0,0 +1,35 @@\n+--TEST--\n+Bug 72790: wddx_deserialize null dereference with invalid xml\n+--SKIPIF--\n+<?php\n+if (!extension_loaded('wddx')) {\n+    die('skip. wddx not available');\n+}\n+?>\n+--FILE--\n+<?php\n+\n+$xml = <<< XML\n+<?xml version='1.0' ?>\n+<!DOCTYPE wddxPacket SYSTEM 'wddx_0100.dtd'>\n+<wddxPacket version='1.0'>\n+        |array>\n+                <var name=\""XXXX\"">\n+                        <boolean value=\""this\"">\n+                        </boolean>\n+                </var>\n+                <var name=\""YYYY\"">\n+                        <var name=\""UUUU\"">\n+                                <var name=\""EZEZ\"">\n+                                </var>\n+                        </var>\n+                </var>\n+        </array>\n+</wddxPacket>\n+XML;\n+\n+$array = wddx_deserialize($xml);\n+var_dump($array);\n+?>\n+--EXPECT--\n+NULL\n\\ No newline at end of file""}<_**next**_>{""sha"": ""5861d5538f49fd61939d8239601bca57328f5982"", ""filename"": ""ext/wddx/tests/bug72799.phpt"", ""status"": ""added"", ""additions"": 28, ""deletions"": 0, ""changes"": 28, ""blob_url"": ""https://github.com/php/php-src/blob/a14fdb9746262549bbbb96abb87338bacd147e1b/ext/wddx/tests/bug72799.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/a14fdb9746262549bbbb96abb87338bacd147e1b/ext/wddx/tests/bug72799.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/tests/bug72799.phpt?ref=a14fdb9746262549bbbb96abb87338bacd147e1b"", ""patch"": ""@@ -0,0 +1,28 @@\n+--TEST--\n+Bug #72799: wddx_deserialize null dereference in php_wddx_pop_element\n+--SKIPIF--\n+<?php\n+if (!extension_loaded('wddx')) {\n+    die('skip. wddx not available');\n+}\n+?>\n+--FILE--\n+<?php\n+\n+$xml = <<<XML\n+<?xml version='1.0'?>\n+<!DOCTYPE wddxPacket SYSTEM 'wddx_0100.dtd'>\n+<wddxPacket version=\""1.0\"">\n+    <var name=\""XXXX\"">\n+        <boolean value=\""1\"">\n+            <dateTime>1998-06-12T04:32:12+00</dateTime>\n+        </boolean>\n+    </var>\n+</wddxPacket>\n+XML;\n+\n+$array = wddx_deserialize($xml);\n+var_dump($array);\n+?>\n+--EXPECT--\n+NULL\n\\ No newline at end of file""}<_**next**_>{""sha"": ""d7bd295832c70aba70b1632cf0b6e5291f5200ae"", ""filename"": ""ext/wddx/wddx.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 5, ""changes"": 14, ""blob_url"": ""https://github.com/php/php-src/blob/a14fdb9746262549bbbb96abb87338bacd147e1b/ext/wddx/wddx.c"", ""raw_url"": ""https://github.com/php/php-src/raw/a14fdb9746262549bbbb96abb87338bacd147e1b/ext/wddx/wddx.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/wddx.c?ref=a14fdb9746262549bbbb96abb87338bacd147e1b"", ""patch"": ""@@ -946,10 +946,10 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n \t\tif (!ent1->data) {\n \t\t\tif (stack->top > 1) {\n \t\t\t\tstack->top--;\n+\t\t\t\tefree(ent1);\n \t\t\t} else {\n \t\t\t\tstack->done = 1;\n \t\t\t}\n-\t\t\tefree(ent1);\n \t\t\treturn;\n \t\t}\n \n@@ -988,7 +988,7 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n \t\t\twddx_stack_top(stack, (void**)&ent2);\n \n \t\t\t/* if non-existent field */\n-\t\t\tif (ent2->type == ST_FIELD && ent2->data == NULL) {\n+\t\t\tif (ent2->data == NULL) {\n \t\t\t\tzval_ptr_dtor(&ent1->data);\n \t\t\t\tefree(ent1);\n \t\t\t\treturn;\n@@ -1179,9 +1179,13 @@ int php_wddx_deserialize_ex(char *value, int vallen, zval *return_value)\n \n \tif (stack.top == 1) {\n \t\twddx_stack_top(&stack, (void**)&ent);\n-\t\t*return_value = *(ent->data);\n-\t\tzval_copy_ctor(return_value);\n-\t\tretval = SUCCESS;\n+\t\tif(ent->data == NULL) {\n+\t\t\tretval = FAILURE;\n+\t\t} else {\n+\t\t\t*return_value = *(ent->data);\n+\t\t\tzval_copy_ctor(return_value);\n+\t\t\tretval = SUCCESS;\n+\t\t}\n \t} else {\n \t\tretval = FAILURE;\n \t}""}","int php_wddx_deserialize_ex(char *value, int vallen, zval *return_value)
{
	wddx_stack stack;
	XML_Parser parser;
	st_entry *ent;
	int retval;

	wddx_stack_init(&stack);
	parser = XML_ParserCreate(""UTF-8"");

	XML_SetUserData(parser, &stack);
	XML_SetElementHandler(parser, php_wddx_push_element, php_wddx_pop_element);
	XML_SetCharacterDataHandler(parser, php_wddx_process_data);

	XML_Parse(parser, value, vallen, 1);

	XML_ParserFree(parser);
 
 	if (stack.top == 1) {
 		wddx_stack_top(&stack, (void**)&ent);
		if(ent->data == NULL) {
			retval = FAILURE;
		} else {
			*return_value = *(ent->data);
			zval_copy_ctor(return_value);
			retval = SUCCESS;
		}
 	} else {
 		retval = FAILURE;
 	}

	wddx_stack_destroy(&stack);

	return retval;
}
","int php_wddx_deserialize_ex(char *value, int vallen, zval *return_value)
{
	wddx_stack stack;
	XML_Parser parser;
	st_entry *ent;
	int retval;

	wddx_stack_init(&stack);
	parser = XML_ParserCreate(""UTF-8"");

	XML_SetUserData(parser, &stack);
	XML_SetElementHandler(parser, php_wddx_push_element, php_wddx_pop_element);
	XML_SetCharacterDataHandler(parser, php_wddx_process_data);

	XML_Parse(parser, value, vallen, 1);

	XML_ParserFree(parser);
 
 	if (stack.top == 1) {
 		wddx_stack_top(&stack, (void**)&ent);
		*return_value = *(ent->data);
		zval_copy_ctor(return_value);
		retval = SUCCESS;
 	} else {
 		retval = FAILURE;
 	}

	wddx_stack_destroy(&stack);

	return retval;
}
",C,"		if(ent->data == NULL) {
			retval = FAILURE;
		} else {
			*return_value = *(ent->data);
			zval_copy_ctor(return_value);
			retval = SUCCESS;
		}
","		*return_value = *(ent->data);
		zval_copy_ctor(return_value);
		retval = SUCCESS;
",,"@@ -946,10 +946,10 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)
 		if (!ent1->data) {
 			if (stack->top > 1) {
 				stack->top--;
+				efree(ent1);
 			} else {
 				stack->done = 1;
 			}
-			efree(ent1);
 			return;
 		}
 
@@ -988,7 +988,7 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)
 			wddx_stack_top(stack, (void**)&ent2);
 
 			/* if non-existent field */
-			if (ent2->type == ST_FIELD && ent2->data == NULL) {
+			if (ent2->data == NULL) {
 				zval_ptr_dtor(&ent1->data);
 				efree(ent1);
 				return;
@@ -1179,9 +1179,13 @@ int php_wddx_deserialize_ex(char *value, int vallen, zval *return_value)
 
 	if (stack.top == 1) {
 		wddx_stack_top(&stack, (void**)&ent);
-		*return_value = *(ent->data);
-		zval_copy_ctor(return_value);
-		retval = SUCCESS;
+		if(ent->data == NULL) {
+			retval = FAILURE;
+		} else {
+			*return_value = *(ent->data);
+			zval_copy_ctor(return_value);
+			retval = SUCCESS;
+		}
 	} else {
 		retval = FAILURE;
 	}",php-src,a14fdb9746262549bbbb96abb87338bacd147e1b?w=1,047fe0ed03093a496691d376fcf51a7e2f1d04b0,1,"int php_wddx_deserialize_ex(char *value, int vallen, zval *return_value)
{
	wddx_stack stack;
	XML_Parser parser;
	st_entry *ent;
	int retval;

	wddx_stack_init(&stack);
	parser = XML_ParserCreate(""UTF-8"");

	XML_SetUserData(parser, &stack);
	XML_SetElementHandler(parser, php_wddx_push_element, php_wddx_pop_element);
	XML_SetCharacterDataHandler(parser, php_wddx_process_data);

	XML_Parse(parser, value, vallen, 1);

	XML_ParserFree(parser);
 
 	if (stack.top == 1) {
 		wddx_stack_top(&stack, (void**)&ent);
//flaw_line_below:
		*return_value = *(ent->data);
//flaw_line_below:
		zval_copy_ctor(return_value);
//flaw_line_below:
		retval = SUCCESS;
//fix_flaw_line_below:
//		if(ent->data == NULL) {
//fix_flaw_line_below:
//			retval = FAILURE;
//fix_flaw_line_below:
//		} else {
//fix_flaw_line_below:
//			*return_value = *(ent->data);
//fix_flaw_line_below:
//			zval_copy_ctor(return_value);
//fix_flaw_line_below:
//			retval = SUCCESS;
//fix_flaw_line_below:
//		}
 	} else {
 		retval = FAILURE;
 	}

	wddx_stack_destroy(&stack);

	return retval;
}
"
2385,180121,,Remote,Not required,Partial,CVE-2016-7132,https://www.cvedetails.com/cve/CVE-2016-7132/,CWE-476,Low,,,,2016-09-11,5.0,"ext/wddx/wddx.c in PHP before 5.6.25 and 7.x before 7.0.10 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) or possibly have unspecified other impact via an invalid wddxPacket XML document that is mishandled in a wddx_deserialize call, as demonstrated by a stray element inside a boolean element, leading to incorrect pop processing.",2018-01-04,DoS ,2,https://github.com/php/php-src/commit/a14fdb9746262549bbbb96abb87338bacd147e1b?w=1,a14fdb9746262549bbbb96abb87338bacd147e1b?w=1,Fix for bug #72790 and bug #72799,2,ext/wddx/wddx.c,"{""sha"": ""a60524bdaf19e37f9326b6111092a6423832dbf3"", ""filename"": ""ext/wddx/tests/bug72790.phpt"", ""status"": ""added"", ""additions"": 35, ""deletions"": 0, ""changes"": 35, ""blob_url"": ""https://github.com/php/php-src/blob/a14fdb9746262549bbbb96abb87338bacd147e1b/ext/wddx/tests/bug72790.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/a14fdb9746262549bbbb96abb87338bacd147e1b/ext/wddx/tests/bug72790.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/tests/bug72790.phpt?ref=a14fdb9746262549bbbb96abb87338bacd147e1b"", ""patch"": ""@@ -0,0 +1,35 @@\n+--TEST--\n+Bug 72790: wddx_deserialize null dereference with invalid xml\n+--SKIPIF--\n+<?php\n+if (!extension_loaded('wddx')) {\n+    die('skip. wddx not available');\n+}\n+?>\n+--FILE--\n+<?php\n+\n+$xml = <<< XML\n+<?xml version='1.0' ?>\n+<!DOCTYPE wddxPacket SYSTEM 'wddx_0100.dtd'>\n+<wddxPacket version='1.0'>\n+        |array>\n+                <var name=\""XXXX\"">\n+                        <boolean value=\""this\"">\n+                        </boolean>\n+                </var>\n+                <var name=\""YYYY\"">\n+                        <var name=\""UUUU\"">\n+                                <var name=\""EZEZ\"">\n+                                </var>\n+                        </var>\n+                </var>\n+        </array>\n+</wddxPacket>\n+XML;\n+\n+$array = wddx_deserialize($xml);\n+var_dump($array);\n+?>\n+--EXPECT--\n+NULL\n\\ No newline at end of file""}<_**next**_>{""sha"": ""5861d5538f49fd61939d8239601bca57328f5982"", ""filename"": ""ext/wddx/tests/bug72799.phpt"", ""status"": ""added"", ""additions"": 28, ""deletions"": 0, ""changes"": 28, ""blob_url"": ""https://github.com/php/php-src/blob/a14fdb9746262549bbbb96abb87338bacd147e1b/ext/wddx/tests/bug72799.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/a14fdb9746262549bbbb96abb87338bacd147e1b/ext/wddx/tests/bug72799.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/tests/bug72799.phpt?ref=a14fdb9746262549bbbb96abb87338bacd147e1b"", ""patch"": ""@@ -0,0 +1,28 @@\n+--TEST--\n+Bug #72799: wddx_deserialize null dereference in php_wddx_pop_element\n+--SKIPIF--\n+<?php\n+if (!extension_loaded('wddx')) {\n+    die('skip. wddx not available');\n+}\n+?>\n+--FILE--\n+<?php\n+\n+$xml = <<<XML\n+<?xml version='1.0'?>\n+<!DOCTYPE wddxPacket SYSTEM 'wddx_0100.dtd'>\n+<wddxPacket version=\""1.0\"">\n+    <var name=\""XXXX\"">\n+        <boolean value=\""1\"">\n+            <dateTime>1998-06-12T04:32:12+00</dateTime>\n+        </boolean>\n+    </var>\n+</wddxPacket>\n+XML;\n+\n+$array = wddx_deserialize($xml);\n+var_dump($array);\n+?>\n+--EXPECT--\n+NULL\n\\ No newline at end of file""}<_**next**_>{""sha"": ""d7bd295832c70aba70b1632cf0b6e5291f5200ae"", ""filename"": ""ext/wddx/wddx.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 5, ""changes"": 14, ""blob_url"": ""https://github.com/php/php-src/blob/a14fdb9746262549bbbb96abb87338bacd147e1b/ext/wddx/wddx.c"", ""raw_url"": ""https://github.com/php/php-src/raw/a14fdb9746262549bbbb96abb87338bacd147e1b/ext/wddx/wddx.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/wddx.c?ref=a14fdb9746262549bbbb96abb87338bacd147e1b"", ""patch"": ""@@ -946,10 +946,10 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n \t\tif (!ent1->data) {\n \t\t\tif (stack->top > 1) {\n \t\t\t\tstack->top--;\n+\t\t\t\tefree(ent1);\n \t\t\t} else {\n \t\t\t\tstack->done = 1;\n \t\t\t}\n-\t\t\tefree(ent1);\n \t\t\treturn;\n \t\t}\n \n@@ -988,7 +988,7 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n \t\t\twddx_stack_top(stack, (void**)&ent2);\n \n \t\t\t/* if non-existent field */\n-\t\t\tif (ent2->type == ST_FIELD && ent2->data == NULL) {\n+\t\t\tif (ent2->data == NULL) {\n \t\t\t\tzval_ptr_dtor(&ent1->data);\n \t\t\t\tefree(ent1);\n \t\t\t\treturn;\n@@ -1179,9 +1179,13 @@ int php_wddx_deserialize_ex(char *value, int vallen, zval *return_value)\n \n \tif (stack.top == 1) {\n \t\twddx_stack_top(&stack, (void**)&ent);\n-\t\t*return_value = *(ent->data);\n-\t\tzval_copy_ctor(return_value);\n-\t\tretval = SUCCESS;\n+\t\tif(ent->data == NULL) {\n+\t\t\tretval = FAILURE;\n+\t\t} else {\n+\t\t\t*return_value = *(ent->data);\n+\t\t\tzval_copy_ctor(return_value);\n+\t\t\tretval = SUCCESS;\n+\t\t}\n \t} else {\n \t\tretval = FAILURE;\n \t}""}","static void php_wddx_pop_element(void *user_data, const XML_Char *name)
{
	st_entry 			*ent1, *ent2;
	wddx_stack 			*stack = (wddx_stack *)user_data;
	HashTable 			*target_hash;
	zend_class_entry 	**pce;
	zval				*obj;
	zval				*tmp;
	TSRMLS_FETCH();

/* OBJECTS_FIXME */
	if (stack->top == 0) {
		return;
	}

	if (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||
		!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||
	  	!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||
		!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||
		!strcmp(name, EL_DATETIME)) {
		wddx_stack_top(stack, (void**)&ent1);

 		if (!ent1->data) {
 			if (stack->top > 1) {
 				stack->top--;
				efree(ent1);
 			} else {
 				stack->done = 1;
 			}
 			return;
 		}
 
		if (!strcmp(name, EL_BINARY)) {
			int new_len=0;
			unsigned char *new_str;

			new_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);
			STR_FREE(Z_STRVAL_P(ent1->data));
			if (new_str) {
				Z_STRVAL_P(ent1->data) = new_str;
				Z_STRLEN_P(ent1->data) = new_len;
			} else {
				ZVAL_EMPTY_STRING(ent1->data);
			}
		}

		/* Call __wakeup() method on the object. */
		if (Z_TYPE_P(ent1->data) == IS_OBJECT) {
			zval *fname, *retval = NULL;

			MAKE_STD_ZVAL(fname);
			ZVAL_STRING(fname, ""__wakeup"", 1);

			call_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);

			zval_dtor(fname);
			FREE_ZVAL(fname);
			if (retval) {
				zval_ptr_dtor(&retval);
			}
		}

		if (stack->top > 1) {
			stack->top--;
 			wddx_stack_top(stack, (void**)&ent2);
 
 			/* if non-existent field */
			if (ent2->data == NULL) {
 				zval_ptr_dtor(&ent1->data);
 				efree(ent1);
 				return;
			}

			if (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {
				target_hash = HASH_OF(ent2->data);

				if (ent1->varname) {
					if (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&
						Z_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&
						ent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {
						zend_bool incomplete_class = 0;

						zend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
						if (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),
										   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {
							incomplete_class = 1;
							pce = &PHP_IC_ENTRY;
						}

						/* Initialize target object */
						MAKE_STD_ZVAL(obj);
						object_init_ex(obj, *pce);

						/* Merge current hashtable with object's default properties */
						zend_hash_merge(Z_OBJPROP_P(obj),
										Z_ARRVAL_P(ent2->data),
										(void (*)(void *)) zval_add_ref,
										(void *) &tmp, sizeof(zval *), 0);

						if (incomplete_class) {
							php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
						}

						/* Clean up old array entry */
						zval_ptr_dtor(&ent2->data);

						/* Set stack entry to point to the newly created object */
						ent2->data = obj;

						/* Clean up class name var entry */
						zval_ptr_dtor(&ent1->data);
					} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {
						zend_class_entry *old_scope = EG(scope);

						EG(scope) = Z_OBJCE_P(ent2->data);
						Z_DELREF_P(ent1->data);
						add_property_zval(ent2->data, ent1->varname, ent1->data);
						EG(scope) = old_scope;
					} else {
						zend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);
					}
					efree(ent1->varname);
				} else	{
					zend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);
				}
			}
			efree(ent1);
		} else {
			stack->done = 1;
		}
	} else if (!strcmp(name, EL_VAR) && stack->varname) {
		efree(stack->varname);
		stack->varname = NULL;
	} else if (!strcmp(name, EL_FIELD)) {
		st_entry *ent;
		wddx_stack_top(stack, (void **)&ent);
		efree(ent);
		stack->top--;
	}
}
","static void php_wddx_pop_element(void *user_data, const XML_Char *name)
{
	st_entry 			*ent1, *ent2;
	wddx_stack 			*stack = (wddx_stack *)user_data;
	HashTable 			*target_hash;
	zend_class_entry 	**pce;
	zval				*obj;
	zval				*tmp;
	TSRMLS_FETCH();

/* OBJECTS_FIXME */
	if (stack->top == 0) {
		return;
	}

	if (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||
		!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||
	  	!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||
		!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||
		!strcmp(name, EL_DATETIME)) {
		wddx_stack_top(stack, (void**)&ent1);

 		if (!ent1->data) {
 			if (stack->top > 1) {
 				stack->top--;
 			} else {
 				stack->done = 1;
 			}
			efree(ent1);
 			return;
 		}
 
		if (!strcmp(name, EL_BINARY)) {
			int new_len=0;
			unsigned char *new_str;

			new_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);
			STR_FREE(Z_STRVAL_P(ent1->data));
			if (new_str) {
				Z_STRVAL_P(ent1->data) = new_str;
				Z_STRLEN_P(ent1->data) = new_len;
			} else {
				ZVAL_EMPTY_STRING(ent1->data);
			}
		}

		/* Call __wakeup() method on the object. */
		if (Z_TYPE_P(ent1->data) == IS_OBJECT) {
			zval *fname, *retval = NULL;

			MAKE_STD_ZVAL(fname);
			ZVAL_STRING(fname, ""__wakeup"", 1);

			call_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);

			zval_dtor(fname);
			FREE_ZVAL(fname);
			if (retval) {
				zval_ptr_dtor(&retval);
			}
		}

		if (stack->top > 1) {
			stack->top--;
 			wddx_stack_top(stack, (void**)&ent2);
 
 			/* if non-existent field */
			if (ent2->type == ST_FIELD && ent2->data == NULL) {
 				zval_ptr_dtor(&ent1->data);
 				efree(ent1);
 				return;
			}

			if (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {
				target_hash = HASH_OF(ent2->data);

				if (ent1->varname) {
					if (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&
						Z_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&
						ent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {
						zend_bool incomplete_class = 0;

						zend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
						if (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),
										   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {
							incomplete_class = 1;
							pce = &PHP_IC_ENTRY;
						}

						/* Initialize target object */
						MAKE_STD_ZVAL(obj);
						object_init_ex(obj, *pce);

						/* Merge current hashtable with object's default properties */
						zend_hash_merge(Z_OBJPROP_P(obj),
										Z_ARRVAL_P(ent2->data),
										(void (*)(void *)) zval_add_ref,
										(void *) &tmp, sizeof(zval *), 0);

						if (incomplete_class) {
							php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
						}

						/* Clean up old array entry */
						zval_ptr_dtor(&ent2->data);

						/* Set stack entry to point to the newly created object */
						ent2->data = obj;

						/* Clean up class name var entry */
						zval_ptr_dtor(&ent1->data);
					} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {
						zend_class_entry *old_scope = EG(scope);

						EG(scope) = Z_OBJCE_P(ent2->data);
						Z_DELREF_P(ent1->data);
						add_property_zval(ent2->data, ent1->varname, ent1->data);
						EG(scope) = old_scope;
					} else {
						zend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);
					}
					efree(ent1->varname);
				} else	{
					zend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);
				}
			}
			efree(ent1);
		} else {
			stack->done = 1;
		}
	} else if (!strcmp(name, EL_VAR) && stack->varname) {
		efree(stack->varname);
		stack->varname = NULL;
	} else if (!strcmp(name, EL_FIELD)) {
		st_entry *ent;
		wddx_stack_top(stack, (void **)&ent);
		efree(ent);
		stack->top--;
	}
}
",C,"				efree(ent1);
			if (ent2->data == NULL) {
","			efree(ent1);
			if (ent2->type == ST_FIELD && ent2->data == NULL) {
",,"@@ -946,10 +946,10 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)
 		if (!ent1->data) {
 			if (stack->top > 1) {
 				stack->top--;
+				efree(ent1);
 			} else {
 				stack->done = 1;
 			}
-			efree(ent1);
 			return;
 		}
 
@@ -988,7 +988,7 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)
 			wddx_stack_top(stack, (void**)&ent2);
 
 			/* if non-existent field */
-			if (ent2->type == ST_FIELD && ent2->data == NULL) {
+			if (ent2->data == NULL) {
 				zval_ptr_dtor(&ent1->data);
 				efree(ent1);
 				return;
@@ -1179,9 +1179,13 @@ int php_wddx_deserialize_ex(char *value, int vallen, zval *return_value)
 
 	if (stack.top == 1) {
 		wddx_stack_top(&stack, (void**)&ent);
-		*return_value = *(ent->data);
-		zval_copy_ctor(return_value);
-		retval = SUCCESS;
+		if(ent->data == NULL) {
+			retval = FAILURE;
+		} else {
+			*return_value = *(ent->data);
+			zval_copy_ctor(return_value);
+			retval = SUCCESS;
+		}
 	} else {
 		retval = FAILURE;
 	}",php-src,a14fdb9746262549bbbb96abb87338bacd147e1b?w=1,047fe0ed03093a496691d376fcf51a7e2f1d04b0,1,"static void php_wddx_pop_element(void *user_data, const XML_Char *name)
{
	st_entry 			*ent1, *ent2;
	wddx_stack 			*stack = (wddx_stack *)user_data;
	HashTable 			*target_hash;
	zend_class_entry 	**pce;
	zval				*obj;
	zval				*tmp;
	TSRMLS_FETCH();

/* OBJECTS_FIXME */
	if (stack->top == 0) {
		return;
	}

	if (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||
		!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||
	  	!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||
		!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||
		!strcmp(name, EL_DATETIME)) {
		wddx_stack_top(stack, (void**)&ent1);

 		if (!ent1->data) {
 			if (stack->top > 1) {
 				stack->top--;
//fix_flaw_line_below:
//				efree(ent1);
 			} else {
 				stack->done = 1;
 			}
//flaw_line_below:
			efree(ent1);
 			return;
 		}
 
		if (!strcmp(name, EL_BINARY)) {
			int new_len=0;
			unsigned char *new_str;

			new_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);
			STR_FREE(Z_STRVAL_P(ent1->data));
			if (new_str) {
				Z_STRVAL_P(ent1->data) = new_str;
				Z_STRLEN_P(ent1->data) = new_len;
			} else {
				ZVAL_EMPTY_STRING(ent1->data);
			}
		}

		/* Call __wakeup() method on the object. */
		if (Z_TYPE_P(ent1->data) == IS_OBJECT) {
			zval *fname, *retval = NULL;

			MAKE_STD_ZVAL(fname);
			ZVAL_STRING(fname, ""__wakeup"", 1);

			call_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);

			zval_dtor(fname);
			FREE_ZVAL(fname);
			if (retval) {
				zval_ptr_dtor(&retval);
			}
		}

		if (stack->top > 1) {
			stack->top--;
 			wddx_stack_top(stack, (void**)&ent2);
 
 			/* if non-existent field */
//flaw_line_below:
			if (ent2->type == ST_FIELD && ent2->data == NULL) {
//fix_flaw_line_below:
//			if (ent2->data == NULL) {
 				zval_ptr_dtor(&ent1->data);
 				efree(ent1);
 				return;
			}

			if (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {
				target_hash = HASH_OF(ent2->data);

				if (ent1->varname) {
					if (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&
						Z_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&
						ent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {
						zend_bool incomplete_class = 0;

						zend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
						if (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),
										   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {
							incomplete_class = 1;
							pce = &PHP_IC_ENTRY;
						}

						/* Initialize target object */
						MAKE_STD_ZVAL(obj);
						object_init_ex(obj, *pce);

						/* Merge current hashtable with object's default properties */
						zend_hash_merge(Z_OBJPROP_P(obj),
										Z_ARRVAL_P(ent2->data),
										(void (*)(void *)) zval_add_ref,
										(void *) &tmp, sizeof(zval *), 0);

						if (incomplete_class) {
							php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
						}

						/* Clean up old array entry */
						zval_ptr_dtor(&ent2->data);

						/* Set stack entry to point to the newly created object */
						ent2->data = obj;

						/* Clean up class name var entry */
						zval_ptr_dtor(&ent1->data);
					} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {
						zend_class_entry *old_scope = EG(scope);

						EG(scope) = Z_OBJCE_P(ent2->data);
						Z_DELREF_P(ent1->data);
						add_property_zval(ent2->data, ent1->varname, ent1->data);
						EG(scope) = old_scope;
					} else {
						zend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);
					}
					efree(ent1->varname);
				} else	{
					zend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);
				}
			}
			efree(ent1);
		} else {
			stack->done = 1;
		}
	} else if (!strcmp(name, EL_VAR) && stack->varname) {
		efree(stack->varname);
		stack->varname = NULL;
	} else if (!strcmp(name, EL_FIELD)) {
		st_entry *ent;
		wddx_stack_top(stack, (void **)&ent);
		efree(ent);
		stack->top--;
	}
}
"
2386,180122,,Remote,Not required,Partial,CVE-2016-7130,https://www.cvedetails.com/cve/CVE-2016-7130/,CWE-476,Low,,,,2016-09-11,5.0,"The php_wddx_pop_element function in ext/wddx/wddx.c in PHP before 5.6.25 and 7.x before 7.0.10 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) or possibly have unspecified other impact via an invalid base64 binary value, as demonstrated by a wddx_deserialize call that mishandles a binary element in a wddxPacket XML document.",2018-01-04,DoS ,6,https://github.com/php/php-src/commit/698a691724c0a949295991e5df091ce16f899e02?w=1,698a691724c0a949295991e5df091ce16f899e02?w=1,Fix bug #72750: wddx_deserialize null dereference,2,ext/wddx/wddx.c,"{""sha"": ""3a6794df2803f71de7d23d16d261167db16ac095"", ""filename"": ""ext/wddx/tests/bug72750.phpt"", ""status"": ""added"", ""additions"": 34, ""deletions"": 0, ""changes"": 34, ""blob_url"": ""https://github.com/php/php-src/blob/698a691724c0a949295991e5df091ce16f899e02/ext/wddx/tests/bug72750.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/698a691724c0a949295991e5df091ce16f899e02/ext/wddx/tests/bug72750.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/tests/bug72750.phpt?ref=698a691724c0a949295991e5df091ce16f899e02"", ""patch"": ""@@ -0,0 +1,34 @@\n+--TEST--\n+Bug #72750: wddx_deserialize null dereference\n+--SKIPIF--\n+<?php\n+if (!extension_loaded('wddx')) {\n+    die('skip. wddx not available');\n+}\n+?>\n+--FILE--\n+<?php\n+\n+$xml = <<< XML\n+<?xml version='1.0'?>\n+<!DOCTYPE wddxPacket SYSTEM 'wddx_0100.dtd'>\n+<wddxPacket version='1.0'>\n+<header/>\n+        <data>\n+                <struct>\n+                     <var name='aBinary'>\n+                         <binary length='11'>\\\\tYmluYXJRhdGE=</binary>\n+                     </var>\n+                 </struct>\n+        </data>\n+</wddxPacket>\n+XML;\n+\n+$array = wddx_deserialize($xml);\n+var_dump($array);\n+?>\n+--EXPECT--\n+array(1) {\n+  [\""aBinary\""]=>\n+  string(0) \""\""\n+}""}<_**next**_>{""sha"": ""1b2d103af18e3a7f12e38c1894659432ac9fc7e4"", ""filename"": ""ext/wddx/wddx.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 2, ""changes"": 8, ""blob_url"": ""https://github.com/php/php-src/blob/698a691724c0a949295991e5df091ce16f899e02/ext/wddx/wddx.c"", ""raw_url"": ""https://github.com/php/php-src/raw/698a691724c0a949295991e5df091ce16f899e02/ext/wddx/wddx.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/wddx.c?ref=698a691724c0a949295991e5df091ce16f899e02"", ""patch"": ""@@ -959,8 +959,12 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n \n \t\t\tnew_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);\n \t\t\tSTR_FREE(Z_STRVAL_P(ent1->data));\n-\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n-\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n+\t\t\tif (new_str) {\n+\t\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n+\t\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n+\t\t\t} else {\n+\t\t\t\tZVAL_EMPTY_STRING(ent1->data);\n+\t\t\t}\n \t\t}\n \n \t\t/* Call __wakeup() method on the object. */""}","static void php_wddx_pop_element(void *user_data, const XML_Char *name)
{
	st_entry 			*ent1, *ent2;
	wddx_stack 			*stack = (wddx_stack *)user_data;
	HashTable 			*target_hash;
	zend_class_entry 	**pce;
	zval				*obj;
	zval				*tmp;
	TSRMLS_FETCH();

/* OBJECTS_FIXME */
	if (stack->top == 0) {
		return;
	}

	if (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||
		!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||
	  	!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||
		!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||
		!strcmp(name, EL_DATETIME)) {
		wddx_stack_top(stack, (void**)&ent1);

		if (!ent1->data) {
			if (stack->top > 1) {
				stack->top--;
			} else {
				stack->done = 1;
			}
			efree(ent1);
			return;
		}

		if (!strcmp(name, EL_BINARY)) {
			int new_len=0;
			unsigned char *new_str;
 
 			new_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);
 			STR_FREE(Z_STRVAL_P(ent1->data));
			if (new_str) {
				Z_STRVAL_P(ent1->data) = new_str;
				Z_STRLEN_P(ent1->data) = new_len;
			} else {
				ZVAL_EMPTY_STRING(ent1->data);
			}
 		}
 
 		/* Call __wakeup() method on the object. */
		if (Z_TYPE_P(ent1->data) == IS_OBJECT) {
			zval *fname, *retval = NULL;

			MAKE_STD_ZVAL(fname);
			ZVAL_STRING(fname, ""__wakeup"", 1);

			call_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);

			zval_dtor(fname);
			FREE_ZVAL(fname);
			if (retval) {
				zval_ptr_dtor(&retval);
			}
		}

		if (stack->top > 1) {
			stack->top--;
			wddx_stack_top(stack, (void**)&ent2);

			/* if non-existent field */
			if (ent2->type == ST_FIELD && ent2->data == NULL) {
				zval_ptr_dtor(&ent1->data);
				efree(ent1);
				return;
			}

			if (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {
				target_hash = HASH_OF(ent2->data);

				if (ent1->varname) {
					if (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&
						Z_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&
						ent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {
						zend_bool incomplete_class = 0;

						zend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
						if (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),
										   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {
							incomplete_class = 1;
							pce = &PHP_IC_ENTRY;
						}

						/* Initialize target object */
						MAKE_STD_ZVAL(obj);
						object_init_ex(obj, *pce);

						/* Merge current hashtable with object's default properties */
						zend_hash_merge(Z_OBJPROP_P(obj),
										Z_ARRVAL_P(ent2->data),
										(void (*)(void *)) zval_add_ref,
										(void *) &tmp, sizeof(zval *), 0);

						if (incomplete_class) {
							php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
						}

						/* Clean up old array entry */
						zval_ptr_dtor(&ent2->data);

						/* Set stack entry to point to the newly created object */
						ent2->data = obj;

						/* Clean up class name var entry */
						zval_ptr_dtor(&ent1->data);
					} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {
						zend_class_entry *old_scope = EG(scope);

						EG(scope) = Z_OBJCE_P(ent2->data);
						Z_DELREF_P(ent1->data);
						add_property_zval(ent2->data, ent1->varname, ent1->data);
						EG(scope) = old_scope;
					} else {
						zend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);
					}
					efree(ent1->varname);
				} else	{
					zend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);
				}
			}
			efree(ent1);
		} else {
			stack->done = 1;
		}
	} else if (!strcmp(name, EL_VAR) && stack->varname) {
		efree(stack->varname);
		stack->varname = NULL;
	} else if (!strcmp(name, EL_FIELD)) {
		st_entry *ent;
		wddx_stack_top(stack, (void **)&ent);
		efree(ent);
		stack->top--;
	}
}
","static void php_wddx_pop_element(void *user_data, const XML_Char *name)
{
	st_entry 			*ent1, *ent2;
	wddx_stack 			*stack = (wddx_stack *)user_data;
	HashTable 			*target_hash;
	zend_class_entry 	**pce;
	zval				*obj;
	zval				*tmp;
	TSRMLS_FETCH();

/* OBJECTS_FIXME */
	if (stack->top == 0) {
		return;
	}

	if (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||
		!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||
	  	!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||
		!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||
		!strcmp(name, EL_DATETIME)) {
		wddx_stack_top(stack, (void**)&ent1);

		if (!ent1->data) {
			if (stack->top > 1) {
				stack->top--;
			} else {
				stack->done = 1;
			}
			efree(ent1);
			return;
		}

		if (!strcmp(name, EL_BINARY)) {
			int new_len=0;
			unsigned char *new_str;
 
 			new_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);
 			STR_FREE(Z_STRVAL_P(ent1->data));
			Z_STRVAL_P(ent1->data) = new_str;
			Z_STRLEN_P(ent1->data) = new_len;
 		}
 
 		/* Call __wakeup() method on the object. */
		if (Z_TYPE_P(ent1->data) == IS_OBJECT) {
			zval *fname, *retval = NULL;

			MAKE_STD_ZVAL(fname);
			ZVAL_STRING(fname, ""__wakeup"", 1);

			call_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);

			zval_dtor(fname);
			FREE_ZVAL(fname);
			if (retval) {
				zval_ptr_dtor(&retval);
			}
		}

		if (stack->top > 1) {
			stack->top--;
			wddx_stack_top(stack, (void**)&ent2);

			/* if non-existent field */
			if (ent2->type == ST_FIELD && ent2->data == NULL) {
				zval_ptr_dtor(&ent1->data);
				efree(ent1);
				return;
			}

			if (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {
				target_hash = HASH_OF(ent2->data);

				if (ent1->varname) {
					if (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&
						Z_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&
						ent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {
						zend_bool incomplete_class = 0;

						zend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
						if (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),
										   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {
							incomplete_class = 1;
							pce = &PHP_IC_ENTRY;
						}

						/* Initialize target object */
						MAKE_STD_ZVAL(obj);
						object_init_ex(obj, *pce);

						/* Merge current hashtable with object's default properties */
						zend_hash_merge(Z_OBJPROP_P(obj),
										Z_ARRVAL_P(ent2->data),
										(void (*)(void *)) zval_add_ref,
										(void *) &tmp, sizeof(zval *), 0);

						if (incomplete_class) {
							php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
						}

						/* Clean up old array entry */
						zval_ptr_dtor(&ent2->data);

						/* Set stack entry to point to the newly created object */
						ent2->data = obj;

						/* Clean up class name var entry */
						zval_ptr_dtor(&ent1->data);
					} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {
						zend_class_entry *old_scope = EG(scope);

						EG(scope) = Z_OBJCE_P(ent2->data);
						Z_DELREF_P(ent1->data);
						add_property_zval(ent2->data, ent1->varname, ent1->data);
						EG(scope) = old_scope;
					} else {
						zend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);
					}
					efree(ent1->varname);
				} else	{
					zend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);
				}
			}
			efree(ent1);
		} else {
			stack->done = 1;
		}
	} else if (!strcmp(name, EL_VAR) && stack->varname) {
		efree(stack->varname);
		stack->varname = NULL;
	} else if (!strcmp(name, EL_FIELD)) {
		st_entry *ent;
		wddx_stack_top(stack, (void **)&ent);
		efree(ent);
		stack->top--;
	}
}
",C,"			if (new_str) {
				Z_STRVAL_P(ent1->data) = new_str;
				Z_STRLEN_P(ent1->data) = new_len;
			} else {
				ZVAL_EMPTY_STRING(ent1->data);
			}
","			Z_STRVAL_P(ent1->data) = new_str;
			Z_STRLEN_P(ent1->data) = new_len;
",,"@@ -959,8 +959,12 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)
 
 			new_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);
 			STR_FREE(Z_STRVAL_P(ent1->data));
-			Z_STRVAL_P(ent1->data) = new_str;
-			Z_STRLEN_P(ent1->data) = new_len;
+			if (new_str) {
+				Z_STRVAL_P(ent1->data) = new_str;
+				Z_STRLEN_P(ent1->data) = new_len;
+			} else {
+				ZVAL_EMPTY_STRING(ent1->data);
+			}
 		}
 
 		/* Call __wakeup() method on the object. */",php-src,698a691724c0a949295991e5df091ce16f899e02?w=1,e018ff094f8505ea77f881ba11176e3ad0b4863e,1,"static void php_wddx_pop_element(void *user_data, const XML_Char *name)
{
	st_entry 			*ent1, *ent2;
	wddx_stack 			*stack = (wddx_stack *)user_data;
	HashTable 			*target_hash;
	zend_class_entry 	**pce;
	zval				*obj;
	zval				*tmp;
	TSRMLS_FETCH();

/* OBJECTS_FIXME */
	if (stack->top == 0) {
		return;
	}

	if (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||
		!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||
	  	!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||
		!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||
		!strcmp(name, EL_DATETIME)) {
		wddx_stack_top(stack, (void**)&ent1);

		if (!ent1->data) {
			if (stack->top > 1) {
				stack->top--;
			} else {
				stack->done = 1;
			}
			efree(ent1);
			return;
		}

		if (!strcmp(name, EL_BINARY)) {
			int new_len=0;
			unsigned char *new_str;
 
 			new_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);
 			STR_FREE(Z_STRVAL_P(ent1->data));
//flaw_line_below:
			Z_STRVAL_P(ent1->data) = new_str;
//flaw_line_below:
			Z_STRLEN_P(ent1->data) = new_len;
//fix_flaw_line_below:
//			if (new_str) {
//fix_flaw_line_below:
//				Z_STRVAL_P(ent1->data) = new_str;
//fix_flaw_line_below:
//				Z_STRLEN_P(ent1->data) = new_len;
//fix_flaw_line_below:
//			} else {
//fix_flaw_line_below:
//				ZVAL_EMPTY_STRING(ent1->data);
//fix_flaw_line_below:
//			}
 		}
 
 		/* Call __wakeup() method on the object. */
		if (Z_TYPE_P(ent1->data) == IS_OBJECT) {
			zval *fname, *retval = NULL;

			MAKE_STD_ZVAL(fname);
			ZVAL_STRING(fname, ""__wakeup"", 1);

			call_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);

			zval_dtor(fname);
			FREE_ZVAL(fname);
			if (retval) {
				zval_ptr_dtor(&retval);
			}
		}

		if (stack->top > 1) {
			stack->top--;
			wddx_stack_top(stack, (void**)&ent2);

			/* if non-existent field */
			if (ent2->type == ST_FIELD && ent2->data == NULL) {
				zval_ptr_dtor(&ent1->data);
				efree(ent1);
				return;
			}

			if (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {
				target_hash = HASH_OF(ent2->data);

				if (ent1->varname) {
					if (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&
						Z_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&
						ent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {
						zend_bool incomplete_class = 0;

						zend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
						if (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),
										   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {
							incomplete_class = 1;
							pce = &PHP_IC_ENTRY;
						}

						/* Initialize target object */
						MAKE_STD_ZVAL(obj);
						object_init_ex(obj, *pce);

						/* Merge current hashtable with object's default properties */
						zend_hash_merge(Z_OBJPROP_P(obj),
										Z_ARRVAL_P(ent2->data),
										(void (*)(void *)) zval_add_ref,
										(void *) &tmp, sizeof(zval *), 0);

						if (incomplete_class) {
							php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
						}

						/* Clean up old array entry */
						zval_ptr_dtor(&ent2->data);

						/* Set stack entry to point to the newly created object */
						ent2->data = obj;

						/* Clean up class name var entry */
						zval_ptr_dtor(&ent1->data);
					} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {
						zend_class_entry *old_scope = EG(scope);

						EG(scope) = Z_OBJCE_P(ent2->data);
						Z_DELREF_P(ent1->data);
						add_property_zval(ent2->data, ent1->varname, ent1->data);
						EG(scope) = old_scope;
					} else {
						zend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);
					}
					efree(ent1->varname);
				} else	{
					zend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);
				}
			}
			efree(ent1);
		} else {
			stack->done = 1;
		}
	} else if (!strcmp(name, EL_VAR) && stack->varname) {
		efree(stack->varname);
		stack->varname = NULL;
	} else if (!strcmp(name, EL_FIELD)) {
		st_entry *ent;
		wddx_stack_top(stack, (void **)&ent);
		efree(ent);
		stack->top--;
	}
}
"
2436,180172,,Local,Not required,Complete,CVE-2016-6327,https://www.cvedetails.com/cve/CVE-2016-6327/,CWE-476,Low,,,,2016-10-16,4.9,drivers/infiniband/ulp/srpt/ib_srpt.c in the Linux kernel before 4.5.1 allows local users to cause a denial of service (NULL pointer dereference and system crash) by using an ABORT_TASK command to abort a device write operation.,2018-01-04,DoS ,1,https://github.com/torvalds/linux/commit/51093254bf879bc9ce96590400a87897c7498463,51093254bf879bc9ce96590400a87897c7498463,"IB/srpt: Simplify srpt_handle_tsk_mgmt()

Let the target core check task existence instead of the SRP target
driver. Additionally, let the target core check the validity of the
task management request instead of the ib_srpt driver.

This patch fixes the following kernel crash:

BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
IP: [<ffffffffa0565f37>] srpt_handle_new_iu+0x6d7/0x790 [ib_srpt]
Oops: 0002 [#1] SMP
Call Trace:
 [<ffffffffa05660ce>] srpt_process_completion+0xde/0x570 [ib_srpt]
 [<ffffffffa056669f>] srpt_compl_thread+0x13f/0x160 [ib_srpt]
 [<ffffffff8109726f>] kthread+0xcf/0xe0
 [<ffffffff81613cfc>] ret_from_fork+0x7c/0xb0

Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
Fixes: 3e4f574857ee (""ib_srpt: Convert TMR path to target_submit_tmr"")
Tested-by: Alex Estrin <alex.estrin@intel.com>
Reviewed-by: Christoph Hellwig <hch@lst.de>
Cc: Nicholas Bellinger <nab@linux-iscsi.org>
Cc: Sagi Grimberg <sagig@mellanox.com>
Cc: stable <stable@vger.kernel.org>
Signed-off-by: Doug Ledford <dledford@redhat.com>",16,drivers/infiniband/ulp/srpt/ib_srpt.c,"{""sha"": ""4328679a67a76792694a3e1169bc4e7bdac10d2f"", ""filename"": ""drivers/infiniband/ulp/srpt/ib_srpt.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 58, ""changes"": 59, ""blob_url"": ""https://github.com/torvalds/linux/blob/51093254bf879bc9ce96590400a87897c7498463/drivers/infiniband/ulp/srpt/ib_srpt.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/51093254bf879bc9ce96590400a87897c7498463/drivers/infiniband/ulp/srpt/ib_srpt.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/infiniband/ulp/srpt/ib_srpt.c?ref=51093254bf879bc9ce96590400a87897c7498463"", ""patch"": ""@@ -1670,47 +1670,6 @@ static int srpt_handle_cmd(struct srpt_rdma_ch *ch,\n \treturn -1;\n }\n \n-/**\n- * srpt_rx_mgmt_fn_tag() - Process a task management function by tag.\n- * @ch: RDMA channel of the task management request.\n- * @fn: Task management function to perform.\n- * @req_tag: Tag of the SRP task management request.\n- * @mgmt_ioctx: I/O context of the task management request.\n- *\n- * Returns zero if the target core will process the task management\n- * request asynchronously.\n- *\n- * Note: It is assumed that the initiator serializes tag-based task management\n- * requests.\n- */\n-static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)\n-{\n-\tstruct srpt_device *sdev;\n-\tstruct srpt_rdma_ch *ch;\n-\tstruct srpt_send_ioctx *target;\n-\tint ret, i;\n-\n-\tret = -EINVAL;\n-\tch = ioctx->ch;\n-\tBUG_ON(!ch);\n-\tBUG_ON(!ch->sport);\n-\tsdev = ch->sport->sdev;\n-\tBUG_ON(!sdev);\n-\tspin_lock_irq(&sdev->spinlock);\n-\tfor (i = 0; i < ch->rq_size; ++i) {\n-\t\ttarget = ch->ioctx_ring[i];\n-\t\tif (target->cmd.se_lun == ioctx->cmd.se_lun &&\n-\t\t    target->cmd.tag == tag &&\n-\t\t    srpt_get_cmd_state(target) != SRPT_STATE_DONE) {\n-\t\t\tret = 0;\n-\t\t\t/* now let the target core abort &target->cmd; */\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-\tspin_unlock_irq(&sdev->spinlock);\n-\treturn ret;\n-}\n-\n static int srp_tmr_to_tcm(int fn)\n {\n \tswitch (fn) {\n@@ -1745,7 +1704,6 @@ static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,\n \tstruct se_cmd *cmd;\n \tstruct se_session *sess = ch->sess;\n \tuint64_t unpacked_lun;\n-\tuint32_t tag = 0;\n \tint tcm_tmr;\n \tint rc;\n \n@@ -1761,25 +1719,10 @@ static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,\n \tsrpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);\n \tsend_ioctx->cmd.tag = srp_tsk->tag;\n \ttcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);\n-\tif (tcm_tmr < 0) {\n-\t\tsend_ioctx->cmd.se_tmr_req->response =\n-\t\t\tTMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;\n-\t\tgoto fail;\n-\t}\n \tunpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,\n \t\t\t\t       sizeof(srp_tsk->lun));\n-\n-\tif (srp_tsk->tsk_mgmt_func == SRP_TSK_ABORT_TASK) {\n-\t\trc = srpt_rx_mgmt_fn_tag(send_ioctx, srp_tsk->task_tag);\n-\t\tif (rc < 0) {\n-\t\t\tsend_ioctx->cmd.se_tmr_req->response =\n-\t\t\t\t\tTMR_TASK_DOES_NOT_EXIST;\n-\t\t\tgoto fail;\n-\t\t}\n-\t\ttag = srp_tsk->task_tag;\n-\t}\n \trc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,\n-\t\t\t\tsrp_tsk, tcm_tmr, GFP_KERNEL, tag,\n+\t\t\t\tsrp_tsk, tcm_tmr, GFP_KERNEL, srp_tsk->task_tag,\n \t\t\t\tTARGET_SCF_ACK_KREF);\n \tif (rc != 0) {\n \t\tsend_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;""}","static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,
				 struct srpt_recv_ioctx *recv_ioctx,
				 struct srpt_send_ioctx *send_ioctx)
{
	struct srp_tsk_mgmt *srp_tsk;
 	struct se_cmd *cmd;
 	struct se_session *sess = ch->sess;
 	uint64_t unpacked_lun;
 	int tcm_tmr;
 	int rc;
 
	BUG_ON(!send_ioctx);

	srp_tsk = recv_ioctx->ioctx.buf;
	cmd = &send_ioctx->cmd;

	pr_debug(""recv tsk_mgmt fn %d for task_tag %lld and cmd tag %lld""
		 "" cm_id %p sess %p\n"", srp_tsk->tsk_mgmt_func,
		 srp_tsk->task_tag, srp_tsk->tag, ch->cm_id, ch->sess);

 	srpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);
 	send_ioctx->cmd.tag = srp_tsk->tag;
 	tcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);
 	unpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,
 				       sizeof(srp_tsk->lun));
 	rc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,
				srp_tsk, tcm_tmr, GFP_KERNEL, srp_tsk->task_tag,
 				TARGET_SCF_ACK_KREF);
 	if (rc != 0) {
 		send_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;
		goto fail;
	}
	return;
fail:
	transport_send_check_condition_and_sense(cmd, 0, 0); // XXX:
}
","static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,
				 struct srpt_recv_ioctx *recv_ioctx,
				 struct srpt_send_ioctx *send_ioctx)
{
	struct srp_tsk_mgmt *srp_tsk;
 	struct se_cmd *cmd;
 	struct se_session *sess = ch->sess;
 	uint64_t unpacked_lun;
	uint32_t tag = 0;
 	int tcm_tmr;
 	int rc;
 
	BUG_ON(!send_ioctx);

	srp_tsk = recv_ioctx->ioctx.buf;
	cmd = &send_ioctx->cmd;

	pr_debug(""recv tsk_mgmt fn %d for task_tag %lld and cmd tag %lld""
		 "" cm_id %p sess %p\n"", srp_tsk->tsk_mgmt_func,
		 srp_tsk->task_tag, srp_tsk->tag, ch->cm_id, ch->sess);

 	srpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);
 	send_ioctx->cmd.tag = srp_tsk->tag;
 	tcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);
	if (tcm_tmr < 0) {
		send_ioctx->cmd.se_tmr_req->response =
			TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;
		goto fail;
	}
 	unpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,
 				       sizeof(srp_tsk->lun));
	if (srp_tsk->tsk_mgmt_func == SRP_TSK_ABORT_TASK) {
		rc = srpt_rx_mgmt_fn_tag(send_ioctx, srp_tsk->task_tag);
		if (rc < 0) {
			send_ioctx->cmd.se_tmr_req->response =
					TMR_TASK_DOES_NOT_EXIST;
			goto fail;
		}
		tag = srp_tsk->task_tag;
	}
 	rc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,
				srp_tsk, tcm_tmr, GFP_KERNEL, tag,
 				TARGET_SCF_ACK_KREF);
 	if (rc != 0) {
 		send_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;
		goto fail;
	}
	return;
fail:
	transport_send_check_condition_and_sense(cmd, 0, 0); // XXX:
}
",C,"				srp_tsk, tcm_tmr, GFP_KERNEL, srp_tsk->task_tag,
","	uint32_t tag = 0;
	if (tcm_tmr < 0) {
		send_ioctx->cmd.se_tmr_req->response =
			TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;
		goto fail;
	}
	if (srp_tsk->tsk_mgmt_func == SRP_TSK_ABORT_TASK) {
		rc = srpt_rx_mgmt_fn_tag(send_ioctx, srp_tsk->task_tag);
		if (rc < 0) {
			send_ioctx->cmd.se_tmr_req->response =
					TMR_TASK_DOES_NOT_EXIST;
			goto fail;
		}
		tag = srp_tsk->task_tag;
	}
				srp_tsk, tcm_tmr, GFP_KERNEL, tag,
",,"@@ -1670,47 +1670,6 @@ static int srpt_handle_cmd(struct srpt_rdma_ch *ch,
 	return -1;
 }
 
-/**
- * srpt_rx_mgmt_fn_tag() - Process a task management function by tag.
- * @ch: RDMA channel of the task management request.
- * @fn: Task management function to perform.
- * @req_tag: Tag of the SRP task management request.
- * @mgmt_ioctx: I/O context of the task management request.
- *
- * Returns zero if the target core will process the task management
- * request asynchronously.
- *
- * Note: It is assumed that the initiator serializes tag-based task management
- * requests.
- */
-static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)
-{
-	struct srpt_device *sdev;
-	struct srpt_rdma_ch *ch;
-	struct srpt_send_ioctx *target;
-	int ret, i;
-
-	ret = -EINVAL;
-	ch = ioctx->ch;
-	BUG_ON(!ch);
-	BUG_ON(!ch->sport);
-	sdev = ch->sport->sdev;
-	BUG_ON(!sdev);
-	spin_lock_irq(&sdev->spinlock);
-	for (i = 0; i < ch->rq_size; ++i) {
-		target = ch->ioctx_ring[i];
-		if (target->cmd.se_lun == ioctx->cmd.se_lun &&
-		    target->cmd.tag == tag &&
-		    srpt_get_cmd_state(target) != SRPT_STATE_DONE) {
-			ret = 0;
-			/* now let the target core abort &target->cmd; */
-			break;
-		}
-	}
-	spin_unlock_irq(&sdev->spinlock);
-	return ret;
-}
-
 static int srp_tmr_to_tcm(int fn)
 {
 	switch (fn) {
@@ -1745,7 +1704,6 @@ static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,
 	struct se_cmd *cmd;
 	struct se_session *sess = ch->sess;
 	uint64_t unpacked_lun;
-	uint32_t tag = 0;
 	int tcm_tmr;
 	int rc;
 
@@ -1761,25 +1719,10 @@ static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,
 	srpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);
 	send_ioctx->cmd.tag = srp_tsk->tag;
 	tcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);
-	if (tcm_tmr < 0) {
-		send_ioctx->cmd.se_tmr_req->response =
-			TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;
-		goto fail;
-	}
 	unpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,
 				       sizeof(srp_tsk->lun));
-
-	if (srp_tsk->tsk_mgmt_func == SRP_TSK_ABORT_TASK) {
-		rc = srpt_rx_mgmt_fn_tag(send_ioctx, srp_tsk->task_tag);
-		if (rc < 0) {
-			send_ioctx->cmd.se_tmr_req->response =
-					TMR_TASK_DOES_NOT_EXIST;
-			goto fail;
-		}
-		tag = srp_tsk->task_tag;
-	}
 	rc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,
-				srp_tsk, tcm_tmr, GFP_KERNEL, tag,
+				srp_tsk, tcm_tmr, GFP_KERNEL, srp_tsk->task_tag,
 				TARGET_SCF_ACK_KREF);
 	if (rc != 0) {
 		send_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;",linux,51093254bf879bc9ce96590400a87897c7498463,fc77dbd34c5c99bce46d40a2491937c3bcbd10af,1,"static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,
				 struct srpt_recv_ioctx *recv_ioctx,
				 struct srpt_send_ioctx *send_ioctx)
{
	struct srp_tsk_mgmt *srp_tsk;
 	struct se_cmd *cmd;
 	struct se_session *sess = ch->sess;
 	uint64_t unpacked_lun;
//flaw_line_below:
	uint32_t tag = 0;
 	int tcm_tmr;
 	int rc;
 
	BUG_ON(!send_ioctx);

	srp_tsk = recv_ioctx->ioctx.buf;
	cmd = &send_ioctx->cmd;

	pr_debug(""recv tsk_mgmt fn %d for task_tag %lld and cmd tag %lld""
		 "" cm_id %p sess %p\n"", srp_tsk->tsk_mgmt_func,
		 srp_tsk->task_tag, srp_tsk->tag, ch->cm_id, ch->sess);

 	srpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);
 	send_ioctx->cmd.tag = srp_tsk->tag;
 	tcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);
//flaw_line_below:
	if (tcm_tmr < 0) {
//flaw_line_below:
		send_ioctx->cmd.se_tmr_req->response =
//flaw_line_below:
			TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;
//flaw_line_below:
		goto fail;
//flaw_line_below:
	}
 	unpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,
 				       sizeof(srp_tsk->lun));
//flaw_line_below:

//flaw_line_below:
	if (srp_tsk->tsk_mgmt_func == SRP_TSK_ABORT_TASK) {
//flaw_line_below:
		rc = srpt_rx_mgmt_fn_tag(send_ioctx, srp_tsk->task_tag);
//flaw_line_below:
		if (rc < 0) {
//flaw_line_below:
			send_ioctx->cmd.se_tmr_req->response =
//flaw_line_below:
					TMR_TASK_DOES_NOT_EXIST;
//flaw_line_below:
			goto fail;
//flaw_line_below:
		}
//flaw_line_below:
		tag = srp_tsk->task_tag;
//flaw_line_below:
	}
 	rc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,
//flaw_line_below:
				srp_tsk, tcm_tmr, GFP_KERNEL, tag,
//fix_flaw_line_below:
//				srp_tsk, tcm_tmr, GFP_KERNEL, srp_tsk->task_tag,
 				TARGET_SCF_ACK_KREF);
 	if (rc != 0) {
 		send_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;
		goto fail;
	}
	return;
fail:
	transport_send_check_condition_and_sense(cmd, 0, 0); // XXX:
}
"
2437,180173,,Local,Not required,Complete,CVE-2016-6327,https://www.cvedetails.com/cve/CVE-2016-6327/,CWE-476,Low,,,,2016-10-16,4.9,drivers/infiniband/ulp/srpt/ib_srpt.c in the Linux kernel before 4.5.1 allows local users to cause a denial of service (NULL pointer dereference and system crash) by using an ABORT_TASK command to abort a device write operation.,2018-01-04,DoS ,0,https://github.com/torvalds/linux/commit/51093254bf879bc9ce96590400a87897c7498463,51093254bf879bc9ce96590400a87897c7498463,"IB/srpt: Simplify srpt_handle_tsk_mgmt()

Let the target core check task existence instead of the SRP target
driver. Additionally, let the target core check the validity of the
task management request instead of the ib_srpt driver.

This patch fixes the following kernel crash:

BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
IP: [<ffffffffa0565f37>] srpt_handle_new_iu+0x6d7/0x790 [ib_srpt]
Oops: 0002 [#1] SMP
Call Trace:
 [<ffffffffa05660ce>] srpt_process_completion+0xde/0x570 [ib_srpt]
 [<ffffffffa056669f>] srpt_compl_thread+0x13f/0x160 [ib_srpt]
 [<ffffffff8109726f>] kthread+0xcf/0xe0
 [<ffffffff81613cfc>] ret_from_fork+0x7c/0xb0

Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
Fixes: 3e4f574857ee (""ib_srpt: Convert TMR path to target_submit_tmr"")
Tested-by: Alex Estrin <alex.estrin@intel.com>
Reviewed-by: Christoph Hellwig <hch@lst.de>
Cc: Nicholas Bellinger <nab@linux-iscsi.org>
Cc: Sagi Grimberg <sagig@mellanox.com>
Cc: stable <stable@vger.kernel.org>
Signed-off-by: Doug Ledford <dledford@redhat.com>",25,drivers/infiniband/ulp/srpt/ib_srpt.c,"{""sha"": ""4328679a67a76792694a3e1169bc4e7bdac10d2f"", ""filename"": ""drivers/infiniband/ulp/srpt/ib_srpt.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 58, ""changes"": 59, ""blob_url"": ""https://github.com/torvalds/linux/blob/51093254bf879bc9ce96590400a87897c7498463/drivers/infiniband/ulp/srpt/ib_srpt.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/51093254bf879bc9ce96590400a87897c7498463/drivers/infiniband/ulp/srpt/ib_srpt.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/infiniband/ulp/srpt/ib_srpt.c?ref=51093254bf879bc9ce96590400a87897c7498463"", ""patch"": ""@@ -1670,47 +1670,6 @@ static int srpt_handle_cmd(struct srpt_rdma_ch *ch,\n \treturn -1;\n }\n \n-/**\n- * srpt_rx_mgmt_fn_tag() - Process a task management function by tag.\n- * @ch: RDMA channel of the task management request.\n- * @fn: Task management function to perform.\n- * @req_tag: Tag of the SRP task management request.\n- * @mgmt_ioctx: I/O context of the task management request.\n- *\n- * Returns zero if the target core will process the task management\n- * request asynchronously.\n- *\n- * Note: It is assumed that the initiator serializes tag-based task management\n- * requests.\n- */\n-static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)\n-{\n-\tstruct srpt_device *sdev;\n-\tstruct srpt_rdma_ch *ch;\n-\tstruct srpt_send_ioctx *target;\n-\tint ret, i;\n-\n-\tret = -EINVAL;\n-\tch = ioctx->ch;\n-\tBUG_ON(!ch);\n-\tBUG_ON(!ch->sport);\n-\tsdev = ch->sport->sdev;\n-\tBUG_ON(!sdev);\n-\tspin_lock_irq(&sdev->spinlock);\n-\tfor (i = 0; i < ch->rq_size; ++i) {\n-\t\ttarget = ch->ioctx_ring[i];\n-\t\tif (target->cmd.se_lun == ioctx->cmd.se_lun &&\n-\t\t    target->cmd.tag == tag &&\n-\t\t    srpt_get_cmd_state(target) != SRPT_STATE_DONE) {\n-\t\t\tret = 0;\n-\t\t\t/* now let the target core abort &target->cmd; */\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-\tspin_unlock_irq(&sdev->spinlock);\n-\treturn ret;\n-}\n-\n static int srp_tmr_to_tcm(int fn)\n {\n \tswitch (fn) {\n@@ -1745,7 +1704,6 @@ static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,\n \tstruct se_cmd *cmd;\n \tstruct se_session *sess = ch->sess;\n \tuint64_t unpacked_lun;\n-\tuint32_t tag = 0;\n \tint tcm_tmr;\n \tint rc;\n \n@@ -1761,25 +1719,10 @@ static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,\n \tsrpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);\n \tsend_ioctx->cmd.tag = srp_tsk->tag;\n \ttcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);\n-\tif (tcm_tmr < 0) {\n-\t\tsend_ioctx->cmd.se_tmr_req->response =\n-\t\t\tTMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;\n-\t\tgoto fail;\n-\t}\n \tunpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,\n \t\t\t\t       sizeof(srp_tsk->lun));\n-\n-\tif (srp_tsk->tsk_mgmt_func == SRP_TSK_ABORT_TASK) {\n-\t\trc = srpt_rx_mgmt_fn_tag(send_ioctx, srp_tsk->task_tag);\n-\t\tif (rc < 0) {\n-\t\t\tsend_ioctx->cmd.se_tmr_req->response =\n-\t\t\t\t\tTMR_TASK_DOES_NOT_EXIST;\n-\t\t\tgoto fail;\n-\t\t}\n-\t\ttag = srp_tsk->task_tag;\n-\t}\n \trc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,\n-\t\t\t\tsrp_tsk, tcm_tmr, GFP_KERNEL, tag,\n+\t\t\t\tsrp_tsk, tcm_tmr, GFP_KERNEL, srp_tsk->task_tag,\n \t\t\t\tTARGET_SCF_ACK_KREF);\n \tif (rc != 0) {\n \t\tsend_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;""}","static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)
","static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)
{
	struct srpt_device *sdev;
	struct srpt_rdma_ch *ch;
	struct srpt_send_ioctx *target;
	int ret, i;
	ret = -EINVAL;
	ch = ioctx->ch;
	BUG_ON(!ch);
	BUG_ON(!ch->sport);
	sdev = ch->sport->sdev;
	BUG_ON(!sdev);
	spin_lock_irq(&sdev->spinlock);
	for (i = 0; i < ch->rq_size; ++i) {
		target = ch->ioctx_ring[i];
		if (target->cmd.se_lun == ioctx->cmd.se_lun &&
		    target->cmd.tag == tag &&
		    srpt_get_cmd_state(target) != SRPT_STATE_DONE) {
			ret = 0;
			/* now let the target core abort &target->cmd; */
			break;
		}
	}
	spin_unlock_irq(&sdev->spinlock);
	return ret;
}
",C,,"{
	struct srpt_device *sdev;
	struct srpt_rdma_ch *ch;
	struct srpt_send_ioctx *target;
	int ret, i;
	ret = -EINVAL;
	ch = ioctx->ch;
	BUG_ON(!ch);
	BUG_ON(!ch->sport);
	sdev = ch->sport->sdev;
	BUG_ON(!sdev);
	spin_lock_irq(&sdev->spinlock);
	for (i = 0; i < ch->rq_size; ++i) {
		target = ch->ioctx_ring[i];
		if (target->cmd.se_lun == ioctx->cmd.se_lun &&
		    target->cmd.tag == tag &&
		    srpt_get_cmd_state(target) != SRPT_STATE_DONE) {
			ret = 0;
			/* now let the target core abort &target->cmd; */
			break;
		}
	}
	spin_unlock_irq(&sdev->spinlock);
	return ret;
}
",,"@@ -1670,47 +1670,6 @@ static int srpt_handle_cmd(struct srpt_rdma_ch *ch,
 	return -1;
 }
 
-/**
- * srpt_rx_mgmt_fn_tag() - Process a task management function by tag.
- * @ch: RDMA channel of the task management request.
- * @fn: Task management function to perform.
- * @req_tag: Tag of the SRP task management request.
- * @mgmt_ioctx: I/O context of the task management request.
- *
- * Returns zero if the target core will process the task management
- * request asynchronously.
- *
- * Note: It is assumed that the initiator serializes tag-based task management
- * requests.
- */
-static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)
-{
-	struct srpt_device *sdev;
-	struct srpt_rdma_ch *ch;
-	struct srpt_send_ioctx *target;
-	int ret, i;
-
-	ret = -EINVAL;
-	ch = ioctx->ch;
-	BUG_ON(!ch);
-	BUG_ON(!ch->sport);
-	sdev = ch->sport->sdev;
-	BUG_ON(!sdev);
-	spin_lock_irq(&sdev->spinlock);
-	for (i = 0; i < ch->rq_size; ++i) {
-		target = ch->ioctx_ring[i];
-		if (target->cmd.se_lun == ioctx->cmd.se_lun &&
-		    target->cmd.tag == tag &&
-		    srpt_get_cmd_state(target) != SRPT_STATE_DONE) {
-			ret = 0;
-			/* now let the target core abort &target->cmd; */
-			break;
-		}
-	}
-	spin_unlock_irq(&sdev->spinlock);
-	return ret;
-}
-
 static int srp_tmr_to_tcm(int fn)
 {
 	switch (fn) {
@@ -1745,7 +1704,6 @@ static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,
 	struct se_cmd *cmd;
 	struct se_session *sess = ch->sess;
 	uint64_t unpacked_lun;
-	uint32_t tag = 0;
 	int tcm_tmr;
 	int rc;
 
@@ -1761,25 +1719,10 @@ static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,
 	srpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);
 	send_ioctx->cmd.tag = srp_tsk->tag;
 	tcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);
-	if (tcm_tmr < 0) {
-		send_ioctx->cmd.se_tmr_req->response =
-			TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;
-		goto fail;
-	}
 	unpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,
 				       sizeof(srp_tsk->lun));
-
-	if (srp_tsk->tsk_mgmt_func == SRP_TSK_ABORT_TASK) {
-		rc = srpt_rx_mgmt_fn_tag(send_ioctx, srp_tsk->task_tag);
-		if (rc < 0) {
-			send_ioctx->cmd.se_tmr_req->response =
-					TMR_TASK_DOES_NOT_EXIST;
-			goto fail;
-		}
-		tag = srp_tsk->task_tag;
-	}
 	rc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,
-				srp_tsk, tcm_tmr, GFP_KERNEL, tag,
+				srp_tsk, tcm_tmr, GFP_KERNEL, srp_tsk->task_tag,
 				TARGET_SCF_ACK_KREF);
 	if (rc != 0) {
 		send_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;",linux,51093254bf879bc9ce96590400a87897c7498463,fc77dbd34c5c99bce46d40a2491937c3bcbd10af,1,"static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)
//flaw_line_below:
{
//flaw_line_below:
	struct srpt_device *sdev;
//flaw_line_below:
	struct srpt_rdma_ch *ch;
//flaw_line_below:
	struct srpt_send_ioctx *target;
//flaw_line_below:
	int ret, i;
//flaw_line_below:

//flaw_line_below:
	ret = -EINVAL;
//flaw_line_below:
	ch = ioctx->ch;
//flaw_line_below:
	BUG_ON(!ch);
//flaw_line_below:
	BUG_ON(!ch->sport);
//flaw_line_below:
	sdev = ch->sport->sdev;
//flaw_line_below:
	BUG_ON(!sdev);
//flaw_line_below:
	spin_lock_irq(&sdev->spinlock);
//flaw_line_below:
	for (i = 0; i < ch->rq_size; ++i) {
//flaw_line_below:
		target = ch->ioctx_ring[i];
//flaw_line_below:
		if (target->cmd.se_lun == ioctx->cmd.se_lun &&
//flaw_line_below:
		    target->cmd.tag == tag &&
//flaw_line_below:
		    srpt_get_cmd_state(target) != SRPT_STATE_DONE) {
//flaw_line_below:
			ret = 0;
//flaw_line_below:
			/* now let the target core abort &target->cmd; */
//flaw_line_below:
			break;
//flaw_line_below:
		}
//flaw_line_below:
	}
//flaw_line_below:
	spin_unlock_irq(&sdev->spinlock);
//flaw_line_below:
	return ret;
//flaw_line_below:
}
"
2588,180324,,Remote,Not required,Partial,CVE-2016-5354,https://www.cvedetails.com/cve/CVE-2016-5354/,CWE-476,Medium,,,,2016-08-07,4.3,"The USB subsystem in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles class types, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.",2016-11-28,DoS ,4,https://github.com/wireshark/wireshark/commit/2cb5985bf47bdc8bea78d28483ed224abdd33dc6,2cb5985bf47bdc8bea78d28483ed224abdd33dc6,"Make class ""type"" for USB conversations.

USB dissectors can't assume that only their class type has been passed around in the conversation.  Make explicit check that class type expected matches the dissector and stop/prevent dissection if there isn't a match.

Bug: 12356
Change-Id: Ib23973a4ebd0fbb51952ffc118daf95e3389a209
Reviewed-on: https://code.wireshark.org/review/15212
Petri-Dish: Michael Mann <mmann78@netscape.net>
Reviewed-by: Martin Kaiser <wireshark@kaiser.cx>
Petri-Dish: Martin Kaiser <wireshark@kaiser.cx>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Michael Mann <mmann78@netscape.net>",0,epan/dissectors/packet-u3v.c,"{""sha"": ""8e1a979eddce1cff46908cac8a0548793e61d396"", ""filename"": ""epan/dissectors/packet-u3v.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/wireshark/wireshark/blob/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-u3v.c"", ""raw_url"": ""https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-u3v.c"", ""contents_url"": ""https://api.github.com/repos/wireshark/wireshark/contents/epan/dissectors/packet-u3v.c?ref=2cb5985bf47bdc8bea78d28483ed224abdd33dc6"", ""patch"": ""@@ -1683,6 +1683,10 @@ dissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\n     if (!u3v_conv_info) {\n         u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);\n         usb_conv_info->class_data = u3v_conv_info;\n+        usb_conv_info->class_data_type = USB_CONV_U3V;\n+    } else if (usb_conv_info->class_data_type != USB_CONV_U3V) {\n+        /* Don't dissect if another USB type is in the conversation */\n+        return 0;\n     }\n \n     prefix = tvb_get_letohl(tvb, 0);""}<_**next**_>{""sha"": ""df6e9ef7dff96e86386eea8acd40f34c70854e1d"", ""filename"": ""epan/dissectors/packet-usb-audio.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/wireshark/wireshark/blob/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-audio.c"", ""raw_url"": ""https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-audio.c"", ""contents_url"": ""https://api.github.com/repos/wireshark/wireshark/contents/epan/dissectors/packet-usb-audio.c?ref=2cb5985bf47bdc8bea78d28483ed224abdd33dc6"", ""patch"": ""@@ -435,8 +435,12 @@ dissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n     if(!audio_conv_info) {\n         audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);\n         usb_conv_info->class_data = audio_conv_info;\n+        usb_conv_info->class_data_type = USB_CONV_AUDIO;\n         /* XXX - set reasonable default values for all components\n            that are not filled in by this function */\n+    } else if (usb_conv_info->class_data_type != USB_CONV_AUDIO) {\n+        /* Don't dissect if another USB type is in the conversation */\n+        return 0;\n     }\n     audio_conv_info->ver_major = ver_major;\n     offset += 2;""}<_**next**_>{""sha"": ""919f7ef36431aaa7b7e66bb108ceef710c6dfee4"", ""filename"": ""epan/dissectors/packet-usb-masstorage.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/wireshark/wireshark/blob/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-masstorage.c"", ""raw_url"": ""https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-masstorage.c"", ""contents_url"": ""https://api.github.com/repos/wireshark/wireshark/contents/epan/dissectors/packet-usb-masstorage.c?ref=2cb5985bf47bdc8bea78d28483ed224abdd33dc6"", ""patch"": ""@@ -199,9 +199,12 @@ dissect_usb_ms_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree,\n         usb_ms_conv_info->itl=wmem_tree_new(wmem_file_scope());\n         usb_ms_conv_info->itlq=wmem_tree_new(wmem_file_scope());\n         usb_conv_info->class_data=usb_ms_conv_info;\n+        usb_conv_info->class_data_type = USB_CONV_MASS_STORAGE;\n+    } else if (usb_conv_info->class_data_type != USB_CONV_MASS_STORAGE) {\n+        /* Don't dissect if another USB type is in the conversation */\n+        return 0;\n     }\n \n-\n     is_request=(pinfo->srcport==NO_ENDPOINT);\n \n     col_set_str(pinfo->cinfo, COL_PROTOCOL, \""USBMS\"");""}<_**next**_>{""sha"": ""3bf08f6156f34a3b268a04edfbf76b3cd495bf98"", ""filename"": ""epan/dissectors/packet-usb-video.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/wireshark/wireshark/blob/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-video.c"", ""raw_url"": ""https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-video.c"", ""contents_url"": ""https://api.github.com/repos/wireshark/wireshark/contents/epan/dissectors/packet-usb-video.c?ref=2cb5985bf47bdc8bea78d28483ed224abdd33dc6"", ""patch"": ""@@ -1035,6 +1035,10 @@ dissect_usb_video_control_interface_descriptor(proto_tree *parent_tree, tvbuff_t\n             video_conv_info = wmem_new(wmem_file_scope(), video_conv_info_t);\n             video_conv_info->entities = wmem_tree_new(wmem_file_scope());\n             usb_conv_info->class_data = video_conv_info;\n+            usb_conv_info->class_data_type = USB_CONV_VIDEO;\n+        } else if (usb_conv_info->class_data_type != USB_CONV_VIDEO) {\n+            /* Stop dissection if another USB type is in the conversation */\n+            return descriptor_len;\n         }\n \n         entity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);""}<_**next**_>{""sha"": ""261592db5d3ac44db535d2155b8934d1175701c9"", ""filename"": ""epan/dissectors/packet-usb.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/wireshark/wireshark/blob/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb.h"", ""raw_url"": ""https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb.h"", ""contents_url"": ""https://api.github.com/repos/wireshark/wireshark/contents/epan/dissectors/packet-usb.h?ref=2cb5985bf47bdc8bea78d28483ed224abdd33dc6"", ""patch"": ""@@ -90,6 +90,8 @@ typedef struct _usb_trans_info_t {\n     guint64 usb_id;\n } usb_trans_info_t;\n \n+enum usb_conv_class_data_type {USB_CONV_UNKNOWN = 0, USB_CONV_U3V, USB_CONV_AUDIO, USB_CONV_VIDEO, USB_CONV_MASS_STORAGE};\n+\n /* Conversation Structure\n  * there is one such structure for each device/endpoint conversation */\n struct _usb_conv_info_t {\n@@ -113,7 +115,8 @@ struct _usb_conv_info_t {\n     wmem_tree_t *transactions;\n     usb_trans_info_t *usb_trans_info; /* pointer to the current transaction */\n \n-    void *class_data;\t/* private class/id decode data */\n+    void *class_data;           /* private class/id decode data */\n+    enum usb_conv_class_data_type class_data_type;\n \n     wmem_array_t *alt_settings;\n };""}","dissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
    gint offset = 0;
    proto_tree *u3v_tree = NULL, *ccd_tree_flag, *u3v_telegram_tree = NULL, *ccd_tree = NULL;
    gint data_length = 0;
    gint req_id = 0;
    gint command_id = -1;
    gint status = 0;
    guint prefix = 0;
    proto_item *ti = NULL;
    proto_item *item = NULL;
    const char *command_string;
    usb_conv_info_t *usb_conv_info;
    gint stream_detected = FALSE;
    gint control_detected = FALSE;
    u3v_conv_info_t *u3v_conv_info = NULL;
    gencp_transaction_t *gencp_trans = NULL;

    usb_conv_info = (usb_conv_info_t *)data;

    /* decide if this packet belongs to U3V protocol */
    u3v_conv_info = (u3v_conv_info_t *)usb_conv_info->class_data;

     if (!u3v_conv_info) {
         u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);
         usb_conv_info->class_data = u3v_conv_info;
        usb_conv_info->class_data_type = USB_CONV_U3V;
    } else if (usb_conv_info->class_data_type != USB_CONV_U3V) {
        /* Don't dissect if another USB type is in the conversation */
        return 0;
     }
 
     prefix = tvb_get_letohl(tvb, 0);
    if ((tvb_reported_length(tvb) >= 4) && ( ( U3V_CONTROL_PREFIX == prefix ) || ( U3V_EVENT_PREFIX == prefix ) ) ) {
        control_detected = TRUE;
    }

    if (((tvb_reported_length(tvb) >= 4) && (( U3V_STREAM_LEADER_PREFIX == prefix ) || ( U3V_STREAM_TRAILER_PREFIX == prefix )))
         || (usb_conv_info->endpoint == u3v_conv_info->ep_stream)) {
        stream_detected = TRUE;
    }

    /* initialize interface class/subclass in case no descriptors have been dissected yet */
    if ( control_detected || stream_detected){
        if ( usb_conv_info->interfaceClass  == IF_CLASS_UNKNOWN &&
             usb_conv_info->interfaceSubclass  == IF_SUBCLASS_UNKNOWN){
            usb_conv_info->interfaceClass = IF_CLASS_MISCELLANEOUS;
            usb_conv_info->interfaceSubclass = IF_SUBCLASS_MISC_U3V;
        }
    }

    if ( control_detected ) {
        /* Set the protocol column */
        col_set_str(pinfo->cinfo, COL_PROTOCOL, ""U3V"");

        /* Clear out stuff in the info column */
        col_clear(pinfo->cinfo, COL_INFO);

        /* Adds ""USB3Vision"" heading to protocol tree */
        /* We will add fields to this using the u3v_tree pointer */
        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);
        u3v_tree = proto_item_add_subtree(ti, ett_u3v);

        prefix = tvb_get_letohl(tvb, offset);
        command_id = tvb_get_letohs(tvb, offset+6);

        /* decode CCD ( DCI/DCE command data layout) */
        if ((prefix == U3V_CONTROL_PREFIX || prefix == U3V_EVENT_PREFIX) && ((command_id % 2) == 0)) {
            command_string = val_to_str(command_id,command_names,""Unknown Command (0x%x)"");
            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_cmd, tvb, offset, 8, ENC_NA);
            proto_item_append_text(item, "": %s"", command_string);
            ccd_tree = proto_item_add_subtree(item, ett_u3v_cmd);

            /* Add the prefix code: */
            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;

            /* Add the flags */
            item = proto_tree_add_item(ccd_tree, hf_u3v_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            ccd_tree_flag  = proto_item_add_subtree(item, ett_u3v_flags);
            proto_tree_add_item(ccd_tree_flag, hf_u3v_acknowledge_required_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);

            offset += 2;
            col_append_fstr(pinfo->cinfo, COL_INFO, ""> %s "", command_string);
        } else if (prefix == U3V_CONTROL_PREFIX && ((command_id % 2) == 1)) {
            command_string = val_to_str(command_id,command_names,""Unknown Acknowledge (0x%x)"");
            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_ack, tvb, offset, 8, ENC_NA);
            proto_item_append_text(item, "": %s"", command_string);
            ccd_tree = proto_item_add_subtree(item, ett_u3v_ack);

            /* Add the prefix code: */
            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;

            /* Add the status: */
            proto_tree_add_item(ccd_tree, hf_u3v_status, tvb, offset, 2,ENC_LITTLE_ENDIAN);
            status = tvb_get_letohs(tvb, offset);
            offset += 2;
            col_append_fstr(pinfo->cinfo, COL_INFO, ""< %s %s"",
                    command_string,
                    val_to_str(status, status_names_short, ""Unknown status (0x%04X)""));
        } else {
            return 0;
        }

        /* Add the command id*/
        proto_tree_add_item(ccd_tree, hf_u3v_command_id, tvb, offset, 2,ENC_LITTLE_ENDIAN);
        offset += 2;

        /* Parse the second part of both the command and the acknowledge header:
        0          15 16         31
        -------- -------- -------- --------
        |     status      |   acknowledge   |
        -------- -------- -------- --------
        |     length      |      req_id     |
        -------- -------- -------- --------

        Add the data length
        Number of valid data bytes in this message, not including this header. This
        represents the number of bytes of payload appended after this header */

        proto_tree_add_item(ccd_tree, hf_u3v_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        data_length = tvb_get_letohs(tvb, offset);
        offset += 2;

        /* Add the request ID */
        proto_tree_add_item(ccd_tree, hf_u3v_request_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        req_id = tvb_get_letohs(tvb, offset);
        offset += 2;

        /* Add telegram subtree */
        u3v_telegram_tree = proto_item_add_subtree(u3v_tree, ett_u3v);

        if (!PINFO_FD_VISITED(pinfo)) {
              if ((command_id % 2) == 0) {
                    /* This is a command */
                    gencp_trans = wmem_new(wmem_file_scope(), gencp_transaction_t);
                    gencp_trans->cmd_frame = pinfo->fd->num;
                    gencp_trans->ack_frame = 0;
                    gencp_trans->cmd_time = pinfo->fd->abs_ts;
                    /* add reference to current packet */
                    p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);
                    /* add reference to current */
                    u3v_conv_info->trans_info = gencp_trans;
                } else {
                    gencp_trans = u3v_conv_info->trans_info;
                    if (gencp_trans) {
                        gencp_trans->ack_frame = pinfo->fd->num;
                        /* add reference to current packet */
                        p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);
                    }
                }
         } else {
            gencp_trans = (gencp_transaction_t*)p_get_proto_data(wmem_file_scope(),pinfo, proto_u3v, req_id);
         }

        if (!gencp_trans) {
            /* create a ""fake"" gencp_trans structure */
            gencp_trans = wmem_new(wmem_packet_scope(), gencp_transaction_t);
            gencp_trans->cmd_frame = 0;
            gencp_trans->ack_frame = 0;
            gencp_trans->cmd_time = pinfo->fd->abs_ts;
        }

        /* dissect depending on command? */
        switch (command_id) {
        case U3V_READMEM_CMD:
            dissect_u3v_read_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);
            break;
        case U3V_WRITEMEM_CMD:
            dissect_u3v_write_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);
            break;
        case U3V_EVENT_CMD:
            dissect_u3v_event_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length);
            break;
        case U3V_READMEM_ACK:
            if ( U3V_STATUS_GENCP_SUCCESS == status ) {
                dissect_u3v_read_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);
            }
            break;
        case U3V_WRITEMEM_ACK:
            dissect_u3v_write_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);
            break;
        case U3V_PENDING_ACK:
            dissect_u3v_pending_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);
            break;
        default:
            proto_tree_add_item(u3v_telegram_tree, hf_u3v_payloaddata, tvb, offset, data_length, ENC_NA);
            break;
        }
        return data_length + 12;
    } else if ( stream_detected ) {
        /* this is streaming data */

        /* init this stream configuration */
        u3v_conv_info = (u3v_conv_info_t *)usb_conv_info->class_data;
        u3v_conv_info->ep_stream = usb_conv_info->endpoint;

        /* Set the protocol column */
        col_set_str(pinfo->cinfo, COL_PROTOCOL, ""U3V"");

        /* Clear out stuff in the info column */
        col_clear(pinfo->cinfo, COL_INFO);

        /* Adds ""USB3Vision"" heading to protocol tree */
        /* We will add fields to this using the u3v_tree pointer */
        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);
        u3v_tree = proto_item_add_subtree(ti, ett_u3v);

        if(tvb_captured_length(tvb) >=4) {
            prefix = tvb_get_letohl(tvb, offset);
            switch (prefix) {
            case U3V_STREAM_LEADER_PREFIX:
                dissect_u3v_stream_leader(u3v_tree, tvb, pinfo, usb_conv_info);
                break;
            case U3V_STREAM_TRAILER_PREFIX:
                dissect_u3v_stream_trailer(u3v_tree, tvb, pinfo, usb_conv_info);
                break;
            default:
                dissect_u3v_stream_payload(u3v_tree, tvb, pinfo, usb_conv_info);
                break;
            }
        }
        return tvb_captured_length(tvb);
    }
    return 0;
}
","dissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
    gint offset = 0;
    proto_tree *u3v_tree = NULL, *ccd_tree_flag, *u3v_telegram_tree = NULL, *ccd_tree = NULL;
    gint data_length = 0;
    gint req_id = 0;
    gint command_id = -1;
    gint status = 0;
    guint prefix = 0;
    proto_item *ti = NULL;
    proto_item *item = NULL;
    const char *command_string;
    usb_conv_info_t *usb_conv_info;
    gint stream_detected = FALSE;
    gint control_detected = FALSE;
    u3v_conv_info_t *u3v_conv_info = NULL;
    gencp_transaction_t *gencp_trans = NULL;

    usb_conv_info = (usb_conv_info_t *)data;

    /* decide if this packet belongs to U3V protocol */
    u3v_conv_info = (u3v_conv_info_t *)usb_conv_info->class_data;

     if (!u3v_conv_info) {
         u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);
         usb_conv_info->class_data = u3v_conv_info;
     }
 
     prefix = tvb_get_letohl(tvb, 0);
    if ((tvb_reported_length(tvb) >= 4) && ( ( U3V_CONTROL_PREFIX == prefix ) || ( U3V_EVENT_PREFIX == prefix ) ) ) {
        control_detected = TRUE;
    }

    if (((tvb_reported_length(tvb) >= 4) && (( U3V_STREAM_LEADER_PREFIX == prefix ) || ( U3V_STREAM_TRAILER_PREFIX == prefix )))
         || (usb_conv_info->endpoint == u3v_conv_info->ep_stream)) {
        stream_detected = TRUE;
    }

    /* initialize interface class/subclass in case no descriptors have been dissected yet */
    if ( control_detected || stream_detected){
        if ( usb_conv_info->interfaceClass  == IF_CLASS_UNKNOWN &&
             usb_conv_info->interfaceSubclass  == IF_SUBCLASS_UNKNOWN){
            usb_conv_info->interfaceClass = IF_CLASS_MISCELLANEOUS;
            usb_conv_info->interfaceSubclass = IF_SUBCLASS_MISC_U3V;
        }
    }

    if ( control_detected ) {
        /* Set the protocol column */
        col_set_str(pinfo->cinfo, COL_PROTOCOL, ""U3V"");

        /* Clear out stuff in the info column */
        col_clear(pinfo->cinfo, COL_INFO);

        /* Adds ""USB3Vision"" heading to protocol tree */
        /* We will add fields to this using the u3v_tree pointer */
        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);
        u3v_tree = proto_item_add_subtree(ti, ett_u3v);

        prefix = tvb_get_letohl(tvb, offset);
        command_id = tvb_get_letohs(tvb, offset+6);

        /* decode CCD ( DCI/DCE command data layout) */
        if ((prefix == U3V_CONTROL_PREFIX || prefix == U3V_EVENT_PREFIX) && ((command_id % 2) == 0)) {
            command_string = val_to_str(command_id,command_names,""Unknown Command (0x%x)"");
            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_cmd, tvb, offset, 8, ENC_NA);
            proto_item_append_text(item, "": %s"", command_string);
            ccd_tree = proto_item_add_subtree(item, ett_u3v_cmd);

            /* Add the prefix code: */
            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;

            /* Add the flags */
            item = proto_tree_add_item(ccd_tree, hf_u3v_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            ccd_tree_flag  = proto_item_add_subtree(item, ett_u3v_flags);
            proto_tree_add_item(ccd_tree_flag, hf_u3v_acknowledge_required_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);

            offset += 2;
            col_append_fstr(pinfo->cinfo, COL_INFO, ""> %s "", command_string);
        } else if (prefix == U3V_CONTROL_PREFIX && ((command_id % 2) == 1)) {
            command_string = val_to_str(command_id,command_names,""Unknown Acknowledge (0x%x)"");
            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_ack, tvb, offset, 8, ENC_NA);
            proto_item_append_text(item, "": %s"", command_string);
            ccd_tree = proto_item_add_subtree(item, ett_u3v_ack);

            /* Add the prefix code: */
            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;

            /* Add the status: */
            proto_tree_add_item(ccd_tree, hf_u3v_status, tvb, offset, 2,ENC_LITTLE_ENDIAN);
            status = tvb_get_letohs(tvb, offset);
            offset += 2;
            col_append_fstr(pinfo->cinfo, COL_INFO, ""< %s %s"",
                    command_string,
                    val_to_str(status, status_names_short, ""Unknown status (0x%04X)""));
        } else {
            return 0;
        }

        /* Add the command id*/
        proto_tree_add_item(ccd_tree, hf_u3v_command_id, tvb, offset, 2,ENC_LITTLE_ENDIAN);
        offset += 2;

        /* Parse the second part of both the command and the acknowledge header:
        0          15 16         31
        -------- -------- -------- --------
        |     status      |   acknowledge   |
        -------- -------- -------- --------
        |     length      |      req_id     |
        -------- -------- -------- --------

        Add the data length
        Number of valid data bytes in this message, not including this header. This
        represents the number of bytes of payload appended after this header */

        proto_tree_add_item(ccd_tree, hf_u3v_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        data_length = tvb_get_letohs(tvb, offset);
        offset += 2;

        /* Add the request ID */
        proto_tree_add_item(ccd_tree, hf_u3v_request_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        req_id = tvb_get_letohs(tvb, offset);
        offset += 2;

        /* Add telegram subtree */
        u3v_telegram_tree = proto_item_add_subtree(u3v_tree, ett_u3v);

        if (!PINFO_FD_VISITED(pinfo)) {
              if ((command_id % 2) == 0) {
                    /* This is a command */
                    gencp_trans = wmem_new(wmem_file_scope(), gencp_transaction_t);
                    gencp_trans->cmd_frame = pinfo->fd->num;
                    gencp_trans->ack_frame = 0;
                    gencp_trans->cmd_time = pinfo->fd->abs_ts;
                    /* add reference to current packet */
                    p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);
                    /* add reference to current */
                    u3v_conv_info->trans_info = gencp_trans;
                } else {
                    gencp_trans = u3v_conv_info->trans_info;
                    if (gencp_trans) {
                        gencp_trans->ack_frame = pinfo->fd->num;
                        /* add reference to current packet */
                        p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);
                    }
                }
         } else {
            gencp_trans = (gencp_transaction_t*)p_get_proto_data(wmem_file_scope(),pinfo, proto_u3v, req_id);
         }

        if (!gencp_trans) {
            /* create a ""fake"" gencp_trans structure */
            gencp_trans = wmem_new(wmem_packet_scope(), gencp_transaction_t);
            gencp_trans->cmd_frame = 0;
            gencp_trans->ack_frame = 0;
            gencp_trans->cmd_time = pinfo->fd->abs_ts;
        }

        /* dissect depending on command? */
        switch (command_id) {
        case U3V_READMEM_CMD:
            dissect_u3v_read_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);
            break;
        case U3V_WRITEMEM_CMD:
            dissect_u3v_write_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);
            break;
        case U3V_EVENT_CMD:
            dissect_u3v_event_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length);
            break;
        case U3V_READMEM_ACK:
            if ( U3V_STATUS_GENCP_SUCCESS == status ) {
                dissect_u3v_read_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);
            }
            break;
        case U3V_WRITEMEM_ACK:
            dissect_u3v_write_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);
            break;
        case U3V_PENDING_ACK:
            dissect_u3v_pending_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);
            break;
        default:
            proto_tree_add_item(u3v_telegram_tree, hf_u3v_payloaddata, tvb, offset, data_length, ENC_NA);
            break;
        }
        return data_length + 12;
    } else if ( stream_detected ) {
        /* this is streaming data */

        /* init this stream configuration */
        u3v_conv_info = (u3v_conv_info_t *)usb_conv_info->class_data;
        u3v_conv_info->ep_stream = usb_conv_info->endpoint;

        /* Set the protocol column */
        col_set_str(pinfo->cinfo, COL_PROTOCOL, ""U3V"");

        /* Clear out stuff in the info column */
        col_clear(pinfo->cinfo, COL_INFO);

        /* Adds ""USB3Vision"" heading to protocol tree */
        /* We will add fields to this using the u3v_tree pointer */
        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);
        u3v_tree = proto_item_add_subtree(ti, ett_u3v);

        if(tvb_captured_length(tvb) >=4) {
            prefix = tvb_get_letohl(tvb, offset);
            switch (prefix) {
            case U3V_STREAM_LEADER_PREFIX:
                dissect_u3v_stream_leader(u3v_tree, tvb, pinfo, usb_conv_info);
                break;
            case U3V_STREAM_TRAILER_PREFIX:
                dissect_u3v_stream_trailer(u3v_tree, tvb, pinfo, usb_conv_info);
                break;
            default:
                dissect_u3v_stream_payload(u3v_tree, tvb, pinfo, usb_conv_info);
                break;
            }
        }
        return tvb_captured_length(tvb);
    }
    return 0;
}
",C,"        usb_conv_info->class_data_type = USB_CONV_U3V;
    } else if (usb_conv_info->class_data_type != USB_CONV_U3V) {
        /* Don't dissect if another USB type is in the conversation */
        return 0;
",,,"@@ -1683,6 +1683,10 @@ dissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
     if (!u3v_conv_info) {
         u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);
         usb_conv_info->class_data = u3v_conv_info;
+        usb_conv_info->class_data_type = USB_CONV_U3V;
+    } else if (usb_conv_info->class_data_type != USB_CONV_U3V) {
+        /* Don't dissect if another USB type is in the conversation */
+        return 0;
     }
 
     prefix = tvb_get_letohl(tvb, 0);",wireshark,2cb5985bf47bdc8bea78d28483ed224abdd33dc6,7c79da8c30e39aecb1cddab39f537d8f6a1da25f,1,"dissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
    gint offset = 0;
    proto_tree *u3v_tree = NULL, *ccd_tree_flag, *u3v_telegram_tree = NULL, *ccd_tree = NULL;
    gint data_length = 0;
    gint req_id = 0;
    gint command_id = -1;
    gint status = 0;
    guint prefix = 0;
    proto_item *ti = NULL;
    proto_item *item = NULL;
    const char *command_string;
    usb_conv_info_t *usb_conv_info;
    gint stream_detected = FALSE;
    gint control_detected = FALSE;
    u3v_conv_info_t *u3v_conv_info = NULL;
    gencp_transaction_t *gencp_trans = NULL;

    usb_conv_info = (usb_conv_info_t *)data;

    /* decide if this packet belongs to U3V protocol */
    u3v_conv_info = (u3v_conv_info_t *)usb_conv_info->class_data;

     if (!u3v_conv_info) {
         u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);
         usb_conv_info->class_data = u3v_conv_info;
//fix_flaw_line_below:
//        usb_conv_info->class_data_type = USB_CONV_U3V;
//fix_flaw_line_below:
//    } else if (usb_conv_info->class_data_type != USB_CONV_U3V) {
//fix_flaw_line_below:
//        /* Don't dissect if another USB type is in the conversation */
//fix_flaw_line_below:
//        return 0;
     }
 
     prefix = tvb_get_letohl(tvb, 0);
    if ((tvb_reported_length(tvb) >= 4) && ( ( U3V_CONTROL_PREFIX == prefix ) || ( U3V_EVENT_PREFIX == prefix ) ) ) {
        control_detected = TRUE;
    }

    if (((tvb_reported_length(tvb) >= 4) && (( U3V_STREAM_LEADER_PREFIX == prefix ) || ( U3V_STREAM_TRAILER_PREFIX == prefix )))
         || (usb_conv_info->endpoint == u3v_conv_info->ep_stream)) {
        stream_detected = TRUE;
    }

    /* initialize interface class/subclass in case no descriptors have been dissected yet */
    if ( control_detected || stream_detected){
        if ( usb_conv_info->interfaceClass  == IF_CLASS_UNKNOWN &&
             usb_conv_info->interfaceSubclass  == IF_SUBCLASS_UNKNOWN){
            usb_conv_info->interfaceClass = IF_CLASS_MISCELLANEOUS;
            usb_conv_info->interfaceSubclass = IF_SUBCLASS_MISC_U3V;
        }
    }

    if ( control_detected ) {
        /* Set the protocol column */
        col_set_str(pinfo->cinfo, COL_PROTOCOL, ""U3V"");

        /* Clear out stuff in the info column */
        col_clear(pinfo->cinfo, COL_INFO);

        /* Adds ""USB3Vision"" heading to protocol tree */
        /* We will add fields to this using the u3v_tree pointer */
        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);
        u3v_tree = proto_item_add_subtree(ti, ett_u3v);

        prefix = tvb_get_letohl(tvb, offset);
        command_id = tvb_get_letohs(tvb, offset+6);

        /* decode CCD ( DCI/DCE command data layout) */
        if ((prefix == U3V_CONTROL_PREFIX || prefix == U3V_EVENT_PREFIX) && ((command_id % 2) == 0)) {
            command_string = val_to_str(command_id,command_names,""Unknown Command (0x%x)"");
            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_cmd, tvb, offset, 8, ENC_NA);
            proto_item_append_text(item, "": %s"", command_string);
            ccd_tree = proto_item_add_subtree(item, ett_u3v_cmd);

            /* Add the prefix code: */
            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;

            /* Add the flags */
            item = proto_tree_add_item(ccd_tree, hf_u3v_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            ccd_tree_flag  = proto_item_add_subtree(item, ett_u3v_flags);
            proto_tree_add_item(ccd_tree_flag, hf_u3v_acknowledge_required_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);

            offset += 2;
            col_append_fstr(pinfo->cinfo, COL_INFO, ""> %s "", command_string);
        } else if (prefix == U3V_CONTROL_PREFIX && ((command_id % 2) == 1)) {
            command_string = val_to_str(command_id,command_names,""Unknown Acknowledge (0x%x)"");
            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_ack, tvb, offset, 8, ENC_NA);
            proto_item_append_text(item, "": %s"", command_string);
            ccd_tree = proto_item_add_subtree(item, ett_u3v_ack);

            /* Add the prefix code: */
            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;

            /* Add the status: */
            proto_tree_add_item(ccd_tree, hf_u3v_status, tvb, offset, 2,ENC_LITTLE_ENDIAN);
            status = tvb_get_letohs(tvb, offset);
            offset += 2;
            col_append_fstr(pinfo->cinfo, COL_INFO, ""< %s %s"",
                    command_string,
                    val_to_str(status, status_names_short, ""Unknown status (0x%04X)""));
        } else {
            return 0;
        }

        /* Add the command id*/
        proto_tree_add_item(ccd_tree, hf_u3v_command_id, tvb, offset, 2,ENC_LITTLE_ENDIAN);
        offset += 2;

        /* Parse the second part of both the command and the acknowledge header:
        0          15 16         31
        -------- -------- -------- --------
        |     status      |   acknowledge   |
        -------- -------- -------- --------
        |     length      |      req_id     |
        -------- -------- -------- --------

        Add the data length
        Number of valid data bytes in this message, not including this header. This
        represents the number of bytes of payload appended after this header */

        proto_tree_add_item(ccd_tree, hf_u3v_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        data_length = tvb_get_letohs(tvb, offset);
        offset += 2;

        /* Add the request ID */
        proto_tree_add_item(ccd_tree, hf_u3v_request_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        req_id = tvb_get_letohs(tvb, offset);
        offset += 2;

        /* Add telegram subtree */
        u3v_telegram_tree = proto_item_add_subtree(u3v_tree, ett_u3v);

        if (!PINFO_FD_VISITED(pinfo)) {
              if ((command_id % 2) == 0) {
                    /* This is a command */
                    gencp_trans = wmem_new(wmem_file_scope(), gencp_transaction_t);
                    gencp_trans->cmd_frame = pinfo->fd->num;
                    gencp_trans->ack_frame = 0;
                    gencp_trans->cmd_time = pinfo->fd->abs_ts;
                    /* add reference to current packet */
                    p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);
                    /* add reference to current */
                    u3v_conv_info->trans_info = gencp_trans;
                } else {
                    gencp_trans = u3v_conv_info->trans_info;
                    if (gencp_trans) {
                        gencp_trans->ack_frame = pinfo->fd->num;
                        /* add reference to current packet */
                        p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);
                    }
                }
         } else {
            gencp_trans = (gencp_transaction_t*)p_get_proto_data(wmem_file_scope(),pinfo, proto_u3v, req_id);
         }

        if (!gencp_trans) {
            /* create a ""fake"" gencp_trans structure */
            gencp_trans = wmem_new(wmem_packet_scope(), gencp_transaction_t);
            gencp_trans->cmd_frame = 0;
            gencp_trans->ack_frame = 0;
            gencp_trans->cmd_time = pinfo->fd->abs_ts;
        }

        /* dissect depending on command? */
        switch (command_id) {
        case U3V_READMEM_CMD:
            dissect_u3v_read_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);
            break;
        case U3V_WRITEMEM_CMD:
            dissect_u3v_write_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);
            break;
        case U3V_EVENT_CMD:
            dissect_u3v_event_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length);
            break;
        case U3V_READMEM_ACK:
            if ( U3V_STATUS_GENCP_SUCCESS == status ) {
                dissect_u3v_read_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);
            }
            break;
        case U3V_WRITEMEM_ACK:
            dissect_u3v_write_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);
            break;
        case U3V_PENDING_ACK:
            dissect_u3v_pending_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);
            break;
        default:
            proto_tree_add_item(u3v_telegram_tree, hf_u3v_payloaddata, tvb, offset, data_length, ENC_NA);
            break;
        }
        return data_length + 12;
    } else if ( stream_detected ) {
        /* this is streaming data */

        /* init this stream configuration */
        u3v_conv_info = (u3v_conv_info_t *)usb_conv_info->class_data;
        u3v_conv_info->ep_stream = usb_conv_info->endpoint;

        /* Set the protocol column */
        col_set_str(pinfo->cinfo, COL_PROTOCOL, ""U3V"");

        /* Clear out stuff in the info column */
        col_clear(pinfo->cinfo, COL_INFO);

        /* Adds ""USB3Vision"" heading to protocol tree */
        /* We will add fields to this using the u3v_tree pointer */
        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);
        u3v_tree = proto_item_add_subtree(ti, ett_u3v);

        if(tvb_captured_length(tvb) >=4) {
            prefix = tvb_get_letohl(tvb, offset);
            switch (prefix) {
            case U3V_STREAM_LEADER_PREFIX:
                dissect_u3v_stream_leader(u3v_tree, tvb, pinfo, usb_conv_info);
                break;
            case U3V_STREAM_TRAILER_PREFIX:
                dissect_u3v_stream_trailer(u3v_tree, tvb, pinfo, usb_conv_info);
                break;
            default:
                dissect_u3v_stream_payload(u3v_tree, tvb, pinfo, usb_conv_info);
                break;
            }
        }
        return tvb_captured_length(tvb);
    }
    return 0;
}
"
2589,180325,,Remote,Not required,Partial,CVE-2016-5354,https://www.cvedetails.com/cve/CVE-2016-5354/,CWE-476,Medium,,,,2016-08-07,4.3,"The USB subsystem in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles class types, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.",2016-11-28,DoS ,4,https://github.com/wireshark/wireshark/commit/2cb5985bf47bdc8bea78d28483ed224abdd33dc6,2cb5985bf47bdc8bea78d28483ed224abdd33dc6,"Make class ""type"" for USB conversations.

USB dissectors can't assume that only their class type has been passed around in the conversation.  Make explicit check that class type expected matches the dissector and stop/prevent dissection if there isn't a match.

Bug: 12356
Change-Id: Ib23973a4ebd0fbb51952ffc118daf95e3389a209
Reviewed-on: https://code.wireshark.org/review/15212
Petri-Dish: Michael Mann <mmann78@netscape.net>
Reviewed-by: Martin Kaiser <wireshark@kaiser.cx>
Petri-Dish: Martin Kaiser <wireshark@kaiser.cx>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Michael Mann <mmann78@netscape.net>",0,epan/dissectors/packet-usb-audio.c,"{""sha"": ""8e1a979eddce1cff46908cac8a0548793e61d396"", ""filename"": ""epan/dissectors/packet-u3v.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/wireshark/wireshark/blob/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-u3v.c"", ""raw_url"": ""https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-u3v.c"", ""contents_url"": ""https://api.github.com/repos/wireshark/wireshark/contents/epan/dissectors/packet-u3v.c?ref=2cb5985bf47bdc8bea78d28483ed224abdd33dc6"", ""patch"": ""@@ -1683,6 +1683,10 @@ dissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\n     if (!u3v_conv_info) {\n         u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);\n         usb_conv_info->class_data = u3v_conv_info;\n+        usb_conv_info->class_data_type = USB_CONV_U3V;\n+    } else if (usb_conv_info->class_data_type != USB_CONV_U3V) {\n+        /* Don't dissect if another USB type is in the conversation */\n+        return 0;\n     }\n \n     prefix = tvb_get_letohl(tvb, 0);""}<_**next**_>{""sha"": ""df6e9ef7dff96e86386eea8acd40f34c70854e1d"", ""filename"": ""epan/dissectors/packet-usb-audio.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/wireshark/wireshark/blob/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-audio.c"", ""raw_url"": ""https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-audio.c"", ""contents_url"": ""https://api.github.com/repos/wireshark/wireshark/contents/epan/dissectors/packet-usb-audio.c?ref=2cb5985bf47bdc8bea78d28483ed224abdd33dc6"", ""patch"": ""@@ -435,8 +435,12 @@ dissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n     if(!audio_conv_info) {\n         audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);\n         usb_conv_info->class_data = audio_conv_info;\n+        usb_conv_info->class_data_type = USB_CONV_AUDIO;\n         /* XXX - set reasonable default values for all components\n            that are not filled in by this function */\n+    } else if (usb_conv_info->class_data_type != USB_CONV_AUDIO) {\n+        /* Don't dissect if another USB type is in the conversation */\n+        return 0;\n     }\n     audio_conv_info->ver_major = ver_major;\n     offset += 2;""}<_**next**_>{""sha"": ""919f7ef36431aaa7b7e66bb108ceef710c6dfee4"", ""filename"": ""epan/dissectors/packet-usb-masstorage.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/wireshark/wireshark/blob/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-masstorage.c"", ""raw_url"": ""https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-masstorage.c"", ""contents_url"": ""https://api.github.com/repos/wireshark/wireshark/contents/epan/dissectors/packet-usb-masstorage.c?ref=2cb5985bf47bdc8bea78d28483ed224abdd33dc6"", ""patch"": ""@@ -199,9 +199,12 @@ dissect_usb_ms_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree,\n         usb_ms_conv_info->itl=wmem_tree_new(wmem_file_scope());\n         usb_ms_conv_info->itlq=wmem_tree_new(wmem_file_scope());\n         usb_conv_info->class_data=usb_ms_conv_info;\n+        usb_conv_info->class_data_type = USB_CONV_MASS_STORAGE;\n+    } else if (usb_conv_info->class_data_type != USB_CONV_MASS_STORAGE) {\n+        /* Don't dissect if another USB type is in the conversation */\n+        return 0;\n     }\n \n-\n     is_request=(pinfo->srcport==NO_ENDPOINT);\n \n     col_set_str(pinfo->cinfo, COL_PROTOCOL, \""USBMS\"");""}<_**next**_>{""sha"": ""3bf08f6156f34a3b268a04edfbf76b3cd495bf98"", ""filename"": ""epan/dissectors/packet-usb-video.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/wireshark/wireshark/blob/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-video.c"", ""raw_url"": ""https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-video.c"", ""contents_url"": ""https://api.github.com/repos/wireshark/wireshark/contents/epan/dissectors/packet-usb-video.c?ref=2cb5985bf47bdc8bea78d28483ed224abdd33dc6"", ""patch"": ""@@ -1035,6 +1035,10 @@ dissect_usb_video_control_interface_descriptor(proto_tree *parent_tree, tvbuff_t\n             video_conv_info = wmem_new(wmem_file_scope(), video_conv_info_t);\n             video_conv_info->entities = wmem_tree_new(wmem_file_scope());\n             usb_conv_info->class_data = video_conv_info;\n+            usb_conv_info->class_data_type = USB_CONV_VIDEO;\n+        } else if (usb_conv_info->class_data_type != USB_CONV_VIDEO) {\n+            /* Stop dissection if another USB type is in the conversation */\n+            return descriptor_len;\n         }\n \n         entity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);""}<_**next**_>{""sha"": ""261592db5d3ac44db535d2155b8934d1175701c9"", ""filename"": ""epan/dissectors/packet-usb.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/wireshark/wireshark/blob/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb.h"", ""raw_url"": ""https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb.h"", ""contents_url"": ""https://api.github.com/repos/wireshark/wireshark/contents/epan/dissectors/packet-usb.h?ref=2cb5985bf47bdc8bea78d28483ed224abdd33dc6"", ""patch"": ""@@ -90,6 +90,8 @@ typedef struct _usb_trans_info_t {\n     guint64 usb_id;\n } usb_trans_info_t;\n \n+enum usb_conv_class_data_type {USB_CONV_UNKNOWN = 0, USB_CONV_U3V, USB_CONV_AUDIO, USB_CONV_VIDEO, USB_CONV_MASS_STORAGE};\n+\n /* Conversation Structure\n  * there is one such structure for each device/endpoint conversation */\n struct _usb_conv_info_t {\n@@ -113,7 +115,8 @@ struct _usb_conv_info_t {\n     wmem_tree_t *transactions;\n     usb_trans_info_t *usb_trans_info; /* pointer to the current transaction */\n \n-    void *class_data;\t/* private class/id decode data */\n+    void *class_data;           /* private class/id decode data */\n+    enum usb_conv_class_data_type class_data_type;\n \n     wmem_array_t *alt_settings;\n };""}","dissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info)
{
    gint     offset_start;
    guint16  bcdADC;
    guint8   ver_major;
    double   ver;
    guint8   if_in_collection, i;
    audio_conv_info_t *audio_conv_info;


    offset_start = offset;

    bcdADC = tvb_get_letohs(tvb, offset);
    ver_major = USB_AUDIO_BCD44_TO_DEC(bcdADC>>8);
    ver = ver_major + USB_AUDIO_BCD44_TO_DEC(bcdADC&0xFF) / 100.0;

    proto_tree_add_double_format_value(tree, hf_ac_if_hdr_ver,
            tvb, offset, 2, ver, ""%2.2f"", ver);
    audio_conv_info = (audio_conv_info_t *)usb_conv_info->class_data;
     if(!audio_conv_info) {
         audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);
         usb_conv_info->class_data = audio_conv_info;
        usb_conv_info->class_data_type = USB_CONV_AUDIO;
         /* XXX - set reasonable default values for all components
            that are not filled in by this function */
    } else if (usb_conv_info->class_data_type != USB_CONV_AUDIO) {
        /* Don't dissect if another USB type is in the conversation */
        return 0;
     }
     audio_conv_info->ver_major = ver_major;
     offset += 2;

    /* version 1 refers to the Basic Audio Device specification,
       version 2 is the Audio Device class specification, see above */
    if (ver_major==1) {
        proto_tree_add_item(tree, hf_ac_if_hdr_total_len,
                tvb, offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;
        if_in_collection = tvb_get_guint8(tvb, offset);
        proto_tree_add_item(tree, hf_ac_if_hdr_bInCollection,
                tvb, offset, 1, ENC_LITTLE_ENDIAN);
        offset++;

        for (i=0; i<if_in_collection; i++) {
            proto_tree_add_item(tree, hf_ac_if_hdr_if_num,
                    tvb, offset, 1, ENC_LITTLE_ENDIAN);
            offset++;
        }
    }

    return offset-offset_start;
}
","dissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info)
{
    gint     offset_start;
    guint16  bcdADC;
    guint8   ver_major;
    double   ver;
    guint8   if_in_collection, i;
    audio_conv_info_t *audio_conv_info;


    offset_start = offset;

    bcdADC = tvb_get_letohs(tvb, offset);
    ver_major = USB_AUDIO_BCD44_TO_DEC(bcdADC>>8);
    ver = ver_major + USB_AUDIO_BCD44_TO_DEC(bcdADC&0xFF) / 100.0;

    proto_tree_add_double_format_value(tree, hf_ac_if_hdr_ver,
            tvb, offset, 2, ver, ""%2.2f"", ver);
    audio_conv_info = (audio_conv_info_t *)usb_conv_info->class_data;
     if(!audio_conv_info) {
         audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);
         usb_conv_info->class_data = audio_conv_info;
         /* XXX - set reasonable default values for all components
            that are not filled in by this function */
     }
     audio_conv_info->ver_major = ver_major;
     offset += 2;

    /* version 1 refers to the Basic Audio Device specification,
       version 2 is the Audio Device class specification, see above */
    if (ver_major==1) {
        proto_tree_add_item(tree, hf_ac_if_hdr_total_len,
                tvb, offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;
        if_in_collection = tvb_get_guint8(tvb, offset);
        proto_tree_add_item(tree, hf_ac_if_hdr_bInCollection,
                tvb, offset, 1, ENC_LITTLE_ENDIAN);
        offset++;

        for (i=0; i<if_in_collection; i++) {
            proto_tree_add_item(tree, hf_ac_if_hdr_if_num,
                    tvb, offset, 1, ENC_LITTLE_ENDIAN);
            offset++;
        }
    }

    return offset-offset_start;
}
",C,"        usb_conv_info->class_data_type = USB_CONV_AUDIO;
    } else if (usb_conv_info->class_data_type != USB_CONV_AUDIO) {
        /* Don't dissect if another USB type is in the conversation */
        return 0;
",,,"@@ -435,8 +435,12 @@ dissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,
     if(!audio_conv_info) {
         audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);
         usb_conv_info->class_data = audio_conv_info;
+        usb_conv_info->class_data_type = USB_CONV_AUDIO;
         /* XXX - set reasonable default values for all components
            that are not filled in by this function */
+    } else if (usb_conv_info->class_data_type != USB_CONV_AUDIO) {
+        /* Don't dissect if another USB type is in the conversation */
+        return 0;
     }
     audio_conv_info->ver_major = ver_major;
     offset += 2;",wireshark,2cb5985bf47bdc8bea78d28483ed224abdd33dc6,7c79da8c30e39aecb1cddab39f537d8f6a1da25f,1,"dissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info)
{
    gint     offset_start;
    guint16  bcdADC;
    guint8   ver_major;
    double   ver;
    guint8   if_in_collection, i;
    audio_conv_info_t *audio_conv_info;


    offset_start = offset;

    bcdADC = tvb_get_letohs(tvb, offset);
    ver_major = USB_AUDIO_BCD44_TO_DEC(bcdADC>>8);
    ver = ver_major + USB_AUDIO_BCD44_TO_DEC(bcdADC&0xFF) / 100.0;

    proto_tree_add_double_format_value(tree, hf_ac_if_hdr_ver,
            tvb, offset, 2, ver, ""%2.2f"", ver);
    audio_conv_info = (audio_conv_info_t *)usb_conv_info->class_data;
     if(!audio_conv_info) {
         audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);
         usb_conv_info->class_data = audio_conv_info;
//fix_flaw_line_below:
//        usb_conv_info->class_data_type = USB_CONV_AUDIO;
         /* XXX - set reasonable default values for all components
            that are not filled in by this function */
//fix_flaw_line_below:
//    } else if (usb_conv_info->class_data_type != USB_CONV_AUDIO) {
//fix_flaw_line_below:
//        /* Don't dissect if another USB type is in the conversation */
//fix_flaw_line_below:
//        return 0;
     }
     audio_conv_info->ver_major = ver_major;
     offset += 2;

    /* version 1 refers to the Basic Audio Device specification,
       version 2 is the Audio Device class specification, see above */
    if (ver_major==1) {
        proto_tree_add_item(tree, hf_ac_if_hdr_total_len,
                tvb, offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;
        if_in_collection = tvb_get_guint8(tvb, offset);
        proto_tree_add_item(tree, hf_ac_if_hdr_bInCollection,
                tvb, offset, 1, ENC_LITTLE_ENDIAN);
        offset++;

        for (i=0; i<if_in_collection; i++) {
            proto_tree_add_item(tree, hf_ac_if_hdr_if_num,
                    tvb, offset, 1, ENC_LITTLE_ENDIAN);
            offset++;
        }
    }

    return offset-offset_start;
}
"
2590,180326,,Remote,Not required,Partial,CVE-2016-5354,https://www.cvedetails.com/cve/CVE-2016-5354/,CWE-476,Medium,,,,2016-08-07,4.3,"The USB subsystem in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles class types, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.",2016-11-28,DoS ,4,https://github.com/wireshark/wireshark/commit/2cb5985bf47bdc8bea78d28483ed224abdd33dc6,2cb5985bf47bdc8bea78d28483ed224abdd33dc6,"Make class ""type"" for USB conversations.

USB dissectors can't assume that only their class type has been passed around in the conversation.  Make explicit check that class type expected matches the dissector and stop/prevent dissection if there isn't a match.

Bug: 12356
Change-Id: Ib23973a4ebd0fbb51952ffc118daf95e3389a209
Reviewed-on: https://code.wireshark.org/review/15212
Petri-Dish: Michael Mann <mmann78@netscape.net>
Reviewed-by: Martin Kaiser <wireshark@kaiser.cx>
Petri-Dish: Martin Kaiser <wireshark@kaiser.cx>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Michael Mann <mmann78@netscape.net>",0,epan/dissectors/packet-usb-masstorage.c,"{""sha"": ""8e1a979eddce1cff46908cac8a0548793e61d396"", ""filename"": ""epan/dissectors/packet-u3v.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/wireshark/wireshark/blob/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-u3v.c"", ""raw_url"": ""https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-u3v.c"", ""contents_url"": ""https://api.github.com/repos/wireshark/wireshark/contents/epan/dissectors/packet-u3v.c?ref=2cb5985bf47bdc8bea78d28483ed224abdd33dc6"", ""patch"": ""@@ -1683,6 +1683,10 @@ dissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\n     if (!u3v_conv_info) {\n         u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);\n         usb_conv_info->class_data = u3v_conv_info;\n+        usb_conv_info->class_data_type = USB_CONV_U3V;\n+    } else if (usb_conv_info->class_data_type != USB_CONV_U3V) {\n+        /* Don't dissect if another USB type is in the conversation */\n+        return 0;\n     }\n \n     prefix = tvb_get_letohl(tvb, 0);""}<_**next**_>{""sha"": ""df6e9ef7dff96e86386eea8acd40f34c70854e1d"", ""filename"": ""epan/dissectors/packet-usb-audio.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/wireshark/wireshark/blob/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-audio.c"", ""raw_url"": ""https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-audio.c"", ""contents_url"": ""https://api.github.com/repos/wireshark/wireshark/contents/epan/dissectors/packet-usb-audio.c?ref=2cb5985bf47bdc8bea78d28483ed224abdd33dc6"", ""patch"": ""@@ -435,8 +435,12 @@ dissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n     if(!audio_conv_info) {\n         audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);\n         usb_conv_info->class_data = audio_conv_info;\n+        usb_conv_info->class_data_type = USB_CONV_AUDIO;\n         /* XXX - set reasonable default values for all components\n            that are not filled in by this function */\n+    } else if (usb_conv_info->class_data_type != USB_CONV_AUDIO) {\n+        /* Don't dissect if another USB type is in the conversation */\n+        return 0;\n     }\n     audio_conv_info->ver_major = ver_major;\n     offset += 2;""}<_**next**_>{""sha"": ""919f7ef36431aaa7b7e66bb108ceef710c6dfee4"", ""filename"": ""epan/dissectors/packet-usb-masstorage.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/wireshark/wireshark/blob/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-masstorage.c"", ""raw_url"": ""https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-masstorage.c"", ""contents_url"": ""https://api.github.com/repos/wireshark/wireshark/contents/epan/dissectors/packet-usb-masstorage.c?ref=2cb5985bf47bdc8bea78d28483ed224abdd33dc6"", ""patch"": ""@@ -199,9 +199,12 @@ dissect_usb_ms_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree,\n         usb_ms_conv_info->itl=wmem_tree_new(wmem_file_scope());\n         usb_ms_conv_info->itlq=wmem_tree_new(wmem_file_scope());\n         usb_conv_info->class_data=usb_ms_conv_info;\n+        usb_conv_info->class_data_type = USB_CONV_MASS_STORAGE;\n+    } else if (usb_conv_info->class_data_type != USB_CONV_MASS_STORAGE) {\n+        /* Don't dissect if another USB type is in the conversation */\n+        return 0;\n     }\n \n-\n     is_request=(pinfo->srcport==NO_ENDPOINT);\n \n     col_set_str(pinfo->cinfo, COL_PROTOCOL, \""USBMS\"");""}<_**next**_>{""sha"": ""3bf08f6156f34a3b268a04edfbf76b3cd495bf98"", ""filename"": ""epan/dissectors/packet-usb-video.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/wireshark/wireshark/blob/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-video.c"", ""raw_url"": ""https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-video.c"", ""contents_url"": ""https://api.github.com/repos/wireshark/wireshark/contents/epan/dissectors/packet-usb-video.c?ref=2cb5985bf47bdc8bea78d28483ed224abdd33dc6"", ""patch"": ""@@ -1035,6 +1035,10 @@ dissect_usb_video_control_interface_descriptor(proto_tree *parent_tree, tvbuff_t\n             video_conv_info = wmem_new(wmem_file_scope(), video_conv_info_t);\n             video_conv_info->entities = wmem_tree_new(wmem_file_scope());\n             usb_conv_info->class_data = video_conv_info;\n+            usb_conv_info->class_data_type = USB_CONV_VIDEO;\n+        } else if (usb_conv_info->class_data_type != USB_CONV_VIDEO) {\n+            /* Stop dissection if another USB type is in the conversation */\n+            return descriptor_len;\n         }\n \n         entity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);""}<_**next**_>{""sha"": ""261592db5d3ac44db535d2155b8934d1175701c9"", ""filename"": ""epan/dissectors/packet-usb.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/wireshark/wireshark/blob/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb.h"", ""raw_url"": ""https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb.h"", ""contents_url"": ""https://api.github.com/repos/wireshark/wireshark/contents/epan/dissectors/packet-usb.h?ref=2cb5985bf47bdc8bea78d28483ed224abdd33dc6"", ""patch"": ""@@ -90,6 +90,8 @@ typedef struct _usb_trans_info_t {\n     guint64 usb_id;\n } usb_trans_info_t;\n \n+enum usb_conv_class_data_type {USB_CONV_UNKNOWN = 0, USB_CONV_U3V, USB_CONV_AUDIO, USB_CONV_VIDEO, USB_CONV_MASS_STORAGE};\n+\n /* Conversation Structure\n  * there is one such structure for each device/endpoint conversation */\n struct _usb_conv_info_t {\n@@ -113,7 +115,8 @@ struct _usb_conv_info_t {\n     wmem_tree_t *transactions;\n     usb_trans_info_t *usb_trans_info; /* pointer to the current transaction */\n \n-    void *class_data;\t/* private class/id decode data */\n+    void *class_data;           /* private class/id decode data */\n+    enum usb_conv_class_data_type class_data_type;\n \n     wmem_array_t *alt_settings;\n };""}","dissect_usb_ms_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data)
{
    usb_conv_info_t *usb_conv_info;
    usb_ms_conv_info_t *usb_ms_conv_info;
    proto_tree *tree;
    proto_item *ti;
    guint32 signature=0;
    int offset=0;
    gboolean is_request;
    itl_nexus_t *itl;
    itlq_nexus_t *itlq;

    /* Reject the packet if data is NULL */
    if (data == NULL)
        return 0;
    usb_conv_info = (usb_conv_info_t *)data;

    /* verify that we do have a usb_ms_conv_info */
    usb_ms_conv_info=(usb_ms_conv_info_t *)usb_conv_info->class_data;
    if(!usb_ms_conv_info){
        usb_ms_conv_info=wmem_new(wmem_file_scope(), usb_ms_conv_info_t);
         usb_ms_conv_info->itl=wmem_tree_new(wmem_file_scope());
         usb_ms_conv_info->itlq=wmem_tree_new(wmem_file_scope());
         usb_conv_info->class_data=usb_ms_conv_info;
        usb_conv_info->class_data_type = USB_CONV_MASS_STORAGE;
    } else if (usb_conv_info->class_data_type != USB_CONV_MASS_STORAGE) {
        /* Don't dissect if another USB type is in the conversation */
        return 0;
     }
 
     is_request=(pinfo->srcport==NO_ENDPOINT);
 
     col_set_str(pinfo->cinfo, COL_PROTOCOL, ""USBMS"");

    col_clear(pinfo->cinfo, COL_INFO);


    ti = proto_tree_add_protocol_format(parent_tree, proto_usb_ms, tvb, 0, -1, ""USB Mass Storage"");
    tree = proto_item_add_subtree(ti, ett_usb_ms);

    signature=tvb_get_letohl(tvb, offset);


    /*
     * SCSI CDB inside CBW
     */
    if(is_request&&(signature==0x43425355)&&(tvb_reported_length(tvb)==31)){
        tvbuff_t *cdb_tvb;
        int cdbrlen, cdblen;
        guint8 lun, flags;
        guint32 datalen;

        /* dCBWSignature */
        proto_tree_add_item(tree, hf_usb_ms_dCBWSignature, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset+=4;

        /* dCBWTag */
        proto_tree_add_item(tree, hf_usb_ms_dCBWTag, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset+=4;

        /* dCBWDataTransferLength */
        proto_tree_add_item(tree, hf_usb_ms_dCBWDataTransferLength, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        datalen=tvb_get_letohl(tvb, offset);
        offset+=4;

        /* dCBWFlags */
        proto_tree_add_item(tree, hf_usb_ms_dCBWFlags, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        flags=tvb_get_guint8(tvb, offset);
        offset+=1;

        /* dCBWLUN */
        proto_tree_add_item(tree, hf_usb_ms_dCBWTarget, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_ms_dCBWLUN, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        lun=tvb_get_guint8(tvb, offset)&0x0f;
        offset+=1;

        /* make sure we have a ITL structure for this LUN */
        itl=(itl_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itl, lun);
        if(!itl){
            itl=wmem_new(wmem_file_scope(), itl_nexus_t);
            itl->cmdset=0xff;
            itl->conversation=NULL;
            wmem_tree_insert32(usb_ms_conv_info->itl, lun, itl);
        }

        /* make sure we have an ITLQ structure for this LUN/transaction */
        itlq=(itlq_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itlq, pinfo->num);
        if(!itlq){
            itlq=wmem_new(wmem_file_scope(), itlq_nexus_t);
            itlq->lun=lun;
            itlq->scsi_opcode=0xffff;
            itlq->task_flags=0;
            if(datalen){
                if(flags&0x80){
                    itlq->task_flags|=SCSI_DATA_READ;
                } else {
                    itlq->task_flags|=SCSI_DATA_WRITE;
                }
            }
            itlq->data_length=datalen;
            itlq->bidir_data_length=0;
            itlq->fc_time=pinfo->abs_ts;
            itlq->first_exchange_frame=pinfo->num;
            itlq->last_exchange_frame=0;
            itlq->flags=0;
            itlq->alloc_len=0;
            itlq->extra_data=NULL;
            wmem_tree_insert32(usb_ms_conv_info->itlq, pinfo->num, itlq);
        }

        /* dCBWCBLength */
        proto_tree_add_item(tree, hf_usb_ms_dCBWCBLength, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        cdbrlen=tvb_get_guint8(tvb, offset)&0x1f;
        offset+=1;

        cdblen=cdbrlen;
        if(cdblen>tvb_captured_length_remaining(tvb, offset)){
            cdblen=tvb_captured_length_remaining(tvb, offset);
        }
        if(cdblen){
            cdb_tvb=tvb_new_subset(tvb, offset, cdblen, cdbrlen);
            dissect_scsi_cdb(cdb_tvb, pinfo, parent_tree, SCSI_DEV_UNKNOWN, itlq, itl);
        }
        return tvb_captured_length(tvb);
    }


    /*
     * SCSI RESPONSE inside CSW
     */
    if((!is_request)&&(signature==0x53425355)&&(tvb_reported_length(tvb)==13)){
        guint8 status;

        /* dCSWSignature */
        proto_tree_add_item(tree, hf_usb_ms_dCSWSignature, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset+=4;

        /* dCSWTag */
        proto_tree_add_item(tree, hf_usb_ms_dCBWTag, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset+=4;

        /* dCSWDataResidue */
        proto_tree_add_item(tree, hf_usb_ms_dCSWDataResidue, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset+=4;

        /* dCSWStatus */
        proto_tree_add_item(tree, hf_usb_ms_dCSWStatus, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        status=tvb_get_guint8(tvb, offset);
        /*offset+=1;*/

        itlq=(itlq_nexus_t *)wmem_tree_lookup32_le(usb_ms_conv_info->itlq, pinfo->num);
        if(!itlq){
            return tvb_captured_length(tvb);
        }
        itlq->last_exchange_frame=pinfo->num;

        itl=(itl_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itl, itlq->lun);
        if(!itl){
            return tvb_captured_length(tvb);
        }

        if(!status){
            dissect_scsi_rsp(tvb, pinfo, parent_tree, itlq, itl, 0);
        } else {
            /* just send ""check condition"" */
            dissect_scsi_rsp(tvb, pinfo, parent_tree, itlq, itl, 0x02);
        }
        return tvb_captured_length(tvb);
    }

    /*
     * Ok it was neither CDB not STATUS so just assume it is either data in/out
     */
    itlq=(itlq_nexus_t *)wmem_tree_lookup32_le(usb_ms_conv_info->itlq, pinfo->num);
    if(!itlq){
        return tvb_captured_length(tvb);
    }

    itl=(itl_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itl, itlq->lun);
    if(!itl){
        return tvb_captured_length(tvb);
    }

    dissect_scsi_payload(tvb, pinfo, parent_tree, is_request, itlq, itl, 0);
    return tvb_captured_length(tvb);
}
","dissect_usb_ms_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data)
{
    usb_conv_info_t *usb_conv_info;
    usb_ms_conv_info_t *usb_ms_conv_info;
    proto_tree *tree;
    proto_item *ti;
    guint32 signature=0;
    int offset=0;
    gboolean is_request;
    itl_nexus_t *itl;
    itlq_nexus_t *itlq;

    /* Reject the packet if data is NULL */
    if (data == NULL)
        return 0;
    usb_conv_info = (usb_conv_info_t *)data;

    /* verify that we do have a usb_ms_conv_info */
    usb_ms_conv_info=(usb_ms_conv_info_t *)usb_conv_info->class_data;
    if(!usb_ms_conv_info){
        usb_ms_conv_info=wmem_new(wmem_file_scope(), usb_ms_conv_info_t);
         usb_ms_conv_info->itl=wmem_tree_new(wmem_file_scope());
         usb_ms_conv_info->itlq=wmem_tree_new(wmem_file_scope());
         usb_conv_info->class_data=usb_ms_conv_info;
     }
 
     is_request=(pinfo->srcport==NO_ENDPOINT);
 
     col_set_str(pinfo->cinfo, COL_PROTOCOL, ""USBMS"");

    col_clear(pinfo->cinfo, COL_INFO);


    ti = proto_tree_add_protocol_format(parent_tree, proto_usb_ms, tvb, 0, -1, ""USB Mass Storage"");
    tree = proto_item_add_subtree(ti, ett_usb_ms);

    signature=tvb_get_letohl(tvb, offset);


    /*
     * SCSI CDB inside CBW
     */
    if(is_request&&(signature==0x43425355)&&(tvb_reported_length(tvb)==31)){
        tvbuff_t *cdb_tvb;
        int cdbrlen, cdblen;
        guint8 lun, flags;
        guint32 datalen;

        /* dCBWSignature */
        proto_tree_add_item(tree, hf_usb_ms_dCBWSignature, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset+=4;

        /* dCBWTag */
        proto_tree_add_item(tree, hf_usb_ms_dCBWTag, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset+=4;

        /* dCBWDataTransferLength */
        proto_tree_add_item(tree, hf_usb_ms_dCBWDataTransferLength, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        datalen=tvb_get_letohl(tvb, offset);
        offset+=4;

        /* dCBWFlags */
        proto_tree_add_item(tree, hf_usb_ms_dCBWFlags, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        flags=tvb_get_guint8(tvb, offset);
        offset+=1;

        /* dCBWLUN */
        proto_tree_add_item(tree, hf_usb_ms_dCBWTarget, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_ms_dCBWLUN, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        lun=tvb_get_guint8(tvb, offset)&0x0f;
        offset+=1;

        /* make sure we have a ITL structure for this LUN */
        itl=(itl_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itl, lun);
        if(!itl){
            itl=wmem_new(wmem_file_scope(), itl_nexus_t);
            itl->cmdset=0xff;
            itl->conversation=NULL;
            wmem_tree_insert32(usb_ms_conv_info->itl, lun, itl);
        }

        /* make sure we have an ITLQ structure for this LUN/transaction */
        itlq=(itlq_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itlq, pinfo->num);
        if(!itlq){
            itlq=wmem_new(wmem_file_scope(), itlq_nexus_t);
            itlq->lun=lun;
            itlq->scsi_opcode=0xffff;
            itlq->task_flags=0;
            if(datalen){
                if(flags&0x80){
                    itlq->task_flags|=SCSI_DATA_READ;
                } else {
                    itlq->task_flags|=SCSI_DATA_WRITE;
                }
            }
            itlq->data_length=datalen;
            itlq->bidir_data_length=0;
            itlq->fc_time=pinfo->abs_ts;
            itlq->first_exchange_frame=pinfo->num;
            itlq->last_exchange_frame=0;
            itlq->flags=0;
            itlq->alloc_len=0;
            itlq->extra_data=NULL;
            wmem_tree_insert32(usb_ms_conv_info->itlq, pinfo->num, itlq);
        }

        /* dCBWCBLength */
        proto_tree_add_item(tree, hf_usb_ms_dCBWCBLength, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        cdbrlen=tvb_get_guint8(tvb, offset)&0x1f;
        offset+=1;

        cdblen=cdbrlen;
        if(cdblen>tvb_captured_length_remaining(tvb, offset)){
            cdblen=tvb_captured_length_remaining(tvb, offset);
        }
        if(cdblen){
            cdb_tvb=tvb_new_subset(tvb, offset, cdblen, cdbrlen);
            dissect_scsi_cdb(cdb_tvb, pinfo, parent_tree, SCSI_DEV_UNKNOWN, itlq, itl);
        }
        return tvb_captured_length(tvb);
    }


    /*
     * SCSI RESPONSE inside CSW
     */
    if((!is_request)&&(signature==0x53425355)&&(tvb_reported_length(tvb)==13)){
        guint8 status;

        /* dCSWSignature */
        proto_tree_add_item(tree, hf_usb_ms_dCSWSignature, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset+=4;

        /* dCSWTag */
        proto_tree_add_item(tree, hf_usb_ms_dCBWTag, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset+=4;

        /* dCSWDataResidue */
        proto_tree_add_item(tree, hf_usb_ms_dCSWDataResidue, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset+=4;

        /* dCSWStatus */
        proto_tree_add_item(tree, hf_usb_ms_dCSWStatus, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        status=tvb_get_guint8(tvb, offset);
        /*offset+=1;*/

        itlq=(itlq_nexus_t *)wmem_tree_lookup32_le(usb_ms_conv_info->itlq, pinfo->num);
        if(!itlq){
            return tvb_captured_length(tvb);
        }
        itlq->last_exchange_frame=pinfo->num;

        itl=(itl_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itl, itlq->lun);
        if(!itl){
            return tvb_captured_length(tvb);
        }

        if(!status){
            dissect_scsi_rsp(tvb, pinfo, parent_tree, itlq, itl, 0);
        } else {
            /* just send ""check condition"" */
            dissect_scsi_rsp(tvb, pinfo, parent_tree, itlq, itl, 0x02);
        }
        return tvb_captured_length(tvb);
    }

    /*
     * Ok it was neither CDB not STATUS so just assume it is either data in/out
     */
    itlq=(itlq_nexus_t *)wmem_tree_lookup32_le(usb_ms_conv_info->itlq, pinfo->num);
    if(!itlq){
        return tvb_captured_length(tvb);
    }

    itl=(itl_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itl, itlq->lun);
    if(!itl){
        return tvb_captured_length(tvb);
    }

    dissect_scsi_payload(tvb, pinfo, parent_tree, is_request, itlq, itl, 0);
    return tvb_captured_length(tvb);
}
",C,"        usb_conv_info->class_data_type = USB_CONV_MASS_STORAGE;
    } else if (usb_conv_info->class_data_type != USB_CONV_MASS_STORAGE) {
        /* Don't dissect if another USB type is in the conversation */
        return 0;
",,,"@@ -199,9 +199,12 @@ dissect_usb_ms_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree,
         usb_ms_conv_info->itl=wmem_tree_new(wmem_file_scope());
         usb_ms_conv_info->itlq=wmem_tree_new(wmem_file_scope());
         usb_conv_info->class_data=usb_ms_conv_info;
+        usb_conv_info->class_data_type = USB_CONV_MASS_STORAGE;
+    } else if (usb_conv_info->class_data_type != USB_CONV_MASS_STORAGE) {
+        /* Don't dissect if another USB type is in the conversation */
+        return 0;
     }
 
-
     is_request=(pinfo->srcport==NO_ENDPOINT);
 
     col_set_str(pinfo->cinfo, COL_PROTOCOL, ""USBMS"");",wireshark,2cb5985bf47bdc8bea78d28483ed224abdd33dc6,7c79da8c30e39aecb1cddab39f537d8f6a1da25f,1,"dissect_usb_ms_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data)
{
    usb_conv_info_t *usb_conv_info;
    usb_ms_conv_info_t *usb_ms_conv_info;
    proto_tree *tree;
    proto_item *ti;
    guint32 signature=0;
    int offset=0;
    gboolean is_request;
    itl_nexus_t *itl;
    itlq_nexus_t *itlq;

    /* Reject the packet if data is NULL */
    if (data == NULL)
        return 0;
    usb_conv_info = (usb_conv_info_t *)data;

    /* verify that we do have a usb_ms_conv_info */
    usb_ms_conv_info=(usb_ms_conv_info_t *)usb_conv_info->class_data;
    if(!usb_ms_conv_info){
        usb_ms_conv_info=wmem_new(wmem_file_scope(), usb_ms_conv_info_t);
         usb_ms_conv_info->itl=wmem_tree_new(wmem_file_scope());
         usb_ms_conv_info->itlq=wmem_tree_new(wmem_file_scope());
         usb_conv_info->class_data=usb_ms_conv_info;
//fix_flaw_line_below:
//        usb_conv_info->class_data_type = USB_CONV_MASS_STORAGE;
//fix_flaw_line_below:
//    } else if (usb_conv_info->class_data_type != USB_CONV_MASS_STORAGE) {
//fix_flaw_line_below:
//        /* Don't dissect if another USB type is in the conversation */
//fix_flaw_line_below:
//        return 0;
     }
 
//flaw_line_below:

     is_request=(pinfo->srcport==NO_ENDPOINT);
 
     col_set_str(pinfo->cinfo, COL_PROTOCOL, ""USBMS"");

    col_clear(pinfo->cinfo, COL_INFO);


    ti = proto_tree_add_protocol_format(parent_tree, proto_usb_ms, tvb, 0, -1, ""USB Mass Storage"");
    tree = proto_item_add_subtree(ti, ett_usb_ms);

    signature=tvb_get_letohl(tvb, offset);


    /*
     * SCSI CDB inside CBW
     */
    if(is_request&&(signature==0x43425355)&&(tvb_reported_length(tvb)==31)){
        tvbuff_t *cdb_tvb;
        int cdbrlen, cdblen;
        guint8 lun, flags;
        guint32 datalen;

        /* dCBWSignature */
        proto_tree_add_item(tree, hf_usb_ms_dCBWSignature, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset+=4;

        /* dCBWTag */
        proto_tree_add_item(tree, hf_usb_ms_dCBWTag, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset+=4;

        /* dCBWDataTransferLength */
        proto_tree_add_item(tree, hf_usb_ms_dCBWDataTransferLength, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        datalen=tvb_get_letohl(tvb, offset);
        offset+=4;

        /* dCBWFlags */
        proto_tree_add_item(tree, hf_usb_ms_dCBWFlags, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        flags=tvb_get_guint8(tvb, offset);
        offset+=1;

        /* dCBWLUN */
        proto_tree_add_item(tree, hf_usb_ms_dCBWTarget, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_ms_dCBWLUN, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        lun=tvb_get_guint8(tvb, offset)&0x0f;
        offset+=1;

        /* make sure we have a ITL structure for this LUN */
        itl=(itl_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itl, lun);
        if(!itl){
            itl=wmem_new(wmem_file_scope(), itl_nexus_t);
            itl->cmdset=0xff;
            itl->conversation=NULL;
            wmem_tree_insert32(usb_ms_conv_info->itl, lun, itl);
        }

        /* make sure we have an ITLQ structure for this LUN/transaction */
        itlq=(itlq_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itlq, pinfo->num);
        if(!itlq){
            itlq=wmem_new(wmem_file_scope(), itlq_nexus_t);
            itlq->lun=lun;
            itlq->scsi_opcode=0xffff;
            itlq->task_flags=0;
            if(datalen){
                if(flags&0x80){
                    itlq->task_flags|=SCSI_DATA_READ;
                } else {
                    itlq->task_flags|=SCSI_DATA_WRITE;
                }
            }
            itlq->data_length=datalen;
            itlq->bidir_data_length=0;
            itlq->fc_time=pinfo->abs_ts;
            itlq->first_exchange_frame=pinfo->num;
            itlq->last_exchange_frame=0;
            itlq->flags=0;
            itlq->alloc_len=0;
            itlq->extra_data=NULL;
            wmem_tree_insert32(usb_ms_conv_info->itlq, pinfo->num, itlq);
        }

        /* dCBWCBLength */
        proto_tree_add_item(tree, hf_usb_ms_dCBWCBLength, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        cdbrlen=tvb_get_guint8(tvb, offset)&0x1f;
        offset+=1;

        cdblen=cdbrlen;
        if(cdblen>tvb_captured_length_remaining(tvb, offset)){
            cdblen=tvb_captured_length_remaining(tvb, offset);
        }
        if(cdblen){
            cdb_tvb=tvb_new_subset(tvb, offset, cdblen, cdbrlen);
            dissect_scsi_cdb(cdb_tvb, pinfo, parent_tree, SCSI_DEV_UNKNOWN, itlq, itl);
        }
        return tvb_captured_length(tvb);
    }


    /*
     * SCSI RESPONSE inside CSW
     */
    if((!is_request)&&(signature==0x53425355)&&(tvb_reported_length(tvb)==13)){
        guint8 status;

        /* dCSWSignature */
        proto_tree_add_item(tree, hf_usb_ms_dCSWSignature, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset+=4;

        /* dCSWTag */
        proto_tree_add_item(tree, hf_usb_ms_dCBWTag, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset+=4;

        /* dCSWDataResidue */
        proto_tree_add_item(tree, hf_usb_ms_dCSWDataResidue, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset+=4;

        /* dCSWStatus */
        proto_tree_add_item(tree, hf_usb_ms_dCSWStatus, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        status=tvb_get_guint8(tvb, offset);
        /*offset+=1;*/

        itlq=(itlq_nexus_t *)wmem_tree_lookup32_le(usb_ms_conv_info->itlq, pinfo->num);
        if(!itlq){
            return tvb_captured_length(tvb);
        }
        itlq->last_exchange_frame=pinfo->num;

        itl=(itl_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itl, itlq->lun);
        if(!itl){
            return tvb_captured_length(tvb);
        }

        if(!status){
            dissect_scsi_rsp(tvb, pinfo, parent_tree, itlq, itl, 0);
        } else {
            /* just send ""check condition"" */
            dissect_scsi_rsp(tvb, pinfo, parent_tree, itlq, itl, 0x02);
        }
        return tvb_captured_length(tvb);
    }

    /*
     * Ok it was neither CDB not STATUS so just assume it is either data in/out
     */
    itlq=(itlq_nexus_t *)wmem_tree_lookup32_le(usb_ms_conv_info->itlq, pinfo->num);
    if(!itlq){
        return tvb_captured_length(tvb);
    }

    itl=(itl_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itl, itlq->lun);
    if(!itl){
        return tvb_captured_length(tvb);
    }

    dissect_scsi_payload(tvb, pinfo, parent_tree, is_request, itlq, itl, 0);
    return tvb_captured_length(tvb);
}
"
2591,180327,,Remote,Not required,Partial,CVE-2016-5354,https://www.cvedetails.com/cve/CVE-2016-5354/,CWE-476,Medium,,,,2016-08-07,4.3,"The USB subsystem in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles class types, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.",2016-11-28,DoS ,4,https://github.com/wireshark/wireshark/commit/2cb5985bf47bdc8bea78d28483ed224abdd33dc6,2cb5985bf47bdc8bea78d28483ed224abdd33dc6,"Make class ""type"" for USB conversations.

USB dissectors can't assume that only their class type has been passed around in the conversation.  Make explicit check that class type expected matches the dissector and stop/prevent dissection if there isn't a match.

Bug: 12356
Change-Id: Ib23973a4ebd0fbb51952ffc118daf95e3389a209
Reviewed-on: https://code.wireshark.org/review/15212
Petri-Dish: Michael Mann <mmann78@netscape.net>
Reviewed-by: Martin Kaiser <wireshark@kaiser.cx>
Petri-Dish: Martin Kaiser <wireshark@kaiser.cx>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Michael Mann <mmann78@netscape.net>",0,epan/dissectors/packet-usb-video.c,"{""sha"": ""8e1a979eddce1cff46908cac8a0548793e61d396"", ""filename"": ""epan/dissectors/packet-u3v.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/wireshark/wireshark/blob/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-u3v.c"", ""raw_url"": ""https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-u3v.c"", ""contents_url"": ""https://api.github.com/repos/wireshark/wireshark/contents/epan/dissectors/packet-u3v.c?ref=2cb5985bf47bdc8bea78d28483ed224abdd33dc6"", ""patch"": ""@@ -1683,6 +1683,10 @@ dissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\n     if (!u3v_conv_info) {\n         u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);\n         usb_conv_info->class_data = u3v_conv_info;\n+        usb_conv_info->class_data_type = USB_CONV_U3V;\n+    } else if (usb_conv_info->class_data_type != USB_CONV_U3V) {\n+        /* Don't dissect if another USB type is in the conversation */\n+        return 0;\n     }\n \n     prefix = tvb_get_letohl(tvb, 0);""}<_**next**_>{""sha"": ""df6e9ef7dff96e86386eea8acd40f34c70854e1d"", ""filename"": ""epan/dissectors/packet-usb-audio.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/wireshark/wireshark/blob/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-audio.c"", ""raw_url"": ""https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-audio.c"", ""contents_url"": ""https://api.github.com/repos/wireshark/wireshark/contents/epan/dissectors/packet-usb-audio.c?ref=2cb5985bf47bdc8bea78d28483ed224abdd33dc6"", ""patch"": ""@@ -435,8 +435,12 @@ dissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n     if(!audio_conv_info) {\n         audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);\n         usb_conv_info->class_data = audio_conv_info;\n+        usb_conv_info->class_data_type = USB_CONV_AUDIO;\n         /* XXX - set reasonable default values for all components\n            that are not filled in by this function */\n+    } else if (usb_conv_info->class_data_type != USB_CONV_AUDIO) {\n+        /* Don't dissect if another USB type is in the conversation */\n+        return 0;\n     }\n     audio_conv_info->ver_major = ver_major;\n     offset += 2;""}<_**next**_>{""sha"": ""919f7ef36431aaa7b7e66bb108ceef710c6dfee4"", ""filename"": ""epan/dissectors/packet-usb-masstorage.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/wireshark/wireshark/blob/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-masstorage.c"", ""raw_url"": ""https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-masstorage.c"", ""contents_url"": ""https://api.github.com/repos/wireshark/wireshark/contents/epan/dissectors/packet-usb-masstorage.c?ref=2cb5985bf47bdc8bea78d28483ed224abdd33dc6"", ""patch"": ""@@ -199,9 +199,12 @@ dissect_usb_ms_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree,\n         usb_ms_conv_info->itl=wmem_tree_new(wmem_file_scope());\n         usb_ms_conv_info->itlq=wmem_tree_new(wmem_file_scope());\n         usb_conv_info->class_data=usb_ms_conv_info;\n+        usb_conv_info->class_data_type = USB_CONV_MASS_STORAGE;\n+    } else if (usb_conv_info->class_data_type != USB_CONV_MASS_STORAGE) {\n+        /* Don't dissect if another USB type is in the conversation */\n+        return 0;\n     }\n \n-\n     is_request=(pinfo->srcport==NO_ENDPOINT);\n \n     col_set_str(pinfo->cinfo, COL_PROTOCOL, \""USBMS\"");""}<_**next**_>{""sha"": ""3bf08f6156f34a3b268a04edfbf76b3cd495bf98"", ""filename"": ""epan/dissectors/packet-usb-video.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/wireshark/wireshark/blob/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-video.c"", ""raw_url"": ""https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb-video.c"", ""contents_url"": ""https://api.github.com/repos/wireshark/wireshark/contents/epan/dissectors/packet-usb-video.c?ref=2cb5985bf47bdc8bea78d28483ed224abdd33dc6"", ""patch"": ""@@ -1035,6 +1035,10 @@ dissect_usb_video_control_interface_descriptor(proto_tree *parent_tree, tvbuff_t\n             video_conv_info = wmem_new(wmem_file_scope(), video_conv_info_t);\n             video_conv_info->entities = wmem_tree_new(wmem_file_scope());\n             usb_conv_info->class_data = video_conv_info;\n+            usb_conv_info->class_data_type = USB_CONV_VIDEO;\n+        } else if (usb_conv_info->class_data_type != USB_CONV_VIDEO) {\n+            /* Stop dissection if another USB type is in the conversation */\n+            return descriptor_len;\n         }\n \n         entity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);""}<_**next**_>{""sha"": ""261592db5d3ac44db535d2155b8934d1175701c9"", ""filename"": ""epan/dissectors/packet-usb.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/wireshark/wireshark/blob/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb.h"", ""raw_url"": ""https://github.com/wireshark/wireshark/raw/2cb5985bf47bdc8bea78d28483ed224abdd33dc6/epan/dissectors/packet-usb.h"", ""contents_url"": ""https://api.github.com/repos/wireshark/wireshark/contents/epan/dissectors/packet-usb.h?ref=2cb5985bf47bdc8bea78d28483ed224abdd33dc6"", ""patch"": ""@@ -90,6 +90,8 @@ typedef struct _usb_trans_info_t {\n     guint64 usb_id;\n } usb_trans_info_t;\n \n+enum usb_conv_class_data_type {USB_CONV_UNKNOWN = 0, USB_CONV_U3V, USB_CONV_AUDIO, USB_CONV_VIDEO, USB_CONV_MASS_STORAGE};\n+\n /* Conversation Structure\n  * there is one such structure for each device/endpoint conversation */\n struct _usb_conv_info_t {\n@@ -113,7 +115,8 @@ struct _usb_conv_info_t {\n     wmem_tree_t *transactions;\n     usb_trans_info_t *usb_trans_info; /* pointer to the current transaction */\n \n-    void *class_data;\t/* private class/id decode data */\n+    void *class_data;           /* private class/id decode data */\n+    enum usb_conv_class_data_type class_data_type;\n \n     wmem_array_t *alt_settings;\n };""}","dissect_usb_video_control_interface_descriptor(proto_tree *parent_tree, tvbuff_t *tvb,
                                               guint8 descriptor_len, packet_info *pinfo, usb_conv_info_t *usb_conv_info)
{
    video_conv_info_t *video_conv_info = NULL;
    video_entity_t    *entity          = NULL;
    proto_item *item          = NULL;
    proto_item *subtype_item  = NULL;
    proto_tree *tree          = NULL;
    guint8      entity_id     = 0;
    guint16     terminal_type = 0;
    int         offset        = 0;
    guint8      subtype;

    subtype = tvb_get_guint8(tvb, offset+2);

    if (parent_tree)
    {
        const gchar *subtype_str;

        subtype_str = val_to_str_ext(subtype, &vc_if_descriptor_subtypes_ext, ""Unknown (0x%x)"");

        tree = proto_tree_add_subtree_format(parent_tree, tvb, offset, descriptor_len,
                                   ett_descriptor_video_control, &item, ""VIDEO CONTROL INTERFACE DESCRIPTOR [%s]"",
                                   subtype_str);
    }

    /* Common fields */
    dissect_usb_descriptor_header(tree, tvb, offset, &vid_descriptor_type_vals_ext);
    subtype_item = proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_subtype, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);
    offset += 3;

    if (subtype == VC_HEADER)
    {
        guint8 num_vs_interfaces;

        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bcdUVC,            tvb, offset,   2, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_vid_ifdesc_wTotalLength,              tvb, offset+2, 2, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_dwClockFrequency,  tvb, offset+4, 4, ENC_LITTLE_ENDIAN);

        num_vs_interfaces = tvb_get_guint8(tvb, offset+8);
        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bInCollection,     tvb, offset+8, 1, ENC_LITTLE_ENDIAN);

        if (num_vs_interfaces > 0)
        {
            proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_baInterfaceNr, tvb, offset+9, num_vs_interfaces, ENC_NA);
        }

        offset += 9 + num_vs_interfaces;
    }
    else if ((subtype == VC_INPUT_TERMINAL) || (subtype == VC_OUTPUT_TERMINAL))
    {
        /* Fields common to input and output terminals */
        entity_id     = tvb_get_guint8(tvb, offset);
        terminal_type = tvb_get_letohs(tvb, offset+1);

        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_id,    tvb, offset,   1, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_type,  tvb, offset+1, 2, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_assoc_terminal, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);
        offset += 4;

        if (subtype == VC_OUTPUT_TERMINAL)
        {
            proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_src_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);
            ++offset;
        }

        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_iTerminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        ++offset;

        if (subtype == VC_INPUT_TERMINAL)
        {
            if (terminal_type == ITT_CAMERA)
            {
                offset = dissect_usb_video_camera_terminal(tree, tvb, offset);
            }
            else if (terminal_type == ITT_MEDIA_TRANSPORT_INPUT)
            {
                /* @todo */
            }
        }

        if (subtype == VC_OUTPUT_TERMINAL)
        {
            if (terminal_type == OTT_MEDIA_TRANSPORT_OUTPUT)
            {
                /* @todo */
            }
        }
    }
    else
    {
        /* Field common to extension / processing / selector / encoding units */
        entity_id = tvb_get_guint8(tvb, offset);
        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_unit_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        ++offset;

        if (subtype == VC_PROCESSING_UNIT)
        {
            offset = dissect_usb_video_processing_unit(tree, tvb, offset);
        }
        else if (subtype == VC_SELECTOR_UNIT)
        {
            offset = dissect_usb_video_selector_unit(tree, tvb, offset);
        }
        else if (subtype == VC_EXTENSION_UNIT)
        {
            offset = dissect_usb_video_extension_unit(tree, tvb, offset);
        }
        else if (subtype == VC_ENCODING_UNIT)
        {
            /* @todo UVC 1.5 */
        }
        else
        {
            expert_add_info_format(pinfo, subtype_item, &ei_usb_vid_subtype_unknown,
                                   ""Unknown VC subtype %u"", subtype);
        }
    }

    /* Soak up descriptor bytes beyond those we know how to dissect */
    if (offset < descriptor_len)
    {
        proto_tree_add_item(tree, hf_usb_vid_descriptor_data, tvb, offset, descriptor_len-offset, ENC_NA);
        /* offset = descriptor_len; */
    }

    if (entity_id != 0)
        proto_item_append_text(item, "" (Entity %d)"", entity_id);

    if (subtype != VC_HEADER && usb_conv_info)
    {
        /* Switch to the usb_conv_info of the Video Control interface */
        usb_conv_info = get_usb_iface_conv_info(pinfo, usb_conv_info->interfaceNum);
        video_conv_info = (video_conv_info_t *)usb_conv_info->class_data;

        if (!video_conv_info)
        {
             video_conv_info = wmem_new(wmem_file_scope(), video_conv_info_t);
             video_conv_info->entities = wmem_tree_new(wmem_file_scope());
             usb_conv_info->class_data = video_conv_info;
            usb_conv_info->class_data_type = USB_CONV_VIDEO;
        } else if (usb_conv_info->class_data_type != USB_CONV_VIDEO) {
            /* Stop dissection if another USB type is in the conversation */
            return descriptor_len;
         }
 
         entity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);
        if (!entity)
        {
            entity = wmem_new(wmem_file_scope(), video_entity_t);
            entity->entityID     = entity_id;
            entity->subtype      = subtype;
            entity->terminalType = terminal_type;

            wmem_tree_insert32(video_conv_info->entities, entity_id, entity);
        }
    }

    return descriptor_len;
}
","dissect_usb_video_control_interface_descriptor(proto_tree *parent_tree, tvbuff_t *tvb,
                                               guint8 descriptor_len, packet_info *pinfo, usb_conv_info_t *usb_conv_info)
{
    video_conv_info_t *video_conv_info = NULL;
    video_entity_t    *entity          = NULL;
    proto_item *item          = NULL;
    proto_item *subtype_item  = NULL;
    proto_tree *tree          = NULL;
    guint8      entity_id     = 0;
    guint16     terminal_type = 0;
    int         offset        = 0;
    guint8      subtype;

    subtype = tvb_get_guint8(tvb, offset+2);

    if (parent_tree)
    {
        const gchar *subtype_str;

        subtype_str = val_to_str_ext(subtype, &vc_if_descriptor_subtypes_ext, ""Unknown (0x%x)"");

        tree = proto_tree_add_subtree_format(parent_tree, tvb, offset, descriptor_len,
                                   ett_descriptor_video_control, &item, ""VIDEO CONTROL INTERFACE DESCRIPTOR [%s]"",
                                   subtype_str);
    }

    /* Common fields */
    dissect_usb_descriptor_header(tree, tvb, offset, &vid_descriptor_type_vals_ext);
    subtype_item = proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_subtype, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);
    offset += 3;

    if (subtype == VC_HEADER)
    {
        guint8 num_vs_interfaces;

        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bcdUVC,            tvb, offset,   2, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_vid_ifdesc_wTotalLength,              tvb, offset+2, 2, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_dwClockFrequency,  tvb, offset+4, 4, ENC_LITTLE_ENDIAN);

        num_vs_interfaces = tvb_get_guint8(tvb, offset+8);
        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bInCollection,     tvb, offset+8, 1, ENC_LITTLE_ENDIAN);

        if (num_vs_interfaces > 0)
        {
            proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_baInterfaceNr, tvb, offset+9, num_vs_interfaces, ENC_NA);
        }

        offset += 9 + num_vs_interfaces;
    }
    else if ((subtype == VC_INPUT_TERMINAL) || (subtype == VC_OUTPUT_TERMINAL))
    {
        /* Fields common to input and output terminals */
        entity_id     = tvb_get_guint8(tvb, offset);
        terminal_type = tvb_get_letohs(tvb, offset+1);

        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_id,    tvb, offset,   1, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_type,  tvb, offset+1, 2, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_assoc_terminal, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);
        offset += 4;

        if (subtype == VC_OUTPUT_TERMINAL)
        {
            proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_src_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);
            ++offset;
        }

        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_iTerminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        ++offset;

        if (subtype == VC_INPUT_TERMINAL)
        {
            if (terminal_type == ITT_CAMERA)
            {
                offset = dissect_usb_video_camera_terminal(tree, tvb, offset);
            }
            else if (terminal_type == ITT_MEDIA_TRANSPORT_INPUT)
            {
                /* @todo */
            }
        }

        if (subtype == VC_OUTPUT_TERMINAL)
        {
            if (terminal_type == OTT_MEDIA_TRANSPORT_OUTPUT)
            {
                /* @todo */
            }
        }
    }
    else
    {
        /* Field common to extension / processing / selector / encoding units */
        entity_id = tvb_get_guint8(tvb, offset);
        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_unit_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        ++offset;

        if (subtype == VC_PROCESSING_UNIT)
        {
            offset = dissect_usb_video_processing_unit(tree, tvb, offset);
        }
        else if (subtype == VC_SELECTOR_UNIT)
        {
            offset = dissect_usb_video_selector_unit(tree, tvb, offset);
        }
        else if (subtype == VC_EXTENSION_UNIT)
        {
            offset = dissect_usb_video_extension_unit(tree, tvb, offset);
        }
        else if (subtype == VC_ENCODING_UNIT)
        {
            /* @todo UVC 1.5 */
        }
        else
        {
            expert_add_info_format(pinfo, subtype_item, &ei_usb_vid_subtype_unknown,
                                   ""Unknown VC subtype %u"", subtype);
        }
    }

    /* Soak up descriptor bytes beyond those we know how to dissect */
    if (offset < descriptor_len)
    {
        proto_tree_add_item(tree, hf_usb_vid_descriptor_data, tvb, offset, descriptor_len-offset, ENC_NA);
        /* offset = descriptor_len; */
    }

    if (entity_id != 0)
        proto_item_append_text(item, "" (Entity %d)"", entity_id);

    if (subtype != VC_HEADER && usb_conv_info)
    {
        /* Switch to the usb_conv_info of the Video Control interface */
        usb_conv_info = get_usb_iface_conv_info(pinfo, usb_conv_info->interfaceNum);
        video_conv_info = (video_conv_info_t *)usb_conv_info->class_data;

        if (!video_conv_info)
        {
             video_conv_info = wmem_new(wmem_file_scope(), video_conv_info_t);
             video_conv_info->entities = wmem_tree_new(wmem_file_scope());
             usb_conv_info->class_data = video_conv_info;
         }
 
         entity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);
        if (!entity)
        {
            entity = wmem_new(wmem_file_scope(), video_entity_t);
            entity->entityID     = entity_id;
            entity->subtype      = subtype;
            entity->terminalType = terminal_type;

            wmem_tree_insert32(video_conv_info->entities, entity_id, entity);
        }
    }

    return descriptor_len;
}
",C,"            usb_conv_info->class_data_type = USB_CONV_VIDEO;
        } else if (usb_conv_info->class_data_type != USB_CONV_VIDEO) {
            /* Stop dissection if another USB type is in the conversation */
            return descriptor_len;
",,,"@@ -1035,6 +1035,10 @@ dissect_usb_video_control_interface_descriptor(proto_tree *parent_tree, tvbuff_t
             video_conv_info = wmem_new(wmem_file_scope(), video_conv_info_t);
             video_conv_info->entities = wmem_tree_new(wmem_file_scope());
             usb_conv_info->class_data = video_conv_info;
+            usb_conv_info->class_data_type = USB_CONV_VIDEO;
+        } else if (usb_conv_info->class_data_type != USB_CONV_VIDEO) {
+            /* Stop dissection if another USB type is in the conversation */
+            return descriptor_len;
         }
 
         entity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);",wireshark,2cb5985bf47bdc8bea78d28483ed224abdd33dc6,7c79da8c30e39aecb1cddab39f537d8f6a1da25f,1,"dissect_usb_video_control_interface_descriptor(proto_tree *parent_tree, tvbuff_t *tvb,
                                               guint8 descriptor_len, packet_info *pinfo, usb_conv_info_t *usb_conv_info)
{
    video_conv_info_t *video_conv_info = NULL;
    video_entity_t    *entity          = NULL;
    proto_item *item          = NULL;
    proto_item *subtype_item  = NULL;
    proto_tree *tree          = NULL;
    guint8      entity_id     = 0;
    guint16     terminal_type = 0;
    int         offset        = 0;
    guint8      subtype;

    subtype = tvb_get_guint8(tvb, offset+2);

    if (parent_tree)
    {
        const gchar *subtype_str;

        subtype_str = val_to_str_ext(subtype, &vc_if_descriptor_subtypes_ext, ""Unknown (0x%x)"");

        tree = proto_tree_add_subtree_format(parent_tree, tvb, offset, descriptor_len,
                                   ett_descriptor_video_control, &item, ""VIDEO CONTROL INTERFACE DESCRIPTOR [%s]"",
                                   subtype_str);
    }

    /* Common fields */
    dissect_usb_descriptor_header(tree, tvb, offset, &vid_descriptor_type_vals_ext);
    subtype_item = proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_subtype, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);
    offset += 3;

    if (subtype == VC_HEADER)
    {
        guint8 num_vs_interfaces;

        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bcdUVC,            tvb, offset,   2, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_vid_ifdesc_wTotalLength,              tvb, offset+2, 2, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_dwClockFrequency,  tvb, offset+4, 4, ENC_LITTLE_ENDIAN);

        num_vs_interfaces = tvb_get_guint8(tvb, offset+8);
        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bInCollection,     tvb, offset+8, 1, ENC_LITTLE_ENDIAN);

        if (num_vs_interfaces > 0)
        {
            proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_baInterfaceNr, tvb, offset+9, num_vs_interfaces, ENC_NA);
        }

        offset += 9 + num_vs_interfaces;
    }
    else if ((subtype == VC_INPUT_TERMINAL) || (subtype == VC_OUTPUT_TERMINAL))
    {
        /* Fields common to input and output terminals */
        entity_id     = tvb_get_guint8(tvb, offset);
        terminal_type = tvb_get_letohs(tvb, offset+1);

        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_id,    tvb, offset,   1, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_type,  tvb, offset+1, 2, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_assoc_terminal, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);
        offset += 4;

        if (subtype == VC_OUTPUT_TERMINAL)
        {
            proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_src_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);
            ++offset;
        }

        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_iTerminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        ++offset;

        if (subtype == VC_INPUT_TERMINAL)
        {
            if (terminal_type == ITT_CAMERA)
            {
                offset = dissect_usb_video_camera_terminal(tree, tvb, offset);
            }
            else if (terminal_type == ITT_MEDIA_TRANSPORT_INPUT)
            {
                /* @todo */
            }
        }

        if (subtype == VC_OUTPUT_TERMINAL)
        {
            if (terminal_type == OTT_MEDIA_TRANSPORT_OUTPUT)
            {
                /* @todo */
            }
        }
    }
    else
    {
        /* Field common to extension / processing / selector / encoding units */
        entity_id = tvb_get_guint8(tvb, offset);
        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_unit_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        ++offset;

        if (subtype == VC_PROCESSING_UNIT)
        {
            offset = dissect_usb_video_processing_unit(tree, tvb, offset);
        }
        else if (subtype == VC_SELECTOR_UNIT)
        {
            offset = dissect_usb_video_selector_unit(tree, tvb, offset);
        }
        else if (subtype == VC_EXTENSION_UNIT)
        {
            offset = dissect_usb_video_extension_unit(tree, tvb, offset);
        }
        else if (subtype == VC_ENCODING_UNIT)
        {
            /* @todo UVC 1.5 */
        }
        else
        {
            expert_add_info_format(pinfo, subtype_item, &ei_usb_vid_subtype_unknown,
                                   ""Unknown VC subtype %u"", subtype);
        }
    }

    /* Soak up descriptor bytes beyond those we know how to dissect */
    if (offset < descriptor_len)
    {
        proto_tree_add_item(tree, hf_usb_vid_descriptor_data, tvb, offset, descriptor_len-offset, ENC_NA);
        /* offset = descriptor_len; */
    }

    if (entity_id != 0)
        proto_item_append_text(item, "" (Entity %d)"", entity_id);

    if (subtype != VC_HEADER && usb_conv_info)
    {
        /* Switch to the usb_conv_info of the Video Control interface */
        usb_conv_info = get_usb_iface_conv_info(pinfo, usb_conv_info->interfaceNum);
        video_conv_info = (video_conv_info_t *)usb_conv_info->class_data;

        if (!video_conv_info)
        {
             video_conv_info = wmem_new(wmem_file_scope(), video_conv_info_t);
             video_conv_info->entities = wmem_tree_new(wmem_file_scope());
             usb_conv_info->class_data = video_conv_info;
//fix_flaw_line_below:
//            usb_conv_info->class_data_type = USB_CONV_VIDEO;
//fix_flaw_line_below:
//        } else if (usb_conv_info->class_data_type != USB_CONV_VIDEO) {
//fix_flaw_line_below:
//            /* Stop dissection if another USB type is in the conversation */
//fix_flaw_line_below:
//            return descriptor_len;
         }
 
         entity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);
        if (!entity)
        {
            entity = wmem_new(wmem_file_scope(), video_entity_t);
            entity->entityID     = entity_id;
            entity->subtype      = subtype;
            entity->terminalType = terminal_type;

            wmem_tree_insert32(video_conv_info->entities, entity_id, entity);
        }
    }

    return descriptor_len;
}
"
2814,180550,,Remote,Single system,Partial,CVE-2016-3120,https://www.cvedetails.com/cve/CVE-2016-3120/,CWE-476,Low,,,,2016-07-31,4.0,"The validate_as_request function in kdc_util.c in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.13.6 and 1.4.x before 1.14.3, when restrict_anonymous_to_tgt is enabled, uses an incorrect client data structure, which allows remote authenticated users to cause a denial of service (NULL pointer dereference and daemon crash) via an S4U2Self request.",2018-02-03,DoS ,1,https://github.com/krb5/krb5/commit/93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7,93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7,"Fix S4U2Self KDC crash when anon is restricted

In validate_as_request(), when enforcing restrict_anonymous_to_tgt,
use client.princ instead of request->client; the latter is NULL when
validating S4U2Self requests.

CVE-2016-3120:

In MIT krb5 1.9 and later, an authenticated attacker can cause krb5kdc
to dereference a null pointer if the restrict_anonymous_to_tgt option
is set to true, by making an S4U2Self request.

  CVSSv2 Vector: AV:N/AC:H/Au:S/C:N/I:N/A:C/E:H/RL:OF/RC:C

ticket: 8458 (new)
target_version: 1.14-next
target_version: 1.13-next",1,src/kdc/kdc_util.c,"{""sha"": ""29f9dbbf07eb567d378c9c47ec5489357d54eba7"", ""filename"": ""src/kdc/kdc_util.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7/src/kdc/kdc_util.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7/src/kdc/kdc_util.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/kdc/kdc_util.c?ref=93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7"", ""patch"": ""@@ -739,7 +739,7 @@ validate_as_request(kdc_realm_t *kdc_active_realm,\n         return(KDC_ERR_MUST_USE_USER2USER);\n     }\n \n-    if (check_anon(kdc_active_realm, request->client, request->server) != 0) {\n+    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {\n         *status = \""ANONYMOUS NOT ALLOWED\"";\n         return(KDC_ERR_POLICY);\n     }""}<_**next**_>{""sha"": ""f0214b6529e45cc689eb8a76ad21080c3f55d2b2"", ""filename"": ""src/tests/t_pkinit.py"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/krb5/krb5/blob/93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7/src/tests/t_pkinit.py"", ""raw_url"": ""https://github.com/krb5/krb5/raw/93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7/src/tests/t_pkinit.py"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/tests/t_pkinit.py?ref=93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7"", ""patch"": ""@@ -93,6 +93,11 @@\n if 'KDC policy rejects request' not in out:\n     fail('Wrong error for restricted anonymous PKINIT')\n \n+# Regression test for #8458: S4U2Self requests crash the KDC if\n+# anonymous is restricted.\n+realm.kinit(realm.host_princ, flags=['-k'])\n+realm.run([kvno, '-U', 'user', realm.host_princ])\n+\n # Go back to a normal KDC and disable anonymous PKINIT.\n realm.stop_kdc()\n realm.start_kdc()""}","validate_as_request(kdc_realm_t *kdc_active_realm,
                    register krb5_kdc_req *request, krb5_db_entry client,
                    krb5_db_entry server, krb5_timestamp kdc_time,
                    const char **status, krb5_pa_data ***e_data)
{
    int errcode;
    krb5_error_code ret;

    /*
     * If an option is set that is only allowed in TGS requests, complain.
     */
    if (request->kdc_options & AS_INVALID_OPTIONS) {
        *status = ""INVALID AS OPTIONS"";
        return KDC_ERR_BADOPTION;
    }

    /* The client must not be expired */
    if (client.expiration && client.expiration < kdc_time) {
        *status = ""CLIENT EXPIRED"";
        if (vague_errors)
            return(KRB_ERR_GENERIC);
        else
            return(KDC_ERR_NAME_EXP);
    }

    /* The client's password must not be expired, unless the server is
       a KRB5_KDC_PWCHANGE_SERVICE. */
    if (client.pw_expiration && client.pw_expiration < kdc_time &&
        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {
        *status = ""CLIENT KEY EXPIRED"";
        if (vague_errors)
            return(KRB_ERR_GENERIC);
        else
            return(KDC_ERR_KEY_EXP);
    }

    /* The server must not be expired */
    if (server.expiration && server.expiration < kdc_time) {
        *status = ""SERVICE EXPIRED"";
        return(KDC_ERR_SERVICE_EXP);
    }

    /*
     * If the client requires password changing, then only allow the
     * pwchange service.
     */
    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&
        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {
        *status = ""REQUIRED PWCHANGE"";
        return(KDC_ERR_KEY_EXP);
    }

    /* Client and server must allow postdating tickets */
    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||
         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&
        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||
         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {
        *status = ""POSTDATE NOT ALLOWED"";
        return(KDC_ERR_CANNOT_POSTDATE);
    }

    /*
     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of
     * KDC_ERR_POLICY in the following case:
     *
     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local
     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the
     *     client, and;
     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but
     *     preauthentication data is absent in the request.
     *
     * Hence, this check most be done after the check for preauth
     * data, and is now performed by validate_forwardable() (the
     * contents of which were previously below).
     */

    /* Client and server must allow proxiable tickets */
    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&
        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||
         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {
        *status = ""PROXIABLE NOT ALLOWED"";
        return(KDC_ERR_POLICY);
    }

    /* Check to see if client is locked out */
    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {
        *status = ""CLIENT LOCKED OUT"";
        return(KDC_ERR_CLIENT_REVOKED);
    }

    /* Check to see if server is locked out */
    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {
        *status = ""SERVICE LOCKED OUT"";
        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);
    }

    /* Check to see if server is allowed to be a service */
    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {
        *status = ""SERVICE NOT ALLOWED"";
         return(KDC_ERR_MUST_USE_USER2USER);
     }
 
    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {
         *status = ""ANONYMOUS NOT ALLOWED"";
         return(KDC_ERR_POLICY);
     }

    /* Perform KDB module policy checks. */
    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,
                                  kdc_time, status, e_data);
    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)
        return errcode_to_protocol(ret);

    /* Check against local policy. */
    errcode = against_local_policy_as(request, client, server,
                                      kdc_time, status, e_data);
    if (errcode)
        return errcode;

    return 0;
}
","validate_as_request(kdc_realm_t *kdc_active_realm,
                    register krb5_kdc_req *request, krb5_db_entry client,
                    krb5_db_entry server, krb5_timestamp kdc_time,
                    const char **status, krb5_pa_data ***e_data)
{
    int errcode;
    krb5_error_code ret;

    /*
     * If an option is set that is only allowed in TGS requests, complain.
     */
    if (request->kdc_options & AS_INVALID_OPTIONS) {
        *status = ""INVALID AS OPTIONS"";
        return KDC_ERR_BADOPTION;
    }

    /* The client must not be expired */
    if (client.expiration && client.expiration < kdc_time) {
        *status = ""CLIENT EXPIRED"";
        if (vague_errors)
            return(KRB_ERR_GENERIC);
        else
            return(KDC_ERR_NAME_EXP);
    }

    /* The client's password must not be expired, unless the server is
       a KRB5_KDC_PWCHANGE_SERVICE. */
    if (client.pw_expiration && client.pw_expiration < kdc_time &&
        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {
        *status = ""CLIENT KEY EXPIRED"";
        if (vague_errors)
            return(KRB_ERR_GENERIC);
        else
            return(KDC_ERR_KEY_EXP);
    }

    /* The server must not be expired */
    if (server.expiration && server.expiration < kdc_time) {
        *status = ""SERVICE EXPIRED"";
        return(KDC_ERR_SERVICE_EXP);
    }

    /*
     * If the client requires password changing, then only allow the
     * pwchange service.
     */
    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&
        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {
        *status = ""REQUIRED PWCHANGE"";
        return(KDC_ERR_KEY_EXP);
    }

    /* Client and server must allow postdating tickets */
    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||
         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&
        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||
         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {
        *status = ""POSTDATE NOT ALLOWED"";
        return(KDC_ERR_CANNOT_POSTDATE);
    }

    /*
     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of
     * KDC_ERR_POLICY in the following case:
     *
     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local
     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the
     *     client, and;
     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but
     *     preauthentication data is absent in the request.
     *
     * Hence, this check most be done after the check for preauth
     * data, and is now performed by validate_forwardable() (the
     * contents of which were previously below).
     */

    /* Client and server must allow proxiable tickets */
    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&
        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||
         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {
        *status = ""PROXIABLE NOT ALLOWED"";
        return(KDC_ERR_POLICY);
    }

    /* Check to see if client is locked out */
    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {
        *status = ""CLIENT LOCKED OUT"";
        return(KDC_ERR_CLIENT_REVOKED);
    }

    /* Check to see if server is locked out */
    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {
        *status = ""SERVICE LOCKED OUT"";
        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);
    }

    /* Check to see if server is allowed to be a service */
    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {
        *status = ""SERVICE NOT ALLOWED"";
         return(KDC_ERR_MUST_USE_USER2USER);
     }
 
    if (check_anon(kdc_active_realm, request->client, request->server) != 0) {
         *status = ""ANONYMOUS NOT ALLOWED"";
         return(KDC_ERR_POLICY);
     }

    /* Perform KDB module policy checks. */
    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,
                                  kdc_time, status, e_data);
    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)
        return errcode_to_protocol(ret);

    /* Check against local policy. */
    errcode = against_local_policy_as(request, client, server,
                                      kdc_time, status, e_data);
    if (errcode)
        return errcode;

    return 0;
}
",C,"    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {
","    if (check_anon(kdc_active_realm, request->client, request->server) != 0) {
",,"@@ -739,7 +739,7 @@ validate_as_request(kdc_realm_t *kdc_active_realm,
         return(KDC_ERR_MUST_USE_USER2USER);
     }
 
-    if (check_anon(kdc_active_realm, request->client, request->server) != 0) {
+    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {
         *status = ""ANONYMOUS NOT ALLOWED"";
         return(KDC_ERR_POLICY);
     }",krb5,93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7,560e11dabb63b141df29c54aaa2e120309a1e021,1,"validate_as_request(kdc_realm_t *kdc_active_realm,
                    register krb5_kdc_req *request, krb5_db_entry client,
                    krb5_db_entry server, krb5_timestamp kdc_time,
                    const char **status, krb5_pa_data ***e_data)
{
    int errcode;
    krb5_error_code ret;

    /*
     * If an option is set that is only allowed in TGS requests, complain.
     */
    if (request->kdc_options & AS_INVALID_OPTIONS) {
        *status = ""INVALID AS OPTIONS"";
        return KDC_ERR_BADOPTION;
    }

    /* The client must not be expired */
    if (client.expiration && client.expiration < kdc_time) {
        *status = ""CLIENT EXPIRED"";
        if (vague_errors)
            return(KRB_ERR_GENERIC);
        else
            return(KDC_ERR_NAME_EXP);
    }

    /* The client's password must not be expired, unless the server is
       a KRB5_KDC_PWCHANGE_SERVICE. */
    if (client.pw_expiration && client.pw_expiration < kdc_time &&
        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {
        *status = ""CLIENT KEY EXPIRED"";
        if (vague_errors)
            return(KRB_ERR_GENERIC);
        else
            return(KDC_ERR_KEY_EXP);
    }

    /* The server must not be expired */
    if (server.expiration && server.expiration < kdc_time) {
        *status = ""SERVICE EXPIRED"";
        return(KDC_ERR_SERVICE_EXP);
    }

    /*
     * If the client requires password changing, then only allow the
     * pwchange service.
     */
    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&
        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {
        *status = ""REQUIRED PWCHANGE"";
        return(KDC_ERR_KEY_EXP);
    }

    /* Client and server must allow postdating tickets */
    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||
         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&
        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||
         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {
        *status = ""POSTDATE NOT ALLOWED"";
        return(KDC_ERR_CANNOT_POSTDATE);
    }

    /*
     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of
     * KDC_ERR_POLICY in the following case:
     *
     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local
     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the
     *     client, and;
     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but
     *     preauthentication data is absent in the request.
     *
     * Hence, this check most be done after the check for preauth
     * data, and is now performed by validate_forwardable() (the
     * contents of which were previously below).
     */

    /* Client and server must allow proxiable tickets */
    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&
        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||
         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {
        *status = ""PROXIABLE NOT ALLOWED"";
        return(KDC_ERR_POLICY);
    }

    /* Check to see if client is locked out */
    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {
        *status = ""CLIENT LOCKED OUT"";
        return(KDC_ERR_CLIENT_REVOKED);
    }

    /* Check to see if server is locked out */
    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {
        *status = ""SERVICE LOCKED OUT"";
        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);
    }

    /* Check to see if server is allowed to be a service */
    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {
        *status = ""SERVICE NOT ALLOWED"";
         return(KDC_ERR_MUST_USE_USER2USER);
     }
 
//flaw_line_below:
    if (check_anon(kdc_active_realm, request->client, request->server) != 0) {
//fix_flaw_line_below:
//    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {
         *status = ""ANONYMOUS NOT ALLOWED"";
         return(KDC_ERR_POLICY);
     }

    /* Perform KDB module policy checks. */
    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,
                                  kdc_time, status, e_data);
    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)
        return errcode_to_protocol(ret);

    /* Check against local policy. */
    errcode = against_local_policy_as(request, client, server,
                                      kdc_time, status, e_data);
    if (errcode)
        return errcode;

    return 0;
}
"
2819,180555,,Local,Not required,Partial,CVE-2016-3070,https://www.cvedetails.com/cve/CVE-2016-3070/,CWE-476,Low,Partial,Partial,,2016-08-06,4.6,"The trace_writeback_dirty_page implementation in include/trace/events/writeback.h in the Linux kernel before 4.4 improperly interacts with mm/migrate.c, which allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by triggering a certain page move.",2018-01-04,DoS ,3,https://github.com/torvalds/linux/commit/42cb14b110a5698ccf26ce59c4441722605a3743,42cb14b110a5698ccf26ce59c4441722605a3743,"mm: migrate dirty page without clear_page_dirty_for_io etc

clear_page_dirty_for_io() has accumulated writeback and memcg subtleties
since v2.6.16 first introduced page migration; and the set_page_dirty()
which completed its migration of PageDirty, later had to be moderated to
__set_page_dirty_nobuffers(); then PageSwapBacked had to skip that too.

No actual problems seen with this procedure recently, but if you look into
what the clear_page_dirty_for_io(page)+set_page_dirty(newpage) is actually
achieving, it turns out to be nothing more than moving the PageDirty flag,
and its NR_FILE_DIRTY stat from one zone to another.

It would be good to avoid a pile of irrelevant decrementations and
incrementations, and improper event counting, and unnecessary descent of
the radix_tree under tree_lock (to set the PAGECACHE_TAG_DIRTY which
radix_tree_replace_slot() left in place anyway).

Do the NR_FILE_DIRTY movement, like the other stats movements, while
interrupts still disabled in migrate_page_move_mapping(); and don't even
bother if the zone is the same.  Do the PageDirty movement there under
tree_lock too, where old page is frozen and newpage not yet visible:
bearing in mind that as soon as newpage becomes visible in radix_tree, an
un-page-locked set_page_dirty() might interfere (or perhaps that's just
not possible: anything doing so should already hold an additional
reference to the old page, preventing its migration; but play safe).

But we do still need to transfer PageDirty in migrate_page_copy(), for
those who don't go the mapping route through migrate_page_move_mapping().

Signed-off-by: Hugh Dickins <hughd@google.com>
Cc: Christoph Lameter <cl@linux.com>
Cc: ""Kirill A. Shutemov"" <kirill.shutemov@linux.intel.com>
Cc: Rik van Riel <riel@redhat.com>
Cc: Vlastimil Babka <vbabka@suse.cz>
Cc: Davidlohr Bueso <dave@stgolabs.net>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: Sasha Levin <sasha.levin@oracle.com>
Cc: Dmitry Vyukov <dvyukov@google.com>
Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",14,mm/migrate.c,"{""sha"": ""2834faba719a9e4ea1e49af6037d2b70efcf0ad2"", ""filename"": ""mm/migrate.c"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 20, ""changes"": 51, ""blob_url"": ""https://github.com/torvalds/linux/blob/42cb14b110a5698ccf26ce59c4441722605a3743/mm/migrate.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/42cb14b110a5698ccf26ce59c4441722605a3743/mm/migrate.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/migrate.c?ref=42cb14b110a5698ccf26ce59c4441722605a3743"", ""patch"": ""@@ -30,6 +30,7 @@\n #include <linux/mempolicy.h>\n #include <linux/vmalloc.h>\n #include <linux/security.h>\n+#include <linux/backing-dev.h>\n #include <linux/syscalls.h>\n #include <linux/hugetlb.h>\n #include <linux/hugetlb_cgroup.h>\n@@ -313,6 +314,8 @@ int migrate_page_move_mapping(struct address_space *mapping,\n \t\tstruct buffer_head *head, enum migrate_mode mode,\n \t\tint extra_count)\n {\n+\tstruct zone *oldzone, *newzone;\n+\tint dirty;\n \tint expected_count = 1 + extra_count;\n \tvoid **pslot;\n \n@@ -331,6 +334,9 @@ int migrate_page_move_mapping(struct address_space *mapping,\n \t\treturn MIGRATEPAGE_SUCCESS;\n \t}\n \n+\toldzone = page_zone(page);\n+\tnewzone = page_zone(newpage);\n+\n \tspin_lock_irq(&mapping->tree_lock);\n \n \tpslot = radix_tree_lookup_slot(&mapping->page_tree,\n@@ -378,6 +384,13 @@ int migrate_page_move_mapping(struct address_space *mapping,\n \t\tset_page_private(newpage, page_private(page));\n \t}\n \n+\t/* Move dirty while page refs frozen and newpage not yet exposed */\n+\tdirty = PageDirty(page);\n+\tif (dirty) {\n+\t\tClearPageDirty(page);\n+\t\tSetPageDirty(newpage);\n+\t}\n+\n \tradix_tree_replace_slot(pslot, newpage);\n \n \t/*\n@@ -387,6 +400,9 @@ int migrate_page_move_mapping(struct address_space *mapping,\n \t */\n \tpage_unfreeze_refs(page, expected_count - 1);\n \n+\tspin_unlock(&mapping->tree_lock);\n+\t/* Leave irq disabled to prevent preemption while updating stats */\n+\n \t/*\n \t * If moved to a different zone then also account\n \t * the page for that zone. Other VM counters will be\n@@ -397,13 +413,19 @@ int migrate_page_move_mapping(struct address_space *mapping,\n \t * via NR_FILE_PAGES and NR_ANON_PAGES if they\n \t * are mapped to swap space.\n \t */\n-\t__dec_zone_page_state(page, NR_FILE_PAGES);\n-\t__inc_zone_page_state(newpage, NR_FILE_PAGES);\n-\tif (!PageSwapCache(page) && PageSwapBacked(page)) {\n-\t\t__dec_zone_page_state(page, NR_SHMEM);\n-\t\t__inc_zone_page_state(newpage, NR_SHMEM);\n+\tif (newzone != oldzone) {\n+\t\t__dec_zone_state(oldzone, NR_FILE_PAGES);\n+\t\t__inc_zone_state(newzone, NR_FILE_PAGES);\n+\t\tif (PageSwapBacked(page) && !PageSwapCache(page)) {\n+\t\t\t__dec_zone_state(oldzone, NR_SHMEM);\n+\t\t\t__inc_zone_state(newzone, NR_SHMEM);\n+\t\t}\n+\t\tif (dirty && mapping_cap_account_dirty(mapping)) {\n+\t\t\t__dec_zone_state(oldzone, NR_FILE_DIRTY);\n+\t\t\t__inc_zone_state(newzone, NR_FILE_DIRTY);\n+\t\t}\n \t}\n-\tspin_unlock_irq(&mapping->tree_lock);\n+\tlocal_irq_enable();\n \n \treturn MIGRATEPAGE_SUCCESS;\n }\n@@ -524,20 +546,9 @@ void migrate_page_copy(struct page *newpage, struct page *page)\n \tif (PageMappedToDisk(page))\n \t\tSetPageMappedToDisk(newpage);\n \n-\tif (PageDirty(page)) {\n-\t\tclear_page_dirty_for_io(page);\n-\t\t/*\n-\t\t * Want to mark the page and the radix tree as dirty, and\n-\t\t * redo the accounting that clear_page_dirty_for_io undid,\n-\t\t * but we can't use set_page_dirty because that function\n-\t\t * is actually a signal that all of the page has become dirty.\n-\t\t * Whereas only part of our page may be dirty.\n-\t\t */\n-\t\tif (PageSwapBacked(page))\n-\t\t\tSetPageDirty(newpage);\n-\t\telse\n-\t\t\t__set_page_dirty_nobuffers(newpage);\n- \t}\n+\t/* Move dirty on pages not done by migrate_page_move_mapping() */\n+\tif (PageDirty(page))\n+\t\tSetPageDirty(newpage);\n \n \tif (page_is_young(page))\n \t\tset_page_young(newpage);""}","void migrate_page_copy(struct page *newpage, struct page *page)
{
	int cpupid;

	if (PageHuge(page) || PageTransHuge(page))
		copy_huge_page(newpage, page);
	else
		copy_highpage(newpage, page);

	if (PageError(page))
		SetPageError(newpage);
	if (PageReferenced(page))
		SetPageReferenced(newpage);
	if (PageUptodate(page))
		SetPageUptodate(newpage);
	if (TestClearPageActive(page)) {
		VM_BUG_ON_PAGE(PageUnevictable(page), page);
		SetPageActive(newpage);
	} else if (TestClearPageUnevictable(page))
		SetPageUnevictable(newpage);
	if (PageChecked(page))
		SetPageChecked(newpage);
 	if (PageMappedToDisk(page))
 		SetPageMappedToDisk(newpage);
 
	/* Move dirty on pages not done by migrate_page_move_mapping() */
	if (PageDirty(page))
		SetPageDirty(newpage);
 
 	if (page_is_young(page))
 		set_page_young(newpage);
	if (page_is_idle(page))
		set_page_idle(newpage);

	/*
	 * Copy NUMA information to the new page, to prevent over-eager
	 * future migrations of this same page.
	 */
	cpupid = page_cpupid_xchg_last(page, -1);
	page_cpupid_xchg_last(newpage, cpupid);

	ksm_migrate_page(newpage, page);
	/*
	 * Please do not reorder this without considering how mm/ksm.c's
	 * get_ksm_page() depends upon ksm_migrate_page() and PageSwapCache().
	 */
	if (PageSwapCache(page))
		ClearPageSwapCache(page);
	ClearPagePrivate(page);
	set_page_private(page, 0);

	/*
	 * If any waiters have accumulated on the new page then
	 * wake them up.
	 */
	if (PageWriteback(newpage))
		end_page_writeback(newpage);
}
","void migrate_page_copy(struct page *newpage, struct page *page)
{
	int cpupid;

	if (PageHuge(page) || PageTransHuge(page))
		copy_huge_page(newpage, page);
	else
		copy_highpage(newpage, page);

	if (PageError(page))
		SetPageError(newpage);
	if (PageReferenced(page))
		SetPageReferenced(newpage);
	if (PageUptodate(page))
		SetPageUptodate(newpage);
	if (TestClearPageActive(page)) {
		VM_BUG_ON_PAGE(PageUnevictable(page), page);
		SetPageActive(newpage);
	} else if (TestClearPageUnevictable(page))
		SetPageUnevictable(newpage);
	if (PageChecked(page))
		SetPageChecked(newpage);
 	if (PageMappedToDisk(page))
 		SetPageMappedToDisk(newpage);
 
	if (PageDirty(page)) {
		clear_page_dirty_for_io(page);
		/*
		 * Want to mark the page and the radix tree as dirty, and
		 * redo the accounting that clear_page_dirty_for_io undid,
		 * but we can't use set_page_dirty because that function
		 * is actually a signal that all of the page has become dirty.
		 * Whereas only part of our page may be dirty.
		 */
		if (PageSwapBacked(page))
			SetPageDirty(newpage);
		else
			__set_page_dirty_nobuffers(newpage);
 	}
 
 	if (page_is_young(page))
 		set_page_young(newpage);
	if (page_is_idle(page))
		set_page_idle(newpage);

	/*
	 * Copy NUMA information to the new page, to prevent over-eager
	 * future migrations of this same page.
	 */
	cpupid = page_cpupid_xchg_last(page, -1);
	page_cpupid_xchg_last(newpage, cpupid);

	ksm_migrate_page(newpage, page);
	/*
	 * Please do not reorder this without considering how mm/ksm.c's
	 * get_ksm_page() depends upon ksm_migrate_page() and PageSwapCache().
	 */
	if (PageSwapCache(page))
		ClearPageSwapCache(page);
	ClearPagePrivate(page);
	set_page_private(page, 0);

	/*
	 * If any waiters have accumulated on the new page then
	 * wake them up.
	 */
	if (PageWriteback(newpage))
		end_page_writeback(newpage);
}
",C,"	/* Move dirty on pages not done by migrate_page_move_mapping() */
	if (PageDirty(page))
		SetPageDirty(newpage);
","	if (PageDirty(page)) {
		clear_page_dirty_for_io(page);
		/*
		 * Want to mark the page and the radix tree as dirty, and
		 * redo the accounting that clear_page_dirty_for_io undid,
		 * but we can't use set_page_dirty because that function
		 * is actually a signal that all of the page has become dirty.
		 * Whereas only part of our page may be dirty.
		 */
		if (PageSwapBacked(page))
			SetPageDirty(newpage);
		else
			__set_page_dirty_nobuffers(newpage);
 	}
",,"@@ -30,6 +30,7 @@
 #include <linux/mempolicy.h>
 #include <linux/vmalloc.h>
 #include <linux/security.h>
+#include <linux/backing-dev.h>
 #include <linux/syscalls.h>
 #include <linux/hugetlb.h>
 #include <linux/hugetlb_cgroup.h>
@@ -313,6 +314,8 @@ int migrate_page_move_mapping(struct address_space *mapping,
 		struct buffer_head *head, enum migrate_mode mode,
 		int extra_count)
 {
+	struct zone *oldzone, *newzone;
+	int dirty;
 	int expected_count = 1 + extra_count;
 	void **pslot;
 
@@ -331,6 +334,9 @@ int migrate_page_move_mapping(struct address_space *mapping,
 		return MIGRATEPAGE_SUCCESS;
 	}
 
+	oldzone = page_zone(page);
+	newzone = page_zone(newpage);
+
 	spin_lock_irq(&mapping->tree_lock);
 
 	pslot = radix_tree_lookup_slot(&mapping->page_tree,
@@ -378,6 +384,13 @@ int migrate_page_move_mapping(struct address_space *mapping,
 		set_page_private(newpage, page_private(page));
 	}
 
+	/* Move dirty while page refs frozen and newpage not yet exposed */
+	dirty = PageDirty(page);
+	if (dirty) {
+		ClearPageDirty(page);
+		SetPageDirty(newpage);
+	}
+
 	radix_tree_replace_slot(pslot, newpage);
 
 	/*
@@ -387,6 +400,9 @@ int migrate_page_move_mapping(struct address_space *mapping,
 	 */
 	page_unfreeze_refs(page, expected_count - 1);
 
+	spin_unlock(&mapping->tree_lock);
+	/* Leave irq disabled to prevent preemption while updating stats */
+
 	/*
 	 * If moved to a different zone then also account
 	 * the page for that zone. Other VM counters will be
@@ -397,13 +413,19 @@ int migrate_page_move_mapping(struct address_space *mapping,
 	 * via NR_FILE_PAGES and NR_ANON_PAGES if they
 	 * are mapped to swap space.
 	 */
-	__dec_zone_page_state(page, NR_FILE_PAGES);
-	__inc_zone_page_state(newpage, NR_FILE_PAGES);
-	if (!PageSwapCache(page) && PageSwapBacked(page)) {
-		__dec_zone_page_state(page, NR_SHMEM);
-		__inc_zone_page_state(newpage, NR_SHMEM);
+	if (newzone != oldzone) {
+		__dec_zone_state(oldzone, NR_FILE_PAGES);
+		__inc_zone_state(newzone, NR_FILE_PAGES);
+		if (PageSwapBacked(page) && !PageSwapCache(page)) {
+			__dec_zone_state(oldzone, NR_SHMEM);
+			__inc_zone_state(newzone, NR_SHMEM);
+		}
+		if (dirty && mapping_cap_account_dirty(mapping)) {
+			__dec_zone_state(oldzone, NR_FILE_DIRTY);
+			__inc_zone_state(newzone, NR_FILE_DIRTY);
+		}
 	}
-	spin_unlock_irq(&mapping->tree_lock);
+	local_irq_enable();
 
 	return MIGRATEPAGE_SUCCESS;
 }
@@ -524,20 +546,9 @@ void migrate_page_copy(struct page *newpage, struct page *page)
 	if (PageMappedToDisk(page))
 		SetPageMappedToDisk(newpage);
 
-	if (PageDirty(page)) {
-		clear_page_dirty_for_io(page);
-		/*
-		 * Want to mark the page and the radix tree as dirty, and
-		 * redo the accounting that clear_page_dirty_for_io undid,
-		 * but we can't use set_page_dirty because that function
-		 * is actually a signal that all of the page has become dirty.
-		 * Whereas only part of our page may be dirty.
-		 */
-		if (PageSwapBacked(page))
-			SetPageDirty(newpage);
-		else
-			__set_page_dirty_nobuffers(newpage);
- 	}
+	/* Move dirty on pages not done by migrate_page_move_mapping() */
+	if (PageDirty(page))
+		SetPageDirty(newpage);
 
 	if (page_is_young(page))
 		set_page_young(newpage);",linux,42cb14b110a5698ccf26ce59c4441722605a3743,cf4b769abb8aef01f887543cb8308c0d8671367c,1,"void migrate_page_copy(struct page *newpage, struct page *page)
{
	int cpupid;

	if (PageHuge(page) || PageTransHuge(page))
		copy_huge_page(newpage, page);
	else
		copy_highpage(newpage, page);

	if (PageError(page))
		SetPageError(newpage);
	if (PageReferenced(page))
		SetPageReferenced(newpage);
	if (PageUptodate(page))
		SetPageUptodate(newpage);
	if (TestClearPageActive(page)) {
		VM_BUG_ON_PAGE(PageUnevictable(page), page);
		SetPageActive(newpage);
	} else if (TestClearPageUnevictable(page))
		SetPageUnevictable(newpage);
	if (PageChecked(page))
		SetPageChecked(newpage);
 	if (PageMappedToDisk(page))
 		SetPageMappedToDisk(newpage);
 
//flaw_line_below:
	if (PageDirty(page)) {
//flaw_line_below:
		clear_page_dirty_for_io(page);
//flaw_line_below:
		/*
//flaw_line_below:
		 * Want to mark the page and the radix tree as dirty, and
//flaw_line_below:
		 * redo the accounting that clear_page_dirty_for_io undid,
//flaw_line_below:
		 * but we can't use set_page_dirty because that function
//flaw_line_below:
		 * is actually a signal that all of the page has become dirty.
//flaw_line_below:
		 * Whereas only part of our page may be dirty.
//flaw_line_below:
		 */
//flaw_line_below:
		if (PageSwapBacked(page))
//flaw_line_below:
			SetPageDirty(newpage);
//flaw_line_below:
		else
//flaw_line_below:
			__set_page_dirty_nobuffers(newpage);
//flaw_line_below:
 	}
//fix_flaw_line_below:
//	/* Move dirty on pages not done by migrate_page_move_mapping() */
//fix_flaw_line_below:
//	if (PageDirty(page))
//fix_flaw_line_below:
//		SetPageDirty(newpage);
 
 	if (page_is_young(page))
 		set_page_young(newpage);
	if (page_is_idle(page))
		set_page_idle(newpage);

	/*
	 * Copy NUMA information to the new page, to prevent over-eager
	 * future migrations of this same page.
	 */
	cpupid = page_cpupid_xchg_last(page, -1);
	page_cpupid_xchg_last(newpage, cpupid);

	ksm_migrate_page(newpage, page);
	/*
	 * Please do not reorder this without considering how mm/ksm.c's
	 * get_ksm_page() depends upon ksm_migrate_page() and PageSwapCache().
	 */
	if (PageSwapCache(page))
		ClearPageSwapCache(page);
	ClearPagePrivate(page);
	set_page_private(page, 0);

	/*
	 * If any waiters have accumulated on the new page then
	 * wake them up.
	 */
	if (PageWriteback(newpage))
		end_page_writeback(newpage);
}
"
2820,180556,,Local,Not required,Partial,CVE-2016-3070,https://www.cvedetails.com/cve/CVE-2016-3070/,CWE-476,Low,Partial,Partial,,2016-08-06,4.6,"The trace_writeback_dirty_page implementation in include/trace/events/writeback.h in the Linux kernel before 4.4 improperly interacts with mm/migrate.c, which allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by triggering a certain page move.",2018-01-04,DoS ,27,https://github.com/torvalds/linux/commit/42cb14b110a5698ccf26ce59c4441722605a3743,42cb14b110a5698ccf26ce59c4441722605a3743,"mm: migrate dirty page without clear_page_dirty_for_io etc

clear_page_dirty_for_io() has accumulated writeback and memcg subtleties
since v2.6.16 first introduced page migration; and the set_page_dirty()
which completed its migration of PageDirty, later had to be moderated to
__set_page_dirty_nobuffers(); then PageSwapBacked had to skip that too.

No actual problems seen with this procedure recently, but if you look into
what the clear_page_dirty_for_io(page)+set_page_dirty(newpage) is actually
achieving, it turns out to be nothing more than moving the PageDirty flag,
and its NR_FILE_DIRTY stat from one zone to another.

It would be good to avoid a pile of irrelevant decrementations and
incrementations, and improper event counting, and unnecessary descent of
the radix_tree under tree_lock (to set the PAGECACHE_TAG_DIRTY which
radix_tree_replace_slot() left in place anyway).

Do the NR_FILE_DIRTY movement, like the other stats movements, while
interrupts still disabled in migrate_page_move_mapping(); and don't even
bother if the zone is the same.  Do the PageDirty movement there under
tree_lock too, where old page is frozen and newpage not yet visible:
bearing in mind that as soon as newpage becomes visible in radix_tree, an
un-page-locked set_page_dirty() might interfere (or perhaps that's just
not possible: anything doing so should already hold an additional
reference to the old page, preventing its migration; but play safe).

But we do still need to transfer PageDirty in migrate_page_copy(), for
those who don't go the mapping route through migrate_page_move_mapping().

Signed-off-by: Hugh Dickins <hughd@google.com>
Cc: Christoph Lameter <cl@linux.com>
Cc: ""Kirill A. Shutemov"" <kirill.shutemov@linux.intel.com>
Cc: Rik van Riel <riel@redhat.com>
Cc: Vlastimil Babka <vbabka@suse.cz>
Cc: Davidlohr Bueso <dave@stgolabs.net>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: Sasha Levin <sasha.levin@oracle.com>
Cc: Dmitry Vyukov <dvyukov@google.com>
Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",6,mm/migrate.c,"{""sha"": ""2834faba719a9e4ea1e49af6037d2b70efcf0ad2"", ""filename"": ""mm/migrate.c"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 20, ""changes"": 51, ""blob_url"": ""https://github.com/torvalds/linux/blob/42cb14b110a5698ccf26ce59c4441722605a3743/mm/migrate.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/42cb14b110a5698ccf26ce59c4441722605a3743/mm/migrate.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/migrate.c?ref=42cb14b110a5698ccf26ce59c4441722605a3743"", ""patch"": ""@@ -30,6 +30,7 @@\n #include <linux/mempolicy.h>\n #include <linux/vmalloc.h>\n #include <linux/security.h>\n+#include <linux/backing-dev.h>\n #include <linux/syscalls.h>\n #include <linux/hugetlb.h>\n #include <linux/hugetlb_cgroup.h>\n@@ -313,6 +314,8 @@ int migrate_page_move_mapping(struct address_space *mapping,\n \t\tstruct buffer_head *head, enum migrate_mode mode,\n \t\tint extra_count)\n {\n+\tstruct zone *oldzone, *newzone;\n+\tint dirty;\n \tint expected_count = 1 + extra_count;\n \tvoid **pslot;\n \n@@ -331,6 +334,9 @@ int migrate_page_move_mapping(struct address_space *mapping,\n \t\treturn MIGRATEPAGE_SUCCESS;\n \t}\n \n+\toldzone = page_zone(page);\n+\tnewzone = page_zone(newpage);\n+\n \tspin_lock_irq(&mapping->tree_lock);\n \n \tpslot = radix_tree_lookup_slot(&mapping->page_tree,\n@@ -378,6 +384,13 @@ int migrate_page_move_mapping(struct address_space *mapping,\n \t\tset_page_private(newpage, page_private(page));\n \t}\n \n+\t/* Move dirty while page refs frozen and newpage not yet exposed */\n+\tdirty = PageDirty(page);\n+\tif (dirty) {\n+\t\tClearPageDirty(page);\n+\t\tSetPageDirty(newpage);\n+\t}\n+\n \tradix_tree_replace_slot(pslot, newpage);\n \n \t/*\n@@ -387,6 +400,9 @@ int migrate_page_move_mapping(struct address_space *mapping,\n \t */\n \tpage_unfreeze_refs(page, expected_count - 1);\n \n+\tspin_unlock(&mapping->tree_lock);\n+\t/* Leave irq disabled to prevent preemption while updating stats */\n+\n \t/*\n \t * If moved to a different zone then also account\n \t * the page for that zone. Other VM counters will be\n@@ -397,13 +413,19 @@ int migrate_page_move_mapping(struct address_space *mapping,\n \t * via NR_FILE_PAGES and NR_ANON_PAGES if they\n \t * are mapped to swap space.\n \t */\n-\t__dec_zone_page_state(page, NR_FILE_PAGES);\n-\t__inc_zone_page_state(newpage, NR_FILE_PAGES);\n-\tif (!PageSwapCache(page) && PageSwapBacked(page)) {\n-\t\t__dec_zone_page_state(page, NR_SHMEM);\n-\t\t__inc_zone_page_state(newpage, NR_SHMEM);\n+\tif (newzone != oldzone) {\n+\t\t__dec_zone_state(oldzone, NR_FILE_PAGES);\n+\t\t__inc_zone_state(newzone, NR_FILE_PAGES);\n+\t\tif (PageSwapBacked(page) && !PageSwapCache(page)) {\n+\t\t\t__dec_zone_state(oldzone, NR_SHMEM);\n+\t\t\t__inc_zone_state(newzone, NR_SHMEM);\n+\t\t}\n+\t\tif (dirty && mapping_cap_account_dirty(mapping)) {\n+\t\t\t__dec_zone_state(oldzone, NR_FILE_DIRTY);\n+\t\t\t__inc_zone_state(newzone, NR_FILE_DIRTY);\n+\t\t}\n \t}\n-\tspin_unlock_irq(&mapping->tree_lock);\n+\tlocal_irq_enable();\n \n \treturn MIGRATEPAGE_SUCCESS;\n }\n@@ -524,20 +546,9 @@ void migrate_page_copy(struct page *newpage, struct page *page)\n \tif (PageMappedToDisk(page))\n \t\tSetPageMappedToDisk(newpage);\n \n-\tif (PageDirty(page)) {\n-\t\tclear_page_dirty_for_io(page);\n-\t\t/*\n-\t\t * Want to mark the page and the radix tree as dirty, and\n-\t\t * redo the accounting that clear_page_dirty_for_io undid,\n-\t\t * but we can't use set_page_dirty because that function\n-\t\t * is actually a signal that all of the page has become dirty.\n-\t\t * Whereas only part of our page may be dirty.\n-\t\t */\n-\t\tif (PageSwapBacked(page))\n-\t\t\tSetPageDirty(newpage);\n-\t\telse\n-\t\t\t__set_page_dirty_nobuffers(newpage);\n- \t}\n+\t/* Move dirty on pages not done by migrate_page_move_mapping() */\n+\tif (PageDirty(page))\n+\t\tSetPageDirty(newpage);\n \n \tif (page_is_young(page))\n \t\tset_page_young(newpage);""}","int migrate_page_move_mapping(struct address_space *mapping,
		struct page *newpage, struct page *page,
 		struct buffer_head *head, enum migrate_mode mode,
 		int extra_count)
 {
	struct zone *oldzone, *newzone;
	int dirty;
 	int expected_count = 1 + extra_count;
 	void **pslot;
 
	if (!mapping) {
		/* Anonymous page without mapping */
		if (page_count(page) != expected_count)
			return -EAGAIN;

		/* No turning back from here */
		set_page_memcg(newpage, page_memcg(page));
		newpage->index = page->index;
		newpage->mapping = page->mapping;
		if (PageSwapBacked(page))
			SetPageSwapBacked(newpage);

 		return MIGRATEPAGE_SUCCESS;
 	}
 
	oldzone = page_zone(page);
	newzone = page_zone(newpage);

 	spin_lock_irq(&mapping->tree_lock);
 
 	pslot = radix_tree_lookup_slot(&mapping->page_tree,
 					page_index(page));

	expected_count += 1 + page_has_private(page);
	if (page_count(page) != expected_count ||
		radix_tree_deref_slot_protected(pslot, &mapping->tree_lock) != page) {
		spin_unlock_irq(&mapping->tree_lock);
		return -EAGAIN;
	}

	if (!page_freeze_refs(page, expected_count)) {
		spin_unlock_irq(&mapping->tree_lock);
		return -EAGAIN;
	}

	/*
	 * In the async migration case of moving a page with buffers, lock the
	 * buffers using trylock before the mapping is moved. If the mapping
	 * was moved, we later failed to lock the buffers and could not move
	 * the mapping back due to an elevated page count, we would have to
	 * block waiting on other references to be dropped.
	 */
	if (mode == MIGRATE_ASYNC && head &&
			!buffer_migrate_lock_buffers(head, mode)) {
		page_unfreeze_refs(page, expected_count);
		spin_unlock_irq(&mapping->tree_lock);
		return -EAGAIN;
	}

	/*
	 * Now we know that no one else is looking at the page:
	 * no turning back from here.
	 */
	set_page_memcg(newpage, page_memcg(page));
	newpage->index = page->index;
	newpage->mapping = page->mapping;
	if (PageSwapBacked(page))
		SetPageSwapBacked(newpage);

	get_page(newpage);	/* add cache reference */
	if (PageSwapCache(page)) {
		SetPageSwapCache(newpage);
 		set_page_private(newpage, page_private(page));
 	}
 
	/* Move dirty while page refs frozen and newpage not yet exposed */
	dirty = PageDirty(page);
	if (dirty) {
		ClearPageDirty(page);
		SetPageDirty(newpage);
	}

 	radix_tree_replace_slot(pslot, newpage);
 
 	/*
	 * Drop cache reference from old page by unfreezing
	 * to one less reference.
	 * We know this isn't the last reference.
 	 */
 	page_unfreeze_refs(page, expected_count - 1);
 
	spin_unlock(&mapping->tree_lock);
	/* Leave irq disabled to prevent preemption while updating stats */

 	/*
 	 * If moved to a different zone then also account
 	 * the page for that zone. Other VM counters will be
	 * taken care of when we establish references to the
	 * new page and drop references to the old page.
	 *
	 * Note that anonymous pages are accounted for
 	 * via NR_FILE_PAGES and NR_ANON_PAGES if they
 	 * are mapped to swap space.
 	 */
	if (newzone != oldzone) {
		__dec_zone_state(oldzone, NR_FILE_PAGES);
		__inc_zone_state(newzone, NR_FILE_PAGES);
		if (PageSwapBacked(page) && !PageSwapCache(page)) {
			__dec_zone_state(oldzone, NR_SHMEM);
			__inc_zone_state(newzone, NR_SHMEM);
		}
		if (dirty && mapping_cap_account_dirty(mapping)) {
			__dec_zone_state(oldzone, NR_FILE_DIRTY);
			__inc_zone_state(newzone, NR_FILE_DIRTY);
		}
 	}
	local_irq_enable();
 
 	return MIGRATEPAGE_SUCCESS;
 }
","int migrate_page_move_mapping(struct address_space *mapping,
		struct page *newpage, struct page *page,
 		struct buffer_head *head, enum migrate_mode mode,
 		int extra_count)
 {
 	int expected_count = 1 + extra_count;
 	void **pslot;
 
	if (!mapping) {
		/* Anonymous page without mapping */
		if (page_count(page) != expected_count)
			return -EAGAIN;

		/* No turning back from here */
		set_page_memcg(newpage, page_memcg(page));
		newpage->index = page->index;
		newpage->mapping = page->mapping;
		if (PageSwapBacked(page))
			SetPageSwapBacked(newpage);

 		return MIGRATEPAGE_SUCCESS;
 	}
 
 	spin_lock_irq(&mapping->tree_lock);
 
 	pslot = radix_tree_lookup_slot(&mapping->page_tree,
 					page_index(page));

	expected_count += 1 + page_has_private(page);
	if (page_count(page) != expected_count ||
		radix_tree_deref_slot_protected(pslot, &mapping->tree_lock) != page) {
		spin_unlock_irq(&mapping->tree_lock);
		return -EAGAIN;
	}

	if (!page_freeze_refs(page, expected_count)) {
		spin_unlock_irq(&mapping->tree_lock);
		return -EAGAIN;
	}

	/*
	 * In the async migration case of moving a page with buffers, lock the
	 * buffers using trylock before the mapping is moved. If the mapping
	 * was moved, we later failed to lock the buffers and could not move
	 * the mapping back due to an elevated page count, we would have to
	 * block waiting on other references to be dropped.
	 */
	if (mode == MIGRATE_ASYNC && head &&
			!buffer_migrate_lock_buffers(head, mode)) {
		page_unfreeze_refs(page, expected_count);
		spin_unlock_irq(&mapping->tree_lock);
		return -EAGAIN;
	}

	/*
	 * Now we know that no one else is looking at the page:
	 * no turning back from here.
	 */
	set_page_memcg(newpage, page_memcg(page));
	newpage->index = page->index;
	newpage->mapping = page->mapping;
	if (PageSwapBacked(page))
		SetPageSwapBacked(newpage);

	get_page(newpage);	/* add cache reference */
	if (PageSwapCache(page)) {
		SetPageSwapCache(newpage);
 		set_page_private(newpage, page_private(page));
 	}
 
 	radix_tree_replace_slot(pslot, newpage);
 
 	/*
	 * Drop cache reference from old page by unfreezing
	 * to one less reference.
	 * We know this isn't the last reference.
 	 */
 	page_unfreeze_refs(page, expected_count - 1);
 
 	/*
 	 * If moved to a different zone then also account
 	 * the page for that zone. Other VM counters will be
	 * taken care of when we establish references to the
	 * new page and drop references to the old page.
	 *
	 * Note that anonymous pages are accounted for
 	 * via NR_FILE_PAGES and NR_ANON_PAGES if they
 	 * are mapped to swap space.
 	 */
	__dec_zone_page_state(page, NR_FILE_PAGES);
	__inc_zone_page_state(newpage, NR_FILE_PAGES);
	if (!PageSwapCache(page) && PageSwapBacked(page)) {
		__dec_zone_page_state(page, NR_SHMEM);
		__inc_zone_page_state(newpage, NR_SHMEM);
 	}
	spin_unlock_irq(&mapping->tree_lock);
 
 	return MIGRATEPAGE_SUCCESS;
 }
",C,"	struct zone *oldzone, *newzone;
	int dirty;
	oldzone = page_zone(page);
	newzone = page_zone(newpage);

	/* Move dirty while page refs frozen and newpage not yet exposed */
	dirty = PageDirty(page);
	if (dirty) {
		ClearPageDirty(page);
		SetPageDirty(newpage);
	}

	spin_unlock(&mapping->tree_lock);
	/* Leave irq disabled to prevent preemption while updating stats */

	if (newzone != oldzone) {
		__dec_zone_state(oldzone, NR_FILE_PAGES);
		__inc_zone_state(newzone, NR_FILE_PAGES);
		if (PageSwapBacked(page) && !PageSwapCache(page)) {
			__dec_zone_state(oldzone, NR_SHMEM);
			__inc_zone_state(newzone, NR_SHMEM);
		}
		if (dirty && mapping_cap_account_dirty(mapping)) {
			__dec_zone_state(oldzone, NR_FILE_DIRTY);
			__inc_zone_state(newzone, NR_FILE_DIRTY);
		}
	local_irq_enable();
","	__dec_zone_page_state(page, NR_FILE_PAGES);
	__inc_zone_page_state(newpage, NR_FILE_PAGES);
	if (!PageSwapCache(page) && PageSwapBacked(page)) {
		__dec_zone_page_state(page, NR_SHMEM);
		__inc_zone_page_state(newpage, NR_SHMEM);
	spin_unlock_irq(&mapping->tree_lock);
",,"@@ -30,6 +30,7 @@
 #include <linux/mempolicy.h>
 #include <linux/vmalloc.h>
 #include <linux/security.h>
+#include <linux/backing-dev.h>
 #include <linux/syscalls.h>
 #include <linux/hugetlb.h>
 #include <linux/hugetlb_cgroup.h>
@@ -313,6 +314,8 @@ int migrate_page_move_mapping(struct address_space *mapping,
 		struct buffer_head *head, enum migrate_mode mode,
 		int extra_count)
 {
+	struct zone *oldzone, *newzone;
+	int dirty;
 	int expected_count = 1 + extra_count;
 	void **pslot;
 
@@ -331,6 +334,9 @@ int migrate_page_move_mapping(struct address_space *mapping,
 		return MIGRATEPAGE_SUCCESS;
 	}
 
+	oldzone = page_zone(page);
+	newzone = page_zone(newpage);
+
 	spin_lock_irq(&mapping->tree_lock);
 
 	pslot = radix_tree_lookup_slot(&mapping->page_tree,
@@ -378,6 +384,13 @@ int migrate_page_move_mapping(struct address_space *mapping,
 		set_page_private(newpage, page_private(page));
 	}
 
+	/* Move dirty while page refs frozen and newpage not yet exposed */
+	dirty = PageDirty(page);
+	if (dirty) {
+		ClearPageDirty(page);
+		SetPageDirty(newpage);
+	}
+
 	radix_tree_replace_slot(pslot, newpage);
 
 	/*
@@ -387,6 +400,9 @@ int migrate_page_move_mapping(struct address_space *mapping,
 	 */
 	page_unfreeze_refs(page, expected_count - 1);
 
+	spin_unlock(&mapping->tree_lock);
+	/* Leave irq disabled to prevent preemption while updating stats */
+
 	/*
 	 * If moved to a different zone then also account
 	 * the page for that zone. Other VM counters will be
@@ -397,13 +413,19 @@ int migrate_page_move_mapping(struct address_space *mapping,
 	 * via NR_FILE_PAGES and NR_ANON_PAGES if they
 	 * are mapped to swap space.
 	 */
-	__dec_zone_page_state(page, NR_FILE_PAGES);
-	__inc_zone_page_state(newpage, NR_FILE_PAGES);
-	if (!PageSwapCache(page) && PageSwapBacked(page)) {
-		__dec_zone_page_state(page, NR_SHMEM);
-		__inc_zone_page_state(newpage, NR_SHMEM);
+	if (newzone != oldzone) {
+		__dec_zone_state(oldzone, NR_FILE_PAGES);
+		__inc_zone_state(newzone, NR_FILE_PAGES);
+		if (PageSwapBacked(page) && !PageSwapCache(page)) {
+			__dec_zone_state(oldzone, NR_SHMEM);
+			__inc_zone_state(newzone, NR_SHMEM);
+		}
+		if (dirty && mapping_cap_account_dirty(mapping)) {
+			__dec_zone_state(oldzone, NR_FILE_DIRTY);
+			__inc_zone_state(newzone, NR_FILE_DIRTY);
+		}
 	}
-	spin_unlock_irq(&mapping->tree_lock);
+	local_irq_enable();
 
 	return MIGRATEPAGE_SUCCESS;
 }
@@ -524,20 +546,9 @@ void migrate_page_copy(struct page *newpage, struct page *page)
 	if (PageMappedToDisk(page))
 		SetPageMappedToDisk(newpage);
 
-	if (PageDirty(page)) {
-		clear_page_dirty_for_io(page);
-		/*
-		 * Want to mark the page and the radix tree as dirty, and
-		 * redo the accounting that clear_page_dirty_for_io undid,
-		 * but we can't use set_page_dirty because that function
-		 * is actually a signal that all of the page has become dirty.
-		 * Whereas only part of our page may be dirty.
-		 */
-		if (PageSwapBacked(page))
-			SetPageDirty(newpage);
-		else
-			__set_page_dirty_nobuffers(newpage);
- 	}
+	/* Move dirty on pages not done by migrate_page_move_mapping() */
+	if (PageDirty(page))
+		SetPageDirty(newpage);
 
 	if (page_is_young(page))
 		set_page_young(newpage);",linux,42cb14b110a5698ccf26ce59c4441722605a3743,cf4b769abb8aef01f887543cb8308c0d8671367c,1,"int migrate_page_move_mapping(struct address_space *mapping,
		struct page *newpage, struct page *page,
 		struct buffer_head *head, enum migrate_mode mode,
 		int extra_count)
 {
//fix_flaw_line_below:
//	struct zone *oldzone, *newzone;
//fix_flaw_line_below:
//	int dirty;
 	int expected_count = 1 + extra_count;
 	void **pslot;
 
	if (!mapping) {
		/* Anonymous page without mapping */
		if (page_count(page) != expected_count)
			return -EAGAIN;

		/* No turning back from here */
		set_page_memcg(newpage, page_memcg(page));
		newpage->index = page->index;
		newpage->mapping = page->mapping;
		if (PageSwapBacked(page))
			SetPageSwapBacked(newpage);

 		return MIGRATEPAGE_SUCCESS;
 	}
 
//fix_flaw_line_below:
//	oldzone = page_zone(page);
//fix_flaw_line_below:
//	newzone = page_zone(newpage);
//fix_flaw_line_below:
//
 	spin_lock_irq(&mapping->tree_lock);
 
 	pslot = radix_tree_lookup_slot(&mapping->page_tree,
 					page_index(page));

	expected_count += 1 + page_has_private(page);
	if (page_count(page) != expected_count ||
		radix_tree_deref_slot_protected(pslot, &mapping->tree_lock) != page) {
		spin_unlock_irq(&mapping->tree_lock);
		return -EAGAIN;
	}

	if (!page_freeze_refs(page, expected_count)) {
		spin_unlock_irq(&mapping->tree_lock);
		return -EAGAIN;
	}

	/*
	 * In the async migration case of moving a page with buffers, lock the
	 * buffers using trylock before the mapping is moved. If the mapping
	 * was moved, we later failed to lock the buffers and could not move
	 * the mapping back due to an elevated page count, we would have to
	 * block waiting on other references to be dropped.
	 */
	if (mode == MIGRATE_ASYNC && head &&
			!buffer_migrate_lock_buffers(head, mode)) {
		page_unfreeze_refs(page, expected_count);
		spin_unlock_irq(&mapping->tree_lock);
		return -EAGAIN;
	}

	/*
	 * Now we know that no one else is looking at the page:
	 * no turning back from here.
	 */
	set_page_memcg(newpage, page_memcg(page));
	newpage->index = page->index;
	newpage->mapping = page->mapping;
	if (PageSwapBacked(page))
		SetPageSwapBacked(newpage);

	get_page(newpage);	/* add cache reference */
	if (PageSwapCache(page)) {
		SetPageSwapCache(newpage);
 		set_page_private(newpage, page_private(page));
 	}
 
//fix_flaw_line_below:
//	/* Move dirty while page refs frozen and newpage not yet exposed */
//fix_flaw_line_below:
//	dirty = PageDirty(page);
//fix_flaw_line_below:
//	if (dirty) {
//fix_flaw_line_below:
//		ClearPageDirty(page);
//fix_flaw_line_below:
//		SetPageDirty(newpage);
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	radix_tree_replace_slot(pslot, newpage);
 
 	/*
	 * Drop cache reference from old page by unfreezing
	 * to one less reference.
	 * We know this isn't the last reference.
 	 */
 	page_unfreeze_refs(page, expected_count - 1);
 
//fix_flaw_line_below:
//	spin_unlock(&mapping->tree_lock);
//fix_flaw_line_below:
//	/* Leave irq disabled to prevent preemption while updating stats */
//fix_flaw_line_below:
//
 	/*
 	 * If moved to a different zone then also account
 	 * the page for that zone. Other VM counters will be
	 * taken care of when we establish references to the
	 * new page and drop references to the old page.
	 *
	 * Note that anonymous pages are accounted for
 	 * via NR_FILE_PAGES and NR_ANON_PAGES if they
 	 * are mapped to swap space.
 	 */
//flaw_line_below:
	__dec_zone_page_state(page, NR_FILE_PAGES);
//flaw_line_below:
	__inc_zone_page_state(newpage, NR_FILE_PAGES);
//flaw_line_below:
	if (!PageSwapCache(page) && PageSwapBacked(page)) {
//flaw_line_below:
		__dec_zone_page_state(page, NR_SHMEM);
//flaw_line_below:
		__inc_zone_page_state(newpage, NR_SHMEM);
//fix_flaw_line_below:
//	if (newzone != oldzone) {
//fix_flaw_line_below:
//		__dec_zone_state(oldzone, NR_FILE_PAGES);
//fix_flaw_line_below:
//		__inc_zone_state(newzone, NR_FILE_PAGES);
//fix_flaw_line_below:
//		if (PageSwapBacked(page) && !PageSwapCache(page)) {
//fix_flaw_line_below:
//			__dec_zone_state(oldzone, NR_SHMEM);
//fix_flaw_line_below:
//			__inc_zone_state(newzone, NR_SHMEM);
//fix_flaw_line_below:
//		}
//fix_flaw_line_below:
//		if (dirty && mapping_cap_account_dirty(mapping)) {
//fix_flaw_line_below:
//			__dec_zone_state(oldzone, NR_FILE_DIRTY);
//fix_flaw_line_below:
//			__inc_zone_state(newzone, NR_FILE_DIRTY);
//fix_flaw_line_below:
//		}
 	}
//flaw_line_below:
	spin_unlock_irq(&mapping->tree_lock);
//fix_flaw_line_below:
//	local_irq_enable();
 
 	return MIGRATEPAGE_SUCCESS;
 }
"
2890,180626,,Local,Not required,Complete,CVE-2015-8970,https://www.cvedetails.com/cve/CVE-2015-8970/,CWE-476,Low,,,,2016-11-27,4.9,"crypto/algif_skcipher.c in the Linux kernel before 4.4.2 does not verify that a setkey operation has been performed on an AF_ALG socket before an accept system call is processed, which allows local users to cause a denial of service (NULL pointer dereference and system crash) via a crafted application that does not supply a key, related to the lrw_crypt function in crypto/lrw.c.",2018-08-13,DoS ,9,https://github.com/torvalds/linux/commit/dd504589577d8e8e70f51f997ad487a4cb6c026f,dd504589577d8e8e70f51f997ad487a4cb6c026f,"crypto: algif_skcipher - Require setkey before accept(2)

Some cipher implementations will crash if you try to use them
without calling setkey first.  This patch adds a check so that
the accept(2) call will fail with -ENOKEY if setkey hasn't been
done on the socket yet.

Cc: stable@vger.kernel.org
Reported-by: Dmitry Vyukov <dvyukov@google.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
Tested-by: Dmitry Vyukov <dvyukov@google.com>",4,crypto/algif_skcipher.c,"{""sha"": ""f4431bc1ce430203b374ae757e627d808c6f17a4"", ""filename"": ""crypto/algif_skcipher.c"", ""status"": ""modified"", ""additions"": 41, ""deletions"": 7, ""changes"": 48, ""blob_url"": ""https://github.com/torvalds/linux/blob/dd504589577d8e8e70f51f997ad487a4cb6c026f/crypto/algif_skcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/dd504589577d8e8e70f51f997ad487a4cb6c026f/crypto/algif_skcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/algif_skcipher.c?ref=dd504589577d8e8e70f51f997ad487a4cb6c026f"", ""patch"": ""@@ -31,6 +31,11 @@ struct skcipher_sg_list {\n \tstruct scatterlist sg[0];\n };\n \n+struct skcipher_tfm {\n+\tstruct crypto_skcipher *skcipher;\n+\tbool has_key;\n+};\n+\n struct skcipher_ctx {\n \tstruct list_head tsgl;\n \tstruct af_alg_sgl rsgl;\n@@ -750,17 +755,41 @@ static struct proto_ops algif_skcipher_ops = {\n \n static void *skcipher_bind(const char *name, u32 type, u32 mask)\n {\n-\treturn crypto_alloc_skcipher(name, type, mask);\n+\tstruct skcipher_tfm *tfm;\n+\tstruct crypto_skcipher *skcipher;\n+\n+\ttfm = kzalloc(sizeof(*tfm), GFP_KERNEL);\n+\tif (!tfm)\n+\t\treturn ERR_PTR(-ENOMEM);\n+\n+\tskcipher = crypto_alloc_skcipher(name, type, mask);\n+\tif (IS_ERR(skcipher)) {\n+\t\tkfree(tfm);\n+\t\treturn ERR_CAST(skcipher);\n+\t}\n+\n+\ttfm->skcipher = skcipher;\n+\n+\treturn tfm;\n }\n \n static void skcipher_release(void *private)\n {\n-\tcrypto_free_skcipher(private);\n+\tstruct skcipher_tfm *tfm = private;\n+\n+\tcrypto_free_skcipher(tfm->skcipher);\n+\tkfree(tfm);\n }\n \n static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\n {\n-\treturn crypto_skcipher_setkey(private, key, keylen);\n+\tstruct skcipher_tfm *tfm = private;\n+\tint err;\n+\n+\terr = crypto_skcipher_setkey(tfm->skcipher, key, keylen);\n+\ttfm->has_key = !err;\n+\n+\treturn err;\n }\n \n static void skcipher_wait(struct sock *sk)\n@@ -792,20 +821,25 @@ static int skcipher_accept_parent(void *private, struct sock *sk)\n {\n \tstruct skcipher_ctx *ctx;\n \tstruct alg_sock *ask = alg_sk(sk);\n-\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);\n+\tstruct skcipher_tfm *tfm = private;\n+\tstruct crypto_skcipher *skcipher = tfm->skcipher;\n+\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);\n+\n+\tif (!tfm->has_key)\n+\t\treturn -ENOKEY;\n \n \tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n \tif (!ctx)\n \t\treturn -ENOMEM;\n \n-\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),\n+\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),\n \t\t\t       GFP_KERNEL);\n \tif (!ctx->iv) {\n \t\tsock_kfree_s(sk, ctx, len);\n \t\treturn -ENOMEM;\n \t}\n \n-\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(private));\n+\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));\n \n \tINIT_LIST_HEAD(&ctx->tsgl);\n \tctx->len = len;\n@@ -818,7 +852,7 @@ static int skcipher_accept_parent(void *private, struct sock *sk)\n \n \task->private = ctx;\n \n-\tskcipher_request_set_tfm(&ctx->req, private);\n+\tskcipher_request_set_tfm(&ctx->req, skcipher);\n \tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n \t\t\t\t      af_alg_complete, &ctx->completion);\n ""}","static int skcipher_accept_parent(void *private, struct sock *sk)
 {
 	struct skcipher_ctx *ctx;
 	struct alg_sock *ask = alg_sk(sk);
	struct skcipher_tfm *tfm = private;
	struct crypto_skcipher *skcipher = tfm->skcipher;
	unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);

	if (!tfm->has_key)
		return -ENOKEY;
 
 	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
 	if (!ctx)
 		return -ENOMEM;
 
	ctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),
 			       GFP_KERNEL);
 	if (!ctx->iv) {
 		sock_kfree_s(sk, ctx, len);
 		return -ENOMEM;
 	}
 
	memset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));
 
 	INIT_LIST_HEAD(&ctx->tsgl);
 	ctx->len = len;
	ctx->used = 0;
	ctx->more = 0;
	ctx->merge = 0;
	ctx->enc = 0;
	atomic_set(&ctx->inflight, 0);
	af_alg_init_completion(&ctx->completion);
 
 	ask->private = ctx;
 
	skcipher_request_set_tfm(&ctx->req, skcipher);
 	skcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
 				      af_alg_complete, &ctx->completion);
 
	sk->sk_destruct = skcipher_sock_destruct;

	return 0;
}
","static int skcipher_accept_parent(void *private, struct sock *sk)
 {
 	struct skcipher_ctx *ctx;
 	struct alg_sock *ask = alg_sk(sk);
	unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);
 
 	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
 	if (!ctx)
 		return -ENOMEM;
 
	ctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),
 			       GFP_KERNEL);
 	if (!ctx->iv) {
 		sock_kfree_s(sk, ctx, len);
 		return -ENOMEM;
 	}
 
	memset(ctx->iv, 0, crypto_skcipher_ivsize(private));
 
 	INIT_LIST_HEAD(&ctx->tsgl);
 	ctx->len = len;
	ctx->used = 0;
	ctx->more = 0;
	ctx->merge = 0;
	ctx->enc = 0;
	atomic_set(&ctx->inflight, 0);
	af_alg_init_completion(&ctx->completion);
 
 	ask->private = ctx;
 
	skcipher_request_set_tfm(&ctx->req, private);
 	skcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
 				      af_alg_complete, &ctx->completion);
 
	sk->sk_destruct = skcipher_sock_destruct;

	return 0;
}
",C,"	struct skcipher_tfm *tfm = private;
	struct crypto_skcipher *skcipher = tfm->skcipher;
	unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);

	if (!tfm->has_key)
		return -ENOKEY;
	ctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),
	memset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));
	skcipher_request_set_tfm(&ctx->req, skcipher);
","	unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);
	ctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),
	memset(ctx->iv, 0, crypto_skcipher_ivsize(private));
	skcipher_request_set_tfm(&ctx->req, private);
",,"@@ -31,6 +31,11 @@ struct skcipher_sg_list {
 	struct scatterlist sg[0];
 };
 
+struct skcipher_tfm {
+	struct crypto_skcipher *skcipher;
+	bool has_key;
+};
+
 struct skcipher_ctx {
 	struct list_head tsgl;
 	struct af_alg_sgl rsgl;
@@ -750,17 +755,41 @@ static struct proto_ops algif_skcipher_ops = {
 
 static void *skcipher_bind(const char *name, u32 type, u32 mask)
 {
-	return crypto_alloc_skcipher(name, type, mask);
+	struct skcipher_tfm *tfm;
+	struct crypto_skcipher *skcipher;
+
+	tfm = kzalloc(sizeof(*tfm), GFP_KERNEL);
+	if (!tfm)
+		return ERR_PTR(-ENOMEM);
+
+	skcipher = crypto_alloc_skcipher(name, type, mask);
+	if (IS_ERR(skcipher)) {
+		kfree(tfm);
+		return ERR_CAST(skcipher);
+	}
+
+	tfm->skcipher = skcipher;
+
+	return tfm;
 }
 
 static void skcipher_release(void *private)
 {
-	crypto_free_skcipher(private);
+	struct skcipher_tfm *tfm = private;
+
+	crypto_free_skcipher(tfm->skcipher);
+	kfree(tfm);
 }
 
 static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
 {
-	return crypto_skcipher_setkey(private, key, keylen);
+	struct skcipher_tfm *tfm = private;
+	int err;
+
+	err = crypto_skcipher_setkey(tfm->skcipher, key, keylen);
+	tfm->has_key = !err;
+
+	return err;
 }
 
 static void skcipher_wait(struct sock *sk)
@@ -792,20 +821,25 @@ static int skcipher_accept_parent(void *private, struct sock *sk)
 {
 	struct skcipher_ctx *ctx;
 	struct alg_sock *ask = alg_sk(sk);
-	unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);
+	struct skcipher_tfm *tfm = private;
+	struct crypto_skcipher *skcipher = tfm->skcipher;
+	unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);
+
+	if (!tfm->has_key)
+		return -ENOKEY;
 
 	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
 	if (!ctx)
 		return -ENOMEM;
 
-	ctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),
+	ctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),
 			       GFP_KERNEL);
 	if (!ctx->iv) {
 		sock_kfree_s(sk, ctx, len);
 		return -ENOMEM;
 	}
 
-	memset(ctx->iv, 0, crypto_skcipher_ivsize(private));
+	memset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));
 
 	INIT_LIST_HEAD(&ctx->tsgl);
 	ctx->len = len;
@@ -818,7 +852,7 @@ static int skcipher_accept_parent(void *private, struct sock *sk)
 
 	ask->private = ctx;
 
-	skcipher_request_set_tfm(&ctx->req, private);
+	skcipher_request_set_tfm(&ctx->req, skcipher);
 	skcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
 				      af_alg_complete, &ctx->completion);
 ",linux,dd504589577d8e8e70f51f997ad487a4cb6c026f,c597b6bcd5c624534afc3df65cdc42bb05173bca,1,"static int skcipher_accept_parent(void *private, struct sock *sk)
 {
 	struct skcipher_ctx *ctx;
 	struct alg_sock *ask = alg_sk(sk);
//flaw_line_below:
	unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);
//fix_flaw_line_below:
//	struct skcipher_tfm *tfm = private;
//fix_flaw_line_below:
//	struct crypto_skcipher *skcipher = tfm->skcipher;
//fix_flaw_line_below:
//	unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (!tfm->has_key)
//fix_flaw_line_below:
//		return -ENOKEY;
 
 	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
 	if (!ctx)
 		return -ENOMEM;
 
//flaw_line_below:
	ctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),
//fix_flaw_line_below:
//	ctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),
 			       GFP_KERNEL);
 	if (!ctx->iv) {
 		sock_kfree_s(sk, ctx, len);
 		return -ENOMEM;
 	}
 
//flaw_line_below:
	memset(ctx->iv, 0, crypto_skcipher_ivsize(private));
//fix_flaw_line_below:
//	memset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));
 
 	INIT_LIST_HEAD(&ctx->tsgl);
 	ctx->len = len;
	ctx->used = 0;
	ctx->more = 0;
	ctx->merge = 0;
	ctx->enc = 0;
	atomic_set(&ctx->inflight, 0);
	af_alg_init_completion(&ctx->completion);
 
 	ask->private = ctx;
 
//flaw_line_below:
	skcipher_request_set_tfm(&ctx->req, private);
//fix_flaw_line_below:
//	skcipher_request_set_tfm(&ctx->req, skcipher);
 	skcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
 				      af_alg_complete, &ctx->completion);
 
	sk->sk_destruct = skcipher_sock_destruct;

	return 0;
}
"
2891,180627,,Local,Not required,Complete,CVE-2015-8970,https://www.cvedetails.com/cve/CVE-2015-8970/,CWE-476,Low,,,,2016-11-27,4.9,"crypto/algif_skcipher.c in the Linux kernel before 4.4.2 does not verify that a setkey operation has been performed on an AF_ALG socket before an accept system call is processed, which allows local users to cause a denial of service (NULL pointer dereference and system crash) via a crafted application that does not supply a key, related to the lrw_crypt function in crypto/lrw.c.",2018-08-13,DoS ,16,https://github.com/torvalds/linux/commit/dd504589577d8e8e70f51f997ad487a4cb6c026f,dd504589577d8e8e70f51f997ad487a4cb6c026f,"crypto: algif_skcipher - Require setkey before accept(2)

Some cipher implementations will crash if you try to use them
without calling setkey first.  This patch adds a check so that
the accept(2) call will fail with -ENOKEY if setkey hasn't been
done on the socket yet.

Cc: stable@vger.kernel.org
Reported-by: Dmitry Vyukov <dvyukov@google.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
Tested-by: Dmitry Vyukov <dvyukov@google.com>",1,crypto/algif_skcipher.c,"{""sha"": ""f4431bc1ce430203b374ae757e627d808c6f17a4"", ""filename"": ""crypto/algif_skcipher.c"", ""status"": ""modified"", ""additions"": 41, ""deletions"": 7, ""changes"": 48, ""blob_url"": ""https://github.com/torvalds/linux/blob/dd504589577d8e8e70f51f997ad487a4cb6c026f/crypto/algif_skcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/dd504589577d8e8e70f51f997ad487a4cb6c026f/crypto/algif_skcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/algif_skcipher.c?ref=dd504589577d8e8e70f51f997ad487a4cb6c026f"", ""patch"": ""@@ -31,6 +31,11 @@ struct skcipher_sg_list {\n \tstruct scatterlist sg[0];\n };\n \n+struct skcipher_tfm {\n+\tstruct crypto_skcipher *skcipher;\n+\tbool has_key;\n+};\n+\n struct skcipher_ctx {\n \tstruct list_head tsgl;\n \tstruct af_alg_sgl rsgl;\n@@ -750,17 +755,41 @@ static struct proto_ops algif_skcipher_ops = {\n \n static void *skcipher_bind(const char *name, u32 type, u32 mask)\n {\n-\treturn crypto_alloc_skcipher(name, type, mask);\n+\tstruct skcipher_tfm *tfm;\n+\tstruct crypto_skcipher *skcipher;\n+\n+\ttfm = kzalloc(sizeof(*tfm), GFP_KERNEL);\n+\tif (!tfm)\n+\t\treturn ERR_PTR(-ENOMEM);\n+\n+\tskcipher = crypto_alloc_skcipher(name, type, mask);\n+\tif (IS_ERR(skcipher)) {\n+\t\tkfree(tfm);\n+\t\treturn ERR_CAST(skcipher);\n+\t}\n+\n+\ttfm->skcipher = skcipher;\n+\n+\treturn tfm;\n }\n \n static void skcipher_release(void *private)\n {\n-\tcrypto_free_skcipher(private);\n+\tstruct skcipher_tfm *tfm = private;\n+\n+\tcrypto_free_skcipher(tfm->skcipher);\n+\tkfree(tfm);\n }\n \n static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\n {\n-\treturn crypto_skcipher_setkey(private, key, keylen);\n+\tstruct skcipher_tfm *tfm = private;\n+\tint err;\n+\n+\terr = crypto_skcipher_setkey(tfm->skcipher, key, keylen);\n+\ttfm->has_key = !err;\n+\n+\treturn err;\n }\n \n static void skcipher_wait(struct sock *sk)\n@@ -792,20 +821,25 @@ static int skcipher_accept_parent(void *private, struct sock *sk)\n {\n \tstruct skcipher_ctx *ctx;\n \tstruct alg_sock *ask = alg_sk(sk);\n-\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);\n+\tstruct skcipher_tfm *tfm = private;\n+\tstruct crypto_skcipher *skcipher = tfm->skcipher;\n+\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);\n+\n+\tif (!tfm->has_key)\n+\t\treturn -ENOKEY;\n \n \tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n \tif (!ctx)\n \t\treturn -ENOMEM;\n \n-\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),\n+\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),\n \t\t\t       GFP_KERNEL);\n \tif (!ctx->iv) {\n \t\tsock_kfree_s(sk, ctx, len);\n \t\treturn -ENOMEM;\n \t}\n \n-\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(private));\n+\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));\n \n \tINIT_LIST_HEAD(&ctx->tsgl);\n \tctx->len = len;\n@@ -818,7 +852,7 @@ static int skcipher_accept_parent(void *private, struct sock *sk)\n \n \task->private = ctx;\n \n-\tskcipher_request_set_tfm(&ctx->req, private);\n+\tskcipher_request_set_tfm(&ctx->req, skcipher);\n \tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n \t\t\t\t      af_alg_complete, &ctx->completion);\n ""}"," static void *skcipher_bind(const char *name, u32 type, u32 mask)
 {
	struct skcipher_tfm *tfm;
	struct crypto_skcipher *skcipher;

	tfm = kzalloc(sizeof(*tfm), GFP_KERNEL);
	if (!tfm)
		return ERR_PTR(-ENOMEM);

	skcipher = crypto_alloc_skcipher(name, type, mask);
	if (IS_ERR(skcipher)) {
		kfree(tfm);
		return ERR_CAST(skcipher);
	}

	tfm->skcipher = skcipher;

	return tfm;
 }
"," static void *skcipher_bind(const char *name, u32 type, u32 mask)
 {
	return crypto_alloc_skcipher(name, type, mask);
 }
",C,"	struct skcipher_tfm *tfm;
	struct crypto_skcipher *skcipher;

	tfm = kzalloc(sizeof(*tfm), GFP_KERNEL);
	if (!tfm)
		return ERR_PTR(-ENOMEM);

	skcipher = crypto_alloc_skcipher(name, type, mask);
	if (IS_ERR(skcipher)) {
		kfree(tfm);
		return ERR_CAST(skcipher);
	}

	tfm->skcipher = skcipher;

	return tfm;
","	return crypto_alloc_skcipher(name, type, mask);
",,"@@ -31,6 +31,11 @@ struct skcipher_sg_list {
 	struct scatterlist sg[0];
 };
 
+struct skcipher_tfm {
+	struct crypto_skcipher *skcipher;
+	bool has_key;
+};
+
 struct skcipher_ctx {
 	struct list_head tsgl;
 	struct af_alg_sgl rsgl;
@@ -750,17 +755,41 @@ static struct proto_ops algif_skcipher_ops = {
 
 static void *skcipher_bind(const char *name, u32 type, u32 mask)
 {
-	return crypto_alloc_skcipher(name, type, mask);
+	struct skcipher_tfm *tfm;
+	struct crypto_skcipher *skcipher;
+
+	tfm = kzalloc(sizeof(*tfm), GFP_KERNEL);
+	if (!tfm)
+		return ERR_PTR(-ENOMEM);
+
+	skcipher = crypto_alloc_skcipher(name, type, mask);
+	if (IS_ERR(skcipher)) {
+		kfree(tfm);
+		return ERR_CAST(skcipher);
+	}
+
+	tfm->skcipher = skcipher;
+
+	return tfm;
 }
 
 static void skcipher_release(void *private)
 {
-	crypto_free_skcipher(private);
+	struct skcipher_tfm *tfm = private;
+
+	crypto_free_skcipher(tfm->skcipher);
+	kfree(tfm);
 }
 
 static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
 {
-	return crypto_skcipher_setkey(private, key, keylen);
+	struct skcipher_tfm *tfm = private;
+	int err;
+
+	err = crypto_skcipher_setkey(tfm->skcipher, key, keylen);
+	tfm->has_key = !err;
+
+	return err;
 }
 
 static void skcipher_wait(struct sock *sk)
@@ -792,20 +821,25 @@ static int skcipher_accept_parent(void *private, struct sock *sk)
 {
 	struct skcipher_ctx *ctx;
 	struct alg_sock *ask = alg_sk(sk);
-	unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);
+	struct skcipher_tfm *tfm = private;
+	struct crypto_skcipher *skcipher = tfm->skcipher;
+	unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);
+
+	if (!tfm->has_key)
+		return -ENOKEY;
 
 	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
 	if (!ctx)
 		return -ENOMEM;
 
-	ctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),
+	ctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),
 			       GFP_KERNEL);
 	if (!ctx->iv) {
 		sock_kfree_s(sk, ctx, len);
 		return -ENOMEM;
 	}
 
-	memset(ctx->iv, 0, crypto_skcipher_ivsize(private));
+	memset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));
 
 	INIT_LIST_HEAD(&ctx->tsgl);
 	ctx->len = len;
@@ -818,7 +852,7 @@ static int skcipher_accept_parent(void *private, struct sock *sk)
 
 	ask->private = ctx;
 
-	skcipher_request_set_tfm(&ctx->req, private);
+	skcipher_request_set_tfm(&ctx->req, skcipher);
 	skcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
 				      af_alg_complete, &ctx->completion);
 ",linux,dd504589577d8e8e70f51f997ad487a4cb6c026f,c597b6bcd5c624534afc3df65cdc42bb05173bca,1," static void *skcipher_bind(const char *name, u32 type, u32 mask)
 {
//flaw_line_below:
	return crypto_alloc_skcipher(name, type, mask);
//fix_flaw_line_below:
//	struct skcipher_tfm *tfm;
//fix_flaw_line_below:
//	struct crypto_skcipher *skcipher;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	tfm = kzalloc(sizeof(*tfm), GFP_KERNEL);
//fix_flaw_line_below:
//	if (!tfm)
//fix_flaw_line_below:
//		return ERR_PTR(-ENOMEM);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	skcipher = crypto_alloc_skcipher(name, type, mask);
//fix_flaw_line_below:
//	if (IS_ERR(skcipher)) {
//fix_flaw_line_below:
//		kfree(tfm);
//fix_flaw_line_below:
//		return ERR_CAST(skcipher);
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	tfm->skcipher = skcipher;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	return tfm;
 }
"
2892,180628,,Local,Not required,Complete,CVE-2015-8970,https://www.cvedetails.com/cve/CVE-2015-8970/,CWE-476,Low,,,,2016-11-27,4.9,"crypto/algif_skcipher.c in the Linux kernel before 4.4.2 does not verify that a setkey operation has been performed on an AF_ALG socket before an accept system call is processed, which allows local users to cause a denial of service (NULL pointer dereference and system crash) via a crafted application that does not supply a key, related to the lrw_crypt function in crypto/lrw.c.",2018-08-13,DoS ,4,https://github.com/torvalds/linux/commit/dd504589577d8e8e70f51f997ad487a4cb6c026f,dd504589577d8e8e70f51f997ad487a4cb6c026f,"crypto: algif_skcipher - Require setkey before accept(2)

Some cipher implementations will crash if you try to use them
without calling setkey first.  This patch adds a check so that
the accept(2) call will fail with -ENOKEY if setkey hasn't been
done on the socket yet.

Cc: stable@vger.kernel.org
Reported-by: Dmitry Vyukov <dvyukov@google.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
Tested-by: Dmitry Vyukov <dvyukov@google.com>",1,crypto/algif_skcipher.c,"{""sha"": ""f4431bc1ce430203b374ae757e627d808c6f17a4"", ""filename"": ""crypto/algif_skcipher.c"", ""status"": ""modified"", ""additions"": 41, ""deletions"": 7, ""changes"": 48, ""blob_url"": ""https://github.com/torvalds/linux/blob/dd504589577d8e8e70f51f997ad487a4cb6c026f/crypto/algif_skcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/dd504589577d8e8e70f51f997ad487a4cb6c026f/crypto/algif_skcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/algif_skcipher.c?ref=dd504589577d8e8e70f51f997ad487a4cb6c026f"", ""patch"": ""@@ -31,6 +31,11 @@ struct skcipher_sg_list {\n \tstruct scatterlist sg[0];\n };\n \n+struct skcipher_tfm {\n+\tstruct crypto_skcipher *skcipher;\n+\tbool has_key;\n+};\n+\n struct skcipher_ctx {\n \tstruct list_head tsgl;\n \tstruct af_alg_sgl rsgl;\n@@ -750,17 +755,41 @@ static struct proto_ops algif_skcipher_ops = {\n \n static void *skcipher_bind(const char *name, u32 type, u32 mask)\n {\n-\treturn crypto_alloc_skcipher(name, type, mask);\n+\tstruct skcipher_tfm *tfm;\n+\tstruct crypto_skcipher *skcipher;\n+\n+\ttfm = kzalloc(sizeof(*tfm), GFP_KERNEL);\n+\tif (!tfm)\n+\t\treturn ERR_PTR(-ENOMEM);\n+\n+\tskcipher = crypto_alloc_skcipher(name, type, mask);\n+\tif (IS_ERR(skcipher)) {\n+\t\tkfree(tfm);\n+\t\treturn ERR_CAST(skcipher);\n+\t}\n+\n+\ttfm->skcipher = skcipher;\n+\n+\treturn tfm;\n }\n \n static void skcipher_release(void *private)\n {\n-\tcrypto_free_skcipher(private);\n+\tstruct skcipher_tfm *tfm = private;\n+\n+\tcrypto_free_skcipher(tfm->skcipher);\n+\tkfree(tfm);\n }\n \n static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\n {\n-\treturn crypto_skcipher_setkey(private, key, keylen);\n+\tstruct skcipher_tfm *tfm = private;\n+\tint err;\n+\n+\terr = crypto_skcipher_setkey(tfm->skcipher, key, keylen);\n+\ttfm->has_key = !err;\n+\n+\treturn err;\n }\n \n static void skcipher_wait(struct sock *sk)\n@@ -792,20 +821,25 @@ static int skcipher_accept_parent(void *private, struct sock *sk)\n {\n \tstruct skcipher_ctx *ctx;\n \tstruct alg_sock *ask = alg_sk(sk);\n-\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);\n+\tstruct skcipher_tfm *tfm = private;\n+\tstruct crypto_skcipher *skcipher = tfm->skcipher;\n+\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);\n+\n+\tif (!tfm->has_key)\n+\t\treturn -ENOKEY;\n \n \tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n \tif (!ctx)\n \t\treturn -ENOMEM;\n \n-\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),\n+\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),\n \t\t\t       GFP_KERNEL);\n \tif (!ctx->iv) {\n \t\tsock_kfree_s(sk, ctx, len);\n \t\treturn -ENOMEM;\n \t}\n \n-\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(private));\n+\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));\n \n \tINIT_LIST_HEAD(&ctx->tsgl);\n \tctx->len = len;\n@@ -818,7 +852,7 @@ static int skcipher_accept_parent(void *private, struct sock *sk)\n \n \task->private = ctx;\n \n-\tskcipher_request_set_tfm(&ctx->req, private);\n+\tskcipher_request_set_tfm(&ctx->req, skcipher);\n \tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n \t\t\t\t      af_alg_complete, &ctx->completion);\n ""}"," static void skcipher_release(void *private)
 {
	struct skcipher_tfm *tfm = private;

	crypto_free_skcipher(tfm->skcipher);
	kfree(tfm);
 }
"," static void skcipher_release(void *private)
 {
	crypto_free_skcipher(private);
 }
",C,"	struct skcipher_tfm *tfm = private;

	crypto_free_skcipher(tfm->skcipher);
	kfree(tfm);
","	crypto_free_skcipher(private);
",,"@@ -31,6 +31,11 @@ struct skcipher_sg_list {
 	struct scatterlist sg[0];
 };
 
+struct skcipher_tfm {
+	struct crypto_skcipher *skcipher;
+	bool has_key;
+};
+
 struct skcipher_ctx {
 	struct list_head tsgl;
 	struct af_alg_sgl rsgl;
@@ -750,17 +755,41 @@ static struct proto_ops algif_skcipher_ops = {
 
 static void *skcipher_bind(const char *name, u32 type, u32 mask)
 {
-	return crypto_alloc_skcipher(name, type, mask);
+	struct skcipher_tfm *tfm;
+	struct crypto_skcipher *skcipher;
+
+	tfm = kzalloc(sizeof(*tfm), GFP_KERNEL);
+	if (!tfm)
+		return ERR_PTR(-ENOMEM);
+
+	skcipher = crypto_alloc_skcipher(name, type, mask);
+	if (IS_ERR(skcipher)) {
+		kfree(tfm);
+		return ERR_CAST(skcipher);
+	}
+
+	tfm->skcipher = skcipher;
+
+	return tfm;
 }
 
 static void skcipher_release(void *private)
 {
-	crypto_free_skcipher(private);
+	struct skcipher_tfm *tfm = private;
+
+	crypto_free_skcipher(tfm->skcipher);
+	kfree(tfm);
 }
 
 static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
 {
-	return crypto_skcipher_setkey(private, key, keylen);
+	struct skcipher_tfm *tfm = private;
+	int err;
+
+	err = crypto_skcipher_setkey(tfm->skcipher, key, keylen);
+	tfm->has_key = !err;
+
+	return err;
 }
 
 static void skcipher_wait(struct sock *sk)
@@ -792,20 +821,25 @@ static int skcipher_accept_parent(void *private, struct sock *sk)
 {
 	struct skcipher_ctx *ctx;
 	struct alg_sock *ask = alg_sk(sk);
-	unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);
+	struct skcipher_tfm *tfm = private;
+	struct crypto_skcipher *skcipher = tfm->skcipher;
+	unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);
+
+	if (!tfm->has_key)
+		return -ENOKEY;
 
 	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
 	if (!ctx)
 		return -ENOMEM;
 
-	ctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),
+	ctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),
 			       GFP_KERNEL);
 	if (!ctx->iv) {
 		sock_kfree_s(sk, ctx, len);
 		return -ENOMEM;
 	}
 
-	memset(ctx->iv, 0, crypto_skcipher_ivsize(private));
+	memset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));
 
 	INIT_LIST_HEAD(&ctx->tsgl);
 	ctx->len = len;
@@ -818,7 +852,7 @@ static int skcipher_accept_parent(void *private, struct sock *sk)
 
 	ask->private = ctx;
 
-	skcipher_request_set_tfm(&ctx->req, private);
+	skcipher_request_set_tfm(&ctx->req, skcipher);
 	skcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
 				      af_alg_complete, &ctx->completion);
 ",linux,dd504589577d8e8e70f51f997ad487a4cb6c026f,c597b6bcd5c624534afc3df65cdc42bb05173bca,1," static void skcipher_release(void *private)
 {
//flaw_line_below:
	crypto_free_skcipher(private);
//fix_flaw_line_below:
//	struct skcipher_tfm *tfm = private;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	crypto_free_skcipher(tfm->skcipher);
//fix_flaw_line_below:
//	kfree(tfm);
 }
"
2893,180629,,Local,Not required,Complete,CVE-2015-8970,https://www.cvedetails.com/cve/CVE-2015-8970/,CWE-476,Low,,,,2016-11-27,4.9,"crypto/algif_skcipher.c in the Linux kernel before 4.4.2 does not verify that a setkey operation has been performed on an AF_ALG socket before an accept system call is processed, which allows local users to cause a denial of service (NULL pointer dereference and system crash) via a crafted application that does not supply a key, related to the lrw_crypt function in crypto/lrw.c.",2018-08-13,DoS ,7,https://github.com/torvalds/linux/commit/dd504589577d8e8e70f51f997ad487a4cb6c026f,dd504589577d8e8e70f51f997ad487a4cb6c026f,"crypto: algif_skcipher - Require setkey before accept(2)

Some cipher implementations will crash if you try to use them
without calling setkey first.  This patch adds a check so that
the accept(2) call will fail with -ENOKEY if setkey hasn't been
done on the socket yet.

Cc: stable@vger.kernel.org
Reported-by: Dmitry Vyukov <dvyukov@google.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
Tested-by: Dmitry Vyukov <dvyukov@google.com>",1,crypto/algif_skcipher.c,"{""sha"": ""f4431bc1ce430203b374ae757e627d808c6f17a4"", ""filename"": ""crypto/algif_skcipher.c"", ""status"": ""modified"", ""additions"": 41, ""deletions"": 7, ""changes"": 48, ""blob_url"": ""https://github.com/torvalds/linux/blob/dd504589577d8e8e70f51f997ad487a4cb6c026f/crypto/algif_skcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/dd504589577d8e8e70f51f997ad487a4cb6c026f/crypto/algif_skcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/algif_skcipher.c?ref=dd504589577d8e8e70f51f997ad487a4cb6c026f"", ""patch"": ""@@ -31,6 +31,11 @@ struct skcipher_sg_list {\n \tstruct scatterlist sg[0];\n };\n \n+struct skcipher_tfm {\n+\tstruct crypto_skcipher *skcipher;\n+\tbool has_key;\n+};\n+\n struct skcipher_ctx {\n \tstruct list_head tsgl;\n \tstruct af_alg_sgl rsgl;\n@@ -750,17 +755,41 @@ static struct proto_ops algif_skcipher_ops = {\n \n static void *skcipher_bind(const char *name, u32 type, u32 mask)\n {\n-\treturn crypto_alloc_skcipher(name, type, mask);\n+\tstruct skcipher_tfm *tfm;\n+\tstruct crypto_skcipher *skcipher;\n+\n+\ttfm = kzalloc(sizeof(*tfm), GFP_KERNEL);\n+\tif (!tfm)\n+\t\treturn ERR_PTR(-ENOMEM);\n+\n+\tskcipher = crypto_alloc_skcipher(name, type, mask);\n+\tif (IS_ERR(skcipher)) {\n+\t\tkfree(tfm);\n+\t\treturn ERR_CAST(skcipher);\n+\t}\n+\n+\ttfm->skcipher = skcipher;\n+\n+\treturn tfm;\n }\n \n static void skcipher_release(void *private)\n {\n-\tcrypto_free_skcipher(private);\n+\tstruct skcipher_tfm *tfm = private;\n+\n+\tcrypto_free_skcipher(tfm->skcipher);\n+\tkfree(tfm);\n }\n \n static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\n {\n-\treturn crypto_skcipher_setkey(private, key, keylen);\n+\tstruct skcipher_tfm *tfm = private;\n+\tint err;\n+\n+\terr = crypto_skcipher_setkey(tfm->skcipher, key, keylen);\n+\ttfm->has_key = !err;\n+\n+\treturn err;\n }\n \n static void skcipher_wait(struct sock *sk)\n@@ -792,20 +821,25 @@ static int skcipher_accept_parent(void *private, struct sock *sk)\n {\n \tstruct skcipher_ctx *ctx;\n \tstruct alg_sock *ask = alg_sk(sk);\n-\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);\n+\tstruct skcipher_tfm *tfm = private;\n+\tstruct crypto_skcipher *skcipher = tfm->skcipher;\n+\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);\n+\n+\tif (!tfm->has_key)\n+\t\treturn -ENOKEY;\n \n \tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n \tif (!ctx)\n \t\treturn -ENOMEM;\n \n-\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),\n+\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),\n \t\t\t       GFP_KERNEL);\n \tif (!ctx->iv) {\n \t\tsock_kfree_s(sk, ctx, len);\n \t\treturn -ENOMEM;\n \t}\n \n-\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(private));\n+\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));\n \n \tINIT_LIST_HEAD(&ctx->tsgl);\n \tctx->len = len;\n@@ -818,7 +852,7 @@ static int skcipher_accept_parent(void *private, struct sock *sk)\n \n \task->private = ctx;\n \n-\tskcipher_request_set_tfm(&ctx->req, private);\n+\tskcipher_request_set_tfm(&ctx->req, skcipher);\n \tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n \t\t\t\t      af_alg_complete, &ctx->completion);\n ""}"," static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
 {
	struct skcipher_tfm *tfm = private;
	int err;

	err = crypto_skcipher_setkey(tfm->skcipher, key, keylen);
	tfm->has_key = !err;

	return err;
 }
"," static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
 {
	return crypto_skcipher_setkey(private, key, keylen);
 }
",C,"	struct skcipher_tfm *tfm = private;
	int err;

	err = crypto_skcipher_setkey(tfm->skcipher, key, keylen);
	tfm->has_key = !err;

	return err;
","	return crypto_skcipher_setkey(private, key, keylen);
",,"@@ -31,6 +31,11 @@ struct skcipher_sg_list {
 	struct scatterlist sg[0];
 };
 
+struct skcipher_tfm {
+	struct crypto_skcipher *skcipher;
+	bool has_key;
+};
+
 struct skcipher_ctx {
 	struct list_head tsgl;
 	struct af_alg_sgl rsgl;
@@ -750,17 +755,41 @@ static struct proto_ops algif_skcipher_ops = {
 
 static void *skcipher_bind(const char *name, u32 type, u32 mask)
 {
-	return crypto_alloc_skcipher(name, type, mask);
+	struct skcipher_tfm *tfm;
+	struct crypto_skcipher *skcipher;
+
+	tfm = kzalloc(sizeof(*tfm), GFP_KERNEL);
+	if (!tfm)
+		return ERR_PTR(-ENOMEM);
+
+	skcipher = crypto_alloc_skcipher(name, type, mask);
+	if (IS_ERR(skcipher)) {
+		kfree(tfm);
+		return ERR_CAST(skcipher);
+	}
+
+	tfm->skcipher = skcipher;
+
+	return tfm;
 }
 
 static void skcipher_release(void *private)
 {
-	crypto_free_skcipher(private);
+	struct skcipher_tfm *tfm = private;
+
+	crypto_free_skcipher(tfm->skcipher);
+	kfree(tfm);
 }
 
 static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
 {
-	return crypto_skcipher_setkey(private, key, keylen);
+	struct skcipher_tfm *tfm = private;
+	int err;
+
+	err = crypto_skcipher_setkey(tfm->skcipher, key, keylen);
+	tfm->has_key = !err;
+
+	return err;
 }
 
 static void skcipher_wait(struct sock *sk)
@@ -792,20 +821,25 @@ static int skcipher_accept_parent(void *private, struct sock *sk)
 {
 	struct skcipher_ctx *ctx;
 	struct alg_sock *ask = alg_sk(sk);
-	unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);
+	struct skcipher_tfm *tfm = private;
+	struct crypto_skcipher *skcipher = tfm->skcipher;
+	unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);
+
+	if (!tfm->has_key)
+		return -ENOKEY;
 
 	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
 	if (!ctx)
 		return -ENOMEM;
 
-	ctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),
+	ctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),
 			       GFP_KERNEL);
 	if (!ctx->iv) {
 		sock_kfree_s(sk, ctx, len);
 		return -ENOMEM;
 	}
 
-	memset(ctx->iv, 0, crypto_skcipher_ivsize(private));
+	memset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));
 
 	INIT_LIST_HEAD(&ctx->tsgl);
 	ctx->len = len;
@@ -818,7 +852,7 @@ static int skcipher_accept_parent(void *private, struct sock *sk)
 
 	ask->private = ctx;
 
-	skcipher_request_set_tfm(&ctx->req, private);
+	skcipher_request_set_tfm(&ctx->req, skcipher);
 	skcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
 				      af_alg_complete, &ctx->completion);
 ",linux,dd504589577d8e8e70f51f997ad487a4cb6c026f,c597b6bcd5c624534afc3df65cdc42bb05173bca,1," static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
 {
//flaw_line_below:
	return crypto_skcipher_setkey(private, key, keylen);
//fix_flaw_line_below:
//	struct skcipher_tfm *tfm = private;
//fix_flaw_line_below:
//	int err;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	err = crypto_skcipher_setkey(tfm->skcipher, key, keylen);
//fix_flaw_line_below:
//	tfm->has_key = !err;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	return err;
 }
"
2902,180638,,Local,Not required,Partial,CVE-2015-8956,https://www.cvedetails.com/cve/CVE-2015-8956/,CWE-476,Low,Partial,,,2016-10-10,3.6,The rfcomm_sock_bind function in net/bluetooth/rfcomm/sock.c in the Linux kernel before 4.2 allows local users to obtain sensitive information or cause a denial of service (NULL pointer dereference) via vectors involving a bind system call on a Bluetooth RFCOMM socket.,2018-01-04,DoS +Info ,12,https://github.com/torvalds/linux/commit/951b6a0717db97ce420547222647bcc40bf1eacd,951b6a0717db97ce420547222647bcc40bf1eacd,"Bluetooth: Fix potential NULL dereference in RFCOMM bind callback

addr can be NULL and it should not be dereferenced before NULL checking.

Signed-off-by: Jaganath Kanakkassery <jaganath.k@samsung.com>
Signed-off-by: Marcel Holtmann <marcel@holtmann.org>",7,net/bluetooth/rfcomm/sock.c,"{""sha"": ""7511df72347f303f3342b8d8243581f327ecd068"", ""filename"": ""net/bluetooth/rfcomm/sock.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 8, ""changes"": 20, ""blob_url"": ""https://github.com/torvalds/linux/blob/951b6a0717db97ce420547222647bcc40bf1eacd/net/bluetooth/rfcomm/sock.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/951b6a0717db97ce420547222647bcc40bf1eacd/net/bluetooth/rfcomm/sock.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/bluetooth/rfcomm/sock.c?ref=951b6a0717db97ce420547222647bcc40bf1eacd"", ""patch"": ""@@ -334,16 +334,19 @@ static int rfcomm_sock_create(struct net *net, struct socket *sock,\n \n static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n {\n-\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n+\tstruct sockaddr_rc sa;\n \tstruct sock *sk = sock->sk;\n-\tint chan = sa->rc_channel;\n-\tint err = 0;\n-\n-\tBT_DBG(\""sk %p %pMR\"", sk, &sa->rc_bdaddr);\n+\tint len, err = 0;\n \n \tif (!addr || addr->sa_family != AF_BLUETOOTH)\n \t\treturn -EINVAL;\n \n+\tmemset(&sa, 0, sizeof(sa));\n+\tlen = min_t(unsigned int, sizeof(sa), addr_len);\n+\tmemcpy(&sa, addr, len);\n+\n+\tBT_DBG(\""sk %p %pMR\"", sk, &sa.rc_bdaddr);\n+\n \tlock_sock(sk);\n \n \tif (sk->sk_state != BT_OPEN) {\n@@ -358,12 +361,13 @@ static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr\n \n \twrite_lock(&rfcomm_sk_list.lock);\n \n-\tif (chan && __rfcomm_get_listen_sock_by_addr(chan, &sa->rc_bdaddr)) {\n+\tif (sa.rc_channel &&\n+\t    __rfcomm_get_listen_sock_by_addr(sa.rc_channel, &sa.rc_bdaddr)) {\n \t\terr = -EADDRINUSE;\n \t} else {\n \t\t/* Save source address */\n-\t\tbacpy(&rfcomm_pi(sk)->src, &sa->rc_bdaddr);\n-\t\trfcomm_pi(sk)->channel = chan;\n+\t\tbacpy(&rfcomm_pi(sk)->src, &sa.rc_bdaddr);\n+\t\trfcomm_pi(sk)->channel = sa.rc_channel;\n \t\tsk->sk_state = BT_BOUND;\n \t}\n ""}"," static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)
 {
	struct sockaddr_rc sa;
 	struct sock *sk = sock->sk;
	int len, err = 0;
 
 	if (!addr || addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
	memset(&sa, 0, sizeof(sa));
	len = min_t(unsigned int, sizeof(sa), addr_len);
	memcpy(&sa, addr, len);

	BT_DBG(""sk %p %pMR"", sk, &sa.rc_bdaddr);

 	lock_sock(sk);
 
 	if (sk->sk_state != BT_OPEN) {
		err = -EBADFD;
		goto done;
	}

	if (sk->sk_type != SOCK_STREAM) {
		err = -EINVAL;
		goto done;
	}
 
 	write_lock(&rfcomm_sk_list.lock);
 
	if (sa.rc_channel &&
	    __rfcomm_get_listen_sock_by_addr(sa.rc_channel, &sa.rc_bdaddr)) {
 		err = -EADDRINUSE;
 	} else {
 		/* Save source address */
		bacpy(&rfcomm_pi(sk)->src, &sa.rc_bdaddr);
		rfcomm_pi(sk)->channel = sa.rc_channel;
 		sk->sk_state = BT_BOUND;
 	}
 
	write_unlock(&rfcomm_sk_list.lock);

done:
	release_sock(sk);
	return err;
}
"," static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)
 {
	struct sockaddr_rc *sa = (struct sockaddr_rc *) addr;
 	struct sock *sk = sock->sk;
	int chan = sa->rc_channel;
	int err = 0;
	BT_DBG(""sk %p %pMR"", sk, &sa->rc_bdaddr);
 
 	if (!addr || addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
 	lock_sock(sk);
 
 	if (sk->sk_state != BT_OPEN) {
		err = -EBADFD;
		goto done;
	}

	if (sk->sk_type != SOCK_STREAM) {
		err = -EINVAL;
		goto done;
	}
 
 	write_lock(&rfcomm_sk_list.lock);
 
	if (chan && __rfcomm_get_listen_sock_by_addr(chan, &sa->rc_bdaddr)) {
 		err = -EADDRINUSE;
 	} else {
 		/* Save source address */
		bacpy(&rfcomm_pi(sk)->src, &sa->rc_bdaddr);
		rfcomm_pi(sk)->channel = chan;
 		sk->sk_state = BT_BOUND;
 	}
 
	write_unlock(&rfcomm_sk_list.lock);

done:
	release_sock(sk);
	return err;
}
",C,"	struct sockaddr_rc sa;
	int len, err = 0;
	memset(&sa, 0, sizeof(sa));
	len = min_t(unsigned int, sizeof(sa), addr_len);
	memcpy(&sa, addr, len);

	BT_DBG(""sk %p %pMR"", sk, &sa.rc_bdaddr);

	if (sa.rc_channel &&
	    __rfcomm_get_listen_sock_by_addr(sa.rc_channel, &sa.rc_bdaddr)) {
		bacpy(&rfcomm_pi(sk)->src, &sa.rc_bdaddr);
		rfcomm_pi(sk)->channel = sa.rc_channel;
","	struct sockaddr_rc *sa = (struct sockaddr_rc *) addr;
	int chan = sa->rc_channel;
	int err = 0;
	BT_DBG(""sk %p %pMR"", sk, &sa->rc_bdaddr);
	if (chan && __rfcomm_get_listen_sock_by_addr(chan, &sa->rc_bdaddr)) {
		bacpy(&rfcomm_pi(sk)->src, &sa->rc_bdaddr);
		rfcomm_pi(sk)->channel = chan;
",,"@@ -334,16 +334,19 @@ static int rfcomm_sock_create(struct net *net, struct socket *sock,
 
 static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)
 {
-	struct sockaddr_rc *sa = (struct sockaddr_rc *) addr;
+	struct sockaddr_rc sa;
 	struct sock *sk = sock->sk;
-	int chan = sa->rc_channel;
-	int err = 0;
-
-	BT_DBG(""sk %p %pMR"", sk, &sa->rc_bdaddr);
+	int len, err = 0;
 
 	if (!addr || addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
+	memset(&sa, 0, sizeof(sa));
+	len = min_t(unsigned int, sizeof(sa), addr_len);
+	memcpy(&sa, addr, len);
+
+	BT_DBG(""sk %p %pMR"", sk, &sa.rc_bdaddr);
+
 	lock_sock(sk);
 
 	if (sk->sk_state != BT_OPEN) {
@@ -358,12 +361,13 @@ static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr
 
 	write_lock(&rfcomm_sk_list.lock);
 
-	if (chan && __rfcomm_get_listen_sock_by_addr(chan, &sa->rc_bdaddr)) {
+	if (sa.rc_channel &&
+	    __rfcomm_get_listen_sock_by_addr(sa.rc_channel, &sa.rc_bdaddr)) {
 		err = -EADDRINUSE;
 	} else {
 		/* Save source address */
-		bacpy(&rfcomm_pi(sk)->src, &sa->rc_bdaddr);
-		rfcomm_pi(sk)->channel = chan;
+		bacpy(&rfcomm_pi(sk)->src, &sa.rc_bdaddr);
+		rfcomm_pi(sk)->channel = sa.rc_channel;
 		sk->sk_state = BT_BOUND;
 	}
 ",linux,951b6a0717db97ce420547222647bcc40bf1eacd,6be09b48ae8bcce8426877b5f89e6218ffb657b0,1," static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)
 {
//flaw_line_below:
	struct sockaddr_rc *sa = (struct sockaddr_rc *) addr;
//fix_flaw_line_below:
//	struct sockaddr_rc sa;
 	struct sock *sk = sock->sk;
//flaw_line_below:
	int chan = sa->rc_channel;
//flaw_line_below:
	int err = 0;
//flaw_line_below:

//flaw_line_below:
	BT_DBG(""sk %p %pMR"", sk, &sa->rc_bdaddr);
//fix_flaw_line_below:
//	int len, err = 0;
 
 	if (!addr || addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
//fix_flaw_line_below:
//	memset(&sa, 0, sizeof(sa));
//fix_flaw_line_below:
//	len = min_t(unsigned int, sizeof(sa), addr_len);
//fix_flaw_line_below:
//	memcpy(&sa, addr, len);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	BT_DBG(""sk %p %pMR"", sk, &sa.rc_bdaddr);
//fix_flaw_line_below:
//
 	lock_sock(sk);
 
 	if (sk->sk_state != BT_OPEN) {
		err = -EBADFD;
		goto done;
	}

	if (sk->sk_type != SOCK_STREAM) {
		err = -EINVAL;
		goto done;
	}
 
 	write_lock(&rfcomm_sk_list.lock);
 
//flaw_line_below:
	if (chan && __rfcomm_get_listen_sock_by_addr(chan, &sa->rc_bdaddr)) {
//fix_flaw_line_below:
//	if (sa.rc_channel &&
//fix_flaw_line_below:
//	    __rfcomm_get_listen_sock_by_addr(sa.rc_channel, &sa.rc_bdaddr)) {
 		err = -EADDRINUSE;
 	} else {
 		/* Save source address */
//flaw_line_below:
		bacpy(&rfcomm_pi(sk)->src, &sa->rc_bdaddr);
//flaw_line_below:
		rfcomm_pi(sk)->channel = chan;
//fix_flaw_line_below:
//		bacpy(&rfcomm_pi(sk)->src, &sa.rc_bdaddr);
//fix_flaw_line_below:
//		rfcomm_pi(sk)->channel = sa.rc_channel;
 		sk->sk_state = BT_BOUND;
 	}
 
	write_unlock(&rfcomm_sk_list.lock);

done:
	release_sock(sk);
	return err;
}
"
3035,180771,,Remote,Not required,Partial,CVE-2013-4119,https://www.cvedetails.com/cve/CVE-2013-4119/,CWE-476,Low,,,,2016-10-03,5.0,FreeRDP before 1.1.0-beta+2013071101 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by disconnecting before authentication has finished.,2016-10-04,DoS ,1,https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53,0773bb9303d24473fe1185d85a424dfe159aff53,"nla: invalidate sec handle after creation

If sec pointer isn't invalidated after creation it is not possible
to check if the upper and lower pointers are valid.

This fixes a segfault in the server part if the client disconnects before
the authentication was finished.",0,libfreerdp/core/nla.c,"{""sha"": ""875c0ae7351a6e8a1161e0fa380329d74b38eba9"", ""filename"": ""libfreerdp/core/nla.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/nla.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/nla.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/nla.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -1245,6 +1245,7 @@ rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings*\n \t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n \t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n \t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n+\t\tSecInvalidateHandle(&credssp->context);\n \n \t\tif (credssp->server)\n \t\t{""}<_**next**_>{""sha"": ""eb4ad60eaa6ae2b08e91858e1147db87fd30362e"", ""filename"": ""libfreerdp/core/peer.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/peer.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/peer.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/peer.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -272,6 +272,7 @@ static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n \t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n \t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n \t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n+\t\t\t\trdp->nego->transport->credssp = NULL;\n \t\t\t}\n \t\t\telse\n \t\t\t{""}<_**next**_>{""sha"": ""4afec5a12d69ac0dc1430afb6af9058b7d2edc53"", ""filename"": ""libfreerdp/core/transport.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/transport.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/transport.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/transport.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -159,6 +159,7 @@ BOOL transport_connect_nla(rdpTransport* transport)\n \t\t\t\""If credentials are valid, the NTLMSSP implementation may be to blame.\\n\"");\n \n \t\tcredssp_free(transport->credssp);\n+\t\ttransport->credssp = NULL;\n \t\treturn FALSE;\n \t}\n \n@@ -292,6 +293,7 @@ BOOL transport_accept_nla(rdpTransport* transport)\n \t{\n \t\tfprintf(stderr, \""client authentication failure\\n\"");\n \t\tcredssp_free(transport->credssp);\n+\t\ttransport->credssp = NULL;\n \t\treturn FALSE;\n \t}\n ""}<_**next**_>{""sha"": ""96c9599958269b4d937d10829623068d0303d2f4"", ""filename"": ""winpr/libwinpr/sspi/sspi.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/winpr/libwinpr/sspi/sspi.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/winpr/libwinpr/sspi/sspi.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/winpr/libwinpr/sspi/sspi.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -248,7 +248,7 @@ void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n-\tif (!handle)\n+\tif (!handle || !SecIsValidHandle(handle))\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwLower);\n@@ -268,7 +268,7 @@ void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n-\tif (!handle)\n+\tif (!handle || !SecIsValidHandle(handle))\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwUpper);\n@@ -839,7 +839,7 @@ SECURITY_STATUS SEC_ENTRY CompleteAuthToken(PCtxtHandle phContext, PSecBufferDes\n \n SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n {\n-\tchar* Name;\n+\tchar* Name = NULL;\n \tSECURITY_STATUS status;\n \tSecurityFunctionTableA* table;\n ""}","rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings)
{
	rdpCredssp* credssp;

	credssp = (rdpCredssp*) malloc(sizeof(rdpCredssp));
	ZeroMemory(credssp, sizeof(rdpCredssp));

	if (credssp != NULL)
	{
		HKEY hKey;
		LONG status;
		DWORD dwType;
		DWORD dwSize;

		credssp->instance = instance;
		credssp->settings = settings;
		credssp->server = settings->ServerMode;
		credssp->transport = transport;
		credssp->send_seq_num = 0;
		credssp->recv_seq_num = 0;
 		ZeroMemory(&credssp->negoToken, sizeof(SecBuffer));
 		ZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));
 		ZeroMemory(&credssp->authInfo, sizeof(SecBuffer));
		SecInvalidateHandle(&credssp->context);
 
 		if (credssp->server)
 		{
			status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(""Software\\FreeRDP\\Server""),
					0, KEY_READ | KEY_WOW64_64KEY, &hKey);

			if (status == ERROR_SUCCESS)
			{
				status = RegQueryValueEx(hKey, _T(""SspiModule""), NULL, &dwType, NULL, &dwSize);

				if (status == ERROR_SUCCESS)
				{
					credssp->SspiModule = (LPTSTR) malloc(dwSize + sizeof(TCHAR));

					status = RegQueryValueEx(hKey, _T(""SspiModule""), NULL, &dwType,
							(BYTE*) credssp->SspiModule, &dwSize);

					if (status == ERROR_SUCCESS)
					{
						_tprintf(_T(""Using SSPI Module: %s\n""), credssp->SspiModule);
						RegCloseKey(hKey);
					}
				}
			}
		}
	}

	return credssp;
}
","rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings)
{
	rdpCredssp* credssp;

	credssp = (rdpCredssp*) malloc(sizeof(rdpCredssp));
	ZeroMemory(credssp, sizeof(rdpCredssp));

	if (credssp != NULL)
	{
		HKEY hKey;
		LONG status;
		DWORD dwType;
		DWORD dwSize;

		credssp->instance = instance;
		credssp->settings = settings;
		credssp->server = settings->ServerMode;
		credssp->transport = transport;
		credssp->send_seq_num = 0;
		credssp->recv_seq_num = 0;
 		ZeroMemory(&credssp->negoToken, sizeof(SecBuffer));
 		ZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));
 		ZeroMemory(&credssp->authInfo, sizeof(SecBuffer));
 
 		if (credssp->server)
 		{
			status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(""Software\\FreeRDP\\Server""),
					0, KEY_READ | KEY_WOW64_64KEY, &hKey);

			if (status == ERROR_SUCCESS)
			{
				status = RegQueryValueEx(hKey, _T(""SspiModule""), NULL, &dwType, NULL, &dwSize);

				if (status == ERROR_SUCCESS)
				{
					credssp->SspiModule = (LPTSTR) malloc(dwSize + sizeof(TCHAR));

					status = RegQueryValueEx(hKey, _T(""SspiModule""), NULL, &dwType,
							(BYTE*) credssp->SspiModule, &dwSize);

					if (status == ERROR_SUCCESS)
					{
						_tprintf(_T(""Using SSPI Module: %s\n""), credssp->SspiModule);
						RegCloseKey(hKey);
					}
				}
			}
		}
	}

	return credssp;
}
",C,"		SecInvalidateHandle(&credssp->context);
",,,"@@ -1245,6 +1245,7 @@ rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings*
 		ZeroMemory(&credssp->negoToken, sizeof(SecBuffer));
 		ZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));
 		ZeroMemory(&credssp->authInfo, sizeof(SecBuffer));
+		SecInvalidateHandle(&credssp->context);
 
 		if (credssp->server)
 		{",FreeRDP,0773bb9303d24473fe1185d85a424dfe159aff53,87e9a24b1e0204aca4206fdc1ce75fe55a3eb580,1,"rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings)
{
	rdpCredssp* credssp;

	credssp = (rdpCredssp*) malloc(sizeof(rdpCredssp));
	ZeroMemory(credssp, sizeof(rdpCredssp));

	if (credssp != NULL)
	{
		HKEY hKey;
		LONG status;
		DWORD dwType;
		DWORD dwSize;

		credssp->instance = instance;
		credssp->settings = settings;
		credssp->server = settings->ServerMode;
		credssp->transport = transport;
		credssp->send_seq_num = 0;
		credssp->recv_seq_num = 0;
 		ZeroMemory(&credssp->negoToken, sizeof(SecBuffer));
 		ZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));
 		ZeroMemory(&credssp->authInfo, sizeof(SecBuffer));
//fix_flaw_line_below:
//		SecInvalidateHandle(&credssp->context);
 
 		if (credssp->server)
 		{
			status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(""Software\\FreeRDP\\Server""),
					0, KEY_READ | KEY_WOW64_64KEY, &hKey);

			if (status == ERROR_SUCCESS)
			{
				status = RegQueryValueEx(hKey, _T(""SspiModule""), NULL, &dwType, NULL, &dwSize);

				if (status == ERROR_SUCCESS)
				{
					credssp->SspiModule = (LPTSTR) malloc(dwSize + sizeof(TCHAR));

					status = RegQueryValueEx(hKey, _T(""SspiModule""), NULL, &dwType,
							(BYTE*) credssp->SspiModule, &dwSize);

					if (status == ERROR_SUCCESS)
					{
						_tprintf(_T(""Using SSPI Module: %s\n""), credssp->SspiModule);
						RegCloseKey(hKey);
					}
				}
			}
		}
	}

	return credssp;
}
"
3036,180772,,Remote,Not required,Partial,CVE-2013-4119,https://www.cvedetails.com/cve/CVE-2013-4119/,CWE-476,Low,,,,2016-10-03,5.0,FreeRDP before 1.1.0-beta+2013071101 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by disconnecting before authentication has finished.,2016-10-04,DoS ,1,https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53,0773bb9303d24473fe1185d85a424dfe159aff53,"nla: invalidate sec handle after creation

If sec pointer isn't invalidated after creation it is not possible
to check if the upper and lower pointers are valid.

This fixes a segfault in the server part if the client disconnects before
the authentication was finished.",0,libfreerdp/core/peer.c,"{""sha"": ""875c0ae7351a6e8a1161e0fa380329d74b38eba9"", ""filename"": ""libfreerdp/core/nla.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/nla.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/nla.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/nla.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -1245,6 +1245,7 @@ rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings*\n \t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n \t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n \t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n+\t\tSecInvalidateHandle(&credssp->context);\n \n \t\tif (credssp->server)\n \t\t{""}<_**next**_>{""sha"": ""eb4ad60eaa6ae2b08e91858e1147db87fd30362e"", ""filename"": ""libfreerdp/core/peer.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/peer.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/peer.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/peer.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -272,6 +272,7 @@ static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n \t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n \t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n \t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n+\t\t\t\trdp->nego->transport->credssp = NULL;\n \t\t\t}\n \t\t\telse\n \t\t\t{""}<_**next**_>{""sha"": ""4afec5a12d69ac0dc1430afb6af9058b7d2edc53"", ""filename"": ""libfreerdp/core/transport.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/transport.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/transport.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/transport.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -159,6 +159,7 @@ BOOL transport_connect_nla(rdpTransport* transport)\n \t\t\t\""If credentials are valid, the NTLMSSP implementation may be to blame.\\n\"");\n \n \t\tcredssp_free(transport->credssp);\n+\t\ttransport->credssp = NULL;\n \t\treturn FALSE;\n \t}\n \n@@ -292,6 +293,7 @@ BOOL transport_accept_nla(rdpTransport* transport)\n \t{\n \t\tfprintf(stderr, \""client authentication failure\\n\"");\n \t\tcredssp_free(transport->credssp);\n+\t\ttransport->credssp = NULL;\n \t\treturn FALSE;\n \t}\n ""}<_**next**_>{""sha"": ""96c9599958269b4d937d10829623068d0303d2f4"", ""filename"": ""winpr/libwinpr/sspi/sspi.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/winpr/libwinpr/sspi/sspi.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/winpr/libwinpr/sspi/sspi.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/winpr/libwinpr/sspi/sspi.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -248,7 +248,7 @@ void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n-\tif (!handle)\n+\tif (!handle || !SecIsValidHandle(handle))\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwLower);\n@@ -268,7 +268,7 @@ void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n-\tif (!handle)\n+\tif (!handle || !SecIsValidHandle(handle))\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwUpper);\n@@ -839,7 +839,7 @@ SECURITY_STATUS SEC_ENTRY CompleteAuthToken(PCtxtHandle phContext, PSecBufferDes\n \n SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n {\n-\tchar* Name;\n+\tchar* Name = NULL;\n \tSECURITY_STATUS status;\n \tSecurityFunctionTableA* table;\n ""}","static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)
{
	freerdp_peer* client = (freerdp_peer*) extra;
	rdpRdp* rdp = client->context->rdp;

	switch (rdp->state)
	{
		case CONNECTION_STATE_INITIAL:
			if (!rdp_server_accept_nego(rdp, s))
				return -1;

			if (rdp->nego->selected_protocol & PROTOCOL_NLA)
			{
 				sspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));
 				IFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);
 				credssp_free(rdp->nego->transport->credssp);
				rdp->nego->transport->credssp = NULL;
 			}
 			else
 			{
				IFCALLRET(client->Logon, client->authenticated, client, &client->identity, FALSE);
			}

			break;

		case CONNECTION_STATE_NEGO:
			if (!rdp_server_accept_mcs_connect_initial(rdp, s))
				return -1;
			break;

		case CONNECTION_STATE_MCS_CONNECT:
			if (!rdp_server_accept_mcs_erect_domain_request(rdp, s))
				return -1;
			break;

		case CONNECTION_STATE_MCS_ERECT_DOMAIN:
			if (!rdp_server_accept_mcs_attach_user_request(rdp, s))
				return -1;
			break;

		case CONNECTION_STATE_MCS_ATTACH_USER:
			if (!rdp_server_accept_mcs_channel_join_request(rdp, s))
				return -1;
			break;

		case CONNECTION_STATE_MCS_CHANNEL_JOIN:
			if (rdp->settings->DisableEncryption)
			{
				if (!rdp_server_accept_client_keys(rdp, s))
					return -1;
				break;
			}
			rdp->state = CONNECTION_STATE_ESTABLISH_KEYS;
			/* FALLTHROUGH */

		case CONNECTION_STATE_ESTABLISH_KEYS:
			if (!rdp_server_accept_client_info(rdp, s))
				return -1;

			IFCALL(client->Capabilities, client);

			if (!rdp_send_demand_active(rdp))
				return -1;
			break;

		case CONNECTION_STATE_LICENSE:
			if (!rdp_server_accept_confirm_active(rdp, s))
			{
				/**
				 * During reactivation sequence the client might sent some input or channel data
				 * before receiving the Deactivate All PDU. We need to process them as usual.
				 */
				Stream_SetPosition(s, 0);
				return peer_recv_pdu(client, s);
			}
			break;

		case CONNECTION_STATE_ACTIVE:
			if (peer_recv_pdu(client, s) < 0)
				return -1;
			break;

		default:
			fprintf(stderr, ""Invalid state %d\n"", rdp->state);
			return -1;
	}

	return 0;
}
","static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)
{
	freerdp_peer* client = (freerdp_peer*) extra;
	rdpRdp* rdp = client->context->rdp;

	switch (rdp->state)
	{
		case CONNECTION_STATE_INITIAL:
			if (!rdp_server_accept_nego(rdp, s))
				return -1;

			if (rdp->nego->selected_protocol & PROTOCOL_NLA)
			{
 				sspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));
 				IFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);
 				credssp_free(rdp->nego->transport->credssp);
 			}
 			else
 			{
				IFCALLRET(client->Logon, client->authenticated, client, &client->identity, FALSE);
			}

			break;

		case CONNECTION_STATE_NEGO:
			if (!rdp_server_accept_mcs_connect_initial(rdp, s))
				return -1;
			break;

		case CONNECTION_STATE_MCS_CONNECT:
			if (!rdp_server_accept_mcs_erect_domain_request(rdp, s))
				return -1;
			break;

		case CONNECTION_STATE_MCS_ERECT_DOMAIN:
			if (!rdp_server_accept_mcs_attach_user_request(rdp, s))
				return -1;
			break;

		case CONNECTION_STATE_MCS_ATTACH_USER:
			if (!rdp_server_accept_mcs_channel_join_request(rdp, s))
				return -1;
			break;

		case CONNECTION_STATE_MCS_CHANNEL_JOIN:
			if (rdp->settings->DisableEncryption)
			{
				if (!rdp_server_accept_client_keys(rdp, s))
					return -1;
				break;
			}
			rdp->state = CONNECTION_STATE_ESTABLISH_KEYS;
			/* FALLTHROUGH */

		case CONNECTION_STATE_ESTABLISH_KEYS:
			if (!rdp_server_accept_client_info(rdp, s))
				return -1;

			IFCALL(client->Capabilities, client);

			if (!rdp_send_demand_active(rdp))
				return -1;
			break;

		case CONNECTION_STATE_LICENSE:
			if (!rdp_server_accept_confirm_active(rdp, s))
			{
				/**
				 * During reactivation sequence the client might sent some input or channel data
				 * before receiving the Deactivate All PDU. We need to process them as usual.
				 */
				Stream_SetPosition(s, 0);
				return peer_recv_pdu(client, s);
			}
			break;

		case CONNECTION_STATE_ACTIVE:
			if (peer_recv_pdu(client, s) < 0)
				return -1;
			break;

		default:
			fprintf(stderr, ""Invalid state %d\n"", rdp->state);
			return -1;
	}

	return 0;
}
",C,"				rdp->nego->transport->credssp = NULL;
",,,"@@ -272,6 +272,7 @@ static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)
 				sspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));
 				IFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);
 				credssp_free(rdp->nego->transport->credssp);
+				rdp->nego->transport->credssp = NULL;
 			}
 			else
 			{",FreeRDP,0773bb9303d24473fe1185d85a424dfe159aff53,87e9a24b1e0204aca4206fdc1ce75fe55a3eb580,1,"static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)
{
	freerdp_peer* client = (freerdp_peer*) extra;
	rdpRdp* rdp = client->context->rdp;

	switch (rdp->state)
	{
		case CONNECTION_STATE_INITIAL:
			if (!rdp_server_accept_nego(rdp, s))
				return -1;

			if (rdp->nego->selected_protocol & PROTOCOL_NLA)
			{
 				sspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));
 				IFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);
 				credssp_free(rdp->nego->transport->credssp);
//fix_flaw_line_below:
//				rdp->nego->transport->credssp = NULL;
 			}
 			else
 			{
				IFCALLRET(client->Logon, client->authenticated, client, &client->identity, FALSE);
			}

			break;

		case CONNECTION_STATE_NEGO:
			if (!rdp_server_accept_mcs_connect_initial(rdp, s))
				return -1;
			break;

		case CONNECTION_STATE_MCS_CONNECT:
			if (!rdp_server_accept_mcs_erect_domain_request(rdp, s))
				return -1;
			break;

		case CONNECTION_STATE_MCS_ERECT_DOMAIN:
			if (!rdp_server_accept_mcs_attach_user_request(rdp, s))
				return -1;
			break;

		case CONNECTION_STATE_MCS_ATTACH_USER:
			if (!rdp_server_accept_mcs_channel_join_request(rdp, s))
				return -1;
			break;

		case CONNECTION_STATE_MCS_CHANNEL_JOIN:
			if (rdp->settings->DisableEncryption)
			{
				if (!rdp_server_accept_client_keys(rdp, s))
					return -1;
				break;
			}
			rdp->state = CONNECTION_STATE_ESTABLISH_KEYS;
			/* FALLTHROUGH */

		case CONNECTION_STATE_ESTABLISH_KEYS:
			if (!rdp_server_accept_client_info(rdp, s))
				return -1;

			IFCALL(client->Capabilities, client);

			if (!rdp_send_demand_active(rdp))
				return -1;
			break;

		case CONNECTION_STATE_LICENSE:
			if (!rdp_server_accept_confirm_active(rdp, s))
			{
				/**
				 * During reactivation sequence the client might sent some input or channel data
				 * before receiving the Deactivate All PDU. We need to process them as usual.
				 */
				Stream_SetPosition(s, 0);
				return peer_recv_pdu(client, s);
			}
			break;

		case CONNECTION_STATE_ACTIVE:
			if (peer_recv_pdu(client, s) < 0)
				return -1;
			break;

		default:
			fprintf(stderr, ""Invalid state %d\n"", rdp->state);
			return -1;
	}

	return 0;
}
"
3037,180773,,Remote,Not required,Partial,CVE-2013-4119,https://www.cvedetails.com/cve/CVE-2013-4119/,CWE-476,Low,,,,2016-10-03,5.0,FreeRDP before 1.1.0-beta+2013071101 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by disconnecting before authentication has finished.,2016-10-04,DoS ,1,https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53,0773bb9303d24473fe1185d85a424dfe159aff53,"nla: invalidate sec handle after creation

If sec pointer isn't invalidated after creation it is not possible
to check if the upper and lower pointers are valid.

This fixes a segfault in the server part if the client disconnects before
the authentication was finished.",0,libfreerdp/core/transport.c,"{""sha"": ""875c0ae7351a6e8a1161e0fa380329d74b38eba9"", ""filename"": ""libfreerdp/core/nla.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/nla.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/nla.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/nla.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -1245,6 +1245,7 @@ rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings*\n \t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n \t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n \t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n+\t\tSecInvalidateHandle(&credssp->context);\n \n \t\tif (credssp->server)\n \t\t{""}<_**next**_>{""sha"": ""eb4ad60eaa6ae2b08e91858e1147db87fd30362e"", ""filename"": ""libfreerdp/core/peer.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/peer.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/peer.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/peer.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -272,6 +272,7 @@ static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n \t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n \t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n \t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n+\t\t\t\trdp->nego->transport->credssp = NULL;\n \t\t\t}\n \t\t\telse\n \t\t\t{""}<_**next**_>{""sha"": ""4afec5a12d69ac0dc1430afb6af9058b7d2edc53"", ""filename"": ""libfreerdp/core/transport.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/transport.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/transport.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/transport.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -159,6 +159,7 @@ BOOL transport_connect_nla(rdpTransport* transport)\n \t\t\t\""If credentials are valid, the NTLMSSP implementation may be to blame.\\n\"");\n \n \t\tcredssp_free(transport->credssp);\n+\t\ttransport->credssp = NULL;\n \t\treturn FALSE;\n \t}\n \n@@ -292,6 +293,7 @@ BOOL transport_accept_nla(rdpTransport* transport)\n \t{\n \t\tfprintf(stderr, \""client authentication failure\\n\"");\n \t\tcredssp_free(transport->credssp);\n+\t\ttransport->credssp = NULL;\n \t\treturn FALSE;\n \t}\n ""}<_**next**_>{""sha"": ""96c9599958269b4d937d10829623068d0303d2f4"", ""filename"": ""winpr/libwinpr/sspi/sspi.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/winpr/libwinpr/sspi/sspi.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/winpr/libwinpr/sspi/sspi.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/winpr/libwinpr/sspi/sspi.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -248,7 +248,7 @@ void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n-\tif (!handle)\n+\tif (!handle || !SecIsValidHandle(handle))\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwLower);\n@@ -268,7 +268,7 @@ void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n-\tif (!handle)\n+\tif (!handle || !SecIsValidHandle(handle))\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwUpper);\n@@ -839,7 +839,7 @@ SECURITY_STATUS SEC_ENTRY CompleteAuthToken(PCtxtHandle phContext, PSecBufferDes\n \n SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n {\n-\tchar* Name;\n+\tchar* Name = NULL;\n \tSECURITY_STATUS status;\n \tSecurityFunctionTableA* table;\n ""}","BOOL transport_accept_nla(rdpTransport* transport)
{
	freerdp* instance;
	rdpSettings* settings;

	if (transport->TlsIn == NULL)
		transport->TlsIn = tls_new(transport->settings);

	if (transport->TlsOut == NULL)
		transport->TlsOut = transport->TlsIn;

	transport->layer = TRANSPORT_LAYER_TLS;
	transport->TlsIn->sockfd = transport->TcpIn->sockfd;

	if (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)
		return FALSE;

	/* Network Level Authentication */

	if (transport->settings->Authentication != TRUE)
		return TRUE;

	settings = transport->settings;
	instance = (freerdp*) settings->instance;

	if (transport->credssp == NULL)
		transport->credssp = credssp_new(instance, transport, settings);

	if (credssp_authenticate(transport->credssp) < 0)
 	{
 		fprintf(stderr, ""client authentication failure\n"");
 		credssp_free(transport->credssp);
		transport->credssp = NULL;
 		return FALSE;
 	}
 
	/* don't free credssp module yet, we need to copy the credentials from it first */

	return TRUE;
}
","BOOL transport_accept_nla(rdpTransport* transport)
{
	freerdp* instance;
	rdpSettings* settings;

	if (transport->TlsIn == NULL)
		transport->TlsIn = tls_new(transport->settings);

	if (transport->TlsOut == NULL)
		transport->TlsOut = transport->TlsIn;

	transport->layer = TRANSPORT_LAYER_TLS;
	transport->TlsIn->sockfd = transport->TcpIn->sockfd;

	if (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)
		return FALSE;

	/* Network Level Authentication */

	if (transport->settings->Authentication != TRUE)
		return TRUE;

	settings = transport->settings;
	instance = (freerdp*) settings->instance;

	if (transport->credssp == NULL)
		transport->credssp = credssp_new(instance, transport, settings);

	if (credssp_authenticate(transport->credssp) < 0)
 	{
 		fprintf(stderr, ""client authentication failure\n"");
 		credssp_free(transport->credssp);
 		return FALSE;
 	}
 
	/* don't free credssp module yet, we need to copy the credentials from it first */

	return TRUE;
}
",C,"		transport->credssp = NULL;
",,,"@@ -159,6 +159,7 @@ BOOL transport_connect_nla(rdpTransport* transport)
 			""If credentials are valid, the NTLMSSP implementation may be to blame.\n"");
 
 		credssp_free(transport->credssp);
+		transport->credssp = NULL;
 		return FALSE;
 	}
 
@@ -292,6 +293,7 @@ BOOL transport_accept_nla(rdpTransport* transport)
 	{
 		fprintf(stderr, ""client authentication failure\n"");
 		credssp_free(transport->credssp);
+		transport->credssp = NULL;
 		return FALSE;
 	}
 ",FreeRDP,0773bb9303d24473fe1185d85a424dfe159aff53,87e9a24b1e0204aca4206fdc1ce75fe55a3eb580,1,"BOOL transport_accept_nla(rdpTransport* transport)
{
	freerdp* instance;
	rdpSettings* settings;

	if (transport->TlsIn == NULL)
		transport->TlsIn = tls_new(transport->settings);

	if (transport->TlsOut == NULL)
		transport->TlsOut = transport->TlsIn;

	transport->layer = TRANSPORT_LAYER_TLS;
	transport->TlsIn->sockfd = transport->TcpIn->sockfd;

	if (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)
		return FALSE;

	/* Network Level Authentication */

	if (transport->settings->Authentication != TRUE)
		return TRUE;

	settings = transport->settings;
	instance = (freerdp*) settings->instance;

	if (transport->credssp == NULL)
		transport->credssp = credssp_new(instance, transport, settings);

	if (credssp_authenticate(transport->credssp) < 0)
 	{
 		fprintf(stderr, ""client authentication failure\n"");
 		credssp_free(transport->credssp);
//fix_flaw_line_below:
//		transport->credssp = NULL;
 		return FALSE;
 	}
 
	/* don't free credssp module yet, we need to copy the credentials from it first */

	return TRUE;
}
"
3038,180774,,Remote,Not required,Partial,CVE-2013-4119,https://www.cvedetails.com/cve/CVE-2013-4119/,CWE-476,Low,,,,2016-10-03,5.0,FreeRDP before 1.1.0-beta+2013071101 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by disconnecting before authentication has finished.,2016-10-04,DoS ,1,https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53,0773bb9303d24473fe1185d85a424dfe159aff53,"nla: invalidate sec handle after creation

If sec pointer isn't invalidated after creation it is not possible
to check if the upper and lower pointers are valid.

This fixes a segfault in the server part if the client disconnects before
the authentication was finished.",0,libfreerdp/core/transport.c,"{""sha"": ""875c0ae7351a6e8a1161e0fa380329d74b38eba9"", ""filename"": ""libfreerdp/core/nla.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/nla.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/nla.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/nla.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -1245,6 +1245,7 @@ rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings*\n \t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n \t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n \t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n+\t\tSecInvalidateHandle(&credssp->context);\n \n \t\tif (credssp->server)\n \t\t{""}<_**next**_>{""sha"": ""eb4ad60eaa6ae2b08e91858e1147db87fd30362e"", ""filename"": ""libfreerdp/core/peer.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/peer.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/peer.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/peer.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -272,6 +272,7 @@ static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n \t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n \t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n \t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n+\t\t\t\trdp->nego->transport->credssp = NULL;\n \t\t\t}\n \t\t\telse\n \t\t\t{""}<_**next**_>{""sha"": ""4afec5a12d69ac0dc1430afb6af9058b7d2edc53"", ""filename"": ""libfreerdp/core/transport.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/transport.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/transport.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/transport.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -159,6 +159,7 @@ BOOL transport_connect_nla(rdpTransport* transport)\n \t\t\t\""If credentials are valid, the NTLMSSP implementation may be to blame.\\n\"");\n \n \t\tcredssp_free(transport->credssp);\n+\t\ttransport->credssp = NULL;\n \t\treturn FALSE;\n \t}\n \n@@ -292,6 +293,7 @@ BOOL transport_accept_nla(rdpTransport* transport)\n \t{\n \t\tfprintf(stderr, \""client authentication failure\\n\"");\n \t\tcredssp_free(transport->credssp);\n+\t\ttransport->credssp = NULL;\n \t\treturn FALSE;\n \t}\n ""}<_**next**_>{""sha"": ""96c9599958269b4d937d10829623068d0303d2f4"", ""filename"": ""winpr/libwinpr/sspi/sspi.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/winpr/libwinpr/sspi/sspi.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/winpr/libwinpr/sspi/sspi.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/winpr/libwinpr/sspi/sspi.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -248,7 +248,7 @@ void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n-\tif (!handle)\n+\tif (!handle || !SecIsValidHandle(handle))\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwLower);\n@@ -268,7 +268,7 @@ void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n-\tif (!handle)\n+\tif (!handle || !SecIsValidHandle(handle))\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwUpper);\n@@ -839,7 +839,7 @@ SECURITY_STATUS SEC_ENTRY CompleteAuthToken(PCtxtHandle phContext, PSecBufferDes\n \n SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n {\n-\tchar* Name;\n+\tchar* Name = NULL;\n \tSECURITY_STATUS status;\n \tSecurityFunctionTableA* table;\n ""}","BOOL transport_connect_nla(rdpTransport* transport)
{
	freerdp* instance;
	rdpSettings* settings;

	if (transport->layer == TRANSPORT_LAYER_TSG)
		return TRUE;

	if (!transport_connect_tls(transport))
		return FALSE;

	/* Network Level Authentication */

	if (transport->settings->Authentication != TRUE)
		return TRUE;

	settings = transport->settings;
	instance = (freerdp*) settings->instance;

	if (transport->credssp == NULL)
		transport->credssp = credssp_new(instance, transport, settings);

	if (credssp_authenticate(transport->credssp) < 0)
	{
		if (!connectErrorCode)
			connectErrorCode = AUTHENTICATIONERROR;

		fprintf(stderr, ""Authentication failure, check credentials.\n""
 			""If credentials are valid, the NTLMSSP implementation may be to blame.\n"");
 
 		credssp_free(transport->credssp);
		transport->credssp = NULL;
 		return FALSE;
 	}
 
	credssp_free(transport->credssp);

	return TRUE;
}
","BOOL transport_connect_nla(rdpTransport* transport)
{
	freerdp* instance;
	rdpSettings* settings;

	if (transport->layer == TRANSPORT_LAYER_TSG)
		return TRUE;

	if (!transport_connect_tls(transport))
		return FALSE;

	/* Network Level Authentication */

	if (transport->settings->Authentication != TRUE)
		return TRUE;

	settings = transport->settings;
	instance = (freerdp*) settings->instance;

	if (transport->credssp == NULL)
		transport->credssp = credssp_new(instance, transport, settings);

	if (credssp_authenticate(transport->credssp) < 0)
	{
		if (!connectErrorCode)
			connectErrorCode = AUTHENTICATIONERROR;

		fprintf(stderr, ""Authentication failure, check credentials.\n""
 			""If credentials are valid, the NTLMSSP implementation may be to blame.\n"");
 
 		credssp_free(transport->credssp);
 		return FALSE;
 	}
 
	credssp_free(transport->credssp);

	return TRUE;
}
",C,"		transport->credssp = NULL;
",,,"@@ -159,6 +159,7 @@ BOOL transport_connect_nla(rdpTransport* transport)
 			""If credentials are valid, the NTLMSSP implementation may be to blame.\n"");
 
 		credssp_free(transport->credssp);
+		transport->credssp = NULL;
 		return FALSE;
 	}
 
@@ -292,6 +293,7 @@ BOOL transport_accept_nla(rdpTransport* transport)
 	{
 		fprintf(stderr, ""client authentication failure\n"");
 		credssp_free(transport->credssp);
+		transport->credssp = NULL;
 		return FALSE;
 	}
 ",FreeRDP,0773bb9303d24473fe1185d85a424dfe159aff53,87e9a24b1e0204aca4206fdc1ce75fe55a3eb580,1,"BOOL transport_connect_nla(rdpTransport* transport)
{
	freerdp* instance;
	rdpSettings* settings;

	if (transport->layer == TRANSPORT_LAYER_TSG)
		return TRUE;

	if (!transport_connect_tls(transport))
		return FALSE;

	/* Network Level Authentication */

	if (transport->settings->Authentication != TRUE)
		return TRUE;

	settings = transport->settings;
	instance = (freerdp*) settings->instance;

	if (transport->credssp == NULL)
		transport->credssp = credssp_new(instance, transport, settings);

	if (credssp_authenticate(transport->credssp) < 0)
	{
		if (!connectErrorCode)
			connectErrorCode = AUTHENTICATIONERROR;

		fprintf(stderr, ""Authentication failure, check credentials.\n""
 			""If credentials are valid, the NTLMSSP implementation may be to blame.\n"");
 
 		credssp_free(transport->credssp);
//fix_flaw_line_below:
//		transport->credssp = NULL;
 		return FALSE;
 	}
 
	credssp_free(transport->credssp);

	return TRUE;
}
"
3039,180775,,Remote,Not required,Partial,CVE-2013-4119,https://www.cvedetails.com/cve/CVE-2013-4119/,CWE-476,Low,,,,2016-10-03,5.0,FreeRDP before 1.1.0-beta+2013071101 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by disconnecting before authentication has finished.,2016-10-04,DoS ,1,https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53,0773bb9303d24473fe1185d85a424dfe159aff53,"nla: invalidate sec handle after creation

If sec pointer isn't invalidated after creation it is not possible
to check if the upper and lower pointers are valid.

This fixes a segfault in the server part if the client disconnects before
the authentication was finished.",1,winpr/libwinpr/sspi/sspi.c,"{""sha"": ""875c0ae7351a6e8a1161e0fa380329d74b38eba9"", ""filename"": ""libfreerdp/core/nla.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/nla.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/nla.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/nla.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -1245,6 +1245,7 @@ rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings*\n \t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n \t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n \t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n+\t\tSecInvalidateHandle(&credssp->context);\n \n \t\tif (credssp->server)\n \t\t{""}<_**next**_>{""sha"": ""eb4ad60eaa6ae2b08e91858e1147db87fd30362e"", ""filename"": ""libfreerdp/core/peer.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/peer.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/peer.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/peer.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -272,6 +272,7 @@ static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n \t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n \t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n \t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n+\t\t\t\trdp->nego->transport->credssp = NULL;\n \t\t\t}\n \t\t\telse\n \t\t\t{""}<_**next**_>{""sha"": ""4afec5a12d69ac0dc1430afb6af9058b7d2edc53"", ""filename"": ""libfreerdp/core/transport.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/transport.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/transport.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/transport.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -159,6 +159,7 @@ BOOL transport_connect_nla(rdpTransport* transport)\n \t\t\t\""If credentials are valid, the NTLMSSP implementation may be to blame.\\n\"");\n \n \t\tcredssp_free(transport->credssp);\n+\t\ttransport->credssp = NULL;\n \t\treturn FALSE;\n \t}\n \n@@ -292,6 +293,7 @@ BOOL transport_accept_nla(rdpTransport* transport)\n \t{\n \t\tfprintf(stderr, \""client authentication failure\\n\"");\n \t\tcredssp_free(transport->credssp);\n+\t\ttransport->credssp = NULL;\n \t\treturn FALSE;\n \t}\n ""}<_**next**_>{""sha"": ""96c9599958269b4d937d10829623068d0303d2f4"", ""filename"": ""winpr/libwinpr/sspi/sspi.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/winpr/libwinpr/sspi/sspi.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/winpr/libwinpr/sspi/sspi.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/winpr/libwinpr/sspi/sspi.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -248,7 +248,7 @@ void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n-\tif (!handle)\n+\tif (!handle || !SecIsValidHandle(handle))\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwLower);\n@@ -268,7 +268,7 @@ void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n-\tif (!handle)\n+\tif (!handle || !SecIsValidHandle(handle))\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwUpper);\n@@ -839,7 +839,7 @@ SECURITY_STATUS SEC_ENTRY CompleteAuthToken(PCtxtHandle phContext, PSecBufferDes\n \n SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n {\n-\tchar* Name;\n+\tchar* Name = NULL;\n \tSECURITY_STATUS status;\n \tSecurityFunctionTableA* table;\n ""}"," SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)
 {
	char* Name = NULL;
 	SECURITY_STATUS status;
 	SecurityFunctionTableA* table;
 
	Name = (char*) sspi_SecureHandleGetUpperPointer(phContext);

	if (!Name)
		return SEC_E_SECPKG_NOT_FOUND;

	table = sspi_GetSecurityFunctionTableAByNameA(Name);

	if (!table)
		return SEC_E_SECPKG_NOT_FOUND;

	if (table->DeleteSecurityContext == NULL)
		return SEC_E_UNSUPPORTED_FUNCTION;

	status = table->DeleteSecurityContext(phContext);

	return status;
}
"," SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)
 {
	char* Name;
 	SECURITY_STATUS status;
 	SecurityFunctionTableA* table;
 
	Name = (char*) sspi_SecureHandleGetUpperPointer(phContext);

	if (!Name)
		return SEC_E_SECPKG_NOT_FOUND;

	table = sspi_GetSecurityFunctionTableAByNameA(Name);

	if (!table)
		return SEC_E_SECPKG_NOT_FOUND;

	if (table->DeleteSecurityContext == NULL)
		return SEC_E_UNSUPPORTED_FUNCTION;

	status = table->DeleteSecurityContext(phContext);

	return status;
}
",C,"	char* Name = NULL;
","	char* Name;
",,"@@ -248,7 +248,7 @@ void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)
 {
 	void* pointer;
 
-	if (!handle)
+	if (!handle || !SecIsValidHandle(handle))
 		return NULL;
 
 	pointer = (void*) ~((size_t) handle->dwLower);
@@ -268,7 +268,7 @@ void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)
 {
 	void* pointer;
 
-	if (!handle)
+	if (!handle || !SecIsValidHandle(handle))
 		return NULL;
 
 	pointer = (void*) ~((size_t) handle->dwUpper);
@@ -839,7 +839,7 @@ SECURITY_STATUS SEC_ENTRY CompleteAuthToken(PCtxtHandle phContext, PSecBufferDes
 
 SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)
 {
-	char* Name;
+	char* Name = NULL;
 	SECURITY_STATUS status;
 	SecurityFunctionTableA* table;
 ",FreeRDP,0773bb9303d24473fe1185d85a424dfe159aff53,87e9a24b1e0204aca4206fdc1ce75fe55a3eb580,1," SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)
 {
//flaw_line_below:
	char* Name;
//fix_flaw_line_below:
//	char* Name = NULL;
 	SECURITY_STATUS status;
 	SecurityFunctionTableA* table;
 
	Name = (char*) sspi_SecureHandleGetUpperPointer(phContext);

	if (!Name)
		return SEC_E_SECPKG_NOT_FOUND;

	table = sspi_GetSecurityFunctionTableAByNameA(Name);

	if (!table)
		return SEC_E_SECPKG_NOT_FOUND;

	if (table->DeleteSecurityContext == NULL)
		return SEC_E_UNSUPPORTED_FUNCTION;

	status = table->DeleteSecurityContext(phContext);

	return status;
}
"
3040,180776,,Remote,Not required,Partial,CVE-2013-4119,https://www.cvedetails.com/cve/CVE-2013-4119/,CWE-476,Low,,,,2016-10-03,5.0,FreeRDP before 1.1.0-beta+2013071101 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by disconnecting before authentication has finished.,2016-10-04,DoS ,1,https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53,0773bb9303d24473fe1185d85a424dfe159aff53,"nla: invalidate sec handle after creation

If sec pointer isn't invalidated after creation it is not possible
to check if the upper and lower pointers are valid.

This fixes a segfault in the server part if the client disconnects before
the authentication was finished.",1,winpr/libwinpr/sspi/sspi.c,"{""sha"": ""875c0ae7351a6e8a1161e0fa380329d74b38eba9"", ""filename"": ""libfreerdp/core/nla.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/nla.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/nla.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/nla.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -1245,6 +1245,7 @@ rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings*\n \t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n \t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n \t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n+\t\tSecInvalidateHandle(&credssp->context);\n \n \t\tif (credssp->server)\n \t\t{""}<_**next**_>{""sha"": ""eb4ad60eaa6ae2b08e91858e1147db87fd30362e"", ""filename"": ""libfreerdp/core/peer.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/peer.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/peer.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/peer.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -272,6 +272,7 @@ static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n \t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n \t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n \t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n+\t\t\t\trdp->nego->transport->credssp = NULL;\n \t\t\t}\n \t\t\telse\n \t\t\t{""}<_**next**_>{""sha"": ""4afec5a12d69ac0dc1430afb6af9058b7d2edc53"", ""filename"": ""libfreerdp/core/transport.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/transport.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/transport.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/transport.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -159,6 +159,7 @@ BOOL transport_connect_nla(rdpTransport* transport)\n \t\t\t\""If credentials are valid, the NTLMSSP implementation may be to blame.\\n\"");\n \n \t\tcredssp_free(transport->credssp);\n+\t\ttransport->credssp = NULL;\n \t\treturn FALSE;\n \t}\n \n@@ -292,6 +293,7 @@ BOOL transport_accept_nla(rdpTransport* transport)\n \t{\n \t\tfprintf(stderr, \""client authentication failure\\n\"");\n \t\tcredssp_free(transport->credssp);\n+\t\ttransport->credssp = NULL;\n \t\treturn FALSE;\n \t}\n ""}<_**next**_>{""sha"": ""96c9599958269b4d937d10829623068d0303d2f4"", ""filename"": ""winpr/libwinpr/sspi/sspi.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/winpr/libwinpr/sspi/sspi.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/winpr/libwinpr/sspi/sspi.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/winpr/libwinpr/sspi/sspi.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -248,7 +248,7 @@ void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n-\tif (!handle)\n+\tif (!handle || !SecIsValidHandle(handle))\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwLower);\n@@ -268,7 +268,7 @@ void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n-\tif (!handle)\n+\tif (!handle || !SecIsValidHandle(handle))\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwUpper);\n@@ -839,7 +839,7 @@ SECURITY_STATUS SEC_ENTRY CompleteAuthToken(PCtxtHandle phContext, PSecBufferDes\n \n SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n {\n-\tchar* Name;\n+\tchar* Name = NULL;\n \tSECURITY_STATUS status;\n \tSecurityFunctionTableA* table;\n ""}","void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)
 {
 	void* pointer;
 
	if (!handle || !SecIsValidHandle(handle))
 		return NULL;
 
 	pointer = (void*) ~((size_t) handle->dwLower);

	return pointer;
}
","void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)
 {
 	void* pointer;
 
	if (!handle)
 		return NULL;
 
 	pointer = (void*) ~((size_t) handle->dwLower);

	return pointer;
}
",C,"	if (!handle || !SecIsValidHandle(handle))
","	if (!handle)
",,"@@ -248,7 +248,7 @@ void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)
 {
 	void* pointer;
 
-	if (!handle)
+	if (!handle || !SecIsValidHandle(handle))
 		return NULL;
 
 	pointer = (void*) ~((size_t) handle->dwLower);
@@ -268,7 +268,7 @@ void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)
 {
 	void* pointer;
 
-	if (!handle)
+	if (!handle || !SecIsValidHandle(handle))
 		return NULL;
 
 	pointer = (void*) ~((size_t) handle->dwUpper);
@@ -839,7 +839,7 @@ SECURITY_STATUS SEC_ENTRY CompleteAuthToken(PCtxtHandle phContext, PSecBufferDes
 
 SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)
 {
-	char* Name;
+	char* Name = NULL;
 	SECURITY_STATUS status;
 	SecurityFunctionTableA* table;
 ",FreeRDP,0773bb9303d24473fe1185d85a424dfe159aff53,87e9a24b1e0204aca4206fdc1ce75fe55a3eb580,1,"void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)
 {
 	void* pointer;
 
//flaw_line_below:
	if (!handle)
//fix_flaw_line_below:
//	if (!handle || !SecIsValidHandle(handle))
 		return NULL;
 
 	pointer = (void*) ~((size_t) handle->dwLower);

	return pointer;
}
"
3041,180777,,Remote,Not required,Partial,CVE-2013-4119,https://www.cvedetails.com/cve/CVE-2013-4119/,CWE-476,Low,,,,2016-10-03,5.0,FreeRDP before 1.1.0-beta+2013071101 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by disconnecting before authentication has finished.,2016-10-04,DoS ,1,https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53,0773bb9303d24473fe1185d85a424dfe159aff53,"nla: invalidate sec handle after creation

If sec pointer isn't invalidated after creation it is not possible
to check if the upper and lower pointers are valid.

This fixes a segfault in the server part if the client disconnects before
the authentication was finished.",1,winpr/libwinpr/sspi/sspi.c,"{""sha"": ""875c0ae7351a6e8a1161e0fa380329d74b38eba9"", ""filename"": ""libfreerdp/core/nla.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/nla.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/nla.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/nla.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -1245,6 +1245,7 @@ rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings*\n \t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n \t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n \t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n+\t\tSecInvalidateHandle(&credssp->context);\n \n \t\tif (credssp->server)\n \t\t{""}<_**next**_>{""sha"": ""eb4ad60eaa6ae2b08e91858e1147db87fd30362e"", ""filename"": ""libfreerdp/core/peer.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/peer.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/peer.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/peer.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -272,6 +272,7 @@ static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n \t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n \t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n \t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n+\t\t\t\trdp->nego->transport->credssp = NULL;\n \t\t\t}\n \t\t\telse\n \t\t\t{""}<_**next**_>{""sha"": ""4afec5a12d69ac0dc1430afb6af9058b7d2edc53"", ""filename"": ""libfreerdp/core/transport.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/transport.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/libfreerdp/core/transport.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/transport.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -159,6 +159,7 @@ BOOL transport_connect_nla(rdpTransport* transport)\n \t\t\t\""If credentials are valid, the NTLMSSP implementation may be to blame.\\n\"");\n \n \t\tcredssp_free(transport->credssp);\n+\t\ttransport->credssp = NULL;\n \t\treturn FALSE;\n \t}\n \n@@ -292,6 +293,7 @@ BOOL transport_accept_nla(rdpTransport* transport)\n \t{\n \t\tfprintf(stderr, \""client authentication failure\\n\"");\n \t\tcredssp_free(transport->credssp);\n+\t\ttransport->credssp = NULL;\n \t\treturn FALSE;\n \t}\n ""}<_**next**_>{""sha"": ""96c9599958269b4d937d10829623068d0303d2f4"", ""filename"": ""winpr/libwinpr/sspi/sspi.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/0773bb9303d24473fe1185d85a424dfe159aff53/winpr/libwinpr/sspi/sspi.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/0773bb9303d24473fe1185d85a424dfe159aff53/winpr/libwinpr/sspi/sspi.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/winpr/libwinpr/sspi/sspi.c?ref=0773bb9303d24473fe1185d85a424dfe159aff53"", ""patch"": ""@@ -248,7 +248,7 @@ void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n-\tif (!handle)\n+\tif (!handle || !SecIsValidHandle(handle))\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwLower);\n@@ -268,7 +268,7 @@ void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n-\tif (!handle)\n+\tif (!handle || !SecIsValidHandle(handle))\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwUpper);\n@@ -839,7 +839,7 @@ SECURITY_STATUS SEC_ENTRY CompleteAuthToken(PCtxtHandle phContext, PSecBufferDes\n \n SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n {\n-\tchar* Name;\n+\tchar* Name = NULL;\n \tSECURITY_STATUS status;\n \tSecurityFunctionTableA* table;\n ""}","void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)
 {
 	void* pointer;
 
	if (!handle || !SecIsValidHandle(handle))
 		return NULL;
 
 	pointer = (void*) ~((size_t) handle->dwUpper);

	return pointer;
}
","void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)
 {
 	void* pointer;
 
	if (!handle)
 		return NULL;
 
 	pointer = (void*) ~((size_t) handle->dwUpper);

	return pointer;
}
",C,"	if (!handle || !SecIsValidHandle(handle))
","	if (!handle)
",,"@@ -248,7 +248,7 @@ void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)
 {
 	void* pointer;
 
-	if (!handle)
+	if (!handle || !SecIsValidHandle(handle))
 		return NULL;
 
 	pointer = (void*) ~((size_t) handle->dwLower);
@@ -268,7 +268,7 @@ void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)
 {
 	void* pointer;
 
-	if (!handle)
+	if (!handle || !SecIsValidHandle(handle))
 		return NULL;
 
 	pointer = (void*) ~((size_t) handle->dwUpper);
@@ -839,7 +839,7 @@ SECURITY_STATUS SEC_ENTRY CompleteAuthToken(PCtxtHandle phContext, PSecBufferDes
 
 SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)
 {
-	char* Name;
+	char* Name = NULL;
 	SECURITY_STATUS status;
 	SecurityFunctionTableA* table;
 ",FreeRDP,0773bb9303d24473fe1185d85a424dfe159aff53,87e9a24b1e0204aca4206fdc1ce75fe55a3eb580,1,"void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)
 {
 	void* pointer;
 
//flaw_line_below:
	if (!handle)
//fix_flaw_line_below:
//	if (!handle || !SecIsValidHandle(handle))
 		return NULL;
 
 	pointer = (void*) ~((size_t) handle->dwUpper);

	return pointer;
}
"
3042,180778,,Remote,Not required,Partial,CVE-2013-4118,https://www.cvedetails.com/cve/CVE-2013-4118/,CWE-476,Low,,,,2016-10-03,5.0,FreeRDP before 1.1.0-beta1 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via unspecified vectors.,2018-10-30,DoS ,2,https://github.com/FreeRDP/FreeRDP/commit/7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7,7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7,security: add a NULL pointer check to fix a server crash.,1,libfreerdp/core/rdp.c,"{""sha"": ""7eecc6880510201ba3e423f396b2ebecf2d6a64b"", ""filename"": ""libfreerdp/core/rdp.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7/libfreerdp/core/rdp.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7/libfreerdp/core/rdp.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/rdp.c?ref=7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7"", ""patch"": ""@@ -717,7 +717,8 @@ BOOL rdp_decrypt(rdpRdp* rdp, STREAM* s, int length, UINT16 securityFlags)\n \n \tstream_read(s, wmac, sizeof(wmac));\n \tlength -= sizeof(wmac);\n-\tsecurity_decrypt(s->p, length, rdp);\n+\tif (!security_decrypt(s->p, length, rdp))\n+\t\treturn FALSE;\n \n \tif (securityFlags & SEC_SECURE_CHECKSUM)\n \t\tsecurity_salted_mac_signature(rdp, s->p, length, FALSE, cmac);""}<_**next**_>{""sha"": ""83298fdd1be69a33365a51dd65915f46c7a23cef"", ""filename"": ""libfreerdp/core/security.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7/libfreerdp/core/security.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7/libfreerdp/core/security.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/security.c?ref=7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7"", ""patch"": ""@@ -492,6 +492,8 @@ BOOL security_encrypt(BYTE* data, int length, rdpRdp* rdp)\n \n BOOL security_decrypt(BYTE* data, int length, rdpRdp* rdp)\n {\n+\tif (rdp->rc4_decrypt_key == NULL)\n+\t\treturn FALSE;\n \tif (rdp->decrypt_use_count >= 4096)\n \t{\n \t\tsecurity_key_update(rdp->decrypt_key, rdp->decrypt_update_key, rdp->rc4_key_len);""}","BOOL rdp_decrypt(rdpRdp* rdp, STREAM* s, int length, UINT16 securityFlags)
{
	BYTE cmac[8];
	BYTE wmac[8];

	if (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)
	{
		UINT16 len;
		BYTE version, pad;
		BYTE* sig;

		if (stream_get_left(s) < 12)
			return FALSE;

		stream_read_UINT16(s, len); /* 0x10 */
		stream_read_BYTE(s, version); /* 0x1 */
		stream_read_BYTE(s, pad);

		sig = s->p;
		stream_seek(s, 8);	/* signature */

		length -= 12;

		if (!security_fips_decrypt(s->p, length, rdp))
		{
			printf(""FATAL: cannot decrypt\n"");
			return FALSE; /* TODO */
		}

		if (!security_fips_check_signature(s->p, length - pad, sig, rdp))
		{
			printf(""FATAL: invalid packet signature\n"");
			return FALSE; /* TODO */
		}

		/* is this what needs adjusting? */
		s->size -= pad;
		return TRUE;
	}

	if (stream_get_left(s) < 8)
		return FALSE;
 
 	stream_read(s, wmac, sizeof(wmac));
 	length -= sizeof(wmac);
	if (!security_decrypt(s->p, length, rdp))
		return FALSE;
 
 	if (securityFlags & SEC_SECURE_CHECKSUM)
 		security_salted_mac_signature(rdp, s->p, length, FALSE, cmac);
	else
		security_mac_signature(rdp, s->p, length, cmac);

	if (memcmp(wmac, cmac, sizeof(wmac)) != 0)
	{
		printf(""WARNING: invalid packet signature\n"");
		/*
		 * Because Standard RDP Security is totally broken,
		 * and cannot protect against MITM, don't treat signature
		 * verification failure as critical. This at least enables
		 * us to work with broken RDP clients and servers that
		 * generate invalid signatures.
		 */
	}

	return TRUE;
}
","BOOL rdp_decrypt(rdpRdp* rdp, STREAM* s, int length, UINT16 securityFlags)
{
	BYTE cmac[8];
	BYTE wmac[8];

	if (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)
	{
		UINT16 len;
		BYTE version, pad;
		BYTE* sig;

		if (stream_get_left(s) < 12)
			return FALSE;

		stream_read_UINT16(s, len); /* 0x10 */
		stream_read_BYTE(s, version); /* 0x1 */
		stream_read_BYTE(s, pad);

		sig = s->p;
		stream_seek(s, 8);	/* signature */

		length -= 12;

		if (!security_fips_decrypt(s->p, length, rdp))
		{
			printf(""FATAL: cannot decrypt\n"");
			return FALSE; /* TODO */
		}

		if (!security_fips_check_signature(s->p, length - pad, sig, rdp))
		{
			printf(""FATAL: invalid packet signature\n"");
			return FALSE; /* TODO */
		}

		/* is this what needs adjusting? */
		s->size -= pad;
		return TRUE;
	}

	if (stream_get_left(s) < 8)
		return FALSE;
 
 	stream_read(s, wmac, sizeof(wmac));
 	length -= sizeof(wmac);
	security_decrypt(s->p, length, rdp);
 
 	if (securityFlags & SEC_SECURE_CHECKSUM)
 		security_salted_mac_signature(rdp, s->p, length, FALSE, cmac);
	else
		security_mac_signature(rdp, s->p, length, cmac);

	if (memcmp(wmac, cmac, sizeof(wmac)) != 0)
	{
		printf(""WARNING: invalid packet signature\n"");
		/*
		 * Because Standard RDP Security is totally broken,
		 * and cannot protect against MITM, don't treat signature
		 * verification failure as critical. This at least enables
		 * us to work with broken RDP clients and servers that
		 * generate invalid signatures.
		 */
	}

	return TRUE;
}
",C,"	if (!security_decrypt(s->p, length, rdp))
		return FALSE;
","	security_decrypt(s->p, length, rdp);
",,"@@ -717,7 +717,8 @@ BOOL rdp_decrypt(rdpRdp* rdp, STREAM* s, int length, UINT16 securityFlags)
 
 	stream_read(s, wmac, sizeof(wmac));
 	length -= sizeof(wmac);
-	security_decrypt(s->p, length, rdp);
+	if (!security_decrypt(s->p, length, rdp))
+		return FALSE;
 
 	if (securityFlags & SEC_SECURE_CHECKSUM)
 		security_salted_mac_signature(rdp, s->p, length, FALSE, cmac);",FreeRDP,7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7,03fd416b3b59e03591123bde29f7371d8f76e4b3,1,"BOOL rdp_decrypt(rdpRdp* rdp, STREAM* s, int length, UINT16 securityFlags)
{
	BYTE cmac[8];
	BYTE wmac[8];

	if (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)
	{
		UINT16 len;
		BYTE version, pad;
		BYTE* sig;

		if (stream_get_left(s) < 12)
			return FALSE;

		stream_read_UINT16(s, len); /* 0x10 */
		stream_read_BYTE(s, version); /* 0x1 */
		stream_read_BYTE(s, pad);

		sig = s->p;
		stream_seek(s, 8);	/* signature */

		length -= 12;

		if (!security_fips_decrypt(s->p, length, rdp))
		{
			printf(""FATAL: cannot decrypt\n"");
			return FALSE; /* TODO */
		}

		if (!security_fips_check_signature(s->p, length - pad, sig, rdp))
		{
			printf(""FATAL: invalid packet signature\n"");
			return FALSE; /* TODO */
		}

		/* is this what needs adjusting? */
		s->size -= pad;
		return TRUE;
	}

	if (stream_get_left(s) < 8)
		return FALSE;
 
 	stream_read(s, wmac, sizeof(wmac));
 	length -= sizeof(wmac);
//flaw_line_below:
	security_decrypt(s->p, length, rdp);
//fix_flaw_line_below:
//	if (!security_decrypt(s->p, length, rdp))
//fix_flaw_line_below:
//		return FALSE;
 
 	if (securityFlags & SEC_SECURE_CHECKSUM)
 		security_salted_mac_signature(rdp, s->p, length, FALSE, cmac);
	else
		security_mac_signature(rdp, s->p, length, cmac);

	if (memcmp(wmac, cmac, sizeof(wmac)) != 0)
	{
		printf(""WARNING: invalid packet signature\n"");
		/*
		 * Because Standard RDP Security is totally broken,
		 * and cannot protect against MITM, don't treat signature
		 * verification failure as critical. This at least enables
		 * us to work with broken RDP clients and servers that
		 * generate invalid signatures.
		 */
		//return FALSE;
	}

	return TRUE;
}
"
3043,180779,,Remote,Not required,Partial,CVE-2013-4118,https://www.cvedetails.com/cve/CVE-2013-4118/,CWE-476,Low,,,,2016-10-03,5.0,FreeRDP before 1.1.0-beta1 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via unspecified vectors.,2018-10-30,DoS ,2,https://github.com/FreeRDP/FreeRDP/commit/7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7,7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7,security: add a NULL pointer check to fix a server crash.,0,libfreerdp/core/security.c,"{""sha"": ""7eecc6880510201ba3e423f396b2ebecf2d6a64b"", ""filename"": ""libfreerdp/core/rdp.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7/libfreerdp/core/rdp.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7/libfreerdp/core/rdp.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/rdp.c?ref=7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7"", ""patch"": ""@@ -717,7 +717,8 @@ BOOL rdp_decrypt(rdpRdp* rdp, STREAM* s, int length, UINT16 securityFlags)\n \n \tstream_read(s, wmac, sizeof(wmac));\n \tlength -= sizeof(wmac);\n-\tsecurity_decrypt(s->p, length, rdp);\n+\tif (!security_decrypt(s->p, length, rdp))\n+\t\treturn FALSE;\n \n \tif (securityFlags & SEC_SECURE_CHECKSUM)\n \t\tsecurity_salted_mac_signature(rdp, s->p, length, FALSE, cmac);""}<_**next**_>{""sha"": ""83298fdd1be69a33365a51dd65915f46c7a23cef"", ""filename"": ""libfreerdp/core/security.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/FreeRDP/FreeRDP/blob/7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7/libfreerdp/core/security.c"", ""raw_url"": ""https://github.com/FreeRDP/FreeRDP/raw/7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7/libfreerdp/core/security.c"", ""contents_url"": ""https://api.github.com/repos/FreeRDP/FreeRDP/contents/libfreerdp/core/security.c?ref=7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7"", ""patch"": ""@@ -492,6 +492,8 @@ BOOL security_encrypt(BYTE* data, int length, rdpRdp* rdp)\n \n BOOL security_decrypt(BYTE* data, int length, rdpRdp* rdp)\n {\n+\tif (rdp->rc4_decrypt_key == NULL)\n+\t\treturn FALSE;\n \tif (rdp->decrypt_use_count >= 4096)\n \t{\n \t\tsecurity_key_update(rdp->decrypt_key, rdp->decrypt_update_key, rdp->rc4_key_len);""}"," BOOL security_decrypt(BYTE* data, int length, rdpRdp* rdp)
 {
	if (rdp->rc4_decrypt_key == NULL)
		return FALSE;
 	if (rdp->decrypt_use_count >= 4096)
 	{
 		security_key_update(rdp->decrypt_key, rdp->decrypt_update_key, rdp->rc4_key_len);
		crypto_rc4_free(rdp->rc4_decrypt_key);
		rdp->rc4_decrypt_key = crypto_rc4_init(rdp->decrypt_key, rdp->rc4_key_len);
		rdp->decrypt_use_count = 0;
	}
	crypto_rc4(rdp->rc4_decrypt_key, length, data, data);
	rdp->decrypt_use_count += 1;
	rdp->decrypt_checksum_use_count++;
	return TRUE;
}
"," BOOL security_decrypt(BYTE* data, int length, rdpRdp* rdp)
 {
 	if (rdp->decrypt_use_count >= 4096)
 	{
 		security_key_update(rdp->decrypt_key, rdp->decrypt_update_key, rdp->rc4_key_len);
		crypto_rc4_free(rdp->rc4_decrypt_key);
		rdp->rc4_decrypt_key = crypto_rc4_init(rdp->decrypt_key, rdp->rc4_key_len);
		rdp->decrypt_use_count = 0;
	}
	crypto_rc4(rdp->rc4_decrypt_key, length, data, data);
	rdp->decrypt_use_count += 1;
	rdp->decrypt_checksum_use_count++;
	return TRUE;
}
",C,"	if (rdp->rc4_decrypt_key == NULL)
		return FALSE;
",,,"@@ -492,6 +492,8 @@ BOOL security_encrypt(BYTE* data, int length, rdpRdp* rdp)
 
 BOOL security_decrypt(BYTE* data, int length, rdpRdp* rdp)
 {
+	if (rdp->rc4_decrypt_key == NULL)
+		return FALSE;
 	if (rdp->decrypt_use_count >= 4096)
 	{
 		security_key_update(rdp->decrypt_key, rdp->decrypt_update_key, rdp->rc4_key_len);",FreeRDP,7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7,03fd416b3b59e03591123bde29f7371d8f76e4b3,1," BOOL security_decrypt(BYTE* data, int length, rdpRdp* rdp)
 {
//fix_flaw_line_below:
//	if (rdp->rc4_decrypt_key == NULL)
//fix_flaw_line_below:
//		return FALSE;
 	if (rdp->decrypt_use_count >= 4096)
 	{
 		security_key_update(rdp->decrypt_key, rdp->decrypt_update_key, rdp->rc4_key_len);
		crypto_rc4_free(rdp->rc4_decrypt_key);
		rdp->rc4_decrypt_key = crypto_rc4_init(rdp->decrypt_key, rdp->rc4_key_len);
		rdp->decrypt_use_count = 0;
	}
	crypto_rc4(rdp->rc4_decrypt_key, length, data, data);
	rdp->decrypt_use_count += 1;
	rdp->decrypt_checksum_use_count++;
	return TRUE;
}
"
3067,180803,,Remote,Not required,Partial,CVE-2017-1000200,https://www.cvedetails.com/cve/CVE-2017-1000200/,CWE-476,Low,,,,2017-11-16,5.0,tcmu-runner version 1.0.5 to 1.2.0 is vulnerable to a dbus triggered NULL pointer dereference in the tcmu-runner daemon's on_unregister_handler() function resulting in denial of service,2017-12-01,DoS ,1,https://github.com/open-iscsi/tcmu-runner/pull/200/commits/bb80e9c7a798f035768260ebdadffb6eb0786178,bb80e9c7a798f035768260ebdadffb6eb0786178,"only allow dynamic UnregisterHandler for external handlers, thereby fixing DoS

Trying to unregister an internal handler ended up in a SEGFAULT, because
the tcmur_handler->opaque was NULL. Way to reproduce:

dbus-send --system --print-reply --dest=org.kernel.TCMUService1 /org/kernel/TCMUService1/HandlerManager1 org.kernel.TCMUService1.HandlerManager1.UnregisterHandler string:qcow

we use a newly introduced boolean in struct tcmur_handler for keeping
track of external handlers. As suggested by mikechristie adjusting the
public data structure is acceptable.",1,main.c,"{""sha"": ""78e47560b125a81521436ce2ab2c73ad8d800d32"", ""filename"": ""main.c"", ""status"": ""modified"", ""additions"": 29, ""deletions"": 3, ""changes"": 32, ""blob_url"": ""https://github.com/open-iscsi/tcmu-runner/blob/bb80e9c7a798f035768260ebdadffb6eb0786178/main.c"", ""raw_url"": ""https://github.com/open-iscsi/tcmu-runner/raw/bb80e9c7a798f035768260ebdadffb6eb0786178/main.c"", ""contents_url"": ""https://api.github.com/repos/open-iscsi/tcmu-runner/contents/main.c?ref=bb80e9c7a798f035768260ebdadffb6eb0786178"", ""patch"": ""@@ -91,6 +91,12 @@ int tcmur_register_handler(struct tcmur_handler *handler)\n \treturn 0;\n }\n \n+static int tcmur_register_dbus_handler(struct tcmur_handler *handler)\n+{\n+\tassert(handler->_is_dbus_handler == true);\n+\treturn tcmur_register_handler(handler);\n+}\n+\n bool tcmur_unregister_handler(struct tcmur_handler *handler)\n {\n \tint i;\n@@ -103,6 +109,16 @@ bool tcmur_unregister_handler(struct tcmur_handler *handler)\n \treturn false;\n }\n \n+static bool tcmur_unregister_dbus_handler(struct tcmur_handler *handler)\n+{\n+\tbool ret = false;\n+\tassert(handler->_is_dbus_handler == true);\n+\n+\tret = tcmur_unregister_handler(handler);\n+\n+\treturn ret;\n+}\n+\n static int is_handler(const struct dirent *dirent)\n {\n \tif (strncmp(dirent->d_name, \""handler_\"", 8))\n@@ -315,7 +331,7 @@ on_handler_appeared(GDBusConnection *connection,\n \n \tif (info->register_invocation) {\n \t\tinfo->connection = connection;\n-\t\ttcmur_register_handler(handler);\n+\t\ttcmur_register_dbus_handler(handler);\n \t\tdbus_export_handler(handler, G_CALLBACK(on_dbus_check_config));\n \t\tg_dbus_method_invocation_return_value(info->register_invocation,\n \t\t\t    g_variant_new(\""(bs)\"", TRUE, \""succeeded\""));\n@@ -340,7 +356,7 @@ on_handler_vanished(GDBusConnection *connection,\n \t\t\t    g_variant_new(\""(bs)\"", FALSE, reason));\n \t\tg_free(reason);\n \t}\n-\ttcmur_unregister_handler(handler);\n+\ttcmur_unregister_dbus_handler(handler);\n \tdbus_unexport_handler(handler);\n }\n \n@@ -366,6 +382,8 @@ on_register_handler(TCMUService1HandlerManager1 *interface,\n \thandler->handle_cmd   = dbus_handler_handle_cmd;\n \n \tinfo = g_new0(struct dbus_info, 1);\n+\thandler->opaque = info;\n+\thandler->_is_dbus_handler = 1;\n \tinfo->register_invocation = invocation;\n \tinfo->watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM,\n \t\t\t\t\t    bus_name,\n@@ -394,8 +412,16 @@ on_unregister_handler(TCMUService1HandlerManager1 *interface,\n \t\t\t\t      \""unknown subtype\""));\n \t\treturn TRUE;\n \t}\n+\telse if (handler->_is_dbus_handler != 1) {\n+\t\tg_dbus_method_invocation_return_value(invocation,\n+\t\t\tg_variant_new(\""(bs)\"", FALSE,\n+\t\t\t\t      \""cannot unregister internal handler\""));\n+\t\treturn TRUE;\n+\t}\n+\n \tdbus_unexport_handler(handler);\n-\ttcmur_unregister_handler(handler);\n+\ttcmur_unregister_dbus_handler(handler);\n+\n \tg_bus_unwatch_name(info->watcher_id);\n \tg_free(info);\n \tg_free(handler);""}<_**next**_>{""sha"": ""635ed90d89e65ad5a728257b2a908a7288d77f1b"", ""filename"": ""tcmu-runner.h"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/open-iscsi/tcmu-runner/blob/bb80e9c7a798f035768260ebdadffb6eb0786178/tcmu-runner.h"", ""raw_url"": ""https://github.com/open-iscsi/tcmu-runner/raw/bb80e9c7a798f035768260ebdadffb6eb0786178/tcmu-runner.h"", ""contents_url"": ""https://api.github.com/repos/open-iscsi/tcmu-runner/contents/tcmu-runner.h?ref=bb80e9c7a798f035768260ebdadffb6eb0786178"", ""patch"": ""@@ -115,6 +115,15 @@ struct tcmur_handler {\n \tint (*lock)(struct tcmu_device *dev);\n \tint (*unlock)(struct tcmu_device *dev);\n \tint (*has_lock)(struct tcmu_device *dev);\n+\n+\t/*\n+\t * internal field, don't touch this\n+\t *\n+\t * indicates to tcmu-runner whether this is an internal handler loaded\n+\t * via dlopen or an external handler registered via dbus. In the\n+\t * latter case opaque will point to a struct dbus_info.\n+\t */\n+\tbool _is_dbus_handler;\n };\n \n /*""}","on_handler_appeared(GDBusConnection *connection,
		    const gchar     *name,
		    const gchar     *name_owner,
		    gpointer         user_data)
{
	struct tcmur_handler *handler = user_data;
	struct dbus_info *info = handler->opaque;
 
 	if (info->register_invocation) {
 		info->connection = connection;
		tcmur_register_dbus_handler(handler);
 		dbus_export_handler(handler, G_CALLBACK(on_dbus_check_config));
 		g_dbus_method_invocation_return_value(info->register_invocation,
 			    g_variant_new(""(bs)"", TRUE, ""succeeded""));
		info->register_invocation = NULL;
	}
}
","on_handler_appeared(GDBusConnection *connection,
		    const gchar     *name,
		    const gchar     *name_owner,
		    gpointer         user_data)
{
	struct tcmur_handler *handler = user_data;
	struct dbus_info *info = handler->opaque;
 
 	if (info->register_invocation) {
 		info->connection = connection;
		tcmur_register_handler(handler);
 		dbus_export_handler(handler, G_CALLBACK(on_dbus_check_config));
 		g_dbus_method_invocation_return_value(info->register_invocation,
 			    g_variant_new(""(bs)"", TRUE, ""succeeded""));
		info->register_invocation = NULL;
	}
}
",C,"		tcmur_register_dbus_handler(handler);
","		tcmur_register_handler(handler);
",,"@@ -91,6 +91,12 @@ int tcmur_register_handler(struct tcmur_handler *handler)
 	return 0;
 }
 
+static int tcmur_register_dbus_handler(struct tcmur_handler *handler)
+{
+	assert(handler->_is_dbus_handler == true);
+	return tcmur_register_handler(handler);
+}
+
 bool tcmur_unregister_handler(struct tcmur_handler *handler)
 {
 	int i;
@@ -103,6 +109,16 @@ bool tcmur_unregister_handler(struct tcmur_handler *handler)
 	return false;
 }
 
+static bool tcmur_unregister_dbus_handler(struct tcmur_handler *handler)
+{
+	bool ret = false;
+	assert(handler->_is_dbus_handler == true);
+
+	ret = tcmur_unregister_handler(handler);
+
+	return ret;
+}
+
 static int is_handler(const struct dirent *dirent)
 {
 	if (strncmp(dirent->d_name, ""handler_"", 8))
@@ -315,7 +331,7 @@ on_handler_appeared(GDBusConnection *connection,
 
 	if (info->register_invocation) {
 		info->connection = connection;
-		tcmur_register_handler(handler);
+		tcmur_register_dbus_handler(handler);
 		dbus_export_handler(handler, G_CALLBACK(on_dbus_check_config));
 		g_dbus_method_invocation_return_value(info->register_invocation,
 			    g_variant_new(""(bs)"", TRUE, ""succeeded""));
@@ -340,7 +356,7 @@ on_handler_vanished(GDBusConnection *connection,
 			    g_variant_new(""(bs)"", FALSE, reason));
 		g_free(reason);
 	}
-	tcmur_unregister_handler(handler);
+	tcmur_unregister_dbus_handler(handler);
 	dbus_unexport_handler(handler);
 }
 
@@ -366,6 +382,8 @@ on_register_handler(TCMUService1HandlerManager1 *interface,
 	handler->handle_cmd   = dbus_handler_handle_cmd;
 
 	info = g_new0(struct dbus_info, 1);
+	handler->opaque = info;
+	handler->_is_dbus_handler = 1;
 	info->register_invocation = invocation;
 	info->watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM,
 					    bus_name,
@@ -394,8 +412,16 @@ on_unregister_handler(TCMUService1HandlerManager1 *interface,
 				      ""unknown subtype""));
 		return TRUE;
 	}
+	else if (handler->_is_dbus_handler != 1) {
+		g_dbus_method_invocation_return_value(invocation,
+			g_variant_new(""(bs)"", FALSE,
+				      ""cannot unregister internal handler""));
+		return TRUE;
+	}
+
 	dbus_unexport_handler(handler);
-	tcmur_unregister_handler(handler);
+	tcmur_unregister_dbus_handler(handler);
+
 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(handler);",tcmu-runner,bb80e9c7a798f035768260ebdadffb6eb0786178,e2d953050766ac538615a811c64b34358614edce,1,"on_handler_appeared(GDBusConnection *connection,
		    const gchar     *name,
		    const gchar     *name_owner,
		    gpointer         user_data)
{
	struct tcmur_handler *handler = user_data;
	struct dbus_info *info = handler->opaque;
 
 	if (info->register_invocation) {
 		info->connection = connection;
//flaw_line_below:
		tcmur_register_handler(handler);
//fix_flaw_line_below:
//		tcmur_register_dbus_handler(handler);
 		dbus_export_handler(handler, G_CALLBACK(on_dbus_check_config));
 		g_dbus_method_invocation_return_value(info->register_invocation,
 			    g_variant_new(""(bs)"", TRUE, ""succeeded""));
		info->register_invocation = NULL;
	}
}
"
3068,180804,,Remote,Not required,Partial,CVE-2017-1000200,https://www.cvedetails.com/cve/CVE-2017-1000200/,CWE-476,Low,,,,2017-11-16,5.0,tcmu-runner version 1.0.5 to 1.2.0 is vulnerable to a dbus triggered NULL pointer dereference in the tcmu-runner daemon's on_unregister_handler() function resulting in denial of service,2017-12-01,DoS ,1,https://github.com/open-iscsi/tcmu-runner/pull/200/commits/bb80e9c7a798f035768260ebdadffb6eb0786178,bb80e9c7a798f035768260ebdadffb6eb0786178,"only allow dynamic UnregisterHandler for external handlers, thereby fixing DoS

Trying to unregister an internal handler ended up in a SEGFAULT, because
the tcmur_handler->opaque was NULL. Way to reproduce:

dbus-send --system --print-reply --dest=org.kernel.TCMUService1 /org/kernel/TCMUService1/HandlerManager1 org.kernel.TCMUService1.HandlerManager1.UnregisterHandler string:qcow

we use a newly introduced boolean in struct tcmur_handler for keeping
track of external handlers. As suggested by mikechristie adjusting the
public data structure is acceptable.",1,main.c,"{""sha"": ""78e47560b125a81521436ce2ab2c73ad8d800d32"", ""filename"": ""main.c"", ""status"": ""modified"", ""additions"": 29, ""deletions"": 3, ""changes"": 32, ""blob_url"": ""https://github.com/open-iscsi/tcmu-runner/blob/bb80e9c7a798f035768260ebdadffb6eb0786178/main.c"", ""raw_url"": ""https://github.com/open-iscsi/tcmu-runner/raw/bb80e9c7a798f035768260ebdadffb6eb0786178/main.c"", ""contents_url"": ""https://api.github.com/repos/open-iscsi/tcmu-runner/contents/main.c?ref=bb80e9c7a798f035768260ebdadffb6eb0786178"", ""patch"": ""@@ -91,6 +91,12 @@ int tcmur_register_handler(struct tcmur_handler *handler)\n \treturn 0;\n }\n \n+static int tcmur_register_dbus_handler(struct tcmur_handler *handler)\n+{\n+\tassert(handler->_is_dbus_handler == true);\n+\treturn tcmur_register_handler(handler);\n+}\n+\n bool tcmur_unregister_handler(struct tcmur_handler *handler)\n {\n \tint i;\n@@ -103,6 +109,16 @@ bool tcmur_unregister_handler(struct tcmur_handler *handler)\n \treturn false;\n }\n \n+static bool tcmur_unregister_dbus_handler(struct tcmur_handler *handler)\n+{\n+\tbool ret = false;\n+\tassert(handler->_is_dbus_handler == true);\n+\n+\tret = tcmur_unregister_handler(handler);\n+\n+\treturn ret;\n+}\n+\n static int is_handler(const struct dirent *dirent)\n {\n \tif (strncmp(dirent->d_name, \""handler_\"", 8))\n@@ -315,7 +331,7 @@ on_handler_appeared(GDBusConnection *connection,\n \n \tif (info->register_invocation) {\n \t\tinfo->connection = connection;\n-\t\ttcmur_register_handler(handler);\n+\t\ttcmur_register_dbus_handler(handler);\n \t\tdbus_export_handler(handler, G_CALLBACK(on_dbus_check_config));\n \t\tg_dbus_method_invocation_return_value(info->register_invocation,\n \t\t\t    g_variant_new(\""(bs)\"", TRUE, \""succeeded\""));\n@@ -340,7 +356,7 @@ on_handler_vanished(GDBusConnection *connection,\n \t\t\t    g_variant_new(\""(bs)\"", FALSE, reason));\n \t\tg_free(reason);\n \t}\n-\ttcmur_unregister_handler(handler);\n+\ttcmur_unregister_dbus_handler(handler);\n \tdbus_unexport_handler(handler);\n }\n \n@@ -366,6 +382,8 @@ on_register_handler(TCMUService1HandlerManager1 *interface,\n \thandler->handle_cmd   = dbus_handler_handle_cmd;\n \n \tinfo = g_new0(struct dbus_info, 1);\n+\thandler->opaque = info;\n+\thandler->_is_dbus_handler = 1;\n \tinfo->register_invocation = invocation;\n \tinfo->watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM,\n \t\t\t\t\t    bus_name,\n@@ -394,8 +412,16 @@ on_unregister_handler(TCMUService1HandlerManager1 *interface,\n \t\t\t\t      \""unknown subtype\""));\n \t\treturn TRUE;\n \t}\n+\telse if (handler->_is_dbus_handler != 1) {\n+\t\tg_dbus_method_invocation_return_value(invocation,\n+\t\t\tg_variant_new(\""(bs)\"", FALSE,\n+\t\t\t\t      \""cannot unregister internal handler\""));\n+\t\treturn TRUE;\n+\t}\n+\n \tdbus_unexport_handler(handler);\n-\ttcmur_unregister_handler(handler);\n+\ttcmur_unregister_dbus_handler(handler);\n+\n \tg_bus_unwatch_name(info->watcher_id);\n \tg_free(info);\n \tg_free(handler);""}<_**next**_>{""sha"": ""635ed90d89e65ad5a728257b2a908a7288d77f1b"", ""filename"": ""tcmu-runner.h"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/open-iscsi/tcmu-runner/blob/bb80e9c7a798f035768260ebdadffb6eb0786178/tcmu-runner.h"", ""raw_url"": ""https://github.com/open-iscsi/tcmu-runner/raw/bb80e9c7a798f035768260ebdadffb6eb0786178/tcmu-runner.h"", ""contents_url"": ""https://api.github.com/repos/open-iscsi/tcmu-runner/contents/tcmu-runner.h?ref=bb80e9c7a798f035768260ebdadffb6eb0786178"", ""patch"": ""@@ -115,6 +115,15 @@ struct tcmur_handler {\n \tint (*lock)(struct tcmu_device *dev);\n \tint (*unlock)(struct tcmu_device *dev);\n \tint (*has_lock)(struct tcmu_device *dev);\n+\n+\t/*\n+\t * internal field, don't touch this\n+\t *\n+\t * indicates to tcmu-runner whether this is an internal handler loaded\n+\t * via dlopen or an external handler registered via dbus. In the\n+\t * latter case opaque will point to a struct dbus_info.\n+\t */\n+\tbool _is_dbus_handler;\n };\n \n /*""}","on_handler_vanished(GDBusConnection *connection,
		    const gchar     *name,
		    gpointer         user_data)
{
	struct tcmur_handler *handler = user_data;
	struct dbus_info *info = handler->opaque;

	if (info->register_invocation) {
		char *reason;
		reason = g_strdup_printf(""Cannot find handler bus name: ""
				""org.kernel.TCMUService1.HandlerManager1.%s"",
				handler->subtype);
		g_dbus_method_invocation_return_value(info->register_invocation,
 			    g_variant_new(""(bs)"", FALSE, reason));
 		g_free(reason);
 	}
	tcmur_unregister_dbus_handler(handler);
 	dbus_unexport_handler(handler);
 }
","on_handler_vanished(GDBusConnection *connection,
		    const gchar     *name,
		    gpointer         user_data)
{
	struct tcmur_handler *handler = user_data;
	struct dbus_info *info = handler->opaque;

	if (info->register_invocation) {
		char *reason;
		reason = g_strdup_printf(""Cannot find handler bus name: ""
				""org.kernel.TCMUService1.HandlerManager1.%s"",
				handler->subtype);
		g_dbus_method_invocation_return_value(info->register_invocation,
 			    g_variant_new(""(bs)"", FALSE, reason));
 		g_free(reason);
 	}
	tcmur_unregister_handler(handler);
 	dbus_unexport_handler(handler);
 }
",C,"	tcmur_unregister_dbus_handler(handler);
","	tcmur_unregister_handler(handler);
",,"@@ -91,6 +91,12 @@ int tcmur_register_handler(struct tcmur_handler *handler)
 	return 0;
 }
 
+static int tcmur_register_dbus_handler(struct tcmur_handler *handler)
+{
+	assert(handler->_is_dbus_handler == true);
+	return tcmur_register_handler(handler);
+}
+
 bool tcmur_unregister_handler(struct tcmur_handler *handler)
 {
 	int i;
@@ -103,6 +109,16 @@ bool tcmur_unregister_handler(struct tcmur_handler *handler)
 	return false;
 }
 
+static bool tcmur_unregister_dbus_handler(struct tcmur_handler *handler)
+{
+	bool ret = false;
+	assert(handler->_is_dbus_handler == true);
+
+	ret = tcmur_unregister_handler(handler);
+
+	return ret;
+}
+
 static int is_handler(const struct dirent *dirent)
 {
 	if (strncmp(dirent->d_name, ""handler_"", 8))
@@ -315,7 +331,7 @@ on_handler_appeared(GDBusConnection *connection,
 
 	if (info->register_invocation) {
 		info->connection = connection;
-		tcmur_register_handler(handler);
+		tcmur_register_dbus_handler(handler);
 		dbus_export_handler(handler, G_CALLBACK(on_dbus_check_config));
 		g_dbus_method_invocation_return_value(info->register_invocation,
 			    g_variant_new(""(bs)"", TRUE, ""succeeded""));
@@ -340,7 +356,7 @@ on_handler_vanished(GDBusConnection *connection,
 			    g_variant_new(""(bs)"", FALSE, reason));
 		g_free(reason);
 	}
-	tcmur_unregister_handler(handler);
+	tcmur_unregister_dbus_handler(handler);
 	dbus_unexport_handler(handler);
 }
 
@@ -366,6 +382,8 @@ on_register_handler(TCMUService1HandlerManager1 *interface,
 	handler->handle_cmd   = dbus_handler_handle_cmd;
 
 	info = g_new0(struct dbus_info, 1);
+	handler->opaque = info;
+	handler->_is_dbus_handler = 1;
 	info->register_invocation = invocation;
 	info->watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM,
 					    bus_name,
@@ -394,8 +412,16 @@ on_unregister_handler(TCMUService1HandlerManager1 *interface,
 				      ""unknown subtype""));
 		return TRUE;
 	}
+	else if (handler->_is_dbus_handler != 1) {
+		g_dbus_method_invocation_return_value(invocation,
+			g_variant_new(""(bs)"", FALSE,
+				      ""cannot unregister internal handler""));
+		return TRUE;
+	}
+
 	dbus_unexport_handler(handler);
-	tcmur_unregister_handler(handler);
+	tcmur_unregister_dbus_handler(handler);
+
 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(handler);",tcmu-runner,bb80e9c7a798f035768260ebdadffb6eb0786178,e2d953050766ac538615a811c64b34358614edce,1,"on_handler_vanished(GDBusConnection *connection,
		    const gchar     *name,
		    gpointer         user_data)
{
	struct tcmur_handler *handler = user_data;
	struct dbus_info *info = handler->opaque;

	if (info->register_invocation) {
		char *reason;
		reason = g_strdup_printf(""Cannot find handler bus name: ""
				""org.kernel.TCMUService1.HandlerManager1.%s"",
				handler->subtype);
		g_dbus_method_invocation_return_value(info->register_invocation,
 			    g_variant_new(""(bs)"", FALSE, reason));
 		g_free(reason);
 	}
//flaw_line_below:
	tcmur_unregister_handler(handler);
//fix_flaw_line_below:
//	tcmur_unregister_dbus_handler(handler);
 	dbus_unexport_handler(handler);
 }
"
3069,180805,,Remote,Not required,Partial,CVE-2017-1000200,https://www.cvedetails.com/cve/CVE-2017-1000200/,CWE-476,Low,,,,2017-11-16,5.0,tcmu-runner version 1.0.5 to 1.2.0 is vulnerable to a dbus triggered NULL pointer dereference in the tcmu-runner daemon's on_unregister_handler() function resulting in denial of service,2017-12-01,DoS ,2,https://github.com/open-iscsi/tcmu-runner/pull/200/commits/bb80e9c7a798f035768260ebdadffb6eb0786178,bb80e9c7a798f035768260ebdadffb6eb0786178,"only allow dynamic UnregisterHandler for external handlers, thereby fixing DoS

Trying to unregister an internal handler ended up in a SEGFAULT, because
the tcmur_handler->opaque was NULL. Way to reproduce:

dbus-send --system --print-reply --dest=org.kernel.TCMUService1 /org/kernel/TCMUService1/HandlerManager1 org.kernel.TCMUService1.HandlerManager1.UnregisterHandler string:qcow

we use a newly introduced boolean in struct tcmur_handler for keeping
track of external handlers. As suggested by mikechristie adjusting the
public data structure is acceptable.",0,main.c,"{""sha"": ""78e47560b125a81521436ce2ab2c73ad8d800d32"", ""filename"": ""main.c"", ""status"": ""modified"", ""additions"": 29, ""deletions"": 3, ""changes"": 32, ""blob_url"": ""https://github.com/open-iscsi/tcmu-runner/blob/bb80e9c7a798f035768260ebdadffb6eb0786178/main.c"", ""raw_url"": ""https://github.com/open-iscsi/tcmu-runner/raw/bb80e9c7a798f035768260ebdadffb6eb0786178/main.c"", ""contents_url"": ""https://api.github.com/repos/open-iscsi/tcmu-runner/contents/main.c?ref=bb80e9c7a798f035768260ebdadffb6eb0786178"", ""patch"": ""@@ -91,6 +91,12 @@ int tcmur_register_handler(struct tcmur_handler *handler)\n \treturn 0;\n }\n \n+static int tcmur_register_dbus_handler(struct tcmur_handler *handler)\n+{\n+\tassert(handler->_is_dbus_handler == true);\n+\treturn tcmur_register_handler(handler);\n+}\n+\n bool tcmur_unregister_handler(struct tcmur_handler *handler)\n {\n \tint i;\n@@ -103,6 +109,16 @@ bool tcmur_unregister_handler(struct tcmur_handler *handler)\n \treturn false;\n }\n \n+static bool tcmur_unregister_dbus_handler(struct tcmur_handler *handler)\n+{\n+\tbool ret = false;\n+\tassert(handler->_is_dbus_handler == true);\n+\n+\tret = tcmur_unregister_handler(handler);\n+\n+\treturn ret;\n+}\n+\n static int is_handler(const struct dirent *dirent)\n {\n \tif (strncmp(dirent->d_name, \""handler_\"", 8))\n@@ -315,7 +331,7 @@ on_handler_appeared(GDBusConnection *connection,\n \n \tif (info->register_invocation) {\n \t\tinfo->connection = connection;\n-\t\ttcmur_register_handler(handler);\n+\t\ttcmur_register_dbus_handler(handler);\n \t\tdbus_export_handler(handler, G_CALLBACK(on_dbus_check_config));\n \t\tg_dbus_method_invocation_return_value(info->register_invocation,\n \t\t\t    g_variant_new(\""(bs)\"", TRUE, \""succeeded\""));\n@@ -340,7 +356,7 @@ on_handler_vanished(GDBusConnection *connection,\n \t\t\t    g_variant_new(\""(bs)\"", FALSE, reason));\n \t\tg_free(reason);\n \t}\n-\ttcmur_unregister_handler(handler);\n+\ttcmur_unregister_dbus_handler(handler);\n \tdbus_unexport_handler(handler);\n }\n \n@@ -366,6 +382,8 @@ on_register_handler(TCMUService1HandlerManager1 *interface,\n \thandler->handle_cmd   = dbus_handler_handle_cmd;\n \n \tinfo = g_new0(struct dbus_info, 1);\n+\thandler->opaque = info;\n+\thandler->_is_dbus_handler = 1;\n \tinfo->register_invocation = invocation;\n \tinfo->watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM,\n \t\t\t\t\t    bus_name,\n@@ -394,8 +412,16 @@ on_unregister_handler(TCMUService1HandlerManager1 *interface,\n \t\t\t\t      \""unknown subtype\""));\n \t\treturn TRUE;\n \t}\n+\telse if (handler->_is_dbus_handler != 1) {\n+\t\tg_dbus_method_invocation_return_value(invocation,\n+\t\t\tg_variant_new(\""(bs)\"", FALSE,\n+\t\t\t\t      \""cannot unregister internal handler\""));\n+\t\treturn TRUE;\n+\t}\n+\n \tdbus_unexport_handler(handler);\n-\ttcmur_unregister_handler(handler);\n+\ttcmur_unregister_dbus_handler(handler);\n+\n \tg_bus_unwatch_name(info->watcher_id);\n \tg_free(info);\n \tg_free(handler);""}<_**next**_>{""sha"": ""635ed90d89e65ad5a728257b2a908a7288d77f1b"", ""filename"": ""tcmu-runner.h"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/open-iscsi/tcmu-runner/blob/bb80e9c7a798f035768260ebdadffb6eb0786178/tcmu-runner.h"", ""raw_url"": ""https://github.com/open-iscsi/tcmu-runner/raw/bb80e9c7a798f035768260ebdadffb6eb0786178/tcmu-runner.h"", ""contents_url"": ""https://api.github.com/repos/open-iscsi/tcmu-runner/contents/tcmu-runner.h?ref=bb80e9c7a798f035768260ebdadffb6eb0786178"", ""patch"": ""@@ -115,6 +115,15 @@ struct tcmur_handler {\n \tint (*lock)(struct tcmu_device *dev);\n \tint (*unlock)(struct tcmu_device *dev);\n \tint (*has_lock)(struct tcmu_device *dev);\n+\n+\t/*\n+\t * internal field, don't touch this\n+\t *\n+\t * indicates to tcmu-runner whether this is an internal handler loaded\n+\t * via dlopen or an external handler registered via dbus. In the\n+\t * latter case opaque will point to a struct dbus_info.\n+\t */\n+\tbool _is_dbus_handler;\n };\n \n /*""}","on_register_handler(TCMUService1HandlerManager1 *interface,
		    GDBusMethodInvocation *invocation,
		    gchar *subtype,
		    gchar *cfg_desc,
		    gpointer user_data)
{
	struct tcmur_handler *handler;
	struct dbus_info *info;
	char *bus_name;

	bus_name = g_strdup_printf(""org.kernel.TCMUService1.HandlerManager1.%s"",
				   subtype);

	handler               = g_new0(struct tcmur_handler, 1);
	handler->subtype      = g_strdup(subtype);
	handler->cfg_desc     = g_strdup(cfg_desc);
	handler->open         = dbus_handler_open;
	handler->close        = dbus_handler_close;
 	handler->handle_cmd   = dbus_handler_handle_cmd;
 
 	info = g_new0(struct dbus_info, 1);
	handler->opaque = info;
	handler->_is_dbus_handler = 1;
 	info->register_invocation = invocation;
 	info->watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM,
 					    bus_name,
					    G_BUS_NAME_WATCHER_FLAGS_NONE,
					    on_handler_appeared,
					    on_handler_vanished,
					    handler,
					    NULL);
	g_free(bus_name);
	handler->opaque = info;
	return TRUE;
}
","on_register_handler(TCMUService1HandlerManager1 *interface,
		    GDBusMethodInvocation *invocation,
		    gchar *subtype,
		    gchar *cfg_desc,
		    gpointer user_data)
{
	struct tcmur_handler *handler;
	struct dbus_info *info;
	char *bus_name;

	bus_name = g_strdup_printf(""org.kernel.TCMUService1.HandlerManager1.%s"",
				   subtype);

	handler               = g_new0(struct tcmur_handler, 1);
	handler->subtype      = g_strdup(subtype);
	handler->cfg_desc     = g_strdup(cfg_desc);
	handler->open         = dbus_handler_open;
	handler->close        = dbus_handler_close;
 	handler->handle_cmd   = dbus_handler_handle_cmd;
 
 	info = g_new0(struct dbus_info, 1);
 	info->register_invocation = invocation;
 	info->watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM,
 					    bus_name,
					    G_BUS_NAME_WATCHER_FLAGS_NONE,
					    on_handler_appeared,
					    on_handler_vanished,
					    handler,
					    NULL);
	g_free(bus_name);
	handler->opaque = info;
	return TRUE;
}
",C,"	handler->opaque = info;
	handler->_is_dbus_handler = 1;
",,,"@@ -91,6 +91,12 @@ int tcmur_register_handler(struct tcmur_handler *handler)
 	return 0;
 }
 
+static int tcmur_register_dbus_handler(struct tcmur_handler *handler)
+{
+	assert(handler->_is_dbus_handler == true);
+	return tcmur_register_handler(handler);
+}
+
 bool tcmur_unregister_handler(struct tcmur_handler *handler)
 {
 	int i;
@@ -103,6 +109,16 @@ bool tcmur_unregister_handler(struct tcmur_handler *handler)
 	return false;
 }
 
+static bool tcmur_unregister_dbus_handler(struct tcmur_handler *handler)
+{
+	bool ret = false;
+	assert(handler->_is_dbus_handler == true);
+
+	ret = tcmur_unregister_handler(handler);
+
+	return ret;
+}
+
 static int is_handler(const struct dirent *dirent)
 {
 	if (strncmp(dirent->d_name, ""handler_"", 8))
@@ -315,7 +331,7 @@ on_handler_appeared(GDBusConnection *connection,
 
 	if (info->register_invocation) {
 		info->connection = connection;
-		tcmur_register_handler(handler);
+		tcmur_register_dbus_handler(handler);
 		dbus_export_handler(handler, G_CALLBACK(on_dbus_check_config));
 		g_dbus_method_invocation_return_value(info->register_invocation,
 			    g_variant_new(""(bs)"", TRUE, ""succeeded""));
@@ -340,7 +356,7 @@ on_handler_vanished(GDBusConnection *connection,
 			    g_variant_new(""(bs)"", FALSE, reason));
 		g_free(reason);
 	}
-	tcmur_unregister_handler(handler);
+	tcmur_unregister_dbus_handler(handler);
 	dbus_unexport_handler(handler);
 }
 
@@ -366,6 +382,8 @@ on_register_handler(TCMUService1HandlerManager1 *interface,
 	handler->handle_cmd   = dbus_handler_handle_cmd;
 
 	info = g_new0(struct dbus_info, 1);
+	handler->opaque = info;
+	handler->_is_dbus_handler = 1;
 	info->register_invocation = invocation;
 	info->watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM,
 					    bus_name,
@@ -394,8 +412,16 @@ on_unregister_handler(TCMUService1HandlerManager1 *interface,
 				      ""unknown subtype""));
 		return TRUE;
 	}
+	else if (handler->_is_dbus_handler != 1) {
+		g_dbus_method_invocation_return_value(invocation,
+			g_variant_new(""(bs)"", FALSE,
+				      ""cannot unregister internal handler""));
+		return TRUE;
+	}
+
 	dbus_unexport_handler(handler);
-	tcmur_unregister_handler(handler);
+	tcmur_unregister_dbus_handler(handler);
+
 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(handler);",tcmu-runner,bb80e9c7a798f035768260ebdadffb6eb0786178,e2d953050766ac538615a811c64b34358614edce,1,"on_register_handler(TCMUService1HandlerManager1 *interface,
		    GDBusMethodInvocation *invocation,
		    gchar *subtype,
		    gchar *cfg_desc,
		    gpointer user_data)
{
	struct tcmur_handler *handler;
	struct dbus_info *info;
	char *bus_name;

	bus_name = g_strdup_printf(""org.kernel.TCMUService1.HandlerManager1.%s"",
				   subtype);

	handler               = g_new0(struct tcmur_handler, 1);
	handler->subtype      = g_strdup(subtype);
	handler->cfg_desc     = g_strdup(cfg_desc);
	handler->open         = dbus_handler_open;
	handler->close        = dbus_handler_close;
 	handler->handle_cmd   = dbus_handler_handle_cmd;
 
 	info = g_new0(struct dbus_info, 1);
//fix_flaw_line_below:
//	handler->opaque = info;
//fix_flaw_line_below:
//	handler->_is_dbus_handler = 1;
 	info->register_invocation = invocation;
 	info->watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM,
 					    bus_name,
					    G_BUS_NAME_WATCHER_FLAGS_NONE,
					    on_handler_appeared,
					    on_handler_vanished,
					    handler,
					    NULL);
	g_free(bus_name);
	handler->opaque = info;
	return TRUE;
}
"
3070,180806,,Remote,Not required,Partial,CVE-2017-1000200,https://www.cvedetails.com/cve/CVE-2017-1000200/,CWE-476,Low,,,,2017-11-16,5.0,tcmu-runner version 1.0.5 to 1.2.0 is vulnerable to a dbus triggered NULL pointer dereference in the tcmu-runner daemon's on_unregister_handler() function resulting in denial of service,2017-12-01,DoS ,9,https://github.com/open-iscsi/tcmu-runner/pull/200/commits/bb80e9c7a798f035768260ebdadffb6eb0786178,bb80e9c7a798f035768260ebdadffb6eb0786178,"only allow dynamic UnregisterHandler for external handlers, thereby fixing DoS

Trying to unregister an internal handler ended up in a SEGFAULT, because
the tcmur_handler->opaque was NULL. Way to reproduce:

dbus-send --system --print-reply --dest=org.kernel.TCMUService1 /org/kernel/TCMUService1/HandlerManager1 org.kernel.TCMUService1.HandlerManager1.UnregisterHandler string:qcow

we use a newly introduced boolean in struct tcmur_handler for keeping
track of external handlers. As suggested by mikechristie adjusting the
public data structure is acceptable.",1,main.c,"{""sha"": ""78e47560b125a81521436ce2ab2c73ad8d800d32"", ""filename"": ""main.c"", ""status"": ""modified"", ""additions"": 29, ""deletions"": 3, ""changes"": 32, ""blob_url"": ""https://github.com/open-iscsi/tcmu-runner/blob/bb80e9c7a798f035768260ebdadffb6eb0786178/main.c"", ""raw_url"": ""https://github.com/open-iscsi/tcmu-runner/raw/bb80e9c7a798f035768260ebdadffb6eb0786178/main.c"", ""contents_url"": ""https://api.github.com/repos/open-iscsi/tcmu-runner/contents/main.c?ref=bb80e9c7a798f035768260ebdadffb6eb0786178"", ""patch"": ""@@ -91,6 +91,12 @@ int tcmur_register_handler(struct tcmur_handler *handler)\n \treturn 0;\n }\n \n+static int tcmur_register_dbus_handler(struct tcmur_handler *handler)\n+{\n+\tassert(handler->_is_dbus_handler == true);\n+\treturn tcmur_register_handler(handler);\n+}\n+\n bool tcmur_unregister_handler(struct tcmur_handler *handler)\n {\n \tint i;\n@@ -103,6 +109,16 @@ bool tcmur_unregister_handler(struct tcmur_handler *handler)\n \treturn false;\n }\n \n+static bool tcmur_unregister_dbus_handler(struct tcmur_handler *handler)\n+{\n+\tbool ret = false;\n+\tassert(handler->_is_dbus_handler == true);\n+\n+\tret = tcmur_unregister_handler(handler);\n+\n+\treturn ret;\n+}\n+\n static int is_handler(const struct dirent *dirent)\n {\n \tif (strncmp(dirent->d_name, \""handler_\"", 8))\n@@ -315,7 +331,7 @@ on_handler_appeared(GDBusConnection *connection,\n \n \tif (info->register_invocation) {\n \t\tinfo->connection = connection;\n-\t\ttcmur_register_handler(handler);\n+\t\ttcmur_register_dbus_handler(handler);\n \t\tdbus_export_handler(handler, G_CALLBACK(on_dbus_check_config));\n \t\tg_dbus_method_invocation_return_value(info->register_invocation,\n \t\t\t    g_variant_new(\""(bs)\"", TRUE, \""succeeded\""));\n@@ -340,7 +356,7 @@ on_handler_vanished(GDBusConnection *connection,\n \t\t\t    g_variant_new(\""(bs)\"", FALSE, reason));\n \t\tg_free(reason);\n \t}\n-\ttcmur_unregister_handler(handler);\n+\ttcmur_unregister_dbus_handler(handler);\n \tdbus_unexport_handler(handler);\n }\n \n@@ -366,6 +382,8 @@ on_register_handler(TCMUService1HandlerManager1 *interface,\n \thandler->handle_cmd   = dbus_handler_handle_cmd;\n \n \tinfo = g_new0(struct dbus_info, 1);\n+\thandler->opaque = info;\n+\thandler->_is_dbus_handler = 1;\n \tinfo->register_invocation = invocation;\n \tinfo->watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM,\n \t\t\t\t\t    bus_name,\n@@ -394,8 +412,16 @@ on_unregister_handler(TCMUService1HandlerManager1 *interface,\n \t\t\t\t      \""unknown subtype\""));\n \t\treturn TRUE;\n \t}\n+\telse if (handler->_is_dbus_handler != 1) {\n+\t\tg_dbus_method_invocation_return_value(invocation,\n+\t\t\tg_variant_new(\""(bs)\"", FALSE,\n+\t\t\t\t      \""cannot unregister internal handler\""));\n+\t\treturn TRUE;\n+\t}\n+\n \tdbus_unexport_handler(handler);\n-\ttcmur_unregister_handler(handler);\n+\ttcmur_unregister_dbus_handler(handler);\n+\n \tg_bus_unwatch_name(info->watcher_id);\n \tg_free(info);\n \tg_free(handler);""}<_**next**_>{""sha"": ""635ed90d89e65ad5a728257b2a908a7288d77f1b"", ""filename"": ""tcmu-runner.h"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/open-iscsi/tcmu-runner/blob/bb80e9c7a798f035768260ebdadffb6eb0786178/tcmu-runner.h"", ""raw_url"": ""https://github.com/open-iscsi/tcmu-runner/raw/bb80e9c7a798f035768260ebdadffb6eb0786178/tcmu-runner.h"", ""contents_url"": ""https://api.github.com/repos/open-iscsi/tcmu-runner/contents/tcmu-runner.h?ref=bb80e9c7a798f035768260ebdadffb6eb0786178"", ""patch"": ""@@ -115,6 +115,15 @@ struct tcmur_handler {\n \tint (*lock)(struct tcmu_device *dev);\n \tint (*unlock)(struct tcmu_device *dev);\n \tint (*has_lock)(struct tcmu_device *dev);\n+\n+\t/*\n+\t * internal field, don't touch this\n+\t *\n+\t * indicates to tcmu-runner whether this is an internal handler loaded\n+\t * via dlopen or an external handler registered via dbus. In the\n+\t * latter case opaque will point to a struct dbus_info.\n+\t */\n+\tbool _is_dbus_handler;\n };\n \n /*""}","on_unregister_handler(TCMUService1HandlerManager1 *interface,
		      GDBusMethodInvocation *invocation,
		      gchar *subtype,
		      gpointer user_data)
{
	struct tcmur_handler *handler = find_handler_by_subtype(subtype);
	struct dbus_info *info = handler ? handler->opaque : NULL;

	if (!handler) {
		g_dbus_method_invocation_return_value(invocation,
			g_variant_new(""(bs)"", FALSE,
 				      ""unknown subtype""));
 		return TRUE;
 	}
	else if (handler->_is_dbus_handler != 1) {
		g_dbus_method_invocation_return_value(invocation,
			g_variant_new(""(bs)"", FALSE,
				      ""cannot unregister internal handler""));
		return TRUE;
	}

 	dbus_unexport_handler(handler);
	tcmur_unregister_dbus_handler(handler);

 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(handler);
	g_dbus_method_invocation_return_value(invocation,
		g_variant_new(""(bs)"", TRUE, ""succeeded""));
	return TRUE;
}
","on_unregister_handler(TCMUService1HandlerManager1 *interface,
		      GDBusMethodInvocation *invocation,
		      gchar *subtype,
		      gpointer user_data)
{
	struct tcmur_handler *handler = find_handler_by_subtype(subtype);
	struct dbus_info *info = handler ? handler->opaque : NULL;

	if (!handler) {
		g_dbus_method_invocation_return_value(invocation,
			g_variant_new(""(bs)"", FALSE,
 				      ""unknown subtype""));
 		return TRUE;
 	}
 	dbus_unexport_handler(handler);
	tcmur_unregister_handler(handler);
 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(handler);
	g_dbus_method_invocation_return_value(invocation,
		g_variant_new(""(bs)"", TRUE, ""succeeded""));
	return TRUE;
}
",C,"	else if (handler->_is_dbus_handler != 1) {
		g_dbus_method_invocation_return_value(invocation,
			g_variant_new(""(bs)"", FALSE,
				      ""cannot unregister internal handler""));
		return TRUE;
	}

	tcmur_unregister_dbus_handler(handler);

","	tcmur_unregister_handler(handler);
",,"@@ -91,6 +91,12 @@ int tcmur_register_handler(struct tcmur_handler *handler)
 	return 0;
 }
 
+static int tcmur_register_dbus_handler(struct tcmur_handler *handler)
+{
+	assert(handler->_is_dbus_handler == true);
+	return tcmur_register_handler(handler);
+}
+
 bool tcmur_unregister_handler(struct tcmur_handler *handler)
 {
 	int i;
@@ -103,6 +109,16 @@ bool tcmur_unregister_handler(struct tcmur_handler *handler)
 	return false;
 }
 
+static bool tcmur_unregister_dbus_handler(struct tcmur_handler *handler)
+{
+	bool ret = false;
+	assert(handler->_is_dbus_handler == true);
+
+	ret = tcmur_unregister_handler(handler);
+
+	return ret;
+}
+
 static int is_handler(const struct dirent *dirent)
 {
 	if (strncmp(dirent->d_name, ""handler_"", 8))
@@ -315,7 +331,7 @@ on_handler_appeared(GDBusConnection *connection,
 
 	if (info->register_invocation) {
 		info->connection = connection;
-		tcmur_register_handler(handler);
+		tcmur_register_dbus_handler(handler);
 		dbus_export_handler(handler, G_CALLBACK(on_dbus_check_config));
 		g_dbus_method_invocation_return_value(info->register_invocation,
 			    g_variant_new(""(bs)"", TRUE, ""succeeded""));
@@ -340,7 +356,7 @@ on_handler_vanished(GDBusConnection *connection,
 			    g_variant_new(""(bs)"", FALSE, reason));
 		g_free(reason);
 	}
-	tcmur_unregister_handler(handler);
+	tcmur_unregister_dbus_handler(handler);
 	dbus_unexport_handler(handler);
 }
 
@@ -366,6 +382,8 @@ on_register_handler(TCMUService1HandlerManager1 *interface,
 	handler->handle_cmd   = dbus_handler_handle_cmd;
 
 	info = g_new0(struct dbus_info, 1);
+	handler->opaque = info;
+	handler->_is_dbus_handler = 1;
 	info->register_invocation = invocation;
 	info->watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM,
 					    bus_name,
@@ -394,8 +412,16 @@ on_unregister_handler(TCMUService1HandlerManager1 *interface,
 				      ""unknown subtype""));
 		return TRUE;
 	}
+	else if (handler->_is_dbus_handler != 1) {
+		g_dbus_method_invocation_return_value(invocation,
+			g_variant_new(""(bs)"", FALSE,
+				      ""cannot unregister internal handler""));
+		return TRUE;
+	}
+
 	dbus_unexport_handler(handler);
-	tcmur_unregister_handler(handler);
+	tcmur_unregister_dbus_handler(handler);
+
 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(handler);",tcmu-runner,bb80e9c7a798f035768260ebdadffb6eb0786178,e2d953050766ac538615a811c64b34358614edce,1,"on_unregister_handler(TCMUService1HandlerManager1 *interface,
		      GDBusMethodInvocation *invocation,
		      gchar *subtype,
		      gpointer user_data)
{
	struct tcmur_handler *handler = find_handler_by_subtype(subtype);
	struct dbus_info *info = handler ? handler->opaque : NULL;

	if (!handler) {
		g_dbus_method_invocation_return_value(invocation,
			g_variant_new(""(bs)"", FALSE,
 				      ""unknown subtype""));
 		return TRUE;
 	}
//fix_flaw_line_below:
//	else if (handler->_is_dbus_handler != 1) {
//fix_flaw_line_below:
//		g_dbus_method_invocation_return_value(invocation,
//fix_flaw_line_below:
//			g_variant_new(""(bs)"", FALSE,
//fix_flaw_line_below:
//				      ""cannot unregister internal handler""));
//fix_flaw_line_below:
//		return TRUE;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	dbus_unexport_handler(handler);
//flaw_line_below:
	tcmur_unregister_handler(handler);
//fix_flaw_line_below:
//	tcmur_unregister_dbus_handler(handler);
//fix_flaw_line_below:
//
 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(handler);
	g_dbus_method_invocation_return_value(invocation,
		g_variant_new(""(bs)"", TRUE, ""succeeded""));
	return TRUE;
}
"
3090,180826,,Remote,Not required,Partial,CVE-2017-17439,https://www.cvedetails.com/cve/CVE-2017-17439/,CWE-476,Low,,,,2017-12-06,5.0,"In Heimdal through 7.4, remote unauthenticated attackers are able to crash the KDC by sending a crafted UDP packet containing empty data fields for client name or realm. The parser would unconditionally dereference NULL pointers in that case, leading to a segmentation fault. This is related to the _kdc_as_rep function in kdc/kerberos5.c and the der_length_visible_string function in lib/asn1/der_length.c.",2017-12-29,,5,https://github.com/heimdal/heimdal/commit/1a6a6e462dc2ac6111f9e02c6852ddec4849b887,1a6a6e462dc2ac6111f9e02c6852ddec4849b887,"Security: Avoid NULL structure pointer member dereference

This can happen in the error path when processing malformed AS
requests with a NULL client name.  Bug originally introduced on
Fri Feb 13 09:26:01 2015 +0100 in commit:

    a873e21d7c06f22943a90a41dc733ae76799390d

    kdc: base _kdc_fast_mk_error() on krb5_mk_error_ext()

Original patch by Jeffrey Altman <jaltman@secure-endpoints.com>",3,kdc/kerberos5.c,"{""sha"": ""1582fee751b0442c578ee176db44da74edc26a66"", ""filename"": ""kdc/kerberos5.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 3, ""changes"": 8, ""blob_url"": ""https://github.com/heimdal/heimdal/blob/1a6a6e462dc2ac6111f9e02c6852ddec4849b887/kdc/kerberos5.c"", ""raw_url"": ""https://github.com/heimdal/heimdal/raw/1a6a6e462dc2ac6111f9e02c6852ddec4849b887/kdc/kerberos5.c"", ""contents_url"": ""https://api.github.com/repos/heimdal/heimdal/contents/kdc/kerberos5.c?ref=1a6a6e462dc2ac6111f9e02c6852ddec4849b887"", ""patch"": ""@@ -2232,15 +2232,17 @@ _kdc_as_rep(kdc_request_t r,\n     /*\n      * In case of a non proxy error, build an error message.\n      */\n-    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n+    if (ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n \tret = _kdc_fast_mk_error(context, r,\n \t\t\t\t &error_method,\n \t\t\t\t r->armor_crypto,\n \t\t\t\t &req->req_body,\n \t\t\t\t ret, r->e_text,\n \t\t\t\t r->server_princ,\n-\t\t\t\t &r->client_princ->name,\n-\t\t\t\t &r->client_princ->realm,\n+\t\t\t\t r->client_princ ?\n+                                     &r->client_princ->name : NULL,\n+\t\t\t\t r->client_princ ?\n+                                     &r->client_princ->realm : NULL,\n \t\t\t\t NULL, NULL,\n \t\t\t\t reply);\n \tif (ret)""}","_kdc_as_rep(kdc_request_t r,
	    krb5_data *reply,
	    const char *from,
	    struct sockaddr *from_addr,
	    int datagram_reply)
{
    krb5_context context = r->context;
    krb5_kdc_configuration *config = r->config;
    KDC_REQ *req = &r->req;
    KDC_REQ_BODY *b = NULL;
    AS_REP rep;
    KDCOptions f;
    krb5_enctype setype;
    krb5_error_code ret = 0;
    Key *skey;
    int found_pa = 0;
    int i, flags = HDB_F_FOR_AS_REQ;
    METHOD_DATA error_method;
    const PA_DATA *pa;

    memset(&rep, 0, sizeof(rep));
    error_method.len = 0;
    error_method.val = NULL;

    /*
     * Look for FAST armor and unwrap
     */
    ret = _kdc_fast_unwrap_request(r);
    if (ret) {
	_kdc_r_log(r, 0, ""FAST unwrap request from %s failed: %d"", from, ret);
	goto out;
    }

    b = &req->req_body;
    f = b->kdc_options;

    if (f.canonicalize)
	flags |= HDB_F_CANON;

    if(b->sname == NULL){
	ret = KRB5KRB_ERR_GENERIC;
	_kdc_set_e_text(r, ""No server in request"");
    } else{
	ret = _krb5_principalname2krb5_principal (context,
						  &r->server_princ,
						  *(b->sname),
						  b->realm);
	if (ret == 0)
	    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);
    }
    if (ret) {
	kdc_log(context, config, 0,
		""AS-REQ malformed server name from %s"", from);
	goto out;
    }
    if(b->cname == NULL){
	ret = KRB5KRB_ERR_GENERIC;
	_kdc_set_e_text(r, ""No client in request"");
    } else {
	ret = _krb5_principalname2krb5_principal (context,
						  &r->client_princ,
						  *(b->cname),
						  b->realm);
	if (ret)
	    goto out;

	ret = krb5_unparse_name(context, r->client_princ, &r->client_name);
    }
    if (ret) {
	kdc_log(context, config, 0,
		""AS-REQ malformed client name from %s"", from);
	goto out;
    }

    kdc_log(context, config, 0, ""AS-REQ %s from %s for %s"",
	    r->client_name, from, r->server_name);

    /*
     *
     */

    if (_kdc_is_anonymous(context, r->client_princ)) {
	if (!_kdc_is_anon_request(b)) {
	    kdc_log(context, config, 0, ""Anonymous ticket w/o anonymous flag"");
	    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
	    goto out;
	}
    } else if (_kdc_is_anon_request(b)) {
	kdc_log(context, config, 0,
		""Request for a anonymous ticket with non ""
		""anonymous client name: %s"", r->client_name);
	ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
	goto out;
    }

    /*
     *
     */

    ret = _kdc_db_fetch(context, config, r->client_princ,
			HDB_F_GET_CLIENT | flags, NULL,
			&r->clientdb, &r->client);
    if(ret == HDB_ERR_NOT_FOUND_HERE) {
	kdc_log(context, config, 5, ""client %s does not have secrets at this KDC, need to proxy"",
		r->client_name);
	goto out;
    } else if (ret == HDB_ERR_WRONG_REALM) {
	char *fixed_client_name = NULL;

	ret = krb5_unparse_name(context, r->client->entry.principal,
				&fixed_client_name);
	if (ret) {
	    goto out;
	}

	kdc_log(context, config, 0, ""WRONG_REALM - %s -> %s"",
		r->client_name, fixed_client_name);
	free(fixed_client_name);

	ret = _kdc_fast_mk_error(context, r,
				 &error_method,
				 r->armor_crypto,
				 &req->req_body,
				 KRB5_KDC_ERR_WRONG_REALM,
				 NULL,
				 r->server_princ,
				 NULL,
				 &r->client->entry.principal->realm,
				 NULL, NULL,
				 reply);
	goto out;
    } else if(ret){
	const char *msg = krb5_get_error_message(context, ret);
	kdc_log(context, config, 0, ""UNKNOWN -- %s: %s"", r->client_name, msg);
	krb5_free_error_message(context, msg);
	ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
	goto out;
    }
    ret = _kdc_db_fetch(context, config, r->server_princ,
			HDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,
			NULL, NULL, &r->server);
    if(ret == HDB_ERR_NOT_FOUND_HERE) {
	kdc_log(context, config, 5, ""target %s does not have secrets at this KDC, need to proxy"",
		r->server_name);
	goto out;
    } else if(ret){
	const char *msg = krb5_get_error_message(context, ret);
	kdc_log(context, config, 0, ""UNKNOWN -- %s: %s"", r->server_name, msg);
	krb5_free_error_message(context, msg);
	ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;
	goto out;
    }

    /*
     * Select a session enctype from the list of the crypto system
     * supported enctypes that is supported by the client and is one of
     * the enctype of the enctype of the service (likely krbtgt).
     *
     * The latter is used as a hint of what enctypes all KDC support,
     * to make sure a newer version of KDC won't generate a session
     * enctype that an older version of a KDC in the same realm can't
     * decrypt.
     */

    ret = _kdc_find_etype(context,
			  krb5_principal_is_krbtgt(context, r->server_princ) ?
			  config->tgt_use_strongest_session_key :
			  config->svc_use_strongest_session_key, FALSE,
			  r->client, b->etype.val, b->etype.len, &r->sessionetype,
			  NULL);
    if (ret) {
	kdc_log(context, config, 0,
		""Client (%s) from %s has no common enctypes with KDC ""
		""to use for the session key"",
		r->client_name, from);
	goto out;
    }

    /*
     * Pre-auth processing
     */

    if(req->padata){
	unsigned int n;

	log_patypes(context, config, req->padata);

	/* Check if preauth matching */

	for (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {
	    if (pat[n].validate == NULL)
		continue;
	    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))
		continue;

	    kdc_log(context, config, 5,
		    ""Looking for %s pa-data -- %s"", pat[n].name, r->client_name);
	    i = 0;
	    pa = _kdc_find_padata(req, &i, pat[n].type);
	    if (pa) {
		ret = pat[n].validate(r, pa);
		if (ret != 0) {
		    goto out;
		}
		kdc_log(context, config, 0,
			""%s pre-authentication succeeded -- %s"",
			pat[n].name, r->client_name);
		found_pa = 1;
		r->et.flags.pre_authent = 1;
	    }
	}
    }

    if (found_pa == 0) {
	Key *ckey = NULL;
	size_t n;

	for (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {
	    if ((pat[n].flags & PA_ANNOUNCE) == 0)
		continue;
	    ret = krb5_padata_add(context, &error_method,
				  pat[n].type, NULL, 0);
	    if (ret)
		goto out;
	}

	/*
	 * If there is a client key, send ETYPE_INFO{,2}
	 */
	ret = _kdc_find_etype(context,
			      config->preauth_use_strongest_session_key, TRUE,
			      r->client, b->etype.val, b->etype.len, NULL, &ckey);
	if (ret == 0) {

	    /*
	     * RFC4120 requires:
	     * - If the client only knows about old enctypes, then send
	     *   both info replies (we send 'info' first in the list).
	     * - If the client is 'modern', because it knows about 'new'
	     *   enctype types, then only send the 'info2' reply.
	     *
	     * Before we send the full list of etype-info data, we pick
	     * the client key we would have used anyway below, just pick
	     * that instead.
	     */

	    if (older_enctype(ckey->key.keytype)) {
		ret = get_pa_etype_info(context, config,
					&error_method, ckey);
		if (ret)
		    goto out;
	    }
	    ret = get_pa_etype_info2(context, config,
				     &error_method, ckey);
	    if (ret)
		goto out;
	}

	/* 
	 * send requre preauth is its required or anon is requested,
	 * anon is today only allowed via preauth mechanisms.
	 */
	if (require_preauth_p(r) || _kdc_is_anon_request(b)) {
	    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;
	    _kdc_set_e_text(r, ""Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ"");
	    goto out;
	}

	if (ckey == NULL) {
	    ret = KRB5KDC_ERR_CLIENT_NOTYET;
	    _kdc_set_e_text(r, ""Doesn't have a client key available"");
	    goto out;
	}
	krb5_free_keyblock_contents(r->context,  &r->reply_key);
	ret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);
	if (ret)
	    goto out;
    }

    if (r->clientdb->hdb_auth_status) {
	r->clientdb->hdb_auth_status(context, r->clientdb, r->client, 
				     HDB_AUTH_SUCCESS);
    }

    /*
     * Verify flags after the user been required to prove its identity
     * with in a preauth mech.
     */

    ret = _kdc_check_access(context, config, r->client, r->client_name,
			    r->server, r->server_name,
			    req, &error_method);
    if(ret)
	goto out;

    /*
     * Select the best encryption type for the KDC with out regard to
     * the client since the client never needs to read that data.
     */

    ret = _kdc_get_preferred_key(context, config,
				 r->server, r->server_name,
				 &setype, &skey);
    if(ret)
	goto out;

    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey
       || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {
	ret = KRB5KDC_ERR_BADOPTION;
	_kdc_set_e_text(r, ""Bad KDC options"");
	goto out;
    }

    /*
     * Build reply
     */

    rep.pvno = 5;
    rep.msg_type = krb_as_rep;

    if (_kdc_is_anonymous(context, r->client_princ)) {
	Realm anon_realm=KRB5_ANON_REALM;
	ret = copy_Realm(&anon_realm, &rep.crealm);
    } else
	ret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);
    if (ret)
	goto out;
    ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);
    if (ret)
	goto out;

    rep.ticket.tkt_vno = 5;
    ret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);
    if (ret)
	goto out;
    _krb5_principal2principalname(&rep.ticket.sname,
				  r->server->entry.principal);
    /* java 1.6 expects the name to be the same type, lets allow that
     * uncomplicated name-types. */
#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)
    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))
	rep.ticket.sname.name_type = b->sname->name_type;
#undef CNT

    r->et.flags.initial = 1;
    if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)
	r->et.flags.forwardable = f.forwardable;
    else if (f.forwardable) {
	_kdc_set_e_text(r, ""Ticket may not be forwardable"");
	ret = KRB5KDC_ERR_POLICY;
	goto out;
    }
    if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)
	r->et.flags.proxiable = f.proxiable;
    else if (f.proxiable) {
	_kdc_set_e_text(r, ""Ticket may not be proxiable"");
	ret = KRB5KDC_ERR_POLICY;
	goto out;
    }
    if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)
	r->et.flags.may_postdate = f.allow_postdate;
    else if (f.allow_postdate){
	_kdc_set_e_text(r, ""Ticket may not be postdate"");
	ret = KRB5KDC_ERR_POLICY;
	goto out;
    }

    /* check for valid set of addresses */
    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {
	_kdc_set_e_text(r, ""Bad address list in requested"");
	ret = KRB5KRB_AP_ERR_BADADDR;
	goto out;
    }

    ret = copy_PrincipalName(&rep.cname, &r->et.cname);
    if (ret)
	goto out;
    ret = copy_Realm(&rep.crealm, &r->et.crealm);
    if (ret)
	goto out;

    {
	time_t start;
	time_t t;
	
	start = r->et.authtime = kdc_time;

	if(f.postdated && req->req_body.from){
	    ALLOC(r->et.starttime);
	    start = *r->et.starttime = *req->req_body.from;
	    r->et.flags.invalid = 1;
	    r->et.flags.postdated = 1; /* XXX ??? */
	}
	_kdc_fix_time(&b->till);
	t = *b->till;

	/* be careful not overflowing */

	if(r->client->entry.max_life)
	    t = start + min(t - start, *r->client->entry.max_life);
	if(r->server->entry.max_life)
	    t = start + min(t - start, *r->server->entry.max_life);
#if 0
	t = min(t, start + realm->max_life);
#endif
	r->et.endtime = t;
	if(f.renewable_ok && r->et.endtime < *b->till){
	    f.renewable = 1;
	    if(b->rtime == NULL){
		ALLOC(b->rtime);
		*b->rtime = 0;
	    }
	    if(*b->rtime < *b->till)
		*b->rtime = *b->till;
	}
	if(f.renewable && b->rtime){
	    t = *b->rtime;
	    if(t == 0)
		t = MAX_TIME;
	    if(r->client->entry.max_renew)
		t = start + min(t - start, *r->client->entry.max_renew);
	    if(r->server->entry.max_renew)
		t = start + min(t - start, *r->server->entry.max_renew);
#if 0
	    t = min(t, start + realm->max_renew);
#endif
	    ALLOC(r->et.renew_till);
	    *r->et.renew_till = t;
	    r->et.flags.renewable = 1;
	}
    }

    if (_kdc_is_anon_request(b))
	r->et.flags.anonymous = 1;

    if(b->addresses){
	ALLOC(r->et.caddr);
	copy_HostAddresses(b->addresses, r->et.caddr);
    }

    r->et.transited.tr_type = DOMAIN_X500_COMPRESS;
    krb5_data_zero(&r->et.transited.contents);

    /* The MIT ASN.1 library (obviously) doesn't tell lengths encoded
     * as 0 and as 0x80 (meaning indefinite length) apart, and is thus
     * incapable of correctly decoding SEQUENCE OF's of zero length.
     *
     * To fix this, always send at least one no-op last_req
     *
     * If there's a pw_end or valid_end we will use that,
     * otherwise just a dummy lr.
     */
    r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));
    if (r->ek.last_req.val == NULL) {
	ret = ENOMEM;
	goto out;
    }
    r->ek.last_req.len = 0;
    if (r->client->entry.pw_end
	&& (config->kdc_warn_pwexpire == 0
	    || kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {
	r->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;
	r->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;
	++r->ek.last_req.len;
    }
    if (r->client->entry.valid_end) {
	r->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;
	r->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;
	++r->ek.last_req.len;
    }
    if (r->ek.last_req.len == 0) {
	r->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;
	r->ek.last_req.val[r->ek.last_req.len].lr_value = 0;
	++r->ek.last_req.len;
    }
    r->ek.nonce = b->nonce;
    if (r->client->entry.valid_end || r->client->entry.pw_end) {
	ALLOC(r->ek.key_expiration);
	if (r->client->entry.valid_end) {
	    if (r->client->entry.pw_end)
		*r->ek.key_expiration = min(*r->client->entry.valid_end,
					 *r->client->entry.pw_end);
	    else
		*r->ek.key_expiration = *r->client->entry.valid_end;
	} else
	    *r->ek.key_expiration = *r->client->entry.pw_end;
    } else
	r->ek.key_expiration = NULL;
    r->ek.flags = r->et.flags;
    r->ek.authtime = r->et.authtime;
    if (r->et.starttime) {
	ALLOC(r->ek.starttime);
	*r->ek.starttime = *r->et.starttime;
    }
    r->ek.endtime = r->et.endtime;
    if (r->et.renew_till) {
	ALLOC(r->ek.renew_till);
	*r->ek.renew_till = *r->et.renew_till;
    }
    ret = copy_Realm(&rep.ticket.realm, &r->ek.srealm);
    if (ret)
	goto out;
    ret = copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);
    if (ret)
	goto out;
    if(r->et.caddr){
	ALLOC(r->ek.caddr);
	copy_HostAddresses(r->et.caddr, r->ek.caddr);
    }

    /*
     * Check and session and reply keys
     */

    if (r->session_key.keytype == ETYPE_NULL) {
	ret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);
	if (ret)
	    goto out;
    }

    if (r->reply_key.keytype == ETYPE_NULL) {
	_kdc_set_e_text(r, ""Client have no reply key"");
	ret = KRB5KDC_ERR_CLIENT_NOTYET;
	goto out;
    }

    ret = copy_EncryptionKey(&r->session_key, &r->et.key);
    if (ret)
	goto out;

    ret = copy_EncryptionKey(&r->session_key, &r->ek.key);
    if (ret)
	goto out;

    if (r->outpadata.len) {

	ALLOC(rep.padata);
	if (rep.padata == NULL) {
	    ret = ENOMEM;
	    goto out;
	}
	ret = copy_METHOD_DATA(&r->outpadata, rep.padata);
	if (ret)
	    goto out;
    }

    /* Add the PAC */
    if (send_pac_p(context, req)) {
	generate_pac(r, skey);
    }

    _kdc_log_timestamp(context, config, ""AS-REQ"", r->et.authtime, r->et.starttime,
		       r->et.endtime, r->et.renew_till);

    /* do this as the last thing since this signs the EncTicketPart */
    ret = _kdc_add_KRB5SignedPath(context,
				  config,
				  r->server,
				  setype,
				  r->client->entry.principal,
				  NULL,
				  NULL,
				  &r->et);
    if (ret)
	goto out;

    log_as_req(context, config, r->reply_key.keytype, setype, b);

    /*
     * We always say we support FAST/enc-pa-rep
     */

    r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;

    /*
     * Add REQ_ENC_PA_REP if client supports it
     */

    i = 0;
    pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);
    if (pa) {

	ret = add_enc_pa_rep(r);
	if (ret) {
	    const char *msg = krb5_get_error_message(r->context, ret);
	    _kdc_r_log(r, 0, ""add_enc_pa_rep failed: %s: %d"", msg, ret);
	    krb5_free_error_message(r->context, msg);
	    goto out;
	}
    }

    /*
     *
     */

    ret = _kdc_encode_reply(context, config,
			    r->armor_crypto, req->req_body.nonce,
			    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,
			    &skey->key, r->client->entry.kvno,
			    &r->reply_key, 0, &r->e_text, reply);
    if (ret)
	goto out;

    /*
     * Check if message too large
     */
    if (datagram_reply && reply->length > config->max_datagram_reply_length) {
	krb5_data_free(reply);
	ret = KRB5KRB_ERR_RESPONSE_TOO_BIG;
	_kdc_set_e_text(r, ""Reply packet too large"");
    }

out:
    free_AS_REP(&rep);

     /*
      * In case of a non proxy error, build an error message.
      */
    if (ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {
 	ret = _kdc_fast_mk_error(context, r,
 				 &error_method,
 				 r->armor_crypto,
 				 &req->req_body,
 				 ret, r->e_text,
 				 r->server_princ,
				 r->client_princ ?
                                     &r->client_princ->name : NULL,
				 r->client_princ ?
                                     &r->client_princ->realm : NULL,
 				 NULL, NULL,
 				 reply);
 	if (ret)
	    goto out2;
    }
out2:
    free_EncTicketPart(&r->et);
    free_EncKDCRepPart(&r->ek);
    free_KDCFastState(&r->fast);

    if (error_method.len)
	free_METHOD_DATA(&error_method);
    if (r->outpadata.len)
	free_METHOD_DATA(&r->outpadata);
    if (r->client_princ) {
	krb5_free_principal(context, r->client_princ);
	r->client_princ = NULL;
    }
    if (r->client_name) {
	free(r->client_name);
	r->client_name = NULL;
    }
    if (r->server_princ){
	krb5_free_principal(context, r->server_princ);
	r->server_princ = NULL;
    }
    if (r->server_name) {
	free(r->server_name);
	r->server_name = NULL;
    }
    if (r->client)
	_kdc_free_ent(context, r->client);
    if (r->server)
	_kdc_free_ent(context, r->server);
    if (r->armor_crypto) {
	krb5_crypto_destroy(r->context, r->armor_crypto);
	r->armor_crypto = NULL;
    }
    krb5_free_keyblock_contents(r->context, &r->reply_key);
    krb5_free_keyblock_contents(r->context, &r->session_key);
    return ret;
}
","_kdc_as_rep(kdc_request_t r,
	    krb5_data *reply,
	    const char *from,
	    struct sockaddr *from_addr,
	    int datagram_reply)
{
    krb5_context context = r->context;
    krb5_kdc_configuration *config = r->config;
    KDC_REQ *req = &r->req;
    KDC_REQ_BODY *b = NULL;
    AS_REP rep;
    KDCOptions f;
    krb5_enctype setype;
    krb5_error_code ret = 0;
    Key *skey;
    int found_pa = 0;
    int i, flags = HDB_F_FOR_AS_REQ;
    METHOD_DATA error_method;
    const PA_DATA *pa;

    memset(&rep, 0, sizeof(rep));
    error_method.len = 0;
    error_method.val = NULL;

    /*
     * Look for FAST armor and unwrap
     */
    ret = _kdc_fast_unwrap_request(r);
    if (ret) {
	_kdc_r_log(r, 0, ""FAST unwrap request from %s failed: %d"", from, ret);
	goto out;
    }

    b = &req->req_body;
    f = b->kdc_options;

    if (f.canonicalize)
	flags |= HDB_F_CANON;

    if(b->sname == NULL){
	ret = KRB5KRB_ERR_GENERIC;
	_kdc_set_e_text(r, ""No server in request"");
    } else{
	ret = _krb5_principalname2krb5_principal (context,
						  &r->server_princ,
						  *(b->sname),
						  b->realm);
	if (ret == 0)
	    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);
    }
    if (ret) {
	kdc_log(context, config, 0,
		""AS-REQ malformed server name from %s"", from);
	goto out;
    }
    if(b->cname == NULL){
	ret = KRB5KRB_ERR_GENERIC;
	_kdc_set_e_text(r, ""No client in request"");
    } else {
	ret = _krb5_principalname2krb5_principal (context,
						  &r->client_princ,
						  *(b->cname),
						  b->realm);
	if (ret)
	    goto out;

	ret = krb5_unparse_name(context, r->client_princ, &r->client_name);
    }
    if (ret) {
	kdc_log(context, config, 0,
		""AS-REQ malformed client name from %s"", from);
	goto out;
    }

    kdc_log(context, config, 0, ""AS-REQ %s from %s for %s"",
	    r->client_name, from, r->server_name);

    /*
     *
     */

    if (_kdc_is_anonymous(context, r->client_princ)) {
	if (!_kdc_is_anon_request(b)) {
	    kdc_log(context, config, 0, ""Anonymous ticket w/o anonymous flag"");
	    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
	    goto out;
	}
    } else if (_kdc_is_anon_request(b)) {
	kdc_log(context, config, 0,
		""Request for a anonymous ticket with non ""
		""anonymous client name: %s"", r->client_name);
	ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
	goto out;
    }

    /*
     *
     */

    ret = _kdc_db_fetch(context, config, r->client_princ,
			HDB_F_GET_CLIENT | flags, NULL,
			&r->clientdb, &r->client);
    if(ret == HDB_ERR_NOT_FOUND_HERE) {
	kdc_log(context, config, 5, ""client %s does not have secrets at this KDC, need to proxy"",
		r->client_name);
	goto out;
    } else if (ret == HDB_ERR_WRONG_REALM) {
	char *fixed_client_name = NULL;

	ret = krb5_unparse_name(context, r->client->entry.principal,
				&fixed_client_name);
	if (ret) {
	    goto out;
	}

	kdc_log(context, config, 0, ""WRONG_REALM - %s -> %s"",
		r->client_name, fixed_client_name);
	free(fixed_client_name);

	ret = _kdc_fast_mk_error(context, r,
				 &error_method,
				 r->armor_crypto,
				 &req->req_body,
				 KRB5_KDC_ERR_WRONG_REALM,
				 NULL,
				 r->server_princ,
				 NULL,
				 &r->client->entry.principal->realm,
				 NULL, NULL,
				 reply);
	goto out;
    } else if(ret){
	const char *msg = krb5_get_error_message(context, ret);
	kdc_log(context, config, 0, ""UNKNOWN -- %s: %s"", r->client_name, msg);
	krb5_free_error_message(context, msg);
	ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
	goto out;
    }
    ret = _kdc_db_fetch(context, config, r->server_princ,
			HDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,
			NULL, NULL, &r->server);
    if(ret == HDB_ERR_NOT_FOUND_HERE) {
	kdc_log(context, config, 5, ""target %s does not have secrets at this KDC, need to proxy"",
		r->server_name);
	goto out;
    } else if(ret){
	const char *msg = krb5_get_error_message(context, ret);
	kdc_log(context, config, 0, ""UNKNOWN -- %s: %s"", r->server_name, msg);
	krb5_free_error_message(context, msg);
	ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;
	goto out;
    }

    /*
     * Select a session enctype from the list of the crypto system
     * supported enctypes that is supported by the client and is one of
     * the enctype of the enctype of the service (likely krbtgt).
     *
     * The latter is used as a hint of what enctypes all KDC support,
     * to make sure a newer version of KDC won't generate a session
     * enctype that an older version of a KDC in the same realm can't
     * decrypt.
     */

    ret = _kdc_find_etype(context,
			  krb5_principal_is_krbtgt(context, r->server_princ) ?
			  config->tgt_use_strongest_session_key :
			  config->svc_use_strongest_session_key, FALSE,
			  r->client, b->etype.val, b->etype.len, &r->sessionetype,
			  NULL);
    if (ret) {
	kdc_log(context, config, 0,
		""Client (%s) from %s has no common enctypes with KDC ""
		""to use for the session key"",
		r->client_name, from);
	goto out;
    }

    /*
     * Pre-auth processing
     */

    if(req->padata){
	unsigned int n;

	log_patypes(context, config, req->padata);

	/* Check if preauth matching */

	for (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {
	    if (pat[n].validate == NULL)
		continue;
	    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))
		continue;

	    kdc_log(context, config, 5,
		    ""Looking for %s pa-data -- %s"", pat[n].name, r->client_name);
	    i = 0;
	    pa = _kdc_find_padata(req, &i, pat[n].type);
	    if (pa) {
		ret = pat[n].validate(r, pa);
		if (ret != 0) {
		    goto out;
		}
		kdc_log(context, config, 0,
			""%s pre-authentication succeeded -- %s"",
			pat[n].name, r->client_name);
		found_pa = 1;
		r->et.flags.pre_authent = 1;
	    }
	}
    }

    if (found_pa == 0) {
	Key *ckey = NULL;
	size_t n;

	for (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {
	    if ((pat[n].flags & PA_ANNOUNCE) == 0)
		continue;
	    ret = krb5_padata_add(context, &error_method,
				  pat[n].type, NULL, 0);
	    if (ret)
		goto out;
	}

	/*
	 * If there is a client key, send ETYPE_INFO{,2}
	 */
	ret = _kdc_find_etype(context,
			      config->preauth_use_strongest_session_key, TRUE,
			      r->client, b->etype.val, b->etype.len, NULL, &ckey);
	if (ret == 0) {

	    /*
	     * RFC4120 requires:
	     * - If the client only knows about old enctypes, then send
	     *   both info replies (we send 'info' first in the list).
	     * - If the client is 'modern', because it knows about 'new'
	     *   enctype types, then only send the 'info2' reply.
	     *
	     * Before we send the full list of etype-info data, we pick
	     * the client key we would have used anyway below, just pick
	     * that instead.
	     */

	    if (older_enctype(ckey->key.keytype)) {
		ret = get_pa_etype_info(context, config,
					&error_method, ckey);
		if (ret)
		    goto out;
	    }
	    ret = get_pa_etype_info2(context, config,
				     &error_method, ckey);
	    if (ret)
		goto out;
	}

	/* 
	 * send requre preauth is its required or anon is requested,
	 * anon is today only allowed via preauth mechanisms.
	 */
	if (require_preauth_p(r) || _kdc_is_anon_request(b)) {
	    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;
	    _kdc_set_e_text(r, ""Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ"");
	    goto out;
	}

	if (ckey == NULL) {
	    ret = KRB5KDC_ERR_CLIENT_NOTYET;
	    _kdc_set_e_text(r, ""Doesn't have a client key available"");
	    goto out;
	}
	krb5_free_keyblock_contents(r->context,  &r->reply_key);
	ret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);
	if (ret)
	    goto out;
    }

    if (r->clientdb->hdb_auth_status) {
	r->clientdb->hdb_auth_status(context, r->clientdb, r->client, 
				     HDB_AUTH_SUCCESS);
    }

    /*
     * Verify flags after the user been required to prove its identity
     * with in a preauth mech.
     */

    ret = _kdc_check_access(context, config, r->client, r->client_name,
			    r->server, r->server_name,
			    req, &error_method);
    if(ret)
	goto out;

    /*
     * Select the best encryption type for the KDC with out regard to
     * the client since the client never needs to read that data.
     */

    ret = _kdc_get_preferred_key(context, config,
				 r->server, r->server_name,
				 &setype, &skey);
    if(ret)
	goto out;

    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey
       || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {
	ret = KRB5KDC_ERR_BADOPTION;
	_kdc_set_e_text(r, ""Bad KDC options"");
	goto out;
    }

    /*
     * Build reply
     */

    rep.pvno = 5;
    rep.msg_type = krb_as_rep;

    if (_kdc_is_anonymous(context, r->client_princ)) {
	Realm anon_realm=KRB5_ANON_REALM;
	ret = copy_Realm(&anon_realm, &rep.crealm);
    } else
	ret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);
    if (ret)
	goto out;
    ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);
    if (ret)
	goto out;

    rep.ticket.tkt_vno = 5;
    ret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);
    if (ret)
	goto out;
    _krb5_principal2principalname(&rep.ticket.sname,
				  r->server->entry.principal);
    /* java 1.6 expects the name to be the same type, lets allow that
     * uncomplicated name-types. */
#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)
    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))
	rep.ticket.sname.name_type = b->sname->name_type;
#undef CNT

    r->et.flags.initial = 1;
    if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)
	r->et.flags.forwardable = f.forwardable;
    else if (f.forwardable) {
	_kdc_set_e_text(r, ""Ticket may not be forwardable"");
	ret = KRB5KDC_ERR_POLICY;
	goto out;
    }
    if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)
	r->et.flags.proxiable = f.proxiable;
    else if (f.proxiable) {
	_kdc_set_e_text(r, ""Ticket may not be proxiable"");
	ret = KRB5KDC_ERR_POLICY;
	goto out;
    }
    if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)
	r->et.flags.may_postdate = f.allow_postdate;
    else if (f.allow_postdate){
	_kdc_set_e_text(r, ""Ticket may not be postdate"");
	ret = KRB5KDC_ERR_POLICY;
	goto out;
    }

    /* check for valid set of addresses */
    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {
	_kdc_set_e_text(r, ""Bad address list in requested"");
	ret = KRB5KRB_AP_ERR_BADADDR;
	goto out;
    }

    ret = copy_PrincipalName(&rep.cname, &r->et.cname);
    if (ret)
	goto out;
    ret = copy_Realm(&rep.crealm, &r->et.crealm);
    if (ret)
	goto out;

    {
	time_t start;
	time_t t;
	
	start = r->et.authtime = kdc_time;

	if(f.postdated && req->req_body.from){
	    ALLOC(r->et.starttime);
	    start = *r->et.starttime = *req->req_body.from;
	    r->et.flags.invalid = 1;
	    r->et.flags.postdated = 1; /* XXX ??? */
	}
	_kdc_fix_time(&b->till);
	t = *b->till;

	/* be careful not overflowing */

	if(r->client->entry.max_life)
	    t = start + min(t - start, *r->client->entry.max_life);
	if(r->server->entry.max_life)
	    t = start + min(t - start, *r->server->entry.max_life);
#if 0
	t = min(t, start + realm->max_life);
#endif
	r->et.endtime = t;
	if(f.renewable_ok && r->et.endtime < *b->till){
	    f.renewable = 1;
	    if(b->rtime == NULL){
		ALLOC(b->rtime);
		*b->rtime = 0;
	    }
	    if(*b->rtime < *b->till)
		*b->rtime = *b->till;
	}
	if(f.renewable && b->rtime){
	    t = *b->rtime;
	    if(t == 0)
		t = MAX_TIME;
	    if(r->client->entry.max_renew)
		t = start + min(t - start, *r->client->entry.max_renew);
	    if(r->server->entry.max_renew)
		t = start + min(t - start, *r->server->entry.max_renew);
#if 0
	    t = min(t, start + realm->max_renew);
#endif
	    ALLOC(r->et.renew_till);
	    *r->et.renew_till = t;
	    r->et.flags.renewable = 1;
	}
    }

    if (_kdc_is_anon_request(b))
	r->et.flags.anonymous = 1;

    if(b->addresses){
	ALLOC(r->et.caddr);
	copy_HostAddresses(b->addresses, r->et.caddr);
    }

    r->et.transited.tr_type = DOMAIN_X500_COMPRESS;
    krb5_data_zero(&r->et.transited.contents);

    /* The MIT ASN.1 library (obviously) doesn't tell lengths encoded
     * as 0 and as 0x80 (meaning indefinite length) apart, and is thus
     * incapable of correctly decoding SEQUENCE OF's of zero length.
     *
     * To fix this, always send at least one no-op last_req
     *
     * If there's a pw_end or valid_end we will use that,
     * otherwise just a dummy lr.
     */
    r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));
    if (r->ek.last_req.val == NULL) {
	ret = ENOMEM;
	goto out;
    }
    r->ek.last_req.len = 0;
    if (r->client->entry.pw_end
	&& (config->kdc_warn_pwexpire == 0
	    || kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {
	r->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;
	r->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;
	++r->ek.last_req.len;
    }
    if (r->client->entry.valid_end) {
	r->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;
	r->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;
	++r->ek.last_req.len;
    }
    if (r->ek.last_req.len == 0) {
	r->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;
	r->ek.last_req.val[r->ek.last_req.len].lr_value = 0;
	++r->ek.last_req.len;
    }
    r->ek.nonce = b->nonce;
    if (r->client->entry.valid_end || r->client->entry.pw_end) {
	ALLOC(r->ek.key_expiration);
	if (r->client->entry.valid_end) {
	    if (r->client->entry.pw_end)
		*r->ek.key_expiration = min(*r->client->entry.valid_end,
					 *r->client->entry.pw_end);
	    else
		*r->ek.key_expiration = *r->client->entry.valid_end;
	} else
	    *r->ek.key_expiration = *r->client->entry.pw_end;
    } else
	r->ek.key_expiration = NULL;
    r->ek.flags = r->et.flags;
    r->ek.authtime = r->et.authtime;
    if (r->et.starttime) {
	ALLOC(r->ek.starttime);
	*r->ek.starttime = *r->et.starttime;
    }
    r->ek.endtime = r->et.endtime;
    if (r->et.renew_till) {
	ALLOC(r->ek.renew_till);
	*r->ek.renew_till = *r->et.renew_till;
    }
    ret = copy_Realm(&rep.ticket.realm, &r->ek.srealm);
    if (ret)
	goto out;
    ret = copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);
    if (ret)
	goto out;
    if(r->et.caddr){
	ALLOC(r->ek.caddr);
	copy_HostAddresses(r->et.caddr, r->ek.caddr);
    }

    /*
     * Check and session and reply keys
     */

    if (r->session_key.keytype == ETYPE_NULL) {
	ret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);
	if (ret)
	    goto out;
    }

    if (r->reply_key.keytype == ETYPE_NULL) {
	_kdc_set_e_text(r, ""Client have no reply key"");
	ret = KRB5KDC_ERR_CLIENT_NOTYET;
	goto out;
    }

    ret = copy_EncryptionKey(&r->session_key, &r->et.key);
    if (ret)
	goto out;

    ret = copy_EncryptionKey(&r->session_key, &r->ek.key);
    if (ret)
	goto out;

    if (r->outpadata.len) {

	ALLOC(rep.padata);
	if (rep.padata == NULL) {
	    ret = ENOMEM;
	    goto out;
	}
	ret = copy_METHOD_DATA(&r->outpadata, rep.padata);
	if (ret)
	    goto out;
    }

    /* Add the PAC */
    if (send_pac_p(context, req)) {
	generate_pac(r, skey);
    }

    _kdc_log_timestamp(context, config, ""AS-REQ"", r->et.authtime, r->et.starttime,
		       r->et.endtime, r->et.renew_till);

    /* do this as the last thing since this signs the EncTicketPart */
    ret = _kdc_add_KRB5SignedPath(context,
				  config,
				  r->server,
				  setype,
				  r->client->entry.principal,
				  NULL,
				  NULL,
				  &r->et);
    if (ret)
	goto out;

    log_as_req(context, config, r->reply_key.keytype, setype, b);

    /*
     * We always say we support FAST/enc-pa-rep
     */

    r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;

    /*
     * Add REQ_ENC_PA_REP if client supports it
     */

    i = 0;
    pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);
    if (pa) {

	ret = add_enc_pa_rep(r);
	if (ret) {
	    const char *msg = krb5_get_error_message(r->context, ret);
	    _kdc_r_log(r, 0, ""add_enc_pa_rep failed: %s: %d"", msg, ret);
	    krb5_free_error_message(r->context, msg);
	    goto out;
	}
    }

    /*
     *
     */

    ret = _kdc_encode_reply(context, config,
			    r->armor_crypto, req->req_body.nonce,
			    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,
			    &skey->key, r->client->entry.kvno,
			    &r->reply_key, 0, &r->e_text, reply);
    if (ret)
	goto out;

    /*
     * Check if message too large
     */
    if (datagram_reply && reply->length > config->max_datagram_reply_length) {
	krb5_data_free(reply);
	ret = KRB5KRB_ERR_RESPONSE_TOO_BIG;
	_kdc_set_e_text(r, ""Reply packet too large"");
    }

out:
    free_AS_REP(&rep);

     /*
      * In case of a non proxy error, build an error message.
      */
    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {
 	ret = _kdc_fast_mk_error(context, r,
 				 &error_method,
 				 r->armor_crypto,
 				 &req->req_body,
 				 ret, r->e_text,
 				 r->server_princ,
				 &r->client_princ->name,
				 &r->client_princ->realm,
 				 NULL, NULL,
 				 reply);
 	if (ret)
	    goto out2;
    }
out2:
    free_EncTicketPart(&r->et);
    free_EncKDCRepPart(&r->ek);
    free_KDCFastState(&r->fast);

    if (error_method.len)
	free_METHOD_DATA(&error_method);
    if (r->outpadata.len)
	free_METHOD_DATA(&r->outpadata);
    if (r->client_princ) {
	krb5_free_principal(context, r->client_princ);
	r->client_princ = NULL;
    }
    if (r->client_name) {
	free(r->client_name);
	r->client_name = NULL;
    }
    if (r->server_princ){
	krb5_free_principal(context, r->server_princ);
	r->server_princ = NULL;
    }
    if (r->server_name) {
	free(r->server_name);
	r->server_name = NULL;
    }
    if (r->client)
	_kdc_free_ent(context, r->client);
    if (r->server)
	_kdc_free_ent(context, r->server);
    if (r->armor_crypto) {
	krb5_crypto_destroy(r->context, r->armor_crypto);
	r->armor_crypto = NULL;
    }
    krb5_free_keyblock_contents(r->context, &r->reply_key);
    krb5_free_keyblock_contents(r->context, &r->session_key);
    return ret;
}
",C,"    if (ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {
				 r->client_princ ?
                                     &r->client_princ->name : NULL,
				 r->client_princ ?
                                     &r->client_princ->realm : NULL,
","    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {
				 &r->client_princ->name,
				 &r->client_princ->realm,
",,"@@ -2232,15 +2232,17 @@ _kdc_as_rep(kdc_request_t r,
     /*
      * In case of a non proxy error, build an error message.
      */
-    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {
+    if (ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {
 	ret = _kdc_fast_mk_error(context, r,
 				 &error_method,
 				 r->armor_crypto,
 				 &req->req_body,
 				 ret, r->e_text,
 				 r->server_princ,
-				 &r->client_princ->name,
-				 &r->client_princ->realm,
+				 r->client_princ ?
+                                     &r->client_princ->name : NULL,
+				 r->client_princ ?
+                                     &r->client_princ->realm : NULL,
 				 NULL, NULL,
 				 reply);
 	if (ret)",heimdal,1a6a6e462dc2ac6111f9e02c6852ddec4849b887,abee4b3f6851914d47740a1d96beafd6cc0ee9bf,1,"_kdc_as_rep(kdc_request_t r,
	    krb5_data *reply,
	    const char *from,
	    struct sockaddr *from_addr,
	    int datagram_reply)
{
    krb5_context context = r->context;
    krb5_kdc_configuration *config = r->config;
    KDC_REQ *req = &r->req;
    KDC_REQ_BODY *b = NULL;
    AS_REP rep;
    KDCOptions f;
    krb5_enctype setype;
    krb5_error_code ret = 0;
    Key *skey;
    int found_pa = 0;
    int i, flags = HDB_F_FOR_AS_REQ;
    METHOD_DATA error_method;
    const PA_DATA *pa;

    memset(&rep, 0, sizeof(rep));
    error_method.len = 0;
    error_method.val = NULL;

    /*
     * Look for FAST armor and unwrap
     */
    ret = _kdc_fast_unwrap_request(r);
    if (ret) {
	_kdc_r_log(r, 0, ""FAST unwrap request from %s failed: %d"", from, ret);
	goto out;
    }

    b = &req->req_body;
    f = b->kdc_options;

    if (f.canonicalize)
	flags |= HDB_F_CANON;

    if(b->sname == NULL){
	ret = KRB5KRB_ERR_GENERIC;
	_kdc_set_e_text(r, ""No server in request"");
    } else{
	ret = _krb5_principalname2krb5_principal (context,
						  &r->server_princ,
						  *(b->sname),
						  b->realm);
	if (ret == 0)
	    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);
    }
    if (ret) {
	kdc_log(context, config, 0,
		""AS-REQ malformed server name from %s"", from);
	goto out;
    }
    if(b->cname == NULL){
	ret = KRB5KRB_ERR_GENERIC;
	_kdc_set_e_text(r, ""No client in request"");
    } else {
	ret = _krb5_principalname2krb5_principal (context,
						  &r->client_princ,
						  *(b->cname),
						  b->realm);
	if (ret)
	    goto out;

	ret = krb5_unparse_name(context, r->client_princ, &r->client_name);
    }
    if (ret) {
	kdc_log(context, config, 0,
		""AS-REQ malformed client name from %s"", from);
	goto out;
    }

    kdc_log(context, config, 0, ""AS-REQ %s from %s for %s"",
	    r->client_name, from, r->server_name);

    /*
     *
     */

    if (_kdc_is_anonymous(context, r->client_princ)) {
	if (!_kdc_is_anon_request(b)) {
	    kdc_log(context, config, 0, ""Anonymous ticket w/o anonymous flag"");
	    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
	    goto out;
	}
    } else if (_kdc_is_anon_request(b)) {
	kdc_log(context, config, 0,
		""Request for a anonymous ticket with non ""
		""anonymous client name: %s"", r->client_name);
	ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
	goto out;
    }

    /*
     *
     */

    ret = _kdc_db_fetch(context, config, r->client_princ,
			HDB_F_GET_CLIENT | flags, NULL,
			&r->clientdb, &r->client);
    if(ret == HDB_ERR_NOT_FOUND_HERE) {
	kdc_log(context, config, 5, ""client %s does not have secrets at this KDC, need to proxy"",
		r->client_name);
	goto out;
    } else if (ret == HDB_ERR_WRONG_REALM) {
	char *fixed_client_name = NULL;

	ret = krb5_unparse_name(context, r->client->entry.principal,
				&fixed_client_name);
	if (ret) {
	    goto out;
	}

	kdc_log(context, config, 0, ""WRONG_REALM - %s -> %s"",
		r->client_name, fixed_client_name);
	free(fixed_client_name);

	ret = _kdc_fast_mk_error(context, r,
				 &error_method,
				 r->armor_crypto,
				 &req->req_body,
				 KRB5_KDC_ERR_WRONG_REALM,
				 NULL,
				 r->server_princ,
				 NULL,
				 &r->client->entry.principal->realm,
				 NULL, NULL,
				 reply);
	goto out;
    } else if(ret){
	const char *msg = krb5_get_error_message(context, ret);
	kdc_log(context, config, 0, ""UNKNOWN -- %s: %s"", r->client_name, msg);
	krb5_free_error_message(context, msg);
	ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
	goto out;
    }
    ret = _kdc_db_fetch(context, config, r->server_princ,
			HDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,
			NULL, NULL, &r->server);
    if(ret == HDB_ERR_NOT_FOUND_HERE) {
	kdc_log(context, config, 5, ""target %s does not have secrets at this KDC, need to proxy"",
		r->server_name);
	goto out;
    } else if(ret){
	const char *msg = krb5_get_error_message(context, ret);
	kdc_log(context, config, 0, ""UNKNOWN -- %s: %s"", r->server_name, msg);
	krb5_free_error_message(context, msg);
	ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;
	goto out;
    }

    /*
     * Select a session enctype from the list of the crypto system
     * supported enctypes that is supported by the client and is one of
     * the enctype of the enctype of the service (likely krbtgt).
     *
     * The latter is used as a hint of what enctypes all KDC support,
     * to make sure a newer version of KDC won't generate a session
     * enctype that an older version of a KDC in the same realm can't
     * decrypt.
     */

    ret = _kdc_find_etype(context,
			  krb5_principal_is_krbtgt(context, r->server_princ) ?
			  config->tgt_use_strongest_session_key :
			  config->svc_use_strongest_session_key, FALSE,
			  r->client, b->etype.val, b->etype.len, &r->sessionetype,
			  NULL);
    if (ret) {
	kdc_log(context, config, 0,
		""Client (%s) from %s has no common enctypes with KDC ""
		""to use for the session key"",
		r->client_name, from);
	goto out;
    }

    /*
     * Pre-auth processing
     */

    if(req->padata){
	unsigned int n;

	log_patypes(context, config, req->padata);

	/* Check if preauth matching */

	for (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {
	    if (pat[n].validate == NULL)
		continue;
	    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))
		continue;

	    kdc_log(context, config, 5,
		    ""Looking for %s pa-data -- %s"", pat[n].name, r->client_name);
	    i = 0;
	    pa = _kdc_find_padata(req, &i, pat[n].type);
	    if (pa) {
		ret = pat[n].validate(r, pa);
		if (ret != 0) {
		    goto out;
		}
		kdc_log(context, config, 0,
			""%s pre-authentication succeeded -- %s"",
			pat[n].name, r->client_name);
		found_pa = 1;
		r->et.flags.pre_authent = 1;
	    }
	}
    }

    if (found_pa == 0) {
	Key *ckey = NULL;
	size_t n;

	for (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {
	    if ((pat[n].flags & PA_ANNOUNCE) == 0)
		continue;
	    ret = krb5_padata_add(context, &error_method,
				  pat[n].type, NULL, 0);
	    if (ret)
		goto out;
	}

	/*
	 * If there is a client key, send ETYPE_INFO{,2}
	 */
	ret = _kdc_find_etype(context,
			      config->preauth_use_strongest_session_key, TRUE,
			      r->client, b->etype.val, b->etype.len, NULL, &ckey);
	if (ret == 0) {

	    /*
	     * RFC4120 requires:
	     * - If the client only knows about old enctypes, then send
	     *   both info replies (we send 'info' first in the list).
	     * - If the client is 'modern', because it knows about 'new'
	     *   enctype types, then only send the 'info2' reply.
	     *
	     * Before we send the full list of etype-info data, we pick
	     * the client key we would have used anyway below, just pick
	     * that instead.
	     */

	    if (older_enctype(ckey->key.keytype)) {
		ret = get_pa_etype_info(context, config,
					&error_method, ckey);
		if (ret)
		    goto out;
	    }
	    ret = get_pa_etype_info2(context, config,
				     &error_method, ckey);
	    if (ret)
		goto out;
	}

	/* 
	 * send requre preauth is its required or anon is requested,
	 * anon is today only allowed via preauth mechanisms.
	 */
	if (require_preauth_p(r) || _kdc_is_anon_request(b)) {
	    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;
	    _kdc_set_e_text(r, ""Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ"");
	    goto out;
	}

	if (ckey == NULL) {
	    ret = KRB5KDC_ERR_CLIENT_NOTYET;
	    _kdc_set_e_text(r, ""Doesn't have a client key available"");
	    goto out;
	}
	krb5_free_keyblock_contents(r->context,  &r->reply_key);
	ret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);
	if (ret)
	    goto out;
    }

    if (r->clientdb->hdb_auth_status) {
	r->clientdb->hdb_auth_status(context, r->clientdb, r->client, 
				     HDB_AUTH_SUCCESS);
    }

    /*
     * Verify flags after the user been required to prove its identity
     * with in a preauth mech.
     */

    ret = _kdc_check_access(context, config, r->client, r->client_name,
			    r->server, r->server_name,
			    req, &error_method);
    if(ret)
	goto out;

    /*
     * Select the best encryption type for the KDC with out regard to
     * the client since the client never needs to read that data.
     */

    ret = _kdc_get_preferred_key(context, config,
				 r->server, r->server_name,
				 &setype, &skey);
    if(ret)
	goto out;

    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey
       || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {
	ret = KRB5KDC_ERR_BADOPTION;
	_kdc_set_e_text(r, ""Bad KDC options"");
	goto out;
    }

    /*
     * Build reply
     */

    rep.pvno = 5;
    rep.msg_type = krb_as_rep;

    if (_kdc_is_anonymous(context, r->client_princ)) {
	Realm anon_realm=KRB5_ANON_REALM;
	ret = copy_Realm(&anon_realm, &rep.crealm);
    } else
	ret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);
    if (ret)
	goto out;
    ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);
    if (ret)
	goto out;

    rep.ticket.tkt_vno = 5;
    ret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);
    if (ret)
	goto out;
    _krb5_principal2principalname(&rep.ticket.sname,
				  r->server->entry.principal);
    /* java 1.6 expects the name to be the same type, lets allow that
     * uncomplicated name-types. */
#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)
    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))
	rep.ticket.sname.name_type = b->sname->name_type;
#undef CNT

    r->et.flags.initial = 1;
    if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)
	r->et.flags.forwardable = f.forwardable;
    else if (f.forwardable) {
	_kdc_set_e_text(r, ""Ticket may not be forwardable"");
	ret = KRB5KDC_ERR_POLICY;
	goto out;
    }
    if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)
	r->et.flags.proxiable = f.proxiable;
    else if (f.proxiable) {
	_kdc_set_e_text(r, ""Ticket may not be proxiable"");
	ret = KRB5KDC_ERR_POLICY;
	goto out;
    }
    if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)
	r->et.flags.may_postdate = f.allow_postdate;
    else if (f.allow_postdate){
	_kdc_set_e_text(r, ""Ticket may not be postdate"");
	ret = KRB5KDC_ERR_POLICY;
	goto out;
    }

    /* check for valid set of addresses */
    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {
	_kdc_set_e_text(r, ""Bad address list in requested"");
	ret = KRB5KRB_AP_ERR_BADADDR;
	goto out;
    }

    ret = copy_PrincipalName(&rep.cname, &r->et.cname);
    if (ret)
	goto out;
    ret = copy_Realm(&rep.crealm, &r->et.crealm);
    if (ret)
	goto out;

    {
	time_t start;
	time_t t;
	
	start = r->et.authtime = kdc_time;

	if(f.postdated && req->req_body.from){
	    ALLOC(r->et.starttime);
	    start = *r->et.starttime = *req->req_body.from;
	    r->et.flags.invalid = 1;
	    r->et.flags.postdated = 1; /* XXX ??? */
	}
	_kdc_fix_time(&b->till);
	t = *b->till;

	/* be careful not overflowing */

	if(r->client->entry.max_life)
	    t = start + min(t - start, *r->client->entry.max_life);
	if(r->server->entry.max_life)
	    t = start + min(t - start, *r->server->entry.max_life);
#if 0
	t = min(t, start + realm->max_life);
#endif
	r->et.endtime = t;
	if(f.renewable_ok && r->et.endtime < *b->till){
	    f.renewable = 1;
	    if(b->rtime == NULL){
		ALLOC(b->rtime);
		*b->rtime = 0;
	    }
	    if(*b->rtime < *b->till)
		*b->rtime = *b->till;
	}
	if(f.renewable && b->rtime){
	    t = *b->rtime;
	    if(t == 0)
		t = MAX_TIME;
	    if(r->client->entry.max_renew)
		t = start + min(t - start, *r->client->entry.max_renew);
	    if(r->server->entry.max_renew)
		t = start + min(t - start, *r->server->entry.max_renew);
#if 0
	    t = min(t, start + realm->max_renew);
#endif
	    ALLOC(r->et.renew_till);
	    *r->et.renew_till = t;
	    r->et.flags.renewable = 1;
	}
    }

    if (_kdc_is_anon_request(b))
	r->et.flags.anonymous = 1;

    if(b->addresses){
	ALLOC(r->et.caddr);
	copy_HostAddresses(b->addresses, r->et.caddr);
    }

    r->et.transited.tr_type = DOMAIN_X500_COMPRESS;
    krb5_data_zero(&r->et.transited.contents);

    /* The MIT ASN.1 library (obviously) doesn't tell lengths encoded
     * as 0 and as 0x80 (meaning indefinite length) apart, and is thus
     * incapable of correctly decoding SEQUENCE OF's of zero length.
     *
     * To fix this, always send at least one no-op last_req
     *
     * If there's a pw_end or valid_end we will use that,
     * otherwise just a dummy lr.
     */
    r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));
    if (r->ek.last_req.val == NULL) {
	ret = ENOMEM;
	goto out;
    }
    r->ek.last_req.len = 0;
    if (r->client->entry.pw_end
	&& (config->kdc_warn_pwexpire == 0
	    || kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {
	r->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;
	r->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;
	++r->ek.last_req.len;
    }
    if (r->client->entry.valid_end) {
	r->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;
	r->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;
	++r->ek.last_req.len;
    }
    if (r->ek.last_req.len == 0) {
	r->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;
	r->ek.last_req.val[r->ek.last_req.len].lr_value = 0;
	++r->ek.last_req.len;
    }
    r->ek.nonce = b->nonce;
    if (r->client->entry.valid_end || r->client->entry.pw_end) {
	ALLOC(r->ek.key_expiration);
	if (r->client->entry.valid_end) {
	    if (r->client->entry.pw_end)
		*r->ek.key_expiration = min(*r->client->entry.valid_end,
					 *r->client->entry.pw_end);
	    else
		*r->ek.key_expiration = *r->client->entry.valid_end;
	} else
	    *r->ek.key_expiration = *r->client->entry.pw_end;
    } else
	r->ek.key_expiration = NULL;
    r->ek.flags = r->et.flags;
    r->ek.authtime = r->et.authtime;
    if (r->et.starttime) {
	ALLOC(r->ek.starttime);
	*r->ek.starttime = *r->et.starttime;
    }
    r->ek.endtime = r->et.endtime;
    if (r->et.renew_till) {
	ALLOC(r->ek.renew_till);
	*r->ek.renew_till = *r->et.renew_till;
    }
    ret = copy_Realm(&rep.ticket.realm, &r->ek.srealm);
    if (ret)
	goto out;
    ret = copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);
    if (ret)
	goto out;
    if(r->et.caddr){
	ALLOC(r->ek.caddr);
	copy_HostAddresses(r->et.caddr, r->ek.caddr);
    }

    /*
     * Check and session and reply keys
     */

    if (r->session_key.keytype == ETYPE_NULL) {
	ret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);
	if (ret)
	    goto out;
    }

    if (r->reply_key.keytype == ETYPE_NULL) {
	_kdc_set_e_text(r, ""Client have no reply key"");
	ret = KRB5KDC_ERR_CLIENT_NOTYET;
	goto out;
    }

    ret = copy_EncryptionKey(&r->session_key, &r->et.key);
    if (ret)
	goto out;

    ret = copy_EncryptionKey(&r->session_key, &r->ek.key);
    if (ret)
	goto out;

    if (r->outpadata.len) {

	ALLOC(rep.padata);
	if (rep.padata == NULL) {
	    ret = ENOMEM;
	    goto out;
	}
	ret = copy_METHOD_DATA(&r->outpadata, rep.padata);
	if (ret)
	    goto out;
    }

    /* Add the PAC */
    if (send_pac_p(context, req)) {
	generate_pac(r, skey);
    }

    _kdc_log_timestamp(context, config, ""AS-REQ"", r->et.authtime, r->et.starttime,
		       r->et.endtime, r->et.renew_till);

    /* do this as the last thing since this signs the EncTicketPart */
    ret = _kdc_add_KRB5SignedPath(context,
				  config,
				  r->server,
				  setype,
				  r->client->entry.principal,
				  NULL,
				  NULL,
				  &r->et);
    if (ret)
	goto out;

    log_as_req(context, config, r->reply_key.keytype, setype, b);

    /*
     * We always say we support FAST/enc-pa-rep
     */

    r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;

    /*
     * Add REQ_ENC_PA_REP if client supports it
     */

    i = 0;
    pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);
    if (pa) {

	ret = add_enc_pa_rep(r);
	if (ret) {
	    const char *msg = krb5_get_error_message(r->context, ret);
	    _kdc_r_log(r, 0, ""add_enc_pa_rep failed: %s: %d"", msg, ret);
	    krb5_free_error_message(r->context, msg);
	    goto out;
	}
    }

    /*
     *
     */

    ret = _kdc_encode_reply(context, config,
			    r->armor_crypto, req->req_body.nonce,
			    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,
			    &skey->key, r->client->entry.kvno,
			    &r->reply_key, 0, &r->e_text, reply);
    if (ret)
	goto out;

    /*
     * Check if message too large
     */
    if (datagram_reply && reply->length > config->max_datagram_reply_length) {
	krb5_data_free(reply);
	ret = KRB5KRB_ERR_RESPONSE_TOO_BIG;
	_kdc_set_e_text(r, ""Reply packet too large"");
    }

out:
    free_AS_REP(&rep);

     /*
      * In case of a non proxy error, build an error message.
      */
//flaw_line_below:
    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {
//fix_flaw_line_below:
//    if (ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {
 	ret = _kdc_fast_mk_error(context, r,
 				 &error_method,
 				 r->armor_crypto,
 				 &req->req_body,
 				 ret, r->e_text,
 				 r->server_princ,
//flaw_line_below:
				 &r->client_princ->name,
//flaw_line_below:
				 &r->client_princ->realm,
//fix_flaw_line_below:
//				 r->client_princ ?
//fix_flaw_line_below:
//                                     &r->client_princ->name : NULL,
//fix_flaw_line_below:
//				 r->client_princ ?
//fix_flaw_line_below:
//                                     &r->client_princ->realm : NULL,
 				 NULL, NULL,
 				 reply);
 	if (ret)
	    goto out2;
    }
out2:
    free_EncTicketPart(&r->et);
    free_EncKDCRepPart(&r->ek);
    free_KDCFastState(&r->fast);

    if (error_method.len)
	free_METHOD_DATA(&error_method);
    if (r->outpadata.len)
	free_METHOD_DATA(&r->outpadata);
    if (r->client_princ) {
	krb5_free_principal(context, r->client_princ);
	r->client_princ = NULL;
    }
    if (r->client_name) {
	free(r->client_name);
	r->client_name = NULL;
    }
    if (r->server_princ){
	krb5_free_principal(context, r->server_princ);
	r->server_princ = NULL;
    }
    if (r->server_name) {
	free(r->server_name);
	r->server_name = NULL;
    }
    if (r->client)
	_kdc_free_ent(context, r->client);
    if (r->server)
	_kdc_free_ent(context, r->server);
    if (r->armor_crypto) {
	krb5_crypto_destroy(r->context, r->armor_crypto);
	r->armor_crypto = NULL;
    }
    krb5_free_keyblock_contents(r->context, &r->reply_key);
    krb5_free_keyblock_contents(r->context, &r->session_key);
    return ret;
}
"
3114,180850,,Local,Not required,Complete,CVE-2017-16532,https://www.cvedetails.com/cve/CVE-2017-16532/,CWE-476,Low,Complete,Complete,,2017-11-03,7.2,The get_endpoints function in drivers/usb/misc/usbtest.c in the Linux kernel through 4.13.11 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via a crafted USB device.,2018-08-24,DoS ,3,https://github.com/torvalds/linux/commit/7c80f9e4a588f1925b07134bb2e3689335f6c6d8,7c80f9e4a588f1925b07134bb2e3689335f6c6d8,"usb: usbtest: fix NULL pointer dereference

If the usbtest driver encounters a device with an IN bulk endpoint but
no OUT bulk endpoint, it will try to dereference a NULL pointer
(out->desc.bEndpointAddress).  The problem can be solved by adding a
missing test.

Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Reported-by: Andrey Konovalov <andreyknvl@google.com>
Tested-by: Andrey Konovalov <andreyknvl@google.com>
Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>",2,drivers/usb/misc/usbtest.c,"{""sha"": ""b3fc602b2e247ea150a49c13323ae66cde2b6b4b"", ""filename"": ""drivers/usb/misc/usbtest.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/7c80f9e4a588f1925b07134bb2e3689335f6c6d8/drivers/usb/misc/usbtest.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/7c80f9e4a588f1925b07134bb2e3689335f6c6d8/drivers/usb/misc/usbtest.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/misc/usbtest.c?ref=7c80f9e4a588f1925b07134bb2e3689335f6c6d8"", ""patch"": ""@@ -202,12 +202,13 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)\n \t\t\treturn tmp;\n \t}\n \n-\tif (in) {\n+\tif (in)\n \t\tdev->in_pipe = usb_rcvbulkpipe(udev,\n \t\t\tin->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n+\tif (out)\n \t\tdev->out_pipe = usb_sndbulkpipe(udev,\n \t\t\tout->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n-\t}\n+\n \tif (iso_in) {\n \t\tdev->iso_in = &iso_in->desc;\n \t\tdev->in_iso_pipe = usb_rcvisocpipe(udev,""}","get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
{
	int				tmp;
	struct usb_host_interface	*alt;
	struct usb_host_endpoint	*in, *out;
	struct usb_host_endpoint	*iso_in, *iso_out;
	struct usb_host_endpoint	*int_in, *int_out;
	struct usb_device		*udev;

	for (tmp = 0; tmp < intf->num_altsetting; tmp++) {
		unsigned	ep;

		in = out = NULL;
		iso_in = iso_out = NULL;
		int_in = int_out = NULL;
		alt = intf->altsetting + tmp;

		if (override_alt >= 0 &&
				override_alt != alt->desc.bAlternateSetting)
			continue;

		/* take the first altsetting with in-bulk + out-bulk;
		 * ignore other endpoints and altsettings.
		 */
		for (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {
			struct usb_host_endpoint	*e;
			int edi;

			e = alt->endpoint + ep;
			edi = usb_endpoint_dir_in(&e->desc);

			switch (usb_endpoint_type(&e->desc)) {
			case USB_ENDPOINT_XFER_BULK:
				endpoint_update(edi, &in, &out, e);
				continue;
			case USB_ENDPOINT_XFER_INT:
				if (dev->info->intr)
					endpoint_update(edi, &int_in, &int_out, e);
				continue;
			case USB_ENDPOINT_XFER_ISOC:
				if (dev->info->iso)
					endpoint_update(edi, &iso_in, &iso_out, e);
				/* FALLTHROUGH */
			default:
				continue;
			}
		}
		if ((in && out)  ||  iso_in || iso_out || int_in || int_out)
			goto found;
	}
	return -EINVAL;

found:
	udev = testdev_to_usbdev(dev);
	dev->info->alt = alt->desc.bAlternateSetting;
	if (alt->desc.bAlternateSetting != 0) {
		tmp = usb_set_interface(udev,
				alt->desc.bInterfaceNumber,
				alt->desc.bAlternateSetting);
		if (tmp < 0)
 			return tmp;
 	}
 
	if (in)
 		dev->in_pipe = usb_rcvbulkpipe(udev,
 			in->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
	if (out)
 		dev->out_pipe = usb_sndbulkpipe(udev,
 			out->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);

 	if (iso_in) {
 		dev->iso_in = &iso_in->desc;
 		dev->in_iso_pipe = usb_rcvisocpipe(udev,
				iso_in->desc.bEndpointAddress
					& USB_ENDPOINT_NUMBER_MASK);
	}

	if (iso_out) {
		dev->iso_out = &iso_out->desc;
		dev->out_iso_pipe = usb_sndisocpipe(udev,
				iso_out->desc.bEndpointAddress
					& USB_ENDPOINT_NUMBER_MASK);
	}

	if (int_in) {
		dev->int_in = &int_in->desc;
		dev->in_int_pipe = usb_rcvintpipe(udev,
				int_in->desc.bEndpointAddress
					& USB_ENDPOINT_NUMBER_MASK);
	}

	if (int_out) {
		dev->int_out = &int_out->desc;
		dev->out_int_pipe = usb_sndintpipe(udev,
				int_out->desc.bEndpointAddress
					& USB_ENDPOINT_NUMBER_MASK);
	}
	return 0;
}
","get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
{
	int				tmp;
	struct usb_host_interface	*alt;
	struct usb_host_endpoint	*in, *out;
	struct usb_host_endpoint	*iso_in, *iso_out;
	struct usb_host_endpoint	*int_in, *int_out;
	struct usb_device		*udev;

	for (tmp = 0; tmp < intf->num_altsetting; tmp++) {
		unsigned	ep;

		in = out = NULL;
		iso_in = iso_out = NULL;
		int_in = int_out = NULL;
		alt = intf->altsetting + tmp;

		if (override_alt >= 0 &&
				override_alt != alt->desc.bAlternateSetting)
			continue;

		/* take the first altsetting with in-bulk + out-bulk;
		 * ignore other endpoints and altsettings.
		 */
		for (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {
			struct usb_host_endpoint	*e;
			int edi;

			e = alt->endpoint + ep;
			edi = usb_endpoint_dir_in(&e->desc);

			switch (usb_endpoint_type(&e->desc)) {
			case USB_ENDPOINT_XFER_BULK:
				endpoint_update(edi, &in, &out, e);
				continue;
			case USB_ENDPOINT_XFER_INT:
				if (dev->info->intr)
					endpoint_update(edi, &int_in, &int_out, e);
				continue;
			case USB_ENDPOINT_XFER_ISOC:
				if (dev->info->iso)
					endpoint_update(edi, &iso_in, &iso_out, e);
				/* FALLTHROUGH */
			default:
				continue;
			}
		}
		if ((in && out)  ||  iso_in || iso_out || int_in || int_out)
			goto found;
	}
	return -EINVAL;

found:
	udev = testdev_to_usbdev(dev);
	dev->info->alt = alt->desc.bAlternateSetting;
	if (alt->desc.bAlternateSetting != 0) {
		tmp = usb_set_interface(udev,
				alt->desc.bInterfaceNumber,
				alt->desc.bAlternateSetting);
		if (tmp < 0)
 			return tmp;
 	}
 
	if (in) {
 		dev->in_pipe = usb_rcvbulkpipe(udev,
 			in->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
 		dev->out_pipe = usb_sndbulkpipe(udev,
 			out->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
	}
 	if (iso_in) {
 		dev->iso_in = &iso_in->desc;
 		dev->in_iso_pipe = usb_rcvisocpipe(udev,
				iso_in->desc.bEndpointAddress
					& USB_ENDPOINT_NUMBER_MASK);
	}

	if (iso_out) {
		dev->iso_out = &iso_out->desc;
		dev->out_iso_pipe = usb_sndisocpipe(udev,
				iso_out->desc.bEndpointAddress
					& USB_ENDPOINT_NUMBER_MASK);
	}

	if (int_in) {
		dev->int_in = &int_in->desc;
		dev->in_int_pipe = usb_rcvintpipe(udev,
				int_in->desc.bEndpointAddress
					& USB_ENDPOINT_NUMBER_MASK);
	}

	if (int_out) {
		dev->int_out = &int_out->desc;
		dev->out_int_pipe = usb_sndintpipe(udev,
				int_out->desc.bEndpointAddress
					& USB_ENDPOINT_NUMBER_MASK);
	}
	return 0;
}
",C,"	if (in)
	if (out)

","	if (in) {
	}
",,"@@ -202,12 +202,13 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 			return tmp;
 	}
 
-	if (in) {
+	if (in)
 		dev->in_pipe = usb_rcvbulkpipe(udev,
 			in->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
+	if (out)
 		dev->out_pipe = usb_sndbulkpipe(udev,
 			out->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
-	}
+
 	if (iso_in) {
 		dev->iso_in = &iso_in->desc;
 		dev->in_iso_pipe = usb_rcvisocpipe(udev,",linux,7c80f9e4a588f1925b07134bb2e3689335f6c6d8,ff74745e6d3d97a865eda8c1f3fd29c13b79f0cc,1,"get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
{
	int				tmp;
	struct usb_host_interface	*alt;
	struct usb_host_endpoint	*in, *out;
	struct usb_host_endpoint	*iso_in, *iso_out;
	struct usb_host_endpoint	*int_in, *int_out;
	struct usb_device		*udev;

	for (tmp = 0; tmp < intf->num_altsetting; tmp++) {
		unsigned	ep;

		in = out = NULL;
		iso_in = iso_out = NULL;
		int_in = int_out = NULL;
		alt = intf->altsetting + tmp;

		if (override_alt >= 0 &&
				override_alt != alt->desc.bAlternateSetting)
			continue;

		/* take the first altsetting with in-bulk + out-bulk;
		 * ignore other endpoints and altsettings.
		 */
		for (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {
			struct usb_host_endpoint	*e;
			int edi;

			e = alt->endpoint + ep;
			edi = usb_endpoint_dir_in(&e->desc);

			switch (usb_endpoint_type(&e->desc)) {
			case USB_ENDPOINT_XFER_BULK:
				endpoint_update(edi, &in, &out, e);
				continue;
			case USB_ENDPOINT_XFER_INT:
				if (dev->info->intr)
					endpoint_update(edi, &int_in, &int_out, e);
				continue;
			case USB_ENDPOINT_XFER_ISOC:
				if (dev->info->iso)
					endpoint_update(edi, &iso_in, &iso_out, e);
				/* FALLTHROUGH */
			default:
				continue;
			}
		}
		if ((in && out)  ||  iso_in || iso_out || int_in || int_out)
			goto found;
	}
	return -EINVAL;

found:
	udev = testdev_to_usbdev(dev);
	dev->info->alt = alt->desc.bAlternateSetting;
	if (alt->desc.bAlternateSetting != 0) {
		tmp = usb_set_interface(udev,
				alt->desc.bInterfaceNumber,
				alt->desc.bAlternateSetting);
		if (tmp < 0)
 			return tmp;
 	}
 
//flaw_line_below:
	if (in) {
//fix_flaw_line_below:
//	if (in)
 		dev->in_pipe = usb_rcvbulkpipe(udev,
 			in->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
//fix_flaw_line_below:
//	if (out)
 		dev->out_pipe = usb_sndbulkpipe(udev,
 			out->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
//flaw_line_below:
	}
//fix_flaw_line_below:
//
 	if (iso_in) {
 		dev->iso_in = &iso_in->desc;
 		dev->in_iso_pipe = usb_rcvisocpipe(udev,
				iso_in->desc.bEndpointAddress
					& USB_ENDPOINT_NUMBER_MASK);
	}

	if (iso_out) {
		dev->iso_out = &iso_out->desc;
		dev->out_iso_pipe = usb_sndisocpipe(udev,
				iso_out->desc.bEndpointAddress
					& USB_ENDPOINT_NUMBER_MASK);
	}

	if (int_in) {
		dev->int_in = &int_in->desc;
		dev->in_int_pipe = usb_rcvintpipe(udev,
				int_in->desc.bEndpointAddress
					& USB_ENDPOINT_NUMBER_MASK);
	}

	if (int_out) {
		dev->int_out = &int_out->desc;
		dev->out_int_pipe = usb_sndintpipe(udev,
				int_out->desc.bEndpointAddress
					& USB_ENDPOINT_NUMBER_MASK);
	}
	return 0;
}
"
3124,180860,,Remote,Not required,Partial,CVE-2017-16359,https://www.cvedetails.com/cve/CVE-2017-16359/,CWE-476,Medium,,,,2017-11-01,4.3,"In radare 2.0.1, a pointer wraparound vulnerability exists in store_versioninfo_gnu_verdef() in libr/bin/format/elf/elf.c.",2017-11-13,,4,https://github.com/radare/radare2/commit/62e39f34b2705131a2d08aff0c2e542c6a52cf0e,62e39f34b2705131a2d08aff0c2e542c6a52cf0e,Fix #8764 - huge vd_aux caused pointer wraparound,4,libr/bin/format/elf/elf.c,"{""sha"": ""ba3d1d5404f6a99c81a717ee695e78e4c5c02771"", ""filename"": ""libr/bin/format/elf/elf.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/radareorg/radare2/blob/62e39f34b2705131a2d08aff0c2e542c6a52cf0e/libr/bin/format/elf/elf.c"", ""raw_url"": ""https://github.com/radareorg/radare2/raw/62e39f34b2705131a2d08aff0c2e542c6a52cf0e/libr/bin/format/elf/elf.c"", ""contents_url"": ""https://api.github.com/repos/radareorg/radare2/contents/libr/bin/format/elf/elf.c?ref=62e39f34b2705131a2d08aff0c2e542c6a52cf0e"", ""patch"": ""@@ -731,7 +731,7 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)\n \tsdb_num_set (sdb, \""link\"", shdr->sh_link, 0);\n \tsdb_set (sdb, \""link_section_name\"", link_section_name, 0);\n \n-\tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {\n+\tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && (end - (char *)defs > i); ++cnt) {\n \t\tSdb *sdb_verdef = sdb_new0 ();\n \t\tchar *vstart = ((char*)defs) + i;\n \t\tchar key[32] = {0};\n@@ -749,12 +749,12 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)\n \t\tverdef->vd_aux = READ32 (dfs, j)\n \t\tverdef->vd_next = READ32 (dfs, j)\n \t\tint vdaux = verdef->vd_aux;\n-\t\tif (vdaux < 1) {\n+\t\tif (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {\n \t\t\tsdb_free (sdb_verdef);\n \t\t\tgoto out_error;\n \t\t}\n \t\tvstart += vdaux;\n-\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n+\t\tif (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {\n \t\t\tsdb_free (sdb_verdef);\n \t\t\tgoto out_error;\n \t\t}\n@@ -781,7 +781,7 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)\n \t\t\tSdb *sdb_parent = sdb_new0 ();\n \t\t\tisum += aux.vda_next;\n \t\t\tvstart += aux.vda_next;\n-\t\t\tif (vstart > end || vstart + sizeof(Elf_(Verdaux)) > end) {\n+\t\t\tif (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {\n \t\t\t\tsdb_free (sdb_verdef);\n \t\t\t\tsdb_free (sdb_parent);\n \t\t\t\tgoto out_error;""}","static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {
	const char *section_name = """";
	const char *link_section_name = """";
	char *end = NULL;
	Elf_(Shdr) *link_shdr = NULL;
	ut8 dfs[sizeof (Elf_(Verdef))] = {0};
	Sdb *sdb;
	int cnt, i;
	if (shdr->sh_link > bin->ehdr.e_shnum) {
		return false;
	}
	link_shdr = &bin->shdr[shdr->sh_link];
	if (shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {
		return false;
	}
	Elf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));
	if (!defs) {
		return false;
	}
	if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {
		section_name = &bin->shstrtab[shdr->sh_name];
	}
	if (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {
		link_section_name = &bin->shstrtab[link_shdr->sh_name];
	}
	if (!defs) {
		bprintf (""Warning: Cannot allocate memory (Check Elf_(Verdef))\n"");
		return NULL;
	}
	sdb = sdb_new0 ();
	end = (char *)defs + shdr->sh_size;
	sdb_set (sdb, ""section_name"", section_name, 0);
	sdb_num_set (sdb, ""entries"", shdr->sh_info, 0);
	sdb_num_set (sdb, ""addr"", shdr->sh_addr, 0);
	sdb_num_set (sdb, ""offset"", shdr->sh_offset, 0);
 	sdb_num_set (sdb, ""link"", shdr->sh_link, 0);
 	sdb_set (sdb, ""link_section_name"", link_section_name, 0);
 
	for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && (end - (char *)defs > i); ++cnt) {
 		Sdb *sdb_verdef = sdb_new0 ();
 		char *vstart = ((char*)defs) + i;
 		char key[32] = {0};
		Elf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;
		Elf_(Verdaux) aux = {0};
		int j = 0;
		int isum = 0;

		r_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));
		verdef->vd_version = READ16 (dfs, j)
		verdef->vd_flags = READ16 (dfs, j)
		verdef->vd_ndx = READ16 (dfs, j)
		verdef->vd_cnt = READ16 (dfs, j)
		verdef->vd_hash = READ32 (dfs, j)
 		verdef->vd_aux = READ32 (dfs, j)
 		verdef->vd_next = READ32 (dfs, j)
 		int vdaux = verdef->vd_aux;
		if (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
 		vstart += vdaux;
		if (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}

		j = 0;
		aux.vda_name = READ32 (vstart, j)
		aux.vda_next = READ32 (vstart, j)

		isum = i + verdef->vd_aux;
		if (aux.vda_name > bin->dynstr_size) {
			sdb_free (sdb_verdef);
			goto out_error;
		}

		sdb_num_set (sdb_verdef, ""idx"", i, 0);
		sdb_num_set (sdb_verdef, ""vd_version"", verdef->vd_version, 0);
		sdb_num_set (sdb_verdef, ""vd_ndx"", verdef->vd_ndx, 0);
		sdb_num_set (sdb_verdef, ""vd_cnt"", verdef->vd_cnt, 0);
		sdb_set (sdb_verdef, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
		sdb_set (sdb_verdef, ""flags"", get_ver_flags (verdef->vd_flags), 0);

		for (j = 1; j < verdef->vd_cnt; ++j) {
			int k;
 			Sdb *sdb_parent = sdb_new0 ();
 			isum += aux.vda_next;
 			vstart += aux.vda_next;
			if (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {
 				sdb_free (sdb_verdef);
 				sdb_free (sdb_parent);
 				goto out_error;
			}
			k = 0;
			aux.vda_name = READ32 (vstart, k)
			aux.vda_next = READ32 (vstart, k)
			if (aux.vda_name > bin->dynstr_size) {
				sdb_free (sdb_verdef);
				sdb_free (sdb_parent);
				goto out_error;
			}
			sdb_num_set (sdb_parent, ""idx"", isum, 0);
			sdb_num_set (sdb_parent, ""parent"", j, 0);
			sdb_set (sdb_parent, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
			snprintf (key, sizeof (key), ""parent%d"", j - 1);
			sdb_ns_set (sdb_verdef, key, sdb_parent);
		}

		snprintf (key, sizeof (key), ""verdef%d"", cnt);
		sdb_ns_set (sdb, key, sdb_verdef);
		if (!verdef->vd_next) {
			sdb_free (sdb_verdef);
			goto out_error;
		}
		if ((st32)verdef->vd_next < 1) {
			eprintf (""Warning: Invalid vd_next in the ELF version\n"");
			break;
		}
		i += verdef->vd_next;
	}
	free (defs);
	return sdb;
out_error:
	free (defs);
	sdb_free (sdb);
	return NULL;
}
","static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {
	const char *section_name = """";
	const char *link_section_name = """";
	char *end = NULL;
	Elf_(Shdr) *link_shdr = NULL;
	ut8 dfs[sizeof (Elf_(Verdef))] = {0};
	Sdb *sdb;
	int cnt, i;
	if (shdr->sh_link > bin->ehdr.e_shnum) {
		return false;
	}
	link_shdr = &bin->shdr[shdr->sh_link];
	if (shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {
		return false;
	}
	Elf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));
	if (!defs) {
		return false;
	}
	if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {
		section_name = &bin->shstrtab[shdr->sh_name];
	}
	if (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {
		link_section_name = &bin->shstrtab[link_shdr->sh_name];
	}
	if (!defs) {
		bprintf (""Warning: Cannot allocate memory (Check Elf_(Verdef))\n"");
		return NULL;
	}
	sdb = sdb_new0 ();
	end = (char *)defs + shdr->sh_size;
	sdb_set (sdb, ""section_name"", section_name, 0);
	sdb_num_set (sdb, ""entries"", shdr->sh_info, 0);
	sdb_num_set (sdb, ""addr"", shdr->sh_addr, 0);
	sdb_num_set (sdb, ""offset"", shdr->sh_offset, 0);
 	sdb_num_set (sdb, ""link"", shdr->sh_link, 0);
 	sdb_set (sdb, ""link_section_name"", link_section_name, 0);
 
	for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {
 		Sdb *sdb_verdef = sdb_new0 ();
 		char *vstart = ((char*)defs) + i;
 		char key[32] = {0};
		Elf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;
		Elf_(Verdaux) aux = {0};
		int j = 0;
		int isum = 0;

		r_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));
		verdef->vd_version = READ16 (dfs, j)
		verdef->vd_flags = READ16 (dfs, j)
		verdef->vd_ndx = READ16 (dfs, j)
		verdef->vd_cnt = READ16 (dfs, j)
		verdef->vd_hash = READ32 (dfs, j)
 		verdef->vd_aux = READ32 (dfs, j)
 		verdef->vd_next = READ32 (dfs, j)
 		int vdaux = verdef->vd_aux;
		if (vdaux < 1) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
 		vstart += vdaux;
		if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}

		j = 0;
		aux.vda_name = READ32 (vstart, j)
		aux.vda_next = READ32 (vstart, j)

		isum = i + verdef->vd_aux;
		if (aux.vda_name > bin->dynstr_size) {
			sdb_free (sdb_verdef);
			goto out_error;
		}

		sdb_num_set (sdb_verdef, ""idx"", i, 0);
		sdb_num_set (sdb_verdef, ""vd_version"", verdef->vd_version, 0);
		sdb_num_set (sdb_verdef, ""vd_ndx"", verdef->vd_ndx, 0);
		sdb_num_set (sdb_verdef, ""vd_cnt"", verdef->vd_cnt, 0);
		sdb_set (sdb_verdef, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
		sdb_set (sdb_verdef, ""flags"", get_ver_flags (verdef->vd_flags), 0);

		for (j = 1; j < verdef->vd_cnt; ++j) {
			int k;
 			Sdb *sdb_parent = sdb_new0 ();
 			isum += aux.vda_next;
 			vstart += aux.vda_next;
			if (vstart > end || vstart + sizeof(Elf_(Verdaux)) > end) {
 				sdb_free (sdb_verdef);
 				sdb_free (sdb_parent);
 				goto out_error;
			}
			k = 0;
			aux.vda_name = READ32 (vstart, k)
			aux.vda_next = READ32 (vstart, k)
			if (aux.vda_name > bin->dynstr_size) {
				sdb_free (sdb_verdef);
				sdb_free (sdb_parent);
				goto out_error;
			}
			sdb_num_set (sdb_parent, ""idx"", isum, 0);
			sdb_num_set (sdb_parent, ""parent"", j, 0);
			sdb_set (sdb_parent, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
			snprintf (key, sizeof (key), ""parent%d"", j - 1);
			sdb_ns_set (sdb_verdef, key, sdb_parent);
		}

		snprintf (key, sizeof (key), ""verdef%d"", cnt);
		sdb_ns_set (sdb, key, sdb_verdef);
		if (!verdef->vd_next) {
			sdb_free (sdb_verdef);
			goto out_error;
		}
		if ((st32)verdef->vd_next < 1) {
			eprintf (""Warning: Invalid vd_next in the ELF version\n"");
			break;
		}
		i += verdef->vd_next;
	}
	free (defs);
	return sdb;
out_error:
	free (defs);
	sdb_free (sdb);
	return NULL;
}
",C,"	for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && (end - (char *)defs > i); ++cnt) {
		if (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {
		if (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {
			if (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {
","	for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {
		if (vdaux < 1) {
		if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {
			if (vstart > end || vstart + sizeof(Elf_(Verdaux)) > end) {
",,"@@ -731,7 +731,7 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 	sdb_num_set (sdb, ""link"", shdr->sh_link, 0);
 	sdb_set (sdb, ""link_section_name"", link_section_name, 0);
 
-	for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {
+	for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && (end - (char *)defs > i); ++cnt) {
 		Sdb *sdb_verdef = sdb_new0 ();
 		char *vstart = ((char*)defs) + i;
 		char key[32] = {0};
@@ -749,12 +749,12 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 		verdef->vd_aux = READ32 (dfs, j)
 		verdef->vd_next = READ32 (dfs, j)
 		int vdaux = verdef->vd_aux;
-		if (vdaux < 1) {
+		if (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
 		vstart += vdaux;
-		if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {
+		if (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
@@ -781,7 +781,7 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 			Sdb *sdb_parent = sdb_new0 ();
 			isum += aux.vda_next;
 			vstart += aux.vda_next;
-			if (vstart > end || vstart + sizeof(Elf_(Verdaux)) > end) {
+			if (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {
 				sdb_free (sdb_verdef);
 				sdb_free (sdb_parent);
 				goto out_error;",radare2,62e39f34b2705131a2d08aff0c2e542c6a52cf0e,1f5050868eedabcbf2eda510a05c93577e1c2cd5,1,"static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {
	const char *section_name = """";
	const char *link_section_name = """";
	char *end = NULL;
	Elf_(Shdr) *link_shdr = NULL;
	ut8 dfs[sizeof (Elf_(Verdef))] = {0};
	Sdb *sdb;
	int cnt, i;
	if (shdr->sh_link > bin->ehdr.e_shnum) {
		return false;
	}
	link_shdr = &bin->shdr[shdr->sh_link];
	if (shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {
		return false;
	}
	Elf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));
	if (!defs) {
		return false;
	}
	if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {
		section_name = &bin->shstrtab[shdr->sh_name];
	}
	if (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {
		link_section_name = &bin->shstrtab[link_shdr->sh_name];
	}
	if (!defs) {
		bprintf (""Warning: Cannot allocate memory (Check Elf_(Verdef))\n"");
		return NULL;
	}
	sdb = sdb_new0 ();
	end = (char *)defs + shdr->sh_size;
	sdb_set (sdb, ""section_name"", section_name, 0);
	sdb_num_set (sdb, ""entries"", shdr->sh_info, 0);
	sdb_num_set (sdb, ""addr"", shdr->sh_addr, 0);
	sdb_num_set (sdb, ""offset"", shdr->sh_offset, 0);
 	sdb_num_set (sdb, ""link"", shdr->sh_link, 0);
 	sdb_set (sdb, ""link_section_name"", link_section_name, 0);
 
//flaw_line_below:
	for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {
//fix_flaw_line_below:
//	for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && (end - (char *)defs > i); ++cnt) {
 		Sdb *sdb_verdef = sdb_new0 ();
 		char *vstart = ((char*)defs) + i;
 		char key[32] = {0};
		Elf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;
		Elf_(Verdaux) aux = {0};
		int j = 0;
		int isum = 0;

		r_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));
		verdef->vd_version = READ16 (dfs, j)
		verdef->vd_flags = READ16 (dfs, j)
		verdef->vd_ndx = READ16 (dfs, j)
		verdef->vd_cnt = READ16 (dfs, j)
		verdef->vd_hash = READ32 (dfs, j)
 		verdef->vd_aux = READ32 (dfs, j)
 		verdef->vd_next = READ32 (dfs, j)
 		int vdaux = verdef->vd_aux;
//flaw_line_below:
		if (vdaux < 1) {
//fix_flaw_line_below:
//		if (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
 		vstart += vdaux;
//flaw_line_below:
		if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {
//fix_flaw_line_below:
//		if (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}

		j = 0;
		aux.vda_name = READ32 (vstart, j)
		aux.vda_next = READ32 (vstart, j)

		isum = i + verdef->vd_aux;
		if (aux.vda_name > bin->dynstr_size) {
			sdb_free (sdb_verdef);
			goto out_error;
		}

		sdb_num_set (sdb_verdef, ""idx"", i, 0);
		sdb_num_set (sdb_verdef, ""vd_version"", verdef->vd_version, 0);
		sdb_num_set (sdb_verdef, ""vd_ndx"", verdef->vd_ndx, 0);
		sdb_num_set (sdb_verdef, ""vd_cnt"", verdef->vd_cnt, 0);
		sdb_set (sdb_verdef, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
		sdb_set (sdb_verdef, ""flags"", get_ver_flags (verdef->vd_flags), 0);

		for (j = 1; j < verdef->vd_cnt; ++j) {
			int k;
 			Sdb *sdb_parent = sdb_new0 ();
 			isum += aux.vda_next;
 			vstart += aux.vda_next;
//flaw_line_below:
			if (vstart > end || vstart + sizeof(Elf_(Verdaux)) > end) {
//fix_flaw_line_below:
//			if (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {
 				sdb_free (sdb_verdef);
 				sdb_free (sdb_parent);
 				goto out_error;
			}
			k = 0;
			aux.vda_name = READ32 (vstart, k)
			aux.vda_next = READ32 (vstart, k)
			if (aux.vda_name > bin->dynstr_size) {
				sdb_free (sdb_verdef);
				sdb_free (sdb_parent);
				goto out_error;
			}
			sdb_num_set (sdb_parent, ""idx"", isum, 0);
			sdb_num_set (sdb_parent, ""parent"", j, 0);
			sdb_set (sdb_parent, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
			snprintf (key, sizeof (key), ""parent%d"", j - 1);
			sdb_ns_set (sdb_verdef, key, sdb_parent);
		}

		snprintf (key, sizeof (key), ""verdef%d"", cnt);
		sdb_ns_set (sdb, key, sdb_verdef);
		if (!verdef->vd_next) {
			sdb_free (sdb_verdef);
			goto out_error;
		}
		if ((st32)verdef->vd_next < 1) {
			eprintf (""Warning: Invalid vd_next in the ELF version\n"");
			break;
		}
		i += verdef->vd_next;
	}
	free (defs);
	return sdb;
out_error:
	free (defs);
	sdb_free (sdb);
	return NULL;
}
"
3160,180896,,Local,Not required,Complete,CVE-2017-15306,https://www.cvedetails.com/cve/CVE-2017-15306/,CWE-476,Low,,,,2017-11-06,4.9,The kvm_vm_ioctl_check_extension function in arch/powerpc/kvm/powerpc.c in the Linux kernel before 4.13.11 allows local users to cause a denial of service (NULL pointer dereference and system crash) via a KVM_CHECK_EXTENSION KVM_CAP_PPC_HTM ioctl call to /dev/kvm.,2017-11-28,DoS ,1,https://github.com/torvalds/linux/commit/ac64115a66c18c01745bbd3c47a36b124e5fd8c0,ac64115a66c18c01745bbd3c47a36b124e5fd8c0,"KVM: PPC: Fix oops when checking KVM_CAP_PPC_HTM

The following program causes a kernel oops:

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/kvm.h>

main()
{
    int fd = open(""/dev/kvm"", O_RDWR);
    ioctl(fd, KVM_CHECK_EXTENSION, KVM_CAP_PPC_HTM);
}

This happens because when using the global KVM fd with
KVM_CHECK_EXTENSION, kvm_vm_ioctl_check_extension() gets
called with a NULL kvm argument, which gets dereferenced
in is_kvmppc_hv_enabled(). Spotted while reading the code.

Let's use the hv_enabled fallback variable, like everywhere
else in this function.

Fixes: 23528bb21ee2 (""KVM: PPC: Introduce KVM_CAP_PPC_HTM"")
Cc: stable@vger.kernel.org # v4.7+
Signed-off-by: Greg Kurz <groug@kaod.org>
Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
Reviewed-by: Thomas Huth <thuth@redhat.com>
Signed-off-by: Paul Mackerras <paulus@ozlabs.org>",2,arch/powerpc/kvm/powerpc.c,"{""sha"": ""ee279c7f48021e0b43c658d7529b9160061b5415"", ""filename"": ""arch/powerpc/kvm/powerpc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/ac64115a66c18c01745bbd3c47a36b124e5fd8c0/arch/powerpc/kvm/powerpc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/ac64115a66c18c01745bbd3c47a36b124e5fd8c0/arch/powerpc/kvm/powerpc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/powerpc/kvm/powerpc.c?ref=ac64115a66c18c01745bbd3c47a36b124e5fd8c0"", ""patch"": ""@@ -644,8 +644,7 @@ int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)\n \t\tbreak;\n #endif\n \tcase KVM_CAP_PPC_HTM:\n-\t\tr = cpu_has_feature(CPU_FTR_TM_COMP) &&\n-\t\t    is_kvmppc_hv_enabled(kvm);\n+\t\tr = cpu_has_feature(CPU_FTR_TM_COMP) && hv_enabled;\n \t\tbreak;\n \tdefault:\n \t\tr = 0;""}","int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)
{
	int r;
	/* Assume we're using HV mode when the HV module is loaded */
	int hv_enabled = kvmppc_hv_ops ? 1 : 0;

	if (kvm) {
		/*
		 * Hooray - we know which VM type we're running on. Depend on
		 * that rather than the guess above.
		 */
		hv_enabled = is_kvmppc_hv_enabled(kvm);
	}

	switch (ext) {
#ifdef CONFIG_BOOKE
	case KVM_CAP_PPC_BOOKE_SREGS:
	case KVM_CAP_PPC_BOOKE_WATCHDOG:
	case KVM_CAP_PPC_EPR:
#else
	case KVM_CAP_PPC_SEGSTATE:
	case KVM_CAP_PPC_HIOR:
	case KVM_CAP_PPC_PAPR:
#endif
	case KVM_CAP_PPC_UNSET_IRQ:
	case KVM_CAP_PPC_IRQ_LEVEL:
	case KVM_CAP_ENABLE_CAP:
	case KVM_CAP_ENABLE_CAP_VM:
	case KVM_CAP_ONE_REG:
	case KVM_CAP_IOEVENTFD:
	case KVM_CAP_DEVICE_CTRL:
	case KVM_CAP_IMMEDIATE_EXIT:
		r = 1;
		break;
	case KVM_CAP_PPC_PAIRED_SINGLES:
	case KVM_CAP_PPC_OSI:
	case KVM_CAP_PPC_GET_PVINFO:
#if defined(CONFIG_KVM_E500V2) || defined(CONFIG_KVM_E500MC)
	case KVM_CAP_SW_TLB:
#endif
		/* We support this only for PR */
		r = !hv_enabled;
		break;
#ifdef CONFIG_KVM_MPIC
	case KVM_CAP_IRQ_MPIC:
		r = 1;
		break;
#endif

#ifdef CONFIG_PPC_BOOK3S_64
	case KVM_CAP_SPAPR_TCE:
	case KVM_CAP_SPAPR_TCE_64:
		/* fallthrough */
	case KVM_CAP_SPAPR_TCE_VFIO:
	case KVM_CAP_PPC_RTAS:
	case KVM_CAP_PPC_FIXUP_HCALL:
	case KVM_CAP_PPC_ENABLE_HCALL:
#ifdef CONFIG_KVM_XICS
	case KVM_CAP_IRQ_XICS:
#endif
		r = 1;
		break;

	case KVM_CAP_PPC_ALLOC_HTAB:
		r = hv_enabled;
		break;
#endif /* CONFIG_PPC_BOOK3S_64 */
#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
	case KVM_CAP_PPC_SMT:
		r = 0;
		if (kvm) {
			if (kvm->arch.emul_smt_mode > 1)
				r = kvm->arch.emul_smt_mode;
			else
				r = kvm->arch.smt_mode;
		} else if (hv_enabled) {
			if (cpu_has_feature(CPU_FTR_ARCH_300))
				r = 1;
			else
				r = threads_per_subcore;
		}
		break;
	case KVM_CAP_PPC_SMT_POSSIBLE:
		r = 1;
		if (hv_enabled) {
			if (!cpu_has_feature(CPU_FTR_ARCH_300))
				r = ((threads_per_subcore << 1) - 1);
			else
				/* P9 can emulate dbells, so allow any mode */
				r = 8 | 4 | 2 | 1;
		}
		break;
	case KVM_CAP_PPC_RMA:
		r = 0;
		break;
	case KVM_CAP_PPC_HWRNG:
		r = kvmppc_hwrng_present();
		break;
	case KVM_CAP_PPC_MMU_RADIX:
		r = !!(hv_enabled && radix_enabled());
		break;
	case KVM_CAP_PPC_MMU_HASH_V3:
		r = !!(hv_enabled && !radix_enabled() &&
		       cpu_has_feature(CPU_FTR_ARCH_300));
		break;
#endif
	case KVM_CAP_SYNC_MMU:
#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
		r = hv_enabled;
#elif defined(KVM_ARCH_WANT_MMU_NOTIFIER)
		r = 1;
#else
		r = 0;
#endif
		break;
#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
	case KVM_CAP_PPC_HTAB_FD:
		r = hv_enabled;
		break;
#endif
	case KVM_CAP_NR_VCPUS:
		/*
		 * Recommending a number of CPUs is somewhat arbitrary; we
		 * return the number of present CPUs for -HV (since a host
		 * will have secondary threads ""offline""), and for other KVM
		 * implementations just count online CPUs.
		 */
		if (hv_enabled)
			r = num_present_cpus();
		else
			r = num_online_cpus();
		break;
	case KVM_CAP_NR_MEMSLOTS:
		r = KVM_USER_MEM_SLOTS;
		break;
	case KVM_CAP_MAX_VCPUS:
		r = KVM_MAX_VCPUS;
		break;
#ifdef CONFIG_PPC_BOOK3S_64
	case KVM_CAP_PPC_GET_SMMU_INFO:
		r = 1;
		break;
	case KVM_CAP_SPAPR_MULTITCE:
		r = 1;
		break;
	case KVM_CAP_SPAPR_RESIZE_HPT:
		/* Disable this on POWER9 until code handles new HPTE format */
		r = !!hv_enabled && !cpu_has_feature(CPU_FTR_ARCH_300);
		break;
#endif
#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
	case KVM_CAP_PPC_FWNMI:
		r = hv_enabled;
 		break;
 #endif
 	case KVM_CAP_PPC_HTM:
		r = cpu_has_feature(CPU_FTR_TM_COMP) && hv_enabled;
 		break;
 	default:
 		r = 0;
		break;
	}
	return r;

}
","int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)
{
	int r;
	/* Assume we're using HV mode when the HV module is loaded */
	int hv_enabled = kvmppc_hv_ops ? 1 : 0;

	if (kvm) {
		/*
		 * Hooray - we know which VM type we're running on. Depend on
		 * that rather than the guess above.
		 */
		hv_enabled = is_kvmppc_hv_enabled(kvm);
	}

	switch (ext) {
#ifdef CONFIG_BOOKE
	case KVM_CAP_PPC_BOOKE_SREGS:
	case KVM_CAP_PPC_BOOKE_WATCHDOG:
	case KVM_CAP_PPC_EPR:
#else
	case KVM_CAP_PPC_SEGSTATE:
	case KVM_CAP_PPC_HIOR:
	case KVM_CAP_PPC_PAPR:
#endif
	case KVM_CAP_PPC_UNSET_IRQ:
	case KVM_CAP_PPC_IRQ_LEVEL:
	case KVM_CAP_ENABLE_CAP:
	case KVM_CAP_ENABLE_CAP_VM:
	case KVM_CAP_ONE_REG:
	case KVM_CAP_IOEVENTFD:
	case KVM_CAP_DEVICE_CTRL:
	case KVM_CAP_IMMEDIATE_EXIT:
		r = 1;
		break;
	case KVM_CAP_PPC_PAIRED_SINGLES:
	case KVM_CAP_PPC_OSI:
	case KVM_CAP_PPC_GET_PVINFO:
#if defined(CONFIG_KVM_E500V2) || defined(CONFIG_KVM_E500MC)
	case KVM_CAP_SW_TLB:
#endif
		/* We support this only for PR */
		r = !hv_enabled;
		break;
#ifdef CONFIG_KVM_MPIC
	case KVM_CAP_IRQ_MPIC:
		r = 1;
		break;
#endif

#ifdef CONFIG_PPC_BOOK3S_64
	case KVM_CAP_SPAPR_TCE:
	case KVM_CAP_SPAPR_TCE_64:
		/* fallthrough */
	case KVM_CAP_SPAPR_TCE_VFIO:
	case KVM_CAP_PPC_RTAS:
	case KVM_CAP_PPC_FIXUP_HCALL:
	case KVM_CAP_PPC_ENABLE_HCALL:
#ifdef CONFIG_KVM_XICS
	case KVM_CAP_IRQ_XICS:
#endif
		r = 1;
		break;

	case KVM_CAP_PPC_ALLOC_HTAB:
		r = hv_enabled;
		break;
#endif /* CONFIG_PPC_BOOK3S_64 */
#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
	case KVM_CAP_PPC_SMT:
		r = 0;
		if (kvm) {
			if (kvm->arch.emul_smt_mode > 1)
				r = kvm->arch.emul_smt_mode;
			else
				r = kvm->arch.smt_mode;
		} else if (hv_enabled) {
			if (cpu_has_feature(CPU_FTR_ARCH_300))
				r = 1;
			else
				r = threads_per_subcore;
		}
		break;
	case KVM_CAP_PPC_SMT_POSSIBLE:
		r = 1;
		if (hv_enabled) {
			if (!cpu_has_feature(CPU_FTR_ARCH_300))
				r = ((threads_per_subcore << 1) - 1);
			else
				/* P9 can emulate dbells, so allow any mode */
				r = 8 | 4 | 2 | 1;
		}
		break;
	case KVM_CAP_PPC_RMA:
		r = 0;
		break;
	case KVM_CAP_PPC_HWRNG:
		r = kvmppc_hwrng_present();
		break;
	case KVM_CAP_PPC_MMU_RADIX:
		r = !!(hv_enabled && radix_enabled());
		break;
	case KVM_CAP_PPC_MMU_HASH_V3:
		r = !!(hv_enabled && !radix_enabled() &&
		       cpu_has_feature(CPU_FTR_ARCH_300));
		break;
#endif
	case KVM_CAP_SYNC_MMU:
#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
		r = hv_enabled;
#elif defined(KVM_ARCH_WANT_MMU_NOTIFIER)
		r = 1;
#else
		r = 0;
#endif
		break;
#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
	case KVM_CAP_PPC_HTAB_FD:
		r = hv_enabled;
		break;
#endif
	case KVM_CAP_NR_VCPUS:
		/*
		 * Recommending a number of CPUs is somewhat arbitrary; we
		 * return the number of present CPUs for -HV (since a host
		 * will have secondary threads ""offline""), and for other KVM
		 * implementations just count online CPUs.
		 */
		if (hv_enabled)
			r = num_present_cpus();
		else
			r = num_online_cpus();
		break;
	case KVM_CAP_NR_MEMSLOTS:
		r = KVM_USER_MEM_SLOTS;
		break;
	case KVM_CAP_MAX_VCPUS:
		r = KVM_MAX_VCPUS;
		break;
#ifdef CONFIG_PPC_BOOK3S_64
	case KVM_CAP_PPC_GET_SMMU_INFO:
		r = 1;
		break;
	case KVM_CAP_SPAPR_MULTITCE:
		r = 1;
		break;
	case KVM_CAP_SPAPR_RESIZE_HPT:
		/* Disable this on POWER9 until code handles new HPTE format */
		r = !!hv_enabled && !cpu_has_feature(CPU_FTR_ARCH_300);
		break;
#endif
#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
	case KVM_CAP_PPC_FWNMI:
		r = hv_enabled;
 		break;
 #endif
 	case KVM_CAP_PPC_HTM:
		r = cpu_has_feature(CPU_FTR_TM_COMP) &&
		    is_kvmppc_hv_enabled(kvm);
 		break;
 	default:
 		r = 0;
		break;
	}
	return r;

}
",C,"		r = cpu_has_feature(CPU_FTR_TM_COMP) && hv_enabled;
","		r = cpu_has_feature(CPU_FTR_TM_COMP) &&
		    is_kvmppc_hv_enabled(kvm);
",,"@@ -644,8 +644,7 @@ int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)
 		break;
 #endif
 	case KVM_CAP_PPC_HTM:
-		r = cpu_has_feature(CPU_FTR_TM_COMP) &&
-		    is_kvmppc_hv_enabled(kvm);
+		r = cpu_has_feature(CPU_FTR_TM_COMP) && hv_enabled;
 		break;
 	default:
 		r = 0;",linux,ac64115a66c18c01745bbd3c47a36b124e5fd8c0,8a5776a5f49812d29fe4b2d0a2d71675c3facf3f,1,"int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)
{
	int r;
	/* Assume we're using HV mode when the HV module is loaded */
	int hv_enabled = kvmppc_hv_ops ? 1 : 0;

	if (kvm) {
		/*
		 * Hooray - we know which VM type we're running on. Depend on
		 * that rather than the guess above.
		 */
		hv_enabled = is_kvmppc_hv_enabled(kvm);
	}

	switch (ext) {
#ifdef CONFIG_BOOKE
	case KVM_CAP_PPC_BOOKE_SREGS:
	case KVM_CAP_PPC_BOOKE_WATCHDOG:
	case KVM_CAP_PPC_EPR:
#else
	case KVM_CAP_PPC_SEGSTATE:
	case KVM_CAP_PPC_HIOR:
	case KVM_CAP_PPC_PAPR:
#endif
	case KVM_CAP_PPC_UNSET_IRQ:
	case KVM_CAP_PPC_IRQ_LEVEL:
	case KVM_CAP_ENABLE_CAP:
	case KVM_CAP_ENABLE_CAP_VM:
	case KVM_CAP_ONE_REG:
	case KVM_CAP_IOEVENTFD:
	case KVM_CAP_DEVICE_CTRL:
	case KVM_CAP_IMMEDIATE_EXIT:
		r = 1;
		break;
	case KVM_CAP_PPC_PAIRED_SINGLES:
	case KVM_CAP_PPC_OSI:
	case KVM_CAP_PPC_GET_PVINFO:
#if defined(CONFIG_KVM_E500V2) || defined(CONFIG_KVM_E500MC)
	case KVM_CAP_SW_TLB:
#endif
		/* We support this only for PR */
		r = !hv_enabled;
		break;
#ifdef CONFIG_KVM_MPIC
	case KVM_CAP_IRQ_MPIC:
		r = 1;
		break;
#endif

#ifdef CONFIG_PPC_BOOK3S_64
	case KVM_CAP_SPAPR_TCE:
	case KVM_CAP_SPAPR_TCE_64:
		/* fallthrough */
	case KVM_CAP_SPAPR_TCE_VFIO:
	case KVM_CAP_PPC_RTAS:
	case KVM_CAP_PPC_FIXUP_HCALL:
	case KVM_CAP_PPC_ENABLE_HCALL:
#ifdef CONFIG_KVM_XICS
	case KVM_CAP_IRQ_XICS:
#endif
		r = 1;
		break;

	case KVM_CAP_PPC_ALLOC_HTAB:
		r = hv_enabled;
		break;
#endif /* CONFIG_PPC_BOOK3S_64 */
#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
	case KVM_CAP_PPC_SMT:
		r = 0;
		if (kvm) {
			if (kvm->arch.emul_smt_mode > 1)
				r = kvm->arch.emul_smt_mode;
			else
				r = kvm->arch.smt_mode;
		} else if (hv_enabled) {
			if (cpu_has_feature(CPU_FTR_ARCH_300))
				r = 1;
			else
				r = threads_per_subcore;
		}
		break;
	case KVM_CAP_PPC_SMT_POSSIBLE:
		r = 1;
		if (hv_enabled) {
			if (!cpu_has_feature(CPU_FTR_ARCH_300))
				r = ((threads_per_subcore << 1) - 1);
			else
				/* P9 can emulate dbells, so allow any mode */
				r = 8 | 4 | 2 | 1;
		}
		break;
	case KVM_CAP_PPC_RMA:
		r = 0;
		break;
	case KVM_CAP_PPC_HWRNG:
		r = kvmppc_hwrng_present();
		break;
	case KVM_CAP_PPC_MMU_RADIX:
		r = !!(hv_enabled && radix_enabled());
		break;
	case KVM_CAP_PPC_MMU_HASH_V3:
		r = !!(hv_enabled && !radix_enabled() &&
		       cpu_has_feature(CPU_FTR_ARCH_300));
		break;
#endif
	case KVM_CAP_SYNC_MMU:
#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
		r = hv_enabled;
#elif defined(KVM_ARCH_WANT_MMU_NOTIFIER)
		r = 1;
#else
		r = 0;
#endif
		break;
#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
	case KVM_CAP_PPC_HTAB_FD:
		r = hv_enabled;
		break;
#endif
	case KVM_CAP_NR_VCPUS:
		/*
		 * Recommending a number of CPUs is somewhat arbitrary; we
		 * return the number of present CPUs for -HV (since a host
		 * will have secondary threads ""offline""), and for other KVM
		 * implementations just count online CPUs.
		 */
		if (hv_enabled)
			r = num_present_cpus();
		else
			r = num_online_cpus();
		break;
	case KVM_CAP_NR_MEMSLOTS:
		r = KVM_USER_MEM_SLOTS;
		break;
	case KVM_CAP_MAX_VCPUS:
		r = KVM_MAX_VCPUS;
		break;
#ifdef CONFIG_PPC_BOOK3S_64
	case KVM_CAP_PPC_GET_SMMU_INFO:
		r = 1;
		break;
	case KVM_CAP_SPAPR_MULTITCE:
		r = 1;
		break;
	case KVM_CAP_SPAPR_RESIZE_HPT:
		/* Disable this on POWER9 until code handles new HPTE format */
		r = !!hv_enabled && !cpu_has_feature(CPU_FTR_ARCH_300);
		break;
#endif
#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
	case KVM_CAP_PPC_FWNMI:
		r = hv_enabled;
 		break;
 #endif
 	case KVM_CAP_PPC_HTM:
//flaw_line_below:
		r = cpu_has_feature(CPU_FTR_TM_COMP) &&
//flaw_line_below:
		    is_kvmppc_hv_enabled(kvm);
//fix_flaw_line_below:
//		r = cpu_has_feature(CPU_FTR_TM_COMP) && hv_enabled;
 		break;
 	default:
 		r = 0;
		break;
	}
	return r;

}
"
3162,180898,,Local,Not required,Complete,CVE-2017-15274,https://www.cvedetails.com/cve/CVE-2017-15274/,CWE-476,Low,,,,2017-10-11,4.9,"security/keys/keyctl.c in the Linux kernel before 4.11.5 does not consider the case of a NULL payload in conjunction with a nonzero length value, which allows local users to cause a denial of service (NULL pointer dereference and OOPS) via a crafted add_key or keyctl system call, a different vulnerability than CVE-2017-12192.",2018-03-15,DoS ,1,https://github.com/torvalds/linux/commit/5649645d725c73df4302428ee4e02c869248b4c5,5649645d725c73df4302428ee4e02c869248b4c5,"KEYS: fix dereferencing NULL payload with nonzero length

sys_add_key() and the KEYCTL_UPDATE operation of sys_keyctl() allowed a
NULL payload with nonzero length to be passed to the key type's
->preparse(), ->instantiate(), and/or ->update() methods.  Various key
types including asymmetric, cifs.idmap, cifs.spnego, and pkcs7_test did
not handle this case, allowing an unprivileged user to trivially cause a
NULL pointer dereference (kernel oops) if one of these key types was
present.  Fix it by doing the copy_from_user() when 'plen' is nonzero
rather than when '_payload' is non-NULL, causing the syscall to fail
with EFAULT as expected when an invalid buffer is specified.

Cc: stable@vger.kernel.org # 2.6.10+
Signed-off-by: Eric Biggers <ebiggers@google.com>
Signed-off-by: David Howells <dhowells@redhat.com>
Signed-off-by: James Morris <james.l.morris@oracle.com>",1,security/keys/keyctl.c,"{""sha"": ""94c2790f82839adb260dc2af00907c24c5f40826"", ""filename"": ""security/keys/keyctl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5649645d725c73df4302428ee4e02c869248b4c5/security/keys/keyctl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5649645d725c73df4302428ee4e02c869248b4c5/security/keys/keyctl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/keyctl.c?ref=5649645d725c73df4302428ee4e02c869248b4c5"", ""patch"": ""@@ -99,7 +99,7 @@ SYSCALL_DEFINE5(add_key, const char __user *, _type,\n \t/* pull the payload in if one was supplied */\n \tpayload = NULL;\n \n-\tif (_payload) {\n+\tif (plen) {\n \t\tret = -ENOMEM;\n \t\tpayload = kvmalloc(plen, GFP_KERNEL);\n \t\tif (!payload)\n@@ -324,7 +324,7 @@ long keyctl_update_key(key_serial_t id,\n \n \t/* pull the payload in if one was supplied */\n \tpayload = NULL;\n-\tif (_payload) {\n+\tif (plen) {\n \t\tret = -ENOMEM;\n \t\tpayload = kmalloc(plen, GFP_KERNEL);\n \t\tif (!payload)""}","SYSCALL_DEFINE5(add_key, const char __user *, _type,
		const char __user *, _description,
		const void __user *, _payload,
		size_t, plen,
		key_serial_t, ringid)
{
	key_ref_t keyring_ref, key_ref;
	char type[32], *description;
	void *payload;
	long ret;

	ret = -EINVAL;
	if (plen > 1024 * 1024 - 1)
		goto error;

	/* draw all the data into kernel space */
	ret = key_get_type_from_user(type, _type, sizeof(type));
	if (ret < 0)
		goto error;

	description = NULL;
	if (_description) {
		description = strndup_user(_description, KEY_MAX_DESC_SIZE);
		if (IS_ERR(description)) {
			ret = PTR_ERR(description);
			goto error;
		}
		if (!*description) {
			kfree(description);
			description = NULL;
		} else if ((description[0] == '.') &&
			   (strncmp(type, ""keyring"", 7) == 0)) {
			ret = -EPERM;
			goto error2;
		}
	}

 	/* pull the payload in if one was supplied */
 	payload = NULL;
 
	if (plen) {
 		ret = -ENOMEM;
 		payload = kvmalloc(plen, GFP_KERNEL);
 		if (!payload)
			goto error2;

		ret = -EFAULT;
		if (copy_from_user(payload, _payload, plen) != 0)
			goto error3;
	}

	/* find the target keyring (which must be writable) */
	keyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);
	if (IS_ERR(keyring_ref)) {
		ret = PTR_ERR(keyring_ref);
		goto error3;
	}

	/* create or update the requested key and add it to the target
	 * keyring */
	key_ref = key_create_or_update(keyring_ref, type, description,
				       payload, plen, KEY_PERM_UNDEF,
				       KEY_ALLOC_IN_QUOTA);
	if (!IS_ERR(key_ref)) {
		ret = key_ref_to_ptr(key_ref)->serial;
		key_ref_put(key_ref);
	}
	else {
		ret = PTR_ERR(key_ref);
	}

	key_ref_put(keyring_ref);
 error3:
	kvfree(payload);
 error2:
	kfree(description);
 error:
	return ret;
}
","SYSCALL_DEFINE5(add_key, const char __user *, _type,
		const char __user *, _description,
		const void __user *, _payload,
		size_t, plen,
		key_serial_t, ringid)
{
	key_ref_t keyring_ref, key_ref;
	char type[32], *description;
	void *payload;
	long ret;

	ret = -EINVAL;
	if (plen > 1024 * 1024 - 1)
		goto error;

	/* draw all the data into kernel space */
	ret = key_get_type_from_user(type, _type, sizeof(type));
	if (ret < 0)
		goto error;

	description = NULL;
	if (_description) {
		description = strndup_user(_description, KEY_MAX_DESC_SIZE);
		if (IS_ERR(description)) {
			ret = PTR_ERR(description);
			goto error;
		}
		if (!*description) {
			kfree(description);
			description = NULL;
		} else if ((description[0] == '.') &&
			   (strncmp(type, ""keyring"", 7) == 0)) {
			ret = -EPERM;
			goto error2;
		}
	}

 	/* pull the payload in if one was supplied */
 	payload = NULL;
 
	if (_payload) {
 		ret = -ENOMEM;
 		payload = kvmalloc(plen, GFP_KERNEL);
 		if (!payload)
			goto error2;

		ret = -EFAULT;
		if (copy_from_user(payload, _payload, plen) != 0)
			goto error3;
	}

	/* find the target keyring (which must be writable) */
	keyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);
	if (IS_ERR(keyring_ref)) {
		ret = PTR_ERR(keyring_ref);
		goto error3;
	}

	/* create or update the requested key and add it to the target
	 * keyring */
	key_ref = key_create_or_update(keyring_ref, type, description,
				       payload, plen, KEY_PERM_UNDEF,
				       KEY_ALLOC_IN_QUOTA);
	if (!IS_ERR(key_ref)) {
		ret = key_ref_to_ptr(key_ref)->serial;
		key_ref_put(key_ref);
	}
	else {
		ret = PTR_ERR(key_ref);
	}

	key_ref_put(keyring_ref);
 error3:
	kvfree(payload);
 error2:
	kfree(description);
 error:
	return ret;
}
",C,"	if (plen) {
","	if (_payload) {
",,"@@ -99,7 +99,7 @@ SYSCALL_DEFINE5(add_key, const char __user *, _type,
 	/* pull the payload in if one was supplied */
 	payload = NULL;
 
-	if (_payload) {
+	if (plen) {
 		ret = -ENOMEM;
 		payload = kvmalloc(plen, GFP_KERNEL);
 		if (!payload)
@@ -324,7 +324,7 @@ long keyctl_update_key(key_serial_t id,
 
 	/* pull the payload in if one was supplied */
 	payload = NULL;
-	if (_payload) {
+	if (plen) {
 		ret = -ENOMEM;
 		payload = kmalloc(plen, GFP_KERNEL);
 		if (!payload)",linux,5649645d725c73df4302428ee4e02c869248b4c5,0f534e4a13496b02ae284f50fcb0263f6ea37007,1,"SYSCALL_DEFINE5(add_key, const char __user *, _type,
		const char __user *, _description,
		const void __user *, _payload,
		size_t, plen,
		key_serial_t, ringid)
{
	key_ref_t keyring_ref, key_ref;
	char type[32], *description;
	void *payload;
	long ret;

	ret = -EINVAL;
	if (plen > 1024 * 1024 - 1)
		goto error;

	/* draw all the data into kernel space */
	ret = key_get_type_from_user(type, _type, sizeof(type));
	if (ret < 0)
		goto error;

	description = NULL;
	if (_description) {
		description = strndup_user(_description, KEY_MAX_DESC_SIZE);
		if (IS_ERR(description)) {
			ret = PTR_ERR(description);
			goto error;
		}
		if (!*description) {
			kfree(description);
			description = NULL;
		} else if ((description[0] == '.') &&
			   (strncmp(type, ""keyring"", 7) == 0)) {
			ret = -EPERM;
			goto error2;
		}
	}

 	/* pull the payload in if one was supplied */
 	payload = NULL;
 
//flaw_line_below:
	if (_payload) {
//fix_flaw_line_below:
//	if (plen) {
 		ret = -ENOMEM;
 		payload = kvmalloc(plen, GFP_KERNEL);
 		if (!payload)
			goto error2;

		ret = -EFAULT;
		if (copy_from_user(payload, _payload, plen) != 0)
			goto error3;
	}

	/* find the target keyring (which must be writable) */
	keyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);
	if (IS_ERR(keyring_ref)) {
		ret = PTR_ERR(keyring_ref);
		goto error3;
	}

	/* create or update the requested key and add it to the target
	 * keyring */
	key_ref = key_create_or_update(keyring_ref, type, description,
				       payload, plen, KEY_PERM_UNDEF,
				       KEY_ALLOC_IN_QUOTA);
	if (!IS_ERR(key_ref)) {
		ret = key_ref_to_ptr(key_ref)->serial;
		key_ref_put(key_ref);
	}
	else {
		ret = PTR_ERR(key_ref);
	}

	key_ref_put(keyring_ref);
 error3:
	kvfree(payload);
 error2:
	kfree(description);
 error:
	return ret;
}
"
3163,180899,,Local,Not required,Complete,CVE-2017-15274,https://www.cvedetails.com/cve/CVE-2017-15274/,CWE-476,Low,,,,2017-10-11,4.9,"security/keys/keyctl.c in the Linux kernel before 4.11.5 does not consider the case of a NULL payload in conjunction with a nonzero length value, which allows local users to cause a denial of service (NULL pointer dereference and OOPS) via a crafted add_key or keyctl system call, a different vulnerability than CVE-2017-12192.",2018-03-15,DoS ,1,https://github.com/torvalds/linux/commit/5649645d725c73df4302428ee4e02c869248b4c5,5649645d725c73df4302428ee4e02c869248b4c5,"KEYS: fix dereferencing NULL payload with nonzero length

sys_add_key() and the KEYCTL_UPDATE operation of sys_keyctl() allowed a
NULL payload with nonzero length to be passed to the key type's
->preparse(), ->instantiate(), and/or ->update() methods.  Various key
types including asymmetric, cifs.idmap, cifs.spnego, and pkcs7_test did
not handle this case, allowing an unprivileged user to trivially cause a
NULL pointer dereference (kernel oops) if one of these key types was
present.  Fix it by doing the copy_from_user() when 'plen' is nonzero
rather than when '_payload' is non-NULL, causing the syscall to fail
with EFAULT as expected when an invalid buffer is specified.

Cc: stable@vger.kernel.org # 2.6.10+
Signed-off-by: Eric Biggers <ebiggers@google.com>
Signed-off-by: David Howells <dhowells@redhat.com>
Signed-off-by: James Morris <james.l.morris@oracle.com>",1,security/keys/keyctl.c,"{""sha"": ""94c2790f82839adb260dc2af00907c24c5f40826"", ""filename"": ""security/keys/keyctl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5649645d725c73df4302428ee4e02c869248b4c5/security/keys/keyctl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5649645d725c73df4302428ee4e02c869248b4c5/security/keys/keyctl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/keyctl.c?ref=5649645d725c73df4302428ee4e02c869248b4c5"", ""patch"": ""@@ -99,7 +99,7 @@ SYSCALL_DEFINE5(add_key, const char __user *, _type,\n \t/* pull the payload in if one was supplied */\n \tpayload = NULL;\n \n-\tif (_payload) {\n+\tif (plen) {\n \t\tret = -ENOMEM;\n \t\tpayload = kvmalloc(plen, GFP_KERNEL);\n \t\tif (!payload)\n@@ -324,7 +324,7 @@ long keyctl_update_key(key_serial_t id,\n \n \t/* pull the payload in if one was supplied */\n \tpayload = NULL;\n-\tif (_payload) {\n+\tif (plen) {\n \t\tret = -ENOMEM;\n \t\tpayload = kmalloc(plen, GFP_KERNEL);\n \t\tif (!payload)""}","long keyctl_update_key(key_serial_t id,
		       const void __user *_payload,
		       size_t plen)
{
	key_ref_t key_ref;
	void *payload;
	long ret;

	ret = -EINVAL;
	if (plen > PAGE_SIZE)
		goto error;
 
 	/* pull the payload in if one was supplied */
 	payload = NULL;
	if (plen) {
 		ret = -ENOMEM;
 		payload = kmalloc(plen, GFP_KERNEL);
 		if (!payload)
			goto error;

		ret = -EFAULT;
		if (copy_from_user(payload, _payload, plen) != 0)
			goto error2;
	}

	/* find the target key (which must be writable) */
	key_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);
	if (IS_ERR(key_ref)) {
		ret = PTR_ERR(key_ref);
		goto error2;
	}

	/* update the key */
	ret = key_update(key_ref, payload, plen);

	key_ref_put(key_ref);
error2:
	kfree(payload);
error:
	return ret;
}
","long keyctl_update_key(key_serial_t id,
		       const void __user *_payload,
		       size_t plen)
{
	key_ref_t key_ref;
	void *payload;
	long ret;

	ret = -EINVAL;
	if (plen > PAGE_SIZE)
		goto error;
 
 	/* pull the payload in if one was supplied */
 	payload = NULL;
	if (_payload) {
 		ret = -ENOMEM;
 		payload = kmalloc(plen, GFP_KERNEL);
 		if (!payload)
			goto error;

		ret = -EFAULT;
		if (copy_from_user(payload, _payload, plen) != 0)
			goto error2;
	}

	/* find the target key (which must be writable) */
	key_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);
	if (IS_ERR(key_ref)) {
		ret = PTR_ERR(key_ref);
		goto error2;
	}

	/* update the key */
	ret = key_update(key_ref, payload, plen);

	key_ref_put(key_ref);
error2:
	kfree(payload);
error:
	return ret;
}
",C,"	if (plen) {
","	if (_payload) {
",,"@@ -99,7 +99,7 @@ SYSCALL_DEFINE5(add_key, const char __user *, _type,
 	/* pull the payload in if one was supplied */
 	payload = NULL;
 
-	if (_payload) {
+	if (plen) {
 		ret = -ENOMEM;
 		payload = kvmalloc(plen, GFP_KERNEL);
 		if (!payload)
@@ -324,7 +324,7 @@ long keyctl_update_key(key_serial_t id,
 
 	/* pull the payload in if one was supplied */
 	payload = NULL;
-	if (_payload) {
+	if (plen) {
 		ret = -ENOMEM;
 		payload = kmalloc(plen, GFP_KERNEL);
 		if (!payload)",linux,5649645d725c73df4302428ee4e02c869248b4c5,0f534e4a13496b02ae284f50fcb0263f6ea37007,1,"long keyctl_update_key(key_serial_t id,
		       const void __user *_payload,
		       size_t plen)
{
	key_ref_t key_ref;
	void *payload;
	long ret;

	ret = -EINVAL;
	if (plen > PAGE_SIZE)
		goto error;
 
 	/* pull the payload in if one was supplied */
 	payload = NULL;
//flaw_line_below:
	if (_payload) {
//fix_flaw_line_below:
//	if (plen) {
 		ret = -ENOMEM;
 		payload = kmalloc(plen, GFP_KERNEL);
 		if (!payload)
			goto error;

		ret = -EFAULT;
		if (copy_from_user(payload, _payload, plen) != 0)
			goto error2;
	}

	/* find the target key (which must be writable) */
	key_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);
	if (IS_ERR(key_ref)) {
		ret = PTR_ERR(key_ref);
		goto error2;
	}

	/* update the key */
	ret = key_update(key_ref, payload, plen);

	key_ref_put(key_ref);
error2:
	kfree(payload);
error:
	return ret;
}
"
3166,180902,,Local,Not required,Complete,CVE-2017-15116,https://www.cvedetails.com/cve/CVE-2017-15116/,CWE-476,Low,,,,2017-11-30,4.9,The rngapi_reset function in crypto/rng.c in the Linux kernel before 4.2 allows attackers to cause a denial of service (NULL pointer dereference).,2018-04-11,DoS ,0,https://github.com/torvalds/linux/commit/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,"crypto: rng - Remove old low-level rng interface

Now that all rng implementations have switched over to the new
interface, we can remove the old low-level interface.

Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",3,crypto/rng.c,"{""sha"": ""055e276427b120ed48c2acb6314c2e9d922c36ea"", ""filename"": ""crypto/rng.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 53, ""changes"": 57, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/crypto/rng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/crypto/rng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rng.c?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -4,6 +4,7 @@\n  * RNG operations.\n  *\n  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n  *\n  * This program is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU General Public License as published by the Free\n@@ -36,39 +37,6 @@ static inline struct crypto_rng *__crypto_rng_cast(struct crypto_tfm *tfm)\n \treturn container_of(tfm, struct crypto_rng, base);\n }\n \n-static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)\n-{\n-\treturn &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;\n-}\n-\n-static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,\n-\t\t    u8 *dst, unsigned int dlen)\n-{\n-\treturn crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);\n-}\n-\n-static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,\n-\t\t\tunsigned int slen)\n-{\n-\tu8 *buf = NULL;\n-\tu8 *src = (u8 *)seed;\n-\tint err;\n-\n-\tif (slen) {\n-\t\tbuf = kmalloc(slen, GFP_KERNEL);\n-\t\tif (!buf)\n-\t\t\treturn -ENOMEM;\n-\n-\t\tmemcpy(buf, seed, slen);\n-\t\tsrc = buf;\n-\t}\n-\n-\terr = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);\n-\n-\tkzfree(buf);\n-\treturn err;\n-}\n-\n int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n {\n \tu8 *buf = NULL;\n@@ -83,7 +51,7 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n \t\tseed = buf;\n \t}\n \n-\terr = tfm->seed(tfm, seed, slen);\n+\terr = crypto_rng_alg(tfm)->seed(tfm, seed, slen);\n \n \tkfree(buf);\n \treturn err;\n@@ -92,30 +60,14 @@ EXPORT_SYMBOL_GPL(crypto_rng_reset);\n \n static int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n {\n-\tstruct crypto_rng *rng = __crypto_rng_cast(tfm);\n-\tstruct rng_alg *alg = crypto_rng_alg(rng);\n-\tstruct old_rng_alg *oalg = crypto_old_rng_alg(rng);\n-\n-\tif (oalg->rng_make_random) {\n-\t\trng->generate = generate;\n-\t\trng->seed = rngapi_reset;\n-\t\trng->seedsize = oalg->seedsize;\n-\t\treturn 0;\n-\t}\n-\n-\trng->generate = alg->generate;\n-\trng->seed = alg->seed;\n-\trng->seedsize = alg->seedsize;\n-\n \treturn 0;\n }\n \n static unsigned int seedsize(struct crypto_alg *alg)\n {\n \tstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);\n \n-\treturn alg->cra_rng.rng_make_random ?\n-\t       alg->cra_rng.seedsize : ralg->seedsize;\n+\treturn ralg->seedsize;\n }\n \n #ifdef CONFIG_NET\n@@ -150,7 +102,7 @@ static void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)\n \tseq_printf(m, \""seedsize     : %u\\n\"", seedsize(alg));\n }\n \n-const struct crypto_type crypto_rng_type = {\n+static const struct crypto_type crypto_rng_type = {\n \t.extsize = crypto_alg_extsize,\n \t.init_tfm = crypto_rng_init_tfm,\n #ifdef CONFIG_PROC_FS\n@@ -162,7 +114,6 @@ const struct crypto_type crypto_rng_type = {\n \t.type = CRYPTO_ALG_TYPE_RNG,\n \t.tfmsize = offsetof(struct crypto_rng, base),\n };\n-EXPORT_SYMBOL_GPL(crypto_rng_type);\n \n struct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)\n {""}<_**next**_>{""sha"": ""263f1a5eebc7070122ab7bae111c8a0d4bee8265"", ""filename"": ""include/crypto/internal/rng.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/internal/rng.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/internal/rng.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/crypto/internal/rng.h?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -2,6 +2,7 @@\n  * RNG: Random Number Generator  algorithms under the crypto API\n  *\n  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n  *\n  * This program is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU General Public License as published by the Free\n@@ -16,8 +17,6 @@\n #include <crypto/algapi.h>\n #include <crypto/rng.h>\n \n-extern const struct crypto_type crypto_rng_type;\n-\n int crypto_register_rng(struct rng_alg *alg);\n void crypto_unregister_rng(struct rng_alg *alg);\n int crypto_register_rngs(struct rng_alg *algs, int count);""}<_**next**_>{""sha"": ""c5d4684429f5851f5728f767c4e50cdc970ec01e"", ""filename"": ""include/crypto/rng.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 7, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/rng.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/rng.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/crypto/rng.h?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -2,6 +2,7 @@\n  * RNG: Random Number Generator  algorithms under the crypto API\n  *\n  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n  *\n  * This program is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU General Public License as published by the Free\n@@ -56,11 +57,6 @@ struct rng_alg {\n };\n \n struct crypto_rng {\n-\tint (*generate)(struct crypto_rng *tfm,\n-\t\t\tconst u8 *src, unsigned int slen,\n-\t\t\tu8 *dst, unsigned int dlen);\n-\tint (*seed)(struct crypto_rng *tfm, const u8 *seed, unsigned int slen);\n-\tunsigned int seedsize;\n \tstruct crypto_tfm base;\n };\n \n@@ -144,7 +140,7 @@ static inline int crypto_rng_generate(struct crypto_rng *tfm,\n \t\t\t\t      const u8 *src, unsigned int slen,\n \t\t\t\t      u8 *dst, unsigned int dlen)\n {\n-\treturn tfm->generate(tfm, src, slen, dst, dlen);\n+\treturn crypto_rng_alg(tfm)->generate(tfm, src, slen, dst, dlen);\n }\n \n /**\n@@ -198,7 +194,7 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed,\n  */\n static inline int crypto_rng_seedsize(struct crypto_rng *tfm)\n {\n-\treturn tfm->seedsize;\n+\treturn crypto_rng_alg(tfm)->seedsize;\n }\n \n #endif""}<_**next**_>{""sha"": ""ee14140f8893b9b6f8a04c3fa17834e84d05c876"", ""filename"": ""include/linux/crypto.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 30, ""changes"": 30, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/linux/crypto.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/linux/crypto.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/crypto.h?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -138,7 +138,6 @@ struct crypto_async_request;\n struct crypto_aead;\n struct crypto_blkcipher;\n struct crypto_hash;\n-struct crypto_rng;\n struct crypto_tfm;\n struct crypto_type;\n struct aead_givcrypt_request;\n@@ -426,40 +425,12 @@ struct compress_alg {\n \t\t\t      unsigned int slen, u8 *dst, unsigned int *dlen);\n };\n \n-/**\n- * struct old_rng_alg - random number generator definition\n- * @rng_make_random: The function defined by this variable obtains a random\n- *\t\t     number. The random number generator transform must generate\n- *\t\t     the random number out of the context provided with this\n- *\t\t     call.\n- * @rng_reset: Reset of the random number generator by clearing the entire state.\n- *\t       With the invocation of this function call, the random number\n- *             generator shall completely reinitialize its state. If the random\n- *\t       number generator requires a seed for setting up a new state,\n- *\t       the seed must be provided by the consumer while invoking this\n- *\t       function. The required size of the seed is defined with\n- *\t       @seedsize .\n- * @seedsize: The seed size required for a random number generator\n- *\t      initialization defined with this variable. Some random number\n- *\t      generators like the SP800-90A DRBG does not require a seed as the\n- *\t      seeding is implemented internally without the need of support by\n- *\t      the consumer. In this case, the seed size is set to zero.\n- */\n-struct old_rng_alg {\n-\tint (*rng_make_random)(struct crypto_rng *tfm, u8 *rdata,\n-\t\t\t       unsigned int dlen);\n-\tint (*rng_reset)(struct crypto_rng *tfm, u8 *seed, unsigned int slen);\n-\n-\tunsigned int seedsize;\n-};\n-\n \n #define cra_ablkcipher\tcra_u.ablkcipher\n #define cra_aead\tcra_u.aead\n #define cra_blkcipher\tcra_u.blkcipher\n #define cra_cipher\tcra_u.cipher\n #define cra_compress\tcra_u.compress\n-#define cra_rng\t\tcra_u.rng\n \n /**\n  * struct crypto_alg - definition of a cryptograpic cipher algorithm\n@@ -559,7 +530,6 @@ struct crypto_alg {\n \t\tstruct blkcipher_alg blkcipher;\n \t\tstruct cipher_alg cipher;\n \t\tstruct compress_alg compress;\n-\t\tstruct old_rng_alg rng;\n \t} cra_u;\n \n \tint (*cra_init)(struct crypto_tfm *tfm);""}","static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)
","static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)
{
	return &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;
}
",C,,"{
	return &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;
}
",,"@@ -4,6 +4,7 @@
  * RNG operations.
  *
  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>
+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the Free
@@ -36,39 +37,6 @@ static inline struct crypto_rng *__crypto_rng_cast(struct crypto_tfm *tfm)
 	return container_of(tfm, struct crypto_rng, base);
 }
 
-static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)
-{
-	return &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;
-}
-
-static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,
-		    u8 *dst, unsigned int dlen)
-{
-	return crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);
-}
-
-static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,
-			unsigned int slen)
-{
-	u8 *buf = NULL;
-	u8 *src = (u8 *)seed;
-	int err;
-
-	if (slen) {
-		buf = kmalloc(slen, GFP_KERNEL);
-		if (!buf)
-			return -ENOMEM;
-
-		memcpy(buf, seed, slen);
-		src = buf;
-	}
-
-	err = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);
-
-	kzfree(buf);
-	return err;
-}
-
 int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
 {
 	u8 *buf = NULL;
@@ -83,7 +51,7 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
 		seed = buf;
 	}
 
-	err = tfm->seed(tfm, seed, slen);
+	err = crypto_rng_alg(tfm)->seed(tfm, seed, slen);
 
 	kfree(buf);
 	return err;
@@ -92,30 +60,14 @@ EXPORT_SYMBOL_GPL(crypto_rng_reset);
 
 static int crypto_rng_init_tfm(struct crypto_tfm *tfm)
 {
-	struct crypto_rng *rng = __crypto_rng_cast(tfm);
-	struct rng_alg *alg = crypto_rng_alg(rng);
-	struct old_rng_alg *oalg = crypto_old_rng_alg(rng);
-
-	if (oalg->rng_make_random) {
-		rng->generate = generate;
-		rng->seed = rngapi_reset;
-		rng->seedsize = oalg->seedsize;
-		return 0;
-	}
-
-	rng->generate = alg->generate;
-	rng->seed = alg->seed;
-	rng->seedsize = alg->seedsize;
-
 	return 0;
 }
 
 static unsigned int seedsize(struct crypto_alg *alg)
 {
 	struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
 
-	return alg->cra_rng.rng_make_random ?
-	       alg->cra_rng.seedsize : ralg->seedsize;
+	return ralg->seedsize;
 }
 
 #ifdef CONFIG_NET
@@ -150,7 +102,7 @@ static void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)
 	seq_printf(m, ""seedsize     : %u\n"", seedsize(alg));
 }
 
-const struct crypto_type crypto_rng_type = {
+static const struct crypto_type crypto_rng_type = {
 	.extsize = crypto_alg_extsize,
 	.init_tfm = crypto_rng_init_tfm,
 #ifdef CONFIG_PROC_FS
@@ -162,7 +114,6 @@ const struct crypto_type crypto_rng_type = {
 	.type = CRYPTO_ALG_TYPE_RNG,
 	.tfmsize = offsetof(struct crypto_rng, base),
 };
-EXPORT_SYMBOL_GPL(crypto_rng_type);
 
 struct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)
 {",linux,94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,e33cf2c5aab7d0012e7890089e89ae2466c2449c,1,"static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)
//flaw_line_below:
{
//flaw_line_below:
	return &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;
//flaw_line_below:
}
"
3167,180903,,Local,Not required,Complete,CVE-2017-15116,https://www.cvedetails.com/cve/CVE-2017-15116/,CWE-476,Low,,,,2017-11-30,4.9,The rngapi_reset function in crypto/rng.c in the Linux kernel before 4.2 allows attackers to cause a denial of service (NULL pointer dereference).,2018-04-11,DoS ,0,https://github.com/torvalds/linux/commit/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,"crypto: rng - Remove old low-level rng interface

Now that all rng implementations have switched over to the new
interface, we can remove the old low-level interface.

Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",12,crypto/rng.c,"{""sha"": ""055e276427b120ed48c2acb6314c2e9d922c36ea"", ""filename"": ""crypto/rng.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 53, ""changes"": 57, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/crypto/rng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/crypto/rng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rng.c?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -4,6 +4,7 @@\n  * RNG operations.\n  *\n  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n  *\n  * This program is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU General Public License as published by the Free\n@@ -36,39 +37,6 @@ static inline struct crypto_rng *__crypto_rng_cast(struct crypto_tfm *tfm)\n \treturn container_of(tfm, struct crypto_rng, base);\n }\n \n-static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)\n-{\n-\treturn &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;\n-}\n-\n-static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,\n-\t\t    u8 *dst, unsigned int dlen)\n-{\n-\treturn crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);\n-}\n-\n-static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,\n-\t\t\tunsigned int slen)\n-{\n-\tu8 *buf = NULL;\n-\tu8 *src = (u8 *)seed;\n-\tint err;\n-\n-\tif (slen) {\n-\t\tbuf = kmalloc(slen, GFP_KERNEL);\n-\t\tif (!buf)\n-\t\t\treturn -ENOMEM;\n-\n-\t\tmemcpy(buf, seed, slen);\n-\t\tsrc = buf;\n-\t}\n-\n-\terr = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);\n-\n-\tkzfree(buf);\n-\treturn err;\n-}\n-\n int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n {\n \tu8 *buf = NULL;\n@@ -83,7 +51,7 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n \t\tseed = buf;\n \t}\n \n-\terr = tfm->seed(tfm, seed, slen);\n+\terr = crypto_rng_alg(tfm)->seed(tfm, seed, slen);\n \n \tkfree(buf);\n \treturn err;\n@@ -92,30 +60,14 @@ EXPORT_SYMBOL_GPL(crypto_rng_reset);\n \n static int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n {\n-\tstruct crypto_rng *rng = __crypto_rng_cast(tfm);\n-\tstruct rng_alg *alg = crypto_rng_alg(rng);\n-\tstruct old_rng_alg *oalg = crypto_old_rng_alg(rng);\n-\n-\tif (oalg->rng_make_random) {\n-\t\trng->generate = generate;\n-\t\trng->seed = rngapi_reset;\n-\t\trng->seedsize = oalg->seedsize;\n-\t\treturn 0;\n-\t}\n-\n-\trng->generate = alg->generate;\n-\trng->seed = alg->seed;\n-\trng->seedsize = alg->seedsize;\n-\n \treturn 0;\n }\n \n static unsigned int seedsize(struct crypto_alg *alg)\n {\n \tstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);\n \n-\treturn alg->cra_rng.rng_make_random ?\n-\t       alg->cra_rng.seedsize : ralg->seedsize;\n+\treturn ralg->seedsize;\n }\n \n #ifdef CONFIG_NET\n@@ -150,7 +102,7 @@ static void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)\n \tseq_printf(m, \""seedsize     : %u\\n\"", seedsize(alg));\n }\n \n-const struct crypto_type crypto_rng_type = {\n+static const struct crypto_type crypto_rng_type = {\n \t.extsize = crypto_alg_extsize,\n \t.init_tfm = crypto_rng_init_tfm,\n #ifdef CONFIG_PROC_FS\n@@ -162,7 +114,6 @@ const struct crypto_type crypto_rng_type = {\n \t.type = CRYPTO_ALG_TYPE_RNG,\n \t.tfmsize = offsetof(struct crypto_rng, base),\n };\n-EXPORT_SYMBOL_GPL(crypto_rng_type);\n \n struct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)\n {""}<_**next**_>{""sha"": ""263f1a5eebc7070122ab7bae111c8a0d4bee8265"", ""filename"": ""include/crypto/internal/rng.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/internal/rng.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/internal/rng.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/crypto/internal/rng.h?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -2,6 +2,7 @@\n  * RNG: Random Number Generator  algorithms under the crypto API\n  *\n  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n  *\n  * This program is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU General Public License as published by the Free\n@@ -16,8 +17,6 @@\n #include <crypto/algapi.h>\n #include <crypto/rng.h>\n \n-extern const struct crypto_type crypto_rng_type;\n-\n int crypto_register_rng(struct rng_alg *alg);\n void crypto_unregister_rng(struct rng_alg *alg);\n int crypto_register_rngs(struct rng_alg *algs, int count);""}<_**next**_>{""sha"": ""c5d4684429f5851f5728f767c4e50cdc970ec01e"", ""filename"": ""include/crypto/rng.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 7, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/rng.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/rng.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/crypto/rng.h?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -2,6 +2,7 @@\n  * RNG: Random Number Generator  algorithms under the crypto API\n  *\n  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n  *\n  * This program is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU General Public License as published by the Free\n@@ -56,11 +57,6 @@ struct rng_alg {\n };\n \n struct crypto_rng {\n-\tint (*generate)(struct crypto_rng *tfm,\n-\t\t\tconst u8 *src, unsigned int slen,\n-\t\t\tu8 *dst, unsigned int dlen);\n-\tint (*seed)(struct crypto_rng *tfm, const u8 *seed, unsigned int slen);\n-\tunsigned int seedsize;\n \tstruct crypto_tfm base;\n };\n \n@@ -144,7 +140,7 @@ static inline int crypto_rng_generate(struct crypto_rng *tfm,\n \t\t\t\t      const u8 *src, unsigned int slen,\n \t\t\t\t      u8 *dst, unsigned int dlen)\n {\n-\treturn tfm->generate(tfm, src, slen, dst, dlen);\n+\treturn crypto_rng_alg(tfm)->generate(tfm, src, slen, dst, dlen);\n }\n \n /**\n@@ -198,7 +194,7 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed,\n  */\n static inline int crypto_rng_seedsize(struct crypto_rng *tfm)\n {\n-\treturn tfm->seedsize;\n+\treturn crypto_rng_alg(tfm)->seedsize;\n }\n \n #endif""}<_**next**_>{""sha"": ""ee14140f8893b9b6f8a04c3fa17834e84d05c876"", ""filename"": ""include/linux/crypto.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 30, ""changes"": 30, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/linux/crypto.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/linux/crypto.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/crypto.h?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -138,7 +138,6 @@ struct crypto_async_request;\n struct crypto_aead;\n struct crypto_blkcipher;\n struct crypto_hash;\n-struct crypto_rng;\n struct crypto_tfm;\n struct crypto_type;\n struct aead_givcrypt_request;\n@@ -426,40 +425,12 @@ struct compress_alg {\n \t\t\t      unsigned int slen, u8 *dst, unsigned int *dlen);\n };\n \n-/**\n- * struct old_rng_alg - random number generator definition\n- * @rng_make_random: The function defined by this variable obtains a random\n- *\t\t     number. The random number generator transform must generate\n- *\t\t     the random number out of the context provided with this\n- *\t\t     call.\n- * @rng_reset: Reset of the random number generator by clearing the entire state.\n- *\t       With the invocation of this function call, the random number\n- *             generator shall completely reinitialize its state. If the random\n- *\t       number generator requires a seed for setting up a new state,\n- *\t       the seed must be provided by the consumer while invoking this\n- *\t       function. The required size of the seed is defined with\n- *\t       @seedsize .\n- * @seedsize: The seed size required for a random number generator\n- *\t      initialization defined with this variable. Some random number\n- *\t      generators like the SP800-90A DRBG does not require a seed as the\n- *\t      seeding is implemented internally without the need of support by\n- *\t      the consumer. In this case, the seed size is set to zero.\n- */\n-struct old_rng_alg {\n-\tint (*rng_make_random)(struct crypto_rng *tfm, u8 *rdata,\n-\t\t\t       unsigned int dlen);\n-\tint (*rng_reset)(struct crypto_rng *tfm, u8 *seed, unsigned int slen);\n-\n-\tunsigned int seedsize;\n-};\n-\n \n #define cra_ablkcipher\tcra_u.ablkcipher\n #define cra_aead\tcra_u.aead\n #define cra_blkcipher\tcra_u.blkcipher\n #define cra_cipher\tcra_u.cipher\n #define cra_compress\tcra_u.compress\n-#define cra_rng\t\tcra_u.rng\n \n /**\n  * struct crypto_alg - definition of a cryptograpic cipher algorithm\n@@ -559,7 +530,6 @@ struct crypto_alg {\n \t\tstruct blkcipher_alg blkcipher;\n \t\tstruct cipher_alg cipher;\n \t\tstruct compress_alg compress;\n-\t\tstruct old_rng_alg rng;\n \t} cra_u;\n \n \tint (*cra_init)(struct crypto_tfm *tfm);""}"," static int crypto_rng_init_tfm(struct crypto_tfm *tfm)
 {
 	return 0;
 }
"," static int crypto_rng_init_tfm(struct crypto_tfm *tfm)
 {
	struct crypto_rng *rng = __crypto_rng_cast(tfm);
	struct rng_alg *alg = crypto_rng_alg(rng);
	struct old_rng_alg *oalg = crypto_old_rng_alg(rng);
	if (oalg->rng_make_random) {
		rng->generate = generate;
		rng->seed = rngapi_reset;
		rng->seedsize = oalg->seedsize;
		return 0;
	}
	rng->generate = alg->generate;
	rng->seed = alg->seed;
	rng->seedsize = alg->seedsize;
 	return 0;
 }
",C,,"	struct crypto_rng *rng = __crypto_rng_cast(tfm);
	struct rng_alg *alg = crypto_rng_alg(rng);
	struct old_rng_alg *oalg = crypto_old_rng_alg(rng);
	if (oalg->rng_make_random) {
		rng->generate = generate;
		rng->seed = rngapi_reset;
		rng->seedsize = oalg->seedsize;
		return 0;
	}
	rng->generate = alg->generate;
	rng->seed = alg->seed;
	rng->seedsize = alg->seedsize;
",,"@@ -4,6 +4,7 @@
  * RNG operations.
  *
  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>
+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the Free
@@ -36,39 +37,6 @@ static inline struct crypto_rng *__crypto_rng_cast(struct crypto_tfm *tfm)
 	return container_of(tfm, struct crypto_rng, base);
 }
 
-static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)
-{
-	return &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;
-}
-
-static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,
-		    u8 *dst, unsigned int dlen)
-{
-	return crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);
-}
-
-static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,
-			unsigned int slen)
-{
-	u8 *buf = NULL;
-	u8 *src = (u8 *)seed;
-	int err;
-
-	if (slen) {
-		buf = kmalloc(slen, GFP_KERNEL);
-		if (!buf)
-			return -ENOMEM;
-
-		memcpy(buf, seed, slen);
-		src = buf;
-	}
-
-	err = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);
-
-	kzfree(buf);
-	return err;
-}
-
 int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
 {
 	u8 *buf = NULL;
@@ -83,7 +51,7 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
 		seed = buf;
 	}
 
-	err = tfm->seed(tfm, seed, slen);
+	err = crypto_rng_alg(tfm)->seed(tfm, seed, slen);
 
 	kfree(buf);
 	return err;
@@ -92,30 +60,14 @@ EXPORT_SYMBOL_GPL(crypto_rng_reset);
 
 static int crypto_rng_init_tfm(struct crypto_tfm *tfm)
 {
-	struct crypto_rng *rng = __crypto_rng_cast(tfm);
-	struct rng_alg *alg = crypto_rng_alg(rng);
-	struct old_rng_alg *oalg = crypto_old_rng_alg(rng);
-
-	if (oalg->rng_make_random) {
-		rng->generate = generate;
-		rng->seed = rngapi_reset;
-		rng->seedsize = oalg->seedsize;
-		return 0;
-	}
-
-	rng->generate = alg->generate;
-	rng->seed = alg->seed;
-	rng->seedsize = alg->seedsize;
-
 	return 0;
 }
 
 static unsigned int seedsize(struct crypto_alg *alg)
 {
 	struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
 
-	return alg->cra_rng.rng_make_random ?
-	       alg->cra_rng.seedsize : ralg->seedsize;
+	return ralg->seedsize;
 }
 
 #ifdef CONFIG_NET
@@ -150,7 +102,7 @@ static void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)
 	seq_printf(m, ""seedsize     : %u\n"", seedsize(alg));
 }
 
-const struct crypto_type crypto_rng_type = {
+static const struct crypto_type crypto_rng_type = {
 	.extsize = crypto_alg_extsize,
 	.init_tfm = crypto_rng_init_tfm,
 #ifdef CONFIG_PROC_FS
@@ -162,7 +114,6 @@ const struct crypto_type crypto_rng_type = {
 	.type = CRYPTO_ALG_TYPE_RNG,
 	.tfmsize = offsetof(struct crypto_rng, base),
 };
-EXPORT_SYMBOL_GPL(crypto_rng_type);
 
 struct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)
 {",linux,94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,e33cf2c5aab7d0012e7890089e89ae2466c2449c,1," static int crypto_rng_init_tfm(struct crypto_tfm *tfm)
 {
//flaw_line_below:
	struct crypto_rng *rng = __crypto_rng_cast(tfm);
//flaw_line_below:
	struct rng_alg *alg = crypto_rng_alg(rng);
//flaw_line_below:
	struct old_rng_alg *oalg = crypto_old_rng_alg(rng);
//flaw_line_below:

//flaw_line_below:
	if (oalg->rng_make_random) {
//flaw_line_below:
		rng->generate = generate;
//flaw_line_below:
		rng->seed = rngapi_reset;
//flaw_line_below:
		rng->seedsize = oalg->seedsize;
//flaw_line_below:
		return 0;
//flaw_line_below:
	}
//flaw_line_below:

//flaw_line_below:
	rng->generate = alg->generate;
//flaw_line_below:
	rng->seed = alg->seed;
//flaw_line_below:
	rng->seedsize = alg->seedsize;
//flaw_line_below:

 	return 0;
 }
"
3168,180904,,Local,Not required,Complete,CVE-2017-15116,https://www.cvedetails.com/cve/CVE-2017-15116/,CWE-476,Low,,,,2017-11-30,4.9,The rngapi_reset function in crypto/rng.c in the Linux kernel before 4.2 allows attackers to cause a denial of service (NULL pointer dereference).,2018-04-11,DoS ,1,https://github.com/torvalds/linux/commit/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,"crypto: rng - Remove old low-level rng interface

Now that all rng implementations have switched over to the new
interface, we can remove the old low-level interface.

Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",1,crypto/rng.c,"{""sha"": ""055e276427b120ed48c2acb6314c2e9d922c36ea"", ""filename"": ""crypto/rng.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 53, ""changes"": 57, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/crypto/rng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/crypto/rng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rng.c?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -4,6 +4,7 @@\n  * RNG operations.\n  *\n  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n  *\n  * This program is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU General Public License as published by the Free\n@@ -36,39 +37,6 @@ static inline struct crypto_rng *__crypto_rng_cast(struct crypto_tfm *tfm)\n \treturn container_of(tfm, struct crypto_rng, base);\n }\n \n-static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)\n-{\n-\treturn &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;\n-}\n-\n-static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,\n-\t\t    u8 *dst, unsigned int dlen)\n-{\n-\treturn crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);\n-}\n-\n-static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,\n-\t\t\tunsigned int slen)\n-{\n-\tu8 *buf = NULL;\n-\tu8 *src = (u8 *)seed;\n-\tint err;\n-\n-\tif (slen) {\n-\t\tbuf = kmalloc(slen, GFP_KERNEL);\n-\t\tif (!buf)\n-\t\t\treturn -ENOMEM;\n-\n-\t\tmemcpy(buf, seed, slen);\n-\t\tsrc = buf;\n-\t}\n-\n-\terr = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);\n-\n-\tkzfree(buf);\n-\treturn err;\n-}\n-\n int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n {\n \tu8 *buf = NULL;\n@@ -83,7 +51,7 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n \t\tseed = buf;\n \t}\n \n-\terr = tfm->seed(tfm, seed, slen);\n+\terr = crypto_rng_alg(tfm)->seed(tfm, seed, slen);\n \n \tkfree(buf);\n \treturn err;\n@@ -92,30 +60,14 @@ EXPORT_SYMBOL_GPL(crypto_rng_reset);\n \n static int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n {\n-\tstruct crypto_rng *rng = __crypto_rng_cast(tfm);\n-\tstruct rng_alg *alg = crypto_rng_alg(rng);\n-\tstruct old_rng_alg *oalg = crypto_old_rng_alg(rng);\n-\n-\tif (oalg->rng_make_random) {\n-\t\trng->generate = generate;\n-\t\trng->seed = rngapi_reset;\n-\t\trng->seedsize = oalg->seedsize;\n-\t\treturn 0;\n-\t}\n-\n-\trng->generate = alg->generate;\n-\trng->seed = alg->seed;\n-\trng->seedsize = alg->seedsize;\n-\n \treturn 0;\n }\n \n static unsigned int seedsize(struct crypto_alg *alg)\n {\n \tstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);\n \n-\treturn alg->cra_rng.rng_make_random ?\n-\t       alg->cra_rng.seedsize : ralg->seedsize;\n+\treturn ralg->seedsize;\n }\n \n #ifdef CONFIG_NET\n@@ -150,7 +102,7 @@ static void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)\n \tseq_printf(m, \""seedsize     : %u\\n\"", seedsize(alg));\n }\n \n-const struct crypto_type crypto_rng_type = {\n+static const struct crypto_type crypto_rng_type = {\n \t.extsize = crypto_alg_extsize,\n \t.init_tfm = crypto_rng_init_tfm,\n #ifdef CONFIG_PROC_FS\n@@ -162,7 +114,6 @@ const struct crypto_type crypto_rng_type = {\n \t.type = CRYPTO_ALG_TYPE_RNG,\n \t.tfmsize = offsetof(struct crypto_rng, base),\n };\n-EXPORT_SYMBOL_GPL(crypto_rng_type);\n \n struct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)\n {""}<_**next**_>{""sha"": ""263f1a5eebc7070122ab7bae111c8a0d4bee8265"", ""filename"": ""include/crypto/internal/rng.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/internal/rng.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/internal/rng.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/crypto/internal/rng.h?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -2,6 +2,7 @@\n  * RNG: Random Number Generator  algorithms under the crypto API\n  *\n  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n  *\n  * This program is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU General Public License as published by the Free\n@@ -16,8 +17,6 @@\n #include <crypto/algapi.h>\n #include <crypto/rng.h>\n \n-extern const struct crypto_type crypto_rng_type;\n-\n int crypto_register_rng(struct rng_alg *alg);\n void crypto_unregister_rng(struct rng_alg *alg);\n int crypto_register_rngs(struct rng_alg *algs, int count);""}<_**next**_>{""sha"": ""c5d4684429f5851f5728f767c4e50cdc970ec01e"", ""filename"": ""include/crypto/rng.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 7, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/rng.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/rng.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/crypto/rng.h?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -2,6 +2,7 @@\n  * RNG: Random Number Generator  algorithms under the crypto API\n  *\n  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n  *\n  * This program is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU General Public License as published by the Free\n@@ -56,11 +57,6 @@ struct rng_alg {\n };\n \n struct crypto_rng {\n-\tint (*generate)(struct crypto_rng *tfm,\n-\t\t\tconst u8 *src, unsigned int slen,\n-\t\t\tu8 *dst, unsigned int dlen);\n-\tint (*seed)(struct crypto_rng *tfm, const u8 *seed, unsigned int slen);\n-\tunsigned int seedsize;\n \tstruct crypto_tfm base;\n };\n \n@@ -144,7 +140,7 @@ static inline int crypto_rng_generate(struct crypto_rng *tfm,\n \t\t\t\t      const u8 *src, unsigned int slen,\n \t\t\t\t      u8 *dst, unsigned int dlen)\n {\n-\treturn tfm->generate(tfm, src, slen, dst, dlen);\n+\treturn crypto_rng_alg(tfm)->generate(tfm, src, slen, dst, dlen);\n }\n \n /**\n@@ -198,7 +194,7 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed,\n  */\n static inline int crypto_rng_seedsize(struct crypto_rng *tfm)\n {\n-\treturn tfm->seedsize;\n+\treturn crypto_rng_alg(tfm)->seedsize;\n }\n \n #endif""}<_**next**_>{""sha"": ""ee14140f8893b9b6f8a04c3fa17834e84d05c876"", ""filename"": ""include/linux/crypto.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 30, ""changes"": 30, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/linux/crypto.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/linux/crypto.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/crypto.h?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -138,7 +138,6 @@ struct crypto_async_request;\n struct crypto_aead;\n struct crypto_blkcipher;\n struct crypto_hash;\n-struct crypto_rng;\n struct crypto_tfm;\n struct crypto_type;\n struct aead_givcrypt_request;\n@@ -426,40 +425,12 @@ struct compress_alg {\n \t\t\t      unsigned int slen, u8 *dst, unsigned int *dlen);\n };\n \n-/**\n- * struct old_rng_alg - random number generator definition\n- * @rng_make_random: The function defined by this variable obtains a random\n- *\t\t     number. The random number generator transform must generate\n- *\t\t     the random number out of the context provided with this\n- *\t\t     call.\n- * @rng_reset: Reset of the random number generator by clearing the entire state.\n- *\t       With the invocation of this function call, the random number\n- *             generator shall completely reinitialize its state. If the random\n- *\t       number generator requires a seed for setting up a new state,\n- *\t       the seed must be provided by the consumer while invoking this\n- *\t       function. The required size of the seed is defined with\n- *\t       @seedsize .\n- * @seedsize: The seed size required for a random number generator\n- *\t      initialization defined with this variable. Some random number\n- *\t      generators like the SP800-90A DRBG does not require a seed as the\n- *\t      seeding is implemented internally without the need of support by\n- *\t      the consumer. In this case, the seed size is set to zero.\n- */\n-struct old_rng_alg {\n-\tint (*rng_make_random)(struct crypto_rng *tfm, u8 *rdata,\n-\t\t\t       unsigned int dlen);\n-\tint (*rng_reset)(struct crypto_rng *tfm, u8 *seed, unsigned int slen);\n-\n-\tunsigned int seedsize;\n-};\n-\n \n #define cra_ablkcipher\tcra_u.ablkcipher\n #define cra_aead\tcra_u.aead\n #define cra_blkcipher\tcra_u.blkcipher\n #define cra_cipher\tcra_u.cipher\n #define cra_compress\tcra_u.compress\n-#define cra_rng\t\tcra_u.rng\n \n /**\n  * struct crypto_alg - definition of a cryptograpic cipher algorithm\n@@ -559,7 +530,6 @@ struct crypto_alg {\n \t\tstruct blkcipher_alg blkcipher;\n \t\tstruct cipher_alg cipher;\n \t\tstruct compress_alg compress;\n-\t\tstruct old_rng_alg rng;\n \t} cra_u;\n \n \tint (*cra_init)(struct crypto_tfm *tfm);""}"," int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
 {
 	u8 *buf = NULL;
	int err;

	if (!seed && slen) {
		buf = kmalloc(slen, GFP_KERNEL);
		if (!buf)
			return -ENOMEM;

		get_random_bytes(buf, slen);
 		seed = buf;
 	}
 
	err = crypto_rng_alg(tfm)->seed(tfm, seed, slen);
 
 	kfree(buf);
 	return err;
}
"," int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
 {
 	u8 *buf = NULL;
	int err;

	if (!seed && slen) {
		buf = kmalloc(slen, GFP_KERNEL);
		if (!buf)
			return -ENOMEM;

		get_random_bytes(buf, slen);
 		seed = buf;
 	}
 
	err = tfm->seed(tfm, seed, slen);
 
 	kfree(buf);
 	return err;
}
",C,"	err = crypto_rng_alg(tfm)->seed(tfm, seed, slen);
","	err = tfm->seed(tfm, seed, slen);
",,"@@ -4,6 +4,7 @@
  * RNG operations.
  *
  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>
+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the Free
@@ -36,39 +37,6 @@ static inline struct crypto_rng *__crypto_rng_cast(struct crypto_tfm *tfm)
 	return container_of(tfm, struct crypto_rng, base);
 }
 
-static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)
-{
-	return &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;
-}
-
-static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,
-		    u8 *dst, unsigned int dlen)
-{
-	return crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);
-}
-
-static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,
-			unsigned int slen)
-{
-	u8 *buf = NULL;
-	u8 *src = (u8 *)seed;
-	int err;
-
-	if (slen) {
-		buf = kmalloc(slen, GFP_KERNEL);
-		if (!buf)
-			return -ENOMEM;
-
-		memcpy(buf, seed, slen);
-		src = buf;
-	}
-
-	err = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);
-
-	kzfree(buf);
-	return err;
-}
-
 int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
 {
 	u8 *buf = NULL;
@@ -83,7 +51,7 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
 		seed = buf;
 	}
 
-	err = tfm->seed(tfm, seed, slen);
+	err = crypto_rng_alg(tfm)->seed(tfm, seed, slen);
 
 	kfree(buf);
 	return err;
@@ -92,30 +60,14 @@ EXPORT_SYMBOL_GPL(crypto_rng_reset);
 
 static int crypto_rng_init_tfm(struct crypto_tfm *tfm)
 {
-	struct crypto_rng *rng = __crypto_rng_cast(tfm);
-	struct rng_alg *alg = crypto_rng_alg(rng);
-	struct old_rng_alg *oalg = crypto_old_rng_alg(rng);
-
-	if (oalg->rng_make_random) {
-		rng->generate = generate;
-		rng->seed = rngapi_reset;
-		rng->seedsize = oalg->seedsize;
-		return 0;
-	}
-
-	rng->generate = alg->generate;
-	rng->seed = alg->seed;
-	rng->seedsize = alg->seedsize;
-
 	return 0;
 }
 
 static unsigned int seedsize(struct crypto_alg *alg)
 {
 	struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
 
-	return alg->cra_rng.rng_make_random ?
-	       alg->cra_rng.seedsize : ralg->seedsize;
+	return ralg->seedsize;
 }
 
 #ifdef CONFIG_NET
@@ -150,7 +102,7 @@ static void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)
 	seq_printf(m, ""seedsize     : %u\n"", seedsize(alg));
 }
 
-const struct crypto_type crypto_rng_type = {
+static const struct crypto_type crypto_rng_type = {
 	.extsize = crypto_alg_extsize,
 	.init_tfm = crypto_rng_init_tfm,
 #ifdef CONFIG_PROC_FS
@@ -162,7 +114,6 @@ const struct crypto_type crypto_rng_type = {
 	.type = CRYPTO_ALG_TYPE_RNG,
 	.tfmsize = offsetof(struct crypto_rng, base),
 };
-EXPORT_SYMBOL_GPL(crypto_rng_type);
 
 struct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)
 {",linux,94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,e33cf2c5aab7d0012e7890089e89ae2466c2449c,1," int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
 {
 	u8 *buf = NULL;
	int err;

	if (!seed && slen) {
		buf = kmalloc(slen, GFP_KERNEL);
		if (!buf)
			return -ENOMEM;

		get_random_bytes(buf, slen);
 		seed = buf;
 	}
 
//flaw_line_below:
	err = tfm->seed(tfm, seed, slen);
//fix_flaw_line_below:
//	err = crypto_rng_alg(tfm)->seed(tfm, seed, slen);
 
 	kfree(buf);
 	return err;
}
"
3169,180905,,Local,Not required,Complete,CVE-2017-15116,https://www.cvedetails.com/cve/CVE-2017-15116/,CWE-476,Low,,,,2017-11-30,4.9,The rngapi_reset function in crypto/rng.c in the Linux kernel before 4.2 allows attackers to cause a denial of service (NULL pointer dereference).,2018-04-11,DoS ,0,https://github.com/torvalds/linux/commit/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,"crypto: rng - Remove old low-level rng interface

Now that all rng implementations have switched over to the new
interface, we can remove the old low-level interface.

Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",4,crypto/rng.c,"{""sha"": ""055e276427b120ed48c2acb6314c2e9d922c36ea"", ""filename"": ""crypto/rng.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 53, ""changes"": 57, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/crypto/rng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/crypto/rng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rng.c?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -4,6 +4,7 @@\n  * RNG operations.\n  *\n  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n  *\n  * This program is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU General Public License as published by the Free\n@@ -36,39 +37,6 @@ static inline struct crypto_rng *__crypto_rng_cast(struct crypto_tfm *tfm)\n \treturn container_of(tfm, struct crypto_rng, base);\n }\n \n-static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)\n-{\n-\treturn &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;\n-}\n-\n-static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,\n-\t\t    u8 *dst, unsigned int dlen)\n-{\n-\treturn crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);\n-}\n-\n-static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,\n-\t\t\tunsigned int slen)\n-{\n-\tu8 *buf = NULL;\n-\tu8 *src = (u8 *)seed;\n-\tint err;\n-\n-\tif (slen) {\n-\t\tbuf = kmalloc(slen, GFP_KERNEL);\n-\t\tif (!buf)\n-\t\t\treturn -ENOMEM;\n-\n-\t\tmemcpy(buf, seed, slen);\n-\t\tsrc = buf;\n-\t}\n-\n-\terr = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);\n-\n-\tkzfree(buf);\n-\treturn err;\n-}\n-\n int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n {\n \tu8 *buf = NULL;\n@@ -83,7 +51,7 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n \t\tseed = buf;\n \t}\n \n-\terr = tfm->seed(tfm, seed, slen);\n+\terr = crypto_rng_alg(tfm)->seed(tfm, seed, slen);\n \n \tkfree(buf);\n \treturn err;\n@@ -92,30 +60,14 @@ EXPORT_SYMBOL_GPL(crypto_rng_reset);\n \n static int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n {\n-\tstruct crypto_rng *rng = __crypto_rng_cast(tfm);\n-\tstruct rng_alg *alg = crypto_rng_alg(rng);\n-\tstruct old_rng_alg *oalg = crypto_old_rng_alg(rng);\n-\n-\tif (oalg->rng_make_random) {\n-\t\trng->generate = generate;\n-\t\trng->seed = rngapi_reset;\n-\t\trng->seedsize = oalg->seedsize;\n-\t\treturn 0;\n-\t}\n-\n-\trng->generate = alg->generate;\n-\trng->seed = alg->seed;\n-\trng->seedsize = alg->seedsize;\n-\n \treturn 0;\n }\n \n static unsigned int seedsize(struct crypto_alg *alg)\n {\n \tstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);\n \n-\treturn alg->cra_rng.rng_make_random ?\n-\t       alg->cra_rng.seedsize : ralg->seedsize;\n+\treturn ralg->seedsize;\n }\n \n #ifdef CONFIG_NET\n@@ -150,7 +102,7 @@ static void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)\n \tseq_printf(m, \""seedsize     : %u\\n\"", seedsize(alg));\n }\n \n-const struct crypto_type crypto_rng_type = {\n+static const struct crypto_type crypto_rng_type = {\n \t.extsize = crypto_alg_extsize,\n \t.init_tfm = crypto_rng_init_tfm,\n #ifdef CONFIG_PROC_FS\n@@ -162,7 +114,6 @@ const struct crypto_type crypto_rng_type = {\n \t.type = CRYPTO_ALG_TYPE_RNG,\n \t.tfmsize = offsetof(struct crypto_rng, base),\n };\n-EXPORT_SYMBOL_GPL(crypto_rng_type);\n \n struct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)\n {""}<_**next**_>{""sha"": ""263f1a5eebc7070122ab7bae111c8a0d4bee8265"", ""filename"": ""include/crypto/internal/rng.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/internal/rng.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/internal/rng.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/crypto/internal/rng.h?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -2,6 +2,7 @@\n  * RNG: Random Number Generator  algorithms under the crypto API\n  *\n  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n  *\n  * This program is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU General Public License as published by the Free\n@@ -16,8 +17,6 @@\n #include <crypto/algapi.h>\n #include <crypto/rng.h>\n \n-extern const struct crypto_type crypto_rng_type;\n-\n int crypto_register_rng(struct rng_alg *alg);\n void crypto_unregister_rng(struct rng_alg *alg);\n int crypto_register_rngs(struct rng_alg *algs, int count);""}<_**next**_>{""sha"": ""c5d4684429f5851f5728f767c4e50cdc970ec01e"", ""filename"": ""include/crypto/rng.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 7, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/rng.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/rng.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/crypto/rng.h?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -2,6 +2,7 @@\n  * RNG: Random Number Generator  algorithms under the crypto API\n  *\n  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n  *\n  * This program is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU General Public License as published by the Free\n@@ -56,11 +57,6 @@ struct rng_alg {\n };\n \n struct crypto_rng {\n-\tint (*generate)(struct crypto_rng *tfm,\n-\t\t\tconst u8 *src, unsigned int slen,\n-\t\t\tu8 *dst, unsigned int dlen);\n-\tint (*seed)(struct crypto_rng *tfm, const u8 *seed, unsigned int slen);\n-\tunsigned int seedsize;\n \tstruct crypto_tfm base;\n };\n \n@@ -144,7 +140,7 @@ static inline int crypto_rng_generate(struct crypto_rng *tfm,\n \t\t\t\t      const u8 *src, unsigned int slen,\n \t\t\t\t      u8 *dst, unsigned int dlen)\n {\n-\treturn tfm->generate(tfm, src, slen, dst, dlen);\n+\treturn crypto_rng_alg(tfm)->generate(tfm, src, slen, dst, dlen);\n }\n \n /**\n@@ -198,7 +194,7 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed,\n  */\n static inline int crypto_rng_seedsize(struct crypto_rng *tfm)\n {\n-\treturn tfm->seedsize;\n+\treturn crypto_rng_alg(tfm)->seedsize;\n }\n \n #endif""}<_**next**_>{""sha"": ""ee14140f8893b9b6f8a04c3fa17834e84d05c876"", ""filename"": ""include/linux/crypto.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 30, ""changes"": 30, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/linux/crypto.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/linux/crypto.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/crypto.h?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -138,7 +138,6 @@ struct crypto_async_request;\n struct crypto_aead;\n struct crypto_blkcipher;\n struct crypto_hash;\n-struct crypto_rng;\n struct crypto_tfm;\n struct crypto_type;\n struct aead_givcrypt_request;\n@@ -426,40 +425,12 @@ struct compress_alg {\n \t\t\t      unsigned int slen, u8 *dst, unsigned int *dlen);\n };\n \n-/**\n- * struct old_rng_alg - random number generator definition\n- * @rng_make_random: The function defined by this variable obtains a random\n- *\t\t     number. The random number generator transform must generate\n- *\t\t     the random number out of the context provided with this\n- *\t\t     call.\n- * @rng_reset: Reset of the random number generator by clearing the entire state.\n- *\t       With the invocation of this function call, the random number\n- *             generator shall completely reinitialize its state. If the random\n- *\t       number generator requires a seed for setting up a new state,\n- *\t       the seed must be provided by the consumer while invoking this\n- *\t       function. The required size of the seed is defined with\n- *\t       @seedsize .\n- * @seedsize: The seed size required for a random number generator\n- *\t      initialization defined with this variable. Some random number\n- *\t      generators like the SP800-90A DRBG does not require a seed as the\n- *\t      seeding is implemented internally without the need of support by\n- *\t      the consumer. In this case, the seed size is set to zero.\n- */\n-struct old_rng_alg {\n-\tint (*rng_make_random)(struct crypto_rng *tfm, u8 *rdata,\n-\t\t\t       unsigned int dlen);\n-\tint (*rng_reset)(struct crypto_rng *tfm, u8 *seed, unsigned int slen);\n-\n-\tunsigned int seedsize;\n-};\n-\n \n #define cra_ablkcipher\tcra_u.ablkcipher\n #define cra_aead\tcra_u.aead\n #define cra_blkcipher\tcra_u.blkcipher\n #define cra_cipher\tcra_u.cipher\n #define cra_compress\tcra_u.compress\n-#define cra_rng\t\tcra_u.rng\n \n /**\n  * struct crypto_alg - definition of a cryptograpic cipher algorithm\n@@ -559,7 +530,6 @@ struct crypto_alg {\n \t\tstruct blkcipher_alg blkcipher;\n \t\tstruct cipher_alg cipher;\n \t\tstruct compress_alg compress;\n-\t\tstruct old_rng_alg rng;\n \t} cra_u;\n \n \tint (*cra_init)(struct crypto_tfm *tfm);""}","static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,
","static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,
		    u8 *dst, unsigned int dlen)
{
	return crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);
}
",C,,"		    u8 *dst, unsigned int dlen)
{
	return crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);
}
",,"@@ -4,6 +4,7 @@
  * RNG operations.
  *
  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>
+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the Free
@@ -36,39 +37,6 @@ static inline struct crypto_rng *__crypto_rng_cast(struct crypto_tfm *tfm)
 	return container_of(tfm, struct crypto_rng, base);
 }
 
-static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)
-{
-	return &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;
-}
-
-static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,
-		    u8 *dst, unsigned int dlen)
-{
-	return crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);
-}
-
-static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,
-			unsigned int slen)
-{
-	u8 *buf = NULL;
-	u8 *src = (u8 *)seed;
-	int err;
-
-	if (slen) {
-		buf = kmalloc(slen, GFP_KERNEL);
-		if (!buf)
-			return -ENOMEM;
-
-		memcpy(buf, seed, slen);
-		src = buf;
-	}
-
-	err = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);
-
-	kzfree(buf);
-	return err;
-}
-
 int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
 {
 	u8 *buf = NULL;
@@ -83,7 +51,7 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
 		seed = buf;
 	}
 
-	err = tfm->seed(tfm, seed, slen);
+	err = crypto_rng_alg(tfm)->seed(tfm, seed, slen);
 
 	kfree(buf);
 	return err;
@@ -92,30 +60,14 @@ EXPORT_SYMBOL_GPL(crypto_rng_reset);
 
 static int crypto_rng_init_tfm(struct crypto_tfm *tfm)
 {
-	struct crypto_rng *rng = __crypto_rng_cast(tfm);
-	struct rng_alg *alg = crypto_rng_alg(rng);
-	struct old_rng_alg *oalg = crypto_old_rng_alg(rng);
-
-	if (oalg->rng_make_random) {
-		rng->generate = generate;
-		rng->seed = rngapi_reset;
-		rng->seedsize = oalg->seedsize;
-		return 0;
-	}
-
-	rng->generate = alg->generate;
-	rng->seed = alg->seed;
-	rng->seedsize = alg->seedsize;
-
 	return 0;
 }
 
 static unsigned int seedsize(struct crypto_alg *alg)
 {
 	struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
 
-	return alg->cra_rng.rng_make_random ?
-	       alg->cra_rng.seedsize : ralg->seedsize;
+	return ralg->seedsize;
 }
 
 #ifdef CONFIG_NET
@@ -150,7 +102,7 @@ static void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)
 	seq_printf(m, ""seedsize     : %u\n"", seedsize(alg));
 }
 
-const struct crypto_type crypto_rng_type = {
+static const struct crypto_type crypto_rng_type = {
 	.extsize = crypto_alg_extsize,
 	.init_tfm = crypto_rng_init_tfm,
 #ifdef CONFIG_PROC_FS
@@ -162,7 +114,6 @@ const struct crypto_type crypto_rng_type = {
 	.type = CRYPTO_ALG_TYPE_RNG,
 	.tfmsize = offsetof(struct crypto_rng, base),
 };
-EXPORT_SYMBOL_GPL(crypto_rng_type);
 
 struct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)
 {",linux,94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,e33cf2c5aab7d0012e7890089e89ae2466c2449c,1,"static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,
//flaw_line_below:
		    u8 *dst, unsigned int dlen)
//flaw_line_below:
{
//flaw_line_below:
	return crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);
//flaw_line_below:
}
"
3170,180906,,Local,Not required,Complete,CVE-2017-15116,https://www.cvedetails.com/cve/CVE-2017-15116/,CWE-476,Low,,,,2017-11-30,4.9,The rngapi_reset function in crypto/rng.c in the Linux kernel before 4.2 allows attackers to cause a denial of service (NULL pointer dereference).,2018-04-11,DoS ,0,https://github.com/torvalds/linux/commit/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,"crypto: rng - Remove old low-level rng interface

Now that all rng implementations have switched over to the new
interface, we can remove the old low-level interface.

Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",16,crypto/rng.c,"{""sha"": ""055e276427b120ed48c2acb6314c2e9d922c36ea"", ""filename"": ""crypto/rng.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 53, ""changes"": 57, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/crypto/rng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/crypto/rng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rng.c?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -4,6 +4,7 @@\n  * RNG operations.\n  *\n  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n  *\n  * This program is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU General Public License as published by the Free\n@@ -36,39 +37,6 @@ static inline struct crypto_rng *__crypto_rng_cast(struct crypto_tfm *tfm)\n \treturn container_of(tfm, struct crypto_rng, base);\n }\n \n-static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)\n-{\n-\treturn &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;\n-}\n-\n-static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,\n-\t\t    u8 *dst, unsigned int dlen)\n-{\n-\treturn crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);\n-}\n-\n-static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,\n-\t\t\tunsigned int slen)\n-{\n-\tu8 *buf = NULL;\n-\tu8 *src = (u8 *)seed;\n-\tint err;\n-\n-\tif (slen) {\n-\t\tbuf = kmalloc(slen, GFP_KERNEL);\n-\t\tif (!buf)\n-\t\t\treturn -ENOMEM;\n-\n-\t\tmemcpy(buf, seed, slen);\n-\t\tsrc = buf;\n-\t}\n-\n-\terr = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);\n-\n-\tkzfree(buf);\n-\treturn err;\n-}\n-\n int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n {\n \tu8 *buf = NULL;\n@@ -83,7 +51,7 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n \t\tseed = buf;\n \t}\n \n-\terr = tfm->seed(tfm, seed, slen);\n+\terr = crypto_rng_alg(tfm)->seed(tfm, seed, slen);\n \n \tkfree(buf);\n \treturn err;\n@@ -92,30 +60,14 @@ EXPORT_SYMBOL_GPL(crypto_rng_reset);\n \n static int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n {\n-\tstruct crypto_rng *rng = __crypto_rng_cast(tfm);\n-\tstruct rng_alg *alg = crypto_rng_alg(rng);\n-\tstruct old_rng_alg *oalg = crypto_old_rng_alg(rng);\n-\n-\tif (oalg->rng_make_random) {\n-\t\trng->generate = generate;\n-\t\trng->seed = rngapi_reset;\n-\t\trng->seedsize = oalg->seedsize;\n-\t\treturn 0;\n-\t}\n-\n-\trng->generate = alg->generate;\n-\trng->seed = alg->seed;\n-\trng->seedsize = alg->seedsize;\n-\n \treturn 0;\n }\n \n static unsigned int seedsize(struct crypto_alg *alg)\n {\n \tstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);\n \n-\treturn alg->cra_rng.rng_make_random ?\n-\t       alg->cra_rng.seedsize : ralg->seedsize;\n+\treturn ralg->seedsize;\n }\n \n #ifdef CONFIG_NET\n@@ -150,7 +102,7 @@ static void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)\n \tseq_printf(m, \""seedsize     : %u\\n\"", seedsize(alg));\n }\n \n-const struct crypto_type crypto_rng_type = {\n+static const struct crypto_type crypto_rng_type = {\n \t.extsize = crypto_alg_extsize,\n \t.init_tfm = crypto_rng_init_tfm,\n #ifdef CONFIG_PROC_FS\n@@ -162,7 +114,6 @@ const struct crypto_type crypto_rng_type = {\n \t.type = CRYPTO_ALG_TYPE_RNG,\n \t.tfmsize = offsetof(struct crypto_rng, base),\n };\n-EXPORT_SYMBOL_GPL(crypto_rng_type);\n \n struct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)\n {""}<_**next**_>{""sha"": ""263f1a5eebc7070122ab7bae111c8a0d4bee8265"", ""filename"": ""include/crypto/internal/rng.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/internal/rng.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/internal/rng.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/crypto/internal/rng.h?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -2,6 +2,7 @@\n  * RNG: Random Number Generator  algorithms under the crypto API\n  *\n  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n  *\n  * This program is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU General Public License as published by the Free\n@@ -16,8 +17,6 @@\n #include <crypto/algapi.h>\n #include <crypto/rng.h>\n \n-extern const struct crypto_type crypto_rng_type;\n-\n int crypto_register_rng(struct rng_alg *alg);\n void crypto_unregister_rng(struct rng_alg *alg);\n int crypto_register_rngs(struct rng_alg *algs, int count);""}<_**next**_>{""sha"": ""c5d4684429f5851f5728f767c4e50cdc970ec01e"", ""filename"": ""include/crypto/rng.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 7, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/rng.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/rng.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/crypto/rng.h?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -2,6 +2,7 @@\n  * RNG: Random Number Generator  algorithms under the crypto API\n  *\n  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n  *\n  * This program is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU General Public License as published by the Free\n@@ -56,11 +57,6 @@ struct rng_alg {\n };\n \n struct crypto_rng {\n-\tint (*generate)(struct crypto_rng *tfm,\n-\t\t\tconst u8 *src, unsigned int slen,\n-\t\t\tu8 *dst, unsigned int dlen);\n-\tint (*seed)(struct crypto_rng *tfm, const u8 *seed, unsigned int slen);\n-\tunsigned int seedsize;\n \tstruct crypto_tfm base;\n };\n \n@@ -144,7 +140,7 @@ static inline int crypto_rng_generate(struct crypto_rng *tfm,\n \t\t\t\t      const u8 *src, unsigned int slen,\n \t\t\t\t      u8 *dst, unsigned int dlen)\n {\n-\treturn tfm->generate(tfm, src, slen, dst, dlen);\n+\treturn crypto_rng_alg(tfm)->generate(tfm, src, slen, dst, dlen);\n }\n \n /**\n@@ -198,7 +194,7 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed,\n  */\n static inline int crypto_rng_seedsize(struct crypto_rng *tfm)\n {\n-\treturn tfm->seedsize;\n+\treturn crypto_rng_alg(tfm)->seedsize;\n }\n \n #endif""}<_**next**_>{""sha"": ""ee14140f8893b9b6f8a04c3fa17834e84d05c876"", ""filename"": ""include/linux/crypto.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 30, ""changes"": 30, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/linux/crypto.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/linux/crypto.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/crypto.h?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -138,7 +138,6 @@ struct crypto_async_request;\n struct crypto_aead;\n struct crypto_blkcipher;\n struct crypto_hash;\n-struct crypto_rng;\n struct crypto_tfm;\n struct crypto_type;\n struct aead_givcrypt_request;\n@@ -426,40 +425,12 @@ struct compress_alg {\n \t\t\t      unsigned int slen, u8 *dst, unsigned int *dlen);\n };\n \n-/**\n- * struct old_rng_alg - random number generator definition\n- * @rng_make_random: The function defined by this variable obtains a random\n- *\t\t     number. The random number generator transform must generate\n- *\t\t     the random number out of the context provided with this\n- *\t\t     call.\n- * @rng_reset: Reset of the random number generator by clearing the entire state.\n- *\t       With the invocation of this function call, the random number\n- *             generator shall completely reinitialize its state. If the random\n- *\t       number generator requires a seed for setting up a new state,\n- *\t       the seed must be provided by the consumer while invoking this\n- *\t       function. The required size of the seed is defined with\n- *\t       @seedsize .\n- * @seedsize: The seed size required for a random number generator\n- *\t      initialization defined with this variable. Some random number\n- *\t      generators like the SP800-90A DRBG does not require a seed as the\n- *\t      seeding is implemented internally without the need of support by\n- *\t      the consumer. In this case, the seed size is set to zero.\n- */\n-struct old_rng_alg {\n-\tint (*rng_make_random)(struct crypto_rng *tfm, u8 *rdata,\n-\t\t\t       unsigned int dlen);\n-\tint (*rng_reset)(struct crypto_rng *tfm, u8 *seed, unsigned int slen);\n-\n-\tunsigned int seedsize;\n-};\n-\n \n #define cra_ablkcipher\tcra_u.ablkcipher\n #define cra_aead\tcra_u.aead\n #define cra_blkcipher\tcra_u.blkcipher\n #define cra_cipher\tcra_u.cipher\n #define cra_compress\tcra_u.compress\n-#define cra_rng\t\tcra_u.rng\n \n /**\n  * struct crypto_alg - definition of a cryptograpic cipher algorithm\n@@ -559,7 +530,6 @@ struct crypto_alg {\n \t\tstruct blkcipher_alg blkcipher;\n \t\tstruct cipher_alg cipher;\n \t\tstruct compress_alg compress;\n-\t\tstruct old_rng_alg rng;\n \t} cra_u;\n \n \tint (*cra_init)(struct crypto_tfm *tfm);""}","static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,
","static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,
			unsigned int slen)
{
	u8 *buf = NULL;
	u8 *src = (u8 *)seed;
	int err;
	if (slen) {
		buf = kmalloc(slen, GFP_KERNEL);
		if (!buf)
			return -ENOMEM;
		memcpy(buf, seed, slen);
		src = buf;
	}
	err = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);
	kzfree(buf);
	return err;
}
",C,,"			unsigned int slen)
{
	u8 *buf = NULL;
	u8 *src = (u8 *)seed;
	int err;
	if (slen) {
		buf = kmalloc(slen, GFP_KERNEL);
		if (!buf)
			return -ENOMEM;
		memcpy(buf, seed, slen);
		src = buf;
	}
	err = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);
	kzfree(buf);
	return err;
}
",,"@@ -4,6 +4,7 @@
  * RNG operations.
  *
  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>
+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the Free
@@ -36,39 +37,6 @@ static inline struct crypto_rng *__crypto_rng_cast(struct crypto_tfm *tfm)
 	return container_of(tfm, struct crypto_rng, base);
 }
 
-static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)
-{
-	return &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;
-}
-
-static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,
-		    u8 *dst, unsigned int dlen)
-{
-	return crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);
-}
-
-static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,
-			unsigned int slen)
-{
-	u8 *buf = NULL;
-	u8 *src = (u8 *)seed;
-	int err;
-
-	if (slen) {
-		buf = kmalloc(slen, GFP_KERNEL);
-		if (!buf)
-			return -ENOMEM;
-
-		memcpy(buf, seed, slen);
-		src = buf;
-	}
-
-	err = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);
-
-	kzfree(buf);
-	return err;
-}
-
 int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
 {
 	u8 *buf = NULL;
@@ -83,7 +51,7 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
 		seed = buf;
 	}
 
-	err = tfm->seed(tfm, seed, slen);
+	err = crypto_rng_alg(tfm)->seed(tfm, seed, slen);
 
 	kfree(buf);
 	return err;
@@ -92,30 +60,14 @@ EXPORT_SYMBOL_GPL(crypto_rng_reset);
 
 static int crypto_rng_init_tfm(struct crypto_tfm *tfm)
 {
-	struct crypto_rng *rng = __crypto_rng_cast(tfm);
-	struct rng_alg *alg = crypto_rng_alg(rng);
-	struct old_rng_alg *oalg = crypto_old_rng_alg(rng);
-
-	if (oalg->rng_make_random) {
-		rng->generate = generate;
-		rng->seed = rngapi_reset;
-		rng->seedsize = oalg->seedsize;
-		return 0;
-	}
-
-	rng->generate = alg->generate;
-	rng->seed = alg->seed;
-	rng->seedsize = alg->seedsize;
-
 	return 0;
 }
 
 static unsigned int seedsize(struct crypto_alg *alg)
 {
 	struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
 
-	return alg->cra_rng.rng_make_random ?
-	       alg->cra_rng.seedsize : ralg->seedsize;
+	return ralg->seedsize;
 }
 
 #ifdef CONFIG_NET
@@ -150,7 +102,7 @@ static void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)
 	seq_printf(m, ""seedsize     : %u\n"", seedsize(alg));
 }
 
-const struct crypto_type crypto_rng_type = {
+static const struct crypto_type crypto_rng_type = {
 	.extsize = crypto_alg_extsize,
 	.init_tfm = crypto_rng_init_tfm,
 #ifdef CONFIG_PROC_FS
@@ -162,7 +114,6 @@ const struct crypto_type crypto_rng_type = {
 	.type = CRYPTO_ALG_TYPE_RNG,
 	.tfmsize = offsetof(struct crypto_rng, base),
 };
-EXPORT_SYMBOL_GPL(crypto_rng_type);
 
 struct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)
 {",linux,94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,e33cf2c5aab7d0012e7890089e89ae2466c2449c,1,"static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,
//flaw_line_below:
			unsigned int slen)
//flaw_line_below:
{
//flaw_line_below:
	u8 *buf = NULL;
//flaw_line_below:
	u8 *src = (u8 *)seed;
//flaw_line_below:
	int err;
//flaw_line_below:

//flaw_line_below:
	if (slen) {
//flaw_line_below:
		buf = kmalloc(slen, GFP_KERNEL);
//flaw_line_below:
		if (!buf)
//flaw_line_below:
			return -ENOMEM;
//flaw_line_below:

//flaw_line_below:
		memcpy(buf, seed, slen);
//flaw_line_below:
		src = buf;
//flaw_line_below:
	}
//flaw_line_below:

//flaw_line_below:
	err = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);
//flaw_line_below:

//flaw_line_below:
	kzfree(buf);
//flaw_line_below:
	return err;
//flaw_line_below:
}
"
3171,180907,,Local,Not required,Complete,CVE-2017-15116,https://www.cvedetails.com/cve/CVE-2017-15116/,CWE-476,Low,,,,2017-11-30,4.9,The rngapi_reset function in crypto/rng.c in the Linux kernel before 4.2 allows attackers to cause a denial of service (NULL pointer dereference).,2018-04-11,DoS ,1,https://github.com/torvalds/linux/commit/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,"crypto: rng - Remove old low-level rng interface

Now that all rng implementations have switched over to the new
interface, we can remove the old low-level interface.

Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",2,crypto/rng.c,"{""sha"": ""055e276427b120ed48c2acb6314c2e9d922c36ea"", ""filename"": ""crypto/rng.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 53, ""changes"": 57, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/crypto/rng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/crypto/rng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rng.c?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -4,6 +4,7 @@\n  * RNG operations.\n  *\n  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n  *\n  * This program is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU General Public License as published by the Free\n@@ -36,39 +37,6 @@ static inline struct crypto_rng *__crypto_rng_cast(struct crypto_tfm *tfm)\n \treturn container_of(tfm, struct crypto_rng, base);\n }\n \n-static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)\n-{\n-\treturn &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;\n-}\n-\n-static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,\n-\t\t    u8 *dst, unsigned int dlen)\n-{\n-\treturn crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);\n-}\n-\n-static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,\n-\t\t\tunsigned int slen)\n-{\n-\tu8 *buf = NULL;\n-\tu8 *src = (u8 *)seed;\n-\tint err;\n-\n-\tif (slen) {\n-\t\tbuf = kmalloc(slen, GFP_KERNEL);\n-\t\tif (!buf)\n-\t\t\treturn -ENOMEM;\n-\n-\t\tmemcpy(buf, seed, slen);\n-\t\tsrc = buf;\n-\t}\n-\n-\terr = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);\n-\n-\tkzfree(buf);\n-\treturn err;\n-}\n-\n int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n {\n \tu8 *buf = NULL;\n@@ -83,7 +51,7 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n \t\tseed = buf;\n \t}\n \n-\terr = tfm->seed(tfm, seed, slen);\n+\terr = crypto_rng_alg(tfm)->seed(tfm, seed, slen);\n \n \tkfree(buf);\n \treturn err;\n@@ -92,30 +60,14 @@ EXPORT_SYMBOL_GPL(crypto_rng_reset);\n \n static int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n {\n-\tstruct crypto_rng *rng = __crypto_rng_cast(tfm);\n-\tstruct rng_alg *alg = crypto_rng_alg(rng);\n-\tstruct old_rng_alg *oalg = crypto_old_rng_alg(rng);\n-\n-\tif (oalg->rng_make_random) {\n-\t\trng->generate = generate;\n-\t\trng->seed = rngapi_reset;\n-\t\trng->seedsize = oalg->seedsize;\n-\t\treturn 0;\n-\t}\n-\n-\trng->generate = alg->generate;\n-\trng->seed = alg->seed;\n-\trng->seedsize = alg->seedsize;\n-\n \treturn 0;\n }\n \n static unsigned int seedsize(struct crypto_alg *alg)\n {\n \tstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);\n \n-\treturn alg->cra_rng.rng_make_random ?\n-\t       alg->cra_rng.seedsize : ralg->seedsize;\n+\treturn ralg->seedsize;\n }\n \n #ifdef CONFIG_NET\n@@ -150,7 +102,7 @@ static void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)\n \tseq_printf(m, \""seedsize     : %u\\n\"", seedsize(alg));\n }\n \n-const struct crypto_type crypto_rng_type = {\n+static const struct crypto_type crypto_rng_type = {\n \t.extsize = crypto_alg_extsize,\n \t.init_tfm = crypto_rng_init_tfm,\n #ifdef CONFIG_PROC_FS\n@@ -162,7 +114,6 @@ const struct crypto_type crypto_rng_type = {\n \t.type = CRYPTO_ALG_TYPE_RNG,\n \t.tfmsize = offsetof(struct crypto_rng, base),\n };\n-EXPORT_SYMBOL_GPL(crypto_rng_type);\n \n struct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)\n {""}<_**next**_>{""sha"": ""263f1a5eebc7070122ab7bae111c8a0d4bee8265"", ""filename"": ""include/crypto/internal/rng.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/internal/rng.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/internal/rng.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/crypto/internal/rng.h?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -2,6 +2,7 @@\n  * RNG: Random Number Generator  algorithms under the crypto API\n  *\n  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n  *\n  * This program is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU General Public License as published by the Free\n@@ -16,8 +17,6 @@\n #include <crypto/algapi.h>\n #include <crypto/rng.h>\n \n-extern const struct crypto_type crypto_rng_type;\n-\n int crypto_register_rng(struct rng_alg *alg);\n void crypto_unregister_rng(struct rng_alg *alg);\n int crypto_register_rngs(struct rng_alg *algs, int count);""}<_**next**_>{""sha"": ""c5d4684429f5851f5728f767c4e50cdc970ec01e"", ""filename"": ""include/crypto/rng.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 7, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/rng.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/crypto/rng.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/crypto/rng.h?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -2,6 +2,7 @@\n  * RNG: Random Number Generator  algorithms under the crypto API\n  *\n  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n  *\n  * This program is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU General Public License as published by the Free\n@@ -56,11 +57,6 @@ struct rng_alg {\n };\n \n struct crypto_rng {\n-\tint (*generate)(struct crypto_rng *tfm,\n-\t\t\tconst u8 *src, unsigned int slen,\n-\t\t\tu8 *dst, unsigned int dlen);\n-\tint (*seed)(struct crypto_rng *tfm, const u8 *seed, unsigned int slen);\n-\tunsigned int seedsize;\n \tstruct crypto_tfm base;\n };\n \n@@ -144,7 +140,7 @@ static inline int crypto_rng_generate(struct crypto_rng *tfm,\n \t\t\t\t      const u8 *src, unsigned int slen,\n \t\t\t\t      u8 *dst, unsigned int dlen)\n {\n-\treturn tfm->generate(tfm, src, slen, dst, dlen);\n+\treturn crypto_rng_alg(tfm)->generate(tfm, src, slen, dst, dlen);\n }\n \n /**\n@@ -198,7 +194,7 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed,\n  */\n static inline int crypto_rng_seedsize(struct crypto_rng *tfm)\n {\n-\treturn tfm->seedsize;\n+\treturn crypto_rng_alg(tfm)->seedsize;\n }\n \n #endif""}<_**next**_>{""sha"": ""ee14140f8893b9b6f8a04c3fa17834e84d05c876"", ""filename"": ""include/linux/crypto.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 30, ""changes"": 30, ""blob_url"": ""https://github.com/torvalds/linux/blob/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/linux/crypto.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/include/linux/crypto.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/crypto.h?ref=94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6"", ""patch"": ""@@ -138,7 +138,6 @@ struct crypto_async_request;\n struct crypto_aead;\n struct crypto_blkcipher;\n struct crypto_hash;\n-struct crypto_rng;\n struct crypto_tfm;\n struct crypto_type;\n struct aead_givcrypt_request;\n@@ -426,40 +425,12 @@ struct compress_alg {\n \t\t\t      unsigned int slen, u8 *dst, unsigned int *dlen);\n };\n \n-/**\n- * struct old_rng_alg - random number generator definition\n- * @rng_make_random: The function defined by this variable obtains a random\n- *\t\t     number. The random number generator transform must generate\n- *\t\t     the random number out of the context provided with this\n- *\t\t     call.\n- * @rng_reset: Reset of the random number generator by clearing the entire state.\n- *\t       With the invocation of this function call, the random number\n- *             generator shall completely reinitialize its state. If the random\n- *\t       number generator requires a seed for setting up a new state,\n- *\t       the seed must be provided by the consumer while invoking this\n- *\t       function. The required size of the seed is defined with\n- *\t       @seedsize .\n- * @seedsize: The seed size required for a random number generator\n- *\t      initialization defined with this variable. Some random number\n- *\t      generators like the SP800-90A DRBG does not require a seed as the\n- *\t      seeding is implemented internally without the need of support by\n- *\t      the consumer. In this case, the seed size is set to zero.\n- */\n-struct old_rng_alg {\n-\tint (*rng_make_random)(struct crypto_rng *tfm, u8 *rdata,\n-\t\t\t       unsigned int dlen);\n-\tint (*rng_reset)(struct crypto_rng *tfm, u8 *seed, unsigned int slen);\n-\n-\tunsigned int seedsize;\n-};\n-\n \n #define cra_ablkcipher\tcra_u.ablkcipher\n #define cra_aead\tcra_u.aead\n #define cra_blkcipher\tcra_u.blkcipher\n #define cra_cipher\tcra_u.cipher\n #define cra_compress\tcra_u.compress\n-#define cra_rng\t\tcra_u.rng\n \n /**\n  * struct crypto_alg - definition of a cryptograpic cipher algorithm\n@@ -559,7 +530,6 @@ struct crypto_alg {\n \t\tstruct blkcipher_alg blkcipher;\n \t\tstruct cipher_alg cipher;\n \t\tstruct compress_alg compress;\n-\t\tstruct old_rng_alg rng;\n \t} cra_u;\n \n \tint (*cra_init)(struct crypto_tfm *tfm);""}"," static unsigned int seedsize(struct crypto_alg *alg)
 {
 	struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
 
	return ralg->seedsize;
 }
"," static unsigned int seedsize(struct crypto_alg *alg)
 {
 	struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
 
	return alg->cra_rng.rng_make_random ?
	       alg->cra_rng.seedsize : ralg->seedsize;
 }
",C,"	return ralg->seedsize;
","	return alg->cra_rng.rng_make_random ?
	       alg->cra_rng.seedsize : ralg->seedsize;
",,"@@ -4,6 +4,7 @@
  * RNG operations.
  *
  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>
+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the Free
@@ -36,39 +37,6 @@ static inline struct crypto_rng *__crypto_rng_cast(struct crypto_tfm *tfm)
 	return container_of(tfm, struct crypto_rng, base);
 }
 
-static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)
-{
-	return &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;
-}
-
-static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,
-		    u8 *dst, unsigned int dlen)
-{
-	return crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);
-}
-
-static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,
-			unsigned int slen)
-{
-	u8 *buf = NULL;
-	u8 *src = (u8 *)seed;
-	int err;
-
-	if (slen) {
-		buf = kmalloc(slen, GFP_KERNEL);
-		if (!buf)
-			return -ENOMEM;
-
-		memcpy(buf, seed, slen);
-		src = buf;
-	}
-
-	err = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);
-
-	kzfree(buf);
-	return err;
-}
-
 int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
 {
 	u8 *buf = NULL;
@@ -83,7 +51,7 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
 		seed = buf;
 	}
 
-	err = tfm->seed(tfm, seed, slen);
+	err = crypto_rng_alg(tfm)->seed(tfm, seed, slen);
 
 	kfree(buf);
 	return err;
@@ -92,30 +60,14 @@ EXPORT_SYMBOL_GPL(crypto_rng_reset);
 
 static int crypto_rng_init_tfm(struct crypto_tfm *tfm)
 {
-	struct crypto_rng *rng = __crypto_rng_cast(tfm);
-	struct rng_alg *alg = crypto_rng_alg(rng);
-	struct old_rng_alg *oalg = crypto_old_rng_alg(rng);
-
-	if (oalg->rng_make_random) {
-		rng->generate = generate;
-		rng->seed = rngapi_reset;
-		rng->seedsize = oalg->seedsize;
-		return 0;
-	}
-
-	rng->generate = alg->generate;
-	rng->seed = alg->seed;
-	rng->seedsize = alg->seedsize;
-
 	return 0;
 }
 
 static unsigned int seedsize(struct crypto_alg *alg)
 {
 	struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
 
-	return alg->cra_rng.rng_make_random ?
-	       alg->cra_rng.seedsize : ralg->seedsize;
+	return ralg->seedsize;
 }
 
 #ifdef CONFIG_NET
@@ -150,7 +102,7 @@ static void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)
 	seq_printf(m, ""seedsize     : %u\n"", seedsize(alg));
 }
 
-const struct crypto_type crypto_rng_type = {
+static const struct crypto_type crypto_rng_type = {
 	.extsize = crypto_alg_extsize,
 	.init_tfm = crypto_rng_init_tfm,
 #ifdef CONFIG_PROC_FS
@@ -162,7 +114,6 @@ const struct crypto_type crypto_rng_type = {
 	.type = CRYPTO_ALG_TYPE_RNG,
 	.tfmsize = offsetof(struct crypto_rng, base),
 };
-EXPORT_SYMBOL_GPL(crypto_rng_type);
 
 struct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)
 {",linux,94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,e33cf2c5aab7d0012e7890089e89ae2466c2449c,1," static unsigned int seedsize(struct crypto_alg *alg)
 {
 	struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
 
//flaw_line_below:
	return alg->cra_rng.rng_make_random ?
//flaw_line_below:
	       alg->cra_rng.seedsize : ralg->seedsize;
//fix_flaw_line_below:
//	return ralg->seedsize;
 }
"
3173,180909,,Local,Not required,Complete,CVE-2017-15102,https://www.cvedetails.com/cve/CVE-2017-15102/,CWE-476,Medium,Complete,Complete,,2017-11-15,6.9,The tower_probe function in drivers/usb/misc/legousbtower.c in the Linux kernel before 4.8.1 allows local users (who are physically proximate for inserting a crafted USB device) to gain privileges by leveraging a write-what-where condition that occurs after a race condition and a NULL pointer dereference.,2019-05-08,+Priv ,17,https://github.com/torvalds/linux/commit/2fae9e5a7babada041e2e161699ade2447a01989,2fae9e5a7babada041e2e161699ade2447a01989,"usb: misc: legousbtower: Fix NULL pointer deference

This patch fixes a NULL pointer dereference caused by a race codition in
the probe function of the legousbtower driver. It re-structures the
probe function to only register the interface after successfully reading
the board's firmware ID.

The probe function does not deregister the usb interface after an error
receiving the devices firmware ID. The device file registered
(/dev/usb/legousbtower%d) may be read/written globally before the probe
function returns. When tower_delete is called in the probe function
(after an r/w has been initiated), core dev structures are deleted while
the file operation functions are still running. If the 0 address is
mappable on the machine, this vulnerability can be used to create a
Local Priviege Escalation exploit via a write-what-where condition by
remapping dev->interrupt_out_buffer in tower_write. A forged USB device
and local program execution would be required for LPE. The USB device
would have to delay the control message in tower_probe and accept
the control urb in tower_open whilst guest code initiated a write to the
device file as tower_delete is called from the error in tower_probe.

This bug has existed since 2003. Patch tested by emulated device.

Reported-by: James Patrick-Evans <james@jmp-e.com>
Tested-by: James Patrick-Evans <james@jmp-e.com>
Signed-off-by: James Patrick-Evans <james@jmp-e.com>
Cc: stable <stable@vger.kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",14,drivers/usb/misc/legousbtower.c,"{""sha"": ""c8fbe7b739a0bb110cdfbca9e82bc7238adf5e08"", ""filename"": ""drivers/usb/misc/legousbtower.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 18, ""changes"": 35, ""blob_url"": ""https://github.com/torvalds/linux/blob/2fae9e5a7babada041e2e161699ade2447a01989/drivers/usb/misc/legousbtower.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/2fae9e5a7babada041e2e161699ade2447a01989/drivers/usb/misc/legousbtower.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/misc/legousbtower.c?ref=2fae9e5a7babada041e2e161699ade2447a01989"", ""patch"": ""@@ -886,24 +886,6 @@ static int tower_probe (struct usb_interface *interface, const struct usb_device\n \tdev->interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev->interrupt_in_endpoint->bInterval;\n \tdev->interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev->interrupt_out_endpoint->bInterval;\n \n-\t/* we can register the device now, as it is ready */\n-\tusb_set_intfdata (interface, dev);\n-\n-\tretval = usb_register_dev (interface, &tower_class);\n-\n-\tif (retval) {\n-\t\t/* something prevented us from registering this driver */\n-\t\tdev_err(idev, \""Not able to get a minor for this device.\\n\"");\n-\t\tusb_set_intfdata (interface, NULL);\n-\t\tgoto error;\n-\t}\n-\tdev->minor = interface->minor;\n-\n-\t/* let the user know what node this device is now attached to */\n-\tdev_info(&interface->dev, \""LEGO USB Tower #%d now attached to major \""\n-\t\t \""%d minor %d\\n\"", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),\n-\t\t USB_MAJOR, dev->minor);\n-\n \t/* get the firmware version and log it */\n \tresult = usb_control_msg (udev,\n \t\t\t\t  usb_rcvctrlpipe(udev, 0),\n@@ -924,6 +906,23 @@ static int tower_probe (struct usb_interface *interface, const struct usb_device\n \t\t get_version_reply.minor,\n \t\t le16_to_cpu(get_version_reply.build_no));\n \n+\t/* we can register the device now, as it is ready */\n+\tusb_set_intfdata (interface, dev);\n+\n+\tretval = usb_register_dev (interface, &tower_class);\n+\n+\tif (retval) {\n+\t\t/* something prevented us from registering this driver */\n+\t\tdev_err(idev, \""Not able to get a minor for this device.\\n\"");\n+\t\tusb_set_intfdata (interface, NULL);\n+\t\tgoto error;\n+\t}\n+\tdev->minor = interface->minor;\n+\n+\t/* let the user know what node this device is now attached to */\n+\tdev_info(&interface->dev, \""LEGO USB Tower #%d now attached to major \""\n+\t\t \""%d minor %d\\n\"", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),\n+\t\t USB_MAJOR, dev->minor);\n \n exit:\n \treturn retval;""}","static int tower_probe (struct usb_interface *interface, const struct usb_device_id *id)
{
	struct device *idev = &interface->dev;
	struct usb_device *udev = interface_to_usbdev(interface);
	struct lego_usb_tower *dev = NULL;
	struct usb_host_interface *iface_desc;
	struct usb_endpoint_descriptor* endpoint;
	struct tower_get_version_reply get_version_reply;
	int i;
	int retval = -ENOMEM;
	int result;

	/* allocate memory for our device state and initialize it */

	dev = kmalloc (sizeof(struct lego_usb_tower), GFP_KERNEL);

	if (!dev)
		goto exit;

	mutex_init(&dev->lock);

	dev->udev = udev;
	dev->open_count = 0;

	dev->read_buffer = NULL;
	dev->read_buffer_length = 0;
	dev->read_packet_length = 0;
	spin_lock_init (&dev->read_buffer_lock);
	dev->packet_timeout_jiffies = msecs_to_jiffies(packet_timeout);
	dev->read_last_arrival = jiffies;

	init_waitqueue_head (&dev->read_wait);
	init_waitqueue_head (&dev->write_wait);

	dev->interrupt_in_buffer = NULL;
	dev->interrupt_in_endpoint = NULL;
	dev->interrupt_in_urb = NULL;
	dev->interrupt_in_running = 0;
	dev->interrupt_in_done = 0;

	dev->interrupt_out_buffer = NULL;
	dev->interrupt_out_endpoint = NULL;
	dev->interrupt_out_urb = NULL;
	dev->interrupt_out_busy = 0;

	iface_desc = interface->cur_altsetting;

	/* set up the endpoint information */
	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
		endpoint = &iface_desc->endpoint[i].desc;

		if (usb_endpoint_xfer_int(endpoint)) {
			if (usb_endpoint_dir_in(endpoint))
				dev->interrupt_in_endpoint = endpoint;
			else
				dev->interrupt_out_endpoint = endpoint;
		}
	}
	if(dev->interrupt_in_endpoint == NULL) {
		dev_err(idev, ""interrupt in endpoint not found\n"");
		goto error;
	}
	if (dev->interrupt_out_endpoint == NULL) {
		dev_err(idev, ""interrupt out endpoint not found\n"");
		goto error;
	}

	dev->read_buffer = kmalloc (read_buffer_size, GFP_KERNEL);
	if (!dev->read_buffer)
		goto error;
	dev->interrupt_in_buffer = kmalloc (usb_endpoint_maxp(dev->interrupt_in_endpoint), GFP_KERNEL);
	if (!dev->interrupt_in_buffer)
		goto error;
	dev->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);
	if (!dev->interrupt_in_urb)
		goto error;
	dev->interrupt_out_buffer = kmalloc (write_buffer_size, GFP_KERNEL);
	if (!dev->interrupt_out_buffer)
		goto error;
	dev->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);
	if (!dev->interrupt_out_urb)
		goto error;
 	dev->interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev->interrupt_in_endpoint->bInterval;
 	dev->interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev->interrupt_out_endpoint->bInterval;
 
 	/* get the firmware version and log it */
 	result = usb_control_msg (udev,
 				  usb_rcvctrlpipe(udev, 0),
				  LEGO_USB_TOWER_REQUEST_GET_VERSION,
				  USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,
				  0,
				  0,
				  &get_version_reply,
				  sizeof(get_version_reply),
				  1000);
	if (result < 0) {
		dev_err(idev, ""LEGO USB Tower get version control request failed\n"");
		retval = result;
		goto error;
	}
	dev_info(&interface->dev, ""LEGO USB Tower firmware version is %d.%d ""
		 ""build %d\n"", get_version_reply.major,
 		 get_version_reply.minor,
 		 le16_to_cpu(get_version_reply.build_no));
 
	/* we can register the device now, as it is ready */
	usb_set_intfdata (interface, dev);

	retval = usb_register_dev (interface, &tower_class);

	if (retval) {
		/* something prevented us from registering this driver */
		dev_err(idev, ""Not able to get a minor for this device.\n"");
		usb_set_intfdata (interface, NULL);
		goto error;
	}
	dev->minor = interface->minor;

	/* let the user know what node this device is now attached to */
	dev_info(&interface->dev, ""LEGO USB Tower #%d now attached to major ""
		 ""%d minor %d\n"", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),
		 USB_MAJOR, dev->minor);
 
 exit:
 	return retval;

error:
	tower_delete(dev);
	return retval;
}
","static int tower_probe (struct usb_interface *interface, const struct usb_device_id *id)
{
	struct device *idev = &interface->dev;
	struct usb_device *udev = interface_to_usbdev(interface);
	struct lego_usb_tower *dev = NULL;
	struct usb_host_interface *iface_desc;
	struct usb_endpoint_descriptor* endpoint;
	struct tower_get_version_reply get_version_reply;
	int i;
	int retval = -ENOMEM;
	int result;

	/* allocate memory for our device state and initialize it */

	dev = kmalloc (sizeof(struct lego_usb_tower), GFP_KERNEL);

	if (!dev)
		goto exit;

	mutex_init(&dev->lock);

	dev->udev = udev;
	dev->open_count = 0;

	dev->read_buffer = NULL;
	dev->read_buffer_length = 0;
	dev->read_packet_length = 0;
	spin_lock_init (&dev->read_buffer_lock);
	dev->packet_timeout_jiffies = msecs_to_jiffies(packet_timeout);
	dev->read_last_arrival = jiffies;

	init_waitqueue_head (&dev->read_wait);
	init_waitqueue_head (&dev->write_wait);

	dev->interrupt_in_buffer = NULL;
	dev->interrupt_in_endpoint = NULL;
	dev->interrupt_in_urb = NULL;
	dev->interrupt_in_running = 0;
	dev->interrupt_in_done = 0;

	dev->interrupt_out_buffer = NULL;
	dev->interrupt_out_endpoint = NULL;
	dev->interrupt_out_urb = NULL;
	dev->interrupt_out_busy = 0;

	iface_desc = interface->cur_altsetting;

	/* set up the endpoint information */
	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
		endpoint = &iface_desc->endpoint[i].desc;

		if (usb_endpoint_xfer_int(endpoint)) {
			if (usb_endpoint_dir_in(endpoint))
				dev->interrupt_in_endpoint = endpoint;
			else
				dev->interrupt_out_endpoint = endpoint;
		}
	}
	if(dev->interrupt_in_endpoint == NULL) {
		dev_err(idev, ""interrupt in endpoint not found\n"");
		goto error;
	}
	if (dev->interrupt_out_endpoint == NULL) {
		dev_err(idev, ""interrupt out endpoint not found\n"");
		goto error;
	}

	dev->read_buffer = kmalloc (read_buffer_size, GFP_KERNEL);
	if (!dev->read_buffer)
		goto error;
	dev->interrupt_in_buffer = kmalloc (usb_endpoint_maxp(dev->interrupt_in_endpoint), GFP_KERNEL);
	if (!dev->interrupt_in_buffer)
		goto error;
	dev->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);
	if (!dev->interrupt_in_urb)
		goto error;
	dev->interrupt_out_buffer = kmalloc (write_buffer_size, GFP_KERNEL);
	if (!dev->interrupt_out_buffer)
		goto error;
	dev->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);
	if (!dev->interrupt_out_urb)
		goto error;
 	dev->interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev->interrupt_in_endpoint->bInterval;
 	dev->interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev->interrupt_out_endpoint->bInterval;
 
	/* we can register the device now, as it is ready */
	usb_set_intfdata (interface, dev);
	retval = usb_register_dev (interface, &tower_class);
	if (retval) {
		/* something prevented us from registering this driver */
		dev_err(idev, ""Not able to get a minor for this device.\n"");
		usb_set_intfdata (interface, NULL);
		goto error;
	}
	dev->minor = interface->minor;
	/* let the user know what node this device is now attached to */
	dev_info(&interface->dev, ""LEGO USB Tower #%d now attached to major ""
		 ""%d minor %d\n"", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),
		 USB_MAJOR, dev->minor);
 	/* get the firmware version and log it */
 	result = usb_control_msg (udev,
 				  usb_rcvctrlpipe(udev, 0),
				  LEGO_USB_TOWER_REQUEST_GET_VERSION,
				  USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,
				  0,
				  0,
				  &get_version_reply,
				  sizeof(get_version_reply),
				  1000);
	if (result < 0) {
		dev_err(idev, ""LEGO USB Tower get version control request failed\n"");
		retval = result;
		goto error;
	}
	dev_info(&interface->dev, ""LEGO USB Tower firmware version is %d.%d ""
		 ""build %d\n"", get_version_reply.major,
 		 get_version_reply.minor,
 		 le16_to_cpu(get_version_reply.build_no));
 
 
 exit:
 	return retval;

error:
	tower_delete(dev);
	return retval;
}
",C,"	/* we can register the device now, as it is ready */
	usb_set_intfdata (interface, dev);

	retval = usb_register_dev (interface, &tower_class);

	if (retval) {
		/* something prevented us from registering this driver */
		dev_err(idev, ""Not able to get a minor for this device.\n"");
		usb_set_intfdata (interface, NULL);
		goto error;
	}
	dev->minor = interface->minor;

	/* let the user know what node this device is now attached to */
	dev_info(&interface->dev, ""LEGO USB Tower #%d now attached to major ""
		 ""%d minor %d\n"", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),
		 USB_MAJOR, dev->minor);
","	/* we can register the device now, as it is ready */
	usb_set_intfdata (interface, dev);
	retval = usb_register_dev (interface, &tower_class);
	if (retval) {
		/* something prevented us from registering this driver */
		dev_err(idev, ""Not able to get a minor for this device.\n"");
		usb_set_intfdata (interface, NULL);
		goto error;
	}
	dev->minor = interface->minor;
	/* let the user know what node this device is now attached to */
	dev_info(&interface->dev, ""LEGO USB Tower #%d now attached to major ""
		 ""%d minor %d\n"", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),
		 USB_MAJOR, dev->minor);
",,"@@ -886,24 +886,6 @@ static int tower_probe (struct usb_interface *interface, const struct usb_device
 	dev->interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev->interrupt_in_endpoint->bInterval;
 	dev->interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev->interrupt_out_endpoint->bInterval;
 
-	/* we can register the device now, as it is ready */
-	usb_set_intfdata (interface, dev);
-
-	retval = usb_register_dev (interface, &tower_class);
-
-	if (retval) {
-		/* something prevented us from registering this driver */
-		dev_err(idev, ""Not able to get a minor for this device.\n"");
-		usb_set_intfdata (interface, NULL);
-		goto error;
-	}
-	dev->minor = interface->minor;
-
-	/* let the user know what node this device is now attached to */
-	dev_info(&interface->dev, ""LEGO USB Tower #%d now attached to major ""
-		 ""%d minor %d\n"", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),
-		 USB_MAJOR, dev->minor);
-
 	/* get the firmware version and log it */
 	result = usb_control_msg (udev,
 				  usb_rcvctrlpipe(udev, 0),
@@ -924,6 +906,23 @@ static int tower_probe (struct usb_interface *interface, const struct usb_device
 		 get_version_reply.minor,
 		 le16_to_cpu(get_version_reply.build_no));
 
+	/* we can register the device now, as it is ready */
+	usb_set_intfdata (interface, dev);
+
+	retval = usb_register_dev (interface, &tower_class);
+
+	if (retval) {
+		/* something prevented us from registering this driver */
+		dev_err(idev, ""Not able to get a minor for this device.\n"");
+		usb_set_intfdata (interface, NULL);
+		goto error;
+	}
+	dev->minor = interface->minor;
+
+	/* let the user know what node this device is now attached to */
+	dev_info(&interface->dev, ""LEGO USB Tower #%d now attached to major ""
+		 ""%d minor %d\n"", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),
+		 USB_MAJOR, dev->minor);
 
 exit:
 	return retval;",linux,2fae9e5a7babada041e2e161699ade2447a01989,2ad9d544f2497a7bf239c34bd2b86fd19683dbb5,1,"static int tower_probe (struct usb_interface *interface, const struct usb_device_id *id)
{
	struct device *idev = &interface->dev;
	struct usb_device *udev = interface_to_usbdev(interface);
	struct lego_usb_tower *dev = NULL;
	struct usb_host_interface *iface_desc;
	struct usb_endpoint_descriptor* endpoint;
	struct tower_get_version_reply get_version_reply;
	int i;
	int retval = -ENOMEM;
	int result;

	/* allocate memory for our device state and initialize it */

	dev = kmalloc (sizeof(struct lego_usb_tower), GFP_KERNEL);

	if (!dev)
		goto exit;

	mutex_init(&dev->lock);

	dev->udev = udev;
	dev->open_count = 0;

	dev->read_buffer = NULL;
	dev->read_buffer_length = 0;
	dev->read_packet_length = 0;
	spin_lock_init (&dev->read_buffer_lock);
	dev->packet_timeout_jiffies = msecs_to_jiffies(packet_timeout);
	dev->read_last_arrival = jiffies;

	init_waitqueue_head (&dev->read_wait);
	init_waitqueue_head (&dev->write_wait);

	dev->interrupt_in_buffer = NULL;
	dev->interrupt_in_endpoint = NULL;
	dev->interrupt_in_urb = NULL;
	dev->interrupt_in_running = 0;
	dev->interrupt_in_done = 0;

	dev->interrupt_out_buffer = NULL;
	dev->interrupt_out_endpoint = NULL;
	dev->interrupt_out_urb = NULL;
	dev->interrupt_out_busy = 0;

	iface_desc = interface->cur_altsetting;

	/* set up the endpoint information */
	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
		endpoint = &iface_desc->endpoint[i].desc;

		if (usb_endpoint_xfer_int(endpoint)) {
			if (usb_endpoint_dir_in(endpoint))
				dev->interrupt_in_endpoint = endpoint;
			else
				dev->interrupt_out_endpoint = endpoint;
		}
	}
	if(dev->interrupt_in_endpoint == NULL) {
		dev_err(idev, ""interrupt in endpoint not found\n"");
		goto error;
	}
	if (dev->interrupt_out_endpoint == NULL) {
		dev_err(idev, ""interrupt out endpoint not found\n"");
		goto error;
	}

	dev->read_buffer = kmalloc (read_buffer_size, GFP_KERNEL);
	if (!dev->read_buffer)
		goto error;
	dev->interrupt_in_buffer = kmalloc (usb_endpoint_maxp(dev->interrupt_in_endpoint), GFP_KERNEL);
	if (!dev->interrupt_in_buffer)
		goto error;
	dev->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);
	if (!dev->interrupt_in_urb)
		goto error;
	dev->interrupt_out_buffer = kmalloc (write_buffer_size, GFP_KERNEL);
	if (!dev->interrupt_out_buffer)
		goto error;
	dev->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);
	if (!dev->interrupt_out_urb)
		goto error;
 	dev->interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev->interrupt_in_endpoint->bInterval;
 	dev->interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev->interrupt_out_endpoint->bInterval;
 
//flaw_line_below:
	/* we can register the device now, as it is ready */
//flaw_line_below:
	usb_set_intfdata (interface, dev);
//flaw_line_below:

//flaw_line_below:
	retval = usb_register_dev (interface, &tower_class);
//flaw_line_below:

//flaw_line_below:
	if (retval) {
//flaw_line_below:
		/* something prevented us from registering this driver */
//flaw_line_below:
		dev_err(idev, ""Not able to get a minor for this device.\n"");
//flaw_line_below:
		usb_set_intfdata (interface, NULL);
//flaw_line_below:
		goto error;
//flaw_line_below:
	}
//flaw_line_below:
	dev->minor = interface->minor;
//flaw_line_below:

//flaw_line_below:
	/* let the user know what node this device is now attached to */
//flaw_line_below:
	dev_info(&interface->dev, ""LEGO USB Tower #%d now attached to major ""
//flaw_line_below:
		 ""%d minor %d\n"", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),
//flaw_line_below:
		 USB_MAJOR, dev->minor);
//flaw_line_below:

 	/* get the firmware version and log it */
 	result = usb_control_msg (udev,
 				  usb_rcvctrlpipe(udev, 0),
				  LEGO_USB_TOWER_REQUEST_GET_VERSION,
				  USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,
				  0,
				  0,
				  &get_version_reply,
				  sizeof(get_version_reply),
				  1000);
	if (result < 0) {
		dev_err(idev, ""LEGO USB Tower get version control request failed\n"");
		retval = result;
		goto error;
	}
	dev_info(&interface->dev, ""LEGO USB Tower firmware version is %d.%d ""
		 ""build %d\n"", get_version_reply.major,
 		 get_version_reply.minor,
 		 le16_to_cpu(get_version_reply.build_no));
 
//fix_flaw_line_below:
//	/* we can register the device now, as it is ready */
//fix_flaw_line_below:
//	usb_set_intfdata (interface, dev);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	retval = usb_register_dev (interface, &tower_class);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (retval) {
//fix_flaw_line_below:
//		/* something prevented us from registering this driver */
//fix_flaw_line_below:
//		dev_err(idev, ""Not able to get a minor for this device.\n"");
//fix_flaw_line_below:
//		usb_set_intfdata (interface, NULL);
//fix_flaw_line_below:
//		goto error;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//	dev->minor = interface->minor;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	/* let the user know what node this device is now attached to */
//fix_flaw_line_below:
//	dev_info(&interface->dev, ""LEGO USB Tower #%d now attached to major ""
//fix_flaw_line_below:
//		 ""%d minor %d\n"", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),
//fix_flaw_line_below:
//		 USB_MAJOR, dev->minor);
 
 exit:
 	return retval;

error:
	tower_delete(dev);
	return retval;
}
"
3242,180978,,Local,Not required,Complete,CVE-2017-13686,https://www.cvedetails.com/cve/CVE-2017-13686/,CWE-476,Low,Complete,Complete,,2017-08-24,7.2,"net/ipv4/route.c in the Linux kernel 4.13-rc1 through 4.13-rc6 is too late to check for a NULL fi field when RTM_F_FIB_MATCH is set, which allows local users to cause a denial of service (NULL pointer dereference) or possibly have unspecified other impact via crafted system calls. NOTE: this does not affect any stable release.",2017-08-29,DoS ,9,https://github.com/torvalds/linux/commit/bc3aae2bbac46dd894c89db5d5e98f7f0ef9e205,bc3aae2bbac46dd894c89db5d5e98f7f0ef9e205,"net: check and errout if res->fi is NULL when RTM_F_FIB_MATCH is set

Syzkaller hit 'general protection fault in fib_dump_info' bug on
commit 4.13-rc5..

Guilty file: net/ipv4/fib_semantics.c

kasan: GPF could be caused by NULL-ptr deref or user memory access
general protection fault: 0000 [#1] SMP KASAN
Modules linked in:
CPU: 0 PID: 2808 Comm: syz-executor0 Not tainted 4.13.0-rc5 #1
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
Ubuntu-1.8.2-1ubuntu1 04/01/2014
task: ffff880078562700 task.stack: ffff880078110000
RIP: 0010:fib_dump_info+0x388/0x1170 net/ipv4/fib_semantics.c:1314
RSP: 0018:ffff880078117010 EFLAGS: 00010206
RAX: dffffc0000000000 RBX: 00000000000000fe RCX: 0000000000000002
RDX: 0000000000000006 RSI: ffff880078117084 RDI: 0000000000000030
RBP: ffff880078117268 R08: 000000000000000c R09: ffff8800780d80c8
R10: 0000000058d629b4 R11: 0000000067fce681 R12: 0000000000000000
R13: ffff8800784bd540 R14: ffff8800780d80b5 R15: ffff8800780d80a4
FS:  00000000022fa940(0000) GS:ffff88007fc00000(0000)
knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00000000004387d0 CR3: 0000000079135000 CR4: 00000000000006f0
Call Trace:
  inet_rtm_getroute+0xc89/0x1f50 net/ipv4/route.c:2766
  rtnetlink_rcv_msg+0x288/0x680 net/core/rtnetlink.c:4217
  netlink_rcv_skb+0x340/0x470 net/netlink/af_netlink.c:2397
  rtnetlink_rcv+0x28/0x30 net/core/rtnetlink.c:4223
  netlink_unicast_kernel net/netlink/af_netlink.c:1265 [inline]
  netlink_unicast+0x4c4/0x6e0 net/netlink/af_netlink.c:1291
  netlink_sendmsg+0x8c4/0xca0 net/netlink/af_netlink.c:1854
  sock_sendmsg_nosec net/socket.c:633 [inline]
  sock_sendmsg+0xca/0x110 net/socket.c:643
  ___sys_sendmsg+0x779/0x8d0 net/socket.c:2035
  __sys_sendmsg+0xd1/0x170 net/socket.c:2069
  SYSC_sendmsg net/socket.c:2080 [inline]
  SyS_sendmsg+0x2d/0x50 net/socket.c:2076
  entry_SYSCALL_64_fastpath+0x1a/0xa5
  RIP: 0033:0x4512e9
  RSP: 002b:00007ffc75584cc8 EFLAGS: 00000216 ORIG_RAX:
  000000000000002e
  RAX: ffffffffffffffda RBX: 0000000000000002 RCX: 00000000004512e9
  RDX: 0000000000000000 RSI: 0000000020f2cfc8 RDI: 0000000000000003
  RBP: 000000000000000e R08: 0000000000000000 R09: 0000000000000000
  R10: 0000000000000000 R11: 0000000000000216 R12: fffffffffffffffe
  R13: 0000000000718000 R14: 0000000020c44ff0 R15: 0000000000000000
  Code: 00 0f b6 8d ec fd ff ff 48 8b 85 f0 fd ff ff 88 48 17 48 8b 45
  28 48 8d 78 30 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03
  <0f>
  b6 04 02 84 c0 74 08 3c 03 0f 8e cb 0c 00 00 48 8b 45 28 44
  RIP: fib_dump_info+0x388/0x1170 net/ipv4/fib_semantics.c:1314 RSP:
  ffff880078117010
---[ end trace 254a7af28348f88b ]---

This patch adds a res->fi NULL check.

example run:
$ip route get 0.0.0.0 iif virt1-0
broadcast 0.0.0.0 dev lo
    cache <local,brd> iif virt1-0

$ip route get 0.0.0.0 iif virt1-0 fibmatch
RTNETLINK answers: No route to host

Reported-by: idaifish <idaifish@gmail.com>
Reported-by: Dmitry Vyukov <dvyukov@google.com>
Fixes: b61798130f1b (""net: ipv4: RTM_GETROUTE: return matched fib result when requested"")
Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",2,net/ipv4/route.c,"{""sha"": ""2331de20ca505d7f25fe9d93d5320e9e39af6c39"", ""filename"": ""net/ipv4/route.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 2, ""changes"": 11, ""blob_url"": ""https://github.com/torvalds/linux/blob/bc3aae2bbac46dd894c89db5d5e98f7f0ef9e205/net/ipv4/route.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bc3aae2bbac46dd894c89db5d5e98f7f0ef9e205/net/ipv4/route.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/route.c?ref=bc3aae2bbac46dd894c89db5d5e98f7f0ef9e205"", ""patch"": ""@@ -2763,14 +2763,21 @@ static int inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n \tif (rtm->rtm_flags & RTM_F_LOOKUP_TABLE)\n \t\ttable_id = rt->rt_table_id;\n \n-\tif (rtm->rtm_flags & RTM_F_FIB_MATCH)\n+\tif (rtm->rtm_flags & RTM_F_FIB_MATCH) {\n+\t\tif (!res.fi) {\n+\t\t\terr = fib_props[res.type].error;\n+\t\t\tif (!err)\n+\t\t\t\terr = -EHOSTUNREACH;\n+\t\t\tgoto errout_free;\n+\t\t}\n \t\terr = fib_dump_info(skb, NETLINK_CB(in_skb).portid,\n \t\t\t\t    nlh->nlmsg_seq, RTM_NEWROUTE, table_id,\n \t\t\t\t    rt->rt_type, res.prefix, res.prefixlen,\n \t\t\t\t    fl4.flowi4_tos, res.fi, 0);\n-\telse\n+\t} else {\n \t\terr = rt_fill_info(net, dst, src, table_id, &fl4, skb,\n \t\t\t\t   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq);\n+\t}\n \tif (err < 0)\n \t\tgoto errout_free;\n ""}","static int inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh,
			     struct netlink_ext_ack *extack)
{
	struct net *net = sock_net(in_skb->sk);
	struct rtmsg *rtm;
	struct nlattr *tb[RTA_MAX+1];
	struct fib_result res = {};
	struct rtable *rt = NULL;
	struct flowi4 fl4;
	__be32 dst = 0;
	__be32 src = 0;
	u32 iif;
	int err;
	int mark;
	struct sk_buff *skb;
	u32 table_id = RT_TABLE_MAIN;
	kuid_t uid;

	err = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_ipv4_policy,
			  extack);
	if (err < 0)
		goto errout;

	rtm = nlmsg_data(nlh);

	skb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);
	if (!skb) {
		err = -ENOBUFS;
		goto errout;
	}

	/* Reserve room for dummy headers, this skb can pass
	   through good chunk of routing engine.
	 */
	skb_reset_mac_header(skb);
	skb_reset_network_header(skb);

	src = tb[RTA_SRC] ? nla_get_in_addr(tb[RTA_SRC]) : 0;
	dst = tb[RTA_DST] ? nla_get_in_addr(tb[RTA_DST]) : 0;
	iif = tb[RTA_IIF] ? nla_get_u32(tb[RTA_IIF]) : 0;
	mark = tb[RTA_MARK] ? nla_get_u32(tb[RTA_MARK]) : 0;
	if (tb[RTA_UID])
		uid = make_kuid(current_user_ns(), nla_get_u32(tb[RTA_UID]));
	else
		uid = (iif ? INVALID_UID : current_uid());

	/* Bugfix: need to give ip_route_input enough of an IP header to
	 * not gag.
	 */
	ip_hdr(skb)->protocol = IPPROTO_UDP;
	ip_hdr(skb)->saddr = src;
	ip_hdr(skb)->daddr = dst;

	skb_reserve(skb, MAX_HEADER + sizeof(struct iphdr));

	memset(&fl4, 0, sizeof(fl4));
	fl4.daddr = dst;
	fl4.saddr = src;
	fl4.flowi4_tos = rtm->rtm_tos;
	fl4.flowi4_oif = tb[RTA_OIF] ? nla_get_u32(tb[RTA_OIF]) : 0;
	fl4.flowi4_mark = mark;
	fl4.flowi4_uid = uid;

	rcu_read_lock();

	if (iif) {
		struct net_device *dev;

		dev = dev_get_by_index_rcu(net, iif);
		if (!dev) {
			err = -ENODEV;
			goto errout_free;
		}

		skb->protocol	= htons(ETH_P_IP);
		skb->dev	= dev;
		skb->mark	= mark;
		err = ip_route_input_rcu(skb, dst, src, rtm->rtm_tos,
					 dev, &res);

		rt = skb_rtable(skb);
		if (err == 0 && rt->dst.error)
			err = -rt->dst.error;
	} else {
		rt = ip_route_output_key_hash_rcu(net, &fl4, &res, skb);
		err = 0;
		if (IS_ERR(rt))
			err = PTR_ERR(rt);
		else
			skb_dst_set(skb, &rt->dst);
	}

	if (err)
		goto errout_free;

	if (rtm->rtm_flags & RTM_F_NOTIFY)
		rt->rt_flags |= RTCF_NOTIFY;

 	if (rtm->rtm_flags & RTM_F_LOOKUP_TABLE)
 		table_id = rt->rt_table_id;
 
	if (rtm->rtm_flags & RTM_F_FIB_MATCH) {
		if (!res.fi) {
			err = fib_props[res.type].error;
			if (!err)
				err = -EHOSTUNREACH;
			goto errout_free;
		}
 		err = fib_dump_info(skb, NETLINK_CB(in_skb).portid,
 				    nlh->nlmsg_seq, RTM_NEWROUTE, table_id,
 				    rt->rt_type, res.prefix, res.prefixlen,
 				    fl4.flowi4_tos, res.fi, 0);
	} else {
 		err = rt_fill_info(net, dst, src, table_id, &fl4, skb,
 				   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq);
	}
 	if (err < 0)
 		goto errout_free;
 
	rcu_read_unlock();

	err = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);
errout:
	return err;

errout_free:
	rcu_read_unlock();
	kfree_skb(skb);
	goto errout;
}
","static int inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh,
			     struct netlink_ext_ack *extack)
{
	struct net *net = sock_net(in_skb->sk);
	struct rtmsg *rtm;
	struct nlattr *tb[RTA_MAX+1];
	struct fib_result res = {};
	struct rtable *rt = NULL;
	struct flowi4 fl4;
	__be32 dst = 0;
	__be32 src = 0;
	u32 iif;
	int err;
	int mark;
	struct sk_buff *skb;
	u32 table_id = RT_TABLE_MAIN;
	kuid_t uid;

	err = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_ipv4_policy,
			  extack);
	if (err < 0)
		goto errout;

	rtm = nlmsg_data(nlh);

	skb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);
	if (!skb) {
		err = -ENOBUFS;
		goto errout;
	}

	/* Reserve room for dummy headers, this skb can pass
	   through good chunk of routing engine.
	 */
	skb_reset_mac_header(skb);
	skb_reset_network_header(skb);

	src = tb[RTA_SRC] ? nla_get_in_addr(tb[RTA_SRC]) : 0;
	dst = tb[RTA_DST] ? nla_get_in_addr(tb[RTA_DST]) : 0;
	iif = tb[RTA_IIF] ? nla_get_u32(tb[RTA_IIF]) : 0;
	mark = tb[RTA_MARK] ? nla_get_u32(tb[RTA_MARK]) : 0;
	if (tb[RTA_UID])
		uid = make_kuid(current_user_ns(), nla_get_u32(tb[RTA_UID]));
	else
		uid = (iif ? INVALID_UID : current_uid());

	/* Bugfix: need to give ip_route_input enough of an IP header to
	 * not gag.
	 */
	ip_hdr(skb)->protocol = IPPROTO_UDP;
	ip_hdr(skb)->saddr = src;
	ip_hdr(skb)->daddr = dst;

	skb_reserve(skb, MAX_HEADER + sizeof(struct iphdr));

	memset(&fl4, 0, sizeof(fl4));
	fl4.daddr = dst;
	fl4.saddr = src;
	fl4.flowi4_tos = rtm->rtm_tos;
	fl4.flowi4_oif = tb[RTA_OIF] ? nla_get_u32(tb[RTA_OIF]) : 0;
	fl4.flowi4_mark = mark;
	fl4.flowi4_uid = uid;

	rcu_read_lock();

	if (iif) {
		struct net_device *dev;

		dev = dev_get_by_index_rcu(net, iif);
		if (!dev) {
			err = -ENODEV;
			goto errout_free;
		}

		skb->protocol	= htons(ETH_P_IP);
		skb->dev	= dev;
		skb->mark	= mark;
		err = ip_route_input_rcu(skb, dst, src, rtm->rtm_tos,
					 dev, &res);

		rt = skb_rtable(skb);
		if (err == 0 && rt->dst.error)
			err = -rt->dst.error;
	} else {
		rt = ip_route_output_key_hash_rcu(net, &fl4, &res, skb);
		err = 0;
		if (IS_ERR(rt))
			err = PTR_ERR(rt);
		else
			skb_dst_set(skb, &rt->dst);
	}

	if (err)
		goto errout_free;

	if (rtm->rtm_flags & RTM_F_NOTIFY)
		rt->rt_flags |= RTCF_NOTIFY;

 	if (rtm->rtm_flags & RTM_F_LOOKUP_TABLE)
 		table_id = rt->rt_table_id;
 
	if (rtm->rtm_flags & RTM_F_FIB_MATCH)
 		err = fib_dump_info(skb, NETLINK_CB(in_skb).portid,
 				    nlh->nlmsg_seq, RTM_NEWROUTE, table_id,
 				    rt->rt_type, res.prefix, res.prefixlen,
 				    fl4.flowi4_tos, res.fi, 0);
	else
 		err = rt_fill_info(net, dst, src, table_id, &fl4, skb,
 				   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq);
 	if (err < 0)
 		goto errout_free;
 
	rcu_read_unlock();

	err = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);
errout:
	return err;

errout_free:
	rcu_read_unlock();
	kfree_skb(skb);
	goto errout;
}
",C,"	if (rtm->rtm_flags & RTM_F_FIB_MATCH) {
		if (!res.fi) {
			err = fib_props[res.type].error;
			if (!err)
				err = -EHOSTUNREACH;
			goto errout_free;
		}
	} else {
	}
","	if (rtm->rtm_flags & RTM_F_FIB_MATCH)
	else
",,"@@ -2763,14 +2763,21 @@ static int inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh,
 	if (rtm->rtm_flags & RTM_F_LOOKUP_TABLE)
 		table_id = rt->rt_table_id;
 
-	if (rtm->rtm_flags & RTM_F_FIB_MATCH)
+	if (rtm->rtm_flags & RTM_F_FIB_MATCH) {
+		if (!res.fi) {
+			err = fib_props[res.type].error;
+			if (!err)
+				err = -EHOSTUNREACH;
+			goto errout_free;
+		}
 		err = fib_dump_info(skb, NETLINK_CB(in_skb).portid,
 				    nlh->nlmsg_seq, RTM_NEWROUTE, table_id,
 				    rt->rt_type, res.prefix, res.prefixlen,
 				    fl4.flowi4_tos, res.fi, 0);
-	else
+	} else {
 		err = rt_fill_info(net, dst, src, table_id, &fl4, skb,
 				   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq);
+	}
 	if (err < 0)
 		goto errout_free;
 ",linux,bc3aae2bbac46dd894c89db5d5e98f7f0ef9e205,383143f31d7d3525a1dbff733d52fff917f82f15,1,"static int inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh,
			     struct netlink_ext_ack *extack)
{
	struct net *net = sock_net(in_skb->sk);
	struct rtmsg *rtm;
	struct nlattr *tb[RTA_MAX+1];
	struct fib_result res = {};
	struct rtable *rt = NULL;
	struct flowi4 fl4;
	__be32 dst = 0;
	__be32 src = 0;
	u32 iif;
	int err;
	int mark;
	struct sk_buff *skb;
	u32 table_id = RT_TABLE_MAIN;
	kuid_t uid;

	err = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_ipv4_policy,
			  extack);
	if (err < 0)
		goto errout;

	rtm = nlmsg_data(nlh);

	skb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);
	if (!skb) {
		err = -ENOBUFS;
		goto errout;
	}

	/* Reserve room for dummy headers, this skb can pass
	   through good chunk of routing engine.
	 */
	skb_reset_mac_header(skb);
	skb_reset_network_header(skb);

	src = tb[RTA_SRC] ? nla_get_in_addr(tb[RTA_SRC]) : 0;
	dst = tb[RTA_DST] ? nla_get_in_addr(tb[RTA_DST]) : 0;
	iif = tb[RTA_IIF] ? nla_get_u32(tb[RTA_IIF]) : 0;
	mark = tb[RTA_MARK] ? nla_get_u32(tb[RTA_MARK]) : 0;
	if (tb[RTA_UID])
		uid = make_kuid(current_user_ns(), nla_get_u32(tb[RTA_UID]));
	else
		uid = (iif ? INVALID_UID : current_uid());

	/* Bugfix: need to give ip_route_input enough of an IP header to
	 * not gag.
	 */
	ip_hdr(skb)->protocol = IPPROTO_UDP;
	ip_hdr(skb)->saddr = src;
	ip_hdr(skb)->daddr = dst;

	skb_reserve(skb, MAX_HEADER + sizeof(struct iphdr));

	memset(&fl4, 0, sizeof(fl4));
	fl4.daddr = dst;
	fl4.saddr = src;
	fl4.flowi4_tos = rtm->rtm_tos;
	fl4.flowi4_oif = tb[RTA_OIF] ? nla_get_u32(tb[RTA_OIF]) : 0;
	fl4.flowi4_mark = mark;
	fl4.flowi4_uid = uid;

	rcu_read_lock();

	if (iif) {
		struct net_device *dev;

		dev = dev_get_by_index_rcu(net, iif);
		if (!dev) {
			err = -ENODEV;
			goto errout_free;
		}

		skb->protocol	= htons(ETH_P_IP);
		skb->dev	= dev;
		skb->mark	= mark;
		err = ip_route_input_rcu(skb, dst, src, rtm->rtm_tos,
					 dev, &res);

		rt = skb_rtable(skb);
		if (err == 0 && rt->dst.error)
			err = -rt->dst.error;
	} else {
		rt = ip_route_output_key_hash_rcu(net, &fl4, &res, skb);
		err = 0;
		if (IS_ERR(rt))
			err = PTR_ERR(rt);
		else
			skb_dst_set(skb, &rt->dst);
	}

	if (err)
		goto errout_free;

	if (rtm->rtm_flags & RTM_F_NOTIFY)
		rt->rt_flags |= RTCF_NOTIFY;

 	if (rtm->rtm_flags & RTM_F_LOOKUP_TABLE)
 		table_id = rt->rt_table_id;
 
//flaw_line_below:
	if (rtm->rtm_flags & RTM_F_FIB_MATCH)
//fix_flaw_line_below:
//	if (rtm->rtm_flags & RTM_F_FIB_MATCH) {
//fix_flaw_line_below:
//		if (!res.fi) {
//fix_flaw_line_below:
//			err = fib_props[res.type].error;
//fix_flaw_line_below:
//			if (!err)
//fix_flaw_line_below:
//				err = -EHOSTUNREACH;
//fix_flaw_line_below:
//			goto errout_free;
//fix_flaw_line_below:
//		}
 		err = fib_dump_info(skb, NETLINK_CB(in_skb).portid,
 				    nlh->nlmsg_seq, RTM_NEWROUTE, table_id,
 				    rt->rt_type, res.prefix, res.prefixlen,
 				    fl4.flowi4_tos, res.fi, 0);
//flaw_line_below:
	else
//fix_flaw_line_below:
//	} else {
 		err = rt_fill_info(net, dst, src, table_id, &fl4, skb,
 				   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq);
//fix_flaw_line_below:
//	}
 	if (err < 0)
 		goto errout_free;
 
	rcu_read_unlock();

	err = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);
errout:
	return err;

errout_free:
	rcu_read_unlock();
	kfree_skb(skb);
	goto errout;
}
"
3422,181158,,Local,Not required,Complete,CVE-2017-12193,https://www.cvedetails.com/cve/CVE-2017-12193/,CWE-476,Low,,,,2017-11-22,4.9,"The assoc_array_insert_into_terminal_node function in lib/assoc_array.c in the Linux kernel before 4.13.11 mishandles node splitting, which allows local users to cause a denial of service (NULL pointer dereference and panic) via a crafted application, as demonstrated by the keyring key type, and key addition and link creation operations.",2018-07-12,DoS ,17,https://github.com/torvalds/linux/commit/ea6789980fdaa610d7eb63602c746bf6ec70cd2b,ea6789980fdaa610d7eb63602c746bf6ec70cd2b,"assoc_array: Fix a buggy node-splitting case

This fixes CVE-2017-12193.

Fix a case in the assoc_array implementation in which a new leaf is
added that needs to go into a node that happens to be full, where the
existing leaves in that node cluster together at that level to the
exclusion of new leaf.

What needs to happen is that the existing leaves get moved out to a new
node, N1, at level + 1 and the existing node needs replacing with one,
N0, that has pointers to the new leaf and to N1.

The code that tries to do this gets this wrong in two ways:

 (1) The pointer that should've pointed from N0 to N1 is set to point
     recursively to N0 instead.

 (2) The backpointer from N0 needs to be set correctly in the case N0 is
     either the root node or reached through a shortcut.

Fix this by removing this path and using the split_node path instead,
which achieves the same end, but in a more general way (thanks to Eric
Biggers for spotting the redundancy).

The problem manifests itself as:

  BUG: unable to handle kernel NULL pointer dereference at 0000000000000010
  IP: assoc_array_apply_edit+0x59/0xe5

Fixes: 3cb989501c26 (""Add a generic associative array implementation."")
Reported-and-tested-by: WU Fan <u3536072@connect.hku.hk>
Signed-off-by: David Howells <dhowells@redhat.com>
Cc: stable@vger.kernel.org [v3.13-rc1+]
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",29,lib/assoc_array.c,"{""sha"": ""4e53be8bc590dc2030a930aec5a2cac8c4fa6a30"", ""filename"": ""lib/assoc_array.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 34, ""changes"": 51, ""blob_url"": ""https://github.com/torvalds/linux/blob/ea6789980fdaa610d7eb63602c746bf6ec70cd2b/lib/assoc_array.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/ea6789980fdaa610d7eb63602c746bf6ec70cd2b/lib/assoc_array.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/lib/assoc_array.c?ref=ea6789980fdaa610d7eb63602c746bf6ec70cd2b"", ""patch"": ""@@ -598,21 +598,31 @@ static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,\n \t\tif ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)\n \t\t\tgoto all_leaves_cluster_together;\n \n-\t\t/* Otherwise we can just insert a new node ahead of the old\n-\t\t * one.\n+\t\t/* Otherwise all the old leaves cluster in the same slot, but\n+\t\t * the new leaf wants to go into a different slot - so we\n+\t\t * create a new node (n0) to hold the new leaf and a pointer to\n+\t\t * a new node (n1) holding all the old leaves.\n+\t\t *\n+\t\t * This can be done by falling through to the node splitting\n+\t\t * path.\n \t\t */\n-\t\tgoto present_leaves_cluster_but_not_new_leaf;\n+\t\tpr_devel(\""present leaves cluster but not new leaf\\n\"");\n \t}\n \n split_node:\n \tpr_devel(\""split node\\n\"");\n \n-\t/* We need to split the current node; we know that the node doesn't\n-\t * simply contain a full set of leaves that cluster together (it\n-\t * contains meta pointers and/or non-clustering leaves).\n+\t/* We need to split the current node.  The node must contain anything\n+\t * from a single leaf (in the one leaf case, this leaf will cluster\n+\t * with the new leaf) and the rest meta-pointers, to all leaves, some\n+\t * of which may cluster.\n+\t *\n+\t * It won't contain the case in which all the current leaves plus the\n+\t * new leaves want to cluster in the same slot.\n \t *\n \t * We need to expel at least two leaves out of a set consisting of the\n-\t * leaves in the node and the new leaf.\n+\t * leaves in the node and the new leaf.  The current meta pointers can\n+\t * just be copied as they shouldn't cluster with any of the leaves.\n \t *\n \t * We need a new node (n0) to replace the current one and a new node to\n \t * take the expelled nodes (n1).\n@@ -717,33 +727,6 @@ static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,\n \tpr_devel(\""<--%s() = ok [split node]\\n\"", __func__);\n \treturn true;\n \n-present_leaves_cluster_but_not_new_leaf:\n-\t/* All the old leaves cluster in the same slot, but the new leaf wants\n-\t * to go into a different slot, so we create a new node to hold the new\n-\t * leaf and a pointer to a new node holding all the old leaves.\n-\t */\n-\tpr_devel(\""present leaves cluster but not new leaf\\n\"");\n-\n-\tnew_n0->back_pointer = node->back_pointer;\n-\tnew_n0->parent_slot = node->parent_slot;\n-\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n-\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n-\tnew_n1->parent_slot = edit->segment_cache[0];\n-\tnew_n1->nr_leaves_on_branch = node->nr_leaves_on_branch;\n-\tedit->adjust_count_on = new_n0;\n-\n-\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n-\t\tnew_n1->slots[i] = node->slots[i];\n-\n-\tnew_n0->slots[edit->segment_cache[0]] = assoc_array_node_to_ptr(new_n0);\n-\tedit->leaf_p = &new_n0->slots[edit->segment_cache[ASSOC_ARRAY_FAN_OUT]];\n-\n-\tedit->set[0].ptr = &assoc_array_ptr_to_node(node->back_pointer)->slots[node->parent_slot];\n-\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n-\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n-\tpr_devel(\""<--%s() = ok [insert node before]\\n\"", __func__);\n-\treturn true;\n-\n all_leaves_cluster_together:\n \t/* All the leaves, new and old, want to cluster together in this node\n \t * in the same slot, so we have to replace this node with a shortcut to""}","static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,
						  const struct assoc_array_ops *ops,
						  const void *index_key,
						  struct assoc_array_walk_result *result)
{
	struct assoc_array_shortcut *shortcut, *new_s0;
	struct assoc_array_node *node, *new_n0, *new_n1, *side;
	struct assoc_array_ptr *ptr;
	unsigned long dissimilarity, base_seg, blank;
	size_t keylen;
	bool have_meta;
	int level, diff;
	int slot, next_slot, free_slot, i, j;

	node	= result->terminal_node.node;
	level	= result->terminal_node.level;
	edit->segment_cache[ASSOC_ARRAY_FAN_OUT] = result->terminal_node.slot;

	pr_devel(""-->%s()\n"", __func__);

	/* We arrived at a node which doesn't have an onward node or shortcut
	 * pointer that we have to follow.  This means that (a) the leaf we
	 * want must go here (either by insertion or replacement) or (b) we
	 * need to split this node and insert in one of the fragments.
	 */
	free_slot = -1;

	/* Firstly, we have to check the leaves in this node to see if there's
	 * a matching one we should replace in place.
	 */
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {
		ptr = node->slots[i];
		if (!ptr) {
			free_slot = i;
			continue;
		}
		if (assoc_array_ptr_is_leaf(ptr) &&
		    ops->compare_object(assoc_array_ptr_to_leaf(ptr),
					index_key)) {
			pr_devel(""replace in slot %d\n"", i);
			edit->leaf_p = &node->slots[i];
			edit->dead_leaf = node->slots[i];
			pr_devel(""<--%s() = ok [replace]\n"", __func__);
			return true;
		}
	}

	/* If there is a free slot in this node then we can just insert the
	 * leaf here.
	 */
	if (free_slot >= 0) {
		pr_devel(""insert in free slot %d\n"", free_slot);
		edit->leaf_p = &node->slots[free_slot];
		edit->adjust_count_on = node;
		pr_devel(""<--%s() = ok [insert]\n"", __func__);
		return true;
	}

	/* The node has no spare slots - so we're either going to have to split
	 * it or insert another node before it.
	 *
	 * Whatever, we're going to need at least two new nodes - so allocate
	 * those now.  We may also need a new shortcut, but we deal with that
	 * when we need it.
	 */
	new_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);
	if (!new_n0)
		return false;
	edit->new_meta[0] = assoc_array_node_to_ptr(new_n0);
	new_n1 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);
	if (!new_n1)
		return false;
	edit->new_meta[1] = assoc_array_node_to_ptr(new_n1);

	/* We need to find out how similar the leaves are. */
	pr_devel(""no spare slots\n"");
	have_meta = false;
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {
		ptr = node->slots[i];
		if (assoc_array_ptr_is_meta(ptr)) {
			edit->segment_cache[i] = 0xff;
			have_meta = true;
			continue;
		}
		base_seg = ops->get_object_key_chunk(
			assoc_array_ptr_to_leaf(ptr), level);
		base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;
		edit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;
	}

	if (have_meta) {
		pr_devel(""have meta\n"");
		goto split_node;
	}

	/* The node contains only leaves */
	dissimilarity = 0;
	base_seg = edit->segment_cache[0];
	for (i = 1; i < ASSOC_ARRAY_FAN_OUT; i++)
		dissimilarity |= edit->segment_cache[i] ^ base_seg;

	pr_devel(""only leaves; dissimilarity=%lx\n"", dissimilarity);

	if ((dissimilarity & ASSOC_ARRAY_FAN_MASK) == 0) {
		/* The old leaves all cluster in the same slot.  We will need
		 * to insert a shortcut if the new node wants to cluster with them.
		 */
 		if ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)
 			goto all_leaves_cluster_together;
 
		/* Otherwise all the old leaves cluster in the same slot, but
		 * the new leaf wants to go into a different slot - so we
		 * create a new node (n0) to hold the new leaf and a pointer to
		 * a new node (n1) holding all the old leaves.
		 *
		 * This can be done by falling through to the node splitting
		 * path.
 		 */
		pr_devel(""present leaves cluster but not new leaf\n"");
 	}
 
 split_node:
 	pr_devel(""split node\n"");
 
	/* We need to split the current node.  The node must contain anything
	 * from a single leaf (in the one leaf case, this leaf will cluster
	 * with the new leaf) and the rest meta-pointers, to all leaves, some
	 * of which may cluster.
	 *
	 * It won't contain the case in which all the current leaves plus the
	 * new leaves want to cluster in the same slot.
 	 *
 	 * We need to expel at least two leaves out of a set consisting of the
	 * leaves in the node and the new leaf.  The current meta pointers can
	 * just be copied as they shouldn't cluster with any of the leaves.
 	 *
 	 * We need a new node (n0) to replace the current one and a new node to
 	 * take the expelled nodes (n1).
	 */
	edit->set[0].to = assoc_array_node_to_ptr(new_n0);
	new_n0->back_pointer = node->back_pointer;
	new_n0->parent_slot = node->parent_slot;
	new_n1->back_pointer = assoc_array_node_to_ptr(new_n0);
	new_n1->parent_slot = -1; /* Need to calculate this */

do_split_node:
	pr_devel(""do_split_node\n"");

	new_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;
	new_n1->nr_leaves_on_branch = 0;

	/* Begin by finding two matching leaves.  There have to be at least two
	 * that match - even if there are meta pointers - because any leaf that
	 * would match a slot with a meta pointer in it must be somewhere
	 * behind that meta pointer and cannot be here.  Further, given N
	 * remaining leaf slots, we now have N+1 leaves to go in them.
	 */
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {
		slot = edit->segment_cache[i];
		if (slot != 0xff)
			for (j = i + 1; j < ASSOC_ARRAY_FAN_OUT + 1; j++)
				if (edit->segment_cache[j] == slot)
					goto found_slot_for_multiple_occupancy;
	}
found_slot_for_multiple_occupancy:
	pr_devel(""same slot: %x %x [%02x]\n"", i, j, slot);
	BUG_ON(i >= ASSOC_ARRAY_FAN_OUT);
	BUG_ON(j >= ASSOC_ARRAY_FAN_OUT + 1);
	BUG_ON(slot >= ASSOC_ARRAY_FAN_OUT);

	new_n1->parent_slot = slot;

	/* Metadata pointers cannot change slot */
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)
		if (assoc_array_ptr_is_meta(node->slots[i]))
			new_n0->slots[i] = node->slots[i];
		else
			new_n0->slots[i] = NULL;
	BUG_ON(new_n0->slots[slot] != NULL);
	new_n0->slots[slot] = assoc_array_node_to_ptr(new_n1);

	/* Filter the leaf pointers between the new nodes */
	free_slot = -1;
	next_slot = 0;
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {
		if (assoc_array_ptr_is_meta(node->slots[i]))
			continue;
		if (edit->segment_cache[i] == slot) {
			new_n1->slots[next_slot++] = node->slots[i];
			new_n1->nr_leaves_on_branch++;
		} else {
			do {
				free_slot++;
			} while (new_n0->slots[free_slot] != NULL);
			new_n0->slots[free_slot] = node->slots[i];
		}
	}

	pr_devel(""filtered: f=%x n=%x\n"", free_slot, next_slot);

	if (edit->segment_cache[ASSOC_ARRAY_FAN_OUT] != slot) {
		do {
			free_slot++;
		} while (new_n0->slots[free_slot] != NULL);
		edit->leaf_p = &new_n0->slots[free_slot];
		edit->adjust_count_on = new_n0;
	} else {
		edit->leaf_p = &new_n1->slots[next_slot++];
		edit->adjust_count_on = new_n1;
	}

	BUG_ON(next_slot <= 1);

	edit->set_backpointers_to = assoc_array_node_to_ptr(new_n0);
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {
		if (edit->segment_cache[i] == 0xff) {
			ptr = node->slots[i];
			BUG_ON(assoc_array_ptr_is_leaf(ptr));
			if (assoc_array_ptr_is_node(ptr)) {
				side = assoc_array_ptr_to_node(ptr);
				edit->set_backpointers[i] = &side->back_pointer;
			} else {
				shortcut = assoc_array_ptr_to_shortcut(ptr);
				edit->set_backpointers[i] = &shortcut->back_pointer;
			}
		}
	}

	ptr = node->back_pointer;
	if (!ptr)
		edit->set[0].ptr = &edit->array->root;
	else if (assoc_array_ptr_is_node(ptr))
		edit->set[0].ptr = &assoc_array_ptr_to_node(ptr)->slots[node->parent_slot];
	else
		edit->set[0].ptr = &assoc_array_ptr_to_shortcut(ptr)->next_node;
	edit->excised_meta[0] = assoc_array_node_to_ptr(node);
 	pr_devel(""<--%s() = ok [split node]\n"", __func__);
 	return true;
 
 all_leaves_cluster_together:
 	/* All the leaves, new and old, want to cluster together in this node
 	 * in the same slot, so we have to replace this node with a shortcut to
	 * skip over the identical parts of the key and then place a pair of
	 * nodes, one inside the other, at the end of the shortcut and
	 * distribute the keys between them.
	 *
	 * Firstly we need to work out where the leaves start diverging as a
	 * bit position into their keys so that we know how big the shortcut
	 * needs to be.
	 *
	 * We only need to make a single pass of N of the N+1 leaves because if
	 * any keys differ between themselves at bit X then at least one of
	 * them must also differ with the base key at bit X or before.
	 */
	pr_devel(""all leaves cluster together\n"");
	diff = INT_MAX;
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {
		int x = ops->diff_objects(assoc_array_ptr_to_leaf(node->slots[i]),
					  index_key);
		if (x < diff) {
			BUG_ON(x < 0);
			diff = x;
		}
	}
	BUG_ON(diff == INT_MAX);
	BUG_ON(diff < level + ASSOC_ARRAY_LEVEL_STEP);

	keylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);
	keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;

	new_s0 = kzalloc(sizeof(struct assoc_array_shortcut) +
			 keylen * sizeof(unsigned long), GFP_KERNEL);
	if (!new_s0)
		return false;
	edit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s0);

	edit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);
	new_s0->back_pointer = node->back_pointer;
	new_s0->parent_slot = node->parent_slot;
	new_s0->next_node = assoc_array_node_to_ptr(new_n0);
	new_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);
	new_n0->parent_slot = 0;
	new_n1->back_pointer = assoc_array_node_to_ptr(new_n0);
	new_n1->parent_slot = -1; /* Need to calculate this */

	new_s0->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK;
	pr_devel(""skip_to_level = %d [diff %d]\n"", level, diff);
	BUG_ON(level <= 0);

	for (i = 0; i < keylen; i++)
		new_s0->index_key[i] =
			ops->get_key_chunk(index_key, i * ASSOC_ARRAY_KEY_CHUNK_SIZE);

	blank = ULONG_MAX << (level & ASSOC_ARRAY_KEY_CHUNK_MASK);
	pr_devel(""blank off [%zu] %d: %lx\n"", keylen - 1, level, blank);
	new_s0->index_key[keylen - 1] &= ~blank;

	/* This now reduces to a node splitting exercise for which we'll need
	 * to regenerate the disparity table.
	 */
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {
		ptr = node->slots[i];
		base_seg = ops->get_object_key_chunk(assoc_array_ptr_to_leaf(ptr),
						     level);
		base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;
		edit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;
	}

	base_seg = ops->get_key_chunk(index_key, level);
	base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;
	edit->segment_cache[ASSOC_ARRAY_FAN_OUT] = base_seg & ASSOC_ARRAY_FAN_MASK;
	goto do_split_node;
}
","static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,
						  const struct assoc_array_ops *ops,
						  const void *index_key,
						  struct assoc_array_walk_result *result)
{
	struct assoc_array_shortcut *shortcut, *new_s0;
	struct assoc_array_node *node, *new_n0, *new_n1, *side;
	struct assoc_array_ptr *ptr;
	unsigned long dissimilarity, base_seg, blank;
	size_t keylen;
	bool have_meta;
	int level, diff;
	int slot, next_slot, free_slot, i, j;

	node	= result->terminal_node.node;
	level	= result->terminal_node.level;
	edit->segment_cache[ASSOC_ARRAY_FAN_OUT] = result->terminal_node.slot;

	pr_devel(""-->%s()\n"", __func__);

	/* We arrived at a node which doesn't have an onward node or shortcut
	 * pointer that we have to follow.  This means that (a) the leaf we
	 * want must go here (either by insertion or replacement) or (b) we
	 * need to split this node and insert in one of the fragments.
	 */
	free_slot = -1;

	/* Firstly, we have to check the leaves in this node to see if there's
	 * a matching one we should replace in place.
	 */
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {
		ptr = node->slots[i];
		if (!ptr) {
			free_slot = i;
			continue;
		}
		if (assoc_array_ptr_is_leaf(ptr) &&
		    ops->compare_object(assoc_array_ptr_to_leaf(ptr),
					index_key)) {
			pr_devel(""replace in slot %d\n"", i);
			edit->leaf_p = &node->slots[i];
			edit->dead_leaf = node->slots[i];
			pr_devel(""<--%s() = ok [replace]\n"", __func__);
			return true;
		}
	}

	/* If there is a free slot in this node then we can just insert the
	 * leaf here.
	 */
	if (free_slot >= 0) {
		pr_devel(""insert in free slot %d\n"", free_slot);
		edit->leaf_p = &node->slots[free_slot];
		edit->adjust_count_on = node;
		pr_devel(""<--%s() = ok [insert]\n"", __func__);
		return true;
	}

	/* The node has no spare slots - so we're either going to have to split
	 * it or insert another node before it.
	 *
	 * Whatever, we're going to need at least two new nodes - so allocate
	 * those now.  We may also need a new shortcut, but we deal with that
	 * when we need it.
	 */
	new_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);
	if (!new_n0)
		return false;
	edit->new_meta[0] = assoc_array_node_to_ptr(new_n0);
	new_n1 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);
	if (!new_n1)
		return false;
	edit->new_meta[1] = assoc_array_node_to_ptr(new_n1);

	/* We need to find out how similar the leaves are. */
	pr_devel(""no spare slots\n"");
	have_meta = false;
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {
		ptr = node->slots[i];
		if (assoc_array_ptr_is_meta(ptr)) {
			edit->segment_cache[i] = 0xff;
			have_meta = true;
			continue;
		}
		base_seg = ops->get_object_key_chunk(
			assoc_array_ptr_to_leaf(ptr), level);
		base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;
		edit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;
	}

	if (have_meta) {
		pr_devel(""have meta\n"");
		goto split_node;
	}

	/* The node contains only leaves */
	dissimilarity = 0;
	base_seg = edit->segment_cache[0];
	for (i = 1; i < ASSOC_ARRAY_FAN_OUT; i++)
		dissimilarity |= edit->segment_cache[i] ^ base_seg;

	pr_devel(""only leaves; dissimilarity=%lx\n"", dissimilarity);

	if ((dissimilarity & ASSOC_ARRAY_FAN_MASK) == 0) {
		/* The old leaves all cluster in the same slot.  We will need
		 * to insert a shortcut if the new node wants to cluster with them.
		 */
 		if ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)
 			goto all_leaves_cluster_together;
 
		/* Otherwise we can just insert a new node ahead of the old
		 * one.
 		 */
		goto present_leaves_cluster_but_not_new_leaf;
 	}
 
 split_node:
 	pr_devel(""split node\n"");
 
	/* We need to split the current node; we know that the node doesn't
	 * simply contain a full set of leaves that cluster together (it
	 * contains meta pointers and/or non-clustering leaves).
 	 *
 	 * We need to expel at least two leaves out of a set consisting of the
	 * leaves in the node and the new leaf.
 	 *
 	 * We need a new node (n0) to replace the current one and a new node to
 	 * take the expelled nodes (n1).
	 */
	edit->set[0].to = assoc_array_node_to_ptr(new_n0);
	new_n0->back_pointer = node->back_pointer;
	new_n0->parent_slot = node->parent_slot;
	new_n1->back_pointer = assoc_array_node_to_ptr(new_n0);
	new_n1->parent_slot = -1; /* Need to calculate this */

do_split_node:
	pr_devel(""do_split_node\n"");

	new_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;
	new_n1->nr_leaves_on_branch = 0;

	/* Begin by finding two matching leaves.  There have to be at least two
	 * that match - even if there are meta pointers - because any leaf that
	 * would match a slot with a meta pointer in it must be somewhere
	 * behind that meta pointer and cannot be here.  Further, given N
	 * remaining leaf slots, we now have N+1 leaves to go in them.
	 */
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {
		slot = edit->segment_cache[i];
		if (slot != 0xff)
			for (j = i + 1; j < ASSOC_ARRAY_FAN_OUT + 1; j++)
				if (edit->segment_cache[j] == slot)
					goto found_slot_for_multiple_occupancy;
	}
found_slot_for_multiple_occupancy:
	pr_devel(""same slot: %x %x [%02x]\n"", i, j, slot);
	BUG_ON(i >= ASSOC_ARRAY_FAN_OUT);
	BUG_ON(j >= ASSOC_ARRAY_FAN_OUT + 1);
	BUG_ON(slot >= ASSOC_ARRAY_FAN_OUT);

	new_n1->parent_slot = slot;

	/* Metadata pointers cannot change slot */
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)
		if (assoc_array_ptr_is_meta(node->slots[i]))
			new_n0->slots[i] = node->slots[i];
		else
			new_n0->slots[i] = NULL;
	BUG_ON(new_n0->slots[slot] != NULL);
	new_n0->slots[slot] = assoc_array_node_to_ptr(new_n1);

	/* Filter the leaf pointers between the new nodes */
	free_slot = -1;
	next_slot = 0;
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {
		if (assoc_array_ptr_is_meta(node->slots[i]))
			continue;
		if (edit->segment_cache[i] == slot) {
			new_n1->slots[next_slot++] = node->slots[i];
			new_n1->nr_leaves_on_branch++;
		} else {
			do {
				free_slot++;
			} while (new_n0->slots[free_slot] != NULL);
			new_n0->slots[free_slot] = node->slots[i];
		}
	}

	pr_devel(""filtered: f=%x n=%x\n"", free_slot, next_slot);

	if (edit->segment_cache[ASSOC_ARRAY_FAN_OUT] != slot) {
		do {
			free_slot++;
		} while (new_n0->slots[free_slot] != NULL);
		edit->leaf_p = &new_n0->slots[free_slot];
		edit->adjust_count_on = new_n0;
	} else {
		edit->leaf_p = &new_n1->slots[next_slot++];
		edit->adjust_count_on = new_n1;
	}

	BUG_ON(next_slot <= 1);

	edit->set_backpointers_to = assoc_array_node_to_ptr(new_n0);
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {
		if (edit->segment_cache[i] == 0xff) {
			ptr = node->slots[i];
			BUG_ON(assoc_array_ptr_is_leaf(ptr));
			if (assoc_array_ptr_is_node(ptr)) {
				side = assoc_array_ptr_to_node(ptr);
				edit->set_backpointers[i] = &side->back_pointer;
			} else {
				shortcut = assoc_array_ptr_to_shortcut(ptr);
				edit->set_backpointers[i] = &shortcut->back_pointer;
			}
		}
	}

	ptr = node->back_pointer;
	if (!ptr)
		edit->set[0].ptr = &edit->array->root;
	else if (assoc_array_ptr_is_node(ptr))
		edit->set[0].ptr = &assoc_array_ptr_to_node(ptr)->slots[node->parent_slot];
	else
		edit->set[0].ptr = &assoc_array_ptr_to_shortcut(ptr)->next_node;
	edit->excised_meta[0] = assoc_array_node_to_ptr(node);
 	pr_devel(""<--%s() = ok [split node]\n"", __func__);
 	return true;
 
present_leaves_cluster_but_not_new_leaf:
	/* All the old leaves cluster in the same slot, but the new leaf wants
	 * to go into a different slot, so we create a new node to hold the new
	 * leaf and a pointer to a new node holding all the old leaves.
	 */
	pr_devel(""present leaves cluster but not new leaf\n"");
	new_n0->back_pointer = node->back_pointer;
	new_n0->parent_slot = node->parent_slot;
	new_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;
	new_n1->back_pointer = assoc_array_node_to_ptr(new_n0);
	new_n1->parent_slot = edit->segment_cache[0];
	new_n1->nr_leaves_on_branch = node->nr_leaves_on_branch;
	edit->adjust_count_on = new_n0;
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)
		new_n1->slots[i] = node->slots[i];
	new_n0->slots[edit->segment_cache[0]] = assoc_array_node_to_ptr(new_n0);
	edit->leaf_p = &new_n0->slots[edit->segment_cache[ASSOC_ARRAY_FAN_OUT]];
	edit->set[0].ptr = &assoc_array_ptr_to_node(node->back_pointer)->slots[node->parent_slot];
	edit->set[0].to = assoc_array_node_to_ptr(new_n0);
	edit->excised_meta[0] = assoc_array_node_to_ptr(node);
	pr_devel(""<--%s() = ok [insert node before]\n"", __func__);
	return true;
 all_leaves_cluster_together:
 	/* All the leaves, new and old, want to cluster together in this node
 	 * in the same slot, so we have to replace this node with a shortcut to
	 * skip over the identical parts of the key and then place a pair of
	 * nodes, one inside the other, at the end of the shortcut and
	 * distribute the keys between them.
	 *
	 * Firstly we need to work out where the leaves start diverging as a
	 * bit position into their keys so that we know how big the shortcut
	 * needs to be.
	 *
	 * We only need to make a single pass of N of the N+1 leaves because if
	 * any keys differ between themselves at bit X then at least one of
	 * them must also differ with the base key at bit X or before.
	 */
	pr_devel(""all leaves cluster together\n"");
	diff = INT_MAX;
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {
		int x = ops->diff_objects(assoc_array_ptr_to_leaf(node->slots[i]),
					  index_key);
		if (x < diff) {
			BUG_ON(x < 0);
			diff = x;
		}
	}
	BUG_ON(diff == INT_MAX);
	BUG_ON(diff < level + ASSOC_ARRAY_LEVEL_STEP);

	keylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);
	keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;

	new_s0 = kzalloc(sizeof(struct assoc_array_shortcut) +
			 keylen * sizeof(unsigned long), GFP_KERNEL);
	if (!new_s0)
		return false;
	edit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s0);

	edit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);
	new_s0->back_pointer = node->back_pointer;
	new_s0->parent_slot = node->parent_slot;
	new_s0->next_node = assoc_array_node_to_ptr(new_n0);
	new_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);
	new_n0->parent_slot = 0;
	new_n1->back_pointer = assoc_array_node_to_ptr(new_n0);
	new_n1->parent_slot = -1; /* Need to calculate this */

	new_s0->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK;
	pr_devel(""skip_to_level = %d [diff %d]\n"", level, diff);
	BUG_ON(level <= 0);

	for (i = 0; i < keylen; i++)
		new_s0->index_key[i] =
			ops->get_key_chunk(index_key, i * ASSOC_ARRAY_KEY_CHUNK_SIZE);

	blank = ULONG_MAX << (level & ASSOC_ARRAY_KEY_CHUNK_MASK);
	pr_devel(""blank off [%zu] %d: %lx\n"", keylen - 1, level, blank);
	new_s0->index_key[keylen - 1] &= ~blank;

	/* This now reduces to a node splitting exercise for which we'll need
	 * to regenerate the disparity table.
	 */
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {
		ptr = node->slots[i];
		base_seg = ops->get_object_key_chunk(assoc_array_ptr_to_leaf(ptr),
						     level);
		base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;
		edit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;
	}

	base_seg = ops->get_key_chunk(index_key, level);
	base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;
	edit->segment_cache[ASSOC_ARRAY_FAN_OUT] = base_seg & ASSOC_ARRAY_FAN_MASK;
	goto do_split_node;
}
",C,"		/* Otherwise all the old leaves cluster in the same slot, but
		 * the new leaf wants to go into a different slot - so we
		 * create a new node (n0) to hold the new leaf and a pointer to
		 * a new node (n1) holding all the old leaves.
		 *
		 * This can be done by falling through to the node splitting
		 * path.
		pr_devel(""present leaves cluster but not new leaf\n"");
	/* We need to split the current node.  The node must contain anything
	 * from a single leaf (in the one leaf case, this leaf will cluster
	 * with the new leaf) and the rest meta-pointers, to all leaves, some
	 * of which may cluster.
	 *
	 * It won't contain the case in which all the current leaves plus the
	 * new leaves want to cluster in the same slot.
	 * leaves in the node and the new leaf.  The current meta pointers can
	 * just be copied as they shouldn't cluster with any of the leaves.
","		/* Otherwise we can just insert a new node ahead of the old
		 * one.
		goto present_leaves_cluster_but_not_new_leaf;
	/* We need to split the current node; we know that the node doesn't
	 * simply contain a full set of leaves that cluster together (it
	 * contains meta pointers and/or non-clustering leaves).
	 * leaves in the node and the new leaf.
present_leaves_cluster_but_not_new_leaf:
	/* All the old leaves cluster in the same slot, but the new leaf wants
	 * to go into a different slot, so we create a new node to hold the new
	 * leaf and a pointer to a new node holding all the old leaves.
	 */
	pr_devel(""present leaves cluster but not new leaf\n"");
	new_n0->back_pointer = node->back_pointer;
	new_n0->parent_slot = node->parent_slot;
	new_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;
	new_n1->back_pointer = assoc_array_node_to_ptr(new_n0);
	new_n1->parent_slot = edit->segment_cache[0];
	new_n1->nr_leaves_on_branch = node->nr_leaves_on_branch;
	edit->adjust_count_on = new_n0;
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)
		new_n1->slots[i] = node->slots[i];
	new_n0->slots[edit->segment_cache[0]] = assoc_array_node_to_ptr(new_n0);
	edit->leaf_p = &new_n0->slots[edit->segment_cache[ASSOC_ARRAY_FAN_OUT]];
	edit->set[0].ptr = &assoc_array_ptr_to_node(node->back_pointer)->slots[node->parent_slot];
	edit->set[0].to = assoc_array_node_to_ptr(new_n0);
	edit->excised_meta[0] = assoc_array_node_to_ptr(node);
	pr_devel(""<--%s() = ok [insert node before]\n"", __func__);
	return true;
",,"@@ -598,21 +598,31 @@ static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,
 		if ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)
 			goto all_leaves_cluster_together;
 
-		/* Otherwise we can just insert a new node ahead of the old
-		 * one.
+		/* Otherwise all the old leaves cluster in the same slot, but
+		 * the new leaf wants to go into a different slot - so we
+		 * create a new node (n0) to hold the new leaf and a pointer to
+		 * a new node (n1) holding all the old leaves.
+		 *
+		 * This can be done by falling through to the node splitting
+		 * path.
 		 */
-		goto present_leaves_cluster_but_not_new_leaf;
+		pr_devel(""present leaves cluster but not new leaf\n"");
 	}
 
 split_node:
 	pr_devel(""split node\n"");
 
-	/* We need to split the current node; we know that the node doesn't
-	 * simply contain a full set of leaves that cluster together (it
-	 * contains meta pointers and/or non-clustering leaves).
+	/* We need to split the current node.  The node must contain anything
+	 * from a single leaf (in the one leaf case, this leaf will cluster
+	 * with the new leaf) and the rest meta-pointers, to all leaves, some
+	 * of which may cluster.
+	 *
+	 * It won't contain the case in which all the current leaves plus the
+	 * new leaves want to cluster in the same slot.
 	 *
 	 * We need to expel at least two leaves out of a set consisting of the
-	 * leaves in the node and the new leaf.
+	 * leaves in the node and the new leaf.  The current meta pointers can
+	 * just be copied as they shouldn't cluster with any of the leaves.
 	 *
 	 * We need a new node (n0) to replace the current one and a new node to
 	 * take the expelled nodes (n1).
@@ -717,33 +727,6 @@ static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,
 	pr_devel(""<--%s() = ok [split node]\n"", __func__);
 	return true;
 
-present_leaves_cluster_but_not_new_leaf:
-	/* All the old leaves cluster in the same slot, but the new leaf wants
-	 * to go into a different slot, so we create a new node to hold the new
-	 * leaf and a pointer to a new node holding all the old leaves.
-	 */
-	pr_devel(""present leaves cluster but not new leaf\n"");
-
-	new_n0->back_pointer = node->back_pointer;
-	new_n0->parent_slot = node->parent_slot;
-	new_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;
-	new_n1->back_pointer = assoc_array_node_to_ptr(new_n0);
-	new_n1->parent_slot = edit->segment_cache[0];
-	new_n1->nr_leaves_on_branch = node->nr_leaves_on_branch;
-	edit->adjust_count_on = new_n0;
-
-	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)
-		new_n1->slots[i] = node->slots[i];
-
-	new_n0->slots[edit->segment_cache[0]] = assoc_array_node_to_ptr(new_n0);
-	edit->leaf_p = &new_n0->slots[edit->segment_cache[ASSOC_ARRAY_FAN_OUT]];
-
-	edit->set[0].ptr = &assoc_array_ptr_to_node(node->back_pointer)->slots[node->parent_slot];
-	edit->set[0].to = assoc_array_node_to_ptr(new_n0);
-	edit->excised_meta[0] = assoc_array_node_to_ptr(node);
-	pr_devel(""<--%s() = ok [insert node before]\n"", __func__);
-	return true;
-
 all_leaves_cluster_together:
 	/* All the leaves, new and old, want to cluster together in this node
 	 * in the same slot, so we have to replace this node with a shortcut to",linux,ea6789980fdaa610d7eb63602c746bf6ec70cd2b,781402340475144bb360e32bb7437fa4b84cadc3,1,"static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,
						  const struct assoc_array_ops *ops,
						  const void *index_key,
						  struct assoc_array_walk_result *result)
{
	struct assoc_array_shortcut *shortcut, *new_s0;
	struct assoc_array_node *node, *new_n0, *new_n1, *side;
	struct assoc_array_ptr *ptr;
	unsigned long dissimilarity, base_seg, blank;
	size_t keylen;
	bool have_meta;
	int level, diff;
	int slot, next_slot, free_slot, i, j;

	node	= result->terminal_node.node;
	level	= result->terminal_node.level;
	edit->segment_cache[ASSOC_ARRAY_FAN_OUT] = result->terminal_node.slot;

	pr_devel(""-->%s()\n"", __func__);

	/* We arrived at a node which doesn't have an onward node or shortcut
	 * pointer that we have to follow.  This means that (a) the leaf we
	 * want must go here (either by insertion or replacement) or (b) we
	 * need to split this node and insert in one of the fragments.
	 */
	free_slot = -1;

	/* Firstly, we have to check the leaves in this node to see if there's
	 * a matching one we should replace in place.
	 */
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {
		ptr = node->slots[i];
		if (!ptr) {
			free_slot = i;
			continue;
		}
		if (assoc_array_ptr_is_leaf(ptr) &&
		    ops->compare_object(assoc_array_ptr_to_leaf(ptr),
					index_key)) {
			pr_devel(""replace in slot %d\n"", i);
			edit->leaf_p = &node->slots[i];
			edit->dead_leaf = node->slots[i];
			pr_devel(""<--%s() = ok [replace]\n"", __func__);
			return true;
		}
	}

	/* If there is a free slot in this node then we can just insert the
	 * leaf here.
	 */
	if (free_slot >= 0) {
		pr_devel(""insert in free slot %d\n"", free_slot);
		edit->leaf_p = &node->slots[free_slot];
		edit->adjust_count_on = node;
		pr_devel(""<--%s() = ok [insert]\n"", __func__);
		return true;
	}

	/* The node has no spare slots - so we're either going to have to split
	 * it or insert another node before it.
	 *
	 * Whatever, we're going to need at least two new nodes - so allocate
	 * those now.  We may also need a new shortcut, but we deal with that
	 * when we need it.
	 */
	new_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);
	if (!new_n0)
		return false;
	edit->new_meta[0] = assoc_array_node_to_ptr(new_n0);
	new_n1 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);
	if (!new_n1)
		return false;
	edit->new_meta[1] = assoc_array_node_to_ptr(new_n1);

	/* We need to find out how similar the leaves are. */
	pr_devel(""no spare slots\n"");
	have_meta = false;
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {
		ptr = node->slots[i];
		if (assoc_array_ptr_is_meta(ptr)) {
			edit->segment_cache[i] = 0xff;
			have_meta = true;
			continue;
		}
		base_seg = ops->get_object_key_chunk(
			assoc_array_ptr_to_leaf(ptr), level);
		base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;
		edit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;
	}

	if (have_meta) {
		pr_devel(""have meta\n"");
		goto split_node;
	}

	/* The node contains only leaves */
	dissimilarity = 0;
	base_seg = edit->segment_cache[0];
	for (i = 1; i < ASSOC_ARRAY_FAN_OUT; i++)
		dissimilarity |= edit->segment_cache[i] ^ base_seg;

	pr_devel(""only leaves; dissimilarity=%lx\n"", dissimilarity);

	if ((dissimilarity & ASSOC_ARRAY_FAN_MASK) == 0) {
		/* The old leaves all cluster in the same slot.  We will need
		 * to insert a shortcut if the new node wants to cluster with them.
		 */
 		if ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)
 			goto all_leaves_cluster_together;
 
//flaw_line_below:
		/* Otherwise we can just insert a new node ahead of the old
//flaw_line_below:
		 * one.
//fix_flaw_line_below:
//		/* Otherwise all the old leaves cluster in the same slot, but
//fix_flaw_line_below:
//		 * the new leaf wants to go into a different slot - so we
//fix_flaw_line_below:
//		 * create a new node (n0) to hold the new leaf and a pointer to
//fix_flaw_line_below:
//		 * a new node (n1) holding all the old leaves.
//fix_flaw_line_below:
//		 *
//fix_flaw_line_below:
//		 * This can be done by falling through to the node splitting
//fix_flaw_line_below:
//		 * path.
 		 */
//flaw_line_below:
		goto present_leaves_cluster_but_not_new_leaf;
//fix_flaw_line_below:
//		pr_devel(""present leaves cluster but not new leaf\n"");
 	}
 
 split_node:
 	pr_devel(""split node\n"");
 
//flaw_line_below:
	/* We need to split the current node; we know that the node doesn't
//flaw_line_below:
	 * simply contain a full set of leaves that cluster together (it
//flaw_line_below:
	 * contains meta pointers and/or non-clustering leaves).
//fix_flaw_line_below:
//	/* We need to split the current node.  The node must contain anything
//fix_flaw_line_below:
//	 * from a single leaf (in the one leaf case, this leaf will cluster
//fix_flaw_line_below:
//	 * with the new leaf) and the rest meta-pointers, to all leaves, some
//fix_flaw_line_below:
//	 * of which may cluster.
//fix_flaw_line_below:
//	 *
//fix_flaw_line_below:
//	 * It won't contain the case in which all the current leaves plus the
//fix_flaw_line_below:
//	 * new leaves want to cluster in the same slot.
 	 *
 	 * We need to expel at least two leaves out of a set consisting of the
//flaw_line_below:
	 * leaves in the node and the new leaf.
//fix_flaw_line_below:
//	 * leaves in the node and the new leaf.  The current meta pointers can
//fix_flaw_line_below:
//	 * just be copied as they shouldn't cluster with any of the leaves.
 	 *
 	 * We need a new node (n0) to replace the current one and a new node to
 	 * take the expelled nodes (n1).
	 */
	edit->set[0].to = assoc_array_node_to_ptr(new_n0);
	new_n0->back_pointer = node->back_pointer;
	new_n0->parent_slot = node->parent_slot;
	new_n1->back_pointer = assoc_array_node_to_ptr(new_n0);
	new_n1->parent_slot = -1; /* Need to calculate this */

do_split_node:
	pr_devel(""do_split_node\n"");

	new_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;
	new_n1->nr_leaves_on_branch = 0;

	/* Begin by finding two matching leaves.  There have to be at least two
	 * that match - even if there are meta pointers - because any leaf that
	 * would match a slot with a meta pointer in it must be somewhere
	 * behind that meta pointer and cannot be here.  Further, given N
	 * remaining leaf slots, we now have N+1 leaves to go in them.
	 */
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {
		slot = edit->segment_cache[i];
		if (slot != 0xff)
			for (j = i + 1; j < ASSOC_ARRAY_FAN_OUT + 1; j++)
				if (edit->segment_cache[j] == slot)
					goto found_slot_for_multiple_occupancy;
	}
found_slot_for_multiple_occupancy:
	pr_devel(""same slot: %x %x [%02x]\n"", i, j, slot);
	BUG_ON(i >= ASSOC_ARRAY_FAN_OUT);
	BUG_ON(j >= ASSOC_ARRAY_FAN_OUT + 1);
	BUG_ON(slot >= ASSOC_ARRAY_FAN_OUT);

	new_n1->parent_slot = slot;

	/* Metadata pointers cannot change slot */
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)
		if (assoc_array_ptr_is_meta(node->slots[i]))
			new_n0->slots[i] = node->slots[i];
		else
			new_n0->slots[i] = NULL;
	BUG_ON(new_n0->slots[slot] != NULL);
	new_n0->slots[slot] = assoc_array_node_to_ptr(new_n1);

	/* Filter the leaf pointers between the new nodes */
	free_slot = -1;
	next_slot = 0;
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {
		if (assoc_array_ptr_is_meta(node->slots[i]))
			continue;
		if (edit->segment_cache[i] == slot) {
			new_n1->slots[next_slot++] = node->slots[i];
			new_n1->nr_leaves_on_branch++;
		} else {
			do {
				free_slot++;
			} while (new_n0->slots[free_slot] != NULL);
			new_n0->slots[free_slot] = node->slots[i];
		}
	}

	pr_devel(""filtered: f=%x n=%x\n"", free_slot, next_slot);

	if (edit->segment_cache[ASSOC_ARRAY_FAN_OUT] != slot) {
		do {
			free_slot++;
		} while (new_n0->slots[free_slot] != NULL);
		edit->leaf_p = &new_n0->slots[free_slot];
		edit->adjust_count_on = new_n0;
	} else {
		edit->leaf_p = &new_n1->slots[next_slot++];
		edit->adjust_count_on = new_n1;
	}

	BUG_ON(next_slot <= 1);

	edit->set_backpointers_to = assoc_array_node_to_ptr(new_n0);
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {
		if (edit->segment_cache[i] == 0xff) {
			ptr = node->slots[i];
			BUG_ON(assoc_array_ptr_is_leaf(ptr));
			if (assoc_array_ptr_is_node(ptr)) {
				side = assoc_array_ptr_to_node(ptr);
				edit->set_backpointers[i] = &side->back_pointer;
			} else {
				shortcut = assoc_array_ptr_to_shortcut(ptr);
				edit->set_backpointers[i] = &shortcut->back_pointer;
			}
		}
	}

	ptr = node->back_pointer;
	if (!ptr)
		edit->set[0].ptr = &edit->array->root;
	else if (assoc_array_ptr_is_node(ptr))
		edit->set[0].ptr = &assoc_array_ptr_to_node(ptr)->slots[node->parent_slot];
	else
		edit->set[0].ptr = &assoc_array_ptr_to_shortcut(ptr)->next_node;
	edit->excised_meta[0] = assoc_array_node_to_ptr(node);
 	pr_devel(""<--%s() = ok [split node]\n"", __func__);
 	return true;
 
//flaw_line_below:
present_leaves_cluster_but_not_new_leaf:
//flaw_line_below:
	/* All the old leaves cluster in the same slot, but the new leaf wants
//flaw_line_below:
	 * to go into a different slot, so we create a new node to hold the new
//flaw_line_below:
	 * leaf and a pointer to a new node holding all the old leaves.
//flaw_line_below:
	 */
//flaw_line_below:
	pr_devel(""present leaves cluster but not new leaf\n"");
//flaw_line_below:

//flaw_line_below:
	new_n0->back_pointer = node->back_pointer;
//flaw_line_below:
	new_n0->parent_slot = node->parent_slot;
//flaw_line_below:
	new_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;
//flaw_line_below:
	new_n1->back_pointer = assoc_array_node_to_ptr(new_n0);
//flaw_line_below:
	new_n1->parent_slot = edit->segment_cache[0];
//flaw_line_below:
	new_n1->nr_leaves_on_branch = node->nr_leaves_on_branch;
//flaw_line_below:
	edit->adjust_count_on = new_n0;
//flaw_line_below:

//flaw_line_below:
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)
//flaw_line_below:
		new_n1->slots[i] = node->slots[i];
//flaw_line_below:

//flaw_line_below:
	new_n0->slots[edit->segment_cache[0]] = assoc_array_node_to_ptr(new_n0);
//flaw_line_below:
	edit->leaf_p = &new_n0->slots[edit->segment_cache[ASSOC_ARRAY_FAN_OUT]];
//flaw_line_below:

//flaw_line_below:
	edit->set[0].ptr = &assoc_array_ptr_to_node(node->back_pointer)->slots[node->parent_slot];
//flaw_line_below:
	edit->set[0].to = assoc_array_node_to_ptr(new_n0);
//flaw_line_below:
	edit->excised_meta[0] = assoc_array_node_to_ptr(node);
//flaw_line_below:
	pr_devel(""<--%s() = ok [insert node before]\n"", __func__);
//flaw_line_below:
	return true;
//flaw_line_below:

 all_leaves_cluster_together:
 	/* All the leaves, new and old, want to cluster together in this node
 	 * in the same slot, so we have to replace this node with a shortcut to
	 * skip over the identical parts of the key and then place a pair of
	 * nodes, one inside the other, at the end of the shortcut and
	 * distribute the keys between them.
	 *
	 * Firstly we need to work out where the leaves start diverging as a
	 * bit position into their keys so that we know how big the shortcut
	 * needs to be.
	 *
	 * We only need to make a single pass of N of the N+1 leaves because if
	 * any keys differ between themselves at bit X then at least one of
	 * them must also differ with the base key at bit X or before.
	 */
	pr_devel(""all leaves cluster together\n"");
	diff = INT_MAX;
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {
		int x = ops->diff_objects(assoc_array_ptr_to_leaf(node->slots[i]),
					  index_key);
		if (x < diff) {
			BUG_ON(x < 0);
			diff = x;
		}
	}
	BUG_ON(diff == INT_MAX);
	BUG_ON(diff < level + ASSOC_ARRAY_LEVEL_STEP);

	keylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);
	keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;

	new_s0 = kzalloc(sizeof(struct assoc_array_shortcut) +
			 keylen * sizeof(unsigned long), GFP_KERNEL);
	if (!new_s0)
		return false;
	edit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s0);

	edit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);
	new_s0->back_pointer = node->back_pointer;
	new_s0->parent_slot = node->parent_slot;
	new_s0->next_node = assoc_array_node_to_ptr(new_n0);
	new_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);
	new_n0->parent_slot = 0;
	new_n1->back_pointer = assoc_array_node_to_ptr(new_n0);
	new_n1->parent_slot = -1; /* Need to calculate this */

	new_s0->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK;
	pr_devel(""skip_to_level = %d [diff %d]\n"", level, diff);
	BUG_ON(level <= 0);

	for (i = 0; i < keylen; i++)
		new_s0->index_key[i] =
			ops->get_key_chunk(index_key, i * ASSOC_ARRAY_KEY_CHUNK_SIZE);

	blank = ULONG_MAX << (level & ASSOC_ARRAY_KEY_CHUNK_MASK);
	pr_devel(""blank off [%zu] %d: %lx\n"", keylen - 1, level, blank);
	new_s0->index_key[keylen - 1] &= ~blank;

	/* This now reduces to a node splitting exercise for which we'll need
	 * to regenerate the disparity table.
	 */
	for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {
		ptr = node->slots[i];
		base_seg = ops->get_object_key_chunk(assoc_array_ptr_to_leaf(ptr),
						     level);
		base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;
		edit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;
	}

	base_seg = ops->get_key_chunk(index_key, level);
	base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;
	edit->segment_cache[ASSOC_ARRAY_FAN_OUT] = base_seg & ASSOC_ARRAY_FAN_MASK;
	goto do_split_node;
}
"
3423,181159,,Local,Not required,Complete,CVE-2017-12192,https://www.cvedetails.com/cve/CVE-2017-12192/,CWE-476,Low,,,,2017-10-11,4.9,"The keyctl_read_key function in security/keys/keyctl.c in the Key Management subcomponent in the Linux kernel before 4.13.5 does not properly consider that a key may be possessed but negatively instantiated, which allows local users to cause a denial of service (OOPS and system crash) via a crafted KEYCTL_READ operation.",2018-03-15,DoS ,5,https://github.com/torvalds/linux/commit/37863c43b2c6464f252862bf2e9768264e961678,37863c43b2c6464f252862bf2e9768264e961678,"KEYS: prevent KEYCTL_READ on negative key

Because keyctl_read_key() looks up the key with no permissions
requested, it may find a negatively instantiated key.  If the key is
also possessed, we went ahead and called ->read() on the key.  But the
key payload will actually contain the ->reject_error rather than the
normal payload.  Thus, the kernel oopses trying to read the
user_key_payload from memory address (int)-ENOKEY = 0x00000000ffffff82.

Fortunately the payload data is stored inline, so it shouldn't be
possible to abuse this as an arbitrary memory read primitive...

Reproducer:
    keyctl new_session
    keyctl request2 user desc '' @s
    keyctl read $(keyctl show | awk '/user: desc/ {print $1}')

It causes a crash like the following:
     BUG: unable to handle kernel paging request at 00000000ffffff92
     IP: user_read+0x33/0xa0
     PGD 36a54067 P4D 36a54067 PUD 0
     Oops: 0000 [#1] SMP
     CPU: 0 PID: 211 Comm: keyctl Not tainted 4.14.0-rc1 #337
     Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-20170228_101828-anatol 04/01/2014
     task: ffff90aa3b74c3c0 task.stack: ffff9878c0478000
     RIP: 0010:user_read+0x33/0xa0
     RSP: 0018:ffff9878c047bee8 EFLAGS: 00010246
     RAX: 0000000000000001 RBX: ffff90aa3d7da340 RCX: 0000000000000017
     RDX: 0000000000000000 RSI: 00000000ffffff82 RDI: ffff90aa3d7da340
     RBP: ffff9878c047bf00 R08: 00000024f95da94f R09: 0000000000000000
     R10: 0000000000000001 R11: 0000000000000000 R12: 0000000000000000
     R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000
     FS:  00007f58ece69740(0000) GS:ffff90aa3e200000(0000) knlGS:0000000000000000
     CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
     CR2: 00000000ffffff92 CR3: 0000000036adc001 CR4: 00000000003606f0
     Call Trace:
      keyctl_read_key+0xac/0xe0
      SyS_keyctl+0x99/0x120
      entry_SYSCALL_64_fastpath+0x1f/0xbe
     RIP: 0033:0x7f58ec787bb9
     RSP: 002b:00007ffc8d401678 EFLAGS: 00000206 ORIG_RAX: 00000000000000fa
     RAX: ffffffffffffffda RBX: 00007ffc8d402800 RCX: 00007f58ec787bb9
     RDX: 0000000000000000 RSI: 00000000174a63ac RDI: 000000000000000b
     RBP: 0000000000000004 R08: 00007ffc8d402809 R09: 0000000000000020
     R10: 0000000000000000 R11: 0000000000000206 R12: 00007ffc8d402800
     R13: 00007ffc8d4016e0 R14: 0000000000000000 R15: 0000000000000000
     Code: e5 41 55 49 89 f5 41 54 49 89 d4 53 48 89 fb e8 a4 b4 ad ff 85 c0 74 09 80 3d b9 4c 96 00 00 74 43 48 8b b3 20 01 00 00 4d 85 ed <0f> b7 5e 10 74 29 4d 85 e4 74 24 4c 39 e3 4c 89 e2 4c 89 ef 48
     RIP: user_read+0x33/0xa0 RSP: ffff9878c047bee8
     CR2: 00000000ffffff92

Fixes: 61ea0c0ba904 (""KEYS: Skip key state checks when checking for possession"")
Cc: <stable@vger.kernel.org>	[v3.13+]
Signed-off-by: Eric Biggers <ebiggers@google.com>
Signed-off-by: David Howells <dhowells@redhat.com>",0,security/keys/keyctl.c,"{""sha"": ""365ff85d7e27122db220fad6d633f8e0b352209f"", ""filename"": ""security/keys/keyctl.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/37863c43b2c6464f252862bf2e9768264e961678/security/keys/keyctl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/37863c43b2c6464f252862bf2e9768264e961678/security/keys/keyctl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/keyctl.c?ref=37863c43b2c6464f252862bf2e9768264e961678"", ""patch"": ""@@ -766,6 +766,11 @@ long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n \n \tkey = key_ref_to_ptr(key_ref);\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n+\t\tret = -ENOKEY;\n+\t\tgoto error2;\n+\t}\n+\n \t/* see if we can read it directly */\n \tret = key_permission(key_ref, KEY_NEED_READ);\n \tif (ret == 0)""}","long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)
{
	struct key *key;
	key_ref_t key_ref;
	long ret;

	/* find the key first */
	key_ref = lookup_user_key(keyid, 0, 0);
	if (IS_ERR(key_ref)) {
		ret = -ENOKEY;
		goto error;
	}
 
 	key = key_ref_to_ptr(key_ref);
 
	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {
		ret = -ENOKEY;
		goto error2;
	}

 	/* see if we can read it directly */
 	ret = key_permission(key_ref, KEY_NEED_READ);
 	if (ret == 0)
		goto can_read_key;
	if (ret != -EACCES)
		goto error2;

	/* we can't; see if it's searchable from this process's keyrings
	 * - we automatically take account of the fact that it may be
	 *   dangling off an instantiation key
	 */
	if (!is_key_possessed(key_ref)) {
		ret = -EACCES;
		goto error2;
	}

	/* the key is probably readable - now try to read it */
can_read_key:
	ret = -EOPNOTSUPP;
	if (key->type->read) {
		/* Read the data with the semaphore held (since we might sleep)
		 * to protect against the key being updated or revoked.
		 */
		down_read(&key->sem);
		ret = key_validate(key);
		if (ret == 0)
			ret = key->type->read(key, buffer, buflen);
		up_read(&key->sem);
	}

error2:
	key_put(key);
error:
	return ret;
}
","long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)
{
	struct key *key;
	key_ref_t key_ref;
	long ret;

	/* find the key first */
	key_ref = lookup_user_key(keyid, 0, 0);
	if (IS_ERR(key_ref)) {
		ret = -ENOKEY;
		goto error;
	}
 
 	key = key_ref_to_ptr(key_ref);
 
 	/* see if we can read it directly */
 	ret = key_permission(key_ref, KEY_NEED_READ);
 	if (ret == 0)
		goto can_read_key;
	if (ret != -EACCES)
		goto error2;

	/* we can't; see if it's searchable from this process's keyrings
	 * - we automatically take account of the fact that it may be
	 *   dangling off an instantiation key
	 */
	if (!is_key_possessed(key_ref)) {
		ret = -EACCES;
		goto error2;
	}

	/* the key is probably readable - now try to read it */
can_read_key:
	ret = -EOPNOTSUPP;
	if (key->type->read) {
		/* Read the data with the semaphore held (since we might sleep)
		 * to protect against the key being updated or revoked.
		 */
		down_read(&key->sem);
		ret = key_validate(key);
		if (ret == 0)
			ret = key->type->read(key, buffer, buflen);
		up_read(&key->sem);
	}

error2:
	key_put(key);
error:
	return ret;
}
",C,"	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {
		ret = -ENOKEY;
		goto error2;
	}

",,,"@@ -766,6 +766,11 @@ long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)
 
 	key = key_ref_to_ptr(key_ref);
 
+	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {
+		ret = -ENOKEY;
+		goto error2;
+	}
+
 	/* see if we can read it directly */
 	ret = key_permission(key_ref, KEY_NEED_READ);
 	if (ret == 0)",linux,37863c43b2c6464f252862bf2e9768264e961678,237bbd29f7a049d310d907f4b2716a7feef9abf3,1,"long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)
{
	struct key *key;
	key_ref_t key_ref;
	long ret;

	/* find the key first */
	key_ref = lookup_user_key(keyid, 0, 0);
	if (IS_ERR(key_ref)) {
		ret = -ENOKEY;
		goto error;
	}
 
 	key = key_ref_to_ptr(key_ref);
 
//fix_flaw_line_below:
//	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {
//fix_flaw_line_below:
//		ret = -ENOKEY;
//fix_flaw_line_below:
//		goto error2;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	/* see if we can read it directly */
 	ret = key_permission(key_ref, KEY_NEED_READ);
 	if (ret == 0)
		goto can_read_key;
	if (ret != -EACCES)
		goto error2;

	/* we can't; see if it's searchable from this process's keyrings
	 * - we automatically take account of the fact that it may be
	 *   dangling off an instantiation key
	 */
	if (!is_key_possessed(key_ref)) {
		ret = -EACCES;
		goto error2;
	}

	/* the key is probably readable - now try to read it */
can_read_key:
	ret = -EOPNOTSUPP;
	if (key->type->read) {
		/* Read the data with the semaphore held (since we might sleep)
		 * to protect against the key being updated or revoked.
		 */
		down_read(&key->sem);
		ret = key_validate(key);
		if (ret == 0)
			ret = key->type->read(key, buffer, buflen);
		up_read(&key->sem);
	}

error2:
	key_put(key);
error:
	return ret;
}
"
3445,181181,,Remote,Not required,Partial,CVE-2017-11522,https://www.cvedetails.com/cve/CVE-2017-11522/,CWE-476,Medium,,,,2017-07-22,4.3,The WriteOnePNGImage function in coders/png.c in ImageMagick through 6.9.9-0 and 7.x through 7.0.6-1 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted file.,2017-07-26,DoS ,3,https://github.com/ImageMagick/ImageMagick/commit/816ecab6c532ae086ff4186b3eaf4aa7092d536f,816ecab6c532ae086ff4186b3eaf4aa7092d536f,https://github.com/ImageMagick/ImageMagick/issues/58,1,coders/png.c,"{""sha"": ""c61b6874e7ad5c817a732bece839eae339bc03a7"", ""filename"": ""coders/png.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/816ecab6c532ae086ff4186b3eaf4aa7092d536f/coders/png.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/816ecab6c532ae086ff4186b3eaf4aa7092d536f/coders/png.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/png.c?ref=816ecab6c532ae086ff4186b3eaf4aa7092d536f"", ""patch"": ""@@ -8270,9 +8270,11 @@ static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,\n     \""  Enter WriteOnePNGImage()\"");\n \n   image = CloneImage(IMimage,0,0,MagickFalse,exception);\n+  if (image == (Image *) NULL)\n+    return(MagickFalse);\n   image_info=(ImageInfo *) CloneImageInfo(IMimage_info);\n   if (image_info == (ImageInfo *) NULL)\n-     ThrowWriterException(ResourceLimitError, \""MemoryAllocationFailed\"");\n+    ThrowWriterException(ResourceLimitError, \""MemoryAllocationFailed\"");\n \n   /* Define these outside of the following \""if logging()\"" block so they will\n    * show in debuggers.""}","static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,
  const ImageInfo *IMimage_info,Image *IMimage,ExceptionInfo *exception)
{
  char
    im_vers[32],
    libpng_runv[32],
    libpng_vers[32],
    zlib_runv[32],
    zlib_vers[32];

  Image
    *image;

  ImageInfo
    *image_info;

  char
    s[2];

  const char
    *name,
    *property,
    *value;

  const StringInfo
    *profile;

  int
    num_passes,
    pass,
    ping_wrote_caNv;

  png_byte
     ping_trans_alpha[256];

  png_color
     palette[257];

  png_color_16
    ping_background,
    ping_trans_color;

  png_info
    *ping_info;

  png_struct
    *ping;

  png_uint_32
    ping_height,
    ping_width;

  ssize_t
    y;

  MagickBooleanType
    image_matte,
    logging,
    matte,

    ping_have_blob,
    ping_have_cheap_transparency,
    ping_have_color,
    ping_have_non_bw,
    ping_have_PLTE,
    ping_have_bKGD,
    ping_have_eXIf,
    ping_have_iCCP,
    ping_have_pHYs,
    ping_have_sRGB,
    ping_have_tRNS,

    ping_exclude_bKGD,
    ping_exclude_cHRM,
    ping_exclude_date,
    /* ping_exclude_EXIF, */
    ping_exclude_eXIf,
    ping_exclude_gAMA,
    ping_exclude_iCCP,
    /* ping_exclude_iTXt, */
    ping_exclude_oFFs,
    ping_exclude_pHYs,
    ping_exclude_sRGB,
    ping_exclude_tEXt,
    ping_exclude_tIME,
    /* ping_exclude_tRNS, */
    ping_exclude_vpAg,
    ping_exclude_caNv,
    ping_exclude_zCCP, /* hex-encoded iCCP */
    ping_exclude_zTXt,

    ping_preserve_colormap,
    ping_preserve_iCCP,
    ping_need_colortype_warning,

    status,
    tried_332,
    tried_333,
    tried_444;

  MemoryInfo
    *volatile pixel_info;

  QuantumInfo
    *quantum_info;

  PNGErrorInfo
    error_info;

  register ssize_t
    i,
    x;

  unsigned char
    *ping_pixels;

  volatile int
    image_colors,
    ping_bit_depth,
    ping_color_type,
    ping_interlace_method,
    ping_compression_method,
    ping_filter_method,
    ping_num_trans;

  volatile size_t
    image_depth,
    old_bit_depth;

  size_t
    quality,
    rowbytes,
    save_image_depth;

  int
    j,
    number_colors,
    number_opaque,
    number_semitransparent,
    number_transparent,
    ping_pHYs_unit_type;

  png_uint_32
    ping_pHYs_x_resolution,
    ping_pHYs_y_resolution;

  logging=LogMagickEvent(CoderEvent,GetMagickModule(),
     ""  Enter WriteOnePNGImage()"");
 
   image = CloneImage(IMimage,0,0,MagickFalse,exception);
  if (image == (Image *) NULL)
    return(MagickFalse);
   image_info=(ImageInfo *) CloneImageInfo(IMimage_info);
   if (image_info == (ImageInfo *) NULL)
    ThrowWriterException(ResourceLimitError, ""MemoryAllocationFailed"");
 
   /* Define these outside of the following ""if logging()"" block so they will
    * show in debuggers.
   */
  *im_vers='\0';
  (void) ConcatenateMagickString(im_vers,
         MagickLibVersionText,MagickPathExtent);
  (void) ConcatenateMagickString(im_vers,
         MagickLibAddendum,MagickPathExtent);

  *libpng_vers='\0';
  (void) ConcatenateMagickString(libpng_vers,
         PNG_LIBPNG_VER_STRING,32);
  *libpng_runv='\0';
  (void) ConcatenateMagickString(libpng_runv,
         png_get_libpng_ver(NULL),32);

  *zlib_vers='\0';
  (void) ConcatenateMagickString(zlib_vers,
         ZLIB_VERSION,32);
  *zlib_runv='\0';
  (void) ConcatenateMagickString(zlib_runv,
         zlib_version,32);

  if (logging != MagickFalse)
    {
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""    IM version     = %s"",
           im_vers);
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""    Libpng version = %s"",
           libpng_vers);
       if (LocaleCompare(libpng_vers,libpng_runv) != 0)
       {
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""      running with   %s"",
           libpng_runv);
       }
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""    Zlib version   = %s"",
           zlib_vers);
       if (LocaleCompare(zlib_vers,zlib_runv) != 0)
       {
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""      running with   %s"",
           zlib_runv);
       }
    }

  /* Initialize some stuff */
  ping_bit_depth=0,
  ping_color_type=0,
  ping_interlace_method=0,
  ping_compression_method=0,
  ping_filter_method=0,
  ping_num_trans = 0;

  ping_background.red = 0;
  ping_background.green = 0;
  ping_background.blue = 0;
  ping_background.gray = 0;
  ping_background.index = 0;

  ping_trans_color.red=0;
  ping_trans_color.green=0;
  ping_trans_color.blue=0;
  ping_trans_color.gray=0;

  ping_pHYs_unit_type = 0;
  ping_pHYs_x_resolution = 0;
  ping_pHYs_y_resolution = 0;

  ping_have_blob=MagickFalse;
  ping_have_cheap_transparency=MagickFalse;
  ping_have_color=MagickTrue;
  ping_have_non_bw=MagickTrue;
  ping_have_PLTE=MagickFalse;
  ping_have_bKGD=MagickFalse;
  ping_have_eXIf=MagickTrue;
  ping_have_iCCP=MagickFalse;
  ping_have_pHYs=MagickFalse;
  ping_have_sRGB=MagickFalse;
  ping_have_tRNS=MagickFalse;

  ping_exclude_bKGD=mng_info->ping_exclude_bKGD;
  ping_exclude_caNv=mng_info->ping_exclude_caNv;
  ping_exclude_cHRM=mng_info->ping_exclude_cHRM;
  ping_exclude_date=mng_info->ping_exclude_date;
  ping_exclude_eXIf=mng_info->ping_exclude_eXIf;
  ping_exclude_gAMA=mng_info->ping_exclude_gAMA;
  ping_exclude_iCCP=mng_info->ping_exclude_iCCP;
  /* ping_exclude_iTXt=mng_info->ping_exclude_iTXt; */
  ping_exclude_oFFs=mng_info->ping_exclude_oFFs;
  ping_exclude_pHYs=mng_info->ping_exclude_pHYs;
  ping_exclude_sRGB=mng_info->ping_exclude_sRGB;
  ping_exclude_tEXt=mng_info->ping_exclude_tEXt;
  ping_exclude_tIME=mng_info->ping_exclude_tIME;
  /* ping_exclude_tRNS=mng_info->ping_exclude_tRNS; */
  ping_exclude_vpAg=mng_info->ping_exclude_vpAg;
  ping_exclude_zCCP=mng_info->ping_exclude_zCCP; /* hex-encoded iCCP in zTXt */
  ping_exclude_zTXt=mng_info->ping_exclude_zTXt;

  ping_preserve_colormap = mng_info->ping_preserve_colormap;
  ping_preserve_iCCP = mng_info->ping_preserve_iCCP;
  ping_need_colortype_warning = MagickFalse;

  /* Recognize the ICC sRGB profile and convert it to the sRGB chunk,
   * i.e., eliminate the ICC profile and set image->rendering_intent.
   * Note that this will not involve any changes to the actual pixels
   * but merely passes information to applications that read the resulting
   * PNG image.
   *
   * To do: recognize other variants of the sRGB profile, using the CRC to
   * verify all recognized variants including the 7 already known.
   *
   * Work around libpng16+ rejecting some ""known invalid sRGB profiles"".
   *
   * Use something other than image->rendering_intent to record the fact
   * that the sRGB profile was found.
   *
   * Record the ICC version (currently v2 or v4) of the incoming sRGB ICC
   * profile.  Record the Blackpoint Compensation, if any.
   */
   if (ping_exclude_sRGB == MagickFalse && ping_preserve_iCCP == MagickFalse)
   {
      char
        *name;

      const StringInfo
        *profile;

      ResetImageProfileIterator(image);
      for (name=GetNextImageProfile(image); name != (const char *) NULL; )
      {
        profile=GetImageProfile(image,name);

        if (profile != (StringInfo *) NULL)
          {
            if ((LocaleCompare(name,""ICC"") == 0) ||
                (LocaleCompare(name,""ICM"") == 0))

             {
                 int
                   icheck,
                   got_crc=0;


                 png_uint_32
                   length,
                   profile_crc=0;

                 unsigned char
                   *data;

                 length=(png_uint_32) GetStringInfoLength(profile);

                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)
                 {
                   if (length == sRGB_info[icheck].len)
                   {
                     if (got_crc == 0)
                     {
                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                         ""    Got a %lu-byte ICC profile (potentially sRGB)"",
                         (unsigned long) length);

                       data=GetStringInfoDatum(profile);
                       profile_crc=crc32(0,data,length);

                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                           ""      with crc=%8x"",(unsigned int) profile_crc);
                       got_crc++;
                     }

                     if (profile_crc == sRGB_info[icheck].crc)
                     {
                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                            ""      It is sRGB with rendering intent = %s"",
                        Magick_RenderingIntentString_from_PNG_RenderingIntent(
                             sRGB_info[icheck].intent));
                        if (image->rendering_intent==UndefinedIntent)
                        {
                          image->rendering_intent=
                          Magick_RenderingIntent_from_PNG_RenderingIntent(
                             sRGB_info[icheck].intent);
                        }
                        ping_exclude_iCCP = MagickTrue;
                        ping_exclude_zCCP = MagickTrue;
                        ping_have_sRGB = MagickTrue;
                        break;
                     }
                   }
                 }
                 if (sRGB_info[icheck].len == 0)
                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                        ""    Got %lu-byte ICC profile not recognized as sRGB"",
                        (unsigned long) length);
              }
          }
        name=GetNextImageProfile(image);
      }
  }

  number_opaque = 0;
  number_semitransparent = 0;
  number_transparent = 0;

  if (logging != MagickFalse)
    {
      if (image->storage_class == UndefinedClass)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    image->storage_class=UndefinedClass"");
      if (image->storage_class == DirectClass)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    image->storage_class=DirectClass"");
      if (image->storage_class == PseudoClass)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    image->storage_class=PseudoClass"");
      (void) LogMagickEvent(CoderEvent,GetMagickModule(), image->taint ?
          ""    image->taint=MagickTrue"":
          ""    image->taint=MagickFalse"");
    }

  if (image->storage_class == PseudoClass &&
     (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32 ||
     mng_info->write_png48 || mng_info->write_png64 ||
     (mng_info->write_png_colortype != 1 &&
     mng_info->write_png_colortype != 5)))
    {
      (void) SyncImage(image,exception);
      image->storage_class = DirectClass;
    }

  if (ping_preserve_colormap == MagickFalse)
    {
      if (image->storage_class != PseudoClass && image->colormap != NULL)
        {
          /* Free the bogus colormap; it can cause trouble later */
           if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    Freeing bogus colormap"");
           (void) RelinquishMagickMemory(image->colormap);
           image->colormap=NULL;
        }
    }

  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
    (void) TransformImageColorspace(image,sRGBColorspace,exception);

  /*
    Sometimes we get PseudoClass images whose RGB values don't match
    the colors in the colormap.  This code syncs the RGB values.
  */
  if (image->depth <= 8 && image->taint && image->storage_class == PseudoClass)
     (void) SyncImage(image,exception);

#if (MAGICKCORE_QUANTUM_DEPTH == 8)
  if (image->depth > 8)
    {
      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    Reducing PNG bit depth to 8 since this is a Q8 build."");

      image->depth=8;
    }
#endif

  /* Respect the -depth option */
  if (image->depth < 4)
    {
       register Quantum
         *r;

       if (image->depth > 2)
         {
           /* Scale to 4-bit */
           LBR04PacketRGBO(image->background_color);

           for (y=0; y < (ssize_t) image->rows; y++)
           {
             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

             if (r == (Quantum *) NULL)
               break;

             for (x=0; x < (ssize_t) image->columns; x++)
             {
                LBR04PixelRGBA(r);
                r+=GetPixelChannels(image);
             }

             if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
           }

           if (image->storage_class == PseudoClass && image->colormap != NULL)
           {
             for (i=0; i < (ssize_t) image->colors; i++)
             {
               LBR04PacketRGBO(image->colormap[i]);
             }
           }
         }
       else if (image->depth > 1)
         {
           /* Scale to 2-bit */
           LBR02PacketRGBO(image->background_color);

           for (y=0; y < (ssize_t) image->rows; y++)
           {
             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

             if (r == (Quantum *) NULL)
               break;

             for (x=0; x < (ssize_t) image->columns; x++)
             {
                LBR02PixelRGBA(r);
                r+=GetPixelChannels(image);
             }

             if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
           }

           if (image->storage_class == PseudoClass && image->colormap != NULL)
           {
             for (i=0; i < (ssize_t) image->colors; i++)
             {
               LBR02PacketRGBO(image->colormap[i]);
             }
           }
         }
       else
         {
           /* Scale to 1-bit */
           LBR01PacketRGBO(image->background_color);

           for (y=0; y < (ssize_t) image->rows; y++)
           {
             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

             if (r == (Quantum *) NULL)
               break;

             for (x=0; x < (ssize_t) image->columns; x++)
             {
                LBR01PixelRGBA(r);
                r+=GetPixelChannels(image);
             }

             if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
           }

           if (image->storage_class == PseudoClass && image->colormap != NULL)
           {
             for (i=0; i < (ssize_t) image->colors; i++)
             {
               LBR01PacketRGBO(image->colormap[i]);
             }
           }
         }
    }

  /* To do: set to next higher multiple of 8 */
  if (image->depth < 8)
     image->depth=8;

#if (MAGICKCORE_QUANTUM_DEPTH > 16)
  /* PNG does not handle depths greater than 16 so reduce it even
   * if lossy
   */
  if (image->depth > 8)
      image->depth=16;
#endif

#if (MAGICKCORE_QUANTUM_DEPTH > 8)
  if (image->depth > 8)
    {
      /* To do: fill low byte properly */
      image->depth=16;
    }

  if (image->depth == 16 && mng_info->write_png_depth != 16)
    if (mng_info->write_png8 ||
        LosslessReduceDepthOK(image,exception) != MagickFalse)
      image->depth = 8;
#endif

  image_colors = (int) image->colors;
  number_opaque = (int) image->colors;
  number_transparent = 0;
  number_semitransparent = 0;

  if (mng_info->write_png_colortype &&
     (mng_info->write_png_colortype > 4 || (mng_info->write_png_depth >= 8 &&
     mng_info->write_png_colortype < 4 &&
     image->alpha_trait == UndefinedPixelTrait)))
  {
     /* Avoid the expensive BUILD_PALETTE operation if we're sure that we
      * are not going to need the result.
      */
     if (mng_info->write_png_colortype == 1 ||
        mng_info->write_png_colortype == 5)
       ping_have_color=MagickFalse;

     if (image->alpha_trait != UndefinedPixelTrait)
       {
         number_transparent = 2;
         number_semitransparent = 1;
       }
  }

  if (mng_info->write_png_colortype < 7)
  {
  /* BUILD_PALETTE
   *
   * Normally we run this just once, but in the case of writing PNG8
   * we reduce the transparency to binary and run again, then if there
   * are still too many colors we reduce to a simple 4-4-4-1, then 3-3-3-1
   * RGBA palette and run again, and then to a simple 3-3-2-1 RGBA
   * palette.  Then (To do) we take care of a final reduction that is only
   * needed if there are still 256 colors present and one of them has both
   * transparent and opaque instances.
   */

  tried_332 = MagickFalse;
  tried_333 = MagickFalse;
  tried_444 = MagickFalse;

  for (j=0; j<6; j++)
  {
    /*
     * Sometimes we get DirectClass images that have 256 colors or fewer.
     * This code will build a colormap.
     *
     * Also, sometimes we get PseudoClass images with an out-of-date
     * colormap.  This code will replace the colormap with a new one.
     * Sometimes we get PseudoClass images that have more than 256 colors.
     * This code will delete the colormap and change the image to
     * DirectClass.
     *
     * If image->alpha_trait is MagickFalse, we ignore the alpha channel
     * even though it sometimes contains left-over non-opaque values.
     *
     * Also we gather some information (number of opaque, transparent,
     * and semitransparent pixels, and whether the image has any non-gray
     * pixels or only black-and-white pixels) that we might need later.
     *
     * Even if the user wants to force GrayAlpha or RGBA (colortype 4 or 6)
     * we need to check for bogus non-opaque values, at least.
     */

   int
     n;

   PixelInfo
     opaque[260],
     semitransparent[260],
     transparent[260];

   register const Quantum
     *s;

   register Quantum
     *q,
     *r;

   if (logging != MagickFalse)
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    Enter BUILD_PALETTE:"");

   if (logging != MagickFalse)
     {
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      image->columns=%.20g"",(double) image->columns);
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      image->rows=%.20g"",(double) image->rows);
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      image->alpha_trait=%.20g"",(double) image->alpha_trait);
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      image->depth=%.20g"",(double) image->depth);

       if (image->storage_class == PseudoClass && image->colormap != NULL)
       {
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      Original colormap:"");
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""        i    (red,green,blue,alpha)"");

         for (i=0; i < 256; i++)
         {
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""        %d    (%d,%d,%d,%d)"",
                    (int) i,
                    (int) image->colormap[i].red,
                    (int) image->colormap[i].green,
                    (int) image->colormap[i].blue,
                    (int) image->colormap[i].alpha);
         }

         for (i=image->colors - 10; i < (ssize_t) image->colors; i++)
         {
           if (i > 255)
             {
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""        %d    (%d,%d,%d,%d)"",
                    (int) i,
                    (int) image->colormap[i].red,
                    (int) image->colormap[i].green,
                    (int) image->colormap[i].blue,
                    (int) image->colormap[i].alpha);
             }
         }
       }

       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""      image->colors=%d"",(int) image->colors);

       if (image->colors == 0)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""        (zero means unknown)"");

       if (ping_preserve_colormap == MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""      Regenerate the colormap"");
     }

     image_colors=0;
     number_opaque = 0;
     number_semitransparent = 0;
     number_transparent = 0;

     for (y=0; y < (ssize_t) image->rows; y++)
     {
       q=GetAuthenticPixels(image,0,y,image->columns,1,exception);

       if (q == (Quantum *) NULL)
         break;

       for (x=0; x < (ssize_t) image->columns; x++)
       {
           if (image->alpha_trait == UndefinedPixelTrait ||
              GetPixelAlpha(image,q) == OpaqueAlpha)
             {
               if (number_opaque < 259)
                 {
                   if (number_opaque == 0)
                     {
                       GetPixelInfoPixel(image, q, opaque);
                       opaque[0].alpha=OpaqueAlpha;
                       number_opaque=1;
                     }

                   for (i=0; i< (ssize_t) number_opaque; i++)
                     {
                       if (Magick_png_color_equal(image,q,opaque+i))
                         break;
                     }

                   if (i ==  (ssize_t) number_opaque && number_opaque < 259)
                     {
                       number_opaque++;
                       GetPixelInfoPixel(image, q, opaque+i);
                       opaque[i].alpha=OpaqueAlpha;
                     }
                 }
             }
           else if (GetPixelAlpha(image,q) == TransparentAlpha)
             {
               if (number_transparent < 259)
                 {
                   if (number_transparent == 0)
                     {
                       GetPixelInfoPixel(image, q, transparent);
                       ping_trans_color.red=(unsigned short)
                         GetPixelRed(image,q);
                       ping_trans_color.green=(unsigned short)
                         GetPixelGreen(image,q);
                       ping_trans_color.blue=(unsigned short)
                         GetPixelBlue(image,q);
                       ping_trans_color.gray=(unsigned short)
                         GetPixelGray(image,q);
                       number_transparent = 1;
                     }

                   for (i=0; i< (ssize_t) number_transparent; i++)
                     {
                       if (Magick_png_color_equal(image,q,transparent+i))
                         break;
                     }

                   if (i ==  (ssize_t) number_transparent &&
                       number_transparent < 259)
                     {
                       number_transparent++;
                       GetPixelInfoPixel(image,q,transparent+i);
                     }
                 }
             }
           else
             {
               if (number_semitransparent < 259)
                 {
                   if (number_semitransparent == 0)
                     {
                       GetPixelInfoPixel(image,q,semitransparent);
                       number_semitransparent = 1;
                     }

                   for (i=0; i< (ssize_t) number_semitransparent; i++)
                     {
                       if (Magick_png_color_equal(image,q,semitransparent+i)
                           && GetPixelAlpha(image,q) ==
                           semitransparent[i].alpha)
                         break;
                     }

                   if (i ==  (ssize_t) number_semitransparent &&
                       number_semitransparent < 259)
                     {
                       number_semitransparent++;
                       GetPixelInfoPixel(image, q, semitransparent+i);
                     }
                 }
             }
           q+=GetPixelChannels(image);
        }
     }

     if (mng_info->write_png8 == MagickFalse &&
         ping_exclude_bKGD == MagickFalse)
       {
         /* Add the background color to the palette, if it
          * isn't already there.
          */
          if (logging != MagickFalse)
            {
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      Check colormap for background (%d,%d,%d)"",
                  (int) image->background_color.red,
                  (int) image->background_color.green,
                  (int) image->background_color.blue);
            }
          for (i=0; i<number_opaque; i++)
          {
             if (opaque[i].red == image->background_color.red &&
                 opaque[i].green == image->background_color.green &&
                 opaque[i].blue == image->background_color.blue)
               break;
          }
          if (number_opaque < 259 && i == number_opaque)
            {
               opaque[i] = image->background_color;
               ping_background.index = i;
               number_opaque++;
               if (logging != MagickFalse)
                 {
                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                       ""      background_color index is %d"",(int) i);
                 }

            }
          else if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      No room in the colormap to add background color"");
       }

     image_colors=number_opaque+number_transparent+number_semitransparent;

     if (logging != MagickFalse)
       {
         if (image_colors > 256)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      image has more than 256 colors"");

         else
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      image has %d colors"",image_colors);
       }

     if (ping_preserve_colormap != MagickFalse)
       break;

     if (mng_info->write_png_colortype != 7) /* We won't need this info */
       {
         ping_have_color=MagickFalse;
         ping_have_non_bw=MagickFalse;

         if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
         {
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""incompatible colorspace"");
           ping_have_color=MagickTrue;
           ping_have_non_bw=MagickTrue;
         }

         if(image_colors > 256)
           {
             for (y=0; y < (ssize_t) image->rows; y++)
             {
               q=GetAuthenticPixels(image,0,y,image->columns,1,exception);

               if (q == (Quantum *) NULL)
                 break;

               s=q;
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                 if (GetPixelRed(image,s) != GetPixelGreen(image,s) ||
                     GetPixelRed(image,s) != GetPixelBlue(image,s))
                   {
                      ping_have_color=MagickTrue;
                      ping_have_non_bw=MagickTrue;
                      break;
                   }
                 s+=GetPixelChannels(image);
               }

               if (ping_have_color != MagickFalse)
                 break;

               /* Worst case is black-and-white; we are looking at every
                * pixel twice.
                */

               if (ping_have_non_bw == MagickFalse)
                 {
                   s=q;
                   for (x=0; x < (ssize_t) image->columns; x++)
                   {
                     if (GetPixelRed(image,s) != 0 &&
                         GetPixelRed(image,s) != QuantumRange)
                       {
                         ping_have_non_bw=MagickTrue;
                         break;
                       }
                     s+=GetPixelChannels(image);
                   }
               }
             }
           }
       }

     if (image_colors < 257)
       {
         PixelInfo
           colormap[260];

         /*
          * Initialize image colormap.
          */

         if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      Sort the new colormap"");

        /* Sort palette, transparent first */;

         n = 0;

         for (i=0; i<number_transparent; i++)
            colormap[n++] = transparent[i];

         for (i=0; i<number_semitransparent; i++)
            colormap[n++] = semitransparent[i];

         for (i=0; i<number_opaque; i++)
            colormap[n++] = opaque[i];

         ping_background.index +=
           (number_transparent + number_semitransparent);

         /* image_colors < 257; search the colormap instead of the pixels
          * to get ping_have_color and ping_have_non_bw
          */
         for (i=0; i<n; i++)
         {
           if (ping_have_color == MagickFalse)
             {
                if (colormap[i].red != colormap[i].green ||
                    colormap[i].red != colormap[i].blue)
                  {
                     ping_have_color=MagickTrue;
                     ping_have_non_bw=MagickTrue;
                     break;
                  }
              }

           if (ping_have_non_bw == MagickFalse)
             {
               if (colormap[i].red != 0 && colormap[i].red != QuantumRange)
                   ping_have_non_bw=MagickTrue;
             }
          }

        if ((mng_info->ping_exclude_tRNS == MagickFalse ||
            (number_transparent == 0 && number_semitransparent == 0)) &&
            (((mng_info->write_png_colortype-1) ==
            PNG_COLOR_TYPE_PALETTE) ||
            (mng_info->write_png_colortype == 0)))
          {
            if (logging != MagickFalse)
              {
                if (n !=  (ssize_t) image_colors)
                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""   image_colors (%d) and n (%d)  don't match"",
                   image_colors, n);

                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      AcquireImageColormap"");
              }

            image->colors = image_colors;

            if (AcquireImageColormap(image,image_colors,exception) ==
                MagickFalse)
               ThrowWriterException(ResourceLimitError,
                   ""MemoryAllocationFailed"");

            for (i=0; i< (ssize_t) image_colors; i++)
               image->colormap[i] = colormap[i];

            if (logging != MagickFalse)
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                      ""      image->colors=%d (%d)"",
                      (int) image->colors, image_colors);

                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                      ""      Update the pixel indexes"");
              }

            /* Sync the pixel indices with the new colormap */

            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);

              if (q == (Quantum *) NULL)
                break;

              for (x=0; x < (ssize_t) image->columns; x++)
              {
                for (i=0; i< (ssize_t) image_colors; i++)
                {
                  if ((image->alpha_trait == UndefinedPixelTrait ||
                      image->colormap[i].alpha == GetPixelAlpha(image,q)) &&
                      image->colormap[i].red == GetPixelRed(image,q) &&
                      image->colormap[i].green == GetPixelGreen(image,q) &&
                      image->colormap[i].blue == GetPixelBlue(image,q))
                  {
                    SetPixelIndex(image,i,q);
                    break;
                  }
                }
                q+=GetPixelChannels(image);
              }

              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
            }
          }
       }

     if (logging != MagickFalse)
       {
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""      image->colors=%d"", (int) image->colors);

         if (image->colormap != NULL)
           {
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""       i     (red,green,blue,alpha)"");

             for (i=0; i < (ssize_t) image->colors; i++)
             {
               if (i < 300 || i >= (ssize_t) image->colors - 10)
                 {
                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                       ""       %d     (%d,%d,%d,%d)"",
                        (int) i,
                        (int) image->colormap[i].red,
                        (int) image->colormap[i].green,
                        (int) image->colormap[i].blue,
                        (int) image->colormap[i].alpha);
                 }
             }
           }

           if (number_transparent < 257)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      number_transparent     = %d"",
                   number_transparent);
           else

             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      number_transparent     > 256"");

           if (number_opaque < 257)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      number_opaque          = %d"",
                   number_opaque);

           else
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      number_opaque          > 256"");

           if (number_semitransparent < 257)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      number_semitransparent = %d"",
                   number_semitransparent);

           else
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      number_semitransparent > 256"");

           if (ping_have_non_bw == MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      All pixels and the background are black or white"");

           else if (ping_have_color == MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      All pixels and the background are gray"");

           else
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      At least one pixel or the background is non-gray"");

           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""    Exit BUILD_PALETTE:"");
       }

   if (mng_info->write_png8 == MagickFalse)
      break;

   /* Make any reductions necessary for the PNG8 format */
    if (image_colors <= 256 &&
        image_colors != 0 && image->colormap != NULL &&
        number_semitransparent == 0 &&
        number_transparent <= 1)
      break;

    /* PNG8 can't have semitransparent colors so we threshold the
     * opacity to 0 or OpaqueOpacity, and PNG8 can only have one
     * transparent color so if more than one is transparent we merge
     * them into image->background_color.
     */
    if (number_semitransparent != 0 || number_transparent > 1)
      {
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Thresholding the alpha channel to binary"");

        for (y=0; y < (ssize_t) image->rows; y++)
        {
          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

          if (r == (Quantum *) NULL)
            break;

          for (x=0; x < (ssize_t) image->columns; x++)
          {
              if (GetPixelAlpha(image,r) < OpaqueAlpha/2)
                {
                  SetPixelViaPixelInfo(image,&image->background_color,r);
                  SetPixelAlpha(image,TransparentAlpha,r);
                }
              else
                  SetPixelAlpha(image,OpaqueAlpha,r);
              r+=GetPixelChannels(image);
          }

          if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;

          if (image_colors != 0 && image_colors <= 256 &&
             image->colormap != NULL)
            for (i=0; i<image_colors; i++)
                image->colormap[i].alpha =
                    (image->colormap[i].alpha > TransparentAlpha/2 ?
                    TransparentAlpha : OpaqueAlpha);
        }
      continue;
    }

    /* PNG8 can't have more than 256 colors so we quantize the pixels and
     * background color to the 4-4-4-1, 3-3-3-1 or 3-3-2-1 palette.  If the
     * image is mostly gray, the 4-4-4-1 palette is likely to end up with 256
     * colors or less.
     */
    if (tried_444 == MagickFalse && (image_colors == 0 || image_colors > 256))
      {
        if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""    Quantizing the background color to 4-4-4"");

        tried_444 = MagickTrue;

        LBR04PacketRGB(image->background_color);

        if (logging != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    Quantizing the pixel colors to 4-4-4"");

        if (image->colormap == NULL)
        {
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

            if (r == (Quantum *) NULL)
              break;

            for (x=0; x < (ssize_t) image->columns; x++)
            {
              if (GetPixelAlpha(image,r) == OpaqueAlpha)
                  LBR04PixelRGB(r);
              r+=GetPixelChannels(image);
            }

            if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
          }
        }

        else /* Should not reach this; colormap already exists and
                must be <= 256 */
        {
          if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    Quantizing the colormap to 4-4-4"");

          for (i=0; i<image_colors; i++)
          {
            LBR04PacketRGB(image->colormap[i]);
          }
        }
        continue;
      }

    if (tried_333 == MagickFalse && (image_colors == 0 || image_colors > 256))
      {
        if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""    Quantizing the background color to 3-3-3"");

        tried_333 = MagickTrue;

        LBR03PacketRGB(image->background_color);

        if (logging != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    Quantizing the pixel colors to 3-3-3-1"");

        if (image->colormap == NULL)
        {
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

            if (r == (Quantum *) NULL)
              break;

            for (x=0; x < (ssize_t) image->columns; x++)
            {
              if (GetPixelAlpha(image,r) == OpaqueAlpha)
                  LBR03RGB(r);
              r+=GetPixelChannels(image);
            }

            if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
          }
        }

        else /* Should not reach this; colormap already exists and
                must be <= 256 */
        {
          if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    Quantizing the colormap to 3-3-3-1"");
          for (i=0; i<image_colors; i++)
          {
              LBR03PacketRGB(image->colormap[i]);
          }
        }
        continue;
      }

    if (tried_332 == MagickFalse && (image_colors == 0 || image_colors > 256))
      {
        if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""    Quantizing the background color to 3-3-2"");

        tried_332 = MagickTrue;

        /* Red and green were already done so we only quantize the blue
         * channel
         */

        LBR02PacketBlue(image->background_color);

        if (logging != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    Quantizing the pixel colors to 3-3-2-1"");

        if (image->colormap == NULL)
        {
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

            if (r == (Quantum *) NULL)
              break;

            for (x=0; x < (ssize_t) image->columns; x++)
            {
              if (GetPixelAlpha(image,r) == OpaqueAlpha)
                  LBR02PixelBlue(r);
              r+=GetPixelChannels(image);
            }

            if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
          }
        }

        else /* Should not reach this; colormap already exists and
                must be <= 256 */
        {
          if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    Quantizing the colormap to 3-3-2-1"");
          for (i=0; i<image_colors; i++)
          {
              LBR02PacketBlue(image->colormap[i]);
          }
      }
      continue;
    }

    if (image_colors == 0 || image_colors > 256)
    {
      /* Take care of special case with 256 opaque colors + 1 transparent
       * color.  We don't need to quantize to 2-3-2-1; we only need to
       * eliminate one color, so we'll merge the two darkest red
       * colors (0x49, 0, 0) -> (0x24, 0, 0).
       */
      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Merging two dark red background colors to 3-3-2-1"");

      if (ScaleQuantumToChar(image->background_color.red) == 0x49 &&
          ScaleQuantumToChar(image->background_color.green) == 0x00 &&
          ScaleQuantumToChar(image->background_color.blue) == 0x00)
      {
         image->background_color.red=ScaleCharToQuantum(0x24);
      }

      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Merging two dark red pixel colors to 3-3-2-1"");

      if (image->colormap == NULL)
      {
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

          if (r == (Quantum *) NULL)
            break;

          for (x=0; x < (ssize_t) image->columns; x++)
          {
            if (ScaleQuantumToChar(GetPixelRed(image,r)) == 0x49 &&
                ScaleQuantumToChar(GetPixelGreen(image,r)) == 0x00 &&
                ScaleQuantumToChar(GetPixelBlue(image,r)) == 0x00 &&
                GetPixelAlpha(image,r) == OpaqueAlpha)
              {
                SetPixelRed(image,ScaleCharToQuantum(0x24),r);
              }
            r+=GetPixelChannels(image);
          }

          if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;

        }
      }

      else
      {
         for (i=0; i<image_colors; i++)
         {
            if (ScaleQuantumToChar(image->colormap[i].red) == 0x49 &&
                ScaleQuantumToChar(image->colormap[i].green) == 0x00 &&
                ScaleQuantumToChar(image->colormap[i].blue) == 0x00)
            {
               image->colormap[i].red=ScaleCharToQuantum(0x24);
            }
         }
      }
    }
  }
  }
  /* END OF BUILD_PALETTE */

  /* If we are excluding the tRNS chunk and there is transparency,
   * then we must write a Gray-Alpha (color-type 4) or RGBA (color-type 6)
   * PNG.
   */
  if (mng_info->ping_exclude_tRNS != MagickFalse &&
     (number_transparent != 0 || number_semitransparent != 0))
    {
      unsigned int colortype=mng_info->write_png_colortype;

      if (ping_have_color == MagickFalse)
        mng_info->write_png_colortype = 5;

      else
        mng_info->write_png_colortype = 7;

      if (colortype != 0 &&
         mng_info->write_png_colortype != colortype)
        ping_need_colortype_warning=MagickTrue;

    }

  /* See if cheap transparency is possible.  It is only possible
   * when there is a single transparent color, no semitransparent
   * color, and no opaque color that has the same RGB components
   * as the transparent color.  We only need this information if
   * we are writing a PNG with colortype 0 or 2, and we have not
   * excluded the tRNS chunk.
   */
  if (number_transparent == 1 &&
      mng_info->write_png_colortype < 4)
    {
       ping_have_cheap_transparency = MagickTrue;

       if (number_semitransparent != 0)
         ping_have_cheap_transparency = MagickFalse;

       else if (image_colors == 0 || image_colors > 256 ||
           image->colormap == NULL)
         {
           register const Quantum
             *q;

           for (y=0; y < (ssize_t) image->rows; y++)
           {
             q=GetVirtualPixels(image,0,y,image->columns,1, exception);

             if (q == (Quantum *) NULL)
               break;

             for (x=0; x < (ssize_t) image->columns; x++)
             {
                 if (GetPixelAlpha(image,q) != TransparentAlpha &&
                     (unsigned short) GetPixelRed(image,q) ==
                                     ping_trans_color.red &&
                     (unsigned short) GetPixelGreen(image,q) ==
                                     ping_trans_color.green &&
                     (unsigned short) GetPixelBlue(image,q) ==
                                     ping_trans_color.blue)
                   {
                     ping_have_cheap_transparency = MagickFalse;
                     break;
                   }

                 q+=GetPixelChannels(image);
             }

             if (ping_have_cheap_transparency == MagickFalse)
                break;
           }
         }
       else
         {
            /* Assuming that image->colormap[0] is the one transparent color
             * and that all others are opaque.
             */
            if (image_colors > 1)
              for (i=1; i<image_colors; i++)
                if (image->colormap[i].red == image->colormap[0].red &&
                    image->colormap[i].green == image->colormap[0].green &&
                    image->colormap[i].blue == image->colormap[0].blue)
                  {
                     ping_have_cheap_transparency = MagickFalse;
                     break;
                  }
         }

       if (logging != MagickFalse)
         {
           if (ping_have_cheap_transparency == MagickFalse)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""   Cheap transparency is not possible."");

           else
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""   Cheap transparency is possible."");
         }
     }
  else
    ping_have_cheap_transparency = MagickFalse;

  image_depth=image->depth;

  quantum_info = (QuantumInfo *) NULL;
  number_colors=0;
  image_colors=(int) image->colors;
  image_matte=image->alpha_trait !=
        UndefinedPixelTrait ? MagickTrue : MagickFalse;

  if (mng_info->write_png_colortype < 5)
    mng_info->IsPalette=image->storage_class == PseudoClass &&
      image_colors <= 256 && image->colormap != NULL;
  else
    mng_info->IsPalette = MagickFalse;

  if ((mng_info->write_png_colortype == 4 || mng_info->write_png8) &&
     (image->colors == 0 || image->colormap == NULL))
    {
      image_info=DestroyImageInfo(image_info);
      image=DestroyImage(image);
      (void) ThrowMagickException(exception,GetMagickModule(),CoderError,
          ""Cannot write PNG8 or color-type 3; colormap is NULL"",
          ""`%s'"",IMimage->filename);
      return(MagickFalse);
    }

  /*
    Allocate the PNG structures
  */
#ifdef PNG_USER_MEM_SUPPORTED
 error_info.image=image;
 error_info.exception=exception;
  ping=png_create_write_struct_2(PNG_LIBPNG_VER_STRING,&error_info,
    MagickPNGErrorHandler,MagickPNGWarningHandler,(void *) NULL,
    (png_malloc_ptr) Magick_png_malloc,(png_free_ptr) Magick_png_free);

#else
  ping=png_create_write_struct(PNG_LIBPNG_VER_STRING,&error_info,
    MagickPNGErrorHandler,MagickPNGWarningHandler);

#endif
  if (ping == (png_struct *) NULL)
    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");

  ping_info=png_create_info_struct(ping);

  if (ping_info == (png_info *) NULL)
    {
      png_destroy_write_struct(&ping,(png_info **) NULL);
      ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
    }

  png_set_write_fn(ping,image,png_put_data,png_flush_data);
  pixel_info=(MemoryInfo *) NULL;

  if (setjmp(png_jmpbuf(ping)))
    {
      /*
        PNG write failed.
      */
#ifdef PNG_DEBUG
     if (image_info->verbose)
        (void) printf(""PNG write has failed.\n"");
#endif
      png_destroy_write_struct(&ping,&ping_info);
#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE
      UnlockSemaphoreInfo(ping_semaphore);
#endif

      if (pixel_info != (MemoryInfo *) NULL)
        pixel_info=RelinquishVirtualMemory(pixel_info);

      if (quantum_info != (QuantumInfo *) NULL)
        quantum_info=DestroyQuantumInfo(quantum_info);

      if (ping_have_blob != MagickFalse)
          (void) CloseBlob(image);
      image_info=DestroyImageInfo(image_info);
      image=DestroyImage(image);
      return(MagickFalse);
    }

  /* {  For navigation to end of SETJMP-protected block.  Within this
   *    block, use png_error() instead of Throwing an Exception, to ensure
   *    that libpng is able to clean up, and that the semaphore is unlocked.
   */

#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE
  LockSemaphoreInfo(ping_semaphore);
#endif

#ifdef PNG_BENIGN_ERRORS_SUPPORTED
  /* Allow benign errors */
  png_set_benign_errors(ping, 1);
#endif

#ifdef PNG_SET_USER_LIMITS_SUPPORTED
  /* Reject images with too many rows or columns */
  png_set_user_limits(ping,
    (png_uint_32) MagickMin(0x7fffffffL,
        GetMagickResourceLimit(WidthResource)),
    (png_uint_32) MagickMin(0x7fffffffL,
        GetMagickResourceLimit(HeightResource)));
#endif /* PNG_SET_USER_LIMITS_SUPPORTED */

  /*
    Prepare PNG for writing.
  */

#if defined(PNG_MNG_FEATURES_SUPPORTED)
  if (mng_info->write_mng)
  {
     (void) png_permit_mng_features(ping,PNG_ALL_MNG_FEATURES);
# ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
     /* Disable new libpng-1.5.10 feature when writing a MNG because
      * zero-length PLTE is OK
      */
     png_set_check_for_invalid_index (ping, 0);
# endif
  }

#else
# ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED
  if (mng_info->write_mng)
     png_permit_empty_plte(ping,MagickTrue);

# endif
#endif

  x=0;

  ping_width=(png_uint_32) image->columns;
  ping_height=(png_uint_32) image->rows;

  if (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32)
     image_depth=8;

  if (mng_info->write_png48 || mng_info->write_png64)
     image_depth=16;

  if (mng_info->write_png_depth != 0)
     image_depth=mng_info->write_png_depth;

  /* Adjust requested depth to next higher valid depth if necessary */
  if (image_depth > 8)
     image_depth=16;

  if ((image_depth > 4) && (image_depth < 8))
     image_depth=8;

  if (image_depth == 3)
     image_depth=4;

  if (logging != MagickFalse)
    {
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    width=%.20g"",(double) ping_width);
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    height=%.20g"",(double) ping_height);
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    image_matte=%.20g"",(double) image->alpha_trait);
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    image->depth=%.20g"",(double) image->depth);
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    Tentative ping_bit_depth=%.20g"",(double) image_depth);
    }

  save_image_depth=image_depth;
  ping_bit_depth=(png_byte) save_image_depth;


#if defined(PNG_pHYs_SUPPORTED)
  if (ping_exclude_pHYs == MagickFalse)
  {
  if ((image->resolution.x != 0) && (image->resolution.y != 0) &&
      (!mng_info->write_mng || !mng_info->equal_physs))
    {
      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Setting up pHYs chunk"");

      if (image->units == PixelsPerInchResolution)
        {
          ping_pHYs_unit_type=PNG_RESOLUTION_METER;
          ping_pHYs_x_resolution=
             (png_uint_32) ((100.0*image->resolution.x+0.5)/2.54);
          ping_pHYs_y_resolution=
             (png_uint_32) ((100.0*image->resolution.y+0.5)/2.54);
        }

      else if (image->units == PixelsPerCentimeterResolution)
        {
          ping_pHYs_unit_type=PNG_RESOLUTION_METER;
          ping_pHYs_x_resolution=(png_uint_32) (100.0*image->resolution.x+0.5);
          ping_pHYs_y_resolution=(png_uint_32) (100.0*image->resolution.y+0.5);
        }

      else
        {
          ping_pHYs_unit_type=PNG_RESOLUTION_UNKNOWN;
          ping_pHYs_x_resolution=(png_uint_32) image->resolution.x;
          ping_pHYs_y_resolution=(png_uint_32) image->resolution.y;
        }

      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    Set up PNG pHYs chunk: xres: %.20g, yres: %.20g, units: %d."",
          (double) ping_pHYs_x_resolution,(double) ping_pHYs_y_resolution,
          (int) ping_pHYs_unit_type);
       ping_have_pHYs = MagickTrue;
    }
  }
#endif

  if (ping_exclude_bKGD == MagickFalse)
  {
  if ((!mng_info->adjoin || !mng_info->equal_backgrounds))
    {
       unsigned int
         mask;

       mask=0xffff;
       if (ping_bit_depth == 8)
          mask=0x00ff;

       if (ping_bit_depth == 4)
          mask=0x000f;

       if (ping_bit_depth == 2)
          mask=0x0003;

       if (ping_bit_depth == 1)
          mask=0x0001;

       ping_background.red=(png_uint_16)
         (ScaleQuantumToShort(image->background_color.red) & mask);

       ping_background.green=(png_uint_16)
         (ScaleQuantumToShort(image->background_color.green) & mask);

       ping_background.blue=(png_uint_16)
         (ScaleQuantumToShort(image->background_color.blue) & mask);

       ping_background.gray=(png_uint_16) ping_background.green;
    }

  if (logging != MagickFalse)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    Setting up bKGD chunk (1)"");
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""      background_color index is %d"",
          (int) ping_background.index);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    ping_bit_depth=%d"",ping_bit_depth);
    }

  ping_have_bKGD = MagickTrue;
  }

  /*
    Select the color type.
  */
  matte=image_matte;
  old_bit_depth=0;

  if (mng_info->IsPalette && mng_info->write_png8)
    {
      /* To do: make this a function cause it's used twice, except
         for reducing the sample depth from 8. */

      number_colors=image_colors;

      ping_have_tRNS=MagickFalse;

      /*
        Set image palette.
      */
      ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;

      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  Setting up PLTE chunk with %d colors (%d)"",
            number_colors, image_colors);

      for (i=0; i < (ssize_t) number_colors; i++)
      {
        palette[i].red=ScaleQuantumToChar(image->colormap[i].red);
        palette[i].green=ScaleQuantumToChar(image->colormap[i].green);
        palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);
        if (logging != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
#if MAGICKCORE_QUANTUM_DEPTH == 8
            ""    %3ld (%3d,%3d,%3d)"",
#else
            ""    %5ld (%5d,%5d,%5d)"",
#endif
            (long) i,palette[i].red,palette[i].green,palette[i].blue);

      }

      ping_have_PLTE=MagickTrue;
      image_depth=ping_bit_depth;
      ping_num_trans=0;

      if (matte != MagickFalse)
      {
          /*
            Identify which colormap entry is transparent.
          */
          assert(number_colors <= 256);
          assert(image->colormap != NULL);

          for (i=0; i < (ssize_t) number_transparent; i++)
             ping_trans_alpha[i]=0;


          ping_num_trans=(unsigned short) (number_transparent +
             number_semitransparent);

          if (ping_num_trans == 0)
             ping_have_tRNS=MagickFalse;

          else
             ping_have_tRNS=MagickTrue;
      }

      if (ping_exclude_bKGD == MagickFalse)
      {
       /*
        * Identify which colormap entry is the background color.
        */

        for (i=0; i < (ssize_t) MagickMax(1L*number_colors-1L,1L); i++)
          if (IsPNGColorEqual(ping_background,image->colormap[i]))
            break;

        ping_background.index=(png_byte) i;

        if (logging != MagickFalse)
          {
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""      background_color index is %d"",
                 (int) ping_background.index);
          }
      }
    } /* end of write_png8 */

  else if (mng_info->write_png_colortype == 1)
    {
      image_matte=MagickFalse;
      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;
    }

  else if (mng_info->write_png24 || mng_info->write_png48 ||
      mng_info->write_png_colortype == 3)
    {
      image_matte=MagickFalse;
      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;
    }

  else if (mng_info->write_png32 || mng_info->write_png64 ||
      mng_info->write_png_colortype == 7)
    {
      image_matte=MagickTrue;
      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;
    }

  else /* mng_info->write_pngNN not specified */
    {
      image_depth=ping_bit_depth;

      if (mng_info->write_png_colortype != 0)
        {
          ping_color_type=(png_byte) mng_info->write_png_colortype-1;

          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            image_matte=MagickTrue;

          else
            image_matte=MagickFalse;

          if (logging != MagickFalse)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""   PNG colortype %d was specified:"",(int) ping_color_type);
        }

      else /* write_png_colortype not specified */
        {
          if (logging != MagickFalse)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  Selecting PNG colortype:"");

          ping_color_type=(png_byte) ((matte != MagickFalse)?
            PNG_COLOR_TYPE_RGB_ALPHA:PNG_COLOR_TYPE_RGB);

          if (image_info->type == TrueColorType)
            {
              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;
              image_matte=MagickFalse;
            }

          if (image_info->type == TrueColorAlphaType)
            {
              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;
              image_matte=MagickTrue;
            }

          if (image_info->type == PaletteType ||
              image_info->type == PaletteAlphaType)
            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;

          if (mng_info->write_png_colortype == 0 &&
             image_info->type == UndefinedType)
            {
              if (ping_have_color == MagickFalse)
                {
                  if (image_matte == MagickFalse)
                    {
                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;
                      image_matte=MagickFalse;
                    }

                  else
                    {
                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY_ALPHA;
                      image_matte=MagickTrue;
                    }
                }
              else
                {
                  if (image_matte == MagickFalse)
                    {
                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;
                      image_matte=MagickFalse;
                    }

                  else
                    {
                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGBA;
                      image_matte=MagickTrue;
                    }
                 }
            }

        }

      if (logging != MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    Selected PNG colortype=%d"",ping_color_type);

      if (ping_bit_depth < 8)
        {
          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
              ping_color_type == PNG_COLOR_TYPE_RGB ||
              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            ping_bit_depth=8;
        }

      old_bit_depth=ping_bit_depth;

      if (ping_color_type == PNG_COLOR_TYPE_GRAY)
        {
          if (image->alpha_trait == UndefinedPixelTrait &&
               ping_have_non_bw == MagickFalse)
             ping_bit_depth=1;
        }

      if (ping_color_type == PNG_COLOR_TYPE_PALETTE)
        {
           size_t one = 1;
           ping_bit_depth=1;

           if (image->colors == 0)
           {
              /* DO SOMETHING */
                png_error(ping,""image has 0 colors"");
           }

           while ((int) (one << ping_bit_depth) < (ssize_t) image_colors)
             ping_bit_depth <<= 1;
        }

      if (logging != MagickFalse)
         {
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Number of colors: %.20g"",(double) image_colors);

           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Tentative PNG bit depth: %d"",ping_bit_depth);
         }

      if (ping_bit_depth < (int) mng_info->write_png_depth)
         ping_bit_depth = mng_info->write_png_depth;
    }

  image_depth=ping_bit_depth;

  if (logging != MagickFalse)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    Tentative PNG color type: %s (%.20g)"",
        PngColorTypeToString(ping_color_type),
        (double) ping_color_type);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    image_info->type: %.20g"",(double) image_info->type);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    image_depth: %.20g"",(double) image_depth);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),

        ""    image->depth: %.20g"",(double) image->depth);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    ping_bit_depth: %.20g"",(double) ping_bit_depth);
    }

  if (matte != MagickFalse)
    {
      if (mng_info->IsPalette)
        {
          if (mng_info->write_png_colortype == 0)
            {
              ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;

              if (ping_have_color != MagickFalse)
                 ping_color_type=PNG_COLOR_TYPE_RGBA;
            }

          /*
           * Determine if there is any transparent color.
          */
          if (number_transparent + number_semitransparent == 0)
            {
              /*
                No transparent pixels are present.  Change 4 or 6 to 0 or 2.
              */

              image_matte=MagickFalse;

              if (mng_info->write_png_colortype == 0)
                ping_color_type&=0x03;
            }

          else
            {
              unsigned int
                mask;

              mask=0xffff;

              if (ping_bit_depth == 8)
                 mask=0x00ff;

              if (ping_bit_depth == 4)
                 mask=0x000f;

              if (ping_bit_depth == 2)
                 mask=0x0003;

              if (ping_bit_depth == 1)
                 mask=0x0001;

              ping_trans_color.red=(png_uint_16)
                (ScaleQuantumToShort(image->colormap[0].red) & mask);

              ping_trans_color.green=(png_uint_16)
                (ScaleQuantumToShort(image->colormap[0].green) & mask);

              ping_trans_color.blue=(png_uint_16)
                (ScaleQuantumToShort(image->colormap[0].blue) & mask);

              ping_trans_color.gray=(png_uint_16)
                (ScaleQuantumToShort(GetPixelInfoIntensity(image,
                   image->colormap)) & mask);

              ping_trans_color.index=(png_byte) 0;

              ping_have_tRNS=MagickTrue;
            }

          if (ping_have_tRNS != MagickFalse)
            {
              /*
               * Determine if there is one and only one transparent color
               * and if so if it is fully transparent.
               */
              if (ping_have_cheap_transparency == MagickFalse)
                ping_have_tRNS=MagickFalse;
            }

          if (ping_have_tRNS != MagickFalse)
            {
              if (mng_info->write_png_colortype == 0)
                ping_color_type &= 0x03;  /* changes 4 or 6 to 0 or 2 */

              if (image_depth == 8)
                {
                  ping_trans_color.red&=0xff;
                  ping_trans_color.green&=0xff;
                  ping_trans_color.blue&=0xff;
                  ping_trans_color.gray&=0xff;
                }
            }
        }
      else
        {
          if (image_depth == 8)
            {
              ping_trans_color.red&=0xff;
              ping_trans_color.green&=0xff;
              ping_trans_color.blue&=0xff;
              ping_trans_color.gray&=0xff;
            }
        }
    }

    matte=image_matte;

    if (ping_have_tRNS != MagickFalse)
      image_matte=MagickFalse;

    if ((mng_info->IsPalette) &&
        mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE &&
        ping_have_color == MagickFalse &&
        (image_matte == MagickFalse || image_depth >= 8))
      {
        size_t one=1;

        if (image_matte != MagickFalse)
          ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;

        else if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_GRAY_ALPHA)
          {
            ping_color_type=PNG_COLOR_TYPE_GRAY;

            if (save_image_depth == 16 && image_depth == 8)
              {
                if (logging != MagickFalse)
                  {
                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                        ""  Scaling ping_trans_color (0)"");
                  }
                    ping_trans_color.gray*=0x0101;
              }
          }

        if (image_depth > MAGICKCORE_QUANTUM_DEPTH)
          image_depth=MAGICKCORE_QUANTUM_DEPTH;

        if ((image_colors == 0) ||
             ((ssize_t) (image_colors-1) > (ssize_t) MaxColormapSize))
          image_colors=(int) (one << image_depth);

        if (image_depth > 8)
          ping_bit_depth=16;

        else
          {
            ping_bit_depth=8;
            if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)
              {
                if(!mng_info->write_png_depth)
                  {
                    ping_bit_depth=1;

                    while ((int) (one << ping_bit_depth)
                        < (ssize_t) image_colors)
                      ping_bit_depth <<= 1;
                  }
              }

            else if (ping_color_type ==
                PNG_COLOR_TYPE_GRAY && image_colors < 17 &&
                mng_info->IsPalette)
              {
              /* Check if grayscale is reducible */

                int
                  depth_4_ok=MagickTrue,
                  depth_2_ok=MagickTrue,
                  depth_1_ok=MagickTrue;

                for (i=0; i < (ssize_t) image_colors; i++)
                {
                   unsigned char
                     intensity;

                   intensity=ScaleQuantumToChar(image->colormap[i].red);

                   if ((intensity & 0x0f) != ((intensity & 0xf0) >> 4))
                     depth_4_ok=depth_2_ok=depth_1_ok=MagickFalse;
                   else if ((intensity & 0x03) != ((intensity & 0x0c) >> 2))
                     depth_2_ok=depth_1_ok=MagickFalse;
                   else if ((intensity & 0x01) != ((intensity & 0x02) >> 1))
                     depth_1_ok=MagickFalse;
                }

                if (depth_1_ok && mng_info->write_png_depth <= 1)
                  ping_bit_depth=1;

                else if (depth_2_ok && mng_info->write_png_depth <= 2)
                  ping_bit_depth=2;

                else if (depth_4_ok && mng_info->write_png_depth <= 4)
                  ping_bit_depth=4;
              }
          }

          image_depth=ping_bit_depth;
      }

    else

      if (mng_info->IsPalette)
      {
        number_colors=image_colors;

        if (image_depth <= 8)
          {
            /*
              Set image palette.
            */
            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;

            if (!(mng_info->have_write_global_plte && matte == MagickFalse))
              {
                for (i=0; i < (ssize_t) number_colors; i++)
                {
                  palette[i].red=ScaleQuantumToChar(image->colormap[i].red);
                  palette[i].green=
                    ScaleQuantumToChar(image->colormap[i].green);
                  palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);
                }

                if (logging != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""  Setting up PLTE chunk with %d colors"",
                    number_colors);

                ping_have_PLTE=MagickTrue;
              }

            /* color_type is PNG_COLOR_TYPE_PALETTE */
            if (mng_info->write_png_depth == 0)
              {
                size_t
                  one;

                ping_bit_depth=1;
                one=1;

                while ((one << ping_bit_depth) < (size_t) number_colors)
                  ping_bit_depth <<= 1;
              }

            ping_num_trans=0;

            if (matte != MagickFalse)
              {
                /*
                 * Set up trans_colors array.
                 */
                assert(number_colors <= 256);

                ping_num_trans=(unsigned short) (number_transparent +
                  number_semitransparent);

                if (ping_num_trans == 0)
                  ping_have_tRNS=MagickFalse;

                else
                  {
                    if (logging != MagickFalse)
                      {
                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                          ""  Scaling ping_trans_color (1)"");
                      }
                    ping_have_tRNS=MagickTrue;

                    for (i=0; i < ping_num_trans; i++)
                    {
                       ping_trans_alpha[i]= (png_byte)
                         ScaleQuantumToChar(image->colormap[i].alpha);
                    }
                  }
              }
          }
      }

    else
      {

        if (image_depth < 8)
          image_depth=8;

        if ((save_image_depth == 16) && (image_depth == 8))
          {
            if (logging != MagickFalse)
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""    Scaling ping_trans_color from (%d,%d,%d)"",
                  (int) ping_trans_color.red,
                  (int) ping_trans_color.green,
                  (int) ping_trans_color.blue);
              }

            ping_trans_color.red*=0x0101;
            ping_trans_color.green*=0x0101;
            ping_trans_color.blue*=0x0101;
            ping_trans_color.gray*=0x0101;

            if (logging != MagickFalse)
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""    to (%d,%d,%d)"",
                  (int) ping_trans_color.red,
                  (int) ping_trans_color.green,
                  (int) ping_trans_color.blue);
              }
          }
      }

    if (ping_bit_depth <  (ssize_t) mng_info->write_png_depth)
         ping_bit_depth =  (ssize_t) mng_info->write_png_depth;

    /*
      Adjust background and transparency samples in sub-8-bit grayscale files.
    */
    if (ping_bit_depth < 8 && ping_color_type ==
        PNG_COLOR_TYPE_GRAY)
      {
         png_uint_16
           maxval;

         size_t
           one=1;

         maxval=(png_uint_16) ((one << ping_bit_depth)-1);

         if (ping_exclude_bKGD == MagickFalse)
         {

         ping_background.gray=(png_uint_16) ((maxval/65535.)*
           (ScaleQuantumToShort(((GetPixelInfoIntensity(image,
           &image->background_color))) +.5)));

         if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  Setting up bKGD chunk (2)"");
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      background_color index is %d"",
             (int) ping_background.index);

         ping_have_bKGD = MagickTrue;
         }

         if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  Scaling ping_trans_color.gray from %d"",
             (int)ping_trans_color.gray);

         ping_trans_color.gray=(png_uint_16) ((maxval/255.)*(
           ping_trans_color.gray)+.5);

         if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      to %d"", (int)ping_trans_color.gray);
      }

  if (ping_exclude_bKGD == MagickFalse)
  {
    if (mng_info->IsPalette && (int) ping_color_type == PNG_COLOR_TYPE_PALETTE)
      {
        /*
           Identify which colormap entry is the background color.
        */

        number_colors=image_colors;

        for (i=0; i < (ssize_t) MagickMax(1L*number_colors,1L); i++)
          if (IsPNGColorEqual(image->background_color,image->colormap[i]))
            break;

        ping_background.index=(png_byte) i;

        if (logging != MagickFalse)
          {
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Setting up bKGD chunk with index=%d"",(int) i);
          }

        if (i < (ssize_t) number_colors)
          {
            ping_have_bKGD = MagickTrue;

            if (logging != MagickFalse)
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""     background   =(%d,%d,%d)"",
                        (int) ping_background.red,
                        (int) ping_background.green,
                        (int) ping_background.blue);
              }
          }

        else  /* Can't happen */
          {
            if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      No room in PLTE to add bKGD color"");
            ping_have_bKGD = MagickFalse;
          }
      }
  }

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""    PNG color type: %s (%d)"", PngColorTypeToString(ping_color_type),
      ping_color_type);
  /*
    Initialize compression level and filtering.
  */
  if (logging != MagickFalse)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""  Setting up deflate compression"");

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    Compression buffer size: 32768"");
    }

  png_set_compression_buffer_size(ping,32768L);

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""    Compression mem level: 9"");

  png_set_compression_mem_level(ping, 9);

  /* Untangle the ""-quality"" setting:

     Undefined is 0; the default is used.
     Default is 75

     10's digit:

        0 or omitted: Use Z_HUFFMAN_ONLY strategy with the
           zlib default compression level

        1-9: the zlib compression level

     1's digit:

        0-4: the PNG filter method

        5:   libpng adaptive filtering if compression level > 5
             libpng filter type ""none"" if compression level <= 5
                or if image is grayscale or palette

        6:   libpng adaptive filtering

        7:   ""LOCO"" filtering (intrapixel differing) if writing
             a MNG, otherwise ""none"".  Did not work in IM-6.7.0-9
             and earlier because of a missing ""else"".

        8:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), adaptive
             filtering. Unused prior to IM-6.7.0-10, was same as 6

        9:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), no PNG filters
             Unused prior to IM-6.7.0-10, was same as 6

    Note that using the -quality option, not all combinations of
    PNG filter type, zlib compression level, and zlib compression
    strategy are possible.  This will be addressed soon in a
    release that accomodates ""-define png:compression-strategy"", etc.

   */

  quality=image_info->quality == UndefinedCompressionQuality ? 75UL :
     image_info->quality;

  if (quality <= 9)
    {
      if (mng_info->write_png_compression_strategy == 0)
        mng_info->write_png_compression_strategy = Z_HUFFMAN_ONLY+1;
    }

  else if (mng_info->write_png_compression_level == 0)
    {
      int
        level;

      level=(int) MagickMin((ssize_t) quality/10,9);

      mng_info->write_png_compression_level = level+1;
    }

  if (mng_info->write_png_compression_strategy == 0)
    {
        if ((quality %10) == 8 || (quality %10) == 9)
#ifdef Z_RLE  /* Z_RLE was added to zlib-1.2.0 */
          mng_info->write_png_compression_strategy=Z_RLE+1;
#else
          mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;
#endif
    }

  if (mng_info->write_png_compression_filter == 0)
        mng_info->write_png_compression_filter=((int) quality % 10) + 1;

  if (logging != MagickFalse)
    {
        if (mng_info->write_png_compression_level)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Compression level:    %d"",
            (int) mng_info->write_png_compression_level-1);

        if (mng_info->write_png_compression_strategy)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Compression strategy: %d"",
            (int) mng_info->write_png_compression_strategy-1);

        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  Setting up filtering"");

        if (mng_info->write_png_compression_filter == 6)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Base filter method: ADAPTIVE"");
        else if (mng_info->write_png_compression_filter == 0 ||
                 mng_info->write_png_compression_filter == 1)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Base filter method: NONE"");
        else
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Base filter method: %d"",
            (int) mng_info->write_png_compression_filter-1);
    }

  if (mng_info->write_png_compression_level != 0)
    png_set_compression_level(ping,mng_info->write_png_compression_level-1);

  if (mng_info->write_png_compression_filter == 6)
    {
      if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||
         ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE) ||
         (quality < 50))
        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);
      else
        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);
     }
  else if (mng_info->write_png_compression_filter == 7 ||
      mng_info->write_png_compression_filter == 10)
    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);

  else if (mng_info->write_png_compression_filter == 8)
    {
#if defined(PNG_MNG_FEATURES_SUPPORTED) && defined(PNG_INTRAPIXEL_DIFFERENCING)
      if (mng_info->write_mng)
      {
         if (((int) ping_color_type == PNG_COLOR_TYPE_RGB) ||
             ((int) ping_color_type == PNG_COLOR_TYPE_RGBA))
        ping_filter_method=PNG_INTRAPIXEL_DIFFERENCING;
      }
#endif
      png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);
    }

  else if (mng_info->write_png_compression_filter == 9)
    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);

  else if (mng_info->write_png_compression_filter != 0)
    png_set_filter(ping,PNG_FILTER_TYPE_BASE,
       mng_info->write_png_compression_filter-1);

  if (mng_info->write_png_compression_strategy != 0)
    png_set_compression_strategy(ping,
       mng_info->write_png_compression_strategy-1);

  ping_interlace_method=image_info->interlace != NoInterlace;

  if (mng_info->write_mng)
    png_set_sig_bytes(ping,8);

  /* Bail out if cannot meet defined png:bit-depth or png:color-type */

  if (mng_info->write_png_colortype != 0)
    {
     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY)
       if (ping_have_color != MagickFalse)
         {
           ping_color_type = PNG_COLOR_TYPE_RGB;

           if (ping_bit_depth < 8)
             ping_bit_depth=8;
         }

     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY_ALPHA)
       if (ping_have_color != MagickFalse)
         ping_color_type = PNG_COLOR_TYPE_RGB_ALPHA;
    }

  if (ping_need_colortype_warning != MagickFalse ||
     ((mng_info->write_png_depth &&
     (int) mng_info->write_png_depth != ping_bit_depth) ||
     (mng_info->write_png_colortype &&
     ((int) mng_info->write_png_colortype-1 != ping_color_type &&
      mng_info->write_png_colortype != 7 &&
      !(mng_info->write_png_colortype == 5 && ping_color_type == 0)))))
    {
      if (logging != MagickFalse)
        {
          if (ping_need_colortype_warning != MagickFalse)
            {
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""  Image has transparency but tRNS chunk was excluded"");
            }

          if (mng_info->write_png_depth)
            {
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Defined png:bit-depth=%u, Computed depth=%u"",
                  mng_info->write_png_depth,
                  ping_bit_depth);
            }

          if (mng_info->write_png_colortype)
            {
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Defined png:color-type=%u, Computed color type=%u"",
                  mng_info->write_png_colortype-1,
                  ping_color_type);
            }
        }

      png_warning(ping,
        ""Cannot write image with defined png:bit-depth or png:color-type."");
    }

  if (image_matte != MagickFalse && image->alpha_trait == UndefinedPixelTrait)
    {
      /* Add an opaque matte channel */
      image->alpha_trait = BlendPixelTrait;
      (void) SetImageAlpha(image,OpaqueAlpha,exception);

      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  Added an opaque matte channel"");
    }

  if (number_transparent != 0 || number_semitransparent != 0)
    {
      if (ping_color_type < 4)
        {
           ping_have_tRNS=MagickTrue;
           if (logging != MagickFalse)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""  Setting ping_have_tRNS=MagickTrue."");
        }
    }

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  Writing PNG header chunks"");

  png_set_IHDR(ping,ping_info,ping_width,ping_height,
               ping_bit_depth,ping_color_type,
               ping_interlace_method,ping_compression_method,
               ping_filter_method);

  if (ping_color_type == 3 && ping_have_PLTE != MagickFalse)
    {
      png_set_PLTE(ping,ping_info,palette,number_colors);

      if (logging != MagickFalse)
        {
          for (i=0; i< (ssize_t) number_colors; i++)
          {
            if (i < ping_num_trans)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""     PLTE[%d] = (%d,%d,%d), tRNS[%d] = (%d)"",
                      (int) i,
                      (int) palette[i].red,
                      (int) palette[i].green,
                      (int) palette[i].blue,
                      (int) i,
                      (int) ping_trans_alpha[i]);
             else
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""     PLTE[%d] = (%d,%d,%d)"",
                      (int) i,
                      (int) palette[i].red,
                      (int) palette[i].green,
                      (int) palette[i].blue);
           }
         }
    }

  /* Only write the iCCP chunk if we are not writing the sRGB chunk. */
  if (ping_exclude_sRGB != MagickFalse ||
     (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))
  {
    if ((ping_exclude_tEXt == MagickFalse ||
       ping_exclude_zTXt == MagickFalse) &&
       (ping_exclude_iCCP == MagickFalse || ping_exclude_zCCP == MagickFalse))
    {
      ResetImageProfileIterator(image);
      for (name=GetNextImageProfile(image); name != (const char *) NULL; )
      {
        profile=GetImageProfile(image,name);

        if (profile != (StringInfo *) NULL)
          {
#ifdef PNG_WRITE_iCCP_SUPPORTED
            if ((LocaleCompare(name,""ICC"") == 0) ||
                (LocaleCompare(name,""ICM"") == 0))
              {
                ping_have_iCCP = MagickTrue;
                if (ping_exclude_iCCP == MagickFalse)
                  {
                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                        ""  Setting up iCCP chunk"");

                    png_set_iCCP(ping,ping_info,(png_charp) name,0,
#if (PNG_LIBPNG_VER < 10500)
                    (png_charp) GetStringInfoDatum(profile),
#else
                    (const png_byte *) GetStringInfoDatum(profile),
#endif
                    (png_uint_32) GetStringInfoLength(profile));
                  }
                else
                  {
                    /* Do not write hex-encoded ICC chunk */
                       name=GetNextImageProfile(image);
                       continue;
                  }
              }
#endif /* WRITE_iCCP */

            if (LocaleCompare(name,""exif"") == 0)
              {
                   /* Do not write hex-encoded ICC chunk; we will
                      write it later as an eXIf chunk */
                   name=GetNextImageProfile(image);
                   continue;
              }

              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""  Setting up zTXt chunk with uuencoded %s profile"",
                 name);
              Magick_png_write_raw_profile(image_info,ping,ping_info,
                (unsigned char *) name,(unsigned char *) name,
                GetStringInfoDatum(profile),
                (png_uint_32) GetStringInfoLength(profile));
          }
        name=GetNextImageProfile(image);
      }
    }
  }

#if defined(PNG_WRITE_sRGB_SUPPORTED)
  if ((mng_info->have_write_global_srgb == 0) &&
      ping_have_iCCP != MagickTrue &&
      (ping_have_sRGB != MagickFalse ||
      png_get_valid(ping,ping_info,PNG_INFO_sRGB)))
    {
      if (ping_exclude_sRGB == MagickFalse)
        {
          /*
            Note image rendering intent.
          */
          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  Setting up sRGB chunk"");

          (void) png_set_sRGB(ping,ping_info,(
            Magick_RenderingIntent_to_PNG_RenderingIntent(
              image->rendering_intent)));

          ping_have_sRGB = MagickTrue;
        }
    }

  if ((!mng_info->write_mng) || (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))
#endif
    {
      if (ping_exclude_gAMA == MagickFalse &&
          ping_have_iCCP == MagickFalse &&
          ping_have_sRGB == MagickFalse &&
          (ping_exclude_sRGB == MagickFalse ||
          (image->gamma < .45 || image->gamma > .46)))
      {
      if ((mng_info->have_write_global_gama == 0) && (image->gamma != 0.0))
        {
          /*
            Note image gamma.
            To do: check for cHRM+gAMA == sRGB, and write sRGB instead.
          */
          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Setting up gAMA chunk"");

          png_set_gAMA(ping,ping_info,image->gamma);
        }
      }

      if (ping_exclude_cHRM == MagickFalse && ping_have_sRGB == MagickFalse)
        {
          if ((mng_info->have_write_global_chrm == 0) &&
              (image->chromaticity.red_primary.x != 0.0))
            {
              /*
                Note image chromaticity.
                Note: if cHRM+gAMA == sRGB write sRGB instead.
              */
               PrimaryInfo
                 bp,
                 gp,
                 rp,
                 wp;

               wp=image->chromaticity.white_point;
               rp=image->chromaticity.red_primary;
               gp=image->chromaticity.green_primary;
               bp=image->chromaticity.blue_primary;

               if (logging != MagickFalse)
                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""  Setting up cHRM chunk"");

               png_set_cHRM(ping,ping_info,wp.x,wp.y,rp.x,rp.y,gp.x,gp.y,
                   bp.x,bp.y);
           }
        }
    }

  if (ping_exclude_bKGD == MagickFalse)
    {
      if (ping_have_bKGD != MagickFalse)
        {
          png_set_bKGD(ping,ping_info,&ping_background);
          if (logging != MagickFalse)
            {
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""    Setting up bKGD chunk"");
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      background color = (%d,%d,%d)"",
                        (int) ping_background.red,
                        (int) ping_background.green,
                        (int) ping_background.blue);
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      index = %d, gray=%d"",
                        (int) ping_background.index,
                        (int) ping_background.gray);
            }
         }
    }

  if (ping_exclude_pHYs == MagickFalse)
    {
      if (ping_have_pHYs != MagickFalse)
        {
          png_set_pHYs(ping,ping_info,
             ping_pHYs_x_resolution,
             ping_pHYs_y_resolution,
             ping_pHYs_unit_type);

          if (logging != MagickFalse)
            {
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""    Setting up pHYs chunk"");
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      x_resolution=%lu"",
                   (unsigned long) ping_pHYs_x_resolution);
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      y_resolution=%lu"",
                   (unsigned long) ping_pHYs_y_resolution);
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      unit_type=%lu"",
                   (unsigned long) ping_pHYs_unit_type);
            }
        }
    }

#if defined(PNG_tIME_SUPPORTED)
  if (ping_exclude_tIME == MagickFalse)
    {
      const char
        *timestamp;

      if (image->taint == MagickFalse)
        {
          timestamp=GetImageOption(image_info,""png:tIME"");

          if (timestamp == (const char *) NULL)
            timestamp=GetImageProperty(image,""png:tIME"",exception);
        }

      else
        {
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  Reset tIME in tainted image"");

          timestamp=GetImageProperty(image,""date:modify"",exception);
        }

      if (timestamp != (const char *) NULL)
          write_tIME_chunk(image,ping,ping_info,timestamp,exception);
    }
#endif

  if (mng_info->need_blob != MagickFalse)
  {
    if (OpenBlob(image_info,image,WriteBinaryBlobMode,exception) ==
       MagickFalse)
       png_error(ping,""WriteBlob Failed"");

     ping_have_blob=MagickTrue;
  }

  png_write_info_before_PLTE(ping, ping_info);

  if (ping_have_tRNS != MagickFalse && ping_color_type < 4)
    {
      if (logging != MagickFalse)
        {
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Calling png_set_tRNS with num_trans=%d"",ping_num_trans);
        }

      if (ping_color_type == 3)
         (void) png_set_tRNS(ping, ping_info,
                ping_trans_alpha,
                ping_num_trans,
                NULL);

      else
        {
           (void) png_set_tRNS(ping, ping_info,
                  NULL,
                  0,
                  &ping_trans_color);

           if (logging != MagickFalse)
             {
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""     tRNS color   =(%d,%d,%d)"",
                       (int) ping_trans_color.red,
                       (int) ping_trans_color.green,
                       (int) ping_trans_color.blue);
             }
         }
    }

  /* write any png-chunk-b profiles */
  (void) Magick_png_write_chunk_from_profile(image,""PNG-chunk-b"",logging);

  png_write_info(ping,ping_info);

  /* write any PNG-chunk-m profiles */
  (void) Magick_png_write_chunk_from_profile(image,""PNG-chunk-m"",logging);

  ping_wrote_caNv = MagickFalse;

  /* write caNv chunk */
  if (ping_exclude_caNv == MagickFalse)
    {
      if ((image->page.width != 0 && image->page.width != image->columns) ||
          (image->page.height != 0 && image->page.height != image->rows) ||
          image->page.x != 0 || image->page.y != 0)
        {
          unsigned char
            chunk[20];

          (void) WriteBlobMSBULong(image,16L);  /* data length=8 */
          PNGType(chunk,mng_caNv);
          LogPNGChunk(logging,mng_caNv,16L);
          PNGLong(chunk+4,(png_uint_32) image->page.width);
          PNGLong(chunk+8,(png_uint_32) image->page.height);
          PNGsLong(chunk+12,(png_int_32) image->page.x);
          PNGsLong(chunk+16,(png_int_32) image->page.y);
          (void) WriteBlob(image,20,chunk);
          (void) WriteBlobMSBULong(image,crc32(0,chunk,20));
          ping_wrote_caNv = MagickTrue;
        }
    }

#if defined(PNG_oFFs_SUPPORTED)
  if (ping_exclude_oFFs == MagickFalse && ping_wrote_caNv == MagickFalse)
    {
      if (image->page.x || image->page.y)
        {
           png_set_oFFs(ping,ping_info,(png_int_32) image->page.x,
              (png_int_32) image->page.y, 0);

           if (logging != MagickFalse)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""    Setting up oFFs chunk with x=%d, y=%d, units=0"",
                 (int) image->page.x, (int) image->page.y);
        }
    }
#endif

  /* write vpAg chunk (deprecated, replaced by caNv) */
  if (ping_exclude_vpAg == MagickFalse && ping_wrote_caNv == MagickFalse)
    {
      if ((image->page.width != 0 && image->page.width != image->columns) ||
          (image->page.height != 0 && image->page.height != image->rows))
        {
          unsigned char
            chunk[14];

          (void) WriteBlobMSBULong(image,9L);  /* data length=8 */
          PNGType(chunk,mng_vpAg);
          LogPNGChunk(logging,mng_vpAg,9L);
          PNGLong(chunk+4,(png_uint_32) image->page.width);
          PNGLong(chunk+8,(png_uint_32) image->page.height);
          chunk[12]=0;   /* unit = pixels */
          (void) WriteBlob(image,13,chunk);
          (void) WriteBlobMSBULong(image,crc32(0,chunk,13));
        }
    }

#if (PNG_LIBPNG_VER == 10206)
    /* avoid libpng-1.2.6 bug by setting PNG_HAVE_IDAT flag */
#define PNG_HAVE_IDAT               0x04
    ping->mode |= PNG_HAVE_IDAT;
#undef PNG_HAVE_IDAT
#endif

  png_set_packing(ping);
  /*
    Allocate memory.
  */
  rowbytes=image->columns;
  if (image_depth > 8)
    rowbytes*=2;
  switch (ping_color_type)
    {
      case PNG_COLOR_TYPE_RGB:
        rowbytes*=3;
        break;

      case PNG_COLOR_TYPE_GRAY_ALPHA:
        rowbytes*=2;
        break;

      case PNG_COLOR_TYPE_RGBA:
        rowbytes*=4;
        break;

      default:
        break;
    }

  if (logging != MagickFalse)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""  Writing PNG image data"");

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    Allocating %.20g bytes of memory for pixels"",(double) rowbytes);
    }
  pixel_info=AcquireVirtualMemory(rowbytes,sizeof(*ping_pixels));
  if (pixel_info == (MemoryInfo *) NULL)
    png_error(ping,""Allocation of memory for pixels failed"");
  ping_pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);

  /*
    Initialize image scanlines.
  */
  quantum_info=AcquireQuantumInfo(image_info,image);
  if (quantum_info == (QuantumInfo *) NULL)
    png_error(ping,""Memory allocation for quantum_info failed"");
  quantum_info->format=UndefinedQuantumFormat;
  SetQuantumDepth(image,quantum_info,image_depth);
  (void) SetQuantumEndian(image,quantum_info,MSBEndian);
  num_passes=png_set_interlace_handling(ping);

  if ((!mng_info->write_png8 && !mng_info->write_png24 &&
       !mng_info->write_png48 && !mng_info->write_png64 &&
       !mng_info->write_png32) &&
       (mng_info->IsPalette ||
       (image_info->type == BilevelType)) &&
       image_matte == MagickFalse &&
       ping_have_non_bw == MagickFalse)
    {
      /* Palette, Bilevel, or Opaque Monochrome */
      register const Quantum
        *p;

      SetQuantumDepth(image,quantum_info,8);
      for (pass=0; pass < num_passes; pass++)
      {
        /*
          Convert PseudoClass image to a PNG monochrome image.
        */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          if (logging != MagickFalse && y == 0)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""    Writing row of pixels (0)"");

          p=GetVirtualPixels(image,0,y,image->columns,1,exception);

          if (p == (const Quantum *) NULL)
            break;

          if (mng_info->IsPalette)
            {
              (void) ExportQuantumPixels(image,(CacheView *) NULL,
                quantum_info,GrayQuantum,ping_pixels,exception);
              if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_PALETTE &&
                  mng_info->write_png_depth &&
                  mng_info->write_png_depth != old_bit_depth)
                {
                  /* Undo pixel scaling */
                  for (i=0; i < (ssize_t) image->columns; i++)
                     *(ping_pixels+i)=(unsigned char) (*(ping_pixels+i)
                     >> (8-old_bit_depth));
                }
            }

          else
            {
              (void) ExportQuantumPixels(image,(CacheView *) NULL,
                quantum_info,RedQuantum,ping_pixels,exception);
            }

          if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE)
            for (i=0; i < (ssize_t) image->columns; i++)
               *(ping_pixels+i)=(unsigned char) ((*(ping_pixels+i) > 127) ?
                      255 : 0);

          if (logging != MagickFalse && y == 0)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""    Writing row of pixels (1)"");

          png_write_row(ping,ping_pixels);

          status=SetImageProgress(image,SaveImageTag,
              (MagickOffsetType) (pass * image->rows + y),
              num_passes * image->rows);

          if (status == MagickFalse)
            break;
        }
      }
    }

  else   /* Not Palette, Bilevel, or Opaque Monochrome */
    {
      if ((!mng_info->write_png8 && !mng_info->write_png24 &&
          !mng_info->write_png48 && !mng_info->write_png64 &&
          !mng_info->write_png32) && (image_matte != MagickFalse ||
          (ping_bit_depth >= MAGICKCORE_QUANTUM_DEPTH)) &&
          (mng_info->IsPalette) && ping_have_color == MagickFalse)
        {
          register const Quantum
            *p;

          for (pass=0; pass < num_passes; pass++)
          {

          for (y=0; y < (ssize_t) image->rows; y++)
          {
            p=GetVirtualPixels(image,0,y,image->columns,1,exception);

            if (p == (const Quantum *) NULL)
              break;

            if (ping_color_type == PNG_COLOR_TYPE_GRAY)
              {
                if (mng_info->IsPalette)
                  (void) ExportQuantumPixels(image,(CacheView *) NULL,
                    quantum_info,GrayQuantum,ping_pixels,exception);

                else
                  (void) ExportQuantumPixels(image,(CacheView *) NULL,
                    quantum_info,RedQuantum,ping_pixels,exception);

                if (logging != MagickFalse && y == 0)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                       ""    Writing GRAY PNG pixels (2)"");
              }

            else /* PNG_COLOR_TYPE_GRAY_ALPHA */
              {
                if (logging != MagickFalse && y == 0)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                         ""    Writing GRAY_ALPHA PNG pixels (2)"");

                (void) ExportQuantumPixels(image,(CacheView *) NULL,
                  quantum_info,GrayAlphaQuantum,ping_pixels,exception);
              }

            if (logging != MagickFalse && y == 0)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""    Writing row of pixels (2)"");

            png_write_row(ping,ping_pixels);

            status=SetImageProgress(image,SaveImageTag,
              (MagickOffsetType) (pass * image->rows + y),
              num_passes * image->rows);

            if (status == MagickFalse)
              break;
            }
          }
        }

      else
        {
          register const Quantum
            *p;

          for (pass=0; pass < num_passes; pass++)
          {
            if ((image_depth > 8) ||
                mng_info->write_png24 ||
                mng_info->write_png32 ||
                mng_info->write_png48 ||
                mng_info->write_png64 ||
                (!mng_info->write_png8 && !mng_info->IsPalette))
            {
              for (y=0; y < (ssize_t) image->rows; y++)
              {
                p=GetVirtualPixels(image,0,y,image->columns,1, exception);

                if (p == (const Quantum *) NULL)
                  break;

                if (ping_color_type == PNG_COLOR_TYPE_GRAY)
                  {
                    if (image->storage_class == DirectClass)
                      (void) ExportQuantumPixels(image,(CacheView *) NULL,
                        quantum_info,RedQuantum,ping_pixels,exception);

                    else
                      (void) ExportQuantumPixels(image,(CacheView *) NULL,
                        quantum_info,GrayQuantum,ping_pixels,exception);
                  }

                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
                  {
                    (void) ExportQuantumPixels(image,(CacheView *) NULL,
                      quantum_info,GrayAlphaQuantum,ping_pixels,
                      exception);

                    if (logging != MagickFalse && y == 0)
                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                           ""    Writing GRAY_ALPHA PNG pixels (3)"");
                  }

                else if (image_matte != MagickFalse)
                  (void) ExportQuantumPixels(image,(CacheView *) NULL,
                    quantum_info,RGBAQuantum,ping_pixels,exception);

                else
                  (void) ExportQuantumPixels(image,(CacheView *) NULL,
                    quantum_info,RGBQuantum,ping_pixels,exception);

                if (logging != MagickFalse && y == 0)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                      ""    Writing row of pixels (3)"");

                png_write_row(ping,ping_pixels);

                status=SetImageProgress(image,SaveImageTag,
                  (MagickOffsetType) (pass * image->rows + y),
                  num_passes * image->rows);

                if (status == MagickFalse)
                  break;
              }
            }

          else
            /* not ((image_depth > 8) ||
                mng_info->write_png24 || mng_info->write_png32 ||
                mng_info->write_png48 || mng_info->write_png64 ||
                (!mng_info->write_png8 && !mng_info->IsPalette))
             */
            {
              if ((ping_color_type != PNG_COLOR_TYPE_GRAY) &&
                  (ping_color_type != PNG_COLOR_TYPE_GRAY_ALPHA))
                {
                  if (logging != MagickFalse)
                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                      ""  pass %d, Image Is not GRAY or GRAY_ALPHA"",pass);

                  SetQuantumDepth(image,quantum_info,8);
                  image_depth=8;
                }

              for (y=0; y < (ssize_t) image->rows; y++)
              {
                if (logging != MagickFalse && y == 0)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""  pass %d, Image Is RGB, 16-bit GRAY, or GRAY_ALPHA"",
                    pass);

                p=GetVirtualPixels(image,0,y,image->columns,1, exception);

                if (p == (const Quantum *) NULL)
                  break;

                if (ping_color_type == PNG_COLOR_TYPE_GRAY)
                  {
                    SetQuantumDepth(image,quantum_info,image->depth);

                    (void) ExportQuantumPixels(image,(CacheView *) NULL,
                       quantum_info,GrayQuantum,ping_pixels,exception);
                  }

                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
                  {
                    if (logging != MagickFalse && y == 0)
                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                           ""  Writing GRAY_ALPHA PNG pixels (4)"");

                    (void) ExportQuantumPixels(image,(CacheView *) NULL,
                         quantum_info,GrayAlphaQuantum,ping_pixels,
                         exception);
                  }

                else
                  {
                    (void) ExportQuantumPixels(image,(CacheView *) NULL,
                      quantum_info,IndexQuantum,ping_pixels,exception);

                    if (logging != MagickFalse && y <= 2)
                    {
                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                          ""  Writing row of non-gray pixels (4)"");

                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                          ""  ping_pixels[0]=%d,ping_pixels[1]=%d"",
                          (int)ping_pixels[0],(int)ping_pixels[1]);
                    }
                  }
                png_write_row(ping,ping_pixels);

                status=SetImageProgress(image,SaveImageTag,
                  (MagickOffsetType) (pass * image->rows + y),
                  num_passes * image->rows);

                if (status == MagickFalse)
                  break;
              }
            }
          }
        }
    }

  if (quantum_info != (QuantumInfo *) NULL)
    quantum_info=DestroyQuantumInfo(quantum_info);

  if (logging != MagickFalse)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""  Wrote PNG image data"");

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    Width: %.20g"",(double) ping_width);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    Height: %.20g"",(double) ping_height);

      if (mng_info->write_png_depth)
        {
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Defined png:bit-depth: %d"",mng_info->write_png_depth);
        }

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    PNG bit-depth written: %d"",ping_bit_depth);

      if (mng_info->write_png_colortype)
        {
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Defined png:color-type: %d"",mng_info->write_png_colortype-1);
        }

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    PNG color-type written: %d"",ping_color_type);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    PNG Interlace method: %d"",ping_interlace_method);
    }
  /*
    Generate text chunks after IDAT.
  */
  if (ping_exclude_tEXt == MagickFalse || ping_exclude_zTXt == MagickFalse)
  {
    ResetImagePropertyIterator(image);
    property=GetNextImageProperty(image);
    while (property != (const char *) NULL)
    {
      png_textp
        text;

      value=GetImageProperty(image,property,exception);

      /* Don't write any ""png:"" or ""jpeg:"" properties; those are just for
       * ""identify"" or for passing through to another JPEG
       */
      if ((LocaleNCompare(property,""png:"",4) != 0 &&
           LocaleNCompare(property,""jpeg:"",5) != 0) &&


          /* Suppress density and units if we wrote a pHYs chunk */
          (ping_exclude_pHYs != MagickFalse      ||
          LocaleCompare(property,""density"") != 0 ||
          LocaleCompare(property,""units"") != 0) &&

          /* Suppress the IM-generated Date:create and Date:modify */
          (ping_exclude_date == MagickFalse      ||
          LocaleNCompare(property, ""Date:"",5) != 0))
        {
        if (value != (const char *) NULL)
          {

#if PNG_LIBPNG_VER >= 10400
            text=(png_textp) png_malloc(ping,
                 (png_alloc_size_t) sizeof(png_text));
#else
            text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));
#endif
            text[0].key=(char *) property;
            text[0].text=(char *) value;
            text[0].text_length=strlen(value);

            if (ping_exclude_tEXt != MagickFalse)
               text[0].compression=PNG_TEXT_COMPRESSION_zTXt;

            else if (ping_exclude_zTXt != MagickFalse)
               text[0].compression=PNG_TEXT_COMPRESSION_NONE;

            else
            {
               text[0].compression=image_info->compression == NoCompression ||
                 (image_info->compression == UndefinedCompression &&
                 text[0].text_length < 128) ? PNG_TEXT_COMPRESSION_NONE :
                 PNG_TEXT_COMPRESSION_zTXt ;
            }

            if (logging != MagickFalse)
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Setting up text chunk"");

                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""    keyword: '%s'"",text[0].key);
              }

            png_set_text(ping,ping_info,text,1);
            png_free(ping,text);
          }
        }
      property=GetNextImageProperty(image);
    }
  }

  /* write any PNG-chunk-e profiles */
  (void) Magick_png_write_chunk_from_profile(image,""PNG-chunk-e"",logging);

  /* write exIf profile */
  if (ping_have_eXIf != MagickFalse && ping_exclude_eXIf == MagickFalse)
    {
      char
        *name;

      ResetImageProfileIterator(image);

      for (name=GetNextImageProfile(image); name != (const char *) NULL; )
      {
        if (LocaleCompare(name,""exif"") == 0)
          {
            const StringInfo
              *profile;

            profile=GetImageProfile(image,name);

            if (profile != (StringInfo *) NULL)
              {
                png_uint_32
                  length;

                unsigned char
                  chunk[4],
                  *data;

               StringInfo
                 *ping_profile;

               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Have eXIf profile"");

               ping_profile=CloneStringInfo(profile);
               data=GetStringInfoDatum(ping_profile),
               length=(png_uint_32) GetStringInfoLength(ping_profile);

               PNGType(chunk,mng_eXIf);
               if (length < 7)
                 {
                   ping_profile=DestroyStringInfo(ping_profile);
                   break;  /* otherwise crashes */
                 }

               /* skip the ""Exif\0\0"" JFIF Exif Header ID */
               length -= 6;

               LogPNGChunk(logging,chunk,length);
               (void) WriteBlobMSBULong(image,length);
               (void) WriteBlob(image,4,chunk);
               (void) WriteBlob(image,length,data+6);
               (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),
                 data+6, (uInt) length));
               ping_profile=DestroyStringInfo(ping_profile);
               break;
             }
         }
       name=GetNextImageProfile(image);
     }
  }

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  Writing PNG end info"");

  png_write_end(ping,ping_info);

  if (mng_info->need_fram && (int) image->dispose == BackgroundDispose)
    {
      if (mng_info->page.x || mng_info->page.y ||
          (ping_width != mng_info->page.width) ||
          (ping_height != mng_info->page.height))
        {
          unsigned char
            chunk[32];

          /*
            Write FRAM 4 with clipping boundaries followed by FRAM 1.
          */
          (void) WriteBlobMSBULong(image,27L);  /* data length=27 */
          PNGType(chunk,mng_FRAM);
          LogPNGChunk(logging,mng_FRAM,27L);
          chunk[4]=4;
          chunk[5]=0;  /* frame name separator (no name) */
          chunk[6]=1;  /* flag for changing delay, for next frame only */
          chunk[7]=0;  /* flag for changing frame timeout */
          chunk[8]=1;  /* flag for changing frame clipping for next frame */
          chunk[9]=0;  /* flag for changing frame sync_id */
          PNGLong(chunk+10,(png_uint_32) (0L)); /* temporary 0 delay */
          chunk[14]=0; /* clipping boundaries delta type */
          PNGLong(chunk+15,(png_uint_32) (mng_info->page.x)); /* left cb */
          PNGLong(chunk+19,
             (png_uint_32) (mng_info->page.x + ping_width));
          PNGLong(chunk+23,(png_uint_32) (mng_info->page.y)); /* top cb */
          PNGLong(chunk+27,
             (png_uint_32) (mng_info->page.y + ping_height));
          (void) WriteBlob(image,31,chunk);
          (void) WriteBlobMSBULong(image,crc32(0,chunk,31));
          mng_info->old_framing_mode=4;
          mng_info->framing_mode=1;
        }

      else
        mng_info->framing_mode=3;
    }
  if (mng_info->write_mng && !mng_info->need_fram &&
      ((int) image->dispose == 3))
     png_error(ping, ""Cannot convert GIF with disposal method 3 to MNG-LC"");

  /*
    Free PNG resources.
  */

  png_destroy_write_struct(&ping,&ping_info);

  pixel_info=RelinquishVirtualMemory(pixel_info);

  if (ping_have_blob != MagickFalse)
     (void) CloseBlob(image);

  image_info=DestroyImageInfo(image_info);
  image=DestroyImage(image);

  /* Store bit depth actually written */
  s[0]=(char) ping_bit_depth;
  s[1]='\0';

  (void) SetImageProperty(IMimage,""png:bit-depth-written"",s,exception);

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  exit WriteOnePNGImage()"");

#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE
  UnlockSemaphoreInfo(ping_semaphore);
#endif

   /* }  for navigation to beginning of SETJMP-protected block. Revert to
    *    Throwing an Exception when an error occurs.
    */

  return(MagickTrue);
/*  End write one PNG image */

}
","static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,
  const ImageInfo *IMimage_info,Image *IMimage,ExceptionInfo *exception)
{
  char
    im_vers[32],
    libpng_runv[32],
    libpng_vers[32],
    zlib_runv[32],
    zlib_vers[32];

  Image
    *image;

  ImageInfo
    *image_info;

  char
    s[2];

  const char
    *name,
    *property,
    *value;

  const StringInfo
    *profile;

  int
    num_passes,
    pass,
    ping_wrote_caNv;

  png_byte
     ping_trans_alpha[256];

  png_color
     palette[257];

  png_color_16
    ping_background,
    ping_trans_color;

  png_info
    *ping_info;

  png_struct
    *ping;

  png_uint_32
    ping_height,
    ping_width;

  ssize_t
    y;

  MagickBooleanType
    image_matte,
    logging,
    matte,

    ping_have_blob,
    ping_have_cheap_transparency,
    ping_have_color,
    ping_have_non_bw,
    ping_have_PLTE,
    ping_have_bKGD,
    ping_have_eXIf,
    ping_have_iCCP,
    ping_have_pHYs,
    ping_have_sRGB,
    ping_have_tRNS,

    ping_exclude_bKGD,
    ping_exclude_cHRM,
    ping_exclude_date,
    /* ping_exclude_EXIF, */
    ping_exclude_eXIf,
    ping_exclude_gAMA,
    ping_exclude_iCCP,
    /* ping_exclude_iTXt, */
    ping_exclude_oFFs,
    ping_exclude_pHYs,
    ping_exclude_sRGB,
    ping_exclude_tEXt,
    ping_exclude_tIME,
    /* ping_exclude_tRNS, */
    ping_exclude_vpAg,
    ping_exclude_caNv,
    ping_exclude_zCCP, /* hex-encoded iCCP */
    ping_exclude_zTXt,

    ping_preserve_colormap,
    ping_preserve_iCCP,
    ping_need_colortype_warning,

    status,
    tried_332,
    tried_333,
    tried_444;

  MemoryInfo
    *volatile pixel_info;

  QuantumInfo
    *quantum_info;

  PNGErrorInfo
    error_info;

  register ssize_t
    i,
    x;

  unsigned char
    *ping_pixels;

  volatile int
    image_colors,
    ping_bit_depth,
    ping_color_type,
    ping_interlace_method,
    ping_compression_method,
    ping_filter_method,
    ping_num_trans;

  volatile size_t
    image_depth,
    old_bit_depth;

  size_t
    quality,
    rowbytes,
    save_image_depth;

  int
    j,
    number_colors,
    number_opaque,
    number_semitransparent,
    number_transparent,
    ping_pHYs_unit_type;

  png_uint_32
    ping_pHYs_x_resolution,
    ping_pHYs_y_resolution;

  logging=LogMagickEvent(CoderEvent,GetMagickModule(),
     ""  Enter WriteOnePNGImage()"");
 
   image = CloneImage(IMimage,0,0,MagickFalse,exception);
   image_info=(ImageInfo *) CloneImageInfo(IMimage_info);
   if (image_info == (ImageInfo *) NULL)
     ThrowWriterException(ResourceLimitError, ""MemoryAllocationFailed"");
 
   /* Define these outside of the following ""if logging()"" block so they will
    * show in debuggers.
   */
  *im_vers='\0';
  (void) ConcatenateMagickString(im_vers,
         MagickLibVersionText,MagickPathExtent);
  (void) ConcatenateMagickString(im_vers,
         MagickLibAddendum,MagickPathExtent);

  *libpng_vers='\0';
  (void) ConcatenateMagickString(libpng_vers,
         PNG_LIBPNG_VER_STRING,32);
  *libpng_runv='\0';
  (void) ConcatenateMagickString(libpng_runv,
         png_get_libpng_ver(NULL),32);

  *zlib_vers='\0';
  (void) ConcatenateMagickString(zlib_vers,
         ZLIB_VERSION,32);
  *zlib_runv='\0';
  (void) ConcatenateMagickString(zlib_runv,
         zlib_version,32);

  if (logging != MagickFalse)
    {
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""    IM version     = %s"",
           im_vers);
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""    Libpng version = %s"",
           libpng_vers);
       if (LocaleCompare(libpng_vers,libpng_runv) != 0)
       {
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""      running with   %s"",
           libpng_runv);
       }
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""    Zlib version   = %s"",
           zlib_vers);
       if (LocaleCompare(zlib_vers,zlib_runv) != 0)
       {
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""      running with   %s"",
           zlib_runv);
       }
    }

  /* Initialize some stuff */
  ping_bit_depth=0,
  ping_color_type=0,
  ping_interlace_method=0,
  ping_compression_method=0,
  ping_filter_method=0,
  ping_num_trans = 0;

  ping_background.red = 0;
  ping_background.green = 0;
  ping_background.blue = 0;
  ping_background.gray = 0;
  ping_background.index = 0;

  ping_trans_color.red=0;
  ping_trans_color.green=0;
  ping_trans_color.blue=0;
  ping_trans_color.gray=0;

  ping_pHYs_unit_type = 0;
  ping_pHYs_x_resolution = 0;
  ping_pHYs_y_resolution = 0;

  ping_have_blob=MagickFalse;
  ping_have_cheap_transparency=MagickFalse;
  ping_have_color=MagickTrue;
  ping_have_non_bw=MagickTrue;
  ping_have_PLTE=MagickFalse;
  ping_have_bKGD=MagickFalse;
  ping_have_eXIf=MagickTrue;
  ping_have_iCCP=MagickFalse;
  ping_have_pHYs=MagickFalse;
  ping_have_sRGB=MagickFalse;
  ping_have_tRNS=MagickFalse;

  ping_exclude_bKGD=mng_info->ping_exclude_bKGD;
  ping_exclude_caNv=mng_info->ping_exclude_caNv;
  ping_exclude_cHRM=mng_info->ping_exclude_cHRM;
  ping_exclude_date=mng_info->ping_exclude_date;
  ping_exclude_eXIf=mng_info->ping_exclude_eXIf;
  ping_exclude_gAMA=mng_info->ping_exclude_gAMA;
  ping_exclude_iCCP=mng_info->ping_exclude_iCCP;
  /* ping_exclude_iTXt=mng_info->ping_exclude_iTXt; */
  ping_exclude_oFFs=mng_info->ping_exclude_oFFs;
  ping_exclude_pHYs=mng_info->ping_exclude_pHYs;
  ping_exclude_sRGB=mng_info->ping_exclude_sRGB;
  ping_exclude_tEXt=mng_info->ping_exclude_tEXt;
  ping_exclude_tIME=mng_info->ping_exclude_tIME;
  /* ping_exclude_tRNS=mng_info->ping_exclude_tRNS; */
  ping_exclude_vpAg=mng_info->ping_exclude_vpAg;
  ping_exclude_zCCP=mng_info->ping_exclude_zCCP; /* hex-encoded iCCP in zTXt */
  ping_exclude_zTXt=mng_info->ping_exclude_zTXt;

  ping_preserve_colormap = mng_info->ping_preserve_colormap;
  ping_preserve_iCCP = mng_info->ping_preserve_iCCP;
  ping_need_colortype_warning = MagickFalse;

  /* Recognize the ICC sRGB profile and convert it to the sRGB chunk,
   * i.e., eliminate the ICC profile and set image->rendering_intent.
   * Note that this will not involve any changes to the actual pixels
   * but merely passes information to applications that read the resulting
   * PNG image.
   *
   * To do: recognize other variants of the sRGB profile, using the CRC to
   * verify all recognized variants including the 7 already known.
   *
   * Work around libpng16+ rejecting some ""known invalid sRGB profiles"".
   *
   * Use something other than image->rendering_intent to record the fact
   * that the sRGB profile was found.
   *
   * Record the ICC version (currently v2 or v4) of the incoming sRGB ICC
   * profile.  Record the Blackpoint Compensation, if any.
   */
   if (ping_exclude_sRGB == MagickFalse && ping_preserve_iCCP == MagickFalse)
   {
      char
        *name;

      const StringInfo
        *profile;

      ResetImageProfileIterator(image);
      for (name=GetNextImageProfile(image); name != (const char *) NULL; )
      {
        profile=GetImageProfile(image,name);

        if (profile != (StringInfo *) NULL)
          {
            if ((LocaleCompare(name,""ICC"") == 0) ||
                (LocaleCompare(name,""ICM"") == 0))

             {
                 int
                   icheck,
                   got_crc=0;


                 png_uint_32
                   length,
                   profile_crc=0;

                 unsigned char
                   *data;

                 length=(png_uint_32) GetStringInfoLength(profile);

                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)
                 {
                   if (length == sRGB_info[icheck].len)
                   {
                     if (got_crc == 0)
                     {
                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                         ""    Got a %lu-byte ICC profile (potentially sRGB)"",
                         (unsigned long) length);

                       data=GetStringInfoDatum(profile);
                       profile_crc=crc32(0,data,length);

                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                           ""      with crc=%8x"",(unsigned int) profile_crc);
                       got_crc++;
                     }

                     if (profile_crc == sRGB_info[icheck].crc)
                     {
                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                            ""      It is sRGB with rendering intent = %s"",
                        Magick_RenderingIntentString_from_PNG_RenderingIntent(
                             sRGB_info[icheck].intent));
                        if (image->rendering_intent==UndefinedIntent)
                        {
                          image->rendering_intent=
                          Magick_RenderingIntent_from_PNG_RenderingIntent(
                             sRGB_info[icheck].intent);
                        }
                        ping_exclude_iCCP = MagickTrue;
                        ping_exclude_zCCP = MagickTrue;
                        ping_have_sRGB = MagickTrue;
                        break;
                     }
                   }
                 }
                 if (sRGB_info[icheck].len == 0)
                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                        ""    Got %lu-byte ICC profile not recognized as sRGB"",
                        (unsigned long) length);
              }
          }
        name=GetNextImageProfile(image);
      }
  }

  number_opaque = 0;
  number_semitransparent = 0;
  number_transparent = 0;

  if (logging != MagickFalse)
    {
      if (image->storage_class == UndefinedClass)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    image->storage_class=UndefinedClass"");
      if (image->storage_class == DirectClass)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    image->storage_class=DirectClass"");
      if (image->storage_class == PseudoClass)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    image->storage_class=PseudoClass"");
      (void) LogMagickEvent(CoderEvent,GetMagickModule(), image->taint ?
          ""    image->taint=MagickTrue"":
          ""    image->taint=MagickFalse"");
    }

  if (image->storage_class == PseudoClass &&
     (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32 ||
     mng_info->write_png48 || mng_info->write_png64 ||
     (mng_info->write_png_colortype != 1 &&
     mng_info->write_png_colortype != 5)))
    {
      (void) SyncImage(image,exception);
      image->storage_class = DirectClass;
    }

  if (ping_preserve_colormap == MagickFalse)
    {
      if (image->storage_class != PseudoClass && image->colormap != NULL)
        {
          /* Free the bogus colormap; it can cause trouble later */
           if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    Freeing bogus colormap"");
           (void) RelinquishMagickMemory(image->colormap);
           image->colormap=NULL;
        }
    }

  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
    (void) TransformImageColorspace(image,sRGBColorspace,exception);

  /*
    Sometimes we get PseudoClass images whose RGB values don't match
    the colors in the colormap.  This code syncs the RGB values.
  */
  if (image->depth <= 8 && image->taint && image->storage_class == PseudoClass)
     (void) SyncImage(image,exception);

#if (MAGICKCORE_QUANTUM_DEPTH == 8)
  if (image->depth > 8)
    {
      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    Reducing PNG bit depth to 8 since this is a Q8 build."");

      image->depth=8;
    }
#endif

  /* Respect the -depth option */
  if (image->depth < 4)
    {
       register Quantum
         *r;

       if (image->depth > 2)
         {
           /* Scale to 4-bit */
           LBR04PacketRGBO(image->background_color);

           for (y=0; y < (ssize_t) image->rows; y++)
           {
             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

             if (r == (Quantum *) NULL)
               break;

             for (x=0; x < (ssize_t) image->columns; x++)
             {
                LBR04PixelRGBA(r);
                r+=GetPixelChannels(image);
             }

             if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
           }

           if (image->storage_class == PseudoClass && image->colormap != NULL)
           {
             for (i=0; i < (ssize_t) image->colors; i++)
             {
               LBR04PacketRGBO(image->colormap[i]);
             }
           }
         }
       else if (image->depth > 1)
         {
           /* Scale to 2-bit */
           LBR02PacketRGBO(image->background_color);

           for (y=0; y < (ssize_t) image->rows; y++)
           {
             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

             if (r == (Quantum *) NULL)
               break;

             for (x=0; x < (ssize_t) image->columns; x++)
             {
                LBR02PixelRGBA(r);
                r+=GetPixelChannels(image);
             }

             if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
           }

           if (image->storage_class == PseudoClass && image->colormap != NULL)
           {
             for (i=0; i < (ssize_t) image->colors; i++)
             {
               LBR02PacketRGBO(image->colormap[i]);
             }
           }
         }
       else
         {
           /* Scale to 1-bit */
           LBR01PacketRGBO(image->background_color);

           for (y=0; y < (ssize_t) image->rows; y++)
           {
             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

             if (r == (Quantum *) NULL)
               break;

             for (x=0; x < (ssize_t) image->columns; x++)
             {
                LBR01PixelRGBA(r);
                r+=GetPixelChannels(image);
             }

             if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
           }

           if (image->storage_class == PseudoClass && image->colormap != NULL)
           {
             for (i=0; i < (ssize_t) image->colors; i++)
             {
               LBR01PacketRGBO(image->colormap[i]);
             }
           }
         }
    }

  /* To do: set to next higher multiple of 8 */
  if (image->depth < 8)
     image->depth=8;

#if (MAGICKCORE_QUANTUM_DEPTH > 16)
  /* PNG does not handle depths greater than 16 so reduce it even
   * if lossy
   */
  if (image->depth > 8)
      image->depth=16;
#endif

#if (MAGICKCORE_QUANTUM_DEPTH > 8)
  if (image->depth > 8)
    {
      /* To do: fill low byte properly */
      image->depth=16;
    }

  if (image->depth == 16 && mng_info->write_png_depth != 16)
    if (mng_info->write_png8 ||
        LosslessReduceDepthOK(image,exception) != MagickFalse)
      image->depth = 8;
#endif

  image_colors = (int) image->colors;
  number_opaque = (int) image->colors;
  number_transparent = 0;
  number_semitransparent = 0;

  if (mng_info->write_png_colortype &&
     (mng_info->write_png_colortype > 4 || (mng_info->write_png_depth >= 8 &&
     mng_info->write_png_colortype < 4 &&
     image->alpha_trait == UndefinedPixelTrait)))
  {
     /* Avoid the expensive BUILD_PALETTE operation if we're sure that we
      * are not going to need the result.
      */
     if (mng_info->write_png_colortype == 1 ||
        mng_info->write_png_colortype == 5)
       ping_have_color=MagickFalse;

     if (image->alpha_trait != UndefinedPixelTrait)
       {
         number_transparent = 2;
         number_semitransparent = 1;
       }
  }

  if (mng_info->write_png_colortype < 7)
  {
  /* BUILD_PALETTE
   *
   * Normally we run this just once, but in the case of writing PNG8
   * we reduce the transparency to binary and run again, then if there
   * are still too many colors we reduce to a simple 4-4-4-1, then 3-3-3-1
   * RGBA palette and run again, and then to a simple 3-3-2-1 RGBA
   * palette.  Then (To do) we take care of a final reduction that is only
   * needed if there are still 256 colors present and one of them has both
   * transparent and opaque instances.
   */

  tried_332 = MagickFalse;
  tried_333 = MagickFalse;
  tried_444 = MagickFalse;

  for (j=0; j<6; j++)
  {
    /*
     * Sometimes we get DirectClass images that have 256 colors or fewer.
     * This code will build a colormap.
     *
     * Also, sometimes we get PseudoClass images with an out-of-date
     * colormap.  This code will replace the colormap with a new one.
     * Sometimes we get PseudoClass images that have more than 256 colors.
     * This code will delete the colormap and change the image to
     * DirectClass.
     *
     * If image->alpha_trait is MagickFalse, we ignore the alpha channel
     * even though it sometimes contains left-over non-opaque values.
     *
     * Also we gather some information (number of opaque, transparent,
     * and semitransparent pixels, and whether the image has any non-gray
     * pixels or only black-and-white pixels) that we might need later.
     *
     * Even if the user wants to force GrayAlpha or RGBA (colortype 4 or 6)
     * we need to check for bogus non-opaque values, at least.
     */

   int
     n;

   PixelInfo
     opaque[260],
     semitransparent[260],
     transparent[260];

   register const Quantum
     *s;

   register Quantum
     *q,
     *r;

   if (logging != MagickFalse)
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    Enter BUILD_PALETTE:"");

   if (logging != MagickFalse)
     {
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      image->columns=%.20g"",(double) image->columns);
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      image->rows=%.20g"",(double) image->rows);
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      image->alpha_trait=%.20g"",(double) image->alpha_trait);
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      image->depth=%.20g"",(double) image->depth);

       if (image->storage_class == PseudoClass && image->colormap != NULL)
       {
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      Original colormap:"");
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""        i    (red,green,blue,alpha)"");

         for (i=0; i < 256; i++)
         {
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""        %d    (%d,%d,%d,%d)"",
                    (int) i,
                    (int) image->colormap[i].red,
                    (int) image->colormap[i].green,
                    (int) image->colormap[i].blue,
                    (int) image->colormap[i].alpha);
         }

         for (i=image->colors - 10; i < (ssize_t) image->colors; i++)
         {
           if (i > 255)
             {
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""        %d    (%d,%d,%d,%d)"",
                    (int) i,
                    (int) image->colormap[i].red,
                    (int) image->colormap[i].green,
                    (int) image->colormap[i].blue,
                    (int) image->colormap[i].alpha);
             }
         }
       }

       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""      image->colors=%d"",(int) image->colors);

       if (image->colors == 0)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""        (zero means unknown)"");

       if (ping_preserve_colormap == MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""      Regenerate the colormap"");
     }

     image_colors=0;
     number_opaque = 0;
     number_semitransparent = 0;
     number_transparent = 0;

     for (y=0; y < (ssize_t) image->rows; y++)
     {
       q=GetAuthenticPixels(image,0,y,image->columns,1,exception);

       if (q == (Quantum *) NULL)
         break;

       for (x=0; x < (ssize_t) image->columns; x++)
       {
           if (image->alpha_trait == UndefinedPixelTrait ||
              GetPixelAlpha(image,q) == OpaqueAlpha)
             {
               if (number_opaque < 259)
                 {
                   if (number_opaque == 0)
                     {
                       GetPixelInfoPixel(image, q, opaque);
                       opaque[0].alpha=OpaqueAlpha;
                       number_opaque=1;
                     }

                   for (i=0; i< (ssize_t) number_opaque; i++)
                     {
                       if (Magick_png_color_equal(image,q,opaque+i))
                         break;
                     }

                   if (i ==  (ssize_t) number_opaque && number_opaque < 259)
                     {
                       number_opaque++;
                       GetPixelInfoPixel(image, q, opaque+i);
                       opaque[i].alpha=OpaqueAlpha;
                     }
                 }
             }
           else if (GetPixelAlpha(image,q) == TransparentAlpha)
             {
               if (number_transparent < 259)
                 {
                   if (number_transparent == 0)
                     {
                       GetPixelInfoPixel(image, q, transparent);
                       ping_trans_color.red=(unsigned short)
                         GetPixelRed(image,q);
                       ping_trans_color.green=(unsigned short)
                         GetPixelGreen(image,q);
                       ping_trans_color.blue=(unsigned short)
                         GetPixelBlue(image,q);
                       ping_trans_color.gray=(unsigned short)
                         GetPixelGray(image,q);
                       number_transparent = 1;
                     }

                   for (i=0; i< (ssize_t) number_transparent; i++)
                     {
                       if (Magick_png_color_equal(image,q,transparent+i))
                         break;
                     }

                   if (i ==  (ssize_t) number_transparent &&
                       number_transparent < 259)
                     {
                       number_transparent++;
                       GetPixelInfoPixel(image,q,transparent+i);
                     }
                 }
             }
           else
             {
               if (number_semitransparent < 259)
                 {
                   if (number_semitransparent == 0)
                     {
                       GetPixelInfoPixel(image,q,semitransparent);
                       number_semitransparent = 1;
                     }

                   for (i=0; i< (ssize_t) number_semitransparent; i++)
                     {
                       if (Magick_png_color_equal(image,q,semitransparent+i)
                           && GetPixelAlpha(image,q) ==
                           semitransparent[i].alpha)
                         break;
                     }

                   if (i ==  (ssize_t) number_semitransparent &&
                       number_semitransparent < 259)
                     {
                       number_semitransparent++;
                       GetPixelInfoPixel(image, q, semitransparent+i);
                     }
                 }
             }
           q+=GetPixelChannels(image);
        }
     }

     if (mng_info->write_png8 == MagickFalse &&
         ping_exclude_bKGD == MagickFalse)
       {
         /* Add the background color to the palette, if it
          * isn't already there.
          */
          if (logging != MagickFalse)
            {
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      Check colormap for background (%d,%d,%d)"",
                  (int) image->background_color.red,
                  (int) image->background_color.green,
                  (int) image->background_color.blue);
            }
          for (i=0; i<number_opaque; i++)
          {
             if (opaque[i].red == image->background_color.red &&
                 opaque[i].green == image->background_color.green &&
                 opaque[i].blue == image->background_color.blue)
               break;
          }
          if (number_opaque < 259 && i == number_opaque)
            {
               opaque[i] = image->background_color;
               ping_background.index = i;
               number_opaque++;
               if (logging != MagickFalse)
                 {
                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                       ""      background_color index is %d"",(int) i);
                 }

            }
          else if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      No room in the colormap to add background color"");
       }

     image_colors=number_opaque+number_transparent+number_semitransparent;

     if (logging != MagickFalse)
       {
         if (image_colors > 256)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      image has more than 256 colors"");

         else
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      image has %d colors"",image_colors);
       }

     if (ping_preserve_colormap != MagickFalse)
       break;

     if (mng_info->write_png_colortype != 7) /* We won't need this info */
       {
         ping_have_color=MagickFalse;
         ping_have_non_bw=MagickFalse;

         if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
         {
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""incompatible colorspace"");
           ping_have_color=MagickTrue;
           ping_have_non_bw=MagickTrue;
         }

         if(image_colors > 256)
           {
             for (y=0; y < (ssize_t) image->rows; y++)
             {
               q=GetAuthenticPixels(image,0,y,image->columns,1,exception);

               if (q == (Quantum *) NULL)
                 break;

               s=q;
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                 if (GetPixelRed(image,s) != GetPixelGreen(image,s) ||
                     GetPixelRed(image,s) != GetPixelBlue(image,s))
                   {
                      ping_have_color=MagickTrue;
                      ping_have_non_bw=MagickTrue;
                      break;
                   }
                 s+=GetPixelChannels(image);
               }

               if (ping_have_color != MagickFalse)
                 break;

               /* Worst case is black-and-white; we are looking at every
                * pixel twice.
                */

               if (ping_have_non_bw == MagickFalse)
                 {
                   s=q;
                   for (x=0; x < (ssize_t) image->columns; x++)
                   {
                     if (GetPixelRed(image,s) != 0 &&
                         GetPixelRed(image,s) != QuantumRange)
                       {
                         ping_have_non_bw=MagickTrue;
                         break;
                       }
                     s+=GetPixelChannels(image);
                   }
               }
             }
           }
       }

     if (image_colors < 257)
       {
         PixelInfo
           colormap[260];

         /*
          * Initialize image colormap.
          */

         if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      Sort the new colormap"");

        /* Sort palette, transparent first */;

         n = 0;

         for (i=0; i<number_transparent; i++)
            colormap[n++] = transparent[i];

         for (i=0; i<number_semitransparent; i++)
            colormap[n++] = semitransparent[i];

         for (i=0; i<number_opaque; i++)
            colormap[n++] = opaque[i];

         ping_background.index +=
           (number_transparent + number_semitransparent);

         /* image_colors < 257; search the colormap instead of the pixels
          * to get ping_have_color and ping_have_non_bw
          */
         for (i=0; i<n; i++)
         {
           if (ping_have_color == MagickFalse)
             {
                if (colormap[i].red != colormap[i].green ||
                    colormap[i].red != colormap[i].blue)
                  {
                     ping_have_color=MagickTrue;
                     ping_have_non_bw=MagickTrue;
                     break;
                  }
              }

           if (ping_have_non_bw == MagickFalse)
             {
               if (colormap[i].red != 0 && colormap[i].red != QuantumRange)
                   ping_have_non_bw=MagickTrue;
             }
          }

        if ((mng_info->ping_exclude_tRNS == MagickFalse ||
            (number_transparent == 0 && number_semitransparent == 0)) &&
            (((mng_info->write_png_colortype-1) ==
            PNG_COLOR_TYPE_PALETTE) ||
            (mng_info->write_png_colortype == 0)))
          {
            if (logging != MagickFalse)
              {
                if (n !=  (ssize_t) image_colors)
                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""   image_colors (%d) and n (%d)  don't match"",
                   image_colors, n);

                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      AcquireImageColormap"");
              }

            image->colors = image_colors;

            if (AcquireImageColormap(image,image_colors,exception) ==
                MagickFalse)
               ThrowWriterException(ResourceLimitError,
                   ""MemoryAllocationFailed"");

            for (i=0; i< (ssize_t) image_colors; i++)
               image->colormap[i] = colormap[i];

            if (logging != MagickFalse)
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                      ""      image->colors=%d (%d)"",
                      (int) image->colors, image_colors);

                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                      ""      Update the pixel indexes"");
              }

            /* Sync the pixel indices with the new colormap */

            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);

              if (q == (Quantum *) NULL)
                break;

              for (x=0; x < (ssize_t) image->columns; x++)
              {
                for (i=0; i< (ssize_t) image_colors; i++)
                {
                  if ((image->alpha_trait == UndefinedPixelTrait ||
                      image->colormap[i].alpha == GetPixelAlpha(image,q)) &&
                      image->colormap[i].red == GetPixelRed(image,q) &&
                      image->colormap[i].green == GetPixelGreen(image,q) &&
                      image->colormap[i].blue == GetPixelBlue(image,q))
                  {
                    SetPixelIndex(image,i,q);
                    break;
                  }
                }
                q+=GetPixelChannels(image);
              }

              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
            }
          }
       }

     if (logging != MagickFalse)
       {
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""      image->colors=%d"", (int) image->colors);

         if (image->colormap != NULL)
           {
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""       i     (red,green,blue,alpha)"");

             for (i=0; i < (ssize_t) image->colors; i++)
             {
               if (i < 300 || i >= (ssize_t) image->colors - 10)
                 {
                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                       ""       %d     (%d,%d,%d,%d)"",
                        (int) i,
                        (int) image->colormap[i].red,
                        (int) image->colormap[i].green,
                        (int) image->colormap[i].blue,
                        (int) image->colormap[i].alpha);
                 }
             }
           }

           if (number_transparent < 257)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      number_transparent     = %d"",
                   number_transparent);
           else

             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      number_transparent     > 256"");

           if (number_opaque < 257)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      number_opaque          = %d"",
                   number_opaque);

           else
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      number_opaque          > 256"");

           if (number_semitransparent < 257)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      number_semitransparent = %d"",
                   number_semitransparent);

           else
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      number_semitransparent > 256"");

           if (ping_have_non_bw == MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      All pixels and the background are black or white"");

           else if (ping_have_color == MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      All pixels and the background are gray"");

           else
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      At least one pixel or the background is non-gray"");

           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""    Exit BUILD_PALETTE:"");
       }

   if (mng_info->write_png8 == MagickFalse)
      break;

   /* Make any reductions necessary for the PNG8 format */
    if (image_colors <= 256 &&
        image_colors != 0 && image->colormap != NULL &&
        number_semitransparent == 0 &&
        number_transparent <= 1)
      break;

    /* PNG8 can't have semitransparent colors so we threshold the
     * opacity to 0 or OpaqueOpacity, and PNG8 can only have one
     * transparent color so if more than one is transparent we merge
     * them into image->background_color.
     */
    if (number_semitransparent != 0 || number_transparent > 1)
      {
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Thresholding the alpha channel to binary"");

        for (y=0; y < (ssize_t) image->rows; y++)
        {
          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

          if (r == (Quantum *) NULL)
            break;

          for (x=0; x < (ssize_t) image->columns; x++)
          {
              if (GetPixelAlpha(image,r) < OpaqueAlpha/2)
                {
                  SetPixelViaPixelInfo(image,&image->background_color,r);
                  SetPixelAlpha(image,TransparentAlpha,r);
                }
              else
                  SetPixelAlpha(image,OpaqueAlpha,r);
              r+=GetPixelChannels(image);
          }

          if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;

          if (image_colors != 0 && image_colors <= 256 &&
             image->colormap != NULL)
            for (i=0; i<image_colors; i++)
                image->colormap[i].alpha =
                    (image->colormap[i].alpha > TransparentAlpha/2 ?
                    TransparentAlpha : OpaqueAlpha);
        }
      continue;
    }

    /* PNG8 can't have more than 256 colors so we quantize the pixels and
     * background color to the 4-4-4-1, 3-3-3-1 or 3-3-2-1 palette.  If the
     * image is mostly gray, the 4-4-4-1 palette is likely to end up with 256
     * colors or less.
     */
    if (tried_444 == MagickFalse && (image_colors == 0 || image_colors > 256))
      {
        if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""    Quantizing the background color to 4-4-4"");

        tried_444 = MagickTrue;

        LBR04PacketRGB(image->background_color);

        if (logging != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    Quantizing the pixel colors to 4-4-4"");

        if (image->colormap == NULL)
        {
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

            if (r == (Quantum *) NULL)
              break;

            for (x=0; x < (ssize_t) image->columns; x++)
            {
              if (GetPixelAlpha(image,r) == OpaqueAlpha)
                  LBR04PixelRGB(r);
              r+=GetPixelChannels(image);
            }

            if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
          }
        }

        else /* Should not reach this; colormap already exists and
                must be <= 256 */
        {
          if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    Quantizing the colormap to 4-4-4"");

          for (i=0; i<image_colors; i++)
          {
            LBR04PacketRGB(image->colormap[i]);
          }
        }
        continue;
      }

    if (tried_333 == MagickFalse && (image_colors == 0 || image_colors > 256))
      {
        if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""    Quantizing the background color to 3-3-3"");

        tried_333 = MagickTrue;

        LBR03PacketRGB(image->background_color);

        if (logging != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    Quantizing the pixel colors to 3-3-3-1"");

        if (image->colormap == NULL)
        {
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

            if (r == (Quantum *) NULL)
              break;

            for (x=0; x < (ssize_t) image->columns; x++)
            {
              if (GetPixelAlpha(image,r) == OpaqueAlpha)
                  LBR03RGB(r);
              r+=GetPixelChannels(image);
            }

            if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
          }
        }

        else /* Should not reach this; colormap already exists and
                must be <= 256 */
        {
          if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    Quantizing the colormap to 3-3-3-1"");
          for (i=0; i<image_colors; i++)
          {
              LBR03PacketRGB(image->colormap[i]);
          }
        }
        continue;
      }

    if (tried_332 == MagickFalse && (image_colors == 0 || image_colors > 256))
      {
        if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""    Quantizing the background color to 3-3-2"");

        tried_332 = MagickTrue;

        /* Red and green were already done so we only quantize the blue
         * channel
         */

        LBR02PacketBlue(image->background_color);

        if (logging != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    Quantizing the pixel colors to 3-3-2-1"");

        if (image->colormap == NULL)
        {
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

            if (r == (Quantum *) NULL)
              break;

            for (x=0; x < (ssize_t) image->columns; x++)
            {
              if (GetPixelAlpha(image,r) == OpaqueAlpha)
                  LBR02PixelBlue(r);
              r+=GetPixelChannels(image);
            }

            if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
          }
        }

        else /* Should not reach this; colormap already exists and
                must be <= 256 */
        {
          if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    Quantizing the colormap to 3-3-2-1"");
          for (i=0; i<image_colors; i++)
          {
              LBR02PacketBlue(image->colormap[i]);
          }
      }
      continue;
    }

    if (image_colors == 0 || image_colors > 256)
    {
      /* Take care of special case with 256 opaque colors + 1 transparent
       * color.  We don't need to quantize to 2-3-2-1; we only need to
       * eliminate one color, so we'll merge the two darkest red
       * colors (0x49, 0, 0) -> (0x24, 0, 0).
       */
      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Merging two dark red background colors to 3-3-2-1"");

      if (ScaleQuantumToChar(image->background_color.red) == 0x49 &&
          ScaleQuantumToChar(image->background_color.green) == 0x00 &&
          ScaleQuantumToChar(image->background_color.blue) == 0x00)
      {
         image->background_color.red=ScaleCharToQuantum(0x24);
      }

      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Merging two dark red pixel colors to 3-3-2-1"");

      if (image->colormap == NULL)
      {
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

          if (r == (Quantum *) NULL)
            break;

          for (x=0; x < (ssize_t) image->columns; x++)
          {
            if (ScaleQuantumToChar(GetPixelRed(image,r)) == 0x49 &&
                ScaleQuantumToChar(GetPixelGreen(image,r)) == 0x00 &&
                ScaleQuantumToChar(GetPixelBlue(image,r)) == 0x00 &&
                GetPixelAlpha(image,r) == OpaqueAlpha)
              {
                SetPixelRed(image,ScaleCharToQuantum(0x24),r);
              }
            r+=GetPixelChannels(image);
          }

          if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;

        }
      }

      else
      {
         for (i=0; i<image_colors; i++)
         {
            if (ScaleQuantumToChar(image->colormap[i].red) == 0x49 &&
                ScaleQuantumToChar(image->colormap[i].green) == 0x00 &&
                ScaleQuantumToChar(image->colormap[i].blue) == 0x00)
            {
               image->colormap[i].red=ScaleCharToQuantum(0x24);
            }
         }
      }
    }
  }
  }
  /* END OF BUILD_PALETTE */

  /* If we are excluding the tRNS chunk and there is transparency,
   * then we must write a Gray-Alpha (color-type 4) or RGBA (color-type 6)
   * PNG.
   */
  if (mng_info->ping_exclude_tRNS != MagickFalse &&
     (number_transparent != 0 || number_semitransparent != 0))
    {
      unsigned int colortype=mng_info->write_png_colortype;

      if (ping_have_color == MagickFalse)
        mng_info->write_png_colortype = 5;

      else
        mng_info->write_png_colortype = 7;

      if (colortype != 0 &&
         mng_info->write_png_colortype != colortype)
        ping_need_colortype_warning=MagickTrue;

    }

  /* See if cheap transparency is possible.  It is only possible
   * when there is a single transparent color, no semitransparent
   * color, and no opaque color that has the same RGB components
   * as the transparent color.  We only need this information if
   * we are writing a PNG with colortype 0 or 2, and we have not
   * excluded the tRNS chunk.
   */
  if (number_transparent == 1 &&
      mng_info->write_png_colortype < 4)
    {
       ping_have_cheap_transparency = MagickTrue;

       if (number_semitransparent != 0)
         ping_have_cheap_transparency = MagickFalse;

       else if (image_colors == 0 || image_colors > 256 ||
           image->colormap == NULL)
         {
           register const Quantum
             *q;

           for (y=0; y < (ssize_t) image->rows; y++)
           {
             q=GetVirtualPixels(image,0,y,image->columns,1, exception);

             if (q == (Quantum *) NULL)
               break;

             for (x=0; x < (ssize_t) image->columns; x++)
             {
                 if (GetPixelAlpha(image,q) != TransparentAlpha &&
                     (unsigned short) GetPixelRed(image,q) ==
                                     ping_trans_color.red &&
                     (unsigned short) GetPixelGreen(image,q) ==
                                     ping_trans_color.green &&
                     (unsigned short) GetPixelBlue(image,q) ==
                                     ping_trans_color.blue)
                   {
                     ping_have_cheap_transparency = MagickFalse;
                     break;
                   }

                 q+=GetPixelChannels(image);
             }

             if (ping_have_cheap_transparency == MagickFalse)
                break;
           }
         }
       else
         {
            /* Assuming that image->colormap[0] is the one transparent color
             * and that all others are opaque.
             */
            if (image_colors > 1)
              for (i=1; i<image_colors; i++)
                if (image->colormap[i].red == image->colormap[0].red &&
                    image->colormap[i].green == image->colormap[0].green &&
                    image->colormap[i].blue == image->colormap[0].blue)
                  {
                     ping_have_cheap_transparency = MagickFalse;
                     break;
                  }
         }

       if (logging != MagickFalse)
         {
           if (ping_have_cheap_transparency == MagickFalse)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""   Cheap transparency is not possible."");

           else
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""   Cheap transparency is possible."");
         }
     }
  else
    ping_have_cheap_transparency = MagickFalse;

  image_depth=image->depth;

  quantum_info = (QuantumInfo *) NULL;
  number_colors=0;
  image_colors=(int) image->colors;
  image_matte=image->alpha_trait !=
        UndefinedPixelTrait ? MagickTrue : MagickFalse;

  if (mng_info->write_png_colortype < 5)
    mng_info->IsPalette=image->storage_class == PseudoClass &&
      image_colors <= 256 && image->colormap != NULL;
  else
    mng_info->IsPalette = MagickFalse;

  if ((mng_info->write_png_colortype == 4 || mng_info->write_png8) &&
     (image->colors == 0 || image->colormap == NULL))
    {
      image_info=DestroyImageInfo(image_info);
      image=DestroyImage(image);
      (void) ThrowMagickException(exception,GetMagickModule(),CoderError,
          ""Cannot write PNG8 or color-type 3; colormap is NULL"",
          ""`%s'"",IMimage->filename);
      return(MagickFalse);
    }

  /*
    Allocate the PNG structures
  */
#ifdef PNG_USER_MEM_SUPPORTED
 error_info.image=image;
 error_info.exception=exception;
  ping=png_create_write_struct_2(PNG_LIBPNG_VER_STRING,&error_info,
    MagickPNGErrorHandler,MagickPNGWarningHandler,(void *) NULL,
    (png_malloc_ptr) Magick_png_malloc,(png_free_ptr) Magick_png_free);

#else
  ping=png_create_write_struct(PNG_LIBPNG_VER_STRING,&error_info,
    MagickPNGErrorHandler,MagickPNGWarningHandler);

#endif
  if (ping == (png_struct *) NULL)
    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");

  ping_info=png_create_info_struct(ping);

  if (ping_info == (png_info *) NULL)
    {
      png_destroy_write_struct(&ping,(png_info **) NULL);
      ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
    }

  png_set_write_fn(ping,image,png_put_data,png_flush_data);
  pixel_info=(MemoryInfo *) NULL;

  if (setjmp(png_jmpbuf(ping)))
    {
      /*
        PNG write failed.
      */
#ifdef PNG_DEBUG
     if (image_info->verbose)
        (void) printf(""PNG write has failed.\n"");
#endif
      png_destroy_write_struct(&ping,&ping_info);
#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE
      UnlockSemaphoreInfo(ping_semaphore);
#endif

      if (pixel_info != (MemoryInfo *) NULL)
        pixel_info=RelinquishVirtualMemory(pixel_info);

      if (quantum_info != (QuantumInfo *) NULL)
        quantum_info=DestroyQuantumInfo(quantum_info);

      if (ping_have_blob != MagickFalse)
          (void) CloseBlob(image);
      image_info=DestroyImageInfo(image_info);
      image=DestroyImage(image);
      return(MagickFalse);
    }

  /* {  For navigation to end of SETJMP-protected block.  Within this
   *    block, use png_error() instead of Throwing an Exception, to ensure
   *    that libpng is able to clean up, and that the semaphore is unlocked.
   */

#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE
  LockSemaphoreInfo(ping_semaphore);
#endif

#ifdef PNG_BENIGN_ERRORS_SUPPORTED
  /* Allow benign errors */
  png_set_benign_errors(ping, 1);
#endif

#ifdef PNG_SET_USER_LIMITS_SUPPORTED
  /* Reject images with too many rows or columns */
  png_set_user_limits(ping,
    (png_uint_32) MagickMin(0x7fffffffL,
        GetMagickResourceLimit(WidthResource)),
    (png_uint_32) MagickMin(0x7fffffffL,
        GetMagickResourceLimit(HeightResource)));
#endif /* PNG_SET_USER_LIMITS_SUPPORTED */

  /*
    Prepare PNG for writing.
  */

#if defined(PNG_MNG_FEATURES_SUPPORTED)
  if (mng_info->write_mng)
  {
     (void) png_permit_mng_features(ping,PNG_ALL_MNG_FEATURES);
# ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
     /* Disable new libpng-1.5.10 feature when writing a MNG because
      * zero-length PLTE is OK
      */
     png_set_check_for_invalid_index (ping, 0);
# endif
  }

#else
# ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED
  if (mng_info->write_mng)
     png_permit_empty_plte(ping,MagickTrue);

# endif
#endif

  x=0;

  ping_width=(png_uint_32) image->columns;
  ping_height=(png_uint_32) image->rows;

  if (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32)
     image_depth=8;

  if (mng_info->write_png48 || mng_info->write_png64)
     image_depth=16;

  if (mng_info->write_png_depth != 0)
     image_depth=mng_info->write_png_depth;

  /* Adjust requested depth to next higher valid depth if necessary */
  if (image_depth > 8)
     image_depth=16;

  if ((image_depth > 4) && (image_depth < 8))
     image_depth=8;

  if (image_depth == 3)
     image_depth=4;

  if (logging != MagickFalse)
    {
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    width=%.20g"",(double) ping_width);
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    height=%.20g"",(double) ping_height);
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    image_matte=%.20g"",(double) image->alpha_trait);
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    image->depth=%.20g"",(double) image->depth);
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    Tentative ping_bit_depth=%.20g"",(double) image_depth);
    }

  save_image_depth=image_depth;
  ping_bit_depth=(png_byte) save_image_depth;


#if defined(PNG_pHYs_SUPPORTED)
  if (ping_exclude_pHYs == MagickFalse)
  {
  if ((image->resolution.x != 0) && (image->resolution.y != 0) &&
      (!mng_info->write_mng || !mng_info->equal_physs))
    {
      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Setting up pHYs chunk"");

      if (image->units == PixelsPerInchResolution)
        {
          ping_pHYs_unit_type=PNG_RESOLUTION_METER;
          ping_pHYs_x_resolution=
             (png_uint_32) ((100.0*image->resolution.x+0.5)/2.54);
          ping_pHYs_y_resolution=
             (png_uint_32) ((100.0*image->resolution.y+0.5)/2.54);
        }

      else if (image->units == PixelsPerCentimeterResolution)
        {
          ping_pHYs_unit_type=PNG_RESOLUTION_METER;
          ping_pHYs_x_resolution=(png_uint_32) (100.0*image->resolution.x+0.5);
          ping_pHYs_y_resolution=(png_uint_32) (100.0*image->resolution.y+0.5);
        }

      else
        {
          ping_pHYs_unit_type=PNG_RESOLUTION_UNKNOWN;
          ping_pHYs_x_resolution=(png_uint_32) image->resolution.x;
          ping_pHYs_y_resolution=(png_uint_32) image->resolution.y;
        }

      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    Set up PNG pHYs chunk: xres: %.20g, yres: %.20g, units: %d."",
          (double) ping_pHYs_x_resolution,(double) ping_pHYs_y_resolution,
          (int) ping_pHYs_unit_type);
       ping_have_pHYs = MagickTrue;
    }
  }
#endif

  if (ping_exclude_bKGD == MagickFalse)
  {
  if ((!mng_info->adjoin || !mng_info->equal_backgrounds))
    {
       unsigned int
         mask;

       mask=0xffff;
       if (ping_bit_depth == 8)
          mask=0x00ff;

       if (ping_bit_depth == 4)
          mask=0x000f;

       if (ping_bit_depth == 2)
          mask=0x0003;

       if (ping_bit_depth == 1)
          mask=0x0001;

       ping_background.red=(png_uint_16)
         (ScaleQuantumToShort(image->background_color.red) & mask);

       ping_background.green=(png_uint_16)
         (ScaleQuantumToShort(image->background_color.green) & mask);

       ping_background.blue=(png_uint_16)
         (ScaleQuantumToShort(image->background_color.blue) & mask);

       ping_background.gray=(png_uint_16) ping_background.green;
    }

  if (logging != MagickFalse)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    Setting up bKGD chunk (1)"");
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""      background_color index is %d"",
          (int) ping_background.index);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    ping_bit_depth=%d"",ping_bit_depth);
    }

  ping_have_bKGD = MagickTrue;
  }

  /*
    Select the color type.
  */
  matte=image_matte;
  old_bit_depth=0;

  if (mng_info->IsPalette && mng_info->write_png8)
    {
      /* To do: make this a function cause it's used twice, except
         for reducing the sample depth from 8. */

      number_colors=image_colors;

      ping_have_tRNS=MagickFalse;

      /*
        Set image palette.
      */
      ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;

      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  Setting up PLTE chunk with %d colors (%d)"",
            number_colors, image_colors);

      for (i=0; i < (ssize_t) number_colors; i++)
      {
        palette[i].red=ScaleQuantumToChar(image->colormap[i].red);
        palette[i].green=ScaleQuantumToChar(image->colormap[i].green);
        palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);
        if (logging != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
#if MAGICKCORE_QUANTUM_DEPTH == 8
            ""    %3ld (%3d,%3d,%3d)"",
#else
            ""    %5ld (%5d,%5d,%5d)"",
#endif
            (long) i,palette[i].red,palette[i].green,palette[i].blue);

      }

      ping_have_PLTE=MagickTrue;
      image_depth=ping_bit_depth;
      ping_num_trans=0;

      if (matte != MagickFalse)
      {
          /*
            Identify which colormap entry is transparent.
          */
          assert(number_colors <= 256);
          assert(image->colormap != NULL);

          for (i=0; i < (ssize_t) number_transparent; i++)
             ping_trans_alpha[i]=0;


          ping_num_trans=(unsigned short) (number_transparent +
             number_semitransparent);

          if (ping_num_trans == 0)
             ping_have_tRNS=MagickFalse;

          else
             ping_have_tRNS=MagickTrue;
      }

      if (ping_exclude_bKGD == MagickFalse)
      {
       /*
        * Identify which colormap entry is the background color.
        */

        for (i=0; i < (ssize_t) MagickMax(1L*number_colors-1L,1L); i++)
          if (IsPNGColorEqual(ping_background,image->colormap[i]))
            break;

        ping_background.index=(png_byte) i;

        if (logging != MagickFalse)
          {
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""      background_color index is %d"",
                 (int) ping_background.index);
          }
      }
    } /* end of write_png8 */

  else if (mng_info->write_png_colortype == 1)
    {
      image_matte=MagickFalse;
      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;
    }

  else if (mng_info->write_png24 || mng_info->write_png48 ||
      mng_info->write_png_colortype == 3)
    {
      image_matte=MagickFalse;
      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;
    }

  else if (mng_info->write_png32 || mng_info->write_png64 ||
      mng_info->write_png_colortype == 7)
    {
      image_matte=MagickTrue;
      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;
    }

  else /* mng_info->write_pngNN not specified */
    {
      image_depth=ping_bit_depth;

      if (mng_info->write_png_colortype != 0)
        {
          ping_color_type=(png_byte) mng_info->write_png_colortype-1;

          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            image_matte=MagickTrue;

          else
            image_matte=MagickFalse;

          if (logging != MagickFalse)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""   PNG colortype %d was specified:"",(int) ping_color_type);
        }

      else /* write_png_colortype not specified */
        {
          if (logging != MagickFalse)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  Selecting PNG colortype:"");

          ping_color_type=(png_byte) ((matte != MagickFalse)?
            PNG_COLOR_TYPE_RGB_ALPHA:PNG_COLOR_TYPE_RGB);

          if (image_info->type == TrueColorType)
            {
              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;
              image_matte=MagickFalse;
            }

          if (image_info->type == TrueColorAlphaType)
            {
              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;
              image_matte=MagickTrue;
            }

          if (image_info->type == PaletteType ||
              image_info->type == PaletteAlphaType)
            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;

          if (mng_info->write_png_colortype == 0 &&
             image_info->type == UndefinedType)
            {
              if (ping_have_color == MagickFalse)
                {
                  if (image_matte == MagickFalse)
                    {
                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;
                      image_matte=MagickFalse;
                    }

                  else
                    {
                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY_ALPHA;
                      image_matte=MagickTrue;
                    }
                }
              else
                {
                  if (image_matte == MagickFalse)
                    {
                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;
                      image_matte=MagickFalse;
                    }

                  else
                    {
                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGBA;
                      image_matte=MagickTrue;
                    }
                 }
            }

        }

      if (logging != MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    Selected PNG colortype=%d"",ping_color_type);

      if (ping_bit_depth < 8)
        {
          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
              ping_color_type == PNG_COLOR_TYPE_RGB ||
              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            ping_bit_depth=8;
        }

      old_bit_depth=ping_bit_depth;

      if (ping_color_type == PNG_COLOR_TYPE_GRAY)
        {
          if (image->alpha_trait == UndefinedPixelTrait &&
               ping_have_non_bw == MagickFalse)
             ping_bit_depth=1;
        }

      if (ping_color_type == PNG_COLOR_TYPE_PALETTE)
        {
           size_t one = 1;
           ping_bit_depth=1;

           if (image->colors == 0)
           {
              /* DO SOMETHING */
                png_error(ping,""image has 0 colors"");
           }

           while ((int) (one << ping_bit_depth) < (ssize_t) image_colors)
             ping_bit_depth <<= 1;
        }

      if (logging != MagickFalse)
         {
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Number of colors: %.20g"",(double) image_colors);

           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Tentative PNG bit depth: %d"",ping_bit_depth);
         }

      if (ping_bit_depth < (int) mng_info->write_png_depth)
         ping_bit_depth = mng_info->write_png_depth;
    }

  image_depth=ping_bit_depth;

  if (logging != MagickFalse)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    Tentative PNG color type: %s (%.20g)"",
        PngColorTypeToString(ping_color_type),
        (double) ping_color_type);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    image_info->type: %.20g"",(double) image_info->type);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    image_depth: %.20g"",(double) image_depth);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),

        ""    image->depth: %.20g"",(double) image->depth);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    ping_bit_depth: %.20g"",(double) ping_bit_depth);
    }

  if (matte != MagickFalse)
    {
      if (mng_info->IsPalette)
        {
          if (mng_info->write_png_colortype == 0)
            {
              ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;

              if (ping_have_color != MagickFalse)
                 ping_color_type=PNG_COLOR_TYPE_RGBA;
            }

          /*
           * Determine if there is any transparent color.
          */
          if (number_transparent + number_semitransparent == 0)
            {
              /*
                No transparent pixels are present.  Change 4 or 6 to 0 or 2.
              */

              image_matte=MagickFalse;

              if (mng_info->write_png_colortype == 0)
                ping_color_type&=0x03;
            }

          else
            {
              unsigned int
                mask;

              mask=0xffff;

              if (ping_bit_depth == 8)
                 mask=0x00ff;

              if (ping_bit_depth == 4)
                 mask=0x000f;

              if (ping_bit_depth == 2)
                 mask=0x0003;

              if (ping_bit_depth == 1)
                 mask=0x0001;

              ping_trans_color.red=(png_uint_16)
                (ScaleQuantumToShort(image->colormap[0].red) & mask);

              ping_trans_color.green=(png_uint_16)
                (ScaleQuantumToShort(image->colormap[0].green) & mask);

              ping_trans_color.blue=(png_uint_16)
                (ScaleQuantumToShort(image->colormap[0].blue) & mask);

              ping_trans_color.gray=(png_uint_16)
                (ScaleQuantumToShort(GetPixelInfoIntensity(image,
                   image->colormap)) & mask);

              ping_trans_color.index=(png_byte) 0;

              ping_have_tRNS=MagickTrue;
            }

          if (ping_have_tRNS != MagickFalse)
            {
              /*
               * Determine if there is one and only one transparent color
               * and if so if it is fully transparent.
               */
              if (ping_have_cheap_transparency == MagickFalse)
                ping_have_tRNS=MagickFalse;
            }

          if (ping_have_tRNS != MagickFalse)
            {
              if (mng_info->write_png_colortype == 0)
                ping_color_type &= 0x03;  /* changes 4 or 6 to 0 or 2 */

              if (image_depth == 8)
                {
                  ping_trans_color.red&=0xff;
                  ping_trans_color.green&=0xff;
                  ping_trans_color.blue&=0xff;
                  ping_trans_color.gray&=0xff;
                }
            }
        }
      else
        {
          if (image_depth == 8)
            {
              ping_trans_color.red&=0xff;
              ping_trans_color.green&=0xff;
              ping_trans_color.blue&=0xff;
              ping_trans_color.gray&=0xff;
            }
        }
    }

    matte=image_matte;

    if (ping_have_tRNS != MagickFalse)
      image_matte=MagickFalse;

    if ((mng_info->IsPalette) &&
        mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE &&
        ping_have_color == MagickFalse &&
        (image_matte == MagickFalse || image_depth >= 8))
      {
        size_t one=1;

        if (image_matte != MagickFalse)
          ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;

        else if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_GRAY_ALPHA)
          {
            ping_color_type=PNG_COLOR_TYPE_GRAY;

            if (save_image_depth == 16 && image_depth == 8)
              {
                if (logging != MagickFalse)
                  {
                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                        ""  Scaling ping_trans_color (0)"");
                  }
                    ping_trans_color.gray*=0x0101;
              }
          }

        if (image_depth > MAGICKCORE_QUANTUM_DEPTH)
          image_depth=MAGICKCORE_QUANTUM_DEPTH;

        if ((image_colors == 0) ||
             ((ssize_t) (image_colors-1) > (ssize_t) MaxColormapSize))
          image_colors=(int) (one << image_depth);

        if (image_depth > 8)
          ping_bit_depth=16;

        else
          {
            ping_bit_depth=8;
            if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)
              {
                if(!mng_info->write_png_depth)
                  {
                    ping_bit_depth=1;

                    while ((int) (one << ping_bit_depth)
                        < (ssize_t) image_colors)
                      ping_bit_depth <<= 1;
                  }
              }

            else if (ping_color_type ==
                PNG_COLOR_TYPE_GRAY && image_colors < 17 &&
                mng_info->IsPalette)
              {
              /* Check if grayscale is reducible */

                int
                  depth_4_ok=MagickTrue,
                  depth_2_ok=MagickTrue,
                  depth_1_ok=MagickTrue;

                for (i=0; i < (ssize_t) image_colors; i++)
                {
                   unsigned char
                     intensity;

                   intensity=ScaleQuantumToChar(image->colormap[i].red);

                   if ((intensity & 0x0f) != ((intensity & 0xf0) >> 4))
                     depth_4_ok=depth_2_ok=depth_1_ok=MagickFalse;
                   else if ((intensity & 0x03) != ((intensity & 0x0c) >> 2))
                     depth_2_ok=depth_1_ok=MagickFalse;
                   else if ((intensity & 0x01) != ((intensity & 0x02) >> 1))
                     depth_1_ok=MagickFalse;
                }

                if (depth_1_ok && mng_info->write_png_depth <= 1)
                  ping_bit_depth=1;

                else if (depth_2_ok && mng_info->write_png_depth <= 2)
                  ping_bit_depth=2;

                else if (depth_4_ok && mng_info->write_png_depth <= 4)
                  ping_bit_depth=4;
              }
          }

          image_depth=ping_bit_depth;
      }

    else

      if (mng_info->IsPalette)
      {
        number_colors=image_colors;

        if (image_depth <= 8)
          {
            /*
              Set image palette.
            */
            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;

            if (!(mng_info->have_write_global_plte && matte == MagickFalse))
              {
                for (i=0; i < (ssize_t) number_colors; i++)
                {
                  palette[i].red=ScaleQuantumToChar(image->colormap[i].red);
                  palette[i].green=
                    ScaleQuantumToChar(image->colormap[i].green);
                  palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);
                }

                if (logging != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""  Setting up PLTE chunk with %d colors"",
                    number_colors);

                ping_have_PLTE=MagickTrue;
              }

            /* color_type is PNG_COLOR_TYPE_PALETTE */
            if (mng_info->write_png_depth == 0)
              {
                size_t
                  one;

                ping_bit_depth=1;
                one=1;

                while ((one << ping_bit_depth) < (size_t) number_colors)
                  ping_bit_depth <<= 1;
              }

            ping_num_trans=0;

            if (matte != MagickFalse)
              {
                /*
                 * Set up trans_colors array.
                 */
                assert(number_colors <= 256);

                ping_num_trans=(unsigned short) (number_transparent +
                  number_semitransparent);

                if (ping_num_trans == 0)
                  ping_have_tRNS=MagickFalse;

                else
                  {
                    if (logging != MagickFalse)
                      {
                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                          ""  Scaling ping_trans_color (1)"");
                      }
                    ping_have_tRNS=MagickTrue;

                    for (i=0; i < ping_num_trans; i++)
                    {
                       ping_trans_alpha[i]= (png_byte)
                         ScaleQuantumToChar(image->colormap[i].alpha);
                    }
                  }
              }
          }
      }

    else
      {

        if (image_depth < 8)
          image_depth=8;

        if ((save_image_depth == 16) && (image_depth == 8))
          {
            if (logging != MagickFalse)
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""    Scaling ping_trans_color from (%d,%d,%d)"",
                  (int) ping_trans_color.red,
                  (int) ping_trans_color.green,
                  (int) ping_trans_color.blue);
              }

            ping_trans_color.red*=0x0101;
            ping_trans_color.green*=0x0101;
            ping_trans_color.blue*=0x0101;
            ping_trans_color.gray*=0x0101;

            if (logging != MagickFalse)
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""    to (%d,%d,%d)"",
                  (int) ping_trans_color.red,
                  (int) ping_trans_color.green,
                  (int) ping_trans_color.blue);
              }
          }
      }

    if (ping_bit_depth <  (ssize_t) mng_info->write_png_depth)
         ping_bit_depth =  (ssize_t) mng_info->write_png_depth;

    /*
      Adjust background and transparency samples in sub-8-bit grayscale files.
    */
    if (ping_bit_depth < 8 && ping_color_type ==
        PNG_COLOR_TYPE_GRAY)
      {
         png_uint_16
           maxval;

         size_t
           one=1;

         maxval=(png_uint_16) ((one << ping_bit_depth)-1);

         if (ping_exclude_bKGD == MagickFalse)
         {

         ping_background.gray=(png_uint_16) ((maxval/65535.)*
           (ScaleQuantumToShort(((GetPixelInfoIntensity(image,
           &image->background_color))) +.5)));

         if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  Setting up bKGD chunk (2)"");
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      background_color index is %d"",
             (int) ping_background.index);

         ping_have_bKGD = MagickTrue;
         }

         if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  Scaling ping_trans_color.gray from %d"",
             (int)ping_trans_color.gray);

         ping_trans_color.gray=(png_uint_16) ((maxval/255.)*(
           ping_trans_color.gray)+.5);

         if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      to %d"", (int)ping_trans_color.gray);
      }

  if (ping_exclude_bKGD == MagickFalse)
  {
    if (mng_info->IsPalette && (int) ping_color_type == PNG_COLOR_TYPE_PALETTE)
      {
        /*
           Identify which colormap entry is the background color.
        */

        number_colors=image_colors;

        for (i=0; i < (ssize_t) MagickMax(1L*number_colors,1L); i++)
          if (IsPNGColorEqual(image->background_color,image->colormap[i]))
            break;

        ping_background.index=(png_byte) i;

        if (logging != MagickFalse)
          {
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Setting up bKGD chunk with index=%d"",(int) i);
          }

        if (i < (ssize_t) number_colors)
          {
            ping_have_bKGD = MagickTrue;

            if (logging != MagickFalse)
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""     background   =(%d,%d,%d)"",
                        (int) ping_background.red,
                        (int) ping_background.green,
                        (int) ping_background.blue);
              }
          }

        else  /* Can't happen */
          {
            if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      No room in PLTE to add bKGD color"");
            ping_have_bKGD = MagickFalse;
          }
      }
  }

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""    PNG color type: %s (%d)"", PngColorTypeToString(ping_color_type),
      ping_color_type);
  /*
    Initialize compression level and filtering.
  */
  if (logging != MagickFalse)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""  Setting up deflate compression"");

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    Compression buffer size: 32768"");
    }

  png_set_compression_buffer_size(ping,32768L);

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""    Compression mem level: 9"");

  png_set_compression_mem_level(ping, 9);

  /* Untangle the ""-quality"" setting:

     Undefined is 0; the default is used.
     Default is 75

     10's digit:

        0 or omitted: Use Z_HUFFMAN_ONLY strategy with the
           zlib default compression level

        1-9: the zlib compression level

     1's digit:

        0-4: the PNG filter method

        5:   libpng adaptive filtering if compression level > 5
             libpng filter type ""none"" if compression level <= 5
                or if image is grayscale or palette

        6:   libpng adaptive filtering

        7:   ""LOCO"" filtering (intrapixel differing) if writing
             a MNG, otherwise ""none"".  Did not work in IM-6.7.0-9
             and earlier because of a missing ""else"".

        8:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), adaptive
             filtering. Unused prior to IM-6.7.0-10, was same as 6

        9:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), no PNG filters
             Unused prior to IM-6.7.0-10, was same as 6

    Note that using the -quality option, not all combinations of
    PNG filter type, zlib compression level, and zlib compression
    strategy are possible.  This will be addressed soon in a
    release that accomodates ""-define png:compression-strategy"", etc.

   */

  quality=image_info->quality == UndefinedCompressionQuality ? 75UL :
     image_info->quality;

  if (quality <= 9)
    {
      if (mng_info->write_png_compression_strategy == 0)
        mng_info->write_png_compression_strategy = Z_HUFFMAN_ONLY+1;
    }

  else if (mng_info->write_png_compression_level == 0)
    {
      int
        level;

      level=(int) MagickMin((ssize_t) quality/10,9);

      mng_info->write_png_compression_level = level+1;
    }

  if (mng_info->write_png_compression_strategy == 0)
    {
        if ((quality %10) == 8 || (quality %10) == 9)
#ifdef Z_RLE  /* Z_RLE was added to zlib-1.2.0 */
          mng_info->write_png_compression_strategy=Z_RLE+1;
#else
          mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;
#endif
    }

  if (mng_info->write_png_compression_filter == 0)
        mng_info->write_png_compression_filter=((int) quality % 10) + 1;

  if (logging != MagickFalse)
    {
        if (mng_info->write_png_compression_level)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Compression level:    %d"",
            (int) mng_info->write_png_compression_level-1);

        if (mng_info->write_png_compression_strategy)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Compression strategy: %d"",
            (int) mng_info->write_png_compression_strategy-1);

        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  Setting up filtering"");

        if (mng_info->write_png_compression_filter == 6)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Base filter method: ADAPTIVE"");
        else if (mng_info->write_png_compression_filter == 0 ||
                 mng_info->write_png_compression_filter == 1)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Base filter method: NONE"");
        else
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Base filter method: %d"",
            (int) mng_info->write_png_compression_filter-1);
    }

  if (mng_info->write_png_compression_level != 0)
    png_set_compression_level(ping,mng_info->write_png_compression_level-1);

  if (mng_info->write_png_compression_filter == 6)
    {
      if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||
         ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE) ||
         (quality < 50))
        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);
      else
        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);
     }
  else if (mng_info->write_png_compression_filter == 7 ||
      mng_info->write_png_compression_filter == 10)
    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);

  else if (mng_info->write_png_compression_filter == 8)
    {
#if defined(PNG_MNG_FEATURES_SUPPORTED) && defined(PNG_INTRAPIXEL_DIFFERENCING)
      if (mng_info->write_mng)
      {
         if (((int) ping_color_type == PNG_COLOR_TYPE_RGB) ||
             ((int) ping_color_type == PNG_COLOR_TYPE_RGBA))
        ping_filter_method=PNG_INTRAPIXEL_DIFFERENCING;
      }
#endif
      png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);
    }

  else if (mng_info->write_png_compression_filter == 9)
    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);

  else if (mng_info->write_png_compression_filter != 0)
    png_set_filter(ping,PNG_FILTER_TYPE_BASE,
       mng_info->write_png_compression_filter-1);

  if (mng_info->write_png_compression_strategy != 0)
    png_set_compression_strategy(ping,
       mng_info->write_png_compression_strategy-1);

  ping_interlace_method=image_info->interlace != NoInterlace;

  if (mng_info->write_mng)
    png_set_sig_bytes(ping,8);

  /* Bail out if cannot meet defined png:bit-depth or png:color-type */

  if (mng_info->write_png_colortype != 0)
    {
     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY)
       if (ping_have_color != MagickFalse)
         {
           ping_color_type = PNG_COLOR_TYPE_RGB;

           if (ping_bit_depth < 8)
             ping_bit_depth=8;
         }

     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY_ALPHA)
       if (ping_have_color != MagickFalse)
         ping_color_type = PNG_COLOR_TYPE_RGB_ALPHA;
    }

  if (ping_need_colortype_warning != MagickFalse ||
     ((mng_info->write_png_depth &&
     (int) mng_info->write_png_depth != ping_bit_depth) ||
     (mng_info->write_png_colortype &&
     ((int) mng_info->write_png_colortype-1 != ping_color_type &&
      mng_info->write_png_colortype != 7 &&
      !(mng_info->write_png_colortype == 5 && ping_color_type == 0)))))
    {
      if (logging != MagickFalse)
        {
          if (ping_need_colortype_warning != MagickFalse)
            {
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""  Image has transparency but tRNS chunk was excluded"");
            }

          if (mng_info->write_png_depth)
            {
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Defined png:bit-depth=%u, Computed depth=%u"",
                  mng_info->write_png_depth,
                  ping_bit_depth);
            }

          if (mng_info->write_png_colortype)
            {
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Defined png:color-type=%u, Computed color type=%u"",
                  mng_info->write_png_colortype-1,
                  ping_color_type);
            }
        }

      png_warning(ping,
        ""Cannot write image with defined png:bit-depth or png:color-type."");
    }

  if (image_matte != MagickFalse && image->alpha_trait == UndefinedPixelTrait)
    {
      /* Add an opaque matte channel */
      image->alpha_trait = BlendPixelTrait;
      (void) SetImageAlpha(image,OpaqueAlpha,exception);

      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  Added an opaque matte channel"");
    }

  if (number_transparent != 0 || number_semitransparent != 0)
    {
      if (ping_color_type < 4)
        {
           ping_have_tRNS=MagickTrue;
           if (logging != MagickFalse)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""  Setting ping_have_tRNS=MagickTrue."");
        }
    }

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  Writing PNG header chunks"");

  png_set_IHDR(ping,ping_info,ping_width,ping_height,
               ping_bit_depth,ping_color_type,
               ping_interlace_method,ping_compression_method,
               ping_filter_method);

  if (ping_color_type == 3 && ping_have_PLTE != MagickFalse)
    {
      png_set_PLTE(ping,ping_info,palette,number_colors);

      if (logging != MagickFalse)
        {
          for (i=0; i< (ssize_t) number_colors; i++)
          {
            if (i < ping_num_trans)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""     PLTE[%d] = (%d,%d,%d), tRNS[%d] = (%d)"",
                      (int) i,
                      (int) palette[i].red,
                      (int) palette[i].green,
                      (int) palette[i].blue,
                      (int) i,
                      (int) ping_trans_alpha[i]);
             else
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""     PLTE[%d] = (%d,%d,%d)"",
                      (int) i,
                      (int) palette[i].red,
                      (int) palette[i].green,
                      (int) palette[i].blue);
           }
         }
    }

  /* Only write the iCCP chunk if we are not writing the sRGB chunk. */
  if (ping_exclude_sRGB != MagickFalse ||
     (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))
  {
    if ((ping_exclude_tEXt == MagickFalse ||
       ping_exclude_zTXt == MagickFalse) &&
       (ping_exclude_iCCP == MagickFalse || ping_exclude_zCCP == MagickFalse))
    {
      ResetImageProfileIterator(image);
      for (name=GetNextImageProfile(image); name != (const char *) NULL; )
      {
        profile=GetImageProfile(image,name);

        if (profile != (StringInfo *) NULL)
          {
#ifdef PNG_WRITE_iCCP_SUPPORTED
            if ((LocaleCompare(name,""ICC"") == 0) ||
                (LocaleCompare(name,""ICM"") == 0))
              {
                ping_have_iCCP = MagickTrue;
                if (ping_exclude_iCCP == MagickFalse)
                  {
                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                        ""  Setting up iCCP chunk"");

                    png_set_iCCP(ping,ping_info,(png_charp) name,0,
#if (PNG_LIBPNG_VER < 10500)
                    (png_charp) GetStringInfoDatum(profile),
#else
                    (const png_byte *) GetStringInfoDatum(profile),
#endif
                    (png_uint_32) GetStringInfoLength(profile));
                  }
                else
                  {
                    /* Do not write hex-encoded ICC chunk */
                       name=GetNextImageProfile(image);
                       continue;
                  }
              }
#endif /* WRITE_iCCP */

            if (LocaleCompare(name,""exif"") == 0)
              {
                   /* Do not write hex-encoded ICC chunk; we will
                      write it later as an eXIf chunk */
                   name=GetNextImageProfile(image);
                   continue;
              }

              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""  Setting up zTXt chunk with uuencoded %s profile"",
                 name);
              Magick_png_write_raw_profile(image_info,ping,ping_info,
                (unsigned char *) name,(unsigned char *) name,
                GetStringInfoDatum(profile),
                (png_uint_32) GetStringInfoLength(profile));
          }
        name=GetNextImageProfile(image);
      }
    }
  }

#if defined(PNG_WRITE_sRGB_SUPPORTED)
  if ((mng_info->have_write_global_srgb == 0) &&
      ping_have_iCCP != MagickTrue &&
      (ping_have_sRGB != MagickFalse ||
      png_get_valid(ping,ping_info,PNG_INFO_sRGB)))
    {
      if (ping_exclude_sRGB == MagickFalse)
        {
          /*
            Note image rendering intent.
          */
          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  Setting up sRGB chunk"");

          (void) png_set_sRGB(ping,ping_info,(
            Magick_RenderingIntent_to_PNG_RenderingIntent(
              image->rendering_intent)));

          ping_have_sRGB = MagickTrue;
        }
    }

  if ((!mng_info->write_mng) || (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))
#endif
    {
      if (ping_exclude_gAMA == MagickFalse &&
          ping_have_iCCP == MagickFalse &&
          ping_have_sRGB == MagickFalse &&
          (ping_exclude_sRGB == MagickFalse ||
          (image->gamma < .45 || image->gamma > .46)))
      {
      if ((mng_info->have_write_global_gama == 0) && (image->gamma != 0.0))
        {
          /*
            Note image gamma.
            To do: check for cHRM+gAMA == sRGB, and write sRGB instead.
          */
          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Setting up gAMA chunk"");

          png_set_gAMA(ping,ping_info,image->gamma);
        }
      }

      if (ping_exclude_cHRM == MagickFalse && ping_have_sRGB == MagickFalse)
        {
          if ((mng_info->have_write_global_chrm == 0) &&
              (image->chromaticity.red_primary.x != 0.0))
            {
              /*
                Note image chromaticity.
                Note: if cHRM+gAMA == sRGB write sRGB instead.
              */
               PrimaryInfo
                 bp,
                 gp,
                 rp,
                 wp;

               wp=image->chromaticity.white_point;
               rp=image->chromaticity.red_primary;
               gp=image->chromaticity.green_primary;
               bp=image->chromaticity.blue_primary;

               if (logging != MagickFalse)
                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""  Setting up cHRM chunk"");

               png_set_cHRM(ping,ping_info,wp.x,wp.y,rp.x,rp.y,gp.x,gp.y,
                   bp.x,bp.y);
           }
        }
    }

  if (ping_exclude_bKGD == MagickFalse)
    {
      if (ping_have_bKGD != MagickFalse)
        {
          png_set_bKGD(ping,ping_info,&ping_background);
          if (logging != MagickFalse)
            {
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""    Setting up bKGD chunk"");
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      background color = (%d,%d,%d)"",
                        (int) ping_background.red,
                        (int) ping_background.green,
                        (int) ping_background.blue);
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      index = %d, gray=%d"",
                        (int) ping_background.index,
                        (int) ping_background.gray);
            }
         }
    }

  if (ping_exclude_pHYs == MagickFalse)
    {
      if (ping_have_pHYs != MagickFalse)
        {
          png_set_pHYs(ping,ping_info,
             ping_pHYs_x_resolution,
             ping_pHYs_y_resolution,
             ping_pHYs_unit_type);

          if (logging != MagickFalse)
            {
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""    Setting up pHYs chunk"");
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      x_resolution=%lu"",
                   (unsigned long) ping_pHYs_x_resolution);
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      y_resolution=%lu"",
                   (unsigned long) ping_pHYs_y_resolution);
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      unit_type=%lu"",
                   (unsigned long) ping_pHYs_unit_type);
            }
        }
    }

#if defined(PNG_tIME_SUPPORTED)
  if (ping_exclude_tIME == MagickFalse)
    {
      const char
        *timestamp;

      if (image->taint == MagickFalse)
        {
          timestamp=GetImageOption(image_info,""png:tIME"");

          if (timestamp == (const char *) NULL)
            timestamp=GetImageProperty(image,""png:tIME"",exception);
        }

      else
        {
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  Reset tIME in tainted image"");

          timestamp=GetImageProperty(image,""date:modify"",exception);
        }

      if (timestamp != (const char *) NULL)
          write_tIME_chunk(image,ping,ping_info,timestamp,exception);
    }
#endif

  if (mng_info->need_blob != MagickFalse)
  {
    if (OpenBlob(image_info,image,WriteBinaryBlobMode,exception) ==
       MagickFalse)
       png_error(ping,""WriteBlob Failed"");

     ping_have_blob=MagickTrue;
  }

  png_write_info_before_PLTE(ping, ping_info);

  if (ping_have_tRNS != MagickFalse && ping_color_type < 4)
    {
      if (logging != MagickFalse)
        {
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Calling png_set_tRNS with num_trans=%d"",ping_num_trans);
        }

      if (ping_color_type == 3)
         (void) png_set_tRNS(ping, ping_info,
                ping_trans_alpha,
                ping_num_trans,
                NULL);

      else
        {
           (void) png_set_tRNS(ping, ping_info,
                  NULL,
                  0,
                  &ping_trans_color);

           if (logging != MagickFalse)
             {
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""     tRNS color   =(%d,%d,%d)"",
                       (int) ping_trans_color.red,
                       (int) ping_trans_color.green,
                       (int) ping_trans_color.blue);
             }
         }
    }

  /* write any png-chunk-b profiles */
  (void) Magick_png_write_chunk_from_profile(image,""PNG-chunk-b"",logging);

  png_write_info(ping,ping_info);

  /* write any PNG-chunk-m profiles */
  (void) Magick_png_write_chunk_from_profile(image,""PNG-chunk-m"",logging);

  ping_wrote_caNv = MagickFalse;

  /* write caNv chunk */
  if (ping_exclude_caNv == MagickFalse)
    {
      if ((image->page.width != 0 && image->page.width != image->columns) ||
          (image->page.height != 0 && image->page.height != image->rows) ||
          image->page.x != 0 || image->page.y != 0)
        {
          unsigned char
            chunk[20];

          (void) WriteBlobMSBULong(image,16L);  /* data length=8 */
          PNGType(chunk,mng_caNv);
          LogPNGChunk(logging,mng_caNv,16L);
          PNGLong(chunk+4,(png_uint_32) image->page.width);
          PNGLong(chunk+8,(png_uint_32) image->page.height);
          PNGsLong(chunk+12,(png_int_32) image->page.x);
          PNGsLong(chunk+16,(png_int_32) image->page.y);
          (void) WriteBlob(image,20,chunk);
          (void) WriteBlobMSBULong(image,crc32(0,chunk,20));
          ping_wrote_caNv = MagickTrue;
        }
    }

#if defined(PNG_oFFs_SUPPORTED)
  if (ping_exclude_oFFs == MagickFalse && ping_wrote_caNv == MagickFalse)
    {
      if (image->page.x || image->page.y)
        {
           png_set_oFFs(ping,ping_info,(png_int_32) image->page.x,
              (png_int_32) image->page.y, 0);

           if (logging != MagickFalse)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""    Setting up oFFs chunk with x=%d, y=%d, units=0"",
                 (int) image->page.x, (int) image->page.y);
        }
    }
#endif

  /* write vpAg chunk (deprecated, replaced by caNv) */
  if (ping_exclude_vpAg == MagickFalse && ping_wrote_caNv == MagickFalse)
    {
      if ((image->page.width != 0 && image->page.width != image->columns) ||
          (image->page.height != 0 && image->page.height != image->rows))
        {
          unsigned char
            chunk[14];

          (void) WriteBlobMSBULong(image,9L);  /* data length=8 */
          PNGType(chunk,mng_vpAg);
          LogPNGChunk(logging,mng_vpAg,9L);
          PNGLong(chunk+4,(png_uint_32) image->page.width);
          PNGLong(chunk+8,(png_uint_32) image->page.height);
          chunk[12]=0;   /* unit = pixels */
          (void) WriteBlob(image,13,chunk);
          (void) WriteBlobMSBULong(image,crc32(0,chunk,13));
        }
    }

#if (PNG_LIBPNG_VER == 10206)
    /* avoid libpng-1.2.6 bug by setting PNG_HAVE_IDAT flag */
#define PNG_HAVE_IDAT               0x04
    ping->mode |= PNG_HAVE_IDAT;
#undef PNG_HAVE_IDAT
#endif

  png_set_packing(ping);
  /*
    Allocate memory.
  */
  rowbytes=image->columns;
  if (image_depth > 8)
    rowbytes*=2;
  switch (ping_color_type)
    {
      case PNG_COLOR_TYPE_RGB:
        rowbytes*=3;
        break;

      case PNG_COLOR_TYPE_GRAY_ALPHA:
        rowbytes*=2;
        break;

      case PNG_COLOR_TYPE_RGBA:
        rowbytes*=4;
        break;

      default:
        break;
    }

  if (logging != MagickFalse)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""  Writing PNG image data"");

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    Allocating %.20g bytes of memory for pixels"",(double) rowbytes);
    }
  pixel_info=AcquireVirtualMemory(rowbytes,sizeof(*ping_pixels));
  if (pixel_info == (MemoryInfo *) NULL)
    png_error(ping,""Allocation of memory for pixels failed"");
  ping_pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);

  /*
    Initialize image scanlines.
  */
  quantum_info=AcquireQuantumInfo(image_info,image);
  if (quantum_info == (QuantumInfo *) NULL)
    png_error(ping,""Memory allocation for quantum_info failed"");
  quantum_info->format=UndefinedQuantumFormat;
  SetQuantumDepth(image,quantum_info,image_depth);
  (void) SetQuantumEndian(image,quantum_info,MSBEndian);
  num_passes=png_set_interlace_handling(ping);

  if ((!mng_info->write_png8 && !mng_info->write_png24 &&
       !mng_info->write_png48 && !mng_info->write_png64 &&
       !mng_info->write_png32) &&
       (mng_info->IsPalette ||
       (image_info->type == BilevelType)) &&
       image_matte == MagickFalse &&
       ping_have_non_bw == MagickFalse)
    {
      /* Palette, Bilevel, or Opaque Monochrome */
      register const Quantum
        *p;

      SetQuantumDepth(image,quantum_info,8);
      for (pass=0; pass < num_passes; pass++)
      {
        /*
          Convert PseudoClass image to a PNG monochrome image.
        */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          if (logging != MagickFalse && y == 0)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""    Writing row of pixels (0)"");

          p=GetVirtualPixels(image,0,y,image->columns,1,exception);

          if (p == (const Quantum *) NULL)
            break;

          if (mng_info->IsPalette)
            {
              (void) ExportQuantumPixels(image,(CacheView *) NULL,
                quantum_info,GrayQuantum,ping_pixels,exception);
              if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_PALETTE &&
                  mng_info->write_png_depth &&
                  mng_info->write_png_depth != old_bit_depth)
                {
                  /* Undo pixel scaling */
                  for (i=0; i < (ssize_t) image->columns; i++)
                     *(ping_pixels+i)=(unsigned char) (*(ping_pixels+i)
                     >> (8-old_bit_depth));
                }
            }

          else
            {
              (void) ExportQuantumPixels(image,(CacheView *) NULL,
                quantum_info,RedQuantum,ping_pixels,exception);
            }

          if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE)
            for (i=0; i < (ssize_t) image->columns; i++)
               *(ping_pixels+i)=(unsigned char) ((*(ping_pixels+i) > 127) ?
                      255 : 0);

          if (logging != MagickFalse && y == 0)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""    Writing row of pixels (1)"");

          png_write_row(ping,ping_pixels);

          status=SetImageProgress(image,SaveImageTag,
              (MagickOffsetType) (pass * image->rows + y),
              num_passes * image->rows);

          if (status == MagickFalse)
            break;
        }
      }
    }

  else   /* Not Palette, Bilevel, or Opaque Monochrome */
    {
      if ((!mng_info->write_png8 && !mng_info->write_png24 &&
          !mng_info->write_png48 && !mng_info->write_png64 &&
          !mng_info->write_png32) && (image_matte != MagickFalse ||
          (ping_bit_depth >= MAGICKCORE_QUANTUM_DEPTH)) &&
          (mng_info->IsPalette) && ping_have_color == MagickFalse)
        {
          register const Quantum
            *p;

          for (pass=0; pass < num_passes; pass++)
          {

          for (y=0; y < (ssize_t) image->rows; y++)
          {
            p=GetVirtualPixels(image,0,y,image->columns,1,exception);

            if (p == (const Quantum *) NULL)
              break;

            if (ping_color_type == PNG_COLOR_TYPE_GRAY)
              {
                if (mng_info->IsPalette)
                  (void) ExportQuantumPixels(image,(CacheView *) NULL,
                    quantum_info,GrayQuantum,ping_pixels,exception);

                else
                  (void) ExportQuantumPixels(image,(CacheView *) NULL,
                    quantum_info,RedQuantum,ping_pixels,exception);

                if (logging != MagickFalse && y == 0)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                       ""    Writing GRAY PNG pixels (2)"");
              }

            else /* PNG_COLOR_TYPE_GRAY_ALPHA */
              {
                if (logging != MagickFalse && y == 0)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                         ""    Writing GRAY_ALPHA PNG pixels (2)"");

                (void) ExportQuantumPixels(image,(CacheView *) NULL,
                  quantum_info,GrayAlphaQuantum,ping_pixels,exception);
              }

            if (logging != MagickFalse && y == 0)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""    Writing row of pixels (2)"");

            png_write_row(ping,ping_pixels);

            status=SetImageProgress(image,SaveImageTag,
              (MagickOffsetType) (pass * image->rows + y),
              num_passes * image->rows);

            if (status == MagickFalse)
              break;
            }
          }
        }

      else
        {
          register const Quantum
            *p;

          for (pass=0; pass < num_passes; pass++)
          {
            if ((image_depth > 8) ||
                mng_info->write_png24 ||
                mng_info->write_png32 ||
                mng_info->write_png48 ||
                mng_info->write_png64 ||
                (!mng_info->write_png8 && !mng_info->IsPalette))
            {
              for (y=0; y < (ssize_t) image->rows; y++)
              {
                p=GetVirtualPixels(image,0,y,image->columns,1, exception);

                if (p == (const Quantum *) NULL)
                  break;

                if (ping_color_type == PNG_COLOR_TYPE_GRAY)
                  {
                    if (image->storage_class == DirectClass)
                      (void) ExportQuantumPixels(image,(CacheView *) NULL,
                        quantum_info,RedQuantum,ping_pixels,exception);

                    else
                      (void) ExportQuantumPixels(image,(CacheView *) NULL,
                        quantum_info,GrayQuantum,ping_pixels,exception);
                  }

                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
                  {
                    (void) ExportQuantumPixels(image,(CacheView *) NULL,
                      quantum_info,GrayAlphaQuantum,ping_pixels,
                      exception);

                    if (logging != MagickFalse && y == 0)
                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                           ""    Writing GRAY_ALPHA PNG pixels (3)"");
                  }

                else if (image_matte != MagickFalse)
                  (void) ExportQuantumPixels(image,(CacheView *) NULL,
                    quantum_info,RGBAQuantum,ping_pixels,exception);

                else
                  (void) ExportQuantumPixels(image,(CacheView *) NULL,
                    quantum_info,RGBQuantum,ping_pixels,exception);

                if (logging != MagickFalse && y == 0)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                      ""    Writing row of pixels (3)"");

                png_write_row(ping,ping_pixels);

                status=SetImageProgress(image,SaveImageTag,
                  (MagickOffsetType) (pass * image->rows + y),
                  num_passes * image->rows);

                if (status == MagickFalse)
                  break;
              }
            }

          else
            /* not ((image_depth > 8) ||
                mng_info->write_png24 || mng_info->write_png32 ||
                mng_info->write_png48 || mng_info->write_png64 ||
                (!mng_info->write_png8 && !mng_info->IsPalette))
             */
            {
              if ((ping_color_type != PNG_COLOR_TYPE_GRAY) &&
                  (ping_color_type != PNG_COLOR_TYPE_GRAY_ALPHA))
                {
                  if (logging != MagickFalse)
                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                      ""  pass %d, Image Is not GRAY or GRAY_ALPHA"",pass);

                  SetQuantumDepth(image,quantum_info,8);
                  image_depth=8;
                }

              for (y=0; y < (ssize_t) image->rows; y++)
              {
                if (logging != MagickFalse && y == 0)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""  pass %d, Image Is RGB, 16-bit GRAY, or GRAY_ALPHA"",
                    pass);

                p=GetVirtualPixels(image,0,y,image->columns,1, exception);

                if (p == (const Quantum *) NULL)
                  break;

                if (ping_color_type == PNG_COLOR_TYPE_GRAY)
                  {
                    SetQuantumDepth(image,quantum_info,image->depth);

                    (void) ExportQuantumPixels(image,(CacheView *) NULL,
                       quantum_info,GrayQuantum,ping_pixels,exception);
                  }

                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
                  {
                    if (logging != MagickFalse && y == 0)
                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                           ""  Writing GRAY_ALPHA PNG pixels (4)"");

                    (void) ExportQuantumPixels(image,(CacheView *) NULL,
                         quantum_info,GrayAlphaQuantum,ping_pixels,
                         exception);
                  }

                else
                  {
                    (void) ExportQuantumPixels(image,(CacheView *) NULL,
                      quantum_info,IndexQuantum,ping_pixels,exception);

                    if (logging != MagickFalse && y <= 2)
                    {
                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                          ""  Writing row of non-gray pixels (4)"");

                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                          ""  ping_pixels[0]=%d,ping_pixels[1]=%d"",
                          (int)ping_pixels[0],(int)ping_pixels[1]);
                    }
                  }
                png_write_row(ping,ping_pixels);

                status=SetImageProgress(image,SaveImageTag,
                  (MagickOffsetType) (pass * image->rows + y),
                  num_passes * image->rows);

                if (status == MagickFalse)
                  break;
              }
            }
          }
        }
    }

  if (quantum_info != (QuantumInfo *) NULL)
    quantum_info=DestroyQuantumInfo(quantum_info);

  if (logging != MagickFalse)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""  Wrote PNG image data"");

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    Width: %.20g"",(double) ping_width);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    Height: %.20g"",(double) ping_height);

      if (mng_info->write_png_depth)
        {
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Defined png:bit-depth: %d"",mng_info->write_png_depth);
        }

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    PNG bit-depth written: %d"",ping_bit_depth);

      if (mng_info->write_png_colortype)
        {
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Defined png:color-type: %d"",mng_info->write_png_colortype-1);
        }

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    PNG color-type written: %d"",ping_color_type);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    PNG Interlace method: %d"",ping_interlace_method);
    }
  /*
    Generate text chunks after IDAT.
  */
  if (ping_exclude_tEXt == MagickFalse || ping_exclude_zTXt == MagickFalse)
  {
    ResetImagePropertyIterator(image);
    property=GetNextImageProperty(image);
    while (property != (const char *) NULL)
    {
      png_textp
        text;

      value=GetImageProperty(image,property,exception);

      /* Don't write any ""png:"" or ""jpeg:"" properties; those are just for
       * ""identify"" or for passing through to another JPEG
       */
      if ((LocaleNCompare(property,""png:"",4) != 0 &&
           LocaleNCompare(property,""jpeg:"",5) != 0) &&


          /* Suppress density and units if we wrote a pHYs chunk */
          (ping_exclude_pHYs != MagickFalse      ||
          LocaleCompare(property,""density"") != 0 ||
          LocaleCompare(property,""units"") != 0) &&

          /* Suppress the IM-generated Date:create and Date:modify */
          (ping_exclude_date == MagickFalse      ||
          LocaleNCompare(property, ""Date:"",5) != 0))
        {
        if (value != (const char *) NULL)
          {

#if PNG_LIBPNG_VER >= 10400
            text=(png_textp) png_malloc(ping,
                 (png_alloc_size_t) sizeof(png_text));
#else
            text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));
#endif
            text[0].key=(char *) property;
            text[0].text=(char *) value;
            text[0].text_length=strlen(value);

            if (ping_exclude_tEXt != MagickFalse)
               text[0].compression=PNG_TEXT_COMPRESSION_zTXt;

            else if (ping_exclude_zTXt != MagickFalse)
               text[0].compression=PNG_TEXT_COMPRESSION_NONE;

            else
            {
               text[0].compression=image_info->compression == NoCompression ||
                 (image_info->compression == UndefinedCompression &&
                 text[0].text_length < 128) ? PNG_TEXT_COMPRESSION_NONE :
                 PNG_TEXT_COMPRESSION_zTXt ;
            }

            if (logging != MagickFalse)
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Setting up text chunk"");

                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""    keyword: '%s'"",text[0].key);
              }

            png_set_text(ping,ping_info,text,1);
            png_free(ping,text);
          }
        }
      property=GetNextImageProperty(image);
    }
  }

  /* write any PNG-chunk-e profiles */
  (void) Magick_png_write_chunk_from_profile(image,""PNG-chunk-e"",logging);

  /* write exIf profile */
  if (ping_have_eXIf != MagickFalse && ping_exclude_eXIf == MagickFalse)
    {
      char
        *name;

      ResetImageProfileIterator(image);

      for (name=GetNextImageProfile(image); name != (const char *) NULL; )
      {
        if (LocaleCompare(name,""exif"") == 0)
          {
            const StringInfo
              *profile;

            profile=GetImageProfile(image,name);

            if (profile != (StringInfo *) NULL)
              {
                png_uint_32
                  length;

                unsigned char
                  chunk[4],
                  *data;

               StringInfo
                 *ping_profile;

               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Have eXIf profile"");

               ping_profile=CloneStringInfo(profile);
               data=GetStringInfoDatum(ping_profile),
               length=(png_uint_32) GetStringInfoLength(ping_profile);

               PNGType(chunk,mng_eXIf);
               if (length < 7)
                 {
                   ping_profile=DestroyStringInfo(ping_profile);
                   break;  /* otherwise crashes */
                 }

               /* skip the ""Exif\0\0"" JFIF Exif Header ID */
               length -= 6;

               LogPNGChunk(logging,chunk,length);
               (void) WriteBlobMSBULong(image,length);
               (void) WriteBlob(image,4,chunk);
               (void) WriteBlob(image,length,data+6);
               (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),
                 data+6, (uInt) length));
               ping_profile=DestroyStringInfo(ping_profile);
               break;
             }
         }
       name=GetNextImageProfile(image);
     }
  }

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  Writing PNG end info"");

  png_write_end(ping,ping_info);

  if (mng_info->need_fram && (int) image->dispose == BackgroundDispose)
    {
      if (mng_info->page.x || mng_info->page.y ||
          (ping_width != mng_info->page.width) ||
          (ping_height != mng_info->page.height))
        {
          unsigned char
            chunk[32];

          /*
            Write FRAM 4 with clipping boundaries followed by FRAM 1.
          */
          (void) WriteBlobMSBULong(image,27L);  /* data length=27 */
          PNGType(chunk,mng_FRAM);
          LogPNGChunk(logging,mng_FRAM,27L);
          chunk[4]=4;
          chunk[5]=0;  /* frame name separator (no name) */
          chunk[6]=1;  /* flag for changing delay, for next frame only */
          chunk[7]=0;  /* flag for changing frame timeout */
          chunk[8]=1;  /* flag for changing frame clipping for next frame */
          chunk[9]=0;  /* flag for changing frame sync_id */
          PNGLong(chunk+10,(png_uint_32) (0L)); /* temporary 0 delay */
          chunk[14]=0; /* clipping boundaries delta type */
          PNGLong(chunk+15,(png_uint_32) (mng_info->page.x)); /* left cb */
          PNGLong(chunk+19,
             (png_uint_32) (mng_info->page.x + ping_width));
          PNGLong(chunk+23,(png_uint_32) (mng_info->page.y)); /* top cb */
          PNGLong(chunk+27,
             (png_uint_32) (mng_info->page.y + ping_height));
          (void) WriteBlob(image,31,chunk);
          (void) WriteBlobMSBULong(image,crc32(0,chunk,31));
          mng_info->old_framing_mode=4;
          mng_info->framing_mode=1;
        }

      else
        mng_info->framing_mode=3;
    }
  if (mng_info->write_mng && !mng_info->need_fram &&
      ((int) image->dispose == 3))
     png_error(ping, ""Cannot convert GIF with disposal method 3 to MNG-LC"");

  /*
    Free PNG resources.
  */

  png_destroy_write_struct(&ping,&ping_info);

  pixel_info=RelinquishVirtualMemory(pixel_info);

  if (ping_have_blob != MagickFalse)
     (void) CloseBlob(image);

  image_info=DestroyImageInfo(image_info);
  image=DestroyImage(image);

  /* Store bit depth actually written */
  s[0]=(char) ping_bit_depth;
  s[1]='\0';

  (void) SetImageProperty(IMimage,""png:bit-depth-written"",s,exception);

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  exit WriteOnePNGImage()"");

#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE
  UnlockSemaphoreInfo(ping_semaphore);
#endif

   /* }  for navigation to beginning of SETJMP-protected block. Revert to
    *    Throwing an Exception when an error occurs.
    */

  return(MagickTrue);
/*  End write one PNG image */

}
",C,"  if (image == (Image *) NULL)
    return(MagickFalse);
    ThrowWriterException(ResourceLimitError, ""MemoryAllocationFailed"");
","     ThrowWriterException(ResourceLimitError, ""MemoryAllocationFailed"");
",,"@@ -8270,9 +8270,11 @@ static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,
     ""  Enter WriteOnePNGImage()"");
 
   image = CloneImage(IMimage,0,0,MagickFalse,exception);
+  if (image == (Image *) NULL)
+    return(MagickFalse);
   image_info=(ImageInfo *) CloneImageInfo(IMimage_info);
   if (image_info == (ImageInfo *) NULL)
-     ThrowWriterException(ResourceLimitError, ""MemoryAllocationFailed"");
+    ThrowWriterException(ResourceLimitError, ""MemoryAllocationFailed"");
 
   /* Define these outside of the following ""if logging()"" block so they will
    * show in debuggers.",ImageMagick,816ecab6c532ae086ff4186b3eaf4aa7092d536f,42ab1bc2982cdca596083975a51de1bc3f22ee9a,1,"static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,
  const ImageInfo *IMimage_info,Image *IMimage,ExceptionInfo *exception)
{
  char
    im_vers[32],
    libpng_runv[32],
    libpng_vers[32],
    zlib_runv[32],
    zlib_vers[32];

  Image
    *image;

  ImageInfo
    *image_info;

  char
    s[2];

  const char
    *name,
    *property,
    *value;

  const StringInfo
    *profile;

  int
    num_passes,
    pass,
    ping_wrote_caNv;

  png_byte
     ping_trans_alpha[256];

  png_color
     palette[257];

  png_color_16
    ping_background,
    ping_trans_color;

  png_info
    *ping_info;

  png_struct
    *ping;

  png_uint_32
    ping_height,
    ping_width;

  ssize_t
    y;

  MagickBooleanType
    image_matte,
    logging,
    matte,

    ping_have_blob,
    ping_have_cheap_transparency,
    ping_have_color,
    ping_have_non_bw,
    ping_have_PLTE,
    ping_have_bKGD,
    ping_have_eXIf,
    ping_have_iCCP,
    ping_have_pHYs,
    ping_have_sRGB,
    ping_have_tRNS,

    ping_exclude_bKGD,
    ping_exclude_cHRM,
    ping_exclude_date,
    /* ping_exclude_EXIF, */
    ping_exclude_eXIf,
    ping_exclude_gAMA,
    ping_exclude_iCCP,
    /* ping_exclude_iTXt, */
    ping_exclude_oFFs,
    ping_exclude_pHYs,
    ping_exclude_sRGB,
    ping_exclude_tEXt,
    ping_exclude_tIME,
    /* ping_exclude_tRNS, */
    ping_exclude_vpAg,
    ping_exclude_caNv,
    ping_exclude_zCCP, /* hex-encoded iCCP */
    ping_exclude_zTXt,

    ping_preserve_colormap,
    ping_preserve_iCCP,
    ping_need_colortype_warning,

    status,
    tried_332,
    tried_333,
    tried_444;

  MemoryInfo
    *volatile pixel_info;

  QuantumInfo
    *quantum_info;

  PNGErrorInfo
    error_info;

  register ssize_t
    i,
    x;

  unsigned char
    *ping_pixels;

  volatile int
    image_colors,
    ping_bit_depth,
    ping_color_type,
    ping_interlace_method,
    ping_compression_method,
    ping_filter_method,
    ping_num_trans;

  volatile size_t
    image_depth,
    old_bit_depth;

  size_t
    quality,
    rowbytes,
    save_image_depth;

  int
    j,
    number_colors,
    number_opaque,
    number_semitransparent,
    number_transparent,
    ping_pHYs_unit_type;

  png_uint_32
    ping_pHYs_x_resolution,
    ping_pHYs_y_resolution;

  logging=LogMagickEvent(CoderEvent,GetMagickModule(),
     ""  Enter WriteOnePNGImage()"");
 
   image = CloneImage(IMimage,0,0,MagickFalse,exception);
//fix_flaw_line_below:
//  if (image == (Image *) NULL)
//fix_flaw_line_below:
//    return(MagickFalse);
   image_info=(ImageInfo *) CloneImageInfo(IMimage_info);
   if (image_info == (ImageInfo *) NULL)
//flaw_line_below:
     ThrowWriterException(ResourceLimitError, ""MemoryAllocationFailed"");
//fix_flaw_line_below:
//    ThrowWriterException(ResourceLimitError, ""MemoryAllocationFailed"");
 
   /* Define these outside of the following ""if logging()"" block so they will
    * show in debuggers.
   */
  *im_vers='\0';
  (void) ConcatenateMagickString(im_vers,
         MagickLibVersionText,MagickPathExtent);
  (void) ConcatenateMagickString(im_vers,
         MagickLibAddendum,MagickPathExtent);

  *libpng_vers='\0';
  (void) ConcatenateMagickString(libpng_vers,
         PNG_LIBPNG_VER_STRING,32);
  *libpng_runv='\0';
  (void) ConcatenateMagickString(libpng_runv,
         png_get_libpng_ver(NULL),32);

  *zlib_vers='\0';
  (void) ConcatenateMagickString(zlib_vers,
         ZLIB_VERSION,32);
  *zlib_runv='\0';
  (void) ConcatenateMagickString(zlib_runv,
         zlib_version,32);

  if (logging != MagickFalse)
    {
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""    IM version     = %s"",
           im_vers);
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""    Libpng version = %s"",
           libpng_vers);
       if (LocaleCompare(libpng_vers,libpng_runv) != 0)
       {
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""      running with   %s"",
           libpng_runv);
       }
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""    Zlib version   = %s"",
           zlib_vers);
       if (LocaleCompare(zlib_vers,zlib_runv) != 0)
       {
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""      running with   %s"",
           zlib_runv);
       }
    }

  /* Initialize some stuff */
  ping_bit_depth=0,
  ping_color_type=0,
  ping_interlace_method=0,
  ping_compression_method=0,
  ping_filter_method=0,
  ping_num_trans = 0;

  ping_background.red = 0;
  ping_background.green = 0;
  ping_background.blue = 0;
  ping_background.gray = 0;
  ping_background.index = 0;

  ping_trans_color.red=0;
  ping_trans_color.green=0;
  ping_trans_color.blue=0;
  ping_trans_color.gray=0;

  ping_pHYs_unit_type = 0;
  ping_pHYs_x_resolution = 0;
  ping_pHYs_y_resolution = 0;

  ping_have_blob=MagickFalse;
  ping_have_cheap_transparency=MagickFalse;
  ping_have_color=MagickTrue;
  ping_have_non_bw=MagickTrue;
  ping_have_PLTE=MagickFalse;
  ping_have_bKGD=MagickFalse;
  ping_have_eXIf=MagickTrue;
  ping_have_iCCP=MagickFalse;
  ping_have_pHYs=MagickFalse;
  ping_have_sRGB=MagickFalse;
  ping_have_tRNS=MagickFalse;

  ping_exclude_bKGD=mng_info->ping_exclude_bKGD;
  ping_exclude_caNv=mng_info->ping_exclude_caNv;
  ping_exclude_cHRM=mng_info->ping_exclude_cHRM;
  ping_exclude_date=mng_info->ping_exclude_date;
  ping_exclude_eXIf=mng_info->ping_exclude_eXIf;
  ping_exclude_gAMA=mng_info->ping_exclude_gAMA;
  ping_exclude_iCCP=mng_info->ping_exclude_iCCP;
  /* ping_exclude_iTXt=mng_info->ping_exclude_iTXt; */
  ping_exclude_oFFs=mng_info->ping_exclude_oFFs;
  ping_exclude_pHYs=mng_info->ping_exclude_pHYs;
  ping_exclude_sRGB=mng_info->ping_exclude_sRGB;
  ping_exclude_tEXt=mng_info->ping_exclude_tEXt;
  ping_exclude_tIME=mng_info->ping_exclude_tIME;
  /* ping_exclude_tRNS=mng_info->ping_exclude_tRNS; */
  ping_exclude_vpAg=mng_info->ping_exclude_vpAg;
  ping_exclude_zCCP=mng_info->ping_exclude_zCCP; /* hex-encoded iCCP in zTXt */
  ping_exclude_zTXt=mng_info->ping_exclude_zTXt;

  ping_preserve_colormap = mng_info->ping_preserve_colormap;
  ping_preserve_iCCP = mng_info->ping_preserve_iCCP;
  ping_need_colortype_warning = MagickFalse;

  /* Recognize the ICC sRGB profile and convert it to the sRGB chunk,
   * i.e., eliminate the ICC profile and set image->rendering_intent.
   * Note that this will not involve any changes to the actual pixels
   * but merely passes information to applications that read the resulting
   * PNG image.
   *
   * To do: recognize other variants of the sRGB profile, using the CRC to
   * verify all recognized variants including the 7 already known.
   *
   * Work around libpng16+ rejecting some ""known invalid sRGB profiles"".
   *
   * Use something other than image->rendering_intent to record the fact
   * that the sRGB profile was found.
   *
   * Record the ICC version (currently v2 or v4) of the incoming sRGB ICC
   * profile.  Record the Blackpoint Compensation, if any.
   */
   if (ping_exclude_sRGB == MagickFalse && ping_preserve_iCCP == MagickFalse)
   {
      char
        *name;

      const StringInfo
        *profile;

      ResetImageProfileIterator(image);
      for (name=GetNextImageProfile(image); name != (const char *) NULL; )
      {
        profile=GetImageProfile(image,name);

        if (profile != (StringInfo *) NULL)
          {
            if ((LocaleCompare(name,""ICC"") == 0) ||
                (LocaleCompare(name,""ICM"") == 0))

             {
                 int
                   icheck,
                   got_crc=0;


                 png_uint_32
                   length,
                   profile_crc=0;

                 unsigned char
                   *data;

                 length=(png_uint_32) GetStringInfoLength(profile);

                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)
                 {
                   if (length == sRGB_info[icheck].len)
                   {
                     if (got_crc == 0)
                     {
                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                         ""    Got a %lu-byte ICC profile (potentially sRGB)"",
                         (unsigned long) length);

                       data=GetStringInfoDatum(profile);
                       profile_crc=crc32(0,data,length);

                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                           ""      with crc=%8x"",(unsigned int) profile_crc);
                       got_crc++;
                     }

                     if (profile_crc == sRGB_info[icheck].crc)
                     {
                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                            ""      It is sRGB with rendering intent = %s"",
                        Magick_RenderingIntentString_from_PNG_RenderingIntent(
                             sRGB_info[icheck].intent));
                        if (image->rendering_intent==UndefinedIntent)
                        {
                          image->rendering_intent=
                          Magick_RenderingIntent_from_PNG_RenderingIntent(
                             sRGB_info[icheck].intent);
                        }
                        ping_exclude_iCCP = MagickTrue;
                        ping_exclude_zCCP = MagickTrue;
                        ping_have_sRGB = MagickTrue;
                        break;
                     }
                   }
                 }
                 if (sRGB_info[icheck].len == 0)
                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                        ""    Got %lu-byte ICC profile not recognized as sRGB"",
                        (unsigned long) length);
              }
          }
        name=GetNextImageProfile(image);
      }
  }

  number_opaque = 0;
  number_semitransparent = 0;
  number_transparent = 0;

  if (logging != MagickFalse)
    {
      if (image->storage_class == UndefinedClass)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    image->storage_class=UndefinedClass"");
      if (image->storage_class == DirectClass)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    image->storage_class=DirectClass"");
      if (image->storage_class == PseudoClass)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    image->storage_class=PseudoClass"");
      (void) LogMagickEvent(CoderEvent,GetMagickModule(), image->taint ?
          ""    image->taint=MagickTrue"":
          ""    image->taint=MagickFalse"");
    }

  if (image->storage_class == PseudoClass &&
     (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32 ||
     mng_info->write_png48 || mng_info->write_png64 ||
     (mng_info->write_png_colortype != 1 &&
     mng_info->write_png_colortype != 5)))
    {
      (void) SyncImage(image,exception);
      image->storage_class = DirectClass;
    }

  if (ping_preserve_colormap == MagickFalse)
    {
      if (image->storage_class != PseudoClass && image->colormap != NULL)
        {
          /* Free the bogus colormap; it can cause trouble later */
           if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    Freeing bogus colormap"");
           (void) RelinquishMagickMemory(image->colormap);
           image->colormap=NULL;
        }
    }

  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
    (void) TransformImageColorspace(image,sRGBColorspace,exception);

  /*
    Sometimes we get PseudoClass images whose RGB values don't match
    the colors in the colormap.  This code syncs the RGB values.
  */
  if (image->depth <= 8 && image->taint && image->storage_class == PseudoClass)
     (void) SyncImage(image,exception);

#if (MAGICKCORE_QUANTUM_DEPTH == 8)
  if (image->depth > 8)
    {
      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    Reducing PNG bit depth to 8 since this is a Q8 build."");

      image->depth=8;
    }
#endif

  /* Respect the -depth option */
  if (image->depth < 4)
    {
       register Quantum
         *r;

       if (image->depth > 2)
         {
           /* Scale to 4-bit */
           LBR04PacketRGBO(image->background_color);

           for (y=0; y < (ssize_t) image->rows; y++)
           {
             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

             if (r == (Quantum *) NULL)
               break;

             for (x=0; x < (ssize_t) image->columns; x++)
             {
                LBR04PixelRGBA(r);
                r+=GetPixelChannels(image);
             }

             if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
           }

           if (image->storage_class == PseudoClass && image->colormap != NULL)
           {
             for (i=0; i < (ssize_t) image->colors; i++)
             {
               LBR04PacketRGBO(image->colormap[i]);
             }
           }
         }
       else if (image->depth > 1)
         {
           /* Scale to 2-bit */
           LBR02PacketRGBO(image->background_color);

           for (y=0; y < (ssize_t) image->rows; y++)
           {
             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

             if (r == (Quantum *) NULL)
               break;

             for (x=0; x < (ssize_t) image->columns; x++)
             {
                LBR02PixelRGBA(r);
                r+=GetPixelChannels(image);
             }

             if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
           }

           if (image->storage_class == PseudoClass && image->colormap != NULL)
           {
             for (i=0; i < (ssize_t) image->colors; i++)
             {
               LBR02PacketRGBO(image->colormap[i]);
             }
           }
         }
       else
         {
           /* Scale to 1-bit */
           LBR01PacketRGBO(image->background_color);

           for (y=0; y < (ssize_t) image->rows; y++)
           {
             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

             if (r == (Quantum *) NULL)
               break;

             for (x=0; x < (ssize_t) image->columns; x++)
             {
                LBR01PixelRGBA(r);
                r+=GetPixelChannels(image);
             }

             if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
           }

           if (image->storage_class == PseudoClass && image->colormap != NULL)
           {
             for (i=0; i < (ssize_t) image->colors; i++)
             {
               LBR01PacketRGBO(image->colormap[i]);
             }
           }
         }
    }

  /* To do: set to next higher multiple of 8 */
  if (image->depth < 8)
     image->depth=8;

#if (MAGICKCORE_QUANTUM_DEPTH > 16)
  /* PNG does not handle depths greater than 16 so reduce it even
   * if lossy
   */
  if (image->depth > 8)
      image->depth=16;
#endif

#if (MAGICKCORE_QUANTUM_DEPTH > 8)
  if (image->depth > 8)
    {
      /* To do: fill low byte properly */
      image->depth=16;
    }

  if (image->depth == 16 && mng_info->write_png_depth != 16)
    if (mng_info->write_png8 ||
        LosslessReduceDepthOK(image,exception) != MagickFalse)
      image->depth = 8;
#endif

  image_colors = (int) image->colors;
  number_opaque = (int) image->colors;
  number_transparent = 0;
  number_semitransparent = 0;

  if (mng_info->write_png_colortype &&
     (mng_info->write_png_colortype > 4 || (mng_info->write_png_depth >= 8 &&
     mng_info->write_png_colortype < 4 &&
     image->alpha_trait == UndefinedPixelTrait)))
  {
     /* Avoid the expensive BUILD_PALETTE operation if we're sure that we
      * are not going to need the result.
      */
     if (mng_info->write_png_colortype == 1 ||
        mng_info->write_png_colortype == 5)
       ping_have_color=MagickFalse;

     if (image->alpha_trait != UndefinedPixelTrait)
       {
         number_transparent = 2;
         number_semitransparent = 1;
       }
  }

  if (mng_info->write_png_colortype < 7)
  {
  /* BUILD_PALETTE
   *
   * Normally we run this just once, but in the case of writing PNG8
   * we reduce the transparency to binary and run again, then if there
   * are still too many colors we reduce to a simple 4-4-4-1, then 3-3-3-1
   * RGBA palette and run again, and then to a simple 3-3-2-1 RGBA
   * palette.  Then (To do) we take care of a final reduction that is only
   * needed if there are still 256 colors present and one of them has both
   * transparent and opaque instances.
   */

  tried_332 = MagickFalse;
  tried_333 = MagickFalse;
  tried_444 = MagickFalse;

  for (j=0; j<6; j++)
  {
    /*
     * Sometimes we get DirectClass images that have 256 colors or fewer.
     * This code will build a colormap.
     *
     * Also, sometimes we get PseudoClass images with an out-of-date
     * colormap.  This code will replace the colormap with a new one.
     * Sometimes we get PseudoClass images that have more than 256 colors.
     * This code will delete the colormap and change the image to
     * DirectClass.
     *
     * If image->alpha_trait is MagickFalse, we ignore the alpha channel
     * even though it sometimes contains left-over non-opaque values.
     *
     * Also we gather some information (number of opaque, transparent,
     * and semitransparent pixels, and whether the image has any non-gray
     * pixels or only black-and-white pixels) that we might need later.
     *
     * Even if the user wants to force GrayAlpha or RGBA (colortype 4 or 6)
     * we need to check for bogus non-opaque values, at least.
     */

   int
     n;

   PixelInfo
     opaque[260],
     semitransparent[260],
     transparent[260];

   register const Quantum
     *s;

   register Quantum
     *q,
     *r;

   if (logging != MagickFalse)
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    Enter BUILD_PALETTE:"");

   if (logging != MagickFalse)
     {
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      image->columns=%.20g"",(double) image->columns);
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      image->rows=%.20g"",(double) image->rows);
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      image->alpha_trait=%.20g"",(double) image->alpha_trait);
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      image->depth=%.20g"",(double) image->depth);

       if (image->storage_class == PseudoClass && image->colormap != NULL)
       {
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      Original colormap:"");
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""        i    (red,green,blue,alpha)"");

         for (i=0; i < 256; i++)
         {
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""        %d    (%d,%d,%d,%d)"",
                    (int) i,
                    (int) image->colormap[i].red,
                    (int) image->colormap[i].green,
                    (int) image->colormap[i].blue,
                    (int) image->colormap[i].alpha);
         }

         for (i=image->colors - 10; i < (ssize_t) image->colors; i++)
         {
           if (i > 255)
             {
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""        %d    (%d,%d,%d,%d)"",
                    (int) i,
                    (int) image->colormap[i].red,
                    (int) image->colormap[i].green,
                    (int) image->colormap[i].blue,
                    (int) image->colormap[i].alpha);
             }
         }
       }

       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""      image->colors=%d"",(int) image->colors);

       if (image->colors == 0)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""        (zero means unknown)"");

       if (ping_preserve_colormap == MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""      Regenerate the colormap"");
     }

     image_colors=0;
     number_opaque = 0;
     number_semitransparent = 0;
     number_transparent = 0;

     for (y=0; y < (ssize_t) image->rows; y++)
     {
       q=GetAuthenticPixels(image,0,y,image->columns,1,exception);

       if (q == (Quantum *) NULL)
         break;

       for (x=0; x < (ssize_t) image->columns; x++)
       {
           if (image->alpha_trait == UndefinedPixelTrait ||
              GetPixelAlpha(image,q) == OpaqueAlpha)
             {
               if (number_opaque < 259)
                 {
                   if (number_opaque == 0)
                     {
                       GetPixelInfoPixel(image, q, opaque);
                       opaque[0].alpha=OpaqueAlpha;
                       number_opaque=1;
                     }

                   for (i=0; i< (ssize_t) number_opaque; i++)
                     {
                       if (Magick_png_color_equal(image,q,opaque+i))
                         break;
                     }

                   if (i ==  (ssize_t) number_opaque && number_opaque < 259)
                     {
                       number_opaque++;
                       GetPixelInfoPixel(image, q, opaque+i);
                       opaque[i].alpha=OpaqueAlpha;
                     }
                 }
             }
           else if (GetPixelAlpha(image,q) == TransparentAlpha)
             {
               if (number_transparent < 259)
                 {
                   if (number_transparent == 0)
                     {
                       GetPixelInfoPixel(image, q, transparent);
                       ping_trans_color.red=(unsigned short)
                         GetPixelRed(image,q);
                       ping_trans_color.green=(unsigned short)
                         GetPixelGreen(image,q);
                       ping_trans_color.blue=(unsigned short)
                         GetPixelBlue(image,q);
                       ping_trans_color.gray=(unsigned short)
                         GetPixelGray(image,q);
                       number_transparent = 1;
                     }

                   for (i=0; i< (ssize_t) number_transparent; i++)
                     {
                       if (Magick_png_color_equal(image,q,transparent+i))
                         break;
                     }

                   if (i ==  (ssize_t) number_transparent &&
                       number_transparent < 259)
                     {
                       number_transparent++;
                       GetPixelInfoPixel(image,q,transparent+i);
                     }
                 }
             }
           else
             {
               if (number_semitransparent < 259)
                 {
                   if (number_semitransparent == 0)
                     {
                       GetPixelInfoPixel(image,q,semitransparent);
                       number_semitransparent = 1;
                     }

                   for (i=0; i< (ssize_t) number_semitransparent; i++)
                     {
                       if (Magick_png_color_equal(image,q,semitransparent+i)
                           && GetPixelAlpha(image,q) ==
                           semitransparent[i].alpha)
                         break;
                     }

                   if (i ==  (ssize_t) number_semitransparent &&
                       number_semitransparent < 259)
                     {
                       number_semitransparent++;
                       GetPixelInfoPixel(image, q, semitransparent+i);
                     }
                 }
             }
           q+=GetPixelChannels(image);
        }
     }

     if (mng_info->write_png8 == MagickFalse &&
         ping_exclude_bKGD == MagickFalse)
       {
         /* Add the background color to the palette, if it
          * isn't already there.
          */
          if (logging != MagickFalse)
            {
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      Check colormap for background (%d,%d,%d)"",
                  (int) image->background_color.red,
                  (int) image->background_color.green,
                  (int) image->background_color.blue);
            }
          for (i=0; i<number_opaque; i++)
          {
             if (opaque[i].red == image->background_color.red &&
                 opaque[i].green == image->background_color.green &&
                 opaque[i].blue == image->background_color.blue)
               break;
          }
          if (number_opaque < 259 && i == number_opaque)
            {
               opaque[i] = image->background_color;
               ping_background.index = i;
               number_opaque++;
               if (logging != MagickFalse)
                 {
                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                       ""      background_color index is %d"",(int) i);
                 }

            }
          else if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      No room in the colormap to add background color"");
       }

     image_colors=number_opaque+number_transparent+number_semitransparent;

     if (logging != MagickFalse)
       {
         if (image_colors > 256)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      image has more than 256 colors"");

         else
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      image has %d colors"",image_colors);
       }

     if (ping_preserve_colormap != MagickFalse)
       break;

     if (mng_info->write_png_colortype != 7) /* We won't need this info */
       {
         ping_have_color=MagickFalse;
         ping_have_non_bw=MagickFalse;

         if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
         {
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""incompatible colorspace"");
           ping_have_color=MagickTrue;
           ping_have_non_bw=MagickTrue;
         }

         if(image_colors > 256)
           {
             for (y=0; y < (ssize_t) image->rows; y++)
             {
               q=GetAuthenticPixels(image,0,y,image->columns,1,exception);

               if (q == (Quantum *) NULL)
                 break;

               s=q;
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                 if (GetPixelRed(image,s) != GetPixelGreen(image,s) ||
                     GetPixelRed(image,s) != GetPixelBlue(image,s))
                   {
                      ping_have_color=MagickTrue;
                      ping_have_non_bw=MagickTrue;
                      break;
                   }
                 s+=GetPixelChannels(image);
               }

               if (ping_have_color != MagickFalse)
                 break;

               /* Worst case is black-and-white; we are looking at every
                * pixel twice.
                */

               if (ping_have_non_bw == MagickFalse)
                 {
                   s=q;
                   for (x=0; x < (ssize_t) image->columns; x++)
                   {
                     if (GetPixelRed(image,s) != 0 &&
                         GetPixelRed(image,s) != QuantumRange)
                       {
                         ping_have_non_bw=MagickTrue;
                         break;
                       }
                     s+=GetPixelChannels(image);
                   }
               }
             }
           }
       }

     if (image_colors < 257)
       {
         PixelInfo
           colormap[260];

         /*
          * Initialize image colormap.
          */

         if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      Sort the new colormap"");

        /* Sort palette, transparent first */;

         n = 0;

         for (i=0; i<number_transparent; i++)
            colormap[n++] = transparent[i];

         for (i=0; i<number_semitransparent; i++)
            colormap[n++] = semitransparent[i];

         for (i=0; i<number_opaque; i++)
            colormap[n++] = opaque[i];

         ping_background.index +=
           (number_transparent + number_semitransparent);

         /* image_colors < 257; search the colormap instead of the pixels
          * to get ping_have_color and ping_have_non_bw
          */
         for (i=0; i<n; i++)
         {
           if (ping_have_color == MagickFalse)
             {
                if (colormap[i].red != colormap[i].green ||
                    colormap[i].red != colormap[i].blue)
                  {
                     ping_have_color=MagickTrue;
                     ping_have_non_bw=MagickTrue;
                     break;
                  }
              }

           if (ping_have_non_bw == MagickFalse)
             {
               if (colormap[i].red != 0 && colormap[i].red != QuantumRange)
                   ping_have_non_bw=MagickTrue;
             }
          }

        if ((mng_info->ping_exclude_tRNS == MagickFalse ||
            (number_transparent == 0 && number_semitransparent == 0)) &&
            (((mng_info->write_png_colortype-1) ==
            PNG_COLOR_TYPE_PALETTE) ||
            (mng_info->write_png_colortype == 0)))
          {
            if (logging != MagickFalse)
              {
                if (n !=  (ssize_t) image_colors)
                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""   image_colors (%d) and n (%d)  don't match"",
                   image_colors, n);

                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      AcquireImageColormap"");
              }

            image->colors = image_colors;

            if (AcquireImageColormap(image,image_colors,exception) ==
                MagickFalse)
               ThrowWriterException(ResourceLimitError,
                   ""MemoryAllocationFailed"");

            for (i=0; i< (ssize_t) image_colors; i++)
               image->colormap[i] = colormap[i];

            if (logging != MagickFalse)
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                      ""      image->colors=%d (%d)"",
                      (int) image->colors, image_colors);

                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                      ""      Update the pixel indexes"");
              }

            /* Sync the pixel indices with the new colormap */

            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);

              if (q == (Quantum *) NULL)
                break;

              for (x=0; x < (ssize_t) image->columns; x++)
              {
                for (i=0; i< (ssize_t) image_colors; i++)
                {
                  if ((image->alpha_trait == UndefinedPixelTrait ||
                      image->colormap[i].alpha == GetPixelAlpha(image,q)) &&
                      image->colormap[i].red == GetPixelRed(image,q) &&
                      image->colormap[i].green == GetPixelGreen(image,q) &&
                      image->colormap[i].blue == GetPixelBlue(image,q))
                  {
                    SetPixelIndex(image,i,q);
                    break;
                  }
                }
                q+=GetPixelChannels(image);
              }

              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
            }
          }
       }

     if (logging != MagickFalse)
       {
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""      image->colors=%d"", (int) image->colors);

         if (image->colormap != NULL)
           {
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""       i     (red,green,blue,alpha)"");

             for (i=0; i < (ssize_t) image->colors; i++)
             {
               if (i < 300 || i >= (ssize_t) image->colors - 10)
                 {
                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                       ""       %d     (%d,%d,%d,%d)"",
                        (int) i,
                        (int) image->colormap[i].red,
                        (int) image->colormap[i].green,
                        (int) image->colormap[i].blue,
                        (int) image->colormap[i].alpha);
                 }
             }
           }

           if (number_transparent < 257)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      number_transparent     = %d"",
                   number_transparent);
           else

             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      number_transparent     > 256"");

           if (number_opaque < 257)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      number_opaque          = %d"",
                   number_opaque);

           else
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      number_opaque          > 256"");

           if (number_semitransparent < 257)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      number_semitransparent = %d"",
                   number_semitransparent);

           else
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      number_semitransparent > 256"");

           if (ping_have_non_bw == MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      All pixels and the background are black or white"");

           else if (ping_have_color == MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      All pixels and the background are gray"");

           else
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      At least one pixel or the background is non-gray"");

           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""    Exit BUILD_PALETTE:"");
       }

   if (mng_info->write_png8 == MagickFalse)
      break;

   /* Make any reductions necessary for the PNG8 format */
    if (image_colors <= 256 &&
        image_colors != 0 && image->colormap != NULL &&
        number_semitransparent == 0 &&
        number_transparent <= 1)
      break;

    /* PNG8 can't have semitransparent colors so we threshold the
     * opacity to 0 or OpaqueOpacity, and PNG8 can only have one
     * transparent color so if more than one is transparent we merge
     * them into image->background_color.
     */
    if (number_semitransparent != 0 || number_transparent > 1)
      {
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Thresholding the alpha channel to binary"");

        for (y=0; y < (ssize_t) image->rows; y++)
        {
          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

          if (r == (Quantum *) NULL)
            break;

          for (x=0; x < (ssize_t) image->columns; x++)
          {
              if (GetPixelAlpha(image,r) < OpaqueAlpha/2)
                {
                  SetPixelViaPixelInfo(image,&image->background_color,r);
                  SetPixelAlpha(image,TransparentAlpha,r);
                }
              else
                  SetPixelAlpha(image,OpaqueAlpha,r);
              r+=GetPixelChannels(image);
          }

          if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;

          if (image_colors != 0 && image_colors <= 256 &&
             image->colormap != NULL)
            for (i=0; i<image_colors; i++)
                image->colormap[i].alpha =
                    (image->colormap[i].alpha > TransparentAlpha/2 ?
                    TransparentAlpha : OpaqueAlpha);
        }
      continue;
    }

    /* PNG8 can't have more than 256 colors so we quantize the pixels and
     * background color to the 4-4-4-1, 3-3-3-1 or 3-3-2-1 palette.  If the
     * image is mostly gray, the 4-4-4-1 palette is likely to end up with 256
     * colors or less.
     */
    if (tried_444 == MagickFalse && (image_colors == 0 || image_colors > 256))
      {
        if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""    Quantizing the background color to 4-4-4"");

        tried_444 = MagickTrue;

        LBR04PacketRGB(image->background_color);

        if (logging != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    Quantizing the pixel colors to 4-4-4"");

        if (image->colormap == NULL)
        {
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

            if (r == (Quantum *) NULL)
              break;

            for (x=0; x < (ssize_t) image->columns; x++)
            {
              if (GetPixelAlpha(image,r) == OpaqueAlpha)
                  LBR04PixelRGB(r);
              r+=GetPixelChannels(image);
            }

            if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
          }
        }

        else /* Should not reach this; colormap already exists and
                must be <= 256 */
        {
          if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    Quantizing the colormap to 4-4-4"");

          for (i=0; i<image_colors; i++)
          {
            LBR04PacketRGB(image->colormap[i]);
          }
        }
        continue;
      }

    if (tried_333 == MagickFalse && (image_colors == 0 || image_colors > 256))
      {
        if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""    Quantizing the background color to 3-3-3"");

        tried_333 = MagickTrue;

        LBR03PacketRGB(image->background_color);

        if (logging != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    Quantizing the pixel colors to 3-3-3-1"");

        if (image->colormap == NULL)
        {
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

            if (r == (Quantum *) NULL)
              break;

            for (x=0; x < (ssize_t) image->columns; x++)
            {
              if (GetPixelAlpha(image,r) == OpaqueAlpha)
                  LBR03RGB(r);
              r+=GetPixelChannels(image);
            }

            if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
          }
        }

        else /* Should not reach this; colormap already exists and
                must be <= 256 */
        {
          if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    Quantizing the colormap to 3-3-3-1"");
          for (i=0; i<image_colors; i++)
          {
              LBR03PacketRGB(image->colormap[i]);
          }
        }
        continue;
      }

    if (tried_332 == MagickFalse && (image_colors == 0 || image_colors > 256))
      {
        if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""    Quantizing the background color to 3-3-2"");

        tried_332 = MagickTrue;

        /* Red and green were already done so we only quantize the blue
         * channel
         */

        LBR02PacketBlue(image->background_color);

        if (logging != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    Quantizing the pixel colors to 3-3-2-1"");

        if (image->colormap == NULL)
        {
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

            if (r == (Quantum *) NULL)
              break;

            for (x=0; x < (ssize_t) image->columns; x++)
            {
              if (GetPixelAlpha(image,r) == OpaqueAlpha)
                  LBR02PixelBlue(r);
              r+=GetPixelChannels(image);
            }

            if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
          }
        }

        else /* Should not reach this; colormap already exists and
                must be <= 256 */
        {
          if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    Quantizing the colormap to 3-3-2-1"");
          for (i=0; i<image_colors; i++)
          {
              LBR02PacketBlue(image->colormap[i]);
          }
      }
      continue;
    }

    if (image_colors == 0 || image_colors > 256)
    {
      /* Take care of special case with 256 opaque colors + 1 transparent
       * color.  We don't need to quantize to 2-3-2-1; we only need to
       * eliminate one color, so we'll merge the two darkest red
       * colors (0x49, 0, 0) -> (0x24, 0, 0).
       */
      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Merging two dark red background colors to 3-3-2-1"");

      if (ScaleQuantumToChar(image->background_color.red) == 0x49 &&
          ScaleQuantumToChar(image->background_color.green) == 0x00 &&
          ScaleQuantumToChar(image->background_color.blue) == 0x00)
      {
         image->background_color.red=ScaleCharToQuantum(0x24);
      }

      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Merging two dark red pixel colors to 3-3-2-1"");

      if (image->colormap == NULL)
      {
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);

          if (r == (Quantum *) NULL)
            break;

          for (x=0; x < (ssize_t) image->columns; x++)
          {
            if (ScaleQuantumToChar(GetPixelRed(image,r)) == 0x49 &&
                ScaleQuantumToChar(GetPixelGreen(image,r)) == 0x00 &&
                ScaleQuantumToChar(GetPixelBlue(image,r)) == 0x00 &&
                GetPixelAlpha(image,r) == OpaqueAlpha)
              {
                SetPixelRed(image,ScaleCharToQuantum(0x24),r);
              }
            r+=GetPixelChannels(image);
          }

          if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;

        }
      }

      else
      {
         for (i=0; i<image_colors; i++)
         {
            if (ScaleQuantumToChar(image->colormap[i].red) == 0x49 &&
                ScaleQuantumToChar(image->colormap[i].green) == 0x00 &&
                ScaleQuantumToChar(image->colormap[i].blue) == 0x00)
            {
               image->colormap[i].red=ScaleCharToQuantum(0x24);
            }
         }
      }
    }
  }
  }
  /* END OF BUILD_PALETTE */

  /* If we are excluding the tRNS chunk and there is transparency,
   * then we must write a Gray-Alpha (color-type 4) or RGBA (color-type 6)
   * PNG.
   */
  if (mng_info->ping_exclude_tRNS != MagickFalse &&
     (number_transparent != 0 || number_semitransparent != 0))
    {
      unsigned int colortype=mng_info->write_png_colortype;

      if (ping_have_color == MagickFalse)
        mng_info->write_png_colortype = 5;

      else
        mng_info->write_png_colortype = 7;

      if (colortype != 0 &&
         mng_info->write_png_colortype != colortype)
        ping_need_colortype_warning=MagickTrue;

    }

  /* See if cheap transparency is possible.  It is only possible
   * when there is a single transparent color, no semitransparent
   * color, and no opaque color that has the same RGB components
   * as the transparent color.  We only need this information if
   * we are writing a PNG with colortype 0 or 2, and we have not
   * excluded the tRNS chunk.
   */
  if (number_transparent == 1 &&
      mng_info->write_png_colortype < 4)
    {
       ping_have_cheap_transparency = MagickTrue;

       if (number_semitransparent != 0)
         ping_have_cheap_transparency = MagickFalse;

       else if (image_colors == 0 || image_colors > 256 ||
           image->colormap == NULL)
         {
           register const Quantum
             *q;

           for (y=0; y < (ssize_t) image->rows; y++)
           {
             q=GetVirtualPixels(image,0,y,image->columns,1, exception);

             if (q == (Quantum *) NULL)
               break;

             for (x=0; x < (ssize_t) image->columns; x++)
             {
                 if (GetPixelAlpha(image,q) != TransparentAlpha &&
                     (unsigned short) GetPixelRed(image,q) ==
                                     ping_trans_color.red &&
                     (unsigned short) GetPixelGreen(image,q) ==
                                     ping_trans_color.green &&
                     (unsigned short) GetPixelBlue(image,q) ==
                                     ping_trans_color.blue)
                   {
                     ping_have_cheap_transparency = MagickFalse;
                     break;
                   }

                 q+=GetPixelChannels(image);
             }

             if (ping_have_cheap_transparency == MagickFalse)
                break;
           }
         }
       else
         {
            /* Assuming that image->colormap[0] is the one transparent color
             * and that all others are opaque.
             */
            if (image_colors > 1)
              for (i=1; i<image_colors; i++)
                if (image->colormap[i].red == image->colormap[0].red &&
                    image->colormap[i].green == image->colormap[0].green &&
                    image->colormap[i].blue == image->colormap[0].blue)
                  {
                     ping_have_cheap_transparency = MagickFalse;
                     break;
                  }
         }

       if (logging != MagickFalse)
         {
           if (ping_have_cheap_transparency == MagickFalse)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""   Cheap transparency is not possible."");

           else
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""   Cheap transparency is possible."");
         }
     }
  else
    ping_have_cheap_transparency = MagickFalse;

  image_depth=image->depth;

  quantum_info = (QuantumInfo *) NULL;
  number_colors=0;
  image_colors=(int) image->colors;
  image_matte=image->alpha_trait !=
        UndefinedPixelTrait ? MagickTrue : MagickFalse;

  if (mng_info->write_png_colortype < 5)
    mng_info->IsPalette=image->storage_class == PseudoClass &&
      image_colors <= 256 && image->colormap != NULL;
  else
    mng_info->IsPalette = MagickFalse;

  if ((mng_info->write_png_colortype == 4 || mng_info->write_png8) &&
     (image->colors == 0 || image->colormap == NULL))
    {
      image_info=DestroyImageInfo(image_info);
      image=DestroyImage(image);
      (void) ThrowMagickException(exception,GetMagickModule(),CoderError,
          ""Cannot write PNG8 or color-type 3; colormap is NULL"",
          ""`%s'"",IMimage->filename);
      return(MagickFalse);
    }

  /*
    Allocate the PNG structures
  */
#ifdef PNG_USER_MEM_SUPPORTED
 error_info.image=image;
 error_info.exception=exception;
  ping=png_create_write_struct_2(PNG_LIBPNG_VER_STRING,&error_info,
    MagickPNGErrorHandler,MagickPNGWarningHandler,(void *) NULL,
    (png_malloc_ptr) Magick_png_malloc,(png_free_ptr) Magick_png_free);

#else
  ping=png_create_write_struct(PNG_LIBPNG_VER_STRING,&error_info,
    MagickPNGErrorHandler,MagickPNGWarningHandler);

#endif
  if (ping == (png_struct *) NULL)
    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");

  ping_info=png_create_info_struct(ping);

  if (ping_info == (png_info *) NULL)
    {
      png_destroy_write_struct(&ping,(png_info **) NULL);
      ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
    }

  png_set_write_fn(ping,image,png_put_data,png_flush_data);
  pixel_info=(MemoryInfo *) NULL;

  if (setjmp(png_jmpbuf(ping)))
    {
      /*
        PNG write failed.
      */
#ifdef PNG_DEBUG
     if (image_info->verbose)
        (void) printf(""PNG write has failed.\n"");
#endif
      png_destroy_write_struct(&ping,&ping_info);
#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE
      UnlockSemaphoreInfo(ping_semaphore);
#endif

      if (pixel_info != (MemoryInfo *) NULL)
        pixel_info=RelinquishVirtualMemory(pixel_info);

      if (quantum_info != (QuantumInfo *) NULL)
        quantum_info=DestroyQuantumInfo(quantum_info);

      if (ping_have_blob != MagickFalse)
          (void) CloseBlob(image);
      image_info=DestroyImageInfo(image_info);
      image=DestroyImage(image);
      return(MagickFalse);
    }

  /* {  For navigation to end of SETJMP-protected block.  Within this
   *    block, use png_error() instead of Throwing an Exception, to ensure
   *    that libpng is able to clean up, and that the semaphore is unlocked.
   */

#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE
  LockSemaphoreInfo(ping_semaphore);
#endif

#ifdef PNG_BENIGN_ERRORS_SUPPORTED
  /* Allow benign errors */
  png_set_benign_errors(ping, 1);
#endif

#ifdef PNG_SET_USER_LIMITS_SUPPORTED
  /* Reject images with too many rows or columns */
  png_set_user_limits(ping,
    (png_uint_32) MagickMin(0x7fffffffL,
        GetMagickResourceLimit(WidthResource)),
    (png_uint_32) MagickMin(0x7fffffffL,
        GetMagickResourceLimit(HeightResource)));
#endif /* PNG_SET_USER_LIMITS_SUPPORTED */

  /*
    Prepare PNG for writing.
  */

#if defined(PNG_MNG_FEATURES_SUPPORTED)
  if (mng_info->write_mng)
  {
     (void) png_permit_mng_features(ping,PNG_ALL_MNG_FEATURES);
# ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
     /* Disable new libpng-1.5.10 feature when writing a MNG because
      * zero-length PLTE is OK
      */
     png_set_check_for_invalid_index (ping, 0);
# endif
  }

#else
# ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED
  if (mng_info->write_mng)
     png_permit_empty_plte(ping,MagickTrue);

# endif
#endif

  x=0;

  ping_width=(png_uint_32) image->columns;
  ping_height=(png_uint_32) image->rows;

  if (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32)
     image_depth=8;

  if (mng_info->write_png48 || mng_info->write_png64)
     image_depth=16;

  if (mng_info->write_png_depth != 0)
     image_depth=mng_info->write_png_depth;

  /* Adjust requested depth to next higher valid depth if necessary */
  if (image_depth > 8)
     image_depth=16;

  if ((image_depth > 4) && (image_depth < 8))
     image_depth=8;

  if (image_depth == 3)
     image_depth=4;

  if (logging != MagickFalse)
    {
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    width=%.20g"",(double) ping_width);
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    height=%.20g"",(double) ping_height);
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    image_matte=%.20g"",(double) image->alpha_trait);
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    image->depth=%.20g"",(double) image->depth);
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    Tentative ping_bit_depth=%.20g"",(double) image_depth);
    }

  save_image_depth=image_depth;
  ping_bit_depth=(png_byte) save_image_depth;


#if defined(PNG_pHYs_SUPPORTED)
  if (ping_exclude_pHYs == MagickFalse)
  {
  if ((image->resolution.x != 0) && (image->resolution.y != 0) &&
      (!mng_info->write_mng || !mng_info->equal_physs))
    {
      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Setting up pHYs chunk"");

      if (image->units == PixelsPerInchResolution)
        {
          ping_pHYs_unit_type=PNG_RESOLUTION_METER;
          ping_pHYs_x_resolution=
             (png_uint_32) ((100.0*image->resolution.x+0.5)/2.54);
          ping_pHYs_y_resolution=
             (png_uint_32) ((100.0*image->resolution.y+0.5)/2.54);
        }

      else if (image->units == PixelsPerCentimeterResolution)
        {
          ping_pHYs_unit_type=PNG_RESOLUTION_METER;
          ping_pHYs_x_resolution=(png_uint_32) (100.0*image->resolution.x+0.5);
          ping_pHYs_y_resolution=(png_uint_32) (100.0*image->resolution.y+0.5);
        }

      else
        {
          ping_pHYs_unit_type=PNG_RESOLUTION_UNKNOWN;
          ping_pHYs_x_resolution=(png_uint_32) image->resolution.x;
          ping_pHYs_y_resolution=(png_uint_32) image->resolution.y;
        }

      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    Set up PNG pHYs chunk: xres: %.20g, yres: %.20g, units: %d."",
          (double) ping_pHYs_x_resolution,(double) ping_pHYs_y_resolution,
          (int) ping_pHYs_unit_type);
       ping_have_pHYs = MagickTrue;
    }
  }
#endif

  if (ping_exclude_bKGD == MagickFalse)
  {
  if ((!mng_info->adjoin || !mng_info->equal_backgrounds))
    {
       unsigned int
         mask;

       mask=0xffff;
       if (ping_bit_depth == 8)
          mask=0x00ff;

       if (ping_bit_depth == 4)
          mask=0x000f;

       if (ping_bit_depth == 2)
          mask=0x0003;

       if (ping_bit_depth == 1)
          mask=0x0001;

       ping_background.red=(png_uint_16)
         (ScaleQuantumToShort(image->background_color.red) & mask);

       ping_background.green=(png_uint_16)
         (ScaleQuantumToShort(image->background_color.green) & mask);

       ping_background.blue=(png_uint_16)
         (ScaleQuantumToShort(image->background_color.blue) & mask);

       ping_background.gray=(png_uint_16) ping_background.green;
    }

  if (logging != MagickFalse)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    Setting up bKGD chunk (1)"");
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""      background_color index is %d"",
          (int) ping_background.index);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    ping_bit_depth=%d"",ping_bit_depth);
    }

  ping_have_bKGD = MagickTrue;
  }

  /*
    Select the color type.
  */
  matte=image_matte;
  old_bit_depth=0;

  if (mng_info->IsPalette && mng_info->write_png8)
    {
      /* To do: make this a function cause it's used twice, except
         for reducing the sample depth from 8. */

      number_colors=image_colors;

      ping_have_tRNS=MagickFalse;

      /*
        Set image palette.
      */
      ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;

      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  Setting up PLTE chunk with %d colors (%d)"",
            number_colors, image_colors);

      for (i=0; i < (ssize_t) number_colors; i++)
      {
        palette[i].red=ScaleQuantumToChar(image->colormap[i].red);
        palette[i].green=ScaleQuantumToChar(image->colormap[i].green);
        palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);
        if (logging != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
#if MAGICKCORE_QUANTUM_DEPTH == 8
            ""    %3ld (%3d,%3d,%3d)"",
#else
            ""    %5ld (%5d,%5d,%5d)"",
#endif
            (long) i,palette[i].red,palette[i].green,palette[i].blue);

      }

      ping_have_PLTE=MagickTrue;
      image_depth=ping_bit_depth;
      ping_num_trans=0;

      if (matte != MagickFalse)
      {
          /*
            Identify which colormap entry is transparent.
          */
          assert(number_colors <= 256);
          assert(image->colormap != NULL);

          for (i=0; i < (ssize_t) number_transparent; i++)
             ping_trans_alpha[i]=0;


          ping_num_trans=(unsigned short) (number_transparent +
             number_semitransparent);

          if (ping_num_trans == 0)
             ping_have_tRNS=MagickFalse;

          else
             ping_have_tRNS=MagickTrue;
      }

      if (ping_exclude_bKGD == MagickFalse)
      {
       /*
        * Identify which colormap entry is the background color.
        */

        for (i=0; i < (ssize_t) MagickMax(1L*number_colors-1L,1L); i++)
          if (IsPNGColorEqual(ping_background,image->colormap[i]))
            break;

        ping_background.index=(png_byte) i;

        if (logging != MagickFalse)
          {
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""      background_color index is %d"",
                 (int) ping_background.index);
          }
      }
    } /* end of write_png8 */

  else if (mng_info->write_png_colortype == 1)
    {
      image_matte=MagickFalse;
      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;
    }

  else if (mng_info->write_png24 || mng_info->write_png48 ||
      mng_info->write_png_colortype == 3)
    {
      image_matte=MagickFalse;
      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;
    }

  else if (mng_info->write_png32 || mng_info->write_png64 ||
      mng_info->write_png_colortype == 7)
    {
      image_matte=MagickTrue;
      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;
    }

  else /* mng_info->write_pngNN not specified */
    {
      image_depth=ping_bit_depth;

      if (mng_info->write_png_colortype != 0)
        {
          ping_color_type=(png_byte) mng_info->write_png_colortype-1;

          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            image_matte=MagickTrue;

          else
            image_matte=MagickFalse;

          if (logging != MagickFalse)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""   PNG colortype %d was specified:"",(int) ping_color_type);
        }

      else /* write_png_colortype not specified */
        {
          if (logging != MagickFalse)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  Selecting PNG colortype:"");

          ping_color_type=(png_byte) ((matte != MagickFalse)?
            PNG_COLOR_TYPE_RGB_ALPHA:PNG_COLOR_TYPE_RGB);

          if (image_info->type == TrueColorType)
            {
              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;
              image_matte=MagickFalse;
            }

          if (image_info->type == TrueColorAlphaType)
            {
              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;
              image_matte=MagickTrue;
            }

          if (image_info->type == PaletteType ||
              image_info->type == PaletteAlphaType)
            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;

          if (mng_info->write_png_colortype == 0 &&
             image_info->type == UndefinedType)
            {
              if (ping_have_color == MagickFalse)
                {
                  if (image_matte == MagickFalse)
                    {
                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;
                      image_matte=MagickFalse;
                    }

                  else
                    {
                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY_ALPHA;
                      image_matte=MagickTrue;
                    }
                }
              else
                {
                  if (image_matte == MagickFalse)
                    {
                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;
                      image_matte=MagickFalse;
                    }

                  else
                    {
                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGBA;
                      image_matte=MagickTrue;
                    }
                 }
            }

        }

      if (logging != MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    Selected PNG colortype=%d"",ping_color_type);

      if (ping_bit_depth < 8)
        {
          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
              ping_color_type == PNG_COLOR_TYPE_RGB ||
              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            ping_bit_depth=8;
        }

      old_bit_depth=ping_bit_depth;

      if (ping_color_type == PNG_COLOR_TYPE_GRAY)
        {
          if (image->alpha_trait == UndefinedPixelTrait &&
               ping_have_non_bw == MagickFalse)
             ping_bit_depth=1;
        }

      if (ping_color_type == PNG_COLOR_TYPE_PALETTE)
        {
           size_t one = 1;
           ping_bit_depth=1;

           if (image->colors == 0)
           {
              /* DO SOMETHING */
                png_error(ping,""image has 0 colors"");
           }

           while ((int) (one << ping_bit_depth) < (ssize_t) image_colors)
             ping_bit_depth <<= 1;
        }

      if (logging != MagickFalse)
         {
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Number of colors: %.20g"",(double) image_colors);

           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Tentative PNG bit depth: %d"",ping_bit_depth);
         }

      if (ping_bit_depth < (int) mng_info->write_png_depth)
         ping_bit_depth = mng_info->write_png_depth;
    }

  image_depth=ping_bit_depth;

  if (logging != MagickFalse)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    Tentative PNG color type: %s (%.20g)"",
        PngColorTypeToString(ping_color_type),
        (double) ping_color_type);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    image_info->type: %.20g"",(double) image_info->type);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    image_depth: %.20g"",(double) image_depth);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),

        ""    image->depth: %.20g"",(double) image->depth);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    ping_bit_depth: %.20g"",(double) ping_bit_depth);
    }

  if (matte != MagickFalse)
    {
      if (mng_info->IsPalette)
        {
          if (mng_info->write_png_colortype == 0)
            {
              ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;

              if (ping_have_color != MagickFalse)
                 ping_color_type=PNG_COLOR_TYPE_RGBA;
            }

          /*
           * Determine if there is any transparent color.
          */
          if (number_transparent + number_semitransparent == 0)
            {
              /*
                No transparent pixels are present.  Change 4 or 6 to 0 or 2.
              */

              image_matte=MagickFalse;

              if (mng_info->write_png_colortype == 0)
                ping_color_type&=0x03;
            }

          else
            {
              unsigned int
                mask;

              mask=0xffff;

              if (ping_bit_depth == 8)
                 mask=0x00ff;

              if (ping_bit_depth == 4)
                 mask=0x000f;

              if (ping_bit_depth == 2)
                 mask=0x0003;

              if (ping_bit_depth == 1)
                 mask=0x0001;

              ping_trans_color.red=(png_uint_16)
                (ScaleQuantumToShort(image->colormap[0].red) & mask);

              ping_trans_color.green=(png_uint_16)
                (ScaleQuantumToShort(image->colormap[0].green) & mask);

              ping_trans_color.blue=(png_uint_16)
                (ScaleQuantumToShort(image->colormap[0].blue) & mask);

              ping_trans_color.gray=(png_uint_16)
                (ScaleQuantumToShort(GetPixelInfoIntensity(image,
                   image->colormap)) & mask);

              ping_trans_color.index=(png_byte) 0;

              ping_have_tRNS=MagickTrue;
            }

          if (ping_have_tRNS != MagickFalse)
            {
              /*
               * Determine if there is one and only one transparent color
               * and if so if it is fully transparent.
               */
              if (ping_have_cheap_transparency == MagickFalse)
                ping_have_tRNS=MagickFalse;
            }

          if (ping_have_tRNS != MagickFalse)
            {
              if (mng_info->write_png_colortype == 0)
                ping_color_type &= 0x03;  /* changes 4 or 6 to 0 or 2 */

              if (image_depth == 8)
                {
                  ping_trans_color.red&=0xff;
                  ping_trans_color.green&=0xff;
                  ping_trans_color.blue&=0xff;
                  ping_trans_color.gray&=0xff;
                }
            }
        }
      else
        {
          if (image_depth == 8)
            {
              ping_trans_color.red&=0xff;
              ping_trans_color.green&=0xff;
              ping_trans_color.blue&=0xff;
              ping_trans_color.gray&=0xff;
            }
        }
    }

    matte=image_matte;

    if (ping_have_tRNS != MagickFalse)
      image_matte=MagickFalse;

    if ((mng_info->IsPalette) &&
        mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE &&
        ping_have_color == MagickFalse &&
        (image_matte == MagickFalse || image_depth >= 8))
      {
        size_t one=1;

        if (image_matte != MagickFalse)
          ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;

        else if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_GRAY_ALPHA)
          {
            ping_color_type=PNG_COLOR_TYPE_GRAY;

            if (save_image_depth == 16 && image_depth == 8)
              {
                if (logging != MagickFalse)
                  {
                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                        ""  Scaling ping_trans_color (0)"");
                  }
                    ping_trans_color.gray*=0x0101;
              }
          }

        if (image_depth > MAGICKCORE_QUANTUM_DEPTH)
          image_depth=MAGICKCORE_QUANTUM_DEPTH;

        if ((image_colors == 0) ||
             ((ssize_t) (image_colors-1) > (ssize_t) MaxColormapSize))
          image_colors=(int) (one << image_depth);

        if (image_depth > 8)
          ping_bit_depth=16;

        else
          {
            ping_bit_depth=8;
            if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)
              {
                if(!mng_info->write_png_depth)
                  {
                    ping_bit_depth=1;

                    while ((int) (one << ping_bit_depth)
                        < (ssize_t) image_colors)
                      ping_bit_depth <<= 1;
                  }
              }

            else if (ping_color_type ==
                PNG_COLOR_TYPE_GRAY && image_colors < 17 &&
                mng_info->IsPalette)
              {
              /* Check if grayscale is reducible */

                int
                  depth_4_ok=MagickTrue,
                  depth_2_ok=MagickTrue,
                  depth_1_ok=MagickTrue;

                for (i=0; i < (ssize_t) image_colors; i++)
                {
                   unsigned char
                     intensity;

                   intensity=ScaleQuantumToChar(image->colormap[i].red);

                   if ((intensity & 0x0f) != ((intensity & 0xf0) >> 4))
                     depth_4_ok=depth_2_ok=depth_1_ok=MagickFalse;
                   else if ((intensity & 0x03) != ((intensity & 0x0c) >> 2))
                     depth_2_ok=depth_1_ok=MagickFalse;
                   else if ((intensity & 0x01) != ((intensity & 0x02) >> 1))
                     depth_1_ok=MagickFalse;
                }

                if (depth_1_ok && mng_info->write_png_depth <= 1)
                  ping_bit_depth=1;

                else if (depth_2_ok && mng_info->write_png_depth <= 2)
                  ping_bit_depth=2;

                else if (depth_4_ok && mng_info->write_png_depth <= 4)
                  ping_bit_depth=4;
              }
          }

          image_depth=ping_bit_depth;
      }

    else

      if (mng_info->IsPalette)
      {
        number_colors=image_colors;

        if (image_depth <= 8)
          {
            /*
              Set image palette.
            */
            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;

            if (!(mng_info->have_write_global_plte && matte == MagickFalse))
              {
                for (i=0; i < (ssize_t) number_colors; i++)
                {
                  palette[i].red=ScaleQuantumToChar(image->colormap[i].red);
                  palette[i].green=
                    ScaleQuantumToChar(image->colormap[i].green);
                  palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);
                }

                if (logging != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""  Setting up PLTE chunk with %d colors"",
                    number_colors);

                ping_have_PLTE=MagickTrue;
              }

            /* color_type is PNG_COLOR_TYPE_PALETTE */
            if (mng_info->write_png_depth == 0)
              {
                size_t
                  one;

                ping_bit_depth=1;
                one=1;

                while ((one << ping_bit_depth) < (size_t) number_colors)
                  ping_bit_depth <<= 1;
              }

            ping_num_trans=0;

            if (matte != MagickFalse)
              {
                /*
                 * Set up trans_colors array.
                 */
                assert(number_colors <= 256);

                ping_num_trans=(unsigned short) (number_transparent +
                  number_semitransparent);

                if (ping_num_trans == 0)
                  ping_have_tRNS=MagickFalse;

                else
                  {
                    if (logging != MagickFalse)
                      {
                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                          ""  Scaling ping_trans_color (1)"");
                      }
                    ping_have_tRNS=MagickTrue;

                    for (i=0; i < ping_num_trans; i++)
                    {
                       ping_trans_alpha[i]= (png_byte)
                         ScaleQuantumToChar(image->colormap[i].alpha);
                    }
                  }
              }
          }
      }

    else
      {

        if (image_depth < 8)
          image_depth=8;

        if ((save_image_depth == 16) && (image_depth == 8))
          {
            if (logging != MagickFalse)
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""    Scaling ping_trans_color from (%d,%d,%d)"",
                  (int) ping_trans_color.red,
                  (int) ping_trans_color.green,
                  (int) ping_trans_color.blue);
              }

            ping_trans_color.red*=0x0101;
            ping_trans_color.green*=0x0101;
            ping_trans_color.blue*=0x0101;
            ping_trans_color.gray*=0x0101;

            if (logging != MagickFalse)
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""    to (%d,%d,%d)"",
                  (int) ping_trans_color.red,
                  (int) ping_trans_color.green,
                  (int) ping_trans_color.blue);
              }
          }
      }

    if (ping_bit_depth <  (ssize_t) mng_info->write_png_depth)
         ping_bit_depth =  (ssize_t) mng_info->write_png_depth;

    /*
      Adjust background and transparency samples in sub-8-bit grayscale files.
    */
    if (ping_bit_depth < 8 && ping_color_type ==
        PNG_COLOR_TYPE_GRAY)
      {
         png_uint_16
           maxval;

         size_t
           one=1;

         maxval=(png_uint_16) ((one << ping_bit_depth)-1);

         if (ping_exclude_bKGD == MagickFalse)
         {

         ping_background.gray=(png_uint_16) ((maxval/65535.)*
           (ScaleQuantumToShort(((GetPixelInfoIntensity(image,
           &image->background_color))) +.5)));

         if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  Setting up bKGD chunk (2)"");
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      background_color index is %d"",
             (int) ping_background.index);

         ping_have_bKGD = MagickTrue;
         }

         if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  Scaling ping_trans_color.gray from %d"",
             (int)ping_trans_color.gray);

         ping_trans_color.gray=(png_uint_16) ((maxval/255.)*(
           ping_trans_color.gray)+.5);

         if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      to %d"", (int)ping_trans_color.gray);
      }

  if (ping_exclude_bKGD == MagickFalse)
  {
    if (mng_info->IsPalette && (int) ping_color_type == PNG_COLOR_TYPE_PALETTE)
      {
        /*
           Identify which colormap entry is the background color.
        */

        number_colors=image_colors;

        for (i=0; i < (ssize_t) MagickMax(1L*number_colors,1L); i++)
          if (IsPNGColorEqual(image->background_color,image->colormap[i]))
            break;

        ping_background.index=(png_byte) i;

        if (logging != MagickFalse)
          {
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Setting up bKGD chunk with index=%d"",(int) i);
          }

        if (i < (ssize_t) number_colors)
          {
            ping_have_bKGD = MagickTrue;

            if (logging != MagickFalse)
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""     background   =(%d,%d,%d)"",
                        (int) ping_background.red,
                        (int) ping_background.green,
                        (int) ping_background.blue);
              }
          }

        else  /* Can't happen */
          {
            if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      No room in PLTE to add bKGD color"");
            ping_have_bKGD = MagickFalse;
          }
      }
  }

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""    PNG color type: %s (%d)"", PngColorTypeToString(ping_color_type),
      ping_color_type);
  /*
    Initialize compression level and filtering.
  */
  if (logging != MagickFalse)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""  Setting up deflate compression"");

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    Compression buffer size: 32768"");
    }

  png_set_compression_buffer_size(ping,32768L);

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""    Compression mem level: 9"");

  png_set_compression_mem_level(ping, 9);

  /* Untangle the ""-quality"" setting:

     Undefined is 0; the default is used.
     Default is 75

     10's digit:

        0 or omitted: Use Z_HUFFMAN_ONLY strategy with the
           zlib default compression level

        1-9: the zlib compression level

     1's digit:

        0-4: the PNG filter method

        5:   libpng adaptive filtering if compression level > 5
             libpng filter type ""none"" if compression level <= 5
                or if image is grayscale or palette

        6:   libpng adaptive filtering

        7:   ""LOCO"" filtering (intrapixel differing) if writing
             a MNG, otherwise ""none"".  Did not work in IM-6.7.0-9
             and earlier because of a missing ""else"".

        8:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), adaptive
             filtering. Unused prior to IM-6.7.0-10, was same as 6

        9:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), no PNG filters
             Unused prior to IM-6.7.0-10, was same as 6

    Note that using the -quality option, not all combinations of
    PNG filter type, zlib compression level, and zlib compression
    strategy are possible.  This will be addressed soon in a
    release that accomodates ""-define png:compression-strategy"", etc.

   */

  quality=image_info->quality == UndefinedCompressionQuality ? 75UL :
     image_info->quality;

  if (quality <= 9)
    {
      if (mng_info->write_png_compression_strategy == 0)
        mng_info->write_png_compression_strategy = Z_HUFFMAN_ONLY+1;
    }

  else if (mng_info->write_png_compression_level == 0)
    {
      int
        level;

      level=(int) MagickMin((ssize_t) quality/10,9);

      mng_info->write_png_compression_level = level+1;
    }

  if (mng_info->write_png_compression_strategy == 0)
    {
        if ((quality %10) == 8 || (quality %10) == 9)
#ifdef Z_RLE  /* Z_RLE was added to zlib-1.2.0 */
          mng_info->write_png_compression_strategy=Z_RLE+1;
#else
          mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;
#endif
    }

  if (mng_info->write_png_compression_filter == 0)
        mng_info->write_png_compression_filter=((int) quality % 10) + 1;

  if (logging != MagickFalse)
    {
        if (mng_info->write_png_compression_level)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Compression level:    %d"",
            (int) mng_info->write_png_compression_level-1);

        if (mng_info->write_png_compression_strategy)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Compression strategy: %d"",
            (int) mng_info->write_png_compression_strategy-1);

        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  Setting up filtering"");

        if (mng_info->write_png_compression_filter == 6)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Base filter method: ADAPTIVE"");
        else if (mng_info->write_png_compression_filter == 0 ||
                 mng_info->write_png_compression_filter == 1)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Base filter method: NONE"");
        else
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Base filter method: %d"",
            (int) mng_info->write_png_compression_filter-1);
    }

  if (mng_info->write_png_compression_level != 0)
    png_set_compression_level(ping,mng_info->write_png_compression_level-1);

  if (mng_info->write_png_compression_filter == 6)
    {
      if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||
         ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE) ||
         (quality < 50))
        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);
      else
        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);
     }
  else if (mng_info->write_png_compression_filter == 7 ||
      mng_info->write_png_compression_filter == 10)
    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);

  else if (mng_info->write_png_compression_filter == 8)
    {
#if defined(PNG_MNG_FEATURES_SUPPORTED) && defined(PNG_INTRAPIXEL_DIFFERENCING)
      if (mng_info->write_mng)
      {
         if (((int) ping_color_type == PNG_COLOR_TYPE_RGB) ||
             ((int) ping_color_type == PNG_COLOR_TYPE_RGBA))
        ping_filter_method=PNG_INTRAPIXEL_DIFFERENCING;
      }
#endif
      png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);
    }

  else if (mng_info->write_png_compression_filter == 9)
    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);

  else if (mng_info->write_png_compression_filter != 0)
    png_set_filter(ping,PNG_FILTER_TYPE_BASE,
       mng_info->write_png_compression_filter-1);

  if (mng_info->write_png_compression_strategy != 0)
    png_set_compression_strategy(ping,
       mng_info->write_png_compression_strategy-1);

  ping_interlace_method=image_info->interlace != NoInterlace;

  if (mng_info->write_mng)
    png_set_sig_bytes(ping,8);

  /* Bail out if cannot meet defined png:bit-depth or png:color-type */

  if (mng_info->write_png_colortype != 0)
    {
     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY)
       if (ping_have_color != MagickFalse)
         {
           ping_color_type = PNG_COLOR_TYPE_RGB;

           if (ping_bit_depth < 8)
             ping_bit_depth=8;
         }

     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY_ALPHA)
       if (ping_have_color != MagickFalse)
         ping_color_type = PNG_COLOR_TYPE_RGB_ALPHA;
    }

  if (ping_need_colortype_warning != MagickFalse ||
     ((mng_info->write_png_depth &&
     (int) mng_info->write_png_depth != ping_bit_depth) ||
     (mng_info->write_png_colortype &&
     ((int) mng_info->write_png_colortype-1 != ping_color_type &&
      mng_info->write_png_colortype != 7 &&
      !(mng_info->write_png_colortype == 5 && ping_color_type == 0)))))
    {
      if (logging != MagickFalse)
        {
          if (ping_need_colortype_warning != MagickFalse)
            {
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""  Image has transparency but tRNS chunk was excluded"");
            }

          if (mng_info->write_png_depth)
            {
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Defined png:bit-depth=%u, Computed depth=%u"",
                  mng_info->write_png_depth,
                  ping_bit_depth);
            }

          if (mng_info->write_png_colortype)
            {
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Defined png:color-type=%u, Computed color type=%u"",
                  mng_info->write_png_colortype-1,
                  ping_color_type);
            }
        }

      png_warning(ping,
        ""Cannot write image with defined png:bit-depth or png:color-type."");
    }

  if (image_matte != MagickFalse && image->alpha_trait == UndefinedPixelTrait)
    {
      /* Add an opaque matte channel */
      image->alpha_trait = BlendPixelTrait;
      (void) SetImageAlpha(image,OpaqueAlpha,exception);

      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  Added an opaque matte channel"");
    }

  if (number_transparent != 0 || number_semitransparent != 0)
    {
      if (ping_color_type < 4)
        {
           ping_have_tRNS=MagickTrue;
           if (logging != MagickFalse)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""  Setting ping_have_tRNS=MagickTrue."");
        }
    }

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  Writing PNG header chunks"");

  png_set_IHDR(ping,ping_info,ping_width,ping_height,
               ping_bit_depth,ping_color_type,
               ping_interlace_method,ping_compression_method,
               ping_filter_method);

  if (ping_color_type == 3 && ping_have_PLTE != MagickFalse)
    {
      png_set_PLTE(ping,ping_info,palette,number_colors);

      if (logging != MagickFalse)
        {
          for (i=0; i< (ssize_t) number_colors; i++)
          {
            if (i < ping_num_trans)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""     PLTE[%d] = (%d,%d,%d), tRNS[%d] = (%d)"",
                      (int) i,
                      (int) palette[i].red,
                      (int) palette[i].green,
                      (int) palette[i].blue,
                      (int) i,
                      (int) ping_trans_alpha[i]);
             else
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""     PLTE[%d] = (%d,%d,%d)"",
                      (int) i,
                      (int) palette[i].red,
                      (int) palette[i].green,
                      (int) palette[i].blue);
           }
         }
    }

  /* Only write the iCCP chunk if we are not writing the sRGB chunk. */
  if (ping_exclude_sRGB != MagickFalse ||
     (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))
  {
    if ((ping_exclude_tEXt == MagickFalse ||
       ping_exclude_zTXt == MagickFalse) &&
       (ping_exclude_iCCP == MagickFalse || ping_exclude_zCCP == MagickFalse))
    {
      ResetImageProfileIterator(image);
      for (name=GetNextImageProfile(image); name != (const char *) NULL; )
      {
        profile=GetImageProfile(image,name);

        if (profile != (StringInfo *) NULL)
          {
#ifdef PNG_WRITE_iCCP_SUPPORTED
            if ((LocaleCompare(name,""ICC"") == 0) ||
                (LocaleCompare(name,""ICM"") == 0))
              {
                ping_have_iCCP = MagickTrue;
                if (ping_exclude_iCCP == MagickFalse)
                  {
                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                        ""  Setting up iCCP chunk"");

                    png_set_iCCP(ping,ping_info,(png_charp) name,0,
#if (PNG_LIBPNG_VER < 10500)
                    (png_charp) GetStringInfoDatum(profile),
#else
                    (const png_byte *) GetStringInfoDatum(profile),
#endif
                    (png_uint_32) GetStringInfoLength(profile));
                  }
                else
                  {
                    /* Do not write hex-encoded ICC chunk */
                       name=GetNextImageProfile(image);
                       continue;
                  }
              }
#endif /* WRITE_iCCP */

            if (LocaleCompare(name,""exif"") == 0)
              {
                   /* Do not write hex-encoded ICC chunk; we will
                      write it later as an eXIf chunk */
                   name=GetNextImageProfile(image);
                   continue;
              }

              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""  Setting up zTXt chunk with uuencoded %s profile"",
                 name);
              Magick_png_write_raw_profile(image_info,ping,ping_info,
                (unsigned char *) name,(unsigned char *) name,
                GetStringInfoDatum(profile),
                (png_uint_32) GetStringInfoLength(profile));
          }
        name=GetNextImageProfile(image);
      }
    }
  }

#if defined(PNG_WRITE_sRGB_SUPPORTED)
  if ((mng_info->have_write_global_srgb == 0) &&
      ping_have_iCCP != MagickTrue &&
      (ping_have_sRGB != MagickFalse ||
      png_get_valid(ping,ping_info,PNG_INFO_sRGB)))
    {
      if (ping_exclude_sRGB == MagickFalse)
        {
          /*
            Note image rendering intent.
          */
          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  Setting up sRGB chunk"");

          (void) png_set_sRGB(ping,ping_info,(
            Magick_RenderingIntent_to_PNG_RenderingIntent(
              image->rendering_intent)));

          ping_have_sRGB = MagickTrue;
        }
    }

  if ((!mng_info->write_mng) || (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))
#endif
    {
      if (ping_exclude_gAMA == MagickFalse &&
          ping_have_iCCP == MagickFalse &&
          ping_have_sRGB == MagickFalse &&
          (ping_exclude_sRGB == MagickFalse ||
          (image->gamma < .45 || image->gamma > .46)))
      {
      if ((mng_info->have_write_global_gama == 0) && (image->gamma != 0.0))
        {
          /*
            Note image gamma.
            To do: check for cHRM+gAMA == sRGB, and write sRGB instead.
          */
          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Setting up gAMA chunk"");

          png_set_gAMA(ping,ping_info,image->gamma);
        }
      }

      if (ping_exclude_cHRM == MagickFalse && ping_have_sRGB == MagickFalse)
        {
          if ((mng_info->have_write_global_chrm == 0) &&
              (image->chromaticity.red_primary.x != 0.0))
            {
              /*
                Note image chromaticity.
                Note: if cHRM+gAMA == sRGB write sRGB instead.
              */
               PrimaryInfo
                 bp,
                 gp,
                 rp,
                 wp;

               wp=image->chromaticity.white_point;
               rp=image->chromaticity.red_primary;
               gp=image->chromaticity.green_primary;
               bp=image->chromaticity.blue_primary;

               if (logging != MagickFalse)
                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""  Setting up cHRM chunk"");

               png_set_cHRM(ping,ping_info,wp.x,wp.y,rp.x,rp.y,gp.x,gp.y,
                   bp.x,bp.y);
           }
        }
    }

  if (ping_exclude_bKGD == MagickFalse)
    {
      if (ping_have_bKGD != MagickFalse)
        {
          png_set_bKGD(ping,ping_info,&ping_background);
          if (logging != MagickFalse)
            {
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""    Setting up bKGD chunk"");
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      background color = (%d,%d,%d)"",
                        (int) ping_background.red,
                        (int) ping_background.green,
                        (int) ping_background.blue);
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      index = %d, gray=%d"",
                        (int) ping_background.index,
                        (int) ping_background.gray);
            }
         }
    }

  if (ping_exclude_pHYs == MagickFalse)
    {
      if (ping_have_pHYs != MagickFalse)
        {
          png_set_pHYs(ping,ping_info,
             ping_pHYs_x_resolution,
             ping_pHYs_y_resolution,
             ping_pHYs_unit_type);

          if (logging != MagickFalse)
            {
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""    Setting up pHYs chunk"");
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      x_resolution=%lu"",
                   (unsigned long) ping_pHYs_x_resolution);
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      y_resolution=%lu"",
                   (unsigned long) ping_pHYs_y_resolution);
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      unit_type=%lu"",
                   (unsigned long) ping_pHYs_unit_type);
            }
        }
    }

#if defined(PNG_tIME_SUPPORTED)
  if (ping_exclude_tIME == MagickFalse)
    {
      const char
        *timestamp;

      if (image->taint == MagickFalse)
        {
          timestamp=GetImageOption(image_info,""png:tIME"");

          if (timestamp == (const char *) NULL)
            timestamp=GetImageProperty(image,""png:tIME"",exception);
        }

      else
        {
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  Reset tIME in tainted image"");

          timestamp=GetImageProperty(image,""date:modify"",exception);
        }

      if (timestamp != (const char *) NULL)
          write_tIME_chunk(image,ping,ping_info,timestamp,exception);
    }
#endif

  if (mng_info->need_blob != MagickFalse)
  {
    if (OpenBlob(image_info,image,WriteBinaryBlobMode,exception) ==
       MagickFalse)
       png_error(ping,""WriteBlob Failed"");

     ping_have_blob=MagickTrue;
  }

  png_write_info_before_PLTE(ping, ping_info);

  if (ping_have_tRNS != MagickFalse && ping_color_type < 4)
    {
      if (logging != MagickFalse)
        {
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Calling png_set_tRNS with num_trans=%d"",ping_num_trans);
        }

      if (ping_color_type == 3)
         (void) png_set_tRNS(ping, ping_info,
                ping_trans_alpha,
                ping_num_trans,
                NULL);

      else
        {
           (void) png_set_tRNS(ping, ping_info,
                  NULL,
                  0,
                  &ping_trans_color);

           if (logging != MagickFalse)
             {
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""     tRNS color   =(%d,%d,%d)"",
                       (int) ping_trans_color.red,
                       (int) ping_trans_color.green,
                       (int) ping_trans_color.blue);
             }
         }
    }

  /* write any png-chunk-b profiles */
  (void) Magick_png_write_chunk_from_profile(image,""PNG-chunk-b"",logging);

  png_write_info(ping,ping_info);

  /* write any PNG-chunk-m profiles */
  (void) Magick_png_write_chunk_from_profile(image,""PNG-chunk-m"",logging);

  ping_wrote_caNv = MagickFalse;

  /* write caNv chunk */
  if (ping_exclude_caNv == MagickFalse)
    {
      if ((image->page.width != 0 && image->page.width != image->columns) ||
          (image->page.height != 0 && image->page.height != image->rows) ||
          image->page.x != 0 || image->page.y != 0)
        {
          unsigned char
            chunk[20];

          (void) WriteBlobMSBULong(image,16L);  /* data length=8 */
          PNGType(chunk,mng_caNv);
          LogPNGChunk(logging,mng_caNv,16L);
          PNGLong(chunk+4,(png_uint_32) image->page.width);
          PNGLong(chunk+8,(png_uint_32) image->page.height);
          PNGsLong(chunk+12,(png_int_32) image->page.x);
          PNGsLong(chunk+16,(png_int_32) image->page.y);
          (void) WriteBlob(image,20,chunk);
          (void) WriteBlobMSBULong(image,crc32(0,chunk,20));
          ping_wrote_caNv = MagickTrue;
        }
    }

#if defined(PNG_oFFs_SUPPORTED)
  if (ping_exclude_oFFs == MagickFalse && ping_wrote_caNv == MagickFalse)
    {
      if (image->page.x || image->page.y)
        {
           png_set_oFFs(ping,ping_info,(png_int_32) image->page.x,
              (png_int_32) image->page.y, 0);

           if (logging != MagickFalse)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""    Setting up oFFs chunk with x=%d, y=%d, units=0"",
                 (int) image->page.x, (int) image->page.y);
        }
    }
#endif

  /* write vpAg chunk (deprecated, replaced by caNv) */
  if (ping_exclude_vpAg == MagickFalse && ping_wrote_caNv == MagickFalse)
    {
      if ((image->page.width != 0 && image->page.width != image->columns) ||
          (image->page.height != 0 && image->page.height != image->rows))
        {
          unsigned char
            chunk[14];

          (void) WriteBlobMSBULong(image,9L);  /* data length=8 */
          PNGType(chunk,mng_vpAg);
          LogPNGChunk(logging,mng_vpAg,9L);
          PNGLong(chunk+4,(png_uint_32) image->page.width);
          PNGLong(chunk+8,(png_uint_32) image->page.height);
          chunk[12]=0;   /* unit = pixels */
          (void) WriteBlob(image,13,chunk);
          (void) WriteBlobMSBULong(image,crc32(0,chunk,13));
        }
    }

#if (PNG_LIBPNG_VER == 10206)
    /* avoid libpng-1.2.6 bug by setting PNG_HAVE_IDAT flag */
#define PNG_HAVE_IDAT               0x04
    ping->mode |= PNG_HAVE_IDAT;
#undef PNG_HAVE_IDAT
#endif

  png_set_packing(ping);
  /*
    Allocate memory.
  */
  rowbytes=image->columns;
  if (image_depth > 8)
    rowbytes*=2;
  switch (ping_color_type)
    {
      case PNG_COLOR_TYPE_RGB:
        rowbytes*=3;
        break;

      case PNG_COLOR_TYPE_GRAY_ALPHA:
        rowbytes*=2;
        break;

      case PNG_COLOR_TYPE_RGBA:
        rowbytes*=4;
        break;

      default:
        break;
    }

  if (logging != MagickFalse)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""  Writing PNG image data"");

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    Allocating %.20g bytes of memory for pixels"",(double) rowbytes);
    }
  pixel_info=AcquireVirtualMemory(rowbytes,sizeof(*ping_pixels));
  if (pixel_info == (MemoryInfo *) NULL)
    png_error(ping,""Allocation of memory for pixels failed"");
  ping_pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);

  /*
    Initialize image scanlines.
  */
  quantum_info=AcquireQuantumInfo(image_info,image);
  if (quantum_info == (QuantumInfo *) NULL)
    png_error(ping,""Memory allocation for quantum_info failed"");
  quantum_info->format=UndefinedQuantumFormat;
  SetQuantumDepth(image,quantum_info,image_depth);
  (void) SetQuantumEndian(image,quantum_info,MSBEndian);
  num_passes=png_set_interlace_handling(ping);

  if ((!mng_info->write_png8 && !mng_info->write_png24 &&
       !mng_info->write_png48 && !mng_info->write_png64 &&
       !mng_info->write_png32) &&
       (mng_info->IsPalette ||
       (image_info->type == BilevelType)) &&
       image_matte == MagickFalse &&
       ping_have_non_bw == MagickFalse)
    {
      /* Palette, Bilevel, or Opaque Monochrome */
      register const Quantum
        *p;

      SetQuantumDepth(image,quantum_info,8);
      for (pass=0; pass < num_passes; pass++)
      {
        /*
          Convert PseudoClass image to a PNG monochrome image.
        */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          if (logging != MagickFalse && y == 0)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""    Writing row of pixels (0)"");

          p=GetVirtualPixels(image,0,y,image->columns,1,exception);

          if (p == (const Quantum *) NULL)
            break;

          if (mng_info->IsPalette)
            {
              (void) ExportQuantumPixels(image,(CacheView *) NULL,
                quantum_info,GrayQuantum,ping_pixels,exception);
              if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_PALETTE &&
                  mng_info->write_png_depth &&
                  mng_info->write_png_depth != old_bit_depth)
                {
                  /* Undo pixel scaling */
                  for (i=0; i < (ssize_t) image->columns; i++)
                     *(ping_pixels+i)=(unsigned char) (*(ping_pixels+i)
                     >> (8-old_bit_depth));
                }
            }

          else
            {
              (void) ExportQuantumPixels(image,(CacheView *) NULL,
                quantum_info,RedQuantum,ping_pixels,exception);
            }

          if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE)
            for (i=0; i < (ssize_t) image->columns; i++)
               *(ping_pixels+i)=(unsigned char) ((*(ping_pixels+i) > 127) ?
                      255 : 0);

          if (logging != MagickFalse && y == 0)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""    Writing row of pixels (1)"");

          png_write_row(ping,ping_pixels);

          status=SetImageProgress(image,SaveImageTag,
              (MagickOffsetType) (pass * image->rows + y),
              num_passes * image->rows);

          if (status == MagickFalse)
            break;
        }
      }
    }

  else   /* Not Palette, Bilevel, or Opaque Monochrome */
    {
      if ((!mng_info->write_png8 && !mng_info->write_png24 &&
          !mng_info->write_png48 && !mng_info->write_png64 &&
          !mng_info->write_png32) && (image_matte != MagickFalse ||
          (ping_bit_depth >= MAGICKCORE_QUANTUM_DEPTH)) &&
          (mng_info->IsPalette) && ping_have_color == MagickFalse)
        {
          register const Quantum
            *p;

          for (pass=0; pass < num_passes; pass++)
          {

          for (y=0; y < (ssize_t) image->rows; y++)
          {
            p=GetVirtualPixels(image,0,y,image->columns,1,exception);

            if (p == (const Quantum *) NULL)
              break;

            if (ping_color_type == PNG_COLOR_TYPE_GRAY)
              {
                if (mng_info->IsPalette)
                  (void) ExportQuantumPixels(image,(CacheView *) NULL,
                    quantum_info,GrayQuantum,ping_pixels,exception);

                else
                  (void) ExportQuantumPixels(image,(CacheView *) NULL,
                    quantum_info,RedQuantum,ping_pixels,exception);

                if (logging != MagickFalse && y == 0)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                       ""    Writing GRAY PNG pixels (2)"");
              }

            else /* PNG_COLOR_TYPE_GRAY_ALPHA */
              {
                if (logging != MagickFalse && y == 0)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                         ""    Writing GRAY_ALPHA PNG pixels (2)"");

                (void) ExportQuantumPixels(image,(CacheView *) NULL,
                  quantum_info,GrayAlphaQuantum,ping_pixels,exception);
              }

            if (logging != MagickFalse && y == 0)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""    Writing row of pixels (2)"");

            png_write_row(ping,ping_pixels);

            status=SetImageProgress(image,SaveImageTag,
              (MagickOffsetType) (pass * image->rows + y),
              num_passes * image->rows);

            if (status == MagickFalse)
              break;
            }
          }
        }

      else
        {
          register const Quantum
            *p;

          for (pass=0; pass < num_passes; pass++)
          {
            if ((image_depth > 8) ||
                mng_info->write_png24 ||
                mng_info->write_png32 ||
                mng_info->write_png48 ||
                mng_info->write_png64 ||
                (!mng_info->write_png8 && !mng_info->IsPalette))
            {
              for (y=0; y < (ssize_t) image->rows; y++)
              {
                p=GetVirtualPixels(image,0,y,image->columns,1, exception);

                if (p == (const Quantum *) NULL)
                  break;

                if (ping_color_type == PNG_COLOR_TYPE_GRAY)
                  {
                    if (image->storage_class == DirectClass)
                      (void) ExportQuantumPixels(image,(CacheView *) NULL,
                        quantum_info,RedQuantum,ping_pixels,exception);

                    else
                      (void) ExportQuantumPixels(image,(CacheView *) NULL,
                        quantum_info,GrayQuantum,ping_pixels,exception);
                  }

                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
                  {
                    (void) ExportQuantumPixels(image,(CacheView *) NULL,
                      quantum_info,GrayAlphaQuantum,ping_pixels,
                      exception);

                    if (logging != MagickFalse && y == 0)
                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                           ""    Writing GRAY_ALPHA PNG pixels (3)"");
                  }

                else if (image_matte != MagickFalse)
                  (void) ExportQuantumPixels(image,(CacheView *) NULL,
                    quantum_info,RGBAQuantum,ping_pixels,exception);

                else
                  (void) ExportQuantumPixels(image,(CacheView *) NULL,
                    quantum_info,RGBQuantum,ping_pixels,exception);

                if (logging != MagickFalse && y == 0)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                      ""    Writing row of pixels (3)"");

                png_write_row(ping,ping_pixels);

                status=SetImageProgress(image,SaveImageTag,
                  (MagickOffsetType) (pass * image->rows + y),
                  num_passes * image->rows);

                if (status == MagickFalse)
                  break;
              }
            }

          else
            /* not ((image_depth > 8) ||
                mng_info->write_png24 || mng_info->write_png32 ||
                mng_info->write_png48 || mng_info->write_png64 ||
                (!mng_info->write_png8 && !mng_info->IsPalette))
             */
            {
              if ((ping_color_type != PNG_COLOR_TYPE_GRAY) &&
                  (ping_color_type != PNG_COLOR_TYPE_GRAY_ALPHA))
                {
                  if (logging != MagickFalse)
                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                      ""  pass %d, Image Is not GRAY or GRAY_ALPHA"",pass);

                  SetQuantumDepth(image,quantum_info,8);
                  image_depth=8;
                }

              for (y=0; y < (ssize_t) image->rows; y++)
              {
                if (logging != MagickFalse && y == 0)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""  pass %d, Image Is RGB, 16-bit GRAY, or GRAY_ALPHA"",
                    pass);

                p=GetVirtualPixels(image,0,y,image->columns,1, exception);

                if (p == (const Quantum *) NULL)
                  break;

                if (ping_color_type == PNG_COLOR_TYPE_GRAY)
                  {
                    SetQuantumDepth(image,quantum_info,image->depth);

                    (void) ExportQuantumPixels(image,(CacheView *) NULL,
                       quantum_info,GrayQuantum,ping_pixels,exception);
                  }

                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
                  {
                    if (logging != MagickFalse && y == 0)
                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                           ""  Writing GRAY_ALPHA PNG pixels (4)"");

                    (void) ExportQuantumPixels(image,(CacheView *) NULL,
                         quantum_info,GrayAlphaQuantum,ping_pixels,
                         exception);
                  }

                else
                  {
                    (void) ExportQuantumPixels(image,(CacheView *) NULL,
                      quantum_info,IndexQuantum,ping_pixels,exception);

                    if (logging != MagickFalse && y <= 2)
                    {
                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                          ""  Writing row of non-gray pixels (4)"");

                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                          ""  ping_pixels[0]=%d,ping_pixels[1]=%d"",
                          (int)ping_pixels[0],(int)ping_pixels[1]);
                    }
                  }
                png_write_row(ping,ping_pixels);

                status=SetImageProgress(image,SaveImageTag,
                  (MagickOffsetType) (pass * image->rows + y),
                  num_passes * image->rows);

                if (status == MagickFalse)
                  break;
              }
            }
          }
        }
    }

  if (quantum_info != (QuantumInfo *) NULL)
    quantum_info=DestroyQuantumInfo(quantum_info);

  if (logging != MagickFalse)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""  Wrote PNG image data"");

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    Width: %.20g"",(double) ping_width);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    Height: %.20g"",(double) ping_height);

      if (mng_info->write_png_depth)
        {
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Defined png:bit-depth: %d"",mng_info->write_png_depth);
        }

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    PNG bit-depth written: %d"",ping_bit_depth);

      if (mng_info->write_png_colortype)
        {
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    Defined png:color-type: %d"",mng_info->write_png_colortype-1);
        }

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    PNG color-type written: %d"",ping_color_type);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    PNG Interlace method: %d"",ping_interlace_method);
    }
  /*
    Generate text chunks after IDAT.
  */
  if (ping_exclude_tEXt == MagickFalse || ping_exclude_zTXt == MagickFalse)
  {
    ResetImagePropertyIterator(image);
    property=GetNextImageProperty(image);
    while (property != (const char *) NULL)
    {
      png_textp
        text;

      value=GetImageProperty(image,property,exception);

      /* Don't write any ""png:"" or ""jpeg:"" properties; those are just for
       * ""identify"" or for passing through to another JPEG
       */
      if ((LocaleNCompare(property,""png:"",4) != 0 &&
           LocaleNCompare(property,""jpeg:"",5) != 0) &&


          /* Suppress density and units if we wrote a pHYs chunk */
          (ping_exclude_pHYs != MagickFalse      ||
          LocaleCompare(property,""density"") != 0 ||
          LocaleCompare(property,""units"") != 0) &&

          /* Suppress the IM-generated Date:create and Date:modify */
          (ping_exclude_date == MagickFalse      ||
          LocaleNCompare(property, ""Date:"",5) != 0))
        {
        if (value != (const char *) NULL)
          {

#if PNG_LIBPNG_VER >= 10400
            text=(png_textp) png_malloc(ping,
                 (png_alloc_size_t) sizeof(png_text));
#else
            text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));
#endif
            text[0].key=(char *) property;
            text[0].text=(char *) value;
            text[0].text_length=strlen(value);

            if (ping_exclude_tEXt != MagickFalse)
               text[0].compression=PNG_TEXT_COMPRESSION_zTXt;

            else if (ping_exclude_zTXt != MagickFalse)
               text[0].compression=PNG_TEXT_COMPRESSION_NONE;

            else
            {
               text[0].compression=image_info->compression == NoCompression ||
                 (image_info->compression == UndefinedCompression &&
                 text[0].text_length < 128) ? PNG_TEXT_COMPRESSION_NONE :
                 PNG_TEXT_COMPRESSION_zTXt ;
            }

            if (logging != MagickFalse)
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Setting up text chunk"");

                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""    keyword: '%s'"",text[0].key);
              }

            png_set_text(ping,ping_info,text,1);
            png_free(ping,text);
          }
        }
      property=GetNextImageProperty(image);
    }
  }

  /* write any PNG-chunk-e profiles */
  (void) Magick_png_write_chunk_from_profile(image,""PNG-chunk-e"",logging);

  /* write exIf profile */
  if (ping_have_eXIf != MagickFalse && ping_exclude_eXIf == MagickFalse)
    {
      char
        *name;

      ResetImageProfileIterator(image);

      for (name=GetNextImageProfile(image); name != (const char *) NULL; )
      {
        if (LocaleCompare(name,""exif"") == 0)
          {
            const StringInfo
              *profile;

            profile=GetImageProfile(image,name);

            if (profile != (StringInfo *) NULL)
              {
                png_uint_32
                  length;

                unsigned char
                  chunk[4],
                  *data;

               StringInfo
                 *ping_profile;

               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Have eXIf profile"");

               ping_profile=CloneStringInfo(profile);
               data=GetStringInfoDatum(ping_profile),
               length=(png_uint_32) GetStringInfoLength(ping_profile);

               PNGType(chunk,mng_eXIf);
               if (length < 7)
                 {
                   ping_profile=DestroyStringInfo(ping_profile);
                   break;  /* otherwise crashes */
                 }

               /* skip the ""Exif\0\0"" JFIF Exif Header ID */
               length -= 6;

               LogPNGChunk(logging,chunk,length);
               (void) WriteBlobMSBULong(image,length);
               (void) WriteBlob(image,4,chunk);
               (void) WriteBlob(image,length,data+6);
               (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),
                 data+6, (uInt) length));
               ping_profile=DestroyStringInfo(ping_profile);
               break;
             }
         }
       name=GetNextImageProfile(image);
     }
  }

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  Writing PNG end info"");

  png_write_end(ping,ping_info);

  if (mng_info->need_fram && (int) image->dispose == BackgroundDispose)
    {
      if (mng_info->page.x || mng_info->page.y ||
          (ping_width != mng_info->page.width) ||
          (ping_height != mng_info->page.height))
        {
          unsigned char
            chunk[32];

          /*
            Write FRAM 4 with clipping boundaries followed by FRAM 1.
          */
          (void) WriteBlobMSBULong(image,27L);  /* data length=27 */
          PNGType(chunk,mng_FRAM);
          LogPNGChunk(logging,mng_FRAM,27L);
          chunk[4]=4;
          chunk[5]=0;  /* frame name separator (no name) */
          chunk[6]=1;  /* flag for changing delay, for next frame only */
          chunk[7]=0;  /* flag for changing frame timeout */
          chunk[8]=1;  /* flag for changing frame clipping for next frame */
          chunk[9]=0;  /* flag for changing frame sync_id */
          PNGLong(chunk+10,(png_uint_32) (0L)); /* temporary 0 delay */
          chunk[14]=0; /* clipping boundaries delta type */
          PNGLong(chunk+15,(png_uint_32) (mng_info->page.x)); /* left cb */
          PNGLong(chunk+19,
             (png_uint_32) (mng_info->page.x + ping_width));
          PNGLong(chunk+23,(png_uint_32) (mng_info->page.y)); /* top cb */
          PNGLong(chunk+27,
             (png_uint_32) (mng_info->page.y + ping_height));
          (void) WriteBlob(image,31,chunk);
          (void) WriteBlobMSBULong(image,crc32(0,chunk,31));
          mng_info->old_framing_mode=4;
          mng_info->framing_mode=1;
        }

      else
        mng_info->framing_mode=3;
    }
  if (mng_info->write_mng && !mng_info->need_fram &&
      ((int) image->dispose == 3))
     png_error(ping, ""Cannot convert GIF with disposal method 3 to MNG-LC"");

  /*
    Free PNG resources.
  */

  png_destroy_write_struct(&ping,&ping_info);

  pixel_info=RelinquishVirtualMemory(pixel_info);

  if (ping_have_blob != MagickFalse)
     (void) CloseBlob(image);

  image_info=DestroyImageInfo(image_info);
  image=DestroyImage(image);

  /* Store bit depth actually written */
  s[0]=(char) ping_bit_depth;
  s[1]='\0';

  (void) SetImageProperty(IMimage,""png:bit-depth-written"",s,exception);

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  exit WriteOnePNGImage()"");

#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE
  UnlockSemaphoreInfo(ping_semaphore);
#endif

   /* }  for navigation to beginning of SETJMP-protected block. Revert to
    *    Throwing an Exception when an error occurs.
    */

  return(MagickTrue);
/*  End write one PNG image */

}
"
3528,181264,,Remote,Not required,Partial,CVE-2017-9608,https://www.cvedetails.com/cve/CVE-2017-9608/,CWE-476,Medium,,,,2017-12-27,4.3,"The dnxhd decoder in FFmpeg before 3.2.6, and 3.3.x before 3.3.3 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted mov file.",2018-01-17,DoS ,7,https://github.com/FFmpeg/FFmpeg/commit/31c1c0b46a7021802c3d1d18039fca30dba5a14e,31c1c0b46a7021802c3d1d18039fca30dba5a14e,"avcodec/dnxhd_parser: Do not return invalid value from dnxhd_find_frame_end() on error

Fixes: Null pointer dereference

Fixes: CVE-2017-9608
Found-by: Yihan Lian
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>
(cherry picked from commit 611b35627488a8d0763e75c25ee0875c5b7987dd)
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",5,libavcodec/dnxhd_parser.c,"{""sha"": ""2519cf23c3cc0fa2428bbf116f1fcf9aeb88c885"", ""filename"": ""libavcodec/dnxhd_parser.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 5, ""changes"": 12, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/31c1c0b46a7021802c3d1d18039fca30dba5a14e/libavcodec/dnxhd_parser.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/31c1c0b46a7021802c3d1d18039fca30dba5a14e/libavcodec/dnxhd_parser.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavcodec/dnxhd_parser.c?ref=31c1c0b46a7021802c3d1d18039fca30dba5a14e"", ""patch"": ""@@ -87,16 +87,18 @@ static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                 dctx->w = (state >> 32) & 0xFFFF;\n             } else if (dctx->cur_byte == 42) {\n                 int cid = (state >> 32) & 0xFFFFFFFF;\n+                int remaining;\n \n                 if (cid <= 0)\n                     continue;\n \n-                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n-                if (dctx->remaining <= 0) {\n-                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n-                    if (dctx->remaining <= 0)\n-                        return dctx->remaining;\n+                remaining = avpriv_dnxhd_get_frame_size(cid);\n+                if (remaining <= 0) {\n+                    remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n+                    if (remaining <= 0)\n+                        continue;\n                 }\n+                dctx->remaining = remaining;\n                 if (buf_size - i >= dctx->remaining && (!dctx->interlaced || dctx->cur_field)) {\n                     int remaining = dctx->remaining;\n ""}","static int dnxhd_find_frame_end(DNXHDParserContext *dctx,
                                const uint8_t *buf, int buf_size)
{
    ParseContext *pc = &dctx->pc;
    uint64_t state = pc->state64;
    int pic_found = pc->frame_start_found;
    int i = 0;
    int interlaced = dctx->interlaced;
    int cur_field = dctx->cur_field;

    if (!pic_found) {
        for (i = 0; i < buf_size; i++) {
            state = (state << 8) | buf[i];
            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {
                i++;
                pic_found = 1;
                interlaced = (state&2)>>1; /* byte following the 5-byte header prefix */
                cur_field = state&1;
                dctx->cur_byte = 0;
                dctx->remaining = 0;
                break;
            }
        }
    }

    if (pic_found && !dctx->remaining) {
        if (!buf_size) /* EOF considered as end of frame */
            return 0;
        for (; i < buf_size; i++) {
            dctx->cur_byte++;
            state = (state << 8) | buf[i];

            if (dctx->cur_byte == 24) {
                dctx->h = (state >> 32) & 0xFFFF;
            } else if (dctx->cur_byte == 26) {
                 dctx->w = (state >> 32) & 0xFFFF;
             } else if (dctx->cur_byte == 42) {
                 int cid = (state >> 32) & 0xFFFFFFFF;
                int remaining;
 
                 if (cid <= 0)
                     continue;
 
                remaining = avpriv_dnxhd_get_frame_size(cid);
                if (remaining <= 0) {
                    remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                    if (remaining <= 0)
                        continue;
                 }
                dctx->remaining = remaining;
                 if (buf_size - i >= dctx->remaining && (!dctx->interlaced || dctx->cur_field)) {
                     int remaining = dctx->remaining;
 
                    pc->frame_start_found = 0;
                    pc->state64 = -1;
                    dctx->interlaced = interlaced;
                    dctx->cur_field = 0;
                    dctx->cur_byte = 0;
                    dctx->remaining = 0;
                    return remaining;
                } else {
                    dctx->remaining -= buf_size;
                }
            }
        }
    } else if (pic_found) {
        if (dctx->remaining > buf_size) {
            dctx->remaining -= buf_size;
        } else {
            int remaining = dctx->remaining;

            pc->frame_start_found = 0;
            pc->state64 = -1;
            dctx->interlaced = interlaced;
            dctx->cur_field = 0;
            dctx->cur_byte = 0;
            dctx->remaining = 0;
            return remaining;
        }
    }
    pc->frame_start_found = pic_found;
    pc->state64 = state;
    dctx->interlaced = interlaced;
    dctx->cur_field = cur_field;
    return END_NOT_FOUND;
}
","static int dnxhd_find_frame_end(DNXHDParserContext *dctx,
                                const uint8_t *buf, int buf_size)
{
    ParseContext *pc = &dctx->pc;
    uint64_t state = pc->state64;
    int pic_found = pc->frame_start_found;
    int i = 0;
    int interlaced = dctx->interlaced;
    int cur_field = dctx->cur_field;

    if (!pic_found) {
        for (i = 0; i < buf_size; i++) {
            state = (state << 8) | buf[i];
            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {
                i++;
                pic_found = 1;
                interlaced = (state&2)>>1; /* byte following the 5-byte header prefix */
                cur_field = state&1;
                dctx->cur_byte = 0;
                dctx->remaining = 0;
                break;
            }
        }
    }

    if (pic_found && !dctx->remaining) {
        if (!buf_size) /* EOF considered as end of frame */
            return 0;
        for (; i < buf_size; i++) {
            dctx->cur_byte++;
            state = (state << 8) | buf[i];

            if (dctx->cur_byte == 24) {
                dctx->h = (state >> 32) & 0xFFFF;
            } else if (dctx->cur_byte == 26) {
                 dctx->w = (state >> 32) & 0xFFFF;
             } else if (dctx->cur_byte == 42) {
                 int cid = (state >> 32) & 0xFFFFFFFF;
 
                 if (cid <= 0)
                     continue;
 
                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
                if (dctx->remaining <= 0) {
                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                    if (dctx->remaining <= 0)
                        return dctx->remaining;
                 }
                 if (buf_size - i >= dctx->remaining && (!dctx->interlaced || dctx->cur_field)) {
                     int remaining = dctx->remaining;
 
                    pc->frame_start_found = 0;
                    pc->state64 = -1;
                    dctx->interlaced = interlaced;
                    dctx->cur_field = 0;
                    dctx->cur_byte = 0;
                    dctx->remaining = 0;
                    return remaining;
                } else {
                    dctx->remaining -= buf_size;
                }
            }
        }
    } else if (pic_found) {
        if (dctx->remaining > buf_size) {
            dctx->remaining -= buf_size;
        } else {
            int remaining = dctx->remaining;

            pc->frame_start_found = 0;
            pc->state64 = -1;
            dctx->interlaced = interlaced;
            dctx->cur_field = 0;
            dctx->cur_byte = 0;
            dctx->remaining = 0;
            return remaining;
        }
    }
    pc->frame_start_found = pic_found;
    pc->state64 = state;
    dctx->interlaced = interlaced;
    dctx->cur_field = cur_field;
    return END_NOT_FOUND;
}
",C,"                int remaining;
                remaining = avpriv_dnxhd_get_frame_size(cid);
                if (remaining <= 0) {
                    remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                    if (remaining <= 0)
                        continue;
                dctx->remaining = remaining;
","                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
                if (dctx->remaining <= 0) {
                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                    if (dctx->remaining <= 0)
                        return dctx->remaining;
",,"@@ -87,16 +87,18 @@ static int dnxhd_find_frame_end(DNXHDParserContext *dctx,
                 dctx->w = (state >> 32) & 0xFFFF;
             } else if (dctx->cur_byte == 42) {
                 int cid = (state >> 32) & 0xFFFFFFFF;
+                int remaining;
 
                 if (cid <= 0)
                     continue;
 
-                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
-                if (dctx->remaining <= 0) {
-                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
-                    if (dctx->remaining <= 0)
-                        return dctx->remaining;
+                remaining = avpriv_dnxhd_get_frame_size(cid);
+                if (remaining <= 0) {
+                    remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
+                    if (remaining <= 0)
+                        continue;
                 }
+                dctx->remaining = remaining;
                 if (buf_size - i >= dctx->remaining && (!dctx->interlaced || dctx->cur_field)) {
                     int remaining = dctx->remaining;
 ",FFmpeg,31c1c0b46a7021802c3d1d18039fca30dba5a14e,6d77a3ff3cd8360874d6f1787c482e09c5239511,1,"static int dnxhd_find_frame_end(DNXHDParserContext *dctx,
                                const uint8_t *buf, int buf_size)
{
    ParseContext *pc = &dctx->pc;
    uint64_t state = pc->state64;
    int pic_found = pc->frame_start_found;
    int i = 0;
    int interlaced = dctx->interlaced;
    int cur_field = dctx->cur_field;

    if (!pic_found) {
        for (i = 0; i < buf_size; i++) {
            state = (state << 8) | buf[i];
            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {
                i++;
                pic_found = 1;
                interlaced = (state&2)>>1; /* byte following the 5-byte header prefix */
                cur_field = state&1;
                dctx->cur_byte = 0;
                dctx->remaining = 0;
                break;
            }
        }
    }

    if (pic_found && !dctx->remaining) {
        if (!buf_size) /* EOF considered as end of frame */
            return 0;
        for (; i < buf_size; i++) {
            dctx->cur_byte++;
            state = (state << 8) | buf[i];

            if (dctx->cur_byte == 24) {
                dctx->h = (state >> 32) & 0xFFFF;
            } else if (dctx->cur_byte == 26) {
                 dctx->w = (state >> 32) & 0xFFFF;
             } else if (dctx->cur_byte == 42) {
                 int cid = (state >> 32) & 0xFFFFFFFF;
//fix_flaw_line_below:
//                int remaining;
 
                 if (cid <= 0)
                     continue;
 
//flaw_line_below:
                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
//flaw_line_below:
                if (dctx->remaining <= 0) {
//flaw_line_below:
                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
//flaw_line_below:
                    if (dctx->remaining <= 0)
//flaw_line_below:
                        return dctx->remaining;
//fix_flaw_line_below:
//                remaining = avpriv_dnxhd_get_frame_size(cid);
//fix_flaw_line_below:
//                if (remaining <= 0) {
//fix_flaw_line_below:
//                    remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
//fix_flaw_line_below:
//                    if (remaining <= 0)
//fix_flaw_line_below:
//                        continue;
                 }
//fix_flaw_line_below:
//                dctx->remaining = remaining;
                 if (buf_size - i >= dctx->remaining && (!dctx->interlaced || dctx->cur_field)) {
                     int remaining = dctx->remaining;
 
                    pc->frame_start_found = 0;
                    pc->state64 = -1;
                    dctx->interlaced = interlaced;
                    dctx->cur_field = 0;
                    dctx->cur_byte = 0;
                    dctx->remaining = 0;
                    return remaining;
                } else {
                    dctx->remaining -= buf_size;
                }
            }
        }
    } else if (pic_found) {
        if (dctx->remaining > buf_size) {
            dctx->remaining -= buf_size;
        } else {
            int remaining = dctx->remaining;

            pc->frame_start_found = 0;
            pc->state64 = -1;
            dctx->interlaced = interlaced;
            dctx->cur_field = 0;
            dctx->cur_byte = 0;
            dctx->remaining = 0;
            return remaining;
        }
    }
    pc->frame_start_found = pic_found;
    pc->state64 = state;
    dctx->interlaced = interlaced;
    dctx->cur_field = cur_field;
    return END_NOT_FOUND;
}
"
3541,181277,,Remote,Not required,Partial,CVE-2017-9250,https://www.cvedetails.com/cve/CVE-2017-9250/,CWE-476,Low,,,,2017-05-28,5.0,"The lexer_process_char_literal function in jerry-core/parser/js/js-lexer.c in JerryScript 1.0 does not skip memory allocation for empty strings, which allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via malformed JavaScript source code, related to the jmem_heap_free_block function.",2017-07-07,DoS ,5,https://github.com/zherczeg/jerryscript/commit/03a8c630f015f63268639d3ed3bf82cff6fa77d8,03a8c630f015f63268639d3ed3bf82cff6fa77d8,"Do not allocate memory for zero length strings.

Fixes #1821.

JerryScript-DCO-1.0-Signed-off-by: Zoltan Herczeg zherczeg.u-szeged@partner.samsung.com",0,jerry-core/parser/js/js-lexer.c,"{""sha"": ""f7bd5b95289a4399317a5ce324082acc80b611ad"", ""filename"": ""jerry-core/parser/js/js-lexer.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/zherczeg/jerryscript/blob/03a8c630f015f63268639d3ed3bf82cff6fa77d8/jerry-core/parser/js/js-lexer.c"", ""raw_url"": ""https://github.com/zherczeg/jerryscript/raw/03a8c630f015f63268639d3ed3bf82cff6fa77d8/jerry-core/parser/js/js-lexer.c"", ""contents_url"": ""https://api.github.com/repos/zherczeg/jerryscript/contents/jerry-core/parser/js/js-lexer.c?ref=03a8c630f015f63268639d3ed3bf82cff6fa77d8"", ""patch"": ""@@ -1197,6 +1197,11 @@ lexer_process_char_literal (parser_context_t *context_p, /**< context */\n     parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);\n   }\n \n+  if (length == 0)\n+  {\n+    has_escape = false;\n+  }\n+\n   literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);\n   literal_p->prop.length = (uint16_t) length;\n   literal_p->type = literal_type;""}<_**next**_>{""sha"": ""7c08601680306ebf5376a3e9dc303406f2cffebb"", ""filename"": ""tests/jerry/regression-test-issue-1833.js"", ""status"": ""added"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/zherczeg/jerryscript/blob/03a8c630f015f63268639d3ed3bf82cff6fa77d8/tests/jerry/regression-test-issue-1833.js"", ""raw_url"": ""https://github.com/zherczeg/jerryscript/raw/03a8c630f015f63268639d3ed3bf82cff6fa77d8/tests/jerry/regression-test-issue-1833.js"", ""contents_url"": ""https://api.github.com/repos/zherczeg/jerryscript/contents/tests/jerry/regression-test-issue-1833.js?ref=03a8c630f015f63268639d3ed3bf82cff6fa77d8"", ""patch"": ""@@ -0,0 +1,16 @@\n+// Copyright JS Foundation and other contributors, http://js.foundation\n+//\n+// Licensed under the Apache License, Version 2.0 (the \""License\"");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \""AS IS\"" BASIS\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+'\\\n+'""}","lexer_process_char_literal (parser_context_t *context_p, /**< context */
                            const uint8_t *char_p, /**< characters */
                            size_t length, /**< length of string */
                            uint8_t literal_type, /**< final literal type */
                            bool has_escape) /**< has escape sequences */
{
  parser_list_iterator_t literal_iterator;
  lexer_literal_t *literal_p;
  uint32_t literal_index = 0;

  JERRY_ASSERT (literal_type == LEXER_IDENT_LITERAL
                || literal_type == LEXER_STRING_LITERAL);

  JERRY_ASSERT (literal_type != LEXER_IDENT_LITERAL || length <= PARSER_MAXIMUM_IDENT_LENGTH);
  JERRY_ASSERT (literal_type != LEXER_STRING_LITERAL || length <= PARSER_MAXIMUM_STRING_LENGTH);

  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);

  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
  {
    if (literal_p->type == literal_type
        && literal_p->prop.length == length
        && memcmp (literal_p->u.char_p, char_p, length) == 0)
    {
      context_p->lit_object.literal_p = literal_p;
      context_p->lit_object.index = (uint16_t) literal_index;
      literal_p->status_flags = (uint8_t) (literal_p->status_flags & ~LEXER_FLAG_UNUSED_IDENT);
      return;
    }

    literal_index++;
  }

  JERRY_ASSERT (literal_index == context_p->literal_count);

  if (literal_index >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)
  {
     parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);
   }
 
  if (length == 0)
  {
    has_escape = false;
  }

   literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);
   literal_p->prop.length = (uint16_t) length;
   literal_p->type = literal_type;
  literal_p->status_flags = has_escape ? 0 : LEXER_FLAG_SOURCE_PTR;

  if (has_escape)
  {
    literal_p->u.char_p = (uint8_t *) jmem_heap_alloc_block (length);
    memcpy ((uint8_t *) literal_p->u.char_p, char_p, length);
  }
  else
  {
    literal_p->u.char_p = char_p;
  }

  context_p->lit_object.literal_p = literal_p;
  context_p->lit_object.index = (uint16_t) literal_index;
  context_p->literal_count++;
} /* lexer_process_char_literal */
","lexer_process_char_literal (parser_context_t *context_p, /**< context */
                            const uint8_t *char_p, /**< characters */
                            size_t length, /**< length of string */
                            uint8_t literal_type, /**< final literal type */
                            bool has_escape) /**< has escape sequences */
{
  parser_list_iterator_t literal_iterator;
  lexer_literal_t *literal_p;
  uint32_t literal_index = 0;

  JERRY_ASSERT (literal_type == LEXER_IDENT_LITERAL
                || literal_type == LEXER_STRING_LITERAL);

  JERRY_ASSERT (literal_type != LEXER_IDENT_LITERAL || length <= PARSER_MAXIMUM_IDENT_LENGTH);
  JERRY_ASSERT (literal_type != LEXER_STRING_LITERAL || length <= PARSER_MAXIMUM_STRING_LENGTH);

  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);

  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
  {
    if (literal_p->type == literal_type
        && literal_p->prop.length == length
        && memcmp (literal_p->u.char_p, char_p, length) == 0)
    {
      context_p->lit_object.literal_p = literal_p;
      context_p->lit_object.index = (uint16_t) literal_index;
      literal_p->status_flags = (uint8_t) (literal_p->status_flags & ~LEXER_FLAG_UNUSED_IDENT);
      return;
    }

    literal_index++;
  }

  JERRY_ASSERT (literal_index == context_p->literal_count);

  if (literal_index >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)
  {
     parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);
   }
 
   literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);
   literal_p->prop.length = (uint16_t) length;
   literal_p->type = literal_type;
  literal_p->status_flags = has_escape ? 0 : LEXER_FLAG_SOURCE_PTR;

  if (has_escape)
  {
    literal_p->u.char_p = (uint8_t *) jmem_heap_alloc_block (length);
    memcpy ((uint8_t *) literal_p->u.char_p, char_p, length);
  }
  else
  {
    literal_p->u.char_p = char_p;
  }

  context_p->lit_object.literal_p = literal_p;
  context_p->lit_object.index = (uint16_t) literal_index;
  context_p->literal_count++;
} /* lexer_process_char_literal */
",C,"  if (length == 0)
  {
    has_escape = false;
  }

",,,"@@ -1197,6 +1197,11 @@ lexer_process_char_literal (parser_context_t *context_p, /**< context */
     parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);
   }
 
+  if (length == 0)
+  {
+    has_escape = false;
+  }
+
   literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);
   literal_p->prop.length = (uint16_t) length;
   literal_p->type = literal_type;",jerryscript,03a8c630f015f63268639d3ed3bf82cff6fa77d8,eb2af2d2a6d46bc45932e7aaeaf25442df6a856a,1,"lexer_process_char_literal (parser_context_t *context_p, /**< context */
                            const uint8_t *char_p, /**< characters */
                            size_t length, /**< length of string */
                            uint8_t literal_type, /**< final literal type */
                            bool has_escape) /**< has escape sequences */
{
  parser_list_iterator_t literal_iterator;
  lexer_literal_t *literal_p;
  uint32_t literal_index = 0;

  JERRY_ASSERT (literal_type == LEXER_IDENT_LITERAL
                || literal_type == LEXER_STRING_LITERAL);

  JERRY_ASSERT (literal_type != LEXER_IDENT_LITERAL || length <= PARSER_MAXIMUM_IDENT_LENGTH);
  JERRY_ASSERT (literal_type != LEXER_STRING_LITERAL || length <= PARSER_MAXIMUM_STRING_LENGTH);

  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);

  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
  {
    if (literal_p->type == literal_type
        && literal_p->prop.length == length
        && memcmp (literal_p->u.char_p, char_p, length) == 0)
    {
      context_p->lit_object.literal_p = literal_p;
      context_p->lit_object.index = (uint16_t) literal_index;
      literal_p->status_flags = (uint8_t) (literal_p->status_flags & ~LEXER_FLAG_UNUSED_IDENT);
      return;
    }

    literal_index++;
  }

  JERRY_ASSERT (literal_index == context_p->literal_count);

  if (literal_index >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)
  {
     parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);
   }
 
//fix_flaw_line_below:
//  if (length == 0)
//fix_flaw_line_below:
//  {
//fix_flaw_line_below:
//    has_escape = false;
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
   literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);
   literal_p->prop.length = (uint16_t) length;
   literal_p->type = literal_type;
  literal_p->status_flags = has_escape ? 0 : LEXER_FLAG_SOURCE_PTR;

  if (has_escape)
  {
    literal_p->u.char_p = (uint8_t *) jmem_heap_alloc_block (length);
    memcpy ((uint8_t *) literal_p->u.char_p, char_p, length);
  }
  else
  {
    literal_p->u.char_p = char_p;
  }

  context_p->lit_object.literal_p = literal_p;
  context_p->lit_object.index = (uint16_t) literal_index;
  context_p->literal_count++;
} /* lexer_process_char_literal */
"
3543,181279,,Remote,Not required,Partial,CVE-2017-9229,https://www.cvedetails.com/cve/CVE-2017-9229/,CWE-476,Low,,,,2017-05-24,5.0,"An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A SIGSEGV occurs in left_adjust_char_head() during regular expression compilation. Invalid handling of reg->dmax in forward_search_range() could result in an invalid pointer dereference, normally as an immediate denial-of-service condition.",2018-05-03,,17,https://github.com/kkos/oniguruma/commit/b690371bbf97794b4a1d3f295d4fb9a8b05d402d,b690371bbf97794b4a1d3f295d4fb9a8b05d402d,fix #59 : access to invalid address by reg->dmax value,10,src/regexec.c,"{""sha"": ""c0626efd43b6ed410bb8dcdc86fc4e477b60c74f"", ""filename"": ""src/regexec.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 10, ""changes"": 27, ""blob_url"": ""https://github.com/kkos/oniguruma/blob/b690371bbf97794b4a1d3f295d4fb9a8b05d402d/src/regexec.c"", ""raw_url"": ""https://github.com/kkos/oniguruma/raw/b690371bbf97794b4a1d3f295d4fb9a8b05d402d/src/regexec.c"", ""contents_url"": ""https://api.github.com/repos/kkos/oniguruma/contents/src/regexec.c?ref=b690371bbf97794b4a1d3f295d4fb9a8b05d402d"", ""patch"": ""@@ -3235,18 +3235,25 @@ forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,\n     }\n     else {\n       if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n-        *low = p - reg->dmax;\n-        if (*low > s) {\n-          *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n-                                          *low, (const UChar** )low_prev);\n-          if (low_prev && IS_NULL(*low_prev))\n-            *low_prev = onigenc_get_prev_char_head(reg->enc,\n-                                                   (pprev ? pprev : s), *low);\n+        if (p - str < reg->dmax) {\n+          *low = (UChar* )str;\n+          if (low_prev)\n+            *low_prev = onigenc_get_prev_char_head(reg->enc, str, *low);\n         }\n         else {\n-          if (low_prev)\n-            *low_prev = onigenc_get_prev_char_head(reg->enc,\n-                                                   (pprev ? pprev : str), *low);\n+          *low = p - reg->dmax;\n+          if (*low > s) {\n+            *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n+                                                 *low, (const UChar** )low_prev);\n+            if (low_prev && IS_NULL(*low_prev))\n+              *low_prev = onigenc_get_prev_char_head(reg->enc,\n+                                                     (pprev ? pprev : s), *low);\n+          }\n+          else {\n+            if (low_prev)\n+              *low_prev = onigenc_get_prev_char_head(reg->enc,\n+                                                     (pprev ? pprev : str), *low);\n+          }\n         }\n       }\n     }""}","forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,
		     UChar* range, UChar** low, UChar** high, UChar** low_prev)
{
  UChar *p, *pprev = (UChar* )NULL;

#ifdef ONIG_DEBUG_SEARCH
  fprintf(stderr, ""forward_search_range: str: %d, end: %d, s: %d, range: %d\n"",
	  (int )str, (int )end, (int )s, (int )range);
#endif

  p = s;
  if (reg->dmin > 0) {
    if (ONIGENC_IS_SINGLEBYTE(reg->enc)) {
      p += reg->dmin;
    }
    else {
      UChar *q = p + reg->dmin;

      if (q >= end) return 0; /* fail */
      while (p < q) p += enclen(reg->enc, p);
    }
  }

 retry:
  switch (reg->optimize) {
  case ONIG_OPTIMIZE_EXACT:
    p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range);
    break;
  case ONIG_OPTIMIZE_EXACT_IC:
    p = slow_search_ic(reg->enc, reg->case_fold_flag,
                       reg->exact, reg->exact_end, p, end, range);
    break;

  case ONIG_OPTIMIZE_EXACT_BM:
    p = bm_search(reg, reg->exact, reg->exact_end, p, end, range);
    break;

  case ONIG_OPTIMIZE_EXACT_BM_NOT_REV:
    p = bm_search_notrev(reg, reg->exact, reg->exact_end, p, end, range);
    break;

  case ONIG_OPTIMIZE_MAP:
    p = map_search(reg->enc, reg->map, p, range);
    break;
  }

  if (p && p < range) {
    if (p - reg->dmin < s) {
    retry_gate:
      pprev = p;
      p += enclen(reg->enc, p);
      goto retry;
    }

    if (reg->sub_anchor) {
      UChar* prev;

      switch (reg->sub_anchor) {
      case ANCHOR_BEGIN_LINE:
        if (!ON_STR_BEGIN(p)) {
          prev = onigenc_get_prev_char_head(reg->enc,
                                            (pprev ? pprev : str), p);
          if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))
            goto retry_gate;
        }
        break;

      case ANCHOR_END_LINE:
        if (ON_STR_END(p)) {
#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE
          prev = (UChar* )onigenc_get_prev_char_head(reg->enc,
                                                     (pprev ? pprev : str), p);
          if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))
            goto retry_gate;
#endif
        }
        else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)
#ifdef USE_CRNL_AS_LINE_TERMINATOR
                 && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)
#endif
                 )
          goto retry_gate;
        break;
      }
    }

    if (reg->dmax == 0) {
      *low = p;
      if (low_prev) {
        if (*low > s)
          *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);
        else
          *low_prev = onigenc_get_prev_char_head(reg->enc,
                                                 (pprev ? pprev : str), p);
      }
     }
     else {
       if (reg->dmax != ONIG_INFINITE_DISTANCE) {
        if (p - str < reg->dmax) {
          *low = (UChar* )str;
          if (low_prev)
            *low_prev = onigenc_get_prev_char_head(reg->enc, str, *low);
         }
         else {
          *low = p - reg->dmax;
          if (*low > s) {
            *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,
                                                 *low, (const UChar** )low_prev);
            if (low_prev && IS_NULL(*low_prev))
              *low_prev = onigenc_get_prev_char_head(reg->enc,
                                                     (pprev ? pprev : s), *low);
          }
          else {
            if (low_prev)
              *low_prev = onigenc_get_prev_char_head(reg->enc,
                                                     (pprev ? pprev : str), *low);
          }
         }
       }
     }
    /* no needs to adjust *high, *high is used as range check only */
    *high = p - reg->dmin;

#ifdef ONIG_DEBUG_SEARCH
    fprintf(stderr,
    ""forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\n"",
	    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);
#endif
    return 1; /* success */
  }

  return 0; /* fail */
}
","forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,
		     UChar* range, UChar** low, UChar** high, UChar** low_prev)
{
  UChar *p, *pprev = (UChar* )NULL;

#ifdef ONIG_DEBUG_SEARCH
  fprintf(stderr, ""forward_search_range: str: %d, end: %d, s: %d, range: %d\n"",
	  (int )str, (int )end, (int )s, (int )range);
#endif

  p = s;
  if (reg->dmin > 0) {
    if (ONIGENC_IS_SINGLEBYTE(reg->enc)) {
      p += reg->dmin;
    }
    else {
      UChar *q = p + reg->dmin;

      if (q >= end) return 0; /* fail */
      while (p < q) p += enclen(reg->enc, p);
    }
  }

 retry:
  switch (reg->optimize) {
  case ONIG_OPTIMIZE_EXACT:
    p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range);
    break;
  case ONIG_OPTIMIZE_EXACT_IC:
    p = slow_search_ic(reg->enc, reg->case_fold_flag,
                       reg->exact, reg->exact_end, p, end, range);
    break;

  case ONIG_OPTIMIZE_EXACT_BM:
    p = bm_search(reg, reg->exact, reg->exact_end, p, end, range);
    break;

  case ONIG_OPTIMIZE_EXACT_BM_NOT_REV:
    p = bm_search_notrev(reg, reg->exact, reg->exact_end, p, end, range);
    break;

  case ONIG_OPTIMIZE_MAP:
    p = map_search(reg->enc, reg->map, p, range);
    break;
  }

  if (p && p < range) {
    if (p - reg->dmin < s) {
    retry_gate:
      pprev = p;
      p += enclen(reg->enc, p);
      goto retry;
    }

    if (reg->sub_anchor) {
      UChar* prev;

      switch (reg->sub_anchor) {
      case ANCHOR_BEGIN_LINE:
        if (!ON_STR_BEGIN(p)) {
          prev = onigenc_get_prev_char_head(reg->enc,
                                            (pprev ? pprev : str), p);
          if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))
            goto retry_gate;
        }
        break;

      case ANCHOR_END_LINE:
        if (ON_STR_END(p)) {
#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE
          prev = (UChar* )onigenc_get_prev_char_head(reg->enc,
                                                     (pprev ? pprev : str), p);
          if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))
            goto retry_gate;
#endif
        }
        else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)
#ifdef USE_CRNL_AS_LINE_TERMINATOR
                 && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)
#endif
                 )
          goto retry_gate;
        break;
      }
    }

    if (reg->dmax == 0) {
      *low = p;
      if (low_prev) {
        if (*low > s)
          *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);
        else
          *low_prev = onigenc_get_prev_char_head(reg->enc,
                                                 (pprev ? pprev : str), p);
      }
     }
     else {
       if (reg->dmax != ONIG_INFINITE_DISTANCE) {
        *low = p - reg->dmax;
        if (*low > s) {
          *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,
                                          *low, (const UChar** )low_prev);
          if (low_prev && IS_NULL(*low_prev))
            *low_prev = onigenc_get_prev_char_head(reg->enc,
                                                   (pprev ? pprev : s), *low);
         }
         else {
          if (low_prev)
            *low_prev = onigenc_get_prev_char_head(reg->enc,
                                                   (pprev ? pprev : str), *low);
         }
       }
     }
    /* no needs to adjust *high, *high is used as range check only */
    *high = p - reg->dmin;

#ifdef ONIG_DEBUG_SEARCH
    fprintf(stderr,
    ""forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\n"",
	    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);
#endif
    return 1; /* success */
  }

  return 0; /* fail */
}
",C,"        if (p - str < reg->dmax) {
          *low = (UChar* )str;
          if (low_prev)
            *low_prev = onigenc_get_prev_char_head(reg->enc, str, *low);
          *low = p - reg->dmax;
          if (*low > s) {
            *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,
                                                 *low, (const UChar** )low_prev);
            if (low_prev && IS_NULL(*low_prev))
              *low_prev = onigenc_get_prev_char_head(reg->enc,
                                                     (pprev ? pprev : s), *low);
          }
          else {
            if (low_prev)
              *low_prev = onigenc_get_prev_char_head(reg->enc,
                                                     (pprev ? pprev : str), *low);
          }
","        *low = p - reg->dmax;
        if (*low > s) {
          *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,
                                          *low, (const UChar** )low_prev);
          if (low_prev && IS_NULL(*low_prev))
            *low_prev = onigenc_get_prev_char_head(reg->enc,
                                                   (pprev ? pprev : s), *low);
          if (low_prev)
            *low_prev = onigenc_get_prev_char_head(reg->enc,
                                                   (pprev ? pprev : str), *low);
",,"@@ -3235,18 +3235,25 @@ forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,
     }
     else {
       if (reg->dmax != ONIG_INFINITE_DISTANCE) {
-        *low = p - reg->dmax;
-        if (*low > s) {
-          *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,
-                                          *low, (const UChar** )low_prev);
-          if (low_prev && IS_NULL(*low_prev))
-            *low_prev = onigenc_get_prev_char_head(reg->enc,
-                                                   (pprev ? pprev : s), *low);
+        if (p - str < reg->dmax) {
+          *low = (UChar* )str;
+          if (low_prev)
+            *low_prev = onigenc_get_prev_char_head(reg->enc, str, *low);
         }
         else {
-          if (low_prev)
-            *low_prev = onigenc_get_prev_char_head(reg->enc,
-                                                   (pprev ? pprev : str), *low);
+          *low = p - reg->dmax;
+          if (*low > s) {
+            *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,
+                                                 *low, (const UChar** )low_prev);
+            if (low_prev && IS_NULL(*low_prev))
+              *low_prev = onigenc_get_prev_char_head(reg->enc,
+                                                     (pprev ? pprev : s), *low);
+          }
+          else {
+            if (low_prev)
+              *low_prev = onigenc_get_prev_char_head(reg->enc,
+                                                     (pprev ? pprev : str), *low);
+          }
         }
       }
     }",oniguruma,b690371bbf97794b4a1d3f295d4fb9a8b05d402d,bfdc384eae73e87b3443d016302b73d9def8071f,1,"forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,
		     UChar* range, UChar** low, UChar** high, UChar** low_prev)
{
  UChar *p, *pprev = (UChar* )NULL;

#ifdef ONIG_DEBUG_SEARCH
  fprintf(stderr, ""forward_search_range: str: %d, end: %d, s: %d, range: %d\n"",
	  (int )str, (int )end, (int )s, (int )range);
#endif

  p = s;
  if (reg->dmin > 0) {
    if (ONIGENC_IS_SINGLEBYTE(reg->enc)) {
      p += reg->dmin;
    }
    else {
      UChar *q = p + reg->dmin;

      if (q >= end) return 0; /* fail */
      while (p < q) p += enclen(reg->enc, p);
    }
  }

 retry:
  switch (reg->optimize) {
  case ONIG_OPTIMIZE_EXACT:
    p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range);
    break;
  case ONIG_OPTIMIZE_EXACT_IC:
    p = slow_search_ic(reg->enc, reg->case_fold_flag,
                       reg->exact, reg->exact_end, p, end, range);
    break;

  case ONIG_OPTIMIZE_EXACT_BM:
    p = bm_search(reg, reg->exact, reg->exact_end, p, end, range);
    break;

  case ONIG_OPTIMIZE_EXACT_BM_NOT_REV:
    p = bm_search_notrev(reg, reg->exact, reg->exact_end, p, end, range);
    break;

  case ONIG_OPTIMIZE_MAP:
    p = map_search(reg->enc, reg->map, p, range);
    break;
  }

  if (p && p < range) {
    if (p - reg->dmin < s) {
    retry_gate:
      pprev = p;
      p += enclen(reg->enc, p);
      goto retry;
    }

    if (reg->sub_anchor) {
      UChar* prev;

      switch (reg->sub_anchor) {
      case ANCHOR_BEGIN_LINE:
        if (!ON_STR_BEGIN(p)) {
          prev = onigenc_get_prev_char_head(reg->enc,
                                            (pprev ? pprev : str), p);
          if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))
            goto retry_gate;
        }
        break;

      case ANCHOR_END_LINE:
        if (ON_STR_END(p)) {
#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE
          prev = (UChar* )onigenc_get_prev_char_head(reg->enc,
                                                     (pprev ? pprev : str), p);
          if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))
            goto retry_gate;
#endif
        }
        else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)
#ifdef USE_CRNL_AS_LINE_TERMINATOR
                 && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)
#endif
                 )
          goto retry_gate;
        break;
      }
    }

    if (reg->dmax == 0) {
      *low = p;
      if (low_prev) {
        if (*low > s)
          *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);
        else
          *low_prev = onigenc_get_prev_char_head(reg->enc,
                                                 (pprev ? pprev : str), p);
      }
     }
     else {
       if (reg->dmax != ONIG_INFINITE_DISTANCE) {
//flaw_line_below:
        *low = p - reg->dmax;
//flaw_line_below:
        if (*low > s) {
//flaw_line_below:
          *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,
//flaw_line_below:
                                          *low, (const UChar** )low_prev);
//flaw_line_below:
          if (low_prev && IS_NULL(*low_prev))
//flaw_line_below:
            *low_prev = onigenc_get_prev_char_head(reg->enc,
//flaw_line_below:
                                                   (pprev ? pprev : s), *low);
//fix_flaw_line_below:
//        if (p - str < reg->dmax) {
//fix_flaw_line_below:
//          *low = (UChar* )str;
//fix_flaw_line_below:
//          if (low_prev)
//fix_flaw_line_below:
//            *low_prev = onigenc_get_prev_char_head(reg->enc, str, *low);
         }
         else {
//flaw_line_below:
          if (low_prev)
//flaw_line_below:
            *low_prev = onigenc_get_prev_char_head(reg->enc,
//flaw_line_below:
                                                   (pprev ? pprev : str), *low);
//fix_flaw_line_below:
//          *low = p - reg->dmax;
//fix_flaw_line_below:
//          if (*low > s) {
//fix_flaw_line_below:
//            *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,
//fix_flaw_line_below:
//                                                 *low, (const UChar** )low_prev);
//fix_flaw_line_below:
//            if (low_prev && IS_NULL(*low_prev))
//fix_flaw_line_below:
//              *low_prev = onigenc_get_prev_char_head(reg->enc,
//fix_flaw_line_below:
//                                                     (pprev ? pprev : s), *low);
//fix_flaw_line_below:
//          }
//fix_flaw_line_below:
//          else {
//fix_flaw_line_below:
//            if (low_prev)
//fix_flaw_line_below:
//              *low_prev = onigenc_get_prev_char_head(reg->enc,
//fix_flaw_line_below:
//                                                     (pprev ? pprev : str), *low);
//fix_flaw_line_below:
//          }
         }
       }
     }
    /* no needs to adjust *high, *high is used as range check only */
    *high = p - reg->dmin;

#ifdef ONIG_DEBUG_SEARCH
    fprintf(stderr,
    ""forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\n"",
	    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);
#endif
    return 1; /* success */
  }

  return 0; /* fail */
}
"
3548,181284,,Local,Not required,Complete,CVE-2017-9211,https://www.cvedetails.com/cve/CVE-2017-9211/,CWE-476,Low,,,,2017-05-23,4.9,"The crypto_skcipher_init_tfm function in crypto/skcipher.c in the Linux kernel through 4.11.2 relies on a setkey function that lacks a key-size check, which allows local users to cause a denial of service (NULL pointer dereference) via a crafted application.",2017-06-08,DoS ,1,https://github.com/torvalds/linux/commit/9933e113c2e87a9f46a40fde8dafbf801dca1ab9,9933e113c2e87a9f46a40fde8dafbf801dca1ab9,"crypto: skcipher - Add missing API setkey checks

The API setkey checks for key sizes and alignment went AWOL during the
skcipher conversion.  This patch restores them.

Cc: <stable@vger.kernel.org>
Fixes: 4e6c3df4d729 (""crypto: skcipher - Add low-level skcipher..."")
Reported-by: Baozeng <sploving1@gmail.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",1,crypto/skcipher.c,"{""sha"": ""4faa0fd53b0c120d39022ad726dbbe2c74f787bd"", ""filename"": ""crypto/skcipher.c"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 1, ""changes"": 40, ""blob_url"": ""https://github.com/torvalds/linux/blob/9933e113c2e87a9f46a40fde8dafbf801dca1ab9/crypto/skcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9933e113c2e87a9f46a40fde8dafbf801dca1ab9/crypto/skcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/skcipher.c?ref=9933e113c2e87a9f46a40fde8dafbf801dca1ab9"", ""patch"": ""@@ -764,6 +764,44 @@ static int crypto_init_skcipher_ops_ablkcipher(struct crypto_tfm *tfm)\n \treturn 0;\n }\n \n+static int skcipher_setkey_unaligned(struct crypto_skcipher *tfm,\n+\t\t\t\t     const u8 *key, unsigned int keylen)\n+{\n+\tunsigned long alignmask = crypto_skcipher_alignmask(tfm);\n+\tstruct skcipher_alg *cipher = crypto_skcipher_alg(tfm);\n+\tu8 *buffer, *alignbuffer;\n+\tunsigned long absize;\n+\tint ret;\n+\n+\tabsize = keylen + alignmask;\n+\tbuffer = kmalloc(absize, GFP_ATOMIC);\n+\tif (!buffer)\n+\t\treturn -ENOMEM;\n+\n+\talignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);\n+\tmemcpy(alignbuffer, key, keylen);\n+\tret = cipher->setkey(tfm, alignbuffer, keylen);\n+\tkzfree(buffer);\n+\treturn ret;\n+}\n+\n+static int skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,\n+\t\t\t   unsigned int keylen)\n+{\n+\tstruct skcipher_alg *cipher = crypto_skcipher_alg(tfm);\n+\tunsigned long alignmask = crypto_skcipher_alignmask(tfm);\n+\n+\tif (keylen < cipher->min_keysize || keylen > cipher->max_keysize) {\n+\t\tcrypto_skcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tif ((unsigned long)key & alignmask)\n+\t\treturn skcipher_setkey_unaligned(tfm, key, keylen);\n+\n+\treturn cipher->setkey(tfm, key, keylen);\n+}\n+\n static void crypto_skcipher_exit_tfm(struct crypto_tfm *tfm)\n {\n \tstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\n@@ -784,7 +822,7 @@ static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)\n \t    tfm->__crt_alg->cra_type == &crypto_givcipher_type)\n \t\treturn crypto_init_skcipher_ops_ablkcipher(tfm);\n \n-\tskcipher->setkey = alg->setkey;\n+\tskcipher->setkey = skcipher_setkey;\n \tskcipher->encrypt = alg->encrypt;\n \tskcipher->decrypt = alg->decrypt;\n \tskcipher->ivsize = alg->ivsize;""}","static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)
{
	struct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);
	struct skcipher_alg *alg = crypto_skcipher_alg(skcipher);

	if (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)
		return crypto_init_skcipher_ops_blkcipher(tfm);

	if (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type ||
 	    tfm->__crt_alg->cra_type == &crypto_givcipher_type)
 		return crypto_init_skcipher_ops_ablkcipher(tfm);
 
	skcipher->setkey = skcipher_setkey;
 	skcipher->encrypt = alg->encrypt;
 	skcipher->decrypt = alg->decrypt;
 	skcipher->ivsize = alg->ivsize;
	skcipher->keysize = alg->max_keysize;

	if (alg->exit)
		skcipher->base.exit = crypto_skcipher_exit_tfm;

	if (alg->init)
		return alg->init(skcipher);

	return 0;
}
","static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)
{
	struct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);
	struct skcipher_alg *alg = crypto_skcipher_alg(skcipher);

	if (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)
		return crypto_init_skcipher_ops_blkcipher(tfm);

	if (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type ||
 	    tfm->__crt_alg->cra_type == &crypto_givcipher_type)
 		return crypto_init_skcipher_ops_ablkcipher(tfm);
 
	skcipher->setkey = alg->setkey;
 	skcipher->encrypt = alg->encrypt;
 	skcipher->decrypt = alg->decrypt;
 	skcipher->ivsize = alg->ivsize;
	skcipher->keysize = alg->max_keysize;

	if (alg->exit)
		skcipher->base.exit = crypto_skcipher_exit_tfm;

	if (alg->init)
		return alg->init(skcipher);

	return 0;
}
",C,"	skcipher->setkey = skcipher_setkey;
","	skcipher->setkey = alg->setkey;
",,"@@ -764,6 +764,44 @@ static int crypto_init_skcipher_ops_ablkcipher(struct crypto_tfm *tfm)
 	return 0;
 }
 
+static int skcipher_setkey_unaligned(struct crypto_skcipher *tfm,
+				     const u8 *key, unsigned int keylen)
+{
+	unsigned long alignmask = crypto_skcipher_alignmask(tfm);
+	struct skcipher_alg *cipher = crypto_skcipher_alg(tfm);
+	u8 *buffer, *alignbuffer;
+	unsigned long absize;
+	int ret;
+
+	absize = keylen + alignmask;
+	buffer = kmalloc(absize, GFP_ATOMIC);
+	if (!buffer)
+		return -ENOMEM;
+
+	alignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);
+	memcpy(alignbuffer, key, keylen);
+	ret = cipher->setkey(tfm, alignbuffer, keylen);
+	kzfree(buffer);
+	return ret;
+}
+
+static int skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,
+			   unsigned int keylen)
+{
+	struct skcipher_alg *cipher = crypto_skcipher_alg(tfm);
+	unsigned long alignmask = crypto_skcipher_alignmask(tfm);
+
+	if (keylen < cipher->min_keysize || keylen > cipher->max_keysize) {
+		crypto_skcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
+		return -EINVAL;
+	}
+
+	if ((unsigned long)key & alignmask)
+		return skcipher_setkey_unaligned(tfm, key, keylen);
+
+	return cipher->setkey(tfm, key, keylen);
+}
+
 static void crypto_skcipher_exit_tfm(struct crypto_tfm *tfm)
 {
 	struct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);
@@ -784,7 +822,7 @@ static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)
 	    tfm->__crt_alg->cra_type == &crypto_givcipher_type)
 		return crypto_init_skcipher_ops_ablkcipher(tfm);
 
-	skcipher->setkey = alg->setkey;
+	skcipher->setkey = skcipher_setkey;
 	skcipher->encrypt = alg->encrypt;
 	skcipher->decrypt = alg->decrypt;
 	skcipher->ivsize = alg->ivsize;",linux,9933e113c2e87a9f46a40fde8dafbf801dca1ab9,2ea659a9ef488125eb46da6eb571de5eae5c43f6,1,"static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)
{
	struct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);
	struct skcipher_alg *alg = crypto_skcipher_alg(skcipher);

	if (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)
		return crypto_init_skcipher_ops_blkcipher(tfm);

	if (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type ||
 	    tfm->__crt_alg->cra_type == &crypto_givcipher_type)
 		return crypto_init_skcipher_ops_ablkcipher(tfm);
 
//flaw_line_below:
	skcipher->setkey = alg->setkey;
//fix_flaw_line_below:
//	skcipher->setkey = skcipher_setkey;
 	skcipher->encrypt = alg->encrypt;
 	skcipher->decrypt = alg->decrypt;
 	skcipher->ivsize = alg->ivsize;
	skcipher->keysize = alg->max_keysize;

	if (alg->exit)
		skcipher->base.exit = crypto_skcipher_exit_tfm;

	if (alg->init)
		return alg->init(skcipher);

	return 0;
}
"
3621,181357,,Remote,Not required,Partial,CVE-2017-9051,https://www.cvedetails.com/cve/CVE-2017-9051/,CWE-476,Low,Partial,Partial,,2017-05-18,7.5,libav before 12.1 is vulnerable to an invalid read of size 1 due to NULL pointer dereferencing in the nsv_read_chunk function in libavformat/nsvdec.c.,2017-05-24,,5,https://github.com/libav/libav/commit/fe6eea99efac66839052af547426518efd970b24,fe6eea99efac66839052af547426518efd970b24,"nsvdec: don't ignore the return value of av_get_packet()

Fixes invalid reads with corrupted files.

CC: libav-stable@libav.org
Bug-Id: 1039",2,libavformat/nsvdec.c,"{""sha"": ""924c8694b136890d8e0c8d4f07fc3ce225b1b683"", ""filename"": ""libavformat/nsvdec.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/libav/libav/blob/fe6eea99efac66839052af547426518efd970b24/libavformat/nsvdec.c"", ""raw_url"": ""https://github.com/libav/libav/raw/fe6eea99efac66839052af547426518efd970b24/libavformat/nsvdec.c"", ""contents_url"": ""https://api.github.com/repos/libav/libav/contents/libavformat/nsvdec.c?ref=fe6eea99efac66839052af547426518efd970b24"", ""patch"": ""@@ -520,6 +520,7 @@ static int nsv_read_chunk(AVFormatContext *s, int fill_header)\n     uint32_t vsize;\n     uint16_t asize;\n     uint16_t auxsize;\n+    int ret;\n \n     if (nsv->ahead[0].data || nsv->ahead[1].data)\n         return 0; //-1; /* hey! eat what you've in your plate first! */\n@@ -571,7 +572,8 @@ static int nsv_read_chunk(AVFormatContext *s, int fill_header)\n     if (vsize && st[NSV_ST_VIDEO]) {\n         nst = st[NSV_ST_VIDEO]->priv_data;\n         pkt = &nsv->ahead[NSV_ST_VIDEO];\n-        av_get_packet(pb, pkt, vsize);\n+        if ((ret = av_get_packet(pb, pkt, vsize)) < 0)\n+            return ret;\n         pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;\n         pkt->dts = nst->frame_offset;\n         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n@@ -615,7 +617,8 @@ static int nsv_read_chunk(AVFormatContext *s, int fill_header)\n                        bps, channels, samplerate);\n             }\n         }\n-        av_get_packet(pb, pkt, asize);\n+        if ((ret = av_get_packet(pb, pkt, asize)) < 0)\n+            return ret;\n         pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;\n         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n         if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {""}","static int nsv_read_chunk(AVFormatContext *s, int fill_header)
{
    NSVContext *nsv = s->priv_data;
    AVIOContext *pb = s->pb;
    AVStream *st[2] = {NULL, NULL};
    NSVStream *nst;
    AVPacket *pkt;
    int i, err = 0;
    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */
     uint32_t vsize;
     uint16_t asize;
     uint16_t auxsize;
    int ret;
 
     if (nsv->ahead[0].data || nsv->ahead[1].data)
         return 0; //-1; /* hey! eat what you've in your plate first! */

null_chunk_retry:
    if (pb->eof_reached)
        return -1;

    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)
        err = nsv_resync(s);
    if (err < 0)
        return err;
    if (nsv->state == NSV_FOUND_NSVS)
        err = nsv_parse_NSVs_header(s);
    if (err < 0)
        return err;
    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)
        return -1;

    auxcount = avio_r8(pb);
    vsize = avio_rl16(pb);
    asize = avio_rl16(pb);
    vsize = (vsize << 4) | (auxcount >> 4);
    auxcount &= 0x0f;
    av_log(s, AV_LOG_TRACE, ""NSV CHUNK %""PRIu8"" aux, %""PRIu32"" bytes video, %""PRIu16"" bytes audio\n"",
           auxcount, vsize, asize);
    /* skip aux stuff */
    for (i = 0; i < auxcount; i++) {
        uint32_t av_unused auxtag;
        auxsize = avio_rl16(pb);
        auxtag = avio_rl32(pb);
        avio_skip(pb, auxsize);
        vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */
    }

    if (pb->eof_reached)
        return -1;
    if (!vsize && !asize) {
        nsv->state = NSV_UNSYNC;
        goto null_chunk_retry;
    }

    /* map back streams to v,a */
    if (s->nb_streams > 0)
        st[s->streams[0]->id] = s->streams[0];
    if (s->nb_streams > 1)
        st[s->streams[1]->id] = s->streams[1];

     if (vsize && st[NSV_ST_VIDEO]) {
         nst = st[NSV_ST_VIDEO]->priv_data;
         pkt = &nsv->ahead[NSV_ST_VIDEO];
        if ((ret = av_get_packet(pb, pkt, vsize)) < 0)
            return ret;
         pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;
         pkt->dts = nst->frame_offset;
         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */
        for (i = 0; i < FFMIN(8, vsize); i++)
            av_log(s, AV_LOG_TRACE, ""NSV video: [%d] = %02""PRIx8""\n"",
                   i, pkt->data[i]);
    }
    if(st[NSV_ST_VIDEO])
        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;

    if (asize && st[NSV_ST_AUDIO]) {
        nst = st[NSV_ST_AUDIO]->priv_data;
        pkt = &nsv->ahead[NSV_ST_AUDIO];
        /* read raw audio specific header on the first audio chunk... */
        /* on ALL audio chunks ?? seems so! */
        if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {
            uint8_t bps;
            uint8_t channels;
            uint16_t samplerate;
            bps = avio_r8(pb);
            channels = avio_r8(pb);
            samplerate = avio_rl16(pb);
            if (!channels || !samplerate)
                return AVERROR_INVALIDDATA;
            asize-=4;
            av_log(s, AV_LOG_TRACE, ""NSV RAWAUDIO: bps %""PRIu8"", nchan %""PRIu8"", srate %""PRIu16""\n"",
                   bps, channels, samplerate);
            if (fill_header) {
                st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */
                if (bps != 16) {
                    av_log(s, AV_LOG_TRACE, ""NSV AUDIO bit/sample != 16 (%""PRIu8"")!!!\n"", bps);
                }
                bps /= channels; // ???
                if (bps == 8)
                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;
                samplerate /= 4;/* UGH ??? XXX */
                channels = 1;
                st[NSV_ST_AUDIO]->codecpar->channels = channels;
                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;
                av_log(s, AV_LOG_TRACE, ""NSV RAWAUDIO: bps %""PRIu8"", nchan %""PRIu8"", srate %""PRIu16""\n"",
                        bps, channels, samplerate);
             }
         }
        if ((ret = av_get_packet(pb, pkt, asize)) < 0)
            return ret;
         pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;
         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */
         if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {
            /* on a nsvs frame we have new information on a/v sync */
            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);
            pkt->dts *= (int64_t)1000        * nsv->framerate.den;
            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;
            av_log(s, AV_LOG_TRACE, ""NSV AUDIO: sync:%""PRId16"", dts:%""PRId64,
                   nsv->avsync, pkt->dts);
        }
        nst->frame_offset++;
    }

    nsv->state = NSV_UNSYNC;
    return 0;
}
","static int nsv_read_chunk(AVFormatContext *s, int fill_header)
{
    NSVContext *nsv = s->priv_data;
    AVIOContext *pb = s->pb;
    AVStream *st[2] = {NULL, NULL};
    NSVStream *nst;
    AVPacket *pkt;
    int i, err = 0;
    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */
     uint32_t vsize;
     uint16_t asize;
     uint16_t auxsize;
 
     if (nsv->ahead[0].data || nsv->ahead[1].data)
         return 0; //-1; /* hey! eat what you've in your plate first! */

null_chunk_retry:
    if (pb->eof_reached)
        return -1;

    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)
        err = nsv_resync(s);
    if (err < 0)
        return err;
    if (nsv->state == NSV_FOUND_NSVS)
        err = nsv_parse_NSVs_header(s);
    if (err < 0)
        return err;
    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)
        return -1;

    auxcount = avio_r8(pb);
    vsize = avio_rl16(pb);
    asize = avio_rl16(pb);
    vsize = (vsize << 4) | (auxcount >> 4);
    auxcount &= 0x0f;
    av_log(s, AV_LOG_TRACE, ""NSV CHUNK %""PRIu8"" aux, %""PRIu32"" bytes video, %""PRIu16"" bytes audio\n"",
           auxcount, vsize, asize);
    /* skip aux stuff */
    for (i = 0; i < auxcount; i++) {
        uint32_t av_unused auxtag;
        auxsize = avio_rl16(pb);
        auxtag = avio_rl32(pb);
        avio_skip(pb, auxsize);
        vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */
    }

    if (pb->eof_reached)
        return -1;
    if (!vsize && !asize) {
        nsv->state = NSV_UNSYNC;
        goto null_chunk_retry;
    }

    /* map back streams to v,a */
    if (s->nb_streams > 0)
        st[s->streams[0]->id] = s->streams[0];
    if (s->nb_streams > 1)
        st[s->streams[1]->id] = s->streams[1];

     if (vsize && st[NSV_ST_VIDEO]) {
         nst = st[NSV_ST_VIDEO]->priv_data;
         pkt = &nsv->ahead[NSV_ST_VIDEO];
        av_get_packet(pb, pkt, vsize);
         pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;
         pkt->dts = nst->frame_offset;
         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */
        for (i = 0; i < FFMIN(8, vsize); i++)
            av_log(s, AV_LOG_TRACE, ""NSV video: [%d] = %02""PRIx8""\n"",
                   i, pkt->data[i]);
    }
    if(st[NSV_ST_VIDEO])
        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;

    if (asize && st[NSV_ST_AUDIO]) {
        nst = st[NSV_ST_AUDIO]->priv_data;
        pkt = &nsv->ahead[NSV_ST_AUDIO];
        /* read raw audio specific header on the first audio chunk... */
        /* on ALL audio chunks ?? seems so! */
        if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {
            uint8_t bps;
            uint8_t channels;
            uint16_t samplerate;
            bps = avio_r8(pb);
            channels = avio_r8(pb);
            samplerate = avio_rl16(pb);
            if (!channels || !samplerate)
                return AVERROR_INVALIDDATA;
            asize-=4;
            av_log(s, AV_LOG_TRACE, ""NSV RAWAUDIO: bps %""PRIu8"", nchan %""PRIu8"", srate %""PRIu16""\n"",
                   bps, channels, samplerate);
            if (fill_header) {
                st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */
                if (bps != 16) {
                    av_log(s, AV_LOG_TRACE, ""NSV AUDIO bit/sample != 16 (%""PRIu8"")!!!\n"", bps);
                }
                bps /= channels; // ???
                if (bps == 8)
                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;
                samplerate /= 4;/* UGH ??? XXX */
                channels = 1;
                st[NSV_ST_AUDIO]->codecpar->channels = channels;
                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;
                av_log(s, AV_LOG_TRACE, ""NSV RAWAUDIO: bps %""PRIu8"", nchan %""PRIu8"", srate %""PRIu16""\n"",
                        bps, channels, samplerate);
             }
         }
        av_get_packet(pb, pkt, asize);
         pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;
         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */
         if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {
            /* on a nsvs frame we have new information on a/v sync */
            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);
            pkt->dts *= (int64_t)1000        * nsv->framerate.den;
            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;
            av_log(s, AV_LOG_TRACE, ""NSV AUDIO: sync:%""PRId16"", dts:%""PRId64,
                   nsv->avsync, pkt->dts);
        }
        nst->frame_offset++;
    }

    nsv->state = NSV_UNSYNC;
    return 0;
}
",C,"    int ret;
        if ((ret = av_get_packet(pb, pkt, vsize)) < 0)
            return ret;
        if ((ret = av_get_packet(pb, pkt, asize)) < 0)
            return ret;
","        av_get_packet(pb, pkt, vsize);
        av_get_packet(pb, pkt, asize);
",,"@@ -520,6 +520,7 @@ static int nsv_read_chunk(AVFormatContext *s, int fill_header)
     uint32_t vsize;
     uint16_t asize;
     uint16_t auxsize;
+    int ret;
 
     if (nsv->ahead[0].data || nsv->ahead[1].data)
         return 0; //-1; /* hey! eat what you've in your plate first! */
@@ -571,7 +572,8 @@ static int nsv_read_chunk(AVFormatContext *s, int fill_header)
     if (vsize && st[NSV_ST_VIDEO]) {
         nst = st[NSV_ST_VIDEO]->priv_data;
         pkt = &nsv->ahead[NSV_ST_VIDEO];
-        av_get_packet(pb, pkt, vsize);
+        if ((ret = av_get_packet(pb, pkt, vsize)) < 0)
+            return ret;
         pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;
         pkt->dts = nst->frame_offset;
         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */
@@ -615,7 +617,8 @@ static int nsv_read_chunk(AVFormatContext *s, int fill_header)
                        bps, channels, samplerate);
             }
         }
-        av_get_packet(pb, pkt, asize);
+        if ((ret = av_get_packet(pb, pkt, asize)) < 0)
+            return ret;
         pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;
         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */
         if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {",libav,fe6eea99efac66839052af547426518efd970b24,d4f3c26b700ae847433ba3c67dc99c32bc1fd4a1,1,"static int nsv_read_chunk(AVFormatContext *s, int fill_header)
{
    NSVContext *nsv = s->priv_data;
    AVIOContext *pb = s->pb;
    AVStream *st[2] = {NULL, NULL};
    NSVStream *nst;
    AVPacket *pkt;
    int i, err = 0;
    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */
     uint32_t vsize;
     uint16_t asize;
     uint16_t auxsize;
//fix_flaw_line_below:
//    int ret;
 
     if (nsv->ahead[0].data || nsv->ahead[1].data)
         return 0; //-1; /* hey! eat what you've in your plate first! */

null_chunk_retry:
    if (pb->eof_reached)
        return -1;

    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)
        err = nsv_resync(s);
    if (err < 0)
        return err;
    if (nsv->state == NSV_FOUND_NSVS)
        err = nsv_parse_NSVs_header(s);
    if (err < 0)
        return err;
    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)
        return -1;

    auxcount = avio_r8(pb);
    vsize = avio_rl16(pb);
    asize = avio_rl16(pb);
    vsize = (vsize << 4) | (auxcount >> 4);
    auxcount &= 0x0f;
    av_log(s, AV_LOG_TRACE, ""NSV CHUNK %""PRIu8"" aux, %""PRIu32"" bytes video, %""PRIu16"" bytes audio\n"",
           auxcount, vsize, asize);
    /* skip aux stuff */
    for (i = 0; i < auxcount; i++) {
        uint32_t av_unused auxtag;
        auxsize = avio_rl16(pb);
        auxtag = avio_rl32(pb);
        avio_skip(pb, auxsize);
        vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */
    }

    if (pb->eof_reached)
        return -1;
    if (!vsize && !asize) {
        nsv->state = NSV_UNSYNC;
        goto null_chunk_retry;
    }

    /* map back streams to v,a */
    if (s->nb_streams > 0)
        st[s->streams[0]->id] = s->streams[0];
    if (s->nb_streams > 1)
        st[s->streams[1]->id] = s->streams[1];

     if (vsize && st[NSV_ST_VIDEO]) {
         nst = st[NSV_ST_VIDEO]->priv_data;
         pkt = &nsv->ahead[NSV_ST_VIDEO];
//flaw_line_below:
        av_get_packet(pb, pkt, vsize);
//fix_flaw_line_below:
//        if ((ret = av_get_packet(pb, pkt, vsize)) < 0)
//fix_flaw_line_below:
//            return ret;
         pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;
         pkt->dts = nst->frame_offset;
         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */
        for (i = 0; i < FFMIN(8, vsize); i++)
            av_log(s, AV_LOG_TRACE, ""NSV video: [%d] = %02""PRIx8""\n"",
                   i, pkt->data[i]);
    }
    if(st[NSV_ST_VIDEO])
        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;

    if (asize && st[NSV_ST_AUDIO]) {
        nst = st[NSV_ST_AUDIO]->priv_data;
        pkt = &nsv->ahead[NSV_ST_AUDIO];
        /* read raw audio specific header on the first audio chunk... */
        /* on ALL audio chunks ?? seems so! */
        if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {
            uint8_t bps;
            uint8_t channels;
            uint16_t samplerate;
            bps = avio_r8(pb);
            channels = avio_r8(pb);
            samplerate = avio_rl16(pb);
            if (!channels || !samplerate)
                return AVERROR_INVALIDDATA;
            asize-=4;
            av_log(s, AV_LOG_TRACE, ""NSV RAWAUDIO: bps %""PRIu8"", nchan %""PRIu8"", srate %""PRIu16""\n"",
                   bps, channels, samplerate);
            if (fill_header) {
                st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */
                if (bps != 16) {
                    av_log(s, AV_LOG_TRACE, ""NSV AUDIO bit/sample != 16 (%""PRIu8"")!!!\n"", bps);
                }
                bps /= channels; // ???
                if (bps == 8)
                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;
                samplerate /= 4;/* UGH ??? XXX */
                channels = 1;
                st[NSV_ST_AUDIO]->codecpar->channels = channels;
                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;
                av_log(s, AV_LOG_TRACE, ""NSV RAWAUDIO: bps %""PRIu8"", nchan %""PRIu8"", srate %""PRIu16""\n"",
                        bps, channels, samplerate);
             }
         }
//flaw_line_below:
        av_get_packet(pb, pkt, asize);
//fix_flaw_line_below:
//        if ((ret = av_get_packet(pb, pkt, asize)) < 0)
//fix_flaw_line_below:
//            return ret;
         pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;
         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */
         if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {
            /* on a nsvs frame we have new information on a/v sync */
            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);
            pkt->dts *= (int64_t)1000        * nsv->framerate.den;
            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;
            av_log(s, AV_LOG_TRACE, ""NSV AUDIO: sync:%""PRId16"", dts:%""PRId64,
                   nsv->avsync, pkt->dts);
        }
        nst->frame_offset++;
    }

    nsv->state = NSV_UNSYNC;
    return 0;
}
"
3628,181364,,Remote,Not required,Partial,CVE-2017-8825,https://www.cvedetails.com/cve/CVE-2017-8825/,CWE-476,Low,,,,2017-05-08,5.0,"A null dereference vulnerability has been found in the MIME handling component of LibEtPan before 1.8, as used in MailCore and MailCore 2. A crash can occur in low-level/imf/mailimf.c during a failed parse of a Cc header containing multiple e-mail addresses.",2017-05-18,,12,https://github.com/dinhviethoa/libetpan/commit/1fe8fbc032ccda1db9af66d93016b49c16c1f22d,1fe8fbc032ccda1db9af66d93016b49c16c1f22d,Fixed crash #274,0,src/low-level/imf/mailimf.c,"{""sha"": ""b557070d2ca3f804686cb57f9f90775112a6ff74"", ""filename"": ""src/low-level/imf/mailimf.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/dinhviethoa/libetpan/blob/1fe8fbc032ccda1db9af66d93016b49c16c1f22d/src/low-level/imf/mailimf.c"", ""raw_url"": ""https://github.com/dinhviethoa/libetpan/raw/1fe8fbc032ccda1db9af66d93016b49c16c1f22d/src/low-level/imf/mailimf.c"", ""contents_url"": ""https://api.github.com/repos/dinhviethoa/libetpan/contents/src/low-level/imf/mailimf.c?ref=1fe8fbc032ccda1db9af66d93016b49c16c1f22d"", ""patch"": ""@@ -3083,6 +3083,7 @@ static int mailimf_group_parse(const char * message, size_t length,\n   struct mailimf_group * group;\n   int r;\n   int res;\n+  clist * list;\n \n   cur_token = * indx;\n \n@@ -3110,6 +3111,17 @@ static int mailimf_group_parse(const char * message, size_t length,\n       res = r;\n       goto free_display_name;\n     }\n+    list = clist_new();\n+    if (list == NULL) {\n+      res = MAILIMF_ERROR_MEMORY;\n+      goto free_display_name;\n+    }\n+    mailbox_list = mailimf_mailbox_list_new(list);\n+    if (mailbox_list == NULL) {\n+      res = MAILIMF_ERROR_MEMORY;\n+      clist_free(list);\n+      goto free_display_name;\n+    }\n     break;\n   default:\n     res = r;""}","static int mailimf_group_parse(const char * message, size_t length,
			       size_t * indx,
			       struct mailimf_group ** result)
{
  size_t cur_token;
  char * display_name;
  struct mailimf_mailbox_list * mailbox_list;
   struct mailimf_group * group;
   int r;
   int res;
  clist * list;
 
   cur_token = * indx;
 
  mailbox_list = NULL;

  r = mailimf_display_name_parse(message, length, &cur_token, &display_name);
  if (r != MAILIMF_NO_ERROR) {
    res = r;
    goto err;
  }

  r = mailimf_colon_parse(message, length, &cur_token);
  if (r != MAILIMF_NO_ERROR) {
    res = r;
    goto free_display_name;
  }

  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mailbox_list);
  switch (r) {
  case MAILIMF_NO_ERROR:
    break;
  case MAILIMF_ERROR_PARSE:
    r = mailimf_cfws_parse(message, length, &cur_token);
    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {
       res = r;
       goto free_display_name;
     }
    list = clist_new();
    if (list == NULL) {
      res = MAILIMF_ERROR_MEMORY;
      goto free_display_name;
    }
    mailbox_list = mailimf_mailbox_list_new(list);
    if (mailbox_list == NULL) {
      res = MAILIMF_ERROR_MEMORY;
      clist_free(list);
      goto free_display_name;
    }
     break;
   default:
     res = r;
    goto free_display_name;
  }

  r = mailimf_semi_colon_parse(message, length, &cur_token);
  if (r != MAILIMF_NO_ERROR) {
    res = r;
    goto free_mailbox_list;
  }

  group = mailimf_group_new(display_name, mailbox_list);
  if (group == NULL) {
    res = MAILIMF_ERROR_MEMORY;
    goto free_mailbox_list;
  }

  * indx = cur_token;
  * result = group;

  return MAILIMF_NO_ERROR;

 free_mailbox_list:
  if (mailbox_list != NULL) {
    mailimf_mailbox_list_free(mailbox_list);
  }
 free_display_name:
  mailimf_display_name_free(display_name);
 err:
  return res;
}
","static int mailimf_group_parse(const char * message, size_t length,
			       size_t * indx,
			       struct mailimf_group ** result)
{
  size_t cur_token;
  char * display_name;
  struct mailimf_mailbox_list * mailbox_list;
   struct mailimf_group * group;
   int r;
   int res;
 
   cur_token = * indx;
 
  mailbox_list = NULL;

  r = mailimf_display_name_parse(message, length, &cur_token, &display_name);
  if (r != MAILIMF_NO_ERROR) {
    res = r;
    goto err;
  }

  r = mailimf_colon_parse(message, length, &cur_token);
  if (r != MAILIMF_NO_ERROR) {
    res = r;
    goto free_display_name;
  }

  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mailbox_list);
  switch (r) {
  case MAILIMF_NO_ERROR:
    break;
  case MAILIMF_ERROR_PARSE:
    r = mailimf_cfws_parse(message, length, &cur_token);
    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {
       res = r;
       goto free_display_name;
     }
     break;
   default:
     res = r;
    goto free_display_name;
  }

  r = mailimf_semi_colon_parse(message, length, &cur_token);
  if (r != MAILIMF_NO_ERROR) {
    res = r;
    goto free_mailbox_list;
  }

  group = mailimf_group_new(display_name, mailbox_list);
  if (group == NULL) {
    res = MAILIMF_ERROR_MEMORY;
    goto free_mailbox_list;
  }

  * indx = cur_token;
  * result = group;

  return MAILIMF_NO_ERROR;

 free_mailbox_list:
  if (mailbox_list != NULL) {
    mailimf_mailbox_list_free(mailbox_list);
  }
 free_display_name:
  mailimf_display_name_free(display_name);
 err:
  return res;
}
",C,"  clist * list;
    list = clist_new();
    if (list == NULL) {
      res = MAILIMF_ERROR_MEMORY;
      goto free_display_name;
    }
    mailbox_list = mailimf_mailbox_list_new(list);
    if (mailbox_list == NULL) {
      res = MAILIMF_ERROR_MEMORY;
      clist_free(list);
      goto free_display_name;
    }
",,,"@@ -3083,6 +3083,7 @@ static int mailimf_group_parse(const char * message, size_t length,
   struct mailimf_group * group;
   int r;
   int res;
+  clist * list;
 
   cur_token = * indx;
 
@@ -3110,6 +3111,17 @@ static int mailimf_group_parse(const char * message, size_t length,
       res = r;
       goto free_display_name;
     }
+    list = clist_new();
+    if (list == NULL) {
+      res = MAILIMF_ERROR_MEMORY;
+      goto free_display_name;
+    }
+    mailbox_list = mailimf_mailbox_list_new(list);
+    if (mailbox_list == NULL) {
+      res = MAILIMF_ERROR_MEMORY;
+      clist_free(list);
+      goto free_display_name;
+    }
     break;
   default:
     res = r;",libetpan,1fe8fbc032ccda1db9af66d93016b49c16c1f22d,d4244c326e392e7c581383d088e302b4fcb3d921,1,"static int mailimf_group_parse(const char * message, size_t length,
			       size_t * indx,
			       struct mailimf_group ** result)
{
  size_t cur_token;
  char * display_name;
  struct mailimf_mailbox_list * mailbox_list;
   struct mailimf_group * group;
   int r;
   int res;
//fix_flaw_line_below:
//  clist * list;
 
   cur_token = * indx;
 
  mailbox_list = NULL;

  r = mailimf_display_name_parse(message, length, &cur_token, &display_name);
  if (r != MAILIMF_NO_ERROR) {
    res = r;
    goto err;
  }

  r = mailimf_colon_parse(message, length, &cur_token);
  if (r != MAILIMF_NO_ERROR) {
    res = r;
    goto free_display_name;
  }

  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mailbox_list);
  switch (r) {
  case MAILIMF_NO_ERROR:
    break;
  case MAILIMF_ERROR_PARSE:
    r = mailimf_cfws_parse(message, length, &cur_token);
    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {
       res = r;
       goto free_display_name;
     }
//fix_flaw_line_below:
//    list = clist_new();
//fix_flaw_line_below:
//    if (list == NULL) {
//fix_flaw_line_below:
//      res = MAILIMF_ERROR_MEMORY;
//fix_flaw_line_below:
//      goto free_display_name;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//    mailbox_list = mailimf_mailbox_list_new(list);
//fix_flaw_line_below:
//    if (mailbox_list == NULL) {
//fix_flaw_line_below:
//      res = MAILIMF_ERROR_MEMORY;
//fix_flaw_line_below:
//      clist_free(list);
//fix_flaw_line_below:
//      goto free_display_name;
//fix_flaw_line_below:
//    }
     break;
   default:
     res = r;
    goto free_display_name;
  }

  r = mailimf_semi_colon_parse(message, length, &cur_token);
  if (r != MAILIMF_NO_ERROR) {
    res = r;
    goto free_mailbox_list;
  }

  group = mailimf_group_new(display_name, mailbox_list);
  if (group == NULL) {
    res = MAILIMF_ERROR_MEMORY;
    goto free_mailbox_list;
  }

  * indx = cur_token;
  * result = group;

  return MAILIMF_NO_ERROR;

 free_mailbox_list:
  if (mailbox_list != NULL) {
    mailimf_mailbox_list_free(mailbox_list);
  }
 free_display_name:
  mailimf_display_name_free(display_name);
 err:
  return res;
}
"
3723,181459,,Remote,Not required,Partial,CVE-2017-7274,https://www.cvedetails.com/cve/CVE-2017-7274/,CWE-476,Medium,,,,2017-03-27,4.3,The r_pkcs7_parse_cms function in libr/util/r_pkcs7.c in radare2 1.3.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted PE file.,2017-03-31,DoS ,3,https://github.com/radare/radare2/commit/7ab66cca5bbdf6cb2d69339ef4f513d95e532dbf,7ab66cca5bbdf6cb2d69339ef4f513d95e532dbf,Fix #7152 - Null deref in cms,1,libr/util/r_pkcs7.c,"{""sha"": ""467f58fa729a43d2970010ada7f5eee36d6815d4"", ""filename"": ""libr/util/r_pkcs7.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/radareorg/radare2/blob/7ab66cca5bbdf6cb2d69339ef4f513d95e532dbf/libr/util/r_pkcs7.c"", ""raw_url"": ""https://github.com/radareorg/radare2/raw/7ab66cca5bbdf6cb2d69339ef4f513d95e532dbf/libr/util/r_pkcs7.c"", ""contents_url"": ""https://api.github.com/repos/radareorg/radare2/contents/libr/util/r_pkcs7.c?ref=7ab66cca5bbdf6cb2d69339ef4f513d95e532dbf"", ""patch"": ""@@ -284,7 +284,9 @@ RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n \t\treturn NULL;\n \t}\n \tobject = r_asn1_create_object (buffer, length);\n-\tif (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {\n+\tif (!object || object->list.length != 2 || !object->list.objects ||\n+\t\t!object->list.objects[0] || !object->list.objects[1] ||\n+\t\tobject->list.objects[1]->list.length != 1) {\n \t\tr_asn1_free_object (object);\n \t\tfree (container);\n \t\treturn NULL;""}","RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {
	RASN1Object *object;
	RCMS *container;
	if (!buffer || !length) {
		return NULL;
	}
	container = R_NEW0 (RCMS);
	if (!container) {
 		return NULL;
 	}
 	object = r_asn1_create_object (buffer, length);
	if (!object || object->list.length != 2 || !object->list.objects ||
		!object->list.objects[0] || !object->list.objects[1] ||
		object->list.objects[1]->list.length != 1) {
 		r_asn1_free_object (object);
 		free (container);
 		return NULL;
	}
	container->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);
	r_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);
	r_asn1_free_object (object);
	return container;
}
","RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {
	RASN1Object *object;
	RCMS *container;
	if (!buffer || !length) {
		return NULL;
	}
	container = R_NEW0 (RCMS);
	if (!container) {
 		return NULL;
 	}
 	object = r_asn1_create_object (buffer, length);
	if (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {
 		r_asn1_free_object (object);
 		free (container);
 		return NULL;
	}
	container->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);
	r_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);
	r_asn1_free_object (object);
	return container;
}
",C,"	if (!object || object->list.length != 2 || !object->list.objects ||
		!object->list.objects[0] || !object->list.objects[1] ||
		object->list.objects[1]->list.length != 1) {
","	if (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {
",,"@@ -284,7 +284,9 @@ RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {
 		return NULL;
 	}
 	object = r_asn1_create_object (buffer, length);
-	if (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {
+	if (!object || object->list.length != 2 || !object->list.objects ||
+		!object->list.objects[0] || !object->list.objects[1] ||
+		object->list.objects[1]->list.length != 1) {
 		r_asn1_free_object (object);
 		free (container);
 		return NULL;",radare2,7ab66cca5bbdf6cb2d69339ef4f513d95e532dbf,6de49610ea69adc693920176948741d8926351f3,1,"RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {
	RASN1Object *object;
	RCMS *container;
	if (!buffer || !length) {
		return NULL;
	}
	container = R_NEW0 (RCMS);
	if (!container) {
 		return NULL;
 	}
 	object = r_asn1_create_object (buffer, length);
//flaw_line_below:
	if (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {
//fix_flaw_line_below:
//	if (!object || object->list.length != 2 || !object->list.objects ||
//fix_flaw_line_below:
//		!object->list.objects[0] || !object->list.objects[1] ||
//fix_flaw_line_below:
//		object->list.objects[1]->list.length != 1) {
 		r_asn1_free_object (object);
 		free (container);
 		return NULL;
	}
	container->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);
	r_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);
	r_asn1_free_object (object);
	return container;
}
"
3753,181489,,Remote,Not required,Partial,CVE-2017-6850,https://www.cvedetails.com/cve/CVE-2017-6850/,CWE-476,Medium,,,,2017-03-15,4.3,The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.,2018-06-28,DoS ,16,https://github.com/mdadams/jasper/commit/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"Fixed bugs due to uninitialized data in the JP2 decoder.
Also, added some comments marking I/O stream interfaces that probably
need to be changed (in the long term) to fix integer overflow problems.",1,src/libjasper/jp2/jp2_cod.c,"{""sha"": ""d70408fbb526d1d1e9166962eae9a2cf39179267"", ""filename"": ""src/libjasper/base/jas_stream.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 0, ""changes"": 18, ""blob_url"": ""https://github.com/mdadams/jasper/blob/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/base/jas_stream.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/base/jas_stream.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/base/jas_stream.c?ref=e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d"", ""patch"": ""@@ -664,6 +664,7 @@ int jas_stream_ungetc(jas_stream_t *stream, int c)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n {\n \tint n;\n@@ -690,6 +691,7 @@ int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n \treturn n;\n }\n \n+/* FIXME integral type */\n int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n {\n \tint n;\n@@ -742,6 +744,7 @@ int jas_stream_puts(jas_stream_t *stream, const char *s)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n {\n \tint c;\n@@ -765,6 +768,7 @@ char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n \treturn buf;\n }\n \n+/* FIXME integral type */\n int jas_stream_gobble(jas_stream_t *stream, int n)\n {\n \tint m;\n@@ -783,6 +787,7 @@ int jas_stream_gobble(jas_stream_t *stream, int n)\n \treturn n;\n }\n \n+/* FIXME integral type */\n int jas_stream_pad(jas_stream_t *stream, int n, int c)\n {\n \tint m;\n@@ -885,6 +890,7 @@ long jas_stream_tell(jas_stream_t *stream)\n * Buffer initialization code.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n   int bufsize)\n {\n@@ -1060,6 +1066,7 @@ static int jas_strtoopenmode(const char *s)\n \treturn openmode;\n }\n \n+/* FIXME integral type */\n int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n {\n \tint all;\n@@ -1085,6 +1092,7 @@ int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n long jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n {\n \tint old;\n@@ -1094,6 +1102,7 @@ long jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n \treturn old;\n }\n \n+/* FIXME integral type */\n int jas_stream_display(jas_stream_t *stream, FILE *fp, int n)\n {\n \tunsigned char buf[16];\n@@ -1168,6 +1177,7 @@ long jas_stream_length(jas_stream_t *stream)\n * Memory stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tssize_t n;\n@@ -1209,6 +1219,7 @@ static int mem_resize(jas_stream_memobj_t *m, size_t bufsize)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tsize_t n;\n@@ -1264,6 +1275,7 @@ static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn ret;\n }\n \n+/* FIXME integral type */\n static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n@@ -1310,6 +1322,7 @@ static int mem_close(jas_stream_obj_t *obj)\n * File stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1318,6 +1331,7 @@ static int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn read(fileobj->fd, buf, cnt);\n }\n \n+/* FIXME integral type */\n static int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1326,6 +1340,7 @@ static int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn write(fileobj->fd, buf, cnt);\n }\n \n+/* FIXME integral type */\n static long file_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1352,6 +1367,7 @@ static int file_close(jas_stream_obj_t *obj)\n * Stdio file stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tFILE *fp;\n@@ -1367,6 +1383,7 @@ static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn result;\n }\n \n+/* FIXME integral type */\n static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tFILE *fp;\n@@ -1377,6 +1394,7 @@ static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn (n != JAS_CAST(size_t, cnt)) ? (-1) : cnt;\n }\n \n+/* FIXME integral type */\n static long sfile_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tFILE *fp;""}<_**next**_>{""sha"": ""8d98a2cad438fac2f83c094515850f2d0aab3054"", ""filename"": ""src/libjasper/jp2/jp2_cod.c"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/mdadams/jasper/blob/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/jp2/jp2_cod.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/jp2/jp2_cod.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/jp2/jp2_cod.c?ref=e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d"", ""patch"": ""@@ -183,15 +183,28 @@ jp2_boxinfo_t jp2_boxinfo_unk = {\n * Box constructor.\n \\******************************************************************************/\n \n-jp2_box_t *jp2_box_create(int type)\n+jp2_box_t *jp2_box_create0()\n {\n \tjp2_box_t *box;\n-\tjp2_boxinfo_t *boxinfo;\n-\n \tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n \t\treturn 0;\n \t}\n \tmemset(box, 0, sizeof(jp2_box_t));\n+\tbox->type = 0;\n+\tbox->len = 0;\n+\t// Mark the box data as never having been constructed\n+\t// so that we will not errantly attempt to destroy it later.\n+\tbox->ops = &jp2_boxinfo_unk.ops;\n+\treturn box;\n+}\n+\n+jp2_box_t *jp2_box_create(int type)\n+{\n+\tjp2_box_t *box;\n+\tjp2_boxinfo_t *boxinfo;\n+\tif (!(box = jp2_box_create0())) {\n+\t\treturn 0;\n+\t}\n \tbox->type = type;\n \tbox->len = 0;\n \tif (!(boxinfo = jp2_boxinfolookup(type))) {\n@@ -248,25 +261,22 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \tbox = 0;\n \ttmpstream = 0;\n \n-\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n+\tif (!(box = jp2_box_create0())) {\n \t\tgoto error;\n \t}\n-\n-\t// Mark the box data as never having been constructed\n-\t// so that we will not errantly attempt to destroy it later.\n-\tbox->ops = &jp2_boxinfo_unk.ops;\n-\n \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n \t\tgoto error;\n \t}\n \tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n \tbox->len = len;\n \tJAS_DBGLOG(10, (\n-\t  \""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\"",\n+\t  \""preliminary processing of JP2 box: \""\n+\t  \""type=%c%s%c (0x%08x); length=%\""PRIuFAST32\""\\n\"",\n \t  '\""', boxinfo->name, '\""', box->type, box->len\n \t  ));\n \tif (box->len == 1) {\n+\t\tJAS_DBGLOG(10, (\""big length\\n\""));\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n \t\t}\n@@ -382,6 +392,7 @@ static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n {\n \tjp2_bpcc_t *bpcc = &box->data.bpcc;\n \tunsigned int i;\n+\tbpcc->bpcs = 0;\n \tbpcc->numcmpts = box->datalen;\n \tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n \t\treturn -1;\n@@ -462,6 +473,7 @@ static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n \tjp2_cdef_t *cdef = &box->data.cdef;\n \tjp2_cdefchan_t *chan;\n \tunsigned int channo;\n+\tcdef->ents = 0;\n \tif (jp2_getuint16(in, &cdef->numchans)) {\n \t\treturn -1;\n \t}\n@@ -518,7 +530,9 @@ int jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n \t}\n \n \tif (dataflag) {\n-\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n+\t\tif (jas_stream_copy(out, tmpstream, box->len -\n+\t\t  JP2_BOX_HDRLEN(false))) {\n+\t\t\tjas_eprintf(\""cannot copy box data\\n\"");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_close(tmpstream);\n@@ -777,6 +791,7 @@ static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n \tjp2_cmap_t *cmap = &box->data.cmap;\n \tjp2_cmapent_t *ent;\n \tunsigned int i;\n+\tcmap->ents = 0;\n \n \tcmap->numchans = (box->datalen) / 4;\n \tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n@@ -835,6 +850,7 @@ static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n \tint_fast32_t x;\n \n \tpclr->lutdata = 0;\n+\tpclr->bpc = 0;\n \n \tif (jp2_getuint16(in, &pclr->numlutents) ||\n \t  jp2_getuint8(in, &pclr->numchans)) {\n@@ -869,9 +885,9 @@ static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n #if 0\n \tjp2_pclr_t *pclr = &box->data.pclr;\n #endif\n-/* Eliminate warning about unused variable. */\n-box = 0;\n-out = 0;\n+\t/* Eliminate warning about unused variable. */\n+\tbox = 0;\n+\tout = 0;\n \treturn -1;\n }\n ""}","jp2_box_t *jp2_box_create(int type)
jp2_box_t *jp2_box_create0()
 {
 	jp2_box_t *box;
 	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
 		return 0;
 	}
 	memset(box, 0, sizeof(jp2_box_t));
	box->type = 0;
	box->len = 0;
	// Mark the box data as never having been constructed
	// so that we will not errantly attempt to destroy it later.
	box->ops = &jp2_boxinfo_unk.ops;
	return box;
}

jp2_box_t *jp2_box_create(int type)
{
	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;
	if (!(box = jp2_box_create0())) {
		return 0;
	}
 	box->type = type;
 	box->len = 0;
 	if (!(boxinfo = jp2_boxinfolookup(type))) {
		return 0;
	}
	box->info = boxinfo;
	box->ops = &boxinfo->ops;
	return box;
}
","jp2_box_t *jp2_box_create(int type)
 {
 	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;
 	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
 		return 0;
 	}
 	memset(box, 0, sizeof(jp2_box_t));
 	box->type = type;
 	box->len = 0;
 	if (!(boxinfo = jp2_boxinfolookup(type))) {
		return 0;
	}
	box->info = boxinfo;
	box->ops = &boxinfo->ops;
	return box;
}
",C,"jp2_box_t *jp2_box_create0()
	box->type = 0;
	box->len = 0;
	// Mark the box data as never having been constructed
	// so that we will not errantly attempt to destroy it later.
	box->ops = &jp2_boxinfo_unk.ops;
	return box;
}

jp2_box_t *jp2_box_create(int type)
{
	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;
	if (!(box = jp2_box_create0())) {
		return 0;
	}
","	jp2_boxinfo_t *boxinfo;
",,"@@ -183,15 +183,28 @@ jp2_boxinfo_t jp2_boxinfo_unk = {
 * Box constructor.
 \******************************************************************************/
 
-jp2_box_t *jp2_box_create(int type)
+jp2_box_t *jp2_box_create0()
 {
 	jp2_box_t *box;
-	jp2_boxinfo_t *boxinfo;
-
 	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
 		return 0;
 	}
 	memset(box, 0, sizeof(jp2_box_t));
+	box->type = 0;
+	box->len = 0;
+	// Mark the box data as never having been constructed
+	// so that we will not errantly attempt to destroy it later.
+	box->ops = &jp2_boxinfo_unk.ops;
+	return box;
+}
+
+jp2_box_t *jp2_box_create(int type)
+{
+	jp2_box_t *box;
+	jp2_boxinfo_t *boxinfo;
+	if (!(box = jp2_box_create0())) {
+		return 0;
+	}
 	box->type = type;
 	box->len = 0;
 	if (!(boxinfo = jp2_boxinfolookup(type))) {
@@ -248,25 +261,22 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)
 	box = 0;
 	tmpstream = 0;
 
-	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
+	if (!(box = jp2_box_create0())) {
 		goto error;
 	}
-
-	// Mark the box data as never having been constructed
-	// so that we will not errantly attempt to destroy it later.
-	box->ops = &jp2_boxinfo_unk.ops;
-
 	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
 		goto error;
 	}
 	boxinfo = jp2_boxinfolookup(box->type);
 	box->info = boxinfo;
 	box->len = len;
 	JAS_DBGLOG(10, (
-	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
+	  ""preliminary processing of JP2 box: ""
+	  ""type=%c%s%c (0x%08x); length=%""PRIuFAST32""\n"",
 	  '""', boxinfo->name, '""', box->type, box->len
 	  ));
 	if (box->len == 1) {
+		JAS_DBGLOG(10, (""big length\n""));
 		if (jp2_getuint64(in, &extlen)) {
 			goto error;
 		}
@@ -382,6 +392,7 @@ static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)
 {
 	jp2_bpcc_t *bpcc = &box->data.bpcc;
 	unsigned int i;
+	bpcc->bpcs = 0;
 	bpcc->numcmpts = box->datalen;
 	if (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {
 		return -1;
@@ -462,6 +473,7 @@ static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)
 	jp2_cdef_t *cdef = &box->data.cdef;
 	jp2_cdefchan_t *chan;
 	unsigned int channo;
+	cdef->ents = 0;
 	if (jp2_getuint16(in, &cdef->numchans)) {
 		return -1;
 	}
@@ -518,7 +530,9 @@ int jp2_box_put(jp2_box_t *box, jas_stream_t *out)
 	}
 
 	if (dataflag) {
-		if (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {
+		if (jas_stream_copy(out, tmpstream, box->len -
+		  JP2_BOX_HDRLEN(false))) {
+			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}
 		jas_stream_close(tmpstream);
@@ -777,6 +791,7 @@ static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)
 	jp2_cmap_t *cmap = &box->data.cmap;
 	jp2_cmapent_t *ent;
 	unsigned int i;
+	cmap->ents = 0;
 
 	cmap->numchans = (box->datalen) / 4;
 	if (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {
@@ -835,6 +850,7 @@ static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)
 	int_fast32_t x;
 
 	pclr->lutdata = 0;
+	pclr->bpc = 0;
 
 	if (jp2_getuint16(in, &pclr->numlutents) ||
 	  jp2_getuint8(in, &pclr->numchans)) {
@@ -869,9 +885,9 @@ static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)
 #if 0
 	jp2_pclr_t *pclr = &box->data.pclr;
 #endif
-/* Eliminate warning about unused variable. */
-box = 0;
-out = 0;
+	/* Eliminate warning about unused variable. */
+	box = 0;
+	out = 0;
 	return -1;
 }
 ",jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,7692d6d1a0bfbd9a1d3f905337e3457cec39bced,1,"jp2_box_t *jp2_box_create(int type)
//fix_flaw_line_below:
//jp2_box_t *jp2_box_create0()
 {
 	jp2_box_t *box;
//flaw_line_below:
	jp2_boxinfo_t *boxinfo;
//flaw_line_below:

 	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
 		return 0;
 	}
 	memset(box, 0, sizeof(jp2_box_t));
//fix_flaw_line_below:
//	box->type = 0;
//fix_flaw_line_below:
//	box->len = 0;
//fix_flaw_line_below:
//	// Mark the box data as never having been constructed
//fix_flaw_line_below:
//	// so that we will not errantly attempt to destroy it later.
//fix_flaw_line_below:
//	box->ops = &jp2_boxinfo_unk.ops;
//fix_flaw_line_below:
//	return box;
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//jp2_box_t *jp2_box_create(int type)
//fix_flaw_line_below:
//{
//fix_flaw_line_below:
//	jp2_box_t *box;
//fix_flaw_line_below:
//	jp2_boxinfo_t *boxinfo;
//fix_flaw_line_below:
//	if (!(box = jp2_box_create0())) {
//fix_flaw_line_below:
//		return 0;
//fix_flaw_line_below:
//	}
 	box->type = type;
 	box->len = 0;
 	if (!(boxinfo = jp2_boxinfolookup(type))) {
		return 0;
	}
	box->info = boxinfo;
	box->ops = &boxinfo->ops;
	return box;
}
"
3754,181490,,Remote,Not required,Partial,CVE-2017-6850,https://www.cvedetails.com/cve/CVE-2017-6850/,CWE-476,Medium,,,,2017-03-15,4.3,The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.,2018-06-28,DoS ,4,https://github.com/mdadams/jasper/commit/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"Fixed bugs due to uninitialized data in the JP2 decoder.
Also, added some comments marking I/O stream interfaces that probably
need to be changed (in the long term) to fix integer overflow problems.",3,src/libjasper/jp2/jp2_cod.c,"{""sha"": ""d70408fbb526d1d1e9166962eae9a2cf39179267"", ""filename"": ""src/libjasper/base/jas_stream.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 0, ""changes"": 18, ""blob_url"": ""https://github.com/mdadams/jasper/blob/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/base/jas_stream.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/base/jas_stream.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/base/jas_stream.c?ref=e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d"", ""patch"": ""@@ -664,6 +664,7 @@ int jas_stream_ungetc(jas_stream_t *stream, int c)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n {\n \tint n;\n@@ -690,6 +691,7 @@ int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n \treturn n;\n }\n \n+/* FIXME integral type */\n int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n {\n \tint n;\n@@ -742,6 +744,7 @@ int jas_stream_puts(jas_stream_t *stream, const char *s)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n {\n \tint c;\n@@ -765,6 +768,7 @@ char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n \treturn buf;\n }\n \n+/* FIXME integral type */\n int jas_stream_gobble(jas_stream_t *stream, int n)\n {\n \tint m;\n@@ -783,6 +787,7 @@ int jas_stream_gobble(jas_stream_t *stream, int n)\n \treturn n;\n }\n \n+/* FIXME integral type */\n int jas_stream_pad(jas_stream_t *stream, int n, int c)\n {\n \tint m;\n@@ -885,6 +890,7 @@ long jas_stream_tell(jas_stream_t *stream)\n * Buffer initialization code.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n   int bufsize)\n {\n@@ -1060,6 +1066,7 @@ static int jas_strtoopenmode(const char *s)\n \treturn openmode;\n }\n \n+/* FIXME integral type */\n int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n {\n \tint all;\n@@ -1085,6 +1092,7 @@ int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n long jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n {\n \tint old;\n@@ -1094,6 +1102,7 @@ long jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n \treturn old;\n }\n \n+/* FIXME integral type */\n int jas_stream_display(jas_stream_t *stream, FILE *fp, int n)\n {\n \tunsigned char buf[16];\n@@ -1168,6 +1177,7 @@ long jas_stream_length(jas_stream_t *stream)\n * Memory stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tssize_t n;\n@@ -1209,6 +1219,7 @@ static int mem_resize(jas_stream_memobj_t *m, size_t bufsize)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tsize_t n;\n@@ -1264,6 +1275,7 @@ static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn ret;\n }\n \n+/* FIXME integral type */\n static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n@@ -1310,6 +1322,7 @@ static int mem_close(jas_stream_obj_t *obj)\n * File stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1318,6 +1331,7 @@ static int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn read(fileobj->fd, buf, cnt);\n }\n \n+/* FIXME integral type */\n static int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1326,6 +1340,7 @@ static int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn write(fileobj->fd, buf, cnt);\n }\n \n+/* FIXME integral type */\n static long file_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1352,6 +1367,7 @@ static int file_close(jas_stream_obj_t *obj)\n * Stdio file stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tFILE *fp;\n@@ -1367,6 +1383,7 @@ static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn result;\n }\n \n+/* FIXME integral type */\n static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tFILE *fp;\n@@ -1377,6 +1394,7 @@ static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn (n != JAS_CAST(size_t, cnt)) ? (-1) : cnt;\n }\n \n+/* FIXME integral type */\n static long sfile_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tFILE *fp;""}<_**next**_>{""sha"": ""8d98a2cad438fac2f83c094515850f2d0aab3054"", ""filename"": ""src/libjasper/jp2/jp2_cod.c"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/mdadams/jasper/blob/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/jp2/jp2_cod.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/jp2/jp2_cod.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/jp2/jp2_cod.c?ref=e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d"", ""patch"": ""@@ -183,15 +183,28 @@ jp2_boxinfo_t jp2_boxinfo_unk = {\n * Box constructor.\n \\******************************************************************************/\n \n-jp2_box_t *jp2_box_create(int type)\n+jp2_box_t *jp2_box_create0()\n {\n \tjp2_box_t *box;\n-\tjp2_boxinfo_t *boxinfo;\n-\n \tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n \t\treturn 0;\n \t}\n \tmemset(box, 0, sizeof(jp2_box_t));\n+\tbox->type = 0;\n+\tbox->len = 0;\n+\t// Mark the box data as never having been constructed\n+\t// so that we will not errantly attempt to destroy it later.\n+\tbox->ops = &jp2_boxinfo_unk.ops;\n+\treturn box;\n+}\n+\n+jp2_box_t *jp2_box_create(int type)\n+{\n+\tjp2_box_t *box;\n+\tjp2_boxinfo_t *boxinfo;\n+\tif (!(box = jp2_box_create0())) {\n+\t\treturn 0;\n+\t}\n \tbox->type = type;\n \tbox->len = 0;\n \tif (!(boxinfo = jp2_boxinfolookup(type))) {\n@@ -248,25 +261,22 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \tbox = 0;\n \ttmpstream = 0;\n \n-\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n+\tif (!(box = jp2_box_create0())) {\n \t\tgoto error;\n \t}\n-\n-\t// Mark the box data as never having been constructed\n-\t// so that we will not errantly attempt to destroy it later.\n-\tbox->ops = &jp2_boxinfo_unk.ops;\n-\n \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n \t\tgoto error;\n \t}\n \tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n \tbox->len = len;\n \tJAS_DBGLOG(10, (\n-\t  \""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\"",\n+\t  \""preliminary processing of JP2 box: \""\n+\t  \""type=%c%s%c (0x%08x); length=%\""PRIuFAST32\""\\n\"",\n \t  '\""', boxinfo->name, '\""', box->type, box->len\n \t  ));\n \tif (box->len == 1) {\n+\t\tJAS_DBGLOG(10, (\""big length\\n\""));\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n \t\t}\n@@ -382,6 +392,7 @@ static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n {\n \tjp2_bpcc_t *bpcc = &box->data.bpcc;\n \tunsigned int i;\n+\tbpcc->bpcs = 0;\n \tbpcc->numcmpts = box->datalen;\n \tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n \t\treturn -1;\n@@ -462,6 +473,7 @@ static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n \tjp2_cdef_t *cdef = &box->data.cdef;\n \tjp2_cdefchan_t *chan;\n \tunsigned int channo;\n+\tcdef->ents = 0;\n \tif (jp2_getuint16(in, &cdef->numchans)) {\n \t\treturn -1;\n \t}\n@@ -518,7 +530,9 @@ int jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n \t}\n \n \tif (dataflag) {\n-\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n+\t\tif (jas_stream_copy(out, tmpstream, box->len -\n+\t\t  JP2_BOX_HDRLEN(false))) {\n+\t\t\tjas_eprintf(\""cannot copy box data\\n\"");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_close(tmpstream);\n@@ -777,6 +791,7 @@ static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n \tjp2_cmap_t *cmap = &box->data.cmap;\n \tjp2_cmapent_t *ent;\n \tunsigned int i;\n+\tcmap->ents = 0;\n \n \tcmap->numchans = (box->datalen) / 4;\n \tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n@@ -835,6 +850,7 @@ static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n \tint_fast32_t x;\n \n \tpclr->lutdata = 0;\n+\tpclr->bpc = 0;\n \n \tif (jp2_getuint16(in, &pclr->numlutents) ||\n \t  jp2_getuint8(in, &pclr->numchans)) {\n@@ -869,9 +885,9 @@ static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n #if 0\n \tjp2_pclr_t *pclr = &box->data.pclr;\n #endif\n-/* Eliminate warning about unused variable. */\n-box = 0;\n-out = 0;\n+\t/* Eliminate warning about unused variable. */\n+\tbox = 0;\n+\tout = 0;\n \treturn -1;\n }\n ""}","jp2_box_t *jp2_box_get(jas_stream_t *in)
{
	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;
	jas_stream_t *tmpstream;
	uint_fast32_t len;
	uint_fast64_t extlen;
	bool dataflag;

 	box = 0;
 	tmpstream = 0;
 
	if (!(box = jp2_box_create0())) {
 		goto error;
 	}
 	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
 		goto error;
 	}
 	boxinfo = jp2_boxinfolookup(box->type);
 	box->info = boxinfo;
 	box->len = len;
 	JAS_DBGLOG(10, (
	  ""preliminary processing of JP2 box: ""
	  ""type=%c%s%c (0x%08x); length=%""PRIuFAST32""\n"",
 	  '""', boxinfo->name, '""', box->type, box->len
 	  ));
 	if (box->len == 1) {
		JAS_DBGLOG(10, (""big length\n""));
 		if (jp2_getuint64(in, &extlen)) {
 			goto error;
 		}
		if (extlen > 0xffffffffUL) {
			jas_eprintf(""warning: cannot handle large 64-bit box length\n"");
			extlen = 0xffffffffUL;
		}
		box->len = extlen;
		box->datalen = extlen - JP2_BOX_HDRLEN(true);
	} else {
		box->datalen = box->len - JP2_BOX_HDRLEN(false);
	}
	if (box->len != 0 && box->len < 8) {
		goto error;
	}

	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));

	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
			goto error;
		}
		if (jas_stream_copy(tmpstream, in, box->datalen)) {
			jas_eprintf(""cannot copy box data\n"");
			goto error;
		}
		jas_stream_rewind(tmpstream);

		box->ops = &boxinfo->ops;

		if (box->ops->getdata) {
			if ((*box->ops->getdata)(box, tmpstream)) {
				jas_eprintf(""cannot parse box data\n"");
				goto error;
			}
		}
		jas_stream_close(tmpstream);
	}

	if (jas_getdbglevel() >= 1) {
		jp2_box_dump(box, stderr);
	}

	return box;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (tmpstream) {
		jas_stream_close(tmpstream);
	}
	return 0;
}
","jp2_box_t *jp2_box_get(jas_stream_t *in)
{
	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;
	jas_stream_t *tmpstream;
	uint_fast32_t len;
	uint_fast64_t extlen;
	bool dataflag;

 	box = 0;
 	tmpstream = 0;
 
	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
 		goto error;
 	}
	box->ops = &jp2_boxinfo_unk.ops;
 	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
 		goto error;
 	}
 	boxinfo = jp2_boxinfolookup(box->type);
 	box->info = boxinfo;
 	box->len = len;
 	JAS_DBGLOG(10, (
	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
 	  '""', boxinfo->name, '""', box->type, box->len
 	  ));
 	if (box->len == 1) {
 		if (jp2_getuint64(in, &extlen)) {
 			goto error;
 		}
		if (extlen > 0xffffffffUL) {
			jas_eprintf(""warning: cannot handle large 64-bit box length\n"");
			extlen = 0xffffffffUL;
		}
		box->len = extlen;
		box->datalen = extlen - JP2_BOX_HDRLEN(true);
	} else {
		box->datalen = box->len - JP2_BOX_HDRLEN(false);
	}
	if (box->len != 0 && box->len < 8) {
		goto error;
	}

	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));

	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
			goto error;
		}
		if (jas_stream_copy(tmpstream, in, box->datalen)) {
			jas_eprintf(""cannot copy box data\n"");
			goto error;
		}
		jas_stream_rewind(tmpstream);

		box->ops = &boxinfo->ops;

		if (box->ops->getdata) {
			if ((*box->ops->getdata)(box, tmpstream)) {
				jas_eprintf(""cannot parse box data\n"");
				goto error;
			}
		}
		jas_stream_close(tmpstream);
	}

	if (jas_getdbglevel() >= 1) {
		jp2_box_dump(box, stderr);
	}

	return box;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (tmpstream) {
		jas_stream_close(tmpstream);
	}
	return 0;
}
",C,"	if (!(box = jp2_box_create0())) {
	  ""preliminary processing of JP2 box: ""
	  ""type=%c%s%c (0x%08x); length=%""PRIuFAST32""\n"",
		JAS_DBGLOG(10, (""big length\n""));
","	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
	box->ops = &jp2_boxinfo_unk.ops;
	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
",,"@@ -183,15 +183,28 @@ jp2_boxinfo_t jp2_boxinfo_unk = {
 * Box constructor.
 \******************************************************************************/
 
-jp2_box_t *jp2_box_create(int type)
+jp2_box_t *jp2_box_create0()
 {
 	jp2_box_t *box;
-	jp2_boxinfo_t *boxinfo;
-
 	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
 		return 0;
 	}
 	memset(box, 0, sizeof(jp2_box_t));
+	box->type = 0;
+	box->len = 0;
+	// Mark the box data as never having been constructed
+	// so that we will not errantly attempt to destroy it later.
+	box->ops = &jp2_boxinfo_unk.ops;
+	return box;
+}
+
+jp2_box_t *jp2_box_create(int type)
+{
+	jp2_box_t *box;
+	jp2_boxinfo_t *boxinfo;
+	if (!(box = jp2_box_create0())) {
+		return 0;
+	}
 	box->type = type;
 	box->len = 0;
 	if (!(boxinfo = jp2_boxinfolookup(type))) {
@@ -248,25 +261,22 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)
 	box = 0;
 	tmpstream = 0;
 
-	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
+	if (!(box = jp2_box_create0())) {
 		goto error;
 	}
-
-	// Mark the box data as never having been constructed
-	// so that we will not errantly attempt to destroy it later.
-	box->ops = &jp2_boxinfo_unk.ops;
-
 	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
 		goto error;
 	}
 	boxinfo = jp2_boxinfolookup(box->type);
 	box->info = boxinfo;
 	box->len = len;
 	JAS_DBGLOG(10, (
-	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
+	  ""preliminary processing of JP2 box: ""
+	  ""type=%c%s%c (0x%08x); length=%""PRIuFAST32""\n"",
 	  '""', boxinfo->name, '""', box->type, box->len
 	  ));
 	if (box->len == 1) {
+		JAS_DBGLOG(10, (""big length\n""));
 		if (jp2_getuint64(in, &extlen)) {
 			goto error;
 		}
@@ -382,6 +392,7 @@ static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)
 {
 	jp2_bpcc_t *bpcc = &box->data.bpcc;
 	unsigned int i;
+	bpcc->bpcs = 0;
 	bpcc->numcmpts = box->datalen;
 	if (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {
 		return -1;
@@ -462,6 +473,7 @@ static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)
 	jp2_cdef_t *cdef = &box->data.cdef;
 	jp2_cdefchan_t *chan;
 	unsigned int channo;
+	cdef->ents = 0;
 	if (jp2_getuint16(in, &cdef->numchans)) {
 		return -1;
 	}
@@ -518,7 +530,9 @@ int jp2_box_put(jp2_box_t *box, jas_stream_t *out)
 	}
 
 	if (dataflag) {
-		if (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {
+		if (jas_stream_copy(out, tmpstream, box->len -
+		  JP2_BOX_HDRLEN(false))) {
+			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}
 		jas_stream_close(tmpstream);
@@ -777,6 +791,7 @@ static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)
 	jp2_cmap_t *cmap = &box->data.cmap;
 	jp2_cmapent_t *ent;
 	unsigned int i;
+	cmap->ents = 0;
 
 	cmap->numchans = (box->datalen) / 4;
 	if (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {
@@ -835,6 +850,7 @@ static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)
 	int_fast32_t x;
 
 	pclr->lutdata = 0;
+	pclr->bpc = 0;
 
 	if (jp2_getuint16(in, &pclr->numlutents) ||
 	  jp2_getuint8(in, &pclr->numchans)) {
@@ -869,9 +885,9 @@ static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)
 #if 0
 	jp2_pclr_t *pclr = &box->data.pclr;
 #endif
-/* Eliminate warning about unused variable. */
-box = 0;
-out = 0;
+	/* Eliminate warning about unused variable. */
+	box = 0;
+	out = 0;
 	return -1;
 }
 ",jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,7692d6d1a0bfbd9a1d3f905337e3457cec39bced,1,"jp2_box_t *jp2_box_get(jas_stream_t *in)
{
	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;
	jas_stream_t *tmpstream;
	uint_fast32_t len;
	uint_fast64_t extlen;
	bool dataflag;

 	box = 0;
 	tmpstream = 0;
 
//flaw_line_below:
	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
//fix_flaw_line_below:
//	if (!(box = jp2_box_create0())) {
 		goto error;
 	}
//flaw_line_below:

//flaw_line_below:
	// Mark the box data as never having been constructed
//flaw_line_below:
	// so that we will not errantly attempt to destroy it later.
//flaw_line_below:
	box->ops = &jp2_boxinfo_unk.ops;
//flaw_line_below:

 	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
 		goto error;
 	}
 	boxinfo = jp2_boxinfolookup(box->type);
 	box->info = boxinfo;
 	box->len = len;
 	JAS_DBGLOG(10, (
//flaw_line_below:
	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
//fix_flaw_line_below:
//	  ""preliminary processing of JP2 box: ""
//fix_flaw_line_below:
//	  ""type=%c%s%c (0x%08x); length=%""PRIuFAST32""\n"",
 	  '""', boxinfo->name, '""', box->type, box->len
 	  ));
 	if (box->len == 1) {
//fix_flaw_line_below:
//		JAS_DBGLOG(10, (""big length\n""));
 		if (jp2_getuint64(in, &extlen)) {
 			goto error;
 		}
		if (extlen > 0xffffffffUL) {
			jas_eprintf(""warning: cannot handle large 64-bit box length\n"");
			extlen = 0xffffffffUL;
		}
		box->len = extlen;
		box->datalen = extlen - JP2_BOX_HDRLEN(true);
	} else {
		box->datalen = box->len - JP2_BOX_HDRLEN(false);
	}
	if (box->len != 0 && box->len < 8) {
		goto error;
	}

	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));

	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
			goto error;
		}
		if (jas_stream_copy(tmpstream, in, box->datalen)) {
			jas_eprintf(""cannot copy box data\n"");
			goto error;
		}
		jas_stream_rewind(tmpstream);

		// From here onwards, the box data will need to be destroyed.
		// So, initialize the box operations.
		box->ops = &boxinfo->ops;

		if (box->ops->getdata) {
			if ((*box->ops->getdata)(box, tmpstream)) {
				jas_eprintf(""cannot parse box data\n"");
				goto error;
			}
		}
		jas_stream_close(tmpstream);
	}

	if (jas_getdbglevel() >= 1) {
		jp2_box_dump(box, stderr);
	}

	return box;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (tmpstream) {
		jas_stream_close(tmpstream);
	}
	return 0;
}
"
3755,181491,,Remote,Not required,Partial,CVE-2017-6850,https://www.cvedetails.com/cve/CVE-2017-6850/,CWE-476,Medium,,,,2017-03-15,4.3,The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.,2018-06-28,DoS ,3,https://github.com/mdadams/jasper/commit/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"Fixed bugs due to uninitialized data in the JP2 decoder.
Also, added some comments marking I/O stream interfaces that probably
need to be changed (in the long term) to fix integer overflow problems.",1,src/libjasper/jp2/jp2_cod.c,"{""sha"": ""d70408fbb526d1d1e9166962eae9a2cf39179267"", ""filename"": ""src/libjasper/base/jas_stream.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 0, ""changes"": 18, ""blob_url"": ""https://github.com/mdadams/jasper/blob/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/base/jas_stream.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/base/jas_stream.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/base/jas_stream.c?ref=e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d"", ""patch"": ""@@ -664,6 +664,7 @@ int jas_stream_ungetc(jas_stream_t *stream, int c)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n {\n \tint n;\n@@ -690,6 +691,7 @@ int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n \treturn n;\n }\n \n+/* FIXME integral type */\n int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n {\n \tint n;\n@@ -742,6 +744,7 @@ int jas_stream_puts(jas_stream_t *stream, const char *s)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n {\n \tint c;\n@@ -765,6 +768,7 @@ char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n \treturn buf;\n }\n \n+/* FIXME integral type */\n int jas_stream_gobble(jas_stream_t *stream, int n)\n {\n \tint m;\n@@ -783,6 +787,7 @@ int jas_stream_gobble(jas_stream_t *stream, int n)\n \treturn n;\n }\n \n+/* FIXME integral type */\n int jas_stream_pad(jas_stream_t *stream, int n, int c)\n {\n \tint m;\n@@ -885,6 +890,7 @@ long jas_stream_tell(jas_stream_t *stream)\n * Buffer initialization code.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n   int bufsize)\n {\n@@ -1060,6 +1066,7 @@ static int jas_strtoopenmode(const char *s)\n \treturn openmode;\n }\n \n+/* FIXME integral type */\n int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n {\n \tint all;\n@@ -1085,6 +1092,7 @@ int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n long jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n {\n \tint old;\n@@ -1094,6 +1102,7 @@ long jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n \treturn old;\n }\n \n+/* FIXME integral type */\n int jas_stream_display(jas_stream_t *stream, FILE *fp, int n)\n {\n \tunsigned char buf[16];\n@@ -1168,6 +1177,7 @@ long jas_stream_length(jas_stream_t *stream)\n * Memory stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tssize_t n;\n@@ -1209,6 +1219,7 @@ static int mem_resize(jas_stream_memobj_t *m, size_t bufsize)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tsize_t n;\n@@ -1264,6 +1275,7 @@ static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn ret;\n }\n \n+/* FIXME integral type */\n static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n@@ -1310,6 +1322,7 @@ static int mem_close(jas_stream_obj_t *obj)\n * File stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1318,6 +1331,7 @@ static int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn read(fileobj->fd, buf, cnt);\n }\n \n+/* FIXME integral type */\n static int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1326,6 +1340,7 @@ static int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn write(fileobj->fd, buf, cnt);\n }\n \n+/* FIXME integral type */\n static long file_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1352,6 +1367,7 @@ static int file_close(jas_stream_obj_t *obj)\n * Stdio file stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tFILE *fp;\n@@ -1367,6 +1383,7 @@ static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn result;\n }\n \n+/* FIXME integral type */\n static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tFILE *fp;\n@@ -1377,6 +1394,7 @@ static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn (n != JAS_CAST(size_t, cnt)) ? (-1) : cnt;\n }\n \n+/* FIXME integral type */\n static long sfile_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tFILE *fp;""}<_**next**_>{""sha"": ""8d98a2cad438fac2f83c094515850f2d0aab3054"", ""filename"": ""src/libjasper/jp2/jp2_cod.c"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/mdadams/jasper/blob/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/jp2/jp2_cod.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/jp2/jp2_cod.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/jp2/jp2_cod.c?ref=e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d"", ""patch"": ""@@ -183,15 +183,28 @@ jp2_boxinfo_t jp2_boxinfo_unk = {\n * Box constructor.\n \\******************************************************************************/\n \n-jp2_box_t *jp2_box_create(int type)\n+jp2_box_t *jp2_box_create0()\n {\n \tjp2_box_t *box;\n-\tjp2_boxinfo_t *boxinfo;\n-\n \tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n \t\treturn 0;\n \t}\n \tmemset(box, 0, sizeof(jp2_box_t));\n+\tbox->type = 0;\n+\tbox->len = 0;\n+\t// Mark the box data as never having been constructed\n+\t// so that we will not errantly attempt to destroy it later.\n+\tbox->ops = &jp2_boxinfo_unk.ops;\n+\treturn box;\n+}\n+\n+jp2_box_t *jp2_box_create(int type)\n+{\n+\tjp2_box_t *box;\n+\tjp2_boxinfo_t *boxinfo;\n+\tif (!(box = jp2_box_create0())) {\n+\t\treturn 0;\n+\t}\n \tbox->type = type;\n \tbox->len = 0;\n \tif (!(boxinfo = jp2_boxinfolookup(type))) {\n@@ -248,25 +261,22 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \tbox = 0;\n \ttmpstream = 0;\n \n-\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n+\tif (!(box = jp2_box_create0())) {\n \t\tgoto error;\n \t}\n-\n-\t// Mark the box data as never having been constructed\n-\t// so that we will not errantly attempt to destroy it later.\n-\tbox->ops = &jp2_boxinfo_unk.ops;\n-\n \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n \t\tgoto error;\n \t}\n \tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n \tbox->len = len;\n \tJAS_DBGLOG(10, (\n-\t  \""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\"",\n+\t  \""preliminary processing of JP2 box: \""\n+\t  \""type=%c%s%c (0x%08x); length=%\""PRIuFAST32\""\\n\"",\n \t  '\""', boxinfo->name, '\""', box->type, box->len\n \t  ));\n \tif (box->len == 1) {\n+\t\tJAS_DBGLOG(10, (\""big length\\n\""));\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n \t\t}\n@@ -382,6 +392,7 @@ static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n {\n \tjp2_bpcc_t *bpcc = &box->data.bpcc;\n \tunsigned int i;\n+\tbpcc->bpcs = 0;\n \tbpcc->numcmpts = box->datalen;\n \tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n \t\treturn -1;\n@@ -462,6 +473,7 @@ static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n \tjp2_cdef_t *cdef = &box->data.cdef;\n \tjp2_cdefchan_t *chan;\n \tunsigned int channo;\n+\tcdef->ents = 0;\n \tif (jp2_getuint16(in, &cdef->numchans)) {\n \t\treturn -1;\n \t}\n@@ -518,7 +530,9 @@ int jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n \t}\n \n \tif (dataflag) {\n-\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n+\t\tif (jas_stream_copy(out, tmpstream, box->len -\n+\t\t  JP2_BOX_HDRLEN(false))) {\n+\t\t\tjas_eprintf(\""cannot copy box data\\n\"");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_close(tmpstream);\n@@ -777,6 +791,7 @@ static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n \tjp2_cmap_t *cmap = &box->data.cmap;\n \tjp2_cmapent_t *ent;\n \tunsigned int i;\n+\tcmap->ents = 0;\n \n \tcmap->numchans = (box->datalen) / 4;\n \tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n@@ -835,6 +850,7 @@ static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n \tint_fast32_t x;\n \n \tpclr->lutdata = 0;\n+\tpclr->bpc = 0;\n \n \tif (jp2_getuint16(in, &pclr->numlutents) ||\n \t  jp2_getuint8(in, &pclr->numchans)) {\n@@ -869,9 +885,9 @@ static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n #if 0\n \tjp2_pclr_t *pclr = &box->data.pclr;\n #endif\n-/* Eliminate warning about unused variable. */\n-box = 0;\n-out = 0;\n+\t/* Eliminate warning about unused variable. */\n+\tbox = 0;\n+\tout = 0;\n \treturn -1;\n }\n ""}","int jp2_box_put(jp2_box_t *box, jas_stream_t *out)
{
	jas_stream_t *tmpstream;
	bool extlen;
	bool dataflag;

	tmpstream = 0;

	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));

	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
			goto error;
		}
		if (box->ops->putdata) {
			if ((*box->ops->putdata)(box, tmpstream)) {
				goto error;
			}
		}
		box->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);
		jas_stream_rewind(tmpstream);
	}
	extlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;
	if (jp2_putuint32(out, extlen ? 1 : box->len)) {
		goto error;
	}
	if (jp2_putuint32(out, box->type)) {
		goto error;
	}
	if (extlen) {
		if (jp2_putuint64(out, box->len)) {
			goto error;
		}
 	}
 
 	if (dataflag) {
		if (jas_stream_copy(out, tmpstream, box->len -
		  JP2_BOX_HDRLEN(false))) {
			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}
 		jas_stream_close(tmpstream);
	}

	return 0;

error:

	if (tmpstream) {
		jas_stream_close(tmpstream);
	}
	return -1;
}
","int jp2_box_put(jp2_box_t *box, jas_stream_t *out)
{
	jas_stream_t *tmpstream;
	bool extlen;
	bool dataflag;

	tmpstream = 0;

	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));

	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
			goto error;
		}
		if (box->ops->putdata) {
			if ((*box->ops->putdata)(box, tmpstream)) {
				goto error;
			}
		}
		box->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);
		jas_stream_rewind(tmpstream);
	}
	extlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;
	if (jp2_putuint32(out, extlen ? 1 : box->len)) {
		goto error;
	}
	if (jp2_putuint32(out, box->type)) {
		goto error;
	}
	if (extlen) {
		if (jp2_putuint64(out, box->len)) {
			goto error;
		}
 	}
 
 	if (dataflag) {
		if (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {
 			goto error;
 		}
 		jas_stream_close(tmpstream);
	}

	return 0;

error:

	if (tmpstream) {
		jas_stream_close(tmpstream);
	}
	return -1;
}
",C,"		if (jas_stream_copy(out, tmpstream, box->len -
		  JP2_BOX_HDRLEN(false))) {
			jas_eprintf(""cannot copy box data\n"");
","		if (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {
",,"@@ -183,15 +183,28 @@ jp2_boxinfo_t jp2_boxinfo_unk = {
 * Box constructor.
 \******************************************************************************/
 
-jp2_box_t *jp2_box_create(int type)
+jp2_box_t *jp2_box_create0()
 {
 	jp2_box_t *box;
-	jp2_boxinfo_t *boxinfo;
-
 	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
 		return 0;
 	}
 	memset(box, 0, sizeof(jp2_box_t));
+	box->type = 0;
+	box->len = 0;
+	// Mark the box data as never having been constructed
+	// so that we will not errantly attempt to destroy it later.
+	box->ops = &jp2_boxinfo_unk.ops;
+	return box;
+}
+
+jp2_box_t *jp2_box_create(int type)
+{
+	jp2_box_t *box;
+	jp2_boxinfo_t *boxinfo;
+	if (!(box = jp2_box_create0())) {
+		return 0;
+	}
 	box->type = type;
 	box->len = 0;
 	if (!(boxinfo = jp2_boxinfolookup(type))) {
@@ -248,25 +261,22 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)
 	box = 0;
 	tmpstream = 0;
 
-	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
+	if (!(box = jp2_box_create0())) {
 		goto error;
 	}
-
-	// Mark the box data as never having been constructed
-	// so that we will not errantly attempt to destroy it later.
-	box->ops = &jp2_boxinfo_unk.ops;
-
 	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
 		goto error;
 	}
 	boxinfo = jp2_boxinfolookup(box->type);
 	box->info = boxinfo;
 	box->len = len;
 	JAS_DBGLOG(10, (
-	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
+	  ""preliminary processing of JP2 box: ""
+	  ""type=%c%s%c (0x%08x); length=%""PRIuFAST32""\n"",
 	  '""', boxinfo->name, '""', box->type, box->len
 	  ));
 	if (box->len == 1) {
+		JAS_DBGLOG(10, (""big length\n""));
 		if (jp2_getuint64(in, &extlen)) {
 			goto error;
 		}
@@ -382,6 +392,7 @@ static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)
 {
 	jp2_bpcc_t *bpcc = &box->data.bpcc;
 	unsigned int i;
+	bpcc->bpcs = 0;
 	bpcc->numcmpts = box->datalen;
 	if (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {
 		return -1;
@@ -462,6 +473,7 @@ static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)
 	jp2_cdef_t *cdef = &box->data.cdef;
 	jp2_cdefchan_t *chan;
 	unsigned int channo;
+	cdef->ents = 0;
 	if (jp2_getuint16(in, &cdef->numchans)) {
 		return -1;
 	}
@@ -518,7 +530,9 @@ int jp2_box_put(jp2_box_t *box, jas_stream_t *out)
 	}
 
 	if (dataflag) {
-		if (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {
+		if (jas_stream_copy(out, tmpstream, box->len -
+		  JP2_BOX_HDRLEN(false))) {
+			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}
 		jas_stream_close(tmpstream);
@@ -777,6 +791,7 @@ static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)
 	jp2_cmap_t *cmap = &box->data.cmap;
 	jp2_cmapent_t *ent;
 	unsigned int i;
+	cmap->ents = 0;
 
 	cmap->numchans = (box->datalen) / 4;
 	if (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {
@@ -835,6 +850,7 @@ static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)
 	int_fast32_t x;
 
 	pclr->lutdata = 0;
+	pclr->bpc = 0;
 
 	if (jp2_getuint16(in, &pclr->numlutents) ||
 	  jp2_getuint8(in, &pclr->numchans)) {
@@ -869,9 +885,9 @@ static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)
 #if 0
 	jp2_pclr_t *pclr = &box->data.pclr;
 #endif
-/* Eliminate warning about unused variable. */
-box = 0;
-out = 0;
+	/* Eliminate warning about unused variable. */
+	box = 0;
+	out = 0;
 	return -1;
 }
 ",jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,7692d6d1a0bfbd9a1d3f905337e3457cec39bced,1,"int jp2_box_put(jp2_box_t *box, jas_stream_t *out)
{
	jas_stream_t *tmpstream;
	bool extlen;
	bool dataflag;

	tmpstream = 0;

	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));

	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
			goto error;
		}
		if (box->ops->putdata) {
			if ((*box->ops->putdata)(box, tmpstream)) {
				goto error;
			}
		}
		box->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);
		jas_stream_rewind(tmpstream);
	}
	extlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;
	if (jp2_putuint32(out, extlen ? 1 : box->len)) {
		goto error;
	}
	if (jp2_putuint32(out, box->type)) {
		goto error;
	}
	if (extlen) {
		if (jp2_putuint64(out, box->len)) {
			goto error;
		}
 	}
 
 	if (dataflag) {
//flaw_line_below:
		if (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {
//fix_flaw_line_below:
//		if (jas_stream_copy(out, tmpstream, box->len -
//fix_flaw_line_below:
//		  JP2_BOX_HDRLEN(false))) {
//fix_flaw_line_below:
//			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}
 		jas_stream_close(tmpstream);
	}

	return 0;

error:

	if (tmpstream) {
		jas_stream_close(tmpstream);
	}
	return -1;
}
"
3756,181492,,Remote,Not required,Partial,CVE-2017-6850,https://www.cvedetails.com/cve/CVE-2017-6850/,CWE-476,Medium,,,,2017-03-15,4.3,The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.,2018-06-28,DoS ,1,https://github.com/mdadams/jasper/commit/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"Fixed bugs due to uninitialized data in the JP2 decoder.
Also, added some comments marking I/O stream interfaces that probably
need to be changed (in the long term) to fix integer overflow problems.",0,src/libjasper/jp2/jp2_cod.c,"{""sha"": ""d70408fbb526d1d1e9166962eae9a2cf39179267"", ""filename"": ""src/libjasper/base/jas_stream.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 0, ""changes"": 18, ""blob_url"": ""https://github.com/mdadams/jasper/blob/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/base/jas_stream.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/base/jas_stream.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/base/jas_stream.c?ref=e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d"", ""patch"": ""@@ -664,6 +664,7 @@ int jas_stream_ungetc(jas_stream_t *stream, int c)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n {\n \tint n;\n@@ -690,6 +691,7 @@ int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n \treturn n;\n }\n \n+/* FIXME integral type */\n int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n {\n \tint n;\n@@ -742,6 +744,7 @@ int jas_stream_puts(jas_stream_t *stream, const char *s)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n {\n \tint c;\n@@ -765,6 +768,7 @@ char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n \treturn buf;\n }\n \n+/* FIXME integral type */\n int jas_stream_gobble(jas_stream_t *stream, int n)\n {\n \tint m;\n@@ -783,6 +787,7 @@ int jas_stream_gobble(jas_stream_t *stream, int n)\n \treturn n;\n }\n \n+/* FIXME integral type */\n int jas_stream_pad(jas_stream_t *stream, int n, int c)\n {\n \tint m;\n@@ -885,6 +890,7 @@ long jas_stream_tell(jas_stream_t *stream)\n * Buffer initialization code.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n   int bufsize)\n {\n@@ -1060,6 +1066,7 @@ static int jas_strtoopenmode(const char *s)\n \treturn openmode;\n }\n \n+/* FIXME integral type */\n int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n {\n \tint all;\n@@ -1085,6 +1092,7 @@ int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n long jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n {\n \tint old;\n@@ -1094,6 +1102,7 @@ long jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n \treturn old;\n }\n \n+/* FIXME integral type */\n int jas_stream_display(jas_stream_t *stream, FILE *fp, int n)\n {\n \tunsigned char buf[16];\n@@ -1168,6 +1177,7 @@ long jas_stream_length(jas_stream_t *stream)\n * Memory stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tssize_t n;\n@@ -1209,6 +1219,7 @@ static int mem_resize(jas_stream_memobj_t *m, size_t bufsize)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tsize_t n;\n@@ -1264,6 +1275,7 @@ static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn ret;\n }\n \n+/* FIXME integral type */\n static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n@@ -1310,6 +1322,7 @@ static int mem_close(jas_stream_obj_t *obj)\n * File stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1318,6 +1331,7 @@ static int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn read(fileobj->fd, buf, cnt);\n }\n \n+/* FIXME integral type */\n static int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1326,6 +1340,7 @@ static int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn write(fileobj->fd, buf, cnt);\n }\n \n+/* FIXME integral type */\n static long file_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1352,6 +1367,7 @@ static int file_close(jas_stream_obj_t *obj)\n * Stdio file stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tFILE *fp;\n@@ -1367,6 +1383,7 @@ static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn result;\n }\n \n+/* FIXME integral type */\n static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tFILE *fp;\n@@ -1377,6 +1394,7 @@ static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn (n != JAS_CAST(size_t, cnt)) ? (-1) : cnt;\n }\n \n+/* FIXME integral type */\n static long sfile_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tFILE *fp;""}<_**next**_>{""sha"": ""8d98a2cad438fac2f83c094515850f2d0aab3054"", ""filename"": ""src/libjasper/jp2/jp2_cod.c"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/mdadams/jasper/blob/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/jp2/jp2_cod.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/jp2/jp2_cod.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/jp2/jp2_cod.c?ref=e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d"", ""patch"": ""@@ -183,15 +183,28 @@ jp2_boxinfo_t jp2_boxinfo_unk = {\n * Box constructor.\n \\******************************************************************************/\n \n-jp2_box_t *jp2_box_create(int type)\n+jp2_box_t *jp2_box_create0()\n {\n \tjp2_box_t *box;\n-\tjp2_boxinfo_t *boxinfo;\n-\n \tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n \t\treturn 0;\n \t}\n \tmemset(box, 0, sizeof(jp2_box_t));\n+\tbox->type = 0;\n+\tbox->len = 0;\n+\t// Mark the box data as never having been constructed\n+\t// so that we will not errantly attempt to destroy it later.\n+\tbox->ops = &jp2_boxinfo_unk.ops;\n+\treturn box;\n+}\n+\n+jp2_box_t *jp2_box_create(int type)\n+{\n+\tjp2_box_t *box;\n+\tjp2_boxinfo_t *boxinfo;\n+\tif (!(box = jp2_box_create0())) {\n+\t\treturn 0;\n+\t}\n \tbox->type = type;\n \tbox->len = 0;\n \tif (!(boxinfo = jp2_boxinfolookup(type))) {\n@@ -248,25 +261,22 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \tbox = 0;\n \ttmpstream = 0;\n \n-\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n+\tif (!(box = jp2_box_create0())) {\n \t\tgoto error;\n \t}\n-\n-\t// Mark the box data as never having been constructed\n-\t// so that we will not errantly attempt to destroy it later.\n-\tbox->ops = &jp2_boxinfo_unk.ops;\n-\n \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n \t\tgoto error;\n \t}\n \tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n \tbox->len = len;\n \tJAS_DBGLOG(10, (\n-\t  \""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\"",\n+\t  \""preliminary processing of JP2 box: \""\n+\t  \""type=%c%s%c (0x%08x); length=%\""PRIuFAST32\""\\n\"",\n \t  '\""', boxinfo->name, '\""', box->type, box->len\n \t  ));\n \tif (box->len == 1) {\n+\t\tJAS_DBGLOG(10, (\""big length\\n\""));\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n \t\t}\n@@ -382,6 +392,7 @@ static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n {\n \tjp2_bpcc_t *bpcc = &box->data.bpcc;\n \tunsigned int i;\n+\tbpcc->bpcs = 0;\n \tbpcc->numcmpts = box->datalen;\n \tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n \t\treturn -1;\n@@ -462,6 +473,7 @@ static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n \tjp2_cdef_t *cdef = &box->data.cdef;\n \tjp2_cdefchan_t *chan;\n \tunsigned int channo;\n+\tcdef->ents = 0;\n \tif (jp2_getuint16(in, &cdef->numchans)) {\n \t\treturn -1;\n \t}\n@@ -518,7 +530,9 @@ int jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n \t}\n \n \tif (dataflag) {\n-\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n+\t\tif (jas_stream_copy(out, tmpstream, box->len -\n+\t\t  JP2_BOX_HDRLEN(false))) {\n+\t\t\tjas_eprintf(\""cannot copy box data\\n\"");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_close(tmpstream);\n@@ -777,6 +791,7 @@ static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n \tjp2_cmap_t *cmap = &box->data.cmap;\n \tjp2_cmapent_t *ent;\n \tunsigned int i;\n+\tcmap->ents = 0;\n \n \tcmap->numchans = (box->datalen) / 4;\n \tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n@@ -835,6 +850,7 @@ static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n \tint_fast32_t x;\n \n \tpclr->lutdata = 0;\n+\tpclr->bpc = 0;\n \n \tif (jp2_getuint16(in, &pclr->numlutents) ||\n \t  jp2_getuint8(in, &pclr->numchans)) {\n@@ -869,9 +885,9 @@ static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n #if 0\n \tjp2_pclr_t *pclr = &box->data.pclr;\n #endif\n-/* Eliminate warning about unused variable. */\n-box = 0;\n-out = 0;\n+\t/* Eliminate warning about unused variable. */\n+\tbox = 0;\n+\tout = 0;\n \treturn -1;\n }\n ""}","static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)
 {
 	jp2_bpcc_t *bpcc = &box->data.bpcc;
 	unsigned int i;
	bpcc->bpcs = 0;
 	bpcc->numcmpts = box->datalen;
 	if (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {
 		return -1;
	}
	for (i = 0; i < bpcc->numcmpts; ++i) {
		if (jp2_getuint8(in, &bpcc->bpcs[i])) {
			return -1;
		}
	}
	return 0;
}
","static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)
 {
 	jp2_bpcc_t *bpcc = &box->data.bpcc;
 	unsigned int i;
 	bpcc->numcmpts = box->datalen;
 	if (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {
 		return -1;
	}
	for (i = 0; i < bpcc->numcmpts; ++i) {
		if (jp2_getuint8(in, &bpcc->bpcs[i])) {
			return -1;
		}
	}
	return 0;
}
",C,"	bpcc->bpcs = 0;
",,,"@@ -183,15 +183,28 @@ jp2_boxinfo_t jp2_boxinfo_unk = {
 * Box constructor.
 \******************************************************************************/
 
-jp2_box_t *jp2_box_create(int type)
+jp2_box_t *jp2_box_create0()
 {
 	jp2_box_t *box;
-	jp2_boxinfo_t *boxinfo;
-
 	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
 		return 0;
 	}
 	memset(box, 0, sizeof(jp2_box_t));
+	box->type = 0;
+	box->len = 0;
+	// Mark the box data as never having been constructed
+	// so that we will not errantly attempt to destroy it later.
+	box->ops = &jp2_boxinfo_unk.ops;
+	return box;
+}
+
+jp2_box_t *jp2_box_create(int type)
+{
+	jp2_box_t *box;
+	jp2_boxinfo_t *boxinfo;
+	if (!(box = jp2_box_create0())) {
+		return 0;
+	}
 	box->type = type;
 	box->len = 0;
 	if (!(boxinfo = jp2_boxinfolookup(type))) {
@@ -248,25 +261,22 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)
 	box = 0;
 	tmpstream = 0;
 
-	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
+	if (!(box = jp2_box_create0())) {
 		goto error;
 	}
-
-	// Mark the box data as never having been constructed
-	// so that we will not errantly attempt to destroy it later.
-	box->ops = &jp2_boxinfo_unk.ops;
-
 	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
 		goto error;
 	}
 	boxinfo = jp2_boxinfolookup(box->type);
 	box->info = boxinfo;
 	box->len = len;
 	JAS_DBGLOG(10, (
-	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
+	  ""preliminary processing of JP2 box: ""
+	  ""type=%c%s%c (0x%08x); length=%""PRIuFAST32""\n"",
 	  '""', boxinfo->name, '""', box->type, box->len
 	  ));
 	if (box->len == 1) {
+		JAS_DBGLOG(10, (""big length\n""));
 		if (jp2_getuint64(in, &extlen)) {
 			goto error;
 		}
@@ -382,6 +392,7 @@ static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)
 {
 	jp2_bpcc_t *bpcc = &box->data.bpcc;
 	unsigned int i;
+	bpcc->bpcs = 0;
 	bpcc->numcmpts = box->datalen;
 	if (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {
 		return -1;
@@ -462,6 +473,7 @@ static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)
 	jp2_cdef_t *cdef = &box->data.cdef;
 	jp2_cdefchan_t *chan;
 	unsigned int channo;
+	cdef->ents = 0;
 	if (jp2_getuint16(in, &cdef->numchans)) {
 		return -1;
 	}
@@ -518,7 +530,9 @@ int jp2_box_put(jp2_box_t *box, jas_stream_t *out)
 	}
 
 	if (dataflag) {
-		if (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {
+		if (jas_stream_copy(out, tmpstream, box->len -
+		  JP2_BOX_HDRLEN(false))) {
+			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}
 		jas_stream_close(tmpstream);
@@ -777,6 +791,7 @@ static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)
 	jp2_cmap_t *cmap = &box->data.cmap;
 	jp2_cmapent_t *ent;
 	unsigned int i;
+	cmap->ents = 0;
 
 	cmap->numchans = (box->datalen) / 4;
 	if (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {
@@ -835,6 +850,7 @@ static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)
 	int_fast32_t x;
 
 	pclr->lutdata = 0;
+	pclr->bpc = 0;
 
 	if (jp2_getuint16(in, &pclr->numlutents) ||
 	  jp2_getuint8(in, &pclr->numchans)) {
@@ -869,9 +885,9 @@ static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)
 #if 0
 	jp2_pclr_t *pclr = &box->data.pclr;
 #endif
-/* Eliminate warning about unused variable. */
-box = 0;
-out = 0;
+	/* Eliminate warning about unused variable. */
+	box = 0;
+	out = 0;
 	return -1;
 }
 ",jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,7692d6d1a0bfbd9a1d3f905337e3457cec39bced,1,"static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)
 {
 	jp2_bpcc_t *bpcc = &box->data.bpcc;
 	unsigned int i;
//fix_flaw_line_below:
//	bpcc->bpcs = 0;
 	bpcc->numcmpts = box->datalen;
 	if (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {
 		return -1;
	}
	for (i = 0; i < bpcc->numcmpts; ++i) {
		if (jp2_getuint8(in, &bpcc->bpcs[i])) {
			return -1;
		}
	}
	return 0;
}
"
3757,181493,,Remote,Not required,Partial,CVE-2017-6850,https://www.cvedetails.com/cve/CVE-2017-6850/,CWE-476,Medium,,,,2017-03-15,4.3,The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.,2018-06-28,DoS ,1,https://github.com/mdadams/jasper/commit/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"Fixed bugs due to uninitialized data in the JP2 decoder.
Also, added some comments marking I/O stream interfaces that probably
need to be changed (in the long term) to fix integer overflow problems.",0,src/libjasper/jp2/jp2_cod.c,"{""sha"": ""d70408fbb526d1d1e9166962eae9a2cf39179267"", ""filename"": ""src/libjasper/base/jas_stream.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 0, ""changes"": 18, ""blob_url"": ""https://github.com/mdadams/jasper/blob/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/base/jas_stream.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/base/jas_stream.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/base/jas_stream.c?ref=e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d"", ""patch"": ""@@ -664,6 +664,7 @@ int jas_stream_ungetc(jas_stream_t *stream, int c)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n {\n \tint n;\n@@ -690,6 +691,7 @@ int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n \treturn n;\n }\n \n+/* FIXME integral type */\n int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n {\n \tint n;\n@@ -742,6 +744,7 @@ int jas_stream_puts(jas_stream_t *stream, const char *s)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n {\n \tint c;\n@@ -765,6 +768,7 @@ char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n \treturn buf;\n }\n \n+/* FIXME integral type */\n int jas_stream_gobble(jas_stream_t *stream, int n)\n {\n \tint m;\n@@ -783,6 +787,7 @@ int jas_stream_gobble(jas_stream_t *stream, int n)\n \treturn n;\n }\n \n+/* FIXME integral type */\n int jas_stream_pad(jas_stream_t *stream, int n, int c)\n {\n \tint m;\n@@ -885,6 +890,7 @@ long jas_stream_tell(jas_stream_t *stream)\n * Buffer initialization code.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n   int bufsize)\n {\n@@ -1060,6 +1066,7 @@ static int jas_strtoopenmode(const char *s)\n \treturn openmode;\n }\n \n+/* FIXME integral type */\n int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n {\n \tint all;\n@@ -1085,6 +1092,7 @@ int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n long jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n {\n \tint old;\n@@ -1094,6 +1102,7 @@ long jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n \treturn old;\n }\n \n+/* FIXME integral type */\n int jas_stream_display(jas_stream_t *stream, FILE *fp, int n)\n {\n \tunsigned char buf[16];\n@@ -1168,6 +1177,7 @@ long jas_stream_length(jas_stream_t *stream)\n * Memory stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tssize_t n;\n@@ -1209,6 +1219,7 @@ static int mem_resize(jas_stream_memobj_t *m, size_t bufsize)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tsize_t n;\n@@ -1264,6 +1275,7 @@ static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn ret;\n }\n \n+/* FIXME integral type */\n static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n@@ -1310,6 +1322,7 @@ static int mem_close(jas_stream_obj_t *obj)\n * File stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1318,6 +1331,7 @@ static int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn read(fileobj->fd, buf, cnt);\n }\n \n+/* FIXME integral type */\n static int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1326,6 +1340,7 @@ static int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn write(fileobj->fd, buf, cnt);\n }\n \n+/* FIXME integral type */\n static long file_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1352,6 +1367,7 @@ static int file_close(jas_stream_obj_t *obj)\n * Stdio file stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tFILE *fp;\n@@ -1367,6 +1383,7 @@ static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn result;\n }\n \n+/* FIXME integral type */\n static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tFILE *fp;\n@@ -1377,6 +1394,7 @@ static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn (n != JAS_CAST(size_t, cnt)) ? (-1) : cnt;\n }\n \n+/* FIXME integral type */\n static long sfile_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tFILE *fp;""}<_**next**_>{""sha"": ""8d98a2cad438fac2f83c094515850f2d0aab3054"", ""filename"": ""src/libjasper/jp2/jp2_cod.c"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/mdadams/jasper/blob/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/jp2/jp2_cod.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/jp2/jp2_cod.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/jp2/jp2_cod.c?ref=e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d"", ""patch"": ""@@ -183,15 +183,28 @@ jp2_boxinfo_t jp2_boxinfo_unk = {\n * Box constructor.\n \\******************************************************************************/\n \n-jp2_box_t *jp2_box_create(int type)\n+jp2_box_t *jp2_box_create0()\n {\n \tjp2_box_t *box;\n-\tjp2_boxinfo_t *boxinfo;\n-\n \tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n \t\treturn 0;\n \t}\n \tmemset(box, 0, sizeof(jp2_box_t));\n+\tbox->type = 0;\n+\tbox->len = 0;\n+\t// Mark the box data as never having been constructed\n+\t// so that we will not errantly attempt to destroy it later.\n+\tbox->ops = &jp2_boxinfo_unk.ops;\n+\treturn box;\n+}\n+\n+jp2_box_t *jp2_box_create(int type)\n+{\n+\tjp2_box_t *box;\n+\tjp2_boxinfo_t *boxinfo;\n+\tif (!(box = jp2_box_create0())) {\n+\t\treturn 0;\n+\t}\n \tbox->type = type;\n \tbox->len = 0;\n \tif (!(boxinfo = jp2_boxinfolookup(type))) {\n@@ -248,25 +261,22 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \tbox = 0;\n \ttmpstream = 0;\n \n-\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n+\tif (!(box = jp2_box_create0())) {\n \t\tgoto error;\n \t}\n-\n-\t// Mark the box data as never having been constructed\n-\t// so that we will not errantly attempt to destroy it later.\n-\tbox->ops = &jp2_boxinfo_unk.ops;\n-\n \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n \t\tgoto error;\n \t}\n \tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n \tbox->len = len;\n \tJAS_DBGLOG(10, (\n-\t  \""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\"",\n+\t  \""preliminary processing of JP2 box: \""\n+\t  \""type=%c%s%c (0x%08x); length=%\""PRIuFAST32\""\\n\"",\n \t  '\""', boxinfo->name, '\""', box->type, box->len\n \t  ));\n \tif (box->len == 1) {\n+\t\tJAS_DBGLOG(10, (\""big length\\n\""));\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n \t\t}\n@@ -382,6 +392,7 @@ static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n {\n \tjp2_bpcc_t *bpcc = &box->data.bpcc;\n \tunsigned int i;\n+\tbpcc->bpcs = 0;\n \tbpcc->numcmpts = box->datalen;\n \tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n \t\treturn -1;\n@@ -462,6 +473,7 @@ static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n \tjp2_cdef_t *cdef = &box->data.cdef;\n \tjp2_cdefchan_t *chan;\n \tunsigned int channo;\n+\tcdef->ents = 0;\n \tif (jp2_getuint16(in, &cdef->numchans)) {\n \t\treturn -1;\n \t}\n@@ -518,7 +530,9 @@ int jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n \t}\n \n \tif (dataflag) {\n-\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n+\t\tif (jas_stream_copy(out, tmpstream, box->len -\n+\t\t  JP2_BOX_HDRLEN(false))) {\n+\t\t\tjas_eprintf(\""cannot copy box data\\n\"");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_close(tmpstream);\n@@ -777,6 +791,7 @@ static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n \tjp2_cmap_t *cmap = &box->data.cmap;\n \tjp2_cmapent_t *ent;\n \tunsigned int i;\n+\tcmap->ents = 0;\n \n \tcmap->numchans = (box->datalen) / 4;\n \tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n@@ -835,6 +850,7 @@ static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n \tint_fast32_t x;\n \n \tpclr->lutdata = 0;\n+\tpclr->bpc = 0;\n \n \tif (jp2_getuint16(in, &pclr->numlutents) ||\n \t  jp2_getuint8(in, &pclr->numchans)) {\n@@ -869,9 +885,9 @@ static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n #if 0\n \tjp2_pclr_t *pclr = &box->data.pclr;\n #endif\n-/* Eliminate warning about unused variable. */\n-box = 0;\n-out = 0;\n+\t/* Eliminate warning about unused variable. */\n+\tbox = 0;\n+\tout = 0;\n \treturn -1;\n }\n ""}","static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)
{
 	jp2_cdef_t *cdef = &box->data.cdef;
 	jp2_cdefchan_t *chan;
 	unsigned int channo;
	cdef->ents = 0;
 	if (jp2_getuint16(in, &cdef->numchans)) {
 		return -1;
 	}
	if (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {
		return -1;
	}
	for (channo = 0; channo < cdef->numchans; ++channo) {
		chan = &cdef->ents[channo];
		if (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||
		  jp2_getuint16(in, &chan->assoc)) {
			return -1;
		}
	}
	return 0;
}
","static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)
{
 	jp2_cdef_t *cdef = &box->data.cdef;
 	jp2_cdefchan_t *chan;
 	unsigned int channo;
 	if (jp2_getuint16(in, &cdef->numchans)) {
 		return -1;
 	}
	if (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {
		return -1;
	}
	for (channo = 0; channo < cdef->numchans; ++channo) {
		chan = &cdef->ents[channo];
		if (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||
		  jp2_getuint16(in, &chan->assoc)) {
			return -1;
		}
	}
	return 0;
}
",C,"	cdef->ents = 0;
",,,"@@ -183,15 +183,28 @@ jp2_boxinfo_t jp2_boxinfo_unk = {
 * Box constructor.
 \******************************************************************************/
 
-jp2_box_t *jp2_box_create(int type)
+jp2_box_t *jp2_box_create0()
 {
 	jp2_box_t *box;
-	jp2_boxinfo_t *boxinfo;
-
 	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
 		return 0;
 	}
 	memset(box, 0, sizeof(jp2_box_t));
+	box->type = 0;
+	box->len = 0;
+	// Mark the box data as never having been constructed
+	// so that we will not errantly attempt to destroy it later.
+	box->ops = &jp2_boxinfo_unk.ops;
+	return box;
+}
+
+jp2_box_t *jp2_box_create(int type)
+{
+	jp2_box_t *box;
+	jp2_boxinfo_t *boxinfo;
+	if (!(box = jp2_box_create0())) {
+		return 0;
+	}
 	box->type = type;
 	box->len = 0;
 	if (!(boxinfo = jp2_boxinfolookup(type))) {
@@ -248,25 +261,22 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)
 	box = 0;
 	tmpstream = 0;
 
-	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
+	if (!(box = jp2_box_create0())) {
 		goto error;
 	}
-
-	// Mark the box data as never having been constructed
-	// so that we will not errantly attempt to destroy it later.
-	box->ops = &jp2_boxinfo_unk.ops;
-
 	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
 		goto error;
 	}
 	boxinfo = jp2_boxinfolookup(box->type);
 	box->info = boxinfo;
 	box->len = len;
 	JAS_DBGLOG(10, (
-	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
+	  ""preliminary processing of JP2 box: ""
+	  ""type=%c%s%c (0x%08x); length=%""PRIuFAST32""\n"",
 	  '""', boxinfo->name, '""', box->type, box->len
 	  ));
 	if (box->len == 1) {
+		JAS_DBGLOG(10, (""big length\n""));
 		if (jp2_getuint64(in, &extlen)) {
 			goto error;
 		}
@@ -382,6 +392,7 @@ static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)
 {
 	jp2_bpcc_t *bpcc = &box->data.bpcc;
 	unsigned int i;
+	bpcc->bpcs = 0;
 	bpcc->numcmpts = box->datalen;
 	if (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {
 		return -1;
@@ -462,6 +473,7 @@ static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)
 	jp2_cdef_t *cdef = &box->data.cdef;
 	jp2_cdefchan_t *chan;
 	unsigned int channo;
+	cdef->ents = 0;
 	if (jp2_getuint16(in, &cdef->numchans)) {
 		return -1;
 	}
@@ -518,7 +530,9 @@ int jp2_box_put(jp2_box_t *box, jas_stream_t *out)
 	}
 
 	if (dataflag) {
-		if (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {
+		if (jas_stream_copy(out, tmpstream, box->len -
+		  JP2_BOX_HDRLEN(false))) {
+			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}
 		jas_stream_close(tmpstream);
@@ -777,6 +791,7 @@ static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)
 	jp2_cmap_t *cmap = &box->data.cmap;
 	jp2_cmapent_t *ent;
 	unsigned int i;
+	cmap->ents = 0;
 
 	cmap->numchans = (box->datalen) / 4;
 	if (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {
@@ -835,6 +850,7 @@ static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)
 	int_fast32_t x;
 
 	pclr->lutdata = 0;
+	pclr->bpc = 0;
 
 	if (jp2_getuint16(in, &pclr->numlutents) ||
 	  jp2_getuint8(in, &pclr->numchans)) {
@@ -869,9 +885,9 @@ static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)
 #if 0
 	jp2_pclr_t *pclr = &box->data.pclr;
 #endif
-/* Eliminate warning about unused variable. */
-box = 0;
-out = 0;
+	/* Eliminate warning about unused variable. */
+	box = 0;
+	out = 0;
 	return -1;
 }
 ",jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,7692d6d1a0bfbd9a1d3f905337e3457cec39bced,1,"static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)
{
 	jp2_cdef_t *cdef = &box->data.cdef;
 	jp2_cdefchan_t *chan;
 	unsigned int channo;
//fix_flaw_line_below:
//	cdef->ents = 0;
 	if (jp2_getuint16(in, &cdef->numchans)) {
 		return -1;
 	}
	if (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {
		return -1;
	}
	for (channo = 0; channo < cdef->numchans; ++channo) {
		chan = &cdef->ents[channo];
		if (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||
		  jp2_getuint16(in, &chan->assoc)) {
			return -1;
		}
	}
	return 0;
}
"
3758,181494,,Remote,Not required,Partial,CVE-2017-6850,https://www.cvedetails.com/cve/CVE-2017-6850/,CWE-476,Medium,,,,2017-03-15,4.3,The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.,2018-06-28,DoS ,1,https://github.com/mdadams/jasper/commit/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"Fixed bugs due to uninitialized data in the JP2 decoder.
Also, added some comments marking I/O stream interfaces that probably
need to be changed (in the long term) to fix integer overflow problems.",0,src/libjasper/jp2/jp2_cod.c,"{""sha"": ""d70408fbb526d1d1e9166962eae9a2cf39179267"", ""filename"": ""src/libjasper/base/jas_stream.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 0, ""changes"": 18, ""blob_url"": ""https://github.com/mdadams/jasper/blob/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/base/jas_stream.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/base/jas_stream.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/base/jas_stream.c?ref=e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d"", ""patch"": ""@@ -664,6 +664,7 @@ int jas_stream_ungetc(jas_stream_t *stream, int c)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n {\n \tint n;\n@@ -690,6 +691,7 @@ int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n \treturn n;\n }\n \n+/* FIXME integral type */\n int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n {\n \tint n;\n@@ -742,6 +744,7 @@ int jas_stream_puts(jas_stream_t *stream, const char *s)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n {\n \tint c;\n@@ -765,6 +768,7 @@ char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n \treturn buf;\n }\n \n+/* FIXME integral type */\n int jas_stream_gobble(jas_stream_t *stream, int n)\n {\n \tint m;\n@@ -783,6 +787,7 @@ int jas_stream_gobble(jas_stream_t *stream, int n)\n \treturn n;\n }\n \n+/* FIXME integral type */\n int jas_stream_pad(jas_stream_t *stream, int n, int c)\n {\n \tint m;\n@@ -885,6 +890,7 @@ long jas_stream_tell(jas_stream_t *stream)\n * Buffer initialization code.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n   int bufsize)\n {\n@@ -1060,6 +1066,7 @@ static int jas_strtoopenmode(const char *s)\n \treturn openmode;\n }\n \n+/* FIXME integral type */\n int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n {\n \tint all;\n@@ -1085,6 +1092,7 @@ int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n long jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n {\n \tint old;\n@@ -1094,6 +1102,7 @@ long jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n \treturn old;\n }\n \n+/* FIXME integral type */\n int jas_stream_display(jas_stream_t *stream, FILE *fp, int n)\n {\n \tunsigned char buf[16];\n@@ -1168,6 +1177,7 @@ long jas_stream_length(jas_stream_t *stream)\n * Memory stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tssize_t n;\n@@ -1209,6 +1219,7 @@ static int mem_resize(jas_stream_memobj_t *m, size_t bufsize)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tsize_t n;\n@@ -1264,6 +1275,7 @@ static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn ret;\n }\n \n+/* FIXME integral type */\n static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n@@ -1310,6 +1322,7 @@ static int mem_close(jas_stream_obj_t *obj)\n * File stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1318,6 +1331,7 @@ static int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn read(fileobj->fd, buf, cnt);\n }\n \n+/* FIXME integral type */\n static int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1326,6 +1340,7 @@ static int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn write(fileobj->fd, buf, cnt);\n }\n \n+/* FIXME integral type */\n static long file_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1352,6 +1367,7 @@ static int file_close(jas_stream_obj_t *obj)\n * Stdio file stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tFILE *fp;\n@@ -1367,6 +1383,7 @@ static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn result;\n }\n \n+/* FIXME integral type */\n static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tFILE *fp;\n@@ -1377,6 +1394,7 @@ static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn (n != JAS_CAST(size_t, cnt)) ? (-1) : cnt;\n }\n \n+/* FIXME integral type */\n static long sfile_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tFILE *fp;""}<_**next**_>{""sha"": ""8d98a2cad438fac2f83c094515850f2d0aab3054"", ""filename"": ""src/libjasper/jp2/jp2_cod.c"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/mdadams/jasper/blob/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/jp2/jp2_cod.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/jp2/jp2_cod.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/jp2/jp2_cod.c?ref=e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d"", ""patch"": ""@@ -183,15 +183,28 @@ jp2_boxinfo_t jp2_boxinfo_unk = {\n * Box constructor.\n \\******************************************************************************/\n \n-jp2_box_t *jp2_box_create(int type)\n+jp2_box_t *jp2_box_create0()\n {\n \tjp2_box_t *box;\n-\tjp2_boxinfo_t *boxinfo;\n-\n \tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n \t\treturn 0;\n \t}\n \tmemset(box, 0, sizeof(jp2_box_t));\n+\tbox->type = 0;\n+\tbox->len = 0;\n+\t// Mark the box data as never having been constructed\n+\t// so that we will not errantly attempt to destroy it later.\n+\tbox->ops = &jp2_boxinfo_unk.ops;\n+\treturn box;\n+}\n+\n+jp2_box_t *jp2_box_create(int type)\n+{\n+\tjp2_box_t *box;\n+\tjp2_boxinfo_t *boxinfo;\n+\tif (!(box = jp2_box_create0())) {\n+\t\treturn 0;\n+\t}\n \tbox->type = type;\n \tbox->len = 0;\n \tif (!(boxinfo = jp2_boxinfolookup(type))) {\n@@ -248,25 +261,22 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \tbox = 0;\n \ttmpstream = 0;\n \n-\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n+\tif (!(box = jp2_box_create0())) {\n \t\tgoto error;\n \t}\n-\n-\t// Mark the box data as never having been constructed\n-\t// so that we will not errantly attempt to destroy it later.\n-\tbox->ops = &jp2_boxinfo_unk.ops;\n-\n \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n \t\tgoto error;\n \t}\n \tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n \tbox->len = len;\n \tJAS_DBGLOG(10, (\n-\t  \""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\"",\n+\t  \""preliminary processing of JP2 box: \""\n+\t  \""type=%c%s%c (0x%08x); length=%\""PRIuFAST32\""\\n\"",\n \t  '\""', boxinfo->name, '\""', box->type, box->len\n \t  ));\n \tif (box->len == 1) {\n+\t\tJAS_DBGLOG(10, (\""big length\\n\""));\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n \t\t}\n@@ -382,6 +392,7 @@ static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n {\n \tjp2_bpcc_t *bpcc = &box->data.bpcc;\n \tunsigned int i;\n+\tbpcc->bpcs = 0;\n \tbpcc->numcmpts = box->datalen;\n \tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n \t\treturn -1;\n@@ -462,6 +473,7 @@ static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n \tjp2_cdef_t *cdef = &box->data.cdef;\n \tjp2_cdefchan_t *chan;\n \tunsigned int channo;\n+\tcdef->ents = 0;\n \tif (jp2_getuint16(in, &cdef->numchans)) {\n \t\treturn -1;\n \t}\n@@ -518,7 +530,9 @@ int jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n \t}\n \n \tif (dataflag) {\n-\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n+\t\tif (jas_stream_copy(out, tmpstream, box->len -\n+\t\t  JP2_BOX_HDRLEN(false))) {\n+\t\t\tjas_eprintf(\""cannot copy box data\\n\"");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_close(tmpstream);\n@@ -777,6 +791,7 @@ static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n \tjp2_cmap_t *cmap = &box->data.cmap;\n \tjp2_cmapent_t *ent;\n \tunsigned int i;\n+\tcmap->ents = 0;\n \n \tcmap->numchans = (box->datalen) / 4;\n \tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n@@ -835,6 +850,7 @@ static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n \tint_fast32_t x;\n \n \tpclr->lutdata = 0;\n+\tpclr->bpc = 0;\n \n \tif (jp2_getuint16(in, &pclr->numlutents) ||\n \t  jp2_getuint8(in, &pclr->numchans)) {\n@@ -869,9 +885,9 @@ static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n #if 0\n \tjp2_pclr_t *pclr = &box->data.pclr;\n #endif\n-/* Eliminate warning about unused variable. */\n-box = 0;\n-out = 0;\n+\t/* Eliminate warning about unused variable. */\n+\tbox = 0;\n+\tout = 0;\n \treturn -1;\n }\n ""}","static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)
{
 	jp2_cmap_t *cmap = &box->data.cmap;
 	jp2_cmapent_t *ent;
 	unsigned int i;
	cmap->ents = 0;
 
 	cmap->numchans = (box->datalen) / 4;
 	if (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {
		return -1;
	}
	for (i = 0; i < cmap->numchans; ++i) {
		ent = &cmap->ents[i];
		if (jp2_getuint16(in, &ent->cmptno) ||
		  jp2_getuint8(in, &ent->map) ||
		  jp2_getuint8(in, &ent->pcol)) {
			return -1;
		}
	}
	
	return 0;
}
","static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)
{
 	jp2_cmap_t *cmap = &box->data.cmap;
 	jp2_cmapent_t *ent;
 	unsigned int i;
 
 	cmap->numchans = (box->datalen) / 4;
 	if (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {
		return -1;
	}
	for (i = 0; i < cmap->numchans; ++i) {
		ent = &cmap->ents[i];
		if (jp2_getuint16(in, &ent->cmptno) ||
		  jp2_getuint8(in, &ent->map) ||
		  jp2_getuint8(in, &ent->pcol)) {
			return -1;
		}
	}
	
	return 0;
}
",C,"	cmap->ents = 0;
",,,"@@ -183,15 +183,28 @@ jp2_boxinfo_t jp2_boxinfo_unk = {
 * Box constructor.
 \******************************************************************************/
 
-jp2_box_t *jp2_box_create(int type)
+jp2_box_t *jp2_box_create0()
 {
 	jp2_box_t *box;
-	jp2_boxinfo_t *boxinfo;
-
 	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
 		return 0;
 	}
 	memset(box, 0, sizeof(jp2_box_t));
+	box->type = 0;
+	box->len = 0;
+	// Mark the box data as never having been constructed
+	// so that we will not errantly attempt to destroy it later.
+	box->ops = &jp2_boxinfo_unk.ops;
+	return box;
+}
+
+jp2_box_t *jp2_box_create(int type)
+{
+	jp2_box_t *box;
+	jp2_boxinfo_t *boxinfo;
+	if (!(box = jp2_box_create0())) {
+		return 0;
+	}
 	box->type = type;
 	box->len = 0;
 	if (!(boxinfo = jp2_boxinfolookup(type))) {
@@ -248,25 +261,22 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)
 	box = 0;
 	tmpstream = 0;
 
-	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
+	if (!(box = jp2_box_create0())) {
 		goto error;
 	}
-
-	// Mark the box data as never having been constructed
-	// so that we will not errantly attempt to destroy it later.
-	box->ops = &jp2_boxinfo_unk.ops;
-
 	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
 		goto error;
 	}
 	boxinfo = jp2_boxinfolookup(box->type);
 	box->info = boxinfo;
 	box->len = len;
 	JAS_DBGLOG(10, (
-	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
+	  ""preliminary processing of JP2 box: ""
+	  ""type=%c%s%c (0x%08x); length=%""PRIuFAST32""\n"",
 	  '""', boxinfo->name, '""', box->type, box->len
 	  ));
 	if (box->len == 1) {
+		JAS_DBGLOG(10, (""big length\n""));
 		if (jp2_getuint64(in, &extlen)) {
 			goto error;
 		}
@@ -382,6 +392,7 @@ static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)
 {
 	jp2_bpcc_t *bpcc = &box->data.bpcc;
 	unsigned int i;
+	bpcc->bpcs = 0;
 	bpcc->numcmpts = box->datalen;
 	if (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {
 		return -1;
@@ -462,6 +473,7 @@ static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)
 	jp2_cdef_t *cdef = &box->data.cdef;
 	jp2_cdefchan_t *chan;
 	unsigned int channo;
+	cdef->ents = 0;
 	if (jp2_getuint16(in, &cdef->numchans)) {
 		return -1;
 	}
@@ -518,7 +530,9 @@ int jp2_box_put(jp2_box_t *box, jas_stream_t *out)
 	}
 
 	if (dataflag) {
-		if (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {
+		if (jas_stream_copy(out, tmpstream, box->len -
+		  JP2_BOX_HDRLEN(false))) {
+			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}
 		jas_stream_close(tmpstream);
@@ -777,6 +791,7 @@ static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)
 	jp2_cmap_t *cmap = &box->data.cmap;
 	jp2_cmapent_t *ent;
 	unsigned int i;
+	cmap->ents = 0;
 
 	cmap->numchans = (box->datalen) / 4;
 	if (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {
@@ -835,6 +850,7 @@ static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)
 	int_fast32_t x;
 
 	pclr->lutdata = 0;
+	pclr->bpc = 0;
 
 	if (jp2_getuint16(in, &pclr->numlutents) ||
 	  jp2_getuint8(in, &pclr->numchans)) {
@@ -869,9 +885,9 @@ static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)
 #if 0
 	jp2_pclr_t *pclr = &box->data.pclr;
 #endif
-/* Eliminate warning about unused variable. */
-box = 0;
-out = 0;
+	/* Eliminate warning about unused variable. */
+	box = 0;
+	out = 0;
 	return -1;
 }
 ",jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,7692d6d1a0bfbd9a1d3f905337e3457cec39bced,1,"static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)
{
 	jp2_cmap_t *cmap = &box->data.cmap;
 	jp2_cmapent_t *ent;
 	unsigned int i;
//fix_flaw_line_below:
//	cmap->ents = 0;
 
 	cmap->numchans = (box->datalen) / 4;
 	if (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {
		return -1;
	}
	for (i = 0; i < cmap->numchans; ++i) {
		ent = &cmap->ents[i];
		if (jp2_getuint16(in, &ent->cmptno) ||
		  jp2_getuint8(in, &ent->map) ||
		  jp2_getuint8(in, &ent->pcol)) {
			return -1;
		}
	}
	
	return 0;
}
"
3759,181495,,Remote,Not required,Partial,CVE-2017-6850,https://www.cvedetails.com/cve/CVE-2017-6850/,CWE-476,Medium,,,,2017-03-15,4.3,The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.,2018-06-28,DoS ,1,https://github.com/mdadams/jasper/commit/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"Fixed bugs due to uninitialized data in the JP2 decoder.
Also, added some comments marking I/O stream interfaces that probably
need to be changed (in the long term) to fix integer overflow problems.",0,src/libjasper/jp2/jp2_cod.c,"{""sha"": ""d70408fbb526d1d1e9166962eae9a2cf39179267"", ""filename"": ""src/libjasper/base/jas_stream.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 0, ""changes"": 18, ""blob_url"": ""https://github.com/mdadams/jasper/blob/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/base/jas_stream.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/base/jas_stream.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/base/jas_stream.c?ref=e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d"", ""patch"": ""@@ -664,6 +664,7 @@ int jas_stream_ungetc(jas_stream_t *stream, int c)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n {\n \tint n;\n@@ -690,6 +691,7 @@ int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n \treturn n;\n }\n \n+/* FIXME integral type */\n int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n {\n \tint n;\n@@ -742,6 +744,7 @@ int jas_stream_puts(jas_stream_t *stream, const char *s)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n {\n \tint c;\n@@ -765,6 +768,7 @@ char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n \treturn buf;\n }\n \n+/* FIXME integral type */\n int jas_stream_gobble(jas_stream_t *stream, int n)\n {\n \tint m;\n@@ -783,6 +787,7 @@ int jas_stream_gobble(jas_stream_t *stream, int n)\n \treturn n;\n }\n \n+/* FIXME integral type */\n int jas_stream_pad(jas_stream_t *stream, int n, int c)\n {\n \tint m;\n@@ -885,6 +890,7 @@ long jas_stream_tell(jas_stream_t *stream)\n * Buffer initialization code.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n   int bufsize)\n {\n@@ -1060,6 +1066,7 @@ static int jas_strtoopenmode(const char *s)\n \treturn openmode;\n }\n \n+/* FIXME integral type */\n int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n {\n \tint all;\n@@ -1085,6 +1092,7 @@ int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n long jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n {\n \tint old;\n@@ -1094,6 +1102,7 @@ long jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n \treturn old;\n }\n \n+/* FIXME integral type */\n int jas_stream_display(jas_stream_t *stream, FILE *fp, int n)\n {\n \tunsigned char buf[16];\n@@ -1168,6 +1177,7 @@ long jas_stream_length(jas_stream_t *stream)\n * Memory stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tssize_t n;\n@@ -1209,6 +1219,7 @@ static int mem_resize(jas_stream_memobj_t *m, size_t bufsize)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tsize_t n;\n@@ -1264,6 +1275,7 @@ static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn ret;\n }\n \n+/* FIXME integral type */\n static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n@@ -1310,6 +1322,7 @@ static int mem_close(jas_stream_obj_t *obj)\n * File stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1318,6 +1331,7 @@ static int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn read(fileobj->fd, buf, cnt);\n }\n \n+/* FIXME integral type */\n static int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1326,6 +1340,7 @@ static int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn write(fileobj->fd, buf, cnt);\n }\n \n+/* FIXME integral type */\n static long file_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1352,6 +1367,7 @@ static int file_close(jas_stream_obj_t *obj)\n * Stdio file stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tFILE *fp;\n@@ -1367,6 +1383,7 @@ static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn result;\n }\n \n+/* FIXME integral type */\n static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tFILE *fp;\n@@ -1377,6 +1394,7 @@ static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn (n != JAS_CAST(size_t, cnt)) ? (-1) : cnt;\n }\n \n+/* FIXME integral type */\n static long sfile_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tFILE *fp;""}<_**next**_>{""sha"": ""8d98a2cad438fac2f83c094515850f2d0aab3054"", ""filename"": ""src/libjasper/jp2/jp2_cod.c"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/mdadams/jasper/blob/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/jp2/jp2_cod.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/jp2/jp2_cod.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/jp2/jp2_cod.c?ref=e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d"", ""patch"": ""@@ -183,15 +183,28 @@ jp2_boxinfo_t jp2_boxinfo_unk = {\n * Box constructor.\n \\******************************************************************************/\n \n-jp2_box_t *jp2_box_create(int type)\n+jp2_box_t *jp2_box_create0()\n {\n \tjp2_box_t *box;\n-\tjp2_boxinfo_t *boxinfo;\n-\n \tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n \t\treturn 0;\n \t}\n \tmemset(box, 0, sizeof(jp2_box_t));\n+\tbox->type = 0;\n+\tbox->len = 0;\n+\t// Mark the box data as never having been constructed\n+\t// so that we will not errantly attempt to destroy it later.\n+\tbox->ops = &jp2_boxinfo_unk.ops;\n+\treturn box;\n+}\n+\n+jp2_box_t *jp2_box_create(int type)\n+{\n+\tjp2_box_t *box;\n+\tjp2_boxinfo_t *boxinfo;\n+\tif (!(box = jp2_box_create0())) {\n+\t\treturn 0;\n+\t}\n \tbox->type = type;\n \tbox->len = 0;\n \tif (!(boxinfo = jp2_boxinfolookup(type))) {\n@@ -248,25 +261,22 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \tbox = 0;\n \ttmpstream = 0;\n \n-\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n+\tif (!(box = jp2_box_create0())) {\n \t\tgoto error;\n \t}\n-\n-\t// Mark the box data as never having been constructed\n-\t// so that we will not errantly attempt to destroy it later.\n-\tbox->ops = &jp2_boxinfo_unk.ops;\n-\n \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n \t\tgoto error;\n \t}\n \tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n \tbox->len = len;\n \tJAS_DBGLOG(10, (\n-\t  \""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\"",\n+\t  \""preliminary processing of JP2 box: \""\n+\t  \""type=%c%s%c (0x%08x); length=%\""PRIuFAST32\""\\n\"",\n \t  '\""', boxinfo->name, '\""', box->type, box->len\n \t  ));\n \tif (box->len == 1) {\n+\t\tJAS_DBGLOG(10, (\""big length\\n\""));\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n \t\t}\n@@ -382,6 +392,7 @@ static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n {\n \tjp2_bpcc_t *bpcc = &box->data.bpcc;\n \tunsigned int i;\n+\tbpcc->bpcs = 0;\n \tbpcc->numcmpts = box->datalen;\n \tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n \t\treturn -1;\n@@ -462,6 +473,7 @@ static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n \tjp2_cdef_t *cdef = &box->data.cdef;\n \tjp2_cdefchan_t *chan;\n \tunsigned int channo;\n+\tcdef->ents = 0;\n \tif (jp2_getuint16(in, &cdef->numchans)) {\n \t\treturn -1;\n \t}\n@@ -518,7 +530,9 @@ int jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n \t}\n \n \tif (dataflag) {\n-\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n+\t\tif (jas_stream_copy(out, tmpstream, box->len -\n+\t\t  JP2_BOX_HDRLEN(false))) {\n+\t\t\tjas_eprintf(\""cannot copy box data\\n\"");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_close(tmpstream);\n@@ -777,6 +791,7 @@ static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n \tjp2_cmap_t *cmap = &box->data.cmap;\n \tjp2_cmapent_t *ent;\n \tunsigned int i;\n+\tcmap->ents = 0;\n \n \tcmap->numchans = (box->datalen) / 4;\n \tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n@@ -835,6 +850,7 @@ static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n \tint_fast32_t x;\n \n \tpclr->lutdata = 0;\n+\tpclr->bpc = 0;\n \n \tif (jp2_getuint16(in, &pclr->numlutents) ||\n \t  jp2_getuint8(in, &pclr->numchans)) {\n@@ -869,9 +885,9 @@ static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n #if 0\n \tjp2_pclr_t *pclr = &box->data.pclr;\n #endif\n-/* Eliminate warning about unused variable. */\n-box = 0;\n-out = 0;\n+\t/* Eliminate warning about unused variable. */\n+\tbox = 0;\n+\tout = 0;\n \treturn -1;\n }\n ""}","static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)
{
	jp2_pclr_t *pclr = &box->data.pclr;
	int lutsize;
	unsigned int i;
	unsigned int j;
 	int_fast32_t x;
 
 	pclr->lutdata = 0;
	pclr->bpc = 0;
 
 	if (jp2_getuint16(in, &pclr->numlutents) ||
 	  jp2_getuint8(in, &pclr->numchans)) {
		return -1;
	}
	lutsize = pclr->numlutents * pclr->numchans;
	if (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {
		return -1;
	}
	if (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {
		return -1;
	}
	for (i = 0; i < pclr->numchans; ++i) {
		if (jp2_getuint8(in, &pclr->bpc[i])) {
			return -1;
		}
	}
	for (i = 0; i < pclr->numlutents; ++i) {
		for (j = 0; j < pclr->numchans; ++j) {
			if (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,
			  (pclr->bpc[j] & 0x7f) + 1, &x)) {
				return -1;
			}
			pclr->lutdata[i * pclr->numchans + j] = x;
		}
	}
	return 0;
}
","static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)
{
	jp2_pclr_t *pclr = &box->data.pclr;
	int lutsize;
	unsigned int i;
	unsigned int j;
 	int_fast32_t x;
 
 	pclr->lutdata = 0;
 
 	if (jp2_getuint16(in, &pclr->numlutents) ||
 	  jp2_getuint8(in, &pclr->numchans)) {
		return -1;
	}
	lutsize = pclr->numlutents * pclr->numchans;
	if (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {
		return -1;
	}
	if (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {
		return -1;
	}
	for (i = 0; i < pclr->numchans; ++i) {
		if (jp2_getuint8(in, &pclr->bpc[i])) {
			return -1;
		}
	}
	for (i = 0; i < pclr->numlutents; ++i) {
		for (j = 0; j < pclr->numchans; ++j) {
			if (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,
			  (pclr->bpc[j] & 0x7f) + 1, &x)) {
				return -1;
			}
			pclr->lutdata[i * pclr->numchans + j] = x;
		}
	}
	return 0;
}
",C,"	pclr->bpc = 0;
",,,"@@ -183,15 +183,28 @@ jp2_boxinfo_t jp2_boxinfo_unk = {
 * Box constructor.
 \******************************************************************************/
 
-jp2_box_t *jp2_box_create(int type)
+jp2_box_t *jp2_box_create0()
 {
 	jp2_box_t *box;
-	jp2_boxinfo_t *boxinfo;
-
 	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
 		return 0;
 	}
 	memset(box, 0, sizeof(jp2_box_t));
+	box->type = 0;
+	box->len = 0;
+	// Mark the box data as never having been constructed
+	// so that we will not errantly attempt to destroy it later.
+	box->ops = &jp2_boxinfo_unk.ops;
+	return box;
+}
+
+jp2_box_t *jp2_box_create(int type)
+{
+	jp2_box_t *box;
+	jp2_boxinfo_t *boxinfo;
+	if (!(box = jp2_box_create0())) {
+		return 0;
+	}
 	box->type = type;
 	box->len = 0;
 	if (!(boxinfo = jp2_boxinfolookup(type))) {
@@ -248,25 +261,22 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)
 	box = 0;
 	tmpstream = 0;
 
-	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
+	if (!(box = jp2_box_create0())) {
 		goto error;
 	}
-
-	// Mark the box data as never having been constructed
-	// so that we will not errantly attempt to destroy it later.
-	box->ops = &jp2_boxinfo_unk.ops;
-
 	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
 		goto error;
 	}
 	boxinfo = jp2_boxinfolookup(box->type);
 	box->info = boxinfo;
 	box->len = len;
 	JAS_DBGLOG(10, (
-	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
+	  ""preliminary processing of JP2 box: ""
+	  ""type=%c%s%c (0x%08x); length=%""PRIuFAST32""\n"",
 	  '""', boxinfo->name, '""', box->type, box->len
 	  ));
 	if (box->len == 1) {
+		JAS_DBGLOG(10, (""big length\n""));
 		if (jp2_getuint64(in, &extlen)) {
 			goto error;
 		}
@@ -382,6 +392,7 @@ static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)
 {
 	jp2_bpcc_t *bpcc = &box->data.bpcc;
 	unsigned int i;
+	bpcc->bpcs = 0;
 	bpcc->numcmpts = box->datalen;
 	if (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {
 		return -1;
@@ -462,6 +473,7 @@ static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)
 	jp2_cdef_t *cdef = &box->data.cdef;
 	jp2_cdefchan_t *chan;
 	unsigned int channo;
+	cdef->ents = 0;
 	if (jp2_getuint16(in, &cdef->numchans)) {
 		return -1;
 	}
@@ -518,7 +530,9 @@ int jp2_box_put(jp2_box_t *box, jas_stream_t *out)
 	}
 
 	if (dataflag) {
-		if (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {
+		if (jas_stream_copy(out, tmpstream, box->len -
+		  JP2_BOX_HDRLEN(false))) {
+			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}
 		jas_stream_close(tmpstream);
@@ -777,6 +791,7 @@ static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)
 	jp2_cmap_t *cmap = &box->data.cmap;
 	jp2_cmapent_t *ent;
 	unsigned int i;
+	cmap->ents = 0;
 
 	cmap->numchans = (box->datalen) / 4;
 	if (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {
@@ -835,6 +850,7 @@ static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)
 	int_fast32_t x;
 
 	pclr->lutdata = 0;
+	pclr->bpc = 0;
 
 	if (jp2_getuint16(in, &pclr->numlutents) ||
 	  jp2_getuint8(in, &pclr->numchans)) {
@@ -869,9 +885,9 @@ static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)
 #if 0
 	jp2_pclr_t *pclr = &box->data.pclr;
 #endif
-/* Eliminate warning about unused variable. */
-box = 0;
-out = 0;
+	/* Eliminate warning about unused variable. */
+	box = 0;
+	out = 0;
 	return -1;
 }
 ",jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,7692d6d1a0bfbd9a1d3f905337e3457cec39bced,1,"static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)
{
	jp2_pclr_t *pclr = &box->data.pclr;
	int lutsize;
	unsigned int i;
	unsigned int j;
 	int_fast32_t x;
 
 	pclr->lutdata = 0;
//fix_flaw_line_below:
//	pclr->bpc = 0;
 
 	if (jp2_getuint16(in, &pclr->numlutents) ||
 	  jp2_getuint8(in, &pclr->numchans)) {
		return -1;
	}
	lutsize = pclr->numlutents * pclr->numchans;
	if (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {
		return -1;
	}
	if (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {
		return -1;
	}
	for (i = 0; i < pclr->numchans; ++i) {
		if (jp2_getuint8(in, &pclr->bpc[i])) {
			return -1;
		}
	}
	for (i = 0; i < pclr->numlutents; ++i) {
		for (j = 0; j < pclr->numchans; ++j) {
			if (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,
			  (pclr->bpc[j] & 0x7f) + 1, &x)) {
				return -1;
			}
			pclr->lutdata[i * pclr->numchans + j] = x;
		}
	}
	return 0;
}
"
3760,181496,,Remote,Not required,Partial,CVE-2017-6850,https://www.cvedetails.com/cve/CVE-2017-6850/,CWE-476,Medium,,,,2017-03-15,4.3,The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.,2018-06-28,DoS ,3,https://github.com/mdadams/jasper/commit/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"Fixed bugs due to uninitialized data in the JP2 decoder.
Also, added some comments marking I/O stream interfaces that probably
need to be changed (in the long term) to fix integer overflow problems.",3,src/libjasper/jp2/jp2_cod.c,"{""sha"": ""d70408fbb526d1d1e9166962eae9a2cf39179267"", ""filename"": ""src/libjasper/base/jas_stream.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 0, ""changes"": 18, ""blob_url"": ""https://github.com/mdadams/jasper/blob/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/base/jas_stream.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/base/jas_stream.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/base/jas_stream.c?ref=e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d"", ""patch"": ""@@ -664,6 +664,7 @@ int jas_stream_ungetc(jas_stream_t *stream, int c)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n {\n \tint n;\n@@ -690,6 +691,7 @@ int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n \treturn n;\n }\n \n+/* FIXME integral type */\n int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n {\n \tint n;\n@@ -742,6 +744,7 @@ int jas_stream_puts(jas_stream_t *stream, const char *s)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n {\n \tint c;\n@@ -765,6 +768,7 @@ char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n \treturn buf;\n }\n \n+/* FIXME integral type */\n int jas_stream_gobble(jas_stream_t *stream, int n)\n {\n \tint m;\n@@ -783,6 +787,7 @@ int jas_stream_gobble(jas_stream_t *stream, int n)\n \treturn n;\n }\n \n+/* FIXME integral type */\n int jas_stream_pad(jas_stream_t *stream, int n, int c)\n {\n \tint m;\n@@ -885,6 +890,7 @@ long jas_stream_tell(jas_stream_t *stream)\n * Buffer initialization code.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n   int bufsize)\n {\n@@ -1060,6 +1066,7 @@ static int jas_strtoopenmode(const char *s)\n \treturn openmode;\n }\n \n+/* FIXME integral type */\n int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n {\n \tint all;\n@@ -1085,6 +1092,7 @@ int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n long jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n {\n \tint old;\n@@ -1094,6 +1102,7 @@ long jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n \treturn old;\n }\n \n+/* FIXME integral type */\n int jas_stream_display(jas_stream_t *stream, FILE *fp, int n)\n {\n \tunsigned char buf[16];\n@@ -1168,6 +1177,7 @@ long jas_stream_length(jas_stream_t *stream)\n * Memory stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tssize_t n;\n@@ -1209,6 +1219,7 @@ static int mem_resize(jas_stream_memobj_t *m, size_t bufsize)\n \treturn 0;\n }\n \n+/* FIXME integral type */\n static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tsize_t n;\n@@ -1264,6 +1275,7 @@ static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn ret;\n }\n \n+/* FIXME integral type */\n static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n@@ -1310,6 +1322,7 @@ static int mem_close(jas_stream_obj_t *obj)\n * File stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1318,6 +1331,7 @@ static int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn read(fileobj->fd, buf, cnt);\n }\n \n+/* FIXME integral type */\n static int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1326,6 +1340,7 @@ static int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn write(fileobj->fd, buf, cnt);\n }\n \n+/* FIXME integral type */\n static long file_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1352,6 +1367,7 @@ static int file_close(jas_stream_obj_t *obj)\n * Stdio file stream object.\n \\******************************************************************************/\n \n+/* FIXME integral type */\n static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tFILE *fp;\n@@ -1367,6 +1383,7 @@ static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn result;\n }\n \n+/* FIXME integral type */\n static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tFILE *fp;\n@@ -1377,6 +1394,7 @@ static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn (n != JAS_CAST(size_t, cnt)) ? (-1) : cnt;\n }\n \n+/* FIXME integral type */\n static long sfile_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tFILE *fp;""}<_**next**_>{""sha"": ""8d98a2cad438fac2f83c094515850f2d0aab3054"", ""filename"": ""src/libjasper/jp2/jp2_cod.c"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/mdadams/jasper/blob/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/jp2/jp2_cod.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d/src/libjasper/jp2/jp2_cod.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/jp2/jp2_cod.c?ref=e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d"", ""patch"": ""@@ -183,15 +183,28 @@ jp2_boxinfo_t jp2_boxinfo_unk = {\n * Box constructor.\n \\******************************************************************************/\n \n-jp2_box_t *jp2_box_create(int type)\n+jp2_box_t *jp2_box_create0()\n {\n \tjp2_box_t *box;\n-\tjp2_boxinfo_t *boxinfo;\n-\n \tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n \t\treturn 0;\n \t}\n \tmemset(box, 0, sizeof(jp2_box_t));\n+\tbox->type = 0;\n+\tbox->len = 0;\n+\t// Mark the box data as never having been constructed\n+\t// so that we will not errantly attempt to destroy it later.\n+\tbox->ops = &jp2_boxinfo_unk.ops;\n+\treturn box;\n+}\n+\n+jp2_box_t *jp2_box_create(int type)\n+{\n+\tjp2_box_t *box;\n+\tjp2_boxinfo_t *boxinfo;\n+\tif (!(box = jp2_box_create0())) {\n+\t\treturn 0;\n+\t}\n \tbox->type = type;\n \tbox->len = 0;\n \tif (!(boxinfo = jp2_boxinfolookup(type))) {\n@@ -248,25 +261,22 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \tbox = 0;\n \ttmpstream = 0;\n \n-\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n+\tif (!(box = jp2_box_create0())) {\n \t\tgoto error;\n \t}\n-\n-\t// Mark the box data as never having been constructed\n-\t// so that we will not errantly attempt to destroy it later.\n-\tbox->ops = &jp2_boxinfo_unk.ops;\n-\n \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n \t\tgoto error;\n \t}\n \tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n \tbox->len = len;\n \tJAS_DBGLOG(10, (\n-\t  \""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\"",\n+\t  \""preliminary processing of JP2 box: \""\n+\t  \""type=%c%s%c (0x%08x); length=%\""PRIuFAST32\""\\n\"",\n \t  '\""', boxinfo->name, '\""', box->type, box->len\n \t  ));\n \tif (box->len == 1) {\n+\t\tJAS_DBGLOG(10, (\""big length\\n\""));\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n \t\t}\n@@ -382,6 +392,7 @@ static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n {\n \tjp2_bpcc_t *bpcc = &box->data.bpcc;\n \tunsigned int i;\n+\tbpcc->bpcs = 0;\n \tbpcc->numcmpts = box->datalen;\n \tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n \t\treturn -1;\n@@ -462,6 +473,7 @@ static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n \tjp2_cdef_t *cdef = &box->data.cdef;\n \tjp2_cdefchan_t *chan;\n \tunsigned int channo;\n+\tcdef->ents = 0;\n \tif (jp2_getuint16(in, &cdef->numchans)) {\n \t\treturn -1;\n \t}\n@@ -518,7 +530,9 @@ int jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n \t}\n \n \tif (dataflag) {\n-\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n+\t\tif (jas_stream_copy(out, tmpstream, box->len -\n+\t\t  JP2_BOX_HDRLEN(false))) {\n+\t\t\tjas_eprintf(\""cannot copy box data\\n\"");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_close(tmpstream);\n@@ -777,6 +791,7 @@ static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n \tjp2_cmap_t *cmap = &box->data.cmap;\n \tjp2_cmapent_t *ent;\n \tunsigned int i;\n+\tcmap->ents = 0;\n \n \tcmap->numchans = (box->datalen) / 4;\n \tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n@@ -835,6 +850,7 @@ static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n \tint_fast32_t x;\n \n \tpclr->lutdata = 0;\n+\tpclr->bpc = 0;\n \n \tif (jp2_getuint16(in, &pclr->numlutents) ||\n \t  jp2_getuint8(in, &pclr->numchans)) {\n@@ -869,9 +885,9 @@ static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n #if 0\n \tjp2_pclr_t *pclr = &box->data.pclr;\n #endif\n-/* Eliminate warning about unused variable. */\n-box = 0;\n-out = 0;\n+\t/* Eliminate warning about unused variable. */\n+\tbox = 0;\n+\tout = 0;\n \treturn -1;\n }\n ""}","static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)
{
 #if 0
 	jp2_pclr_t *pclr = &box->data.pclr;
 #endif
	/* Eliminate warning about unused variable. */
	box = 0;
	out = 0;
 	return -1;
 }
","static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)
{
 #if 0
 	jp2_pclr_t *pclr = &box->data.pclr;
 #endif
/* Eliminate warning about unused variable. */
box = 0;
out = 0;
 	return -1;
 }
",C,"	/* Eliminate warning about unused variable. */
	box = 0;
	out = 0;
","/* Eliminate warning about unused variable. */
box = 0;
out = 0;
",,"@@ -183,15 +183,28 @@ jp2_boxinfo_t jp2_boxinfo_unk = {
 * Box constructor.
 \******************************************************************************/
 
-jp2_box_t *jp2_box_create(int type)
+jp2_box_t *jp2_box_create0()
 {
 	jp2_box_t *box;
-	jp2_boxinfo_t *boxinfo;
-
 	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
 		return 0;
 	}
 	memset(box, 0, sizeof(jp2_box_t));
+	box->type = 0;
+	box->len = 0;
+	// Mark the box data as never having been constructed
+	// so that we will not errantly attempt to destroy it later.
+	box->ops = &jp2_boxinfo_unk.ops;
+	return box;
+}
+
+jp2_box_t *jp2_box_create(int type)
+{
+	jp2_box_t *box;
+	jp2_boxinfo_t *boxinfo;
+	if (!(box = jp2_box_create0())) {
+		return 0;
+	}
 	box->type = type;
 	box->len = 0;
 	if (!(boxinfo = jp2_boxinfolookup(type))) {
@@ -248,25 +261,22 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)
 	box = 0;
 	tmpstream = 0;
 
-	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
+	if (!(box = jp2_box_create0())) {
 		goto error;
 	}
-
-	// Mark the box data as never having been constructed
-	// so that we will not errantly attempt to destroy it later.
-	box->ops = &jp2_boxinfo_unk.ops;
-
 	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
 		goto error;
 	}
 	boxinfo = jp2_boxinfolookup(box->type);
 	box->info = boxinfo;
 	box->len = len;
 	JAS_DBGLOG(10, (
-	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
+	  ""preliminary processing of JP2 box: ""
+	  ""type=%c%s%c (0x%08x); length=%""PRIuFAST32""\n"",
 	  '""', boxinfo->name, '""', box->type, box->len
 	  ));
 	if (box->len == 1) {
+		JAS_DBGLOG(10, (""big length\n""));
 		if (jp2_getuint64(in, &extlen)) {
 			goto error;
 		}
@@ -382,6 +392,7 @@ static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)
 {
 	jp2_bpcc_t *bpcc = &box->data.bpcc;
 	unsigned int i;
+	bpcc->bpcs = 0;
 	bpcc->numcmpts = box->datalen;
 	if (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {
 		return -1;
@@ -462,6 +473,7 @@ static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)
 	jp2_cdef_t *cdef = &box->data.cdef;
 	jp2_cdefchan_t *chan;
 	unsigned int channo;
+	cdef->ents = 0;
 	if (jp2_getuint16(in, &cdef->numchans)) {
 		return -1;
 	}
@@ -518,7 +530,9 @@ int jp2_box_put(jp2_box_t *box, jas_stream_t *out)
 	}
 
 	if (dataflag) {
-		if (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {
+		if (jas_stream_copy(out, tmpstream, box->len -
+		  JP2_BOX_HDRLEN(false))) {
+			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}
 		jas_stream_close(tmpstream);
@@ -777,6 +791,7 @@ static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)
 	jp2_cmap_t *cmap = &box->data.cmap;
 	jp2_cmapent_t *ent;
 	unsigned int i;
+	cmap->ents = 0;
 
 	cmap->numchans = (box->datalen) / 4;
 	if (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {
@@ -835,6 +850,7 @@ static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)
 	int_fast32_t x;
 
 	pclr->lutdata = 0;
+	pclr->bpc = 0;
 
 	if (jp2_getuint16(in, &pclr->numlutents) ||
 	  jp2_getuint8(in, &pclr->numchans)) {
@@ -869,9 +885,9 @@ static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)
 #if 0
 	jp2_pclr_t *pclr = &box->data.pclr;
 #endif
-/* Eliminate warning about unused variable. */
-box = 0;
-out = 0;
+	/* Eliminate warning about unused variable. */
+	box = 0;
+	out = 0;
 	return -1;
 }
 ",jasper,e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,7692d6d1a0bfbd9a1d3f905337e3457cec39bced,1,"static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)
{
 #if 0
 	jp2_pclr_t *pclr = &box->data.pclr;
 #endif
//flaw_line_below:
/* Eliminate warning about unused variable. */
//flaw_line_below:
box = 0;
//flaw_line_below:
out = 0;
//fix_flaw_line_below:
//	/* Eliminate warning about unused variable. */
//fix_flaw_line_below:
//	box = 0;
//fix_flaw_line_below:
//	out = 0;
 	return -1;
 }
"
3765,181501,,Remote,Not required,Partial,CVE-2017-6501,https://www.cvedetails.com/cve/CVE-2017-6501/,CWE-476,Medium,,,,2017-03-05,4.3,An issue was discovered in ImageMagick 6.9.7. A specially crafted xcf file could lead to a NULL pointer dereference.,2017-03-07,,2,https://github.com/ImageMagick/ImageMagick/commit/d31fec57e9dfb0516deead2053a856e3c71e9751,d31fec57e9dfb0516deead2053a856e3c71e9751,Check for image list before we destroy the last image in XCF coder (patch sent privately by Андрей Черный),1,coders/xcf.c,"{""sha"": ""2feef82ff19396e57ec010ec1aae8120575f5c5b"", ""filename"": ""coders/xcf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/d31fec57e9dfb0516deead2053a856e3c71e9751/coders/xcf.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/d31fec57e9dfb0516deead2053a856e3c71e9751/coders/xcf.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/xcf.c?ref=d31fec57e9dfb0516deead2053a856e3c71e9751"", ""patch"": ""@@ -1445,7 +1445,8 @@ static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n   }\n \n   (void) CloseBlob(image);\n-  DestroyImage(RemoveFirstImageFromList(&image));\n+  if (GetNextImageInList(image) != (Image *) NULL)\n+    DestroyImage(RemoveFirstImageFromList(&image));\n   if (image_type == GIMP_GRAY)\n     image->type=GrayscaleType;\n   return(GetFirstImageInList(image));""}","static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  char
    magick[14];

  Image
    *image;

  int
    foundPropEnd = 0;

  MagickBooleanType
    status;

  MagickOffsetType
    offset;

  register ssize_t
    i;

  size_t
    image_type,
    length;

  ssize_t
    count;

  XCFDocInfo
    doc_info;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  count=ReadBlob(image,14,(unsigned char *) magick);
  if ((count != 14) ||
      (LocaleNCompare((char *) magick,""gimp xcf"",8) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  (void) ResetMagickMemory(&doc_info,0,sizeof(XCFDocInfo));
  doc_info.exception=exception;
  doc_info.width=ReadBlobMSBLong(image);
  doc_info.height=ReadBlobMSBLong(image);
  if ((doc_info.width > 262144) || (doc_info.height > 262144))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  doc_info.image_type=ReadBlobMSBLong(image);
  /*
    Initialize image attributes.
  */
  image->columns=doc_info.width;
  image->rows=doc_info.height;
  image_type=doc_info.image_type;
  doc_info.file_size=GetBlobSize(image);
  image->compression=NoCompression;
  image->depth=8;
  status=SetImageExtent(image,image->columns,image->rows);
  if (status == MagickFalse)
    {
      InheritException(exception,&image->exception);
      return(DestroyImageList(image));
    }
  if (image_type == GIMP_RGB)
    ;
  else
    if (image_type == GIMP_GRAY)
      image->colorspace=GRAYColorspace;
    else
      if (image_type == GIMP_INDEXED)
        ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
  (void) SetImageOpacity(image,OpaqueOpacity); 
  (void) SetImageBackgroundColor(image);
  /*
    Read properties.
  */
  while ((foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse))
  {
    PropType prop_type = (PropType) ReadBlobMSBLong(image);
    size_t prop_size = ReadBlobMSBLong(image);

    switch (prop_type)
    {
      case PROP_END:
        foundPropEnd=1;
        break;
      case PROP_COLORMAP:
      {
        /* Cannot rely on prop_size here--the value is set incorrectly
           by some Gimp versions.
        */
        size_t num_colours = ReadBlobMSBLong(image);
        if (DiscardBlobBytes(image,3*num_colours) == MagickFalse)
          ThrowFileException(&image->exception,CorruptImageError,
            ""UnexpectedEndOfFile"",image->filename);
    /*
      if (info->file_version == 0)
      {
        gint i;

        g_message (_(""XCF warning: version 0 of XCF file format\n""
           ""did not save indexed colormaps correctly.\n""
           ""Substituting grayscale map.""));
        info->cp +=
          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);
        gimage->cmap = g_new (guchar, gimage->num_cols*3);
        xcf_seek_pos (info, info->cp + gimage->num_cols);
        for (i = 0; i<gimage->num_cols; i++)
          {
            gimage->cmap[i*3+0] = i;
            gimage->cmap[i*3+1] = i;
            gimage->cmap[i*3+2] = i;
          }
      }
      else
      {
        info->cp +=
          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);
        gimage->cmap = g_new (guchar, gimage->num_cols*3);
        info->cp +=
          xcf_read_int8 (info->fp,
                   (guint8*) gimage->cmap, gimage->num_cols*3);
      }
     */
        break;
      }
      case PROP_COMPRESSION:
      {
        doc_info.compression = ReadBlobByte(image);
        if ((doc_info.compression != COMPRESS_NONE) &&
            (doc_info.compression != COMPRESS_RLE) &&
            (doc_info.compression != COMPRESS_ZLIB) &&
            (doc_info.compression != COMPRESS_FRACTAL))
          ThrowReaderException(CorruptImageError,""UnrecognizedImageCompression"");
      }
      break;

      case PROP_GUIDES:
      {
         /* just skip it - we don't care about guides */
        if (DiscardBlobBytes(image,prop_size) == MagickFalse)
          ThrowFileException(&image->exception,CorruptImageError,
            ""UnexpectedEndOfFile"",image->filename);
      }
      break;

    case PROP_RESOLUTION:
      {
        /* float xres = (float) */ (void) ReadBlobMSBLong(image);
        /* float yres = (float) */ (void) ReadBlobMSBLong(image);

        /*
        if (xres < GIMP_MIN_RESOLUTION || xres > GIMP_MAX_RESOLUTION ||
            yres < GIMP_MIN_RESOLUTION || yres > GIMP_MAX_RESOLUTION)
        {
        g_message (""Warning, resolution out of range in XCF file"");
        xres = gimage->gimp->config->default_xresolution;
        yres = gimage->gimp->config->default_yresolution;
        }
        */


        /* BOGUS: we don't write these yet because we aren't
              reading them properly yet :(
              image->x_resolution = xres;
              image->y_resolution = yres;
        */
      }
      break;

    case PROP_TATTOO:
      {
        /* we need to read it, even if we ignore it */
        /*size_t  tattoo_state = */ (void) ReadBlobMSBLong(image);
      }
      break;

    case PROP_PARASITES:
      {
        /* BOGUS: we may need these for IPTC stuff */
        if (DiscardBlobBytes(image,prop_size) == MagickFalse)
          ThrowFileException(&image->exception,CorruptImageError,
            ""UnexpectedEndOfFile"",image->filename);
        /*
      gssize_t         base = info->cp;
      GimpParasite *p;

      while (info->cp - base < prop_size)
        {
          p = xcf_load_parasite (info);
          gimp_image_parasite_attach (gimage, p);
          gimp_parasite_free (p);
        }
      if (info->cp - base != prop_size)
        g_message (""Error detected while loading an image's parasites"");
      */
          }
      break;

    case PROP_UNIT:
      {
        /* BOGUS: ignore for now... */
      /*size_t unit =  */ (void) ReadBlobMSBLong(image);
      }
      break;

    case PROP_PATHS:
      {
      /* BOGUS: just skip it for now */
        if (DiscardBlobBytes(image,prop_size) == MagickFalse)
          ThrowFileException(&image->exception,CorruptImageError,
            ""UnexpectedEndOfFile"",image->filename);

        /*
      PathList *paths = xcf_load_bzpaths (gimage, info);
      gimp_image_set_paths (gimage, paths);
      */
      }
      break;

    case PROP_USER_UNIT:
      {
        char  unit_string[1000];
        /*BOGUS: ignored for now */
        /*float  factor = (float) */ (void) ReadBlobMSBLong(image);
        /* size_t digits =  */ (void) ReadBlobMSBLong(image);
        for (i=0; i<5; i++)
         (void) ReadBlobStringWithLongSize(image, unit_string,
           sizeof(unit_string));
      }
     break;

      default:
      {
        int buf[16];
        ssize_t amount;

      /* read over it... */
      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))
      {
        amount=(ssize_t) MagickMin(16, prop_size);
        amount=(ssize_t) ReadBlob(image,(size_t) amount,(unsigned char *) &buf);
        if (!amount)
          ThrowReaderException(CorruptImageError,""CorruptImage"");
        prop_size -= (size_t) MagickMin(16,(size_t) amount);
      }
    }
    break;
  }
  }
  if (foundPropEnd == MagickFalse)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
    {
      ; /* do nothing, were just pinging! */
    }
  else
    {
      int
        current_layer = 0,
        foundAllLayers = MagickFalse,
        number_layers = 0;

      MagickOffsetType
        oldPos=TellBlob(image);

      XCFLayerInfo
        *layer_info;

      /*
        The read pointer.
      */
      do
      {
        ssize_t offset = ReadBlobMSBSignedLong(image);
        if (offset == 0)
          foundAllLayers=MagickTrue;
        else
          number_layers++;
        if (EOFBlob(image) != MagickFalse)
          {
            ThrowFileException(exception,CorruptImageError,
              ""UnexpectedEndOfFile"",image->filename);
            break;
          }
    } while (foundAllLayers == MagickFalse);
    doc_info.number_layers=number_layers;
    offset=SeekBlob(image,oldPos,SEEK_SET); /* restore the position! */
    if (offset < 0)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    /* allocate our array of layer info blocks */
    length=(size_t) number_layers;
    layer_info=(XCFLayerInfo *) AcquireQuantumMemory(length,
      sizeof(*layer_info));
    if (layer_info == (XCFLayerInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(layer_info,0,number_layers*sizeof(XCFLayerInfo));
    for ( ; ; )
    {
      MagickBooleanType
        layer_ok;

      MagickOffsetType
        offset,
        saved_pos;

      /* read in the offset of the next layer */
      offset=(MagickOffsetType) ReadBlobMSBLong(image);
      /* if the offset is 0 then we are at the end
      *  of the layer list.
      */
      if (offset == 0)
        break;
      /* save the current position as it is where the
      *  next layer offset is stored.
      */
      saved_pos=TellBlob(image);
      /* seek to the layer offset */
      if (SeekBlob(image,offset,SEEK_SET) != offset)
        ThrowReaderException(ResourceLimitError,""NotEnoughPixelData"");
      /* read in the layer */
      layer_ok=ReadOneLayer(image_info,image,&doc_info,
        &layer_info[current_layer],current_layer);
      if (layer_ok == MagickFalse)
        {
          int j;

          for (j=0; j < current_layer; j++)
            layer_info[j].image=DestroyImage(layer_info[j].image);
          layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        }
      /* restore the saved position so we'll be ready to
      *  read the next offset.
      */
      offset=SeekBlob(image, saved_pos, SEEK_SET);
      current_layer++;
    }
#if 0
        {
        /* NOTE: XCF layers are REVERSED from composite order! */
        signed int  j;
        for (j=number_layers-1; j>=0; j--) {
          /* BOGUS: need to consider layer blending modes!! */

          if ( layer_info[j].visible ) { /* only visible ones, please! */
            CompositeImage(image, OverCompositeOp, layer_info[j].image,
                     layer_info[j].offset_x, layer_info[j].offset_y );
             layer_info[j].image =DestroyImage( layer_info[j].image );

            /* If we do this, we'll get REAL gray images! */
            if ( image_type == GIMP_GRAY ) {
              QuantizeInfo  qi;
              GetQuantizeInfo(&qi);
              qi.colorspace = GRAYColorspace;
              QuantizeImage( &qi, layer_info[j].image );
            }
          }
        }
      }
#else
      {
        /* NOTE: XCF layers are REVERSED from composite order! */
        ssize_t  j;

        /* now reverse the order of the layers as they are put
           into subimages
        */
        for (j=(long) number_layers-1; j >= 0; j--)
          AppendImageToList(&image,layer_info[j].image);
      }
#endif

    layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);

#if 0  /* BOGUS: do we need the channels?? */
    while (MagickTrue)
    {
      /* read in the offset of the next channel */
      info->cp += xcf_read_int32 (info->fp, &offset, 1);

      /* if the offset is 0 then we are at the end
      *  of the channel list.
      */
      if (offset == 0)
        break;

      /* save the current position as it is where the
      *  next channel offset is stored.
      */
      saved_pos = info->cp;

      /* seek to the channel offset */
      xcf_seek_pos (info, offset);

      /* read in the layer */
      channel = xcf_load_channel (info, gimage);
      if (channel == 0)
        goto error;

      num_successful_elements++;

      /* add the channel to the image if its not the selection */
      if (channel != gimage->selection_mask)
        gimp_image_add_channel (gimage, channel, -1);

      /* restore the saved position so we'll be ready to
      *  read the next offset.
      */
      xcf_seek_pos (info, saved_pos);
    }
#endif
   }
 
   (void) CloseBlob(image);
  if (GetNextImageInList(image) != (Image *) NULL)
    DestroyImage(RemoveFirstImageFromList(&image));
   if (image_type == GIMP_GRAY)
     image->type=GrayscaleType;
   return(GetFirstImageInList(image));
}
","static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  char
    magick[14];

  Image
    *image;

  int
    foundPropEnd = 0;

  MagickBooleanType
    status;

  MagickOffsetType
    offset;

  register ssize_t
    i;

  size_t
    image_type,
    length;

  ssize_t
    count;

  XCFDocInfo
    doc_info;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  count=ReadBlob(image,14,(unsigned char *) magick);
  if ((count != 14) ||
      (LocaleNCompare((char *) magick,""gimp xcf"",8) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  (void) ResetMagickMemory(&doc_info,0,sizeof(XCFDocInfo));
  doc_info.exception=exception;
  doc_info.width=ReadBlobMSBLong(image);
  doc_info.height=ReadBlobMSBLong(image);
  if ((doc_info.width > 262144) || (doc_info.height > 262144))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  doc_info.image_type=ReadBlobMSBLong(image);
  /*
    Initialize image attributes.
  */
  image->columns=doc_info.width;
  image->rows=doc_info.height;
  image_type=doc_info.image_type;
  doc_info.file_size=GetBlobSize(image);
  image->compression=NoCompression;
  image->depth=8;
  status=SetImageExtent(image,image->columns,image->rows);
  if (status == MagickFalse)
    {
      InheritException(exception,&image->exception);
      return(DestroyImageList(image));
    }
  if (image_type == GIMP_RGB)
    ;
  else
    if (image_type == GIMP_GRAY)
      image->colorspace=GRAYColorspace;
    else
      if (image_type == GIMP_INDEXED)
        ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
  (void) SetImageOpacity(image,OpaqueOpacity); 
  (void) SetImageBackgroundColor(image);
  /*
    Read properties.
  */
  while ((foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse))
  {
    PropType prop_type = (PropType) ReadBlobMSBLong(image);
    size_t prop_size = ReadBlobMSBLong(image);

    switch (prop_type)
    {
      case PROP_END:
        foundPropEnd=1;
        break;
      case PROP_COLORMAP:
      {
        /* Cannot rely on prop_size here--the value is set incorrectly
           by some Gimp versions.
        */
        size_t num_colours = ReadBlobMSBLong(image);
        if (DiscardBlobBytes(image,3*num_colours) == MagickFalse)
          ThrowFileException(&image->exception,CorruptImageError,
            ""UnexpectedEndOfFile"",image->filename);
    /*
      if (info->file_version == 0)
      {
        gint i;

        g_message (_(""XCF warning: version 0 of XCF file format\n""
           ""did not save indexed colormaps correctly.\n""
           ""Substituting grayscale map.""));
        info->cp +=
          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);
        gimage->cmap = g_new (guchar, gimage->num_cols*3);
        xcf_seek_pos (info, info->cp + gimage->num_cols);
        for (i = 0; i<gimage->num_cols; i++)
          {
            gimage->cmap[i*3+0] = i;
            gimage->cmap[i*3+1] = i;
            gimage->cmap[i*3+2] = i;
          }
      }
      else
      {
        info->cp +=
          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);
        gimage->cmap = g_new (guchar, gimage->num_cols*3);
        info->cp +=
          xcf_read_int8 (info->fp,
                   (guint8*) gimage->cmap, gimage->num_cols*3);
      }
     */
        break;
      }
      case PROP_COMPRESSION:
      {
        doc_info.compression = ReadBlobByte(image);
        if ((doc_info.compression != COMPRESS_NONE) &&
            (doc_info.compression != COMPRESS_RLE) &&
            (doc_info.compression != COMPRESS_ZLIB) &&
            (doc_info.compression != COMPRESS_FRACTAL))
          ThrowReaderException(CorruptImageError,""UnrecognizedImageCompression"");
      }
      break;

      case PROP_GUIDES:
      {
         /* just skip it - we don't care about guides */
        if (DiscardBlobBytes(image,prop_size) == MagickFalse)
          ThrowFileException(&image->exception,CorruptImageError,
            ""UnexpectedEndOfFile"",image->filename);
      }
      break;

    case PROP_RESOLUTION:
      {
        /* float xres = (float) */ (void) ReadBlobMSBLong(image);
        /* float yres = (float) */ (void) ReadBlobMSBLong(image);

        /*
        if (xres < GIMP_MIN_RESOLUTION || xres > GIMP_MAX_RESOLUTION ||
            yres < GIMP_MIN_RESOLUTION || yres > GIMP_MAX_RESOLUTION)
        {
        g_message (""Warning, resolution out of range in XCF file"");
        xres = gimage->gimp->config->default_xresolution;
        yres = gimage->gimp->config->default_yresolution;
        }
        */


        /* BOGUS: we don't write these yet because we aren't
              reading them properly yet :(
              image->x_resolution = xres;
              image->y_resolution = yres;
        */
      }
      break;

    case PROP_TATTOO:
      {
        /* we need to read it, even if we ignore it */
        /*size_t  tattoo_state = */ (void) ReadBlobMSBLong(image);
      }
      break;

    case PROP_PARASITES:
      {
        /* BOGUS: we may need these for IPTC stuff */
        if (DiscardBlobBytes(image,prop_size) == MagickFalse)
          ThrowFileException(&image->exception,CorruptImageError,
            ""UnexpectedEndOfFile"",image->filename);
        /*
      gssize_t         base = info->cp;
      GimpParasite *p;

      while (info->cp - base < prop_size)
        {
          p = xcf_load_parasite (info);
          gimp_image_parasite_attach (gimage, p);
          gimp_parasite_free (p);
        }
      if (info->cp - base != prop_size)
        g_message (""Error detected while loading an image's parasites"");
      */
          }
      break;

    case PROP_UNIT:
      {
        /* BOGUS: ignore for now... */
      /*size_t unit =  */ (void) ReadBlobMSBLong(image);
      }
      break;

    case PROP_PATHS:
      {
      /* BOGUS: just skip it for now */
        if (DiscardBlobBytes(image,prop_size) == MagickFalse)
          ThrowFileException(&image->exception,CorruptImageError,
            ""UnexpectedEndOfFile"",image->filename);

        /*
      PathList *paths = xcf_load_bzpaths (gimage, info);
      gimp_image_set_paths (gimage, paths);
      */
      }
      break;

    case PROP_USER_UNIT:
      {
        char  unit_string[1000];
        /*BOGUS: ignored for now */
        /*float  factor = (float) */ (void) ReadBlobMSBLong(image);
        /* size_t digits =  */ (void) ReadBlobMSBLong(image);
        for (i=0; i<5; i++)
         (void) ReadBlobStringWithLongSize(image, unit_string,
           sizeof(unit_string));
      }
     break;

      default:
      {
        int buf[16];
        ssize_t amount;

      /* read over it... */
      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))
      {
        amount=(ssize_t) MagickMin(16, prop_size);
        amount=(ssize_t) ReadBlob(image,(size_t) amount,(unsigned char *) &buf);
        if (!amount)
          ThrowReaderException(CorruptImageError,""CorruptImage"");
        prop_size -= (size_t) MagickMin(16,(size_t) amount);
      }
    }
    break;
  }
  }
  if (foundPropEnd == MagickFalse)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
    {
      ; /* do nothing, were just pinging! */
    }
  else
    {
      int
        current_layer = 0,
        foundAllLayers = MagickFalse,
        number_layers = 0;

      MagickOffsetType
        oldPos=TellBlob(image);

      XCFLayerInfo
        *layer_info;

      /*
        The read pointer.
      */
      do
      {
        ssize_t offset = ReadBlobMSBSignedLong(image);
        if (offset == 0)
          foundAllLayers=MagickTrue;
        else
          number_layers++;
        if (EOFBlob(image) != MagickFalse)
          {
            ThrowFileException(exception,CorruptImageError,
              ""UnexpectedEndOfFile"",image->filename);
            break;
          }
    } while (foundAllLayers == MagickFalse);
    doc_info.number_layers=number_layers;
    offset=SeekBlob(image,oldPos,SEEK_SET); /* restore the position! */
    if (offset < 0)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    /* allocate our array of layer info blocks */
    length=(size_t) number_layers;
    layer_info=(XCFLayerInfo *) AcquireQuantumMemory(length,
      sizeof(*layer_info));
    if (layer_info == (XCFLayerInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(layer_info,0,number_layers*sizeof(XCFLayerInfo));
    for ( ; ; )
    {
      MagickBooleanType
        layer_ok;

      MagickOffsetType
        offset,
        saved_pos;

      /* read in the offset of the next layer */
      offset=(MagickOffsetType) ReadBlobMSBLong(image);
      /* if the offset is 0 then we are at the end
      *  of the layer list.
      */
      if (offset == 0)
        break;
      /* save the current position as it is where the
      *  next layer offset is stored.
      */
      saved_pos=TellBlob(image);
      /* seek to the layer offset */
      if (SeekBlob(image,offset,SEEK_SET) != offset)
        ThrowReaderException(ResourceLimitError,""NotEnoughPixelData"");
      /* read in the layer */
      layer_ok=ReadOneLayer(image_info,image,&doc_info,
        &layer_info[current_layer],current_layer);
      if (layer_ok == MagickFalse)
        {
          int j;

          for (j=0; j < current_layer; j++)
            layer_info[j].image=DestroyImage(layer_info[j].image);
          layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        }
      /* restore the saved position so we'll be ready to
      *  read the next offset.
      */
      offset=SeekBlob(image, saved_pos, SEEK_SET);
      current_layer++;
    }
#if 0
        {
        /* NOTE: XCF layers are REVERSED from composite order! */
        signed int  j;
        for (j=number_layers-1; j>=0; j--) {
          /* BOGUS: need to consider layer blending modes!! */

          if ( layer_info[j].visible ) { /* only visible ones, please! */
            CompositeImage(image, OverCompositeOp, layer_info[j].image,
                     layer_info[j].offset_x, layer_info[j].offset_y );
             layer_info[j].image =DestroyImage( layer_info[j].image );

            /* If we do this, we'll get REAL gray images! */
            if ( image_type == GIMP_GRAY ) {
              QuantizeInfo  qi;
              GetQuantizeInfo(&qi);
              qi.colorspace = GRAYColorspace;
              QuantizeImage( &qi, layer_info[j].image );
            }
          }
        }
      }
#else
      {
        /* NOTE: XCF layers are REVERSED from composite order! */
        ssize_t  j;

        /* now reverse the order of the layers as they are put
           into subimages
        */
        for (j=(long) number_layers-1; j >= 0; j--)
          AppendImageToList(&image,layer_info[j].image);
      }
#endif

    layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);

#if 0  /* BOGUS: do we need the channels?? */
    while (MagickTrue)
    {
      /* read in the offset of the next channel */
      info->cp += xcf_read_int32 (info->fp, &offset, 1);

      /* if the offset is 0 then we are at the end
      *  of the channel list.
      */
      if (offset == 0)
        break;

      /* save the current position as it is where the
      *  next channel offset is stored.
      */
      saved_pos = info->cp;

      /* seek to the channel offset */
      xcf_seek_pos (info, offset);

      /* read in the layer */
      channel = xcf_load_channel (info, gimage);
      if (channel == 0)
        goto error;

      num_successful_elements++;

      /* add the channel to the image if its not the selection */
      if (channel != gimage->selection_mask)
        gimp_image_add_channel (gimage, channel, -1);

      /* restore the saved position so we'll be ready to
      *  read the next offset.
      */
      xcf_seek_pos (info, saved_pos);
    }
#endif
   }
 
   (void) CloseBlob(image);
  DestroyImage(RemoveFirstImageFromList(&image));
   if (image_type == GIMP_GRAY)
     image->type=GrayscaleType;
   return(GetFirstImageInList(image));
}
",C,"  if (GetNextImageInList(image) != (Image *) NULL)
    DestroyImage(RemoveFirstImageFromList(&image));
","  DestroyImage(RemoveFirstImageFromList(&image));
",,"@@ -1445,7 +1445,8 @@ static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)
   }
 
   (void) CloseBlob(image);
-  DestroyImage(RemoveFirstImageFromList(&image));
+  if (GetNextImageInList(image) != (Image *) NULL)
+    DestroyImage(RemoveFirstImageFromList(&image));
   if (image_type == GIMP_GRAY)
     image->type=GrayscaleType;
   return(GetFirstImageInList(image));",ImageMagick,d31fec57e9dfb0516deead2053a856e3c71e9751,d0ecc3d3477102c91ab9c697b1ba14eae61b1458,1,"static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  char
    magick[14];

  Image
    *image;

  int
    foundPropEnd = 0;

  MagickBooleanType
    status;

  MagickOffsetType
    offset;

  register ssize_t
    i;

  size_t
    image_type,
    length;

  ssize_t
    count;

  XCFDocInfo
    doc_info;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  count=ReadBlob(image,14,(unsigned char *) magick);
  if ((count != 14) ||
      (LocaleNCompare((char *) magick,""gimp xcf"",8) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  (void) ResetMagickMemory(&doc_info,0,sizeof(XCFDocInfo));
  doc_info.exception=exception;
  doc_info.width=ReadBlobMSBLong(image);
  doc_info.height=ReadBlobMSBLong(image);
  if ((doc_info.width > 262144) || (doc_info.height > 262144))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  doc_info.image_type=ReadBlobMSBLong(image);
  /*
    Initialize image attributes.
  */
  image->columns=doc_info.width;
  image->rows=doc_info.height;
  image_type=doc_info.image_type;
  doc_info.file_size=GetBlobSize(image);
  image->compression=NoCompression;
  image->depth=8;
  status=SetImageExtent(image,image->columns,image->rows);
  if (status == MagickFalse)
    {
      InheritException(exception,&image->exception);
      return(DestroyImageList(image));
    }
  if (image_type == GIMP_RGB)
    ;
  else
    if (image_type == GIMP_GRAY)
      image->colorspace=GRAYColorspace;
    else
      if (image_type == GIMP_INDEXED)
        ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
  (void) SetImageOpacity(image,OpaqueOpacity); 
  (void) SetImageBackgroundColor(image);
  /*
    Read properties.
  */
  while ((foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse))
  {
    PropType prop_type = (PropType) ReadBlobMSBLong(image);
    size_t prop_size = ReadBlobMSBLong(image);

    switch (prop_type)
    {
      case PROP_END:
        foundPropEnd=1;
        break;
      case PROP_COLORMAP:
      {
        /* Cannot rely on prop_size here--the value is set incorrectly
           by some Gimp versions.
        */
        size_t num_colours = ReadBlobMSBLong(image);
        if (DiscardBlobBytes(image,3*num_colours) == MagickFalse)
          ThrowFileException(&image->exception,CorruptImageError,
            ""UnexpectedEndOfFile"",image->filename);
    /*
      if (info->file_version == 0)
      {
        gint i;

        g_message (_(""XCF warning: version 0 of XCF file format\n""
           ""did not save indexed colormaps correctly.\n""
           ""Substituting grayscale map.""));
        info->cp +=
          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);
        gimage->cmap = g_new (guchar, gimage->num_cols*3);
        xcf_seek_pos (info, info->cp + gimage->num_cols);
        for (i = 0; i<gimage->num_cols; i++)
          {
            gimage->cmap[i*3+0] = i;
            gimage->cmap[i*3+1] = i;
            gimage->cmap[i*3+2] = i;
          }
      }
      else
      {
        info->cp +=
          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);
        gimage->cmap = g_new (guchar, gimage->num_cols*3);
        info->cp +=
          xcf_read_int8 (info->fp,
                   (guint8*) gimage->cmap, gimage->num_cols*3);
      }
     */
        break;
      }
      case PROP_COMPRESSION:
      {
        doc_info.compression = ReadBlobByte(image);
        if ((doc_info.compression != COMPRESS_NONE) &&
            (doc_info.compression != COMPRESS_RLE) &&
            (doc_info.compression != COMPRESS_ZLIB) &&
            (doc_info.compression != COMPRESS_FRACTAL))
          ThrowReaderException(CorruptImageError,""UnrecognizedImageCompression"");
      }
      break;

      case PROP_GUIDES:
      {
         /* just skip it - we don't care about guides */
        if (DiscardBlobBytes(image,prop_size) == MagickFalse)
          ThrowFileException(&image->exception,CorruptImageError,
            ""UnexpectedEndOfFile"",image->filename);
      }
      break;

    case PROP_RESOLUTION:
      {
        /* float xres = (float) */ (void) ReadBlobMSBLong(image);
        /* float yres = (float) */ (void) ReadBlobMSBLong(image);

        /*
        if (xres < GIMP_MIN_RESOLUTION || xres > GIMP_MAX_RESOLUTION ||
            yres < GIMP_MIN_RESOLUTION || yres > GIMP_MAX_RESOLUTION)
        {
        g_message (""Warning, resolution out of range in XCF file"");
        xres = gimage->gimp->config->default_xresolution;
        yres = gimage->gimp->config->default_yresolution;
        }
        */


        /* BOGUS: we don't write these yet because we aren't
              reading them properly yet :(
              image->x_resolution = xres;
              image->y_resolution = yres;
        */
      }
      break;

    case PROP_TATTOO:
      {
        /* we need to read it, even if we ignore it */
        /*size_t  tattoo_state = */ (void) ReadBlobMSBLong(image);
      }
      break;

    case PROP_PARASITES:
      {
        /* BOGUS: we may need these for IPTC stuff */
        if (DiscardBlobBytes(image,prop_size) == MagickFalse)
          ThrowFileException(&image->exception,CorruptImageError,
            ""UnexpectedEndOfFile"",image->filename);
        /*
      gssize_t         base = info->cp;
      GimpParasite *p;

      while (info->cp - base < prop_size)
        {
          p = xcf_load_parasite (info);
          gimp_image_parasite_attach (gimage, p);
          gimp_parasite_free (p);
        }
      if (info->cp - base != prop_size)
        g_message (""Error detected while loading an image's parasites"");
      */
          }
      break;

    case PROP_UNIT:
      {
        /* BOGUS: ignore for now... */
      /*size_t unit =  */ (void) ReadBlobMSBLong(image);
      }
      break;

    case PROP_PATHS:
      {
      /* BOGUS: just skip it for now */
        if (DiscardBlobBytes(image,prop_size) == MagickFalse)
          ThrowFileException(&image->exception,CorruptImageError,
            ""UnexpectedEndOfFile"",image->filename);

        /*
      PathList *paths = xcf_load_bzpaths (gimage, info);
      gimp_image_set_paths (gimage, paths);
      */
      }
      break;

    case PROP_USER_UNIT:
      {
        char  unit_string[1000];
        /*BOGUS: ignored for now */
        /*float  factor = (float) */ (void) ReadBlobMSBLong(image);
        /* size_t digits =  */ (void) ReadBlobMSBLong(image);
        for (i=0; i<5; i++)
         (void) ReadBlobStringWithLongSize(image, unit_string,
           sizeof(unit_string));
      }
     break;

      default:
      {
        int buf[16];
        ssize_t amount;

      /* read over it... */
      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))
      {
        amount=(ssize_t) MagickMin(16, prop_size);
        amount=(ssize_t) ReadBlob(image,(size_t) amount,(unsigned char *) &buf);
        if (!amount)
          ThrowReaderException(CorruptImageError,""CorruptImage"");
        prop_size -= (size_t) MagickMin(16,(size_t) amount);
      }
    }
    break;
  }
  }
  if (foundPropEnd == MagickFalse)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
    {
      ; /* do nothing, were just pinging! */
    }
  else
    {
      int
        current_layer = 0,
        foundAllLayers = MagickFalse,
        number_layers = 0;

      MagickOffsetType
        oldPos=TellBlob(image);

      XCFLayerInfo
        *layer_info;

      /*
        The read pointer.
      */
      do
      {
        ssize_t offset = ReadBlobMSBSignedLong(image);
        if (offset == 0)
          foundAllLayers=MagickTrue;
        else
          number_layers++;
        if (EOFBlob(image) != MagickFalse)
          {
            ThrowFileException(exception,CorruptImageError,
              ""UnexpectedEndOfFile"",image->filename);
            break;
          }
    } while (foundAllLayers == MagickFalse);
    doc_info.number_layers=number_layers;
    offset=SeekBlob(image,oldPos,SEEK_SET); /* restore the position! */
    if (offset < 0)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    /* allocate our array of layer info blocks */
    length=(size_t) number_layers;
    layer_info=(XCFLayerInfo *) AcquireQuantumMemory(length,
      sizeof(*layer_info));
    if (layer_info == (XCFLayerInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(layer_info,0,number_layers*sizeof(XCFLayerInfo));
    for ( ; ; )
    {
      MagickBooleanType
        layer_ok;

      MagickOffsetType
        offset,
        saved_pos;

      /* read in the offset of the next layer */
      offset=(MagickOffsetType) ReadBlobMSBLong(image);
      /* if the offset is 0 then we are at the end
      *  of the layer list.
      */
      if (offset == 0)
        break;
      /* save the current position as it is where the
      *  next layer offset is stored.
      */
      saved_pos=TellBlob(image);
      /* seek to the layer offset */
      if (SeekBlob(image,offset,SEEK_SET) != offset)
        ThrowReaderException(ResourceLimitError,""NotEnoughPixelData"");
      /* read in the layer */
      layer_ok=ReadOneLayer(image_info,image,&doc_info,
        &layer_info[current_layer],current_layer);
      if (layer_ok == MagickFalse)
        {
          int j;

          for (j=0; j < current_layer; j++)
            layer_info[j].image=DestroyImage(layer_info[j].image);
          layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        }
      /* restore the saved position so we'll be ready to
      *  read the next offset.
      */
      offset=SeekBlob(image, saved_pos, SEEK_SET);
      current_layer++;
    }
#if 0
        {
        /* NOTE: XCF layers are REVERSED from composite order! */
        signed int  j;
        for (j=number_layers-1; j>=0; j--) {
          /* BOGUS: need to consider layer blending modes!! */

          if ( layer_info[j].visible ) { /* only visible ones, please! */
            CompositeImage(image, OverCompositeOp, layer_info[j].image,
                     layer_info[j].offset_x, layer_info[j].offset_y );
             layer_info[j].image =DestroyImage( layer_info[j].image );

            /* If we do this, we'll get REAL gray images! */
            if ( image_type == GIMP_GRAY ) {
              QuantizeInfo  qi;
              GetQuantizeInfo(&qi);
              qi.colorspace = GRAYColorspace;
              QuantizeImage( &qi, layer_info[j].image );
            }
          }
        }
      }
#else
      {
        /* NOTE: XCF layers are REVERSED from composite order! */
        ssize_t  j;

        /* now reverse the order of the layers as they are put
           into subimages
        */
        for (j=(long) number_layers-1; j >= 0; j--)
          AppendImageToList(&image,layer_info[j].image);
      }
#endif

    layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);

#if 0  /* BOGUS: do we need the channels?? */
    while (MagickTrue)
    {
      /* read in the offset of the next channel */
      info->cp += xcf_read_int32 (info->fp, &offset, 1);

      /* if the offset is 0 then we are at the end
      *  of the channel list.
      */
      if (offset == 0)
        break;

      /* save the current position as it is where the
      *  next channel offset is stored.
      */
      saved_pos = info->cp;

      /* seek to the channel offset */
      xcf_seek_pos (info, offset);

      /* read in the layer */
      channel = xcf_load_channel (info, gimage);
      if (channel == 0)
        goto error;

      num_successful_elements++;

      /* add the channel to the image if its not the selection */
      if (channel != gimage->selection_mask)
        gimp_image_add_channel (gimage, channel, -1);

      /* restore the saved position so we'll be ready to
      *  read the next offset.
      */
      xcf_seek_pos (info, saved_pos);
    }
#endif
   }
 
   (void) CloseBlob(image);
//flaw_line_below:
  DestroyImage(RemoveFirstImageFromList(&image));
//fix_flaw_line_below:
//  if (GetNextImageInList(image) != (Image *) NULL)
//fix_flaw_line_below:
//    DestroyImage(RemoveFirstImageFromList(&image));
   if (image_type == GIMP_GRAY)
     image->type=GrayscaleType;
   return(GetFirstImageInList(image));
}
"
3768,181504,,Remote,Not required,Partial,CVE-2017-6497,https://www.cvedetails.com/cve/CVE-2017-6497/,CWE-476,Low,,,,2017-03-05,5.0,"An issue was discovered in ImageMagick 6.9.7. A specially crafted psd file could lead to a NULL pointer dereference (thus, a DoS).",2017-03-07,,5,https://github.com/ImageMagick/ImageMagick/commit/7f2dc7a1afc067d0c89f12c82bcdec0445fb1b94,7f2dc7a1afc067d0c89f12c82bcdec0445fb1b94,Added missing null check.,2,coders/psd.c,"{""sha"": ""fb93c57dd144d115c985877eff2ef8c62ce29d37"", ""filename"": ""coders/psd.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/7f2dc7a1afc067d0c89f12c82bcdec0445fb1b94/coders/psd.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/7f2dc7a1afc067d0c89f12c82bcdec0445fb1b94/coders/psd.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/psd.c?ref=7f2dc7a1afc067d0c89f12c82bcdec0445fb1b94"", ""patch"": ""@@ -1284,8 +1284,11 @@ static MagickBooleanType ReadPSDChannel(Image *image,\n       }\n       mask=CloneImage(image,layer_info->mask.page.width,\n         layer_info->mask.page.height,MagickFalse,exception);\n-      mask->matte=MagickFalse;\n-      channel_image=mask;\n+      if (mask != (Image *) NULL)\n+        {\n+          mask->matte=MagickFalse;\n+          channel_image=mask;\n+        }\n     }\n \n   offset=TellBlob(image);""}","static MagickBooleanType ReadPSDChannel(Image *image,
  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,
  const size_t channel,const PSDCompressionType compression,
  ExceptionInfo *exception)
{
  Image
    *channel_image,
    *mask;

  MagickOffsetType
    offset;

  MagickBooleanType
    status;

  channel_image=image;
  mask=(Image *) NULL;
  if (layer_info->channel_info[channel].type < -1)
    {
      const char
        *option;
      /*
        Ignore mask that is not a user supplied layer mask, if the mask is
        disabled or if the flags have unsupported values.
      */
      option=GetImageOption(image_info,""psd:preserve-opacity-mask"");
      if ((layer_info->channel_info[channel].type != -2) ||
          (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&
           (IsStringTrue(option) == MagickFalse)))
      {
        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);
        return(MagickTrue);
       }
       mask=CloneImage(image,layer_info->mask.page.width,
         layer_info->mask.page.height,MagickFalse,exception);
      if (mask != (Image *) NULL)
        {
          mask->matte=MagickFalse;
          channel_image=mask;
        }
     }
 
   offset=TellBlob(image);
  status=MagickTrue;
  switch(compression)
  {
    case Raw:
      status=ReadPSDChannelRaw(channel_image,psd_info->channels,
        layer_info->channel_info[channel].type,exception);
      break;
    case RLE:
      {
        MagickOffsetType
          *sizes;

        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);
        if (sizes == (MagickOffsetType *) NULL)
          ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
            image->filename);
        status=ReadPSDChannelRLE(channel_image,psd_info,
          layer_info->channel_info[channel].type,sizes,exception);
        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);
      }
      break;
    case ZipWithPrediction:
    case ZipWithoutPrediction:
#ifdef MAGICKCORE_ZLIB_DELEGATE
      status=ReadPSDChannelZip(channel_image,layer_info->channels,
        layer_info->channel_info[channel].type,compression,
        layer_info->channel_info[channel].size-2,exception);
#else
      (void) ThrowMagickException(exception,GetMagickModule(),
          MissingDelegateWarning,""DelegateLibrarySupportNotBuiltIn"",
            ""'%s' (ZLIB)"",image->filename);
#endif
      break;
    default:
      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,
        ""CompressionNotSupported"",""'%.20g'"",(double) compression);
      break;
  }

  SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);
  if (status == MagickFalse)
    {
      if (mask != (Image *) NULL)
        DestroyImage(mask);
      ThrowBinaryException(CoderError,""UnableToDecompressImage"",
        image->filename);
    }
  layer_info->mask.image=mask;
  return(status);
}
","static MagickBooleanType ReadPSDChannel(Image *image,
  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,
  const size_t channel,const PSDCompressionType compression,
  ExceptionInfo *exception)
{
  Image
    *channel_image,
    *mask;

  MagickOffsetType
    offset;

  MagickBooleanType
    status;

  channel_image=image;
  mask=(Image *) NULL;
  if (layer_info->channel_info[channel].type < -1)
    {
      const char
        *option;
      /*
        Ignore mask that is not a user supplied layer mask, if the mask is
        disabled or if the flags have unsupported values.
      */
      option=GetImageOption(image_info,""psd:preserve-opacity-mask"");
      if ((layer_info->channel_info[channel].type != -2) ||
          (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&
           (IsStringTrue(option) == MagickFalse)))
      {
        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);
        return(MagickTrue);
       }
       mask=CloneImage(image,layer_info->mask.page.width,
         layer_info->mask.page.height,MagickFalse,exception);
      mask->matte=MagickFalse;
      channel_image=mask;
     }
 
   offset=TellBlob(image);
  status=MagickTrue;
  switch(compression)
  {
    case Raw:
      status=ReadPSDChannelRaw(channel_image,psd_info->channels,
        layer_info->channel_info[channel].type,exception);
      break;
    case RLE:
      {
        MagickOffsetType
          *sizes;

        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);
        if (sizes == (MagickOffsetType *) NULL)
          ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
            image->filename);
        status=ReadPSDChannelRLE(channel_image,psd_info,
          layer_info->channel_info[channel].type,sizes,exception);
        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);
      }
      break;
    case ZipWithPrediction:
    case ZipWithoutPrediction:
#ifdef MAGICKCORE_ZLIB_DELEGATE
      status=ReadPSDChannelZip(channel_image,layer_info->channels,
        layer_info->channel_info[channel].type,compression,
        layer_info->channel_info[channel].size-2,exception);
#else
      (void) ThrowMagickException(exception,GetMagickModule(),
          MissingDelegateWarning,""DelegateLibrarySupportNotBuiltIn"",
            ""'%s' (ZLIB)"",image->filename);
#endif
      break;
    default:
      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,
        ""CompressionNotSupported"",""'%.20g'"",(double) compression);
      break;
  }

  SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);
  if (status == MagickFalse)
    {
      if (mask != (Image *) NULL)
        DestroyImage(mask);
      ThrowBinaryException(CoderError,""UnableToDecompressImage"",
        image->filename);
    }
  layer_info->mask.image=mask;
  return(status);
}
",C,"      if (mask != (Image *) NULL)
        {
          mask->matte=MagickFalse;
          channel_image=mask;
        }
","      mask->matte=MagickFalse;
      channel_image=mask;
",,"@@ -1284,8 +1284,11 @@ static MagickBooleanType ReadPSDChannel(Image *image,
       }
       mask=CloneImage(image,layer_info->mask.page.width,
         layer_info->mask.page.height,MagickFalse,exception);
-      mask->matte=MagickFalse;
-      channel_image=mask;
+      if (mask != (Image *) NULL)
+        {
+          mask->matte=MagickFalse;
+          channel_image=mask;
+        }
     }
 
   offset=TellBlob(image);",ImageMagick,7f2dc7a1afc067d0c89f12c82bcdec0445fb1b94,9c52e5bf7ed16476cb633b7114b36ff02801afcc,1,"static MagickBooleanType ReadPSDChannel(Image *image,
  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,
  const size_t channel,const PSDCompressionType compression,
  ExceptionInfo *exception)
{
  Image
    *channel_image,
    *mask;

  MagickOffsetType
    offset;

  MagickBooleanType
    status;

  channel_image=image;
  mask=(Image *) NULL;
  if (layer_info->channel_info[channel].type < -1)
    {
      const char
        *option;
      /*
        Ignore mask that is not a user supplied layer mask, if the mask is
        disabled or if the flags have unsupported values.
      */
      option=GetImageOption(image_info,""psd:preserve-opacity-mask"");
      if ((layer_info->channel_info[channel].type != -2) ||
          (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&
           (IsStringTrue(option) == MagickFalse)))
      {
        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);
        return(MagickTrue);
       }
       mask=CloneImage(image,layer_info->mask.page.width,
         layer_info->mask.page.height,MagickFalse,exception);
//flaw_line_below:
      mask->matte=MagickFalse;
//flaw_line_below:
      channel_image=mask;
//fix_flaw_line_below:
//      if (mask != (Image *) NULL)
//fix_flaw_line_below:
//        {
//fix_flaw_line_below:
//          mask->matte=MagickFalse;
//fix_flaw_line_below:
//          channel_image=mask;
//fix_flaw_line_below:
//        }
     }
 
   offset=TellBlob(image);
  status=MagickTrue;
  switch(compression)
  {
    case Raw:
      status=ReadPSDChannelRaw(channel_image,psd_info->channels,
        layer_info->channel_info[channel].type,exception);
      break;
    case RLE:
      {
        MagickOffsetType
          *sizes;

        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);
        if (sizes == (MagickOffsetType *) NULL)
          ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
            image->filename);
        status=ReadPSDChannelRLE(channel_image,psd_info,
          layer_info->channel_info[channel].type,sizes,exception);
        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);
      }
      break;
    case ZipWithPrediction:
    case ZipWithoutPrediction:
#ifdef MAGICKCORE_ZLIB_DELEGATE
      status=ReadPSDChannelZip(channel_image,layer_info->channels,
        layer_info->channel_info[channel].type,compression,
        layer_info->channel_info[channel].size-2,exception);
#else
      (void) ThrowMagickException(exception,GetMagickModule(),
          MissingDelegateWarning,""DelegateLibrarySupportNotBuiltIn"",
            ""'%s' (ZLIB)"",image->filename);
#endif
      break;
    default:
      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,
        ""CompressionNotSupported"",""'%.20g'"",(double) compression);
      break;
  }

  SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);
  if (status == MagickFalse)
    {
      if (mask != (Image *) NULL)
        DestroyImage(mask);
      ThrowBinaryException(CoderError,""UnableToDecompressImage"",
        image->filename);
    }
  layer_info->mask.image=mask;
  return(status);
}
"
3776,181512,,Remote,Not required,Partial,CVE-2017-6415,https://www.cvedetails.com/cve/CVE-2017-6415/,CWE-476,Medium,,,,2017-03-01,4.3,The dex_parse_debug_item function in libr/bin/p/bin_dex.c in radare2 1.2.1 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted DEX file.,2017-03-03,DoS ,3,https://github.com/radare/radare2/commit/252afb1cff9676f3ae1f341a28448bf2c8b6e308,252afb1cff9676f3ae1f341a28448bf2c8b6e308,fix #6872,0,libr/bin/p/bin_dex.c,"{""sha"": ""13a7b45430aeca38ea8ebbc76e34f406ac0efe14"", ""filename"": ""libr/bin/p/bin_dex.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/radareorg/radare2/blob/252afb1cff9676f3ae1f341a28448bf2c8b6e308/libr/bin/p/bin_dex.c"", ""raw_url"": ""https://github.com/radareorg/radare2/raw/252afb1cff9676f3ae1f341a28448bf2c8b6e308/libr/bin/p/bin_dex.c"", ""contents_url"": ""https://api.github.com/repos/radareorg/radare2/contents/libr/bin/p/bin_dex.c?ref=252afb1cff9676f3ae1f341a28448bf2c8b6e308"", ""patch"": ""@@ -377,6 +377,9 @@ static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,\n \t\t--parameters_size;\n \t}\n \n+\tif (p4 <= 0) {\n+\t\treturn;\n+\t}\n \tut8 opcode = *(p4++) & 0xff;\n \twhile (keep) {\n \t\tswitch (opcode) {""}","static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,
				  RBinDexClass *c, int MI, int MA, int paddr, int ins_size,
				  int insns_size, char *class_name, int regsz,
				  int debug_info_off) {
	struct r_bin_t *rbin = binfile->rbin;
	const ut8 *p4 = r_buf_get_at (binfile->buf, debug_info_off, NULL);
	const ut8 *p4_end = p4 + binfile->buf->length - debug_info_off;
	ut64 line_start;
	ut64 parameters_size;
	ut64 param_type_idx;
	ut16 argReg = regsz - ins_size;
	ut64 source_file_idx = c->source_file;
	RList *params, *debug_positions, *emitted_debug_locals = NULL; 
	bool keep = true;
	if (argReg > regsz) {
		return; // this return breaks tests
	}
	p4 = r_uleb128 (p4, p4_end - p4, &line_start);
	p4 = r_uleb128 (p4, p4_end - p4, &parameters_size);
	ut32 address = 0;
	ut32 line = line_start;
	if (!(debug_positions = r_list_newf ((RListFree)free))) {
		return;	
	}
	if (!(emitted_debug_locals = r_list_newf ((RListFree)free))) {
		r_list_free (debug_positions);
		return;
	}

	struct dex_debug_local_t debug_locals[regsz];
	memset (debug_locals, 0, sizeof (struct dex_debug_local_t) * regsz);
	if (!(MA & 0x0008)) {
		debug_locals[argReg].name = ""this"";
		debug_locals[argReg].descriptor = r_str_newf(""%s;"", class_name);
		debug_locals[argReg].startAddress = 0;
		debug_locals[argReg].signature = NULL;
		debug_locals[argReg].live = true;
		argReg++;
	}
	if (!(params = dex_method_signature2 (bin, MI))) {
		r_list_free (debug_positions);
		r_list_free (emitted_debug_locals);
		return;
	}

	RListIter *iter = r_list_iterator (params);
	char *name;
	char *type;
	int reg;

	r_list_foreach (params, iter, type) {
		if ((argReg >= regsz) || !type || parameters_size <= 0) {
			r_list_free (debug_positions);
			r_list_free (params);
			r_list_free (emitted_debug_locals);
			return;
		}
		p4 = r_uleb128 (p4, p4_end - p4, &param_type_idx); // read uleb128p1
		param_type_idx -= 1;
		name = getstr (bin, param_type_idx);
		reg = argReg;
		switch (type[0]) {
		case 'D':
		case 'J':
			argReg += 2;
			break;
		default:
			argReg += 1;
			break;
		}
		if (name) {
			debug_locals[reg].name = name;
			debug_locals[reg].descriptor = type;
			debug_locals[reg].signature = NULL;
			debug_locals[reg].startAddress = address;
			debug_locals[reg].live = true;
		}
 		--parameters_size;
 	}
 
	if (p4 <= 0) {
		return;
	}
 	ut8 opcode = *(p4++) & 0xff;
 	while (keep) {
 		switch (opcode) {
		case 0x0: // DBG_END_SEQUENCE
			keep = false;
			break;
		case 0x1: // DBG_ADVANCE_PC
			{
			ut64 addr_diff;
			p4 = r_uleb128 (p4, p4_end - p4, &addr_diff);
			address += addr_diff;
			}
			break;
		case 0x2: // DBG_ADVANCE_LINE
			{
			st64 line_diff = r_sleb128 (&p4, p4_end);
			line += line_diff;
			}
			break;	
		case 0x3: // DBG_START_LOCAL
			{
			ut64 register_num;
			ut64 name_idx;
			ut64 type_idx;
			p4 = r_uleb128 (p4, p4_end - p4, &register_num);
			p4 = r_uleb128 (p4, p4_end - p4, &name_idx); 
			name_idx -= 1;
			p4 = r_uleb128 (p4, p4_end - p4, &type_idx); 
			type_idx -= 1;
			if (register_num >= regsz) {
				r_list_free (debug_positions);
				r_list_free (params);
				return;
			}
			if (debug_locals[register_num].live) {
				struct dex_debug_local_t *local = malloc (
					sizeof (struct dex_debug_local_t));
				if (!local) {
					keep = false;
					break;
				}
				local->name = debug_locals[register_num].name;
				local->descriptor = debug_locals[register_num].descriptor;
				local->startAddress = debug_locals[register_num].startAddress;
				local->signature = debug_locals[register_num].signature;
				local->live = true;
				local->reg = register_num;
				local->endAddress = address;
				r_list_append (emitted_debug_locals, local);
			}
			debug_locals[register_num].name = getstr (bin, name_idx);
			debug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);
			debug_locals[register_num].startAddress = address;
			debug_locals[register_num].signature = NULL;
			debug_locals[register_num].live = true;
			}
			break;
		case 0x4: //DBG_START_LOCAL_EXTENDED
			{
			ut64 register_num;
			ut64 name_idx;
			ut64 type_idx;
			ut64 sig_idx;
			p4 = r_uleb128 (p4, p4_end - p4, &register_num);
			p4 = r_uleb128 (p4, p4_end - p4, &name_idx);
			name_idx -= 1;
			p4 = r_uleb128 (p4, p4_end - p4, &type_idx);
			type_idx -= 1;
			p4 = r_uleb128 (p4, p4_end - p4, &sig_idx);
			sig_idx -= 1;
			if (register_num >= regsz) {
				r_list_free (debug_positions);
				r_list_free (params);
				return;
			}

			if (debug_locals[register_num].live) {
				struct dex_debug_local_t *local = malloc (
					sizeof (struct dex_debug_local_t));
				if (!local) {
					keep = false;
					break;
				}
				local->name = debug_locals[register_num].name;
				local->descriptor = debug_locals[register_num].descriptor;
				local->startAddress = debug_locals[register_num].startAddress;
				local->signature = debug_locals[register_num].signature;
				local->live = true;
				local->reg = register_num;
				local->endAddress = address;
				r_list_append (emitted_debug_locals, local);
			}

			debug_locals[register_num].name = getstr (bin, name_idx);
			debug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);
			debug_locals[register_num].startAddress = address;
			debug_locals[register_num].signature = getstr (bin, sig_idx);
			debug_locals[register_num].live = true;
			}
			break;
		case 0x5: // DBG_END_LOCAL
			{
			ut64 register_num;
			p4 = r_uleb128 (p4, p4_end - p4, &register_num);
			if (debug_locals[register_num].live) {
				struct dex_debug_local_t *local = malloc (
					sizeof (struct dex_debug_local_t));
				if (!local) {
					keep = false;
					break;
				}
				local->name = debug_locals[register_num].name;
				local->descriptor = debug_locals[register_num].descriptor;
				local->startAddress = debug_locals[register_num].startAddress;
				local->signature = debug_locals[register_num].signature;
				local->live = true;
				local->reg = register_num;
				local->endAddress = address;
				r_list_append (emitted_debug_locals, local);
			}
			debug_locals[register_num].live = false;
			}
			break;
		case 0x6: // DBG_RESTART_LOCAL
			{
			ut64 register_num;
			p4 = r_uleb128 (p4, p4_end - p4, &register_num);
			if (!debug_locals[register_num].live) {
				debug_locals[register_num].startAddress = address;
				debug_locals[register_num].live = true;
			}
			}
			break;
		case 0x7: //DBG_SET_PROLOGUE_END
			break;
		case 0x8: //DBG_SET_PROLOGUE_BEGIN
			break;
		case 0x9:
			{
			p4 = r_uleb128 (p4, p4_end - p4, &source_file_idx);
			source_file_idx--;
			}
			break;
		default:
			{
			int adjusted_opcode = opcode - 0x0a;
			address += (adjusted_opcode / 15);
			line += -4 + (adjusted_opcode % 15);
			struct dex_debug_position_t *position =
				malloc (sizeof (struct dex_debug_position_t));
			if (!position) {
				keep = false;
				break;
			}
			position->source_file_idx = source_file_idx;
			position->address = address;
			position->line = line;
			r_list_append (debug_positions, position);
			}
			break;
		}
		opcode = *(p4++) & 0xff;
	}

	if (!binfile->sdb_addrinfo) {
		binfile->sdb_addrinfo = sdb_new0 ();
	}

	char *fileline;
	char offset[64];
	char *offset_ptr;

	RListIter *iter1;
	struct dex_debug_position_t *pos;
	r_list_foreach (debug_positions, iter1, pos) {
		fileline = r_str_newf (""%s|%""PFMT64d, getstr (bin, pos->source_file_idx), pos->line);
		offset_ptr = sdb_itoa (pos->address + paddr, offset, 16);
		sdb_set (binfile->sdb_addrinfo, offset_ptr, fileline, 0);
		sdb_set (binfile->sdb_addrinfo, fileline, offset_ptr, 0);
	}

	if (!dexdump) {
		r_list_free (debug_positions);
		r_list_free (emitted_debug_locals);
		r_list_free (params);
		return;
	}

	RListIter *iter2;
	struct dex_debug_position_t *position;

	rbin->cb_printf (""      positions     :\n"");
	r_list_foreach (debug_positions, iter2, position) {
		rbin->cb_printf (""        0x%04llx line=%llu\n"",
				 position->address, position->line);
	}

	rbin->cb_printf (""      locals        :\n"");

	RListIter *iter3;
	struct dex_debug_local_t *local;
	r_list_foreach (emitted_debug_locals, iter3, local) {
		if (local->signature) {
			rbin->cb_printf (
				""        0x%04x - 0x%04x reg=%d %s %s %s\n"",
				local->startAddress, local->endAddress,
				local->reg, local->name, local->descriptor,
				local->signature);
		} else {
			rbin->cb_printf (
				""        0x%04x - 0x%04x reg=%d %s %s\n"",
				local->startAddress, local->endAddress,
				local->reg, local->name, local->descriptor);
		}
	}

	for (reg = 0; reg < regsz; reg++) {
		if (debug_locals[reg].live) {
			if (debug_locals[reg].signature) {
				rbin->cb_printf (
					""        0x%04x - 0x%04x reg=%d %s %s ""
					""%s\n"",
					debug_locals[reg].startAddress,
					insns_size, reg, debug_locals[reg].name,
					debug_locals[reg].descriptor,
					debug_locals[reg].signature);
			} else {
				rbin->cb_printf (
					""        0x%04x - 0x%04x reg=%d %s %s""
					""\n"",
					debug_locals[reg].startAddress,
					insns_size, reg, debug_locals[reg].name,
					debug_locals[reg].descriptor);
			}
		}
	}
	r_list_free (debug_positions);
	r_list_free (emitted_debug_locals);
	r_list_free (params);
}
","static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,
				  RBinDexClass *c, int MI, int MA, int paddr, int ins_size,
				  int insns_size, char *class_name, int regsz,
				  int debug_info_off) {
	struct r_bin_t *rbin = binfile->rbin;
	const ut8 *p4 = r_buf_get_at (binfile->buf, debug_info_off, NULL);
	const ut8 *p4_end = p4 + binfile->buf->length - debug_info_off;
	ut64 line_start;
	ut64 parameters_size;
	ut64 param_type_idx;
	ut16 argReg = regsz - ins_size;
	ut64 source_file_idx = c->source_file;
	RList *params, *debug_positions, *emitted_debug_locals = NULL; 
	bool keep = true;
	if (argReg > regsz) {
		return; // this return breaks tests
	}
	p4 = r_uleb128 (p4, p4_end - p4, &line_start);
	p4 = r_uleb128 (p4, p4_end - p4, &parameters_size);
	ut32 address = 0;
	ut32 line = line_start;
	if (!(debug_positions = r_list_newf ((RListFree)free))) {
		return;	
	}
	if (!(emitted_debug_locals = r_list_newf ((RListFree)free))) {
		r_list_free (debug_positions);
		return;
	}

	struct dex_debug_local_t debug_locals[regsz];
	memset (debug_locals, 0, sizeof (struct dex_debug_local_t) * regsz);
	if (!(MA & 0x0008)) {
		debug_locals[argReg].name = ""this"";
		debug_locals[argReg].descriptor = r_str_newf(""%s;"", class_name);
		debug_locals[argReg].startAddress = 0;
		debug_locals[argReg].signature = NULL;
		debug_locals[argReg].live = true;
		argReg++;
	}
	if (!(params = dex_method_signature2 (bin, MI))) {
		r_list_free (debug_positions);
		r_list_free (emitted_debug_locals);
		return;
	}

	RListIter *iter = r_list_iterator (params);
	char *name;
	char *type;
	int reg;

	r_list_foreach (params, iter, type) {
		if ((argReg >= regsz) || !type || parameters_size <= 0) {
			r_list_free (debug_positions);
			r_list_free (params);
			r_list_free (emitted_debug_locals);
			return;
		}
		p4 = r_uleb128 (p4, p4_end - p4, &param_type_idx); // read uleb128p1
		param_type_idx -= 1;
		name = getstr (bin, param_type_idx);
		reg = argReg;
		switch (type[0]) {
		case 'D':
		case 'J':
			argReg += 2;
			break;
		default:
			argReg += 1;
			break;
		}
		if (name) {
			debug_locals[reg].name = name;
			debug_locals[reg].descriptor = type;
			debug_locals[reg].signature = NULL;
			debug_locals[reg].startAddress = address;
			debug_locals[reg].live = true;
		}
 		--parameters_size;
 	}
 
 	ut8 opcode = *(p4++) & 0xff;
 	while (keep) {
 		switch (opcode) {
		case 0x0: // DBG_END_SEQUENCE
			keep = false;
			break;
		case 0x1: // DBG_ADVANCE_PC
			{
			ut64 addr_diff;
			p4 = r_uleb128 (p4, p4_end - p4, &addr_diff);
			address += addr_diff;
			}
			break;
		case 0x2: // DBG_ADVANCE_LINE
			{
			st64 line_diff = r_sleb128 (&p4, p4_end);
			line += line_diff;
			}
			break;	
		case 0x3: // DBG_START_LOCAL
			{
			ut64 register_num;
			ut64 name_idx;
			ut64 type_idx;
			p4 = r_uleb128 (p4, p4_end - p4, &register_num);
			p4 = r_uleb128 (p4, p4_end - p4, &name_idx); 
			name_idx -= 1;
			p4 = r_uleb128 (p4, p4_end - p4, &type_idx); 
			type_idx -= 1;
			if (register_num >= regsz) {
				r_list_free (debug_positions);
				r_list_free (params);
				return;
			}
			if (debug_locals[register_num].live) {
				struct dex_debug_local_t *local = malloc (
					sizeof (struct dex_debug_local_t));
				if (!local) {
					keep = false;
					break;
				}
				local->name = debug_locals[register_num].name;
				local->descriptor = debug_locals[register_num].descriptor;
				local->startAddress = debug_locals[register_num].startAddress;
				local->signature = debug_locals[register_num].signature;
				local->live = true;
				local->reg = register_num;
				local->endAddress = address;
				r_list_append (emitted_debug_locals, local);
			}
			debug_locals[register_num].name = getstr (bin, name_idx);
			debug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);
			debug_locals[register_num].startAddress = address;
			debug_locals[register_num].signature = NULL;
			debug_locals[register_num].live = true;
			}
			break;
		case 0x4: //DBG_START_LOCAL_EXTENDED
			{
			ut64 register_num;
			ut64 name_idx;
			ut64 type_idx;
			ut64 sig_idx;
			p4 = r_uleb128 (p4, p4_end - p4, &register_num);
			p4 = r_uleb128 (p4, p4_end - p4, &name_idx);
			name_idx -= 1;
			p4 = r_uleb128 (p4, p4_end - p4, &type_idx);
			type_idx -= 1;
			p4 = r_uleb128 (p4, p4_end - p4, &sig_idx);
			sig_idx -= 1;
			if (register_num >= regsz) {
				r_list_free (debug_positions);
				r_list_free (params);
				return;
			}

			if (debug_locals[register_num].live) {
				struct dex_debug_local_t *local = malloc (
					sizeof (struct dex_debug_local_t));
				if (!local) {
					keep = false;
					break;
				}
				local->name = debug_locals[register_num].name;
				local->descriptor = debug_locals[register_num].descriptor;
				local->startAddress = debug_locals[register_num].startAddress;
				local->signature = debug_locals[register_num].signature;
				local->live = true;
				local->reg = register_num;
				local->endAddress = address;
				r_list_append (emitted_debug_locals, local);
			}

			debug_locals[register_num].name = getstr (bin, name_idx);
			debug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);
			debug_locals[register_num].startAddress = address;
			debug_locals[register_num].signature = getstr (bin, sig_idx);
			debug_locals[register_num].live = true;
			}
			break;
		case 0x5: // DBG_END_LOCAL
			{
			ut64 register_num;
			p4 = r_uleb128 (p4, p4_end - p4, &register_num);
			if (debug_locals[register_num].live) {
				struct dex_debug_local_t *local = malloc (
					sizeof (struct dex_debug_local_t));
				if (!local) {
					keep = false;
					break;
				}
				local->name = debug_locals[register_num].name;
				local->descriptor = debug_locals[register_num].descriptor;
				local->startAddress = debug_locals[register_num].startAddress;
				local->signature = debug_locals[register_num].signature;
				local->live = true;
				local->reg = register_num;
				local->endAddress = address;
				r_list_append (emitted_debug_locals, local);
			}
			debug_locals[register_num].live = false;
			}
			break;
		case 0x6: // DBG_RESTART_LOCAL
			{
			ut64 register_num;
			p4 = r_uleb128 (p4, p4_end - p4, &register_num);
			if (!debug_locals[register_num].live) {
				debug_locals[register_num].startAddress = address;
				debug_locals[register_num].live = true;
			}
			}
			break;
		case 0x7: //DBG_SET_PROLOGUE_END
			break;
		case 0x8: //DBG_SET_PROLOGUE_BEGIN
			break;
		case 0x9:
			{
			p4 = r_uleb128 (p4, p4_end - p4, &source_file_idx);
			source_file_idx--;
			}
			break;
		default:
			{
			int adjusted_opcode = opcode - 0x0a;
			address += (adjusted_opcode / 15);
			line += -4 + (adjusted_opcode % 15);
			struct dex_debug_position_t *position =
				malloc (sizeof (struct dex_debug_position_t));
			if (!position) {
				keep = false;
				break;
			}
			position->source_file_idx = source_file_idx;
			position->address = address;
			position->line = line;
			r_list_append (debug_positions, position);
			}
			break;
		}
		opcode = *(p4++) & 0xff;
	}

	if (!binfile->sdb_addrinfo) {
		binfile->sdb_addrinfo = sdb_new0 ();
	}

	char *fileline;
	char offset[64];
	char *offset_ptr;

	RListIter *iter1;
	struct dex_debug_position_t *pos;
	r_list_foreach (debug_positions, iter1, pos) {
		fileline = r_str_newf (""%s|%""PFMT64d, getstr (bin, pos->source_file_idx), pos->line);
		offset_ptr = sdb_itoa (pos->address + paddr, offset, 16);
		sdb_set (binfile->sdb_addrinfo, offset_ptr, fileline, 0);
		sdb_set (binfile->sdb_addrinfo, fileline, offset_ptr, 0);
	}

	if (!dexdump) {
		r_list_free (debug_positions);
		r_list_free (emitted_debug_locals);
		r_list_free (params);
		return;
	}

	RListIter *iter2;
	struct dex_debug_position_t *position;

	rbin->cb_printf (""      positions     :\n"");
	r_list_foreach (debug_positions, iter2, position) {
		rbin->cb_printf (""        0x%04llx line=%llu\n"",
				 position->address, position->line);
	}

	rbin->cb_printf (""      locals        :\n"");

	RListIter *iter3;
	struct dex_debug_local_t *local;
	r_list_foreach (emitted_debug_locals, iter3, local) {
		if (local->signature) {
			rbin->cb_printf (
				""        0x%04x - 0x%04x reg=%d %s %s %s\n"",
				local->startAddress, local->endAddress,
				local->reg, local->name, local->descriptor,
				local->signature);
		} else {
			rbin->cb_printf (
				""        0x%04x - 0x%04x reg=%d %s %s\n"",
				local->startAddress, local->endAddress,
				local->reg, local->name, local->descriptor);
		}
	}

	for (reg = 0; reg < regsz; reg++) {
		if (debug_locals[reg].live) {
			if (debug_locals[reg].signature) {
				rbin->cb_printf (
					""        0x%04x - 0x%04x reg=%d %s %s ""
					""%s\n"",
					debug_locals[reg].startAddress,
					insns_size, reg, debug_locals[reg].name,
					debug_locals[reg].descriptor,
					debug_locals[reg].signature);
			} else {
				rbin->cb_printf (
					""        0x%04x - 0x%04x reg=%d %s %s""
					""\n"",
					debug_locals[reg].startAddress,
					insns_size, reg, debug_locals[reg].name,
					debug_locals[reg].descriptor);
			}
		}
	}
	r_list_free (debug_positions);
	r_list_free (emitted_debug_locals);
	r_list_free (params);
}
",C,"	if (p4 <= 0) {
		return;
	}
",,,"@@ -377,6 +377,9 @@ static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,
 		--parameters_size;
 	}
 
+	if (p4 <= 0) {
+		return;
+	}
 	ut8 opcode = *(p4++) & 0xff;
 	while (keep) {
 		switch (opcode) {",radare2,252afb1cff9676f3ae1f341a28448bf2c8b6e308,20b8a9582c1e554747462cdb8fa663b82387a452,1,"static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,
				  RBinDexClass *c, int MI, int MA, int paddr, int ins_size,
				  int insns_size, char *class_name, int regsz,
				  int debug_info_off) {
	struct r_bin_t *rbin = binfile->rbin;
	const ut8 *p4 = r_buf_get_at (binfile->buf, debug_info_off, NULL);
	const ut8 *p4_end = p4 + binfile->buf->length - debug_info_off;
	ut64 line_start;
	ut64 parameters_size;
	ut64 param_type_idx;
	ut16 argReg = regsz - ins_size;
	ut64 source_file_idx = c->source_file;
	RList *params, *debug_positions, *emitted_debug_locals = NULL; 
	bool keep = true;
	if (argReg > regsz) {
		return; // this return breaks tests
	}
	p4 = r_uleb128 (p4, p4_end - p4, &line_start);
	p4 = r_uleb128 (p4, p4_end - p4, &parameters_size);
	// TODO: check when we should use source_file
	// The state machine consists of five registers
	ut32 address = 0;
	ut32 line = line_start;
	if (!(debug_positions = r_list_newf ((RListFree)free))) {
		return;	
	}
	if (!(emitted_debug_locals = r_list_newf ((RListFree)free))) {
		r_list_free (debug_positions);
		return;
	}

	struct dex_debug_local_t debug_locals[regsz];
	memset (debug_locals, 0, sizeof (struct dex_debug_local_t) * regsz);
	if (!(MA & 0x0008)) {
		debug_locals[argReg].name = ""this"";
		debug_locals[argReg].descriptor = r_str_newf(""%s;"", class_name);
		debug_locals[argReg].startAddress = 0;
		debug_locals[argReg].signature = NULL;
		debug_locals[argReg].live = true;
		argReg++;
	}
	if (!(params = dex_method_signature2 (bin, MI))) {
		r_list_free (debug_positions);
		r_list_free (emitted_debug_locals);
		return;
	}

	RListIter *iter = r_list_iterator (params);
	char *name;
	char *type;
	int reg;

	r_list_foreach (params, iter, type) {
		if ((argReg >= regsz) || !type || parameters_size <= 0) {
			r_list_free (debug_positions);
			r_list_free (params);
			r_list_free (emitted_debug_locals);
			return;
		}
		p4 = r_uleb128 (p4, p4_end - p4, &param_type_idx); // read uleb128p1
		param_type_idx -= 1;
		name = getstr (bin, param_type_idx);
		reg = argReg;
		switch (type[0]) {
		case 'D':
		case 'J':
			argReg += 2;
			break;
		default:
			argReg += 1;
			break;
		}
		if (name) {
			debug_locals[reg].name = name;
			debug_locals[reg].descriptor = type;
			debug_locals[reg].signature = NULL;
			debug_locals[reg].startAddress = address;
			debug_locals[reg].live = true;
		}
 		--parameters_size;
 	}
 
//fix_flaw_line_below:
//	if (p4 <= 0) {
//fix_flaw_line_below:
//		return;
//fix_flaw_line_below:
//	}
 	ut8 opcode = *(p4++) & 0xff;
 	while (keep) {
 		switch (opcode) {
		case 0x0: // DBG_END_SEQUENCE
			keep = false;
			break;
		case 0x1: // DBG_ADVANCE_PC
			{
			ut64 addr_diff;
			p4 = r_uleb128 (p4, p4_end - p4, &addr_diff);
			address += addr_diff;
			}
			break;
		case 0x2: // DBG_ADVANCE_LINE
			{
			st64 line_diff = r_sleb128 (&p4, p4_end);
			line += line_diff;
			}
			break;	
		case 0x3: // DBG_START_LOCAL
			{
			ut64 register_num;
			ut64 name_idx;
			ut64 type_idx;
			p4 = r_uleb128 (p4, p4_end - p4, &register_num);
			p4 = r_uleb128 (p4, p4_end - p4, &name_idx); 
			name_idx -= 1;
			p4 = r_uleb128 (p4, p4_end - p4, &type_idx); 
			type_idx -= 1;
			if (register_num >= regsz) {
				r_list_free (debug_positions);
				r_list_free (params);
				return;
			}
			// Emit what was previously there, if anything
			// emitLocalCbIfLive
			if (debug_locals[register_num].live) {
				struct dex_debug_local_t *local = malloc (
					sizeof (struct dex_debug_local_t));
				if (!local) {
					keep = false;
					break;
				}
				local->name = debug_locals[register_num].name;
				local->descriptor = debug_locals[register_num].descriptor;
				local->startAddress = debug_locals[register_num].startAddress;
				local->signature = debug_locals[register_num].signature;
				local->live = true;
				local->reg = register_num;
				local->endAddress = address;
				r_list_append (emitted_debug_locals, local);
			}
			debug_locals[register_num].name = getstr (bin, name_idx);
			debug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);
			debug_locals[register_num].startAddress = address;
			debug_locals[register_num].signature = NULL;
			debug_locals[register_num].live = true;
			//eprintf(""DBG_START_LOCAL %x %x %x\n"", register_num, name_idx, type_idx);
			}
			break;
		case 0x4: //DBG_START_LOCAL_EXTENDED
			{
			ut64 register_num;
			ut64 name_idx;
			ut64 type_idx;
			ut64 sig_idx;
			p4 = r_uleb128 (p4, p4_end - p4, &register_num);
			p4 = r_uleb128 (p4, p4_end - p4, &name_idx);
			name_idx -= 1;
			p4 = r_uleb128 (p4, p4_end - p4, &type_idx);
			type_idx -= 1;
			p4 = r_uleb128 (p4, p4_end - p4, &sig_idx);
			sig_idx -= 1;
			if (register_num >= regsz) {
				r_list_free (debug_positions);
				r_list_free (params);
				return;
			}

			// Emit what was previously there, if anything
			// emitLocalCbIfLive
			if (debug_locals[register_num].live) {
				struct dex_debug_local_t *local = malloc (
					sizeof (struct dex_debug_local_t));
				if (!local) {
					keep = false;
					break;
				}
				local->name = debug_locals[register_num].name;
				local->descriptor = debug_locals[register_num].descriptor;
				local->startAddress = debug_locals[register_num].startAddress;
				local->signature = debug_locals[register_num].signature;
				local->live = true;
				local->reg = register_num;
				local->endAddress = address;
				r_list_append (emitted_debug_locals, local);
			}

			debug_locals[register_num].name = getstr (bin, name_idx);
			debug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);
			debug_locals[register_num].startAddress = address;
			debug_locals[register_num].signature = getstr (bin, sig_idx);
			debug_locals[register_num].live = true;
			}
			break;
		case 0x5: // DBG_END_LOCAL
			{
			ut64 register_num;
			p4 = r_uleb128 (p4, p4_end - p4, &register_num);
			// emitLocalCbIfLive
			if (debug_locals[register_num].live) {
				struct dex_debug_local_t *local = malloc (
					sizeof (struct dex_debug_local_t));
				if (!local) {
					keep = false;
					break;
				}
				local->name = debug_locals[register_num].name;
				local->descriptor = debug_locals[register_num].descriptor;
				local->startAddress = debug_locals[register_num].startAddress;
				local->signature = debug_locals[register_num].signature;
				local->live = true;
				local->reg = register_num;
				local->endAddress = address;
				r_list_append (emitted_debug_locals, local);
			}
			debug_locals[register_num].live = false;
			}
			break;
		case 0x6: // DBG_RESTART_LOCAL
			{
			ut64 register_num;
			p4 = r_uleb128 (p4, p4_end - p4, &register_num);
			if (!debug_locals[register_num].live) {
				debug_locals[register_num].startAddress = address;
				debug_locals[register_num].live = true;
			}
			}
			break;
		case 0x7: //DBG_SET_PROLOGUE_END
			break;
		case 0x8: //DBG_SET_PROLOGUE_BEGIN
			break;
		case 0x9:
			{
			p4 = r_uleb128 (p4, p4_end - p4, &source_file_idx);
			source_file_idx--;
			}
			break;
		default:
			{
			int adjusted_opcode = opcode - 0x0a;
			address += (adjusted_opcode / 15);
			line += -4 + (adjusted_opcode % 15);
			struct dex_debug_position_t *position =
				malloc (sizeof (struct dex_debug_position_t));
			if (!position) {
				keep = false;
				break;
			}
			position->source_file_idx = source_file_idx;
			position->address = address;
			position->line = line;
			r_list_append (debug_positions, position);
			}
			break;
		}
		opcode = *(p4++) & 0xff;
	}

	if (!binfile->sdb_addrinfo) {
		binfile->sdb_addrinfo = sdb_new0 ();
	}

	char *fileline;
	char offset[64];
	char *offset_ptr;

	RListIter *iter1;
	struct dex_debug_position_t *pos;
	r_list_foreach (debug_positions, iter1, pos) {
		fileline = r_str_newf (""%s|%""PFMT64d, getstr (bin, pos->source_file_idx), pos->line);
		offset_ptr = sdb_itoa (pos->address + paddr, offset, 16);
		sdb_set (binfile->sdb_addrinfo, offset_ptr, fileline, 0);
		sdb_set (binfile->sdb_addrinfo, fileline, offset_ptr, 0);
	}

	if (!dexdump) {
		r_list_free (debug_positions);
		r_list_free (emitted_debug_locals);
		r_list_free (params);
		return;
	}

	RListIter *iter2;
	struct dex_debug_position_t *position;

	rbin->cb_printf (""      positions     :\n"");
	r_list_foreach (debug_positions, iter2, position) {
		rbin->cb_printf (""        0x%04llx line=%llu\n"",
				 position->address, position->line);
	}

	rbin->cb_printf (""      locals        :\n"");

	RListIter *iter3;
	struct dex_debug_local_t *local;
	r_list_foreach (emitted_debug_locals, iter3, local) {
		if (local->signature) {
			rbin->cb_printf (
				""        0x%04x - 0x%04x reg=%d %s %s %s\n"",
				local->startAddress, local->endAddress,
				local->reg, local->name, local->descriptor,
				local->signature);
		} else {
			rbin->cb_printf (
				""        0x%04x - 0x%04x reg=%d %s %s\n"",
				local->startAddress, local->endAddress,
				local->reg, local->name, local->descriptor);
		}
	}

	for (reg = 0; reg < regsz; reg++) {
		if (debug_locals[reg].live) {
			if (debug_locals[reg].signature) {
				rbin->cb_printf (
					""        0x%04x - 0x%04x reg=%d %s %s ""
					""%s\n"",
					debug_locals[reg].startAddress,
					insns_size, reg, debug_locals[reg].name,
					debug_locals[reg].descriptor,
					debug_locals[reg].signature);
			} else {
				rbin->cb_printf (
					""        0x%04x - 0x%04x reg=%d %s %s""
					""\n"",
					debug_locals[reg].startAddress,
					insns_size, reg, debug_locals[reg].name,
					debug_locals[reg].descriptor);
			}
		}
	}
	r_list_free (debug_positions);
	r_list_free (emitted_debug_locals);
	r_list_free (params);
}
"
3798,181534,,Remote,Not required,Partial,CVE-2017-6197,https://www.cvedetails.com/cve/CVE-2017-6197/,CWE-476,Medium,,,,2017-02-23,4.3,"The r_read_* functions in libr/include/r_endian.h in radare2 1.2.1 allow remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted binary file, as demonstrated by the r_read_le32 function.",2017-03-01,DoS ,1,https://github.com/radare/radare2/commit/1ea23bd6040441a21fbcfba69dce9a01af03f989,1ea23bd6040441a21fbcfba69dce9a01af03f989,Fix #6816 - null deref in r_read_*,1,libr/bin/p/bin_dex.c,"{""sha"": ""42810ad098b674030ce946c69e0b58d84eeddf4e"", ""filename"": ""doc/uncrustify.cfg"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/radareorg/radare2/blob/1ea23bd6040441a21fbcfba69dce9a01af03f989/doc/uncrustify.cfg"", ""raw_url"": ""https://github.com/radareorg/radare2/raw/1ea23bd6040441a21fbcfba69dce9a01af03f989/doc/uncrustify.cfg"", ""contents_url"": ""https://api.github.com/repos/radareorg/radare2/contents/doc/uncrustify.cfg?ref=1ea23bd6040441a21fbcfba69dce9a01af03f989"", ""patch"": ""@@ -483,7 +483,7 @@ nl_before_block_comment         = 0\n nl_before_c_comment             = 0\n nl_before_cpp_comment           = 0\n nl_after_multiline_comment      = false\n-nl_after_label_colon            = force\n+nl_after_label_colon            = true\n nl_after_struct                 = 0\n nl_before_class                 = 0\n nl_after_class                  = 0""}<_**next**_>{""sha"": ""601b28a5d71f3006e06715d7764ac01fc72b4042"", ""filename"": ""libr/bin/p/bin_dex.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/radareorg/radare2/blob/1ea23bd6040441a21fbcfba69dce9a01af03f989/libr/bin/p/bin_dex.c"", ""raw_url"": ""https://github.com/radareorg/radare2/raw/1ea23bd6040441a21fbcfba69dce9a01af03f989/libr/bin/p/bin_dex.c"", ""contents_url"": ""https://api.github.com/repos/radareorg/radare2/contents/libr/bin/p/bin_dex.c?ref=1ea23bd6040441a21fbcfba69dce9a01af03f989"", ""patch"": ""@@ -1322,7 +1322,7 @@ static void parse_class(RBinFile *binfile, RBinDexObj *bin, RBinDexClass *c,\n \t    c->interfaces_offset <\n \t\t    bin->header.data_offset + bin->header.data_size) {\n \t\tp = r_buf_get_at (binfile->buf, c->interfaces_offset, NULL);\n-\t\tint types_list_size = r_read_le32(p);\n+\t\tint types_list_size = r_read_le32 (p);\n \t\tif (types_list_size < 0 || types_list_size >= bin->header.types_size ) {\n \t\t\treturn;\n \t\t}""}<_**next**_>{""sha"": ""1a2afc603aa9d493353e9f8d0d73561361d8a06c"", ""filename"": ""libr/include/r_endian.h"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 0, ""changes"": 19, ""blob_url"": ""https://github.com/radareorg/radare2/blob/1ea23bd6040441a21fbcfba69dce9a01af03f989/libr/include/r_endian.h"", ""raw_url"": ""https://github.com/radareorg/radare2/raw/1ea23bd6040441a21fbcfba69dce9a01af03f989/libr/include/r_endian.h"", ""contents_url"": ""https://api.github.com/repos/radareorg/radare2/contents/libr/include/r_endian.h?ref=1ea23bd6040441a21fbcfba69dce9a01af03f989"", ""patch"": ""@@ -8,6 +8,9 @@ extern \""C\"" {\n /* Endian agnostic functions working on single byte. */\n \n static inline ut8 r_read_ble8(const void *src) {\n+\tif (!src) {\n+\t\treturn UT8_MAX;\n+\t}\n \treturn *(ut8 *)src;\n }\n \n@@ -114,6 +117,9 @@ static inline void r_write_at_be64(void *dest, ut64 val, size_t offset) {\n /* Little Endian functions. */\n \n static inline ut8 r_read_le8(const void *src) {\n+\tif (!src) {\n+\t\treturn UT8_MAX;\n+\t}\n \treturn r_read_ble8 (src);\n }\n \n@@ -130,11 +136,17 @@ static inline void r_write_at_le8(void *dest, ut8 val, size_t offset) {\n }\n \n static inline ut16 r_read_le16(const void *src) {\n+\tif (!src) {\n+\t\treturn UT16_MAX;\n+\t}\n \tconst ut8 *s = (const ut8*)src;\n \treturn (((ut16)s[1]) << 8) | (((ut16)s[0]) << 0);\n }\n \n static inline ut16 r_read_at_le16(const void *src, size_t offset) {\n+\tif (!src) {\n+\t\treturn UT16_MAX;\n+\t}\n \tconst ut8 *s = (const ut8*)src + offset;\n \treturn r_read_le16 (s);\n }\n@@ -157,12 +169,18 @@ static inline void r_write_le24(void *_dest, ut32 val) {\n }\n \n static inline ut32 r_read_le32(const void *src) {\n+\tif (!src) {\n+\t\treturn UT32_MAX;\n+\t}\n \tconst ut8 *s = (const ut8*)src;\n \treturn (((ut32)s[3]) << 24) | (((ut32)s[2]) << 16) |\n \t\t(((ut32)s[1]) << 8) | (((ut32)s[0]) << 0);\n }\n \n static inline ut32 r_read_at_le32(const void *src, size_t offset) {\n+\tif (!src) {\n+\t\treturn UT32_MAX;\n+\t}\n \tconst ut8 *s = (const ut8*)src + offset;\n \treturn r_read_le32 (s);\n }\n@@ -426,6 +444,7 @@ static inline int UT8_SUB(ut8 *r, ut8 a, ut8 b) {\n \t}\n \treturn 1;\n }\n+\n #ifdef __cplusplus\n }\n #endif""}","static void parse_class(RBinFile *binfile, RBinDexObj *bin, RBinDexClass *c,
			 int class_index, int *methods, int *sym_count) {
	struct r_bin_t *rbin = binfile->rbin;

	char *class_name;
	int z;
	const ut8 *p, *p_end;

	if (!c) {
		return;
	}

	class_name = dex_class_name (bin, c);
	class_name = r_str_replace (class_name, "";"", """", 0); //TODO: move to func

	if (!class_name || !*class_name) {
		return;
	}

	RBinClass *cls = R_NEW0 (RBinClass);
	if (!cls) {
		return;
	}
	cls->name = class_name;
	cls->index = class_index;
	cls->addr = bin->header.class_offset + class_index * DEX_CLASS_SIZE;
	cls->methods = r_list_new ();
	if (!cls->methods) {
		free (cls);
		return;
	}
	cls->fields = r_list_new ();
	if (!cls->fields) {
		r_list_free (cls->methods);
		free (cls);
		return;
	}
	r_list_append (bin->classes_list, cls);
	if (dexdump) {
		rbin->cb_printf (""  Class descriptor  : '%s;'\n"", class_name);
		rbin->cb_printf (
			""  Access flags      : 0x%04x (%s)\n"", c->access_flags,
			createAccessFlagStr (c->access_flags, kAccessForClass));
		rbin->cb_printf (""  Superclass        : '%s'\n"",
				 dex_class_super_name (bin, c));
		rbin->cb_printf (""  Interfaces        -\n"");
	}

	if (c->interfaces_offset > 0 &&
	    bin->header.data_offset < c->interfaces_offset &&
 	    c->interfaces_offset <
 		    bin->header.data_offset + bin->header.data_size) {
 		p = r_buf_get_at (binfile->buf, c->interfaces_offset, NULL);
		int types_list_size = r_read_le32 (p);
 		if (types_list_size < 0 || types_list_size >= bin->header.types_size ) {
 			return;
 		}
		for (z = 0; z < types_list_size; z++) {
			int t = r_read_le16 (p + 4 + z * 2);
			if (t > 0 && t < bin->header.types_size ) {
				int tid = bin->types[t].descriptor_id;
				if (dexdump) {
					rbin->cb_printf (
						""    #%d              : '%s'\n"",
						z, getstr (bin, tid));
				}
			}
		}
	}

	if (!c || !c->class_data_offset) {
		if (dexdump) {
			rbin->cb_printf (
				""  Static fields     -\n  Instance fields   ""
				""-\n  Direct methods    -\n  Virtual methods   ""
				""-\n"");
		}
	} else {
		if (bin->header.class_offset > c->class_data_offset ||
		    c->class_data_offset <
			    bin->header.class_offset +
				    bin->header.class_size * DEX_CLASS_SIZE) {
			return;
		}

		p = r_buf_get_at (binfile->buf, c->class_data_offset, NULL);
		p_end = p + binfile->buf->length - c->class_data_offset;
		c->class_data = (struct dex_class_data_item_t *)malloc (
			sizeof (struct dex_class_data_item_t));
		p = r_uleb128 (p, p_end - p, &c->class_data->static_fields_size);
		p = r_uleb128 (p, p_end - p, &c->class_data->instance_fields_size);
		p = r_uleb128 (p, p_end - p, &c->class_data->direct_methods_size);
		p = r_uleb128 (p, p_end - p, &c->class_data->virtual_methods_size);

		if (dexdump) { 
			rbin->cb_printf (""  Static fields     -\n""); 
		}
		p = parse_dex_class_fields (
			binfile, bin, c, cls, p, p_end, sym_count,
			c->class_data->static_fields_size, true);

		if (dexdump) { 
			rbin->cb_printf (""  Instance fields   -\n"");
		}
		p = parse_dex_class_fields (
			binfile, bin, c, cls, p, p_end, sym_count,
			c->class_data->instance_fields_size, false);

		if (dexdump) { 
			rbin->cb_printf (""  Direct methods    -\n"");
		}
		p = parse_dex_class_method (
			binfile, bin, c, cls, p, p_end, sym_count,
			c->class_data->direct_methods_size, methods, true);

		if (dexdump) { 
			rbin->cb_printf (""  Virtual methods   -\n"");
		}
		p = parse_dex_class_method (
			binfile, bin, c, cls, p, p_end, sym_count,
			c->class_data->virtual_methods_size, methods, false);
	}

	if (dexdump) { 
		char *source_file = getstr (bin, c->source_file);
		if (!source_file) {
			rbin->cb_printf (
				""  source_file_idx   : %d (unknown)\n\n"",
				c->source_file);
		} else {
			rbin->cb_printf (""  source_file_idx   : %d (%s)\n\n"",
					 c->source_file, source_file);
		}
	}
}
","static void parse_class(RBinFile *binfile, RBinDexObj *bin, RBinDexClass *c,
			 int class_index, int *methods, int *sym_count) {
	struct r_bin_t *rbin = binfile->rbin;

	char *class_name;
	int z;
	const ut8 *p, *p_end;

	if (!c) {
		return;
	}

	class_name = dex_class_name (bin, c);
	class_name = r_str_replace (class_name, "";"", """", 0); //TODO: move to func

	if (!class_name || !*class_name) {
		return;
	}

	RBinClass *cls = R_NEW0 (RBinClass);
	if (!cls) {
		return;
	}
	cls->name = class_name;
	cls->index = class_index;
	cls->addr = bin->header.class_offset + class_index * DEX_CLASS_SIZE;
	cls->methods = r_list_new ();
	if (!cls->methods) {
		free (cls);
		return;
	}
	cls->fields = r_list_new ();
	if (!cls->fields) {
		r_list_free (cls->methods);
		free (cls);
		return;
	}
	r_list_append (bin->classes_list, cls);
	if (dexdump) {
		rbin->cb_printf (""  Class descriptor  : '%s;'\n"", class_name);
		rbin->cb_printf (
			""  Access flags      : 0x%04x (%s)\n"", c->access_flags,
			createAccessFlagStr (c->access_flags, kAccessForClass));
		rbin->cb_printf (""  Superclass        : '%s'\n"",
				 dex_class_super_name (bin, c));
		rbin->cb_printf (""  Interfaces        -\n"");
	}

	if (c->interfaces_offset > 0 &&
	    bin->header.data_offset < c->interfaces_offset &&
 	    c->interfaces_offset <
 		    bin->header.data_offset + bin->header.data_size) {
 		p = r_buf_get_at (binfile->buf, c->interfaces_offset, NULL);
		int types_list_size = r_read_le32(p);
 		if (types_list_size < 0 || types_list_size >= bin->header.types_size ) {
 			return;
 		}
		for (z = 0; z < types_list_size; z++) {
			int t = r_read_le16 (p + 4 + z * 2);
			if (t > 0 && t < bin->header.types_size ) {
				int tid = bin->types[t].descriptor_id;
				if (dexdump) {
					rbin->cb_printf (
						""    #%d              : '%s'\n"",
						z, getstr (bin, tid));
				}
			}
		}
	}

	if (!c || !c->class_data_offset) {
		if (dexdump) {
			rbin->cb_printf (
				""  Static fields     -\n  Instance fields   ""
				""-\n  Direct methods    -\n  Virtual methods   ""
				""-\n"");
		}
	} else {
		if (bin->header.class_offset > c->class_data_offset ||
		    c->class_data_offset <
			    bin->header.class_offset +
				    bin->header.class_size * DEX_CLASS_SIZE) {
			return;
		}

		p = r_buf_get_at (binfile->buf, c->class_data_offset, NULL);
		p_end = p + binfile->buf->length - c->class_data_offset;
		c->class_data = (struct dex_class_data_item_t *)malloc (
			sizeof (struct dex_class_data_item_t));
		p = r_uleb128 (p, p_end - p, &c->class_data->static_fields_size);
		p = r_uleb128 (p, p_end - p, &c->class_data->instance_fields_size);
		p = r_uleb128 (p, p_end - p, &c->class_data->direct_methods_size);
		p = r_uleb128 (p, p_end - p, &c->class_data->virtual_methods_size);

		if (dexdump) { 
			rbin->cb_printf (""  Static fields     -\n""); 
		}
		p = parse_dex_class_fields (
			binfile, bin, c, cls, p, p_end, sym_count,
			c->class_data->static_fields_size, true);

		if (dexdump) { 
			rbin->cb_printf (""  Instance fields   -\n"");
		}
		p = parse_dex_class_fields (
			binfile, bin, c, cls, p, p_end, sym_count,
			c->class_data->instance_fields_size, false);

		if (dexdump) { 
			rbin->cb_printf (""  Direct methods    -\n"");
		}
		p = parse_dex_class_method (
			binfile, bin, c, cls, p, p_end, sym_count,
			c->class_data->direct_methods_size, methods, true);

		if (dexdump) { 
			rbin->cb_printf (""  Virtual methods   -\n"");
		}
		p = parse_dex_class_method (
			binfile, bin, c, cls, p, p_end, sym_count,
			c->class_data->virtual_methods_size, methods, false);
	}

	if (dexdump) { 
		char *source_file = getstr (bin, c->source_file);
		if (!source_file) {
			rbin->cb_printf (
				""  source_file_idx   : %d (unknown)\n\n"",
				c->source_file);
		} else {
			rbin->cb_printf (""  source_file_idx   : %d (%s)\n\n"",
					 c->source_file, source_file);
		}
	}
}
",C,"		int types_list_size = r_read_le32 (p);
","		int types_list_size = r_read_le32(p);
",,"@@ -1322,7 +1322,7 @@ static void parse_class(RBinFile *binfile, RBinDexObj *bin, RBinDexClass *c,
 	    c->interfaces_offset <
 		    bin->header.data_offset + bin->header.data_size) {
 		p = r_buf_get_at (binfile->buf, c->interfaces_offset, NULL);
-		int types_list_size = r_read_le32(p);
+		int types_list_size = r_read_le32 (p);
 		if (types_list_size < 0 || types_list_size >= bin->header.types_size ) {
 			return;
 		}",radare2,1ea23bd6040441a21fbcfba69dce9a01af03f989,0ae4a5c3e8da054e27c0917a8857ba979fa432e0,1,"static void parse_class(RBinFile *binfile, RBinDexObj *bin, RBinDexClass *c,
			 int class_index, int *methods, int *sym_count) {
	struct r_bin_t *rbin = binfile->rbin;

	char *class_name;
	int z;
	const ut8 *p, *p_end;

	if (!c) {
		return;
	}

	class_name = dex_class_name (bin, c);
	class_name = r_str_replace (class_name, "";"", """", 0); //TODO: move to func

	if (!class_name || !*class_name) {
		return;
	}

	RBinClass *cls = R_NEW0 (RBinClass);
	if (!cls) {
		return;
	}
	cls->name = class_name;
	cls->index = class_index;
	cls->addr = bin->header.class_offset + class_index * DEX_CLASS_SIZE;
	cls->methods = r_list_new ();
	if (!cls->methods) {
		free (cls);
		return;
	}
	cls->fields = r_list_new ();
	if (!cls->fields) {
		r_list_free (cls->methods);
		free (cls);
		return;
	}
	r_list_append (bin->classes_list, cls);
	if (dexdump) {
		rbin->cb_printf (""  Class descriptor  : '%s;'\n"", class_name);
		rbin->cb_printf (
			""  Access flags      : 0x%04x (%s)\n"", c->access_flags,
			createAccessFlagStr (c->access_flags, kAccessForClass));
		rbin->cb_printf (""  Superclass        : '%s'\n"",
				 dex_class_super_name (bin, c));
		rbin->cb_printf (""  Interfaces        -\n"");
	}

	if (c->interfaces_offset > 0 &&
	    bin->header.data_offset < c->interfaces_offset &&
 	    c->interfaces_offset <
 		    bin->header.data_offset + bin->header.data_size) {
 		p = r_buf_get_at (binfile->buf, c->interfaces_offset, NULL);
//flaw_line_below:
		int types_list_size = r_read_le32(p);
//fix_flaw_line_below:
//		int types_list_size = r_read_le32 (p);
 		if (types_list_size < 0 || types_list_size >= bin->header.types_size ) {
 			return;
 		}
		for (z = 0; z < types_list_size; z++) {
			int t = r_read_le16 (p + 4 + z * 2);
			if (t > 0 && t < bin->header.types_size ) {
				int tid = bin->types[t].descriptor_id;
				if (dexdump) {
					rbin->cb_printf (
						""    #%d              : '%s'\n"",
						z, getstr (bin, tid));
				}
			}
		}
	}

	// TODO: this is quite ugly
	if (!c || !c->class_data_offset) {
		if (dexdump) {
			rbin->cb_printf (
				""  Static fields     -\n  Instance fields   ""
				""-\n  Direct methods    -\n  Virtual methods   ""
				""-\n"");
		}
	} else {
		// TODO: move to func, def or inline
		// class_data_offset => [class_offset, class_defs_off+class_defs_size*32]
		if (bin->header.class_offset > c->class_data_offset ||
		    c->class_data_offset <
			    bin->header.class_offset +
				    bin->header.class_size * DEX_CLASS_SIZE) {
			return;
		}

		p = r_buf_get_at (binfile->buf, c->class_data_offset, NULL);
		p_end = p + binfile->buf->length - c->class_data_offset;
		//XXX check for NULL!!
		c->class_data = (struct dex_class_data_item_t *)malloc (
			sizeof (struct dex_class_data_item_t));
		p = r_uleb128 (p, p_end - p, &c->class_data->static_fields_size);
		p = r_uleb128 (p, p_end - p, &c->class_data->instance_fields_size);
		p = r_uleb128 (p, p_end - p, &c->class_data->direct_methods_size);
		p = r_uleb128 (p, p_end - p, &c->class_data->virtual_methods_size);

		if (dexdump) { 
			rbin->cb_printf (""  Static fields     -\n""); 
		}
		p = parse_dex_class_fields (
			binfile, bin, c, cls, p, p_end, sym_count,
			c->class_data->static_fields_size, true);

		if (dexdump) { 
			rbin->cb_printf (""  Instance fields   -\n"");
		}
		p = parse_dex_class_fields (
			binfile, bin, c, cls, p, p_end, sym_count,
			c->class_data->instance_fields_size, false);

		if (dexdump) { 
			rbin->cb_printf (""  Direct methods    -\n"");
		}
		p = parse_dex_class_method (
			binfile, bin, c, cls, p, p_end, sym_count,
			c->class_data->direct_methods_size, methods, true);

		if (dexdump) { 
			rbin->cb_printf (""  Virtual methods   -\n"");
		}
		p = parse_dex_class_method (
			binfile, bin, c, cls, p, p_end, sym_count,
			c->class_data->virtual_methods_size, methods, false);
	}

	if (dexdump) { 
		char *source_file = getstr (bin, c->source_file);
		if (!source_file) {
			rbin->cb_printf (
				""  source_file_idx   : %d (unknown)\n\n"",
				c->source_file);
		} else {
			rbin->cb_printf (""  source_file_idx   : %d (%s)\n\n"",
					 c->source_file, source_file);
		}
	}
	// TODO:!!!!
	// FIX: FREE BEFORE ALLOCATE!!!
	//free (class_name);
}
"
3806,181542,,Remote,Not required,Partial,CVE-2017-5970,https://www.cvedetails.com/cve/CVE-2017-5970/,CWE-476,Low,,,,2017-02-14,5.0,The ipv4_pktinfo_prepare function in net/ipv4/ip_sockglue.c in the Linux kernel through 4.9.9 allows attackers to cause a denial of service (system crash) via (1) an application that makes crafted system calls or possibly (2) IPv4 traffic with invalid IP options.,2019-10-02,DoS ,8,https://github.com/torvalds/linux/commit/34b2cef20f19c87999fff3da4071e66937db9644,34b2cef20f19c87999fff3da4071e66937db9644,"ipv4: keep skb->dst around in presence of IP options

Andrey Konovalov got crashes in __ip_options_echo() when a NULL skb->dst
is accessed.

ipv4_pktinfo_prepare() should not drop the dst if (evil) IP options
are present.

We could refine the test to the presence of ts_needtime or srr,
but IP options are not often used, so let's be conservative.

Thanks to syzkaller team for finding this bug.

Fixes: d826eb14ecef (""ipv4: PKTINFO doesnt need dst reference"")
Signed-off-by: Eric Dumazet <edumazet@google.com>
Reported-by: Andrey Konovalov <andreyknvl@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/ipv4/ip_sockglue.c,"{""sha"": ""900011709e3b8e4807daaa6bf537c3871a7d9306"", ""filename"": ""net/ipv4/ip_sockglue.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 1, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/34b2cef20f19c87999fff3da4071e66937db9644/net/ipv4/ip_sockglue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/34b2cef20f19c87999fff3da4071e66937db9644/net/ipv4/ip_sockglue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/ip_sockglue.c?ref=34b2cef20f19c87999fff3da4071e66937db9644"", ""patch"": ""@@ -1238,7 +1238,14 @@ void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n \t\tpktinfo->ipi_ifindex = 0;\n \t\tpktinfo->ipi_spec_dst.s_addr = 0;\n \t}\n-\tskb_dst_drop(skb);\n+\t/* We need to keep the dst for __ip_options_echo()\n+\t * We could restrict the test to opt.ts_needtime || opt.srr,\n+\t * but the following is good enough as IP options are not often used.\n+\t */\n+\tif (unlikely(IPCB(skb)->opt.optlen))\n+\t\tskb_dst_force(skb);\n+\telse\n+\t\tskb_dst_drop(skb);\n }\n \n int ip_setsockopt(struct sock *sk, int level,""}","void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)
{
	struct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);
	bool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||
		       ipv6_sk_rxinfo(sk);

	if (prepare && skb_rtable(skb)) {
		/* skb->cb is overloaded: prior to this point it is IP{6}CB
		 * which has interface index (iif) as the first member of the
		 * underlying inet{6}_skb_parm struct. This code then overlays
		 * PKTINFO_SKB_CB and in_pktinfo also has iif as the first
		 * element so the iif is picked up from the prior IPCB. If iif
		 * is the loopback interface, then return the sending interface
		 * (e.g., process binds socket to eth0 for Tx which is
		 * redirected to loopback in the rtable/dst).
		 */
		if (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)
			pktinfo->ipi_ifindex = inet_iif(skb);

		pktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);
	} else {
 		pktinfo->ipi_ifindex = 0;
 		pktinfo->ipi_spec_dst.s_addr = 0;
 	}
	/* We need to keep the dst for __ip_options_echo()
	 * We could restrict the test to opt.ts_needtime || opt.srr,
	 * but the following is good enough as IP options are not often used.
	 */
	if (unlikely(IPCB(skb)->opt.optlen))
		skb_dst_force(skb);
	else
		skb_dst_drop(skb);
 }
","void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)
{
	struct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);
	bool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||
		       ipv6_sk_rxinfo(sk);

	if (prepare && skb_rtable(skb)) {
		/* skb->cb is overloaded: prior to this point it is IP{6}CB
		 * which has interface index (iif) as the first member of the
		 * underlying inet{6}_skb_parm struct. This code then overlays
		 * PKTINFO_SKB_CB and in_pktinfo also has iif as the first
		 * element so the iif is picked up from the prior IPCB. If iif
		 * is the loopback interface, then return the sending interface
		 * (e.g., process binds socket to eth0 for Tx which is
		 * redirected to loopback in the rtable/dst).
		 */
		if (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)
			pktinfo->ipi_ifindex = inet_iif(skb);

		pktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);
	} else {
 		pktinfo->ipi_ifindex = 0;
 		pktinfo->ipi_spec_dst.s_addr = 0;
 	}
	skb_dst_drop(skb);
 }
",C,"	/* We need to keep the dst for __ip_options_echo()
	 * We could restrict the test to opt.ts_needtime || opt.srr,
	 * but the following is good enough as IP options are not often used.
	 */
	if (unlikely(IPCB(skb)->opt.optlen))
		skb_dst_force(skb);
	else
		skb_dst_drop(skb);
","	skb_dst_drop(skb);
",,"@@ -1238,7 +1238,14 @@ void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)
 		pktinfo->ipi_ifindex = 0;
 		pktinfo->ipi_spec_dst.s_addr = 0;
 	}
-	skb_dst_drop(skb);
+	/* We need to keep the dst for __ip_options_echo()
+	 * We could restrict the test to opt.ts_needtime || opt.srr,
+	 * but the following is good enough as IP options are not often used.
+	 */
+	if (unlikely(IPCB(skb)->opt.optlen))
+		skb_dst_force(skb);
+	else
+		skb_dst_drop(skb);
 }
 
 int ip_setsockopt(struct sock *sk, int level,",linux,34b2cef20f19c87999fff3da4071e66937db9644,5fa8bbda38c668e56b0c6cdecced2eac2fe36dec,1,"void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)
{
	struct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);
	bool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||
		       ipv6_sk_rxinfo(sk);

	if (prepare && skb_rtable(skb)) {
		/* skb->cb is overloaded: prior to this point it is IP{6}CB
		 * which has interface index (iif) as the first member of the
		 * underlying inet{6}_skb_parm struct. This code then overlays
		 * PKTINFO_SKB_CB and in_pktinfo also has iif as the first
		 * element so the iif is picked up from the prior IPCB. If iif
		 * is the loopback interface, then return the sending interface
		 * (e.g., process binds socket to eth0 for Tx which is
		 * redirected to loopback in the rtable/dst).
		 */
		if (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)
			pktinfo->ipi_ifindex = inet_iif(skb);

		pktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);
	} else {
 		pktinfo->ipi_ifindex = 0;
 		pktinfo->ipi_spec_dst.s_addr = 0;
 	}
//flaw_line_below:
	skb_dst_drop(skb);
//fix_flaw_line_below:
//	/* We need to keep the dst for __ip_options_echo()
//fix_flaw_line_below:
//	 * We could restrict the test to opt.ts_needtime || opt.srr,
//fix_flaw_line_below:
//	 * but the following is good enough as IP options are not often used.
//fix_flaw_line_below:
//	 */
//fix_flaw_line_below:
//	if (unlikely(IPCB(skb)->opt.optlen))
//fix_flaw_line_below:
//		skb_dst_force(skb);
//fix_flaw_line_below:
//	else
//fix_flaw_line_below:
//		skb_dst_drop(skb);
 }
"
3816,181552,,Remote,Not required,Partial,CVE-2017-5668,https://www.cvedetails.com/cve/CVE-2017-5668/,CWE-476,Low,Partial,Partial,,2017-03-14,7.5,bitlbee-libpurple before 3.5.1 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) and possibly execute arbitrary code via a file transfer request for a contact that is not in the contact list.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-10189.,2017-03-15,DoS Exec Code ,4,https://github.com/bitlbee/bitlbee/commit/30d598ce7cd3f136ee9d7097f39fa9818a272441,30d598ce7cd3f136ee9d7097f39fa9818a272441,"purple: Fix crash on ft requests from unknown contacts

Followup to 701ab81 (included in 3.5) which was a partial fix which only
improved things for non-libpurple file transfers (that is, just jabber)",0,protocols/purple/ft.c,"{""sha"": ""79476ebc97aaa66b027a5a6f142d8b73a2ce31b1"", ""filename"": ""protocols/purple/ft.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/bitlbee/bitlbee/blob/30d598ce7cd3f136ee9d7097f39fa9818a272441/protocols/purple/ft.c"", ""raw_url"": ""https://github.com/bitlbee/bitlbee/raw/30d598ce7cd3f136ee9d7097f39fa9818a272441/protocols/purple/ft.c"", ""contents_url"": ""https://api.github.com/repos/bitlbee/bitlbee/contents/protocols/purple/ft.c?ref=30d598ce7cd3f136ee9d7097f39fa9818a272441"", ""patch"": ""@@ -145,6 +145,10 @@ static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_conditio\n \t/* TODO(wilmer): After spreading some more const goodness in BitlBee,\n \t   remove the evil cast below. */\n \tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n+\n+\tif (!px->ft) {\n+\t\treturn FALSE;\n+\t}\n \tpx->ft->data = px;\n \n \tpx->ft->accept = prpl_xfer_accept;""}","static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)
{
	PurpleXfer *xfer = data;
	struct im_connection *ic = purple_ic_by_pa(xfer->account);
	struct prpl_xfer_data *px = xfer->ui_data;
	PurpleBuddy *buddy;
	const char *who;

	buddy = purple_find_buddy(xfer->account, xfer->who);
	who = buddy ? purple_buddy_get_name(buddy) : xfer->who;

 	/* TODO(wilmer): After spreading some more const goodness in BitlBee,
 	   remove the evil cast below. */
 	px->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);

	if (!px->ft) {
		return FALSE;
	}
 	px->ft->data = px;
 
 	px->ft->accept = prpl_xfer_accept;
	px->ft->canceled = prpl_xfer_canceled;
	px->ft->free = prpl_xfer_free;
	px->ft->write_request = prpl_xfer_write_request;

	return FALSE;
}
","static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)
{
	PurpleXfer *xfer = data;
	struct im_connection *ic = purple_ic_by_pa(xfer->account);
	struct prpl_xfer_data *px = xfer->ui_data;
	PurpleBuddy *buddy;
	const char *who;

	buddy = purple_find_buddy(xfer->account, xfer->who);
	who = buddy ? purple_buddy_get_name(buddy) : xfer->who;

 	/* TODO(wilmer): After spreading some more const goodness in BitlBee,
 	   remove the evil cast below. */
 	px->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);
 	px->ft->data = px;
 
 	px->ft->accept = prpl_xfer_accept;
	px->ft->canceled = prpl_xfer_canceled;
	px->ft->free = prpl_xfer_free;
	px->ft->write_request = prpl_xfer_write_request;

	return FALSE;
}
",C,"
	if (!px->ft) {
		return FALSE;
	}
",,,"@@ -145,6 +145,10 @@ static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_conditio
 	/* TODO(wilmer): After spreading some more const goodness in BitlBee,
 	   remove the evil cast below. */
 	px->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);
+
+	if (!px->ft) {
+		return FALSE;
+	}
 	px->ft->data = px;
 
 	px->ft->accept = prpl_xfer_accept;",bitlbee,30d598ce7cd3f136ee9d7097f39fa9818a272441,53cb4ae80e54b89efebc7d19f739d17fc3286383,1,"static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)
{
	PurpleXfer *xfer = data;
	struct im_connection *ic = purple_ic_by_pa(xfer->account);
	struct prpl_xfer_data *px = xfer->ui_data;
	PurpleBuddy *buddy;
	const char *who;

	buddy = purple_find_buddy(xfer->account, xfer->who);
	who = buddy ? purple_buddy_get_name(buddy) : xfer->who;

 	/* TODO(wilmer): After spreading some more const goodness in BitlBee,
 	   remove the evil cast below. */
 	px->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (!px->ft) {
//fix_flaw_line_below:
//		return FALSE;
//fix_flaw_line_below:
//	}
 	px->ft->data = px;
 
 	px->ft->accept = prpl_xfer_accept;
	px->ft->canceled = prpl_xfer_canceled;
	px->ft->free = prpl_xfer_free;
	px->ft->write_request = prpl_xfer_write_request;

	return FALSE;
}
"
3869,181605,,Remote,Not required,Partial,CVE-2017-3730,https://www.cvedetails.com/cve/CVE-2017-3730/,CWE-476,Low,,,,2017-05-04,5.0,"In OpenSSL 1.1.0 before 1.1.0d, if a malicious server supplies bad parameters for a DHE or ECDHE key exchange then this can result in the client attempting to dereference a NULL pointer leading to a client crash. This could be exploited in a Denial of Service attack.",2019-04-25,DoS ,5,https://github.com/openssl/openssl/commit/efbe126e3ebb9123ac9d058aa2bb044261342aaa,efbe126e3ebb9123ac9d058aa2bb044261342aaa,"Fix missing NULL checks in CKE processing

Reviewed-by: Rich Salz <rsalz@openssl.org>",0,ssl/statem/statem_clnt.c,"{""sha"": ""5ea0919e4ac0bb81893b636659357fbdad136b39"", ""filename"": ""ssl/statem/statem_clnt.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/openssl/openssl/blob/efbe126e3ebb9123ac9d058aa2bb044261342aaa/ssl/statem/statem_clnt.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/efbe126e3ebb9123ac9d058aa2bb044261342aaa/ssl/statem/statem_clnt.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/ssl/statem/statem_clnt.c?ref=efbe126e3ebb9123ac9d058aa2bb044261342aaa"", ""patch"": ""@@ -2258,6 +2258,11 @@ static int tls_construct_cke_dhe(SSL *s, unsigned char **p, int *len, int *al)\n         return 0;\n     }\n     ckey = ssl_generate_pkey(skey);\n+    if (ckey == NULL) {\n+        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n+        return 0;\n+    }\n+\n     dh_clnt = EVP_PKEY_get0_DH(ckey);\n \n     if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {\n@@ -2296,6 +2301,10 @@ static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)\n     }\n \n     ckey = ssl_generate_pkey(skey);\n+    if (ckey == NULL) {\n+        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n+        goto err;\n+    }\n \n     if (ssl_derive(s, ckey, skey) == 0) {\n         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);""}","static int tls_construct_cke_dhe(SSL *s, unsigned char **p, int *len, int *al)
{
#ifndef OPENSSL_NO_DH
    DH *dh_clnt = NULL;
    const BIGNUM *pub_key;
    EVP_PKEY *ckey = NULL, *skey = NULL;

    skey = s->s3->peer_tmp;
    if (skey == NULL) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
         return 0;
     }
     ckey = ssl_generate_pkey(skey);
    if (ckey == NULL) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
        return 0;
    }

     dh_clnt = EVP_PKEY_get0_DH(ckey);
 
     if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
        EVP_PKEY_free(ckey);
        return 0;
    }

    /* send off the data */
    DH_get0_key(dh_clnt, &pub_key, NULL);
    *len = BN_num_bytes(pub_key);
    s2n(*len, *p);
    BN_bn2bin(pub_key, *p);
    *len += 2;
    EVP_PKEY_free(ckey);

    return 1;
#else
    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
    *al = SSL_AD_INTERNAL_ERROR;
    return 0;
#endif
}
","static int tls_construct_cke_dhe(SSL *s, unsigned char **p, int *len, int *al)
{
#ifndef OPENSSL_NO_DH
    DH *dh_clnt = NULL;
    const BIGNUM *pub_key;
    EVP_PKEY *ckey = NULL, *skey = NULL;

    skey = s->s3->peer_tmp;
    if (skey == NULL) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
         return 0;
     }
     ckey = ssl_generate_pkey(skey);
     dh_clnt = EVP_PKEY_get0_DH(ckey);
 
     if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
        EVP_PKEY_free(ckey);
        return 0;
    }

    /* send off the data */
    DH_get0_key(dh_clnt, &pub_key, NULL);
    *len = BN_num_bytes(pub_key);
    s2n(*len, *p);
    BN_bn2bin(pub_key, *p);
    *len += 2;
    EVP_PKEY_free(ckey);

    return 1;
#else
    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
    *al = SSL_AD_INTERNAL_ERROR;
    return 0;
#endif
}
",C,"    if (ckey == NULL) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
        return 0;
    }

",,,"@@ -2258,6 +2258,11 @@ static int tls_construct_cke_dhe(SSL *s, unsigned char **p, int *len, int *al)
         return 0;
     }
     ckey = ssl_generate_pkey(skey);
+    if (ckey == NULL) {
+        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
     dh_clnt = EVP_PKEY_get0_DH(ckey);
 
     if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {
@@ -2296,6 +2301,10 @@ static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)
     }
 
     ckey = ssl_generate_pkey(skey);
+    if (ckey == NULL) {
+        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
 
     if (ssl_derive(s, ckey, skey) == 0) {
         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);",openssl,efbe126e3ebb9123ac9d058aa2bb044261342aaa,793d9b79033c2fffc8e781dab2fd678661b348cd,1,"static int tls_construct_cke_dhe(SSL *s, unsigned char **p, int *len, int *al)
{
#ifndef OPENSSL_NO_DH
    DH *dh_clnt = NULL;
    const BIGNUM *pub_key;
    EVP_PKEY *ckey = NULL, *skey = NULL;

    skey = s->s3->peer_tmp;
    if (skey == NULL) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
         return 0;
     }
     ckey = ssl_generate_pkey(skey);
//fix_flaw_line_below:
//    if (ckey == NULL) {
//fix_flaw_line_below:
//        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
//fix_flaw_line_below:
//        return 0;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     dh_clnt = EVP_PKEY_get0_DH(ckey);
 
     if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
        EVP_PKEY_free(ckey);
        return 0;
    }

    /* send off the data */
    DH_get0_key(dh_clnt, &pub_key, NULL);
    *len = BN_num_bytes(pub_key);
    s2n(*len, *p);
    BN_bn2bin(pub_key, *p);
    *len += 2;
    EVP_PKEY_free(ckey);

    return 1;
#else
    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
    *al = SSL_AD_INTERNAL_ERROR;
    return 0;
#endif
}
"
3870,181606,,Remote,Not required,Partial,CVE-2017-3730,https://www.cvedetails.com/cve/CVE-2017-3730/,CWE-476,Low,,,,2017-05-04,5.0,"In OpenSSL 1.1.0 before 1.1.0d, if a malicious server supplies bad parameters for a DHE or ECDHE key exchange then this can result in the client attempting to dereference a NULL pointer leading to a client crash. This could be exploited in a Denial of Service attack.",2019-04-25,DoS ,4,https://github.com/openssl/openssl/commit/efbe126e3ebb9123ac9d058aa2bb044261342aaa,efbe126e3ebb9123ac9d058aa2bb044261342aaa,"Fix missing NULL checks in CKE processing

Reviewed-by: Rich Salz <rsalz@openssl.org>",0,ssl/statem/statem_clnt.c,"{""sha"": ""5ea0919e4ac0bb81893b636659357fbdad136b39"", ""filename"": ""ssl/statem/statem_clnt.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/openssl/openssl/blob/efbe126e3ebb9123ac9d058aa2bb044261342aaa/ssl/statem/statem_clnt.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/efbe126e3ebb9123ac9d058aa2bb044261342aaa/ssl/statem/statem_clnt.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/ssl/statem/statem_clnt.c?ref=efbe126e3ebb9123ac9d058aa2bb044261342aaa"", ""patch"": ""@@ -2258,6 +2258,11 @@ static int tls_construct_cke_dhe(SSL *s, unsigned char **p, int *len, int *al)\n         return 0;\n     }\n     ckey = ssl_generate_pkey(skey);\n+    if (ckey == NULL) {\n+        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n+        return 0;\n+    }\n+\n     dh_clnt = EVP_PKEY_get0_DH(ckey);\n \n     if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {\n@@ -2296,6 +2301,10 @@ static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)\n     }\n \n     ckey = ssl_generate_pkey(skey);\n+    if (ckey == NULL) {\n+        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n+        goto err;\n+    }\n \n     if (ssl_derive(s, ckey, skey) == 0) {\n         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);""}","static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)
{
#ifndef OPENSSL_NO_EC
    unsigned char *encodedPoint = NULL;
    int encoded_pt_len = 0;
    EVP_PKEY *ckey = NULL, *skey = NULL;

    skey = s->s3->peer_tmp;
    if (skey == NULL) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
        return 0;
     }
 
     ckey = ssl_generate_pkey(skey);
    if (ckey == NULL) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
        goto err;
    }
 
     if (ssl_derive(s, ckey, skey) == 0) {
         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);
        goto err;
    }

    /* Generate encoding of client key */
    encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(ckey, &encodedPoint);

    if (encoded_pt_len == 0) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EC_LIB);
        goto err;
    }

    EVP_PKEY_free(ckey);
    ckey = NULL;

    *len = encoded_pt_len;

    /* length of encoded point */
    **p = *len;
    *p += 1;
    /* copy the point */
    memcpy(*p, encodedPoint, *len);
    /* increment len to account for length field */
    *len += 1;

    OPENSSL_free(encodedPoint);

    return 1;
 err:
    EVP_PKEY_free(ckey);
    return 0;
#else
    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
    *al = SSL_AD_INTERNAL_ERROR;
    return 0;
#endif
}
","static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)
{
#ifndef OPENSSL_NO_EC
    unsigned char *encodedPoint = NULL;
    int encoded_pt_len = 0;
    EVP_PKEY *ckey = NULL, *skey = NULL;

    skey = s->s3->peer_tmp;
    if (skey == NULL) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
        return 0;
     }
 
     ckey = ssl_generate_pkey(skey);
 
     if (ssl_derive(s, ckey, skey) == 0) {
         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);
        goto err;
    }

    /* Generate encoding of client key */
    encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(ckey, &encodedPoint);

    if (encoded_pt_len == 0) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EC_LIB);
        goto err;
    }

    EVP_PKEY_free(ckey);
    ckey = NULL;

    *len = encoded_pt_len;

    /* length of encoded point */
    **p = *len;
    *p += 1;
    /* copy the point */
    memcpy(*p, encodedPoint, *len);
    /* increment len to account for length field */
    *len += 1;

    OPENSSL_free(encodedPoint);

    return 1;
 err:
    EVP_PKEY_free(ckey);
    return 0;
#else
    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
    *al = SSL_AD_INTERNAL_ERROR;
    return 0;
#endif
}
",C,"    if (ckey == NULL) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
        goto err;
    }
",,,"@@ -2258,6 +2258,11 @@ static int tls_construct_cke_dhe(SSL *s, unsigned char **p, int *len, int *al)
         return 0;
     }
     ckey = ssl_generate_pkey(skey);
+    if (ckey == NULL) {
+        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
     dh_clnt = EVP_PKEY_get0_DH(ckey);
 
     if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {
@@ -2296,6 +2301,10 @@ static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)
     }
 
     ckey = ssl_generate_pkey(skey);
+    if (ckey == NULL) {
+        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
 
     if (ssl_derive(s, ckey, skey) == 0) {
         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);",openssl,efbe126e3ebb9123ac9d058aa2bb044261342aaa,793d9b79033c2fffc8e781dab2fd678661b348cd,1,"static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)
{
#ifndef OPENSSL_NO_EC
    unsigned char *encodedPoint = NULL;
    int encoded_pt_len = 0;
    EVP_PKEY *ckey = NULL, *skey = NULL;

    skey = s->s3->peer_tmp;
    if (skey == NULL) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
        return 0;
     }
 
     ckey = ssl_generate_pkey(skey);
//fix_flaw_line_below:
//    if (ckey == NULL) {
//fix_flaw_line_below:
//        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
//fix_flaw_line_below:
//        goto err;
//fix_flaw_line_below:
//    }
 
     if (ssl_derive(s, ckey, skey) == 0) {
         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);
        goto err;
    }

    /* Generate encoding of client key */
    encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(ckey, &encodedPoint);

    if (encoded_pt_len == 0) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EC_LIB);
        goto err;
    }

    EVP_PKEY_free(ckey);
    ckey = NULL;

    *len = encoded_pt_len;

    /* length of encoded point */
    **p = *len;
    *p += 1;
    /* copy the point */
    memcpy(*p, encodedPoint, *len);
    /* increment len to account for length field */
    *len += 1;

    OPENSSL_free(encodedPoint);

    return 1;
 err:
    EVP_PKEY_free(ckey);
    return 0;
#else
    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
    *al = SSL_AD_INTERNAL_ERROR;
    return 0;
#endif
}
"
3872,181608,,Local,Not required,Complete,CVE-2017-2647,https://www.cvedetails.com/cve/CVE-2017-2647/,CWE-476,Low,Complete,Complete,,2017-03-31,7.2,"The KEYS subsystem in the Linux kernel before 3.18 allows local users to gain privileges or cause a denial of service (NULL pointer dereference and system crash) via vectors involving a NULL value for a certain match field, related to the keyring_search_iterator function in keyring.c.",2019-01-15,DoS +Priv ,2,https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"KEYS: Remove key_type::match in favour of overriding default by match_preparse

A previous patch added a ->match_preparse() method to the key type.  This is
allowed to override the function called by the iteration algorithm.
Therefore, we can just set a default that simply checks for an exact match of
the key description with the original criterion data and allow match_preparse
to override it as needed.

The key_type::match op is then redundant and can be removed, as can the
user_match() function.

Signed-off-by: David Howells <dhowells@redhat.com>
Acked-by: Vivek Goyal <vgoyal@redhat.com>",1,crypto/asymmetric_keys/asymmetric_type.c,"{""sha"": ""7c04989689757da3284da98c0e7b933143b89c1b"", ""filename"": ""crypto/asymmetric_keys/asymmetric_type.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/asymmetric_type.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/asymmetric_type.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/asymmetric_keys/asymmetric_type.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -59,8 +59,8 @@ EXPORT_SYMBOL_GPL(asymmetric_keyid_match);\n  *\t\""id:<id>\""\t- request a key matching the ID\n  *\t\""<subtype>:<id>\"" - request a key of a subtype\n  */\n-static int asymmetric_key_match(const struct key *key,\n-\t\t\t\tconst struct key_match_data *match_data)\n+static int asymmetric_key_cmp(const struct key *key,\n+\t\t\t      const struct key_match_data *match_data)\n {\n \tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n \tconst char *description = match_data->raw_data;\n@@ -110,6 +110,7 @@ static int asymmetric_key_match(const struct key *key,\n static int asymmetric_key_match_preparse(struct key_match_data *match_data)\n {\n \tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n+\tmatch_data->cmp = asymmetric_key_cmp;\n \treturn 0;\n }\n \n@@ -224,7 +225,6 @@ struct key_type key_type_asymmetric = {\n \t.free_preparse\t= asymmetric_key_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n \t.match_preparse\t= asymmetric_key_match_preparse,\n-\t.match\t\t= asymmetric_key_match,\n \t.match_free\t= asymmetric_key_match_free,\n \t.destroy\t= asymmetric_key_destroy,\n \t.describe\t= asymmetric_key_describe,""}<_**next**_>{""sha"": ""751f8fd7335db2203f7257edc8ad680dc7ea2a14"", ""filename"": ""crypto/asymmetric_keys/pkcs7_key_type.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/pkcs7_key_type.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/pkcs7_key_type.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/asymmetric_keys/pkcs7_key_type.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -75,7 +75,6 @@ static struct key_type key_type_pkcs7 = {\n \t.preparse\t\t= pkcs7_preparse,\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,""}<_**next**_>{""sha"": ""f4cf200b3c76714ca5a059b1ecdcca6f2e77b338"", ""filename"": ""fs/cifs/cifs_spnego.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifs_spnego.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifs_spnego.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/cifs_spnego.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -62,7 +62,6 @@ cifs_spnego_key_destroy(struct key *key)\n struct key_type cifs_spnego_key_type = {\n \t.name\t\t= \""cifs.spnego\"",\n \t.instantiate\t= cifs_spnego_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= cifs_spnego_key_destroy,\n \t.describe\t= user_describe,\n };""}<_**next**_>{""sha"": ""6d00c419cbae0b54016ba997f55baf1ac7c54956"", ""filename"": ""fs/cifs/cifsacl.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifsacl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifsacl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/cifsacl.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -84,7 +84,6 @@ static struct key_type cifs_idmap_key_type = {\n \t.instantiate = cifs_idmap_key_instantiate,\n \t.destroy     = cifs_idmap_key_destroy,\n \t.describe    = user_describe,\n-\t.match       = user_match,\n };\n \n static char *""}<_**next**_>{""sha"": ""2f5db844c172534a229d86b011be1f6ec2c29aff"", ""filename"": ""fs/nfs/idmap.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/nfs/idmap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/nfs/idmap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfs/idmap.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -177,7 +177,6 @@ static struct key_type key_type_id_resolver = {\n \t.preparse\t= user_preparse,\n \t.free_preparse\t= user_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= user_describe,\n@@ -401,7 +400,6 @@ static struct key_type key_type_id_resolver_legacy = {\n \t.preparse\t= user_preparse,\n \t.free_preparse\t= user_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= user_describe,""}<_**next**_>{""sha"": ""cebefb069c44a51bed96e7fc671f0e839bf94d6a"", ""filename"": ""include/keys/user-type.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/keys/user-type.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/keys/user-type.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/keys/user-type.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -36,13 +36,10 @@ extern struct key_type key_type_user;\n extern struct key_type key_type_logon;\n \n struct key_preparsed_payload;\n-struct key_match_data;\n \n extern int user_preparse(struct key_preparsed_payload *prep);\n extern void user_free_preparse(struct key_preparsed_payload *prep);\n extern int user_update(struct key *key, struct key_preparsed_payload *prep);\n-extern int user_match(const struct key *key,\n-\t\t      const struct key_match_data *match_data);\n extern void user_revoke(struct key *key);\n extern void user_destroy(struct key *key);\n extern void user_describe(const struct key *user, struct seq_file *m);""}<_**next**_>{""sha"": ""c14816bd3b44f14db29787ec90bc3da5ef4a83f9"", ""filename"": ""include/linux/key-type.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/linux/key-type.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/linux/key-type.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/key-type.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -113,10 +113,6 @@ struct key_type {\n \t */\n \tint (*match_preparse)(struct key_match_data *match_data);\n \n-\t/* match a key against a description */\n-\tint (*match)(const struct key *key,\n-\t\t     const struct key_match_data *match_data);\n-\n \t/* Free preparsed match data (optional).  This should be supplied it\n \t * ->match_preparse() is supplied. */\n \tvoid (*match_free)(struct key_match_data *match_data);""}<_**next**_>{""sha"": ""62fc5e7a9acf7506eba2de7ae314ba6067870ceb"", ""filename"": ""net/ceph/crypto.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/ceph/crypto.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/ceph/crypto.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ceph/crypto.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -476,7 +476,6 @@ struct key_type key_type_ceph = {\n \t.preparse\t= ceph_key_preparse,\n \t.free_preparse\t= ceph_key_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= ceph_key_destroy,\n };\n ""}<_**next**_>{""sha"": ""a07b9ba7e0b7bfaa351dc90750c3ca2590b816eb"", ""filename"": ""net/dns_resolver/dns_key.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 4, ""changes"": 17, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/dns_resolver/dns_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/dns_resolver/dns_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/dns_resolver/dns_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -176,9 +176,8 @@ static void dns_resolver_free_preparse(struct key_preparsed_payload *prep)\n  * The domain name may be a simple name or an absolute domain name (which\n  * should end with a period).  The domain name is case-independent.\n  */\n-static int\n-dns_resolver_match(const struct key *key,\n-\t\t   const struct key_match_data *match_data)\n+static int dns_resolver_cmp(const struct key *key,\n+\t\t\t    const struct key_match_data *match_data)\n {\n \tint slen, dlen, ret = 0;\n \tconst char *src = key->description, *dsp = match_data->raw_data;\n@@ -209,6 +208,16 @@ dns_resolver_match(const struct key *key,\n \treturn ret;\n }\n \n+/*\n+ * Preparse the match criterion.\n+ */\n+static int dns_resolver_match_preparse(struct key_match_data *match_data)\n+{\n+\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n+\tmatch_data->cmp = dns_resolver_cmp;\n+\treturn 0;\n+}\n+\n /*\n  * Describe a DNS key\n  */\n@@ -243,7 +252,7 @@ struct key_type key_type_dns_resolver = {\n \t.preparse\t= dns_resolver_preparse,\n \t.free_preparse\t= dns_resolver_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= dns_resolver_match,\n+\t.match_preparse\t= dns_resolver_match_preparse,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= dns_resolver_describe,""}<_**next**_>{""sha"": ""10c6cb694b4343913498a95a2f982ac11d4a1828"", ""filename"": ""net/rxrpc/ar-key.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/rxrpc/ar-key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/rxrpc/ar-key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/rxrpc/ar-key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -44,7 +44,6 @@ struct key_type key_type_rxrpc = {\n \t.preparse\t= rxrpc_preparse,\n \t.free_preparse\t= rxrpc_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= rxrpc_destroy,\n \t.describe\t= rxrpc_describe,\n \t.read\t\t= rxrpc_read,\n@@ -61,7 +60,6 @@ struct key_type key_type_rxrpc_s = {\n \t.preparse\t= rxrpc_preparse_s,\n \t.free_preparse\t= rxrpc_free_preparse_s,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= rxrpc_destroy_s,\n \t.describe\t= rxrpc_describe,\n };""}<_**next**_>{""sha"": ""b6adb94f6d52573aecf2e38a16724e06895dded6"", ""filename"": ""security/keys/big_key.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/big_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/big_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/big_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -36,7 +36,6 @@ struct key_type key_type_big_key = {\n \t.preparse\t\t= big_key_preparse,\n \t.free_preparse\t\t= big_key_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= big_key_revoke,\n \t.destroy\t\t= big_key_destroy,\n \t.describe\t\t= big_key_describe,""}<_**next**_>{""sha"": ""db9675db10262021612016bed79ade14a960d089"", ""filename"": ""security/keys/encrypted-keys/encrypted.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/encrypted-keys/encrypted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/encrypted-keys/encrypted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/encrypted-keys/encrypted.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -970,7 +970,6 @@ struct key_type key_type_encrypted = {\n \t.name = \""encrypted\"",\n \t.instantiate = encrypted_instantiate,\n \t.update = encrypted_update,\n-\t.match = user_match,\n \t.destroy = encrypted_destroy,\n \t.describe = user_describe,\n \t.read = encrypted_read,""}<_**next**_>{""sha"": ""e66a16cb63e1ca223e71d7b3b66ca5c0f19180ea"", ""filename"": ""security/keys/internal.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/internal.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -127,6 +127,8 @@ struct keyring_search_context {\n \tstruct timespec\t\tnow;\n };\n \n+extern int key_default_cmp(const struct key *key,\n+\t\t\t   const struct key_match_data *match_data);\n extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,\n \t\t\t\t    struct keyring_search_context *ctx);\n ""}<_**next**_>{""sha"": ""8c0092ca04430b65b6a0969b5ed3e090038ed2b2"", ""filename"": ""security/keys/key.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -799,7 +799,7 @@ key_ref_t key_create_or_update(key_ref_t keyring_ref,\n \t}\n \n \tkey_ref = ERR_PTR(-EINVAL);\n-\tif (!index_key.type->match || !index_key.type->instantiate ||\n+\tif (!index_key.type->instantiate ||\n \t    (!index_key.description && !index_key.type->preparse))\n \t\tgoto error_put_type;\n ""}<_**next**_>{""sha"": ""253c9a0eb092e2add086d5da72f0811e11007534"", ""filename"": ""security/keys/keyring.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 5, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/keyring.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/keyring.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/keyring.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -89,7 +89,6 @@ struct key_type key_type_keyring = {\n \t.preparse\t= keyring_preparse,\n \t.free_preparse\t= keyring_free_preparse,\n \t.instantiate\t= keyring_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= keyring_revoke,\n \t.destroy\t= keyring_destroy,\n \t.describe\t= keyring_describe,\n@@ -511,6 +510,15 @@ struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n }\n EXPORT_SYMBOL(keyring_alloc);\n \n+/*\n+ * By default, we keys found by getting an exact match on their descriptions.\n+ */\n+int key_default_cmp(const struct key *key,\n+\t\t    const struct key_match_data *match_data)\n+{\n+\treturn strcmp(key->description, match_data->raw_data) == 0;\n+}\n+\n /*\n  * Iteration function to consider each key found.\n  */\n@@ -884,17 +892,14 @@ key_ref_t keyring_search(key_ref_t keyring,\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= type->match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n \t};\n \tkey_ref_t key;\n \tint ret;\n \n-\tif (!ctx.match_data.cmp)\n-\t\treturn ERR_PTR(-ENOKEY);\n-\n \tif (type->match_preparse) {\n \t\tret = type->match_preparse(&ctx.match_data);\n \t\tif (ret < 0)""}<_**next**_>{""sha"": ""dc6ed32b7844cfabce17e4fe0e5e309555524b8b"", ""filename"": ""security/keys/request_key.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/request_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -531,7 +531,7 @@ struct key *request_key_and_link(struct key_type *type,\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= type->match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t};""}<_**next**_>{""sha"": ""6639e2cb885322c6a43924496b2a68be25b9a5e6"", ""filename"": ""security/keys/request_key_auth.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key_auth.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key_auth.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/request_key_auth.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -246,7 +246,7 @@ struct key *key_get_instantiation_authkey(key_serial_t target_id)\n \t\t.index_key.type\t\t= &key_type_request_key_auth,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= user_match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t};""}<_**next**_>{""sha"": ""c0594cb07adab14f1efeb970a8c0dd85d86a7931"", ""filename"": ""security/keys/trusted.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/trusted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/trusted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/trusted.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -1096,7 +1096,6 @@ struct key_type key_type_trusted = {\n \t.name = \""trusted\"",\n \t.instantiate = trusted_instantiate,\n \t.update = trusted_update,\n-\t.match = user_match,\n \t.destroy = trusted_destroy,\n \t.describe = user_describe,\n \t.read = trusted_read,""}<_**next**_>{""sha"": ""36b47bbd3d8cc277de55e0c0cdd722618ca13231"", ""filename"": ""security/keys/user_defined.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 12, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/user_defined.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/user_defined.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/user_defined.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -30,7 +30,6 @@ struct key_type key_type_user = {\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n \t.update\t\t\t= user_update,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,\n@@ -51,7 +50,6 @@ struct key_type key_type_logon = {\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n \t.update\t\t\t= user_update,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,\n@@ -136,16 +134,6 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n EXPORT_SYMBOL_GPL(user_update);\n \n-/*\n- * match users on their name\n- */\n-int user_match(const struct key *key, const struct key_match_data *match_data)\n-{\n-\treturn strcmp(key->description, match_data->raw_data) == 0;\n-}\n-\n-EXPORT_SYMBOL_GPL(user_match);\n-\n /*\n  * dispose of the links from a revoked keyring\n  * - called with the key sem write-locked""}","static int asymmetric_key_match(const struct key *key,
static int asymmetric_key_cmp(const struct key *key,
			      const struct key_match_data *match_data)
 {
 	const struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);
 	const char *description = match_data->raw_data;
	const char *spec = description;
	const char *id;
	ptrdiff_t speclen;

	if (!subtype || !spec || !*spec)
		return 0;

	/* See if the full key description matches as is */
	if (key->description && strcmp(key->description, description) == 0)
		return 1;

	/* All tests from here on break the criterion description into a
	 * specifier, a colon and then an identifier.
	 */
	id = strchr(spec, ':');
	if (!id)
		return 0;

	speclen = id - spec;
	id++;

	if (speclen == 2 && memcmp(spec, ""id"", 2) == 0)
		return asymmetric_keyid_match(asymmetric_key_id(key), id);

	if (speclen == subtype->name_len &&
	    memcmp(spec, subtype->name, speclen) == 0)
		return 1;

	return 0;
}
","static int asymmetric_key_match(const struct key *key,
				const struct key_match_data *match_data)
 {
 	const struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);
 	const char *description = match_data->raw_data;
	const char *spec = description;
	const char *id;
	ptrdiff_t speclen;

	if (!subtype || !spec || !*spec)
		return 0;

	/* See if the full key description matches as is */
	if (key->description && strcmp(key->description, description) == 0)
		return 1;

	/* All tests from here on break the criterion description into a
	 * specifier, a colon and then an identifier.
	 */
	id = strchr(spec, ':');
	if (!id)
		return 0;

	speclen = id - spec;
	id++;

	if (speclen == 2 && memcmp(spec, ""id"", 2) == 0)
		return asymmetric_keyid_match(asymmetric_key_id(key), id);

	if (speclen == subtype->name_len &&
	    memcmp(spec, subtype->name, speclen) == 0)
		return 1;

	return 0;
}
",C,"static int asymmetric_key_cmp(const struct key *key,
			      const struct key_match_data *match_data)
","				const struct key_match_data *match_data)
",,"@@ -59,8 +59,8 @@ EXPORT_SYMBOL_GPL(asymmetric_keyid_match);
  *	""id:<id>""	- request a key matching the ID
  *	""<subtype>:<id>"" - request a key of a subtype
  */
-static int asymmetric_key_match(const struct key *key,
-				const struct key_match_data *match_data)
+static int asymmetric_key_cmp(const struct key *key,
+			      const struct key_match_data *match_data)
 {
 	const struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);
 	const char *description = match_data->raw_data;
@@ -110,6 +110,7 @@ static int asymmetric_key_match(const struct key *key,
 static int asymmetric_key_match_preparse(struct key_match_data *match_data)
 {
 	match_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;
+	match_data->cmp = asymmetric_key_cmp;
 	return 0;
 }
 
@@ -224,7 +225,6 @@ struct key_type key_type_asymmetric = {
 	.free_preparse	= asymmetric_key_free_preparse,
 	.instantiate	= generic_key_instantiate,
 	.match_preparse	= asymmetric_key_match_preparse,
-	.match		= asymmetric_key_match,
 	.match_free	= asymmetric_key_match_free,
 	.destroy	= asymmetric_key_destroy,
 	.describe	= asymmetric_key_describe,",linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,614d8c39014c185aa0f7254f0a470cc33fc1b284,1,"static int asymmetric_key_match(const struct key *key,
//flaw_line_below:
				const struct key_match_data *match_data)
//fix_flaw_line_below:
//static int asymmetric_key_cmp(const struct key *key,
//fix_flaw_line_below:
//			      const struct key_match_data *match_data)
 {
 	const struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);
 	const char *description = match_data->raw_data;
	const char *spec = description;
	const char *id;
	ptrdiff_t speclen;

	if (!subtype || !spec || !*spec)
		return 0;

	/* See if the full key description matches as is */
	if (key->description && strcmp(key->description, description) == 0)
		return 1;

	/* All tests from here on break the criterion description into a
	 * specifier, a colon and then an identifier.
	 */
	id = strchr(spec, ':');
	if (!id)
		return 0;

	speclen = id - spec;
	id++;

	if (speclen == 2 && memcmp(spec, ""id"", 2) == 0)
		return asymmetric_keyid_match(asymmetric_key_id(key), id);

	if (speclen == subtype->name_len &&
	    memcmp(spec, subtype->name, speclen) == 0)
		return 1;

	return 0;
}
"
3873,181609,,Local,Not required,Complete,CVE-2017-2647,https://www.cvedetails.com/cve/CVE-2017-2647/,CWE-476,Low,Complete,Complete,,2017-03-31,7.2,"The KEYS subsystem in the Linux kernel before 3.18 allows local users to gain privileges or cause a denial of service (NULL pointer dereference and system crash) via vectors involving a NULL value for a certain match field, related to the keyring_search_iterator function in keyring.c.",2019-01-15,DoS +Priv ,1,https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"KEYS: Remove key_type::match in favour of overriding default by match_preparse

A previous patch added a ->match_preparse() method to the key type.  This is
allowed to override the function called by the iteration algorithm.
Therefore, we can just set a default that simply checks for an exact match of
the key description with the original criterion data and allow match_preparse
to override it as needed.

The key_type::match op is then redundant and can be removed, as can the
user_match() function.

Signed-off-by: David Howells <dhowells@redhat.com>
Acked-by: Vivek Goyal <vgoyal@redhat.com>",0,crypto/asymmetric_keys/asymmetric_type.c,"{""sha"": ""7c04989689757da3284da98c0e7b933143b89c1b"", ""filename"": ""crypto/asymmetric_keys/asymmetric_type.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/asymmetric_type.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/asymmetric_type.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/asymmetric_keys/asymmetric_type.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -59,8 +59,8 @@ EXPORT_SYMBOL_GPL(asymmetric_keyid_match);\n  *\t\""id:<id>\""\t- request a key matching the ID\n  *\t\""<subtype>:<id>\"" - request a key of a subtype\n  */\n-static int asymmetric_key_match(const struct key *key,\n-\t\t\t\tconst struct key_match_data *match_data)\n+static int asymmetric_key_cmp(const struct key *key,\n+\t\t\t      const struct key_match_data *match_data)\n {\n \tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n \tconst char *description = match_data->raw_data;\n@@ -110,6 +110,7 @@ static int asymmetric_key_match(const struct key *key,\n static int asymmetric_key_match_preparse(struct key_match_data *match_data)\n {\n \tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n+\tmatch_data->cmp = asymmetric_key_cmp;\n \treturn 0;\n }\n \n@@ -224,7 +225,6 @@ struct key_type key_type_asymmetric = {\n \t.free_preparse\t= asymmetric_key_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n \t.match_preparse\t= asymmetric_key_match_preparse,\n-\t.match\t\t= asymmetric_key_match,\n \t.match_free\t= asymmetric_key_match_free,\n \t.destroy\t= asymmetric_key_destroy,\n \t.describe\t= asymmetric_key_describe,""}<_**next**_>{""sha"": ""751f8fd7335db2203f7257edc8ad680dc7ea2a14"", ""filename"": ""crypto/asymmetric_keys/pkcs7_key_type.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/pkcs7_key_type.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/pkcs7_key_type.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/asymmetric_keys/pkcs7_key_type.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -75,7 +75,6 @@ static struct key_type key_type_pkcs7 = {\n \t.preparse\t\t= pkcs7_preparse,\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,""}<_**next**_>{""sha"": ""f4cf200b3c76714ca5a059b1ecdcca6f2e77b338"", ""filename"": ""fs/cifs/cifs_spnego.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifs_spnego.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifs_spnego.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/cifs_spnego.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -62,7 +62,6 @@ cifs_spnego_key_destroy(struct key *key)\n struct key_type cifs_spnego_key_type = {\n \t.name\t\t= \""cifs.spnego\"",\n \t.instantiate\t= cifs_spnego_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= cifs_spnego_key_destroy,\n \t.describe\t= user_describe,\n };""}<_**next**_>{""sha"": ""6d00c419cbae0b54016ba997f55baf1ac7c54956"", ""filename"": ""fs/cifs/cifsacl.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifsacl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifsacl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/cifsacl.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -84,7 +84,6 @@ static struct key_type cifs_idmap_key_type = {\n \t.instantiate = cifs_idmap_key_instantiate,\n \t.destroy     = cifs_idmap_key_destroy,\n \t.describe    = user_describe,\n-\t.match       = user_match,\n };\n \n static char *""}<_**next**_>{""sha"": ""2f5db844c172534a229d86b011be1f6ec2c29aff"", ""filename"": ""fs/nfs/idmap.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/nfs/idmap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/nfs/idmap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfs/idmap.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -177,7 +177,6 @@ static struct key_type key_type_id_resolver = {\n \t.preparse\t= user_preparse,\n \t.free_preparse\t= user_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= user_describe,\n@@ -401,7 +400,6 @@ static struct key_type key_type_id_resolver_legacy = {\n \t.preparse\t= user_preparse,\n \t.free_preparse\t= user_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= user_describe,""}<_**next**_>{""sha"": ""cebefb069c44a51bed96e7fc671f0e839bf94d6a"", ""filename"": ""include/keys/user-type.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/keys/user-type.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/keys/user-type.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/keys/user-type.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -36,13 +36,10 @@ extern struct key_type key_type_user;\n extern struct key_type key_type_logon;\n \n struct key_preparsed_payload;\n-struct key_match_data;\n \n extern int user_preparse(struct key_preparsed_payload *prep);\n extern void user_free_preparse(struct key_preparsed_payload *prep);\n extern int user_update(struct key *key, struct key_preparsed_payload *prep);\n-extern int user_match(const struct key *key,\n-\t\t      const struct key_match_data *match_data);\n extern void user_revoke(struct key *key);\n extern void user_destroy(struct key *key);\n extern void user_describe(const struct key *user, struct seq_file *m);""}<_**next**_>{""sha"": ""c14816bd3b44f14db29787ec90bc3da5ef4a83f9"", ""filename"": ""include/linux/key-type.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/linux/key-type.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/linux/key-type.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/key-type.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -113,10 +113,6 @@ struct key_type {\n \t */\n \tint (*match_preparse)(struct key_match_data *match_data);\n \n-\t/* match a key against a description */\n-\tint (*match)(const struct key *key,\n-\t\t     const struct key_match_data *match_data);\n-\n \t/* Free preparsed match data (optional).  This should be supplied it\n \t * ->match_preparse() is supplied. */\n \tvoid (*match_free)(struct key_match_data *match_data);""}<_**next**_>{""sha"": ""62fc5e7a9acf7506eba2de7ae314ba6067870ceb"", ""filename"": ""net/ceph/crypto.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/ceph/crypto.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/ceph/crypto.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ceph/crypto.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -476,7 +476,6 @@ struct key_type key_type_ceph = {\n \t.preparse\t= ceph_key_preparse,\n \t.free_preparse\t= ceph_key_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= ceph_key_destroy,\n };\n ""}<_**next**_>{""sha"": ""a07b9ba7e0b7bfaa351dc90750c3ca2590b816eb"", ""filename"": ""net/dns_resolver/dns_key.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 4, ""changes"": 17, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/dns_resolver/dns_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/dns_resolver/dns_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/dns_resolver/dns_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -176,9 +176,8 @@ static void dns_resolver_free_preparse(struct key_preparsed_payload *prep)\n  * The domain name may be a simple name or an absolute domain name (which\n  * should end with a period).  The domain name is case-independent.\n  */\n-static int\n-dns_resolver_match(const struct key *key,\n-\t\t   const struct key_match_data *match_data)\n+static int dns_resolver_cmp(const struct key *key,\n+\t\t\t    const struct key_match_data *match_data)\n {\n \tint slen, dlen, ret = 0;\n \tconst char *src = key->description, *dsp = match_data->raw_data;\n@@ -209,6 +208,16 @@ dns_resolver_match(const struct key *key,\n \treturn ret;\n }\n \n+/*\n+ * Preparse the match criterion.\n+ */\n+static int dns_resolver_match_preparse(struct key_match_data *match_data)\n+{\n+\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n+\tmatch_data->cmp = dns_resolver_cmp;\n+\treturn 0;\n+}\n+\n /*\n  * Describe a DNS key\n  */\n@@ -243,7 +252,7 @@ struct key_type key_type_dns_resolver = {\n \t.preparse\t= dns_resolver_preparse,\n \t.free_preparse\t= dns_resolver_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= dns_resolver_match,\n+\t.match_preparse\t= dns_resolver_match_preparse,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= dns_resolver_describe,""}<_**next**_>{""sha"": ""10c6cb694b4343913498a95a2f982ac11d4a1828"", ""filename"": ""net/rxrpc/ar-key.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/rxrpc/ar-key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/rxrpc/ar-key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/rxrpc/ar-key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -44,7 +44,6 @@ struct key_type key_type_rxrpc = {\n \t.preparse\t= rxrpc_preparse,\n \t.free_preparse\t= rxrpc_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= rxrpc_destroy,\n \t.describe\t= rxrpc_describe,\n \t.read\t\t= rxrpc_read,\n@@ -61,7 +60,6 @@ struct key_type key_type_rxrpc_s = {\n \t.preparse\t= rxrpc_preparse_s,\n \t.free_preparse\t= rxrpc_free_preparse_s,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= rxrpc_destroy_s,\n \t.describe\t= rxrpc_describe,\n };""}<_**next**_>{""sha"": ""b6adb94f6d52573aecf2e38a16724e06895dded6"", ""filename"": ""security/keys/big_key.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/big_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/big_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/big_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -36,7 +36,6 @@ struct key_type key_type_big_key = {\n \t.preparse\t\t= big_key_preparse,\n \t.free_preparse\t\t= big_key_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= big_key_revoke,\n \t.destroy\t\t= big_key_destroy,\n \t.describe\t\t= big_key_describe,""}<_**next**_>{""sha"": ""db9675db10262021612016bed79ade14a960d089"", ""filename"": ""security/keys/encrypted-keys/encrypted.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/encrypted-keys/encrypted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/encrypted-keys/encrypted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/encrypted-keys/encrypted.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -970,7 +970,6 @@ struct key_type key_type_encrypted = {\n \t.name = \""encrypted\"",\n \t.instantiate = encrypted_instantiate,\n \t.update = encrypted_update,\n-\t.match = user_match,\n \t.destroy = encrypted_destroy,\n \t.describe = user_describe,\n \t.read = encrypted_read,""}<_**next**_>{""sha"": ""e66a16cb63e1ca223e71d7b3b66ca5c0f19180ea"", ""filename"": ""security/keys/internal.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/internal.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -127,6 +127,8 @@ struct keyring_search_context {\n \tstruct timespec\t\tnow;\n };\n \n+extern int key_default_cmp(const struct key *key,\n+\t\t\t   const struct key_match_data *match_data);\n extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,\n \t\t\t\t    struct keyring_search_context *ctx);\n ""}<_**next**_>{""sha"": ""8c0092ca04430b65b6a0969b5ed3e090038ed2b2"", ""filename"": ""security/keys/key.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -799,7 +799,7 @@ key_ref_t key_create_or_update(key_ref_t keyring_ref,\n \t}\n \n \tkey_ref = ERR_PTR(-EINVAL);\n-\tif (!index_key.type->match || !index_key.type->instantiate ||\n+\tif (!index_key.type->instantiate ||\n \t    (!index_key.description && !index_key.type->preparse))\n \t\tgoto error_put_type;\n ""}<_**next**_>{""sha"": ""253c9a0eb092e2add086d5da72f0811e11007534"", ""filename"": ""security/keys/keyring.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 5, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/keyring.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/keyring.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/keyring.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -89,7 +89,6 @@ struct key_type key_type_keyring = {\n \t.preparse\t= keyring_preparse,\n \t.free_preparse\t= keyring_free_preparse,\n \t.instantiate\t= keyring_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= keyring_revoke,\n \t.destroy\t= keyring_destroy,\n \t.describe\t= keyring_describe,\n@@ -511,6 +510,15 @@ struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n }\n EXPORT_SYMBOL(keyring_alloc);\n \n+/*\n+ * By default, we keys found by getting an exact match on their descriptions.\n+ */\n+int key_default_cmp(const struct key *key,\n+\t\t    const struct key_match_data *match_data)\n+{\n+\treturn strcmp(key->description, match_data->raw_data) == 0;\n+}\n+\n /*\n  * Iteration function to consider each key found.\n  */\n@@ -884,17 +892,14 @@ key_ref_t keyring_search(key_ref_t keyring,\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= type->match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n \t};\n \tkey_ref_t key;\n \tint ret;\n \n-\tif (!ctx.match_data.cmp)\n-\t\treturn ERR_PTR(-ENOKEY);\n-\n \tif (type->match_preparse) {\n \t\tret = type->match_preparse(&ctx.match_data);\n \t\tif (ret < 0)""}<_**next**_>{""sha"": ""dc6ed32b7844cfabce17e4fe0e5e309555524b8b"", ""filename"": ""security/keys/request_key.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/request_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -531,7 +531,7 @@ struct key *request_key_and_link(struct key_type *type,\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= type->match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t};""}<_**next**_>{""sha"": ""6639e2cb885322c6a43924496b2a68be25b9a5e6"", ""filename"": ""security/keys/request_key_auth.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key_auth.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key_auth.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/request_key_auth.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -246,7 +246,7 @@ struct key *key_get_instantiation_authkey(key_serial_t target_id)\n \t\t.index_key.type\t\t= &key_type_request_key_auth,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= user_match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t};""}<_**next**_>{""sha"": ""c0594cb07adab14f1efeb970a8c0dd85d86a7931"", ""filename"": ""security/keys/trusted.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/trusted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/trusted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/trusted.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -1096,7 +1096,6 @@ struct key_type key_type_trusted = {\n \t.name = \""trusted\"",\n \t.instantiate = trusted_instantiate,\n \t.update = trusted_update,\n-\t.match = user_match,\n \t.destroy = trusted_destroy,\n \t.describe = user_describe,\n \t.read = trusted_read,""}<_**next**_>{""sha"": ""36b47bbd3d8cc277de55e0c0cdd722618ca13231"", ""filename"": ""security/keys/user_defined.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 12, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/user_defined.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/user_defined.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/user_defined.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -30,7 +30,6 @@ struct key_type key_type_user = {\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n \t.update\t\t\t= user_update,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,\n@@ -51,7 +50,6 @@ struct key_type key_type_logon = {\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n \t.update\t\t\t= user_update,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,\n@@ -136,16 +134,6 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n EXPORT_SYMBOL_GPL(user_update);\n \n-/*\n- * match users on their name\n- */\n-int user_match(const struct key *key, const struct key_match_data *match_data)\n-{\n-\treturn strcmp(key->description, match_data->raw_data) == 0;\n-}\n-\n-EXPORT_SYMBOL_GPL(user_match);\n-\n /*\n  * dispose of the links from a revoked keyring\n  * - called with the key sem write-locked""}"," static int asymmetric_key_match_preparse(struct key_match_data *match_data)
 {
 	match_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;
	match_data->cmp = asymmetric_key_cmp;
 	return 0;
 }
"," static int asymmetric_key_match_preparse(struct key_match_data *match_data)
 {
 	match_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;
 	return 0;
 }
",C,"	match_data->cmp = asymmetric_key_cmp;
",,,"@@ -59,8 +59,8 @@ EXPORT_SYMBOL_GPL(asymmetric_keyid_match);
  *	""id:<id>""	- request a key matching the ID
  *	""<subtype>:<id>"" - request a key of a subtype
  */
-static int asymmetric_key_match(const struct key *key,
-				const struct key_match_data *match_data)
+static int asymmetric_key_cmp(const struct key *key,
+			      const struct key_match_data *match_data)
 {
 	const struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);
 	const char *description = match_data->raw_data;
@@ -110,6 +110,7 @@ static int asymmetric_key_match(const struct key *key,
 static int asymmetric_key_match_preparse(struct key_match_data *match_data)
 {
 	match_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;
+	match_data->cmp = asymmetric_key_cmp;
 	return 0;
 }
 
@@ -224,7 +225,6 @@ struct key_type key_type_asymmetric = {
 	.free_preparse	= asymmetric_key_free_preparse,
 	.instantiate	= generic_key_instantiate,
 	.match_preparse	= asymmetric_key_match_preparse,
-	.match		= asymmetric_key_match,
 	.match_free	= asymmetric_key_match_free,
 	.destroy	= asymmetric_key_destroy,
 	.describe	= asymmetric_key_describe,",linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,614d8c39014c185aa0f7254f0a470cc33fc1b284,1," static int asymmetric_key_match_preparse(struct key_match_data *match_data)
 {
 	match_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;
//fix_flaw_line_below:
//	match_data->cmp = asymmetric_key_cmp;
 	return 0;
 }
"
3874,181610,,Local,Not required,Complete,CVE-2017-2647,https://www.cvedetails.com/cve/CVE-2017-2647/,CWE-476,Low,Complete,Complete,,2017-03-31,7.2,"The KEYS subsystem in the Linux kernel before 3.18 allows local users to gain privileges or cause a denial of service (NULL pointer dereference and system crash) via vectors involving a NULL value for a certain match field, related to the keyring_search_iterator function in keyring.c.",2019-01-15,DoS +Priv ,2,https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"KEYS: Remove key_type::match in favour of overriding default by match_preparse

A previous patch added a ->match_preparse() method to the key type.  This is
allowed to override the function called by the iteration algorithm.
Therefore, we can just set a default that simply checks for an exact match of
the key description with the original criterion data and allow match_preparse
to override it as needed.

The key_type::match op is then redundant and can be removed, as can the
user_match() function.

Signed-off-by: David Howells <dhowells@redhat.com>
Acked-by: Vivek Goyal <vgoyal@redhat.com>",1,net/dns_resolver/dns_key.c,"{""sha"": ""7c04989689757da3284da98c0e7b933143b89c1b"", ""filename"": ""crypto/asymmetric_keys/asymmetric_type.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/asymmetric_type.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/asymmetric_type.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/asymmetric_keys/asymmetric_type.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -59,8 +59,8 @@ EXPORT_SYMBOL_GPL(asymmetric_keyid_match);\n  *\t\""id:<id>\""\t- request a key matching the ID\n  *\t\""<subtype>:<id>\"" - request a key of a subtype\n  */\n-static int asymmetric_key_match(const struct key *key,\n-\t\t\t\tconst struct key_match_data *match_data)\n+static int asymmetric_key_cmp(const struct key *key,\n+\t\t\t      const struct key_match_data *match_data)\n {\n \tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n \tconst char *description = match_data->raw_data;\n@@ -110,6 +110,7 @@ static int asymmetric_key_match(const struct key *key,\n static int asymmetric_key_match_preparse(struct key_match_data *match_data)\n {\n \tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n+\tmatch_data->cmp = asymmetric_key_cmp;\n \treturn 0;\n }\n \n@@ -224,7 +225,6 @@ struct key_type key_type_asymmetric = {\n \t.free_preparse\t= asymmetric_key_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n \t.match_preparse\t= asymmetric_key_match_preparse,\n-\t.match\t\t= asymmetric_key_match,\n \t.match_free\t= asymmetric_key_match_free,\n \t.destroy\t= asymmetric_key_destroy,\n \t.describe\t= asymmetric_key_describe,""}<_**next**_>{""sha"": ""751f8fd7335db2203f7257edc8ad680dc7ea2a14"", ""filename"": ""crypto/asymmetric_keys/pkcs7_key_type.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/pkcs7_key_type.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/pkcs7_key_type.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/asymmetric_keys/pkcs7_key_type.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -75,7 +75,6 @@ static struct key_type key_type_pkcs7 = {\n \t.preparse\t\t= pkcs7_preparse,\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,""}<_**next**_>{""sha"": ""f4cf200b3c76714ca5a059b1ecdcca6f2e77b338"", ""filename"": ""fs/cifs/cifs_spnego.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifs_spnego.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifs_spnego.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/cifs_spnego.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -62,7 +62,6 @@ cifs_spnego_key_destroy(struct key *key)\n struct key_type cifs_spnego_key_type = {\n \t.name\t\t= \""cifs.spnego\"",\n \t.instantiate\t= cifs_spnego_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= cifs_spnego_key_destroy,\n \t.describe\t= user_describe,\n };""}<_**next**_>{""sha"": ""6d00c419cbae0b54016ba997f55baf1ac7c54956"", ""filename"": ""fs/cifs/cifsacl.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifsacl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifsacl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/cifsacl.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -84,7 +84,6 @@ static struct key_type cifs_idmap_key_type = {\n \t.instantiate = cifs_idmap_key_instantiate,\n \t.destroy     = cifs_idmap_key_destroy,\n \t.describe    = user_describe,\n-\t.match       = user_match,\n };\n \n static char *""}<_**next**_>{""sha"": ""2f5db844c172534a229d86b011be1f6ec2c29aff"", ""filename"": ""fs/nfs/idmap.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/nfs/idmap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/nfs/idmap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfs/idmap.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -177,7 +177,6 @@ static struct key_type key_type_id_resolver = {\n \t.preparse\t= user_preparse,\n \t.free_preparse\t= user_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= user_describe,\n@@ -401,7 +400,6 @@ static struct key_type key_type_id_resolver_legacy = {\n \t.preparse\t= user_preparse,\n \t.free_preparse\t= user_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= user_describe,""}<_**next**_>{""sha"": ""cebefb069c44a51bed96e7fc671f0e839bf94d6a"", ""filename"": ""include/keys/user-type.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/keys/user-type.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/keys/user-type.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/keys/user-type.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -36,13 +36,10 @@ extern struct key_type key_type_user;\n extern struct key_type key_type_logon;\n \n struct key_preparsed_payload;\n-struct key_match_data;\n \n extern int user_preparse(struct key_preparsed_payload *prep);\n extern void user_free_preparse(struct key_preparsed_payload *prep);\n extern int user_update(struct key *key, struct key_preparsed_payload *prep);\n-extern int user_match(const struct key *key,\n-\t\t      const struct key_match_data *match_data);\n extern void user_revoke(struct key *key);\n extern void user_destroy(struct key *key);\n extern void user_describe(const struct key *user, struct seq_file *m);""}<_**next**_>{""sha"": ""c14816bd3b44f14db29787ec90bc3da5ef4a83f9"", ""filename"": ""include/linux/key-type.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/linux/key-type.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/linux/key-type.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/key-type.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -113,10 +113,6 @@ struct key_type {\n \t */\n \tint (*match_preparse)(struct key_match_data *match_data);\n \n-\t/* match a key against a description */\n-\tint (*match)(const struct key *key,\n-\t\t     const struct key_match_data *match_data);\n-\n \t/* Free preparsed match data (optional).  This should be supplied it\n \t * ->match_preparse() is supplied. */\n \tvoid (*match_free)(struct key_match_data *match_data);""}<_**next**_>{""sha"": ""62fc5e7a9acf7506eba2de7ae314ba6067870ceb"", ""filename"": ""net/ceph/crypto.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/ceph/crypto.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/ceph/crypto.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ceph/crypto.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -476,7 +476,6 @@ struct key_type key_type_ceph = {\n \t.preparse\t= ceph_key_preparse,\n \t.free_preparse\t= ceph_key_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= ceph_key_destroy,\n };\n ""}<_**next**_>{""sha"": ""a07b9ba7e0b7bfaa351dc90750c3ca2590b816eb"", ""filename"": ""net/dns_resolver/dns_key.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 4, ""changes"": 17, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/dns_resolver/dns_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/dns_resolver/dns_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/dns_resolver/dns_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -176,9 +176,8 @@ static void dns_resolver_free_preparse(struct key_preparsed_payload *prep)\n  * The domain name may be a simple name or an absolute domain name (which\n  * should end with a period).  The domain name is case-independent.\n  */\n-static int\n-dns_resolver_match(const struct key *key,\n-\t\t   const struct key_match_data *match_data)\n+static int dns_resolver_cmp(const struct key *key,\n+\t\t\t    const struct key_match_data *match_data)\n {\n \tint slen, dlen, ret = 0;\n \tconst char *src = key->description, *dsp = match_data->raw_data;\n@@ -209,6 +208,16 @@ dns_resolver_match(const struct key *key,\n \treturn ret;\n }\n \n+/*\n+ * Preparse the match criterion.\n+ */\n+static int dns_resolver_match_preparse(struct key_match_data *match_data)\n+{\n+\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n+\tmatch_data->cmp = dns_resolver_cmp;\n+\treturn 0;\n+}\n+\n /*\n  * Describe a DNS key\n  */\n@@ -243,7 +252,7 @@ struct key_type key_type_dns_resolver = {\n \t.preparse\t= dns_resolver_preparse,\n \t.free_preparse\t= dns_resolver_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= dns_resolver_match,\n+\t.match_preparse\t= dns_resolver_match_preparse,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= dns_resolver_describe,""}<_**next**_>{""sha"": ""10c6cb694b4343913498a95a2f982ac11d4a1828"", ""filename"": ""net/rxrpc/ar-key.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/rxrpc/ar-key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/rxrpc/ar-key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/rxrpc/ar-key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -44,7 +44,6 @@ struct key_type key_type_rxrpc = {\n \t.preparse\t= rxrpc_preparse,\n \t.free_preparse\t= rxrpc_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= rxrpc_destroy,\n \t.describe\t= rxrpc_describe,\n \t.read\t\t= rxrpc_read,\n@@ -61,7 +60,6 @@ struct key_type key_type_rxrpc_s = {\n \t.preparse\t= rxrpc_preparse_s,\n \t.free_preparse\t= rxrpc_free_preparse_s,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= rxrpc_destroy_s,\n \t.describe\t= rxrpc_describe,\n };""}<_**next**_>{""sha"": ""b6adb94f6d52573aecf2e38a16724e06895dded6"", ""filename"": ""security/keys/big_key.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/big_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/big_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/big_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -36,7 +36,6 @@ struct key_type key_type_big_key = {\n \t.preparse\t\t= big_key_preparse,\n \t.free_preparse\t\t= big_key_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= big_key_revoke,\n \t.destroy\t\t= big_key_destroy,\n \t.describe\t\t= big_key_describe,""}<_**next**_>{""sha"": ""db9675db10262021612016bed79ade14a960d089"", ""filename"": ""security/keys/encrypted-keys/encrypted.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/encrypted-keys/encrypted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/encrypted-keys/encrypted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/encrypted-keys/encrypted.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -970,7 +970,6 @@ struct key_type key_type_encrypted = {\n \t.name = \""encrypted\"",\n \t.instantiate = encrypted_instantiate,\n \t.update = encrypted_update,\n-\t.match = user_match,\n \t.destroy = encrypted_destroy,\n \t.describe = user_describe,\n \t.read = encrypted_read,""}<_**next**_>{""sha"": ""e66a16cb63e1ca223e71d7b3b66ca5c0f19180ea"", ""filename"": ""security/keys/internal.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/internal.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -127,6 +127,8 @@ struct keyring_search_context {\n \tstruct timespec\t\tnow;\n };\n \n+extern int key_default_cmp(const struct key *key,\n+\t\t\t   const struct key_match_data *match_data);\n extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,\n \t\t\t\t    struct keyring_search_context *ctx);\n ""}<_**next**_>{""sha"": ""8c0092ca04430b65b6a0969b5ed3e090038ed2b2"", ""filename"": ""security/keys/key.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -799,7 +799,7 @@ key_ref_t key_create_or_update(key_ref_t keyring_ref,\n \t}\n \n \tkey_ref = ERR_PTR(-EINVAL);\n-\tif (!index_key.type->match || !index_key.type->instantiate ||\n+\tif (!index_key.type->instantiate ||\n \t    (!index_key.description && !index_key.type->preparse))\n \t\tgoto error_put_type;\n ""}<_**next**_>{""sha"": ""253c9a0eb092e2add086d5da72f0811e11007534"", ""filename"": ""security/keys/keyring.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 5, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/keyring.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/keyring.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/keyring.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -89,7 +89,6 @@ struct key_type key_type_keyring = {\n \t.preparse\t= keyring_preparse,\n \t.free_preparse\t= keyring_free_preparse,\n \t.instantiate\t= keyring_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= keyring_revoke,\n \t.destroy\t= keyring_destroy,\n \t.describe\t= keyring_describe,\n@@ -511,6 +510,15 @@ struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n }\n EXPORT_SYMBOL(keyring_alloc);\n \n+/*\n+ * By default, we keys found by getting an exact match on their descriptions.\n+ */\n+int key_default_cmp(const struct key *key,\n+\t\t    const struct key_match_data *match_data)\n+{\n+\treturn strcmp(key->description, match_data->raw_data) == 0;\n+}\n+\n /*\n  * Iteration function to consider each key found.\n  */\n@@ -884,17 +892,14 @@ key_ref_t keyring_search(key_ref_t keyring,\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= type->match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n \t};\n \tkey_ref_t key;\n \tint ret;\n \n-\tif (!ctx.match_data.cmp)\n-\t\treturn ERR_PTR(-ENOKEY);\n-\n \tif (type->match_preparse) {\n \t\tret = type->match_preparse(&ctx.match_data);\n \t\tif (ret < 0)""}<_**next**_>{""sha"": ""dc6ed32b7844cfabce17e4fe0e5e309555524b8b"", ""filename"": ""security/keys/request_key.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/request_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -531,7 +531,7 @@ struct key *request_key_and_link(struct key_type *type,\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= type->match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t};""}<_**next**_>{""sha"": ""6639e2cb885322c6a43924496b2a68be25b9a5e6"", ""filename"": ""security/keys/request_key_auth.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key_auth.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key_auth.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/request_key_auth.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -246,7 +246,7 @@ struct key *key_get_instantiation_authkey(key_serial_t target_id)\n \t\t.index_key.type\t\t= &key_type_request_key_auth,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= user_match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t};""}<_**next**_>{""sha"": ""c0594cb07adab14f1efeb970a8c0dd85d86a7931"", ""filename"": ""security/keys/trusted.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/trusted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/trusted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/trusted.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -1096,7 +1096,6 @@ struct key_type key_type_trusted = {\n \t.name = \""trusted\"",\n \t.instantiate = trusted_instantiate,\n \t.update = trusted_update,\n-\t.match = user_match,\n \t.destroy = trusted_destroy,\n \t.describe = user_describe,\n \t.read = trusted_read,""}<_**next**_>{""sha"": ""36b47bbd3d8cc277de55e0c0cdd722618ca13231"", ""filename"": ""security/keys/user_defined.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 12, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/user_defined.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/user_defined.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/user_defined.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -30,7 +30,6 @@ struct key_type key_type_user = {\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n \t.update\t\t\t= user_update,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,\n@@ -51,7 +50,6 @@ struct key_type key_type_logon = {\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n \t.update\t\t\t= user_update,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,\n@@ -136,16 +134,6 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n EXPORT_SYMBOL_GPL(user_update);\n \n-/*\n- * match users on their name\n- */\n-int user_match(const struct key *key, const struct key_match_data *match_data)\n-{\n-\treturn strcmp(key->description, match_data->raw_data) == 0;\n-}\n-\n-EXPORT_SYMBOL_GPL(user_match);\n-\n /*\n  * dispose of the links from a revoked keyring\n  * - called with the key sem write-locked""}","dns_resolver_match(const struct key *key,
static int dns_resolver_cmp(const struct key *key,
			    const struct key_match_data *match_data)
 {
 	int slen, dlen, ret = 0;
 	const char *src = key->description, *dsp = match_data->raw_data;

	kenter(""%s,%s"", src, dsp);

	if (!src || !dsp)
		goto no_match;

	if (strcasecmp(src, dsp) == 0)
		goto matched;

	slen = strlen(src);
	dlen = strlen(dsp);
	if (slen <= 0 || dlen <= 0)
		goto no_match;
	if (src[slen - 1] == '.')
		slen--;
	if (dsp[dlen - 1] == '.')
		dlen--;
	if (slen != dlen || strncasecmp(src, dsp, slen) != 0)
		goto no_match;

matched:
	ret = 1;
no_match:
	kleave("" = %d"", ret);
 	return ret;
 }
","dns_resolver_match(const struct key *key,
		   const struct key_match_data *match_data)
 {
 	int slen, dlen, ret = 0;
 	const char *src = key->description, *dsp = match_data->raw_data;

	kenter(""%s,%s"", src, dsp);

	if (!src || !dsp)
		goto no_match;

	if (strcasecmp(src, dsp) == 0)
		goto matched;

	slen = strlen(src);
	dlen = strlen(dsp);
	if (slen <= 0 || dlen <= 0)
		goto no_match;
	if (src[slen - 1] == '.')
		slen--;
	if (dsp[dlen - 1] == '.')
		dlen--;
	if (slen != dlen || strncasecmp(src, dsp, slen) != 0)
		goto no_match;

matched:
	ret = 1;
no_match:
	kleave("" = %d"", ret);
 	return ret;
 }
",C,"static int dns_resolver_cmp(const struct key *key,
			    const struct key_match_data *match_data)
","		   const struct key_match_data *match_data)
",,"@@ -176,9 +176,8 @@ static void dns_resolver_free_preparse(struct key_preparsed_payload *prep)
  * The domain name may be a simple name or an absolute domain name (which
  * should end with a period).  The domain name is case-independent.
  */
-static int
-dns_resolver_match(const struct key *key,
-		   const struct key_match_data *match_data)
+static int dns_resolver_cmp(const struct key *key,
+			    const struct key_match_data *match_data)
 {
 	int slen, dlen, ret = 0;
 	const char *src = key->description, *dsp = match_data->raw_data;
@@ -209,6 +208,16 @@ dns_resolver_match(const struct key *key,
 	return ret;
 }
 
+/*
+ * Preparse the match criterion.
+ */
+static int dns_resolver_match_preparse(struct key_match_data *match_data)
+{
+	match_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;
+	match_data->cmp = dns_resolver_cmp;
+	return 0;
+}
+
 /*
  * Describe a DNS key
  */
@@ -243,7 +252,7 @@ struct key_type key_type_dns_resolver = {
 	.preparse	= dns_resolver_preparse,
 	.free_preparse	= dns_resolver_free_preparse,
 	.instantiate	= generic_key_instantiate,
-	.match		= dns_resolver_match,
+	.match_preparse	= dns_resolver_match_preparse,
 	.revoke		= user_revoke,
 	.destroy	= user_destroy,
 	.describe	= dns_resolver_describe,",linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,614d8c39014c185aa0f7254f0a470cc33fc1b284,1,"dns_resolver_match(const struct key *key,
//flaw_line_below:
		   const struct key_match_data *match_data)
//fix_flaw_line_below:
//static int dns_resolver_cmp(const struct key *key,
//fix_flaw_line_below:
//			    const struct key_match_data *match_data)
 {
 	int slen, dlen, ret = 0;
 	const char *src = key->description, *dsp = match_data->raw_data;

	kenter(""%s,%s"", src, dsp);

	if (!src || !dsp)
		goto no_match;

	if (strcasecmp(src, dsp) == 0)
		goto matched;

	slen = strlen(src);
	dlen = strlen(dsp);
	if (slen <= 0 || dlen <= 0)
		goto no_match;
	if (src[slen - 1] == '.')
		slen--;
	if (dsp[dlen - 1] == '.')
		dlen--;
	if (slen != dlen || strncasecmp(src, dsp, slen) != 0)
		goto no_match;

matched:
	ret = 1;
no_match:
	kleave("" = %d"", ret);
 	return ret;
 }
"
3875,181611,,Local,Not required,Complete,CVE-2017-2647,https://www.cvedetails.com/cve/CVE-2017-2647/,CWE-476,Low,Complete,Complete,,2017-03-31,7.2,"The KEYS subsystem in the Linux kernel before 3.18 allows local users to gain privileges or cause a denial of service (NULL pointer dereference and system crash) via vectors involving a NULL value for a certain match field, related to the keyring_search_iterator function in keyring.c.",2019-01-15,DoS +Priv ,1,https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"KEYS: Remove key_type::match in favour of overriding default by match_preparse

A previous patch added a ->match_preparse() method to the key type.  This is
allowed to override the function called by the iteration algorithm.
Therefore, we can just set a default that simply checks for an exact match of
the key description with the original criterion data and allow match_preparse
to override it as needed.

The key_type::match op is then redundant and can be removed, as can the
user_match() function.

Signed-off-by: David Howells <dhowells@redhat.com>
Acked-by: Vivek Goyal <vgoyal@redhat.com>",1,security/keys/key.c,"{""sha"": ""7c04989689757da3284da98c0e7b933143b89c1b"", ""filename"": ""crypto/asymmetric_keys/asymmetric_type.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/asymmetric_type.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/asymmetric_type.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/asymmetric_keys/asymmetric_type.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -59,8 +59,8 @@ EXPORT_SYMBOL_GPL(asymmetric_keyid_match);\n  *\t\""id:<id>\""\t- request a key matching the ID\n  *\t\""<subtype>:<id>\"" - request a key of a subtype\n  */\n-static int asymmetric_key_match(const struct key *key,\n-\t\t\t\tconst struct key_match_data *match_data)\n+static int asymmetric_key_cmp(const struct key *key,\n+\t\t\t      const struct key_match_data *match_data)\n {\n \tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n \tconst char *description = match_data->raw_data;\n@@ -110,6 +110,7 @@ static int asymmetric_key_match(const struct key *key,\n static int asymmetric_key_match_preparse(struct key_match_data *match_data)\n {\n \tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n+\tmatch_data->cmp = asymmetric_key_cmp;\n \treturn 0;\n }\n \n@@ -224,7 +225,6 @@ struct key_type key_type_asymmetric = {\n \t.free_preparse\t= asymmetric_key_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n \t.match_preparse\t= asymmetric_key_match_preparse,\n-\t.match\t\t= asymmetric_key_match,\n \t.match_free\t= asymmetric_key_match_free,\n \t.destroy\t= asymmetric_key_destroy,\n \t.describe\t= asymmetric_key_describe,""}<_**next**_>{""sha"": ""751f8fd7335db2203f7257edc8ad680dc7ea2a14"", ""filename"": ""crypto/asymmetric_keys/pkcs7_key_type.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/pkcs7_key_type.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/pkcs7_key_type.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/asymmetric_keys/pkcs7_key_type.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -75,7 +75,6 @@ static struct key_type key_type_pkcs7 = {\n \t.preparse\t\t= pkcs7_preparse,\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,""}<_**next**_>{""sha"": ""f4cf200b3c76714ca5a059b1ecdcca6f2e77b338"", ""filename"": ""fs/cifs/cifs_spnego.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifs_spnego.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifs_spnego.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/cifs_spnego.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -62,7 +62,6 @@ cifs_spnego_key_destroy(struct key *key)\n struct key_type cifs_spnego_key_type = {\n \t.name\t\t= \""cifs.spnego\"",\n \t.instantiate\t= cifs_spnego_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= cifs_spnego_key_destroy,\n \t.describe\t= user_describe,\n };""}<_**next**_>{""sha"": ""6d00c419cbae0b54016ba997f55baf1ac7c54956"", ""filename"": ""fs/cifs/cifsacl.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifsacl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifsacl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/cifsacl.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -84,7 +84,6 @@ static struct key_type cifs_idmap_key_type = {\n \t.instantiate = cifs_idmap_key_instantiate,\n \t.destroy     = cifs_idmap_key_destroy,\n \t.describe    = user_describe,\n-\t.match       = user_match,\n };\n \n static char *""}<_**next**_>{""sha"": ""2f5db844c172534a229d86b011be1f6ec2c29aff"", ""filename"": ""fs/nfs/idmap.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/nfs/idmap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/nfs/idmap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfs/idmap.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -177,7 +177,6 @@ static struct key_type key_type_id_resolver = {\n \t.preparse\t= user_preparse,\n \t.free_preparse\t= user_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= user_describe,\n@@ -401,7 +400,6 @@ static struct key_type key_type_id_resolver_legacy = {\n \t.preparse\t= user_preparse,\n \t.free_preparse\t= user_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= user_describe,""}<_**next**_>{""sha"": ""cebefb069c44a51bed96e7fc671f0e839bf94d6a"", ""filename"": ""include/keys/user-type.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/keys/user-type.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/keys/user-type.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/keys/user-type.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -36,13 +36,10 @@ extern struct key_type key_type_user;\n extern struct key_type key_type_logon;\n \n struct key_preparsed_payload;\n-struct key_match_data;\n \n extern int user_preparse(struct key_preparsed_payload *prep);\n extern void user_free_preparse(struct key_preparsed_payload *prep);\n extern int user_update(struct key *key, struct key_preparsed_payload *prep);\n-extern int user_match(const struct key *key,\n-\t\t      const struct key_match_data *match_data);\n extern void user_revoke(struct key *key);\n extern void user_destroy(struct key *key);\n extern void user_describe(const struct key *user, struct seq_file *m);""}<_**next**_>{""sha"": ""c14816bd3b44f14db29787ec90bc3da5ef4a83f9"", ""filename"": ""include/linux/key-type.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/linux/key-type.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/linux/key-type.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/key-type.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -113,10 +113,6 @@ struct key_type {\n \t */\n \tint (*match_preparse)(struct key_match_data *match_data);\n \n-\t/* match a key against a description */\n-\tint (*match)(const struct key *key,\n-\t\t     const struct key_match_data *match_data);\n-\n \t/* Free preparsed match data (optional).  This should be supplied it\n \t * ->match_preparse() is supplied. */\n \tvoid (*match_free)(struct key_match_data *match_data);""}<_**next**_>{""sha"": ""62fc5e7a9acf7506eba2de7ae314ba6067870ceb"", ""filename"": ""net/ceph/crypto.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/ceph/crypto.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/ceph/crypto.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ceph/crypto.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -476,7 +476,6 @@ struct key_type key_type_ceph = {\n \t.preparse\t= ceph_key_preparse,\n \t.free_preparse\t= ceph_key_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= ceph_key_destroy,\n };\n ""}<_**next**_>{""sha"": ""a07b9ba7e0b7bfaa351dc90750c3ca2590b816eb"", ""filename"": ""net/dns_resolver/dns_key.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 4, ""changes"": 17, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/dns_resolver/dns_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/dns_resolver/dns_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/dns_resolver/dns_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -176,9 +176,8 @@ static void dns_resolver_free_preparse(struct key_preparsed_payload *prep)\n  * The domain name may be a simple name or an absolute domain name (which\n  * should end with a period).  The domain name is case-independent.\n  */\n-static int\n-dns_resolver_match(const struct key *key,\n-\t\t   const struct key_match_data *match_data)\n+static int dns_resolver_cmp(const struct key *key,\n+\t\t\t    const struct key_match_data *match_data)\n {\n \tint slen, dlen, ret = 0;\n \tconst char *src = key->description, *dsp = match_data->raw_data;\n@@ -209,6 +208,16 @@ dns_resolver_match(const struct key *key,\n \treturn ret;\n }\n \n+/*\n+ * Preparse the match criterion.\n+ */\n+static int dns_resolver_match_preparse(struct key_match_data *match_data)\n+{\n+\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n+\tmatch_data->cmp = dns_resolver_cmp;\n+\treturn 0;\n+}\n+\n /*\n  * Describe a DNS key\n  */\n@@ -243,7 +252,7 @@ struct key_type key_type_dns_resolver = {\n \t.preparse\t= dns_resolver_preparse,\n \t.free_preparse\t= dns_resolver_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= dns_resolver_match,\n+\t.match_preparse\t= dns_resolver_match_preparse,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= dns_resolver_describe,""}<_**next**_>{""sha"": ""10c6cb694b4343913498a95a2f982ac11d4a1828"", ""filename"": ""net/rxrpc/ar-key.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/rxrpc/ar-key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/rxrpc/ar-key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/rxrpc/ar-key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -44,7 +44,6 @@ struct key_type key_type_rxrpc = {\n \t.preparse\t= rxrpc_preparse,\n \t.free_preparse\t= rxrpc_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= rxrpc_destroy,\n \t.describe\t= rxrpc_describe,\n \t.read\t\t= rxrpc_read,\n@@ -61,7 +60,6 @@ struct key_type key_type_rxrpc_s = {\n \t.preparse\t= rxrpc_preparse_s,\n \t.free_preparse\t= rxrpc_free_preparse_s,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= rxrpc_destroy_s,\n \t.describe\t= rxrpc_describe,\n };""}<_**next**_>{""sha"": ""b6adb94f6d52573aecf2e38a16724e06895dded6"", ""filename"": ""security/keys/big_key.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/big_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/big_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/big_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -36,7 +36,6 @@ struct key_type key_type_big_key = {\n \t.preparse\t\t= big_key_preparse,\n \t.free_preparse\t\t= big_key_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= big_key_revoke,\n \t.destroy\t\t= big_key_destroy,\n \t.describe\t\t= big_key_describe,""}<_**next**_>{""sha"": ""db9675db10262021612016bed79ade14a960d089"", ""filename"": ""security/keys/encrypted-keys/encrypted.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/encrypted-keys/encrypted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/encrypted-keys/encrypted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/encrypted-keys/encrypted.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -970,7 +970,6 @@ struct key_type key_type_encrypted = {\n \t.name = \""encrypted\"",\n \t.instantiate = encrypted_instantiate,\n \t.update = encrypted_update,\n-\t.match = user_match,\n \t.destroy = encrypted_destroy,\n \t.describe = user_describe,\n \t.read = encrypted_read,""}<_**next**_>{""sha"": ""e66a16cb63e1ca223e71d7b3b66ca5c0f19180ea"", ""filename"": ""security/keys/internal.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/internal.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -127,6 +127,8 @@ struct keyring_search_context {\n \tstruct timespec\t\tnow;\n };\n \n+extern int key_default_cmp(const struct key *key,\n+\t\t\t   const struct key_match_data *match_data);\n extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,\n \t\t\t\t    struct keyring_search_context *ctx);\n ""}<_**next**_>{""sha"": ""8c0092ca04430b65b6a0969b5ed3e090038ed2b2"", ""filename"": ""security/keys/key.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -799,7 +799,7 @@ key_ref_t key_create_or_update(key_ref_t keyring_ref,\n \t}\n \n \tkey_ref = ERR_PTR(-EINVAL);\n-\tif (!index_key.type->match || !index_key.type->instantiate ||\n+\tif (!index_key.type->instantiate ||\n \t    (!index_key.description && !index_key.type->preparse))\n \t\tgoto error_put_type;\n ""}<_**next**_>{""sha"": ""253c9a0eb092e2add086d5da72f0811e11007534"", ""filename"": ""security/keys/keyring.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 5, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/keyring.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/keyring.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/keyring.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -89,7 +89,6 @@ struct key_type key_type_keyring = {\n \t.preparse\t= keyring_preparse,\n \t.free_preparse\t= keyring_free_preparse,\n \t.instantiate\t= keyring_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= keyring_revoke,\n \t.destroy\t= keyring_destroy,\n \t.describe\t= keyring_describe,\n@@ -511,6 +510,15 @@ struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n }\n EXPORT_SYMBOL(keyring_alloc);\n \n+/*\n+ * By default, we keys found by getting an exact match on their descriptions.\n+ */\n+int key_default_cmp(const struct key *key,\n+\t\t    const struct key_match_data *match_data)\n+{\n+\treturn strcmp(key->description, match_data->raw_data) == 0;\n+}\n+\n /*\n  * Iteration function to consider each key found.\n  */\n@@ -884,17 +892,14 @@ key_ref_t keyring_search(key_ref_t keyring,\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= type->match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n \t};\n \tkey_ref_t key;\n \tint ret;\n \n-\tif (!ctx.match_data.cmp)\n-\t\treturn ERR_PTR(-ENOKEY);\n-\n \tif (type->match_preparse) {\n \t\tret = type->match_preparse(&ctx.match_data);\n \t\tif (ret < 0)""}<_**next**_>{""sha"": ""dc6ed32b7844cfabce17e4fe0e5e309555524b8b"", ""filename"": ""security/keys/request_key.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/request_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -531,7 +531,7 @@ struct key *request_key_and_link(struct key_type *type,\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= type->match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t};""}<_**next**_>{""sha"": ""6639e2cb885322c6a43924496b2a68be25b9a5e6"", ""filename"": ""security/keys/request_key_auth.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key_auth.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key_auth.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/request_key_auth.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -246,7 +246,7 @@ struct key *key_get_instantiation_authkey(key_serial_t target_id)\n \t\t.index_key.type\t\t= &key_type_request_key_auth,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= user_match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t};""}<_**next**_>{""sha"": ""c0594cb07adab14f1efeb970a8c0dd85d86a7931"", ""filename"": ""security/keys/trusted.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/trusted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/trusted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/trusted.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -1096,7 +1096,6 @@ struct key_type key_type_trusted = {\n \t.name = \""trusted\"",\n \t.instantiate = trusted_instantiate,\n \t.update = trusted_update,\n-\t.match = user_match,\n \t.destroy = trusted_destroy,\n \t.describe = user_describe,\n \t.read = trusted_read,""}<_**next**_>{""sha"": ""36b47bbd3d8cc277de55e0c0cdd722618ca13231"", ""filename"": ""security/keys/user_defined.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 12, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/user_defined.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/user_defined.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/user_defined.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -30,7 +30,6 @@ struct key_type key_type_user = {\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n \t.update\t\t\t= user_update,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,\n@@ -51,7 +50,6 @@ struct key_type key_type_logon = {\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n \t.update\t\t\t= user_update,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,\n@@ -136,16 +134,6 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n EXPORT_SYMBOL_GPL(user_update);\n \n-/*\n- * match users on their name\n- */\n-int user_match(const struct key *key, const struct key_match_data *match_data)\n-{\n-\treturn strcmp(key->description, match_data->raw_data) == 0;\n-}\n-\n-EXPORT_SYMBOL_GPL(user_match);\n-\n /*\n  * dispose of the links from a revoked keyring\n  * - called with the key sem write-locked""}","key_ref_t key_create_or_update(key_ref_t keyring_ref,
			       const char *type,
			       const char *description,
			       const void *payload,
			       size_t plen,
			       key_perm_t perm,
			       unsigned long flags)
{
	struct keyring_index_key index_key = {
		.description	= description,
	};
	struct key_preparsed_payload prep;
	struct assoc_array_edit *edit;
	const struct cred *cred = current_cred();
	struct key *keyring, *key = NULL;
	key_ref_t key_ref;
	int ret;

	/* look up the key type to see if it's one of the registered kernel
	 * types */
	index_key.type = key_type_lookup(type);
	if (IS_ERR(index_key.type)) {
		key_ref = ERR_PTR(-ENODEV);
		goto error;
 	}
 
 	key_ref = ERR_PTR(-EINVAL);
	if (!index_key.type->instantiate ||
 	    (!index_key.description && !index_key.type->preparse))
 		goto error_put_type;
 
	keyring = key_ref_to_ptr(keyring_ref);

	key_check(keyring);

	key_ref = ERR_PTR(-ENOTDIR);
	if (keyring->type != &key_type_keyring)
		goto error_put_type;

	memset(&prep, 0, sizeof(prep));
	prep.data = payload;
	prep.datalen = plen;
	prep.quotalen = index_key.type->def_datalen;
	prep.trusted = flags & KEY_ALLOC_TRUSTED;
	prep.expiry = TIME_T_MAX;
	if (index_key.type->preparse) {
		ret = index_key.type->preparse(&prep);
		if (ret < 0) {
			key_ref = ERR_PTR(ret);
			goto error_free_prep;
		}
		if (!index_key.description)
			index_key.description = prep.description;
		key_ref = ERR_PTR(-EINVAL);
		if (!index_key.description)
			goto error_free_prep;
	}
	index_key.desc_len = strlen(index_key.description);

	key_ref = ERR_PTR(-EPERM);
	if (!prep.trusted && test_bit(KEY_FLAG_TRUSTED_ONLY, &keyring->flags))
		goto error_free_prep;
	flags |= prep.trusted ? KEY_ALLOC_TRUSTED : 0;

	ret = __key_link_begin(keyring, &index_key, &edit);
	if (ret < 0) {
		key_ref = ERR_PTR(ret);
		goto error_free_prep;
	}

	/* if we're going to allocate a new key, we're going to have
	 * to modify the keyring */
	ret = key_permission(keyring_ref, KEY_NEED_WRITE);
	if (ret < 0) {
		key_ref = ERR_PTR(ret);
		goto error_link_end;
	}

	/* if it's possible to update this type of key, search for an existing
	 * key of the same type and description in the destination keyring and
	 * update that instead if possible
	 */
	if (index_key.type->update) {
		key_ref = find_key_to_update(keyring_ref, &index_key);
		if (key_ref)
			goto found_matching_key;
	}

	/* if the client doesn't provide, decide on the permissions we want */
	if (perm == KEY_PERM_UNDEF) {
		perm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;
		perm |= KEY_USR_VIEW;

		if (index_key.type->read)
			perm |= KEY_POS_READ;

		if (index_key.type == &key_type_keyring ||
		    index_key.type->update)
			perm |= KEY_POS_WRITE;
	}

	/* allocate a new key */
	key = key_alloc(index_key.type, index_key.description,
			cred->fsuid, cred->fsgid, cred, perm, flags);
	if (IS_ERR(key)) {
		key_ref = ERR_CAST(key);
		goto error_link_end;
	}

	/* instantiate it and link it into the target keyring */
	ret = __key_instantiate_and_link(key, &prep, keyring, NULL, &edit);
	if (ret < 0) {
		key_put(key);
		key_ref = ERR_PTR(ret);
		goto error_link_end;
	}

	key_ref = make_key_ref(key, is_key_possessed(keyring_ref));

error_link_end:
	__key_link_end(keyring, &index_key, edit);
error_free_prep:
	if (index_key.type->preparse)
		index_key.type->free_preparse(&prep);
error_put_type:
	key_type_put(index_key.type);
error:
	return key_ref;

 found_matching_key:
	/* we found a matching key, so we're going to try to update it
	 * - we can drop the locks first as we have the key pinned
	 */
	__key_link_end(keyring, &index_key, edit);

	key_ref = __key_update(key_ref, &prep);
	goto error_free_prep;
}
","key_ref_t key_create_or_update(key_ref_t keyring_ref,
			       const char *type,
			       const char *description,
			       const void *payload,
			       size_t plen,
			       key_perm_t perm,
			       unsigned long flags)
{
	struct keyring_index_key index_key = {
		.description	= description,
	};
	struct key_preparsed_payload prep;
	struct assoc_array_edit *edit;
	const struct cred *cred = current_cred();
	struct key *keyring, *key = NULL;
	key_ref_t key_ref;
	int ret;

	/* look up the key type to see if it's one of the registered kernel
	 * types */
	index_key.type = key_type_lookup(type);
	if (IS_ERR(index_key.type)) {
		key_ref = ERR_PTR(-ENODEV);
		goto error;
 	}
 
 	key_ref = ERR_PTR(-EINVAL);
	if (!index_key.type->match || !index_key.type->instantiate ||
 	    (!index_key.description && !index_key.type->preparse))
 		goto error_put_type;
 
	keyring = key_ref_to_ptr(keyring_ref);

	key_check(keyring);

	key_ref = ERR_PTR(-ENOTDIR);
	if (keyring->type != &key_type_keyring)
		goto error_put_type;

	memset(&prep, 0, sizeof(prep));
	prep.data = payload;
	prep.datalen = plen;
	prep.quotalen = index_key.type->def_datalen;
	prep.trusted = flags & KEY_ALLOC_TRUSTED;
	prep.expiry = TIME_T_MAX;
	if (index_key.type->preparse) {
		ret = index_key.type->preparse(&prep);
		if (ret < 0) {
			key_ref = ERR_PTR(ret);
			goto error_free_prep;
		}
		if (!index_key.description)
			index_key.description = prep.description;
		key_ref = ERR_PTR(-EINVAL);
		if (!index_key.description)
			goto error_free_prep;
	}
	index_key.desc_len = strlen(index_key.description);

	key_ref = ERR_PTR(-EPERM);
	if (!prep.trusted && test_bit(KEY_FLAG_TRUSTED_ONLY, &keyring->flags))
		goto error_free_prep;
	flags |= prep.trusted ? KEY_ALLOC_TRUSTED : 0;

	ret = __key_link_begin(keyring, &index_key, &edit);
	if (ret < 0) {
		key_ref = ERR_PTR(ret);
		goto error_free_prep;
	}

	/* if we're going to allocate a new key, we're going to have
	 * to modify the keyring */
	ret = key_permission(keyring_ref, KEY_NEED_WRITE);
	if (ret < 0) {
		key_ref = ERR_PTR(ret);
		goto error_link_end;
	}

	/* if it's possible to update this type of key, search for an existing
	 * key of the same type and description in the destination keyring and
	 * update that instead if possible
	 */
	if (index_key.type->update) {
		key_ref = find_key_to_update(keyring_ref, &index_key);
		if (key_ref)
			goto found_matching_key;
	}

	/* if the client doesn't provide, decide on the permissions we want */
	if (perm == KEY_PERM_UNDEF) {
		perm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;
		perm |= KEY_USR_VIEW;

		if (index_key.type->read)
			perm |= KEY_POS_READ;

		if (index_key.type == &key_type_keyring ||
		    index_key.type->update)
			perm |= KEY_POS_WRITE;
	}

	/* allocate a new key */
	key = key_alloc(index_key.type, index_key.description,
			cred->fsuid, cred->fsgid, cred, perm, flags);
	if (IS_ERR(key)) {
		key_ref = ERR_CAST(key);
		goto error_link_end;
	}

	/* instantiate it and link it into the target keyring */
	ret = __key_instantiate_and_link(key, &prep, keyring, NULL, &edit);
	if (ret < 0) {
		key_put(key);
		key_ref = ERR_PTR(ret);
		goto error_link_end;
	}

	key_ref = make_key_ref(key, is_key_possessed(keyring_ref));

error_link_end:
	__key_link_end(keyring, &index_key, edit);
error_free_prep:
	if (index_key.type->preparse)
		index_key.type->free_preparse(&prep);
error_put_type:
	key_type_put(index_key.type);
error:
	return key_ref;

 found_matching_key:
	/* we found a matching key, so we're going to try to update it
	 * - we can drop the locks first as we have the key pinned
	 */
	__key_link_end(keyring, &index_key, edit);

	key_ref = __key_update(key_ref, &prep);
	goto error_free_prep;
}
",C,"	if (!index_key.type->instantiate ||
","	if (!index_key.type->match || !index_key.type->instantiate ||
",,"@@ -799,7 +799,7 @@ key_ref_t key_create_or_update(key_ref_t keyring_ref,
 	}
 
 	key_ref = ERR_PTR(-EINVAL);
-	if (!index_key.type->match || !index_key.type->instantiate ||
+	if (!index_key.type->instantiate ||
 	    (!index_key.description && !index_key.type->preparse))
 		goto error_put_type;
 ",linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,614d8c39014c185aa0f7254f0a470cc33fc1b284,1,"key_ref_t key_create_or_update(key_ref_t keyring_ref,
			       const char *type,
			       const char *description,
			       const void *payload,
			       size_t plen,
			       key_perm_t perm,
			       unsigned long flags)
{
	struct keyring_index_key index_key = {
		.description	= description,
	};
	struct key_preparsed_payload prep;
	struct assoc_array_edit *edit;
	const struct cred *cred = current_cred();
	struct key *keyring, *key = NULL;
	key_ref_t key_ref;
	int ret;

	/* look up the key type to see if it's one of the registered kernel
	 * types */
	index_key.type = key_type_lookup(type);
	if (IS_ERR(index_key.type)) {
		key_ref = ERR_PTR(-ENODEV);
		goto error;
 	}
 
 	key_ref = ERR_PTR(-EINVAL);
//flaw_line_below:
	if (!index_key.type->match || !index_key.type->instantiate ||
//fix_flaw_line_below:
//	if (!index_key.type->instantiate ||
 	    (!index_key.description && !index_key.type->preparse))
 		goto error_put_type;
 
	keyring = key_ref_to_ptr(keyring_ref);

	key_check(keyring);

	key_ref = ERR_PTR(-ENOTDIR);
	if (keyring->type != &key_type_keyring)
		goto error_put_type;

	memset(&prep, 0, sizeof(prep));
	prep.data = payload;
	prep.datalen = plen;
	prep.quotalen = index_key.type->def_datalen;
	prep.trusted = flags & KEY_ALLOC_TRUSTED;
	prep.expiry = TIME_T_MAX;
	if (index_key.type->preparse) {
		ret = index_key.type->preparse(&prep);
		if (ret < 0) {
			key_ref = ERR_PTR(ret);
			goto error_free_prep;
		}
		if (!index_key.description)
			index_key.description = prep.description;
		key_ref = ERR_PTR(-EINVAL);
		if (!index_key.description)
			goto error_free_prep;
	}
	index_key.desc_len = strlen(index_key.description);

	key_ref = ERR_PTR(-EPERM);
	if (!prep.trusted && test_bit(KEY_FLAG_TRUSTED_ONLY, &keyring->flags))
		goto error_free_prep;
	flags |= prep.trusted ? KEY_ALLOC_TRUSTED : 0;

	ret = __key_link_begin(keyring, &index_key, &edit);
	if (ret < 0) {
		key_ref = ERR_PTR(ret);
		goto error_free_prep;
	}

	/* if we're going to allocate a new key, we're going to have
	 * to modify the keyring */
	ret = key_permission(keyring_ref, KEY_NEED_WRITE);
	if (ret < 0) {
		key_ref = ERR_PTR(ret);
		goto error_link_end;
	}

	/* if it's possible to update this type of key, search for an existing
	 * key of the same type and description in the destination keyring and
	 * update that instead if possible
	 */
	if (index_key.type->update) {
		key_ref = find_key_to_update(keyring_ref, &index_key);
		if (key_ref)
			goto found_matching_key;
	}

	/* if the client doesn't provide, decide on the permissions we want */
	if (perm == KEY_PERM_UNDEF) {
		perm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;
		perm |= KEY_USR_VIEW;

		if (index_key.type->read)
			perm |= KEY_POS_READ;

		if (index_key.type == &key_type_keyring ||
		    index_key.type->update)
			perm |= KEY_POS_WRITE;
	}

	/* allocate a new key */
	key = key_alloc(index_key.type, index_key.description,
			cred->fsuid, cred->fsgid, cred, perm, flags);
	if (IS_ERR(key)) {
		key_ref = ERR_CAST(key);
		goto error_link_end;
	}

	/* instantiate it and link it into the target keyring */
	ret = __key_instantiate_and_link(key, &prep, keyring, NULL, &edit);
	if (ret < 0) {
		key_put(key);
		key_ref = ERR_PTR(ret);
		goto error_link_end;
	}

	key_ref = make_key_ref(key, is_key_possessed(keyring_ref));

error_link_end:
	__key_link_end(keyring, &index_key, edit);
error_free_prep:
	if (index_key.type->preparse)
		index_key.type->free_preparse(&prep);
error_put_type:
	key_type_put(index_key.type);
error:
	return key_ref;

 found_matching_key:
	/* we found a matching key, so we're going to try to update it
	 * - we can drop the locks first as we have the key pinned
	 */
	__key_link_end(keyring, &index_key, edit);

	key_ref = __key_update(key_ref, &prep);
	goto error_free_prep;
}
"
3876,181612,,Local,Not required,Complete,CVE-2017-2647,https://www.cvedetails.com/cve/CVE-2017-2647/,CWE-476,Low,Complete,Complete,,2017-03-31,7.2,"The KEYS subsystem in the Linux kernel before 3.18 allows local users to gain privileges or cause a denial of service (NULL pointer dereference and system crash) via vectors involving a NULL value for a certain match field, related to the keyring_search_iterator function in keyring.c.",2019-01-15,DoS +Priv ,1,https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"KEYS: Remove key_type::match in favour of overriding default by match_preparse

A previous patch added a ->match_preparse() method to the key type.  This is
allowed to override the function called by the iteration algorithm.
Therefore, we can just set a default that simply checks for an exact match of
the key description with the original criterion data and allow match_preparse
to override it as needed.

The key_type::match op is then redundant and can be removed, as can the
user_match() function.

Signed-off-by: David Howells <dhowells@redhat.com>
Acked-by: Vivek Goyal <vgoyal@redhat.com>",3,security/keys/keyring.c,"{""sha"": ""7c04989689757da3284da98c0e7b933143b89c1b"", ""filename"": ""crypto/asymmetric_keys/asymmetric_type.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/asymmetric_type.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/asymmetric_type.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/asymmetric_keys/asymmetric_type.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -59,8 +59,8 @@ EXPORT_SYMBOL_GPL(asymmetric_keyid_match);\n  *\t\""id:<id>\""\t- request a key matching the ID\n  *\t\""<subtype>:<id>\"" - request a key of a subtype\n  */\n-static int asymmetric_key_match(const struct key *key,\n-\t\t\t\tconst struct key_match_data *match_data)\n+static int asymmetric_key_cmp(const struct key *key,\n+\t\t\t      const struct key_match_data *match_data)\n {\n \tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n \tconst char *description = match_data->raw_data;\n@@ -110,6 +110,7 @@ static int asymmetric_key_match(const struct key *key,\n static int asymmetric_key_match_preparse(struct key_match_data *match_data)\n {\n \tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n+\tmatch_data->cmp = asymmetric_key_cmp;\n \treturn 0;\n }\n \n@@ -224,7 +225,6 @@ struct key_type key_type_asymmetric = {\n \t.free_preparse\t= asymmetric_key_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n \t.match_preparse\t= asymmetric_key_match_preparse,\n-\t.match\t\t= asymmetric_key_match,\n \t.match_free\t= asymmetric_key_match_free,\n \t.destroy\t= asymmetric_key_destroy,\n \t.describe\t= asymmetric_key_describe,""}<_**next**_>{""sha"": ""751f8fd7335db2203f7257edc8ad680dc7ea2a14"", ""filename"": ""crypto/asymmetric_keys/pkcs7_key_type.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/pkcs7_key_type.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/pkcs7_key_type.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/asymmetric_keys/pkcs7_key_type.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -75,7 +75,6 @@ static struct key_type key_type_pkcs7 = {\n \t.preparse\t\t= pkcs7_preparse,\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,""}<_**next**_>{""sha"": ""f4cf200b3c76714ca5a059b1ecdcca6f2e77b338"", ""filename"": ""fs/cifs/cifs_spnego.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifs_spnego.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifs_spnego.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/cifs_spnego.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -62,7 +62,6 @@ cifs_spnego_key_destroy(struct key *key)\n struct key_type cifs_spnego_key_type = {\n \t.name\t\t= \""cifs.spnego\"",\n \t.instantiate\t= cifs_spnego_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= cifs_spnego_key_destroy,\n \t.describe\t= user_describe,\n };""}<_**next**_>{""sha"": ""6d00c419cbae0b54016ba997f55baf1ac7c54956"", ""filename"": ""fs/cifs/cifsacl.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifsacl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifsacl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/cifsacl.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -84,7 +84,6 @@ static struct key_type cifs_idmap_key_type = {\n \t.instantiate = cifs_idmap_key_instantiate,\n \t.destroy     = cifs_idmap_key_destroy,\n \t.describe    = user_describe,\n-\t.match       = user_match,\n };\n \n static char *""}<_**next**_>{""sha"": ""2f5db844c172534a229d86b011be1f6ec2c29aff"", ""filename"": ""fs/nfs/idmap.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/nfs/idmap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/nfs/idmap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfs/idmap.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -177,7 +177,6 @@ static struct key_type key_type_id_resolver = {\n \t.preparse\t= user_preparse,\n \t.free_preparse\t= user_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= user_describe,\n@@ -401,7 +400,6 @@ static struct key_type key_type_id_resolver_legacy = {\n \t.preparse\t= user_preparse,\n \t.free_preparse\t= user_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= user_describe,""}<_**next**_>{""sha"": ""cebefb069c44a51bed96e7fc671f0e839bf94d6a"", ""filename"": ""include/keys/user-type.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/keys/user-type.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/keys/user-type.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/keys/user-type.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -36,13 +36,10 @@ extern struct key_type key_type_user;\n extern struct key_type key_type_logon;\n \n struct key_preparsed_payload;\n-struct key_match_data;\n \n extern int user_preparse(struct key_preparsed_payload *prep);\n extern void user_free_preparse(struct key_preparsed_payload *prep);\n extern int user_update(struct key *key, struct key_preparsed_payload *prep);\n-extern int user_match(const struct key *key,\n-\t\t      const struct key_match_data *match_data);\n extern void user_revoke(struct key *key);\n extern void user_destroy(struct key *key);\n extern void user_describe(const struct key *user, struct seq_file *m);""}<_**next**_>{""sha"": ""c14816bd3b44f14db29787ec90bc3da5ef4a83f9"", ""filename"": ""include/linux/key-type.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/linux/key-type.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/linux/key-type.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/key-type.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -113,10 +113,6 @@ struct key_type {\n \t */\n \tint (*match_preparse)(struct key_match_data *match_data);\n \n-\t/* match a key against a description */\n-\tint (*match)(const struct key *key,\n-\t\t     const struct key_match_data *match_data);\n-\n \t/* Free preparsed match data (optional).  This should be supplied it\n \t * ->match_preparse() is supplied. */\n \tvoid (*match_free)(struct key_match_data *match_data);""}<_**next**_>{""sha"": ""62fc5e7a9acf7506eba2de7ae314ba6067870ceb"", ""filename"": ""net/ceph/crypto.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/ceph/crypto.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/ceph/crypto.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ceph/crypto.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -476,7 +476,6 @@ struct key_type key_type_ceph = {\n \t.preparse\t= ceph_key_preparse,\n \t.free_preparse\t= ceph_key_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= ceph_key_destroy,\n };\n ""}<_**next**_>{""sha"": ""a07b9ba7e0b7bfaa351dc90750c3ca2590b816eb"", ""filename"": ""net/dns_resolver/dns_key.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 4, ""changes"": 17, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/dns_resolver/dns_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/dns_resolver/dns_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/dns_resolver/dns_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -176,9 +176,8 @@ static void dns_resolver_free_preparse(struct key_preparsed_payload *prep)\n  * The domain name may be a simple name or an absolute domain name (which\n  * should end with a period).  The domain name is case-independent.\n  */\n-static int\n-dns_resolver_match(const struct key *key,\n-\t\t   const struct key_match_data *match_data)\n+static int dns_resolver_cmp(const struct key *key,\n+\t\t\t    const struct key_match_data *match_data)\n {\n \tint slen, dlen, ret = 0;\n \tconst char *src = key->description, *dsp = match_data->raw_data;\n@@ -209,6 +208,16 @@ dns_resolver_match(const struct key *key,\n \treturn ret;\n }\n \n+/*\n+ * Preparse the match criterion.\n+ */\n+static int dns_resolver_match_preparse(struct key_match_data *match_data)\n+{\n+\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n+\tmatch_data->cmp = dns_resolver_cmp;\n+\treturn 0;\n+}\n+\n /*\n  * Describe a DNS key\n  */\n@@ -243,7 +252,7 @@ struct key_type key_type_dns_resolver = {\n \t.preparse\t= dns_resolver_preparse,\n \t.free_preparse\t= dns_resolver_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= dns_resolver_match,\n+\t.match_preparse\t= dns_resolver_match_preparse,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= dns_resolver_describe,""}<_**next**_>{""sha"": ""10c6cb694b4343913498a95a2f982ac11d4a1828"", ""filename"": ""net/rxrpc/ar-key.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/rxrpc/ar-key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/rxrpc/ar-key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/rxrpc/ar-key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -44,7 +44,6 @@ struct key_type key_type_rxrpc = {\n \t.preparse\t= rxrpc_preparse,\n \t.free_preparse\t= rxrpc_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= rxrpc_destroy,\n \t.describe\t= rxrpc_describe,\n \t.read\t\t= rxrpc_read,\n@@ -61,7 +60,6 @@ struct key_type key_type_rxrpc_s = {\n \t.preparse\t= rxrpc_preparse_s,\n \t.free_preparse\t= rxrpc_free_preparse_s,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= rxrpc_destroy_s,\n \t.describe\t= rxrpc_describe,\n };""}<_**next**_>{""sha"": ""b6adb94f6d52573aecf2e38a16724e06895dded6"", ""filename"": ""security/keys/big_key.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/big_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/big_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/big_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -36,7 +36,6 @@ struct key_type key_type_big_key = {\n \t.preparse\t\t= big_key_preparse,\n \t.free_preparse\t\t= big_key_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= big_key_revoke,\n \t.destroy\t\t= big_key_destroy,\n \t.describe\t\t= big_key_describe,""}<_**next**_>{""sha"": ""db9675db10262021612016bed79ade14a960d089"", ""filename"": ""security/keys/encrypted-keys/encrypted.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/encrypted-keys/encrypted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/encrypted-keys/encrypted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/encrypted-keys/encrypted.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -970,7 +970,6 @@ struct key_type key_type_encrypted = {\n \t.name = \""encrypted\"",\n \t.instantiate = encrypted_instantiate,\n \t.update = encrypted_update,\n-\t.match = user_match,\n \t.destroy = encrypted_destroy,\n \t.describe = user_describe,\n \t.read = encrypted_read,""}<_**next**_>{""sha"": ""e66a16cb63e1ca223e71d7b3b66ca5c0f19180ea"", ""filename"": ""security/keys/internal.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/internal.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -127,6 +127,8 @@ struct keyring_search_context {\n \tstruct timespec\t\tnow;\n };\n \n+extern int key_default_cmp(const struct key *key,\n+\t\t\t   const struct key_match_data *match_data);\n extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,\n \t\t\t\t    struct keyring_search_context *ctx);\n ""}<_**next**_>{""sha"": ""8c0092ca04430b65b6a0969b5ed3e090038ed2b2"", ""filename"": ""security/keys/key.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -799,7 +799,7 @@ key_ref_t key_create_or_update(key_ref_t keyring_ref,\n \t}\n \n \tkey_ref = ERR_PTR(-EINVAL);\n-\tif (!index_key.type->match || !index_key.type->instantiate ||\n+\tif (!index_key.type->instantiate ||\n \t    (!index_key.description && !index_key.type->preparse))\n \t\tgoto error_put_type;\n ""}<_**next**_>{""sha"": ""253c9a0eb092e2add086d5da72f0811e11007534"", ""filename"": ""security/keys/keyring.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 5, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/keyring.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/keyring.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/keyring.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -89,7 +89,6 @@ struct key_type key_type_keyring = {\n \t.preparse\t= keyring_preparse,\n \t.free_preparse\t= keyring_free_preparse,\n \t.instantiate\t= keyring_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= keyring_revoke,\n \t.destroy\t= keyring_destroy,\n \t.describe\t= keyring_describe,\n@@ -511,6 +510,15 @@ struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n }\n EXPORT_SYMBOL(keyring_alloc);\n \n+/*\n+ * By default, we keys found by getting an exact match on their descriptions.\n+ */\n+int key_default_cmp(const struct key *key,\n+\t\t    const struct key_match_data *match_data)\n+{\n+\treturn strcmp(key->description, match_data->raw_data) == 0;\n+}\n+\n /*\n  * Iteration function to consider each key found.\n  */\n@@ -884,17 +892,14 @@ key_ref_t keyring_search(key_ref_t keyring,\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= type->match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n \t};\n \tkey_ref_t key;\n \tint ret;\n \n-\tif (!ctx.match_data.cmp)\n-\t\treturn ERR_PTR(-ENOKEY);\n-\n \tif (type->match_preparse) {\n \t\tret = type->match_preparse(&ctx.match_data);\n \t\tif (ret < 0)""}<_**next**_>{""sha"": ""dc6ed32b7844cfabce17e4fe0e5e309555524b8b"", ""filename"": ""security/keys/request_key.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/request_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -531,7 +531,7 @@ struct key *request_key_and_link(struct key_type *type,\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= type->match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t};""}<_**next**_>{""sha"": ""6639e2cb885322c6a43924496b2a68be25b9a5e6"", ""filename"": ""security/keys/request_key_auth.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key_auth.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key_auth.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/request_key_auth.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -246,7 +246,7 @@ struct key *key_get_instantiation_authkey(key_serial_t target_id)\n \t\t.index_key.type\t\t= &key_type_request_key_auth,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= user_match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t};""}<_**next**_>{""sha"": ""c0594cb07adab14f1efeb970a8c0dd85d86a7931"", ""filename"": ""security/keys/trusted.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/trusted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/trusted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/trusted.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -1096,7 +1096,6 @@ struct key_type key_type_trusted = {\n \t.name = \""trusted\"",\n \t.instantiate = trusted_instantiate,\n \t.update = trusted_update,\n-\t.match = user_match,\n \t.destroy = trusted_destroy,\n \t.describe = user_describe,\n \t.read = trusted_read,""}<_**next**_>{""sha"": ""36b47bbd3d8cc277de55e0c0cdd722618ca13231"", ""filename"": ""security/keys/user_defined.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 12, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/user_defined.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/user_defined.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/user_defined.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -30,7 +30,6 @@ struct key_type key_type_user = {\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n \t.update\t\t\t= user_update,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,\n@@ -51,7 +50,6 @@ struct key_type key_type_logon = {\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n \t.update\t\t\t= user_update,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,\n@@ -136,16 +134,6 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n EXPORT_SYMBOL_GPL(user_update);\n \n-/*\n- * match users on their name\n- */\n-int user_match(const struct key *key, const struct key_match_data *match_data)\n-{\n-\treturn strcmp(key->description, match_data->raw_data) == 0;\n-}\n-\n-EXPORT_SYMBOL_GPL(user_match);\n-\n /*\n  * dispose of the links from a revoked keyring\n  * - called with the key sem write-locked""}","key_ref_t keyring_search(key_ref_t keyring,
			 struct key_type *type,
			 const char *description)
{
	struct keyring_search_context ctx = {
 		.index_key.type		= type,
 		.index_key.description	= description,
 		.cred			= current_cred(),
		.match_data.cmp		= key_default_cmp,
 		.match_data.raw_data	= description,
 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
 		.flags			= KEYRING_SEARCH_DO_STATE_CHECK,
 	};
 	key_ref_t key;
 	int ret;
 
 	if (type->match_preparse) {
 		ret = type->match_preparse(&ctx.match_data);
 		if (ret < 0)
			return ERR_PTR(ret);
	}

	key = keyring_search_aux(keyring, &ctx);

	if (type->match_free)
		type->match_free(&ctx.match_data);
	return key;
}
","key_ref_t keyring_search(key_ref_t keyring,
			 struct key_type *type,
			 const char *description)
{
	struct keyring_search_context ctx = {
 		.index_key.type		= type,
 		.index_key.description	= description,
 		.cred			= current_cred(),
		.match_data.cmp		= type->match,
 		.match_data.raw_data	= description,
 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
 		.flags			= KEYRING_SEARCH_DO_STATE_CHECK,
 	};
 	key_ref_t key;
 	int ret;
 
	if (!ctx.match_data.cmp)
		return ERR_PTR(-ENOKEY);
 	if (type->match_preparse) {
 		ret = type->match_preparse(&ctx.match_data);
 		if (ret < 0)
			return ERR_PTR(ret);
	}

	key = keyring_search_aux(keyring, &ctx);

	if (type->match_free)
		type->match_free(&ctx.match_data);
	return key;
}
",C,"		.match_data.cmp		= key_default_cmp,
","		.match_data.cmp		= type->match,
	if (!ctx.match_data.cmp)
		return ERR_PTR(-ENOKEY);
",,"@@ -89,7 +89,6 @@ struct key_type key_type_keyring = {
 	.preparse	= keyring_preparse,
 	.free_preparse	= keyring_free_preparse,
 	.instantiate	= keyring_instantiate,
-	.match		= user_match,
 	.revoke		= keyring_revoke,
 	.destroy	= keyring_destroy,
 	.describe	= keyring_describe,
@@ -511,6 +510,15 @@ struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,
 }
 EXPORT_SYMBOL(keyring_alloc);
 
+/*
+ * By default, we keys found by getting an exact match on their descriptions.
+ */
+int key_default_cmp(const struct key *key,
+		    const struct key_match_data *match_data)
+{
+	return strcmp(key->description, match_data->raw_data) == 0;
+}
+
 /*
  * Iteration function to consider each key found.
  */
@@ -884,17 +892,14 @@ key_ref_t keyring_search(key_ref_t keyring,
 		.index_key.type		= type,
 		.index_key.description	= description,
 		.cred			= current_cred(),
-		.match_data.cmp		= type->match,
+		.match_data.cmp		= key_default_cmp,
 		.match_data.raw_data	= description,
 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
 		.flags			= KEYRING_SEARCH_DO_STATE_CHECK,
 	};
 	key_ref_t key;
 	int ret;
 
-	if (!ctx.match_data.cmp)
-		return ERR_PTR(-ENOKEY);
-
 	if (type->match_preparse) {
 		ret = type->match_preparse(&ctx.match_data);
 		if (ret < 0)",linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,614d8c39014c185aa0f7254f0a470cc33fc1b284,1,"key_ref_t keyring_search(key_ref_t keyring,
			 struct key_type *type,
			 const char *description)
{
	struct keyring_search_context ctx = {
 		.index_key.type		= type,
 		.index_key.description	= description,
 		.cred			= current_cred(),
//flaw_line_below:
		.match_data.cmp		= type->match,
//fix_flaw_line_below:
//		.match_data.cmp		= key_default_cmp,
 		.match_data.raw_data	= description,
 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
 		.flags			= KEYRING_SEARCH_DO_STATE_CHECK,
 	};
 	key_ref_t key;
 	int ret;
 
//flaw_line_below:
	if (!ctx.match_data.cmp)
//flaw_line_below:
		return ERR_PTR(-ENOKEY);
//flaw_line_below:

 	if (type->match_preparse) {
 		ret = type->match_preparse(&ctx.match_data);
 		if (ret < 0)
			return ERR_PTR(ret);
	}

	key = keyring_search_aux(keyring, &ctx);

	if (type->match_free)
		type->match_free(&ctx.match_data);
	return key;
}
"
3877,181613,,Local,Not required,Complete,CVE-2017-2647,https://www.cvedetails.com/cve/CVE-2017-2647/,CWE-476,Low,Complete,Complete,,2017-03-31,7.2,"The KEYS subsystem in the Linux kernel before 3.18 allows local users to gain privileges or cause a denial of service (NULL pointer dereference and system crash) via vectors involving a NULL value for a certain match field, related to the keyring_search_iterator function in keyring.c.",2019-01-15,DoS +Priv ,1,https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"KEYS: Remove key_type::match in favour of overriding default by match_preparse

A previous patch added a ->match_preparse() method to the key type.  This is
allowed to override the function called by the iteration algorithm.
Therefore, we can just set a default that simply checks for an exact match of
the key description with the original criterion data and allow match_preparse
to override it as needed.

The key_type::match op is then redundant and can be removed, as can the
user_match() function.

Signed-off-by: David Howells <dhowells@redhat.com>
Acked-by: Vivek Goyal <vgoyal@redhat.com>",1,security/keys/request_key.c,"{""sha"": ""7c04989689757da3284da98c0e7b933143b89c1b"", ""filename"": ""crypto/asymmetric_keys/asymmetric_type.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/asymmetric_type.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/asymmetric_type.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/asymmetric_keys/asymmetric_type.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -59,8 +59,8 @@ EXPORT_SYMBOL_GPL(asymmetric_keyid_match);\n  *\t\""id:<id>\""\t- request a key matching the ID\n  *\t\""<subtype>:<id>\"" - request a key of a subtype\n  */\n-static int asymmetric_key_match(const struct key *key,\n-\t\t\t\tconst struct key_match_data *match_data)\n+static int asymmetric_key_cmp(const struct key *key,\n+\t\t\t      const struct key_match_data *match_data)\n {\n \tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n \tconst char *description = match_data->raw_data;\n@@ -110,6 +110,7 @@ static int asymmetric_key_match(const struct key *key,\n static int asymmetric_key_match_preparse(struct key_match_data *match_data)\n {\n \tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n+\tmatch_data->cmp = asymmetric_key_cmp;\n \treturn 0;\n }\n \n@@ -224,7 +225,6 @@ struct key_type key_type_asymmetric = {\n \t.free_preparse\t= asymmetric_key_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n \t.match_preparse\t= asymmetric_key_match_preparse,\n-\t.match\t\t= asymmetric_key_match,\n \t.match_free\t= asymmetric_key_match_free,\n \t.destroy\t= asymmetric_key_destroy,\n \t.describe\t= asymmetric_key_describe,""}<_**next**_>{""sha"": ""751f8fd7335db2203f7257edc8ad680dc7ea2a14"", ""filename"": ""crypto/asymmetric_keys/pkcs7_key_type.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/pkcs7_key_type.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/pkcs7_key_type.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/asymmetric_keys/pkcs7_key_type.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -75,7 +75,6 @@ static struct key_type key_type_pkcs7 = {\n \t.preparse\t\t= pkcs7_preparse,\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,""}<_**next**_>{""sha"": ""f4cf200b3c76714ca5a059b1ecdcca6f2e77b338"", ""filename"": ""fs/cifs/cifs_spnego.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifs_spnego.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifs_spnego.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/cifs_spnego.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -62,7 +62,6 @@ cifs_spnego_key_destroy(struct key *key)\n struct key_type cifs_spnego_key_type = {\n \t.name\t\t= \""cifs.spnego\"",\n \t.instantiate\t= cifs_spnego_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= cifs_spnego_key_destroy,\n \t.describe\t= user_describe,\n };""}<_**next**_>{""sha"": ""6d00c419cbae0b54016ba997f55baf1ac7c54956"", ""filename"": ""fs/cifs/cifsacl.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifsacl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifsacl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/cifsacl.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -84,7 +84,6 @@ static struct key_type cifs_idmap_key_type = {\n \t.instantiate = cifs_idmap_key_instantiate,\n \t.destroy     = cifs_idmap_key_destroy,\n \t.describe    = user_describe,\n-\t.match       = user_match,\n };\n \n static char *""}<_**next**_>{""sha"": ""2f5db844c172534a229d86b011be1f6ec2c29aff"", ""filename"": ""fs/nfs/idmap.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/nfs/idmap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/nfs/idmap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfs/idmap.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -177,7 +177,6 @@ static struct key_type key_type_id_resolver = {\n \t.preparse\t= user_preparse,\n \t.free_preparse\t= user_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= user_describe,\n@@ -401,7 +400,6 @@ static struct key_type key_type_id_resolver_legacy = {\n \t.preparse\t= user_preparse,\n \t.free_preparse\t= user_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= user_describe,""}<_**next**_>{""sha"": ""cebefb069c44a51bed96e7fc671f0e839bf94d6a"", ""filename"": ""include/keys/user-type.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/keys/user-type.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/keys/user-type.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/keys/user-type.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -36,13 +36,10 @@ extern struct key_type key_type_user;\n extern struct key_type key_type_logon;\n \n struct key_preparsed_payload;\n-struct key_match_data;\n \n extern int user_preparse(struct key_preparsed_payload *prep);\n extern void user_free_preparse(struct key_preparsed_payload *prep);\n extern int user_update(struct key *key, struct key_preparsed_payload *prep);\n-extern int user_match(const struct key *key,\n-\t\t      const struct key_match_data *match_data);\n extern void user_revoke(struct key *key);\n extern void user_destroy(struct key *key);\n extern void user_describe(const struct key *user, struct seq_file *m);""}<_**next**_>{""sha"": ""c14816bd3b44f14db29787ec90bc3da5ef4a83f9"", ""filename"": ""include/linux/key-type.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/linux/key-type.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/linux/key-type.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/key-type.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -113,10 +113,6 @@ struct key_type {\n \t */\n \tint (*match_preparse)(struct key_match_data *match_data);\n \n-\t/* match a key against a description */\n-\tint (*match)(const struct key *key,\n-\t\t     const struct key_match_data *match_data);\n-\n \t/* Free preparsed match data (optional).  This should be supplied it\n \t * ->match_preparse() is supplied. */\n \tvoid (*match_free)(struct key_match_data *match_data);""}<_**next**_>{""sha"": ""62fc5e7a9acf7506eba2de7ae314ba6067870ceb"", ""filename"": ""net/ceph/crypto.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/ceph/crypto.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/ceph/crypto.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ceph/crypto.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -476,7 +476,6 @@ struct key_type key_type_ceph = {\n \t.preparse\t= ceph_key_preparse,\n \t.free_preparse\t= ceph_key_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= ceph_key_destroy,\n };\n ""}<_**next**_>{""sha"": ""a07b9ba7e0b7bfaa351dc90750c3ca2590b816eb"", ""filename"": ""net/dns_resolver/dns_key.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 4, ""changes"": 17, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/dns_resolver/dns_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/dns_resolver/dns_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/dns_resolver/dns_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -176,9 +176,8 @@ static void dns_resolver_free_preparse(struct key_preparsed_payload *prep)\n  * The domain name may be a simple name or an absolute domain name (which\n  * should end with a period).  The domain name is case-independent.\n  */\n-static int\n-dns_resolver_match(const struct key *key,\n-\t\t   const struct key_match_data *match_data)\n+static int dns_resolver_cmp(const struct key *key,\n+\t\t\t    const struct key_match_data *match_data)\n {\n \tint slen, dlen, ret = 0;\n \tconst char *src = key->description, *dsp = match_data->raw_data;\n@@ -209,6 +208,16 @@ dns_resolver_match(const struct key *key,\n \treturn ret;\n }\n \n+/*\n+ * Preparse the match criterion.\n+ */\n+static int dns_resolver_match_preparse(struct key_match_data *match_data)\n+{\n+\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n+\tmatch_data->cmp = dns_resolver_cmp;\n+\treturn 0;\n+}\n+\n /*\n  * Describe a DNS key\n  */\n@@ -243,7 +252,7 @@ struct key_type key_type_dns_resolver = {\n \t.preparse\t= dns_resolver_preparse,\n \t.free_preparse\t= dns_resolver_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= dns_resolver_match,\n+\t.match_preparse\t= dns_resolver_match_preparse,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= dns_resolver_describe,""}<_**next**_>{""sha"": ""10c6cb694b4343913498a95a2f982ac11d4a1828"", ""filename"": ""net/rxrpc/ar-key.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/rxrpc/ar-key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/rxrpc/ar-key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/rxrpc/ar-key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -44,7 +44,6 @@ struct key_type key_type_rxrpc = {\n \t.preparse\t= rxrpc_preparse,\n \t.free_preparse\t= rxrpc_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= rxrpc_destroy,\n \t.describe\t= rxrpc_describe,\n \t.read\t\t= rxrpc_read,\n@@ -61,7 +60,6 @@ struct key_type key_type_rxrpc_s = {\n \t.preparse\t= rxrpc_preparse_s,\n \t.free_preparse\t= rxrpc_free_preparse_s,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= rxrpc_destroy_s,\n \t.describe\t= rxrpc_describe,\n };""}<_**next**_>{""sha"": ""b6adb94f6d52573aecf2e38a16724e06895dded6"", ""filename"": ""security/keys/big_key.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/big_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/big_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/big_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -36,7 +36,6 @@ struct key_type key_type_big_key = {\n \t.preparse\t\t= big_key_preparse,\n \t.free_preparse\t\t= big_key_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= big_key_revoke,\n \t.destroy\t\t= big_key_destroy,\n \t.describe\t\t= big_key_describe,""}<_**next**_>{""sha"": ""db9675db10262021612016bed79ade14a960d089"", ""filename"": ""security/keys/encrypted-keys/encrypted.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/encrypted-keys/encrypted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/encrypted-keys/encrypted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/encrypted-keys/encrypted.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -970,7 +970,6 @@ struct key_type key_type_encrypted = {\n \t.name = \""encrypted\"",\n \t.instantiate = encrypted_instantiate,\n \t.update = encrypted_update,\n-\t.match = user_match,\n \t.destroy = encrypted_destroy,\n \t.describe = user_describe,\n \t.read = encrypted_read,""}<_**next**_>{""sha"": ""e66a16cb63e1ca223e71d7b3b66ca5c0f19180ea"", ""filename"": ""security/keys/internal.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/internal.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -127,6 +127,8 @@ struct keyring_search_context {\n \tstruct timespec\t\tnow;\n };\n \n+extern int key_default_cmp(const struct key *key,\n+\t\t\t   const struct key_match_data *match_data);\n extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,\n \t\t\t\t    struct keyring_search_context *ctx);\n ""}<_**next**_>{""sha"": ""8c0092ca04430b65b6a0969b5ed3e090038ed2b2"", ""filename"": ""security/keys/key.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -799,7 +799,7 @@ key_ref_t key_create_or_update(key_ref_t keyring_ref,\n \t}\n \n \tkey_ref = ERR_PTR(-EINVAL);\n-\tif (!index_key.type->match || !index_key.type->instantiate ||\n+\tif (!index_key.type->instantiate ||\n \t    (!index_key.description && !index_key.type->preparse))\n \t\tgoto error_put_type;\n ""}<_**next**_>{""sha"": ""253c9a0eb092e2add086d5da72f0811e11007534"", ""filename"": ""security/keys/keyring.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 5, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/keyring.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/keyring.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/keyring.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -89,7 +89,6 @@ struct key_type key_type_keyring = {\n \t.preparse\t= keyring_preparse,\n \t.free_preparse\t= keyring_free_preparse,\n \t.instantiate\t= keyring_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= keyring_revoke,\n \t.destroy\t= keyring_destroy,\n \t.describe\t= keyring_describe,\n@@ -511,6 +510,15 @@ struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n }\n EXPORT_SYMBOL(keyring_alloc);\n \n+/*\n+ * By default, we keys found by getting an exact match on their descriptions.\n+ */\n+int key_default_cmp(const struct key *key,\n+\t\t    const struct key_match_data *match_data)\n+{\n+\treturn strcmp(key->description, match_data->raw_data) == 0;\n+}\n+\n /*\n  * Iteration function to consider each key found.\n  */\n@@ -884,17 +892,14 @@ key_ref_t keyring_search(key_ref_t keyring,\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= type->match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n \t};\n \tkey_ref_t key;\n \tint ret;\n \n-\tif (!ctx.match_data.cmp)\n-\t\treturn ERR_PTR(-ENOKEY);\n-\n \tif (type->match_preparse) {\n \t\tret = type->match_preparse(&ctx.match_data);\n \t\tif (ret < 0)""}<_**next**_>{""sha"": ""dc6ed32b7844cfabce17e4fe0e5e309555524b8b"", ""filename"": ""security/keys/request_key.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/request_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -531,7 +531,7 @@ struct key *request_key_and_link(struct key_type *type,\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= type->match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t};""}<_**next**_>{""sha"": ""6639e2cb885322c6a43924496b2a68be25b9a5e6"", ""filename"": ""security/keys/request_key_auth.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key_auth.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key_auth.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/request_key_auth.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -246,7 +246,7 @@ struct key *key_get_instantiation_authkey(key_serial_t target_id)\n \t\t.index_key.type\t\t= &key_type_request_key_auth,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= user_match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t};""}<_**next**_>{""sha"": ""c0594cb07adab14f1efeb970a8c0dd85d86a7931"", ""filename"": ""security/keys/trusted.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/trusted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/trusted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/trusted.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -1096,7 +1096,6 @@ struct key_type key_type_trusted = {\n \t.name = \""trusted\"",\n \t.instantiate = trusted_instantiate,\n \t.update = trusted_update,\n-\t.match = user_match,\n \t.destroy = trusted_destroy,\n \t.describe = user_describe,\n \t.read = trusted_read,""}<_**next**_>{""sha"": ""36b47bbd3d8cc277de55e0c0cdd722618ca13231"", ""filename"": ""security/keys/user_defined.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 12, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/user_defined.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/user_defined.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/user_defined.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -30,7 +30,6 @@ struct key_type key_type_user = {\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n \t.update\t\t\t= user_update,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,\n@@ -51,7 +50,6 @@ struct key_type key_type_logon = {\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n \t.update\t\t\t= user_update,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,\n@@ -136,16 +134,6 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n EXPORT_SYMBOL_GPL(user_update);\n \n-/*\n- * match users on their name\n- */\n-int user_match(const struct key *key, const struct key_match_data *match_data)\n-{\n-\treturn strcmp(key->description, match_data->raw_data) == 0;\n-}\n-\n-EXPORT_SYMBOL_GPL(user_match);\n-\n /*\n  * dispose of the links from a revoked keyring\n  * - called with the key sem write-locked""}","struct key *request_key_and_link(struct key_type *type,
				 const char *description,
				 const void *callout_info,
				 size_t callout_len,
				 void *aux,
				 struct key *dest_keyring,
				 unsigned long flags)
{
	struct keyring_search_context ctx = {
 		.index_key.type		= type,
 		.index_key.description	= description,
 		.cred			= current_cred(),
		.match_data.cmp		= key_default_cmp,
 		.match_data.raw_data	= description,
 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
 	};
	struct key *key;
	key_ref_t key_ref;
	int ret;

	kenter(""%s,%s,%p,%zu,%p,%p,%lx"",
	       ctx.index_key.type->name, ctx.index_key.description,
	       callout_info, callout_len, aux, dest_keyring, flags);

	if (type->match_preparse) {
		ret = type->match_preparse(&ctx.match_data);
		if (ret < 0) {
			key = ERR_PTR(ret);
			goto error;
		}
	}

	/* search all the process keyrings for a key */
	key_ref = search_process_keyrings(&ctx);

	if (!IS_ERR(key_ref)) {
		key = key_ref_to_ptr(key_ref);
		if (dest_keyring) {
			construct_get_dest_keyring(&dest_keyring);
			ret = key_link(dest_keyring, key);
			key_put(dest_keyring);
			if (ret < 0) {
				key_put(key);
				key = ERR_PTR(ret);
				goto error_free;
			}
		}
	} else if (PTR_ERR(key_ref) != -EAGAIN) {
		key = ERR_CAST(key_ref);
	} else  {
		/* the search failed, but the keyrings were searchable, so we
		 * should consult userspace if we can */
		key = ERR_PTR(-ENOKEY);
		if (!callout_info)
			goto error_free;

		key = construct_key_and_link(&ctx, callout_info, callout_len,
					     aux, dest_keyring, flags);
	}

error_free:
	if (type->match_free)
		type->match_free(&ctx.match_data);
error:
	kleave("" = %p"", key);
	return key;
}
","struct key *request_key_and_link(struct key_type *type,
				 const char *description,
				 const void *callout_info,
				 size_t callout_len,
				 void *aux,
				 struct key *dest_keyring,
				 unsigned long flags)
{
	struct keyring_search_context ctx = {
 		.index_key.type		= type,
 		.index_key.description	= description,
 		.cred			= current_cred(),
		.match_data.cmp		= type->match,
 		.match_data.raw_data	= description,
 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
 	};
	struct key *key;
	key_ref_t key_ref;
	int ret;

	kenter(""%s,%s,%p,%zu,%p,%p,%lx"",
	       ctx.index_key.type->name, ctx.index_key.description,
	       callout_info, callout_len, aux, dest_keyring, flags);

	if (type->match_preparse) {
		ret = type->match_preparse(&ctx.match_data);
		if (ret < 0) {
			key = ERR_PTR(ret);
			goto error;
		}
	}

	/* search all the process keyrings for a key */
	key_ref = search_process_keyrings(&ctx);

	if (!IS_ERR(key_ref)) {
		key = key_ref_to_ptr(key_ref);
		if (dest_keyring) {
			construct_get_dest_keyring(&dest_keyring);
			ret = key_link(dest_keyring, key);
			key_put(dest_keyring);
			if (ret < 0) {
				key_put(key);
				key = ERR_PTR(ret);
				goto error_free;
			}
		}
	} else if (PTR_ERR(key_ref) != -EAGAIN) {
		key = ERR_CAST(key_ref);
	} else  {
		/* the search failed, but the keyrings were searchable, so we
		 * should consult userspace if we can */
		key = ERR_PTR(-ENOKEY);
		if (!callout_info)
			goto error_free;

		key = construct_key_and_link(&ctx, callout_info, callout_len,
					     aux, dest_keyring, flags);
	}

error_free:
	if (type->match_free)
		type->match_free(&ctx.match_data);
error:
	kleave("" = %p"", key);
	return key;
}
",C,"		.match_data.cmp		= key_default_cmp,
","		.match_data.cmp		= type->match,
",,"@@ -531,7 +531,7 @@ struct key *request_key_and_link(struct key_type *type,
 		.index_key.type		= type,
 		.index_key.description	= description,
 		.cred			= current_cred(),
-		.match_data.cmp		= type->match,
+		.match_data.cmp		= key_default_cmp,
 		.match_data.raw_data	= description,
 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
 	};",linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,614d8c39014c185aa0f7254f0a470cc33fc1b284,1,"struct key *request_key_and_link(struct key_type *type,
				 const char *description,
				 const void *callout_info,
				 size_t callout_len,
				 void *aux,
				 struct key *dest_keyring,
				 unsigned long flags)
{
	struct keyring_search_context ctx = {
 		.index_key.type		= type,
 		.index_key.description	= description,
 		.cred			= current_cred(),
//flaw_line_below:
		.match_data.cmp		= type->match,
//fix_flaw_line_below:
//		.match_data.cmp		= key_default_cmp,
 		.match_data.raw_data	= description,
 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
 	};
	struct key *key;
	key_ref_t key_ref;
	int ret;

	kenter(""%s,%s,%p,%zu,%p,%p,%lx"",
	       ctx.index_key.type->name, ctx.index_key.description,
	       callout_info, callout_len, aux, dest_keyring, flags);

	if (type->match_preparse) {
		ret = type->match_preparse(&ctx.match_data);
		if (ret < 0) {
			key = ERR_PTR(ret);
			goto error;
		}
	}

	/* search all the process keyrings for a key */
	key_ref = search_process_keyrings(&ctx);

	if (!IS_ERR(key_ref)) {
		key = key_ref_to_ptr(key_ref);
		if (dest_keyring) {
			construct_get_dest_keyring(&dest_keyring);
			ret = key_link(dest_keyring, key);
			key_put(dest_keyring);
			if (ret < 0) {
				key_put(key);
				key = ERR_PTR(ret);
				goto error_free;
			}
		}
	} else if (PTR_ERR(key_ref) != -EAGAIN) {
		key = ERR_CAST(key_ref);
	} else  {
		/* the search failed, but the keyrings were searchable, so we
		 * should consult userspace if we can */
		key = ERR_PTR(-ENOKEY);
		if (!callout_info)
			goto error_free;

		key = construct_key_and_link(&ctx, callout_info, callout_len,
					     aux, dest_keyring, flags);
	}

error_free:
	if (type->match_free)
		type->match_free(&ctx.match_data);
error:
	kleave("" = %p"", key);
	return key;
}
"
3878,181614,,Local,Not required,Complete,CVE-2017-2647,https://www.cvedetails.com/cve/CVE-2017-2647/,CWE-476,Low,Complete,Complete,,2017-03-31,7.2,"The KEYS subsystem in the Linux kernel before 3.18 allows local users to gain privileges or cause a denial of service (NULL pointer dereference and system crash) via vectors involving a NULL value for a certain match field, related to the keyring_search_iterator function in keyring.c.",2019-01-15,DoS +Priv ,1,https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"KEYS: Remove key_type::match in favour of overriding default by match_preparse

A previous patch added a ->match_preparse() method to the key type.  This is
allowed to override the function called by the iteration algorithm.
Therefore, we can just set a default that simply checks for an exact match of
the key description with the original criterion data and allow match_preparse
to override it as needed.

The key_type::match op is then redundant and can be removed, as can the
user_match() function.

Signed-off-by: David Howells <dhowells@redhat.com>
Acked-by: Vivek Goyal <vgoyal@redhat.com>",1,security/keys/request_key_auth.c,"{""sha"": ""7c04989689757da3284da98c0e7b933143b89c1b"", ""filename"": ""crypto/asymmetric_keys/asymmetric_type.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/asymmetric_type.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/asymmetric_type.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/asymmetric_keys/asymmetric_type.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -59,8 +59,8 @@ EXPORT_SYMBOL_GPL(asymmetric_keyid_match);\n  *\t\""id:<id>\""\t- request a key matching the ID\n  *\t\""<subtype>:<id>\"" - request a key of a subtype\n  */\n-static int asymmetric_key_match(const struct key *key,\n-\t\t\t\tconst struct key_match_data *match_data)\n+static int asymmetric_key_cmp(const struct key *key,\n+\t\t\t      const struct key_match_data *match_data)\n {\n \tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n \tconst char *description = match_data->raw_data;\n@@ -110,6 +110,7 @@ static int asymmetric_key_match(const struct key *key,\n static int asymmetric_key_match_preparse(struct key_match_data *match_data)\n {\n \tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n+\tmatch_data->cmp = asymmetric_key_cmp;\n \treturn 0;\n }\n \n@@ -224,7 +225,6 @@ struct key_type key_type_asymmetric = {\n \t.free_preparse\t= asymmetric_key_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n \t.match_preparse\t= asymmetric_key_match_preparse,\n-\t.match\t\t= asymmetric_key_match,\n \t.match_free\t= asymmetric_key_match_free,\n \t.destroy\t= asymmetric_key_destroy,\n \t.describe\t= asymmetric_key_describe,""}<_**next**_>{""sha"": ""751f8fd7335db2203f7257edc8ad680dc7ea2a14"", ""filename"": ""crypto/asymmetric_keys/pkcs7_key_type.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/pkcs7_key_type.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/pkcs7_key_type.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/asymmetric_keys/pkcs7_key_type.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -75,7 +75,6 @@ static struct key_type key_type_pkcs7 = {\n \t.preparse\t\t= pkcs7_preparse,\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,""}<_**next**_>{""sha"": ""f4cf200b3c76714ca5a059b1ecdcca6f2e77b338"", ""filename"": ""fs/cifs/cifs_spnego.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifs_spnego.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifs_spnego.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/cifs_spnego.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -62,7 +62,6 @@ cifs_spnego_key_destroy(struct key *key)\n struct key_type cifs_spnego_key_type = {\n \t.name\t\t= \""cifs.spnego\"",\n \t.instantiate\t= cifs_spnego_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= cifs_spnego_key_destroy,\n \t.describe\t= user_describe,\n };""}<_**next**_>{""sha"": ""6d00c419cbae0b54016ba997f55baf1ac7c54956"", ""filename"": ""fs/cifs/cifsacl.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifsacl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifsacl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/cifsacl.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -84,7 +84,6 @@ static struct key_type cifs_idmap_key_type = {\n \t.instantiate = cifs_idmap_key_instantiate,\n \t.destroy     = cifs_idmap_key_destroy,\n \t.describe    = user_describe,\n-\t.match       = user_match,\n };\n \n static char *""}<_**next**_>{""sha"": ""2f5db844c172534a229d86b011be1f6ec2c29aff"", ""filename"": ""fs/nfs/idmap.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/nfs/idmap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/nfs/idmap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfs/idmap.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -177,7 +177,6 @@ static struct key_type key_type_id_resolver = {\n \t.preparse\t= user_preparse,\n \t.free_preparse\t= user_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= user_describe,\n@@ -401,7 +400,6 @@ static struct key_type key_type_id_resolver_legacy = {\n \t.preparse\t= user_preparse,\n \t.free_preparse\t= user_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= user_describe,""}<_**next**_>{""sha"": ""cebefb069c44a51bed96e7fc671f0e839bf94d6a"", ""filename"": ""include/keys/user-type.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/keys/user-type.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/keys/user-type.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/keys/user-type.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -36,13 +36,10 @@ extern struct key_type key_type_user;\n extern struct key_type key_type_logon;\n \n struct key_preparsed_payload;\n-struct key_match_data;\n \n extern int user_preparse(struct key_preparsed_payload *prep);\n extern void user_free_preparse(struct key_preparsed_payload *prep);\n extern int user_update(struct key *key, struct key_preparsed_payload *prep);\n-extern int user_match(const struct key *key,\n-\t\t      const struct key_match_data *match_data);\n extern void user_revoke(struct key *key);\n extern void user_destroy(struct key *key);\n extern void user_describe(const struct key *user, struct seq_file *m);""}<_**next**_>{""sha"": ""c14816bd3b44f14db29787ec90bc3da5ef4a83f9"", ""filename"": ""include/linux/key-type.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/linux/key-type.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/linux/key-type.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/key-type.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -113,10 +113,6 @@ struct key_type {\n \t */\n \tint (*match_preparse)(struct key_match_data *match_data);\n \n-\t/* match a key against a description */\n-\tint (*match)(const struct key *key,\n-\t\t     const struct key_match_data *match_data);\n-\n \t/* Free preparsed match data (optional).  This should be supplied it\n \t * ->match_preparse() is supplied. */\n \tvoid (*match_free)(struct key_match_data *match_data);""}<_**next**_>{""sha"": ""62fc5e7a9acf7506eba2de7ae314ba6067870ceb"", ""filename"": ""net/ceph/crypto.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/ceph/crypto.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/ceph/crypto.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ceph/crypto.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -476,7 +476,6 @@ struct key_type key_type_ceph = {\n \t.preparse\t= ceph_key_preparse,\n \t.free_preparse\t= ceph_key_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= ceph_key_destroy,\n };\n ""}<_**next**_>{""sha"": ""a07b9ba7e0b7bfaa351dc90750c3ca2590b816eb"", ""filename"": ""net/dns_resolver/dns_key.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 4, ""changes"": 17, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/dns_resolver/dns_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/dns_resolver/dns_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/dns_resolver/dns_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -176,9 +176,8 @@ static void dns_resolver_free_preparse(struct key_preparsed_payload *prep)\n  * The domain name may be a simple name or an absolute domain name (which\n  * should end with a period).  The domain name is case-independent.\n  */\n-static int\n-dns_resolver_match(const struct key *key,\n-\t\t   const struct key_match_data *match_data)\n+static int dns_resolver_cmp(const struct key *key,\n+\t\t\t    const struct key_match_data *match_data)\n {\n \tint slen, dlen, ret = 0;\n \tconst char *src = key->description, *dsp = match_data->raw_data;\n@@ -209,6 +208,16 @@ dns_resolver_match(const struct key *key,\n \treturn ret;\n }\n \n+/*\n+ * Preparse the match criterion.\n+ */\n+static int dns_resolver_match_preparse(struct key_match_data *match_data)\n+{\n+\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n+\tmatch_data->cmp = dns_resolver_cmp;\n+\treturn 0;\n+}\n+\n /*\n  * Describe a DNS key\n  */\n@@ -243,7 +252,7 @@ struct key_type key_type_dns_resolver = {\n \t.preparse\t= dns_resolver_preparse,\n \t.free_preparse\t= dns_resolver_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= dns_resolver_match,\n+\t.match_preparse\t= dns_resolver_match_preparse,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= dns_resolver_describe,""}<_**next**_>{""sha"": ""10c6cb694b4343913498a95a2f982ac11d4a1828"", ""filename"": ""net/rxrpc/ar-key.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/rxrpc/ar-key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/rxrpc/ar-key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/rxrpc/ar-key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -44,7 +44,6 @@ struct key_type key_type_rxrpc = {\n \t.preparse\t= rxrpc_preparse,\n \t.free_preparse\t= rxrpc_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= rxrpc_destroy,\n \t.describe\t= rxrpc_describe,\n \t.read\t\t= rxrpc_read,\n@@ -61,7 +60,6 @@ struct key_type key_type_rxrpc_s = {\n \t.preparse\t= rxrpc_preparse_s,\n \t.free_preparse\t= rxrpc_free_preparse_s,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= rxrpc_destroy_s,\n \t.describe\t= rxrpc_describe,\n };""}<_**next**_>{""sha"": ""b6adb94f6d52573aecf2e38a16724e06895dded6"", ""filename"": ""security/keys/big_key.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/big_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/big_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/big_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -36,7 +36,6 @@ struct key_type key_type_big_key = {\n \t.preparse\t\t= big_key_preparse,\n \t.free_preparse\t\t= big_key_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= big_key_revoke,\n \t.destroy\t\t= big_key_destroy,\n \t.describe\t\t= big_key_describe,""}<_**next**_>{""sha"": ""db9675db10262021612016bed79ade14a960d089"", ""filename"": ""security/keys/encrypted-keys/encrypted.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/encrypted-keys/encrypted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/encrypted-keys/encrypted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/encrypted-keys/encrypted.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -970,7 +970,6 @@ struct key_type key_type_encrypted = {\n \t.name = \""encrypted\"",\n \t.instantiate = encrypted_instantiate,\n \t.update = encrypted_update,\n-\t.match = user_match,\n \t.destroy = encrypted_destroy,\n \t.describe = user_describe,\n \t.read = encrypted_read,""}<_**next**_>{""sha"": ""e66a16cb63e1ca223e71d7b3b66ca5c0f19180ea"", ""filename"": ""security/keys/internal.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/internal.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -127,6 +127,8 @@ struct keyring_search_context {\n \tstruct timespec\t\tnow;\n };\n \n+extern int key_default_cmp(const struct key *key,\n+\t\t\t   const struct key_match_data *match_data);\n extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,\n \t\t\t\t    struct keyring_search_context *ctx);\n ""}<_**next**_>{""sha"": ""8c0092ca04430b65b6a0969b5ed3e090038ed2b2"", ""filename"": ""security/keys/key.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -799,7 +799,7 @@ key_ref_t key_create_or_update(key_ref_t keyring_ref,\n \t}\n \n \tkey_ref = ERR_PTR(-EINVAL);\n-\tif (!index_key.type->match || !index_key.type->instantiate ||\n+\tif (!index_key.type->instantiate ||\n \t    (!index_key.description && !index_key.type->preparse))\n \t\tgoto error_put_type;\n ""}<_**next**_>{""sha"": ""253c9a0eb092e2add086d5da72f0811e11007534"", ""filename"": ""security/keys/keyring.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 5, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/keyring.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/keyring.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/keyring.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -89,7 +89,6 @@ struct key_type key_type_keyring = {\n \t.preparse\t= keyring_preparse,\n \t.free_preparse\t= keyring_free_preparse,\n \t.instantiate\t= keyring_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= keyring_revoke,\n \t.destroy\t= keyring_destroy,\n \t.describe\t= keyring_describe,\n@@ -511,6 +510,15 @@ struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n }\n EXPORT_SYMBOL(keyring_alloc);\n \n+/*\n+ * By default, we keys found by getting an exact match on their descriptions.\n+ */\n+int key_default_cmp(const struct key *key,\n+\t\t    const struct key_match_data *match_data)\n+{\n+\treturn strcmp(key->description, match_data->raw_data) == 0;\n+}\n+\n /*\n  * Iteration function to consider each key found.\n  */\n@@ -884,17 +892,14 @@ key_ref_t keyring_search(key_ref_t keyring,\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= type->match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n \t};\n \tkey_ref_t key;\n \tint ret;\n \n-\tif (!ctx.match_data.cmp)\n-\t\treturn ERR_PTR(-ENOKEY);\n-\n \tif (type->match_preparse) {\n \t\tret = type->match_preparse(&ctx.match_data);\n \t\tif (ret < 0)""}<_**next**_>{""sha"": ""dc6ed32b7844cfabce17e4fe0e5e309555524b8b"", ""filename"": ""security/keys/request_key.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/request_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -531,7 +531,7 @@ struct key *request_key_and_link(struct key_type *type,\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= type->match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t};""}<_**next**_>{""sha"": ""6639e2cb885322c6a43924496b2a68be25b9a5e6"", ""filename"": ""security/keys/request_key_auth.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key_auth.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key_auth.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/request_key_auth.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -246,7 +246,7 @@ struct key *key_get_instantiation_authkey(key_serial_t target_id)\n \t\t.index_key.type\t\t= &key_type_request_key_auth,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= user_match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t};""}<_**next**_>{""sha"": ""c0594cb07adab14f1efeb970a8c0dd85d86a7931"", ""filename"": ""security/keys/trusted.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/trusted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/trusted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/trusted.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -1096,7 +1096,6 @@ struct key_type key_type_trusted = {\n \t.name = \""trusted\"",\n \t.instantiate = trusted_instantiate,\n \t.update = trusted_update,\n-\t.match = user_match,\n \t.destroy = trusted_destroy,\n \t.describe = user_describe,\n \t.read = trusted_read,""}<_**next**_>{""sha"": ""36b47bbd3d8cc277de55e0c0cdd722618ca13231"", ""filename"": ""security/keys/user_defined.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 12, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/user_defined.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/user_defined.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/user_defined.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -30,7 +30,6 @@ struct key_type key_type_user = {\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n \t.update\t\t\t= user_update,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,\n@@ -51,7 +50,6 @@ struct key_type key_type_logon = {\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n \t.update\t\t\t= user_update,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,\n@@ -136,16 +134,6 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n EXPORT_SYMBOL_GPL(user_update);\n \n-/*\n- * match users on their name\n- */\n-int user_match(const struct key *key, const struct key_match_data *match_data)\n-{\n-\treturn strcmp(key->description, match_data->raw_data) == 0;\n-}\n-\n-EXPORT_SYMBOL_GPL(user_match);\n-\n /*\n  * dispose of the links from a revoked keyring\n  * - called with the key sem write-locked""}","struct key *key_get_instantiation_authkey(key_serial_t target_id)
{
	char description[16];
	struct keyring_search_context ctx = {
 		.index_key.type		= &key_type_request_key_auth,
 		.index_key.description	= description,
 		.cred			= current_cred(),
		.match_data.cmp		= key_default_cmp,
 		.match_data.raw_data	= description,
 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
 	};
	struct key *authkey;
	key_ref_t authkey_ref;

	sprintf(description, ""%x"", target_id);

	authkey_ref = search_process_keyrings(&ctx);

	if (IS_ERR(authkey_ref)) {
		authkey = ERR_CAST(authkey_ref);
		if (authkey == ERR_PTR(-EAGAIN))
			authkey = ERR_PTR(-ENOKEY);
		goto error;
	}

	authkey = key_ref_to_ptr(authkey_ref);
	if (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {
		key_put(authkey);
		authkey = ERR_PTR(-EKEYREVOKED);
	}

error:
	return authkey;
}
","struct key *key_get_instantiation_authkey(key_serial_t target_id)
{
	char description[16];
	struct keyring_search_context ctx = {
 		.index_key.type		= &key_type_request_key_auth,
 		.index_key.description	= description,
 		.cred			= current_cred(),
		.match_data.cmp		= user_match,
 		.match_data.raw_data	= description,
 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
 	};
	struct key *authkey;
	key_ref_t authkey_ref;

	sprintf(description, ""%x"", target_id);

	authkey_ref = search_process_keyrings(&ctx);

	if (IS_ERR(authkey_ref)) {
		authkey = ERR_CAST(authkey_ref);
		if (authkey == ERR_PTR(-EAGAIN))
			authkey = ERR_PTR(-ENOKEY);
		goto error;
	}

	authkey = key_ref_to_ptr(authkey_ref);
	if (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {
		key_put(authkey);
		authkey = ERR_PTR(-EKEYREVOKED);
	}

error:
	return authkey;
}
",C,"		.match_data.cmp		= key_default_cmp,
","		.match_data.cmp		= user_match,
",,"@@ -246,7 +246,7 @@ struct key *key_get_instantiation_authkey(key_serial_t target_id)
 		.index_key.type		= &key_type_request_key_auth,
 		.index_key.description	= description,
 		.cred			= current_cred(),
-		.match_data.cmp		= user_match,
+		.match_data.cmp		= key_default_cmp,
 		.match_data.raw_data	= description,
 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
 	};",linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,614d8c39014c185aa0f7254f0a470cc33fc1b284,1,"struct key *key_get_instantiation_authkey(key_serial_t target_id)
{
	char description[16];
	struct keyring_search_context ctx = {
 		.index_key.type		= &key_type_request_key_auth,
 		.index_key.description	= description,
 		.cred			= current_cred(),
//flaw_line_below:
		.match_data.cmp		= user_match,
//fix_flaw_line_below:
//		.match_data.cmp		= key_default_cmp,
 		.match_data.raw_data	= description,
 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
 	};
	struct key *authkey;
	key_ref_t authkey_ref;

	sprintf(description, ""%x"", target_id);

	authkey_ref = search_process_keyrings(&ctx);

	if (IS_ERR(authkey_ref)) {
		authkey = ERR_CAST(authkey_ref);
		if (authkey == ERR_PTR(-EAGAIN))
			authkey = ERR_PTR(-ENOKEY);
		goto error;
	}

	authkey = key_ref_to_ptr(authkey_ref);
	if (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {
		key_put(authkey);
		authkey = ERR_PTR(-EKEYREVOKED);
	}

error:
	return authkey;
}
"
3879,181615,,Local,Not required,Complete,CVE-2017-2647,https://www.cvedetails.com/cve/CVE-2017-2647/,CWE-476,Low,Complete,Complete,,2017-03-31,7.2,"The KEYS subsystem in the Linux kernel before 3.18 allows local users to gain privileges or cause a denial of service (NULL pointer dereference and system crash) via vectors involving a NULL value for a certain match field, related to the keyring_search_iterator function in keyring.c.",2019-01-15,DoS +Priv ,0,https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,"KEYS: Remove key_type::match in favour of overriding default by match_preparse

A previous patch added a ->match_preparse() method to the key type.  This is
allowed to override the function called by the iteration algorithm.
Therefore, we can just set a default that simply checks for an exact match of
the key description with the original criterion data and allow match_preparse
to override it as needed.

The key_type::match op is then redundant and can be removed, as can the
user_match() function.

Signed-off-by: David Howells <dhowells@redhat.com>
Acked-by: Vivek Goyal <vgoyal@redhat.com>",3,security/keys/user_defined.c,"{""sha"": ""7c04989689757da3284da98c0e7b933143b89c1b"", ""filename"": ""crypto/asymmetric_keys/asymmetric_type.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/asymmetric_type.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/asymmetric_type.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/asymmetric_keys/asymmetric_type.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -59,8 +59,8 @@ EXPORT_SYMBOL_GPL(asymmetric_keyid_match);\n  *\t\""id:<id>\""\t- request a key matching the ID\n  *\t\""<subtype>:<id>\"" - request a key of a subtype\n  */\n-static int asymmetric_key_match(const struct key *key,\n-\t\t\t\tconst struct key_match_data *match_data)\n+static int asymmetric_key_cmp(const struct key *key,\n+\t\t\t      const struct key_match_data *match_data)\n {\n \tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n \tconst char *description = match_data->raw_data;\n@@ -110,6 +110,7 @@ static int asymmetric_key_match(const struct key *key,\n static int asymmetric_key_match_preparse(struct key_match_data *match_data)\n {\n \tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n+\tmatch_data->cmp = asymmetric_key_cmp;\n \treturn 0;\n }\n \n@@ -224,7 +225,6 @@ struct key_type key_type_asymmetric = {\n \t.free_preparse\t= asymmetric_key_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n \t.match_preparse\t= asymmetric_key_match_preparse,\n-\t.match\t\t= asymmetric_key_match,\n \t.match_free\t= asymmetric_key_match_free,\n \t.destroy\t= asymmetric_key_destroy,\n \t.describe\t= asymmetric_key_describe,""}<_**next**_>{""sha"": ""751f8fd7335db2203f7257edc8ad680dc7ea2a14"", ""filename"": ""crypto/asymmetric_keys/pkcs7_key_type.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/pkcs7_key_type.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/crypto/asymmetric_keys/pkcs7_key_type.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/asymmetric_keys/pkcs7_key_type.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -75,7 +75,6 @@ static struct key_type key_type_pkcs7 = {\n \t.preparse\t\t= pkcs7_preparse,\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,""}<_**next**_>{""sha"": ""f4cf200b3c76714ca5a059b1ecdcca6f2e77b338"", ""filename"": ""fs/cifs/cifs_spnego.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifs_spnego.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifs_spnego.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/cifs_spnego.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -62,7 +62,6 @@ cifs_spnego_key_destroy(struct key *key)\n struct key_type cifs_spnego_key_type = {\n \t.name\t\t= \""cifs.spnego\"",\n \t.instantiate\t= cifs_spnego_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= cifs_spnego_key_destroy,\n \t.describe\t= user_describe,\n };""}<_**next**_>{""sha"": ""6d00c419cbae0b54016ba997f55baf1ac7c54956"", ""filename"": ""fs/cifs/cifsacl.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifsacl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/cifs/cifsacl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/cifsacl.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -84,7 +84,6 @@ static struct key_type cifs_idmap_key_type = {\n \t.instantiate = cifs_idmap_key_instantiate,\n \t.destroy     = cifs_idmap_key_destroy,\n \t.describe    = user_describe,\n-\t.match       = user_match,\n };\n \n static char *""}<_**next**_>{""sha"": ""2f5db844c172534a229d86b011be1f6ec2c29aff"", ""filename"": ""fs/nfs/idmap.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/nfs/idmap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/fs/nfs/idmap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfs/idmap.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -177,7 +177,6 @@ static struct key_type key_type_id_resolver = {\n \t.preparse\t= user_preparse,\n \t.free_preparse\t= user_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= user_describe,\n@@ -401,7 +400,6 @@ static struct key_type key_type_id_resolver_legacy = {\n \t.preparse\t= user_preparse,\n \t.free_preparse\t= user_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= user_describe,""}<_**next**_>{""sha"": ""cebefb069c44a51bed96e7fc671f0e839bf94d6a"", ""filename"": ""include/keys/user-type.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/keys/user-type.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/keys/user-type.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/keys/user-type.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -36,13 +36,10 @@ extern struct key_type key_type_user;\n extern struct key_type key_type_logon;\n \n struct key_preparsed_payload;\n-struct key_match_data;\n \n extern int user_preparse(struct key_preparsed_payload *prep);\n extern void user_free_preparse(struct key_preparsed_payload *prep);\n extern int user_update(struct key *key, struct key_preparsed_payload *prep);\n-extern int user_match(const struct key *key,\n-\t\t      const struct key_match_data *match_data);\n extern void user_revoke(struct key *key);\n extern void user_destroy(struct key *key);\n extern void user_describe(const struct key *user, struct seq_file *m);""}<_**next**_>{""sha"": ""c14816bd3b44f14db29787ec90bc3da5ef4a83f9"", ""filename"": ""include/linux/key-type.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/linux/key-type.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/include/linux/key-type.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/key-type.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -113,10 +113,6 @@ struct key_type {\n \t */\n \tint (*match_preparse)(struct key_match_data *match_data);\n \n-\t/* match a key against a description */\n-\tint (*match)(const struct key *key,\n-\t\t     const struct key_match_data *match_data);\n-\n \t/* Free preparsed match data (optional).  This should be supplied it\n \t * ->match_preparse() is supplied. */\n \tvoid (*match_free)(struct key_match_data *match_data);""}<_**next**_>{""sha"": ""62fc5e7a9acf7506eba2de7ae314ba6067870ceb"", ""filename"": ""net/ceph/crypto.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/ceph/crypto.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/ceph/crypto.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ceph/crypto.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -476,7 +476,6 @@ struct key_type key_type_ceph = {\n \t.preparse\t= ceph_key_preparse,\n \t.free_preparse\t= ceph_key_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= ceph_key_destroy,\n };\n ""}<_**next**_>{""sha"": ""a07b9ba7e0b7bfaa351dc90750c3ca2590b816eb"", ""filename"": ""net/dns_resolver/dns_key.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 4, ""changes"": 17, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/dns_resolver/dns_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/dns_resolver/dns_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/dns_resolver/dns_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -176,9 +176,8 @@ static void dns_resolver_free_preparse(struct key_preparsed_payload *prep)\n  * The domain name may be a simple name or an absolute domain name (which\n  * should end with a period).  The domain name is case-independent.\n  */\n-static int\n-dns_resolver_match(const struct key *key,\n-\t\t   const struct key_match_data *match_data)\n+static int dns_resolver_cmp(const struct key *key,\n+\t\t\t    const struct key_match_data *match_data)\n {\n \tint slen, dlen, ret = 0;\n \tconst char *src = key->description, *dsp = match_data->raw_data;\n@@ -209,6 +208,16 @@ dns_resolver_match(const struct key *key,\n \treturn ret;\n }\n \n+/*\n+ * Preparse the match criterion.\n+ */\n+static int dns_resolver_match_preparse(struct key_match_data *match_data)\n+{\n+\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n+\tmatch_data->cmp = dns_resolver_cmp;\n+\treturn 0;\n+}\n+\n /*\n  * Describe a DNS key\n  */\n@@ -243,7 +252,7 @@ struct key_type key_type_dns_resolver = {\n \t.preparse\t= dns_resolver_preparse,\n \t.free_preparse\t= dns_resolver_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= dns_resolver_match,\n+\t.match_preparse\t= dns_resolver_match_preparse,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= dns_resolver_describe,""}<_**next**_>{""sha"": ""10c6cb694b4343913498a95a2f982ac11d4a1828"", ""filename"": ""net/rxrpc/ar-key.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/rxrpc/ar-key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/net/rxrpc/ar-key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/rxrpc/ar-key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -44,7 +44,6 @@ struct key_type key_type_rxrpc = {\n \t.preparse\t= rxrpc_preparse,\n \t.free_preparse\t= rxrpc_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= rxrpc_destroy,\n \t.describe\t= rxrpc_describe,\n \t.read\t\t= rxrpc_read,\n@@ -61,7 +60,6 @@ struct key_type key_type_rxrpc_s = {\n \t.preparse\t= rxrpc_preparse_s,\n \t.free_preparse\t= rxrpc_free_preparse_s,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= rxrpc_destroy_s,\n \t.describe\t= rxrpc_describe,\n };""}<_**next**_>{""sha"": ""b6adb94f6d52573aecf2e38a16724e06895dded6"", ""filename"": ""security/keys/big_key.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/big_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/big_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/big_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -36,7 +36,6 @@ struct key_type key_type_big_key = {\n \t.preparse\t\t= big_key_preparse,\n \t.free_preparse\t\t= big_key_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= big_key_revoke,\n \t.destroy\t\t= big_key_destroy,\n \t.describe\t\t= big_key_describe,""}<_**next**_>{""sha"": ""db9675db10262021612016bed79ade14a960d089"", ""filename"": ""security/keys/encrypted-keys/encrypted.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/encrypted-keys/encrypted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/encrypted-keys/encrypted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/encrypted-keys/encrypted.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -970,7 +970,6 @@ struct key_type key_type_encrypted = {\n \t.name = \""encrypted\"",\n \t.instantiate = encrypted_instantiate,\n \t.update = encrypted_update,\n-\t.match = user_match,\n \t.destroy = encrypted_destroy,\n \t.describe = user_describe,\n \t.read = encrypted_read,""}<_**next**_>{""sha"": ""e66a16cb63e1ca223e71d7b3b66ca5c0f19180ea"", ""filename"": ""security/keys/internal.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/internal.h?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -127,6 +127,8 @@ struct keyring_search_context {\n \tstruct timespec\t\tnow;\n };\n \n+extern int key_default_cmp(const struct key *key,\n+\t\t\t   const struct key_match_data *match_data);\n extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,\n \t\t\t\t    struct keyring_search_context *ctx);\n ""}<_**next**_>{""sha"": ""8c0092ca04430b65b6a0969b5ed3e090038ed2b2"", ""filename"": ""security/keys/key.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -799,7 +799,7 @@ key_ref_t key_create_or_update(key_ref_t keyring_ref,\n \t}\n \n \tkey_ref = ERR_PTR(-EINVAL);\n-\tif (!index_key.type->match || !index_key.type->instantiate ||\n+\tif (!index_key.type->instantiate ||\n \t    (!index_key.description && !index_key.type->preparse))\n \t\tgoto error_put_type;\n ""}<_**next**_>{""sha"": ""253c9a0eb092e2add086d5da72f0811e11007534"", ""filename"": ""security/keys/keyring.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 5, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/keyring.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/keyring.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/keyring.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -89,7 +89,6 @@ struct key_type key_type_keyring = {\n \t.preparse\t= keyring_preparse,\n \t.free_preparse\t= keyring_free_preparse,\n \t.instantiate\t= keyring_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= keyring_revoke,\n \t.destroy\t= keyring_destroy,\n \t.describe\t= keyring_describe,\n@@ -511,6 +510,15 @@ struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n }\n EXPORT_SYMBOL(keyring_alloc);\n \n+/*\n+ * By default, we keys found by getting an exact match on their descriptions.\n+ */\n+int key_default_cmp(const struct key *key,\n+\t\t    const struct key_match_data *match_data)\n+{\n+\treturn strcmp(key->description, match_data->raw_data) == 0;\n+}\n+\n /*\n  * Iteration function to consider each key found.\n  */\n@@ -884,17 +892,14 @@ key_ref_t keyring_search(key_ref_t keyring,\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= type->match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n \t};\n \tkey_ref_t key;\n \tint ret;\n \n-\tif (!ctx.match_data.cmp)\n-\t\treturn ERR_PTR(-ENOKEY);\n-\n \tif (type->match_preparse) {\n \t\tret = type->match_preparse(&ctx.match_data);\n \t\tif (ret < 0)""}<_**next**_>{""sha"": ""dc6ed32b7844cfabce17e4fe0e5e309555524b8b"", ""filename"": ""security/keys/request_key.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/request_key.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -531,7 +531,7 @@ struct key *request_key_and_link(struct key_type *type,\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= type->match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t};""}<_**next**_>{""sha"": ""6639e2cb885322c6a43924496b2a68be25b9a5e6"", ""filename"": ""security/keys/request_key_auth.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key_auth.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/request_key_auth.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/request_key_auth.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -246,7 +246,7 @@ struct key *key_get_instantiation_authkey(key_serial_t target_id)\n \t\t.index_key.type\t\t= &key_type_request_key_auth,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= user_match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t};""}<_**next**_>{""sha"": ""c0594cb07adab14f1efeb970a8c0dd85d86a7931"", ""filename"": ""security/keys/trusted.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/trusted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/trusted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/trusted.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -1096,7 +1096,6 @@ struct key_type key_type_trusted = {\n \t.name = \""trusted\"",\n \t.instantiate = trusted_instantiate,\n \t.update = trusted_update,\n-\t.match = user_match,\n \t.destroy = trusted_destroy,\n \t.describe = user_describe,\n \t.read = trusted_read,""}<_**next**_>{""sha"": ""36b47bbd3d8cc277de55e0c0cdd722618ca13231"", ""filename"": ""security/keys/user_defined.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 12, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/user_defined.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81/security/keys/user_defined.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/user_defined.c?ref=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"", ""patch"": ""@@ -30,7 +30,6 @@ struct key_type key_type_user = {\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n \t.update\t\t\t= user_update,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,\n@@ -51,7 +50,6 @@ struct key_type key_type_logon = {\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n \t.update\t\t\t= user_update,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,\n@@ -136,16 +134,6 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n EXPORT_SYMBOL_GPL(user_update);\n \n-/*\n- * match users on their name\n- */\n-int user_match(const struct key *key, const struct key_match_data *match_data)\n-{\n-\treturn strcmp(key->description, match_data->raw_data) == 0;\n-}\n-\n-EXPORT_SYMBOL_GPL(user_match);\n-\n /*\n  * dispose of the links from a revoked keyring\n  * - called with the key sem write-locked""}","int user_match(const struct key *key, const struct key_match_data *match_data)
","int user_match(const struct key *key, const struct key_match_data *match_data)
{
	return strcmp(key->description, match_data->raw_data) == 0;
}
",C,,"{
	return strcmp(key->description, match_data->raw_data) == 0;
}
",,"@@ -30,7 +30,6 @@ struct key_type key_type_user = {
 	.free_preparse		= user_free_preparse,
 	.instantiate		= generic_key_instantiate,
 	.update			= user_update,
-	.match			= user_match,
 	.revoke			= user_revoke,
 	.destroy		= user_destroy,
 	.describe		= user_describe,
@@ -51,7 +50,6 @@ struct key_type key_type_logon = {
 	.free_preparse		= user_free_preparse,
 	.instantiate		= generic_key_instantiate,
 	.update			= user_update,
-	.match			= user_match,
 	.revoke			= user_revoke,
 	.destroy		= user_destroy,
 	.describe		= user_describe,
@@ -136,16 +134,6 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)
 
 EXPORT_SYMBOL_GPL(user_update);
 
-/*
- * match users on their name
- */
-int user_match(const struct key *key, const struct key_match_data *match_data)
-{
-	return strcmp(key->description, match_data->raw_data) == 0;
-}
-
-EXPORT_SYMBOL_GPL(user_match);
-
 /*
  * dispose of the links from a revoked keyring
  * - called with the key sem write-locked",linux,c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,614d8c39014c185aa0f7254f0a470cc33fc1b284,1,"int user_match(const struct key *key, const struct key_match_data *match_data)
//flaw_line_below:
{
//flaw_line_below:
	return strcmp(key->description, match_data->raw_data) == 0;
//flaw_line_below:
}
"
3908,181644,,Remote,Not required,Partial,CVE-2016-10250,https://www.cvedetails.com/cve/CVE-2016-10250/,CWE-476,Low,,,,2017-03-15,5.0,The jp2_colr_destroy function in jp2_cod.c in JasPer before 1.900.13 allows remote attackers to cause a denial of service (NULL pointer dereference) by leveraging incorrect cleanup of JP2 box data on error. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8887.,2018-06-28,DoS ,2,https://github.com/mdadams/jasper/commit/bdfe95a6e81ffb4b2fad31a76b57943695beed20,bdfe95a6e81ffb4b2fad31a76b57943695beed20,Fixed another problem with incorrect cleanup of JP2 box data upon error.,2,src/libjasper/jp2/jp2_cod.c,"{""sha"": ""7f3608ab8de79f357605dbfe6bb3ce18fa8c3c4c"", ""filename"": ""src/libjasper/jp2/jp2_cod.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 6, ""changes"": 16, ""blob_url"": ""https://github.com/mdadams/jasper/blob/bdfe95a6e81ffb4b2fad31a76b57943695beed20/src/libjasper/jp2/jp2_cod.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/bdfe95a6e81ffb4b2fad31a76b57943695beed20/src/libjasper/jp2/jp2_cod.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/jp2/jp2_cod.c?ref=bdfe95a6e81ffb4b2fad31a76b57943695beed20"", ""patch"": ""@@ -251,13 +251,16 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n \t\tgoto error;\n \t}\n+\n+\t// Mark the box data as never having been constructed\n+\t// so that we will not errantly attempt to destroy it later.\n \tbox->ops = &jp2_boxinfo_unk.ops;\n+\n \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n \t\tgoto error;\n \t}\n \tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n-\tbox->ops = &boxinfo->ops;\n \tbox->len = len;\n \tJAS_DBGLOG(10, (\n \t  \""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\"",\n@@ -287,14 +290,15 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \t\t\tgoto error;\n \t\t}\n \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n-\t\t\t// Mark the box data as never having been constructed\n-\t\t\t// so that we will not errantly attempt to destroy it later.\n-\t\t\tbox->ops = &jp2_boxinfo_unk.ops;\n \t\t\tjas_eprintf(\""cannot copy box data\\n\"");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_rewind(tmpstream);\n \n+\t\t// From here onwards, the box data will need to be destroyed.\n+\t\t// So, initialize the box operations.\n+\t\tbox->ops = &boxinfo->ops;\n+\n \t\tif (box->ops->getdata) {\n \t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n \t\t\t\tjas_eprintf(\""cannot parse box data\\n\"");\n@@ -327,8 +331,8 @@ void jp2_box_dump(jp2_box_t *box, FILE *out)\n \tassert(boxinfo);\n \n \tfprintf(out, \""JP2 box: \"");\n-\tfprintf(out, \""type=%c%s%c (0x%08\""PRIxFAST32\""); length=%\""PRIuFAST32\""\\n\"", '\""', boxinfo->name,\n-\t  '\""', box->type, box->len);\n+\tfprintf(out, \""type=%c%s%c (0x%08\""PRIxFAST32\""); length=%\""PRIuFAST32\""\\n\"", '\""',\n+\t  boxinfo->name, '\""', box->type, box->len);\n \tif (box->ops->dumpdata) {\n \t\t(*box->ops->dumpdata)(box, out);\n \t}""}","void jp2_box_dump(jp2_box_t *box, FILE *out)
{
	jp2_boxinfo_t *boxinfo;
	boxinfo = jp2_boxinfolookup(box->type);
 	assert(boxinfo);
 
 	fprintf(out, ""JP2 box: "");
	fprintf(out, ""type=%c%s%c (0x%08""PRIxFAST32""); length=%""PRIuFAST32""\n"", '""',
	  boxinfo->name, '""', box->type, box->len);
 	if (box->ops->dumpdata) {
 		(*box->ops->dumpdata)(box, out);
 	}
}
","void jp2_box_dump(jp2_box_t *box, FILE *out)
{
	jp2_boxinfo_t *boxinfo;
	boxinfo = jp2_boxinfolookup(box->type);
 	assert(boxinfo);
 
 	fprintf(out, ""JP2 box: "");
	fprintf(out, ""type=%c%s%c (0x%08""PRIxFAST32""); length=%""PRIuFAST32""\n"", '""', boxinfo->name,
	  '""', box->type, box->len);
 	if (box->ops->dumpdata) {
 		(*box->ops->dumpdata)(box, out);
 	}
}
",C,"	fprintf(out, ""type=%c%s%c (0x%08""PRIxFAST32""); length=%""PRIuFAST32""\n"", '""',
	  boxinfo->name, '""', box->type, box->len);
","	fprintf(out, ""type=%c%s%c (0x%08""PRIxFAST32""); length=%""PRIuFAST32""\n"", '""', boxinfo->name,
	  '""', box->type, box->len);
",,"@@ -251,13 +251,16 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)
 	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
 		goto error;
 	}
+
+	// Mark the box data as never having been constructed
+	// so that we will not errantly attempt to destroy it later.
 	box->ops = &jp2_boxinfo_unk.ops;
+
 	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
 		goto error;
 	}
 	boxinfo = jp2_boxinfolookup(box->type);
 	box->info = boxinfo;
-	box->ops = &boxinfo->ops;
 	box->len = len;
 	JAS_DBGLOG(10, (
 	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
@@ -287,14 +290,15 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)
 			goto error;
 		}
 		if (jas_stream_copy(tmpstream, in, box->datalen)) {
-			// Mark the box data as never having been constructed
-			// so that we will not errantly attempt to destroy it later.
-			box->ops = &jp2_boxinfo_unk.ops;
 			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}
 		jas_stream_rewind(tmpstream);
 
+		// From here onwards, the box data will need to be destroyed.
+		// So, initialize the box operations.
+		box->ops = &boxinfo->ops;
+
 		if (box->ops->getdata) {
 			if ((*box->ops->getdata)(box, tmpstream)) {
 				jas_eprintf(""cannot parse box data\n"");
@@ -327,8 +331,8 @@ void jp2_box_dump(jp2_box_t *box, FILE *out)
 	assert(boxinfo);
 
 	fprintf(out, ""JP2 box: "");
-	fprintf(out, ""type=%c%s%c (0x%08""PRIxFAST32""); length=%""PRIuFAST32""\n"", '""', boxinfo->name,
-	  '""', box->type, box->len);
+	fprintf(out, ""type=%c%s%c (0x%08""PRIxFAST32""); length=%""PRIuFAST32""\n"", '""',
+	  boxinfo->name, '""', box->type, box->len);
 	if (box->ops->dumpdata) {
 		(*box->ops->dumpdata)(box, out);
 	}",jasper,bdfe95a6e81ffb4b2fad31a76b57943695beed20,d91198abd00fc435a397fe6bad906a4c1748e9cf,1,"void jp2_box_dump(jp2_box_t *box, FILE *out)
{
	jp2_boxinfo_t *boxinfo;
	boxinfo = jp2_boxinfolookup(box->type);
 	assert(boxinfo);
 
 	fprintf(out, ""JP2 box: "");
//flaw_line_below:
	fprintf(out, ""type=%c%s%c (0x%08""PRIxFAST32""); length=%""PRIuFAST32""\n"", '""', boxinfo->name,
//flaw_line_below:
	  '""', box->type, box->len);
//fix_flaw_line_below:
//	fprintf(out, ""type=%c%s%c (0x%08""PRIxFAST32""); length=%""PRIuFAST32""\n"", '""',
//fix_flaw_line_below:
//	  boxinfo->name, '""', box->type, box->len);
 	if (box->ops->dumpdata) {
 		(*box->ops->dumpdata)(box, out);
 	}
}
"
3909,181645,,Remote,Not required,Partial,CVE-2016-10250,https://www.cvedetails.com/cve/CVE-2016-10250/,CWE-476,Low,,,,2017-03-15,5.0,The jp2_colr_destroy function in jp2_cod.c in JasPer before 1.900.13 allows remote attackers to cause a denial of service (NULL pointer dereference) by leveraging incorrect cleanup of JP2 box data on error. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8887.,2018-06-28,DoS ,8,https://github.com/mdadams/jasper/commit/bdfe95a6e81ffb4b2fad31a76b57943695beed20,bdfe95a6e81ffb4b2fad31a76b57943695beed20,Fixed another problem with incorrect cleanup of JP2 box data upon error.,2,src/libjasper/jp2/jp2_cod.c,"{""sha"": ""7f3608ab8de79f357605dbfe6bb3ce18fa8c3c4c"", ""filename"": ""src/libjasper/jp2/jp2_cod.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 6, ""changes"": 16, ""blob_url"": ""https://github.com/mdadams/jasper/blob/bdfe95a6e81ffb4b2fad31a76b57943695beed20/src/libjasper/jp2/jp2_cod.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/bdfe95a6e81ffb4b2fad31a76b57943695beed20/src/libjasper/jp2/jp2_cod.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/jp2/jp2_cod.c?ref=bdfe95a6e81ffb4b2fad31a76b57943695beed20"", ""patch"": ""@@ -251,13 +251,16 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n \t\tgoto error;\n \t}\n+\n+\t// Mark the box data as never having been constructed\n+\t// so that we will not errantly attempt to destroy it later.\n \tbox->ops = &jp2_boxinfo_unk.ops;\n+\n \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n \t\tgoto error;\n \t}\n \tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n-\tbox->ops = &boxinfo->ops;\n \tbox->len = len;\n \tJAS_DBGLOG(10, (\n \t  \""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\"",\n@@ -287,14 +290,15 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \t\t\tgoto error;\n \t\t}\n \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n-\t\t\t// Mark the box data as never having been constructed\n-\t\t\t// so that we will not errantly attempt to destroy it later.\n-\t\t\tbox->ops = &jp2_boxinfo_unk.ops;\n \t\t\tjas_eprintf(\""cannot copy box data\\n\"");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_rewind(tmpstream);\n \n+\t\t// From here onwards, the box data will need to be destroyed.\n+\t\t// So, initialize the box operations.\n+\t\tbox->ops = &boxinfo->ops;\n+\n \t\tif (box->ops->getdata) {\n \t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n \t\t\t\tjas_eprintf(\""cannot parse box data\\n\"");\n@@ -327,8 +331,8 @@ void jp2_box_dump(jp2_box_t *box, FILE *out)\n \tassert(boxinfo);\n \n \tfprintf(out, \""JP2 box: \"");\n-\tfprintf(out, \""type=%c%s%c (0x%08\""PRIxFAST32\""); length=%\""PRIuFAST32\""\\n\"", '\""', boxinfo->name,\n-\t  '\""', box->type, box->len);\n+\tfprintf(out, \""type=%c%s%c (0x%08\""PRIxFAST32\""); length=%\""PRIuFAST32\""\\n\"", '\""',\n+\t  boxinfo->name, '\""', box->type, box->len);\n \tif (box->ops->dumpdata) {\n \t\t(*box->ops->dumpdata)(box, out);\n \t}""}","jp2_box_t *jp2_box_get(jas_stream_t *in)
{
	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;
	jas_stream_t *tmpstream;
	uint_fast32_t len;
	uint_fast64_t extlen;
	bool dataflag;

	box = 0;
	tmpstream = 0;

 	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
 		goto error;
 	}

	// Mark the box data as never having been constructed
	// so that we will not errantly attempt to destroy it later.
 	box->ops = &jp2_boxinfo_unk.ops;

 	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
 		goto error;
 	}
 	boxinfo = jp2_boxinfolookup(box->type);
 	box->info = boxinfo;
 	box->len = len;
 	JAS_DBGLOG(10, (
 	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
	  '""', boxinfo->name, '""', box->type, box->len
	  ));
	if (box->len == 1) {
		if (jp2_getuint64(in, &extlen)) {
			goto error;
		}
		if (extlen > 0xffffffffUL) {
			jas_eprintf(""warning: cannot handle large 64-bit box length\n"");
			extlen = 0xffffffffUL;
		}
		box->len = extlen;
		box->datalen = extlen - JP2_BOX_HDRLEN(true);
	} else {
		box->datalen = box->len - JP2_BOX_HDRLEN(false);
	}
	if (box->len != 0 && box->len < 8) {
		goto error;
	}

	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));

	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
 			goto error;
 		}
 		if (jas_stream_copy(tmpstream, in, box->datalen)) {
 			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}
 		jas_stream_rewind(tmpstream);
 
		// From here onwards, the box data will need to be destroyed.
		// So, initialize the box operations.
		box->ops = &boxinfo->ops;

 		if (box->ops->getdata) {
 			if ((*box->ops->getdata)(box, tmpstream)) {
 				jas_eprintf(""cannot parse box data\n"");
				goto error;
			}
		}
		jas_stream_close(tmpstream);
	}

	if (jas_getdbglevel() >= 1) {
		jp2_box_dump(box, stderr);
	}

	return box;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (tmpstream) {
		jas_stream_close(tmpstream);
	}
	return 0;
}
","jp2_box_t *jp2_box_get(jas_stream_t *in)
{
	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;
	jas_stream_t *tmpstream;
	uint_fast32_t len;
	uint_fast64_t extlen;
	bool dataflag;

	box = 0;
	tmpstream = 0;

 	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
 		goto error;
 	}
 	box->ops = &jp2_boxinfo_unk.ops;
 	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
 		goto error;
 	}
 	boxinfo = jp2_boxinfolookup(box->type);
 	box->info = boxinfo;
	box->ops = &boxinfo->ops;
 	box->len = len;
 	JAS_DBGLOG(10, (
 	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
	  '""', boxinfo->name, '""', box->type, box->len
	  ));
	if (box->len == 1) {
		if (jp2_getuint64(in, &extlen)) {
			goto error;
		}
		if (extlen > 0xffffffffUL) {
			jas_eprintf(""warning: cannot handle large 64-bit box length\n"");
			extlen = 0xffffffffUL;
		}
		box->len = extlen;
		box->datalen = extlen - JP2_BOX_HDRLEN(true);
	} else {
		box->datalen = box->len - JP2_BOX_HDRLEN(false);
	}
	if (box->len != 0 && box->len < 8) {
		goto error;
	}

	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));

	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
 			goto error;
 		}
 		if (jas_stream_copy(tmpstream, in, box->datalen)) {
			box->ops = &jp2_boxinfo_unk.ops;
 			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}
 		jas_stream_rewind(tmpstream);
 
 		if (box->ops->getdata) {
 			if ((*box->ops->getdata)(box, tmpstream)) {
 				jas_eprintf(""cannot parse box data\n"");
				goto error;
			}
		}
		jas_stream_close(tmpstream);
	}

	if (jas_getdbglevel() >= 1) {
		jp2_box_dump(box, stderr);
	}

	return box;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (tmpstream) {
		jas_stream_close(tmpstream);
	}
	return 0;
}
",C,"
	// Mark the box data as never having been constructed
	// so that we will not errantly attempt to destroy it later.

		// From here onwards, the box data will need to be destroyed.
		// So, initialize the box operations.
		box->ops = &boxinfo->ops;

","	box->ops = &boxinfo->ops;
			box->ops = &jp2_boxinfo_unk.ops;
",,"@@ -251,13 +251,16 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)
 	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
 		goto error;
 	}
+
+	// Mark the box data as never having been constructed
+	// so that we will not errantly attempt to destroy it later.
 	box->ops = &jp2_boxinfo_unk.ops;
+
 	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
 		goto error;
 	}
 	boxinfo = jp2_boxinfolookup(box->type);
 	box->info = boxinfo;
-	box->ops = &boxinfo->ops;
 	box->len = len;
 	JAS_DBGLOG(10, (
 	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
@@ -287,14 +290,15 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)
 			goto error;
 		}
 		if (jas_stream_copy(tmpstream, in, box->datalen)) {
-			// Mark the box data as never having been constructed
-			// so that we will not errantly attempt to destroy it later.
-			box->ops = &jp2_boxinfo_unk.ops;
 			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}
 		jas_stream_rewind(tmpstream);
 
+		// From here onwards, the box data will need to be destroyed.
+		// So, initialize the box operations.
+		box->ops = &boxinfo->ops;
+
 		if (box->ops->getdata) {
 			if ((*box->ops->getdata)(box, tmpstream)) {
 				jas_eprintf(""cannot parse box data\n"");
@@ -327,8 +331,8 @@ void jp2_box_dump(jp2_box_t *box, FILE *out)
 	assert(boxinfo);
 
 	fprintf(out, ""JP2 box: "");
-	fprintf(out, ""type=%c%s%c (0x%08""PRIxFAST32""); length=%""PRIuFAST32""\n"", '""', boxinfo->name,
-	  '""', box->type, box->len);
+	fprintf(out, ""type=%c%s%c (0x%08""PRIxFAST32""); length=%""PRIuFAST32""\n"", '""',
+	  boxinfo->name, '""', box->type, box->len);
 	if (box->ops->dumpdata) {
 		(*box->ops->dumpdata)(box, out);
 	}",jasper,bdfe95a6e81ffb4b2fad31a76b57943695beed20,d91198abd00fc435a397fe6bad906a4c1748e9cf,1,"jp2_box_t *jp2_box_get(jas_stream_t *in)
{
	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;
	jas_stream_t *tmpstream;
	uint_fast32_t len;
	uint_fast64_t extlen;
	bool dataflag;

	box = 0;
	tmpstream = 0;

 	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
 		goto error;
 	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	// Mark the box data as never having been constructed
//fix_flaw_line_below:
//	// so that we will not errantly attempt to destroy it later.
 	box->ops = &jp2_boxinfo_unk.ops;
//fix_flaw_line_below:
//
 	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
 		goto error;
 	}
 	boxinfo = jp2_boxinfolookup(box->type);
 	box->info = boxinfo;
//flaw_line_below:
	box->ops = &boxinfo->ops;
 	box->len = len;
 	JAS_DBGLOG(10, (
 	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
	  '""', boxinfo->name, '""', box->type, box->len
	  ));
	if (box->len == 1) {
		if (jp2_getuint64(in, &extlen)) {
			goto error;
		}
		if (extlen > 0xffffffffUL) {
			jas_eprintf(""warning: cannot handle large 64-bit box length\n"");
			extlen = 0xffffffffUL;
		}
		box->len = extlen;
		box->datalen = extlen - JP2_BOX_HDRLEN(true);
	} else {
		box->datalen = box->len - JP2_BOX_HDRLEN(false);
	}
	if (box->len != 0 && box->len < 8) {
		goto error;
	}

	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));

	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
 			goto error;
 		}
 		if (jas_stream_copy(tmpstream, in, box->datalen)) {
//flaw_line_below:
			// Mark the box data as never having been constructed
//flaw_line_below:
			// so that we will not errantly attempt to destroy it later.
//flaw_line_below:
			box->ops = &jp2_boxinfo_unk.ops;
 			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}
 		jas_stream_rewind(tmpstream);
 
//fix_flaw_line_below:
//		// From here onwards, the box data will need to be destroyed.
//fix_flaw_line_below:
//		// So, initialize the box operations.
//fix_flaw_line_below:
//		box->ops = &boxinfo->ops;
//fix_flaw_line_below:
//
 		if (box->ops->getdata) {
 			if ((*box->ops->getdata)(box, tmpstream)) {
 				jas_eprintf(""cannot parse box data\n"");
				goto error;
			}
		}
		jas_stream_close(tmpstream);
	}

	if (jas_getdbglevel() >= 1) {
		jp2_box_dump(box, stderr);
	}

	return box;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (tmpstream) {
		jas_stream_close(tmpstream);
	}
	return 0;
}
"
3913,181649,,Remote,Not required,Partial,CVE-2016-10248,https://www.cvedetails.com/cve/CVE-2016-10248/,CWE-476,Low,,,,2017-03-15,5.0,The jpc_tsfb_synthesize function in jpc_tsfb.c in JasPer before 1.900.9 allows remote attackers to cause a denial of service (NULL pointer dereference) via vectors involving an empty sequence.,2018-06-28,DoS ,8,https://github.com/mdadams/jasper/commit/2e82fa00466ae525339754bb3ab0a0474a31d4bd,2e82fa00466ae525339754bb3ab0a0474a31d4bd,"Fixed an integral type promotion problem by adding a JAS_CAST.
Modified the jpc_tsfb_synthesize function so that it will be a noop for
an empty sequence (in order to avoid dereferencing a null pointer).",1,src/libjasper/jpc/jpc_dec.c,"{""sha"": ""91efc60bbff2351694ec000b41db89beb22be9dc"", ""filename"": ""src/libjasper/include/jasper/jas_math.h"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 0, ""changes"": 18, ""blob_url"": ""https://github.com/mdadams/jasper/blob/2e82fa00466ae525339754bb3ab0a0474a31d4bd/src/libjasper/include/jasper/jas_math.h"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/2e82fa00466ae525339754bb3ab0a0474a31d4bd/src/libjasper/include/jasper/jas_math.h"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/include/jasper/jas_math.h?ref=2e82fa00466ae525339754bb3ab0a0474a31d4bd"", ""patch"": ""@@ -112,6 +112,24 @@ extern \""C\"" {\n #define\tJAS_ONES(n) \\\n   ((1 << (n)) - 1)\n \n+/******************************************************************************\\\n+*\n+\\******************************************************************************/\n+\n+__attribute__((no_sanitize(\""undefined\"")))\n+inline static jas_int_asr(int x, int n)\n+{\n+\tassert(n >= 0);\n+\treturn x >> n;\n+}\n+\n+__attribute__((no_sanitize(\""undefined\"")))\n+inline static jas_int_asl(int x, int n)\n+{\n+\tassert(n >= 0);\n+\treturn x << n;\n+}\n+\n /******************************************************************************\\\n * Safe integer arithmetic (i.e., with overflow checking).\n \\******************************************************************************/""}<_**next**_>{""sha"": ""f470c841ee08d0852dcfb43586471989a5ba664b"", ""filename"": ""src/libjasper/include/jasper/jas_seq.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/mdadams/jasper/blob/2e82fa00466ae525339754bb3ab0a0474a31d4bd/src/libjasper/include/jasper/jas_seq.h"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/2e82fa00466ae525339754bb3ab0a0474a31d4bd/src/libjasper/include/jasper/jas_seq.h"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/include/jasper/jas_seq.h?ref=2e82fa00466ae525339754bb3ab0a0474a31d4bd"", ""patch"": ""@@ -154,6 +154,9 @@ typedef jas_matrix_t jas_seq_t;\n #define jas_matrix_numcols(matrix) \\\n \t((matrix)->numcols_)\n \n+#define jas_matrix_size(matrix) \\\n+\t(jas_matrix_width(matrix) * jas_matrix_height(matrix))\n+\n /* Get a matrix element. */\n #define jas_matrix_get(matrix, i, j) \\\n \t((matrix)->rows_[i][j])\n@@ -269,6 +272,8 @@ jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend);\n \t((s)->xstart_ = (x), (s)->ystart_ = (y), \\\n \t  (s)->xend_ = (s)->xstart_ + (s)->numcols_, \\\n \t  (s)->yend_ = (s)->ystart_ + (s)->numrows_)\n+#define jas_seq2d_size(s) \\\n+\t(jas_seq2d_width(s) * jas_seq2d_height(s))\n \n void jas_seq2d_bindsub(jas_matrix_t *s, jas_matrix_t *s1, int xstart,\n   int ystart, int xend, int yend);""}<_**next**_>{""sha"": ""755c1c6ee9bf79a9cc2c663f7bfb1ce4fcd00c9a"", ""filename"": ""src/libjasper/jpc/jpc_dec.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 1, ""changes"": 9, ""blob_url"": ""https://github.com/mdadams/jasper/blob/2e82fa00466ae525339754bb3ab0a0474a31d4bd/src/libjasper/jpc/jpc_dec.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/2e82fa00466ae525339754bb3ab0a0474a31d4bd/src/libjasper/jpc/jpc_dec.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/jpc/jpc_dec.c?ref=2e82fa00466ae525339754bb3ab0a0474a31d4bd"", ""patch"": ""@@ -1838,6 +1838,13 @@ static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n \tbool warn;\n \tuint_fast32_t mask;\n \n+\tif (roishift < 0) {\n+\t\t/* We could instead return an error here. */\n+\t\t/* I do not think it matters much. */\n+\t\tjas_eprintf(\""warning: forcing negative ROI shift to zero \""\n+\t\t  \""(bitstream is probably corrupt)\\n\"");\n+\t\troishift = 0;\n+\t}\n \tif (roishift == 0 && bgshift == 0) {\n \t\treturn;\n \t}\n@@ -1856,7 +1863,7 @@ static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n \t\t\t} else {\n \t\t\t\t/* We are dealing with non-ROI (i.e., background) data. */\n \t\t\t\tmag <<= bgshift;\n-\t\t\t\tmask = (1 << numbps) - 1;\n+\t\t\t\tmask = (JAS_CAST(uint_fast32_t, 1) << numbps) - 1;\n \t\t\t\t/* Perform a basic sanity check on the sample value. */\n \t\t\t\t/* Some implementations write garbage in the unused\n \t\t\t\t  most-significant bit planes introduced by ROI shifting.""}<_**next**_>{""sha"": ""b51b747d6931f6e8ee8f94bae25712696692d00f"", ""filename"": ""src/libjasper/jpc/jpc_tsfb.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/mdadams/jasper/blob/2e82fa00466ae525339754bb3ab0a0474a31d4bd/src/libjasper/jpc/jpc_tsfb.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/2e82fa00466ae525339754bb3ab0a0474a31d4bd/src/libjasper/jpc/jpc_tsfb.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/jpc/jpc_tsfb.c?ref=2e82fa00466ae525339754bb3ab0a0474a31d4bd"", ""patch"": ""@@ -148,7 +148,8 @@ int jpc_tsfb_analyze2(jpc_tsfb_t *tsfb, int *a, int xstart, int ystart,\n \n int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n {\n-\treturn (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,\n+\treturn (tsfb->numlvls > 0 && jas_seq2d_size(a)) ?\n+\t  jpc_tsfb_synthesize2(tsfb,\n \t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n \t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n \t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;""}","static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)
{
	int i;
	int j;
	int thresh;
	jpc_fix_t val;
	jpc_fix_t mag;
 	bool warn;
 	uint_fast32_t mask;
 
	if (roishift < 0) {
		/* We could instead return an error here. */
		/* I do not think it matters much. */
		jas_eprintf(""warning: forcing negative ROI shift to zero ""
		  ""(bitstream is probably corrupt)\n"");
		roishift = 0;
	}
 	if (roishift == 0 && bgshift == 0) {
 		return;
 	}
	thresh = 1 << roishift;

	warn = false;
	for (i = 0; i < jas_matrix_numrows(x); ++i) {
		for (j = 0; j < jas_matrix_numcols(x); ++j) {
			val = jas_matrix_get(x, i, j);
			mag = JAS_ABS(val);
			if (mag >= thresh) {
				/* We are dealing with ROI data. */
				mag >>= roishift;
				val = (val < 0) ? (-mag) : mag;
				jas_matrix_set(x, i, j, val);
 			} else {
 				/* We are dealing with non-ROI (i.e., background) data. */
 				mag <<= bgshift;
				mask = (JAS_CAST(uint_fast32_t, 1) << numbps) - 1;
 				/* Perform a basic sanity check on the sample value. */
 				/* Some implementations write garbage in the unused
 				  most-significant bit planes introduced by ROI shifting.
				  Here we ensure that any such bits are masked off. */
				if (mag & (~mask)) {
					if (!warn) {
						jas_eprintf(""warning: possibly corrupt code stream\n"");
						warn = true;
					}
					mag &= mask;
				}
				val = (val < 0) ? (-mag) : mag;
				jas_matrix_set(x, i, j, val);
			}
		}
	}
}
","static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)
{
	int i;
	int j;
	int thresh;
	jpc_fix_t val;
	jpc_fix_t mag;
 	bool warn;
 	uint_fast32_t mask;
 
 	if (roishift == 0 && bgshift == 0) {
 		return;
 	}
	thresh = 1 << roishift;

	warn = false;
	for (i = 0; i < jas_matrix_numrows(x); ++i) {
		for (j = 0; j < jas_matrix_numcols(x); ++j) {
			val = jas_matrix_get(x, i, j);
			mag = JAS_ABS(val);
			if (mag >= thresh) {
				/* We are dealing with ROI data. */
				mag >>= roishift;
				val = (val < 0) ? (-mag) : mag;
				jas_matrix_set(x, i, j, val);
 			} else {
 				/* We are dealing with non-ROI (i.e., background) data. */
 				mag <<= bgshift;
				mask = (1 << numbps) - 1;
 				/* Perform a basic sanity check on the sample value. */
 				/* Some implementations write garbage in the unused
 				  most-significant bit planes introduced by ROI shifting.
				  Here we ensure that any such bits are masked off. */
				if (mag & (~mask)) {
					if (!warn) {
						jas_eprintf(""warning: possibly corrupt code stream\n"");
						warn = true;
					}
					mag &= mask;
				}
				val = (val < 0) ? (-mag) : mag;
				jas_matrix_set(x, i, j, val);
			}
		}
	}
}
",C,"	if (roishift < 0) {
		/* We could instead return an error here. */
		/* I do not think it matters much. */
		jas_eprintf(""warning: forcing negative ROI shift to zero ""
		  ""(bitstream is probably corrupt)\n"");
		roishift = 0;
	}
				mask = (JAS_CAST(uint_fast32_t, 1) << numbps) - 1;
","				mask = (1 << numbps) - 1;
",,"@@ -1838,6 +1838,13 @@ static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)
 	bool warn;
 	uint_fast32_t mask;
 
+	if (roishift < 0) {
+		/* We could instead return an error here. */
+		/* I do not think it matters much. */
+		jas_eprintf(""warning: forcing negative ROI shift to zero ""
+		  ""(bitstream is probably corrupt)\n"");
+		roishift = 0;
+	}
 	if (roishift == 0 && bgshift == 0) {
 		return;
 	}
@@ -1856,7 +1863,7 @@ static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)
 			} else {
 				/* We are dealing with non-ROI (i.e., background) data. */
 				mag <<= bgshift;
-				mask = (1 << numbps) - 1;
+				mask = (JAS_CAST(uint_fast32_t, 1) << numbps) - 1;
 				/* Perform a basic sanity check on the sample value. */
 				/* Some implementations write garbage in the unused
 				  most-significant bit planes introduced by ROI shifting.",jasper,2e82fa00466ae525339754bb3ab0a0474a31d4bd,95e510c4c05ad76fbe485ec242b3ddf6e1a3141e,1,"static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)
{
	int i;
	int j;
	int thresh;
	jpc_fix_t val;
	jpc_fix_t mag;
 	bool warn;
 	uint_fast32_t mask;
 
//fix_flaw_line_below:
//	if (roishift < 0) {
//fix_flaw_line_below:
//		/* We could instead return an error here. */
//fix_flaw_line_below:
//		/* I do not think it matters much. */
//fix_flaw_line_below:
//		jas_eprintf(""warning: forcing negative ROI shift to zero ""
//fix_flaw_line_below:
//		  ""(bitstream is probably corrupt)\n"");
//fix_flaw_line_below:
//		roishift = 0;
//fix_flaw_line_below:
//	}
 	if (roishift == 0 && bgshift == 0) {
 		return;
 	}
	thresh = 1 << roishift;

	warn = false;
	for (i = 0; i < jas_matrix_numrows(x); ++i) {
		for (j = 0; j < jas_matrix_numcols(x); ++j) {
			val = jas_matrix_get(x, i, j);
			mag = JAS_ABS(val);
			if (mag >= thresh) {
				/* We are dealing with ROI data. */
				mag >>= roishift;
				val = (val < 0) ? (-mag) : mag;
				jas_matrix_set(x, i, j, val);
 			} else {
 				/* We are dealing with non-ROI (i.e., background) data. */
 				mag <<= bgshift;
//flaw_line_below:
				mask = (1 << numbps) - 1;
//fix_flaw_line_below:
//				mask = (JAS_CAST(uint_fast32_t, 1) << numbps) - 1;
 				/* Perform a basic sanity check on the sample value. */
 				/* Some implementations write garbage in the unused
 				  most-significant bit planes introduced by ROI shifting.
				  Here we ensure that any such bits are masked off. */
				if (mag & (~mask)) {
					if (!warn) {
						jas_eprintf(""warning: possibly corrupt code stream\n"");
						warn = true;
					}
					mag &= mask;
				}
				val = (val < 0) ? (-mag) : mag;
				jas_matrix_set(x, i, j, val);
			}
		}
	}
}
"
3914,181650,,Remote,Not required,Partial,CVE-2016-10248,https://www.cvedetails.com/cve/CVE-2016-10248/,CWE-476,Low,,,,2017-03-15,5.0,The jpc_tsfb_synthesize function in jpc_tsfb.c in JasPer before 1.900.9 allows remote attackers to cause a denial of service (NULL pointer dereference) via vectors involving an empty sequence.,2018-06-28,DoS ,2,https://github.com/mdadams/jasper/commit/2e82fa00466ae525339754bb3ab0a0474a31d4bd,2e82fa00466ae525339754bb3ab0a0474a31d4bd,"Fixed an integral type promotion problem by adding a JAS_CAST.
Modified the jpc_tsfb_synthesize function so that it will be a noop for
an empty sequence (in order to avoid dereferencing a null pointer).",1,src/libjasper/jpc/jpc_tsfb.c,"{""sha"": ""91efc60bbff2351694ec000b41db89beb22be9dc"", ""filename"": ""src/libjasper/include/jasper/jas_math.h"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 0, ""changes"": 18, ""blob_url"": ""https://github.com/mdadams/jasper/blob/2e82fa00466ae525339754bb3ab0a0474a31d4bd/src/libjasper/include/jasper/jas_math.h"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/2e82fa00466ae525339754bb3ab0a0474a31d4bd/src/libjasper/include/jasper/jas_math.h"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/include/jasper/jas_math.h?ref=2e82fa00466ae525339754bb3ab0a0474a31d4bd"", ""patch"": ""@@ -112,6 +112,24 @@ extern \""C\"" {\n #define\tJAS_ONES(n) \\\n   ((1 << (n)) - 1)\n \n+/******************************************************************************\\\n+*\n+\\******************************************************************************/\n+\n+__attribute__((no_sanitize(\""undefined\"")))\n+inline static jas_int_asr(int x, int n)\n+{\n+\tassert(n >= 0);\n+\treturn x >> n;\n+}\n+\n+__attribute__((no_sanitize(\""undefined\"")))\n+inline static jas_int_asl(int x, int n)\n+{\n+\tassert(n >= 0);\n+\treturn x << n;\n+}\n+\n /******************************************************************************\\\n * Safe integer arithmetic (i.e., with overflow checking).\n \\******************************************************************************/""}<_**next**_>{""sha"": ""f470c841ee08d0852dcfb43586471989a5ba664b"", ""filename"": ""src/libjasper/include/jasper/jas_seq.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/mdadams/jasper/blob/2e82fa00466ae525339754bb3ab0a0474a31d4bd/src/libjasper/include/jasper/jas_seq.h"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/2e82fa00466ae525339754bb3ab0a0474a31d4bd/src/libjasper/include/jasper/jas_seq.h"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/include/jasper/jas_seq.h?ref=2e82fa00466ae525339754bb3ab0a0474a31d4bd"", ""patch"": ""@@ -154,6 +154,9 @@ typedef jas_matrix_t jas_seq_t;\n #define jas_matrix_numcols(matrix) \\\n \t((matrix)->numcols_)\n \n+#define jas_matrix_size(matrix) \\\n+\t(jas_matrix_width(matrix) * jas_matrix_height(matrix))\n+\n /* Get a matrix element. */\n #define jas_matrix_get(matrix, i, j) \\\n \t((matrix)->rows_[i][j])\n@@ -269,6 +272,8 @@ jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend);\n \t((s)->xstart_ = (x), (s)->ystart_ = (y), \\\n \t  (s)->xend_ = (s)->xstart_ + (s)->numcols_, \\\n \t  (s)->yend_ = (s)->ystart_ + (s)->numrows_)\n+#define jas_seq2d_size(s) \\\n+\t(jas_seq2d_width(s) * jas_seq2d_height(s))\n \n void jas_seq2d_bindsub(jas_matrix_t *s, jas_matrix_t *s1, int xstart,\n   int ystart, int xend, int yend);""}<_**next**_>{""sha"": ""755c1c6ee9bf79a9cc2c663f7bfb1ce4fcd00c9a"", ""filename"": ""src/libjasper/jpc/jpc_dec.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 1, ""changes"": 9, ""blob_url"": ""https://github.com/mdadams/jasper/blob/2e82fa00466ae525339754bb3ab0a0474a31d4bd/src/libjasper/jpc/jpc_dec.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/2e82fa00466ae525339754bb3ab0a0474a31d4bd/src/libjasper/jpc/jpc_dec.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/jpc/jpc_dec.c?ref=2e82fa00466ae525339754bb3ab0a0474a31d4bd"", ""patch"": ""@@ -1838,6 +1838,13 @@ static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n \tbool warn;\n \tuint_fast32_t mask;\n \n+\tif (roishift < 0) {\n+\t\t/* We could instead return an error here. */\n+\t\t/* I do not think it matters much. */\n+\t\tjas_eprintf(\""warning: forcing negative ROI shift to zero \""\n+\t\t  \""(bitstream is probably corrupt)\\n\"");\n+\t\troishift = 0;\n+\t}\n \tif (roishift == 0 && bgshift == 0) {\n \t\treturn;\n \t}\n@@ -1856,7 +1863,7 @@ static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n \t\t\t} else {\n \t\t\t\t/* We are dealing with non-ROI (i.e., background) data. */\n \t\t\t\tmag <<= bgshift;\n-\t\t\t\tmask = (1 << numbps) - 1;\n+\t\t\t\tmask = (JAS_CAST(uint_fast32_t, 1) << numbps) - 1;\n \t\t\t\t/* Perform a basic sanity check on the sample value. */\n \t\t\t\t/* Some implementations write garbage in the unused\n \t\t\t\t  most-significant bit planes introduced by ROI shifting.""}<_**next**_>{""sha"": ""b51b747d6931f6e8ee8f94bae25712696692d00f"", ""filename"": ""src/libjasper/jpc/jpc_tsfb.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/mdadams/jasper/blob/2e82fa00466ae525339754bb3ab0a0474a31d4bd/src/libjasper/jpc/jpc_tsfb.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/2e82fa00466ae525339754bb3ab0a0474a31d4bd/src/libjasper/jpc/jpc_tsfb.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/jpc/jpc_tsfb.c?ref=2e82fa00466ae525339754bb3ab0a0474a31d4bd"", ""patch"": ""@@ -148,7 +148,8 @@ int jpc_tsfb_analyze2(jpc_tsfb_t *tsfb, int *a, int xstart, int ystart,\n \n int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n {\n-\treturn (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,\n+\treturn (tsfb->numlvls > 0 && jas_seq2d_size(a)) ?\n+\t  jpc_tsfb_synthesize2(tsfb,\n \t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n \t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n \t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;""}"," int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)
 {
	return (tsfb->numlvls > 0 && jas_seq2d_size(a)) ?
	  jpc_tsfb_synthesize2(tsfb,
 	  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),
 	  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),
 	  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;
}
"," int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)
 {
	return (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,
 	  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),
 	  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),
 	  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;
}
",C,"	return (tsfb->numlvls > 0 && jas_seq2d_size(a)) ?
	  jpc_tsfb_synthesize2(tsfb,
","	return (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,
",,"@@ -148,7 +148,8 @@ int jpc_tsfb_analyze2(jpc_tsfb_t *tsfb, int *a, int xstart, int ystart,
 
 int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)
 {
-	return (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,
+	return (tsfb->numlvls > 0 && jas_seq2d_size(a)) ?
+	  jpc_tsfb_synthesize2(tsfb,
 	  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),
 	  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),
 	  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;",jasper,2e82fa00466ae525339754bb3ab0a0474a31d4bd,95e510c4c05ad76fbe485ec242b3ddf6e1a3141e,1," int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)
 {
//flaw_line_below:
	return (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,
//fix_flaw_line_below:
//	return (tsfb->numlvls > 0 && jas_seq2d_size(a)) ?
//fix_flaw_line_below:
//	  jpc_tsfb_synthesize2(tsfb,
 	  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),
 	  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),
 	  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;
}
"
3918,181654,,Remote,Not required,Partial,CVE-2016-10210,https://www.cvedetails.com/cve/CVE-2016-10210/,CWE-476,Low,,,,2017-04-03,5.0,libyara/lexer.l in YARA 3.5.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted rule that is mishandled in the yy_get_next_buffer function.,2017-05-01,DoS ,2,https://github.com/VirusTotal/yara/commit/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,"re_lexer: Make reading escape sequences more robust (#586)

* Add test for issue #503

* re_lexer: Make reading escape sequences more robust

This commit fixes parsing incomplete escape sequences at the end of a
regular expression and parsing things like \xxy (invalid hex digits)
which before were silently turned into (char)255.

Close #503

* Update re_lexer.c",0,libyara/re_lexer.c,"{""sha"": ""f0940a8b2095ec57e12e1ab40a860b4e00113996"", ""filename"": ""libyara/re_lexer.c"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 20, ""changes"": 40, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.c"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.c"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/libyara/re_lexer.c?ref=3119b232c9c453c98d8fa8b6ae4e37ba18117cd4"", ""patch"": ""@@ -190,7 +190,7 @@ typedef size_t yy_size_t;\n \n     /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires\n      *       access to the local variable yy_act. Since yyless() is a macro, it would break\n-     *       existing scanners that call yyless() from OUTSIDE re_yylex. \n+     *       existing scanners that call yyless() from OUTSIDE re_yylex.\n      *       One obvious solution it to make yy_act a global. I tried that, and saw\n      *       a 5% performance hit in a non-yylineno scanner, because yy_act is\n      *       normally declared as a register variable-- so it is not worth it.\n@@ -266,7 +266,7 @@ struct yy_buffer_state\n \n     int yy_bs_lineno; /**< The line count. */\n     int yy_bs_column; /**< The column count. */\n-    \n+\n \t/* Whether to try to fill the input buffer when we reach the\n \t * end of it.\n \t */\n@@ -906,7 +906,7 @@ YY_DECL\n \t\t\tyy_size_t yyl;\n \t\t\tfor ( yyl = 0; yyl < yyleng; ++yyl )\n \t\t\t\tif ( yytext[yyl] == '\\n' )\n-\t\t\t\t\t   \n+\t\t\t\t\t\n     do{ yylineno++;\n         yycolumn=0;\n     }while(0)\n@@ -1125,7 +1125,7 @@ YY_RULE_SETUP\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -1180,7 +1180,7 @@ YY_RULE_SETUP\n   {\n     if (!read_escaped_char(yyscanner, &end))\n     {\n-      yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+      yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n       yyterminate();\n     }\n   }\n@@ -1292,7 +1292,7 @@ YY_RULE_SETUP\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -1763,7 +1763,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)\n \tyyg->yy_hold_char = *++yyg->yy_c_buf_p;\n \n \tif ( c == '\\n' )\n-\t\t   \n+\t\t\n     do{ yylineno++;\n         yycolumn=0;\n     }while(0)\n@@ -2018,9 +2018,9 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)\n \t\t\t\t\t\t\t\t, yyscanner);\n \t\tif ( ! yyg->yy_buffer_stack )\n \t\t\tYY_FATAL_ERROR( \""out of dynamic memory in re_yyensure_buffer_stack()\"" );\n-\t\t\t\t\t\t\t\t  \n+\n \t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n-\t\t\t\t\n+\n \t\tyyg->yy_buffer_stack_max = num_to_alloc;\n \t\tyyg->yy_buffer_stack_top = 0;\n \t\treturn;\n@@ -2049,7 +2049,7 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)\n  * @param base the character buffer\n  * @param size the size in bytes of the character buffer\n  * @param yyscanner The scanner object.\n- * @return the newly allocated buffer state object. \n+ * @return the newly allocated buffer state object.\n  */\n YY_BUFFER_STATE re_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)\n {\n@@ -2177,7 +2177,7 @@ YY_EXTRA_TYPE re_yyget_extra  (yyscan_t yyscanner)\n int re_yyget_lineno  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    \n+\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n@@ -2190,7 +2190,7 @@ int re_yyget_lineno  (yyscan_t yyscanner)\n int re_yyget_column  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    \n+\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n@@ -2365,20 +2365,20 @@ int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )\n         errno = EINVAL;\n         return 1;\n     }\n-\t\n+\n     *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n-\t\n+\n     if (*ptr_yy_globals == NULL){\n         errno = ENOMEM;\n         return 1;\n     }\n-    \n+\n     /* By setting to 0xAA, we expose bugs in\n     yy_init_globals. Leave at 0x00 for releases. */\n     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n-    \n+\n     re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n-    \n+\n     return yy_init_globals ( *ptr_yy_globals );\n }\n \n@@ -2568,19 +2568,19 @@ int read_escaped_char(\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n-  if (text[1] == EOF)\n+  if (text[1] == EOF || text[1] == 0)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n-    if (text[2] == EOF)\n+    if (!isxdigit(text[2]))\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n-    if (text[3] == EOF)\n+    if (!isxdigit(text[3]))\n       return 0;\n   }\n ""}<_**next**_>{""sha"": ""9e0b00549169e599fd87a4a6db9b893b4cde3d29"", ""filename"": ""libyara/re_lexer.l"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.l"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.l"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/libyara/re_lexer.l?ref=3119b232c9c453c98d8fa8b6ae4e37ba18117cd4"", ""patch"": ""@@ -261,7 +261,7 @@ hex_digit     [0-9a-fA-F]\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -312,7 +312,7 @@ hex_digit     [0-9a-fA-F]\n   {\n     if (!read_escaped_char(yyscanner, &end))\n     {\n-      yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+      yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n       yyterminate();\n     }\n   }\n@@ -410,7 +410,7 @@ hex_digit     [0-9a-fA-F]\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -524,19 +524,19 @@ int read_escaped_char(\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n-  if (text[1] == EOF)\n+  if (text[1] == EOF || text[1] == 0)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n-    if (text[2] == EOF)\n+    if (!isxdigit(text[2]))\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n-    if (text[3] == EOF)\n+    if (!isxdigit(text[3]))\n       return 0;\n   }\n ""}<_**next**_>{""sha"": ""556e34526393dad109cfdedb86bdb09e872a077d"", ""filename"": ""tests/test-rules.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/tests/test-rules.c"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/tests/test-rules.c"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/tests/test-rules.c?ref=3119b232c9c453c98d8fa8b6ae4e37ba18117cd4"", ""patch"": ""@@ -1019,6 +1019,12 @@ void test_re()\n \n   // Test case for issue #324\n   assert_true_regexp(\""whatever|   x.   x\"", \""   xy   x\"", \""   xy   x\"");\n+\n+  // test case for issue #503, \\x without two following hex-digits\n+  assert_regexp_syntax_error(\""\\\\x0\"");\n+  assert_regexp_syntax_error(\""\\\\x\"");\n+\n+  assert_regexp_syntax_error(\""\\\\xxy\"");\n }\n \n ""}","static void re_yyensure_buffer_stack (yyscan_t yyscanner)
{
	yy_size_t num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if (!yyg->yy_buffer_stack) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
		num_to_alloc = 1; // After all that talk, this was set to 1 anyways...
		yyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
 								, yyscanner);
 		if ( ! yyg->yy_buffer_stack )
 			YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );

 		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

 		yyg->yy_buffer_stack_max = num_to_alloc;
 		yyg->yy_buffer_stack_top = 0;
 		return;
	}

	if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

		/* Increase the buffer to prepare for a possible push. */
		yy_size_t grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
		yyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyrealloc
								(yyg->yy_buffer_stack,
								num_to_alloc * sizeof(struct yy_buffer_state*)
								, yyscanner);
		if ( ! yyg->yy_buffer_stack )
			YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );

		/* zero only the new slots.*/
		memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
		yyg->yy_buffer_stack_max = num_to_alloc;
	}
}
","static void re_yyensure_buffer_stack (yyscan_t yyscanner)
{
	yy_size_t num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if (!yyg->yy_buffer_stack) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
		num_to_alloc = 1; // After all that talk, this was set to 1 anyways...
		yyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
 								, yyscanner);
 		if ( ! yyg->yy_buffer_stack )
 			YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );
 		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
 		yyg->yy_buffer_stack_max = num_to_alloc;
 		yyg->yy_buffer_stack_top = 0;
 		return;
	}

	if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

		/* Increase the buffer to prepare for a possible push. */
		yy_size_t grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
		yyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyrealloc
								(yyg->yy_buffer_stack,
								num_to_alloc * sizeof(struct yy_buffer_state*)
								, yyscanner);
		if ( ! yyg->yy_buffer_stack )
			YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );

		/* zero only the new slots.*/
		memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
		yyg->yy_buffer_stack_max = num_to_alloc;
	}
}
",C,"

",,,"@@ -190,7 +190,7 @@ typedef size_t yy_size_t;
 
     /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
      *       access to the local variable yy_act. Since yyless() is a macro, it would break
-     *       existing scanners that call yyless() from OUTSIDE re_yylex. 
+     *       existing scanners that call yyless() from OUTSIDE re_yylex.
      *       One obvious solution it to make yy_act a global. I tried that, and saw
      *       a 5% performance hit in a non-yylineno scanner, because yy_act is
      *       normally declared as a register variable-- so it is not worth it.
@@ -266,7 +266,7 @@ struct yy_buffer_state
 
     int yy_bs_lineno; /**< The line count. */
     int yy_bs_column; /**< The column count. */
-    
+
 	/* Whether to try to fill the input buffer when we reach the
 	 * end of it.
 	 */
@@ -906,7 +906,7 @@ YY_DECL
 			yy_size_t yyl;
 			for ( yyl = 0; yyl < yyleng; ++yyl )
 				if ( yytext[yyl] == '\n' )
-					   
+					
     do{ yylineno++;
         yycolumn=0;
     }while(0)
@@ -1125,7 +1125,7 @@ YY_RULE_SETUP
   }
   else
   {
-    yyerror(yyscanner, lex_env, ""unexpected end of buffer"");
+    yyerror(yyscanner, lex_env, ""illegal escape sequence"");
     yyterminate();
   }
 }
@@ -1180,7 +1180,7 @@ YY_RULE_SETUP
   {
     if (!read_escaped_char(yyscanner, &end))
     {
-      yyerror(yyscanner, lex_env, ""unexpected end of buffer"");
+      yyerror(yyscanner, lex_env, ""illegal escape sequence"");
       yyterminate();
     }
   }
@@ -1292,7 +1292,7 @@ YY_RULE_SETUP
   }
   else
   {
-    yyerror(yyscanner, lex_env, ""unexpected end of buffer"");
+    yyerror(yyscanner, lex_env, ""illegal escape sequence"");
     yyterminate();
   }
 }
@@ -1763,7 +1763,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 	yyg->yy_hold_char = *++yyg->yy_c_buf_p;
 
 	if ( c == '\n' )
-		   
+		
     do{ yylineno++;
         yycolumn=0;
     }while(0)
@@ -2018,9 +2018,9 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)
 								, yyscanner);
 		if ( ! yyg->yy_buffer_stack )
 			YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );
-								  
+
 		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-				
+
 		yyg->yy_buffer_stack_max = num_to_alloc;
 		yyg->yy_buffer_stack_top = 0;
 		return;
@@ -2049,7 +2049,7 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)
  * @param base the character buffer
  * @param size the size in bytes of the character buffer
  * @param yyscanner The scanner object.
- * @return the newly allocated buffer state object. 
+ * @return the newly allocated buffer state object.
  */
 YY_BUFFER_STATE re_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
 {
@@ -2177,7 +2177,7 @@ YY_EXTRA_TYPE re_yyget_extra  (yyscan_t yyscanner)
 int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    
+
         if (! YY_CURRENT_BUFFER)
             return 0;
     
@@ -2190,7 +2190,7 @@ int re_yyget_lineno  (yyscan_t yyscanner)
 int re_yyget_column  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    
+
         if (! YY_CURRENT_BUFFER)
             return 0;
     
@@ -2365,20 +2365,20 @@ int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )
         errno = EINVAL;
         return 1;
     }
-	
+
     *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );
-	
+
     if (*ptr_yy_globals == NULL){
         errno = ENOMEM;
         return 1;
     }
-    
+
     /* By setting to 0xAA, we expose bugs in
     yy_init_globals. Leave at 0x00 for releases. */
     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
-    
+
     re_yyset_extra (yy_user_defined, *ptr_yy_globals);
-    
+
     return yy_init_globals ( *ptr_yy_globals );
 }
 
@@ -2568,19 +2568,19 @@ int read_escaped_char(
   text[0] = '\\';
   text[1] = RE_YY_INPUT(yyscanner);
 
-  if (text[1] == EOF)
+  if (text[1] == EOF || text[1] == 0)
     return 0;
 
   if (text[1] == 'x')
   {
     text[2] = RE_YY_INPUT(yyscanner);
 
-    if (text[2] == EOF)
+    if (!isxdigit(text[2]))
       return 0;
 
     text[3] = RE_YY_INPUT(yyscanner);
 
-    if (text[3] == EOF)
+    if (!isxdigit(text[3]))
       return 0;
   }
 ",yara,3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,d68cd32fabb0b7703ada455dfa5b38ef03132907,1,"static void re_yyensure_buffer_stack (yyscan_t yyscanner)
{
	yy_size_t num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if (!yyg->yy_buffer_stack) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
		num_to_alloc = 1; // After all that talk, this was set to 1 anyways...
		yyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
 								, yyscanner);
 		if ( ! yyg->yy_buffer_stack )
 			YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );
//flaw_line_below:
								  
//fix_flaw_line_below:
//
 		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
//flaw_line_below:
				
//fix_flaw_line_below:
//
 		yyg->yy_buffer_stack_max = num_to_alloc;
 		yyg->yy_buffer_stack_top = 0;
 		return;
	}

	if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

		/* Increase the buffer to prepare for a possible push. */
		yy_size_t grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
		yyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyrealloc
								(yyg->yy_buffer_stack,
								num_to_alloc * sizeof(struct yy_buffer_state*)
								, yyscanner);
		if ( ! yyg->yy_buffer_stack )
			YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );

		/* zero only the new slots.*/
		memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
		yyg->yy_buffer_stack_max = num_to_alloc;
	}
}
"
3919,181655,,Remote,Not required,Partial,CVE-2016-10210,https://www.cvedetails.com/cve/CVE-2016-10210/,CWE-476,Low,,,,2017-04-03,5.0,libyara/lexer.l in YARA 3.5.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted rule that is mishandled in the yy_get_next_buffer function.,2017-05-01,DoS ,1,https://github.com/VirusTotal/yara/commit/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,"re_lexer: Make reading escape sequences more robust (#586)

* Add test for issue #503

* re_lexer: Make reading escape sequences more robust

This commit fixes parsing incomplete escape sequences at the end of a
regular expression and parsing things like \xxy (invalid hex digits)
which before were silently turned into (char)255.

Close #503

* Update re_lexer.c",0,libyara/re_lexer.c,"{""sha"": ""f0940a8b2095ec57e12e1ab40a860b4e00113996"", ""filename"": ""libyara/re_lexer.c"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 20, ""changes"": 40, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.c"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.c"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/libyara/re_lexer.c?ref=3119b232c9c453c98d8fa8b6ae4e37ba18117cd4"", ""patch"": ""@@ -190,7 +190,7 @@ typedef size_t yy_size_t;\n \n     /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires\n      *       access to the local variable yy_act. Since yyless() is a macro, it would break\n-     *       existing scanners that call yyless() from OUTSIDE re_yylex. \n+     *       existing scanners that call yyless() from OUTSIDE re_yylex.\n      *       One obvious solution it to make yy_act a global. I tried that, and saw\n      *       a 5% performance hit in a non-yylineno scanner, because yy_act is\n      *       normally declared as a register variable-- so it is not worth it.\n@@ -266,7 +266,7 @@ struct yy_buffer_state\n \n     int yy_bs_lineno; /**< The line count. */\n     int yy_bs_column; /**< The column count. */\n-    \n+\n \t/* Whether to try to fill the input buffer when we reach the\n \t * end of it.\n \t */\n@@ -906,7 +906,7 @@ YY_DECL\n \t\t\tyy_size_t yyl;\n \t\t\tfor ( yyl = 0; yyl < yyleng; ++yyl )\n \t\t\t\tif ( yytext[yyl] == '\\n' )\n-\t\t\t\t\t   \n+\t\t\t\t\t\n     do{ yylineno++;\n         yycolumn=0;\n     }while(0)\n@@ -1125,7 +1125,7 @@ YY_RULE_SETUP\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -1180,7 +1180,7 @@ YY_RULE_SETUP\n   {\n     if (!read_escaped_char(yyscanner, &end))\n     {\n-      yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+      yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n       yyterminate();\n     }\n   }\n@@ -1292,7 +1292,7 @@ YY_RULE_SETUP\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -1763,7 +1763,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)\n \tyyg->yy_hold_char = *++yyg->yy_c_buf_p;\n \n \tif ( c == '\\n' )\n-\t\t   \n+\t\t\n     do{ yylineno++;\n         yycolumn=0;\n     }while(0)\n@@ -2018,9 +2018,9 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)\n \t\t\t\t\t\t\t\t, yyscanner);\n \t\tif ( ! yyg->yy_buffer_stack )\n \t\t\tYY_FATAL_ERROR( \""out of dynamic memory in re_yyensure_buffer_stack()\"" );\n-\t\t\t\t\t\t\t\t  \n+\n \t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n-\t\t\t\t\n+\n \t\tyyg->yy_buffer_stack_max = num_to_alloc;\n \t\tyyg->yy_buffer_stack_top = 0;\n \t\treturn;\n@@ -2049,7 +2049,7 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)\n  * @param base the character buffer\n  * @param size the size in bytes of the character buffer\n  * @param yyscanner The scanner object.\n- * @return the newly allocated buffer state object. \n+ * @return the newly allocated buffer state object.\n  */\n YY_BUFFER_STATE re_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)\n {\n@@ -2177,7 +2177,7 @@ YY_EXTRA_TYPE re_yyget_extra  (yyscan_t yyscanner)\n int re_yyget_lineno  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    \n+\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n@@ -2190,7 +2190,7 @@ int re_yyget_lineno  (yyscan_t yyscanner)\n int re_yyget_column  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    \n+\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n@@ -2365,20 +2365,20 @@ int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )\n         errno = EINVAL;\n         return 1;\n     }\n-\t\n+\n     *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n-\t\n+\n     if (*ptr_yy_globals == NULL){\n         errno = ENOMEM;\n         return 1;\n     }\n-    \n+\n     /* By setting to 0xAA, we expose bugs in\n     yy_init_globals. Leave at 0x00 for releases. */\n     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n-    \n+\n     re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n-    \n+\n     return yy_init_globals ( *ptr_yy_globals );\n }\n \n@@ -2568,19 +2568,19 @@ int read_escaped_char(\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n-  if (text[1] == EOF)\n+  if (text[1] == EOF || text[1] == 0)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n-    if (text[2] == EOF)\n+    if (!isxdigit(text[2]))\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n-    if (text[3] == EOF)\n+    if (!isxdigit(text[3]))\n       return 0;\n   }\n ""}<_**next**_>{""sha"": ""9e0b00549169e599fd87a4a6db9b893b4cde3d29"", ""filename"": ""libyara/re_lexer.l"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.l"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.l"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/libyara/re_lexer.l?ref=3119b232c9c453c98d8fa8b6ae4e37ba18117cd4"", ""patch"": ""@@ -261,7 +261,7 @@ hex_digit     [0-9a-fA-F]\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -312,7 +312,7 @@ hex_digit     [0-9a-fA-F]\n   {\n     if (!read_escaped_char(yyscanner, &end))\n     {\n-      yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+      yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n       yyterminate();\n     }\n   }\n@@ -410,7 +410,7 @@ hex_digit     [0-9a-fA-F]\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -524,19 +524,19 @@ int read_escaped_char(\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n-  if (text[1] == EOF)\n+  if (text[1] == EOF || text[1] == 0)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n-    if (text[2] == EOF)\n+    if (!isxdigit(text[2]))\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n-    if (text[3] == EOF)\n+    if (!isxdigit(text[3]))\n       return 0;\n   }\n ""}<_**next**_>{""sha"": ""556e34526393dad109cfdedb86bdb09e872a077d"", ""filename"": ""tests/test-rules.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/tests/test-rules.c"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/tests/test-rules.c"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/tests/test-rules.c?ref=3119b232c9c453c98d8fa8b6ae4e37ba18117cd4"", ""patch"": ""@@ -1019,6 +1019,12 @@ void test_re()\n \n   // Test case for issue #324\n   assert_true_regexp(\""whatever|   x.   x\"", \""   xy   x\"", \""   xy   x\"");\n+\n+  // test case for issue #503, \\x without two following hex-digits\n+  assert_regexp_syntax_error(\""\\\\x0\"");\n+  assert_regexp_syntax_error(\""\\\\x\"");\n+\n+  assert_regexp_syntax_error(\""\\\\xxy\"");\n }\n \n ""}"," int re_yyget_column  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

         if (! YY_CURRENT_BUFFER)
             return 0;
     
    return yycolumn;
}
"," int re_yyget_column  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
         if (! YY_CURRENT_BUFFER)
             return 0;
     
    return yycolumn;
}
",C,"
",,,"@@ -190,7 +190,7 @@ typedef size_t yy_size_t;
 
     /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
      *       access to the local variable yy_act. Since yyless() is a macro, it would break
-     *       existing scanners that call yyless() from OUTSIDE re_yylex. 
+     *       existing scanners that call yyless() from OUTSIDE re_yylex.
      *       One obvious solution it to make yy_act a global. I tried that, and saw
      *       a 5% performance hit in a non-yylineno scanner, because yy_act is
      *       normally declared as a register variable-- so it is not worth it.
@@ -266,7 +266,7 @@ struct yy_buffer_state
 
     int yy_bs_lineno; /**< The line count. */
     int yy_bs_column; /**< The column count. */
-    
+
 	/* Whether to try to fill the input buffer when we reach the
 	 * end of it.
 	 */
@@ -906,7 +906,7 @@ YY_DECL
 			yy_size_t yyl;
 			for ( yyl = 0; yyl < yyleng; ++yyl )
 				if ( yytext[yyl] == '\n' )
-					   
+					
     do{ yylineno++;
         yycolumn=0;
     }while(0)
@@ -1125,7 +1125,7 @@ YY_RULE_SETUP
   }
   else
   {
-    yyerror(yyscanner, lex_env, ""unexpected end of buffer"");
+    yyerror(yyscanner, lex_env, ""illegal escape sequence"");
     yyterminate();
   }
 }
@@ -1180,7 +1180,7 @@ YY_RULE_SETUP
   {
     if (!read_escaped_char(yyscanner, &end))
     {
-      yyerror(yyscanner, lex_env, ""unexpected end of buffer"");
+      yyerror(yyscanner, lex_env, ""illegal escape sequence"");
       yyterminate();
     }
   }
@@ -1292,7 +1292,7 @@ YY_RULE_SETUP
   }
   else
   {
-    yyerror(yyscanner, lex_env, ""unexpected end of buffer"");
+    yyerror(yyscanner, lex_env, ""illegal escape sequence"");
     yyterminate();
   }
 }
@@ -1763,7 +1763,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 	yyg->yy_hold_char = *++yyg->yy_c_buf_p;
 
 	if ( c == '\n' )
-		   
+		
     do{ yylineno++;
         yycolumn=0;
     }while(0)
@@ -2018,9 +2018,9 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)
 								, yyscanner);
 		if ( ! yyg->yy_buffer_stack )
 			YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );
-								  
+
 		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-				
+
 		yyg->yy_buffer_stack_max = num_to_alloc;
 		yyg->yy_buffer_stack_top = 0;
 		return;
@@ -2049,7 +2049,7 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)
  * @param base the character buffer
  * @param size the size in bytes of the character buffer
  * @param yyscanner The scanner object.
- * @return the newly allocated buffer state object. 
+ * @return the newly allocated buffer state object.
  */
 YY_BUFFER_STATE re_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
 {
@@ -2177,7 +2177,7 @@ YY_EXTRA_TYPE re_yyget_extra  (yyscan_t yyscanner)
 int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    
+
         if (! YY_CURRENT_BUFFER)
             return 0;
     
@@ -2190,7 +2190,7 @@ int re_yyget_lineno  (yyscan_t yyscanner)
 int re_yyget_column  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    
+
         if (! YY_CURRENT_BUFFER)
             return 0;
     
@@ -2365,20 +2365,20 @@ int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )
         errno = EINVAL;
         return 1;
     }
-	
+
     *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );
-	
+
     if (*ptr_yy_globals == NULL){
         errno = ENOMEM;
         return 1;
     }
-    
+
     /* By setting to 0xAA, we expose bugs in
     yy_init_globals. Leave at 0x00 for releases. */
     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
-    
+
     re_yyset_extra (yy_user_defined, *ptr_yy_globals);
-    
+
     return yy_init_globals ( *ptr_yy_globals );
 }
 
@@ -2568,19 +2568,19 @@ int read_escaped_char(
   text[0] = '\\';
   text[1] = RE_YY_INPUT(yyscanner);
 
-  if (text[1] == EOF)
+  if (text[1] == EOF || text[1] == 0)
     return 0;
 
   if (text[1] == 'x')
   {
     text[2] = RE_YY_INPUT(yyscanner);
 
-    if (text[2] == EOF)
+    if (!isxdigit(text[2]))
       return 0;
 
     text[3] = RE_YY_INPUT(yyscanner);
 
-    if (text[3] == EOF)
+    if (!isxdigit(text[3]))
       return 0;
   }
 ",yara,3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,d68cd32fabb0b7703ada455dfa5b38ef03132907,1," int re_yyget_column  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
//flaw_line_below:
    
//fix_flaw_line_below:
//
         if (! YY_CURRENT_BUFFER)
             return 0;
     
    return yycolumn;
}
"
3920,181656,,Remote,Not required,Partial,CVE-2016-10210,https://www.cvedetails.com/cve/CVE-2016-10210/,CWE-476,Low,,,,2017-04-03,5.0,libyara/lexer.l in YARA 3.5.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted rule that is mishandled in the yy_get_next_buffer function.,2017-05-01,DoS ,1,https://github.com/VirusTotal/yara/commit/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,"re_lexer: Make reading escape sequences more robust (#586)

* Add test for issue #503

* re_lexer: Make reading escape sequences more robust

This commit fixes parsing incomplete escape sequences at the end of a
regular expression and parsing things like \xxy (invalid hex digits)
which before were silently turned into (char)255.

Close #503

* Update re_lexer.c",0,libyara/re_lexer.c,"{""sha"": ""f0940a8b2095ec57e12e1ab40a860b4e00113996"", ""filename"": ""libyara/re_lexer.c"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 20, ""changes"": 40, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.c"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.c"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/libyara/re_lexer.c?ref=3119b232c9c453c98d8fa8b6ae4e37ba18117cd4"", ""patch"": ""@@ -190,7 +190,7 @@ typedef size_t yy_size_t;\n \n     /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires\n      *       access to the local variable yy_act. Since yyless() is a macro, it would break\n-     *       existing scanners that call yyless() from OUTSIDE re_yylex. \n+     *       existing scanners that call yyless() from OUTSIDE re_yylex.\n      *       One obvious solution it to make yy_act a global. I tried that, and saw\n      *       a 5% performance hit in a non-yylineno scanner, because yy_act is\n      *       normally declared as a register variable-- so it is not worth it.\n@@ -266,7 +266,7 @@ struct yy_buffer_state\n \n     int yy_bs_lineno; /**< The line count. */\n     int yy_bs_column; /**< The column count. */\n-    \n+\n \t/* Whether to try to fill the input buffer when we reach the\n \t * end of it.\n \t */\n@@ -906,7 +906,7 @@ YY_DECL\n \t\t\tyy_size_t yyl;\n \t\t\tfor ( yyl = 0; yyl < yyleng; ++yyl )\n \t\t\t\tif ( yytext[yyl] == '\\n' )\n-\t\t\t\t\t   \n+\t\t\t\t\t\n     do{ yylineno++;\n         yycolumn=0;\n     }while(0)\n@@ -1125,7 +1125,7 @@ YY_RULE_SETUP\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -1180,7 +1180,7 @@ YY_RULE_SETUP\n   {\n     if (!read_escaped_char(yyscanner, &end))\n     {\n-      yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+      yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n       yyterminate();\n     }\n   }\n@@ -1292,7 +1292,7 @@ YY_RULE_SETUP\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -1763,7 +1763,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)\n \tyyg->yy_hold_char = *++yyg->yy_c_buf_p;\n \n \tif ( c == '\\n' )\n-\t\t   \n+\t\t\n     do{ yylineno++;\n         yycolumn=0;\n     }while(0)\n@@ -2018,9 +2018,9 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)\n \t\t\t\t\t\t\t\t, yyscanner);\n \t\tif ( ! yyg->yy_buffer_stack )\n \t\t\tYY_FATAL_ERROR( \""out of dynamic memory in re_yyensure_buffer_stack()\"" );\n-\t\t\t\t\t\t\t\t  \n+\n \t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n-\t\t\t\t\n+\n \t\tyyg->yy_buffer_stack_max = num_to_alloc;\n \t\tyyg->yy_buffer_stack_top = 0;\n \t\treturn;\n@@ -2049,7 +2049,7 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)\n  * @param base the character buffer\n  * @param size the size in bytes of the character buffer\n  * @param yyscanner The scanner object.\n- * @return the newly allocated buffer state object. \n+ * @return the newly allocated buffer state object.\n  */\n YY_BUFFER_STATE re_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)\n {\n@@ -2177,7 +2177,7 @@ YY_EXTRA_TYPE re_yyget_extra  (yyscan_t yyscanner)\n int re_yyget_lineno  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    \n+\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n@@ -2190,7 +2190,7 @@ int re_yyget_lineno  (yyscan_t yyscanner)\n int re_yyget_column  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    \n+\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n@@ -2365,20 +2365,20 @@ int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )\n         errno = EINVAL;\n         return 1;\n     }\n-\t\n+\n     *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n-\t\n+\n     if (*ptr_yy_globals == NULL){\n         errno = ENOMEM;\n         return 1;\n     }\n-    \n+\n     /* By setting to 0xAA, we expose bugs in\n     yy_init_globals. Leave at 0x00 for releases. */\n     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n-    \n+\n     re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n-    \n+\n     return yy_init_globals ( *ptr_yy_globals );\n }\n \n@@ -2568,19 +2568,19 @@ int read_escaped_char(\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n-  if (text[1] == EOF)\n+  if (text[1] == EOF || text[1] == 0)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n-    if (text[2] == EOF)\n+    if (!isxdigit(text[2]))\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n-    if (text[3] == EOF)\n+    if (!isxdigit(text[3]))\n       return 0;\n   }\n ""}<_**next**_>{""sha"": ""9e0b00549169e599fd87a4a6db9b893b4cde3d29"", ""filename"": ""libyara/re_lexer.l"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.l"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.l"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/libyara/re_lexer.l?ref=3119b232c9c453c98d8fa8b6ae4e37ba18117cd4"", ""patch"": ""@@ -261,7 +261,7 @@ hex_digit     [0-9a-fA-F]\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -312,7 +312,7 @@ hex_digit     [0-9a-fA-F]\n   {\n     if (!read_escaped_char(yyscanner, &end))\n     {\n-      yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+      yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n       yyterminate();\n     }\n   }\n@@ -410,7 +410,7 @@ hex_digit     [0-9a-fA-F]\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -524,19 +524,19 @@ int read_escaped_char(\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n-  if (text[1] == EOF)\n+  if (text[1] == EOF || text[1] == 0)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n-    if (text[2] == EOF)\n+    if (!isxdigit(text[2]))\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n-    if (text[3] == EOF)\n+    if (!isxdigit(text[3]))\n       return 0;\n   }\n ""}<_**next**_>{""sha"": ""556e34526393dad109cfdedb86bdb09e872a077d"", ""filename"": ""tests/test-rules.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/tests/test-rules.c"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/tests/test-rules.c"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/tests/test-rules.c?ref=3119b232c9c453c98d8fa8b6ae4e37ba18117cd4"", ""patch"": ""@@ -1019,6 +1019,12 @@ void test_re()\n \n   // Test case for issue #324\n   assert_true_regexp(\""whatever|   x.   x\"", \""   xy   x\"", \""   xy   x\"");\n+\n+  // test case for issue #503, \\x without two following hex-digits\n+  assert_regexp_syntax_error(\""\\\\x0\"");\n+  assert_regexp_syntax_error(\""\\\\x\"");\n+\n+  assert_regexp_syntax_error(\""\\\\xxy\"");\n }\n \n ""}"," int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

         if (! YY_CURRENT_BUFFER)
             return 0;
     
    return yylineno;
}
"," int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
         if (! YY_CURRENT_BUFFER)
             return 0;
     
    return yylineno;
}
",C,"
",,,"@@ -190,7 +190,7 @@ typedef size_t yy_size_t;
 
     /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
      *       access to the local variable yy_act. Since yyless() is a macro, it would break
-     *       existing scanners that call yyless() from OUTSIDE re_yylex. 
+     *       existing scanners that call yyless() from OUTSIDE re_yylex.
      *       One obvious solution it to make yy_act a global. I tried that, and saw
      *       a 5% performance hit in a non-yylineno scanner, because yy_act is
      *       normally declared as a register variable-- so it is not worth it.
@@ -266,7 +266,7 @@ struct yy_buffer_state
 
     int yy_bs_lineno; /**< The line count. */
     int yy_bs_column; /**< The column count. */
-    
+
 	/* Whether to try to fill the input buffer when we reach the
 	 * end of it.
 	 */
@@ -906,7 +906,7 @@ YY_DECL
 			yy_size_t yyl;
 			for ( yyl = 0; yyl < yyleng; ++yyl )
 				if ( yytext[yyl] == '\n' )
-					   
+					
     do{ yylineno++;
         yycolumn=0;
     }while(0)
@@ -1125,7 +1125,7 @@ YY_RULE_SETUP
   }
   else
   {
-    yyerror(yyscanner, lex_env, ""unexpected end of buffer"");
+    yyerror(yyscanner, lex_env, ""illegal escape sequence"");
     yyterminate();
   }
 }
@@ -1180,7 +1180,7 @@ YY_RULE_SETUP
   {
     if (!read_escaped_char(yyscanner, &end))
     {
-      yyerror(yyscanner, lex_env, ""unexpected end of buffer"");
+      yyerror(yyscanner, lex_env, ""illegal escape sequence"");
       yyterminate();
     }
   }
@@ -1292,7 +1292,7 @@ YY_RULE_SETUP
   }
   else
   {
-    yyerror(yyscanner, lex_env, ""unexpected end of buffer"");
+    yyerror(yyscanner, lex_env, ""illegal escape sequence"");
     yyterminate();
   }
 }
@@ -1763,7 +1763,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 	yyg->yy_hold_char = *++yyg->yy_c_buf_p;
 
 	if ( c == '\n' )
-		   
+		
     do{ yylineno++;
         yycolumn=0;
     }while(0)
@@ -2018,9 +2018,9 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)
 								, yyscanner);
 		if ( ! yyg->yy_buffer_stack )
 			YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );
-								  
+
 		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-				
+
 		yyg->yy_buffer_stack_max = num_to_alloc;
 		yyg->yy_buffer_stack_top = 0;
 		return;
@@ -2049,7 +2049,7 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)
  * @param base the character buffer
  * @param size the size in bytes of the character buffer
  * @param yyscanner The scanner object.
- * @return the newly allocated buffer state object. 
+ * @return the newly allocated buffer state object.
  */
 YY_BUFFER_STATE re_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
 {
@@ -2177,7 +2177,7 @@ YY_EXTRA_TYPE re_yyget_extra  (yyscan_t yyscanner)
 int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    
+
         if (! YY_CURRENT_BUFFER)
             return 0;
     
@@ -2190,7 +2190,7 @@ int re_yyget_lineno  (yyscan_t yyscanner)
 int re_yyget_column  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    
+
         if (! YY_CURRENT_BUFFER)
             return 0;
     
@@ -2365,20 +2365,20 @@ int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )
         errno = EINVAL;
         return 1;
     }
-	
+
     *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );
-	
+
     if (*ptr_yy_globals == NULL){
         errno = ENOMEM;
         return 1;
     }
-    
+
     /* By setting to 0xAA, we expose bugs in
     yy_init_globals. Leave at 0x00 for releases. */
     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
-    
+
     re_yyset_extra (yy_user_defined, *ptr_yy_globals);
-    
+
     return yy_init_globals ( *ptr_yy_globals );
 }
 
@@ -2568,19 +2568,19 @@ int read_escaped_char(
   text[0] = '\\';
   text[1] = RE_YY_INPUT(yyscanner);
 
-  if (text[1] == EOF)
+  if (text[1] == EOF || text[1] == 0)
     return 0;
 
   if (text[1] == 'x')
   {
     text[2] = RE_YY_INPUT(yyscanner);
 
-    if (text[2] == EOF)
+    if (!isxdigit(text[2]))
       return 0;
 
     text[3] = RE_YY_INPUT(yyscanner);
 
-    if (text[3] == EOF)
+    if (!isxdigit(text[3]))
       return 0;
   }
 ",yara,3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,d68cd32fabb0b7703ada455dfa5b38ef03132907,1," int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
//flaw_line_below:
    
//fix_flaw_line_below:
//
         if (! YY_CURRENT_BUFFER)
             return 0;
     
    return yylineno;
}
"
3921,181657,,Remote,Not required,Partial,CVE-2016-10210,https://www.cvedetails.com/cve/CVE-2016-10210/,CWE-476,Low,,,,2017-04-03,5.0,libyara/lexer.l in YARA 3.5.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted rule that is mishandled in the yy_get_next_buffer function.,2017-05-01,DoS ,5,https://github.com/VirusTotal/yara/commit/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,"re_lexer: Make reading escape sequences more robust (#586)

* Add test for issue #503

* re_lexer: Make reading escape sequences more robust

This commit fixes parsing incomplete escape sequences at the end of a
regular expression and parsing things like \xxy (invalid hex digits)
which before were silently turned into (char)255.

Close #503

* Update re_lexer.c",0,libyara/re_lexer.c,"{""sha"": ""f0940a8b2095ec57e12e1ab40a860b4e00113996"", ""filename"": ""libyara/re_lexer.c"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 20, ""changes"": 40, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.c"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.c"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/libyara/re_lexer.c?ref=3119b232c9c453c98d8fa8b6ae4e37ba18117cd4"", ""patch"": ""@@ -190,7 +190,7 @@ typedef size_t yy_size_t;\n \n     /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires\n      *       access to the local variable yy_act. Since yyless() is a macro, it would break\n-     *       existing scanners that call yyless() from OUTSIDE re_yylex. \n+     *       existing scanners that call yyless() from OUTSIDE re_yylex.\n      *       One obvious solution it to make yy_act a global. I tried that, and saw\n      *       a 5% performance hit in a non-yylineno scanner, because yy_act is\n      *       normally declared as a register variable-- so it is not worth it.\n@@ -266,7 +266,7 @@ struct yy_buffer_state\n \n     int yy_bs_lineno; /**< The line count. */\n     int yy_bs_column; /**< The column count. */\n-    \n+\n \t/* Whether to try to fill the input buffer when we reach the\n \t * end of it.\n \t */\n@@ -906,7 +906,7 @@ YY_DECL\n \t\t\tyy_size_t yyl;\n \t\t\tfor ( yyl = 0; yyl < yyleng; ++yyl )\n \t\t\t\tif ( yytext[yyl] == '\\n' )\n-\t\t\t\t\t   \n+\t\t\t\t\t\n     do{ yylineno++;\n         yycolumn=0;\n     }while(0)\n@@ -1125,7 +1125,7 @@ YY_RULE_SETUP\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -1180,7 +1180,7 @@ YY_RULE_SETUP\n   {\n     if (!read_escaped_char(yyscanner, &end))\n     {\n-      yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+      yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n       yyterminate();\n     }\n   }\n@@ -1292,7 +1292,7 @@ YY_RULE_SETUP\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -1763,7 +1763,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)\n \tyyg->yy_hold_char = *++yyg->yy_c_buf_p;\n \n \tif ( c == '\\n' )\n-\t\t   \n+\t\t\n     do{ yylineno++;\n         yycolumn=0;\n     }while(0)\n@@ -2018,9 +2018,9 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)\n \t\t\t\t\t\t\t\t, yyscanner);\n \t\tif ( ! yyg->yy_buffer_stack )\n \t\t\tYY_FATAL_ERROR( \""out of dynamic memory in re_yyensure_buffer_stack()\"" );\n-\t\t\t\t\t\t\t\t  \n+\n \t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n-\t\t\t\t\n+\n \t\tyyg->yy_buffer_stack_max = num_to_alloc;\n \t\tyyg->yy_buffer_stack_top = 0;\n \t\treturn;\n@@ -2049,7 +2049,7 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)\n  * @param base the character buffer\n  * @param size the size in bytes of the character buffer\n  * @param yyscanner The scanner object.\n- * @return the newly allocated buffer state object. \n+ * @return the newly allocated buffer state object.\n  */\n YY_BUFFER_STATE re_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)\n {\n@@ -2177,7 +2177,7 @@ YY_EXTRA_TYPE re_yyget_extra  (yyscan_t yyscanner)\n int re_yyget_lineno  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    \n+\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n@@ -2190,7 +2190,7 @@ int re_yyget_lineno  (yyscan_t yyscanner)\n int re_yyget_column  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    \n+\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n@@ -2365,20 +2365,20 @@ int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )\n         errno = EINVAL;\n         return 1;\n     }\n-\t\n+\n     *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n-\t\n+\n     if (*ptr_yy_globals == NULL){\n         errno = ENOMEM;\n         return 1;\n     }\n-    \n+\n     /* By setting to 0xAA, we expose bugs in\n     yy_init_globals. Leave at 0x00 for releases. */\n     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n-    \n+\n     re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n-    \n+\n     return yy_init_globals ( *ptr_yy_globals );\n }\n \n@@ -2568,19 +2568,19 @@ int read_escaped_char(\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n-  if (text[1] == EOF)\n+  if (text[1] == EOF || text[1] == 0)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n-    if (text[2] == EOF)\n+    if (!isxdigit(text[2]))\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n-    if (text[3] == EOF)\n+    if (!isxdigit(text[3]))\n       return 0;\n   }\n ""}<_**next**_>{""sha"": ""9e0b00549169e599fd87a4a6db9b893b4cde3d29"", ""filename"": ""libyara/re_lexer.l"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.l"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.l"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/libyara/re_lexer.l?ref=3119b232c9c453c98d8fa8b6ae4e37ba18117cd4"", ""patch"": ""@@ -261,7 +261,7 @@ hex_digit     [0-9a-fA-F]\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -312,7 +312,7 @@ hex_digit     [0-9a-fA-F]\n   {\n     if (!read_escaped_char(yyscanner, &end))\n     {\n-      yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+      yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n       yyterminate();\n     }\n   }\n@@ -410,7 +410,7 @@ hex_digit     [0-9a-fA-F]\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -524,19 +524,19 @@ int read_escaped_char(\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n-  if (text[1] == EOF)\n+  if (text[1] == EOF || text[1] == 0)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n-    if (text[2] == EOF)\n+    if (!isxdigit(text[2]))\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n-    if (text[3] == EOF)\n+    if (!isxdigit(text[3]))\n       return 0;\n   }\n ""}<_**next**_>{""sha"": ""556e34526393dad109cfdedb86bdb09e872a077d"", ""filename"": ""tests/test-rules.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/tests/test-rules.c"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/tests/test-rules.c"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/tests/test-rules.c?ref=3119b232c9c453c98d8fa8b6ae4e37ba18117cd4"", ""patch"": ""@@ -1019,6 +1019,12 @@ void test_re()\n \n   // Test case for issue #324\n   assert_true_regexp(\""whatever|   x.   x\"", \""   xy   x\"", \""   xy   x\"");\n+\n+  // test case for issue #503, \\x without two following hex-digits\n+  assert_regexp_syntax_error(\""\\\\x0\"");\n+  assert_regexp_syntax_error(\""\\\\x\"");\n+\n+  assert_regexp_syntax_error(\""\\\\xxy\"");\n }\n \n ""}","int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )

{
    struct yyguts_t dummy_yyguts;

    re_yyset_extra (yy_user_defined, &dummy_yyguts);

    if (ptr_yy_globals == NULL){
         errno = EINVAL;
         return 1;
     }

     *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );

     if (*ptr_yy_globals == NULL){
         errno = ENOMEM;
         return 1;
     }

     /* By setting to 0xAA, we expose bugs in
     yy_init_globals. Leave at 0x00 for releases. */
     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));

     re_yyset_extra (yy_user_defined, *ptr_yy_globals);

     return yy_init_globals ( *ptr_yy_globals );
 }
","int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )

{
    struct yyguts_t dummy_yyguts;

    re_yyset_extra (yy_user_defined, &dummy_yyguts);

    if (ptr_yy_globals == NULL){
         errno = EINVAL;
         return 1;
     }
     *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );
     if (*ptr_yy_globals == NULL){
         errno = ENOMEM;
         return 1;
     }
     /* By setting to 0xAA, we expose bugs in
     yy_init_globals. Leave at 0x00 for releases. */
     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
     re_yyset_extra (yy_user_defined, *ptr_yy_globals);
     return yy_init_globals ( *ptr_yy_globals );
 }
",C,"




",,,"@@ -190,7 +190,7 @@ typedef size_t yy_size_t;
 
     /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
      *       access to the local variable yy_act. Since yyless() is a macro, it would break
-     *       existing scanners that call yyless() from OUTSIDE re_yylex. 
+     *       existing scanners that call yyless() from OUTSIDE re_yylex.
      *       One obvious solution it to make yy_act a global. I tried that, and saw
      *       a 5% performance hit in a non-yylineno scanner, because yy_act is
      *       normally declared as a register variable-- so it is not worth it.
@@ -266,7 +266,7 @@ struct yy_buffer_state
 
     int yy_bs_lineno; /**< The line count. */
     int yy_bs_column; /**< The column count. */
-    
+
 	/* Whether to try to fill the input buffer when we reach the
 	 * end of it.
 	 */
@@ -906,7 +906,7 @@ YY_DECL
 			yy_size_t yyl;
 			for ( yyl = 0; yyl < yyleng; ++yyl )
 				if ( yytext[yyl] == '\n' )
-					   
+					
     do{ yylineno++;
         yycolumn=0;
     }while(0)
@@ -1125,7 +1125,7 @@ YY_RULE_SETUP
   }
   else
   {
-    yyerror(yyscanner, lex_env, ""unexpected end of buffer"");
+    yyerror(yyscanner, lex_env, ""illegal escape sequence"");
     yyterminate();
   }
 }
@@ -1180,7 +1180,7 @@ YY_RULE_SETUP
   {
     if (!read_escaped_char(yyscanner, &end))
     {
-      yyerror(yyscanner, lex_env, ""unexpected end of buffer"");
+      yyerror(yyscanner, lex_env, ""illegal escape sequence"");
       yyterminate();
     }
   }
@@ -1292,7 +1292,7 @@ YY_RULE_SETUP
   }
   else
   {
-    yyerror(yyscanner, lex_env, ""unexpected end of buffer"");
+    yyerror(yyscanner, lex_env, ""illegal escape sequence"");
     yyterminate();
   }
 }
@@ -1763,7 +1763,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 	yyg->yy_hold_char = *++yyg->yy_c_buf_p;
 
 	if ( c == '\n' )
-		   
+		
     do{ yylineno++;
         yycolumn=0;
     }while(0)
@@ -2018,9 +2018,9 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)
 								, yyscanner);
 		if ( ! yyg->yy_buffer_stack )
 			YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );
-								  
+
 		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-				
+
 		yyg->yy_buffer_stack_max = num_to_alloc;
 		yyg->yy_buffer_stack_top = 0;
 		return;
@@ -2049,7 +2049,7 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)
  * @param base the character buffer
  * @param size the size in bytes of the character buffer
  * @param yyscanner The scanner object.
- * @return the newly allocated buffer state object. 
+ * @return the newly allocated buffer state object.
  */
 YY_BUFFER_STATE re_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
 {
@@ -2177,7 +2177,7 @@ YY_EXTRA_TYPE re_yyget_extra  (yyscan_t yyscanner)
 int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    
+
         if (! YY_CURRENT_BUFFER)
             return 0;
     
@@ -2190,7 +2190,7 @@ int re_yyget_lineno  (yyscan_t yyscanner)
 int re_yyget_column  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    
+
         if (! YY_CURRENT_BUFFER)
             return 0;
     
@@ -2365,20 +2365,20 @@ int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )
         errno = EINVAL;
         return 1;
     }
-	
+
     *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );
-	
+
     if (*ptr_yy_globals == NULL){
         errno = ENOMEM;
         return 1;
     }
-    
+
     /* By setting to 0xAA, we expose bugs in
     yy_init_globals. Leave at 0x00 for releases. */
     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
-    
+
     re_yyset_extra (yy_user_defined, *ptr_yy_globals);
-    
+
     return yy_init_globals ( *ptr_yy_globals );
 }
 
@@ -2568,19 +2568,19 @@ int read_escaped_char(
   text[0] = '\\';
   text[1] = RE_YY_INPUT(yyscanner);
 
-  if (text[1] == EOF)
+  if (text[1] == EOF || text[1] == 0)
     return 0;
 
   if (text[1] == 'x')
   {
     text[2] = RE_YY_INPUT(yyscanner);
 
-    if (text[2] == EOF)
+    if (!isxdigit(text[2]))
       return 0;
 
     text[3] = RE_YY_INPUT(yyscanner);
 
-    if (text[3] == EOF)
+    if (!isxdigit(text[3]))
       return 0;
   }
 ",yara,3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,d68cd32fabb0b7703ada455dfa5b38ef03132907,1,"int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )

{
    struct yyguts_t dummy_yyguts;

    re_yyset_extra (yy_user_defined, &dummy_yyguts);

    if (ptr_yy_globals == NULL){
         errno = EINVAL;
         return 1;
     }
//flaw_line_below:
	
//fix_flaw_line_below:
//
     *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );
//flaw_line_below:
	
//fix_flaw_line_below:
//
     if (*ptr_yy_globals == NULL){
         errno = ENOMEM;
         return 1;
     }
//flaw_line_below:
    
//fix_flaw_line_below:
//
     /* By setting to 0xAA, we expose bugs in
     yy_init_globals. Leave at 0x00 for releases. */
     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
//flaw_line_below:
    
//fix_flaw_line_below:
//
     re_yyset_extra (yy_user_defined, *ptr_yy_globals);
//flaw_line_below:
    
//fix_flaw_line_below:
//
     return yy_init_globals ( *ptr_yy_globals );
 }
"
3922,181658,,Remote,Not required,Partial,CVE-2016-10210,https://www.cvedetails.com/cve/CVE-2016-10210/,CWE-476,Low,,,,2017-04-03,5.0,libyara/lexer.l in YARA 3.5.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted rule that is mishandled in the yy_get_next_buffer function.,2017-05-01,DoS ,3,https://github.com/VirusTotal/yara/commit/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,"re_lexer: Make reading escape sequences more robust (#586)

* Add test for issue #503

* re_lexer: Make reading escape sequences more robust

This commit fixes parsing incomplete escape sequences at the end of a
regular expression and parsing things like \xxy (invalid hex digits)
which before were silently turned into (char)255.

Close #503

* Update re_lexer.c",3,libyara/re_lexer.c,"{""sha"": ""f0940a8b2095ec57e12e1ab40a860b4e00113996"", ""filename"": ""libyara/re_lexer.c"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 20, ""changes"": 40, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.c"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.c"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/libyara/re_lexer.c?ref=3119b232c9c453c98d8fa8b6ae4e37ba18117cd4"", ""patch"": ""@@ -190,7 +190,7 @@ typedef size_t yy_size_t;\n \n     /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires\n      *       access to the local variable yy_act. Since yyless() is a macro, it would break\n-     *       existing scanners that call yyless() from OUTSIDE re_yylex. \n+     *       existing scanners that call yyless() from OUTSIDE re_yylex.\n      *       One obvious solution it to make yy_act a global. I tried that, and saw\n      *       a 5% performance hit in a non-yylineno scanner, because yy_act is\n      *       normally declared as a register variable-- so it is not worth it.\n@@ -266,7 +266,7 @@ struct yy_buffer_state\n \n     int yy_bs_lineno; /**< The line count. */\n     int yy_bs_column; /**< The column count. */\n-    \n+\n \t/* Whether to try to fill the input buffer when we reach the\n \t * end of it.\n \t */\n@@ -906,7 +906,7 @@ YY_DECL\n \t\t\tyy_size_t yyl;\n \t\t\tfor ( yyl = 0; yyl < yyleng; ++yyl )\n \t\t\t\tif ( yytext[yyl] == '\\n' )\n-\t\t\t\t\t   \n+\t\t\t\t\t\n     do{ yylineno++;\n         yycolumn=0;\n     }while(0)\n@@ -1125,7 +1125,7 @@ YY_RULE_SETUP\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -1180,7 +1180,7 @@ YY_RULE_SETUP\n   {\n     if (!read_escaped_char(yyscanner, &end))\n     {\n-      yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+      yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n       yyterminate();\n     }\n   }\n@@ -1292,7 +1292,7 @@ YY_RULE_SETUP\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -1763,7 +1763,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)\n \tyyg->yy_hold_char = *++yyg->yy_c_buf_p;\n \n \tif ( c == '\\n' )\n-\t\t   \n+\t\t\n     do{ yylineno++;\n         yycolumn=0;\n     }while(0)\n@@ -2018,9 +2018,9 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)\n \t\t\t\t\t\t\t\t, yyscanner);\n \t\tif ( ! yyg->yy_buffer_stack )\n \t\t\tYY_FATAL_ERROR( \""out of dynamic memory in re_yyensure_buffer_stack()\"" );\n-\t\t\t\t\t\t\t\t  \n+\n \t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n-\t\t\t\t\n+\n \t\tyyg->yy_buffer_stack_max = num_to_alloc;\n \t\tyyg->yy_buffer_stack_top = 0;\n \t\treturn;\n@@ -2049,7 +2049,7 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)\n  * @param base the character buffer\n  * @param size the size in bytes of the character buffer\n  * @param yyscanner The scanner object.\n- * @return the newly allocated buffer state object. \n+ * @return the newly allocated buffer state object.\n  */\n YY_BUFFER_STATE re_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)\n {\n@@ -2177,7 +2177,7 @@ YY_EXTRA_TYPE re_yyget_extra  (yyscan_t yyscanner)\n int re_yyget_lineno  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    \n+\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n@@ -2190,7 +2190,7 @@ int re_yyget_lineno  (yyscan_t yyscanner)\n int re_yyget_column  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    \n+\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n@@ -2365,20 +2365,20 @@ int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )\n         errno = EINVAL;\n         return 1;\n     }\n-\t\n+\n     *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n-\t\n+\n     if (*ptr_yy_globals == NULL){\n         errno = ENOMEM;\n         return 1;\n     }\n-    \n+\n     /* By setting to 0xAA, we expose bugs in\n     yy_init_globals. Leave at 0x00 for releases. */\n     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n-    \n+\n     re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n-    \n+\n     return yy_init_globals ( *ptr_yy_globals );\n }\n \n@@ -2568,19 +2568,19 @@ int read_escaped_char(\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n-  if (text[1] == EOF)\n+  if (text[1] == EOF || text[1] == 0)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n-    if (text[2] == EOF)\n+    if (!isxdigit(text[2]))\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n-    if (text[3] == EOF)\n+    if (!isxdigit(text[3]))\n       return 0;\n   }\n ""}<_**next**_>{""sha"": ""9e0b00549169e599fd87a4a6db9b893b4cde3d29"", ""filename"": ""libyara/re_lexer.l"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.l"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.l"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/libyara/re_lexer.l?ref=3119b232c9c453c98d8fa8b6ae4e37ba18117cd4"", ""patch"": ""@@ -261,7 +261,7 @@ hex_digit     [0-9a-fA-F]\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -312,7 +312,7 @@ hex_digit     [0-9a-fA-F]\n   {\n     if (!read_escaped_char(yyscanner, &end))\n     {\n-      yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+      yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n       yyterminate();\n     }\n   }\n@@ -410,7 +410,7 @@ hex_digit     [0-9a-fA-F]\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -524,19 +524,19 @@ int read_escaped_char(\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n-  if (text[1] == EOF)\n+  if (text[1] == EOF || text[1] == 0)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n-    if (text[2] == EOF)\n+    if (!isxdigit(text[2]))\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n-    if (text[3] == EOF)\n+    if (!isxdigit(text[3]))\n       return 0;\n   }\n ""}<_**next**_>{""sha"": ""556e34526393dad109cfdedb86bdb09e872a077d"", ""filename"": ""tests/test-rules.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/tests/test-rules.c"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/tests/test-rules.c"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/tests/test-rules.c?ref=3119b232c9c453c98d8fa8b6ae4e37ba18117cd4"", ""patch"": ""@@ -1019,6 +1019,12 @@ void test_re()\n \n   // Test case for issue #324\n   assert_true_regexp(\""whatever|   x.   x\"", \""   xy   x\"", \""   xy   x\"");\n+\n+  // test case for issue #503, \\x without two following hex-digits\n+  assert_regexp_syntax_error(\""\\\\x0\"");\n+  assert_regexp_syntax_error(\""\\\\x\"");\n+\n+  assert_regexp_syntax_error(\""\\\\xxy\"");\n }\n \n ""}","int read_escaped_char(
    yyscan_t yyscanner,
    uint8_t* escaped_char)
{
  char text[4] = {0, 0, 0, 0};

   text[0] = '\\';
   text[1] = RE_YY_INPUT(yyscanner);
 
  if (text[1] == EOF || text[1] == 0)
     return 0;
 
   if (text[1] == 'x')
   {
     text[2] = RE_YY_INPUT(yyscanner);
 
    if (!isxdigit(text[2]))
       return 0;
 
     text[3] = RE_YY_INPUT(yyscanner);
 
    if (!isxdigit(text[3]))
       return 0;
   }
 
  *escaped_char = escaped_char_value(text);

  return 1;
}
","int read_escaped_char(
    yyscan_t yyscanner,
    uint8_t* escaped_char)
{
  char text[4] = {0, 0, 0, 0};

   text[0] = '\\';
   text[1] = RE_YY_INPUT(yyscanner);
 
  if (text[1] == EOF)
     return 0;
 
   if (text[1] == 'x')
   {
     text[2] = RE_YY_INPUT(yyscanner);
 
    if (text[2] == EOF)
       return 0;
 
     text[3] = RE_YY_INPUT(yyscanner);
 
    if (text[3] == EOF)
       return 0;
   }
 
  *escaped_char = escaped_char_value(text);

  return 1;
}
",C,"  if (text[1] == EOF || text[1] == 0)
    if (!isxdigit(text[2]))
    if (!isxdigit(text[3]))
","  if (text[1] == EOF)
    if (text[2] == EOF)
    if (text[3] == EOF)
",,"@@ -190,7 +190,7 @@ typedef size_t yy_size_t;
 
     /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
      *       access to the local variable yy_act. Since yyless() is a macro, it would break
-     *       existing scanners that call yyless() from OUTSIDE re_yylex. 
+     *       existing scanners that call yyless() from OUTSIDE re_yylex.
      *       One obvious solution it to make yy_act a global. I tried that, and saw
      *       a 5% performance hit in a non-yylineno scanner, because yy_act is
      *       normally declared as a register variable-- so it is not worth it.
@@ -266,7 +266,7 @@ struct yy_buffer_state
 
     int yy_bs_lineno; /**< The line count. */
     int yy_bs_column; /**< The column count. */
-    
+
 	/* Whether to try to fill the input buffer when we reach the
 	 * end of it.
 	 */
@@ -906,7 +906,7 @@ YY_DECL
 			yy_size_t yyl;
 			for ( yyl = 0; yyl < yyleng; ++yyl )
 				if ( yytext[yyl] == '\n' )
-					   
+					
     do{ yylineno++;
         yycolumn=0;
     }while(0)
@@ -1125,7 +1125,7 @@ YY_RULE_SETUP
   }
   else
   {
-    yyerror(yyscanner, lex_env, ""unexpected end of buffer"");
+    yyerror(yyscanner, lex_env, ""illegal escape sequence"");
     yyterminate();
   }
 }
@@ -1180,7 +1180,7 @@ YY_RULE_SETUP
   {
     if (!read_escaped_char(yyscanner, &end))
     {
-      yyerror(yyscanner, lex_env, ""unexpected end of buffer"");
+      yyerror(yyscanner, lex_env, ""illegal escape sequence"");
       yyterminate();
     }
   }
@@ -1292,7 +1292,7 @@ YY_RULE_SETUP
   }
   else
   {
-    yyerror(yyscanner, lex_env, ""unexpected end of buffer"");
+    yyerror(yyscanner, lex_env, ""illegal escape sequence"");
     yyterminate();
   }
 }
@@ -1763,7 +1763,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 	yyg->yy_hold_char = *++yyg->yy_c_buf_p;
 
 	if ( c == '\n' )
-		   
+		
     do{ yylineno++;
         yycolumn=0;
     }while(0)
@@ -2018,9 +2018,9 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)
 								, yyscanner);
 		if ( ! yyg->yy_buffer_stack )
 			YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );
-								  
+
 		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-				
+
 		yyg->yy_buffer_stack_max = num_to_alloc;
 		yyg->yy_buffer_stack_top = 0;
 		return;
@@ -2049,7 +2049,7 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)
  * @param base the character buffer
  * @param size the size in bytes of the character buffer
  * @param yyscanner The scanner object.
- * @return the newly allocated buffer state object. 
+ * @return the newly allocated buffer state object.
  */
 YY_BUFFER_STATE re_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
 {
@@ -2177,7 +2177,7 @@ YY_EXTRA_TYPE re_yyget_extra  (yyscan_t yyscanner)
 int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    
+
         if (! YY_CURRENT_BUFFER)
             return 0;
     
@@ -2190,7 +2190,7 @@ int re_yyget_lineno  (yyscan_t yyscanner)
 int re_yyget_column  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    
+
         if (! YY_CURRENT_BUFFER)
             return 0;
     
@@ -2365,20 +2365,20 @@ int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )
         errno = EINVAL;
         return 1;
     }
-	
+
     *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );
-	
+
     if (*ptr_yy_globals == NULL){
         errno = ENOMEM;
         return 1;
     }
-    
+
     /* By setting to 0xAA, we expose bugs in
     yy_init_globals. Leave at 0x00 for releases. */
     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
-    
+
     re_yyset_extra (yy_user_defined, *ptr_yy_globals);
-    
+
     return yy_init_globals ( *ptr_yy_globals );
 }
 
@@ -2568,19 +2568,19 @@ int read_escaped_char(
   text[0] = '\\';
   text[1] = RE_YY_INPUT(yyscanner);
 
-  if (text[1] == EOF)
+  if (text[1] == EOF || text[1] == 0)
     return 0;
 
   if (text[1] == 'x')
   {
     text[2] = RE_YY_INPUT(yyscanner);
 
-    if (text[2] == EOF)
+    if (!isxdigit(text[2]))
       return 0;
 
     text[3] = RE_YY_INPUT(yyscanner);
 
-    if (text[3] == EOF)
+    if (!isxdigit(text[3]))
       return 0;
   }
 ",yara,3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,d68cd32fabb0b7703ada455dfa5b38ef03132907,1,"int read_escaped_char(
    yyscan_t yyscanner,
    uint8_t* escaped_char)
{
  char text[4] = {0, 0, 0, 0};

   text[0] = '\\';
   text[1] = RE_YY_INPUT(yyscanner);
 
//flaw_line_below:
  if (text[1] == EOF)
//fix_flaw_line_below:
//  if (text[1] == EOF || text[1] == 0)
     return 0;
 
   if (text[1] == 'x')
   {
     text[2] = RE_YY_INPUT(yyscanner);
 
//flaw_line_below:
    if (text[2] == EOF)
//fix_flaw_line_below:
//    if (!isxdigit(text[2]))
       return 0;
 
     text[3] = RE_YY_INPUT(yyscanner);
 
//flaw_line_below:
    if (text[3] == EOF)
//fix_flaw_line_below:
//    if (!isxdigit(text[3]))
       return 0;
   }
 
  *escaped_char = escaped_char_value(text);

  return 1;
}
"
3923,181659,,Remote,Not required,Partial,CVE-2016-10210,https://www.cvedetails.com/cve/CVE-2016-10210/,CWE-476,Low,,,,2017-04-03,5.0,libyara/lexer.l in YARA 3.5.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted rule that is mishandled in the yy_get_next_buffer function.,2017-05-01,DoS ,1,https://github.com/VirusTotal/yara/commit/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,"re_lexer: Make reading escape sequences more robust (#586)

* Add test for issue #503

* re_lexer: Make reading escape sequences more robust

This commit fixes parsing incomplete escape sequences at the end of a
regular expression and parsing things like \xxy (invalid hex digits)
which before were silently turned into (char)255.

Close #503

* Update re_lexer.c",0,libyara/re_lexer.c,"{""sha"": ""f0940a8b2095ec57e12e1ab40a860b4e00113996"", ""filename"": ""libyara/re_lexer.c"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 20, ""changes"": 40, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.c"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.c"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/libyara/re_lexer.c?ref=3119b232c9c453c98d8fa8b6ae4e37ba18117cd4"", ""patch"": ""@@ -190,7 +190,7 @@ typedef size_t yy_size_t;\n \n     /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires\n      *       access to the local variable yy_act. Since yyless() is a macro, it would break\n-     *       existing scanners that call yyless() from OUTSIDE re_yylex. \n+     *       existing scanners that call yyless() from OUTSIDE re_yylex.\n      *       One obvious solution it to make yy_act a global. I tried that, and saw\n      *       a 5% performance hit in a non-yylineno scanner, because yy_act is\n      *       normally declared as a register variable-- so it is not worth it.\n@@ -266,7 +266,7 @@ struct yy_buffer_state\n \n     int yy_bs_lineno; /**< The line count. */\n     int yy_bs_column; /**< The column count. */\n-    \n+\n \t/* Whether to try to fill the input buffer when we reach the\n \t * end of it.\n \t */\n@@ -906,7 +906,7 @@ YY_DECL\n \t\t\tyy_size_t yyl;\n \t\t\tfor ( yyl = 0; yyl < yyleng; ++yyl )\n \t\t\t\tif ( yytext[yyl] == '\\n' )\n-\t\t\t\t\t   \n+\t\t\t\t\t\n     do{ yylineno++;\n         yycolumn=0;\n     }while(0)\n@@ -1125,7 +1125,7 @@ YY_RULE_SETUP\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -1180,7 +1180,7 @@ YY_RULE_SETUP\n   {\n     if (!read_escaped_char(yyscanner, &end))\n     {\n-      yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+      yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n       yyterminate();\n     }\n   }\n@@ -1292,7 +1292,7 @@ YY_RULE_SETUP\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -1763,7 +1763,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)\n \tyyg->yy_hold_char = *++yyg->yy_c_buf_p;\n \n \tif ( c == '\\n' )\n-\t\t   \n+\t\t\n     do{ yylineno++;\n         yycolumn=0;\n     }while(0)\n@@ -2018,9 +2018,9 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)\n \t\t\t\t\t\t\t\t, yyscanner);\n \t\tif ( ! yyg->yy_buffer_stack )\n \t\t\tYY_FATAL_ERROR( \""out of dynamic memory in re_yyensure_buffer_stack()\"" );\n-\t\t\t\t\t\t\t\t  \n+\n \t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n-\t\t\t\t\n+\n \t\tyyg->yy_buffer_stack_max = num_to_alloc;\n \t\tyyg->yy_buffer_stack_top = 0;\n \t\treturn;\n@@ -2049,7 +2049,7 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)\n  * @param base the character buffer\n  * @param size the size in bytes of the character buffer\n  * @param yyscanner The scanner object.\n- * @return the newly allocated buffer state object. \n+ * @return the newly allocated buffer state object.\n  */\n YY_BUFFER_STATE re_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)\n {\n@@ -2177,7 +2177,7 @@ YY_EXTRA_TYPE re_yyget_extra  (yyscan_t yyscanner)\n int re_yyget_lineno  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    \n+\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n@@ -2190,7 +2190,7 @@ int re_yyget_lineno  (yyscan_t yyscanner)\n int re_yyget_column  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    \n+\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n@@ -2365,20 +2365,20 @@ int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )\n         errno = EINVAL;\n         return 1;\n     }\n-\t\n+\n     *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n-\t\n+\n     if (*ptr_yy_globals == NULL){\n         errno = ENOMEM;\n         return 1;\n     }\n-    \n+\n     /* By setting to 0xAA, we expose bugs in\n     yy_init_globals. Leave at 0x00 for releases. */\n     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n-    \n+\n     re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n-    \n+\n     return yy_init_globals ( *ptr_yy_globals );\n }\n \n@@ -2568,19 +2568,19 @@ int read_escaped_char(\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n-  if (text[1] == EOF)\n+  if (text[1] == EOF || text[1] == 0)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n-    if (text[2] == EOF)\n+    if (!isxdigit(text[2]))\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n-    if (text[3] == EOF)\n+    if (!isxdigit(text[3]))\n       return 0;\n   }\n ""}<_**next**_>{""sha"": ""9e0b00549169e599fd87a4a6db9b893b4cde3d29"", ""filename"": ""libyara/re_lexer.l"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.l"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/libyara/re_lexer.l"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/libyara/re_lexer.l?ref=3119b232c9c453c98d8fa8b6ae4e37ba18117cd4"", ""patch"": ""@@ -261,7 +261,7 @@ hex_digit     [0-9a-fA-F]\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -312,7 +312,7 @@ hex_digit     [0-9a-fA-F]\n   {\n     if (!read_escaped_char(yyscanner, &end))\n     {\n-      yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+      yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n       yyterminate();\n     }\n   }\n@@ -410,7 +410,7 @@ hex_digit     [0-9a-fA-F]\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \""unexpected end of buffer\"");\n+    yyerror(yyscanner, lex_env, \""illegal escape sequence\"");\n     yyterminate();\n   }\n }\n@@ -524,19 +524,19 @@ int read_escaped_char(\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n-  if (text[1] == EOF)\n+  if (text[1] == EOF || text[1] == 0)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n-    if (text[2] == EOF)\n+    if (!isxdigit(text[2]))\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n-    if (text[3] == EOF)\n+    if (!isxdigit(text[3]))\n       return 0;\n   }\n ""}<_**next**_>{""sha"": ""556e34526393dad109cfdedb86bdb09e872a077d"", ""filename"": ""tests/test-rules.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/tests/test-rules.c"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/tests/test-rules.c"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/tests/test-rules.c?ref=3119b232c9c453c98d8fa8b6ae4e37ba18117cd4"", ""patch"": ""@@ -1019,6 +1019,12 @@ void test_re()\n \n   // Test case for issue #324\n   assert_true_regexp(\""whatever|   x.   x\"", \""   xy   x\"", \""   xy   x\"");\n+\n+  // test case for issue #503, \\x without two following hex-digits\n+  assert_regexp_syntax_error(\""\\\\x0\"");\n+  assert_regexp_syntax_error(\""\\\\x\"");\n+\n+  assert_regexp_syntax_error(\""\\\\xxy\"");\n }\n \n ""}","    static int yyinput (yyscan_t yyscanner)
#else
    static int input  (yyscan_t yyscanner)
#endif

{
	int c;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	*yyg->yy_c_buf_p = yyg->yy_hold_char;

	if ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			/* This was really a NUL. */
			*yyg->yy_c_buf_p = '\0';

		else
			{ /* need more input */
			yy_size_t offset = yyg->yy_c_buf_p - yyg->yytext_ptr;
			++yyg->yy_c_buf_p;

			switch ( yy_get_next_buffer( yyscanner ) )
				{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					re_yyrestart(yyin ,yyscanner);

					/*FALLTHROUGH*/

				case EOB_ACT_END_OF_FILE:
					{
					if ( re_yywrap(yyscanner ) )
						return EOF;

					if ( ! yyg->yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput(yyscanner);
#else
					return input(yyscanner);
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					yyg->yy_c_buf_p = yyg->yytext_ptr + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) yyg->yy_c_buf_p;	/* cast for 8-bit char's */
	*yyg->yy_c_buf_p = '\0';	/* preserve yytext */
 	yyg->yy_hold_char = *++yyg->yy_c_buf_p;
 
 	if ( c == '\n' )
		
     do{ yylineno++;
         yycolumn=0;
     }while(0)
;

	return c;
}
","    static int yyinput (yyscan_t yyscanner)
#else
    static int input  (yyscan_t yyscanner)
#endif

{
	int c;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	*yyg->yy_c_buf_p = yyg->yy_hold_char;

	if ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			/* This was really a NUL. */
			*yyg->yy_c_buf_p = '\0';

		else
			{ /* need more input */
			yy_size_t offset = yyg->yy_c_buf_p - yyg->yytext_ptr;
			++yyg->yy_c_buf_p;

			switch ( yy_get_next_buffer( yyscanner ) )
				{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					re_yyrestart(yyin ,yyscanner);

					/*FALLTHROUGH*/

				case EOB_ACT_END_OF_FILE:
					{
					if ( re_yywrap(yyscanner ) )
						return EOF;

					if ( ! yyg->yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput(yyscanner);
#else
					return input(yyscanner);
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					yyg->yy_c_buf_p = yyg->yytext_ptr + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) yyg->yy_c_buf_p;	/* cast for 8-bit char's */
	*yyg->yy_c_buf_p = '\0';	/* preserve yytext */
 	yyg->yy_hold_char = *++yyg->yy_c_buf_p;
 
 	if ( c == '\n' )
     do{ yylineno++;
         yycolumn=0;
     }while(0)
;

	return c;
}
",C,"		
",,,"@@ -190,7 +190,7 @@ typedef size_t yy_size_t;
 
     /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
      *       access to the local variable yy_act. Since yyless() is a macro, it would break
-     *       existing scanners that call yyless() from OUTSIDE re_yylex. 
+     *       existing scanners that call yyless() from OUTSIDE re_yylex.
      *       One obvious solution it to make yy_act a global. I tried that, and saw
      *       a 5% performance hit in a non-yylineno scanner, because yy_act is
      *       normally declared as a register variable-- so it is not worth it.
@@ -266,7 +266,7 @@ struct yy_buffer_state
 
     int yy_bs_lineno; /**< The line count. */
     int yy_bs_column; /**< The column count. */
-    
+
 	/* Whether to try to fill the input buffer when we reach the
 	 * end of it.
 	 */
@@ -906,7 +906,7 @@ YY_DECL
 			yy_size_t yyl;
 			for ( yyl = 0; yyl < yyleng; ++yyl )
 				if ( yytext[yyl] == '\n' )
-					   
+					
     do{ yylineno++;
         yycolumn=0;
     }while(0)
@@ -1125,7 +1125,7 @@ YY_RULE_SETUP
   }
   else
   {
-    yyerror(yyscanner, lex_env, ""unexpected end of buffer"");
+    yyerror(yyscanner, lex_env, ""illegal escape sequence"");
     yyterminate();
   }
 }
@@ -1180,7 +1180,7 @@ YY_RULE_SETUP
   {
     if (!read_escaped_char(yyscanner, &end))
     {
-      yyerror(yyscanner, lex_env, ""unexpected end of buffer"");
+      yyerror(yyscanner, lex_env, ""illegal escape sequence"");
       yyterminate();
     }
   }
@@ -1292,7 +1292,7 @@ YY_RULE_SETUP
   }
   else
   {
-    yyerror(yyscanner, lex_env, ""unexpected end of buffer"");
+    yyerror(yyscanner, lex_env, ""illegal escape sequence"");
     yyterminate();
   }
 }
@@ -1763,7 +1763,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 	yyg->yy_hold_char = *++yyg->yy_c_buf_p;
 
 	if ( c == '\n' )
-		   
+		
     do{ yylineno++;
         yycolumn=0;
     }while(0)
@@ -2018,9 +2018,9 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)
 								, yyscanner);
 		if ( ! yyg->yy_buffer_stack )
 			YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );
-								  
+
 		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-				
+
 		yyg->yy_buffer_stack_max = num_to_alloc;
 		yyg->yy_buffer_stack_top = 0;
 		return;
@@ -2049,7 +2049,7 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)
  * @param base the character buffer
  * @param size the size in bytes of the character buffer
  * @param yyscanner The scanner object.
- * @return the newly allocated buffer state object. 
+ * @return the newly allocated buffer state object.
  */
 YY_BUFFER_STATE re_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
 {
@@ -2177,7 +2177,7 @@ YY_EXTRA_TYPE re_yyget_extra  (yyscan_t yyscanner)
 int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    
+
         if (! YY_CURRENT_BUFFER)
             return 0;
     
@@ -2190,7 +2190,7 @@ int re_yyget_lineno  (yyscan_t yyscanner)
 int re_yyget_column  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    
+
         if (! YY_CURRENT_BUFFER)
             return 0;
     
@@ -2365,20 +2365,20 @@ int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )
         errno = EINVAL;
         return 1;
     }
-	
+
     *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );
-	
+
     if (*ptr_yy_globals == NULL){
         errno = ENOMEM;
         return 1;
     }
-    
+
     /* By setting to 0xAA, we expose bugs in
     yy_init_globals. Leave at 0x00 for releases. */
     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
-    
+
     re_yyset_extra (yy_user_defined, *ptr_yy_globals);
-    
+
     return yy_init_globals ( *ptr_yy_globals );
 }
 
@@ -2568,19 +2568,19 @@ int read_escaped_char(
   text[0] = '\\';
   text[1] = RE_YY_INPUT(yyscanner);
 
-  if (text[1] == EOF)
+  if (text[1] == EOF || text[1] == 0)
     return 0;
 
   if (text[1] == 'x')
   {
     text[2] = RE_YY_INPUT(yyscanner);
 
-    if (text[2] == EOF)
+    if (!isxdigit(text[2]))
       return 0;
 
     text[3] = RE_YY_INPUT(yyscanner);
 
-    if (text[3] == EOF)
+    if (!isxdigit(text[3]))
       return 0;
   }
 ",yara,3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,d68cd32fabb0b7703ada455dfa5b38ef03132907,1,"    static int yyinput (yyscan_t yyscanner)
#else
    static int input  (yyscan_t yyscanner)
#endif

{
	int c;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	*yyg->yy_c_buf_p = yyg->yy_hold_char;

	if ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			/* This was really a NUL. */
			*yyg->yy_c_buf_p = '\0';

		else
			{ /* need more input */
			yy_size_t offset = yyg->yy_c_buf_p - yyg->yytext_ptr;
			++yyg->yy_c_buf_p;

			switch ( yy_get_next_buffer( yyscanner ) )
				{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					re_yyrestart(yyin ,yyscanner);

					/*FALLTHROUGH*/

				case EOB_ACT_END_OF_FILE:
					{
					if ( re_yywrap(yyscanner ) )
						return EOF;

					if ( ! yyg->yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput(yyscanner);
#else
					return input(yyscanner);
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					yyg->yy_c_buf_p = yyg->yytext_ptr + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) yyg->yy_c_buf_p;	/* cast for 8-bit char's */
	*yyg->yy_c_buf_p = '\0';	/* preserve yytext */
 	yyg->yy_hold_char = *++yyg->yy_c_buf_p;
 
 	if ( c == '\n' )
//flaw_line_below:
		   
//fix_flaw_line_below:
//		
     do{ yylineno++;
         yycolumn=0;
     }while(0)
;

	return c;
}
"
3942,181678,,Remote,Not required,Partial,CVE-2016-10189,https://www.cvedetails.com/cve/CVE-2016-10189/,CWE-476,Low,,,,2017-03-14,5.0,BitlBee before 3.5 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) and possibly execute arbitrary code via a file transfer request for a contact that is not in the contact list.,2017-11-03,DoS Exec Code ,1,https://github.com/bitlbee/bitlbee/commit/701ab8129ba9ea64f569daedca9a8603abad740f,701ab8129ba9ea64f569daedca9a8603abad740f,imcb_file_send_start: handle ft attempts from non-existing users,1,protocols/bee_ft.c,"{""sha"": ""916b2e88cfffcc71563c1d46f8bfb3c35d945255"", ""filename"": ""protocols/bee_ft.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/bitlbee/bitlbee/blob/701ab8129ba9ea64f569daedca9a8603abad740f/protocols/bee_ft.c"", ""raw_url"": ""https://github.com/bitlbee/bitlbee/raw/701ab8129ba9ea64f569daedca9a8603abad740f/protocols/bee_ft.c"", ""contents_url"": ""https://api.github.com/repos/bitlbee/bitlbee/contents/protocols/bee_ft.c?ref=701ab8129ba9ea64f569daedca9a8603abad740f"", ""patch"": ""@@ -30,7 +30,7 @@ file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, ch\n \tbee_t *bee = ic->bee;\n \tbee_user_t *bu = bee_user_by_handle(bee, ic, handle);\n \n-\tif (bee->ui->ft_in_start) {\n+\tif (bee->ui->ft_in_start && bu) {\n \t\treturn bee->ui->ft_in_start(bee, bu, file_name, file_size);\n \t} else {\n \t\treturn NULL;""}","file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size)
{
 	bee_t *bee = ic->bee;
 	bee_user_t *bu = bee_user_by_handle(bee, ic, handle);
 
	if (bee->ui->ft_in_start && bu) {
 		return bee->ui->ft_in_start(bee, bu, file_name, file_size);
 	} else {
 		return NULL;
	}
}
","file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size)
{
 	bee_t *bee = ic->bee;
 	bee_user_t *bu = bee_user_by_handle(bee, ic, handle);
 
	if (bee->ui->ft_in_start) {
 		return bee->ui->ft_in_start(bee, bu, file_name, file_size);
 	} else {
 		return NULL;
	}
}
",C,"	if (bee->ui->ft_in_start && bu) {
","	if (bee->ui->ft_in_start) {
",,"@@ -30,7 +30,7 @@ file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, ch
 	bee_t *bee = ic->bee;
 	bee_user_t *bu = bee_user_by_handle(bee, ic, handle);
 
-	if (bee->ui->ft_in_start) {
+	if (bee->ui->ft_in_start && bu) {
 		return bee->ui->ft_in_start(bee, bu, file_name, file_size);
 	} else {
 		return NULL;",bitlbee,701ab8129ba9ea64f569daedca9a8603abad740f,fca468311f1fd9880ed2ae4991b2ecc261fd34d5,1,"file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size)
{
 	bee_t *bee = ic->bee;
 	bee_user_t *bu = bee_user_by_handle(bee, ic, handle);
 
//flaw_line_below:
	if (bee->ui->ft_in_start) {
//fix_flaw_line_below:
//	if (bee->ui->ft_in_start && bu) {
 		return bee->ui->ft_in_start(bee, bu, file_name, file_size);
 	} else {
 		return NULL;
	}
}
"
3949,181685,,Remote,Not required,Partial,CVE-2016-10162,https://www.cvedetails.com/cve/CVE-2016-10162/,CWE-476,Low,,,,2017-01-24,5.0,"The php_wddx_pop_element function in ext/wddx/wddx.c in PHP 7.0.x before 7.0.15 and 7.1.x before 7.1.1 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an inapplicable class name in a wddxPacket XML document, leading to mishandling in a wddx_deserialize call.",2018-05-03,DoS ,20,https://github.com/php/php-src/commit/8d2539fa0faf3f63e1d1e7635347c5b9e777d47b,8d2539fa0faf3f63e1d1e7635347c5b9e777d47b,Fix bug #73831 - NULL Pointer Dereference while unserialize php object,11,ext/wddx/wddx.c,"{""sha"": ""0f8b8b12649627eee5de134bb3fa43af6828d8ef"", ""filename"": ""ext/wddx/tests/bug73831.phpt"", ""status"": ""added"", ""additions"": 23, ""deletions"": 0, ""changes"": 23, ""blob_url"": ""https://github.com/php/php-src/blob/8d2539fa0faf3f63e1d1e7635347c5b9e777d47b/ext/wddx/tests/bug73831.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/8d2539fa0faf3f63e1d1e7635347c5b9e777d47b/ext/wddx/tests/bug73831.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/tests/bug73831.phpt?ref=8d2539fa0faf3f63e1d1e7635347c5b9e777d47b"", ""patch"": ""@@ -0,0 +1,23 @@\n+--TEST--\n+Bug #73831 (NULL Pointer Dereference while unserialize php object)\n+--SKIPIF--\n+<?php if (!extension_loaded(\""wddx\"")) print \""skip\""; ?>\n+--FILE--\n+<?php\n+$xml = <<<EOF\n+<?xml version=\""1.0\"" ?>\n+<wddxPacket version=\""1.0\"">\n+\t<struct>\n+\t\t<var name=\""php_class_name\"">\n+\t\t\t<string>Throwable</string>\n+                </var>\n+        </struct>\n+</wddxPacket>\n+EOF;\n+try {\n+\t$wddx = wddx_deserialize($xml);\n+} catch(Error $e) { echo $e->getMessage(); }\n+?>\n+--EXPECTF--\n+Warning: wddx_deserialize(): Class throwable can not be instantiated in %sbug73831.php on line %d\n+Cannot instantiate interface Throwable""}<_**next**_>{""sha"": ""70c6213407256186aa29ddabae4fe7ead3412e2c"", ""filename"": ""ext/wddx/wddx.c"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 16, ""changes"": 36, ""blob_url"": ""https://github.com/php/php-src/blob/8d2539fa0faf3f63e1d1e7635347c5b9e777d47b/ext/wddx/wddx.c"", ""raw_url"": ""https://github.com/php/php-src/raw/8d2539fa0faf3f63e1d1e7635347c5b9e777d47b/ext/wddx/wddx.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/wddx.c?ref=8d2539fa0faf3f63e1d1e7635347c5b9e777d47b"", ""patch"": ""@@ -908,7 +908,7 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n \n \t\tif (!strcmp((char *)name, EL_BINARY)) {\n \t\t\tzend_string *new_str = NULL;\n-\t\t\t\n+\n \t\t\tif (ZSTR_EMPTY_ALLOC() != Z_STR(ent1->data)) {\n \t\t\t\tnew_str = php_base64_decode(\n \t\t\t\t\t(unsigned char *)Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n@@ -967,22 +967,26 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n \t\t\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \""Class %s can not be unserialized\"", Z_STRVAL(ent1->data));\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t/* Initialize target object */\n-\t\t\t\t\t\t\tobject_init_ex(&obj, pce);\n-\n-\t\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n-\t\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP(obj),\n-\t\t\t\t\t\t\t\t\t\t\tZ_ARRVAL(ent2->data),\n-\t\t\t\t\t\t\t\t\t\t\tzval_add_ref, 0);\n-\n-\t\t\t\t\t\t\tif (incomplete_class) {\n-\t\t\t\t\t\t\t\tphp_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n+\t\t\t\t\t\t\tif (object_init_ex(&obj, pce) != SUCCESS || EG(exception)) {\n+\t\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n+\t\t\t\t\t\t\t\tZVAL_UNDEF(&ent2->data);\n+\t\t\t\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \""Class %s can not be instantiated\"", Z_STRVAL(ent1->data));\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n+\t\t\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP(obj),\n+\t\t\t\t\t\t\t\t\t\t\t\tZ_ARRVAL(ent2->data),\n+\t\t\t\t\t\t\t\t\t\t\t\tzval_add_ref, 0);\n+\n+\t\t\t\t\t\t\t\tif (incomplete_class) {\n+\t\t\t\t\t\t\t\t\tphp_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n+\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t/* Clean up old array entry */\n+\t\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n+\n+\t\t\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n+\t\t\t\t\t\t\t\tZVAL_COPY_VALUE(&ent2->data, &obj);\n \t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t/* Clean up old array entry */\n-\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n-\n-\t\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n-\t\t\t\t\t\t\tZVAL_COPY_VALUE(&ent2->data, &obj);\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\t/* Clean up class name var entry */""}","static void php_wddx_pop_element(void *user_data, const XML_Char *name)
{
	st_entry 			*ent1, *ent2;
	wddx_stack 			*stack = (wddx_stack *)user_data;
	HashTable 			*target_hash;
	zend_class_entry 	*pce;
	zval				obj;

/* OBJECTS_FIXME */
	if (stack->top == 0) {
		return;
	}

	if (!strcmp((char *)name, EL_STRING) || !strcmp((char *)name, EL_NUMBER) ||
		!strcmp((char *)name, EL_BOOLEAN) || !strcmp((char *)name, EL_NULL) ||
	  	!strcmp((char *)name, EL_ARRAY) || !strcmp((char *)name, EL_STRUCT) ||
		!strcmp((char *)name, EL_RECORDSET) || !strcmp((char *)name, EL_BINARY) ||
		!strcmp((char *)name, EL_DATETIME)) {
		wddx_stack_top(stack, (void**)&ent1);

		if (Z_TYPE(ent1->data) == IS_UNDEF) {
			if (stack->top > 1) {
				stack->top--;
				efree(ent1);
			} else {
				stack->done = 1;
			}
			return;
		}
 
 		if (!strcmp((char *)name, EL_BINARY)) {
 			zend_string *new_str = NULL;

 			if (ZSTR_EMPTY_ALLOC() != Z_STR(ent1->data)) {
 				new_str = php_base64_decode(
 					(unsigned char *)Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));
			}

			zval_ptr_dtor(&ent1->data);
			if (new_str) {
				ZVAL_STR(&ent1->data, new_str);
			} else {
				ZVAL_EMPTY_STRING(&ent1->data);
			}
		}

		/* Call __wakeup() method on the object. */
		if (Z_TYPE(ent1->data) == IS_OBJECT) {
			zval fname, retval;

			ZVAL_STRING(&fname, ""__wakeup"");

			call_user_function_ex(NULL, &ent1->data, &fname, &retval, 0, 0, 0, NULL);

			zval_ptr_dtor(&fname);
			zval_ptr_dtor(&retval);
		}

		if (stack->top > 1) {
			stack->top--;
			wddx_stack_top(stack, (void**)&ent2);

			/* if non-existent field */
			if (Z_ISUNDEF(ent2->data)) {
				zval_ptr_dtor(&ent1->data);
				efree(ent1);
				return;
			}

			if (Z_TYPE(ent2->data) == IS_ARRAY || Z_TYPE(ent2->data) == IS_OBJECT) {
				target_hash = HASH_OF(&ent2->data);

				if (ent1->varname) {
					if (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&
						Z_TYPE(ent1->data) == IS_STRING && Z_STRLEN(ent1->data) &&
						ent2->type == ST_STRUCT && Z_TYPE(ent2->data) == IS_ARRAY) {
						zend_bool incomplete_class = 0;

						zend_str_tolower(Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));
						zend_string_forget_hash_val(Z_STR(ent1->data));
						if ((pce = zend_hash_find_ptr(EG(class_table), Z_STR(ent1->data))) == NULL) {
							incomplete_class = 1;
							pce = PHP_IC_ENTRY;
						}

						if (pce != PHP_IC_ENTRY && (pce->serialize || pce->unserialize)) {
							zval_ptr_dtor(&ent2->data);
							ZVAL_UNDEF(&ent2->data);
 							php_error_docref(NULL, E_WARNING, ""Class %s can not be unserialized"", Z_STRVAL(ent1->data));
 						} else {
 							/* Initialize target object */
							if (object_init_ex(&obj, pce) != SUCCESS || EG(exception)) {
								zval_ptr_dtor(&ent2->data);
								ZVAL_UNDEF(&ent2->data);
								php_error_docref(NULL, E_WARNING, ""Class %s can not be instantiated"", Z_STRVAL(ent1->data));
							} else {
								/* Merge current hashtable with object's default properties */
								zend_hash_merge(Z_OBJPROP(obj),
												Z_ARRVAL(ent2->data),
												zval_add_ref, 0);

								if (incomplete_class) {
									php_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));
								}

								/* Clean up old array entry */
								zval_ptr_dtor(&ent2->data);

								/* Set stack entry to point to the newly created object */
								ZVAL_COPY_VALUE(&ent2->data, &obj);
 							}
 						}
 
 						/* Clean up class name var entry */
						zval_ptr_dtor(&ent1->data);
					} else if (Z_TYPE(ent2->data) == IS_OBJECT) {
						zend_class_entry *old_scope = EG(scope);

						EG(scope) = Z_OBJCE(ent2->data);
						add_property_zval(&ent2->data, ent1->varname, &ent1->data);
						if Z_REFCOUNTED(ent1->data) Z_DELREF(ent1->data);
						EG(scope) = old_scope;
					} else {
						zend_symtable_str_update(target_hash, ent1->varname, strlen(ent1->varname), &ent1->data);
					}
					efree(ent1->varname);
				} else	{
					zend_hash_next_index_insert(target_hash, &ent1->data);
				}
			}
			efree(ent1);
		} else {
			stack->done = 1;
		}
	} else if (!strcmp((char *)name, EL_VAR) && stack->varname) {
		efree(stack->varname);
		stack->varname = NULL;
	} else if (!strcmp((char *)name, EL_FIELD)) {
		st_entry *ent;
		wddx_stack_top(stack, (void **)&ent);
		efree(ent);
		stack->top--;
	}
}
","static void php_wddx_pop_element(void *user_data, const XML_Char *name)
{
	st_entry 			*ent1, *ent2;
	wddx_stack 			*stack = (wddx_stack *)user_data;
	HashTable 			*target_hash;
	zend_class_entry 	*pce;
	zval				obj;

/* OBJECTS_FIXME */
	if (stack->top == 0) {
		return;
	}

	if (!strcmp((char *)name, EL_STRING) || !strcmp((char *)name, EL_NUMBER) ||
		!strcmp((char *)name, EL_BOOLEAN) || !strcmp((char *)name, EL_NULL) ||
	  	!strcmp((char *)name, EL_ARRAY) || !strcmp((char *)name, EL_STRUCT) ||
		!strcmp((char *)name, EL_RECORDSET) || !strcmp((char *)name, EL_BINARY) ||
		!strcmp((char *)name, EL_DATETIME)) {
		wddx_stack_top(stack, (void**)&ent1);

		if (Z_TYPE(ent1->data) == IS_UNDEF) {
			if (stack->top > 1) {
				stack->top--;
				efree(ent1);
			} else {
				stack->done = 1;
			}
			return;
		}
 
 		if (!strcmp((char *)name, EL_BINARY)) {
 			zend_string *new_str = NULL;
 			if (ZSTR_EMPTY_ALLOC() != Z_STR(ent1->data)) {
 				new_str = php_base64_decode(
 					(unsigned char *)Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));
			}

			zval_ptr_dtor(&ent1->data);
			if (new_str) {
				ZVAL_STR(&ent1->data, new_str);
			} else {
				ZVAL_EMPTY_STRING(&ent1->data);
			}
		}

		/* Call __wakeup() method on the object. */
		if (Z_TYPE(ent1->data) == IS_OBJECT) {
			zval fname, retval;

			ZVAL_STRING(&fname, ""__wakeup"");

			call_user_function_ex(NULL, &ent1->data, &fname, &retval, 0, 0, 0, NULL);

			zval_ptr_dtor(&fname);
			zval_ptr_dtor(&retval);
		}

		if (stack->top > 1) {
			stack->top--;
			wddx_stack_top(stack, (void**)&ent2);

			/* if non-existent field */
			if (Z_ISUNDEF(ent2->data)) {
				zval_ptr_dtor(&ent1->data);
				efree(ent1);
				return;
			}

			if (Z_TYPE(ent2->data) == IS_ARRAY || Z_TYPE(ent2->data) == IS_OBJECT) {
				target_hash = HASH_OF(&ent2->data);

				if (ent1->varname) {
					if (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&
						Z_TYPE(ent1->data) == IS_STRING && Z_STRLEN(ent1->data) &&
						ent2->type == ST_STRUCT && Z_TYPE(ent2->data) == IS_ARRAY) {
						zend_bool incomplete_class = 0;

						zend_str_tolower(Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));
						zend_string_forget_hash_val(Z_STR(ent1->data));
						if ((pce = zend_hash_find_ptr(EG(class_table), Z_STR(ent1->data))) == NULL) {
							incomplete_class = 1;
							pce = PHP_IC_ENTRY;
						}

						if (pce != PHP_IC_ENTRY && (pce->serialize || pce->unserialize)) {
							zval_ptr_dtor(&ent2->data);
							ZVAL_UNDEF(&ent2->data);
 							php_error_docref(NULL, E_WARNING, ""Class %s can not be unserialized"", Z_STRVAL(ent1->data));
 						} else {
 							/* Initialize target object */
							object_init_ex(&obj, pce);
							/* Merge current hashtable with object's default properties */
							zend_hash_merge(Z_OBJPROP(obj),
											Z_ARRVAL(ent2->data),
											zval_add_ref, 0);
							if (incomplete_class) {
								php_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));
 							}
							/* Clean up old array entry */
							zval_ptr_dtor(&ent2->data);
							/* Set stack entry to point to the newly created object */
							ZVAL_COPY_VALUE(&ent2->data, &obj);
 						}
 
 						/* Clean up class name var entry */
						zval_ptr_dtor(&ent1->data);
					} else if (Z_TYPE(ent2->data) == IS_OBJECT) {
						zend_class_entry *old_scope = EG(scope);

						EG(scope) = Z_OBJCE(ent2->data);
						add_property_zval(&ent2->data, ent1->varname, &ent1->data);
						if Z_REFCOUNTED(ent1->data) Z_DELREF(ent1->data);
						EG(scope) = old_scope;
					} else {
						zend_symtable_str_update(target_hash, ent1->varname, strlen(ent1->varname), &ent1->data);
					}
					efree(ent1->varname);
				} else	{
					zend_hash_next_index_insert(target_hash, &ent1->data);
				}
			}
			efree(ent1);
		} else {
			stack->done = 1;
		}
	} else if (!strcmp((char *)name, EL_VAR) && stack->varname) {
		efree(stack->varname);
		stack->varname = NULL;
	} else if (!strcmp((char *)name, EL_FIELD)) {
		st_entry *ent;
		wddx_stack_top(stack, (void **)&ent);
		efree(ent);
		stack->top--;
	}
}
",C,"
							if (object_init_ex(&obj, pce) != SUCCESS || EG(exception)) {
								zval_ptr_dtor(&ent2->data);
								ZVAL_UNDEF(&ent2->data);
								php_error_docref(NULL, E_WARNING, ""Class %s can not be instantiated"", Z_STRVAL(ent1->data));
							} else {
								/* Merge current hashtable with object's default properties */
								zend_hash_merge(Z_OBJPROP(obj),
												Z_ARRVAL(ent2->data),
												zval_add_ref, 0);

								if (incomplete_class) {
									php_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));
								}

								/* Clean up old array entry */
								zval_ptr_dtor(&ent2->data);

								/* Set stack entry to point to the newly created object */
								ZVAL_COPY_VALUE(&ent2->data, &obj);
","							object_init_ex(&obj, pce);
							/* Merge current hashtable with object's default properties */
							zend_hash_merge(Z_OBJPROP(obj),
											Z_ARRVAL(ent2->data),
											zval_add_ref, 0);
							if (incomplete_class) {
								php_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));
							/* Clean up old array entry */
							zval_ptr_dtor(&ent2->data);
							/* Set stack entry to point to the newly created object */
							ZVAL_COPY_VALUE(&ent2->data, &obj);
",,"@@ -908,7 +908,7 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)
 
 		if (!strcmp((char *)name, EL_BINARY)) {
 			zend_string *new_str = NULL;
-			
+
 			if (ZSTR_EMPTY_ALLOC() != Z_STR(ent1->data)) {
 				new_str = php_base64_decode(
 					(unsigned char *)Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));
@@ -967,22 +967,26 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)
 							php_error_docref(NULL, E_WARNING, ""Class %s can not be unserialized"", Z_STRVAL(ent1->data));
 						} else {
 							/* Initialize target object */
-							object_init_ex(&obj, pce);
-
-							/* Merge current hashtable with object's default properties */
-							zend_hash_merge(Z_OBJPROP(obj),
-											Z_ARRVAL(ent2->data),
-											zval_add_ref, 0);
-
-							if (incomplete_class) {
-								php_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));
+							if (object_init_ex(&obj, pce) != SUCCESS || EG(exception)) {
+								zval_ptr_dtor(&ent2->data);
+								ZVAL_UNDEF(&ent2->data);
+								php_error_docref(NULL, E_WARNING, ""Class %s can not be instantiated"", Z_STRVAL(ent1->data));
+							} else {
+								/* Merge current hashtable with object's default properties */
+								zend_hash_merge(Z_OBJPROP(obj),
+												Z_ARRVAL(ent2->data),
+												zval_add_ref, 0);
+
+								if (incomplete_class) {
+									php_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));
+								}
+
+								/* Clean up old array entry */
+								zval_ptr_dtor(&ent2->data);
+
+								/* Set stack entry to point to the newly created object */
+								ZVAL_COPY_VALUE(&ent2->data, &obj);
 							}
-
-							/* Clean up old array entry */
-							zval_ptr_dtor(&ent2->data);
-
-							/* Set stack entry to point to the newly created object */
-							ZVAL_COPY_VALUE(&ent2->data, &obj);
 						}
 
 						/* Clean up class name var entry */",php-src,8d2539fa0faf3f63e1d1e7635347c5b9e777d47b,97e16ebbe2976dad22e8238958d3d5f023cc0132,1,"static void php_wddx_pop_element(void *user_data, const XML_Char *name)
{
	st_entry 			*ent1, *ent2;
	wddx_stack 			*stack = (wddx_stack *)user_data;
	HashTable 			*target_hash;
	zend_class_entry 	*pce;
	zval				obj;

/* OBJECTS_FIXME */
	if (stack->top == 0) {
		return;
	}

	if (!strcmp((char *)name, EL_STRING) || !strcmp((char *)name, EL_NUMBER) ||
		!strcmp((char *)name, EL_BOOLEAN) || !strcmp((char *)name, EL_NULL) ||
	  	!strcmp((char *)name, EL_ARRAY) || !strcmp((char *)name, EL_STRUCT) ||
		!strcmp((char *)name, EL_RECORDSET) || !strcmp((char *)name, EL_BINARY) ||
		!strcmp((char *)name, EL_DATETIME)) {
		wddx_stack_top(stack, (void**)&ent1);

		if (Z_TYPE(ent1->data) == IS_UNDEF) {
			if (stack->top > 1) {
				stack->top--;
				efree(ent1);
			} else {
				stack->done = 1;
			}
			return;
		}
 
 		if (!strcmp((char *)name, EL_BINARY)) {
 			zend_string *new_str = NULL;
//flaw_line_below:
			
//fix_flaw_line_below:
//
 			if (ZSTR_EMPTY_ALLOC() != Z_STR(ent1->data)) {
 				new_str = php_base64_decode(
 					(unsigned char *)Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));
			}

			zval_ptr_dtor(&ent1->data);
			if (new_str) {
				ZVAL_STR(&ent1->data, new_str);
			} else {
				ZVAL_EMPTY_STRING(&ent1->data);
			}
		}

		/* Call __wakeup() method on the object. */
		if (Z_TYPE(ent1->data) == IS_OBJECT) {
			zval fname, retval;

			ZVAL_STRING(&fname, ""__wakeup"");

			call_user_function_ex(NULL, &ent1->data, &fname, &retval, 0, 0, 0, NULL);

			zval_ptr_dtor(&fname);
			zval_ptr_dtor(&retval);
		}

		if (stack->top > 1) {
			stack->top--;
			wddx_stack_top(stack, (void**)&ent2);

			/* if non-existent field */
			if (Z_ISUNDEF(ent2->data)) {
				zval_ptr_dtor(&ent1->data);
				efree(ent1);
				return;
			}

			if (Z_TYPE(ent2->data) == IS_ARRAY || Z_TYPE(ent2->data) == IS_OBJECT) {
				target_hash = HASH_OF(&ent2->data);

				if (ent1->varname) {
					if (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&
						Z_TYPE(ent1->data) == IS_STRING && Z_STRLEN(ent1->data) &&
						ent2->type == ST_STRUCT && Z_TYPE(ent2->data) == IS_ARRAY) {
						zend_bool incomplete_class = 0;

						zend_str_tolower(Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));
						zend_string_forget_hash_val(Z_STR(ent1->data));
						if ((pce = zend_hash_find_ptr(EG(class_table), Z_STR(ent1->data))) == NULL) {
							incomplete_class = 1;
							pce = PHP_IC_ENTRY;
						}

						if (pce != PHP_IC_ENTRY && (pce->serialize || pce->unserialize)) {
							zval_ptr_dtor(&ent2->data);
							ZVAL_UNDEF(&ent2->data);
 							php_error_docref(NULL, E_WARNING, ""Class %s can not be unserialized"", Z_STRVAL(ent1->data));
 						} else {
 							/* Initialize target object */
//flaw_line_below:
							object_init_ex(&obj, pce);
//flaw_line_below:

//flaw_line_below:
							/* Merge current hashtable with object's default properties */
//flaw_line_below:
							zend_hash_merge(Z_OBJPROP(obj),
//flaw_line_below:
											Z_ARRVAL(ent2->data),
//flaw_line_below:
											zval_add_ref, 0);
//flaw_line_below:

//flaw_line_below:
							if (incomplete_class) {
//flaw_line_below:
								php_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));
//fix_flaw_line_below:
//							if (object_init_ex(&obj, pce) != SUCCESS || EG(exception)) {
//fix_flaw_line_below:
//								zval_ptr_dtor(&ent2->data);
//fix_flaw_line_below:
//								ZVAL_UNDEF(&ent2->data);
//fix_flaw_line_below:
//								php_error_docref(NULL, E_WARNING, ""Class %s can not be instantiated"", Z_STRVAL(ent1->data));
//fix_flaw_line_below:
//							} else {
//fix_flaw_line_below:
//								/* Merge current hashtable with object's default properties */
//fix_flaw_line_below:
//								zend_hash_merge(Z_OBJPROP(obj),
//fix_flaw_line_below:
//												Z_ARRVAL(ent2->data),
//fix_flaw_line_below:
//												zval_add_ref, 0);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//								if (incomplete_class) {
//fix_flaw_line_below:
//									php_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));
//fix_flaw_line_below:
//								}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//								/* Clean up old array entry */
//fix_flaw_line_below:
//								zval_ptr_dtor(&ent2->data);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//								/* Set stack entry to point to the newly created object */
//fix_flaw_line_below:
//								ZVAL_COPY_VALUE(&ent2->data, &obj);
 							}
//flaw_line_below:

//flaw_line_below:
							/* Clean up old array entry */
//flaw_line_below:
							zval_ptr_dtor(&ent2->data);
//flaw_line_below:

//flaw_line_below:
							/* Set stack entry to point to the newly created object */
//flaw_line_below:
							ZVAL_COPY_VALUE(&ent2->data, &obj);
 						}
 
 						/* Clean up class name var entry */
						zval_ptr_dtor(&ent1->data);
					} else if (Z_TYPE(ent2->data) == IS_OBJECT) {
						zend_class_entry *old_scope = EG(scope);

						EG(scope) = Z_OBJCE(ent2->data);
						add_property_zval(&ent2->data, ent1->varname, &ent1->data);
						if Z_REFCOUNTED(ent1->data) Z_DELREF(ent1->data);
						EG(scope) = old_scope;
					} else {
						zend_symtable_str_update(target_hash, ent1->varname, strlen(ent1->varname), &ent1->data);
					}
					efree(ent1->varname);
				} else	{
					zend_hash_next_index_insert(target_hash, &ent1->data);
				}
			}
			efree(ent1);
		} else {
			stack->done = 1;
		}
	} else if (!strcmp((char *)name, EL_VAR) && stack->varname) {
		efree(stack->varname);
		stack->varname = NULL;
	} else if (!strcmp((char *)name, EL_FIELD)) {
		st_entry *ent;
		wddx_stack_top(stack, (void **)&ent);
		efree(ent);
		stack->top--;
	}
}
"
3956,181692,,Local,Not required,Complete,CVE-2016-10147,https://www.cvedetails.com/cve/CVE-2016-10147/,CWE-476,Low,,,,2017-01-18,4.9,"crypto/mcryptd.c in the Linux kernel before 4.8.15 allows local users to cause a denial of service (NULL pointer dereference and system crash) by using an AF_ALG socket with an incompatible algorithm, as demonstrated by mcryptd(md5).",2018-01-04,DoS ,10,https://github.com/torvalds/linux/commit/48a992727d82cb7db076fa15d372178743b1f4cd,48a992727d82cb7db076fa15d372178743b1f4cd,"crypto: mcryptd - Check mcryptd algorithm compatibility

Algorithms not compatible with mcryptd could be spawned by mcryptd
with a direct crypto_alloc_tfm invocation using a ""mcryptd(alg)"" name
construct.  This causes mcryptd to crash the kernel if an arbitrary
""alg"" is incompatible and not intended to be used with mcryptd.  It is
an issue if AF_ALG tries to spawn mcryptd(alg) to expose it externally.
But such algorithms must be used internally and not be exposed.

We added a check to enforce that only internal algorithms are allowed
with mcryptd at the time mcryptd is spawning an algorithm.

Link: http://marc.info/?l=linux-crypto-vger&m=148063683310477&w=2
Cc: stable@vger.kernel.org
Reported-by: Mikulas Patocka <mpatocka@redhat.com>
Signed-off-by: Tim Chen <tim.c.chen@linux.intel.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",5,crypto/mcryptd.c,"{""sha"": ""c207458d62993350d9a0cfca5e1deca573b09c8c"", ""filename"": ""crypto/mcryptd.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 7, ""changes"": 19, ""blob_url"": ""https://github.com/torvalds/linux/blob/48a992727d82cb7db076fa15d372178743b1f4cd/crypto/mcryptd.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/48a992727d82cb7db076fa15d372178743b1f4cd/crypto/mcryptd.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/mcryptd.c?ref=48a992727d82cb7db076fa15d372178743b1f4cd"", ""patch"": ""@@ -254,18 +254,22 @@ static void *mcryptd_alloc_instance(struct crypto_alg *alg, unsigned int head,\n \tgoto out;\n }\n \n-static inline void mcryptd_check_internal(struct rtattr **tb, u32 *type,\n+static inline bool mcryptd_check_internal(struct rtattr **tb, u32 *type,\n \t\t\t\t\t  u32 *mask)\n {\n \tstruct crypto_attr_type *algt;\n \n \talgt = crypto_get_attr_type(tb);\n \tif (IS_ERR(algt))\n-\t\treturn;\n-\tif ((algt->type & CRYPTO_ALG_INTERNAL))\n-\t\t*type |= CRYPTO_ALG_INTERNAL;\n-\tif ((algt->mask & CRYPTO_ALG_INTERNAL))\n-\t\t*mask |= CRYPTO_ALG_INTERNAL;\n+\t\treturn false;\n+\n+\t*type |= algt->type & CRYPTO_ALG_INTERNAL;\n+\t*mask |= algt->mask & CRYPTO_ALG_INTERNAL;\n+\n+\tif (*type & *mask & CRYPTO_ALG_INTERNAL)\n+\t\treturn true;\n+\telse\n+\t\treturn false;\n }\n \n static int mcryptd_hash_init_tfm(struct crypto_tfm *tfm)\n@@ -492,7 +496,8 @@ static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,\n \tu32 mask = 0;\n \tint err;\n \n-\tmcryptd_check_internal(tb, &type, &mask);\n+\tif (!mcryptd_check_internal(tb, &type, &mask))\n+\t\treturn -EINVAL;\n \n \thalg = ahash_attr_alg(tb[1], type, mask);\n \tif (IS_ERR(halg))""}","static inline void mcryptd_check_internal(struct rtattr **tb, u32 *type,
static inline bool mcryptd_check_internal(struct rtattr **tb, u32 *type,
 					  u32 *mask)
 {
 	struct crypto_attr_type *algt;
 
 	algt = crypto_get_attr_type(tb);
 	if (IS_ERR(algt))
		return false;

	*type |= algt->type & CRYPTO_ALG_INTERNAL;
	*mask |= algt->mask & CRYPTO_ALG_INTERNAL;

	if (*type & *mask & CRYPTO_ALG_INTERNAL)
		return true;
	else
		return false;
 }
","static inline void mcryptd_check_internal(struct rtattr **tb, u32 *type,
 					  u32 *mask)
 {
 	struct crypto_attr_type *algt;
 
 	algt = crypto_get_attr_type(tb);
 	if (IS_ERR(algt))
		return;
	if ((algt->type & CRYPTO_ALG_INTERNAL))
		*type |= CRYPTO_ALG_INTERNAL;
	if ((algt->mask & CRYPTO_ALG_INTERNAL))
		*mask |= CRYPTO_ALG_INTERNAL;
 }
",C,"static inline bool mcryptd_check_internal(struct rtattr **tb, u32 *type,
		return false;

	*type |= algt->type & CRYPTO_ALG_INTERNAL;
	*mask |= algt->mask & CRYPTO_ALG_INTERNAL;

	if (*type & *mask & CRYPTO_ALG_INTERNAL)
		return true;
	else
		return false;
","		return;
	if ((algt->type & CRYPTO_ALG_INTERNAL))
		*type |= CRYPTO_ALG_INTERNAL;
	if ((algt->mask & CRYPTO_ALG_INTERNAL))
		*mask |= CRYPTO_ALG_INTERNAL;
",,"@@ -254,18 +254,22 @@ static void *mcryptd_alloc_instance(struct crypto_alg *alg, unsigned int head,
 	goto out;
 }
 
-static inline void mcryptd_check_internal(struct rtattr **tb, u32 *type,
+static inline bool mcryptd_check_internal(struct rtattr **tb, u32 *type,
 					  u32 *mask)
 {
 	struct crypto_attr_type *algt;
 
 	algt = crypto_get_attr_type(tb);
 	if (IS_ERR(algt))
-		return;
-	if ((algt->type & CRYPTO_ALG_INTERNAL))
-		*type |= CRYPTO_ALG_INTERNAL;
-	if ((algt->mask & CRYPTO_ALG_INTERNAL))
-		*mask |= CRYPTO_ALG_INTERNAL;
+		return false;
+
+	*type |= algt->type & CRYPTO_ALG_INTERNAL;
+	*mask |= algt->mask & CRYPTO_ALG_INTERNAL;
+
+	if (*type & *mask & CRYPTO_ALG_INTERNAL)
+		return true;
+	else
+		return false;
 }
 
 static int mcryptd_hash_init_tfm(struct crypto_tfm *tfm)
@@ -492,7 +496,8 @@ static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,
 	u32 mask = 0;
 	int err;
 
-	mcryptd_check_internal(tb, &type, &mask);
+	if (!mcryptd_check_internal(tb, &type, &mask))
+		return -EINVAL;
 
 	halg = ahash_attr_alg(tb[1], type, mask);
 	if (IS_ERR(halg))",linux,48a992727d82cb7db076fa15d372178743b1f4cd,0c1e16cd1ec41987cc6671a2bff46ac958c41eb5,1,"static inline void mcryptd_check_internal(struct rtattr **tb, u32 *type,
//fix_flaw_line_below:
//static inline bool mcryptd_check_internal(struct rtattr **tb, u32 *type,
 					  u32 *mask)
 {
 	struct crypto_attr_type *algt;
 
 	algt = crypto_get_attr_type(tb);
 	if (IS_ERR(algt))
//flaw_line_below:
		return;
//flaw_line_below:
	if ((algt->type & CRYPTO_ALG_INTERNAL))
//flaw_line_below:
		*type |= CRYPTO_ALG_INTERNAL;
//flaw_line_below:
	if ((algt->mask & CRYPTO_ALG_INTERNAL))
//flaw_line_below:
		*mask |= CRYPTO_ALG_INTERNAL;
//fix_flaw_line_below:
//		return false;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	*type |= algt->type & CRYPTO_ALG_INTERNAL;
//fix_flaw_line_below:
//	*mask |= algt->mask & CRYPTO_ALG_INTERNAL;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (*type & *mask & CRYPTO_ALG_INTERNAL)
//fix_flaw_line_below:
//		return true;
//fix_flaw_line_below:
//	else
//fix_flaw_line_below:
//		return false;
 }
"
3957,181693,,Local,Not required,Complete,CVE-2016-10147,https://www.cvedetails.com/cve/CVE-2016-10147/,CWE-476,Low,,,,2017-01-18,4.9,"crypto/mcryptd.c in the Linux kernel before 4.8.15 allows local users to cause a denial of service (NULL pointer dereference and system crash) by using an AF_ALG socket with an incompatible algorithm, as demonstrated by mcryptd(md5).",2018-01-04,DoS ,2,https://github.com/torvalds/linux/commit/48a992727d82cb7db076fa15d372178743b1f4cd,48a992727d82cb7db076fa15d372178743b1f4cd,"crypto: mcryptd - Check mcryptd algorithm compatibility

Algorithms not compatible with mcryptd could be spawned by mcryptd
with a direct crypto_alloc_tfm invocation using a ""mcryptd(alg)"" name
construct.  This causes mcryptd to crash the kernel if an arbitrary
""alg"" is incompatible and not intended to be used with mcryptd.  It is
an issue if AF_ALG tries to spawn mcryptd(alg) to expose it externally.
But such algorithms must be used internally and not be exposed.

We added a check to enforce that only internal algorithms are allowed
with mcryptd at the time mcryptd is spawning an algorithm.

Link: http://marc.info/?l=linux-crypto-vger&m=148063683310477&w=2
Cc: stable@vger.kernel.org
Reported-by: Mikulas Patocka <mpatocka@redhat.com>
Signed-off-by: Tim Chen <tim.c.chen@linux.intel.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",1,crypto/mcryptd.c,"{""sha"": ""c207458d62993350d9a0cfca5e1deca573b09c8c"", ""filename"": ""crypto/mcryptd.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 7, ""changes"": 19, ""blob_url"": ""https://github.com/torvalds/linux/blob/48a992727d82cb7db076fa15d372178743b1f4cd/crypto/mcryptd.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/48a992727d82cb7db076fa15d372178743b1f4cd/crypto/mcryptd.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/mcryptd.c?ref=48a992727d82cb7db076fa15d372178743b1f4cd"", ""patch"": ""@@ -254,18 +254,22 @@ static void *mcryptd_alloc_instance(struct crypto_alg *alg, unsigned int head,\n \tgoto out;\n }\n \n-static inline void mcryptd_check_internal(struct rtattr **tb, u32 *type,\n+static inline bool mcryptd_check_internal(struct rtattr **tb, u32 *type,\n \t\t\t\t\t  u32 *mask)\n {\n \tstruct crypto_attr_type *algt;\n \n \talgt = crypto_get_attr_type(tb);\n \tif (IS_ERR(algt))\n-\t\treturn;\n-\tif ((algt->type & CRYPTO_ALG_INTERNAL))\n-\t\t*type |= CRYPTO_ALG_INTERNAL;\n-\tif ((algt->mask & CRYPTO_ALG_INTERNAL))\n-\t\t*mask |= CRYPTO_ALG_INTERNAL;\n+\t\treturn false;\n+\n+\t*type |= algt->type & CRYPTO_ALG_INTERNAL;\n+\t*mask |= algt->mask & CRYPTO_ALG_INTERNAL;\n+\n+\tif (*type & *mask & CRYPTO_ALG_INTERNAL)\n+\t\treturn true;\n+\telse\n+\t\treturn false;\n }\n \n static int mcryptd_hash_init_tfm(struct crypto_tfm *tfm)\n@@ -492,7 +496,8 @@ static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,\n \tu32 mask = 0;\n \tint err;\n \n-\tmcryptd_check_internal(tb, &type, &mask);\n+\tif (!mcryptd_check_internal(tb, &type, &mask))\n+\t\treturn -EINVAL;\n \n \thalg = ahash_attr_alg(tb[1], type, mask);\n \tif (IS_ERR(halg))""}","static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,
			      struct mcryptd_queue *queue)
{
	struct hashd_instance_ctx *ctx;
	struct ahash_instance *inst;
	struct hash_alg_common *halg;
	struct crypto_alg *alg;
	u32 type = 0;
 	u32 mask = 0;
 	int err;
 
	if (!mcryptd_check_internal(tb, &type, &mask))
		return -EINVAL;
 
 	halg = ahash_attr_alg(tb[1], type, mask);
 	if (IS_ERR(halg))
		return PTR_ERR(halg);

	alg = &halg->base;
	pr_debug(""crypto: mcryptd hash alg: %s\n"", alg->cra_name);
	inst = mcryptd_alloc_instance(alg, ahash_instance_headroom(),
					sizeof(*ctx));
	err = PTR_ERR(inst);
	if (IS_ERR(inst))
		goto out_put_alg;

	ctx = ahash_instance_ctx(inst);
	ctx->queue = queue;

	err = crypto_init_ahash_spawn(&ctx->spawn, halg,
				      ahash_crypto_instance(inst));
	if (err)
		goto out_free_inst;

	type = CRYPTO_ALG_ASYNC;
	if (alg->cra_flags & CRYPTO_ALG_INTERNAL)
		type |= CRYPTO_ALG_INTERNAL;
	inst->alg.halg.base.cra_flags = type;

	inst->alg.halg.digestsize = halg->digestsize;
	inst->alg.halg.statesize = halg->statesize;
	inst->alg.halg.base.cra_ctxsize = sizeof(struct mcryptd_hash_ctx);

	inst->alg.halg.base.cra_init = mcryptd_hash_init_tfm;
	inst->alg.halg.base.cra_exit = mcryptd_hash_exit_tfm;

	inst->alg.init   = mcryptd_hash_init_enqueue;
	inst->alg.update = mcryptd_hash_update_enqueue;
	inst->alg.final  = mcryptd_hash_final_enqueue;
	inst->alg.finup  = mcryptd_hash_finup_enqueue;
	inst->alg.export = mcryptd_hash_export;
	inst->alg.import = mcryptd_hash_import;
	inst->alg.setkey = mcryptd_hash_setkey;
	inst->alg.digest = mcryptd_hash_digest_enqueue;

	err = ahash_register_instance(tmpl, inst);
	if (err) {
		crypto_drop_ahash(&ctx->spawn);
out_free_inst:
		kfree(inst);
	}

out_put_alg:
	crypto_mod_put(alg);
	return err;
}
","static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,
			      struct mcryptd_queue *queue)
{
	struct hashd_instance_ctx *ctx;
	struct ahash_instance *inst;
	struct hash_alg_common *halg;
	struct crypto_alg *alg;
	u32 type = 0;
 	u32 mask = 0;
 	int err;
 
	mcryptd_check_internal(tb, &type, &mask);
 
 	halg = ahash_attr_alg(tb[1], type, mask);
 	if (IS_ERR(halg))
		return PTR_ERR(halg);

	alg = &halg->base;
	pr_debug(""crypto: mcryptd hash alg: %s\n"", alg->cra_name);
	inst = mcryptd_alloc_instance(alg, ahash_instance_headroom(),
					sizeof(*ctx));
	err = PTR_ERR(inst);
	if (IS_ERR(inst))
		goto out_put_alg;

	ctx = ahash_instance_ctx(inst);
	ctx->queue = queue;

	err = crypto_init_ahash_spawn(&ctx->spawn, halg,
				      ahash_crypto_instance(inst));
	if (err)
		goto out_free_inst;

	type = CRYPTO_ALG_ASYNC;
	if (alg->cra_flags & CRYPTO_ALG_INTERNAL)
		type |= CRYPTO_ALG_INTERNAL;
	inst->alg.halg.base.cra_flags = type;

	inst->alg.halg.digestsize = halg->digestsize;
	inst->alg.halg.statesize = halg->statesize;
	inst->alg.halg.base.cra_ctxsize = sizeof(struct mcryptd_hash_ctx);

	inst->alg.halg.base.cra_init = mcryptd_hash_init_tfm;
	inst->alg.halg.base.cra_exit = mcryptd_hash_exit_tfm;

	inst->alg.init   = mcryptd_hash_init_enqueue;
	inst->alg.update = mcryptd_hash_update_enqueue;
	inst->alg.final  = mcryptd_hash_final_enqueue;
	inst->alg.finup  = mcryptd_hash_finup_enqueue;
	inst->alg.export = mcryptd_hash_export;
	inst->alg.import = mcryptd_hash_import;
	inst->alg.setkey = mcryptd_hash_setkey;
	inst->alg.digest = mcryptd_hash_digest_enqueue;

	err = ahash_register_instance(tmpl, inst);
	if (err) {
		crypto_drop_ahash(&ctx->spawn);
out_free_inst:
		kfree(inst);
	}

out_put_alg:
	crypto_mod_put(alg);
	return err;
}
",C,"	if (!mcryptd_check_internal(tb, &type, &mask))
		return -EINVAL;
","	mcryptd_check_internal(tb, &type, &mask);
",,"@@ -254,18 +254,22 @@ static void *mcryptd_alloc_instance(struct crypto_alg *alg, unsigned int head,
 	goto out;
 }
 
-static inline void mcryptd_check_internal(struct rtattr **tb, u32 *type,
+static inline bool mcryptd_check_internal(struct rtattr **tb, u32 *type,
 					  u32 *mask)
 {
 	struct crypto_attr_type *algt;
 
 	algt = crypto_get_attr_type(tb);
 	if (IS_ERR(algt))
-		return;
-	if ((algt->type & CRYPTO_ALG_INTERNAL))
-		*type |= CRYPTO_ALG_INTERNAL;
-	if ((algt->mask & CRYPTO_ALG_INTERNAL))
-		*mask |= CRYPTO_ALG_INTERNAL;
+		return false;
+
+	*type |= algt->type & CRYPTO_ALG_INTERNAL;
+	*mask |= algt->mask & CRYPTO_ALG_INTERNAL;
+
+	if (*type & *mask & CRYPTO_ALG_INTERNAL)
+		return true;
+	else
+		return false;
 }
 
 static int mcryptd_hash_init_tfm(struct crypto_tfm *tfm)
@@ -492,7 +496,8 @@ static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,
 	u32 mask = 0;
 	int err;
 
-	mcryptd_check_internal(tb, &type, &mask);
+	if (!mcryptd_check_internal(tb, &type, &mask))
+		return -EINVAL;
 
 	halg = ahash_attr_alg(tb[1], type, mask);
 	if (IS_ERR(halg))",linux,48a992727d82cb7db076fa15d372178743b1f4cd,0c1e16cd1ec41987cc6671a2bff46ac958c41eb5,1,"static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,
			      struct mcryptd_queue *queue)
{
	struct hashd_instance_ctx *ctx;
	struct ahash_instance *inst;
	struct hash_alg_common *halg;
	struct crypto_alg *alg;
	u32 type = 0;
 	u32 mask = 0;
 	int err;
 
//flaw_line_below:
	mcryptd_check_internal(tb, &type, &mask);
//fix_flaw_line_below:
//	if (!mcryptd_check_internal(tb, &type, &mask))
//fix_flaw_line_below:
//		return -EINVAL;
 
 	halg = ahash_attr_alg(tb[1], type, mask);
 	if (IS_ERR(halg))
		return PTR_ERR(halg);

	alg = &halg->base;
	pr_debug(""crypto: mcryptd hash alg: %s\n"", alg->cra_name);
	inst = mcryptd_alloc_instance(alg, ahash_instance_headroom(),
					sizeof(*ctx));
	err = PTR_ERR(inst);
	if (IS_ERR(inst))
		goto out_put_alg;

	ctx = ahash_instance_ctx(inst);
	ctx->queue = queue;

	err = crypto_init_ahash_spawn(&ctx->spawn, halg,
				      ahash_crypto_instance(inst));
	if (err)
		goto out_free_inst;

	type = CRYPTO_ALG_ASYNC;
	if (alg->cra_flags & CRYPTO_ALG_INTERNAL)
		type |= CRYPTO_ALG_INTERNAL;
	inst->alg.halg.base.cra_flags = type;

	inst->alg.halg.digestsize = halg->digestsize;
	inst->alg.halg.statesize = halg->statesize;
	inst->alg.halg.base.cra_ctxsize = sizeof(struct mcryptd_hash_ctx);

	inst->alg.halg.base.cra_init = mcryptd_hash_init_tfm;
	inst->alg.halg.base.cra_exit = mcryptd_hash_exit_tfm;

	inst->alg.init   = mcryptd_hash_init_enqueue;
	inst->alg.update = mcryptd_hash_update_enqueue;
	inst->alg.final  = mcryptd_hash_final_enqueue;
	inst->alg.finup  = mcryptd_hash_finup_enqueue;
	inst->alg.export = mcryptd_hash_export;
	inst->alg.import = mcryptd_hash_import;
	inst->alg.setkey = mcryptd_hash_setkey;
	inst->alg.digest = mcryptd_hash_digest_enqueue;

	err = ahash_register_instance(tmpl, inst);
	if (err) {
		crypto_drop_ahash(&ctx->spawn);
out_free_inst:
		kfree(inst);
	}

out_put_alg:
	crypto_mod_put(alg);
	return err;
}
"
3963,181699,,Remote,Not required,Partial,CVE-2016-10129,https://www.cvedetails.com/cve/CVE-2016-10129/,CWE-476,Low,,,,2017-03-24,5.0,The Git Smart Protocol support in libgit2 before 0.24.6 and 0.25.x before 0.25.1 allows remote attackers to cause a denial of service (NULL pointer dereference) via an empty packet line.,2017-03-27,DoS ,5,https://github.com/libgit2/libgit2/commit/2fdef641fd0dd2828bd948234ae86de75221a11a,2fdef641fd0dd2828bd948234ae86de75221a11a,"smart_pkt: treat empty packet lines as error

The Git protocol does not specify what should happen in the case
of an empty packet line (that is a packet line ""0004""). We
currently indicate success, but do not return a packet in the
case where we hit an empty line. The smart protocol was not
prepared to handle such packets in all cases, though, resulting
in a `NULL` pointer dereference.

Fix the issue by returning an error instead. As such kind of
packets is not even specified by upstream, this is the right
thing to do.",5,src/transports/smart_pkt.c,"{""sha"": ""e05196cd8a4174f12aa751dba2a7d39a465f7633"", ""filename"": ""src/transports/smart_pkt.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/libgit2/libgit2/blob/2fdef641fd0dd2828bd948234ae86de75221a11a/src/transports/smart_pkt.c"", ""raw_url"": ""https://github.com/libgit2/libgit2/raw/2fdef641fd0dd2828bd948234ae86de75221a11a/src/transports/smart_pkt.c"", ""contents_url"": ""https://api.github.com/repos/libgit2/libgit2/contents/src/transports/smart_pkt.c?ref=2fdef641fd0dd2828bd948234ae86de75221a11a"", ""patch"": ""@@ -437,13 +437,13 @@ int git_pkt_parse_line(\n \n \tline += PKT_LEN_SIZE;\n \t/*\n-\t * TODO: How do we deal with empty lines? Try again? with the next\n-\t * line?\n+\t * The Git protocol does not specify empty lines as part\n+\t * of the protocol. Not knowing what to do with an empty\n+\t * line, we should return an error upon hitting one.\n \t */\n \tif (len == PKT_LEN_SIZE) {\n-\t\t*head = NULL;\n-\t\t*out = line;\n-\t\treturn 0;\n+\t\tgiterr_set_str(GITERR_NET, \""Invalid empty packet\"");\n+\t\treturn GIT_ERROR;\n \t}\n \n \tif (len == 0) { /* Flush pkt */""}<_**next**_>{""sha"": ""db6a8b9c8ebcd601ed1ae34c486243f24473087a"", ""filename"": ""src/transports/smart_protocol.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 11, ""changes"": 11, ""blob_url"": ""https://github.com/libgit2/libgit2/blob/2fdef641fd0dd2828bd948234ae86de75221a11a/src/transports/smart_protocol.c"", ""raw_url"": ""https://github.com/libgit2/libgit2/raw/2fdef641fd0dd2828bd948234ae86de75221a11a/src/transports/smart_protocol.c"", ""contents_url"": ""https://api.github.com/repos/libgit2/libgit2/contents/src/transports/smart_protocol.c?ref=2fdef641fd0dd2828bd948234ae86de75221a11a"", ""patch"": ""@@ -763,14 +763,6 @@ static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt,\n \t\tline_len -= (line_end - line);\n \t\tline = line_end;\n \n-\t\t/* When a valid packet with no content has been\n-\t\t * read, git_pkt_parse_line does not report an\n-\t\t * error, but the pkt pointer has not been set.\n-\t\t * Handle this by skipping over empty packets.\n-\t\t */\n-\t\tif (pkt == NULL)\n-\t\t\tcontinue;\n-\n \t\terror = add_push_report_pkt(push, pkt);\n \n \t\tgit_pkt_free(pkt);\n@@ -825,9 +817,6 @@ static int parse_report(transport_smart *transport, git_push *push)\n \n \t\terror = 0;\n \n-\t\tif (pkt == NULL)\n-\t\t\tcontinue;\n-\n \t\tswitch (pkt->type) {\n \t\t\tcase GIT_PKT_DATA:\n \t\t\t\t/* This is a sideband packet which contains other packets */""}","int git_pkt_parse_line(
	git_pkt **head, const char *line, const char **out, size_t bufflen)
{
	int ret;
	int32_t len;

	/* Not even enough for the length */
	if (bufflen > 0 && bufflen < PKT_LEN_SIZE)
		return GIT_EBUFS;

	len = parse_len(line);
	if (len < 0) {
		/*
		 * If we fail to parse the length, it might be because the
		 * server is trying to send us the packfile already.
		 */
		if (bufflen >= 4 && !git__prefixcmp(line, ""PACK"")) {
			giterr_clear();
			*out = line;
			return pack_pkt(head);
		}

		return (int)len;
	}

	/*
	 * If we were given a buffer length, then make sure there is
	 * enough in the buffer to satisfy this line
	 */
	if (bufflen > 0 && bufflen < (size_t)len)
		return GIT_EBUFS;

	/*
	 * The length has to be exactly 0 in case of a flush
	 * packet or greater than PKT_LEN_SIZE, as the decoded
	 * length includes its own encoded length of four bytes.
	 */
	if (len != 0 && len < PKT_LEN_SIZE)
		return GIT_ERROR;
 
 	line += PKT_LEN_SIZE;
 	/*
	 * The Git protocol does not specify empty lines as part
	 * of the protocol. Not knowing what to do with an empty
	 * line, we should return an error upon hitting one.
 	 */
 	if (len == PKT_LEN_SIZE) {
		giterr_set_str(GITERR_NET, ""Invalid empty packet"");
		return GIT_ERROR;
 	}
 
 	if (len == 0) { /* Flush pkt */
		*out = line;
		return flush_pkt(head);
	}

	len -= PKT_LEN_SIZE; /* the encoded length includes its own size */

	if (*line == GIT_SIDE_BAND_DATA)
		ret = data_pkt(head, line, len);
	else if (*line == GIT_SIDE_BAND_PROGRESS)
		ret = sideband_progress_pkt(head, line, len);
	else if (*line == GIT_SIDE_BAND_ERROR)
		ret = sideband_error_pkt(head, line, len);
	else if (!git__prefixcmp(line, ""ACK""))
		ret = ack_pkt(head, line, len);
	else if (!git__prefixcmp(line, ""NAK""))
		ret = nak_pkt(head);
	else if (!git__prefixcmp(line, ""ERR ""))
		ret = err_pkt(head, line, len);
	else if (*line == '#')
		ret = comment_pkt(head, line, len);
	else if (!git__prefixcmp(line, ""ok""))
		ret = ok_pkt(head, line, len);
	else if (!git__prefixcmp(line, ""ng""))
		ret = ng_pkt(head, line, len);
	else if (!git__prefixcmp(line, ""unpack""))
		ret = unpack_pkt(head, line, len);
	else
		ret = ref_pkt(head, line, len);

	*out = line + len;

	return ret;
}
","int git_pkt_parse_line(
	git_pkt **head, const char *line, const char **out, size_t bufflen)
{
	int ret;
	int32_t len;

	/* Not even enough for the length */
	if (bufflen > 0 && bufflen < PKT_LEN_SIZE)
		return GIT_EBUFS;

	len = parse_len(line);
	if (len < 0) {
		/*
		 * If we fail to parse the length, it might be because the
		 * server is trying to send us the packfile already.
		 */
		if (bufflen >= 4 && !git__prefixcmp(line, ""PACK"")) {
			giterr_clear();
			*out = line;
			return pack_pkt(head);
		}

		return (int)len;
	}

	/*
	 * If we were given a buffer length, then make sure there is
	 * enough in the buffer to satisfy this line
	 */
	if (bufflen > 0 && bufflen < (size_t)len)
		return GIT_EBUFS;

	/*
	 * The length has to be exactly 0 in case of a flush
	 * packet or greater than PKT_LEN_SIZE, as the decoded
	 * length includes its own encoded length of four bytes.
	 */
	if (len != 0 && len < PKT_LEN_SIZE)
		return GIT_ERROR;
 
 	line += PKT_LEN_SIZE;
 	/*
	 * TODO: How do we deal with empty lines? Try again? with the next
	 * line?
 	 */
 	if (len == PKT_LEN_SIZE) {
		*head = NULL;
		*out = line;
		return 0;
 	}
 
 	if (len == 0) { /* Flush pkt */
		*out = line;
		return flush_pkt(head);
	}

	len -= PKT_LEN_SIZE; /* the encoded length includes its own size */

	if (*line == GIT_SIDE_BAND_DATA)
		ret = data_pkt(head, line, len);
	else if (*line == GIT_SIDE_BAND_PROGRESS)
		ret = sideband_progress_pkt(head, line, len);
	else if (*line == GIT_SIDE_BAND_ERROR)
		ret = sideband_error_pkt(head, line, len);
	else if (!git__prefixcmp(line, ""ACK""))
		ret = ack_pkt(head, line, len);
	else if (!git__prefixcmp(line, ""NAK""))
		ret = nak_pkt(head);
	else if (!git__prefixcmp(line, ""ERR ""))
		ret = err_pkt(head, line, len);
	else if (*line == '#')
		ret = comment_pkt(head, line, len);
	else if (!git__prefixcmp(line, ""ok""))
		ret = ok_pkt(head, line, len);
	else if (!git__prefixcmp(line, ""ng""))
		ret = ng_pkt(head, line, len);
	else if (!git__prefixcmp(line, ""unpack""))
		ret = unpack_pkt(head, line, len);
	else
		ret = ref_pkt(head, line, len);

	*out = line + len;

	return ret;
}
",C,"	 * The Git protocol does not specify empty lines as part
	 * of the protocol. Not knowing what to do with an empty
	 * line, we should return an error upon hitting one.
		giterr_set_str(GITERR_NET, ""Invalid empty packet"");
		return GIT_ERROR;
","	 * TODO: How do we deal with empty lines? Try again? with the next
	 * line?
		*head = NULL;
		*out = line;
		return 0;
",,"@@ -437,13 +437,13 @@ int git_pkt_parse_line(
 
 	line += PKT_LEN_SIZE;
 	/*
-	 * TODO: How do we deal with empty lines? Try again? with the next
-	 * line?
+	 * The Git protocol does not specify empty lines as part
+	 * of the protocol. Not knowing what to do with an empty
+	 * line, we should return an error upon hitting one.
 	 */
 	if (len == PKT_LEN_SIZE) {
-		*head = NULL;
-		*out = line;
-		return 0;
+		giterr_set_str(GITERR_NET, ""Invalid empty packet"");
+		return GIT_ERROR;
 	}
 
 	if (len == 0) { /* Flush pkt */",libgit2,2fdef641fd0dd2828bd948234ae86de75221a11a,66e3774d279672ee51c3b54545a79d20d1ada834,1,"int git_pkt_parse_line(
	git_pkt **head, const char *line, const char **out, size_t bufflen)
{
	int ret;
	int32_t len;

	/* Not even enough for the length */
	if (bufflen > 0 && bufflen < PKT_LEN_SIZE)
		return GIT_EBUFS;

	len = parse_len(line);
	if (len < 0) {
		/*
		 * If we fail to parse the length, it might be because the
		 * server is trying to send us the packfile already.
		 */
		if (bufflen >= 4 && !git__prefixcmp(line, ""PACK"")) {
			giterr_clear();
			*out = line;
			return pack_pkt(head);
		}

		return (int)len;
	}

	/*
	 * If we were given a buffer length, then make sure there is
	 * enough in the buffer to satisfy this line
	 */
	if (bufflen > 0 && bufflen < (size_t)len)
		return GIT_EBUFS;

	/*
	 * The length has to be exactly 0 in case of a flush
	 * packet or greater than PKT_LEN_SIZE, as the decoded
	 * length includes its own encoded length of four bytes.
	 */
	if (len != 0 && len < PKT_LEN_SIZE)
		return GIT_ERROR;
 
 	line += PKT_LEN_SIZE;
 	/*
//flaw_line_below:
	 * TODO: How do we deal with empty lines? Try again? with the next
//flaw_line_below:
	 * line?
//fix_flaw_line_below:
//	 * The Git protocol does not specify empty lines as part
//fix_flaw_line_below:
//	 * of the protocol. Not knowing what to do with an empty
//fix_flaw_line_below:
//	 * line, we should return an error upon hitting one.
 	 */
 	if (len == PKT_LEN_SIZE) {
//flaw_line_below:
		*head = NULL;
//flaw_line_below:
		*out = line;
//flaw_line_below:
		return 0;
//fix_flaw_line_below:
//		giterr_set_str(GITERR_NET, ""Invalid empty packet"");
//fix_flaw_line_below:
//		return GIT_ERROR;
 	}
 
 	if (len == 0) { /* Flush pkt */
		*out = line;
		return flush_pkt(head);
	}

	len -= PKT_LEN_SIZE; /* the encoded length includes its own size */

	if (*line == GIT_SIDE_BAND_DATA)
		ret = data_pkt(head, line, len);
	else if (*line == GIT_SIDE_BAND_PROGRESS)
		ret = sideband_progress_pkt(head, line, len);
	else if (*line == GIT_SIDE_BAND_ERROR)
		ret = sideband_error_pkt(head, line, len);
	else if (!git__prefixcmp(line, ""ACK""))
		ret = ack_pkt(head, line, len);
	else if (!git__prefixcmp(line, ""NAK""))
		ret = nak_pkt(head);
	else if (!git__prefixcmp(line, ""ERR ""))
		ret = err_pkt(head, line, len);
	else if (*line == '#')
		ret = comment_pkt(head, line, len);
	else if (!git__prefixcmp(line, ""ok""))
		ret = ok_pkt(head, line, len);
	else if (!git__prefixcmp(line, ""ng""))
		ret = ng_pkt(head, line, len);
	else if (!git__prefixcmp(line, ""unpack""))
		ret = unpack_pkt(head, line, len);
	else
		ret = ref_pkt(head, line, len);

	*out = line + len;

	return ret;
}
"
3964,181700,,Remote,Not required,Partial,CVE-2016-10129,https://www.cvedetails.com/cve/CVE-2016-10129/,CWE-476,Low,,,,2017-03-24,5.0,The Git Smart Protocol support in libgit2 before 0.24.6 and 0.25.x before 0.25.1 allows remote attackers to cause a denial of service (NULL pointer dereference) via an empty packet line.,2017-03-27,DoS ,0,https://github.com/libgit2/libgit2/commit/2fdef641fd0dd2828bd948234ae86de75221a11a,2fdef641fd0dd2828bd948234ae86de75221a11a,"smart_pkt: treat empty packet lines as error

The Git protocol does not specify what should happen in the case
of an empty packet line (that is a packet line ""0004""). We
currently indicate success, but do not return a packet in the
case where we hit an empty line. The smart protocol was not
prepared to handle such packets in all cases, though, resulting
in a `NULL` pointer dereference.

Fix the issue by returning an error instead. As such kind of
packets is not even specified by upstream, this is the right
thing to do.",7,src/transports/smart_protocol.c,"{""sha"": ""e05196cd8a4174f12aa751dba2a7d39a465f7633"", ""filename"": ""src/transports/smart_pkt.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/libgit2/libgit2/blob/2fdef641fd0dd2828bd948234ae86de75221a11a/src/transports/smart_pkt.c"", ""raw_url"": ""https://github.com/libgit2/libgit2/raw/2fdef641fd0dd2828bd948234ae86de75221a11a/src/transports/smart_pkt.c"", ""contents_url"": ""https://api.github.com/repos/libgit2/libgit2/contents/src/transports/smart_pkt.c?ref=2fdef641fd0dd2828bd948234ae86de75221a11a"", ""patch"": ""@@ -437,13 +437,13 @@ int git_pkt_parse_line(\n \n \tline += PKT_LEN_SIZE;\n \t/*\n-\t * TODO: How do we deal with empty lines? Try again? with the next\n-\t * line?\n+\t * The Git protocol does not specify empty lines as part\n+\t * of the protocol. Not knowing what to do with an empty\n+\t * line, we should return an error upon hitting one.\n \t */\n \tif (len == PKT_LEN_SIZE) {\n-\t\t*head = NULL;\n-\t\t*out = line;\n-\t\treturn 0;\n+\t\tgiterr_set_str(GITERR_NET, \""Invalid empty packet\"");\n+\t\treturn GIT_ERROR;\n \t}\n \n \tif (len == 0) { /* Flush pkt */""}<_**next**_>{""sha"": ""db6a8b9c8ebcd601ed1ae34c486243f24473087a"", ""filename"": ""src/transports/smart_protocol.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 11, ""changes"": 11, ""blob_url"": ""https://github.com/libgit2/libgit2/blob/2fdef641fd0dd2828bd948234ae86de75221a11a/src/transports/smart_protocol.c"", ""raw_url"": ""https://github.com/libgit2/libgit2/raw/2fdef641fd0dd2828bd948234ae86de75221a11a/src/transports/smart_protocol.c"", ""contents_url"": ""https://api.github.com/repos/libgit2/libgit2/contents/src/transports/smart_protocol.c?ref=2fdef641fd0dd2828bd948234ae86de75221a11a"", ""patch"": ""@@ -763,14 +763,6 @@ static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt,\n \t\tline_len -= (line_end - line);\n \t\tline = line_end;\n \n-\t\t/* When a valid packet with no content has been\n-\t\t * read, git_pkt_parse_line does not report an\n-\t\t * error, but the pkt pointer has not been set.\n-\t\t * Handle this by skipping over empty packets.\n-\t\t */\n-\t\tif (pkt == NULL)\n-\t\t\tcontinue;\n-\n \t\terror = add_push_report_pkt(push, pkt);\n \n \t\tgit_pkt_free(pkt);\n@@ -825,9 +817,6 @@ static int parse_report(transport_smart *transport, git_push *push)\n \n \t\terror = 0;\n \n-\t\tif (pkt == NULL)\n-\t\t\tcontinue;\n-\n \t\tswitch (pkt->type) {\n \t\t\tcase GIT_PKT_DATA:\n \t\t\t\t/* This is a sideband packet which contains other packets */""}","static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)
{
	git_pkt *pkt;
	const char *line, *line_end = NULL;
	size_t line_len;
	int error;
	int reading_from_buf = data_pkt_buf->size > 0;

	if (reading_from_buf) {
		/* We had an existing partial packet, so add the new
		 * packet to the buffer and parse the whole thing */
		git_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);
		line = data_pkt_buf->ptr;
		line_len = data_pkt_buf->size;
	}
	else {
		line = data_pkt->data;
		line_len = data_pkt->len;
	}

	while (line_len > 0) {
		error = git_pkt_parse_line(&pkt, line, &line_end, line_len);

		if (error == GIT_EBUFS) {
			/* Buffer the data when the inner packet is split
			 * across multiple sideband packets */
			if (!reading_from_buf)
				git_buf_put(data_pkt_buf, line, line_len);
			error = 0;
			goto done;
		}
		else if (error < 0)
			goto done;

		/* Advance in the buffer */
 		line_len -= (line_end - line);
 		line = line_end;
 
 		error = add_push_report_pkt(push, pkt);
 
 		git_pkt_free(pkt);

		if (error < 0 && error != GIT_ITEROVER)
			goto done;
	}

	error = 0;

done:
	if (reading_from_buf)
		git_buf_consume(data_pkt_buf, line_end);
	return error;
}
","static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)
{
	git_pkt *pkt;
	const char *line, *line_end = NULL;
	size_t line_len;
	int error;
	int reading_from_buf = data_pkt_buf->size > 0;

	if (reading_from_buf) {
		/* We had an existing partial packet, so add the new
		 * packet to the buffer and parse the whole thing */
		git_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);
		line = data_pkt_buf->ptr;
		line_len = data_pkt_buf->size;
	}
	else {
		line = data_pkt->data;
		line_len = data_pkt->len;
	}

	while (line_len > 0) {
		error = git_pkt_parse_line(&pkt, line, &line_end, line_len);

		if (error == GIT_EBUFS) {
			/* Buffer the data when the inner packet is split
			 * across multiple sideband packets */
			if (!reading_from_buf)
				git_buf_put(data_pkt_buf, line, line_len);
			error = 0;
			goto done;
		}
		else if (error < 0)
			goto done;

		/* Advance in the buffer */
 		line_len -= (line_end - line);
 		line = line_end;
 
		/* When a valid packet with no content has been
		 * read, git_pkt_parse_line does not report an
		 * error, but the pkt pointer has not been set.
		 * Handle this by skipping over empty packets.
		 */
		if (pkt == NULL)
			continue;
 		error = add_push_report_pkt(push, pkt);
 
 		git_pkt_free(pkt);

		if (error < 0 && error != GIT_ITEROVER)
			goto done;
	}

	error = 0;

done:
	if (reading_from_buf)
		git_buf_consume(data_pkt_buf, line_end);
	return error;
}
",C,,"		/* When a valid packet with no content has been
		 * read, git_pkt_parse_line does not report an
		 * error, but the pkt pointer has not been set.
		 * Handle this by skipping over empty packets.
		 */
		if (pkt == NULL)
			continue;
",,"@@ -763,14 +763,6 @@ static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt,
 		line_len -= (line_end - line);
 		line = line_end;
 
-		/* When a valid packet with no content has been
-		 * read, git_pkt_parse_line does not report an
-		 * error, but the pkt pointer has not been set.
-		 * Handle this by skipping over empty packets.
-		 */
-		if (pkt == NULL)
-			continue;
-
 		error = add_push_report_pkt(push, pkt);
 
 		git_pkt_free(pkt);
@@ -825,9 +817,6 @@ static int parse_report(transport_smart *transport, git_push *push)
 
 		error = 0;
 
-		if (pkt == NULL)
-			continue;
-
 		switch (pkt->type) {
 			case GIT_PKT_DATA:
 				/* This is a sideband packet which contains other packets */",libgit2,2fdef641fd0dd2828bd948234ae86de75221a11a,66e3774d279672ee51c3b54545a79d20d1ada834,1,"static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)
{
	git_pkt *pkt;
	const char *line, *line_end = NULL;
	size_t line_len;
	int error;
	int reading_from_buf = data_pkt_buf->size > 0;

	if (reading_from_buf) {
		/* We had an existing partial packet, so add the new
		 * packet to the buffer and parse the whole thing */
		git_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);
		line = data_pkt_buf->ptr;
		line_len = data_pkt_buf->size;
	}
	else {
		line = data_pkt->data;
		line_len = data_pkt->len;
	}

	while (line_len > 0) {
		error = git_pkt_parse_line(&pkt, line, &line_end, line_len);

		if (error == GIT_EBUFS) {
			/* Buffer the data when the inner packet is split
			 * across multiple sideband packets */
			if (!reading_from_buf)
				git_buf_put(data_pkt_buf, line, line_len);
			error = 0;
			goto done;
		}
		else if (error < 0)
			goto done;

		/* Advance in the buffer */
 		line_len -= (line_end - line);
 		line = line_end;
 
//flaw_line_below:
		/* When a valid packet with no content has been
//flaw_line_below:
		 * read, git_pkt_parse_line does not report an
//flaw_line_below:
		 * error, but the pkt pointer has not been set.
//flaw_line_below:
		 * Handle this by skipping over empty packets.
//flaw_line_below:
		 */
//flaw_line_below:
		if (pkt == NULL)
//flaw_line_below:
			continue;
//flaw_line_below:

 		error = add_push_report_pkt(push, pkt);
 
 		git_pkt_free(pkt);

		if (error < 0 && error != GIT_ITEROVER)
			goto done;
	}

	error = 0;

done:
	if (reading_from_buf)
		git_buf_consume(data_pkt_buf, line_end);
	return error;
}
"
3965,181701,,Remote,Not required,Partial,CVE-2016-10129,https://www.cvedetails.com/cve/CVE-2016-10129/,CWE-476,Low,,,,2017-03-24,5.0,The Git Smart Protocol support in libgit2 before 0.24.6 and 0.25.x before 0.25.1 allows remote attackers to cause a denial of service (NULL pointer dereference) via an empty packet line.,2017-03-27,DoS ,0,https://github.com/libgit2/libgit2/commit/2fdef641fd0dd2828bd948234ae86de75221a11a,2fdef641fd0dd2828bd948234ae86de75221a11a,"smart_pkt: treat empty packet lines as error

The Git protocol does not specify what should happen in the case
of an empty packet line (that is a packet line ""0004""). We
currently indicate success, but do not return a packet in the
case where we hit an empty line. The smart protocol was not
prepared to handle such packets in all cases, though, resulting
in a `NULL` pointer dereference.

Fix the issue by returning an error instead. As such kind of
packets is not even specified by upstream, this is the right
thing to do.",2,src/transports/smart_protocol.c,"{""sha"": ""e05196cd8a4174f12aa751dba2a7d39a465f7633"", ""filename"": ""src/transports/smart_pkt.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/libgit2/libgit2/blob/2fdef641fd0dd2828bd948234ae86de75221a11a/src/transports/smart_pkt.c"", ""raw_url"": ""https://github.com/libgit2/libgit2/raw/2fdef641fd0dd2828bd948234ae86de75221a11a/src/transports/smart_pkt.c"", ""contents_url"": ""https://api.github.com/repos/libgit2/libgit2/contents/src/transports/smart_pkt.c?ref=2fdef641fd0dd2828bd948234ae86de75221a11a"", ""patch"": ""@@ -437,13 +437,13 @@ int git_pkt_parse_line(\n \n \tline += PKT_LEN_SIZE;\n \t/*\n-\t * TODO: How do we deal with empty lines? Try again? with the next\n-\t * line?\n+\t * The Git protocol does not specify empty lines as part\n+\t * of the protocol. Not knowing what to do with an empty\n+\t * line, we should return an error upon hitting one.\n \t */\n \tif (len == PKT_LEN_SIZE) {\n-\t\t*head = NULL;\n-\t\t*out = line;\n-\t\treturn 0;\n+\t\tgiterr_set_str(GITERR_NET, \""Invalid empty packet\"");\n+\t\treturn GIT_ERROR;\n \t}\n \n \tif (len == 0) { /* Flush pkt */""}<_**next**_>{""sha"": ""db6a8b9c8ebcd601ed1ae34c486243f24473087a"", ""filename"": ""src/transports/smart_protocol.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 11, ""changes"": 11, ""blob_url"": ""https://github.com/libgit2/libgit2/blob/2fdef641fd0dd2828bd948234ae86de75221a11a/src/transports/smart_protocol.c"", ""raw_url"": ""https://github.com/libgit2/libgit2/raw/2fdef641fd0dd2828bd948234ae86de75221a11a/src/transports/smart_protocol.c"", ""contents_url"": ""https://api.github.com/repos/libgit2/libgit2/contents/src/transports/smart_protocol.c?ref=2fdef641fd0dd2828bd948234ae86de75221a11a"", ""patch"": ""@@ -763,14 +763,6 @@ static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt,\n \t\tline_len -= (line_end - line);\n \t\tline = line_end;\n \n-\t\t/* When a valid packet with no content has been\n-\t\t * read, git_pkt_parse_line does not report an\n-\t\t * error, but the pkt pointer has not been set.\n-\t\t * Handle this by skipping over empty packets.\n-\t\t */\n-\t\tif (pkt == NULL)\n-\t\t\tcontinue;\n-\n \t\terror = add_push_report_pkt(push, pkt);\n \n \t\tgit_pkt_free(pkt);\n@@ -825,9 +817,6 @@ static int parse_report(transport_smart *transport, git_push *push)\n \n \t\terror = 0;\n \n-\t\tif (pkt == NULL)\n-\t\t\tcontinue;\n-\n \t\tswitch (pkt->type) {\n \t\t\tcase GIT_PKT_DATA:\n \t\t\t\t/* This is a sideband packet which contains other packets */""}","static int parse_report(transport_smart *transport, git_push *push)
{
	git_pkt *pkt = NULL;
	const char *line_end = NULL;
	gitno_buffer *buf = &transport->buffer;
	int error, recvd;
	git_buf data_pkt_buf = GIT_BUF_INIT;

	for (;;) {
		if (buf->offset > 0)
			error = git_pkt_parse_line(&pkt, buf->data,
						   &line_end, buf->offset);
		else
			error = GIT_EBUFS;

		if (error < 0 && error != GIT_EBUFS) {
			error = -1;
			goto done;
		}

		if (error == GIT_EBUFS) {
			if ((recvd = gitno_recv(buf)) < 0) {
				error = recvd;
				goto done;
			}

			if (recvd == 0) {
				giterr_set(GITERR_NET, ""early EOF"");
				error = GIT_EEOF;
				goto done;
			}
			continue;
		}

		gitno_consume(buf, line_end);
 
 		error = 0;
 
 		switch (pkt->type) {
 			case GIT_PKT_DATA:
 				/* This is a sideband packet which contains other packets */
				error = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);
				break;
			case GIT_PKT_ERR:
				giterr_set(GITERR_NET, ""report-status: Error reported: %s"",
					((git_pkt_err *)pkt)->error);
				error = -1;
				break;
			case GIT_PKT_PROGRESS:
				if (transport->progress_cb) {
					git_pkt_progress *p = (git_pkt_progress *) pkt;
					error = transport->progress_cb(p->data, p->len, transport->message_cb_payload);
				}
				break;
			default:
				error = add_push_report_pkt(push, pkt);
				break;
		}

		git_pkt_free(pkt);

		/* add_push_report_pkt returns GIT_ITEROVER when it receives a flush */
		if (error == GIT_ITEROVER) {
			error = 0;
			if (data_pkt_buf.size > 0) {
				/* If there was data remaining in the pack data buffer,
				 * then the server sent a partial pkt-line */
				giterr_set(GITERR_NET, ""Incomplete pack data pkt-line"");
				error = GIT_ERROR;
			}
			goto done;
		}

		if (error < 0) {
			goto done;
		}
	}
done:
	git_buf_free(&data_pkt_buf);
	return error;
}
","static int parse_report(transport_smart *transport, git_push *push)
{
	git_pkt *pkt = NULL;
	const char *line_end = NULL;
	gitno_buffer *buf = &transport->buffer;
	int error, recvd;
	git_buf data_pkt_buf = GIT_BUF_INIT;

	for (;;) {
		if (buf->offset > 0)
			error = git_pkt_parse_line(&pkt, buf->data,
						   &line_end, buf->offset);
		else
			error = GIT_EBUFS;

		if (error < 0 && error != GIT_EBUFS) {
			error = -1;
			goto done;
		}

		if (error == GIT_EBUFS) {
			if ((recvd = gitno_recv(buf)) < 0) {
				error = recvd;
				goto done;
			}

			if (recvd == 0) {
				giterr_set(GITERR_NET, ""early EOF"");
				error = GIT_EEOF;
				goto done;
			}
			continue;
		}

		gitno_consume(buf, line_end);
 
 		error = 0;
 
		if (pkt == NULL)
			continue;
 		switch (pkt->type) {
 			case GIT_PKT_DATA:
 				/* This is a sideband packet which contains other packets */
				error = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);
				break;
			case GIT_PKT_ERR:
				giterr_set(GITERR_NET, ""report-status: Error reported: %s"",
					((git_pkt_err *)pkt)->error);
				error = -1;
				break;
			case GIT_PKT_PROGRESS:
				if (transport->progress_cb) {
					git_pkt_progress *p = (git_pkt_progress *) pkt;
					error = transport->progress_cb(p->data, p->len, transport->message_cb_payload);
				}
				break;
			default:
				error = add_push_report_pkt(push, pkt);
				break;
		}

		git_pkt_free(pkt);

		/* add_push_report_pkt returns GIT_ITEROVER when it receives a flush */
		if (error == GIT_ITEROVER) {
			error = 0;
			if (data_pkt_buf.size > 0) {
				/* If there was data remaining in the pack data buffer,
				 * then the server sent a partial pkt-line */
				giterr_set(GITERR_NET, ""Incomplete pack data pkt-line"");
				error = GIT_ERROR;
			}
			goto done;
		}

		if (error < 0) {
			goto done;
		}
	}
done:
	git_buf_free(&data_pkt_buf);
	return error;
}
",C,,"		if (pkt == NULL)
			continue;
",,"@@ -763,14 +763,6 @@ static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt,
 		line_len -= (line_end - line);
 		line = line_end;
 
-		/* When a valid packet with no content has been
-		 * read, git_pkt_parse_line does not report an
-		 * error, but the pkt pointer has not been set.
-		 * Handle this by skipping over empty packets.
-		 */
-		if (pkt == NULL)
-			continue;
-
 		error = add_push_report_pkt(push, pkt);
 
 		git_pkt_free(pkt);
@@ -825,9 +817,6 @@ static int parse_report(transport_smart *transport, git_push *push)
 
 		error = 0;
 
-		if (pkt == NULL)
-			continue;
-
 		switch (pkt->type) {
 			case GIT_PKT_DATA:
 				/* This is a sideband packet which contains other packets */",libgit2,2fdef641fd0dd2828bd948234ae86de75221a11a,66e3774d279672ee51c3b54545a79d20d1ada834,1,"static int parse_report(transport_smart *transport, git_push *push)
{
	git_pkt *pkt = NULL;
	const char *line_end = NULL;
	gitno_buffer *buf = &transport->buffer;
	int error, recvd;
	git_buf data_pkt_buf = GIT_BUF_INIT;

	for (;;) {
		if (buf->offset > 0)
			error = git_pkt_parse_line(&pkt, buf->data,
						   &line_end, buf->offset);
		else
			error = GIT_EBUFS;

		if (error < 0 && error != GIT_EBUFS) {
			error = -1;
			goto done;
		}

		if (error == GIT_EBUFS) {
			if ((recvd = gitno_recv(buf)) < 0) {
				error = recvd;
				goto done;
			}

			if (recvd == 0) {
				giterr_set(GITERR_NET, ""early EOF"");
				error = GIT_EEOF;
				goto done;
			}
			continue;
		}

		gitno_consume(buf, line_end);
 
 		error = 0;
 
//flaw_line_below:
		if (pkt == NULL)
//flaw_line_below:
			continue;
//flaw_line_below:

 		switch (pkt->type) {
 			case GIT_PKT_DATA:
 				/* This is a sideband packet which contains other packets */
				error = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);
				break;
			case GIT_PKT_ERR:
				giterr_set(GITERR_NET, ""report-status: Error reported: %s"",
					((git_pkt_err *)pkt)->error);
				error = -1;
				break;
			case GIT_PKT_PROGRESS:
				if (transport->progress_cb) {
					git_pkt_progress *p = (git_pkt_progress *) pkt;
					error = transport->progress_cb(p->data, p->len, transport->message_cb_payload);
				}
				break;
			default:
				error = add_push_report_pkt(push, pkt);
				break;
		}

		git_pkt_free(pkt);

		/* add_push_report_pkt returns GIT_ITEROVER when it receives a flush */
		if (error == GIT_ITEROVER) {
			error = 0;
			if (data_pkt_buf.size > 0) {
				/* If there was data remaining in the pack data buffer,
				 * then the server sent a partial pkt-line */
				giterr_set(GITERR_NET, ""Incomplete pack data pkt-line"");
				error = GIT_ERROR;
			}
			goto done;
		}

		if (error < 0) {
			goto done;
		}
	}
done:
	git_buf_free(&data_pkt_buf);
	return error;
}
"
4104,181840,,Remote,Not required,Partial,CVE-2016-9934,https://www.cvedetails.com/cve/CVE-2016-9934/,CWE-476,Low,,,,2017-01-04,5.0,"ext/wddx/wddx.c in PHP before 5.6.28 and 7.x before 7.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via crafted serialized data in a wddxPacket XML document, as demonstrated by a PDORow string.",2018-05-03,DoS ,1,https://github.com/php/php-src/commit/6045de69c7dedcba3eadf7c4bba424b19c81d00d,6045de69c7dedcba3eadf7c4bba424b19c81d00d,"Fix bug #73331 - do not try to serialize/unserialize objects wddx can not handle

Proper soltion would be to call serialize/unserialize and deal with the result,
but this requires more work that should be done by wddx maintainer (not me).",0,ext/pdo/pdo_stmt.c,"{""sha"": ""9f9ada9be3bfc1c088b166da9b69671aedabf5a9"", ""filename"": ""ext/pdo/pdo_stmt.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/php/php-src/blob/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/pdo/pdo_stmt.c"", ""raw_url"": ""https://github.com/php/php-src/raw/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/pdo/pdo_stmt.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/pdo/pdo_stmt.c?ref=6045de69c7dedcba3eadf7c4bba424b19c81d00d"", ""patch"": ""@@ -2338,6 +2338,7 @@ void pdo_stmt_init(TSRMLS_D)\n \tpdo_row_ce->ce_flags |= ZEND_ACC_FINAL_CLASS; /* when removing this a lot of handlers need to be redone */\n \tpdo_row_ce->create_object = pdo_row_new;\n \tpdo_row_ce->serialize = pdo_row_serialize;\n+\tpdo_row_ce->unserialize = zend_class_unserialize_deny;\n }\n \n static void free_statement(pdo_stmt_t *stmt TSRMLS_DC)""}<_**next**_>{""sha"": ""e76e47eab72538de32a45c31e9d6e1c7e6e86540"", ""filename"": ""ext/wddx/tests/bug45901.phpt"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/php/php-src/blob/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/tests/bug45901.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/tests/bug45901.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/tests/bug45901.phpt?ref=6045de69c7dedcba3eadf7c4bba424b19c81d00d"", ""patch"": ""@@ -14,5 +14,7 @@ echo wddx_serialize_value($xml, 'Variables') . \""\\n\"";\n echo \""DONE\"";\n ?>\n --EXPECTF--\n-<wddxPacket version='1.0'><header><comment>Variables</comment></header><data><struct><var name='php_class_name'><string>SimpleXMLElement</string></var><var name='test'><struct><var name='php_class_name'><string>SimpleXMLElement</string></var></struct></var></struct></data></wddxPacket>\n+\n+Warning: wddx_serialize_value(): Class SimpleXMLElement can not be serialized in %sbug45901.php on line %d\n+<wddxPacket version='1.0'><header><comment>Variables</comment></header><data></data></wddxPacket>\n DONE\n\\ No newline at end of file""}<_**next**_>{""sha"": ""3b08e58cc6809312bc15dd77e0fd8ed83827b04f"", ""filename"": ""ext/wddx/tests/bug72790.phpt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/php/php-src/blob/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/tests/bug72790.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/tests/bug72790.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/tests/bug72790.phpt?ref=6045de69c7dedcba3eadf7c4bba424b19c81d00d"", ""patch"": ""@@ -1,5 +1,5 @@\n --TEST--\n-Bug 72790: wddx_deserialize null dereference with invalid xml\n+Bug #72790: wddx_deserialize null dereference with invalid xml\n --SKIPIF--\n <?php\n if (!extension_loaded('wddx')) {""}<_**next**_>{""sha"": ""7e4cda1ea1166909f6c61da34b3ee51d94688652"", ""filename"": ""ext/wddx/tests/bug73331.phpt"", ""status"": ""added"", ""additions"": 15, ""deletions"": 0, ""changes"": 15, ""blob_url"": ""https://github.com/php/php-src/blob/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/tests/bug73331.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/tests/bug73331.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/tests/bug73331.phpt?ref=6045de69c7dedcba3eadf7c4bba424b19c81d00d"", ""patch"": ""@@ -0,0 +1,15 @@\n+--TEST--\n+Bug #73331 (NULL Pointer Dereference in WDDX Packet Deserialization with PDORow)\n+--SKIPIF--\n+<?php if (!extension_loaded(\""wddx\"") || !extension_loaded(\""pdo\"")) print \""skip\""; ?>\n+--FILE--\n+<?php\n+\n+$wddx = \""<wddxPacket version='1.0'><header/><data><struct><var name='php_class_name'><string>PDORow</string></var></struct></data></wddxPacket>\"";\n+var_dump(wddx_deserialize($wddx));\n+?>\n+--EXPECTF--\n+\n+Warning: wddx_deserialize(): Class pdorow can not be unserialized in %s73331.php on line %d\n+NULL\n+""}<_**next**_>{""sha"": ""59cc8ddda8a955918e260f8249996c5bf244717e"", ""filename"": ""ext/wddx/wddx.c"", ""status"": ""modified"", ""additions"": 35, ""deletions"": 32, ""changes"": 67, ""blob_url"": ""https://github.com/php/php-src/blob/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/wddx.c"", ""raw_url"": ""https://github.com/php/php-src/raw/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/wddx.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/wddx.c?ref=6045de69c7dedcba3eadf7c4bba424b19c81d00d"", ""patch"": ""@@ -471,21 +471,26 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n \tulong idx;\n \tchar tmp_buf[WDDX_BUF_LEN];\n \tHashTable *objhash, *sleephash;\n+\tzend_class_entry *ce;\n+\tPHP_CLASS_ATTRIBUTES;\n \tTSRMLS_FETCH();\n \n+\tPHP_SET_CLASS_ATTRIBUTES(obj);\n+\tce = Z_OBJCE_P(obj);\n+\tif (!ce || ce->serialize || ce->unserialize) {\n+\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Class %s can not be serialized\"", class_name);\n+\t\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n+\t\treturn;\n+\t}\n+\n \tMAKE_STD_ZVAL(fname);\n \tZVAL_STRING(fname, \""__sleep\"", 1);\n-\n \t/*\n \t * We try to call __sleep() method on object. It's supposed to return an\n \t * array of property names to be serialized.\n \t */\n \tif (call_user_function_ex(CG(function_table), &obj, fname, &retval, 0, 0, 1, NULL TSRMLS_CC) == SUCCESS) {\n \t\tif (retval && (sleephash = HASH_OF(retval))) {\n-\t\t\tPHP_CLASS_ATTRIBUTES;\n-\n-\t\t\tPHP_SET_CLASS_ATTRIBUTES(obj);\n-\n \t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n \t\t\tsnprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);\n \t\t\tphp_wddx_add_chunk(packet, tmp_buf);\n@@ -494,8 +499,6 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n \t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_E);\n \t\t\tphp_wddx_add_chunk_static(packet, WDDX_VAR_E);\n \n-\t\t\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n-\n \t\t\tobjhash = HASH_OF(obj);\n \n \t\t\tfor (zend_hash_internal_pointer_reset(sleephash);\n@@ -516,10 +519,6 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n \t} else {\n \t\tuint key_len;\n \n-\t\tPHP_CLASS_ATTRIBUTES;\n-\n-\t\tPHP_SET_CLASS_ATTRIBUTES(obj);\n-\n \t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n \t\tsnprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);\n \t\tphp_wddx_add_chunk(packet, tmp_buf);\n@@ -528,8 +527,6 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n \t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_E);\n \t\tphp_wddx_add_chunk_static(packet, WDDX_VAR_E);\n \n-\t\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n-\n \t\tobjhash = HASH_OF(obj);\n \t\tfor (zend_hash_internal_pointer_reset(objhash);\n \t\t\t zend_hash_get_current_data(objhash, (void**)&ent) == SUCCESS;\n@@ -551,6 +548,8 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n \t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n \t}\n \n+\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n+\n \tzval_dtor(fname);\n \tFREE_ZVAL(fname);\n \n@@ -1012,26 +1011,30 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n \t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n \t\t\t\t\t\t}\n \n-\t\t\t\t\t\t/* Initialize target object */\n-\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n-\t\t\t\t\t\tobject_init_ex(obj, *pce);\n-\n-\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n-\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n-\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n-\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n-\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n-\n-\t\t\t\t\t\tif (incomplete_class) {\n-\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n+\t\t\t\t\t\tif (pce != &PHP_IC_ENTRY && ((*pce)->serialize || (*pce)->unserialize)) {\n+\t\t\t\t\t\t\tent2->data = NULL;\n+\t\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Class %s can not be unserialized\"", Z_STRVAL_P(ent1->data));\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t/* Initialize target object */\n+\t\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n+\t\t\t\t\t\t\tobject_init_ex(obj, *pce);\n+\n+\t\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n+\t\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n+\t\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n+\t\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n+\t\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n+\n+\t\t\t\t\t\t\tif (incomplete_class) {\n+\t\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t/* Clean up old array entry */\n+\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n+\n+\t\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n+\t\t\t\t\t\t\tent2->data = obj;\n \t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t/* Clean up old array entry */\n-\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n-\n-\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n-\t\t\t\t\t\tent2->data = obj;\n-\n \t\t\t\t\t\t/* Clean up class name var entry */\n \t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n \t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {""}","void pdo_stmt_init(TSRMLS_D)
{
	zend_class_entry ce;

	INIT_CLASS_ENTRY(ce, ""PDOStatement"", pdo_dbstmt_functions);
	pdo_dbstmt_ce = zend_register_internal_class(&ce TSRMLS_CC);
	pdo_dbstmt_ce->get_iterator = pdo_stmt_iter_get;
	pdo_dbstmt_ce->create_object = pdo_dbstmt_new;
	zend_class_implements(pdo_dbstmt_ce TSRMLS_CC, 1, zend_ce_traversable);
	zend_declare_property_null(pdo_dbstmt_ce, ""queryString"", sizeof(""queryString"")-1, ZEND_ACC_PUBLIC TSRMLS_CC);

	memcpy(&pdo_dbstmt_object_handlers, &std_object_handlers, sizeof(zend_object_handlers));
	pdo_dbstmt_object_handlers.write_property = dbstmt_prop_write;
	pdo_dbstmt_object_handlers.unset_property = dbstmt_prop_delete;
	pdo_dbstmt_object_handlers.get_method = dbstmt_method_get;
	pdo_dbstmt_object_handlers.compare_objects = dbstmt_compare;
	pdo_dbstmt_object_handlers.clone_obj = dbstmt_clone_obj;

	INIT_CLASS_ENTRY(ce, ""PDORow"", pdo_row_functions);
	pdo_row_ce = zend_register_internal_class(&ce TSRMLS_CC);
 	pdo_row_ce->ce_flags |= ZEND_ACC_FINAL_CLASS; /* when removing this a lot of handlers need to be redone */
 	pdo_row_ce->create_object = pdo_row_new;
 	pdo_row_ce->serialize = pdo_row_serialize;
	pdo_row_ce->unserialize = zend_class_unserialize_deny;
 }
","void pdo_stmt_init(TSRMLS_D)
{
	zend_class_entry ce;

	INIT_CLASS_ENTRY(ce, ""PDOStatement"", pdo_dbstmt_functions);
	pdo_dbstmt_ce = zend_register_internal_class(&ce TSRMLS_CC);
	pdo_dbstmt_ce->get_iterator = pdo_stmt_iter_get;
	pdo_dbstmt_ce->create_object = pdo_dbstmt_new;
	zend_class_implements(pdo_dbstmt_ce TSRMLS_CC, 1, zend_ce_traversable);
	zend_declare_property_null(pdo_dbstmt_ce, ""queryString"", sizeof(""queryString"")-1, ZEND_ACC_PUBLIC TSRMLS_CC);

	memcpy(&pdo_dbstmt_object_handlers, &std_object_handlers, sizeof(zend_object_handlers));
	pdo_dbstmt_object_handlers.write_property = dbstmt_prop_write;
	pdo_dbstmt_object_handlers.unset_property = dbstmt_prop_delete;
	pdo_dbstmt_object_handlers.get_method = dbstmt_method_get;
	pdo_dbstmt_object_handlers.compare_objects = dbstmt_compare;
	pdo_dbstmt_object_handlers.clone_obj = dbstmt_clone_obj;

	INIT_CLASS_ENTRY(ce, ""PDORow"", pdo_row_functions);
	pdo_row_ce = zend_register_internal_class(&ce TSRMLS_CC);
 	pdo_row_ce->ce_flags |= ZEND_ACC_FINAL_CLASS; /* when removing this a lot of handlers need to be redone */
 	pdo_row_ce->create_object = pdo_row_new;
 	pdo_row_ce->serialize = pdo_row_serialize;
 }
",C,"	pdo_row_ce->unserialize = zend_class_unserialize_deny;
",,,"@@ -2338,6 +2338,7 @@ void pdo_stmt_init(TSRMLS_D)
 	pdo_row_ce->ce_flags |= ZEND_ACC_FINAL_CLASS; /* when removing this a lot of handlers need to be redone */
 	pdo_row_ce->create_object = pdo_row_new;
 	pdo_row_ce->serialize = pdo_row_serialize;
+	pdo_row_ce->unserialize = zend_class_unserialize_deny;
 }
 
 static void free_statement(pdo_stmt_t *stmt TSRMLS_DC)",php-src,6045de69c7dedcba3eadf7c4bba424b19c81d00d,6558559bcc1cd24e3639e4a215e9d546ee05fc48,1,"void pdo_stmt_init(TSRMLS_D)
{
	zend_class_entry ce;

	INIT_CLASS_ENTRY(ce, ""PDOStatement"", pdo_dbstmt_functions);
	pdo_dbstmt_ce = zend_register_internal_class(&ce TSRMLS_CC);
	pdo_dbstmt_ce->get_iterator = pdo_stmt_iter_get;
	pdo_dbstmt_ce->create_object = pdo_dbstmt_new;
	zend_class_implements(pdo_dbstmt_ce TSRMLS_CC, 1, zend_ce_traversable);
	zend_declare_property_null(pdo_dbstmt_ce, ""queryString"", sizeof(""queryString"")-1, ZEND_ACC_PUBLIC TSRMLS_CC);

	memcpy(&pdo_dbstmt_object_handlers, &std_object_handlers, sizeof(zend_object_handlers));
	pdo_dbstmt_object_handlers.write_property = dbstmt_prop_write;
	pdo_dbstmt_object_handlers.unset_property = dbstmt_prop_delete;
	pdo_dbstmt_object_handlers.get_method = dbstmt_method_get;
	pdo_dbstmt_object_handlers.compare_objects = dbstmt_compare;
	pdo_dbstmt_object_handlers.clone_obj = dbstmt_clone_obj;

	INIT_CLASS_ENTRY(ce, ""PDORow"", pdo_row_functions);
	pdo_row_ce = zend_register_internal_class(&ce TSRMLS_CC);
 	pdo_row_ce->ce_flags |= ZEND_ACC_FINAL_CLASS; /* when removing this a lot of handlers need to be redone */
 	pdo_row_ce->create_object = pdo_row_new;
 	pdo_row_ce->serialize = pdo_row_serialize;
//fix_flaw_line_below:
//	pdo_row_ce->unserialize = zend_class_unserialize_deny;
 }
"
4105,181841,,Remote,Not required,Partial,CVE-2016-9934,https://www.cvedetails.com/cve/CVE-2016-9934/,CWE-476,Low,,,,2017-01-04,5.0,"ext/wddx/wddx.c in PHP before 5.6.28 and 7.x before 7.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via crafted serialized data in a wddxPacket XML document, as demonstrated by a PDORow string.",2018-05-03,DoS ,23,https://github.com/php/php-src/commit/6045de69c7dedcba3eadf7c4bba424b19c81d00d,6045de69c7dedcba3eadf7c4bba424b19c81d00d,"Fix bug #73331 - do not try to serialize/unserialize objects wddx can not handle

Proper soltion would be to call serialize/unserialize and deal with the result,
but this requires more work that should be done by wddx maintainer (not me).",14,ext/wddx/wddx.c,"{""sha"": ""9f9ada9be3bfc1c088b166da9b69671aedabf5a9"", ""filename"": ""ext/pdo/pdo_stmt.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/php/php-src/blob/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/pdo/pdo_stmt.c"", ""raw_url"": ""https://github.com/php/php-src/raw/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/pdo/pdo_stmt.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/pdo/pdo_stmt.c?ref=6045de69c7dedcba3eadf7c4bba424b19c81d00d"", ""patch"": ""@@ -2338,6 +2338,7 @@ void pdo_stmt_init(TSRMLS_D)\n \tpdo_row_ce->ce_flags |= ZEND_ACC_FINAL_CLASS; /* when removing this a lot of handlers need to be redone */\n \tpdo_row_ce->create_object = pdo_row_new;\n \tpdo_row_ce->serialize = pdo_row_serialize;\n+\tpdo_row_ce->unserialize = zend_class_unserialize_deny;\n }\n \n static void free_statement(pdo_stmt_t *stmt TSRMLS_DC)""}<_**next**_>{""sha"": ""e76e47eab72538de32a45c31e9d6e1c7e6e86540"", ""filename"": ""ext/wddx/tests/bug45901.phpt"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/php/php-src/blob/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/tests/bug45901.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/tests/bug45901.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/tests/bug45901.phpt?ref=6045de69c7dedcba3eadf7c4bba424b19c81d00d"", ""patch"": ""@@ -14,5 +14,7 @@ echo wddx_serialize_value($xml, 'Variables') . \""\\n\"";\n echo \""DONE\"";\n ?>\n --EXPECTF--\n-<wddxPacket version='1.0'><header><comment>Variables</comment></header><data><struct><var name='php_class_name'><string>SimpleXMLElement</string></var><var name='test'><struct><var name='php_class_name'><string>SimpleXMLElement</string></var></struct></var></struct></data></wddxPacket>\n+\n+Warning: wddx_serialize_value(): Class SimpleXMLElement can not be serialized in %sbug45901.php on line %d\n+<wddxPacket version='1.0'><header><comment>Variables</comment></header><data></data></wddxPacket>\n DONE\n\\ No newline at end of file""}<_**next**_>{""sha"": ""3b08e58cc6809312bc15dd77e0fd8ed83827b04f"", ""filename"": ""ext/wddx/tests/bug72790.phpt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/php/php-src/blob/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/tests/bug72790.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/tests/bug72790.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/tests/bug72790.phpt?ref=6045de69c7dedcba3eadf7c4bba424b19c81d00d"", ""patch"": ""@@ -1,5 +1,5 @@\n --TEST--\n-Bug 72790: wddx_deserialize null dereference with invalid xml\n+Bug #72790: wddx_deserialize null dereference with invalid xml\n --SKIPIF--\n <?php\n if (!extension_loaded('wddx')) {""}<_**next**_>{""sha"": ""7e4cda1ea1166909f6c61da34b3ee51d94688652"", ""filename"": ""ext/wddx/tests/bug73331.phpt"", ""status"": ""added"", ""additions"": 15, ""deletions"": 0, ""changes"": 15, ""blob_url"": ""https://github.com/php/php-src/blob/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/tests/bug73331.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/tests/bug73331.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/tests/bug73331.phpt?ref=6045de69c7dedcba3eadf7c4bba424b19c81d00d"", ""patch"": ""@@ -0,0 +1,15 @@\n+--TEST--\n+Bug #73331 (NULL Pointer Dereference in WDDX Packet Deserialization with PDORow)\n+--SKIPIF--\n+<?php if (!extension_loaded(\""wddx\"") || !extension_loaded(\""pdo\"")) print \""skip\""; ?>\n+--FILE--\n+<?php\n+\n+$wddx = \""<wddxPacket version='1.0'><header/><data><struct><var name='php_class_name'><string>PDORow</string></var></struct></data></wddxPacket>\"";\n+var_dump(wddx_deserialize($wddx));\n+?>\n+--EXPECTF--\n+\n+Warning: wddx_deserialize(): Class pdorow can not be unserialized in %s73331.php on line %d\n+NULL\n+""}<_**next**_>{""sha"": ""59cc8ddda8a955918e260f8249996c5bf244717e"", ""filename"": ""ext/wddx/wddx.c"", ""status"": ""modified"", ""additions"": 35, ""deletions"": 32, ""changes"": 67, ""blob_url"": ""https://github.com/php/php-src/blob/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/wddx.c"", ""raw_url"": ""https://github.com/php/php-src/raw/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/wddx.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/wddx.c?ref=6045de69c7dedcba3eadf7c4bba424b19c81d00d"", ""patch"": ""@@ -471,21 +471,26 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n \tulong idx;\n \tchar tmp_buf[WDDX_BUF_LEN];\n \tHashTable *objhash, *sleephash;\n+\tzend_class_entry *ce;\n+\tPHP_CLASS_ATTRIBUTES;\n \tTSRMLS_FETCH();\n \n+\tPHP_SET_CLASS_ATTRIBUTES(obj);\n+\tce = Z_OBJCE_P(obj);\n+\tif (!ce || ce->serialize || ce->unserialize) {\n+\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Class %s can not be serialized\"", class_name);\n+\t\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n+\t\treturn;\n+\t}\n+\n \tMAKE_STD_ZVAL(fname);\n \tZVAL_STRING(fname, \""__sleep\"", 1);\n-\n \t/*\n \t * We try to call __sleep() method on object. It's supposed to return an\n \t * array of property names to be serialized.\n \t */\n \tif (call_user_function_ex(CG(function_table), &obj, fname, &retval, 0, 0, 1, NULL TSRMLS_CC) == SUCCESS) {\n \t\tif (retval && (sleephash = HASH_OF(retval))) {\n-\t\t\tPHP_CLASS_ATTRIBUTES;\n-\n-\t\t\tPHP_SET_CLASS_ATTRIBUTES(obj);\n-\n \t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n \t\t\tsnprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);\n \t\t\tphp_wddx_add_chunk(packet, tmp_buf);\n@@ -494,8 +499,6 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n \t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_E);\n \t\t\tphp_wddx_add_chunk_static(packet, WDDX_VAR_E);\n \n-\t\t\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n-\n \t\t\tobjhash = HASH_OF(obj);\n \n \t\t\tfor (zend_hash_internal_pointer_reset(sleephash);\n@@ -516,10 +519,6 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n \t} else {\n \t\tuint key_len;\n \n-\t\tPHP_CLASS_ATTRIBUTES;\n-\n-\t\tPHP_SET_CLASS_ATTRIBUTES(obj);\n-\n \t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n \t\tsnprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);\n \t\tphp_wddx_add_chunk(packet, tmp_buf);\n@@ -528,8 +527,6 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n \t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_E);\n \t\tphp_wddx_add_chunk_static(packet, WDDX_VAR_E);\n \n-\t\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n-\n \t\tobjhash = HASH_OF(obj);\n \t\tfor (zend_hash_internal_pointer_reset(objhash);\n \t\t\t zend_hash_get_current_data(objhash, (void**)&ent) == SUCCESS;\n@@ -551,6 +548,8 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n \t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n \t}\n \n+\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n+\n \tzval_dtor(fname);\n \tFREE_ZVAL(fname);\n \n@@ -1012,26 +1011,30 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n \t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n \t\t\t\t\t\t}\n \n-\t\t\t\t\t\t/* Initialize target object */\n-\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n-\t\t\t\t\t\tobject_init_ex(obj, *pce);\n-\n-\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n-\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n-\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n-\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n-\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n-\n-\t\t\t\t\t\tif (incomplete_class) {\n-\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n+\t\t\t\t\t\tif (pce != &PHP_IC_ENTRY && ((*pce)->serialize || (*pce)->unserialize)) {\n+\t\t\t\t\t\t\tent2->data = NULL;\n+\t\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Class %s can not be unserialized\"", Z_STRVAL_P(ent1->data));\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t/* Initialize target object */\n+\t\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n+\t\t\t\t\t\t\tobject_init_ex(obj, *pce);\n+\n+\t\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n+\t\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n+\t\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n+\t\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n+\t\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n+\n+\t\t\t\t\t\t\tif (incomplete_class) {\n+\t\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t/* Clean up old array entry */\n+\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n+\n+\t\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n+\t\t\t\t\t\t\tent2->data = obj;\n \t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t/* Clean up old array entry */\n-\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n-\n-\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n-\t\t\t\t\t\tent2->data = obj;\n-\n \t\t\t\t\t\t/* Clean up class name var entry */\n \t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n \t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {""}","static void php_wddx_pop_element(void *user_data, const XML_Char *name)
{
	st_entry 			*ent1, *ent2;
	wddx_stack 			*stack = (wddx_stack *)user_data;
	HashTable 			*target_hash;
	zend_class_entry 	**pce;
	zval				*obj;
	zval				*tmp;
	TSRMLS_FETCH();

/* OBJECTS_FIXME */
	if (stack->top == 0) {
		return;
	}

	if (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||
		!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||
	  	!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||
		!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||
		!strcmp(name, EL_DATETIME)) {
		wddx_stack_top(stack, (void**)&ent1);

		if (!ent1->data) {
			if (stack->top > 1) {
				stack->top--;
				efree(ent1);
			} else {
				stack->done = 1;
			}
			return;
		}

		if (!strcmp(name, EL_BINARY)) {
			int new_len=0;
			unsigned char *new_str;

			new_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);
			STR_FREE(Z_STRVAL_P(ent1->data));
			if (new_str) {
				Z_STRVAL_P(ent1->data) = new_str;
				Z_STRLEN_P(ent1->data) = new_len;
			} else {
				ZVAL_EMPTY_STRING(ent1->data);
			}
		}

		/* Call __wakeup() method on the object. */
		if (Z_TYPE_P(ent1->data) == IS_OBJECT) {
			zval *fname, *retval = NULL;

			MAKE_STD_ZVAL(fname);
			ZVAL_STRING(fname, ""__wakeup"", 1);

			call_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);

			zval_dtor(fname);
			FREE_ZVAL(fname);
			if (retval) {
				zval_ptr_dtor(&retval);
			}
		}

		if (stack->top > 1) {
			stack->top--;
			wddx_stack_top(stack, (void**)&ent2);

			/* if non-existent field */
			if (ent2->data == NULL) {
				zval_ptr_dtor(&ent1->data);
				efree(ent1);
				return;
			}

			if (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {
				target_hash = HASH_OF(ent2->data);

				if (ent1->varname) {
					if (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&
						Z_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&
						ent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {
						zend_bool incomplete_class = 0;

						zend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
						if (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),
										   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {
							incomplete_class = 1;
 							pce = &PHP_IC_ENTRY;
 						}
 
						if (pce != &PHP_IC_ENTRY && ((*pce)->serialize || (*pce)->unserialize)) {
							ent2->data = NULL;
							php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Class %s can not be unserialized"", Z_STRVAL_P(ent1->data));
						} else {
							/* Initialize target object */
							MAKE_STD_ZVAL(obj);
							object_init_ex(obj, *pce);

							/* Merge current hashtable with object's default properties */
							zend_hash_merge(Z_OBJPROP_P(obj),
											Z_ARRVAL_P(ent2->data),
											(void (*)(void *)) zval_add_ref,
											(void *) &tmp, sizeof(zval *), 0);

							if (incomplete_class) {
								php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
							}

							/* Clean up old array entry */
							zval_ptr_dtor(&ent2->data);

							/* Set stack entry to point to the newly created object */
							ent2->data = obj;
 						}
 						/* Clean up class name var entry */
 						zval_ptr_dtor(&ent1->data);
 					} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {
						zend_class_entry *old_scope = EG(scope);

						EG(scope) = Z_OBJCE_P(ent2->data);
						Z_DELREF_P(ent1->data);
						add_property_zval(ent2->data, ent1->varname, ent1->data);
						EG(scope) = old_scope;
					} else {
						zend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);
					}
					efree(ent1->varname);
				} else	{
					zend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);
				}
			}
			efree(ent1);
		} else {
			stack->done = 1;
		}
	} else if (!strcmp(name, EL_VAR) && stack->varname) {
		efree(stack->varname);
		stack->varname = NULL;
	} else if (!strcmp(name, EL_FIELD)) {
		st_entry *ent;
		wddx_stack_top(stack, (void **)&ent);
		efree(ent);
		stack->top--;
	}
}
","static void php_wddx_pop_element(void *user_data, const XML_Char *name)
{
	st_entry 			*ent1, *ent2;
	wddx_stack 			*stack = (wddx_stack *)user_data;
	HashTable 			*target_hash;
	zend_class_entry 	**pce;
	zval				*obj;
	zval				*tmp;
	TSRMLS_FETCH();

/* OBJECTS_FIXME */
	if (stack->top == 0) {
		return;
	}

	if (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||
		!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||
	  	!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||
		!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||
		!strcmp(name, EL_DATETIME)) {
		wddx_stack_top(stack, (void**)&ent1);

		if (!ent1->data) {
			if (stack->top > 1) {
				stack->top--;
				efree(ent1);
			} else {
				stack->done = 1;
			}
			return;
		}

		if (!strcmp(name, EL_BINARY)) {
			int new_len=0;
			unsigned char *new_str;

			new_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);
			STR_FREE(Z_STRVAL_P(ent1->data));
			if (new_str) {
				Z_STRVAL_P(ent1->data) = new_str;
				Z_STRLEN_P(ent1->data) = new_len;
			} else {
				ZVAL_EMPTY_STRING(ent1->data);
			}
		}

		/* Call __wakeup() method on the object. */
		if (Z_TYPE_P(ent1->data) == IS_OBJECT) {
			zval *fname, *retval = NULL;

			MAKE_STD_ZVAL(fname);
			ZVAL_STRING(fname, ""__wakeup"", 1);

			call_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);

			zval_dtor(fname);
			FREE_ZVAL(fname);
			if (retval) {
				zval_ptr_dtor(&retval);
			}
		}

		if (stack->top > 1) {
			stack->top--;
			wddx_stack_top(stack, (void**)&ent2);

			/* if non-existent field */
			if (ent2->data == NULL) {
				zval_ptr_dtor(&ent1->data);
				efree(ent1);
				return;
			}

			if (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {
				target_hash = HASH_OF(ent2->data);

				if (ent1->varname) {
					if (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&
						Z_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&
						ent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {
						zend_bool incomplete_class = 0;

						zend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
						if (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),
										   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {
							incomplete_class = 1;
 							pce = &PHP_IC_ENTRY;
 						}
 
						/* Initialize target object */
						MAKE_STD_ZVAL(obj);
						object_init_ex(obj, *pce);
						/* Merge current hashtable with object's default properties */
						zend_hash_merge(Z_OBJPROP_P(obj),
										Z_ARRVAL_P(ent2->data),
										(void (*)(void *)) zval_add_ref,
										(void *) &tmp, sizeof(zval *), 0);
						if (incomplete_class) {
							php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
 						}
						/* Clean up old array entry */
						zval_ptr_dtor(&ent2->data);
						/* Set stack entry to point to the newly created object */
						ent2->data = obj;
 						/* Clean up class name var entry */
 						zval_ptr_dtor(&ent1->data);
 					} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {
						zend_class_entry *old_scope = EG(scope);

						EG(scope) = Z_OBJCE_P(ent2->data);
						Z_DELREF_P(ent1->data);
						add_property_zval(ent2->data, ent1->varname, ent1->data);
						EG(scope) = old_scope;
					} else {
						zend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);
					}
					efree(ent1->varname);
				} else	{
					zend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);
				}
			}
			efree(ent1);
		} else {
			stack->done = 1;
		}
	} else if (!strcmp(name, EL_VAR) && stack->varname) {
		efree(stack->varname);
		stack->varname = NULL;
	} else if (!strcmp(name, EL_FIELD)) {
		st_entry *ent;
		wddx_stack_top(stack, (void **)&ent);
		efree(ent);
		stack->top--;
	}
}
",C,"						if (pce != &PHP_IC_ENTRY && ((*pce)->serialize || (*pce)->unserialize)) {
							ent2->data = NULL;
							php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Class %s can not be unserialized"", Z_STRVAL_P(ent1->data));
						} else {
							/* Initialize target object */
							MAKE_STD_ZVAL(obj);
							object_init_ex(obj, *pce);

							/* Merge current hashtable with object's default properties */
							zend_hash_merge(Z_OBJPROP_P(obj),
											Z_ARRVAL_P(ent2->data),
											(void (*)(void *)) zval_add_ref,
											(void *) &tmp, sizeof(zval *), 0);

							if (incomplete_class) {
								php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
							}

							/* Clean up old array entry */
							zval_ptr_dtor(&ent2->data);

							/* Set stack entry to point to the newly created object */
							ent2->data = obj;
","						/* Initialize target object */
						MAKE_STD_ZVAL(obj);
						object_init_ex(obj, *pce);
						/* Merge current hashtable with object's default properties */
						zend_hash_merge(Z_OBJPROP_P(obj),
										Z_ARRVAL_P(ent2->data),
										(void (*)(void *)) zval_add_ref,
										(void *) &tmp, sizeof(zval *), 0);
						if (incomplete_class) {
							php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
						/* Clean up old array entry */
						zval_ptr_dtor(&ent2->data);
						/* Set stack entry to point to the newly created object */
						ent2->data = obj;
",,"@@ -471,21 +471,26 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)
 	ulong idx;
 	char tmp_buf[WDDX_BUF_LEN];
 	HashTable *objhash, *sleephash;
+	zend_class_entry *ce;
+	PHP_CLASS_ATTRIBUTES;
 	TSRMLS_FETCH();
 
+	PHP_SET_CLASS_ATTRIBUTES(obj);
+	ce = Z_OBJCE_P(obj);
+	if (!ce || ce->serialize || ce->unserialize) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Class %s can not be serialized"", class_name);
+		PHP_CLEANUP_CLASS_ATTRIBUTES();
+		return;
+	}
+
 	MAKE_STD_ZVAL(fname);
 	ZVAL_STRING(fname, ""__sleep"", 1);
-
 	/*
 	 * We try to call __sleep() method on object. It's supposed to return an
 	 * array of property names to be serialized.
 	 */
 	if (call_user_function_ex(CG(function_table), &obj, fname, &retval, 0, 0, 1, NULL TSRMLS_CC) == SUCCESS) {
 		if (retval && (sleephash = HASH_OF(retval))) {
-			PHP_CLASS_ATTRIBUTES;
-
-			PHP_SET_CLASS_ATTRIBUTES(obj);
-
 			php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
 			snprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);
 			php_wddx_add_chunk(packet, tmp_buf);
@@ -494,8 +499,6 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)
 			php_wddx_add_chunk_static(packet, WDDX_STRING_E);
 			php_wddx_add_chunk_static(packet, WDDX_VAR_E);
 
-			PHP_CLEANUP_CLASS_ATTRIBUTES();
-
 			objhash = HASH_OF(obj);
 
 			for (zend_hash_internal_pointer_reset(sleephash);
@@ -516,10 +519,6 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)
 	} else {
 		uint key_len;
 
-		PHP_CLASS_ATTRIBUTES;
-
-		PHP_SET_CLASS_ATTRIBUTES(obj);
-
 		php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
 		snprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);
 		php_wddx_add_chunk(packet, tmp_buf);
@@ -528,8 +527,6 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)
 		php_wddx_add_chunk_static(packet, WDDX_STRING_E);
 		php_wddx_add_chunk_static(packet, WDDX_VAR_E);
 
-		PHP_CLEANUP_CLASS_ATTRIBUTES();
-
 		objhash = HASH_OF(obj);
 		for (zend_hash_internal_pointer_reset(objhash);
 			 zend_hash_get_current_data(objhash, (void**)&ent) == SUCCESS;
@@ -551,6 +548,8 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)
 		php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
 	}
 
+	PHP_CLEANUP_CLASS_ATTRIBUTES();
+
 	zval_dtor(fname);
 	FREE_ZVAL(fname);
 
@@ -1012,26 +1011,30 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)
 							pce = &PHP_IC_ENTRY;
 						}
 
-						/* Initialize target object */
-						MAKE_STD_ZVAL(obj);
-						object_init_ex(obj, *pce);
-
-						/* Merge current hashtable with object's default properties */
-						zend_hash_merge(Z_OBJPROP_P(obj),
-										Z_ARRVAL_P(ent2->data),
-										(void (*)(void *)) zval_add_ref,
-										(void *) &tmp, sizeof(zval *), 0);
-
-						if (incomplete_class) {
-							php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
+						if (pce != &PHP_IC_ENTRY && ((*pce)->serialize || (*pce)->unserialize)) {
+							ent2->data = NULL;
+							php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Class %s can not be unserialized"", Z_STRVAL_P(ent1->data));
+						} else {
+							/* Initialize target object */
+							MAKE_STD_ZVAL(obj);
+							object_init_ex(obj, *pce);
+
+							/* Merge current hashtable with object's default properties */
+							zend_hash_merge(Z_OBJPROP_P(obj),
+											Z_ARRVAL_P(ent2->data),
+											(void (*)(void *)) zval_add_ref,
+											(void *) &tmp, sizeof(zval *), 0);
+
+							if (incomplete_class) {
+								php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
+							}
+
+							/* Clean up old array entry */
+							zval_ptr_dtor(&ent2->data);
+
+							/* Set stack entry to point to the newly created object */
+							ent2->data = obj;
 						}
-
-						/* Clean up old array entry */
-						zval_ptr_dtor(&ent2->data);
-
-						/* Set stack entry to point to the newly created object */
-						ent2->data = obj;
-
 						/* Clean up class name var entry */
 						zval_ptr_dtor(&ent1->data);
 					} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {",php-src,6045de69c7dedcba3eadf7c4bba424b19c81d00d,6558559bcc1cd24e3639e4a215e9d546ee05fc48,1,"static void php_wddx_pop_element(void *user_data, const XML_Char *name)
{
	st_entry 			*ent1, *ent2;
	wddx_stack 			*stack = (wddx_stack *)user_data;
	HashTable 			*target_hash;
	zend_class_entry 	**pce;
	zval				*obj;
	zval				*tmp;
	TSRMLS_FETCH();

/* OBJECTS_FIXME */
	if (stack->top == 0) {
		return;
	}

	if (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||
		!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||
	  	!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||
		!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||
		!strcmp(name, EL_DATETIME)) {
		wddx_stack_top(stack, (void**)&ent1);

		if (!ent1->data) {
			if (stack->top > 1) {
				stack->top--;
				efree(ent1);
			} else {
				stack->done = 1;
			}
			return;
		}

		if (!strcmp(name, EL_BINARY)) {
			int new_len=0;
			unsigned char *new_str;

			new_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);
			STR_FREE(Z_STRVAL_P(ent1->data));
			if (new_str) {
				Z_STRVAL_P(ent1->data) = new_str;
				Z_STRLEN_P(ent1->data) = new_len;
			} else {
				ZVAL_EMPTY_STRING(ent1->data);
			}
		}

		/* Call __wakeup() method on the object. */
		if (Z_TYPE_P(ent1->data) == IS_OBJECT) {
			zval *fname, *retval = NULL;

			MAKE_STD_ZVAL(fname);
			ZVAL_STRING(fname, ""__wakeup"", 1);

			call_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);

			zval_dtor(fname);
			FREE_ZVAL(fname);
			if (retval) {
				zval_ptr_dtor(&retval);
			}
		}

		if (stack->top > 1) {
			stack->top--;
			wddx_stack_top(stack, (void**)&ent2);

			/* if non-existent field */
			if (ent2->data == NULL) {
				zval_ptr_dtor(&ent1->data);
				efree(ent1);
				return;
			}

			if (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {
				target_hash = HASH_OF(ent2->data);

				if (ent1->varname) {
					if (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&
						Z_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&
						ent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {
						zend_bool incomplete_class = 0;

						zend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
						if (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),
										   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {
							incomplete_class = 1;
 							pce = &PHP_IC_ENTRY;
 						}
 
//flaw_line_below:
						/* Initialize target object */
//flaw_line_below:
						MAKE_STD_ZVAL(obj);
//flaw_line_below:
						object_init_ex(obj, *pce);
//flaw_line_below:

//flaw_line_below:
						/* Merge current hashtable with object's default properties */
//flaw_line_below:
						zend_hash_merge(Z_OBJPROP_P(obj),
//flaw_line_below:
										Z_ARRVAL_P(ent2->data),
//flaw_line_below:
										(void (*)(void *)) zval_add_ref,
//flaw_line_below:
										(void *) &tmp, sizeof(zval *), 0);
//flaw_line_below:

//flaw_line_below:
						if (incomplete_class) {
//flaw_line_below:
							php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
//fix_flaw_line_below:
//						if (pce != &PHP_IC_ENTRY && ((*pce)->serialize || (*pce)->unserialize)) {
//fix_flaw_line_below:
//							ent2->data = NULL;
//fix_flaw_line_below:
//							php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Class %s can not be unserialized"", Z_STRVAL_P(ent1->data));
//fix_flaw_line_below:
//						} else {
//fix_flaw_line_below:
//							/* Initialize target object */
//fix_flaw_line_below:
//							MAKE_STD_ZVAL(obj);
//fix_flaw_line_below:
//							object_init_ex(obj, *pce);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//							/* Merge current hashtable with object's default properties */
//fix_flaw_line_below:
//							zend_hash_merge(Z_OBJPROP_P(obj),
//fix_flaw_line_below:
//											Z_ARRVAL_P(ent2->data),
//fix_flaw_line_below:
//											(void (*)(void *)) zval_add_ref,
//fix_flaw_line_below:
//											(void *) &tmp, sizeof(zval *), 0);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//							if (incomplete_class) {
//fix_flaw_line_below:
//								php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
//fix_flaw_line_below:
//							}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//							/* Clean up old array entry */
//fix_flaw_line_below:
//							zval_ptr_dtor(&ent2->data);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//							/* Set stack entry to point to the newly created object */
//fix_flaw_line_below:
//							ent2->data = obj;
 						}
//flaw_line_below:

//flaw_line_below:
						/* Clean up old array entry */
//flaw_line_below:
						zval_ptr_dtor(&ent2->data);
//flaw_line_below:

//flaw_line_below:
						/* Set stack entry to point to the newly created object */
//flaw_line_below:
						ent2->data = obj;
//flaw_line_below:

 						/* Clean up class name var entry */
 						zval_ptr_dtor(&ent1->data);
 					} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {
						zend_class_entry *old_scope = EG(scope);

						EG(scope) = Z_OBJCE_P(ent2->data);
						Z_DELREF_P(ent1->data);
						add_property_zval(ent2->data, ent1->varname, ent1->data);
						EG(scope) = old_scope;
					} else {
						zend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);
					}
					efree(ent1->varname);
				} else	{
					zend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);
				}
			}
			efree(ent1);
		} else {
			stack->done = 1;
		}
	} else if (!strcmp(name, EL_VAR) && stack->varname) {
		efree(stack->varname);
		stack->varname = NULL;
	} else if (!strcmp(name, EL_FIELD)) {
		st_entry *ent;
		wddx_stack_top(stack, (void **)&ent);
		efree(ent);
		stack->top--;
	}
}
"
4106,181842,,Remote,Not required,Partial,CVE-2016-9934,https://www.cvedetails.com/cve/CVE-2016-9934/,CWE-476,Low,,,,2017-01-04,5.0,"ext/wddx/wddx.c in PHP before 5.6.28 and 7.x before 7.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via crafted serialized data in a wddxPacket XML document, as demonstrated by a PDORow string.",2018-05-03,DoS ,12,https://github.com/php/php-src/commit/6045de69c7dedcba3eadf7c4bba424b19c81d00d,6045de69c7dedcba3eadf7c4bba424b19c81d00d,"Fix bug #73331 - do not try to serialize/unserialize objects wddx can not handle

Proper soltion would be to call serialize/unserialize and deal with the result,
but this requires more work that should be done by wddx maintainer (not me).",6,ext/wddx/wddx.c,"{""sha"": ""9f9ada9be3bfc1c088b166da9b69671aedabf5a9"", ""filename"": ""ext/pdo/pdo_stmt.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/php/php-src/blob/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/pdo/pdo_stmt.c"", ""raw_url"": ""https://github.com/php/php-src/raw/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/pdo/pdo_stmt.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/pdo/pdo_stmt.c?ref=6045de69c7dedcba3eadf7c4bba424b19c81d00d"", ""patch"": ""@@ -2338,6 +2338,7 @@ void pdo_stmt_init(TSRMLS_D)\n \tpdo_row_ce->ce_flags |= ZEND_ACC_FINAL_CLASS; /* when removing this a lot of handlers need to be redone */\n \tpdo_row_ce->create_object = pdo_row_new;\n \tpdo_row_ce->serialize = pdo_row_serialize;\n+\tpdo_row_ce->unserialize = zend_class_unserialize_deny;\n }\n \n static void free_statement(pdo_stmt_t *stmt TSRMLS_DC)""}<_**next**_>{""sha"": ""e76e47eab72538de32a45c31e9d6e1c7e6e86540"", ""filename"": ""ext/wddx/tests/bug45901.phpt"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/php/php-src/blob/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/tests/bug45901.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/tests/bug45901.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/tests/bug45901.phpt?ref=6045de69c7dedcba3eadf7c4bba424b19c81d00d"", ""patch"": ""@@ -14,5 +14,7 @@ echo wddx_serialize_value($xml, 'Variables') . \""\\n\"";\n echo \""DONE\"";\n ?>\n --EXPECTF--\n-<wddxPacket version='1.0'><header><comment>Variables</comment></header><data><struct><var name='php_class_name'><string>SimpleXMLElement</string></var><var name='test'><struct><var name='php_class_name'><string>SimpleXMLElement</string></var></struct></var></struct></data></wddxPacket>\n+\n+Warning: wddx_serialize_value(): Class SimpleXMLElement can not be serialized in %sbug45901.php on line %d\n+<wddxPacket version='1.0'><header><comment>Variables</comment></header><data></data></wddxPacket>\n DONE\n\\ No newline at end of file""}<_**next**_>{""sha"": ""3b08e58cc6809312bc15dd77e0fd8ed83827b04f"", ""filename"": ""ext/wddx/tests/bug72790.phpt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/php/php-src/blob/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/tests/bug72790.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/tests/bug72790.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/tests/bug72790.phpt?ref=6045de69c7dedcba3eadf7c4bba424b19c81d00d"", ""patch"": ""@@ -1,5 +1,5 @@\n --TEST--\n-Bug 72790: wddx_deserialize null dereference with invalid xml\n+Bug #72790: wddx_deserialize null dereference with invalid xml\n --SKIPIF--\n <?php\n if (!extension_loaded('wddx')) {""}<_**next**_>{""sha"": ""7e4cda1ea1166909f6c61da34b3ee51d94688652"", ""filename"": ""ext/wddx/tests/bug73331.phpt"", ""status"": ""added"", ""additions"": 15, ""deletions"": 0, ""changes"": 15, ""blob_url"": ""https://github.com/php/php-src/blob/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/tests/bug73331.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/tests/bug73331.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/tests/bug73331.phpt?ref=6045de69c7dedcba3eadf7c4bba424b19c81d00d"", ""patch"": ""@@ -0,0 +1,15 @@\n+--TEST--\n+Bug #73331 (NULL Pointer Dereference in WDDX Packet Deserialization with PDORow)\n+--SKIPIF--\n+<?php if (!extension_loaded(\""wddx\"") || !extension_loaded(\""pdo\"")) print \""skip\""; ?>\n+--FILE--\n+<?php\n+\n+$wddx = \""<wddxPacket version='1.0'><header/><data><struct><var name='php_class_name'><string>PDORow</string></var></struct></data></wddxPacket>\"";\n+var_dump(wddx_deserialize($wddx));\n+?>\n+--EXPECTF--\n+\n+Warning: wddx_deserialize(): Class pdorow can not be unserialized in %s73331.php on line %d\n+NULL\n+""}<_**next**_>{""sha"": ""59cc8ddda8a955918e260f8249996c5bf244717e"", ""filename"": ""ext/wddx/wddx.c"", ""status"": ""modified"", ""additions"": 35, ""deletions"": 32, ""changes"": 67, ""blob_url"": ""https://github.com/php/php-src/blob/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/wddx.c"", ""raw_url"": ""https://github.com/php/php-src/raw/6045de69c7dedcba3eadf7c4bba424b19c81d00d/ext/wddx/wddx.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/wddx.c?ref=6045de69c7dedcba3eadf7c4bba424b19c81d00d"", ""patch"": ""@@ -471,21 +471,26 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n \tulong idx;\n \tchar tmp_buf[WDDX_BUF_LEN];\n \tHashTable *objhash, *sleephash;\n+\tzend_class_entry *ce;\n+\tPHP_CLASS_ATTRIBUTES;\n \tTSRMLS_FETCH();\n \n+\tPHP_SET_CLASS_ATTRIBUTES(obj);\n+\tce = Z_OBJCE_P(obj);\n+\tif (!ce || ce->serialize || ce->unserialize) {\n+\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Class %s can not be serialized\"", class_name);\n+\t\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n+\t\treturn;\n+\t}\n+\n \tMAKE_STD_ZVAL(fname);\n \tZVAL_STRING(fname, \""__sleep\"", 1);\n-\n \t/*\n \t * We try to call __sleep() method on object. It's supposed to return an\n \t * array of property names to be serialized.\n \t */\n \tif (call_user_function_ex(CG(function_table), &obj, fname, &retval, 0, 0, 1, NULL TSRMLS_CC) == SUCCESS) {\n \t\tif (retval && (sleephash = HASH_OF(retval))) {\n-\t\t\tPHP_CLASS_ATTRIBUTES;\n-\n-\t\t\tPHP_SET_CLASS_ATTRIBUTES(obj);\n-\n \t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n \t\t\tsnprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);\n \t\t\tphp_wddx_add_chunk(packet, tmp_buf);\n@@ -494,8 +499,6 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n \t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_E);\n \t\t\tphp_wddx_add_chunk_static(packet, WDDX_VAR_E);\n \n-\t\t\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n-\n \t\t\tobjhash = HASH_OF(obj);\n \n \t\t\tfor (zend_hash_internal_pointer_reset(sleephash);\n@@ -516,10 +519,6 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n \t} else {\n \t\tuint key_len;\n \n-\t\tPHP_CLASS_ATTRIBUTES;\n-\n-\t\tPHP_SET_CLASS_ATTRIBUTES(obj);\n-\n \t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n \t\tsnprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);\n \t\tphp_wddx_add_chunk(packet, tmp_buf);\n@@ -528,8 +527,6 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n \t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_E);\n \t\tphp_wddx_add_chunk_static(packet, WDDX_VAR_E);\n \n-\t\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n-\n \t\tobjhash = HASH_OF(obj);\n \t\tfor (zend_hash_internal_pointer_reset(objhash);\n \t\t\t zend_hash_get_current_data(objhash, (void**)&ent) == SUCCESS;\n@@ -551,6 +548,8 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n \t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n \t}\n \n+\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n+\n \tzval_dtor(fname);\n \tFREE_ZVAL(fname);\n \n@@ -1012,26 +1011,30 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n \t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n \t\t\t\t\t\t}\n \n-\t\t\t\t\t\t/* Initialize target object */\n-\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n-\t\t\t\t\t\tobject_init_ex(obj, *pce);\n-\n-\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n-\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n-\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n-\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n-\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n-\n-\t\t\t\t\t\tif (incomplete_class) {\n-\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n+\t\t\t\t\t\tif (pce != &PHP_IC_ENTRY && ((*pce)->serialize || (*pce)->unserialize)) {\n+\t\t\t\t\t\t\tent2->data = NULL;\n+\t\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Class %s can not be unserialized\"", Z_STRVAL_P(ent1->data));\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t/* Initialize target object */\n+\t\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n+\t\t\t\t\t\t\tobject_init_ex(obj, *pce);\n+\n+\t\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n+\t\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n+\t\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n+\t\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n+\t\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n+\n+\t\t\t\t\t\t\tif (incomplete_class) {\n+\t\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t/* Clean up old array entry */\n+\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n+\n+\t\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n+\t\t\t\t\t\t\tent2->data = obj;\n \t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t/* Clean up old array entry */\n-\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n-\n-\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n-\t\t\t\t\t\tent2->data = obj;\n-\n \t\t\t\t\t\t/* Clean up class name var entry */\n \t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n \t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {""}","static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)
{
/* OBJECTS_FIXME */
	zval **ent, *fname, **varname;
	zval *retval = NULL;
	const char *key;
 	ulong idx;
 	char tmp_buf[WDDX_BUF_LEN];
 	HashTable *objhash, *sleephash;
	zend_class_entry *ce;
	PHP_CLASS_ATTRIBUTES;
 	TSRMLS_FETCH();
 
	PHP_SET_CLASS_ATTRIBUTES(obj);
	ce = Z_OBJCE_P(obj);
	if (!ce || ce->serialize || ce->unserialize) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Class %s can not be serialized"", class_name);
		PHP_CLEANUP_CLASS_ATTRIBUTES();
		return;
	}

 	MAKE_STD_ZVAL(fname);
 	ZVAL_STRING(fname, ""__sleep"", 1);
 	/*
 	 * We try to call __sleep() method on object. It's supposed to return an
 	 * array of property names to be serialized.
 	 */
 	if (call_user_function_ex(CG(function_table), &obj, fname, &retval, 0, 0, 1, NULL TSRMLS_CC) == SUCCESS) {
 		if (retval && (sleephash = HASH_OF(retval))) {
 			php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
 			snprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);
 			php_wddx_add_chunk(packet, tmp_buf);
			php_wddx_add_chunk_static(packet, WDDX_STRING_S);
			php_wddx_add_chunk_ex(packet, class_name, name_len);
 			php_wddx_add_chunk_static(packet, WDDX_STRING_E);
 			php_wddx_add_chunk_static(packet, WDDX_VAR_E);
 
 			objhash = HASH_OF(obj);
 
 			for (zend_hash_internal_pointer_reset(sleephash);
				 zend_hash_get_current_data(sleephash, (void **)&varname) == SUCCESS;
				 zend_hash_move_forward(sleephash)) {
				if (Z_TYPE_PP(varname) != IS_STRING) {
					php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""__sleep should return an array only containing the names of instance-variables to serialize."");
					continue;
				}

				if (zend_hash_find(objhash, Z_STRVAL_PP(varname), Z_STRLEN_PP(varname)+1, (void **)&ent) == SUCCESS) {
					php_wddx_serialize_var(packet, *ent, Z_STRVAL_PP(varname), Z_STRLEN_PP(varname) TSRMLS_CC);
				}
			}

			php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
		}
 	} else {
 		uint key_len;
 
 		php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
 		snprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);
 		php_wddx_add_chunk(packet, tmp_buf);
		php_wddx_add_chunk_static(packet, WDDX_STRING_S);
		php_wddx_add_chunk_ex(packet, class_name, name_len);
 		php_wddx_add_chunk_static(packet, WDDX_STRING_E);
 		php_wddx_add_chunk_static(packet, WDDX_VAR_E);
 
 		objhash = HASH_OF(obj);
 		for (zend_hash_internal_pointer_reset(objhash);
 			 zend_hash_get_current_data(objhash, (void**)&ent) == SUCCESS;
			 zend_hash_move_forward(objhash)) {
			if (*ent == obj) {
				continue;
			}

			if (zend_hash_get_current_key_ex(objhash, &key, &key_len, &idx, 0, NULL) == HASH_KEY_IS_STRING) {
				const char *class_name, *prop_name;

				zend_unmangle_property_name(key, key_len-1, &class_name, &prop_name);
				php_wddx_serialize_var(packet, *ent, prop_name, strlen(prop_name)+1 TSRMLS_CC);
			} else {
				key_len = slprintf(tmp_buf, sizeof(tmp_buf), ""%ld"", idx);
				php_wddx_serialize_var(packet, *ent, tmp_buf, key_len TSRMLS_CC);
			}
		}
 		php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
 	}
 
	PHP_CLEANUP_CLASS_ATTRIBUTES();

 	zval_dtor(fname);
 	FREE_ZVAL(fname);
 
	if (retval) {
		zval_ptr_dtor(&retval);
	}
}
","static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)
{
/* OBJECTS_FIXME */
	zval **ent, *fname, **varname;
	zval *retval = NULL;
	const char *key;
 	ulong idx;
 	char tmp_buf[WDDX_BUF_LEN];
 	HashTable *objhash, *sleephash;
 	TSRMLS_FETCH();
 
 	MAKE_STD_ZVAL(fname);
 	ZVAL_STRING(fname, ""__sleep"", 1);
 	/*
 	 * We try to call __sleep() method on object. It's supposed to return an
 	 * array of property names to be serialized.
 	 */
 	if (call_user_function_ex(CG(function_table), &obj, fname, &retval, 0, 0, 1, NULL TSRMLS_CC) == SUCCESS) {
 		if (retval && (sleephash = HASH_OF(retval))) {
			PHP_CLASS_ATTRIBUTES;
			PHP_SET_CLASS_ATTRIBUTES(obj);
 			php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
 			snprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);
 			php_wddx_add_chunk(packet, tmp_buf);
			php_wddx_add_chunk_static(packet, WDDX_STRING_S);
			php_wddx_add_chunk_ex(packet, class_name, name_len);
 			php_wddx_add_chunk_static(packet, WDDX_STRING_E);
 			php_wddx_add_chunk_static(packet, WDDX_VAR_E);
 
			PHP_CLEANUP_CLASS_ATTRIBUTES();
 			objhash = HASH_OF(obj);
 
 			for (zend_hash_internal_pointer_reset(sleephash);
				 zend_hash_get_current_data(sleephash, (void **)&varname) == SUCCESS;
				 zend_hash_move_forward(sleephash)) {
				if (Z_TYPE_PP(varname) != IS_STRING) {
					php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""__sleep should return an array only containing the names of instance-variables to serialize."");
					continue;
				}

				if (zend_hash_find(objhash, Z_STRVAL_PP(varname), Z_STRLEN_PP(varname)+1, (void **)&ent) == SUCCESS) {
					php_wddx_serialize_var(packet, *ent, Z_STRVAL_PP(varname), Z_STRLEN_PP(varname) TSRMLS_CC);
				}
			}

			php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
		}
 	} else {
 		uint key_len;
 
		PHP_CLASS_ATTRIBUTES;
		PHP_SET_CLASS_ATTRIBUTES(obj);
 		php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
 		snprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);
 		php_wddx_add_chunk(packet, tmp_buf);
		php_wddx_add_chunk_static(packet, WDDX_STRING_S);
		php_wddx_add_chunk_ex(packet, class_name, name_len);
 		php_wddx_add_chunk_static(packet, WDDX_STRING_E);
 		php_wddx_add_chunk_static(packet, WDDX_VAR_E);
 
		PHP_CLEANUP_CLASS_ATTRIBUTES();
 		objhash = HASH_OF(obj);
 		for (zend_hash_internal_pointer_reset(objhash);
 			 zend_hash_get_current_data(objhash, (void**)&ent) == SUCCESS;
			 zend_hash_move_forward(objhash)) {
			if (*ent == obj) {
				continue;
			}

			if (zend_hash_get_current_key_ex(objhash, &key, &key_len, &idx, 0, NULL) == HASH_KEY_IS_STRING) {
				const char *class_name, *prop_name;

				zend_unmangle_property_name(key, key_len-1, &class_name, &prop_name);
				php_wddx_serialize_var(packet, *ent, prop_name, strlen(prop_name)+1 TSRMLS_CC);
			} else {
				key_len = slprintf(tmp_buf, sizeof(tmp_buf), ""%ld"", idx);
				php_wddx_serialize_var(packet, *ent, tmp_buf, key_len TSRMLS_CC);
			}
		}
 		php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
 	}
 
 	zval_dtor(fname);
 	FREE_ZVAL(fname);
 
	if (retval) {
		zval_ptr_dtor(&retval);
	}
}
",C,"	zend_class_entry *ce;
	PHP_CLASS_ATTRIBUTES;
	PHP_SET_CLASS_ATTRIBUTES(obj);
	ce = Z_OBJCE_P(obj);
	if (!ce || ce->serialize || ce->unserialize) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Class %s can not be serialized"", class_name);
		PHP_CLEANUP_CLASS_ATTRIBUTES();
		return;
	}

	PHP_CLEANUP_CLASS_ATTRIBUTES();

","			PHP_CLASS_ATTRIBUTES;
			PHP_SET_CLASS_ATTRIBUTES(obj);
			PHP_CLEANUP_CLASS_ATTRIBUTES();
		PHP_CLASS_ATTRIBUTES;
		PHP_SET_CLASS_ATTRIBUTES(obj);
		PHP_CLEANUP_CLASS_ATTRIBUTES();
",,"@@ -471,21 +471,26 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)
 	ulong idx;
 	char tmp_buf[WDDX_BUF_LEN];
 	HashTable *objhash, *sleephash;
+	zend_class_entry *ce;
+	PHP_CLASS_ATTRIBUTES;
 	TSRMLS_FETCH();
 
+	PHP_SET_CLASS_ATTRIBUTES(obj);
+	ce = Z_OBJCE_P(obj);
+	if (!ce || ce->serialize || ce->unserialize) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Class %s can not be serialized"", class_name);
+		PHP_CLEANUP_CLASS_ATTRIBUTES();
+		return;
+	}
+
 	MAKE_STD_ZVAL(fname);
 	ZVAL_STRING(fname, ""__sleep"", 1);
-
 	/*
 	 * We try to call __sleep() method on object. It's supposed to return an
 	 * array of property names to be serialized.
 	 */
 	if (call_user_function_ex(CG(function_table), &obj, fname, &retval, 0, 0, 1, NULL TSRMLS_CC) == SUCCESS) {
 		if (retval && (sleephash = HASH_OF(retval))) {
-			PHP_CLASS_ATTRIBUTES;
-
-			PHP_SET_CLASS_ATTRIBUTES(obj);
-
 			php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
 			snprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);
 			php_wddx_add_chunk(packet, tmp_buf);
@@ -494,8 +499,6 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)
 			php_wddx_add_chunk_static(packet, WDDX_STRING_E);
 			php_wddx_add_chunk_static(packet, WDDX_VAR_E);
 
-			PHP_CLEANUP_CLASS_ATTRIBUTES();
-
 			objhash = HASH_OF(obj);
 
 			for (zend_hash_internal_pointer_reset(sleephash);
@@ -516,10 +519,6 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)
 	} else {
 		uint key_len;
 
-		PHP_CLASS_ATTRIBUTES;
-
-		PHP_SET_CLASS_ATTRIBUTES(obj);
-
 		php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
 		snprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);
 		php_wddx_add_chunk(packet, tmp_buf);
@@ -528,8 +527,6 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)
 		php_wddx_add_chunk_static(packet, WDDX_STRING_E);
 		php_wddx_add_chunk_static(packet, WDDX_VAR_E);
 
-		PHP_CLEANUP_CLASS_ATTRIBUTES();
-
 		objhash = HASH_OF(obj);
 		for (zend_hash_internal_pointer_reset(objhash);
 			 zend_hash_get_current_data(objhash, (void**)&ent) == SUCCESS;
@@ -551,6 +548,8 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)
 		php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
 	}
 
+	PHP_CLEANUP_CLASS_ATTRIBUTES();
+
 	zval_dtor(fname);
 	FREE_ZVAL(fname);
 
@@ -1012,26 +1011,30 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)
 							pce = &PHP_IC_ENTRY;
 						}
 
-						/* Initialize target object */
-						MAKE_STD_ZVAL(obj);
-						object_init_ex(obj, *pce);
-
-						/* Merge current hashtable with object's default properties */
-						zend_hash_merge(Z_OBJPROP_P(obj),
-										Z_ARRVAL_P(ent2->data),
-										(void (*)(void *)) zval_add_ref,
-										(void *) &tmp, sizeof(zval *), 0);
-
-						if (incomplete_class) {
-							php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
+						if (pce != &PHP_IC_ENTRY && ((*pce)->serialize || (*pce)->unserialize)) {
+							ent2->data = NULL;
+							php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Class %s can not be unserialized"", Z_STRVAL_P(ent1->data));
+						} else {
+							/* Initialize target object */
+							MAKE_STD_ZVAL(obj);
+							object_init_ex(obj, *pce);
+
+							/* Merge current hashtable with object's default properties */
+							zend_hash_merge(Z_OBJPROP_P(obj),
+											Z_ARRVAL_P(ent2->data),
+											(void (*)(void *)) zval_add_ref,
+											(void *) &tmp, sizeof(zval *), 0);
+
+							if (incomplete_class) {
+								php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
+							}
+
+							/* Clean up old array entry */
+							zval_ptr_dtor(&ent2->data);
+
+							/* Set stack entry to point to the newly created object */
+							ent2->data = obj;
 						}
-
-						/* Clean up old array entry */
-						zval_ptr_dtor(&ent2->data);
-
-						/* Set stack entry to point to the newly created object */
-						ent2->data = obj;
-
 						/* Clean up class name var entry */
 						zval_ptr_dtor(&ent1->data);
 					} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {",php-src,6045de69c7dedcba3eadf7c4bba424b19c81d00d,6558559bcc1cd24e3639e4a215e9d546ee05fc48,1,"static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)
{
/* OBJECTS_FIXME */
	zval **ent, *fname, **varname;
	zval *retval = NULL;
	const char *key;
 	ulong idx;
 	char tmp_buf[WDDX_BUF_LEN];
 	HashTable *objhash, *sleephash;
//fix_flaw_line_below:
//	zend_class_entry *ce;
//fix_flaw_line_below:
//	PHP_CLASS_ATTRIBUTES;
 	TSRMLS_FETCH();
 
//fix_flaw_line_below:
//	PHP_SET_CLASS_ATTRIBUTES(obj);
//fix_flaw_line_below:
//	ce = Z_OBJCE_P(obj);
//fix_flaw_line_below:
//	if (!ce || ce->serialize || ce->unserialize) {
//fix_flaw_line_below:
//		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Class %s can not be serialized"", class_name);
//fix_flaw_line_below:
//		PHP_CLEANUP_CLASS_ATTRIBUTES();
//fix_flaw_line_below:
//		return;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	MAKE_STD_ZVAL(fname);
 	ZVAL_STRING(fname, ""__sleep"", 1);
//flaw_line_below:

 	/*
 	 * We try to call __sleep() method on object. It's supposed to return an
 	 * array of property names to be serialized.
 	 */
 	if (call_user_function_ex(CG(function_table), &obj, fname, &retval, 0, 0, 1, NULL TSRMLS_CC) == SUCCESS) {
 		if (retval && (sleephash = HASH_OF(retval))) {
//flaw_line_below:
			PHP_CLASS_ATTRIBUTES;
//flaw_line_below:

//flaw_line_below:
			PHP_SET_CLASS_ATTRIBUTES(obj);
//flaw_line_below:

 			php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
 			snprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);
 			php_wddx_add_chunk(packet, tmp_buf);
			php_wddx_add_chunk_static(packet, WDDX_STRING_S);
			php_wddx_add_chunk_ex(packet, class_name, name_len);
 			php_wddx_add_chunk_static(packet, WDDX_STRING_E);
 			php_wddx_add_chunk_static(packet, WDDX_VAR_E);
 
//flaw_line_below:
			PHP_CLEANUP_CLASS_ATTRIBUTES();
//flaw_line_below:

 			objhash = HASH_OF(obj);
 
 			for (zend_hash_internal_pointer_reset(sleephash);
				 zend_hash_get_current_data(sleephash, (void **)&varname) == SUCCESS;
				 zend_hash_move_forward(sleephash)) {
				if (Z_TYPE_PP(varname) != IS_STRING) {
					php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""__sleep should return an array only containing the names of instance-variables to serialize."");
					continue;
				}

				if (zend_hash_find(objhash, Z_STRVAL_PP(varname), Z_STRLEN_PP(varname)+1, (void **)&ent) == SUCCESS) {
					php_wddx_serialize_var(packet, *ent, Z_STRVAL_PP(varname), Z_STRLEN_PP(varname) TSRMLS_CC);
				}
			}

			php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
		}
 	} else {
 		uint key_len;
 
//flaw_line_below:
		PHP_CLASS_ATTRIBUTES;
//flaw_line_below:

//flaw_line_below:
		PHP_SET_CLASS_ATTRIBUTES(obj);
//flaw_line_below:

 		php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
 		snprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);
 		php_wddx_add_chunk(packet, tmp_buf);
		php_wddx_add_chunk_static(packet, WDDX_STRING_S);
		php_wddx_add_chunk_ex(packet, class_name, name_len);
 		php_wddx_add_chunk_static(packet, WDDX_STRING_E);
 		php_wddx_add_chunk_static(packet, WDDX_VAR_E);
 
//flaw_line_below:
		PHP_CLEANUP_CLASS_ATTRIBUTES();
//flaw_line_below:

 		objhash = HASH_OF(obj);
 		for (zend_hash_internal_pointer_reset(objhash);
 			 zend_hash_get_current_data(objhash, (void**)&ent) == SUCCESS;
			 zend_hash_move_forward(objhash)) {
			if (*ent == obj) {
				continue;
			}

			if (zend_hash_get_current_key_ex(objhash, &key, &key_len, &idx, 0, NULL) == HASH_KEY_IS_STRING) {
				const char *class_name, *prop_name;

				zend_unmangle_property_name(key, key_len-1, &class_name, &prop_name);
				php_wddx_serialize_var(packet, *ent, prop_name, strlen(prop_name)+1 TSRMLS_CC);
			} else {
				key_len = slprintf(tmp_buf, sizeof(tmp_buf), ""%ld"", idx);
				php_wddx_serialize_var(packet, *ent, tmp_buf, key_len TSRMLS_CC);
			}
		}
 		php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
 	}
 
//fix_flaw_line_below:
//	PHP_CLEANUP_CLASS_ATTRIBUTES();
//fix_flaw_line_below:
//
 	zval_dtor(fname);
 	FREE_ZVAL(fname);
 
	if (retval) {
		zval_ptr_dtor(&retval);
	}
}
"
4114,181850,,Remote,Not required,Partial,CVE-2016-9559,https://www.cvedetails.com/cve/CVE-2016-9559/,CWE-476,Medium,,,,2017-03-01,4.3,coders/tiff.c in ImageMagick before 7.0.3.7 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) via a crafted image.,2017-11-03,DoS ,1,https://github.com/ImageMagick/ImageMagick/commit/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b,b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b,https://github.com/ImageMagick/ImageMagick/issues/298,1,MagickCore/property.c,"{""sha"": ""39fcb8ce7a7080a4dbc04ef84530d41e454ca24d"", ""filename"": ""MagickCore/property.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b/MagickCore/property.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b/MagickCore/property.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/MagickCore/property.c?ref=b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b"", ""patch"": ""@@ -213,7 +213,7 @@ MagickExport MagickBooleanType CloneImageProperties(Image *image,\n %\n %  DefineImageProperty() associates an assignment string of the form\n %  \""key=value\"" with an artifact or options. It is equivelent to\n-%  SetImageProperty()\n+%  SetImageProperty().\n %\n %  The format of the DefineImageProperty method is:\n %\n@@ -3962,7 +3962,7 @@ MagickExport MagickBooleanType SetImageProperty(Image *image,\n     {\n       /*\n         Do not 'set' single letter properties - read only shorthand.\n-       */\n+      */\n       (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n         \""SetReadOnlyProperty\"",\""`%s'\"",property);\n       return(MagickFalse);""}<_**next**_>{""sha"": ""e108920f3086a74347d0562964b98e8230029afd"", ""filename"": ""coders/tiff.c"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 15, ""changes"": 43, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b/coders/tiff.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b/coders/tiff.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/tiff.c?ref=b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b"", ""patch"": ""@@ -631,42 +631,54 @@ static void TIFFGetProperties(TIFF *tiff,Image *image,ExceptionInfo *exception)\n   unsigned long\n     *tietz;\n \n-\n-  if (TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:artist\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:copyright\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:timestamp\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:document\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:hostcomputer\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""comment\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:make\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:model\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1) &&\n+      (text != (char *) NULL))\n     {\n       if (count >= MagickPathExtent)\n         count=MagickPathExtent-1;\n       (void) CopyMagickString(message,text,count+1);\n       (void) SetImageProperty(image,\""tiff:image-id\"",message,exception);\n     }\n-  if (TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""label\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:software\"",text,exception);\n-  if (TIFFGetField(tiff,33423,&count,&text) == 1)\n+  if ((TIFFGetField(tiff,33423,&count,&text) == 1) &&\n+      (text != (char *) NULL))\n     {\n       if (count >= MagickPathExtent)\n         count=MagickPathExtent-1;\n       (void) CopyMagickString(message,text,count+1);\n       (void) SetImageProperty(image,\""tiff:kodak-33423\"",message,exception);\n     }\n-  if (TIFFGetField(tiff,36867,&count,&text) == 1)\n+  if ((TIFFGetField(tiff,36867,&count,&text) == 1) &&\n+      (text != (char *) NULL))\n     {\n       if (count >= MagickPathExtent)\n         count=MagickPathExtent-1;\n@@ -695,7 +707,8 @@ static void TIFFGetProperties(TIFF *tiff,Image *image,ExceptionInfo *exception)\n       default:\n         break;\n     }\n-  if (TIFFGetField(tiff,37706,&length,&tietz) == 1)\n+  if ((TIFFGetField(tiff,37706,&length,&tietz) == 1) &&\n+      (tietz != (unsigned long *) NULL))\n     {\n       (void) FormatLocaleString(message,MagickPathExtent,\""%lu\"",tietz[0]);\n       (void) SetImageProperty(image,\""tiff:tietz_offset\"",message,exception);""}<_**next**_>{""sha"": ""7d0dbb2e249a7b4b60a7b52ce113ed28b5ccab2e"", ""filename"": ""coders/txt.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b/coders/txt.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b/coders/txt.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/txt.c?ref=b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b"", ""patch"": ""@@ -793,8 +793,7 @@ static MagickBooleanType WriteTXTImage(const ImageInfo *image_info,Image *image,\n         (void) WriteBlobString(image,buffer);\n         (void) CopyMagickString(tuple,\""(\"",MagickPathExtent);\n         if (pixel.colorspace == GRAYColorspace)\n-          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,\n-            tuple);\n+          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,tuple);\n         else\n           {\n             ConcatenateColorComponent(&pixel,RedPixelChannel,compliance,tuple);""}","MagickExport MagickBooleanType SetImageProperty(Image *image,
  const char *property,const char *value,ExceptionInfo *exception)
{
  MagickBooleanType
    status;

  MagickStatusType
    flags;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  if (image->properties == (void *) NULL)
    image->properties=NewSplayTree(CompareSplayTreeString,
      RelinquishMagickMemory,RelinquishMagickMemory);  /* create splay-tree */
  if (value == (const char *) NULL)
    return(DeleteImageProperty(image,property));  /* delete if NULL */
  status=MagickTrue;
  if (strlen(property) <= 1)
     {
       /*
         Do not 'set' single letter properties - read only shorthand.
      */
       (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
         ""SetReadOnlyProperty"",""`%s'"",property);
       return(MagickFalse);
    }

  /* FUTURE: binary chars or quotes in key should produce a error */
  /* Set attributes with known names or special prefixes
     return result is found, or break to set a free form properity
  */
  switch (*property)
  {
#if 0  /* Percent escape's sets values with this prefix: for later use
          Throwing an exception causes this setting to fail */
    case '8':
    {
      if (LocaleNCompare(""8bim:"",property,5) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break;
    }
#endif
    case 'B':
    case 'b':
    {
      if (LocaleCompare(""background"",property) == 0)
        {
          (void) QueryColorCompliance(value,AllCompliance,
               &image->background_color,exception);
          /* check for FUTURE: value exception?? */
          /* also add user input to splay tree */
        }
      break; /* not an attribute, add as a property */
    }
    case 'C':
    case 'c':
    {
      if (LocaleCompare(""channels"",property) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      if (LocaleCompare(""colorspace"",property) == 0)
        {
          ssize_t
            colorspace;

          colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,
            value);
          if (colorspace < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          return(SetImageColorspace(image,(ColorspaceType) colorspace,exception));
        }
      if (LocaleCompare(""compose"",property) == 0)
        {
          ssize_t
            compose;

          compose=ParseCommandOption(MagickComposeOptions,MagickFalse,value);
          if (compose < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->compose=(CompositeOperator) compose;
          return(MagickTrue);
        }
      if (LocaleCompare(""compress"",property) == 0)
        {
          ssize_t
            compression;

          compression=ParseCommandOption(MagickCompressOptions,MagickFalse,
            value);
          if (compression < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->compression=(CompressionType) compression;
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
    case 'D':
    case 'd':
    {
      if (LocaleCompare(""delay"",property) == 0)
        {
          GeometryInfo
            geometry_info;

          flags=ParseGeometry(value,&geometry_info);
          if ((flags & GreaterValue) != 0)
            {
              if (image->delay > (size_t) floor(geometry_info.rho+0.5))
                image->delay=(size_t) floor(geometry_info.rho+0.5);
            }
          else
            if ((flags & LessValue) != 0)
              {
                if (image->delay < (size_t) floor(geometry_info.rho+0.5))
                  image->delay=(ssize_t)
                    floor(geometry_info.sigma+0.5);
              }
            else
              image->delay=(size_t) floor(geometry_info.rho+0.5);
          if ((flags & SigmaValue) != 0)
            image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);
          return(MagickTrue);
        }
      if (LocaleCompare(""delay_units"",property) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      if (LocaleCompare(""density"",property) == 0)
        {
          GeometryInfo
            geometry_info;

          flags=ParseGeometry(value,&geometry_info);
          image->resolution.x=geometry_info.rho;
          image->resolution.y=geometry_info.sigma;
          if ((flags & SigmaValue) == 0)
            image->resolution.y=image->resolution.x;
          return(MagickTrue);
        }
      if (LocaleCompare(""depth"",property) == 0)
        {
          image->depth=StringToUnsignedLong(value);
          return(MagickTrue);
        }
      if (LocaleCompare(""dispose"",property) == 0)
        {
          ssize_t
            dispose;

          dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,value);
          if (dispose < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->dispose=(DisposeType) dispose;
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
#if 0  /* Percent escape's sets values with this prefix: for later use
          Throwing an exception causes this setting to fail */
    case 'E':
    case 'e':
    {
      if (LocaleNCompare(""exif:"",property,5) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    }
    case 'F':
    case 'f':
    {
      if (LocaleNCompare(""fx:"",property,3) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    }
#endif
    case 'G':
    case 'g':
    {
      if (LocaleCompare(""gamma"",property) == 0)
        {
          image->gamma=StringToDouble(value,(char **) NULL);
          return(MagickTrue);
        }
      if (LocaleCompare(""gravity"",property) == 0)
        {
          ssize_t
            gravity;

          gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,value);
          if (gravity < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->gravity=(GravityType) gravity;
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
    case 'H':
    case 'h':
    {
      if (LocaleCompare(""height"",property) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    }
    case 'I':
    case 'i':
    {
      if (LocaleCompare(""intensity"",property) == 0)
        {
          ssize_t
            intensity;

          intensity=ParseCommandOption(MagickIntentOptions,MagickFalse,value);
          if (intensity < 0)
            return(MagickFalse);
          image->intensity=(PixelIntensityMethod) intensity;
          return(MagickTrue);
        }
      if (LocaleCompare(""intent"",property) == 0)
        {
          ssize_t
            rendering_intent;

          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,
            value);
          if (rendering_intent < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->rendering_intent=(RenderingIntent) rendering_intent;
          return(MagickTrue);
        }
      if (LocaleCompare(""interpolate"",property) == 0)
        {
          ssize_t
            interpolate;

          interpolate=ParseCommandOption(MagickInterpolateOptions,MagickFalse,
            value);
          if (interpolate < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->interpolate=(PixelInterpolateMethod) interpolate;
          return(MagickTrue);
        }
#if 0  /* Percent escape's sets values with this prefix: for later use
          Throwing an exception causes this setting to fail */
      if (LocaleNCompare(""iptc:"",property,5) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
#endif
      break; /* not an attribute, add as a property */
    }
    case 'K':
    case 'k':
      if (LocaleCompare(""kurtosis"",property) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    case 'L':
    case 'l':
    {
      if (LocaleCompare(""loop"",property) == 0)
        {
          image->iterations=StringToUnsignedLong(value);
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
    case 'M':
    case 'm':
      if ((LocaleCompare(""magick"",property) == 0) ||
          (LocaleCompare(""max"",property) == 0) ||
          (LocaleCompare(""mean"",property) == 0) ||
          (LocaleCompare(""min"",property) == 0) ||
          (LocaleCompare(""min"",property) == 0))
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
             ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    case 'O':
    case 'o':
      if (LocaleCompare(""opaque"",property) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    case 'P':
    case 'p':
    {
      if (LocaleCompare(""page"",property) == 0)
        {
          char
            *geometry;

          geometry=GetPageGeometry(value);
          flags=ParseAbsoluteGeometry(geometry,&image->page);
          geometry=DestroyString(geometry);
          return(MagickTrue);
        }
#if 0  /* Percent escape's sets values with this prefix: for later use
          Throwing an exception causes this setting to fail */
      if (LocaleNCompare(""pixel:"",property,6) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
#endif
      if (LocaleCompare(""profile"",property) == 0)
        {
          ImageInfo
            *image_info;

          StringInfo
            *profile;

          image_info=AcquireImageInfo();
          (void) CopyMagickString(image_info->filename,value,MagickPathExtent);
          (void) SetImageInfo(image_info,1,exception);
          profile=FileToStringInfo(image_info->filename,~0UL,exception);
          if (profile != (StringInfo *) NULL)
            status=SetImageProfile(image,image_info->magick,profile,exception);
          image_info=DestroyImageInfo(image_info);
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
    case 'R':
    case 'r':
    {
      if (LocaleCompare(""rendering-intent"",property) == 0)
        {
          ssize_t
            rendering_intent;

          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,
            value);
          if (rendering_intent < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->rendering_intent=(RenderingIntent) rendering_intent;
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
    case 'S':
    case 's':
      if ((LocaleCompare(""size"",property) == 0) ||
          (LocaleCompare(""skewness"",property) == 0) ||
          (LocaleCompare(""scenes"",property) == 0) ||
          (LocaleCompare(""standard-deviation"",property) == 0))
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    case 'T':
    case 't':
    {
      if (LocaleCompare(""tile-offset"",property) == 0)
        {
          char
            *geometry;

          geometry=GetPageGeometry(value);
          flags=ParseAbsoluteGeometry(geometry,&image->tile_offset);
          geometry=DestroyString(geometry);
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
    case 'U':
    case 'u':
    {
      if (LocaleCompare(""units"",property) == 0)
        {
          ssize_t
            units;

          units=ParseCommandOption(MagickResolutionOptions,MagickFalse,value);
          if (units < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->units=(ResolutionType) units;
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
    case 'V':
    case 'v':
    {
      if (LocaleCompare(""version"",property) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    }
    case 'W':
    case 'w':
    {
      if (LocaleCompare(""width"",property) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    }
#if 0  /* Percent escape's sets values with this prefix: for later use
          Throwing an exception causes this setting to fail */
    case 'X':
    case 'x':
    {
      if (LocaleNCompare(""xmp:"",property,4) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    }
#endif
  }
  /* Default: not an attribute, add as a property */
  status=AddValueToSplayTree((SplayTreeInfo *) image->properties,
    ConstantString(property),ConstantString(value));
  /* FUTURE: error if status is bad? */
  return(status);
}
","MagickExport MagickBooleanType SetImageProperty(Image *image,
  const char *property,const char *value,ExceptionInfo *exception)
{
  MagickBooleanType
    status;

  MagickStatusType
    flags;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  if (image->properties == (void *) NULL)
    image->properties=NewSplayTree(CompareSplayTreeString,
      RelinquishMagickMemory,RelinquishMagickMemory);  /* create splay-tree */
  if (value == (const char *) NULL)
    return(DeleteImageProperty(image,property));  /* delete if NULL */
  status=MagickTrue;
  if (strlen(property) <= 1)
     {
       /*
         Do not 'set' single letter properties - read only shorthand.
       */
       (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
         ""SetReadOnlyProperty"",""`%s'"",property);
       return(MagickFalse);
    }

  /* FUTURE: binary chars or quotes in key should produce a error */
  /* Set attributes with known names or special prefixes
     return result is found, or break to set a free form properity
  */
  switch (*property)
  {
#if 0  /* Percent escape's sets values with this prefix: for later use
          Throwing an exception causes this setting to fail */
    case '8':
    {
      if (LocaleNCompare(""8bim:"",property,5) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break;
    }
#endif
    case 'B':
    case 'b':
    {
      if (LocaleCompare(""background"",property) == 0)
        {
          (void) QueryColorCompliance(value,AllCompliance,
               &image->background_color,exception);
          /* check for FUTURE: value exception?? */
          /* also add user input to splay tree */
        }
      break; /* not an attribute, add as a property */
    }
    case 'C':
    case 'c':
    {
      if (LocaleCompare(""channels"",property) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      if (LocaleCompare(""colorspace"",property) == 0)
        {
          ssize_t
            colorspace;

          colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,
            value);
          if (colorspace < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          return(SetImageColorspace(image,(ColorspaceType) colorspace,exception));
        }
      if (LocaleCompare(""compose"",property) == 0)
        {
          ssize_t
            compose;

          compose=ParseCommandOption(MagickComposeOptions,MagickFalse,value);
          if (compose < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->compose=(CompositeOperator) compose;
          return(MagickTrue);
        }
      if (LocaleCompare(""compress"",property) == 0)
        {
          ssize_t
            compression;

          compression=ParseCommandOption(MagickCompressOptions,MagickFalse,
            value);
          if (compression < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->compression=(CompressionType) compression;
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
    case 'D':
    case 'd':
    {
      if (LocaleCompare(""delay"",property) == 0)
        {
          GeometryInfo
            geometry_info;

          flags=ParseGeometry(value,&geometry_info);
          if ((flags & GreaterValue) != 0)
            {
              if (image->delay > (size_t) floor(geometry_info.rho+0.5))
                image->delay=(size_t) floor(geometry_info.rho+0.5);
            }
          else
            if ((flags & LessValue) != 0)
              {
                if (image->delay < (size_t) floor(geometry_info.rho+0.5))
                  image->delay=(ssize_t)
                    floor(geometry_info.sigma+0.5);
              }
            else
              image->delay=(size_t) floor(geometry_info.rho+0.5);
          if ((flags & SigmaValue) != 0)
            image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);
          return(MagickTrue);
        }
      if (LocaleCompare(""delay_units"",property) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      if (LocaleCompare(""density"",property) == 0)
        {
          GeometryInfo
            geometry_info;

          flags=ParseGeometry(value,&geometry_info);
          image->resolution.x=geometry_info.rho;
          image->resolution.y=geometry_info.sigma;
          if ((flags & SigmaValue) == 0)
            image->resolution.y=image->resolution.x;
          return(MagickTrue);
        }
      if (LocaleCompare(""depth"",property) == 0)
        {
          image->depth=StringToUnsignedLong(value);
          return(MagickTrue);
        }
      if (LocaleCompare(""dispose"",property) == 0)
        {
          ssize_t
            dispose;

          dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,value);
          if (dispose < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->dispose=(DisposeType) dispose;
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
#if 0  /* Percent escape's sets values with this prefix: for later use
          Throwing an exception causes this setting to fail */
    case 'E':
    case 'e':
    {
      if (LocaleNCompare(""exif:"",property,5) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    }
    case 'F':
    case 'f':
    {
      if (LocaleNCompare(""fx:"",property,3) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    }
#endif
    case 'G':
    case 'g':
    {
      if (LocaleCompare(""gamma"",property) == 0)
        {
          image->gamma=StringToDouble(value,(char **) NULL);
          return(MagickTrue);
        }
      if (LocaleCompare(""gravity"",property) == 0)
        {
          ssize_t
            gravity;

          gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,value);
          if (gravity < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->gravity=(GravityType) gravity;
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
    case 'H':
    case 'h':
    {
      if (LocaleCompare(""height"",property) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    }
    case 'I':
    case 'i':
    {
      if (LocaleCompare(""intensity"",property) == 0)
        {
          ssize_t
            intensity;

          intensity=ParseCommandOption(MagickIntentOptions,MagickFalse,value);
          if (intensity < 0)
            return(MagickFalse);
          image->intensity=(PixelIntensityMethod) intensity;
          return(MagickTrue);
        }
      if (LocaleCompare(""intent"",property) == 0)
        {
          ssize_t
            rendering_intent;

          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,
            value);
          if (rendering_intent < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->rendering_intent=(RenderingIntent) rendering_intent;
          return(MagickTrue);
        }
      if (LocaleCompare(""interpolate"",property) == 0)
        {
          ssize_t
            interpolate;

          interpolate=ParseCommandOption(MagickInterpolateOptions,MagickFalse,
            value);
          if (interpolate < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->interpolate=(PixelInterpolateMethod) interpolate;
          return(MagickTrue);
        }
#if 0  /* Percent escape's sets values with this prefix: for later use
          Throwing an exception causes this setting to fail */
      if (LocaleNCompare(""iptc:"",property,5) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
#endif
      break; /* not an attribute, add as a property */
    }
    case 'K':
    case 'k':
      if (LocaleCompare(""kurtosis"",property) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    case 'L':
    case 'l':
    {
      if (LocaleCompare(""loop"",property) == 0)
        {
          image->iterations=StringToUnsignedLong(value);
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
    case 'M':
    case 'm':
      if ((LocaleCompare(""magick"",property) == 0) ||
          (LocaleCompare(""max"",property) == 0) ||
          (LocaleCompare(""mean"",property) == 0) ||
          (LocaleCompare(""min"",property) == 0) ||
          (LocaleCompare(""min"",property) == 0))
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
             ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    case 'O':
    case 'o':
      if (LocaleCompare(""opaque"",property) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    case 'P':
    case 'p':
    {
      if (LocaleCompare(""page"",property) == 0)
        {
          char
            *geometry;

          geometry=GetPageGeometry(value);
          flags=ParseAbsoluteGeometry(geometry,&image->page);
          geometry=DestroyString(geometry);
          return(MagickTrue);
        }
#if 0  /* Percent escape's sets values with this prefix: for later use
          Throwing an exception causes this setting to fail */
      if (LocaleNCompare(""pixel:"",property,6) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
#endif
      if (LocaleCompare(""profile"",property) == 0)
        {
          ImageInfo
            *image_info;

          StringInfo
            *profile;

          image_info=AcquireImageInfo();
          (void) CopyMagickString(image_info->filename,value,MagickPathExtent);
          (void) SetImageInfo(image_info,1,exception);
          profile=FileToStringInfo(image_info->filename,~0UL,exception);
          if (profile != (StringInfo *) NULL)
            status=SetImageProfile(image,image_info->magick,profile,exception);
          image_info=DestroyImageInfo(image_info);
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
    case 'R':
    case 'r':
    {
      if (LocaleCompare(""rendering-intent"",property) == 0)
        {
          ssize_t
            rendering_intent;

          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,
            value);
          if (rendering_intent < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->rendering_intent=(RenderingIntent) rendering_intent;
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
    case 'S':
    case 's':
      if ((LocaleCompare(""size"",property) == 0) ||
          (LocaleCompare(""skewness"",property) == 0) ||
          (LocaleCompare(""scenes"",property) == 0) ||
          (LocaleCompare(""standard-deviation"",property) == 0))
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    case 'T':
    case 't':
    {
      if (LocaleCompare(""tile-offset"",property) == 0)
        {
          char
            *geometry;

          geometry=GetPageGeometry(value);
          flags=ParseAbsoluteGeometry(geometry,&image->tile_offset);
          geometry=DestroyString(geometry);
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
    case 'U':
    case 'u':
    {
      if (LocaleCompare(""units"",property) == 0)
        {
          ssize_t
            units;

          units=ParseCommandOption(MagickResolutionOptions,MagickFalse,value);
          if (units < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->units=(ResolutionType) units;
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
    case 'V':
    case 'v':
    {
      if (LocaleCompare(""version"",property) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    }
    case 'W':
    case 'w':
    {
      if (LocaleCompare(""width"",property) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    }
#if 0  /* Percent escape's sets values with this prefix: for later use
          Throwing an exception causes this setting to fail */
    case 'X':
    case 'x':
    {
      if (LocaleNCompare(""xmp:"",property,4) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    }
#endif
  }
  /* Default: not an attribute, add as a property */
  status=AddValueToSplayTree((SplayTreeInfo *) image->properties,
    ConstantString(property),ConstantString(value));
  /* FUTURE: error if status is bad? */
  return(status);
}
",C,"      */
","       */
",,"@@ -213,7 +213,7 @@ MagickExport MagickBooleanType CloneImageProperties(Image *image,
 %
 %  DefineImageProperty() associates an assignment string of the form
 %  ""key=value"" with an artifact or options. It is equivelent to
-%  SetImageProperty()
+%  SetImageProperty().
 %
 %  The format of the DefineImageProperty method is:
 %
@@ -3962,7 +3962,7 @@ MagickExport MagickBooleanType SetImageProperty(Image *image,
     {
       /*
         Do not 'set' single letter properties - read only shorthand.
-       */
+      */
       (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
         ""SetReadOnlyProperty"",""`%s'"",property);
       return(MagickFalse);",ImageMagick,b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b,b1c211487f6e69857fca7a2c5f1bcb52f00e9fe2,1,"MagickExport MagickBooleanType SetImageProperty(Image *image,
  const char *property,const char *value,ExceptionInfo *exception)
{
  MagickBooleanType
    status;

  MagickStatusType
    flags;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  if (image->properties == (void *) NULL)
    image->properties=NewSplayTree(CompareSplayTreeString,
      RelinquishMagickMemory,RelinquishMagickMemory);  /* create splay-tree */
  if (value == (const char *) NULL)
    return(DeleteImageProperty(image,property));  /* delete if NULL */
  status=MagickTrue;
  if (strlen(property) <= 1)
     {
       /*
         Do not 'set' single letter properties - read only shorthand.
//flaw_line_below:
       */
//fix_flaw_line_below:
//      */
       (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
         ""SetReadOnlyProperty"",""`%s'"",property);
       return(MagickFalse);
    }

  /* FUTURE: binary chars or quotes in key should produce a error */
  /* Set attributes with known names or special prefixes
     return result is found, or break to set a free form properity
  */
  switch (*property)
  {
#if 0  /* Percent escape's sets values with this prefix: for later use
          Throwing an exception causes this setting to fail */
    case '8':
    {
      if (LocaleNCompare(""8bim:"",property,5) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break;
    }
#endif
    case 'B':
    case 'b':
    {
      if (LocaleCompare(""background"",property) == 0)
        {
          (void) QueryColorCompliance(value,AllCompliance,
               &image->background_color,exception);
          /* check for FUTURE: value exception?? */
          /* also add user input to splay tree */
        }
      break; /* not an attribute, add as a property */
    }
    case 'C':
    case 'c':
    {
      if (LocaleCompare(""channels"",property) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      if (LocaleCompare(""colorspace"",property) == 0)
        {
          ssize_t
            colorspace;

          colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,
            value);
          if (colorspace < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          return(SetImageColorspace(image,(ColorspaceType) colorspace,exception));
        }
      if (LocaleCompare(""compose"",property) == 0)
        {
          ssize_t
            compose;

          compose=ParseCommandOption(MagickComposeOptions,MagickFalse,value);
          if (compose < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->compose=(CompositeOperator) compose;
          return(MagickTrue);
        }
      if (LocaleCompare(""compress"",property) == 0)
        {
          ssize_t
            compression;

          compression=ParseCommandOption(MagickCompressOptions,MagickFalse,
            value);
          if (compression < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->compression=(CompressionType) compression;
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
    case 'D':
    case 'd':
    {
      if (LocaleCompare(""delay"",property) == 0)
        {
          GeometryInfo
            geometry_info;

          flags=ParseGeometry(value,&geometry_info);
          if ((flags & GreaterValue) != 0)
            {
              if (image->delay > (size_t) floor(geometry_info.rho+0.5))
                image->delay=(size_t) floor(geometry_info.rho+0.5);
            }
          else
            if ((flags & LessValue) != 0)
              {
                if (image->delay < (size_t) floor(geometry_info.rho+0.5))
                  image->delay=(ssize_t)
                    floor(geometry_info.sigma+0.5);
              }
            else
              image->delay=(size_t) floor(geometry_info.rho+0.5);
          if ((flags & SigmaValue) != 0)
            image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);
          return(MagickTrue);
        }
      if (LocaleCompare(""delay_units"",property) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      if (LocaleCompare(""density"",property) == 0)
        {
          GeometryInfo
            geometry_info;

          flags=ParseGeometry(value,&geometry_info);
          image->resolution.x=geometry_info.rho;
          image->resolution.y=geometry_info.sigma;
          if ((flags & SigmaValue) == 0)
            image->resolution.y=image->resolution.x;
          return(MagickTrue);
        }
      if (LocaleCompare(""depth"",property) == 0)
        {
          image->depth=StringToUnsignedLong(value);
          return(MagickTrue);
        }
      if (LocaleCompare(""dispose"",property) == 0)
        {
          ssize_t
            dispose;

          dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,value);
          if (dispose < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->dispose=(DisposeType) dispose;
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
#if 0  /* Percent escape's sets values with this prefix: for later use
          Throwing an exception causes this setting to fail */
    case 'E':
    case 'e':
    {
      if (LocaleNCompare(""exif:"",property,5) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    }
    case 'F':
    case 'f':
    {
      if (LocaleNCompare(""fx:"",property,3) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    }
#endif
    case 'G':
    case 'g':
    {
      if (LocaleCompare(""gamma"",property) == 0)
        {
          image->gamma=StringToDouble(value,(char **) NULL);
          return(MagickTrue);
        }
      if (LocaleCompare(""gravity"",property) == 0)
        {
          ssize_t
            gravity;

          gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,value);
          if (gravity < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->gravity=(GravityType) gravity;
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
    case 'H':
    case 'h':
    {
      if (LocaleCompare(""height"",property) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    }
    case 'I':
    case 'i':
    {
      if (LocaleCompare(""intensity"",property) == 0)
        {
          ssize_t
            intensity;

          intensity=ParseCommandOption(MagickIntentOptions,MagickFalse,value);
          if (intensity < 0)
            return(MagickFalse);
          image->intensity=(PixelIntensityMethod) intensity;
          return(MagickTrue);
        }
      if (LocaleCompare(""intent"",property) == 0)
        {
          ssize_t
            rendering_intent;

          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,
            value);
          if (rendering_intent < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->rendering_intent=(RenderingIntent) rendering_intent;
          return(MagickTrue);
        }
      if (LocaleCompare(""interpolate"",property) == 0)
        {
          ssize_t
            interpolate;

          interpolate=ParseCommandOption(MagickInterpolateOptions,MagickFalse,
            value);
          if (interpolate < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->interpolate=(PixelInterpolateMethod) interpolate;
          return(MagickTrue);
        }
#if 0  /* Percent escape's sets values with this prefix: for later use
          Throwing an exception causes this setting to fail */
      if (LocaleNCompare(""iptc:"",property,5) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
#endif
      break; /* not an attribute, add as a property */
    }
    case 'K':
    case 'k':
      if (LocaleCompare(""kurtosis"",property) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    case 'L':
    case 'l':
    {
      if (LocaleCompare(""loop"",property) == 0)
        {
          image->iterations=StringToUnsignedLong(value);
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
    case 'M':
    case 'm':
      if ((LocaleCompare(""magick"",property) == 0) ||
          (LocaleCompare(""max"",property) == 0) ||
          (LocaleCompare(""mean"",property) == 0) ||
          (LocaleCompare(""min"",property) == 0) ||
          (LocaleCompare(""min"",property) == 0))
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
             ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    case 'O':
    case 'o':
      if (LocaleCompare(""opaque"",property) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    case 'P':
    case 'p':
    {
      if (LocaleCompare(""page"",property) == 0)
        {
          char
            *geometry;

          geometry=GetPageGeometry(value);
          flags=ParseAbsoluteGeometry(geometry,&image->page);
          geometry=DestroyString(geometry);
          return(MagickTrue);
        }
#if 0  /* Percent escape's sets values with this prefix: for later use
          Throwing an exception causes this setting to fail */
      if (LocaleNCompare(""pixel:"",property,6) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
#endif
      if (LocaleCompare(""profile"",property) == 0)
        {
          ImageInfo
            *image_info;

          StringInfo
            *profile;

          image_info=AcquireImageInfo();
          (void) CopyMagickString(image_info->filename,value,MagickPathExtent);
          (void) SetImageInfo(image_info,1,exception);
          profile=FileToStringInfo(image_info->filename,~0UL,exception);
          if (profile != (StringInfo *) NULL)
            status=SetImageProfile(image,image_info->magick,profile,exception);
          image_info=DestroyImageInfo(image_info);
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
    case 'R':
    case 'r':
    {
      if (LocaleCompare(""rendering-intent"",property) == 0)
        {
          ssize_t
            rendering_intent;

          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,
            value);
          if (rendering_intent < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->rendering_intent=(RenderingIntent) rendering_intent;
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
    case 'S':
    case 's':
      if ((LocaleCompare(""size"",property) == 0) ||
          (LocaleCompare(""skewness"",property) == 0) ||
          (LocaleCompare(""scenes"",property) == 0) ||
          (LocaleCompare(""standard-deviation"",property) == 0))
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    case 'T':
    case 't':
    {
      if (LocaleCompare(""tile-offset"",property) == 0)
        {
          char
            *geometry;

          geometry=GetPageGeometry(value);
          flags=ParseAbsoluteGeometry(geometry,&image->tile_offset);
          geometry=DestroyString(geometry);
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
    case 'U':
    case 'u':
    {
      if (LocaleCompare(""units"",property) == 0)
        {
          ssize_t
            units;

          units=ParseCommandOption(MagickResolutionOptions,MagickFalse,value);
          if (units < 0)
            return(MagickFalse); /* FUTURE: value exception?? */
          image->units=(ResolutionType) units;
          return(MagickTrue);
        }
      break; /* not an attribute, add as a property */
    }
    case 'V':
    case 'v':
    {
      if (LocaleCompare(""version"",property) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    }
    case 'W':
    case 'w':
    {
      if (LocaleCompare(""width"",property) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    }
#if 0  /* Percent escape's sets values with this prefix: for later use
          Throwing an exception causes this setting to fail */
    case 'X':
    case 'x':
    {
      if (LocaleNCompare(""xmp:"",property,4) == 0)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""SetReadOnlyProperty"",""`%s'"",property);
          return(MagickFalse);
        }
      break; /* not an attribute, add as a property */
    }
#endif
  }
  /* Default: not an attribute, add as a property */
  status=AddValueToSplayTree((SplayTreeInfo *) image->properties,
    ConstantString(property),ConstantString(value));
  /* FUTURE: error if status is bad? */
  return(status);
}
"
4115,181851,,Remote,Not required,Partial,CVE-2016-9559,https://www.cvedetails.com/cve/CVE-2016-9559/,CWE-476,Medium,,,,2017-03-01,4.3,coders/tiff.c in ImageMagick before 7.0.3.7 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) via a crafted image.,2017-11-03,DoS ,28,https://github.com/ImageMagick/ImageMagick/commit/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b,b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b,https://github.com/ImageMagick/ImageMagick/issues/298,14,coders/tiff.c,"{""sha"": ""39fcb8ce7a7080a4dbc04ef84530d41e454ca24d"", ""filename"": ""MagickCore/property.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b/MagickCore/property.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b/MagickCore/property.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/MagickCore/property.c?ref=b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b"", ""patch"": ""@@ -213,7 +213,7 @@ MagickExport MagickBooleanType CloneImageProperties(Image *image,\n %\n %  DefineImageProperty() associates an assignment string of the form\n %  \""key=value\"" with an artifact or options. It is equivelent to\n-%  SetImageProperty()\n+%  SetImageProperty().\n %\n %  The format of the DefineImageProperty method is:\n %\n@@ -3962,7 +3962,7 @@ MagickExport MagickBooleanType SetImageProperty(Image *image,\n     {\n       /*\n         Do not 'set' single letter properties - read only shorthand.\n-       */\n+      */\n       (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n         \""SetReadOnlyProperty\"",\""`%s'\"",property);\n       return(MagickFalse);""}<_**next**_>{""sha"": ""e108920f3086a74347d0562964b98e8230029afd"", ""filename"": ""coders/tiff.c"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 15, ""changes"": 43, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b/coders/tiff.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b/coders/tiff.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/tiff.c?ref=b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b"", ""patch"": ""@@ -631,42 +631,54 @@ static void TIFFGetProperties(TIFF *tiff,Image *image,ExceptionInfo *exception)\n   unsigned long\n     *tietz;\n \n-\n-  if (TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:artist\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:copyright\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:timestamp\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:document\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:hostcomputer\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""comment\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:make\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:model\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1) &&\n+      (text != (char *) NULL))\n     {\n       if (count >= MagickPathExtent)\n         count=MagickPathExtent-1;\n       (void) CopyMagickString(message,text,count+1);\n       (void) SetImageProperty(image,\""tiff:image-id\"",message,exception);\n     }\n-  if (TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""label\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:software\"",text,exception);\n-  if (TIFFGetField(tiff,33423,&count,&text) == 1)\n+  if ((TIFFGetField(tiff,33423,&count,&text) == 1) &&\n+      (text != (char *) NULL))\n     {\n       if (count >= MagickPathExtent)\n         count=MagickPathExtent-1;\n       (void) CopyMagickString(message,text,count+1);\n       (void) SetImageProperty(image,\""tiff:kodak-33423\"",message,exception);\n     }\n-  if (TIFFGetField(tiff,36867,&count,&text) == 1)\n+  if ((TIFFGetField(tiff,36867,&count,&text) == 1) &&\n+      (text != (char *) NULL))\n     {\n       if (count >= MagickPathExtent)\n         count=MagickPathExtent-1;\n@@ -695,7 +707,8 @@ static void TIFFGetProperties(TIFF *tiff,Image *image,ExceptionInfo *exception)\n       default:\n         break;\n     }\n-  if (TIFFGetField(tiff,37706,&length,&tietz) == 1)\n+  if ((TIFFGetField(tiff,37706,&length,&tietz) == 1) &&\n+      (tietz != (unsigned long *) NULL))\n     {\n       (void) FormatLocaleString(message,MagickPathExtent,\""%lu\"",tietz[0]);\n       (void) SetImageProperty(image,\""tiff:tietz_offset\"",message,exception);""}<_**next**_>{""sha"": ""7d0dbb2e249a7b4b60a7b52ce113ed28b5ccab2e"", ""filename"": ""coders/txt.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b/coders/txt.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b/coders/txt.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/txt.c?ref=b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b"", ""patch"": ""@@ -793,8 +793,7 @@ static MagickBooleanType WriteTXTImage(const ImageInfo *image_info,Image *image,\n         (void) WriteBlobString(image,buffer);\n         (void) CopyMagickString(tuple,\""(\"",MagickPathExtent);\n         if (pixel.colorspace == GRAYColorspace)\n-          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,\n-            tuple);\n+          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,tuple);\n         else\n           {\n             ConcatenateColorComponent(&pixel,RedPixelChannel,compliance,tuple);""}","static void TIFFGetProperties(TIFF *tiff,Image *image,ExceptionInfo *exception)
{
  char
    message[MagickPathExtent],
    *text;

  uint32
    count,
    length,
    type;

   unsigned long
     *tietz;
 
  if ((TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1) &&
      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:artist"",text,exception);
  if ((TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1) &&
      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:copyright"",text,exception);
  if ((TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1) &&
      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:timestamp"",text,exception);
  if ((TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1) &&
      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:document"",text,exception);
  if ((TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1) &&
      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:hostcomputer"",text,exception);
  if ((TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1) &&
      (text != (char *) NULL))
     (void) SetImageProperty(image,""comment"",text,exception);
  if ((TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1) &&
      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:make"",text,exception);
  if ((TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1) &&
      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:model"",text,exception);
  if ((TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1) &&
      (text != (char *) NULL))
     {
       if (count >= MagickPathExtent)
         count=MagickPathExtent-1;
       (void) CopyMagickString(message,text,count+1);
       (void) SetImageProperty(image,""tiff:image-id"",message,exception);
     }
  if ((TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1) &&
      (text != (char *) NULL))
     (void) SetImageProperty(image,""label"",text,exception);
  if ((TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1) &&
      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:software"",text,exception);
  if ((TIFFGetField(tiff,33423,&count,&text) == 1) &&
      (text != (char *) NULL))
     {
       if (count >= MagickPathExtent)
         count=MagickPathExtent-1;
       (void) CopyMagickString(message,text,count+1);
       (void) SetImageProperty(image,""tiff:kodak-33423"",message,exception);
     }
  if ((TIFFGetField(tiff,36867,&count,&text) == 1) &&
      (text != (char *) NULL))
     {
       if (count >= MagickPathExtent)
         count=MagickPathExtent-1;
      (void) CopyMagickString(message,text,count+1);
      (void) SetImageProperty(image,""tiff:kodak-36867"",message,exception);
    }
  if (TIFFGetField(tiff,TIFFTAG_SUBFILETYPE,&type) == 1)
    switch (type)
    {
      case 0x01:
      {
        (void) SetImageProperty(image,""tiff:subfiletype"",""REDUCEDIMAGE"",
          exception);
        break;
      }
      case 0x02:
      {
        (void) SetImageProperty(image,""tiff:subfiletype"",""PAGE"",exception);
        break;
      }
      case 0x04:
      {
        (void) SetImageProperty(image,""tiff:subfiletype"",""MASK"",exception);
        break;
      }
       default:
         break;
     }
  if ((TIFFGetField(tiff,37706,&length,&tietz) == 1) &&
      (tietz != (unsigned long *) NULL))
     {
       (void) FormatLocaleString(message,MagickPathExtent,""%lu"",tietz[0]);
       (void) SetImageProperty(image,""tiff:tietz_offset"",message,exception);
    }
}
","static void TIFFGetProperties(TIFF *tiff,Image *image,ExceptionInfo *exception)
{
  char
    message[MagickPathExtent],
    *text;

  uint32
    count,
    length,
    type;

   unsigned long
     *tietz;
 
  if (TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1)
     (void) SetImageProperty(image,""tiff:artist"",text,exception);
  if (TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1)
     (void) SetImageProperty(image,""tiff:copyright"",text,exception);
  if (TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1)
     (void) SetImageProperty(image,""tiff:timestamp"",text,exception);
  if (TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1)
     (void) SetImageProperty(image,""tiff:document"",text,exception);
  if (TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1)
     (void) SetImageProperty(image,""tiff:hostcomputer"",text,exception);
  if (TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1)
     (void) SetImageProperty(image,""comment"",text,exception);
  if (TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1)
     (void) SetImageProperty(image,""tiff:make"",text,exception);
  if (TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1)
     (void) SetImageProperty(image,""tiff:model"",text,exception);
  if (TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1)
     {
       if (count >= MagickPathExtent)
         count=MagickPathExtent-1;
       (void) CopyMagickString(message,text,count+1);
       (void) SetImageProperty(image,""tiff:image-id"",message,exception);
     }
  if (TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1)
     (void) SetImageProperty(image,""label"",text,exception);
  if (TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1)
     (void) SetImageProperty(image,""tiff:software"",text,exception);
  if (TIFFGetField(tiff,33423,&count,&text) == 1)
     {
       if (count >= MagickPathExtent)
         count=MagickPathExtent-1;
       (void) CopyMagickString(message,text,count+1);
       (void) SetImageProperty(image,""tiff:kodak-33423"",message,exception);
     }
  if (TIFFGetField(tiff,36867,&count,&text) == 1)
     {
       if (count >= MagickPathExtent)
         count=MagickPathExtent-1;
      (void) CopyMagickString(message,text,count+1);
      (void) SetImageProperty(image,""tiff:kodak-36867"",message,exception);
    }
  if (TIFFGetField(tiff,TIFFTAG_SUBFILETYPE,&type) == 1)
    switch (type)
    {
      case 0x01:
      {
        (void) SetImageProperty(image,""tiff:subfiletype"",""REDUCEDIMAGE"",
          exception);
        break;
      }
      case 0x02:
      {
        (void) SetImageProperty(image,""tiff:subfiletype"",""PAGE"",exception);
        break;
      }
      case 0x04:
      {
        (void) SetImageProperty(image,""tiff:subfiletype"",""MASK"",exception);
        break;
      }
       default:
         break;
     }
  if (TIFFGetField(tiff,37706,&length,&tietz) == 1)
     {
       (void) FormatLocaleString(message,MagickPathExtent,""%lu"",tietz[0]);
       (void) SetImageProperty(image,""tiff:tietz_offset"",message,exception);
    }
}
",C,"  if ((TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1) &&
      (text != (char *) NULL))
  if ((TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1) &&
      (text != (char *) NULL))
  if ((TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1) &&
      (text != (char *) NULL))
  if ((TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1) &&
      (text != (char *) NULL))
  if ((TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1) &&
      (text != (char *) NULL))
  if ((TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1) &&
      (text != (char *) NULL))
  if ((TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1) &&
      (text != (char *) NULL))
  if ((TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1) &&
      (text != (char *) NULL))
  if ((TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1) &&
      (text != (char *) NULL))
  if ((TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1) &&
      (text != (char *) NULL))
  if ((TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1) &&
      (text != (char *) NULL))
  if ((TIFFGetField(tiff,33423,&count,&text) == 1) &&
      (text != (char *) NULL))
  if ((TIFFGetField(tiff,36867,&count,&text) == 1) &&
      (text != (char *) NULL))
  if ((TIFFGetField(tiff,37706,&length,&tietz) == 1) &&
      (tietz != (unsigned long *) NULL))
","  if (TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1)
  if (TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1)
  if (TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1)
  if (TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1)
  if (TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1)
  if (TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1)
  if (TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1)
  if (TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1)
  if (TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1)
  if (TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1)
  if (TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1)
  if (TIFFGetField(tiff,33423,&count,&text) == 1)
  if (TIFFGetField(tiff,36867,&count,&text) == 1)
  if (TIFFGetField(tiff,37706,&length,&tietz) == 1)
",,"@@ -631,42 +631,54 @@ static void TIFFGetProperties(TIFF *tiff,Image *image,ExceptionInfo *exception)
   unsigned long
     *tietz;
 
-
-  if (TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1)
+  if ((TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1) &&
+      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:artist"",text,exception);
-  if (TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1)
+  if ((TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1) &&
+      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:copyright"",text,exception);
-  if (TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1)
+  if ((TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1) &&
+      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:timestamp"",text,exception);
-  if (TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1)
+  if ((TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1) &&
+      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:document"",text,exception);
-  if (TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1)
+  if ((TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1) &&
+      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:hostcomputer"",text,exception);
-  if (TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1)
+  if ((TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1) &&
+      (text != (char *) NULL))
     (void) SetImageProperty(image,""comment"",text,exception);
-  if (TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1)
+  if ((TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1) &&
+      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:make"",text,exception);
-  if (TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1)
+  if ((TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1) &&
+      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:model"",text,exception);
-  if (TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1)
+  if ((TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1) &&
+      (text != (char *) NULL))
     {
       if (count >= MagickPathExtent)
         count=MagickPathExtent-1;
       (void) CopyMagickString(message,text,count+1);
       (void) SetImageProperty(image,""tiff:image-id"",message,exception);
     }
-  if (TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1)
+  if ((TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1) &&
+      (text != (char *) NULL))
     (void) SetImageProperty(image,""label"",text,exception);
-  if (TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1)
+  if ((TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1) &&
+      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:software"",text,exception);
-  if (TIFFGetField(tiff,33423,&count,&text) == 1)
+  if ((TIFFGetField(tiff,33423,&count,&text) == 1) &&
+      (text != (char *) NULL))
     {
       if (count >= MagickPathExtent)
         count=MagickPathExtent-1;
       (void) CopyMagickString(message,text,count+1);
       (void) SetImageProperty(image,""tiff:kodak-33423"",message,exception);
     }
-  if (TIFFGetField(tiff,36867,&count,&text) == 1)
+  if ((TIFFGetField(tiff,36867,&count,&text) == 1) &&
+      (text != (char *) NULL))
     {
       if (count >= MagickPathExtent)
         count=MagickPathExtent-1;
@@ -695,7 +707,8 @@ static void TIFFGetProperties(TIFF *tiff,Image *image,ExceptionInfo *exception)
       default:
         break;
     }
-  if (TIFFGetField(tiff,37706,&length,&tietz) == 1)
+  if ((TIFFGetField(tiff,37706,&length,&tietz) == 1) &&
+      (tietz != (unsigned long *) NULL))
     {
       (void) FormatLocaleString(message,MagickPathExtent,""%lu"",tietz[0]);
       (void) SetImageProperty(image,""tiff:tietz_offset"",message,exception);",ImageMagick,b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b,b1c211487f6e69857fca7a2c5f1bcb52f00e9fe2,1,"static void TIFFGetProperties(TIFF *tiff,Image *image,ExceptionInfo *exception)
{
  char
    message[MagickPathExtent],
    *text;

  uint32
    count,
    length,
    type;

   unsigned long
     *tietz;
 
//flaw_line_below:

//flaw_line_below:
  if (TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1)
//fix_flaw_line_below:
//  if ((TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1) &&
//fix_flaw_line_below:
//      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:artist"",text,exception);
//flaw_line_below:
  if (TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1)
//fix_flaw_line_below:
//  if ((TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1) &&
//fix_flaw_line_below:
//      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:copyright"",text,exception);
//flaw_line_below:
  if (TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1)
//fix_flaw_line_below:
//  if ((TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1) &&
//fix_flaw_line_below:
//      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:timestamp"",text,exception);
//flaw_line_below:
  if (TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1)
//fix_flaw_line_below:
//  if ((TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1) &&
//fix_flaw_line_below:
//      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:document"",text,exception);
//flaw_line_below:
  if (TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1)
//fix_flaw_line_below:
//  if ((TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1) &&
//fix_flaw_line_below:
//      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:hostcomputer"",text,exception);
//flaw_line_below:
  if (TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1)
//fix_flaw_line_below:
//  if ((TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1) &&
//fix_flaw_line_below:
//      (text != (char *) NULL))
     (void) SetImageProperty(image,""comment"",text,exception);
//flaw_line_below:
  if (TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1)
//fix_flaw_line_below:
//  if ((TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1) &&
//fix_flaw_line_below:
//      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:make"",text,exception);
//flaw_line_below:
  if (TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1)
//fix_flaw_line_below:
//  if ((TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1) &&
//fix_flaw_line_below:
//      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:model"",text,exception);
//flaw_line_below:
  if (TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1)
//fix_flaw_line_below:
//  if ((TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1) &&
//fix_flaw_line_below:
//      (text != (char *) NULL))
     {
       if (count >= MagickPathExtent)
         count=MagickPathExtent-1;
       (void) CopyMagickString(message,text,count+1);
       (void) SetImageProperty(image,""tiff:image-id"",message,exception);
     }
//flaw_line_below:
  if (TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1)
//fix_flaw_line_below:
//  if ((TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1) &&
//fix_flaw_line_below:
//      (text != (char *) NULL))
     (void) SetImageProperty(image,""label"",text,exception);
//flaw_line_below:
  if (TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1)
//fix_flaw_line_below:
//  if ((TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1) &&
//fix_flaw_line_below:
//      (text != (char *) NULL))
     (void) SetImageProperty(image,""tiff:software"",text,exception);
//flaw_line_below:
  if (TIFFGetField(tiff,33423,&count,&text) == 1)
//fix_flaw_line_below:
//  if ((TIFFGetField(tiff,33423,&count,&text) == 1) &&
//fix_flaw_line_below:
//      (text != (char *) NULL))
     {
       if (count >= MagickPathExtent)
         count=MagickPathExtent-1;
       (void) CopyMagickString(message,text,count+1);
       (void) SetImageProperty(image,""tiff:kodak-33423"",message,exception);
     }
//flaw_line_below:
  if (TIFFGetField(tiff,36867,&count,&text) == 1)
//fix_flaw_line_below:
//  if ((TIFFGetField(tiff,36867,&count,&text) == 1) &&
//fix_flaw_line_below:
//      (text != (char *) NULL))
     {
       if (count >= MagickPathExtent)
         count=MagickPathExtent-1;
      (void) CopyMagickString(message,text,count+1);
      (void) SetImageProperty(image,""tiff:kodak-36867"",message,exception);
    }
  if (TIFFGetField(tiff,TIFFTAG_SUBFILETYPE,&type) == 1)
    switch (type)
    {
      case 0x01:
      {
        (void) SetImageProperty(image,""tiff:subfiletype"",""REDUCEDIMAGE"",
          exception);
        break;
      }
      case 0x02:
      {
        (void) SetImageProperty(image,""tiff:subfiletype"",""PAGE"",exception);
        break;
      }
      case 0x04:
      {
        (void) SetImageProperty(image,""tiff:subfiletype"",""MASK"",exception);
        break;
      }
       default:
         break;
     }
//flaw_line_below:
  if (TIFFGetField(tiff,37706,&length,&tietz) == 1)
//fix_flaw_line_below:
//  if ((TIFFGetField(tiff,37706,&length,&tietz) == 1) &&
//fix_flaw_line_below:
//      (tietz != (unsigned long *) NULL))
     {
       (void) FormatLocaleString(message,MagickPathExtent,""%lu"",tietz[0]);
       (void) SetImageProperty(image,""tiff:tietz_offset"",message,exception);
    }
}
"
4116,181852,,Remote,Not required,Partial,CVE-2016-9559,https://www.cvedetails.com/cve/CVE-2016-9559/,CWE-476,Medium,,,,2017-03-01,4.3,coders/tiff.c in ImageMagick before 7.0.3.7 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) via a crafted image.,2017-11-03,DoS ,1,https://github.com/ImageMagick/ImageMagick/commit/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b,b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b,https://github.com/ImageMagick/ImageMagick/issues/298,2,coders/txt.c,"{""sha"": ""39fcb8ce7a7080a4dbc04ef84530d41e454ca24d"", ""filename"": ""MagickCore/property.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b/MagickCore/property.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b/MagickCore/property.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/MagickCore/property.c?ref=b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b"", ""patch"": ""@@ -213,7 +213,7 @@ MagickExport MagickBooleanType CloneImageProperties(Image *image,\n %\n %  DefineImageProperty() associates an assignment string of the form\n %  \""key=value\"" with an artifact or options. It is equivelent to\n-%  SetImageProperty()\n+%  SetImageProperty().\n %\n %  The format of the DefineImageProperty method is:\n %\n@@ -3962,7 +3962,7 @@ MagickExport MagickBooleanType SetImageProperty(Image *image,\n     {\n       /*\n         Do not 'set' single letter properties - read only shorthand.\n-       */\n+      */\n       (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n         \""SetReadOnlyProperty\"",\""`%s'\"",property);\n       return(MagickFalse);""}<_**next**_>{""sha"": ""e108920f3086a74347d0562964b98e8230029afd"", ""filename"": ""coders/tiff.c"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 15, ""changes"": 43, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b/coders/tiff.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b/coders/tiff.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/tiff.c?ref=b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b"", ""patch"": ""@@ -631,42 +631,54 @@ static void TIFFGetProperties(TIFF *tiff,Image *image,ExceptionInfo *exception)\n   unsigned long\n     *tietz;\n \n-\n-  if (TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:artist\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:copyright\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:timestamp\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:document\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:hostcomputer\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""comment\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:make\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:model\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1) &&\n+      (text != (char *) NULL))\n     {\n       if (count >= MagickPathExtent)\n         count=MagickPathExtent-1;\n       (void) CopyMagickString(message,text,count+1);\n       (void) SetImageProperty(image,\""tiff:image-id\"",message,exception);\n     }\n-  if (TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""label\"",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\""tiff:software\"",text,exception);\n-  if (TIFFGetField(tiff,33423,&count,&text) == 1)\n+  if ((TIFFGetField(tiff,33423,&count,&text) == 1) &&\n+      (text != (char *) NULL))\n     {\n       if (count >= MagickPathExtent)\n         count=MagickPathExtent-1;\n       (void) CopyMagickString(message,text,count+1);\n       (void) SetImageProperty(image,\""tiff:kodak-33423\"",message,exception);\n     }\n-  if (TIFFGetField(tiff,36867,&count,&text) == 1)\n+  if ((TIFFGetField(tiff,36867,&count,&text) == 1) &&\n+      (text != (char *) NULL))\n     {\n       if (count >= MagickPathExtent)\n         count=MagickPathExtent-1;\n@@ -695,7 +707,8 @@ static void TIFFGetProperties(TIFF *tiff,Image *image,ExceptionInfo *exception)\n       default:\n         break;\n     }\n-  if (TIFFGetField(tiff,37706,&length,&tietz) == 1)\n+  if ((TIFFGetField(tiff,37706,&length,&tietz) == 1) &&\n+      (tietz != (unsigned long *) NULL))\n     {\n       (void) FormatLocaleString(message,MagickPathExtent,\""%lu\"",tietz[0]);\n       (void) SetImageProperty(image,\""tiff:tietz_offset\"",message,exception);""}<_**next**_>{""sha"": ""7d0dbb2e249a7b4b60a7b52ce113ed28b5ccab2e"", ""filename"": ""coders/txt.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b/coders/txt.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b/coders/txt.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/txt.c?ref=b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b"", ""patch"": ""@@ -793,8 +793,7 @@ static MagickBooleanType WriteTXTImage(const ImageInfo *image_info,Image *image,\n         (void) WriteBlobString(image,buffer);\n         (void) CopyMagickString(tuple,\""(\"",MagickPathExtent);\n         if (pixel.colorspace == GRAYColorspace)\n-          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,\n-            tuple);\n+          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,tuple);\n         else\n           {\n             ConcatenateColorComponent(&pixel,RedPixelChannel,compliance,tuple);""}","static MagickBooleanType WriteTXTImage(const ImageInfo *image_info,Image *image,
  ExceptionInfo *exception)
{
  char
    buffer[MagickPathExtent],
    colorspace[MagickPathExtent],
    tuple[MagickPathExtent];

  MagickBooleanType
    status;

  MagickOffsetType
    scene;

  PixelInfo
    pixel;

  register const Quantum
    *p;

  register ssize_t
    x;

  ssize_t
    y;

  /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  status=OpenBlob(image_info,image,WriteBlobMode,exception);
  if (status == MagickFalse)
    return(status);
  scene=0;
  do
  {
    ComplianceType
      compliance;

    const char
      *value;

    (void) CopyMagickString(colorspace,CommandOptionToMnemonic(
      MagickColorspaceOptions,(ssize_t) image->colorspace),MagickPathExtent);
    LocaleLower(colorspace);
    image->depth=GetImageQuantumDepth(image,MagickTrue);
    if (image->alpha_trait != UndefinedPixelTrait)
      (void) ConcatenateMagickString(colorspace,""a"",MagickPathExtent);
    compliance=NoCompliance;
    value=GetImageOption(image_info,""txt:compliance"");
    if (value != (char *) NULL)
      compliance=(ComplianceType) ParseCommandOption(MagickComplianceOptions,
        MagickFalse,value);
    if (LocaleCompare(image_info->magick,""SPARSE-COLOR"") != 0)
      {
        size_t
          depth;

        depth=compliance == SVGCompliance ? image->depth :
          MAGICKCORE_QUANTUM_DEPTH;
        (void) FormatLocaleString(buffer,MagickPathExtent,
          ""# ImageMagick pixel enumeration: %.20g,%.20g,%.20g,%s\n"",(double)
          image->columns,(double) image->rows,(double) ((MagickOffsetType)
          GetQuantumRange(depth)),colorspace);
        (void) WriteBlobString(image,buffer);
      }
    GetPixelInfo(image,&pixel);
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      p=GetVirtualPixels(image,0,y,image->columns,1,exception);
      if (p == (const Quantum *) NULL)
        break;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        GetPixelInfoPixel(image,p,&pixel);
        if (pixel.colorspace == LabColorspace)
          {
            pixel.green-=(QuantumRange+1)/2.0;
            pixel.blue-=(QuantumRange+1)/2.0;
          }
        if (LocaleCompare(image_info->magick,""SPARSE-COLOR"") == 0)
          {
            /*
              Sparse-color format.
            */
            if (GetPixelAlpha(image,p) == (Quantum) OpaqueAlpha)
              {
                GetColorTuple(&pixel,MagickFalse,tuple);
                (void) FormatLocaleString(buffer,MagickPathExtent,
                  ""%.20g,%.20g,"",(double) x,(double) y);
                (void) WriteBlobString(image,buffer);
                (void) WriteBlobString(image,tuple);
                (void) WriteBlobString(image,"" "");
              }
            p+=GetPixelChannels(image);
            continue;
          }
        (void) FormatLocaleString(buffer,MagickPathExtent,""%.20g,%.20g: "",
          (double) x,(double) y);
         (void) WriteBlobString(image,buffer);
         (void) CopyMagickString(tuple,""("",MagickPathExtent);
         if (pixel.colorspace == GRAYColorspace)
          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,tuple);
         else
           {
             ConcatenateColorComponent(&pixel,RedPixelChannel,compliance,tuple);
            (void) ConcatenateMagickString(tuple,"","",MagickPathExtent);
            ConcatenateColorComponent(&pixel,GreenPixelChannel,compliance,
              tuple);
            (void) ConcatenateMagickString(tuple,"","",MagickPathExtent);
            ConcatenateColorComponent(&pixel,BluePixelChannel,compliance,tuple);
          }
        if (pixel.colorspace == CMYKColorspace)
          {
            (void) ConcatenateMagickString(tuple,"","",MagickPathExtent);
            ConcatenateColorComponent(&pixel,BlackPixelChannel,compliance,
              tuple);
          }
        if (pixel.alpha_trait != UndefinedPixelTrait)
          {
            (void) ConcatenateMagickString(tuple,"","",MagickPathExtent);
            ConcatenateColorComponent(&pixel,AlphaPixelChannel,compliance,
              tuple);
          }
        (void) ConcatenateMagickString(tuple,"")"",MagickPathExtent);
        (void) WriteBlobString(image,tuple);
        (void) WriteBlobString(image,""  "");
        GetColorTuple(&pixel,MagickTrue,tuple);
        (void) FormatLocaleString(buffer,MagickPathExtent,""%s"",tuple);
        (void) WriteBlobString(image,buffer);
        (void) WriteBlobString(image,""  "");
        (void) QueryColorname(image,&pixel,SVGCompliance,tuple,exception);
        (void) WriteBlobString(image,tuple);
        (void) WriteBlobString(image,""\n"");
        p+=GetPixelChannels(image);
      }
      status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
        image->rows);
      if (status == MagickFalse)
        break;
    }
    if (GetNextImageInList(image) == (Image *) NULL)
      break;
    image=SyncNextImageInList(image);
    status=SetImageProgress(image,SaveImagesTag,scene++,
      GetImageListLength(image));
    if (status == MagickFalse)
      break;
  } while (image_info->adjoin != MagickFalse);
  (void) CloseBlob(image);
  return(MagickTrue);
}
","static MagickBooleanType WriteTXTImage(const ImageInfo *image_info,Image *image,
  ExceptionInfo *exception)
{
  char
    buffer[MagickPathExtent],
    colorspace[MagickPathExtent],
    tuple[MagickPathExtent];

  MagickBooleanType
    status;

  MagickOffsetType
    scene;

  PixelInfo
    pixel;

  register const Quantum
    *p;

  register ssize_t
    x;

  ssize_t
    y;

  /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  status=OpenBlob(image_info,image,WriteBlobMode,exception);
  if (status == MagickFalse)
    return(status);
  scene=0;
  do
  {
    ComplianceType
      compliance;

    const char
      *value;

    (void) CopyMagickString(colorspace,CommandOptionToMnemonic(
      MagickColorspaceOptions,(ssize_t) image->colorspace),MagickPathExtent);
    LocaleLower(colorspace);
    image->depth=GetImageQuantumDepth(image,MagickTrue);
    if (image->alpha_trait != UndefinedPixelTrait)
      (void) ConcatenateMagickString(colorspace,""a"",MagickPathExtent);
    compliance=NoCompliance;
    value=GetImageOption(image_info,""txt:compliance"");
    if (value != (char *) NULL)
      compliance=(ComplianceType) ParseCommandOption(MagickComplianceOptions,
        MagickFalse,value);
    if (LocaleCompare(image_info->magick,""SPARSE-COLOR"") != 0)
      {
        size_t
          depth;

        depth=compliance == SVGCompliance ? image->depth :
          MAGICKCORE_QUANTUM_DEPTH;
        (void) FormatLocaleString(buffer,MagickPathExtent,
          ""# ImageMagick pixel enumeration: %.20g,%.20g,%.20g,%s\n"",(double)
          image->columns,(double) image->rows,(double) ((MagickOffsetType)
          GetQuantumRange(depth)),colorspace);
        (void) WriteBlobString(image,buffer);
      }
    GetPixelInfo(image,&pixel);
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      p=GetVirtualPixels(image,0,y,image->columns,1,exception);
      if (p == (const Quantum *) NULL)
        break;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        GetPixelInfoPixel(image,p,&pixel);
        if (pixel.colorspace == LabColorspace)
          {
            pixel.green-=(QuantumRange+1)/2.0;
            pixel.blue-=(QuantumRange+1)/2.0;
          }
        if (LocaleCompare(image_info->magick,""SPARSE-COLOR"") == 0)
          {
            /*
              Sparse-color format.
            */
            if (GetPixelAlpha(image,p) == (Quantum) OpaqueAlpha)
              {
                GetColorTuple(&pixel,MagickFalse,tuple);
                (void) FormatLocaleString(buffer,MagickPathExtent,
                  ""%.20g,%.20g,"",(double) x,(double) y);
                (void) WriteBlobString(image,buffer);
                (void) WriteBlobString(image,tuple);
                (void) WriteBlobString(image,"" "");
              }
            p+=GetPixelChannels(image);
            continue;
          }
        (void) FormatLocaleString(buffer,MagickPathExtent,""%.20g,%.20g: "",
          (double) x,(double) y);
         (void) WriteBlobString(image,buffer);
         (void) CopyMagickString(tuple,""("",MagickPathExtent);
         if (pixel.colorspace == GRAYColorspace)
          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,
            tuple);
         else
           {
             ConcatenateColorComponent(&pixel,RedPixelChannel,compliance,tuple);
            (void) ConcatenateMagickString(tuple,"","",MagickPathExtent);
            ConcatenateColorComponent(&pixel,GreenPixelChannel,compliance,
              tuple);
            (void) ConcatenateMagickString(tuple,"","",MagickPathExtent);
            ConcatenateColorComponent(&pixel,BluePixelChannel,compliance,tuple);
          }
        if (pixel.colorspace == CMYKColorspace)
          {
            (void) ConcatenateMagickString(tuple,"","",MagickPathExtent);
            ConcatenateColorComponent(&pixel,BlackPixelChannel,compliance,
              tuple);
          }
        if (pixel.alpha_trait != UndefinedPixelTrait)
          {
            (void) ConcatenateMagickString(tuple,"","",MagickPathExtent);
            ConcatenateColorComponent(&pixel,AlphaPixelChannel,compliance,
              tuple);
          }
        (void) ConcatenateMagickString(tuple,"")"",MagickPathExtent);
        (void) WriteBlobString(image,tuple);
        (void) WriteBlobString(image,""  "");
        GetColorTuple(&pixel,MagickTrue,tuple);
        (void) FormatLocaleString(buffer,MagickPathExtent,""%s"",tuple);
        (void) WriteBlobString(image,buffer);
        (void) WriteBlobString(image,""  "");
        (void) QueryColorname(image,&pixel,SVGCompliance,tuple,exception);
        (void) WriteBlobString(image,tuple);
        (void) WriteBlobString(image,""\n"");
        p+=GetPixelChannels(image);
      }
      status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
        image->rows);
      if (status == MagickFalse)
        break;
    }
    if (GetNextImageInList(image) == (Image *) NULL)
      break;
    image=SyncNextImageInList(image);
    status=SetImageProgress(image,SaveImagesTag,scene++,
      GetImageListLength(image));
    if (status == MagickFalse)
      break;
  } while (image_info->adjoin != MagickFalse);
  (void) CloseBlob(image);
  return(MagickTrue);
}
",C,"          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,tuple);
","          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,
            tuple);
",,"@@ -793,8 +793,7 @@ static MagickBooleanType WriteTXTImage(const ImageInfo *image_info,Image *image,
         (void) WriteBlobString(image,buffer);
         (void) CopyMagickString(tuple,""("",MagickPathExtent);
         if (pixel.colorspace == GRAYColorspace)
-          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,
-            tuple);
+          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,tuple);
         else
           {
             ConcatenateColorComponent(&pixel,RedPixelChannel,compliance,tuple);",ImageMagick,b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b,b1c211487f6e69857fca7a2c5f1bcb52f00e9fe2,1,"static MagickBooleanType WriteTXTImage(const ImageInfo *image_info,Image *image,
  ExceptionInfo *exception)
{
  char
    buffer[MagickPathExtent],
    colorspace[MagickPathExtent],
    tuple[MagickPathExtent];

  MagickBooleanType
    status;

  MagickOffsetType
    scene;

  PixelInfo
    pixel;

  register const Quantum
    *p;

  register ssize_t
    x;

  ssize_t
    y;

  /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  status=OpenBlob(image_info,image,WriteBlobMode,exception);
  if (status == MagickFalse)
    return(status);
  scene=0;
  do
  {
    ComplianceType
      compliance;

    const char
      *value;

    (void) CopyMagickString(colorspace,CommandOptionToMnemonic(
      MagickColorspaceOptions,(ssize_t) image->colorspace),MagickPathExtent);
    LocaleLower(colorspace);
    image->depth=GetImageQuantumDepth(image,MagickTrue);
    if (image->alpha_trait != UndefinedPixelTrait)
      (void) ConcatenateMagickString(colorspace,""a"",MagickPathExtent);
    compliance=NoCompliance;
    value=GetImageOption(image_info,""txt:compliance"");
    if (value != (char *) NULL)
      compliance=(ComplianceType) ParseCommandOption(MagickComplianceOptions,
        MagickFalse,value);
    if (LocaleCompare(image_info->magick,""SPARSE-COLOR"") != 0)
      {
        size_t
          depth;

        depth=compliance == SVGCompliance ? image->depth :
          MAGICKCORE_QUANTUM_DEPTH;
        (void) FormatLocaleString(buffer,MagickPathExtent,
          ""# ImageMagick pixel enumeration: %.20g,%.20g,%.20g,%s\n"",(double)
          image->columns,(double) image->rows,(double) ((MagickOffsetType)
          GetQuantumRange(depth)),colorspace);
        (void) WriteBlobString(image,buffer);
      }
    GetPixelInfo(image,&pixel);
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      p=GetVirtualPixels(image,0,y,image->columns,1,exception);
      if (p == (const Quantum *) NULL)
        break;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        GetPixelInfoPixel(image,p,&pixel);
        if (pixel.colorspace == LabColorspace)
          {
            pixel.green-=(QuantumRange+1)/2.0;
            pixel.blue-=(QuantumRange+1)/2.0;
          }
        if (LocaleCompare(image_info->magick,""SPARSE-COLOR"") == 0)
          {
            /*
              Sparse-color format.
            */
            if (GetPixelAlpha(image,p) == (Quantum) OpaqueAlpha)
              {
                GetColorTuple(&pixel,MagickFalse,tuple);
                (void) FormatLocaleString(buffer,MagickPathExtent,
                  ""%.20g,%.20g,"",(double) x,(double) y);
                (void) WriteBlobString(image,buffer);
                (void) WriteBlobString(image,tuple);
                (void) WriteBlobString(image,"" "");
              }
            p+=GetPixelChannels(image);
            continue;
          }
        (void) FormatLocaleString(buffer,MagickPathExtent,""%.20g,%.20g: "",
          (double) x,(double) y);
         (void) WriteBlobString(image,buffer);
         (void) CopyMagickString(tuple,""("",MagickPathExtent);
         if (pixel.colorspace == GRAYColorspace)
//flaw_line_below:
          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,
//flaw_line_below:
            tuple);
//fix_flaw_line_below:
//          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,tuple);
         else
           {
             ConcatenateColorComponent(&pixel,RedPixelChannel,compliance,tuple);
            (void) ConcatenateMagickString(tuple,"","",MagickPathExtent);
            ConcatenateColorComponent(&pixel,GreenPixelChannel,compliance,
              tuple);
            (void) ConcatenateMagickString(tuple,"","",MagickPathExtent);
            ConcatenateColorComponent(&pixel,BluePixelChannel,compliance,tuple);
          }
        if (pixel.colorspace == CMYKColorspace)
          {
            (void) ConcatenateMagickString(tuple,"","",MagickPathExtent);
            ConcatenateColorComponent(&pixel,BlackPixelChannel,compliance,
              tuple);
          }
        if (pixel.alpha_trait != UndefinedPixelTrait)
          {
            (void) ConcatenateMagickString(tuple,"","",MagickPathExtent);
            ConcatenateColorComponent(&pixel,AlphaPixelChannel,compliance,
              tuple);
          }
        (void) ConcatenateMagickString(tuple,"")"",MagickPathExtent);
        (void) WriteBlobString(image,tuple);
        (void) WriteBlobString(image,""  "");
        GetColorTuple(&pixel,MagickTrue,tuple);
        (void) FormatLocaleString(buffer,MagickPathExtent,""%s"",tuple);
        (void) WriteBlobString(image,buffer);
        (void) WriteBlobString(image,""  "");
        (void) QueryColorname(image,&pixel,SVGCompliance,tuple,exception);
        (void) WriteBlobString(image,tuple);
        (void) WriteBlobString(image,""\n"");
        p+=GetPixelChannels(image);
      }
      status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
        image->rows);
      if (status == MagickFalse)
        break;
    }
    if (GetNextImageInList(image) == (Image *) NULL)
      break;
    image=SyncNextImageInList(image);
    status=SetImageProgress(image,SaveImagesTag,scene++,
      GetImageListLength(image));
    if (status == MagickFalse)
      break;
  } while (image_info->adjoin != MagickFalse);
  (void) CloseBlob(image);
  return(MagickTrue);
}
"
4189,181925,,Remote,Not required,Partial,CVE-2016-8887,https://www.cvedetails.com/cve/CVE-2016-8887/,CWE-476,Medium,,,,2017-03-23,4.3,The jp2_colr_destroy function in libjasper/jp2/jp2_cod.c in JasPer before 1.900.10 allows remote attackers to cause a denial of service (NULL pointer dereference).,2018-06-28,DoS ,7,https://github.com/mdadams/jasper/commit/e24bdc716c3327b067c551bc6cfb97fd2370358d,e24bdc716c3327b067c551bc6cfb97fd2370358d,"Fixed a bug that resulted in the destruction of JP2 box data that had never
been constructed in the first place.",0,src/libjasper/jp2/jp2_cod.c,"{""sha"": ""dc0f66cf5bbf868c04a26a83bd176eca343f70ea"", ""filename"": ""src/libjasper/jp2/jp2_cod.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/mdadams/jasper/blob/e24bdc716c3327b067c551bc6cfb97fd2370358d/src/libjasper/jp2/jp2_cod.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/e24bdc716c3327b067c551bc6cfb97fd2370358d/src/libjasper/jp2/jp2_cod.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/jp2/jp2_cod.c?ref=e24bdc716c3327b067c551bc6cfb97fd2370358d"", ""patch"": ""@@ -258,6 +258,10 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \tbox->info = boxinfo;\n \tbox->ops = &boxinfo->ops;\n \tbox->len = len;\n+\tJAS_DBGLOG(10, (\n+\t  \""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\"",\n+\t  '\""', boxinfo->name, '\""', box->type, box->len\n+\t  ));\n \tif (box->len == 1) {\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n@@ -282,6 +286,9 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \t\t\tgoto error;\n \t\t}\n \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n+\t\t\t// Mark the box data as never having been constructed\n+\t\t\t// so that we will not errantly attempt to destroy it later.\n+\t\t\tbox->ops = &jp2_boxinfo_unk.ops;\n \t\t\tjas_eprintf(\""cannot copy box data\\n\"");\n \t\t\tgoto error;\n \t\t}""}<_**next**_>{""sha"": ""2996393bdcb089de524528688789eeb39d22a614"", ""filename"": ""src/libjasper/jp2/jp2_dec.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/mdadams/jasper/blob/e24bdc716c3327b067c551bc6cfb97fd2370358d/src/libjasper/jp2/jp2_dec.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/e24bdc716c3327b067c551bc6cfb97fd2370358d/src/libjasper/jp2/jp2_dec.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/jp2/jp2_dec.c?ref=e24bdc716c3327b067c551bc6cfb97fd2370358d"", ""patch"": ""@@ -155,7 +155,7 @@ jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)\n \tfound = 0;\n \twhile ((box = jp2_box_get(in))) {\n \t\tif (jas_getdbglevel() >= 1) {\n-\t\t\tjas_eprintf(\""box type %s\\n\"", box->info->name);\n+\t\t\tjas_eprintf(\""got box type %s\\n\"", box->info->name);\n \t\t}\n \t\tswitch (box->type) {\n \t\tcase JP2_BOX_JP2C:""}","jp2_box_t *jp2_box_get(jas_stream_t *in)
{
	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;
	jas_stream_t *tmpstream;
	uint_fast32_t len;
	uint_fast64_t extlen;
	bool dataflag;

	box = 0;
	tmpstream = 0;

	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
		goto error;
	}
	box->ops = &jp2_boxinfo_unk.ops;
	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
		goto error;
	}
	boxinfo = jp2_boxinfolookup(box->type);
 	box->info = boxinfo;
 	box->ops = &boxinfo->ops;
 	box->len = len;
	JAS_DBGLOG(10, (
	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
	  '""', boxinfo->name, '""', box->type, box->len
	  ));
 	if (box->len == 1) {
 		if (jp2_getuint64(in, &extlen)) {
 			goto error;
		}
		if (extlen > 0xffffffffUL) {
			jas_eprintf(""warning: cannot handle large 64-bit box length\n"");
			extlen = 0xffffffffUL;
		}
		box->len = extlen;
		box->datalen = extlen - JP2_BOX_HDRLEN(true);
	} else {
		box->datalen = box->len - JP2_BOX_HDRLEN(false);
	}
	if (box->len != 0 && box->len < 8) {
		goto error;
	}

	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));

	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
 			goto error;
 		}
 		if (jas_stream_copy(tmpstream, in, box->datalen)) {
			// Mark the box data as never having been constructed
			// so that we will not errantly attempt to destroy it later.
			box->ops = &jp2_boxinfo_unk.ops;
 			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}
		jas_stream_rewind(tmpstream);

		if (box->ops->getdata) {
			if ((*box->ops->getdata)(box, tmpstream)) {
				jas_eprintf(""cannot parse box data\n"");
				goto error;
			}
		}
		jas_stream_close(tmpstream);
	}

	if (jas_getdbglevel() >= 1) {
		jp2_box_dump(box, stderr);
	}

	return box;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (tmpstream) {
		jas_stream_close(tmpstream);
	}
	return 0;
}
","jp2_box_t *jp2_box_get(jas_stream_t *in)
{
	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;
	jas_stream_t *tmpstream;
	uint_fast32_t len;
	uint_fast64_t extlen;
	bool dataflag;

	box = 0;
	tmpstream = 0;

	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
		goto error;
	}
	box->ops = &jp2_boxinfo_unk.ops;
	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
		goto error;
	}
	boxinfo = jp2_boxinfolookup(box->type);
 	box->info = boxinfo;
 	box->ops = &boxinfo->ops;
 	box->len = len;
 	if (box->len == 1) {
 		if (jp2_getuint64(in, &extlen)) {
 			goto error;
		}
		if (extlen > 0xffffffffUL) {
			jas_eprintf(""warning: cannot handle large 64-bit box length\n"");
			extlen = 0xffffffffUL;
		}
		box->len = extlen;
		box->datalen = extlen - JP2_BOX_HDRLEN(true);
	} else {
		box->datalen = box->len - JP2_BOX_HDRLEN(false);
	}
	if (box->len != 0 && box->len < 8) {
		goto error;
	}

	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));

	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
 			goto error;
 		}
 		if (jas_stream_copy(tmpstream, in, box->datalen)) {
 			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}
		jas_stream_rewind(tmpstream);

		if (box->ops->getdata) {
			if ((*box->ops->getdata)(box, tmpstream)) {
				jas_eprintf(""cannot parse box data\n"");
				goto error;
			}
		}
		jas_stream_close(tmpstream);
	}

	if (jas_getdbglevel() >= 1) {
		jp2_box_dump(box, stderr);
	}

	return box;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (tmpstream) {
		jas_stream_close(tmpstream);
	}
	return 0;
}
",C,"	JAS_DBGLOG(10, (
	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
	  '""', boxinfo->name, '""', box->type, box->len
	  ));
			// Mark the box data as never having been constructed
			// so that we will not errantly attempt to destroy it later.
			box->ops = &jp2_boxinfo_unk.ops;
",,,"@@ -258,6 +258,10 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)
 	box->info = boxinfo;
 	box->ops = &boxinfo->ops;
 	box->len = len;
+	JAS_DBGLOG(10, (
+	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
+	  '""', boxinfo->name, '""', box->type, box->len
+	  ));
 	if (box->len == 1) {
 		if (jp2_getuint64(in, &extlen)) {
 			goto error;
@@ -282,6 +286,9 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)
 			goto error;
 		}
 		if (jas_stream_copy(tmpstream, in, box->datalen)) {
+			// Mark the box data as never having been constructed
+			// so that we will not errantly attempt to destroy it later.
+			box->ops = &jp2_boxinfo_unk.ops;
 			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}",jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,dfc60c97090f7519bf06de2b01f59cd8874ed34c,1,"jp2_box_t *jp2_box_get(jas_stream_t *in)
{
	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;
	jas_stream_t *tmpstream;
	uint_fast32_t len;
	uint_fast64_t extlen;
	bool dataflag;

	box = 0;
	tmpstream = 0;

	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
		goto error;
	}
	box->ops = &jp2_boxinfo_unk.ops;
	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
		goto error;
	}
	boxinfo = jp2_boxinfolookup(box->type);
 	box->info = boxinfo;
 	box->ops = &boxinfo->ops;
 	box->len = len;
//fix_flaw_line_below:
//	JAS_DBGLOG(10, (
//fix_flaw_line_below:
//	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
//fix_flaw_line_below:
//	  '""', boxinfo->name, '""', box->type, box->len
//fix_flaw_line_below:
//	  ));
 	if (box->len == 1) {
 		if (jp2_getuint64(in, &extlen)) {
 			goto error;
		}
		if (extlen > 0xffffffffUL) {
			jas_eprintf(""warning: cannot handle large 64-bit box length\n"");
			extlen = 0xffffffffUL;
		}
		box->len = extlen;
		box->datalen = extlen - JP2_BOX_HDRLEN(true);
	} else {
		box->datalen = box->len - JP2_BOX_HDRLEN(false);
	}
	if (box->len != 0 && box->len < 8) {
		goto error;
	}

	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));

	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
 			goto error;
 		}
 		if (jas_stream_copy(tmpstream, in, box->datalen)) {
//fix_flaw_line_below:
//			// Mark the box data as never having been constructed
//fix_flaw_line_below:
//			// so that we will not errantly attempt to destroy it later.
//fix_flaw_line_below:
//			box->ops = &jp2_boxinfo_unk.ops;
 			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}
		jas_stream_rewind(tmpstream);

		if (box->ops->getdata) {
			if ((*box->ops->getdata)(box, tmpstream)) {
				jas_eprintf(""cannot parse box data\n"");
				goto error;
			}
		}
		jas_stream_close(tmpstream);
	}

	if (jas_getdbglevel() >= 1) {
		jp2_box_dump(box, stderr);
	}

	return box;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (tmpstream) {
		jas_stream_close(tmpstream);
	}
	return 0;
}
"
4190,181926,,Remote,Not required,Partial,CVE-2016-8887,https://www.cvedetails.com/cve/CVE-2016-8887/,CWE-476,Medium,,,,2017-03-23,4.3,The jp2_colr_destroy function in libjasper/jp2/jp2_cod.c in JasPer before 1.900.10 allows remote attackers to cause a denial of service (NULL pointer dereference).,2018-06-28,DoS ,1,https://github.com/mdadams/jasper/commit/e24bdc716c3327b067c551bc6cfb97fd2370358d,e24bdc716c3327b067c551bc6cfb97fd2370358d,"Fixed a bug that resulted in the destruction of JP2 box data that had never
been constructed in the first place.",1,src/libjasper/jp2/jp2_dec.c,"{""sha"": ""dc0f66cf5bbf868c04a26a83bd176eca343f70ea"", ""filename"": ""src/libjasper/jp2/jp2_cod.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/mdadams/jasper/blob/e24bdc716c3327b067c551bc6cfb97fd2370358d/src/libjasper/jp2/jp2_cod.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/e24bdc716c3327b067c551bc6cfb97fd2370358d/src/libjasper/jp2/jp2_cod.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/jp2/jp2_cod.c?ref=e24bdc716c3327b067c551bc6cfb97fd2370358d"", ""patch"": ""@@ -258,6 +258,10 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \tbox->info = boxinfo;\n \tbox->ops = &boxinfo->ops;\n \tbox->len = len;\n+\tJAS_DBGLOG(10, (\n+\t  \""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\"",\n+\t  '\""', boxinfo->name, '\""', box->type, box->len\n+\t  ));\n \tif (box->len == 1) {\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n@@ -282,6 +286,9 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \t\t\tgoto error;\n \t\t}\n \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n+\t\t\t// Mark the box data as never having been constructed\n+\t\t\t// so that we will not errantly attempt to destroy it later.\n+\t\t\tbox->ops = &jp2_boxinfo_unk.ops;\n \t\t\tjas_eprintf(\""cannot copy box data\\n\"");\n \t\t\tgoto error;\n \t\t}""}<_**next**_>{""sha"": ""2996393bdcb089de524528688789eeb39d22a614"", ""filename"": ""src/libjasper/jp2/jp2_dec.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/mdadams/jasper/blob/e24bdc716c3327b067c551bc6cfb97fd2370358d/src/libjasper/jp2/jp2_dec.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/e24bdc716c3327b067c551bc6cfb97fd2370358d/src/libjasper/jp2/jp2_dec.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/jp2/jp2_dec.c?ref=e24bdc716c3327b067c551bc6cfb97fd2370358d"", ""patch"": ""@@ -155,7 +155,7 @@ jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)\n \tfound = 0;\n \twhile ((box = jp2_box_get(in))) {\n \t\tif (jas_getdbglevel() >= 1) {\n-\t\t\tjas_eprintf(\""box type %s\\n\"", box->info->name);\n+\t\t\tjas_eprintf(\""got box type %s\\n\"", box->info->name);\n \t\t}\n \t\tswitch (box->type) {\n \t\tcase JP2_BOX_JP2C:""}","jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)
{
	jp2_box_t *box;
	int found;
	jas_image_t *image;
	jp2_dec_t *dec;
	bool samedtype;
	int dtype;
	unsigned int i;
	jp2_cmap_t *cmapd;
	jp2_pclr_t *pclrd;
	jp2_cdef_t *cdefd;
	unsigned int channo;
	int newcmptno;
	int_fast32_t *lutents;
#if 0
	jp2_cdefchan_t *cdefent;
	int cmptno;
#endif
	jp2_cmapent_t *cmapent;
	jas_icchdr_t icchdr;
	jas_iccprof_t *iccprof;

	dec = 0;
	box = 0;
	image = 0;

	if (!(dec = jp2_dec_create())) {
		goto error;
	}

	/* Get the first box.  This should be a JP box. */
	if (!(box = jp2_box_get(in))) {
		jas_eprintf(""error: cannot get box\n"");
		goto error;
	}
	if (box->type != JP2_BOX_JP) {
		jas_eprintf(""error: expecting signature box\n"");
		goto error;
	}
	if (box->data.jp.magic != JP2_JP_MAGIC) {
		jas_eprintf(""incorrect magic number\n"");
		goto error;
	}
	jp2_box_destroy(box);
	box = 0;

	/* Get the second box.  This should be a FTYP box. */
	if (!(box = jp2_box_get(in))) {
		goto error;
	}
	if (box->type != JP2_BOX_FTYP) {
		jas_eprintf(""expecting file type box\n"");
		goto error;
	}
	jp2_box_destroy(box);
	box = 0;

	/* Get more boxes... */
 	found = 0;
 	while ((box = jp2_box_get(in))) {
 		if (jas_getdbglevel() >= 1) {
			jas_eprintf(""got box type %s\n"", box->info->name);
 		}
 		switch (box->type) {
 		case JP2_BOX_JP2C:
			found = 1;
			break;
		case JP2_BOX_IHDR:
			if (!dec->ihdr) {
				dec->ihdr = box;
				box = 0;
			}
			break;
		case JP2_BOX_BPCC:
			if (!dec->bpcc) {
				dec->bpcc = box;
				box = 0;
			}
			break;
		case JP2_BOX_CDEF:
			if (!dec->cdef) {
				dec->cdef = box;
				box = 0;
			}
			break;
		case JP2_BOX_PCLR:
			if (!dec->pclr) {
				dec->pclr = box;
				box = 0;
			}
			break;
		case JP2_BOX_CMAP:
			if (!dec->cmap) {
				dec->cmap = box;
				box = 0;
			}
			break;
		case JP2_BOX_COLR:
			if (!dec->colr) {
				dec->colr = box;
				box = 0;
			}
			break;
		}
		if (box) {
			jp2_box_destroy(box);
			box = 0;
		}
		if (found) {
			break;
		}
	}

	if (!found) {
		jas_eprintf(""error: no code stream found\n"");
		goto error;
	}

	if (!(dec->image = jpc_decode(in, optstr))) {
		jas_eprintf(""error: cannot decode code stream\n"");
		goto error;
	}

	/* An IHDR box must be present. */
	if (!dec->ihdr) {
		jas_eprintf(""error: missing IHDR box\n"");
		goto error;
	}

	/* Does the number of components indicated in the IHDR box match
	  the value specified in the code stream? */
	if (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(uint,
	  jas_image_numcmpts(dec->image))) {
		jas_eprintf(""warning: number of components mismatch\n"");
	}

	/* At least one component must be present. */
	if (!jas_image_numcmpts(dec->image)) {
		jas_eprintf(""error: no components\n"");
		goto error;
	}

	/* Determine if all components have the same data type. */
	samedtype = true;
	dtype = jas_image_cmptdtype(dec->image, 0);
	for (i = 1; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {
		if (jas_image_cmptdtype(dec->image, i) != dtype) {
			samedtype = false;
			break;
		}
	}

	/* Is the component data type indicated in the IHDR box consistent
	  with the data in the code stream? */
	if ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||
	  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {
		jas_eprintf(""warning: component data type mismatch\n"");
	}

	/* Is the compression type supported? */
	if (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {
		jas_eprintf(""error: unsupported compression type\n"");
		goto error;
	}

	if (dec->bpcc) {
		/* Is the number of components indicated in the BPCC box
		  consistent with the code stream data? */
		if (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(uint, jas_image_numcmpts(
		  dec->image))) {
			jas_eprintf(""warning: number of components mismatch\n"");
		}
		/* Is the component data type information indicated in the BPCC
		  box consistent with the code stream data? */
		if (!samedtype) {
			for (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image));
			  ++i) {
				if (jas_image_cmptdtype(dec->image, i) !=
				  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {
					jas_eprintf(""warning: component data type mismatch\n"");
				}
			}
		} else {
			jas_eprintf(""warning: superfluous BPCC box\n"");
		}
	}

	/* A COLR box must be present. */
	if (!dec->colr) {
		jas_eprintf(""error: no COLR box\n"");
		goto error;
	}

	switch (dec->colr->data.colr.method) {
	case JP2_COLR_ENUM:
		jas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));
		break;
	case JP2_COLR_ICC:
		iccprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,
		  dec->colr->data.colr.iccplen);
		if (!iccprof) {
			jas_eprintf(""error: failed to parse ICC profile\n"");
			goto error;
		}
		jas_iccprof_gethdr(iccprof, &icchdr);
		jas_eprintf(""ICC Profile CS %08x\n"", icchdr.colorspc);
		jas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));
		dec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);
		assert(dec->image->cmprof_);
		jas_iccprof_destroy(iccprof);
		break;
	}

	/* If a CMAP box is present, a PCLR box must also be present. */
	if (dec->cmap && !dec->pclr) {
		jas_eprintf(""warning: missing PCLR box or superfluous CMAP box\n"");
		jp2_box_destroy(dec->cmap);
		dec->cmap = 0;
	}

	/* If a CMAP box is not present, a PCLR box must not be present. */
	if (!dec->cmap && dec->pclr) {
		jas_eprintf(""warning: missing CMAP box or superfluous PCLR box\n"");
		jp2_box_destroy(dec->pclr);
		dec->pclr = 0;
	}

	/* Determine the number of channels (which is essentially the number
	  of components after any palette mappings have been applied). */
	dec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :
	  JAS_CAST(uint, jas_image_numcmpts(dec->image));

	/* Perform a basic sanity check on the CMAP box if present. */
	if (dec->cmap) {
		for (i = 0; i < dec->numchans; ++i) {
			/* Is the component number reasonable? */
			if (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(uint,
			  jas_image_numcmpts(dec->image))) {
				jas_eprintf(""error: invalid component number in CMAP box\n"");
				goto error;
			}
			/* Is the LUT index reasonable? */
			if (dec->cmap->data.cmap.ents[i].pcol >=
			  dec->pclr->data.pclr.numchans) {
				jas_eprintf(""error: invalid CMAP LUT index\n"");
				goto error;
			}
		}
	}

	/* Allocate space for the channel-number to component-number LUT. */
	if (!(dec->chantocmptlut = jas_alloc2(dec->numchans,
	  sizeof(uint_fast16_t)))) {
		jas_eprintf(""error: no memory\n"");
		goto error;
	}

	if (!dec->cmap) {
		for (i = 0; i < dec->numchans; ++i) {
			dec->chantocmptlut[i] = i;
		}
	} else {
		cmapd = &dec->cmap->data.cmap;
		pclrd = &dec->pclr->data.pclr;
		cdefd = &dec->cdef->data.cdef;
		for (channo = 0; channo < cmapd->numchans; ++channo) {
			cmapent = &cmapd->ents[channo];
			if (cmapent->map == JP2_CMAP_DIRECT) {
				dec->chantocmptlut[channo] = channo;
			} else if (cmapent->map == JP2_CMAP_PALETTE) {
				lutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));
				for (i = 0; i < pclrd->numlutents; ++i) {
					lutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];
				}
				newcmptno = jas_image_numcmpts(dec->image);
				jas_image_depalettize(dec->image, cmapent->cmptno,
				  pclrd->numlutents, lutents,
				  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);
				dec->chantocmptlut[channo] = newcmptno;
				jas_free(lutents);
#if 0
				if (dec->cdef) {
					cdefent = jp2_cdef_lookup(cdefd, channo);
					if (!cdefent) {
						abort();
					}
				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));
				} else {
				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));
				}
#endif
			}
		}
	}

	/* Mark all components as being of unknown type. */

	for (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {
		jas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);
	}

	/* Determine the type of each component. */
	if (dec->cdef) {
		for (i = 0; i < dec->numchans; ++i) {
			/* Is the channel number reasonable? */
			if (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {
				jas_eprintf(""error: invalid channel number in CDEF box\n"");
				goto error;
			}
			jas_image_setcmpttype(dec->image,
			  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],
			  jp2_getct(jas_image_clrspc(dec->image),
			  dec->cdef->data.cdef.ents[i].type,
			  dec->cdef->data.cdef.ents[i].assoc));
		}
	} else {
		for (i = 0; i < dec->numchans; ++i) {
			jas_image_setcmpttype(dec->image, dec->chantocmptlut[i],
			  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));
		}
	}

	/* Delete any components that are not of interest. */
	for (i = jas_image_numcmpts(dec->image); i > 0; --i) {
		if (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {
			jas_image_delcmpt(dec->image, i - 1);
		}
	}

	/* Ensure that some components survived. */
	if (!jas_image_numcmpts(dec->image)) {
		jas_eprintf(""error: no components\n"");
		goto error;
	}
#if 0
jas_eprintf(""no of components is %d\n"", jas_image_numcmpts(dec->image));
#endif

	/* Prevent the image from being destroyed later. */
	image = dec->image;
	dec->image = 0;

	jp2_dec_destroy(dec);

	return image;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (dec) {
		jp2_dec_destroy(dec);
	}
	return 0;
}
","jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)
{
	jp2_box_t *box;
	int found;
	jas_image_t *image;
	jp2_dec_t *dec;
	bool samedtype;
	int dtype;
	unsigned int i;
	jp2_cmap_t *cmapd;
	jp2_pclr_t *pclrd;
	jp2_cdef_t *cdefd;
	unsigned int channo;
	int newcmptno;
	int_fast32_t *lutents;
#if 0
	jp2_cdefchan_t *cdefent;
	int cmptno;
#endif
	jp2_cmapent_t *cmapent;
	jas_icchdr_t icchdr;
	jas_iccprof_t *iccprof;

	dec = 0;
	box = 0;
	image = 0;

	if (!(dec = jp2_dec_create())) {
		goto error;
	}

	/* Get the first box.  This should be a JP box. */
	if (!(box = jp2_box_get(in))) {
		jas_eprintf(""error: cannot get box\n"");
		goto error;
	}
	if (box->type != JP2_BOX_JP) {
		jas_eprintf(""error: expecting signature box\n"");
		goto error;
	}
	if (box->data.jp.magic != JP2_JP_MAGIC) {
		jas_eprintf(""incorrect magic number\n"");
		goto error;
	}
	jp2_box_destroy(box);
	box = 0;

	/* Get the second box.  This should be a FTYP box. */
	if (!(box = jp2_box_get(in))) {
		goto error;
	}
	if (box->type != JP2_BOX_FTYP) {
		jas_eprintf(""expecting file type box\n"");
		goto error;
	}
	jp2_box_destroy(box);
	box = 0;

	/* Get more boxes... */
 	found = 0;
 	while ((box = jp2_box_get(in))) {
 		if (jas_getdbglevel() >= 1) {
			jas_eprintf(""box type %s\n"", box->info->name);
 		}
 		switch (box->type) {
 		case JP2_BOX_JP2C:
			found = 1;
			break;
		case JP2_BOX_IHDR:
			if (!dec->ihdr) {
				dec->ihdr = box;
				box = 0;
			}
			break;
		case JP2_BOX_BPCC:
			if (!dec->bpcc) {
				dec->bpcc = box;
				box = 0;
			}
			break;
		case JP2_BOX_CDEF:
			if (!dec->cdef) {
				dec->cdef = box;
				box = 0;
			}
			break;
		case JP2_BOX_PCLR:
			if (!dec->pclr) {
				dec->pclr = box;
				box = 0;
			}
			break;
		case JP2_BOX_CMAP:
			if (!dec->cmap) {
				dec->cmap = box;
				box = 0;
			}
			break;
		case JP2_BOX_COLR:
			if (!dec->colr) {
				dec->colr = box;
				box = 0;
			}
			break;
		}
		if (box) {
			jp2_box_destroy(box);
			box = 0;
		}
		if (found) {
			break;
		}
	}

	if (!found) {
		jas_eprintf(""error: no code stream found\n"");
		goto error;
	}

	if (!(dec->image = jpc_decode(in, optstr))) {
		jas_eprintf(""error: cannot decode code stream\n"");
		goto error;
	}

	/* An IHDR box must be present. */
	if (!dec->ihdr) {
		jas_eprintf(""error: missing IHDR box\n"");
		goto error;
	}

	/* Does the number of components indicated in the IHDR box match
	  the value specified in the code stream? */
	if (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(uint,
	  jas_image_numcmpts(dec->image))) {
		jas_eprintf(""warning: number of components mismatch\n"");
	}

	/* At least one component must be present. */
	if (!jas_image_numcmpts(dec->image)) {
		jas_eprintf(""error: no components\n"");
		goto error;
	}

	/* Determine if all components have the same data type. */
	samedtype = true;
	dtype = jas_image_cmptdtype(dec->image, 0);
	for (i = 1; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {
		if (jas_image_cmptdtype(dec->image, i) != dtype) {
			samedtype = false;
			break;
		}
	}

	/* Is the component data type indicated in the IHDR box consistent
	  with the data in the code stream? */
	if ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||
	  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {
		jas_eprintf(""warning: component data type mismatch\n"");
	}

	/* Is the compression type supported? */
	if (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {
		jas_eprintf(""error: unsupported compression type\n"");
		goto error;
	}

	if (dec->bpcc) {
		/* Is the number of components indicated in the BPCC box
		  consistent with the code stream data? */
		if (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(uint, jas_image_numcmpts(
		  dec->image))) {
			jas_eprintf(""warning: number of components mismatch\n"");
		}
		/* Is the component data type information indicated in the BPCC
		  box consistent with the code stream data? */
		if (!samedtype) {
			for (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image));
			  ++i) {
				if (jas_image_cmptdtype(dec->image, i) !=
				  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {
					jas_eprintf(""warning: component data type mismatch\n"");
				}
			}
		} else {
			jas_eprintf(""warning: superfluous BPCC box\n"");
		}
	}

	/* A COLR box must be present. */
	if (!dec->colr) {
		jas_eprintf(""error: no COLR box\n"");
		goto error;
	}

	switch (dec->colr->data.colr.method) {
	case JP2_COLR_ENUM:
		jas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));
		break;
	case JP2_COLR_ICC:
		iccprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,
		  dec->colr->data.colr.iccplen);
		if (!iccprof) {
			jas_eprintf(""error: failed to parse ICC profile\n"");
			goto error;
		}
		jas_iccprof_gethdr(iccprof, &icchdr);
		jas_eprintf(""ICC Profile CS %08x\n"", icchdr.colorspc);
		jas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));
		dec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);
		assert(dec->image->cmprof_);
		jas_iccprof_destroy(iccprof);
		break;
	}

	/* If a CMAP box is present, a PCLR box must also be present. */
	if (dec->cmap && !dec->pclr) {
		jas_eprintf(""warning: missing PCLR box or superfluous CMAP box\n"");
		jp2_box_destroy(dec->cmap);
		dec->cmap = 0;
	}

	/* If a CMAP box is not present, a PCLR box must not be present. */
	if (!dec->cmap && dec->pclr) {
		jas_eprintf(""warning: missing CMAP box or superfluous PCLR box\n"");
		jp2_box_destroy(dec->pclr);
		dec->pclr = 0;
	}

	/* Determine the number of channels (which is essentially the number
	  of components after any palette mappings have been applied). */
	dec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :
	  JAS_CAST(uint, jas_image_numcmpts(dec->image));

	/* Perform a basic sanity check on the CMAP box if present. */
	if (dec->cmap) {
		for (i = 0; i < dec->numchans; ++i) {
			/* Is the component number reasonable? */
			if (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(uint,
			  jas_image_numcmpts(dec->image))) {
				jas_eprintf(""error: invalid component number in CMAP box\n"");
				goto error;
			}
			/* Is the LUT index reasonable? */
			if (dec->cmap->data.cmap.ents[i].pcol >=
			  dec->pclr->data.pclr.numchans) {
				jas_eprintf(""error: invalid CMAP LUT index\n"");
				goto error;
			}
		}
	}

	/* Allocate space for the channel-number to component-number LUT. */
	if (!(dec->chantocmptlut = jas_alloc2(dec->numchans,
	  sizeof(uint_fast16_t)))) {
		jas_eprintf(""error: no memory\n"");
		goto error;
	}

	if (!dec->cmap) {
		for (i = 0; i < dec->numchans; ++i) {
			dec->chantocmptlut[i] = i;
		}
	} else {
		cmapd = &dec->cmap->data.cmap;
		pclrd = &dec->pclr->data.pclr;
		cdefd = &dec->cdef->data.cdef;
		for (channo = 0; channo < cmapd->numchans; ++channo) {
			cmapent = &cmapd->ents[channo];
			if (cmapent->map == JP2_CMAP_DIRECT) {
				dec->chantocmptlut[channo] = channo;
			} else if (cmapent->map == JP2_CMAP_PALETTE) {
				lutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));
				for (i = 0; i < pclrd->numlutents; ++i) {
					lutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];
				}
				newcmptno = jas_image_numcmpts(dec->image);
				jas_image_depalettize(dec->image, cmapent->cmptno,
				  pclrd->numlutents, lutents,
				  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);
				dec->chantocmptlut[channo] = newcmptno;
				jas_free(lutents);
#if 0
				if (dec->cdef) {
					cdefent = jp2_cdef_lookup(cdefd, channo);
					if (!cdefent) {
						abort();
					}
				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));
				} else {
				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));
				}
#endif
			}
		}
	}

	/* Mark all components as being of unknown type. */

	for (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {
		jas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);
	}

	/* Determine the type of each component. */
	if (dec->cdef) {
		for (i = 0; i < dec->numchans; ++i) {
			/* Is the channel number reasonable? */
			if (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {
				jas_eprintf(""error: invalid channel number in CDEF box\n"");
				goto error;
			}
			jas_image_setcmpttype(dec->image,
			  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],
			  jp2_getct(jas_image_clrspc(dec->image),
			  dec->cdef->data.cdef.ents[i].type,
			  dec->cdef->data.cdef.ents[i].assoc));
		}
	} else {
		for (i = 0; i < dec->numchans; ++i) {
			jas_image_setcmpttype(dec->image, dec->chantocmptlut[i],
			  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));
		}
	}

	/* Delete any components that are not of interest. */
	for (i = jas_image_numcmpts(dec->image); i > 0; --i) {
		if (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {
			jas_image_delcmpt(dec->image, i - 1);
		}
	}

	/* Ensure that some components survived. */
	if (!jas_image_numcmpts(dec->image)) {
		jas_eprintf(""error: no components\n"");
		goto error;
	}
#if 0
jas_eprintf(""no of components is %d\n"", jas_image_numcmpts(dec->image));
#endif

	/* Prevent the image from being destroyed later. */
	image = dec->image;
	dec->image = 0;

	jp2_dec_destroy(dec);

	return image;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (dec) {
		jp2_dec_destroy(dec);
	}
	return 0;
}
",C,"			jas_eprintf(""got box type %s\n"", box->info->name);
","			jas_eprintf(""box type %s\n"", box->info->name);
",,"@@ -155,7 +155,7 @@ jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)
 	found = 0;
 	while ((box = jp2_box_get(in))) {
 		if (jas_getdbglevel() >= 1) {
-			jas_eprintf(""box type %s\n"", box->info->name);
+			jas_eprintf(""got box type %s\n"", box->info->name);
 		}
 		switch (box->type) {
 		case JP2_BOX_JP2C:",jasper,e24bdc716c3327b067c551bc6cfb97fd2370358d,dfc60c97090f7519bf06de2b01f59cd8874ed34c,1,"jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)
{
	jp2_box_t *box;
	int found;
	jas_image_t *image;
	jp2_dec_t *dec;
	bool samedtype;
	int dtype;
	unsigned int i;
	jp2_cmap_t *cmapd;
	jp2_pclr_t *pclrd;
	jp2_cdef_t *cdefd;
	unsigned int channo;
	int newcmptno;
	int_fast32_t *lutents;
#if 0
	jp2_cdefchan_t *cdefent;
	int cmptno;
#endif
	jp2_cmapent_t *cmapent;
	jas_icchdr_t icchdr;
	jas_iccprof_t *iccprof;

	dec = 0;
	box = 0;
	image = 0;

	if (!(dec = jp2_dec_create())) {
		goto error;
	}

	/* Get the first box.  This should be a JP box. */
	if (!(box = jp2_box_get(in))) {
		jas_eprintf(""error: cannot get box\n"");
		goto error;
	}
	if (box->type != JP2_BOX_JP) {
		jas_eprintf(""error: expecting signature box\n"");
		goto error;
	}
	if (box->data.jp.magic != JP2_JP_MAGIC) {
		jas_eprintf(""incorrect magic number\n"");
		goto error;
	}
	jp2_box_destroy(box);
	box = 0;

	/* Get the second box.  This should be a FTYP box. */
	if (!(box = jp2_box_get(in))) {
		goto error;
	}
	if (box->type != JP2_BOX_FTYP) {
		jas_eprintf(""expecting file type box\n"");
		goto error;
	}
	jp2_box_destroy(box);
	box = 0;

	/* Get more boxes... */
 	found = 0;
 	while ((box = jp2_box_get(in))) {
 		if (jas_getdbglevel() >= 1) {
//flaw_line_below:
			jas_eprintf(""box type %s\n"", box->info->name);
//fix_flaw_line_below:
//			jas_eprintf(""got box type %s\n"", box->info->name);
 		}
 		switch (box->type) {
 		case JP2_BOX_JP2C:
			found = 1;
			break;
		case JP2_BOX_IHDR:
			if (!dec->ihdr) {
				dec->ihdr = box;
				box = 0;
			}
			break;
		case JP2_BOX_BPCC:
			if (!dec->bpcc) {
				dec->bpcc = box;
				box = 0;
			}
			break;
		case JP2_BOX_CDEF:
			if (!dec->cdef) {
				dec->cdef = box;
				box = 0;
			}
			break;
		case JP2_BOX_PCLR:
			if (!dec->pclr) {
				dec->pclr = box;
				box = 0;
			}
			break;
		case JP2_BOX_CMAP:
			if (!dec->cmap) {
				dec->cmap = box;
				box = 0;
			}
			break;
		case JP2_BOX_COLR:
			if (!dec->colr) {
				dec->colr = box;
				box = 0;
			}
			break;
		}
		if (box) {
			jp2_box_destroy(box);
			box = 0;
		}
		if (found) {
			break;
		}
	}

	if (!found) {
		jas_eprintf(""error: no code stream found\n"");
		goto error;
	}

	if (!(dec->image = jpc_decode(in, optstr))) {
		jas_eprintf(""error: cannot decode code stream\n"");
		goto error;
	}

	/* An IHDR box must be present. */
	if (!dec->ihdr) {
		jas_eprintf(""error: missing IHDR box\n"");
		goto error;
	}

	/* Does the number of components indicated in the IHDR box match
	  the value specified in the code stream? */
	if (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(uint,
	  jas_image_numcmpts(dec->image))) {
		jas_eprintf(""warning: number of components mismatch\n"");
	}

	/* At least one component must be present. */
	if (!jas_image_numcmpts(dec->image)) {
		jas_eprintf(""error: no components\n"");
		goto error;
	}

	/* Determine if all components have the same data type. */
	samedtype = true;
	dtype = jas_image_cmptdtype(dec->image, 0);
	for (i = 1; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {
		if (jas_image_cmptdtype(dec->image, i) != dtype) {
			samedtype = false;
			break;
		}
	}

	/* Is the component data type indicated in the IHDR box consistent
	  with the data in the code stream? */
	if ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||
	  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {
		jas_eprintf(""warning: component data type mismatch\n"");
	}

	/* Is the compression type supported? */
	if (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {
		jas_eprintf(""error: unsupported compression type\n"");
		goto error;
	}

	if (dec->bpcc) {
		/* Is the number of components indicated in the BPCC box
		  consistent with the code stream data? */
		if (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(uint, jas_image_numcmpts(
		  dec->image))) {
			jas_eprintf(""warning: number of components mismatch\n"");
		}
		/* Is the component data type information indicated in the BPCC
		  box consistent with the code stream data? */
		if (!samedtype) {
			for (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image));
			  ++i) {
				if (jas_image_cmptdtype(dec->image, i) !=
				  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {
					jas_eprintf(""warning: component data type mismatch\n"");
				}
			}
		} else {
			jas_eprintf(""warning: superfluous BPCC box\n"");
		}
	}

	/* A COLR box must be present. */
	if (!dec->colr) {
		jas_eprintf(""error: no COLR box\n"");
		goto error;
	}

	switch (dec->colr->data.colr.method) {
	case JP2_COLR_ENUM:
		jas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));
		break;
	case JP2_COLR_ICC:
		iccprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,
		  dec->colr->data.colr.iccplen);
		if (!iccprof) {
			jas_eprintf(""error: failed to parse ICC profile\n"");
			goto error;
		}
		jas_iccprof_gethdr(iccprof, &icchdr);
		jas_eprintf(""ICC Profile CS %08x\n"", icchdr.colorspc);
		jas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));
		dec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);
		assert(dec->image->cmprof_);
		jas_iccprof_destroy(iccprof);
		break;
	}

	/* If a CMAP box is present, a PCLR box must also be present. */
	if (dec->cmap && !dec->pclr) {
		jas_eprintf(""warning: missing PCLR box or superfluous CMAP box\n"");
		jp2_box_destroy(dec->cmap);
		dec->cmap = 0;
	}

	/* If a CMAP box is not present, a PCLR box must not be present. */
	if (!dec->cmap && dec->pclr) {
		jas_eprintf(""warning: missing CMAP box or superfluous PCLR box\n"");
		jp2_box_destroy(dec->pclr);
		dec->pclr = 0;
	}

	/* Determine the number of channels (which is essentially the number
	  of components after any palette mappings have been applied). */
	dec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :
	  JAS_CAST(uint, jas_image_numcmpts(dec->image));

	/* Perform a basic sanity check on the CMAP box if present. */
	if (dec->cmap) {
		for (i = 0; i < dec->numchans; ++i) {
			/* Is the component number reasonable? */
			if (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(uint,
			  jas_image_numcmpts(dec->image))) {
				jas_eprintf(""error: invalid component number in CMAP box\n"");
				goto error;
			}
			/* Is the LUT index reasonable? */
			if (dec->cmap->data.cmap.ents[i].pcol >=
			  dec->pclr->data.pclr.numchans) {
				jas_eprintf(""error: invalid CMAP LUT index\n"");
				goto error;
			}
		}
	}

	/* Allocate space for the channel-number to component-number LUT. */
	if (!(dec->chantocmptlut = jas_alloc2(dec->numchans,
	  sizeof(uint_fast16_t)))) {
		jas_eprintf(""error: no memory\n"");
		goto error;
	}

	if (!dec->cmap) {
		for (i = 0; i < dec->numchans; ++i) {
			dec->chantocmptlut[i] = i;
		}
	} else {
		cmapd = &dec->cmap->data.cmap;
		pclrd = &dec->pclr->data.pclr;
		cdefd = &dec->cdef->data.cdef;
		for (channo = 0; channo < cmapd->numchans; ++channo) {
			cmapent = &cmapd->ents[channo];
			if (cmapent->map == JP2_CMAP_DIRECT) {
				dec->chantocmptlut[channo] = channo;
			} else if (cmapent->map == JP2_CMAP_PALETTE) {
				lutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));
				for (i = 0; i < pclrd->numlutents; ++i) {
					lutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];
				}
				newcmptno = jas_image_numcmpts(dec->image);
				jas_image_depalettize(dec->image, cmapent->cmptno,
				  pclrd->numlutents, lutents,
				  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);
				dec->chantocmptlut[channo] = newcmptno;
				jas_free(lutents);
#if 0
				if (dec->cdef) {
					cdefent = jp2_cdef_lookup(cdefd, channo);
					if (!cdefent) {
						abort();
					}
				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));
				} else {
				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));
				}
#endif
			}
		}
	}

	/* Mark all components as being of unknown type. */

	for (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {
		jas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);
	}

	/* Determine the type of each component. */
	if (dec->cdef) {
		for (i = 0; i < dec->numchans; ++i) {
			/* Is the channel number reasonable? */
			if (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {
				jas_eprintf(""error: invalid channel number in CDEF box\n"");
				goto error;
			}
			jas_image_setcmpttype(dec->image,
			  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],
			  jp2_getct(jas_image_clrspc(dec->image),
			  dec->cdef->data.cdef.ents[i].type,
			  dec->cdef->data.cdef.ents[i].assoc));
		}
	} else {
		for (i = 0; i < dec->numchans; ++i) {
			jas_image_setcmpttype(dec->image, dec->chantocmptlut[i],
			  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));
		}
	}

	/* Delete any components that are not of interest. */
	for (i = jas_image_numcmpts(dec->image); i > 0; --i) {
		if (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {
			jas_image_delcmpt(dec->image, i - 1);
		}
	}

	/* Ensure that some components survived. */
	if (!jas_image_numcmpts(dec->image)) {
		jas_eprintf(""error: no components\n"");
		goto error;
	}
#if 0
jas_eprintf(""no of components is %d\n"", jas_image_numcmpts(dec->image));
#endif

	/* Prevent the image from being destroyed later. */
	image = dec->image;
	dec->image = 0;

	jp2_dec_destroy(dec);

	return image;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (dec) {
		jp2_dec_destroy(dec);
	}
	return 0;
}
"
4191,181927,,Remote,Not required,Partial,CVE-2016-8884,https://www.cvedetails.com/cve/CVE-2016-8884/,CWE-476,Medium,,,,2017-03-28,4.3,The bmp_getdata function in libjasper/bmp/bmp_dec.c in JasPer 1.900.5 allows remote attackers to cause a denial of service (NULL pointer dereference) by calling the imginfo command with a crafted BMP image. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8690.,2018-01-04,DoS ,4,https://github.com/mdadams/jasper/commit/5d66894d2313e3f3469f19066e149e08ff076698,5d66894d2313e3f3469f19066e149e08ff076698,Fixed a problem with a null pointer dereference in the BMP decoder.,0,src/libjasper/base/jas_seq.c,"{""sha"": ""cac20e2d4f2d5f880428d825e09a226acd45fd28"", ""filename"": ""src/libjasper/base/jas_seq.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/mdadams/jasper/blob/5d66894d2313e3f3469f19066e149e08ff076698/src/libjasper/base/jas_seq.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/5d66894d2313e3f3469f19066e149e08ff076698/src/libjasper/base/jas_seq.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/base/jas_seq.c?ref=5d66894d2313e3f3469f19066e149e08ff076698"", ""patch"": ""@@ -102,6 +102,10 @@ jas_matrix_t *jas_matrix_create(int numrows, int numcols)\n \tjas_matrix_t *matrix;\n \tint i;\n \n+\tif (numrows < 0 || numcols < 0) {\n+\t\treturn 0;\n+\t}\n+\n \tif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\n \t\treturn 0;\n \t}""}<_**next**_>{""sha"": ""d5a903f5ced3d36af6bb96c8fb7cbab29f0108e3"", ""filename"": ""src/libjasper/bmp/bmp_dec.c"", ""status"": ""modified"", ""additions"": 45, ""deletions"": 17, ""changes"": 62, ""blob_url"": ""https://github.com/mdadams/jasper/blob/5d66894d2313e3f3469f19066e149e08ff076698/src/libjasper/bmp/bmp_dec.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/5d66894d2313e3f3469f19066e149e08ff076698/src/libjasper/bmp/bmp_dec.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/bmp/bmp_dec.c?ref=5d66894d2313e3f3469f19066e149e08ff076698"", ""patch"": ""@@ -107,6 +107,9 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \tuint_fast16_t numcmpts;\n \tlong n;\n \n+\timage = 0;\n+\tinfo = 0;\n+\n \tif (optstr) {\n \t\tjas_eprintf(\""warning: ignoring BMP decoder options\\n\"");\n \t}\n@@ -121,7 +124,8 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \t/* Read the bitmap header. */\n \tif (bmp_gethdr(in, &hdr)) {\n \t\tjas_eprintf(\""cannot get header\\n\"");\n-\t\treturn 0;\n+\t\tgoto error;\n+\t\t//return 0;\n \t}\n \tJAS_DBGLOG(1, (\n \t  \""BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\"",\n@@ -131,33 +135,46 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \t/* Read the bitmap information. */\n \tif (!(info = bmp_getinfo(in))) {\n \t\tjas_eprintf(\""cannot get info\\n\"");\n-\t\treturn 0;\n+\t\t//return 0;\n+\t\tgoto error;\n \t}\n \tJAS_DBGLOG(1,\n-\t  (\""BMP information: len %d; width %d; height %d; numplanes %d; \""\n-\t  \""depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \""\n-\t  \""mincolors %d\\n\"", info->len, info->width, info->height, info->numplanes,\n-\t  info->depth, info->enctype, info->siz, info->hres, info->vres,\n-\t  info->numcolors, info->mincolors));\n+\t  (\""BMP information: len %ld; width %ld; height %ld; numplanes %d; \""\n+\t  \""depth %d; enctype %ld; siz %ld; hres %ld; vres %ld; numcolors %ld; \""\n+\t  \""mincolors %ld\\n\"", JAS_CAST(long, info->len),\n+\t  JAS_CAST(long, info->width), JAS_CAST(long, info->height),\n+\t  JAS_CAST(long, info->numplanes), JAS_CAST(long, info->depth),\n+\t  JAS_CAST(long, info->enctype), JAS_CAST(long, info->siz),\n+\t  JAS_CAST(long, info->hres), JAS_CAST(long, info->vres),\n+\t  JAS_CAST(long, info->numcolors), JAS_CAST(long, info->mincolors)));\n+\n+\tif (info->width < 0 || info->height < 0 || info->numplanes < 0 ||\n+\t  info->depth < 0 || info->siz < 0 || info->hres < 0 || info->vres < 0) {\n+\t\tjas_eprintf(\""corrupt bit stream\\n\"");\n+\t\tgoto error;\n+\t}\n \n \t/* Ensure that we support this type of BMP file. */\n \tif (!bmp_issupported(&hdr, info)) {\n \t\tjas_eprintf(\""error: unsupported BMP encoding\\n\"");\n-\t\tbmp_info_destroy(info);\n-\t\treturn 0;\n+\t\t//bmp_info_destroy(info);\n+\t\t//return 0;\n+\t\tgoto error;\n \t}\n \n \t/* Skip over any useless data between the end of the palette\n \t  and start of the bitmap data. */\n \tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n \t\tjas_eprintf(\""error: possibly bad bitmap offset?\\n\"");\n-\t\treturn 0;\n+\t\tgoto error;\n+\t\t//return 0;\n \t}\n \tif (n > 0) {\n \t\tjas_eprintf(\""skipping unknown data in BMP file\\n\"");\n \t\tif (bmp_gobble(in, n)) {\n-\t\t\tbmp_info_destroy(info);\n-\t\t\treturn 0;\n+\t\t\t//bmp_info_destroy(info);\n+\t\t\t//return 0;\n+\t\t\tgoto error;\n \t\t}\n \t}\n \n@@ -179,8 +196,9 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \t/* Create image object. */\n \tif (!(image = jas_image_create(numcmpts, cmptparms,\n \t  JAS_CLRSPC_UNKNOWN))) {\n-\t\tbmp_info_destroy(info);\n-\t\treturn 0;\n+\t\t//bmp_info_destroy(info);\n+\t\t//return 0;\n+\t\tgoto error;\n \t}\n \n \tif (numcmpts == 3) {\n@@ -199,14 +217,24 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \n \t/* Read the bitmap data. */\n \tif (bmp_getdata(in, info, image)) {\n-\t\tbmp_info_destroy(info);\n-\t\tjas_image_destroy(image);\n-\t\treturn 0;\n+\t\t//bmp_info_destroy(info);\n+\t\t//jas_image_destroy(image);\n+\t\t//return 0;\n+\t\tgoto error;\n \t}\n \n \tbmp_info_destroy(info);\n \n \treturn image;\n+\n+error:\n+\tif (info) {\n+\t\tbmp_info_destroy(info);\n+\t}\n+\tif (image) {\n+\t\tjas_image_destroy(image);\n+\t}\n+\treturn 0;\n }\n \n int bmp_validate(jas_stream_t *in)""}","jas_matrix_t *jas_matrix_create(int numrows, int numcols)
{
 	jas_matrix_t *matrix;
 	int i;
 
	if (numrows < 0 || numcols < 0) {
		return 0;
	}

 	if (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {
 		return 0;
 	}
	matrix->flags_ = 0;
	matrix->numrows_ = numrows;
	matrix->numcols_ = numcols;
	matrix->rows_ = 0;
	matrix->maxrows_ = numrows;
	matrix->data_ = 0;
	matrix->datasize_ = numrows * numcols;

	if (matrix->maxrows_ > 0) {
		if (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,
		  sizeof(jas_seqent_t *)))) {
			jas_matrix_destroy(matrix);
			return 0;
		}
	}

	if (matrix->datasize_ > 0) {
		if (!(matrix->data_ = jas_alloc2(matrix->datasize_,
		  sizeof(jas_seqent_t)))) {
			jas_matrix_destroy(matrix);
			return 0;
		}
	}

	for (i = 0; i < numrows; ++i) {
		matrix->rows_[i] = &matrix->data_[i * matrix->numcols_];
	}

	for (i = 0; i < matrix->datasize_; ++i) {
		matrix->data_[i] = 0;
	}

	matrix->xstart_ = 0;
	matrix->ystart_ = 0;
	matrix->xend_ = matrix->numcols_;
	matrix->yend_ = matrix->numrows_;

	return matrix;
}
","jas_matrix_t *jas_matrix_create(int numrows, int numcols)
{
 	jas_matrix_t *matrix;
 	int i;
 
 	if (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {
 		return 0;
 	}
	matrix->flags_ = 0;
	matrix->numrows_ = numrows;
	matrix->numcols_ = numcols;
	matrix->rows_ = 0;
	matrix->maxrows_ = numrows;
	matrix->data_ = 0;
	matrix->datasize_ = numrows * numcols;

	if (matrix->maxrows_ > 0) {
		if (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,
		  sizeof(jas_seqent_t *)))) {
			jas_matrix_destroy(matrix);
			return 0;
		}
	}

	if (matrix->datasize_ > 0) {
		if (!(matrix->data_ = jas_alloc2(matrix->datasize_,
		  sizeof(jas_seqent_t)))) {
			jas_matrix_destroy(matrix);
			return 0;
		}
	}

	for (i = 0; i < numrows; ++i) {
		matrix->rows_[i] = &matrix->data_[i * matrix->numcols_];
	}

	for (i = 0; i < matrix->datasize_; ++i) {
		matrix->data_[i] = 0;
	}

	matrix->xstart_ = 0;
	matrix->ystart_ = 0;
	matrix->xend_ = matrix->numcols_;
	matrix->yend_ = matrix->numrows_;

	return matrix;
}
",C,"	if (numrows < 0 || numcols < 0) {
		return 0;
	}

",,,"@@ -102,6 +102,10 @@ jas_matrix_t *jas_matrix_create(int numrows, int numcols)
 	jas_matrix_t *matrix;
 	int i;
 
+	if (numrows < 0 || numcols < 0) {
+		return 0;
+	}
+
 	if (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {
 		return 0;
 	}",jasper,5d66894d2313e3f3469f19066e149e08ff076698,cfa945c7246407cb8ceeb7f6cb205c60295c906f,1,"jas_matrix_t *jas_matrix_create(int numrows, int numcols)
{
 	jas_matrix_t *matrix;
 	int i;
 
//fix_flaw_line_below:
//	if (numrows < 0 || numcols < 0) {
//fix_flaw_line_below:
//		return 0;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	if (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {
 		return 0;
 	}
	matrix->flags_ = 0;
	matrix->numrows_ = numrows;
	matrix->numcols_ = numcols;
	matrix->rows_ = 0;
	matrix->maxrows_ = numrows;
	matrix->data_ = 0;
	matrix->datasize_ = numrows * numcols;

	if (matrix->maxrows_ > 0) {
		if (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,
		  sizeof(jas_seqent_t *)))) {
			jas_matrix_destroy(matrix);
			return 0;
		}
	}

	if (matrix->datasize_ > 0) {
		if (!(matrix->data_ = jas_alloc2(matrix->datasize_,
		  sizeof(jas_seqent_t)))) {
			jas_matrix_destroy(matrix);
			return 0;
		}
	}

	for (i = 0; i < numrows; ++i) {
		matrix->rows_[i] = &matrix->data_[i * matrix->numcols_];
	}

	for (i = 0; i < matrix->datasize_; ++i) {
		matrix->data_[i] = 0;
	}

	matrix->xstart_ = 0;
	matrix->ystart_ = 0;
	matrix->xend_ = matrix->numcols_;
	matrix->yend_ = matrix->numrows_;

	return matrix;
}
"
4192,181928,,Remote,Not required,Partial,CVE-2016-8884,https://www.cvedetails.com/cve/CVE-2016-8884/,CWE-476,Medium,,,,2017-03-28,4.3,The bmp_getdata function in libjasper/bmp/bmp_dec.c in JasPer 1.900.5 allows remote attackers to cause a denial of service (NULL pointer dereference) by calling the imginfo command with a crafted BMP image. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8690.,2018-01-04,DoS ,45,https://github.com/mdadams/jasper/commit/5d66894d2313e3f3469f19066e149e08ff076698,5d66894d2313e3f3469f19066e149e08ff076698,Fixed a problem with a null pointer dereference in the BMP decoder.,17,src/libjasper/bmp/bmp_dec.c,"{""sha"": ""cac20e2d4f2d5f880428d825e09a226acd45fd28"", ""filename"": ""src/libjasper/base/jas_seq.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/mdadams/jasper/blob/5d66894d2313e3f3469f19066e149e08ff076698/src/libjasper/base/jas_seq.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/5d66894d2313e3f3469f19066e149e08ff076698/src/libjasper/base/jas_seq.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/base/jas_seq.c?ref=5d66894d2313e3f3469f19066e149e08ff076698"", ""patch"": ""@@ -102,6 +102,10 @@ jas_matrix_t *jas_matrix_create(int numrows, int numcols)\n \tjas_matrix_t *matrix;\n \tint i;\n \n+\tif (numrows < 0 || numcols < 0) {\n+\t\treturn 0;\n+\t}\n+\n \tif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\n \t\treturn 0;\n \t}""}<_**next**_>{""sha"": ""d5a903f5ced3d36af6bb96c8fb7cbab29f0108e3"", ""filename"": ""src/libjasper/bmp/bmp_dec.c"", ""status"": ""modified"", ""additions"": 45, ""deletions"": 17, ""changes"": 62, ""blob_url"": ""https://github.com/mdadams/jasper/blob/5d66894d2313e3f3469f19066e149e08ff076698/src/libjasper/bmp/bmp_dec.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/5d66894d2313e3f3469f19066e149e08ff076698/src/libjasper/bmp/bmp_dec.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/bmp/bmp_dec.c?ref=5d66894d2313e3f3469f19066e149e08ff076698"", ""patch"": ""@@ -107,6 +107,9 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \tuint_fast16_t numcmpts;\n \tlong n;\n \n+\timage = 0;\n+\tinfo = 0;\n+\n \tif (optstr) {\n \t\tjas_eprintf(\""warning: ignoring BMP decoder options\\n\"");\n \t}\n@@ -121,7 +124,8 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \t/* Read the bitmap header. */\n \tif (bmp_gethdr(in, &hdr)) {\n \t\tjas_eprintf(\""cannot get header\\n\"");\n-\t\treturn 0;\n+\t\tgoto error;\n+\t\t//return 0;\n \t}\n \tJAS_DBGLOG(1, (\n \t  \""BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\"",\n@@ -131,33 +135,46 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \t/* Read the bitmap information. */\n \tif (!(info = bmp_getinfo(in))) {\n \t\tjas_eprintf(\""cannot get info\\n\"");\n-\t\treturn 0;\n+\t\t//return 0;\n+\t\tgoto error;\n \t}\n \tJAS_DBGLOG(1,\n-\t  (\""BMP information: len %d; width %d; height %d; numplanes %d; \""\n-\t  \""depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \""\n-\t  \""mincolors %d\\n\"", info->len, info->width, info->height, info->numplanes,\n-\t  info->depth, info->enctype, info->siz, info->hres, info->vres,\n-\t  info->numcolors, info->mincolors));\n+\t  (\""BMP information: len %ld; width %ld; height %ld; numplanes %d; \""\n+\t  \""depth %d; enctype %ld; siz %ld; hres %ld; vres %ld; numcolors %ld; \""\n+\t  \""mincolors %ld\\n\"", JAS_CAST(long, info->len),\n+\t  JAS_CAST(long, info->width), JAS_CAST(long, info->height),\n+\t  JAS_CAST(long, info->numplanes), JAS_CAST(long, info->depth),\n+\t  JAS_CAST(long, info->enctype), JAS_CAST(long, info->siz),\n+\t  JAS_CAST(long, info->hres), JAS_CAST(long, info->vres),\n+\t  JAS_CAST(long, info->numcolors), JAS_CAST(long, info->mincolors)));\n+\n+\tif (info->width < 0 || info->height < 0 || info->numplanes < 0 ||\n+\t  info->depth < 0 || info->siz < 0 || info->hres < 0 || info->vres < 0) {\n+\t\tjas_eprintf(\""corrupt bit stream\\n\"");\n+\t\tgoto error;\n+\t}\n \n \t/* Ensure that we support this type of BMP file. */\n \tif (!bmp_issupported(&hdr, info)) {\n \t\tjas_eprintf(\""error: unsupported BMP encoding\\n\"");\n-\t\tbmp_info_destroy(info);\n-\t\treturn 0;\n+\t\t//bmp_info_destroy(info);\n+\t\t//return 0;\n+\t\tgoto error;\n \t}\n \n \t/* Skip over any useless data between the end of the palette\n \t  and start of the bitmap data. */\n \tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n \t\tjas_eprintf(\""error: possibly bad bitmap offset?\\n\"");\n-\t\treturn 0;\n+\t\tgoto error;\n+\t\t//return 0;\n \t}\n \tif (n > 0) {\n \t\tjas_eprintf(\""skipping unknown data in BMP file\\n\"");\n \t\tif (bmp_gobble(in, n)) {\n-\t\t\tbmp_info_destroy(info);\n-\t\t\treturn 0;\n+\t\t\t//bmp_info_destroy(info);\n+\t\t\t//return 0;\n+\t\t\tgoto error;\n \t\t}\n \t}\n \n@@ -179,8 +196,9 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \t/* Create image object. */\n \tif (!(image = jas_image_create(numcmpts, cmptparms,\n \t  JAS_CLRSPC_UNKNOWN))) {\n-\t\tbmp_info_destroy(info);\n-\t\treturn 0;\n+\t\t//bmp_info_destroy(info);\n+\t\t//return 0;\n+\t\tgoto error;\n \t}\n \n \tif (numcmpts == 3) {\n@@ -199,14 +217,24 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \n \t/* Read the bitmap data. */\n \tif (bmp_getdata(in, info, image)) {\n-\t\tbmp_info_destroy(info);\n-\t\tjas_image_destroy(image);\n-\t\treturn 0;\n+\t\t//bmp_info_destroy(info);\n+\t\t//jas_image_destroy(image);\n+\t\t//return 0;\n+\t\tgoto error;\n \t}\n \n \tbmp_info_destroy(info);\n \n \treturn image;\n+\n+error:\n+\tif (info) {\n+\t\tbmp_info_destroy(info);\n+\t}\n+\tif (image) {\n+\t\tjas_image_destroy(image);\n+\t}\n+\treturn 0;\n }\n \n int bmp_validate(jas_stream_t *in)""}","jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)
{
	jas_image_t *image;
	bmp_hdr_t hdr;
	bmp_info_t *info;
	uint_fast16_t cmptno;
	jas_image_cmptparm_t cmptparms[3];
	jas_image_cmptparm_t *cmptparm;
 	uint_fast16_t numcmpts;
 	long n;
 
	image = 0;
	info = 0;

 	if (optstr) {
 		jas_eprintf(""warning: ignoring BMP decoder options\n"");
 	}

	jas_eprintf(
	  ""THE BMP FORMAT IS NOT FULLY SUPPORTED!\n""
	  ""THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\n""
	  ""IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\n""
	  ""TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\n""
	  );

 	/* Read the bitmap header. */
 	if (bmp_gethdr(in, &hdr)) {
 		jas_eprintf(""cannot get header\n"");
		goto error;
		//return 0;
 	}
 	JAS_DBGLOG(1, (
 	  ""BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\n"",
	  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off
	  ));

 	/* Read the bitmap information. */
 	if (!(info = bmp_getinfo(in))) {
 		jas_eprintf(""cannot get info\n"");
		//return 0;
		goto error;
 	}
 	JAS_DBGLOG(1,
	  (""BMP information: len %ld; width %ld; height %ld; numplanes %d; ""
	  ""depth %d; enctype %ld; siz %ld; hres %ld; vres %ld; numcolors %ld; ""
	  ""mincolors %ld\n"", JAS_CAST(long, info->len),
	  JAS_CAST(long, info->width), JAS_CAST(long, info->height),
	  JAS_CAST(long, info->numplanes), JAS_CAST(long, info->depth),
	  JAS_CAST(long, info->enctype), JAS_CAST(long, info->siz),
	  JAS_CAST(long, info->hres), JAS_CAST(long, info->vres),
	  JAS_CAST(long, info->numcolors), JAS_CAST(long, info->mincolors)));

	if (info->width < 0 || info->height < 0 || info->numplanes < 0 ||
	  info->depth < 0 || info->siz < 0 || info->hres < 0 || info->vres < 0) {
		jas_eprintf(""corrupt bit stream\n"");
		goto error;
	}
 
 	/* Ensure that we support this type of BMP file. */
 	if (!bmp_issupported(&hdr, info)) {
 		jas_eprintf(""error: unsupported BMP encoding\n"");
		//bmp_info_destroy(info);
		//return 0;
		goto error;
 	}
 
 	/* Skip over any useless data between the end of the palette
 	  and start of the bitmap data. */
 	if ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {
 		jas_eprintf(""error: possibly bad bitmap offset?\n"");
		goto error;
		//return 0;
 	}
 	if (n > 0) {
 		jas_eprintf(""skipping unknown data in BMP file\n"");
 		if (bmp_gobble(in, n)) {
			//bmp_info_destroy(info);
			//return 0;
			goto error;
 		}
 	}
 
	/* Get the number of components. */
	numcmpts = bmp_numcmpts(info);

	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
	  ++cmptparm) {
		cmptparm->tlx = 0;
		cmptparm->tly = 0;
		cmptparm->hstep = 1;
		cmptparm->vstep = 1;
		cmptparm->width = info->width;
		cmptparm->height = info->height;
		cmptparm->prec = 8;
		cmptparm->sgnd = false;
	}

 	/* Create image object. */
 	if (!(image = jas_image_create(numcmpts, cmptparms,
 	  JAS_CLRSPC_UNKNOWN))) {
		//bmp_info_destroy(info);
		//return 0;
		goto error;
 	}
 
 	if (numcmpts == 3) {
		jas_image_setclrspc(image, JAS_CLRSPC_SRGB);
		jas_image_setcmpttype(image, 0,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));
		jas_image_setcmpttype(image, 1,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));
		jas_image_setcmpttype(image, 2,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));
	} else {
		jas_image_setclrspc(image, JAS_CLRSPC_SGRAY);
		jas_image_setcmpttype(image, 0,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));
	}
 
 	/* Read the bitmap data. */
 	if (bmp_getdata(in, info, image)) {
		//bmp_info_destroy(info);
		//jas_image_destroy(image);
		//return 0;
		goto error;
 	}
 
 	bmp_info_destroy(info);
 
 	return image;

error:
	if (info) {
		bmp_info_destroy(info);
	}
	if (image) {
		jas_image_destroy(image);
	}
	return 0;
 }
","jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)
{
	jas_image_t *image;
	bmp_hdr_t hdr;
	bmp_info_t *info;
	uint_fast16_t cmptno;
	jas_image_cmptparm_t cmptparms[3];
	jas_image_cmptparm_t *cmptparm;
 	uint_fast16_t numcmpts;
 	long n;
 
 	if (optstr) {
 		jas_eprintf(""warning: ignoring BMP decoder options\n"");
 	}

	jas_eprintf(
	  ""THE BMP FORMAT IS NOT FULLY SUPPORTED!\n""
	  ""THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\n""
	  ""IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\n""
	  ""TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\n""
	  );

 	/* Read the bitmap header. */
 	if (bmp_gethdr(in, &hdr)) {
 		jas_eprintf(""cannot get header\n"");
		return 0;
 	}
 	JAS_DBGLOG(1, (
 	  ""BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\n"",
	  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off
	  ));

 	/* Read the bitmap information. */
 	if (!(info = bmp_getinfo(in))) {
 		jas_eprintf(""cannot get info\n"");
		return 0;
 	}
 	JAS_DBGLOG(1,
	  (""BMP information: len %d; width %d; height %d; numplanes %d; ""
	  ""depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; ""
	  ""mincolors %d\n"", info->len, info->width, info->height, info->numplanes,
	  info->depth, info->enctype, info->siz, info->hres, info->vres,
	  info->numcolors, info->mincolors));
 
 	/* Ensure that we support this type of BMP file. */
 	if (!bmp_issupported(&hdr, info)) {
 		jas_eprintf(""error: unsupported BMP encoding\n"");
		bmp_info_destroy(info);
		return 0;
 	}
 
 	/* Skip over any useless data between the end of the palette
 	  and start of the bitmap data. */
 	if ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {
 		jas_eprintf(""error: possibly bad bitmap offset?\n"");
		return 0;
 	}
 	if (n > 0) {
 		jas_eprintf(""skipping unknown data in BMP file\n"");
 		if (bmp_gobble(in, n)) {
			bmp_info_destroy(info);
			return 0;
 		}
 	}
 
	/* Get the number of components. */
	numcmpts = bmp_numcmpts(info);

	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
	  ++cmptparm) {
		cmptparm->tlx = 0;
		cmptparm->tly = 0;
		cmptparm->hstep = 1;
		cmptparm->vstep = 1;
		cmptparm->width = info->width;
		cmptparm->height = info->height;
		cmptparm->prec = 8;
		cmptparm->sgnd = false;
	}

 	/* Create image object. */
 	if (!(image = jas_image_create(numcmpts, cmptparms,
 	  JAS_CLRSPC_UNKNOWN))) {
		bmp_info_destroy(info);
		return 0;
 	}
 
 	if (numcmpts == 3) {
		jas_image_setclrspc(image, JAS_CLRSPC_SRGB);
		jas_image_setcmpttype(image, 0,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));
		jas_image_setcmpttype(image, 1,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));
		jas_image_setcmpttype(image, 2,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));
	} else {
		jas_image_setclrspc(image, JAS_CLRSPC_SGRAY);
		jas_image_setcmpttype(image, 0,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));
	}
 
 	/* Read the bitmap data. */
 	if (bmp_getdata(in, info, image)) {
		bmp_info_destroy(info);
		jas_image_destroy(image);
		return 0;
 	}
 
 	bmp_info_destroy(info);
 
 	return image;
 }
",C,"	image = 0;
	info = 0;

		goto error;
		//return 0;
		//return 0;
		goto error;
	  (""BMP information: len %ld; width %ld; height %ld; numplanes %d; ""
	  ""depth %d; enctype %ld; siz %ld; hres %ld; vres %ld; numcolors %ld; ""
	  ""mincolors %ld\n"", JAS_CAST(long, info->len),
	  JAS_CAST(long, info->width), JAS_CAST(long, info->height),
	  JAS_CAST(long, info->numplanes), JAS_CAST(long, info->depth),
	  JAS_CAST(long, info->enctype), JAS_CAST(long, info->siz),
	  JAS_CAST(long, info->hres), JAS_CAST(long, info->vres),
	  JAS_CAST(long, info->numcolors), JAS_CAST(long, info->mincolors)));

	if (info->width < 0 || info->height < 0 || info->numplanes < 0 ||
	  info->depth < 0 || info->siz < 0 || info->hres < 0 || info->vres < 0) {
		jas_eprintf(""corrupt bit stream\n"");
		goto error;
	}
		//bmp_info_destroy(info);
		//return 0;
		goto error;
		goto error;
		//return 0;
			//bmp_info_destroy(info);
			//return 0;
			goto error;
		//bmp_info_destroy(info);
		//return 0;
		goto error;
		//bmp_info_destroy(info);
		//jas_image_destroy(image);
		//return 0;
		goto error;

error:
	if (info) {
		bmp_info_destroy(info);
	}
	if (image) {
		jas_image_destroy(image);
	}
	return 0;
","		return 0;
		return 0;
	  (""BMP information: len %d; width %d; height %d; numplanes %d; ""
	  ""depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; ""
	  ""mincolors %d\n"", info->len, info->width, info->height, info->numplanes,
	  info->depth, info->enctype, info->siz, info->hres, info->vres,
	  info->numcolors, info->mincolors));
		bmp_info_destroy(info);
		return 0;
		return 0;
			bmp_info_destroy(info);
			return 0;
		bmp_info_destroy(info);
		return 0;
		bmp_info_destroy(info);
		jas_image_destroy(image);
		return 0;
",,"@@ -107,6 +107,9 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)
 	uint_fast16_t numcmpts;
 	long n;
 
+	image = 0;
+	info = 0;
+
 	if (optstr) {
 		jas_eprintf(""warning: ignoring BMP decoder options\n"");
 	}
@@ -121,7 +124,8 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)
 	/* Read the bitmap header. */
 	if (bmp_gethdr(in, &hdr)) {
 		jas_eprintf(""cannot get header\n"");
-		return 0;
+		goto error;
+		//return 0;
 	}
 	JAS_DBGLOG(1, (
 	  ""BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\n"",
@@ -131,33 +135,46 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)
 	/* Read the bitmap information. */
 	if (!(info = bmp_getinfo(in))) {
 		jas_eprintf(""cannot get info\n"");
-		return 0;
+		//return 0;
+		goto error;
 	}
 	JAS_DBGLOG(1,
-	  (""BMP information: len %d; width %d; height %d; numplanes %d; ""
-	  ""depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; ""
-	  ""mincolors %d\n"", info->len, info->width, info->height, info->numplanes,
-	  info->depth, info->enctype, info->siz, info->hres, info->vres,
-	  info->numcolors, info->mincolors));
+	  (""BMP information: len %ld; width %ld; height %ld; numplanes %d; ""
+	  ""depth %d; enctype %ld; siz %ld; hres %ld; vres %ld; numcolors %ld; ""
+	  ""mincolors %ld\n"", JAS_CAST(long, info->len),
+	  JAS_CAST(long, info->width), JAS_CAST(long, info->height),
+	  JAS_CAST(long, info->numplanes), JAS_CAST(long, info->depth),
+	  JAS_CAST(long, info->enctype), JAS_CAST(long, info->siz),
+	  JAS_CAST(long, info->hres), JAS_CAST(long, info->vres),
+	  JAS_CAST(long, info->numcolors), JAS_CAST(long, info->mincolors)));
+
+	if (info->width < 0 || info->height < 0 || info->numplanes < 0 ||
+	  info->depth < 0 || info->siz < 0 || info->hres < 0 || info->vres < 0) {
+		jas_eprintf(""corrupt bit stream\n"");
+		goto error;
+	}
 
 	/* Ensure that we support this type of BMP file. */
 	if (!bmp_issupported(&hdr, info)) {
 		jas_eprintf(""error: unsupported BMP encoding\n"");
-		bmp_info_destroy(info);
-		return 0;
+		//bmp_info_destroy(info);
+		//return 0;
+		goto error;
 	}
 
 	/* Skip over any useless data between the end of the palette
 	  and start of the bitmap data. */
 	if ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {
 		jas_eprintf(""error: possibly bad bitmap offset?\n"");
-		return 0;
+		goto error;
+		//return 0;
 	}
 	if (n > 0) {
 		jas_eprintf(""skipping unknown data in BMP file\n"");
 		if (bmp_gobble(in, n)) {
-			bmp_info_destroy(info);
-			return 0;
+			//bmp_info_destroy(info);
+			//return 0;
+			goto error;
 		}
 	}
 
@@ -179,8 +196,9 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)
 	/* Create image object. */
 	if (!(image = jas_image_create(numcmpts, cmptparms,
 	  JAS_CLRSPC_UNKNOWN))) {
-		bmp_info_destroy(info);
-		return 0;
+		//bmp_info_destroy(info);
+		//return 0;
+		goto error;
 	}
 
 	if (numcmpts == 3) {
@@ -199,14 +217,24 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)
 
 	/* Read the bitmap data. */
 	if (bmp_getdata(in, info, image)) {
-		bmp_info_destroy(info);
-		jas_image_destroy(image);
-		return 0;
+		//bmp_info_destroy(info);
+		//jas_image_destroy(image);
+		//return 0;
+		goto error;
 	}
 
 	bmp_info_destroy(info);
 
 	return image;
+
+error:
+	if (info) {
+		bmp_info_destroy(info);
+	}
+	if (image) {
+		jas_image_destroy(image);
+	}
+	return 0;
 }
 
 int bmp_validate(jas_stream_t *in)",jasper,5d66894d2313e3f3469f19066e149e08ff076698,cfa945c7246407cb8ceeb7f6cb205c60295c906f,1,"jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)
{
	jas_image_t *image;
	bmp_hdr_t hdr;
	bmp_info_t *info;
	uint_fast16_t cmptno;
	jas_image_cmptparm_t cmptparms[3];
	jas_image_cmptparm_t *cmptparm;
 	uint_fast16_t numcmpts;
 	long n;
 
//fix_flaw_line_below:
//	image = 0;
//fix_flaw_line_below:
//	info = 0;
//fix_flaw_line_below:
//
 	if (optstr) {
 		jas_eprintf(""warning: ignoring BMP decoder options\n"");
 	}

	jas_eprintf(
	  ""THE BMP FORMAT IS NOT FULLY SUPPORTED!\n""
	  ""THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\n""
	  ""IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\n""
	  ""TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\n""
	  );

 	/* Read the bitmap header. */
 	if (bmp_gethdr(in, &hdr)) {
 		jas_eprintf(""cannot get header\n"");
//flaw_line_below:
		return 0;
//fix_flaw_line_below:
//		goto error;
//fix_flaw_line_below:
//		//return 0;
 	}
 	JAS_DBGLOG(1, (
 	  ""BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\n"",
	  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off
	  ));

 	/* Read the bitmap information. */
 	if (!(info = bmp_getinfo(in))) {
 		jas_eprintf(""cannot get info\n"");
//flaw_line_below:
		return 0;
//fix_flaw_line_below:
//		//return 0;
//fix_flaw_line_below:
//		goto error;
 	}
 	JAS_DBGLOG(1,
//flaw_line_below:
	  (""BMP information: len %d; width %d; height %d; numplanes %d; ""
//flaw_line_below:
	  ""depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; ""
//flaw_line_below:
	  ""mincolors %d\n"", info->len, info->width, info->height, info->numplanes,
//flaw_line_below:
	  info->depth, info->enctype, info->siz, info->hres, info->vres,
//flaw_line_below:
	  info->numcolors, info->mincolors));
//fix_flaw_line_below:
//	  (""BMP information: len %ld; width %ld; height %ld; numplanes %d; ""
//fix_flaw_line_below:
//	  ""depth %d; enctype %ld; siz %ld; hres %ld; vres %ld; numcolors %ld; ""
//fix_flaw_line_below:
//	  ""mincolors %ld\n"", JAS_CAST(long, info->len),
//fix_flaw_line_below:
//	  JAS_CAST(long, info->width), JAS_CAST(long, info->height),
//fix_flaw_line_below:
//	  JAS_CAST(long, info->numplanes), JAS_CAST(long, info->depth),
//fix_flaw_line_below:
//	  JAS_CAST(long, info->enctype), JAS_CAST(long, info->siz),
//fix_flaw_line_below:
//	  JAS_CAST(long, info->hres), JAS_CAST(long, info->vres),
//fix_flaw_line_below:
//	  JAS_CAST(long, info->numcolors), JAS_CAST(long, info->mincolors)));
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (info->width < 0 || info->height < 0 || info->numplanes < 0 ||
//fix_flaw_line_below:
//	  info->depth < 0 || info->siz < 0 || info->hres < 0 || info->vres < 0) {
//fix_flaw_line_below:
//		jas_eprintf(""corrupt bit stream\n"");
//fix_flaw_line_below:
//		goto error;
//fix_flaw_line_below:
//	}
 
 	/* Ensure that we support this type of BMP file. */
 	if (!bmp_issupported(&hdr, info)) {
 		jas_eprintf(""error: unsupported BMP encoding\n"");
//flaw_line_below:
		bmp_info_destroy(info);
//flaw_line_below:
		return 0;
//fix_flaw_line_below:
//		//bmp_info_destroy(info);
//fix_flaw_line_below:
//		//return 0;
//fix_flaw_line_below:
//		goto error;
 	}
 
 	/* Skip over any useless data between the end of the palette
 	  and start of the bitmap data. */
 	if ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {
 		jas_eprintf(""error: possibly bad bitmap offset?\n"");
//flaw_line_below:
		return 0;
//fix_flaw_line_below:
//		goto error;
//fix_flaw_line_below:
//		//return 0;
 	}
 	if (n > 0) {
 		jas_eprintf(""skipping unknown data in BMP file\n"");
 		if (bmp_gobble(in, n)) {
//flaw_line_below:
			bmp_info_destroy(info);
//flaw_line_below:
			return 0;
//fix_flaw_line_below:
//			//bmp_info_destroy(info);
//fix_flaw_line_below:
//			//return 0;
//fix_flaw_line_below:
//			goto error;
 		}
 	}
 
	/* Get the number of components. */
	numcmpts = bmp_numcmpts(info);

	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
	  ++cmptparm) {
		cmptparm->tlx = 0;
		cmptparm->tly = 0;
		cmptparm->hstep = 1;
		cmptparm->vstep = 1;
		cmptparm->width = info->width;
		cmptparm->height = info->height;
		cmptparm->prec = 8;
		cmptparm->sgnd = false;
	}

 	/* Create image object. */
 	if (!(image = jas_image_create(numcmpts, cmptparms,
 	  JAS_CLRSPC_UNKNOWN))) {
//flaw_line_below:
		bmp_info_destroy(info);
//flaw_line_below:
		return 0;
//fix_flaw_line_below:
//		//bmp_info_destroy(info);
//fix_flaw_line_below:
//		//return 0;
//fix_flaw_line_below:
//		goto error;
 	}
 
 	if (numcmpts == 3) {
		jas_image_setclrspc(image, JAS_CLRSPC_SRGB);
		jas_image_setcmpttype(image, 0,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));
		jas_image_setcmpttype(image, 1,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));
		jas_image_setcmpttype(image, 2,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));
	} else {
		jas_image_setclrspc(image, JAS_CLRSPC_SGRAY);
		jas_image_setcmpttype(image, 0,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));
	}
 
 	/* Read the bitmap data. */
 	if (bmp_getdata(in, info, image)) {
//flaw_line_below:
		bmp_info_destroy(info);
//flaw_line_below:
		jas_image_destroy(image);
//flaw_line_below:
		return 0;
//fix_flaw_line_below:
//		//bmp_info_destroy(info);
//fix_flaw_line_below:
//		//jas_image_destroy(image);
//fix_flaw_line_below:
//		//return 0;
//fix_flaw_line_below:
//		goto error;
 	}
 
 	bmp_info_destroy(info);
 
 	return image;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//error:
//fix_flaw_line_below:
//	if (info) {
//fix_flaw_line_below:
//		bmp_info_destroy(info);
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//	if (image) {
//fix_flaw_line_below:
//		jas_image_destroy(image);
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//	return 0;
 }
"
4197,181933,,Remote,Not required,Partial,CVE-2016-8690,https://www.cvedetails.com/cve/CVE-2016-8690/,CWE-476,Medium,,,,2017-02-15,4.3,The bmp_getdata function in libjasper/bmp/bmp_dec.c in JasPer before 1.900.5 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted BMP image in an imginfo command.,2018-11-22,DoS ,8,https://github.com/mdadams/jasper/commit/8f62b4761711d036fd8964df256b938c809b7fca,8f62b4761711d036fd8964df256b938c809b7fca,"Fixed a sanitizer failure in the BMP codec.
Also, added a --debug-level command line option to the imginfo command
for debugging purposes.",0,src/appl/imginfo.c,"{""sha"": ""f458a9770e5554e0128f8794ecbeeb0dd37ba158"", ""filename"": ""src/appl/imginfo.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 1, ""changes"": 12, ""blob_url"": ""https://github.com/mdadams/jasper/blob/8f62b4761711d036fd8964df256b938c809b7fca/src/appl/imginfo.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/8f62b4761711d036fd8964df256b938c809b7fca/src/appl/imginfo.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/appl/imginfo.c?ref=8f62b4761711d036fd8964df256b938c809b7fca"", ""patch"": ""@@ -85,7 +85,8 @@ typedef enum {\n \tOPT_HELP,\n \tOPT_VERSION,\n \tOPT_VERBOSE,\n-\tOPT_INFILE\n+\tOPT_INFILE,\n+\tOPT_DEBUG\n } optid_t;\n \n /******************************************************************************\\\n@@ -104,6 +105,7 @@ static jas_opt_t opts[] = {\n \t{OPT_VERSION, \""version\"", 0},\n \t{OPT_VERBOSE, \""verbose\"", 0},\n \t{OPT_INFILE, \""f\"", JAS_OPT_HASARG},\n+\t{OPT_DEBUG, \""debug-level\"", JAS_OPT_HASARG},\n \t{-1, 0, 0}\n };\n \n@@ -126,6 +128,7 @@ int main(int argc, char **argv)\n \tint numcmpts;\n \tint verbose;\n \tchar *fmtname;\n+\tint debug;\n \n \tif (jas_init()) {\n \t\tabort();\n@@ -135,6 +138,7 @@ int main(int argc, char **argv)\n \n \tinfile = 0;\n \tverbose = 0;\n+\tdebug = 0;\n \n \t/* Parse the command line options. */\n \twhile ((id = jas_getopt(argc, argv, opts)) >= 0) {\n@@ -146,6 +150,9 @@ int main(int argc, char **argv)\n \t\t\tprintf(\""%s\\n\"", JAS_VERSION);\n \t\t\texit(EXIT_SUCCESS);\n \t\t\tbreak;\n+\t\tcase OPT_DEBUG:\n+\t\t\tdebug = atoi(jas_optarg);\n+\t\t\tbreak;\n \t\tcase OPT_INFILE:\n \t\t\tinfile = jas_optarg;\n \t\t\tbreak;\n@@ -156,6 +163,8 @@ int main(int argc, char **argv)\n \t\t}\n \t}\n \n+\tjas_setdbglevel(debug);\n+\n \t/* Open the image file. */\n \tif (infile) {\n \t\t/* The image is to be read from a file. */\n@@ -177,6 +186,7 @@ int main(int argc, char **argv)\n \n \t/* Decode the image. */\n \tif (!(image = jas_image_decode(instream, fmtid, 0))) {\n+\t\tjas_stream_close(instream);\n \t\tfprintf(stderr, \""cannot load image\\n\"");\n \t\treturn EXIT_FAILURE;\n \t}""}<_**next**_>{""sha"": ""6e7d8802cc7b88b7d02f6686c4c22fd131e2bea0"", ""filename"": ""src/libjasper/bmp/bmp_dec.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 1, ""changes"": 13, ""blob_url"": ""https://github.com/mdadams/jasper/blob/8f62b4761711d036fd8964df256b938c809b7fca/src/libjasper/bmp/bmp_dec.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/8f62b4761711d036fd8964df256b938c809b7fca/src/libjasper/bmp/bmp_dec.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/bmp/bmp_dec.c?ref=8f62b4761711d036fd8964df256b938c809b7fca"", ""patch"": ""@@ -77,6 +77,7 @@\n #include \""jasper/jas_stream.h\""\n #include \""jasper/jas_image.h\""\n #include \""jasper/jas_malloc.h\""\n+#include \""jasper/jas_debug.h\""\n \n #include \""bmp_cod.h\""\n \n@@ -122,12 +123,22 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \t\tjas_eprintf(\""cannot get header\\n\"");\n \t\treturn 0;\n \t}\n+\tJAS_DBGLOG(1, (\n+\t  \""BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\"",\n+\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n+\t  ));\n \n \t/* Read the bitmap information. */\n \tif (!(info = bmp_getinfo(in))) {\n \t\tjas_eprintf(\""cannot get info\\n\"");\n \t\treturn 0;\n \t}\n+\tJAS_DBGLOG(1,\n+\t  (\""BMP information: len %d; width %d; height %d; numplanes %d; \""\n+\t  \""depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \""\n+\t  \""mincolors %d\\n\"", info->len, info->width, info->height, info->numplanes,\n+\t  info->depth, info->enctype, info->siz, info->hres, info->vres,\n+\t  info->numcolors, info->mincolors));\n \n \t/* Ensure that we support this type of BMP file. */\n \tif (!bmp_issupported(&hdr, info)) {\n@@ -440,7 +451,7 @@ static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)\n \t\tif ((c = jas_stream_getc(in)) == EOF) {\n \t\t\treturn -1;\n \t\t}\n-\t\tv |= (c << 24);\n+\t\tv |= (JAS_CAST(uint_fast32_t, c) << 24);\n \t\tif (--n <= 0) {\n \t\t\tbreak;\n \t\t}""}","int main(int argc, char **argv)
{
	int fmtid;
	int id;
	char *infile;
	jas_stream_t *instream;
	jas_image_t *image;
	int width;
	int height;
	int depth;
 	int numcmpts;
 	int verbose;
 	char *fmtname;
	int debug;
 
 	if (jas_init()) {
 		abort();
	}

	cmdname = argv[0];
 
 	infile = 0;
 	verbose = 0;
	debug = 0;
 
 	/* Parse the command line options. */
 	while ((id = jas_getopt(argc, argv, opts)) >= 0) {
		switch (id) {
		case OPT_VERBOSE:
			verbose = 1;
			break;
		case OPT_VERSION:
 			printf(""%s\n"", JAS_VERSION);
 			exit(EXIT_SUCCESS);
 			break;
		case OPT_DEBUG:
			debug = atoi(jas_optarg);
			break;
 		case OPT_INFILE:
 			infile = jas_optarg;
 			break;
		case OPT_HELP:
		default:
			usage();
			break;
 		}
 	}
 
	jas_setdbglevel(debug);

 	/* Open the image file. */
 	if (infile) {
 		/* The image is to be read from a file. */
		if (!(instream = jas_stream_fopen(infile, ""rb""))) {
			fprintf(stderr, ""cannot open input image file %s\n"", infile);
			exit(EXIT_FAILURE);
		}
	} else {
		/* The image is to be read from standard input. */
		if (!(instream = jas_stream_fdopen(0, ""rb""))) {
			fprintf(stderr, ""cannot open standard input\n"");
			exit(EXIT_FAILURE);
		}
	}

	if ((fmtid = jas_image_getfmt(instream)) < 0) {
		fprintf(stderr, ""unknown image format\n"");
	}
 
 	/* Decode the image. */
 	if (!(image = jas_image_decode(instream, fmtid, 0))) {
		jas_stream_close(instream);
 		fprintf(stderr, ""cannot load image\n"");
 		return EXIT_FAILURE;
 	}

	/* Close the image file. */
	jas_stream_close(instream);

	numcmpts = jas_image_numcmpts(image);
	width = jas_image_cmptwidth(image, 0);
	height = jas_image_cmptheight(image, 0);
	depth = jas_image_cmptprec(image, 0);
	if (!(fmtname = jas_image_fmttostr(fmtid))) {
		abort();
	}
	printf(""%s %d %d %d %d %ld\n"", fmtname, numcmpts, width, height, depth, (long) jas_image_rawsize(image));

	jas_image_destroy(image);
	jas_image_clearfmts();

	return EXIT_SUCCESS;
}
","int main(int argc, char **argv)
{
	int fmtid;
	int id;
	char *infile;
	jas_stream_t *instream;
	jas_image_t *image;
	int width;
	int height;
	int depth;
 	int numcmpts;
 	int verbose;
 	char *fmtname;
 
 	if (jas_init()) {
 		abort();
	}

	cmdname = argv[0];
 
 	infile = 0;
 	verbose = 0;
 
 	/* Parse the command line options. */
 	while ((id = jas_getopt(argc, argv, opts)) >= 0) {
		switch (id) {
		case OPT_VERBOSE:
			verbose = 1;
			break;
		case OPT_VERSION:
 			printf(""%s\n"", JAS_VERSION);
 			exit(EXIT_SUCCESS);
 			break;
 		case OPT_INFILE:
 			infile = jas_optarg;
 			break;
		case OPT_HELP:
		default:
			usage();
			break;
 		}
 	}
 
 	/* Open the image file. */
 	if (infile) {
 		/* The image is to be read from a file. */
		if (!(instream = jas_stream_fopen(infile, ""rb""))) {
			fprintf(stderr, ""cannot open input image file %s\n"", infile);
			exit(EXIT_FAILURE);
		}
	} else {
		/* The image is to be read from standard input. */
		if (!(instream = jas_stream_fdopen(0, ""rb""))) {
			fprintf(stderr, ""cannot open standard input\n"");
			exit(EXIT_FAILURE);
		}
	}

	if ((fmtid = jas_image_getfmt(instream)) < 0) {
		fprintf(stderr, ""unknown image format\n"");
	}
 
 	/* Decode the image. */
 	if (!(image = jas_image_decode(instream, fmtid, 0))) {
 		fprintf(stderr, ""cannot load image\n"");
 		return EXIT_FAILURE;
 	}

	/* Close the image file. */
	jas_stream_close(instream);

	numcmpts = jas_image_numcmpts(image);
	width = jas_image_cmptwidth(image, 0);
	height = jas_image_cmptheight(image, 0);
	depth = jas_image_cmptprec(image, 0);
	if (!(fmtname = jas_image_fmttostr(fmtid))) {
		abort();
	}
	printf(""%s %d %d %d %d %ld\n"", fmtname, numcmpts, width, height, depth, (long) jas_image_rawsize(image));

	jas_image_destroy(image);
	jas_image_clearfmts();

	return EXIT_SUCCESS;
}
",C,"	int debug;
	debug = 0;
		case OPT_DEBUG:
			debug = atoi(jas_optarg);
			break;
	jas_setdbglevel(debug);

		jas_stream_close(instream);
",,,"@@ -85,7 +85,8 @@ typedef enum {
 	OPT_HELP,
 	OPT_VERSION,
 	OPT_VERBOSE,
-	OPT_INFILE
+	OPT_INFILE,
+	OPT_DEBUG
 } optid_t;
 
 /******************************************************************************\
@@ -104,6 +105,7 @@ static jas_opt_t opts[] = {
 	{OPT_VERSION, ""version"", 0},
 	{OPT_VERBOSE, ""verbose"", 0},
 	{OPT_INFILE, ""f"", JAS_OPT_HASARG},
+	{OPT_DEBUG, ""debug-level"", JAS_OPT_HASARG},
 	{-1, 0, 0}
 };
 
@@ -126,6 +128,7 @@ int main(int argc, char **argv)
 	int numcmpts;
 	int verbose;
 	char *fmtname;
+	int debug;
 
 	if (jas_init()) {
 		abort();
@@ -135,6 +138,7 @@ int main(int argc, char **argv)
 
 	infile = 0;
 	verbose = 0;
+	debug = 0;
 
 	/* Parse the command line options. */
 	while ((id = jas_getopt(argc, argv, opts)) >= 0) {
@@ -146,6 +150,9 @@ int main(int argc, char **argv)
 			printf(""%s\n"", JAS_VERSION);
 			exit(EXIT_SUCCESS);
 			break;
+		case OPT_DEBUG:
+			debug = atoi(jas_optarg);
+			break;
 		case OPT_INFILE:
 			infile = jas_optarg;
 			break;
@@ -156,6 +163,8 @@ int main(int argc, char **argv)
 		}
 	}
 
+	jas_setdbglevel(debug);
+
 	/* Open the image file. */
 	if (infile) {
 		/* The image is to be read from a file. */
@@ -177,6 +186,7 @@ int main(int argc, char **argv)
 
 	/* Decode the image. */
 	if (!(image = jas_image_decode(instream, fmtid, 0))) {
+		jas_stream_close(instream);
 		fprintf(stderr, ""cannot load image\n"");
 		return EXIT_FAILURE;
 	}",jasper,8f62b4761711d036fd8964df256b938c809b7fca,4549e056f82d182a51e30ab93c30aa5f9ce72b2f,1,"int main(int argc, char **argv)
{
	int fmtid;
	int id;
	char *infile;
	jas_stream_t *instream;
	jas_image_t *image;
	int width;
	int height;
	int depth;
 	int numcmpts;
 	int verbose;
 	char *fmtname;
//fix_flaw_line_below:
//	int debug;
 
 	if (jas_init()) {
 		abort();
	}

	cmdname = argv[0];
 
 	infile = 0;
 	verbose = 0;
//fix_flaw_line_below:
//	debug = 0;
 
 	/* Parse the command line options. */
 	while ((id = jas_getopt(argc, argv, opts)) >= 0) {
		switch (id) {
		case OPT_VERBOSE:
			verbose = 1;
			break;
		case OPT_VERSION:
 			printf(""%s\n"", JAS_VERSION);
 			exit(EXIT_SUCCESS);
 			break;
//fix_flaw_line_below:
//		case OPT_DEBUG:
//fix_flaw_line_below:
//			debug = atoi(jas_optarg);
//fix_flaw_line_below:
//			break;
 		case OPT_INFILE:
 			infile = jas_optarg;
 			break;
		case OPT_HELP:
		default:
			usage();
			break;
 		}
 	}
 
//fix_flaw_line_below:
//	jas_setdbglevel(debug);
//fix_flaw_line_below:
//
 	/* Open the image file. */
 	if (infile) {
 		/* The image is to be read from a file. */
		if (!(instream = jas_stream_fopen(infile, ""rb""))) {
			fprintf(stderr, ""cannot open input image file %s\n"", infile);
			exit(EXIT_FAILURE);
		}
	} else {
		/* The image is to be read from standard input. */
		if (!(instream = jas_stream_fdopen(0, ""rb""))) {
			fprintf(stderr, ""cannot open standard input\n"");
			exit(EXIT_FAILURE);
		}
	}

	if ((fmtid = jas_image_getfmt(instream)) < 0) {
		fprintf(stderr, ""unknown image format\n"");
	}
 
 	/* Decode the image. */
 	if (!(image = jas_image_decode(instream, fmtid, 0))) {
//fix_flaw_line_below:
//		jas_stream_close(instream);
 		fprintf(stderr, ""cannot load image\n"");
 		return EXIT_FAILURE;
 	}

	/* Close the image file. */
	jas_stream_close(instream);

	numcmpts = jas_image_numcmpts(image);
	width = jas_image_cmptwidth(image, 0);
	height = jas_image_cmptheight(image, 0);
	depth = jas_image_cmptprec(image, 0);
	if (!(fmtname = jas_image_fmttostr(fmtid))) {
		abort();
	}
	printf(""%s %d %d %d %d %ld\n"", fmtname, numcmpts, width, height, depth, (long) jas_image_rawsize(image));

	jas_image_destroy(image);
	jas_image_clearfmts();

	return EXIT_SUCCESS;
}
"
4198,181934,,Remote,Not required,Partial,CVE-2016-8690,https://www.cvedetails.com/cve/CVE-2016-8690/,CWE-476,Medium,,,,2017-02-15,4.3,The bmp_getdata function in libjasper/bmp/bmp_dec.c in JasPer before 1.900.5 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted BMP image in an imginfo command.,2018-11-22,DoS ,10,https://github.com/mdadams/jasper/commit/8f62b4761711d036fd8964df256b938c809b7fca,8f62b4761711d036fd8964df256b938c809b7fca,"Fixed a sanitizer failure in the BMP codec.
Also, added a --debug-level command line option to the imginfo command
for debugging purposes.",0,src/libjasper/bmp/bmp_dec.c,"{""sha"": ""f458a9770e5554e0128f8794ecbeeb0dd37ba158"", ""filename"": ""src/appl/imginfo.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 1, ""changes"": 12, ""blob_url"": ""https://github.com/mdadams/jasper/blob/8f62b4761711d036fd8964df256b938c809b7fca/src/appl/imginfo.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/8f62b4761711d036fd8964df256b938c809b7fca/src/appl/imginfo.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/appl/imginfo.c?ref=8f62b4761711d036fd8964df256b938c809b7fca"", ""patch"": ""@@ -85,7 +85,8 @@ typedef enum {\n \tOPT_HELP,\n \tOPT_VERSION,\n \tOPT_VERBOSE,\n-\tOPT_INFILE\n+\tOPT_INFILE,\n+\tOPT_DEBUG\n } optid_t;\n \n /******************************************************************************\\\n@@ -104,6 +105,7 @@ static jas_opt_t opts[] = {\n \t{OPT_VERSION, \""version\"", 0},\n \t{OPT_VERBOSE, \""verbose\"", 0},\n \t{OPT_INFILE, \""f\"", JAS_OPT_HASARG},\n+\t{OPT_DEBUG, \""debug-level\"", JAS_OPT_HASARG},\n \t{-1, 0, 0}\n };\n \n@@ -126,6 +128,7 @@ int main(int argc, char **argv)\n \tint numcmpts;\n \tint verbose;\n \tchar *fmtname;\n+\tint debug;\n \n \tif (jas_init()) {\n \t\tabort();\n@@ -135,6 +138,7 @@ int main(int argc, char **argv)\n \n \tinfile = 0;\n \tverbose = 0;\n+\tdebug = 0;\n \n \t/* Parse the command line options. */\n \twhile ((id = jas_getopt(argc, argv, opts)) >= 0) {\n@@ -146,6 +150,9 @@ int main(int argc, char **argv)\n \t\t\tprintf(\""%s\\n\"", JAS_VERSION);\n \t\t\texit(EXIT_SUCCESS);\n \t\t\tbreak;\n+\t\tcase OPT_DEBUG:\n+\t\t\tdebug = atoi(jas_optarg);\n+\t\t\tbreak;\n \t\tcase OPT_INFILE:\n \t\t\tinfile = jas_optarg;\n \t\t\tbreak;\n@@ -156,6 +163,8 @@ int main(int argc, char **argv)\n \t\t}\n \t}\n \n+\tjas_setdbglevel(debug);\n+\n \t/* Open the image file. */\n \tif (infile) {\n \t\t/* The image is to be read from a file. */\n@@ -177,6 +186,7 @@ int main(int argc, char **argv)\n \n \t/* Decode the image. */\n \tif (!(image = jas_image_decode(instream, fmtid, 0))) {\n+\t\tjas_stream_close(instream);\n \t\tfprintf(stderr, \""cannot load image\\n\"");\n \t\treturn EXIT_FAILURE;\n \t}""}<_**next**_>{""sha"": ""6e7d8802cc7b88b7d02f6686c4c22fd131e2bea0"", ""filename"": ""src/libjasper/bmp/bmp_dec.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 1, ""changes"": 13, ""blob_url"": ""https://github.com/mdadams/jasper/blob/8f62b4761711d036fd8964df256b938c809b7fca/src/libjasper/bmp/bmp_dec.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/8f62b4761711d036fd8964df256b938c809b7fca/src/libjasper/bmp/bmp_dec.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/bmp/bmp_dec.c?ref=8f62b4761711d036fd8964df256b938c809b7fca"", ""patch"": ""@@ -77,6 +77,7 @@\n #include \""jasper/jas_stream.h\""\n #include \""jasper/jas_image.h\""\n #include \""jasper/jas_malloc.h\""\n+#include \""jasper/jas_debug.h\""\n \n #include \""bmp_cod.h\""\n \n@@ -122,12 +123,22 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \t\tjas_eprintf(\""cannot get header\\n\"");\n \t\treturn 0;\n \t}\n+\tJAS_DBGLOG(1, (\n+\t  \""BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\"",\n+\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n+\t  ));\n \n \t/* Read the bitmap information. */\n \tif (!(info = bmp_getinfo(in))) {\n \t\tjas_eprintf(\""cannot get info\\n\"");\n \t\treturn 0;\n \t}\n+\tJAS_DBGLOG(1,\n+\t  (\""BMP information: len %d; width %d; height %d; numplanes %d; \""\n+\t  \""depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \""\n+\t  \""mincolors %d\\n\"", info->len, info->width, info->height, info->numplanes,\n+\t  info->depth, info->enctype, info->siz, info->hres, info->vres,\n+\t  info->numcolors, info->mincolors));\n \n \t/* Ensure that we support this type of BMP file. */\n \tif (!bmp_issupported(&hdr, info)) {\n@@ -440,7 +451,7 @@ static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)\n \t\tif ((c = jas_stream_getc(in)) == EOF) {\n \t\t\treturn -1;\n \t\t}\n-\t\tv |= (c << 24);\n+\t\tv |= (JAS_CAST(uint_fast32_t, c) << 24);\n \t\tif (--n <= 0) {\n \t\t\tbreak;\n \t\t}""}","jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)
{
	jas_image_t *image;
	bmp_hdr_t hdr;
	bmp_info_t *info;
	uint_fast16_t cmptno;
	jas_image_cmptparm_t cmptparms[3];
	jas_image_cmptparm_t *cmptparm;
	uint_fast16_t numcmpts;
	long n;

	if (optstr) {
		jas_eprintf(""warning: ignoring BMP decoder options\n"");
	}

	jas_eprintf(
	  ""THE BMP FORMAT IS NOT FULLY SUPPORTED!\n""
	  ""THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\n""
	  ""IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\n""
	  ""TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\n""
	  );

	/* Read the bitmap header. */
	if (bmp_gethdr(in, &hdr)) {
 		jas_eprintf(""cannot get header\n"");
 		return 0;
 	}
	JAS_DBGLOG(1, (
	  ""BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\n"",
	  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off
	  ));
 
 	/* Read the bitmap information. */
 	if (!(info = bmp_getinfo(in))) {
 		jas_eprintf(""cannot get info\n"");
 		return 0;
 	}
	JAS_DBGLOG(1,
	  (""BMP information: len %d; width %d; height %d; numplanes %d; ""
	  ""depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; ""
	  ""mincolors %d\n"", info->len, info->width, info->height, info->numplanes,
	  info->depth, info->enctype, info->siz, info->hres, info->vres,
	  info->numcolors, info->mincolors));
 
 	/* Ensure that we support this type of BMP file. */
 	if (!bmp_issupported(&hdr, info)) {
		jas_eprintf(""error: unsupported BMP encoding\n"");
		bmp_info_destroy(info);
		return 0;
	}

	/* Skip over any useless data between the end of the palette
	  and start of the bitmap data. */
	if ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {
		jas_eprintf(""error: possibly bad bitmap offset?\n"");
		return 0;
	}
	if (n > 0) {
		jas_eprintf(""skipping unknown data in BMP file\n"");
		if (bmp_gobble(in, n)) {
			bmp_info_destroy(info);
			return 0;
		}
	}

	/* Get the number of components. */
	numcmpts = bmp_numcmpts(info);

	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
	  ++cmptparm) {
		cmptparm->tlx = 0;
		cmptparm->tly = 0;
		cmptparm->hstep = 1;
		cmptparm->vstep = 1;
		cmptparm->width = info->width;
		cmptparm->height = info->height;
		cmptparm->prec = 8;
		cmptparm->sgnd = false;
	}

	/* Create image object. */
	if (!(image = jas_image_create(numcmpts, cmptparms,
	  JAS_CLRSPC_UNKNOWN))) {
		bmp_info_destroy(info);
		return 0;
	}

	if (numcmpts == 3) {
		jas_image_setclrspc(image, JAS_CLRSPC_SRGB);
		jas_image_setcmpttype(image, 0,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));
		jas_image_setcmpttype(image, 1,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));
		jas_image_setcmpttype(image, 2,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));
	} else {
		jas_image_setclrspc(image, JAS_CLRSPC_SGRAY);
		jas_image_setcmpttype(image, 0,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));
	}

	/* Read the bitmap data. */
	if (bmp_getdata(in, info, image)) {
		bmp_info_destroy(info);
		jas_image_destroy(image);
		return 0;
	}

	bmp_info_destroy(info);

	return image;
}
","jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)
{
	jas_image_t *image;
	bmp_hdr_t hdr;
	bmp_info_t *info;
	uint_fast16_t cmptno;
	jas_image_cmptparm_t cmptparms[3];
	jas_image_cmptparm_t *cmptparm;
	uint_fast16_t numcmpts;
	long n;

	if (optstr) {
		jas_eprintf(""warning: ignoring BMP decoder options\n"");
	}

	jas_eprintf(
	  ""THE BMP FORMAT IS NOT FULLY SUPPORTED!\n""
	  ""THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\n""
	  ""IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\n""
	  ""TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\n""
	  );

	/* Read the bitmap header. */
	if (bmp_gethdr(in, &hdr)) {
 		jas_eprintf(""cannot get header\n"");
 		return 0;
 	}
 
 	/* Read the bitmap information. */
 	if (!(info = bmp_getinfo(in))) {
 		jas_eprintf(""cannot get info\n"");
 		return 0;
 	}
 
 	/* Ensure that we support this type of BMP file. */
 	if (!bmp_issupported(&hdr, info)) {
		jas_eprintf(""error: unsupported BMP encoding\n"");
		bmp_info_destroy(info);
		return 0;
	}

	/* Skip over any useless data between the end of the palette
	  and start of the bitmap data. */
	if ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {
		jas_eprintf(""error: possibly bad bitmap offset?\n"");
		return 0;
	}
	if (n > 0) {
		jas_eprintf(""skipping unknown data in BMP file\n"");
		if (bmp_gobble(in, n)) {
			bmp_info_destroy(info);
			return 0;
		}
	}

	/* Get the number of components. */
	numcmpts = bmp_numcmpts(info);

	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
	  ++cmptparm) {
		cmptparm->tlx = 0;
		cmptparm->tly = 0;
		cmptparm->hstep = 1;
		cmptparm->vstep = 1;
		cmptparm->width = info->width;
		cmptparm->height = info->height;
		cmptparm->prec = 8;
		cmptparm->sgnd = false;
	}

	/* Create image object. */
	if (!(image = jas_image_create(numcmpts, cmptparms,
	  JAS_CLRSPC_UNKNOWN))) {
		bmp_info_destroy(info);
		return 0;
	}

	if (numcmpts == 3) {
		jas_image_setclrspc(image, JAS_CLRSPC_SRGB);
		jas_image_setcmpttype(image, 0,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));
		jas_image_setcmpttype(image, 1,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));
		jas_image_setcmpttype(image, 2,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));
	} else {
		jas_image_setclrspc(image, JAS_CLRSPC_SGRAY);
		jas_image_setcmpttype(image, 0,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));
	}

	/* Read the bitmap data. */
	if (bmp_getdata(in, info, image)) {
		bmp_info_destroy(info);
		jas_image_destroy(image);
		return 0;
	}

	bmp_info_destroy(info);

	return image;
}
",C,"	JAS_DBGLOG(1, (
	  ""BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\n"",
	  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off
	  ));
	JAS_DBGLOG(1,
	  (""BMP information: len %d; width %d; height %d; numplanes %d; ""
	  ""depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; ""
	  ""mincolors %d\n"", info->len, info->width, info->height, info->numplanes,
	  info->depth, info->enctype, info->siz, info->hres, info->vres,
	  info->numcolors, info->mincolors));
",,,"@@ -77,6 +77,7 @@
 #include ""jasper/jas_stream.h""
 #include ""jasper/jas_image.h""
 #include ""jasper/jas_malloc.h""
+#include ""jasper/jas_debug.h""
 
 #include ""bmp_cod.h""
 
@@ -122,12 +123,22 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)
 		jas_eprintf(""cannot get header\n"");
 		return 0;
 	}
+	JAS_DBGLOG(1, (
+	  ""BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\n"",
+	  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off
+	  ));
 
 	/* Read the bitmap information. */
 	if (!(info = bmp_getinfo(in))) {
 		jas_eprintf(""cannot get info\n"");
 		return 0;
 	}
+	JAS_DBGLOG(1,
+	  (""BMP information: len %d; width %d; height %d; numplanes %d; ""
+	  ""depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; ""
+	  ""mincolors %d\n"", info->len, info->width, info->height, info->numplanes,
+	  info->depth, info->enctype, info->siz, info->hres, info->vres,
+	  info->numcolors, info->mincolors));
 
 	/* Ensure that we support this type of BMP file. */
 	if (!bmp_issupported(&hdr, info)) {
@@ -440,7 +451,7 @@ static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)
 		if ((c = jas_stream_getc(in)) == EOF) {
 			return -1;
 		}
-		v |= (c << 24);
+		v |= (JAS_CAST(uint_fast32_t, c) << 24);
 		if (--n <= 0) {
 			break;
 		}",jasper,8f62b4761711d036fd8964df256b938c809b7fca,4549e056f82d182a51e30ab93c30aa5f9ce72b2f,1,"jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)
{
	jas_image_t *image;
	bmp_hdr_t hdr;
	bmp_info_t *info;
	uint_fast16_t cmptno;
	jas_image_cmptparm_t cmptparms[3];
	jas_image_cmptparm_t *cmptparm;
	uint_fast16_t numcmpts;
	long n;

	if (optstr) {
		jas_eprintf(""warning: ignoring BMP decoder options\n"");
	}

	jas_eprintf(
	  ""THE BMP FORMAT IS NOT FULLY SUPPORTED!\n""
	  ""THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\n""
	  ""IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\n""
	  ""TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\n""
	  );

	/* Read the bitmap header. */
	if (bmp_gethdr(in, &hdr)) {
 		jas_eprintf(""cannot get header\n"");
 		return 0;
 	}
//fix_flaw_line_below:
//	JAS_DBGLOG(1, (
//fix_flaw_line_below:
//	  ""BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\n"",
//fix_flaw_line_below:
//	  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off
//fix_flaw_line_below:
//	  ));
 
 	/* Read the bitmap information. */
 	if (!(info = bmp_getinfo(in))) {
 		jas_eprintf(""cannot get info\n"");
 		return 0;
 	}
//fix_flaw_line_below:
//	JAS_DBGLOG(1,
//fix_flaw_line_below:
//	  (""BMP information: len %d; width %d; height %d; numplanes %d; ""
//fix_flaw_line_below:
//	  ""depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; ""
//fix_flaw_line_below:
//	  ""mincolors %d\n"", info->len, info->width, info->height, info->numplanes,
//fix_flaw_line_below:
//	  info->depth, info->enctype, info->siz, info->hres, info->vres,
//fix_flaw_line_below:
//	  info->numcolors, info->mincolors));
 
 	/* Ensure that we support this type of BMP file. */
 	if (!bmp_issupported(&hdr, info)) {
		jas_eprintf(""error: unsupported BMP encoding\n"");
		bmp_info_destroy(info);
		return 0;
	}

	/* Skip over any useless data between the end of the palette
	  and start of the bitmap data. */
	if ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {
		jas_eprintf(""error: possibly bad bitmap offset?\n"");
		return 0;
	}
	if (n > 0) {
		jas_eprintf(""skipping unknown data in BMP file\n"");
		if (bmp_gobble(in, n)) {
			bmp_info_destroy(info);
			return 0;
		}
	}

	/* Get the number of components. */
	numcmpts = bmp_numcmpts(info);

	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
	  ++cmptparm) {
		cmptparm->tlx = 0;
		cmptparm->tly = 0;
		cmptparm->hstep = 1;
		cmptparm->vstep = 1;
		cmptparm->width = info->width;
		cmptparm->height = info->height;
		cmptparm->prec = 8;
		cmptparm->sgnd = false;
	}

	/* Create image object. */
	if (!(image = jas_image_create(numcmpts, cmptparms,
	  JAS_CLRSPC_UNKNOWN))) {
		bmp_info_destroy(info);
		return 0;
	}

	if (numcmpts == 3) {
		jas_image_setclrspc(image, JAS_CLRSPC_SRGB);
		jas_image_setcmpttype(image, 0,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));
		jas_image_setcmpttype(image, 1,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));
		jas_image_setcmpttype(image, 2,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));
	} else {
		jas_image_setclrspc(image, JAS_CLRSPC_SGRAY);
		jas_image_setcmpttype(image, 0,
		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));
	}

	/* Read the bitmap data. */
	if (bmp_getdata(in, info, image)) {
		bmp_info_destroy(info);
		jas_image_destroy(image);
		return 0;
	}

	bmp_info_destroy(info);

	return image;
}
"
4199,181935,,Remote,Not required,Partial,CVE-2016-8690,https://www.cvedetails.com/cve/CVE-2016-8690/,CWE-476,Medium,,,,2017-02-15,4.3,The bmp_getdata function in libjasper/bmp/bmp_dec.c in JasPer before 1.900.5 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted BMP image in an imginfo command.,2018-11-22,DoS ,1,https://github.com/mdadams/jasper/commit/8f62b4761711d036fd8964df256b938c809b7fca,8f62b4761711d036fd8964df256b938c809b7fca,"Fixed a sanitizer failure in the BMP codec.
Also, added a --debug-level command line option to the imginfo command
for debugging purposes.",1,src/libjasper/bmp/bmp_dec.c,"{""sha"": ""f458a9770e5554e0128f8794ecbeeb0dd37ba158"", ""filename"": ""src/appl/imginfo.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 1, ""changes"": 12, ""blob_url"": ""https://github.com/mdadams/jasper/blob/8f62b4761711d036fd8964df256b938c809b7fca/src/appl/imginfo.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/8f62b4761711d036fd8964df256b938c809b7fca/src/appl/imginfo.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/appl/imginfo.c?ref=8f62b4761711d036fd8964df256b938c809b7fca"", ""patch"": ""@@ -85,7 +85,8 @@ typedef enum {\n \tOPT_HELP,\n \tOPT_VERSION,\n \tOPT_VERBOSE,\n-\tOPT_INFILE\n+\tOPT_INFILE,\n+\tOPT_DEBUG\n } optid_t;\n \n /******************************************************************************\\\n@@ -104,6 +105,7 @@ static jas_opt_t opts[] = {\n \t{OPT_VERSION, \""version\"", 0},\n \t{OPT_VERBOSE, \""verbose\"", 0},\n \t{OPT_INFILE, \""f\"", JAS_OPT_HASARG},\n+\t{OPT_DEBUG, \""debug-level\"", JAS_OPT_HASARG},\n \t{-1, 0, 0}\n };\n \n@@ -126,6 +128,7 @@ int main(int argc, char **argv)\n \tint numcmpts;\n \tint verbose;\n \tchar *fmtname;\n+\tint debug;\n \n \tif (jas_init()) {\n \t\tabort();\n@@ -135,6 +138,7 @@ int main(int argc, char **argv)\n \n \tinfile = 0;\n \tverbose = 0;\n+\tdebug = 0;\n \n \t/* Parse the command line options. */\n \twhile ((id = jas_getopt(argc, argv, opts)) >= 0) {\n@@ -146,6 +150,9 @@ int main(int argc, char **argv)\n \t\t\tprintf(\""%s\\n\"", JAS_VERSION);\n \t\t\texit(EXIT_SUCCESS);\n \t\t\tbreak;\n+\t\tcase OPT_DEBUG:\n+\t\t\tdebug = atoi(jas_optarg);\n+\t\t\tbreak;\n \t\tcase OPT_INFILE:\n \t\t\tinfile = jas_optarg;\n \t\t\tbreak;\n@@ -156,6 +163,8 @@ int main(int argc, char **argv)\n \t\t}\n \t}\n \n+\tjas_setdbglevel(debug);\n+\n \t/* Open the image file. */\n \tif (infile) {\n \t\t/* The image is to be read from a file. */\n@@ -177,6 +186,7 @@ int main(int argc, char **argv)\n \n \t/* Decode the image. */\n \tif (!(image = jas_image_decode(instream, fmtid, 0))) {\n+\t\tjas_stream_close(instream);\n \t\tfprintf(stderr, \""cannot load image\\n\"");\n \t\treturn EXIT_FAILURE;\n \t}""}<_**next**_>{""sha"": ""6e7d8802cc7b88b7d02f6686c4c22fd131e2bea0"", ""filename"": ""src/libjasper/bmp/bmp_dec.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 1, ""changes"": 13, ""blob_url"": ""https://github.com/mdadams/jasper/blob/8f62b4761711d036fd8964df256b938c809b7fca/src/libjasper/bmp/bmp_dec.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/8f62b4761711d036fd8964df256b938c809b7fca/src/libjasper/bmp/bmp_dec.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/bmp/bmp_dec.c?ref=8f62b4761711d036fd8964df256b938c809b7fca"", ""patch"": ""@@ -77,6 +77,7 @@\n #include \""jasper/jas_stream.h\""\n #include \""jasper/jas_image.h\""\n #include \""jasper/jas_malloc.h\""\n+#include \""jasper/jas_debug.h\""\n \n #include \""bmp_cod.h\""\n \n@@ -122,12 +123,22 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \t\tjas_eprintf(\""cannot get header\\n\"");\n \t\treturn 0;\n \t}\n+\tJAS_DBGLOG(1, (\n+\t  \""BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\"",\n+\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n+\t  ));\n \n \t/* Read the bitmap information. */\n \tif (!(info = bmp_getinfo(in))) {\n \t\tjas_eprintf(\""cannot get info\\n\"");\n \t\treturn 0;\n \t}\n+\tJAS_DBGLOG(1,\n+\t  (\""BMP information: len %d; width %d; height %d; numplanes %d; \""\n+\t  \""depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \""\n+\t  \""mincolors %d\\n\"", info->len, info->width, info->height, info->numplanes,\n+\t  info->depth, info->enctype, info->siz, info->hres, info->vres,\n+\t  info->numcolors, info->mincolors));\n \n \t/* Ensure that we support this type of BMP file. */\n \tif (!bmp_issupported(&hdr, info)) {\n@@ -440,7 +451,7 @@ static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)\n \t\tif ((c = jas_stream_getc(in)) == EOF) {\n \t\t\treturn -1;\n \t\t}\n-\t\tv |= (c << 24);\n+\t\tv |= (JAS_CAST(uint_fast32_t, c) << 24);\n \t\tif (--n <= 0) {\n \t\t\tbreak;\n \t\t}""}","static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)
{
	int n;
	uint_fast32_t v;
	int c;
	for (n = 4, v = 0;;) {
 		if ((c = jas_stream_getc(in)) == EOF) {
 			return -1;
 		}
		v |= (JAS_CAST(uint_fast32_t, c) << 24);
 		if (--n <= 0) {
 			break;
 		}
		v >>= 8;
	}
	if (val) {
		*val = v;
	}
	return 0;
}
","static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)
{
	int n;
	uint_fast32_t v;
	int c;
	for (n = 4, v = 0;;) {
 		if ((c = jas_stream_getc(in)) == EOF) {
 			return -1;
 		}
		v |= (c << 24);
 		if (--n <= 0) {
 			break;
 		}
		v >>= 8;
	}
	if (val) {
		*val = v;
	}
	return 0;
}
",C,"		v |= (JAS_CAST(uint_fast32_t, c) << 24);
","		v |= (c << 24);
",,"@@ -77,6 +77,7 @@
 #include ""jasper/jas_stream.h""
 #include ""jasper/jas_image.h""
 #include ""jasper/jas_malloc.h""
+#include ""jasper/jas_debug.h""
 
 #include ""bmp_cod.h""
 
@@ -122,12 +123,22 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)
 		jas_eprintf(""cannot get header\n"");
 		return 0;
 	}
+	JAS_DBGLOG(1, (
+	  ""BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\n"",
+	  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off
+	  ));
 
 	/* Read the bitmap information. */
 	if (!(info = bmp_getinfo(in))) {
 		jas_eprintf(""cannot get info\n"");
 		return 0;
 	}
+	JAS_DBGLOG(1,
+	  (""BMP information: len %d; width %d; height %d; numplanes %d; ""
+	  ""depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; ""
+	  ""mincolors %d\n"", info->len, info->width, info->height, info->numplanes,
+	  info->depth, info->enctype, info->siz, info->hres, info->vres,
+	  info->numcolors, info->mincolors));
 
 	/* Ensure that we support this type of BMP file. */
 	if (!bmp_issupported(&hdr, info)) {
@@ -440,7 +451,7 @@ static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)
 		if ((c = jas_stream_getc(in)) == EOF) {
 			return -1;
 		}
-		v |= (c << 24);
+		v |= (JAS_CAST(uint_fast32_t, c) << 24);
 		if (--n <= 0) {
 			break;
 		}",jasper,8f62b4761711d036fd8964df256b938c809b7fca,4549e056f82d182a51e30ab93c30aa5f9ce72b2f,1,"static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)
{
	int n;
	uint_fast32_t v;
	int c;
	for (n = 4, v = 0;;) {
 		if ((c = jas_stream_getc(in)) == EOF) {
 			return -1;
 		}
//flaw_line_below:
		v |= (c << 24);
//fix_flaw_line_below:
//		v |= (JAS_CAST(uint_fast32_t, c) << 24);
 		if (--n <= 0) {
 			break;
 		}
		v >>= 8;
	}
	if (val) {
		*val = v;
	}
	return 0;
}
"
4204,181940,,Remote,Not required,Partial,CVE-2016-8675,https://www.cvedetails.com/cve/CVE-2016-8675/,CWE-476,Medium,,,,2017-02-15,4.3,"The get_vlc2 function in get_bits.h in Libav before 11.9 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) via a crafted mp3 file, possibly related to startcode sequences during m4v detection.",2017-02-17,DoS ,5,https://github.com/libav/libav/commit/e5b019725f53b79159931d3a7317107cbbfd0860,e5b019725f53b79159931d3a7317107cbbfd0860,"m4vdec: Check for non-startcode 00 00 00 sequences in probe

This makes the m4v detection less trigger-happy.

Bug-Id: 949
Signed-off-by: Diego Biurrun <diego@biurrun.de>",3,libavformat/m4vdec.c,"{""sha"": ""9d69dcc042142a93b0a61a2a41854e84a4c26b42"", ""filename"": ""libavformat/m4vdec.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 3, ""changes"": 8, ""blob_url"": ""https://github.com/libav/libav/blob/e5b019725f53b79159931d3a7317107cbbfd0860/libavformat/m4vdec.c"", ""raw_url"": ""https://github.com/libav/libav/raw/e5b019725f53b79159931d3a7317107cbbfd0860/libavformat/m4vdec.c"", ""contents_url"": ""https://api.github.com/repos/libav/libav/contents/libavformat/m4vdec.c?ref=e5b019725f53b79159931d3a7317107cbbfd0860"", ""patch"": ""@@ -33,16 +33,18 @@ static int mpeg4video_probe(AVProbeData *probe_packet)\n \n     for (i = 0; i < probe_packet->buf_size; i++) {\n         temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];\n-        if ((temp_buffer & 0xffffff00) != 0x100)\n+        if (temp_buffer & 0xfffffe00)\n+            continue;\n+        if (temp_buffer < 2)\n             continue;\n \n         if (temp_buffer == VOP_START_CODE)\n             VOP++;\n         else if (temp_buffer == VISUAL_OBJECT_START_CODE)\n             VISO++;\n-        else if (temp_buffer < 0x120)\n+        else if (temp_buffer >= 0x100 && temp_buffer < 0x120)\n             VO++;\n-        else if (temp_buffer < 0x130)\n+        else if (temp_buffer >= 0x120 && temp_buffer < 0x130)\n             VOL++;\n         else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&\n                  !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))""}","static int mpeg4video_probe(AVProbeData *probe_packet)
{
    uint32_t temp_buffer = -1;
    int VO = 0, VOL = 0, VOP = 0, VISO = 0, res = 0;
    int i;
 
     for (i = 0; i < probe_packet->buf_size; i++) {
         temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];
        if (temp_buffer & 0xfffffe00)
            continue;
        if (temp_buffer < 2)
             continue;
 
         if (temp_buffer == VOP_START_CODE)
             VOP++;
         else if (temp_buffer == VISUAL_OBJECT_START_CODE)
             VISO++;
        else if (temp_buffer >= 0x100 && temp_buffer < 0x120)
             VO++;
        else if (temp_buffer >= 0x120 && temp_buffer < 0x130)
             VOL++;
         else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&
                  !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))
            res++;
    }

    if (VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0)
        return AVPROBE_SCORE_EXTENSION;
    return 0;
}
","static int mpeg4video_probe(AVProbeData *probe_packet)
{
    uint32_t temp_buffer = -1;
    int VO = 0, VOL = 0, VOP = 0, VISO = 0, res = 0;
    int i;
 
     for (i = 0; i < probe_packet->buf_size; i++) {
         temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];
        if ((temp_buffer & 0xffffff00) != 0x100)
             continue;
 
         if (temp_buffer == VOP_START_CODE)
             VOP++;
         else if (temp_buffer == VISUAL_OBJECT_START_CODE)
             VISO++;
        else if (temp_buffer < 0x120)
             VO++;
        else if (temp_buffer < 0x130)
             VOL++;
         else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&
                  !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))
            res++;
    }

    if (VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0)
        return AVPROBE_SCORE_EXTENSION;
    return 0;
}
",C,"        if (temp_buffer & 0xfffffe00)
            continue;
        if (temp_buffer < 2)
        else if (temp_buffer >= 0x100 && temp_buffer < 0x120)
        else if (temp_buffer >= 0x120 && temp_buffer < 0x130)
","        if ((temp_buffer & 0xffffff00) != 0x100)
        else if (temp_buffer < 0x120)
        else if (temp_buffer < 0x130)
",,"@@ -33,16 +33,18 @@ static int mpeg4video_probe(AVProbeData *probe_packet)
 
     for (i = 0; i < probe_packet->buf_size; i++) {
         temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];
-        if ((temp_buffer & 0xffffff00) != 0x100)
+        if (temp_buffer & 0xfffffe00)
+            continue;
+        if (temp_buffer < 2)
             continue;
 
         if (temp_buffer == VOP_START_CODE)
             VOP++;
         else if (temp_buffer == VISUAL_OBJECT_START_CODE)
             VISO++;
-        else if (temp_buffer < 0x120)
+        else if (temp_buffer >= 0x100 && temp_buffer < 0x120)
             VO++;
-        else if (temp_buffer < 0x130)
+        else if (temp_buffer >= 0x120 && temp_buffer < 0x130)
             VOL++;
         else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&
                  !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))",libav,e5b019725f53b79159931d3a7317107cbbfd0860,3ccec334b8502701e72ef13bed25913c3578022e,1,"static int mpeg4video_probe(AVProbeData *probe_packet)
{
    uint32_t temp_buffer = -1;
    int VO = 0, VOL = 0, VOP = 0, VISO = 0, res = 0;
    int i;
 
     for (i = 0; i < probe_packet->buf_size; i++) {
         temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];
//flaw_line_below:
        if ((temp_buffer & 0xffffff00) != 0x100)
//fix_flaw_line_below:
//        if (temp_buffer & 0xfffffe00)
//fix_flaw_line_below:
//            continue;
//fix_flaw_line_below:
//        if (temp_buffer < 2)
             continue;
 
         if (temp_buffer == VOP_START_CODE)
             VOP++;
         else if (temp_buffer == VISUAL_OBJECT_START_CODE)
             VISO++;
//flaw_line_below:
        else if (temp_buffer < 0x120)
//fix_flaw_line_below:
//        else if (temp_buffer >= 0x100 && temp_buffer < 0x120)
             VO++;
//flaw_line_below:
        else if (temp_buffer < 0x130)
//fix_flaw_line_below:
//        else if (temp_buffer >= 0x120 && temp_buffer < 0x130)
             VOL++;
         else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&
                  !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))
            res++;
    }

    if (VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0)
        return AVPROBE_SCORE_EXTENSION;
    return 0;
}
"
4261,181997,,Remote,Not required,Complete,CVE-2016-6561,https://www.cvedetails.com/cve/CVE-2016-6561/,CWE-476,Low,,,,2017-03-31,7.8,illumos smbsrv NULL pointer dereference allows system crash.,2017-05-01,,1,https://github.com/illumos/illumos-gate/commit/6d1c73b5858fefc6161c7d686345f0dc887ea799,6d1c73b5858fefc6161c7d686345f0dc887ea799,"7483 SMB flush on pipe triggers NULL pointer dereference in module smbsrv
Reviewed by: Gordon Ross <gwr@nexenta.com>
Reviewed by: Matt Barden <matt.barden@nexenta.com>
Reviewed by: Evan Layton <evan.layton@nexenta.com>
Reviewed by: Dan McDonald <danmcd@omniti.com>
Approved by: Gordon Ross <gwr@nexenta.com>",8,usr/src/uts/common/fs/smbsrv/smb2_flush.c,"{""sha"": ""82263d59366b6880a932b04f7a054a273e5a2169"", ""filename"": ""usr/src/uts/common/fs/smbsrv/smb2_flush.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 8, ""changes"": 10, ""blob_url"": ""https://github.com/illumos/illumos-gate/blob/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb2_flush.c"", ""raw_url"": ""https://github.com/illumos/illumos-gate/raw/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb2_flush.c"", ""contents_url"": ""https://api.github.com/repos/illumos/illumos-gate/contents/usr/src/uts/common/fs/smbsrv/smb2_flush.c?ref=6d1c73b5858fefc6161c7d686345f0dc887ea799"", ""patch"": ""@@ -11,6 +11,7 @@\n \n /*\n  * Copyright 2014 Nexenta Systems, Inc.  All rights reserved.\n+ * Copyright 2016 Syneto S.R.L. All rights reserved.\n  */\n \n /*\n@@ -23,7 +24,6 @@\n smb_sdrc_t\n smb2_flush(smb_request_t *sr)\n {\n-\tsmb_ofile_t *of = NULL;\n \tuint16_t StructSize;\n \tuint16_t reserved1;\n \tuint32_t reserved2;\n@@ -51,14 +51,8 @@ smb2_flush(smb_request_t *sr)\n \t\tsmb2sr_put_error(sr, status);\n \t\treturn (SDRC_SUCCESS);\n \t}\n-\tof = sr->fid_ofile;\n \n-\t/*\n-\t * XXX - todo:\n-\t * Flush named pipe should drain writes.\n-\t */\n-\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n-\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n+\tsmb_ofile_flush(sr, sr->fid_ofile);\n \n \t/*\n \t * SMB2 Flush reply""}<_**next**_>{""sha"": ""1d210c3d8990d77683b7c5ca69ea67fe338c129c"", ""filename"": ""usr/src/uts/common/fs/smbsrv/smb_flush.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 21, ""changes"": 25, ""blob_url"": ""https://github.com/illumos/illumos-gate/blob/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb_flush.c"", ""raw_url"": ""https://github.com/illumos/illumos-gate/raw/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb_flush.c"", ""contents_url"": ""https://api.github.com/repos/illumos/illumos-gate/contents/usr/src/uts/common/fs/smbsrv/smb_flush.c?ref=6d1c73b5858fefc6161c7d686345f0dc887ea799"", ""patch"": ""@@ -21,6 +21,8 @@\n /*\n  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.\n  * Use is subject to license terms.\n+ *\n+ * Copyright 2016 Syneto S.R.L. All rights reserved.\n  */\n \n /*\n@@ -40,8 +42,6 @@\n #include <smbsrv/smb_fsops.h>\n \n \n-static void smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile);\n-\n /*\n  * smb_com_flush\n  *\n@@ -90,15 +90,14 @@ smb_com_flush(smb_request_t *sr)\n \t\t\t    ERRDOS, ERRbadfid);\n \t\t\treturn (SDRC_ERROR);\n \t\t}\n-\n-\t\tsmb_flush_file(sr, sr->fid_ofile);\n+\t\tsmb_ofile_flush(sr, sr->fid_ofile);\n \t} else {\n \t\tflist = &sr->tid_tree->t_ofile_list;\n \t\tsmb_llist_enter(flist, RW_READER);\n \t\tfile = smb_llist_head(flist);\n \t\twhile (file) {\n \t\t\tmutex_enter(&file->f_mutex);\n-\t\t\tsmb_flush_file(sr, file);\n+\t\t\tsmb_ofile_flush(sr, file);\n \t\t\tmutex_exit(&file->f_mutex);\n \t\t\tfile = smb_llist_next(flist, file);\n \t\t}\n@@ -108,19 +107,3 @@ smb_com_flush(smb_request_t *sr)\n \trc = smbsr_encode_empty_result(sr);\n \treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n }\n-\n-\n-/*\n- * smb_flush_file\n- *\n- * If writes on this file are not synchronous, flush it using the NFSv3\n- * commit interface.\n- */\n-static void\n-smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile)\n-{\n-\tsr->user_cr = smb_ofile_getcred(ofile);\n-\n-\tif ((ofile->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n-\t\t(void) smb_fsop_commit(sr, sr->user_cr, ofile->f_node);\n-}""}<_**next**_>{""sha"": ""582091d1dd645238651551fb71c024bddd1d27d5"", ""filename"": ""usr/src/uts/common/fs/smbsrv/smb_ofile.c"", ""status"": ""modified"", ""additions"": 22, ""deletions"": 0, ""changes"": 22, ""blob_url"": ""https://github.com/illumos/illumos-gate/blob/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb_ofile.c"", ""raw_url"": ""https://github.com/illumos/illumos-gate/raw/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb_ofile.c"", ""contents_url"": ""https://api.github.com/repos/illumos/illumos-gate/contents/usr/src/uts/common/fs/smbsrv/smb_ofile.c?ref=6d1c73b5858fefc6161c7d686345f0dc887ea799"", ""patch"": ""@@ -21,6 +21,7 @@\n /*\n  * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.\n  * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.\n+ * Copyright 2016 Syneto S.R.L. All rights reserved.\n  */\n \n /*\n@@ -836,6 +837,27 @@ smb_ofile_seek(\n \treturn (rc);\n }\n \n+/*\n+ * smb_ofile_flush\n+ *\n+ * If writes on this file are not synchronous, flush it using the NFSv3\n+ * commit interface.\n+ *\n+ * XXX - todo: Flush named pipe should drain writes.\n+ */\n+void\n+smb_ofile_flush(struct smb_request *sr, struct smb_ofile *of)\n+{\n+\tswitch (of->f_ftype) {\n+\tcase SMB_FTYPE_DISK:\n+\t\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n+\t\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n+\t\tbreak;\n+\tdefault:\n+\t\tbreak;\n+\t}\n+}\n+\n /*\n  * smb_ofile_is_open\n  */""}<_**next**_>{""sha"": ""2dd8787aebfd3af6f5a5fb3a345e26ef697b68a5"", ""filename"": ""usr/src/uts/common/smbsrv/smb_kproto.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/illumos/illumos-gate/blob/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/smbsrv/smb_kproto.h"", ""raw_url"": ""https://github.com/illumos/illumos-gate/raw/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/smbsrv/smb_kproto.h"", ""contents_url"": ""https://api.github.com/repos/illumos/illumos-gate/contents/usr/src/uts/common/smbsrv/smb_kproto.h?ref=6d1c73b5858fefc6161c7d686345f0dc887ea799"", ""patch"": ""@@ -22,6 +22,7 @@\n /*\n  * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.\n  * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.\n+ * Copyright 2016 Syneto S.R.L.  All rights reserved.\n  */\n \n /*\n@@ -673,6 +674,7 @@ void smb_ofile_close(smb_ofile_t *, int32_t);\n void smb_ofile_delete(void *);\n uint32_t smb_ofile_access(smb_ofile_t *, cred_t *, uint32_t);\n int smb_ofile_seek(smb_ofile_t *, ushort_t, int32_t, uint32_t *);\n+void smb_ofile_flush(smb_request_t *, smb_ofile_t *);\n boolean_t smb_ofile_hold(smb_ofile_t *);\n void smb_ofile_release(smb_ofile_t *);\n void smb_ofile_request_complete(smb_ofile_t *);""}"," smb2_flush(smb_request_t *sr)
 {
 	uint16_t StructSize;
 	uint16_t reserved1;
 	uint32_t reserved2;
	smb2fid_t smb2fid;
	uint32_t status;
	int rc = 0;

	/*
	 * SMB2 Flush request
	 */
	rc = smb_mbc_decodef(
	    &sr->smb_data, ""wwlqq"",
	    &StructSize,		/* w */
	    &reserved1,			/* w */
	    &reserved2,			/* l */
	    &smb2fid.persistent,	/* q */
	    &smb2fid.temporal);		/* q */
	if (rc)
		return (SDRC_ERROR);
	if (StructSize != 24)
		return (SDRC_ERROR);

	status = smb2sr_lookup_fid(sr, &smb2fid);
	if (status) {
 		smb2sr_put_error(sr, status);
 		return (SDRC_SUCCESS);
 	}
 
	smb_ofile_flush(sr, sr->fid_ofile);
 
 	/*
 	 * SMB2 Flush reply
	 */
	(void) smb_mbc_encodef(
	    &sr->reply, ""wwl"",
	    4,	/* StructSize */	/* w */
	    0); /* reserved */		/* w */

	return (SDRC_SUCCESS);
}
"," smb2_flush(smb_request_t *sr)
 {
	smb_ofile_t *of = NULL;
 	uint16_t StructSize;
 	uint16_t reserved1;
 	uint32_t reserved2;
	smb2fid_t smb2fid;
	uint32_t status;
	int rc = 0;

	/*
	 * SMB2 Flush request
	 */
	rc = smb_mbc_decodef(
	    &sr->smb_data, ""wwlqq"",
	    &StructSize,		/* w */
	    &reserved1,			/* w */
	    &reserved2,			/* l */
	    &smb2fid.persistent,	/* q */
	    &smb2fid.temporal);		/* q */
	if (rc)
		return (SDRC_ERROR);
	if (StructSize != 24)
		return (SDRC_ERROR);

	status = smb2sr_lookup_fid(sr, &smb2fid);
	if (status) {
 		smb2sr_put_error(sr, status);
 		return (SDRC_SUCCESS);
 	}
	of = sr->fid_ofile;
 
	/*
	 * XXX - todo:
	 * Flush named pipe should drain writes.
	 */
	if ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)
		(void) smb_fsop_commit(sr, of->f_cr, of->f_node);
 
 	/*
 	 * SMB2 Flush reply
	 */
	(void) smb_mbc_encodef(
	    &sr->reply, ""wwl"",
	    4,	/* StructSize */	/* w */
	    0); /* reserved */		/* w */

	return (SDRC_SUCCESS);
}
",C,"	smb_ofile_flush(sr, sr->fid_ofile);
","	smb_ofile_t *of = NULL;
	of = sr->fid_ofile;
	/*
	 * XXX - todo:
	 * Flush named pipe should drain writes.
	 */
	if ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)
		(void) smb_fsop_commit(sr, of->f_cr, of->f_node);
",,"@@ -11,6 +11,7 @@
 
 /*
  * Copyright 2014 Nexenta Systems, Inc.  All rights reserved.
+ * Copyright 2016 Syneto S.R.L. All rights reserved.
  */
 
 /*
@@ -23,7 +24,6 @@
 smb_sdrc_t
 smb2_flush(smb_request_t *sr)
 {
-	smb_ofile_t *of = NULL;
 	uint16_t StructSize;
 	uint16_t reserved1;
 	uint32_t reserved2;
@@ -51,14 +51,8 @@ smb2_flush(smb_request_t *sr)
 		smb2sr_put_error(sr, status);
 		return (SDRC_SUCCESS);
 	}
-	of = sr->fid_ofile;
 
-	/*
-	 * XXX - todo:
-	 * Flush named pipe should drain writes.
-	 */
-	if ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)
-		(void) smb_fsop_commit(sr, of->f_cr, of->f_node);
+	smb_ofile_flush(sr, sr->fid_ofile);
 
 	/*
 	 * SMB2 Flush reply",illumos-gate,6d1c73b5858fefc6161c7d686345f0dc887ea799,516627f338a630bcf9806a91aa873bbbae9a2fac,1," smb2_flush(smb_request_t *sr)
 {
//flaw_line_below:
	smb_ofile_t *of = NULL;
 	uint16_t StructSize;
 	uint16_t reserved1;
 	uint32_t reserved2;
	smb2fid_t smb2fid;
	uint32_t status;
	int rc = 0;

	/*
	 * SMB2 Flush request
	 */
	rc = smb_mbc_decodef(
	    &sr->smb_data, ""wwlqq"",
	    &StructSize,		/* w */
	    &reserved1,			/* w */
	    &reserved2,			/* l */
	    &smb2fid.persistent,	/* q */
	    &smb2fid.temporal);		/* q */
	if (rc)
		return (SDRC_ERROR);
	if (StructSize != 24)
		return (SDRC_ERROR);

	status = smb2sr_lookup_fid(sr, &smb2fid);
	if (status) {
 		smb2sr_put_error(sr, status);
 		return (SDRC_SUCCESS);
 	}
//flaw_line_below:
	of = sr->fid_ofile;
 
//flaw_line_below:
	/*
//flaw_line_below:
	 * XXX - todo:
//flaw_line_below:
	 * Flush named pipe should drain writes.
//flaw_line_below:
	 */
//flaw_line_below:
	if ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)
//flaw_line_below:
		(void) smb_fsop_commit(sr, of->f_cr, of->f_node);
//fix_flaw_line_below:
//	smb_ofile_flush(sr, sr->fid_ofile);
 
 	/*
 	 * SMB2 Flush reply
	 */
	(void) smb_mbc_encodef(
	    &sr->reply, ""wwl"",
	    4,	/* StructSize */	/* w */
	    0); /* reserved */		/* w */

	return (SDRC_SUCCESS);
}
"
4262,181998,,Remote,Not required,Complete,CVE-2016-6561,https://www.cvedetails.com/cve/CVE-2016-6561/,CWE-476,Low,,,,2017-03-31,7.8,illumos smbsrv NULL pointer dereference allows system crash.,2017-05-01,,2,https://github.com/illumos/illumos-gate/commit/6d1c73b5858fefc6161c7d686345f0dc887ea799,6d1c73b5858fefc6161c7d686345f0dc887ea799,"7483 SMB flush on pipe triggers NULL pointer dereference in module smbsrv
Reviewed by: Gordon Ross <gwr@nexenta.com>
Reviewed by: Matt Barden <matt.barden@nexenta.com>
Reviewed by: Evan Layton <evan.layton@nexenta.com>
Reviewed by: Dan McDonald <danmcd@omniti.com>
Approved by: Gordon Ross <gwr@nexenta.com>",2,usr/src/uts/common/fs/smbsrv/smb_flush.c,"{""sha"": ""82263d59366b6880a932b04f7a054a273e5a2169"", ""filename"": ""usr/src/uts/common/fs/smbsrv/smb2_flush.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 8, ""changes"": 10, ""blob_url"": ""https://github.com/illumos/illumos-gate/blob/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb2_flush.c"", ""raw_url"": ""https://github.com/illumos/illumos-gate/raw/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb2_flush.c"", ""contents_url"": ""https://api.github.com/repos/illumos/illumos-gate/contents/usr/src/uts/common/fs/smbsrv/smb2_flush.c?ref=6d1c73b5858fefc6161c7d686345f0dc887ea799"", ""patch"": ""@@ -11,6 +11,7 @@\n \n /*\n  * Copyright 2014 Nexenta Systems, Inc.  All rights reserved.\n+ * Copyright 2016 Syneto S.R.L. All rights reserved.\n  */\n \n /*\n@@ -23,7 +24,6 @@\n smb_sdrc_t\n smb2_flush(smb_request_t *sr)\n {\n-\tsmb_ofile_t *of = NULL;\n \tuint16_t StructSize;\n \tuint16_t reserved1;\n \tuint32_t reserved2;\n@@ -51,14 +51,8 @@ smb2_flush(smb_request_t *sr)\n \t\tsmb2sr_put_error(sr, status);\n \t\treturn (SDRC_SUCCESS);\n \t}\n-\tof = sr->fid_ofile;\n \n-\t/*\n-\t * XXX - todo:\n-\t * Flush named pipe should drain writes.\n-\t */\n-\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n-\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n+\tsmb_ofile_flush(sr, sr->fid_ofile);\n \n \t/*\n \t * SMB2 Flush reply""}<_**next**_>{""sha"": ""1d210c3d8990d77683b7c5ca69ea67fe338c129c"", ""filename"": ""usr/src/uts/common/fs/smbsrv/smb_flush.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 21, ""changes"": 25, ""blob_url"": ""https://github.com/illumos/illumos-gate/blob/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb_flush.c"", ""raw_url"": ""https://github.com/illumos/illumos-gate/raw/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb_flush.c"", ""contents_url"": ""https://api.github.com/repos/illumos/illumos-gate/contents/usr/src/uts/common/fs/smbsrv/smb_flush.c?ref=6d1c73b5858fefc6161c7d686345f0dc887ea799"", ""patch"": ""@@ -21,6 +21,8 @@\n /*\n  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.\n  * Use is subject to license terms.\n+ *\n+ * Copyright 2016 Syneto S.R.L. All rights reserved.\n  */\n \n /*\n@@ -40,8 +42,6 @@\n #include <smbsrv/smb_fsops.h>\n \n \n-static void smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile);\n-\n /*\n  * smb_com_flush\n  *\n@@ -90,15 +90,14 @@ smb_com_flush(smb_request_t *sr)\n \t\t\t    ERRDOS, ERRbadfid);\n \t\t\treturn (SDRC_ERROR);\n \t\t}\n-\n-\t\tsmb_flush_file(sr, sr->fid_ofile);\n+\t\tsmb_ofile_flush(sr, sr->fid_ofile);\n \t} else {\n \t\tflist = &sr->tid_tree->t_ofile_list;\n \t\tsmb_llist_enter(flist, RW_READER);\n \t\tfile = smb_llist_head(flist);\n \t\twhile (file) {\n \t\t\tmutex_enter(&file->f_mutex);\n-\t\t\tsmb_flush_file(sr, file);\n+\t\t\tsmb_ofile_flush(sr, file);\n \t\t\tmutex_exit(&file->f_mutex);\n \t\t\tfile = smb_llist_next(flist, file);\n \t\t}\n@@ -108,19 +107,3 @@ smb_com_flush(smb_request_t *sr)\n \trc = smbsr_encode_empty_result(sr);\n \treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n }\n-\n-\n-/*\n- * smb_flush_file\n- *\n- * If writes on this file are not synchronous, flush it using the NFSv3\n- * commit interface.\n- */\n-static void\n-smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile)\n-{\n-\tsr->user_cr = smb_ofile_getcred(ofile);\n-\n-\tif ((ofile->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n-\t\t(void) smb_fsop_commit(sr, sr->user_cr, ofile->f_node);\n-}""}<_**next**_>{""sha"": ""582091d1dd645238651551fb71c024bddd1d27d5"", ""filename"": ""usr/src/uts/common/fs/smbsrv/smb_ofile.c"", ""status"": ""modified"", ""additions"": 22, ""deletions"": 0, ""changes"": 22, ""blob_url"": ""https://github.com/illumos/illumos-gate/blob/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb_ofile.c"", ""raw_url"": ""https://github.com/illumos/illumos-gate/raw/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb_ofile.c"", ""contents_url"": ""https://api.github.com/repos/illumos/illumos-gate/contents/usr/src/uts/common/fs/smbsrv/smb_ofile.c?ref=6d1c73b5858fefc6161c7d686345f0dc887ea799"", ""patch"": ""@@ -21,6 +21,7 @@\n /*\n  * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.\n  * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.\n+ * Copyright 2016 Syneto S.R.L. All rights reserved.\n  */\n \n /*\n@@ -836,6 +837,27 @@ smb_ofile_seek(\n \treturn (rc);\n }\n \n+/*\n+ * smb_ofile_flush\n+ *\n+ * If writes on this file are not synchronous, flush it using the NFSv3\n+ * commit interface.\n+ *\n+ * XXX - todo: Flush named pipe should drain writes.\n+ */\n+void\n+smb_ofile_flush(struct smb_request *sr, struct smb_ofile *of)\n+{\n+\tswitch (of->f_ftype) {\n+\tcase SMB_FTYPE_DISK:\n+\t\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n+\t\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n+\t\tbreak;\n+\tdefault:\n+\t\tbreak;\n+\t}\n+}\n+\n /*\n  * smb_ofile_is_open\n  */""}<_**next**_>{""sha"": ""2dd8787aebfd3af6f5a5fb3a345e26ef697b68a5"", ""filename"": ""usr/src/uts/common/smbsrv/smb_kproto.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/illumos/illumos-gate/blob/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/smbsrv/smb_kproto.h"", ""raw_url"": ""https://github.com/illumos/illumos-gate/raw/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/smbsrv/smb_kproto.h"", ""contents_url"": ""https://api.github.com/repos/illumos/illumos-gate/contents/usr/src/uts/common/smbsrv/smb_kproto.h?ref=6d1c73b5858fefc6161c7d686345f0dc887ea799"", ""patch"": ""@@ -22,6 +22,7 @@\n /*\n  * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.\n  * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.\n+ * Copyright 2016 Syneto S.R.L.  All rights reserved.\n  */\n \n /*\n@@ -673,6 +674,7 @@ void smb_ofile_close(smb_ofile_t *, int32_t);\n void smb_ofile_delete(void *);\n uint32_t smb_ofile_access(smb_ofile_t *, cred_t *, uint32_t);\n int smb_ofile_seek(smb_ofile_t *, ushort_t, int32_t, uint32_t *);\n+void smb_ofile_flush(smb_request_t *, smb_ofile_t *);\n boolean_t smb_ofile_hold(smb_ofile_t *);\n void smb_ofile_release(smb_ofile_t *);\n void smb_ofile_request_complete(smb_ofile_t *);""}","smb_com_flush(smb_request_t *sr)
{
	smb_ofile_t	*file;
	smb_llist_t	*flist;
	int		rc;

	if (smb_flush_required == 0) {
		rc = smbsr_encode_empty_result(sr);
		return ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);
	}

	if (sr->smb_fid != 0xffff) {
		smbsr_lookup_file(sr);
		if (sr->fid_ofile == NULL) {
			smbsr_error(sr, NT_STATUS_INVALID_HANDLE,
 			    ERRDOS, ERRbadfid);
 			return (SDRC_ERROR);
 		}
		smb_ofile_flush(sr, sr->fid_ofile);
 	} else {
 		flist = &sr->tid_tree->t_ofile_list;
 		smb_llist_enter(flist, RW_READER);
 		file = smb_llist_head(flist);
 		while (file) {
 			mutex_enter(&file->f_mutex);
			smb_ofile_flush(sr, file);
 			mutex_exit(&file->f_mutex);
 			file = smb_llist_next(flist, file);
 		}
		smb_llist_exit(flist);
	}

 	rc = smbsr_encode_empty_result(sr);
 	return ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);
 }
","smb_com_flush(smb_request_t *sr)
{
	smb_ofile_t	*file;
	smb_llist_t	*flist;
	int		rc;

	if (smb_flush_required == 0) {
		rc = smbsr_encode_empty_result(sr);
		return ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);
	}

	if (sr->smb_fid != 0xffff) {
		smbsr_lookup_file(sr);
		if (sr->fid_ofile == NULL) {
			smbsr_error(sr, NT_STATUS_INVALID_HANDLE,
 			    ERRDOS, ERRbadfid);
 			return (SDRC_ERROR);
 		}
		smb_flush_file(sr, sr->fid_ofile);
 	} else {
 		flist = &sr->tid_tree->t_ofile_list;
 		smb_llist_enter(flist, RW_READER);
 		file = smb_llist_head(flist);
 		while (file) {
 			mutex_enter(&file->f_mutex);
			smb_flush_file(sr, file);
 			mutex_exit(&file->f_mutex);
 			file = smb_llist_next(flist, file);
 		}
		smb_llist_exit(flist);
	}

 	rc = smbsr_encode_empty_result(sr);
 	return ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);
 }
",C,"		smb_ofile_flush(sr, sr->fid_ofile);
			smb_ofile_flush(sr, file);
","		smb_flush_file(sr, sr->fid_ofile);
			smb_flush_file(sr, file);
",,"@@ -21,6 +21,8 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2016 Syneto S.R.L. All rights reserved.
  */
 
 /*
@@ -40,8 +42,6 @@
 #include <smbsrv/smb_fsops.h>
 
 
-static void smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile);
-
 /*
  * smb_com_flush
  *
@@ -90,15 +90,14 @@ smb_com_flush(smb_request_t *sr)
 			    ERRDOS, ERRbadfid);
 			return (SDRC_ERROR);
 		}
-
-		smb_flush_file(sr, sr->fid_ofile);
+		smb_ofile_flush(sr, sr->fid_ofile);
 	} else {
 		flist = &sr->tid_tree->t_ofile_list;
 		smb_llist_enter(flist, RW_READER);
 		file = smb_llist_head(flist);
 		while (file) {
 			mutex_enter(&file->f_mutex);
-			smb_flush_file(sr, file);
+			smb_ofile_flush(sr, file);
 			mutex_exit(&file->f_mutex);
 			file = smb_llist_next(flist, file);
 		}
@@ -108,19 +107,3 @@ smb_com_flush(smb_request_t *sr)
 	rc = smbsr_encode_empty_result(sr);
 	return ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);
 }
-
-
-/*
- * smb_flush_file
- *
- * If writes on this file are not synchronous, flush it using the NFSv3
- * commit interface.
- */
-static void
-smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile)
-{
-	sr->user_cr = smb_ofile_getcred(ofile);
-
-	if ((ofile->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)
-		(void) smb_fsop_commit(sr, sr->user_cr, ofile->f_node);
-}",illumos-gate,6d1c73b5858fefc6161c7d686345f0dc887ea799,516627f338a630bcf9806a91aa873bbbae9a2fac,1,"smb_com_flush(smb_request_t *sr)
{
	smb_ofile_t	*file;
	smb_llist_t	*flist;
	int		rc;

	if (smb_flush_required == 0) {
		rc = smbsr_encode_empty_result(sr);
		return ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);
	}

	if (sr->smb_fid != 0xffff) {
		smbsr_lookup_file(sr);
		if (sr->fid_ofile == NULL) {
			smbsr_error(sr, NT_STATUS_INVALID_HANDLE,
 			    ERRDOS, ERRbadfid);
 			return (SDRC_ERROR);
 		}
//flaw_line_below:

//flaw_line_below:
		smb_flush_file(sr, sr->fid_ofile);
//fix_flaw_line_below:
//		smb_ofile_flush(sr, sr->fid_ofile);
 	} else {
 		flist = &sr->tid_tree->t_ofile_list;
 		smb_llist_enter(flist, RW_READER);
 		file = smb_llist_head(flist);
 		while (file) {
 			mutex_enter(&file->f_mutex);
//flaw_line_below:
			smb_flush_file(sr, file);
//fix_flaw_line_below:
//			smb_ofile_flush(sr, file);
 			mutex_exit(&file->f_mutex);
 			file = smb_llist_next(flist, file);
 		}
		smb_llist_exit(flist);
	}

 	rc = smbsr_encode_empty_result(sr);
 	return ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);
 }
"
4263,181999,,Remote,Not required,Complete,CVE-2016-6561,https://www.cvedetails.com/cve/CVE-2016-6561/,CWE-476,Low,,,,2017-03-31,7.8,illumos smbsrv NULL pointer dereference allows system crash.,2017-05-01,,0,https://github.com/illumos/illumos-gate/commit/6d1c73b5858fefc6161c7d686345f0dc887ea799,6d1c73b5858fefc6161c7d686345f0dc887ea799,"7483 SMB flush on pipe triggers NULL pointer dereference in module smbsrv
Reviewed by: Gordon Ross <gwr@nexenta.com>
Reviewed by: Matt Barden <matt.barden@nexenta.com>
Reviewed by: Evan Layton <evan.layton@nexenta.com>
Reviewed by: Dan McDonald <danmcd@omniti.com>
Approved by: Gordon Ross <gwr@nexenta.com>",5,usr/src/uts/common/fs/smbsrv/smb_flush.c,"{""sha"": ""82263d59366b6880a932b04f7a054a273e5a2169"", ""filename"": ""usr/src/uts/common/fs/smbsrv/smb2_flush.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 8, ""changes"": 10, ""blob_url"": ""https://github.com/illumos/illumos-gate/blob/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb2_flush.c"", ""raw_url"": ""https://github.com/illumos/illumos-gate/raw/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb2_flush.c"", ""contents_url"": ""https://api.github.com/repos/illumos/illumos-gate/contents/usr/src/uts/common/fs/smbsrv/smb2_flush.c?ref=6d1c73b5858fefc6161c7d686345f0dc887ea799"", ""patch"": ""@@ -11,6 +11,7 @@\n \n /*\n  * Copyright 2014 Nexenta Systems, Inc.  All rights reserved.\n+ * Copyright 2016 Syneto S.R.L. All rights reserved.\n  */\n \n /*\n@@ -23,7 +24,6 @@\n smb_sdrc_t\n smb2_flush(smb_request_t *sr)\n {\n-\tsmb_ofile_t *of = NULL;\n \tuint16_t StructSize;\n \tuint16_t reserved1;\n \tuint32_t reserved2;\n@@ -51,14 +51,8 @@ smb2_flush(smb_request_t *sr)\n \t\tsmb2sr_put_error(sr, status);\n \t\treturn (SDRC_SUCCESS);\n \t}\n-\tof = sr->fid_ofile;\n \n-\t/*\n-\t * XXX - todo:\n-\t * Flush named pipe should drain writes.\n-\t */\n-\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n-\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n+\tsmb_ofile_flush(sr, sr->fid_ofile);\n \n \t/*\n \t * SMB2 Flush reply""}<_**next**_>{""sha"": ""1d210c3d8990d77683b7c5ca69ea67fe338c129c"", ""filename"": ""usr/src/uts/common/fs/smbsrv/smb_flush.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 21, ""changes"": 25, ""blob_url"": ""https://github.com/illumos/illumos-gate/blob/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb_flush.c"", ""raw_url"": ""https://github.com/illumos/illumos-gate/raw/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb_flush.c"", ""contents_url"": ""https://api.github.com/repos/illumos/illumos-gate/contents/usr/src/uts/common/fs/smbsrv/smb_flush.c?ref=6d1c73b5858fefc6161c7d686345f0dc887ea799"", ""patch"": ""@@ -21,6 +21,8 @@\n /*\n  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.\n  * Use is subject to license terms.\n+ *\n+ * Copyright 2016 Syneto S.R.L. All rights reserved.\n  */\n \n /*\n@@ -40,8 +42,6 @@\n #include <smbsrv/smb_fsops.h>\n \n \n-static void smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile);\n-\n /*\n  * smb_com_flush\n  *\n@@ -90,15 +90,14 @@ smb_com_flush(smb_request_t *sr)\n \t\t\t    ERRDOS, ERRbadfid);\n \t\t\treturn (SDRC_ERROR);\n \t\t}\n-\n-\t\tsmb_flush_file(sr, sr->fid_ofile);\n+\t\tsmb_ofile_flush(sr, sr->fid_ofile);\n \t} else {\n \t\tflist = &sr->tid_tree->t_ofile_list;\n \t\tsmb_llist_enter(flist, RW_READER);\n \t\tfile = smb_llist_head(flist);\n \t\twhile (file) {\n \t\t\tmutex_enter(&file->f_mutex);\n-\t\t\tsmb_flush_file(sr, file);\n+\t\t\tsmb_ofile_flush(sr, file);\n \t\t\tmutex_exit(&file->f_mutex);\n \t\t\tfile = smb_llist_next(flist, file);\n \t\t}\n@@ -108,19 +107,3 @@ smb_com_flush(smb_request_t *sr)\n \trc = smbsr_encode_empty_result(sr);\n \treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n }\n-\n-\n-/*\n- * smb_flush_file\n- *\n- * If writes on this file are not synchronous, flush it using the NFSv3\n- * commit interface.\n- */\n-static void\n-smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile)\n-{\n-\tsr->user_cr = smb_ofile_getcred(ofile);\n-\n-\tif ((ofile->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n-\t\t(void) smb_fsop_commit(sr, sr->user_cr, ofile->f_node);\n-}""}<_**next**_>{""sha"": ""582091d1dd645238651551fb71c024bddd1d27d5"", ""filename"": ""usr/src/uts/common/fs/smbsrv/smb_ofile.c"", ""status"": ""modified"", ""additions"": 22, ""deletions"": 0, ""changes"": 22, ""blob_url"": ""https://github.com/illumos/illumos-gate/blob/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb_ofile.c"", ""raw_url"": ""https://github.com/illumos/illumos-gate/raw/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/fs/smbsrv/smb_ofile.c"", ""contents_url"": ""https://api.github.com/repos/illumos/illumos-gate/contents/usr/src/uts/common/fs/smbsrv/smb_ofile.c?ref=6d1c73b5858fefc6161c7d686345f0dc887ea799"", ""patch"": ""@@ -21,6 +21,7 @@\n /*\n  * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.\n  * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.\n+ * Copyright 2016 Syneto S.R.L. All rights reserved.\n  */\n \n /*\n@@ -836,6 +837,27 @@ smb_ofile_seek(\n \treturn (rc);\n }\n \n+/*\n+ * smb_ofile_flush\n+ *\n+ * If writes on this file are not synchronous, flush it using the NFSv3\n+ * commit interface.\n+ *\n+ * XXX - todo: Flush named pipe should drain writes.\n+ */\n+void\n+smb_ofile_flush(struct smb_request *sr, struct smb_ofile *of)\n+{\n+\tswitch (of->f_ftype) {\n+\tcase SMB_FTYPE_DISK:\n+\t\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n+\t\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n+\t\tbreak;\n+\tdefault:\n+\t\tbreak;\n+\t}\n+}\n+\n /*\n  * smb_ofile_is_open\n  */""}<_**next**_>{""sha"": ""2dd8787aebfd3af6f5a5fb3a345e26ef697b68a5"", ""filename"": ""usr/src/uts/common/smbsrv/smb_kproto.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/illumos/illumos-gate/blob/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/smbsrv/smb_kproto.h"", ""raw_url"": ""https://github.com/illumos/illumos-gate/raw/6d1c73b5858fefc6161c7d686345f0dc887ea799/usr/src/uts/common/smbsrv/smb_kproto.h"", ""contents_url"": ""https://api.github.com/repos/illumos/illumos-gate/contents/usr/src/uts/common/smbsrv/smb_kproto.h?ref=6d1c73b5858fefc6161c7d686345f0dc887ea799"", ""patch"": ""@@ -22,6 +22,7 @@\n /*\n  * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.\n  * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.\n+ * Copyright 2016 Syneto S.R.L.  All rights reserved.\n  */\n \n /*\n@@ -673,6 +674,7 @@ void smb_ofile_close(smb_ofile_t *, int32_t);\n void smb_ofile_delete(void *);\n uint32_t smb_ofile_access(smb_ofile_t *, cred_t *, uint32_t);\n int smb_ofile_seek(smb_ofile_t *, ushort_t, int32_t, uint32_t *);\n+void smb_ofile_flush(smb_request_t *, smb_ofile_t *);\n boolean_t smb_ofile_hold(smb_ofile_t *);\n void smb_ofile_release(smb_ofile_t *);\n void smb_ofile_request_complete(smb_ofile_t *);""}","smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile)
","smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile)
{
	sr->user_cr = smb_ofile_getcred(ofile);
	if ((ofile->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)
		(void) smb_fsop_commit(sr, sr->user_cr, ofile->f_node);
}
",C,,"{
	sr->user_cr = smb_ofile_getcred(ofile);
	if ((ofile->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)
		(void) smb_fsop_commit(sr, sr->user_cr, ofile->f_node);
}
",,"@@ -21,6 +21,8 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2016 Syneto S.R.L. All rights reserved.
  */
 
 /*
@@ -40,8 +42,6 @@
 #include <smbsrv/smb_fsops.h>
 
 
-static void smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile);
-
 /*
  * smb_com_flush
  *
@@ -90,15 +90,14 @@ smb_com_flush(smb_request_t *sr)
 			    ERRDOS, ERRbadfid);
 			return (SDRC_ERROR);
 		}
-
-		smb_flush_file(sr, sr->fid_ofile);
+		smb_ofile_flush(sr, sr->fid_ofile);
 	} else {
 		flist = &sr->tid_tree->t_ofile_list;
 		smb_llist_enter(flist, RW_READER);
 		file = smb_llist_head(flist);
 		while (file) {
 			mutex_enter(&file->f_mutex);
-			smb_flush_file(sr, file);
+			smb_ofile_flush(sr, file);
 			mutex_exit(&file->f_mutex);
 			file = smb_llist_next(flist, file);
 		}
@@ -108,19 +107,3 @@ smb_com_flush(smb_request_t *sr)
 	rc = smbsr_encode_empty_result(sr);
 	return ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);
 }
-
-
-/*
- * smb_flush_file
- *
- * If writes on this file are not synchronous, flush it using the NFSv3
- * commit interface.
- */
-static void
-smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile)
-{
-	sr->user_cr = smb_ofile_getcred(ofile);
-
-	if ((ofile->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)
-		(void) smb_fsop_commit(sr, sr->user_cr, ofile->f_node);
-}",illumos-gate,6d1c73b5858fefc6161c7d686345f0dc887ea799,516627f338a630bcf9806a91aa873bbbae9a2fac,1,"smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile)
//flaw_line_below:
{
//flaw_line_below:
	sr->user_cr = smb_ofile_getcred(ofile);
//flaw_line_below:

//flaw_line_below:
	if ((ofile->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)
//flaw_line_below:
		(void) smb_fsop_commit(sr, sr->user_cr, ofile->f_node);
//flaw_line_below:
}
"
4293,182029,,Remote,Not required,Partial,CVE-2015-8898,https://www.cvedetails.com/cve/CVE-2015-8898/,CWE-476,Medium,,,,2017-03-15,4.3,The WriteImages function in magick/constitute.c in ImageMagick before 6.9.2-4 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image file.,2018-05-17,DoS ,9,https://github.com/ImageMagick/ImageMagick/commit/5b4bebaa91849c592a8448bc353ab25a54ff8c44,5b4bebaa91849c592a8448bc353ab25a54ff8c44,https://github.com/ImageMagick/ImageMagick/pull/34,1,MagickCore/constitute.c,"{""sha"": ""dc6ec49c131aff898964ae458eb8ead7aee361e3"", ""filename"": ""MagickCore/constitute.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 1, ""changes"": 10, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/5b4bebaa91849c592a8448bc353ab25a54ff8c44/MagickCore/constitute.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/5b4bebaa91849c592a8448bc353ab25a54ff8c44/MagickCore/constitute.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/MagickCore/constitute.c?ref=5b4bebaa91849c592a8448bc353ab25a54ff8c44"", ""patch"": ""@@ -1272,7 +1272,14 @@ MagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,\n     (void) CopyMagickString(write_info->magick,images->magick,MagickPathExtent);\n   p=images;\n   for ( ; GetNextImageInList(p) != (Image *) NULL; p=GetNextImageInList(p))\n-    if (p->scene >= GetNextImageInList(p)->scene)\n+  {\n+    register Image\n+      *next;\n+    \n+    next=GetNextImageInList(p);\n+    if (next == (Image *) NULL)\n+      break;\n+    if (p->scene >= next->scene)\n       {\n         register ssize_t\n           i;\n@@ -1285,6 +1292,7 @@ MagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,\n           p->scene=(size_t) i++;\n         break;\n       }\n+  }\n   /*\n     Write images.\n   */""}","MagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,
  Image *images,const char *filename,ExceptionInfo *exception)
{
#define WriteImageTag  ""Write/Image""

  ExceptionInfo
    *sans_exception;

  ImageInfo
    *write_info;

  MagickBooleanType
    proceed;

  MagickOffsetType
    progress;

  MagickProgressMonitor
    progress_monitor;

  MagickSizeType
    number_images;

  MagickStatusType
    status;

  register Image
    *p;

  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(images != (Image *) NULL);
  assert(images->signature == MagickCoreSignature);
  if (images->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",images->filename);
  assert(exception != (ExceptionInfo *) NULL);
  write_info=CloneImageInfo(image_info);
  *write_info->magick='\0';
  images=GetFirstImageInList(images);
  if (filename != (const char *) NULL)
    for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))
      (void) CopyMagickString(p->filename,filename,MagickPathExtent);
  (void) CopyMagickString(write_info->filename,images->filename,MagickPathExtent);
  sans_exception=AcquireExceptionInfo();
  (void) SetImageInfo(write_info,(unsigned int) GetImageListLength(images),
    sans_exception);
  sans_exception=DestroyExceptionInfo(sans_exception);
  if (*write_info->magick == '\0')
     (void) CopyMagickString(write_info->magick,images->magick,MagickPathExtent);
   p=images;
   for ( ; GetNextImageInList(p) != (Image *) NULL; p=GetNextImageInList(p))
  {
    register Image
      *next;
    
    next=GetNextImageInList(p);
    if (next == (Image *) NULL)
      break;
    if (p->scene >= next->scene)
       {
         register ssize_t
           i;

        /*
          Generate consistent scene numbers.
        */
        i=(ssize_t) images->scene;
        for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))
           p->scene=(size_t) i++;
         break;
       }
  }
   /*
     Write images.
   */
  status=MagickTrue;
  progress_monitor=(MagickProgressMonitor) NULL;
  progress=0;
  number_images=GetImageListLength(images);
  for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))
  {
    if (number_images != 1)
      progress_monitor=SetImageProgressMonitor(p,(MagickProgressMonitor) NULL,
        p->client_data);
    status&=WriteImage(write_info,p,exception);
    if (number_images != 1)
      (void) SetImageProgressMonitor(p,progress_monitor,p->client_data);
    if (write_info->adjoin != MagickFalse)
      break;
    if (number_images != 1)
      {
        proceed=SetImageProgress(p,WriteImageTag,progress++,number_images);
        if (proceed == MagickFalse)
          break;
      }
  }
  write_info=DestroyImageInfo(write_info);
  return(status != 0 ? MagickTrue : MagickFalse);
}
","MagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,
  Image *images,const char *filename,ExceptionInfo *exception)
{
#define WriteImageTag  ""Write/Image""

  ExceptionInfo
    *sans_exception;

  ImageInfo
    *write_info;

  MagickBooleanType
    proceed;

  MagickOffsetType
    progress;

  MagickProgressMonitor
    progress_monitor;

  MagickSizeType
    number_images;

  MagickStatusType
    status;

  register Image
    *p;

  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(images != (Image *) NULL);
  assert(images->signature == MagickCoreSignature);
  if (images->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",images->filename);
  assert(exception != (ExceptionInfo *) NULL);
  write_info=CloneImageInfo(image_info);
  *write_info->magick='\0';
  images=GetFirstImageInList(images);
  if (filename != (const char *) NULL)
    for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))
      (void) CopyMagickString(p->filename,filename,MagickPathExtent);
  (void) CopyMagickString(write_info->filename,images->filename,MagickPathExtent);
  sans_exception=AcquireExceptionInfo();
  (void) SetImageInfo(write_info,(unsigned int) GetImageListLength(images),
    sans_exception);
  sans_exception=DestroyExceptionInfo(sans_exception);
  if (*write_info->magick == '\0')
     (void) CopyMagickString(write_info->magick,images->magick,MagickPathExtent);
   p=images;
   for ( ; GetNextImageInList(p) != (Image *) NULL; p=GetNextImageInList(p))
    if (p->scene >= GetNextImageInList(p)->scene)
       {
         register ssize_t
           i;

        /*
          Generate consistent scene numbers.
        */
        i=(ssize_t) images->scene;
        for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))
           p->scene=(size_t) i++;
         break;
       }
   /*
     Write images.
   */
  status=MagickTrue;
  progress_monitor=(MagickProgressMonitor) NULL;
  progress=0;
  number_images=GetImageListLength(images);
  for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))
  {
    if (number_images != 1)
      progress_monitor=SetImageProgressMonitor(p,(MagickProgressMonitor) NULL,
        p->client_data);
    status&=WriteImage(write_info,p,exception);
    if (number_images != 1)
      (void) SetImageProgressMonitor(p,progress_monitor,p->client_data);
    if (write_info->adjoin != MagickFalse)
      break;
    if (number_images != 1)
      {
        proceed=SetImageProgress(p,WriteImageTag,progress++,number_images);
        if (proceed == MagickFalse)
          break;
      }
  }
  write_info=DestroyImageInfo(write_info);
  return(status != 0 ? MagickTrue : MagickFalse);
}
",C,"  {
    register Image
      *next;
    
    next=GetNextImageInList(p);
    if (next == (Image *) NULL)
      break;
    if (p->scene >= next->scene)
  }
","    if (p->scene >= GetNextImageInList(p)->scene)
",,"@@ -1272,7 +1272,14 @@ MagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,
     (void) CopyMagickString(write_info->magick,images->magick,MagickPathExtent);
   p=images;
   for ( ; GetNextImageInList(p) != (Image *) NULL; p=GetNextImageInList(p))
-    if (p->scene >= GetNextImageInList(p)->scene)
+  {
+    register Image
+      *next;
+    
+    next=GetNextImageInList(p);
+    if (next == (Image *) NULL)
+      break;
+    if (p->scene >= next->scene)
       {
         register ssize_t
           i;
@@ -1285,6 +1292,7 @@ MagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,
           p->scene=(size_t) i++;
         break;
       }
+  }
   /*
     Write images.
   */",ImageMagick,5b4bebaa91849c592a8448bc353ab25a54ff8c44,52ec99e1511bdf61dbe568526a93441545ff4371,1,"MagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,
  Image *images,const char *filename,ExceptionInfo *exception)
{
#define WriteImageTag  ""Write/Image""

  ExceptionInfo
    *sans_exception;

  ImageInfo
    *write_info;

  MagickBooleanType
    proceed;

  MagickOffsetType
    progress;

  MagickProgressMonitor
    progress_monitor;

  MagickSizeType
    number_images;

  MagickStatusType
    status;

  register Image
    *p;

  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(images != (Image *) NULL);
  assert(images->signature == MagickCoreSignature);
  if (images->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",images->filename);
  assert(exception != (ExceptionInfo *) NULL);
  write_info=CloneImageInfo(image_info);
  *write_info->magick='\0';
  images=GetFirstImageInList(images);
  if (filename != (const char *) NULL)
    for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))
      (void) CopyMagickString(p->filename,filename,MagickPathExtent);
  (void) CopyMagickString(write_info->filename,images->filename,MagickPathExtent);
  sans_exception=AcquireExceptionInfo();
  (void) SetImageInfo(write_info,(unsigned int) GetImageListLength(images),
    sans_exception);
  sans_exception=DestroyExceptionInfo(sans_exception);
  if (*write_info->magick == '\0')
     (void) CopyMagickString(write_info->magick,images->magick,MagickPathExtent);
   p=images;
   for ( ; GetNextImageInList(p) != (Image *) NULL; p=GetNextImageInList(p))
//flaw_line_below:
    if (p->scene >= GetNextImageInList(p)->scene)
//fix_flaw_line_below:
//  {
//fix_flaw_line_below:
//    register Image
//fix_flaw_line_below:
//      *next;
//fix_flaw_line_below:
//    
//fix_flaw_line_below:
//    next=GetNextImageInList(p);
//fix_flaw_line_below:
//    if (next == (Image *) NULL)
//fix_flaw_line_below:
//      break;
//fix_flaw_line_below:
//    if (p->scene >= next->scene)
       {
         register ssize_t
           i;

        /*
          Generate consistent scene numbers.
        */
        i=(ssize_t) images->scene;
        for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))
           p->scene=(size_t) i++;
         break;
       }
//fix_flaw_line_below:
//  }
   /*
     Write images.
   */
  status=MagickTrue;
  progress_monitor=(MagickProgressMonitor) NULL;
  progress=0;
  number_images=GetImageListLength(images);
  for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))
  {
    if (number_images != 1)
      progress_monitor=SetImageProgressMonitor(p,(MagickProgressMonitor) NULL,
        p->client_data);
    status&=WriteImage(write_info,p,exception);
    if (number_images != 1)
      (void) SetImageProgressMonitor(p,progress_monitor,p->client_data);
    if (write_info->adjoin != MagickFalse)
      break;
    if (number_images != 1)
      {
        proceed=SetImageProgress(p,WriteImageTag,progress++,number_images);
        if (proceed == MagickFalse)
          break;
      }
  }
  write_info=DestroyImageInfo(write_info);
  return(status != 0 ? MagickTrue : MagickFalse);
}
"
4302,182038,,Remote,Not required,Partial,CVE-2015-8750,https://www.cvedetails.com/cve/CVE-2015-8750/,CWE-476,Medium,,,,2017-02-13,4.3,libdwarf 20151114 and earlier allows remote attackers to cause a denial of service (NULL pointer dereference and crash) via a debug_abbrev section marked NOBITS in an ELF file.,2017-02-16,DoS ,10,https://github.com/tomhughes/libdwarf/commit/11750a2838e52953013e3114ef27b3c7b1780697,11750a2838e52953013e3114ef27b3c7b1780697,"A DWARF related section marked SHT_NOBITS (elf section type)
is an error in the elf object.  Now detected.
dwarf_elf_access.c",0,libdwarf/dwarf_elf_access.c,"{""sha"": ""57fb87a15d60323fc18590ed35bc30ae61f95e4a"", ""filename"": ""libdwarf/ChangeLog"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/tomhughes/libdwarf/blob/11750a2838e52953013e3114ef27b3c7b1780697/libdwarf/ChangeLog"", ""raw_url"": ""https://github.com/tomhughes/libdwarf/raw/11750a2838e52953013e3114ef27b3c7b1780697/libdwarf/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/tomhughes/libdwarf/contents/libdwarf/ChangeLog?ref=11750a2838e52953013e3114ef27b3c7b1780697"", ""patch"": ""@@ -1,3 +1,7 @@\n+2015-12-30  David Anderson\n+     * dwarf_elf_access.c(dwarf_elf_object_access_load_section):\n+       now test for a NULL data pointer from libelf. Problem caused\n+       by DWARF related section being marked SHT_NOBITS.\n 2015-12-29  David Anderson\n      * dwarf_loc2.c: ll_dbg was not set, two places.\n        dwarf_loc_head_c_dealloc() was not iterating""}<_**next**_>{""sha"": ""72a139dbd1c239a8a3b96eebd0ccd35bc1e89677"", ""filename"": ""libdwarf/dwarf_elf_access.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 1, ""changes"": 14, ""blob_url"": ""https://github.com/tomhughes/libdwarf/blob/11750a2838e52953013e3114ef27b3c7b1780697/libdwarf/dwarf_elf_access.c"", ""raw_url"": ""https://github.com/tomhughes/libdwarf/raw/11750a2838e52953013e3114ef27b3c7b1780697/libdwarf/dwarf_elf_access.c"", ""contents_url"": ""https://api.github.com/repos/tomhughes/libdwarf/contents/libdwarf/dwarf_elf_access.c?ref=11750a2838e52953013e3114ef27b3c7b1780697"", ""patch"": ""@@ -1201,7 +1201,9 @@ dwarf_elf_object_relocate_a_section(void* obj_in,\n     return res;\n }\n \n-/* dwarf_elf_object_access_load_section */\n+/*  dwarf_elf_object_access_load_section()\n+    We are only asked to load sections that\n+    libdwarf really needs. */\n static int\n dwarf_elf_object_access_load_section(void* obj_in,\n     Dwarf_Half section_index,\n@@ -1235,6 +1237,16 @@ dwarf_elf_object_access_load_section(void* obj_in,\n             *error = DW_DLE_MDE;\n             return DW_DLV_ERROR;\n         }\n+        if (!data->d_buf) {\n+            /*  If NULL it means 'the section has no data'\n+                according to libelf documentation.\n+                No DWARF-related section should ever have\n+                'no data'.  Happens if a section type is\n+                SHT_NOBITS and no section libdwarf\n+                wants to look at should be SHT_NOBITS. */\n+            *error = DW_DLE_MDE;\n+            return DW_DLV_ERROR;\n+        }\n         *section_data = data->d_buf;\n     }\n     return DW_DLV_OK;""}"," dwarf_elf_object_access_load_section(void* obj_in,
     Dwarf_Half section_index,
    Dwarf_Small** section_data,
    int* error)
{
    dwarf_elf_object_access_internals_t*obj =
        (dwarf_elf_object_access_internals_t*)obj_in;
    if (section_index == 0) {
        return DW_DLV_NO_ENTRY;
    }

    {
        Elf_Scn *scn = 0;
        Elf_Data *data = 0;

        scn = elf_getscn(obj->elf, section_index);
        if (scn == NULL) {
            *error = DW_DLE_MDE;
            return DW_DLV_ERROR;
        }

        /*  When using libelf as a producer, section data may be stored
            in multiple buffers. In libdwarf however, we only use libelf
            as a consumer (there is a dwarf producer API, but it doesn't
            use libelf). Because of this, this single call to elf_getdata
            will retrieve the entire section in a single contiguous
            buffer. */
        data = elf_getdata(scn, NULL);
        if (data == NULL) {
             *error = DW_DLE_MDE;
             return DW_DLV_ERROR;
         }
        if (!data->d_buf) {
            /*  If NULL it means 'the section has no data'
                according to libelf documentation.
                No DWARF-related section should ever have
                'no data'.  Happens if a section type is
                SHT_NOBITS and no section libdwarf
                wants to look at should be SHT_NOBITS. */
            *error = DW_DLE_MDE;
            return DW_DLV_ERROR;
        }
         *section_data = data->d_buf;
     }
     return DW_DLV_OK;
}
"," dwarf_elf_object_access_load_section(void* obj_in,
     Dwarf_Half section_index,
    Dwarf_Small** section_data,
    int* error)
{
    dwarf_elf_object_access_internals_t*obj =
        (dwarf_elf_object_access_internals_t*)obj_in;
    if (section_index == 0) {
        return DW_DLV_NO_ENTRY;
    }

    {
        Elf_Scn *scn = 0;
        Elf_Data *data = 0;

        scn = elf_getscn(obj->elf, section_index);
        if (scn == NULL) {
            *error = DW_DLE_MDE;
            return DW_DLV_ERROR;
        }

        /*  When using libelf as a producer, section data may be stored
            in multiple buffers. In libdwarf however, we only use libelf
            as a consumer (there is a dwarf producer API, but it doesn't
            use libelf). Because of this, this single call to elf_getdata
            will retrieve the entire section in a single contiguous
            buffer. */
        data = elf_getdata(scn, NULL);
        if (data == NULL) {
             *error = DW_DLE_MDE;
             return DW_DLV_ERROR;
         }
         *section_data = data->d_buf;
     }
     return DW_DLV_OK;
}
",C,"        if (!data->d_buf) {
            /*  If NULL it means 'the section has no data'
                according to libelf documentation.
                No DWARF-related section should ever have
                'no data'.  Happens if a section type is
                SHT_NOBITS and no section libdwarf
                wants to look at should be SHT_NOBITS. */
            *error = DW_DLE_MDE;
            return DW_DLV_ERROR;
        }
",,,"@@ -1201,7 +1201,9 @@ dwarf_elf_object_relocate_a_section(void* obj_in,
     return res;
 }
 
-/* dwarf_elf_object_access_load_section */
+/*  dwarf_elf_object_access_load_section()
+    We are only asked to load sections that
+    libdwarf really needs. */
 static int
 dwarf_elf_object_access_load_section(void* obj_in,
     Dwarf_Half section_index,
@@ -1235,6 +1237,16 @@ dwarf_elf_object_access_load_section(void* obj_in,
             *error = DW_DLE_MDE;
             return DW_DLV_ERROR;
         }
+        if (!data->d_buf) {
+            /*  If NULL it means 'the section has no data'
+                according to libelf documentation.
+                No DWARF-related section should ever have
+                'no data'.  Happens if a section type is
+                SHT_NOBITS and no section libdwarf
+                wants to look at should be SHT_NOBITS. */
+            *error = DW_DLE_MDE;
+            return DW_DLV_ERROR;
+        }
         *section_data = data->d_buf;
     }
     return DW_DLV_OK;",libdwarf,11750a2838e52953013e3114ef27b3c7b1780697,47fdf4a8b4ac876f293ec27c2c6422c1079204a5,1," dwarf_elf_object_access_load_section(void* obj_in,
     Dwarf_Half section_index,
    Dwarf_Small** section_data,
    int* error)
{
    dwarf_elf_object_access_internals_t*obj =
        (dwarf_elf_object_access_internals_t*)obj_in;
    if (section_index == 0) {
        return DW_DLV_NO_ENTRY;
    }

    {
        Elf_Scn *scn = 0;
        Elf_Data *data = 0;

        scn = elf_getscn(obj->elf, section_index);
        if (scn == NULL) {
            *error = DW_DLE_MDE;
            return DW_DLV_ERROR;
        }

        /*  When using libelf as a producer, section data may be stored
            in multiple buffers. In libdwarf however, we only use libelf
            as a consumer (there is a dwarf producer API, but it doesn't
            use libelf). Because of this, this single call to elf_getdata
            will retrieve the entire section in a single contiguous
            buffer. */
        data = elf_getdata(scn, NULL);
        if (data == NULL) {
             *error = DW_DLE_MDE;
             return DW_DLV_ERROR;
         }
//fix_flaw_line_below:
//        if (!data->d_buf) {
//fix_flaw_line_below:
//            /*  If NULL it means 'the section has no data'
//fix_flaw_line_below:
//                according to libelf documentation.
//fix_flaw_line_below:
//                No DWARF-related section should ever have
//fix_flaw_line_below:
//                'no data'.  Happens if a section type is
//fix_flaw_line_below:
//                SHT_NOBITS and no section libdwarf
//fix_flaw_line_below:
//                wants to look at should be SHT_NOBITS. */
//fix_flaw_line_below:
//            *error = DW_DLE_MDE;
//fix_flaw_line_below:
//            return DW_DLV_ERROR;
//fix_flaw_line_below:
//        }
         *section_data = data->d_buf;
     }
     return DW_DLV_OK;
}
"
4319,182055,,Remote,Not required,Partial,CVE-2015-4054,https://www.cvedetails.com/cve/CVE-2015-4054/,CWE-476,Low,,,,2017-05-23,5.0,PgBouncer before 1.5.5 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) by sending a password packet before a startup packet.,2017-06-02,DoS ,6,https://github.com/pgbouncer/pgbouncer/commit/74d6e5f7de5ec736f71204b7b422af7380c19ac5,74d6e5f7de5ec736f71204b7b422af7380c19ac5,"Check if auth_user is set.

Fixes a crash if password packet appears before startup packet (#42).",0,src/client.c,"{""sha"": ""7c4f1c76a8900f3787942b3138b3eae56927fe43"", ""filename"": ""src/client.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/pgbouncer/pgbouncer/blob/74d6e5f7de5ec736f71204b7b422af7380c19ac5/src/client.c"", ""raw_url"": ""https://github.com/pgbouncer/pgbouncer/raw/74d6e5f7de5ec736f71204b7b422af7380c19ac5/src/client.c"", ""contents_url"": ""https://api.github.com/repos/pgbouncer/pgbouncer/contents/src/client.c?ref=74d6e5f7de5ec736f71204b7b422af7380c19ac5"", ""patch"": ""@@ -262,6 +262,12 @@ static bool handle_client_startup(PgSocket *client, PktHdr *pkt)\n \t\t}\n \t\tbreak;\n \tcase 'p':\t\t/* PasswordMessage */\n+\t\t/* too early */\n+\t\tif (!client->auth_user) {\n+\t\t\tdisconnect_client(client, true, \""client password pkt before startup packet\"");\n+\t\t\treturn false;\n+\t\t}\n+\n \t\t/* haven't requested it */\n \t\tif (cf_auth_type <= AUTH_TRUST) {\n \t\t\tdisconnect_client(client, true, \""unrequested passwd pkt\"");""}","static bool handle_client_startup(PgSocket *client, PktHdr *pkt)
{
	const char *passwd;
	const uint8_t *key;
	bool ok;

	SBuf *sbuf = &client->sbuf;

	/* don't tolerate partial packets */
	if (incomplete_pkt(pkt)) {
		disconnect_client(client, true, ""client sent partial pkt in startup phase"");
		return false;
	}

	if (client->wait_for_welcome) {
		if  (finish_client_login(client)) {
			/* the packet was already parsed */
			sbuf_prepare_skip(sbuf, pkt->len);
			return true;
		} else
			return false;
	}

	switch (pkt->type) {
	case PKT_SSLREQ:
		slog_noise(client, ""C: req SSL"");
		slog_noise(client, ""P: nak"");

		/* reject SSL attempt */
		if (!sbuf_answer(&client->sbuf, ""N"", 1)) {
			disconnect_client(client, false, ""failed to nak SSL"");
			return false;
		}
		break;
	case PKT_STARTUP_V2:
		disconnect_client(client, true, ""Old V2 protocol not supported"");
		return false;
	case PKT_STARTUP:
		if (client->pool) {
			disconnect_client(client, true, ""client re-sent startup pkt"");
			return false;
		}

		if (!decide_startup_pool(client, pkt))
			return false;

		if (client->pool->db->admin) {
			if (!admin_pre_login(client))
				return false;
		}

		if (cf_auth_type <= AUTH_TRUST || client->own_user) {
			if (!finish_client_login(client))
				return false;
		} else {
			if (!send_client_authreq(client)) {
				disconnect_client(client, false, ""failed to send auth req"");
				return false;
			}
 		}
 		break;
 	case 'p':		/* PasswordMessage */
		/* too early */
		if (!client->auth_user) {
			disconnect_client(client, true, ""client password pkt before startup packet"");
			return false;
		}

 		/* haven't requested it */
 		if (cf_auth_type <= AUTH_TRUST) {
 			disconnect_client(client, true, ""unrequested passwd pkt"");
			return false;
		}

		ok = mbuf_get_string(&pkt->data, &passwd);
		if (ok && check_client_passwd(client, passwd)) {
			if (!finish_client_login(client))
				return false;
		} else {
			disconnect_client(client, true, ""Auth failed"");
			return false;
		}
		break;
	case PKT_CANCEL:
		if (mbuf_avail_for_read(&pkt->data) == BACKENDKEY_LEN
		    && mbuf_get_bytes(&pkt->data, BACKENDKEY_LEN, &key))
		{
			memcpy(client->cancel_key, key, BACKENDKEY_LEN);
			accept_cancel_request(client);
		} else
			disconnect_client(client, false, ""bad cancel request"");
		return false;
	default:
		disconnect_client(client, false, ""bad packet"");
		return false;
	}
	sbuf_prepare_skip(sbuf, pkt->len);
	client->request_time = get_cached_time();
	return true;
}
","static bool handle_client_startup(PgSocket *client, PktHdr *pkt)
{
	const char *passwd;
	const uint8_t *key;
	bool ok;

	SBuf *sbuf = &client->sbuf;

	/* don't tolerate partial packets */
	if (incomplete_pkt(pkt)) {
		disconnect_client(client, true, ""client sent partial pkt in startup phase"");
		return false;
	}

	if (client->wait_for_welcome) {
		if  (finish_client_login(client)) {
			/* the packet was already parsed */
			sbuf_prepare_skip(sbuf, pkt->len);
			return true;
		} else
			return false;
	}

	switch (pkt->type) {
	case PKT_SSLREQ:
		slog_noise(client, ""C: req SSL"");
		slog_noise(client, ""P: nak"");

		/* reject SSL attempt */
		if (!sbuf_answer(&client->sbuf, ""N"", 1)) {
			disconnect_client(client, false, ""failed to nak SSL"");
			return false;
		}
		break;
	case PKT_STARTUP_V2:
		disconnect_client(client, true, ""Old V2 protocol not supported"");
		return false;
	case PKT_STARTUP:
		if (client->pool) {
			disconnect_client(client, true, ""client re-sent startup pkt"");
			return false;
		}

		if (!decide_startup_pool(client, pkt))
			return false;

		if (client->pool->db->admin) {
			if (!admin_pre_login(client))
				return false;
		}

		if (cf_auth_type <= AUTH_TRUST || client->own_user) {
			if (!finish_client_login(client))
				return false;
		} else {
			if (!send_client_authreq(client)) {
				disconnect_client(client, false, ""failed to send auth req"");
				return false;
			}
 		}
 		break;
 	case 'p':		/* PasswordMessage */
 		/* haven't requested it */
 		if (cf_auth_type <= AUTH_TRUST) {
 			disconnect_client(client, true, ""unrequested passwd pkt"");
			return false;
		}

		ok = mbuf_get_string(&pkt->data, &passwd);
		if (ok && check_client_passwd(client, passwd)) {
			if (!finish_client_login(client))
				return false;
		} else {
			disconnect_client(client, true, ""Auth failed"");
			return false;
		}
		break;
	case PKT_CANCEL:
		if (mbuf_avail_for_read(&pkt->data) == BACKENDKEY_LEN
		    && mbuf_get_bytes(&pkt->data, BACKENDKEY_LEN, &key))
		{
			memcpy(client->cancel_key, key, BACKENDKEY_LEN);
			accept_cancel_request(client);
		} else
			disconnect_client(client, false, ""bad cancel request"");
		return false;
	default:
		disconnect_client(client, false, ""bad packet"");
		return false;
	}
	sbuf_prepare_skip(sbuf, pkt->len);
	client->request_time = get_cached_time();
	return true;
}
",C,"		/* too early */
		if (!client->auth_user) {
			disconnect_client(client, true, ""client password pkt before startup packet"");
			return false;
		}

",,,"@@ -262,6 +262,12 @@ static bool handle_client_startup(PgSocket *client, PktHdr *pkt)
 		}
 		break;
 	case 'p':		/* PasswordMessage */
+		/* too early */
+		if (!client->auth_user) {
+			disconnect_client(client, true, ""client password pkt before startup packet"");
+			return false;
+		}
+
 		/* haven't requested it */
 		if (cf_auth_type <= AUTH_TRUST) {
 			disconnect_client(client, true, ""unrequested passwd pkt"");",pgbouncer,74d6e5f7de5ec736f71204b7b422af7380c19ac5,82c7b4d248b25d3eafb0d63059f0f2a03150ccd4,1,"static bool handle_client_startup(PgSocket *client, PktHdr *pkt)
{
	const char *passwd;
	const uint8_t *key;
	bool ok;

	SBuf *sbuf = &client->sbuf;

	/* don't tolerate partial packets */
	if (incomplete_pkt(pkt)) {
		disconnect_client(client, true, ""client sent partial pkt in startup phase"");
		return false;
	}

	if (client->wait_for_welcome) {
		if  (finish_client_login(client)) {
			/* the packet was already parsed */
			sbuf_prepare_skip(sbuf, pkt->len);
			return true;
		} else
			return false;
	}

	switch (pkt->type) {
	case PKT_SSLREQ:
		slog_noise(client, ""C: req SSL"");
		slog_noise(client, ""P: nak"");

		/* reject SSL attempt */
		if (!sbuf_answer(&client->sbuf, ""N"", 1)) {
			disconnect_client(client, false, ""failed to nak SSL"");
			return false;
		}
		break;
	case PKT_STARTUP_V2:
		disconnect_client(client, true, ""Old V2 protocol not supported"");
		return false;
	case PKT_STARTUP:
		if (client->pool) {
			disconnect_client(client, true, ""client re-sent startup pkt"");
			return false;
		}

		if (!decide_startup_pool(client, pkt))
			return false;

		if (client->pool->db->admin) {
			if (!admin_pre_login(client))
				return false;
		}

		if (cf_auth_type <= AUTH_TRUST || client->own_user) {
			if (!finish_client_login(client))
				return false;
		} else {
			if (!send_client_authreq(client)) {
				disconnect_client(client, false, ""failed to send auth req"");
				return false;
			}
 		}
 		break;
 	case 'p':		/* PasswordMessage */
//fix_flaw_line_below:
//		/* too early */
//fix_flaw_line_below:
//		if (!client->auth_user) {
//fix_flaw_line_below:
//			disconnect_client(client, true, ""client password pkt before startup packet"");
//fix_flaw_line_below:
//			return false;
//fix_flaw_line_below:
//		}
//fix_flaw_line_below:
//
 		/* haven't requested it */
 		if (cf_auth_type <= AUTH_TRUST) {
 			disconnect_client(client, true, ""unrequested passwd pkt"");
			return false;
		}

		ok = mbuf_get_string(&pkt->data, &passwd);
		if (ok && check_client_passwd(client, passwd)) {
			if (!finish_client_login(client))
				return false;
		} else {
			disconnect_client(client, true, ""Auth failed"");
			return false;
		}
		break;
	case PKT_CANCEL:
		if (mbuf_avail_for_read(&pkt->data) == BACKENDKEY_LEN
		    && mbuf_get_bytes(&pkt->data, BACKENDKEY_LEN, &key))
		{
			memcpy(client->cancel_key, key, BACKENDKEY_LEN);
			accept_cancel_request(client);
		} else
			disconnect_client(client, false, ""bad cancel request"");
		return false;
	default:
		disconnect_client(client, false, ""bad packet"");
		return false;
	}
	sbuf_prepare_skip(sbuf, pkt->len);
	client->request_time = get_cached_time();
	return true;
}
"
4365,182101,,Remote,Not required,Partial,CVE-2018-1000879,https://www.cvedetails.com/cve/CVE-2018-1000879/,CWE-476,Medium,,,,2018-12-20,4.3,"libarchive version commit 379867ecb330b3a952fb7bfa7bffb7bbd5547205 onwards (release v3.3.0 onwards) contains a CWE-476: NULL Pointer Dereference vulnerability in ACL parser - libarchive/archive_acl.c, archive_acl_from_text_l() that can result in Crash/DoS. This attack appear to be exploitable via the victim must open a specially crafted archive file.",2019-04-12,,5,https://github.com/libarchive/libarchive/pull/1105/commits/15bf44fd2c1ad0e3fd87048b3fcc90c4dcff1175,15bf44fd2c1ad0e3fd87048b3fcc90c4dcff1175,"Skip 0-length ACL fields

Currently, it is possible to create an archive that crashes bsdtar
with a malformed ACL:

Program received signal SIGSEGV, Segmentation fault.
archive_acl_from_text_l (acl=<optimised out>, text=0x7e2e92 """", want_type=<optimised out>, sc=<optimised out>) at libarchive/archive_acl.c:1726
1726				switch (*s) {
(gdb) p n
$1 = 1
(gdb) p field[n]
$2 = {start = 0x0, end = 0x0}

Stop this by checking that the length is not zero before beginning
the switch statement.

I am pretty sure this is the bug mentioned in the qsym paper [1],
and I was able to replicate it with a qsym + AFL + afl-rb setup.

[1] https://www.usenix.org/conference/usenixsecurity18/presentation/yun",0,libarchive/archive_acl.c,"{""sha"": ""7beeee86efedc974ae39d957f5ef795cb0587378"", ""filename"": ""libarchive/archive_acl.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/libarchive/libarchive/blob/15bf44fd2c1ad0e3fd87048b3fcc90c4dcff1175/libarchive/archive_acl.c"", ""raw_url"": ""https://github.com/libarchive/libarchive/raw/15bf44fd2c1ad0e3fd87048b3fcc90c4dcff1175/libarchive/archive_acl.c"", ""contents_url"": ""https://api.github.com/repos/libarchive/libarchive/contents/libarchive/archive_acl.c?ref=15bf44fd2c1ad0e3fd87048b3fcc90c4dcff1175"", ""patch"": ""@@ -1723,6 +1723,11 @@ archive_acl_from_text_l(struct archive_acl *acl, const char *text,\n \t\t\tst = field[n].start + 1;\n \t\t\tlen = field[n].end - field[n].start;\n \n+\t\t\tif (len == 0) {\n+\t\t\t\tret = ARCHIVE_WARN;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n \t\t\tswitch (*s) {\n \t\t\tcase 'u':\n \t\t\t\tif (len == 1 || (len == 4""}","archive_acl_from_text_l(struct archive_acl *acl, const char *text,
    int want_type, struct archive_string_conv *sc)
{
	struct {
		const char *start;
		const char *end;
	} field[6], name;

	const char *s, *st;
	int numfields, fields, n, r, sol, ret;
	int type, types, tag, permset, id;
	size_t len;
	char sep;

	switch (want_type) {
	case ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:
		want_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;
		__LA_FALLTHROUGH;
	case ARCHIVE_ENTRY_ACL_TYPE_ACCESS:
	case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:
		numfields = 5;
		break;
	case ARCHIVE_ENTRY_ACL_TYPE_NFS4:
		numfields = 6;
		break;
	default:
		return (ARCHIVE_FATAL);
	}

	ret = ARCHIVE_OK;
	types = 0;

	while (text != NULL &&  *text != '\0') {
		/*
		 * Parse the fields out of the next entry,
		 * advance 'text' to start of next entry.
		 */
		fields = 0;
		do {
			const char *start, *end;
			next_field(&text, &start, &end, &sep);
			if (fields < numfields) {
				field[fields].start = start;
				field[fields].end = end;
			}
			++fields;
		} while (sep == ':');

		/* Set remaining fields to blank. */
		for (n = fields; n < numfields; ++n)
			field[n].start = field[n].end = NULL;

		if (field[0].start != NULL && *(field[0].start) == '#') {
			/* Comment, skip entry */
			continue;
		}

		n = 0;
		sol = 0;
		id = -1;
		permset = 0;
		name.start = name.end = NULL;

		if (want_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {
			/* POSIX.1e ACLs */
			/*
			 * Default keyword ""default:user::rwx""
			 * if found, we have one more field
			 *
			 * We also support old Solaris extension:
			 * ""defaultuser::rwx"" is the default ACL corresponding
			 * to ""user::rwx"", etc. valid only for first field
			 */
			s = field[0].start;
			len = field[0].end - field[0].start;
			if (*s == 'd' && (len == 1 || (len >= 7
			    && memcmp((s + 1), ""efault"", 6) == 0))) {
				type = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;
				if (len > 7)
					field[0].start += 7;
				else
					n = 1;
			} else
				type = want_type;

			/* Check for a numeric ID in field n+1 or n+3. */
			isint(field[n + 1].start, field[n + 1].end, &id);
			/* Field n+3 is optional. */
			if (id == -1 && fields > (n + 3))
				isint(field[n + 3].start, field[n + 3].end,
				    &id);

			tag = 0;
			s = field[n].start;
 			st = field[n].start + 1;
 			len = field[n].end - field[n].start;
 
			if (len == 0) {
				ret = ARCHIVE_WARN;
				continue;
			}

 			switch (*s) {
 			case 'u':
 				if (len == 1 || (len == 4
				    && memcmp(st, ""ser"", 3) == 0))
					tag = ARCHIVE_ENTRY_ACL_USER_OBJ;
				break;
			case 'g':
				if (len == 1 || (len == 5
				    && memcmp(st, ""roup"", 4) == 0))
					tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;
				break;
			case 'o':
				if (len == 1 || (len == 5
				    && memcmp(st, ""ther"", 4) == 0))
					tag = ARCHIVE_ENTRY_ACL_OTHER;
				break;
			case 'm':
				if (len == 1 || (len == 4
				    && memcmp(st, ""ask"", 3) == 0))
					tag = ARCHIVE_ENTRY_ACL_MASK;
				break;
			default:
					break;
			}

			switch (tag) {
			case ARCHIVE_ENTRY_ACL_OTHER:
			case ARCHIVE_ENTRY_ACL_MASK:
				if (fields == (n + 2)
				    && field[n + 1].start < field[n + 1].end
				    && ismode(field[n + 1].start,
				    field[n + 1].end, &permset)) {
					/* This is Solaris-style ""other:rwx"" */
					sol = 1;
				} else if (fields == (n + 3) &&
				    field[n + 1].start < field[n + 1].end) {
					/* Invalid mask or other field */
					ret = ARCHIVE_WARN;
					continue;
				}
				break;
			case ARCHIVE_ENTRY_ACL_USER_OBJ:
			case ARCHIVE_ENTRY_ACL_GROUP_OBJ:
				if (id != -1 ||
				    field[n + 1].start < field[n + 1].end) {
					name = field[n + 1];
					if (tag == ARCHIVE_ENTRY_ACL_USER_OBJ)
						tag = ARCHIVE_ENTRY_ACL_USER;
					else
						tag = ARCHIVE_ENTRY_ACL_GROUP;
				}
				break;
			default:
				/* Invalid tag, skip entry */
				ret = ARCHIVE_WARN;
				continue;
			}

			/*
			 * Without ""default:"" we expect mode in field 3
			 * Exception: Solaris other and mask fields
			 */
			if (permset == 0 && !ismode(field[n + 2 - sol].start,
			    field[n + 2 - sol].end, &permset)) {
				/* Invalid mode, skip entry */
				ret = ARCHIVE_WARN;
				continue;
			}
		} else {
			/* NFS4 ACLs */
			s = field[0].start;
			len = field[0].end - field[0].start;
			tag = 0;

			switch (len) {
			case 4:
				if (memcmp(s, ""user"", 4) == 0)
					tag = ARCHIVE_ENTRY_ACL_USER;
				break;
			case 5:
				if (memcmp(s, ""group"", 5) == 0)
					tag = ARCHIVE_ENTRY_ACL_GROUP;
				break;
			case 6:
				if (memcmp(s, ""owner@"", 6) == 0)
					tag = ARCHIVE_ENTRY_ACL_USER_OBJ;
				else if (memcmp(s, ""group@"", 6) == 0)
					tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;
				break;
			case 9:
				if (memcmp(s, ""everyone@"", 9) == 0)
					tag = ARCHIVE_ENTRY_ACL_EVERYONE;
				break;
			default:
				break;
			}

			if (tag == 0) {
				/* Invalid tag, skip entry */
				ret = ARCHIVE_WARN;
				continue;
			} else if (tag == ARCHIVE_ENTRY_ACL_USER ||
			    tag == ARCHIVE_ENTRY_ACL_GROUP) {
				n = 1;
				name = field[1];
				isint(name.start, name.end, &id);
			} else
				n = 0;

			if (!is_nfs4_perms(field[1 + n].start,
			    field[1 + n].end, &permset)) {
				/* Invalid NFSv4 perms, skip entry */
				ret = ARCHIVE_WARN;
				continue;
			}
			if (!is_nfs4_flags(field[2 + n].start,
			    field[2 + n].end, &permset)) {
				/* Invalid NFSv4 flags, skip entry */
				ret = ARCHIVE_WARN;
				continue;
			}
			s = field[3 + n].start;
			len = field[3 + n].end - field[3 + n].start;
			type = 0;
			if (len == 4) {
				if (memcmp(s, ""deny"", 4) == 0)
					type = ARCHIVE_ENTRY_ACL_TYPE_DENY;
			} else if (len == 5) {
				if (memcmp(s, ""allow"", 5) == 0)
					type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;
				else if (memcmp(s, ""audit"", 5) == 0)
					type = ARCHIVE_ENTRY_ACL_TYPE_AUDIT;
				else if (memcmp(s, ""alarm"", 5) == 0)
					type = ARCHIVE_ENTRY_ACL_TYPE_ALARM;
			}
			if (type == 0) {
				/* Invalid entry type, skip entry */
				ret = ARCHIVE_WARN;
				continue;
			}
			isint(field[4 + n].start, field[4 + n].end,
			    &id);
		}

		/* Add entry to the internal list. */
		r = archive_acl_add_entry_len_l(acl, type, permset,
		    tag, id, name.start, name.end - name.start, sc);
		if (r < ARCHIVE_WARN)
			return (r);
		if (r != ARCHIVE_OK)
			ret = ARCHIVE_WARN;
		types |= type;
	}

	/* Reset ACL */
	archive_acl_reset(acl, types);

	return (ret);
}
","archive_acl_from_text_l(struct archive_acl *acl, const char *text,
    int want_type, struct archive_string_conv *sc)
{
	struct {
		const char *start;
		const char *end;
	} field[6], name;

	const char *s, *st;
	int numfields, fields, n, r, sol, ret;
	int type, types, tag, permset, id;
	size_t len;
	char sep;

	switch (want_type) {
	case ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:
		want_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;
		__LA_FALLTHROUGH;
	case ARCHIVE_ENTRY_ACL_TYPE_ACCESS:
	case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:
		numfields = 5;
		break;
	case ARCHIVE_ENTRY_ACL_TYPE_NFS4:
		numfields = 6;
		break;
	default:
		return (ARCHIVE_FATAL);
	}

	ret = ARCHIVE_OK;
	types = 0;

	while (text != NULL &&  *text != '\0') {
		/*
		 * Parse the fields out of the next entry,
		 * advance 'text' to start of next entry.
		 */
		fields = 0;
		do {
			const char *start, *end;
			next_field(&text, &start, &end, &sep);
			if (fields < numfields) {
				field[fields].start = start;
				field[fields].end = end;
			}
			++fields;
		} while (sep == ':');

		/* Set remaining fields to blank. */
		for (n = fields; n < numfields; ++n)
			field[n].start = field[n].end = NULL;

		if (field[0].start != NULL && *(field[0].start) == '#') {
			/* Comment, skip entry */
			continue;
		}

		n = 0;
		sol = 0;
		id = -1;
		permset = 0;
		name.start = name.end = NULL;

		if (want_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {
			/* POSIX.1e ACLs */
			/*
			 * Default keyword ""default:user::rwx""
			 * if found, we have one more field
			 *
			 * We also support old Solaris extension:
			 * ""defaultuser::rwx"" is the default ACL corresponding
			 * to ""user::rwx"", etc. valid only for first field
			 */
			s = field[0].start;
			len = field[0].end - field[0].start;
			if (*s == 'd' && (len == 1 || (len >= 7
			    && memcmp((s + 1), ""efault"", 6) == 0))) {
				type = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;
				if (len > 7)
					field[0].start += 7;
				else
					n = 1;
			} else
				type = want_type;

			/* Check for a numeric ID in field n+1 or n+3. */
			isint(field[n + 1].start, field[n + 1].end, &id);
			/* Field n+3 is optional. */
			if (id == -1 && fields > (n + 3))
				isint(field[n + 3].start, field[n + 3].end,
				    &id);

			tag = 0;
			s = field[n].start;
 			st = field[n].start + 1;
 			len = field[n].end - field[n].start;
 
 			switch (*s) {
 			case 'u':
 				if (len == 1 || (len == 4
				    && memcmp(st, ""ser"", 3) == 0))
					tag = ARCHIVE_ENTRY_ACL_USER_OBJ;
				break;
			case 'g':
				if (len == 1 || (len == 5
				    && memcmp(st, ""roup"", 4) == 0))
					tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;
				break;
			case 'o':
				if (len == 1 || (len == 5
				    && memcmp(st, ""ther"", 4) == 0))
					tag = ARCHIVE_ENTRY_ACL_OTHER;
				break;
			case 'm':
				if (len == 1 || (len == 4
				    && memcmp(st, ""ask"", 3) == 0))
					tag = ARCHIVE_ENTRY_ACL_MASK;
				break;
			default:
					break;
			}

			switch (tag) {
			case ARCHIVE_ENTRY_ACL_OTHER:
			case ARCHIVE_ENTRY_ACL_MASK:
				if (fields == (n + 2)
				    && field[n + 1].start < field[n + 1].end
				    && ismode(field[n + 1].start,
				    field[n + 1].end, &permset)) {
					/* This is Solaris-style ""other:rwx"" */
					sol = 1;
				} else if (fields == (n + 3) &&
				    field[n + 1].start < field[n + 1].end) {
					/* Invalid mask or other field */
					ret = ARCHIVE_WARN;
					continue;
				}
				break;
			case ARCHIVE_ENTRY_ACL_USER_OBJ:
			case ARCHIVE_ENTRY_ACL_GROUP_OBJ:
				if (id != -1 ||
				    field[n + 1].start < field[n + 1].end) {
					name = field[n + 1];
					if (tag == ARCHIVE_ENTRY_ACL_USER_OBJ)
						tag = ARCHIVE_ENTRY_ACL_USER;
					else
						tag = ARCHIVE_ENTRY_ACL_GROUP;
				}
				break;
			default:
				/* Invalid tag, skip entry */
				ret = ARCHIVE_WARN;
				continue;
			}

			/*
			 * Without ""default:"" we expect mode in field 3
			 * Exception: Solaris other and mask fields
			 */
			if (permset == 0 && !ismode(field[n + 2 - sol].start,
			    field[n + 2 - sol].end, &permset)) {
				/* Invalid mode, skip entry */
				ret = ARCHIVE_WARN;
				continue;
			}
		} else {
			/* NFS4 ACLs */
			s = field[0].start;
			len = field[0].end - field[0].start;
			tag = 0;

			switch (len) {
			case 4:
				if (memcmp(s, ""user"", 4) == 0)
					tag = ARCHIVE_ENTRY_ACL_USER;
				break;
			case 5:
				if (memcmp(s, ""group"", 5) == 0)
					tag = ARCHIVE_ENTRY_ACL_GROUP;
				break;
			case 6:
				if (memcmp(s, ""owner@"", 6) == 0)
					tag = ARCHIVE_ENTRY_ACL_USER_OBJ;
				else if (memcmp(s, ""group@"", 6) == 0)
					tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;
				break;
			case 9:
				if (memcmp(s, ""everyone@"", 9) == 0)
					tag = ARCHIVE_ENTRY_ACL_EVERYONE;
				break;
			default:
				break;
			}

			if (tag == 0) {
				/* Invalid tag, skip entry */
				ret = ARCHIVE_WARN;
				continue;
			} else if (tag == ARCHIVE_ENTRY_ACL_USER ||
			    tag == ARCHIVE_ENTRY_ACL_GROUP) {
				n = 1;
				name = field[1];
				isint(name.start, name.end, &id);
			} else
				n = 0;

			if (!is_nfs4_perms(field[1 + n].start,
			    field[1 + n].end, &permset)) {
				/* Invalid NFSv4 perms, skip entry */
				ret = ARCHIVE_WARN;
				continue;
			}
			if (!is_nfs4_flags(field[2 + n].start,
			    field[2 + n].end, &permset)) {
				/* Invalid NFSv4 flags, skip entry */
				ret = ARCHIVE_WARN;
				continue;
			}
			s = field[3 + n].start;
			len = field[3 + n].end - field[3 + n].start;
			type = 0;
			if (len == 4) {
				if (memcmp(s, ""deny"", 4) == 0)
					type = ARCHIVE_ENTRY_ACL_TYPE_DENY;
			} else if (len == 5) {
				if (memcmp(s, ""allow"", 5) == 0)
					type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;
				else if (memcmp(s, ""audit"", 5) == 0)
					type = ARCHIVE_ENTRY_ACL_TYPE_AUDIT;
				else if (memcmp(s, ""alarm"", 5) == 0)
					type = ARCHIVE_ENTRY_ACL_TYPE_ALARM;
			}
			if (type == 0) {
				/* Invalid entry type, skip entry */
				ret = ARCHIVE_WARN;
				continue;
			}
			isint(field[4 + n].start, field[4 + n].end,
			    &id);
		}

		/* Add entry to the internal list. */
		r = archive_acl_add_entry_len_l(acl, type, permset,
		    tag, id, name.start, name.end - name.start, sc);
		if (r < ARCHIVE_WARN)
			return (r);
		if (r != ARCHIVE_OK)
			ret = ARCHIVE_WARN;
		types |= type;
	}

	/* Reset ACL */
	archive_acl_reset(acl, types);

	return (ret);
}
",C,"			if (len == 0) {
				ret = ARCHIVE_WARN;
				continue;
			}

",,,"@@ -1723,6 +1723,11 @@ archive_acl_from_text_l(struct archive_acl *acl, const char *text,
 			st = field[n].start + 1;
 			len = field[n].end - field[n].start;
 
+			if (len == 0) {
+				ret = ARCHIVE_WARN;
+				continue;
+			}
+
 			switch (*s) {
 			case 'u':
 				if (len == 1 || (len == 4",libarchive,15bf44fd2c1ad0e3fd87048b3fcc90c4dcff1175,bfcfe6f04ed20db2504db8a254d1f40a1d84eb28,1,"archive_acl_from_text_l(struct archive_acl *acl, const char *text,
    int want_type, struct archive_string_conv *sc)
{
	struct {
		const char *start;
		const char *end;
	} field[6], name;

	const char *s, *st;
	int numfields, fields, n, r, sol, ret;
	int type, types, tag, permset, id;
	size_t len;
	char sep;

	switch (want_type) {
	case ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:
		want_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;
		__LA_FALLTHROUGH;
	case ARCHIVE_ENTRY_ACL_TYPE_ACCESS:
	case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:
		numfields = 5;
		break;
	case ARCHIVE_ENTRY_ACL_TYPE_NFS4:
		numfields = 6;
		break;
	default:
		return (ARCHIVE_FATAL);
	}

	ret = ARCHIVE_OK;
	types = 0;

	while (text != NULL &&  *text != '\0') {
		/*
		 * Parse the fields out of the next entry,
		 * advance 'text' to start of next entry.
		 */
		fields = 0;
		do {
			const char *start, *end;
			next_field(&text, &start, &end, &sep);
			if (fields < numfields) {
				field[fields].start = start;
				field[fields].end = end;
			}
			++fields;
		} while (sep == ':');

		/* Set remaining fields to blank. */
		for (n = fields; n < numfields; ++n)
			field[n].start = field[n].end = NULL;

		if (field[0].start != NULL && *(field[0].start) == '#') {
			/* Comment, skip entry */
			continue;
		}

		n = 0;
		sol = 0;
		id = -1;
		permset = 0;
		name.start = name.end = NULL;

		if (want_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {
			/* POSIX.1e ACLs */
			/*
			 * Default keyword ""default:user::rwx""
			 * if found, we have one more field
			 *
			 * We also support old Solaris extension:
			 * ""defaultuser::rwx"" is the default ACL corresponding
			 * to ""user::rwx"", etc. valid only for first field
			 */
			s = field[0].start;
			len = field[0].end - field[0].start;
			if (*s == 'd' && (len == 1 || (len >= 7
			    && memcmp((s + 1), ""efault"", 6) == 0))) {
				type = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;
				if (len > 7)
					field[0].start += 7;
				else
					n = 1;
			} else
				type = want_type;

			/* Check for a numeric ID in field n+1 or n+3. */
			isint(field[n + 1].start, field[n + 1].end, &id);
			/* Field n+3 is optional. */
			if (id == -1 && fields > (n + 3))
				isint(field[n + 3].start, field[n + 3].end,
				    &id);

			tag = 0;
			s = field[n].start;
 			st = field[n].start + 1;
 			len = field[n].end - field[n].start;
 
//fix_flaw_line_below:
//			if (len == 0) {
//fix_flaw_line_below:
//				ret = ARCHIVE_WARN;
//fix_flaw_line_below:
//				continue;
//fix_flaw_line_below:
//			}
//fix_flaw_line_below:
//
 			switch (*s) {
 			case 'u':
 				if (len == 1 || (len == 4
				    && memcmp(st, ""ser"", 3) == 0))
					tag = ARCHIVE_ENTRY_ACL_USER_OBJ;
				break;
			case 'g':
				if (len == 1 || (len == 5
				    && memcmp(st, ""roup"", 4) == 0))
					tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;
				break;
			case 'o':
				if (len == 1 || (len == 5
				    && memcmp(st, ""ther"", 4) == 0))
					tag = ARCHIVE_ENTRY_ACL_OTHER;
				break;
			case 'm':
				if (len == 1 || (len == 4
				    && memcmp(st, ""ask"", 3) == 0))
					tag = ARCHIVE_ENTRY_ACL_MASK;
				break;
			default:
					break;
			}

			switch (tag) {
			case ARCHIVE_ENTRY_ACL_OTHER:
			case ARCHIVE_ENTRY_ACL_MASK:
				if (fields == (n + 2)
				    && field[n + 1].start < field[n + 1].end
				    && ismode(field[n + 1].start,
				    field[n + 1].end, &permset)) {
					/* This is Solaris-style ""other:rwx"" */
					sol = 1;
				} else if (fields == (n + 3) &&
				    field[n + 1].start < field[n + 1].end) {
					/* Invalid mask or other field */
					ret = ARCHIVE_WARN;
					continue;
				}
				break;
			case ARCHIVE_ENTRY_ACL_USER_OBJ:
			case ARCHIVE_ENTRY_ACL_GROUP_OBJ:
				if (id != -1 ||
				    field[n + 1].start < field[n + 1].end) {
					name = field[n + 1];
					if (tag == ARCHIVE_ENTRY_ACL_USER_OBJ)
						tag = ARCHIVE_ENTRY_ACL_USER;
					else
						tag = ARCHIVE_ENTRY_ACL_GROUP;
				}
				break;
			default:
				/* Invalid tag, skip entry */
				ret = ARCHIVE_WARN;
				continue;
			}

			/*
			 * Without ""default:"" we expect mode in field 3
			 * Exception: Solaris other and mask fields
			 */
			if (permset == 0 && !ismode(field[n + 2 - sol].start,
			    field[n + 2 - sol].end, &permset)) {
				/* Invalid mode, skip entry */
				ret = ARCHIVE_WARN;
				continue;
			}
		} else {
			/* NFS4 ACLs */
			s = field[0].start;
			len = field[0].end - field[0].start;
			tag = 0;

			switch (len) {
			case 4:
				if (memcmp(s, ""user"", 4) == 0)
					tag = ARCHIVE_ENTRY_ACL_USER;
				break;
			case 5:
				if (memcmp(s, ""group"", 5) == 0)
					tag = ARCHIVE_ENTRY_ACL_GROUP;
				break;
			case 6:
				if (memcmp(s, ""owner@"", 6) == 0)
					tag = ARCHIVE_ENTRY_ACL_USER_OBJ;
				else if (memcmp(s, ""group@"", 6) == 0)
					tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;
				break;
			case 9:
				if (memcmp(s, ""everyone@"", 9) == 0)
					tag = ARCHIVE_ENTRY_ACL_EVERYONE;
				break;
			default:
				break;
			}

			if (tag == 0) {
				/* Invalid tag, skip entry */
				ret = ARCHIVE_WARN;
				continue;
			} else if (tag == ARCHIVE_ENTRY_ACL_USER ||
			    tag == ARCHIVE_ENTRY_ACL_GROUP) {
				n = 1;
				name = field[1];
				isint(name.start, name.end, &id);
			} else
				n = 0;

			if (!is_nfs4_perms(field[1 + n].start,
			    field[1 + n].end, &permset)) {
				/* Invalid NFSv4 perms, skip entry */
				ret = ARCHIVE_WARN;
				continue;
			}
			if (!is_nfs4_flags(field[2 + n].start,
			    field[2 + n].end, &permset)) {
				/* Invalid NFSv4 flags, skip entry */
				ret = ARCHIVE_WARN;
				continue;
			}
			s = field[3 + n].start;
			len = field[3 + n].end - field[3 + n].start;
			type = 0;
			if (len == 4) {
				if (memcmp(s, ""deny"", 4) == 0)
					type = ARCHIVE_ENTRY_ACL_TYPE_DENY;
			} else if (len == 5) {
				if (memcmp(s, ""allow"", 5) == 0)
					type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;
				else if (memcmp(s, ""audit"", 5) == 0)
					type = ARCHIVE_ENTRY_ACL_TYPE_AUDIT;
				else if (memcmp(s, ""alarm"", 5) == 0)
					type = ARCHIVE_ENTRY_ACL_TYPE_ALARM;
			}
			if (type == 0) {
				/* Invalid entry type, skip entry */
				ret = ARCHIVE_WARN;
				continue;
			}
			isint(field[4 + n].start, field[4 + n].end,
			    &id);
		}

		/* Add entry to the internal list. */
		r = archive_acl_add_entry_len_l(acl, type, permset,
		    tag, id, name.start, name.end - name.start, sc);
		if (r < ARCHIVE_WARN)
			return (r);
		if (r != ARCHIVE_OK)
			ret = ARCHIVE_WARN;
		types |= type;
	}

	/* Reset ACL */
	archive_acl_reset(acl, types);

	return (ret);
}
"
4439,182175,,Remote,Not required,Partial,CVE-2018-18585,https://www.cvedetails.com/cve/CVE-2018-18585/,CWE-476,Medium,,,,2018-10-22,4.3,chmd_read_headers in mspack/chmd.c in libmspack before 0.8alpha accepts a filename that has '0' as its first or second character (such as the */0* name).,2019-08-06,,3,https://github.com/kyz/libmspack/commit/8759da8db6ec9e866cb8eb143313f397f925bb4f,8759da8db6ec9e866cb8eb143313f397f925bb4f,"Avoid returning CHM file entries that are ""blank"" because they have embedded null bytes",2,libmspack/mspack/chmd.c,"{""sha"": ""a5873b69c26252fa830c3ce1dd76b5d13a73c34b"", ""filename"": ""libmspack/ChangeLog"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/kyz/libmspack/blob/8759da8db6ec9e866cb8eb143313f397f925bb4f/libmspack/ChangeLog"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/8759da8db6ec9e866cb8eb143313f397f925bb4f/libmspack/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/ChangeLog?ref=8759da8db6ec9e866cb8eb143313f397f925bb4f"", ""patch"": ""@@ -1,3 +1,9 @@\n+2018-10-17  Stuart Caie <kyzer@cabextract.org.uk>\n+  \n+        * chmd_read_headers(): again reject files with blank filenames, this\n+        time because their 1st or 2nd byte is null, not because their length\n+        is zero.  Thanks again to Hanno B\u00f6ck for finding the issue.\n+\n 2018-10-16  Stuart Caie <kyzer@cabextract.org.uk>\n \n \t* Makefile.am: using automake _DEPENDENCIES for chmd_test appears to""}<_**next**_>{""sha"": ""1d198bf75d2f2529126cb043ff7e03e40df886a5"", ""filename"": ""libmspack/mspack/chmd.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/kyz/libmspack/blob/8759da8db6ec9e866cb8eb143313f397f925bb4f/libmspack/mspack/chmd.c"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/8759da8db6ec9e866cb8eb143313f397f925bb4f/libmspack/mspack/chmd.c"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/mspack/chmd.c?ref=8759da8db6ec9e866cb8eb143313f397f925bb4f"", ""patch"": ""@@ -447,14 +447,14 @@ static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,\n     while (num_entries--) {\n       READ_ENCINT(name_len);\n       if (name_len > (unsigned int) (end - p)) goto chunk_end;\n-      /* consider blank filenames to be an error */\n-      if (name_len == 0) goto chunk_end;\n       name = p; p += name_len;\n-\n       READ_ENCINT(section);\n       READ_ENCINT(offset);\n       READ_ENCINT(length);\n \n+      /* ignore blank or one-char (e.g. \""/\"") filenames we'd return as blank */\n+      if (name_len < 2 || !name[0] || !name[1]) continue;\n+\n       /* empty files and directory names are stored as a file entry at\n        * offset 0 with length 0. We want to keep empty files, but not\n        * directory names, which end with a \""/\"" */""}","static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,
			     struct mschmd_header *chm, int entire)
{
  unsigned int section, name_len, x, errors, num_chunks;
  unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;
  struct mschmd_file *fi, *link = NULL;
  off_t offset, length;
  int num_entries;

  /* initialise pointers */
  chm->files         = NULL;
  chm->sysfiles      = NULL;
  chm->chunk_cache   = NULL;
  chm->sec0.base.chm = chm;
  chm->sec0.base.id  = 0;
  chm->sec1.base.chm = chm;
  chm->sec1.base.id  = 1;
  chm->sec1.content  = NULL;
  chm->sec1.control  = NULL;
  chm->sec1.spaninfo = NULL;
  chm->sec1.rtable   = NULL;

  /* read the first header */
  if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {
    return MSPACK_ERR_READ;
  }

  /* check ITSF signature */
  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {
    return MSPACK_ERR_SIGNATURE;
  }

  /* check both header GUIDs */
  if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {
    D((""incorrect GUIDs""))
    return MSPACK_ERR_SIGNATURE;
  }

  chm->version   = EndGetI32(&buf[chmhead_Version]);
  chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);
  chm->language  = EndGetI32(&buf[chmhead_LanguageID]);
  if (chm->version > 3) {
    sys->message(fh, ""WARNING; CHM version > 3"");
  }

  /* read the header section table */
  if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {
    return MSPACK_ERR_READ;
  }

  /* chmhst3_OffsetCS0 does not exist in version 1 or 2 CHM files.
   * The offset will be corrected later, once HS1 is read.
   */
  if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||
      read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||
      read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))
  {
    return MSPACK_ERR_DATAFORMAT;
  }

  /* seek to header section 0 */
  if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {
    return MSPACK_ERR_SEEK;
  }

  /* read header section 0 */
  if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {
    return MSPACK_ERR_READ;
  }
  if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {
    return MSPACK_ERR_DATAFORMAT;
  }

  /* seek to header section 1 */
  if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {
    return MSPACK_ERR_SEEK;
  }

  /* read header section 1 */
  if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {
    return MSPACK_ERR_READ;
  }

  chm->dir_offset = sys->tell(fh);
  chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);
  chm->density    = EndGetI32(&buf[chmhs1_Density]);
  chm->depth      = EndGetI32(&buf[chmhs1_Depth]);
  chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);
  chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);
  chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);
  chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);

  if (chm->version < 3) {
    /* versions before 3 don't have chmhst3_OffsetCS0 */
    chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);
  }

  /* check if content offset or file size is wrong */
  if (chm->sec0.offset > chm->length) {
    D((""content section begins after file has ended""))
    return MSPACK_ERR_DATAFORMAT;
  }
  
  /* ensure there are chunks and that chunk size is
   * large enough for signature and num_entries */
  if (chm->chunk_size < (pmgl_Entries + 2)) {
    D((""chunk size not large enough""))
    return MSPACK_ERR_DATAFORMAT;
  }
  if (chm->num_chunks == 0) {
    D((""no chunks""))
    return MSPACK_ERR_DATAFORMAT;
  }

  /* The chunk_cache data structure is not great; large values for num_chunks
   * or num_chunks*chunk_size can exhaust all memory. Until a better chunk
   * cache is implemented, put arbitrary limits on num_chunks and chunk size.
   */
  if (chm->num_chunks > 100000) {
    D((""more than 100,000 chunks""))
    return MSPACK_ERR_DATAFORMAT;
  }   
  if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {
    D((""chunks larger than entire file""))
    return MSPACK_ERR_DATAFORMAT;
  }

  /* common sense checks on header section 1 fields */
  if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {
    sys->message(fh, ""WARNING; chunk size is not a power of two"");
  }
  if (chm->first_pmgl != 0) {
    sys->message(fh, ""WARNING; first PMGL chunk is not zero"");
  }
  if (chm->first_pmgl > chm->last_pmgl) {
    D((""first pmgl chunk is after last pmgl chunk""))
    return MSPACK_ERR_DATAFORMAT;
  }
  if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) {
    D((""index_root outside valid range""))
    return MSPACK_ERR_DATAFORMAT;
  }

  /* if we are doing a quick read, stop here! */
  if (!entire) {
    return MSPACK_ERR_OK;
  }

  /* seek to the first PMGL chunk, and reduce the number of chunks to read */
  if ((x = chm->first_pmgl) != 0) {
    if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {
      return MSPACK_ERR_SEEK;
    }
  }
  num_chunks = chm->last_pmgl - x + 1;

  if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {
    return MSPACK_ERR_NOMEMORY;
  }

  /* read and process all chunks from FirstPMGL to LastPMGL */
  errors = 0;
  while (num_chunks--) {
    /* read next chunk */
    if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {
      sys->free(chunk);
      return MSPACK_ERR_READ;
    }

    /* process only directory (PMGL) chunks */
    if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;

    if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {
      sys->message(fh, ""WARNING; PMGL quickref area is too small"");
    }
    if (EndGetI32(&chunk[pmgl_QuickRefSize]) > 
	((int)chm->chunk_size - pmgl_Entries))
    {
      sys->message(fh, ""WARNING; PMGL quickref area is too large"");
    }

    p = &chunk[pmgl_Entries];
    end = &chunk[chm->chunk_size - 2];
    num_entries = EndGetI16(end);

     while (num_entries--) {
       READ_ENCINT(name_len);
       if (name_len > (unsigned int) (end - p)) goto chunk_end;
       name = p; p += name_len;
       READ_ENCINT(section);
       READ_ENCINT(offset);
       READ_ENCINT(length);
 
      /* ignore blank or one-char (e.g. ""/"") filenames we'd return as blank */
      if (name_len < 2 || !name[0] || !name[1]) continue;

       /* empty files and directory names are stored as a file entry at
        * offset 0 with length 0. We want to keep empty files, but not
        * directory names, which end with a ""/"" */
      if ((offset == 0) && (length == 0)) {
	if ((name_len > 0) && (name[name_len-1] == '/')) continue;
      }

      if (section > 1) {
	sys->message(fh, ""invalid section number '%u'."", section);
	continue;
      }

      if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {
	sys->free(chunk);
	return MSPACK_ERR_NOMEMORY;
      }

      fi->next     = NULL;
      fi->filename = (char *) &fi[1];
      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)
		                     : (struct mschmd_section *) (&chm->sec1));
      fi->offset   = offset;
      fi->length   = length;
      sys->copy(name, fi->filename, (size_t) name_len);
      fi->filename[name_len] = '\0';

      if (name[0] == ':' && name[1] == ':') {
	/* system file */
	if (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) {
	  if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) {
	    chm->sec1.content = fi;
	  }
	  else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) {
	    chm->sec1.control = fi;
	  }
	  else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {
	    chm->sec1.spaninfo = fi;
	  }
	  else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) {
	    chm->sec1.rtable = fi;
	  }
	}
	fi->next = chm->sysfiles;
	chm->sysfiles = fi;
      }
      else {
	/* normal file */
	if (link) link->next = fi; else chm->files = fi;
	link = fi;
      }
    }

    /* this is reached either when num_entries runs out, or if
     * reading data from the chunk reached a premature end of chunk */
  chunk_end:
    if (num_entries >= 0) {
      D((""chunk ended before all entries could be read""))
      errors++;
    }

  }
  sys->free(chunk);
  return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;
}
","static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,
			     struct mschmd_header *chm, int entire)
{
  unsigned int section, name_len, x, errors, num_chunks;
  unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;
  struct mschmd_file *fi, *link = NULL;
  off_t offset, length;
  int num_entries;

  /* initialise pointers */
  chm->files         = NULL;
  chm->sysfiles      = NULL;
  chm->chunk_cache   = NULL;
  chm->sec0.base.chm = chm;
  chm->sec0.base.id  = 0;
  chm->sec1.base.chm = chm;
  chm->sec1.base.id  = 1;
  chm->sec1.content  = NULL;
  chm->sec1.control  = NULL;
  chm->sec1.spaninfo = NULL;
  chm->sec1.rtable   = NULL;

  /* read the first header */
  if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {
    return MSPACK_ERR_READ;
  }

  /* check ITSF signature */
  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {
    return MSPACK_ERR_SIGNATURE;
  }

  /* check both header GUIDs */
  if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {
    D((""incorrect GUIDs""))
    return MSPACK_ERR_SIGNATURE;
  }

  chm->version   = EndGetI32(&buf[chmhead_Version]);
  chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);
  chm->language  = EndGetI32(&buf[chmhead_LanguageID]);
  if (chm->version > 3) {
    sys->message(fh, ""WARNING; CHM version > 3"");
  }

  /* read the header section table */
  if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {
    return MSPACK_ERR_READ;
  }

  /* chmhst3_OffsetCS0 does not exist in version 1 or 2 CHM files.
   * The offset will be corrected later, once HS1 is read.
   */
  if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||
      read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||
      read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))
  {
    return MSPACK_ERR_DATAFORMAT;
  }

  /* seek to header section 0 */
  if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {
    return MSPACK_ERR_SEEK;
  }

  /* read header section 0 */
  if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {
    return MSPACK_ERR_READ;
  }
  if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {
    return MSPACK_ERR_DATAFORMAT;
  }

  /* seek to header section 1 */
  if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {
    return MSPACK_ERR_SEEK;
  }

  /* read header section 1 */
  if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {
    return MSPACK_ERR_READ;
  }

  chm->dir_offset = sys->tell(fh);
  chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);
  chm->density    = EndGetI32(&buf[chmhs1_Density]);
  chm->depth      = EndGetI32(&buf[chmhs1_Depth]);
  chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);
  chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);
  chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);
  chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);

  if (chm->version < 3) {
    /* versions before 3 don't have chmhst3_OffsetCS0 */
    chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);
  }

  /* check if content offset or file size is wrong */
  if (chm->sec0.offset > chm->length) {
    D((""content section begins after file has ended""))
    return MSPACK_ERR_DATAFORMAT;
  }
  
  /* ensure there are chunks and that chunk size is
   * large enough for signature and num_entries */
  if (chm->chunk_size < (pmgl_Entries + 2)) {
    D((""chunk size not large enough""))
    return MSPACK_ERR_DATAFORMAT;
  }
  if (chm->num_chunks == 0) {
    D((""no chunks""))
    return MSPACK_ERR_DATAFORMAT;
  }

  /* The chunk_cache data structure is not great; large values for num_chunks
   * or num_chunks*chunk_size can exhaust all memory. Until a better chunk
   * cache is implemented, put arbitrary limits on num_chunks and chunk size.
   */
  if (chm->num_chunks > 100000) {
    D((""more than 100,000 chunks""))
    return MSPACK_ERR_DATAFORMAT;
  }   
  if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {
    D((""chunks larger than entire file""))
    return MSPACK_ERR_DATAFORMAT;
  }

  /* common sense checks on header section 1 fields */
  if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {
    sys->message(fh, ""WARNING; chunk size is not a power of two"");
  }
  if (chm->first_pmgl != 0) {
    sys->message(fh, ""WARNING; first PMGL chunk is not zero"");
  }
  if (chm->first_pmgl > chm->last_pmgl) {
    D((""first pmgl chunk is after last pmgl chunk""))
    return MSPACK_ERR_DATAFORMAT;
  }
  if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) {
    D((""index_root outside valid range""))
    return MSPACK_ERR_DATAFORMAT;
  }

  /* if we are doing a quick read, stop here! */
  if (!entire) {
    return MSPACK_ERR_OK;
  }

  /* seek to the first PMGL chunk, and reduce the number of chunks to read */
  if ((x = chm->first_pmgl) != 0) {
    if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {
      return MSPACK_ERR_SEEK;
    }
  }
  num_chunks = chm->last_pmgl - x + 1;

  if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {
    return MSPACK_ERR_NOMEMORY;
  }

  /* read and process all chunks from FirstPMGL to LastPMGL */
  errors = 0;
  while (num_chunks--) {
    /* read next chunk */
    if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {
      sys->free(chunk);
      return MSPACK_ERR_READ;
    }

    /* process only directory (PMGL) chunks */
    if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;

    if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {
      sys->message(fh, ""WARNING; PMGL quickref area is too small"");
    }
    if (EndGetI32(&chunk[pmgl_QuickRefSize]) > 
	((int)chm->chunk_size - pmgl_Entries))
    {
      sys->message(fh, ""WARNING; PMGL quickref area is too large"");
    }

    p = &chunk[pmgl_Entries];
    end = &chunk[chm->chunk_size - 2];
    num_entries = EndGetI16(end);

     while (num_entries--) {
       READ_ENCINT(name_len);
       if (name_len > (unsigned int) (end - p)) goto chunk_end;
      /* consider blank filenames to be an error */
      if (name_len == 0) goto chunk_end;
       name = p; p += name_len;
       READ_ENCINT(section);
       READ_ENCINT(offset);
       READ_ENCINT(length);
 
       /* empty files and directory names are stored as a file entry at
        * offset 0 with length 0. We want to keep empty files, but not
        * directory names, which end with a ""/"" */
      if ((offset == 0) && (length == 0)) {
	if ((name_len > 0) && (name[name_len-1] == '/')) continue;
      }

      if (section > 1) {
	sys->message(fh, ""invalid section number '%u'."", section);
	continue;
      }

      if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {
	sys->free(chunk);
	return MSPACK_ERR_NOMEMORY;
      }

      fi->next     = NULL;
      fi->filename = (char *) &fi[1];
      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)
		                     : (struct mschmd_section *) (&chm->sec1));
      fi->offset   = offset;
      fi->length   = length;
      sys->copy(name, fi->filename, (size_t) name_len);
      fi->filename[name_len] = '\0';

      if (name[0] == ':' && name[1] == ':') {
	/* system file */
	if (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) {
	  if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) {
	    chm->sec1.content = fi;
	  }
	  else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) {
	    chm->sec1.control = fi;
	  }
	  else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {
	    chm->sec1.spaninfo = fi;
	  }
	  else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) {
	    chm->sec1.rtable = fi;
	  }
	}
	fi->next = chm->sysfiles;
	chm->sysfiles = fi;
      }
      else {
	/* normal file */
	if (link) link->next = fi; else chm->files = fi;
	link = fi;
      }
    }

    /* this is reached either when num_entries runs out, or if
     * reading data from the chunk reached a premature end of chunk */
  chunk_end:
    if (num_entries >= 0) {
      D((""chunk ended before all entries could be read""))
      errors++;
    }

  }
  sys->free(chunk);
  return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;
}
",C,"      /* ignore blank or one-char (e.g. ""/"") filenames we'd return as blank */
      if (name_len < 2 || !name[0] || !name[1]) continue;

","      /* consider blank filenames to be an error */
      if (name_len == 0) goto chunk_end;
",,"@@ -447,14 +447,14 @@ static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,
     while (num_entries--) {
       READ_ENCINT(name_len);
       if (name_len > (unsigned int) (end - p)) goto chunk_end;
-      /* consider blank filenames to be an error */
-      if (name_len == 0) goto chunk_end;
       name = p; p += name_len;
-
       READ_ENCINT(section);
       READ_ENCINT(offset);
       READ_ENCINT(length);
 
+      /* ignore blank or one-char (e.g. ""/"") filenames we'd return as blank */
+      if (name_len < 2 || !name[0] || !name[1]) continue;
+
       /* empty files and directory names are stored as a file entry at
        * offset 0 with length 0. We want to keep empty files, but not
        * directory names, which end with a ""/"" */",libmspack,8759da8db6ec9e866cb8eb143313f397f925bb4f,944cc107cf8aa0f1537f13a7795bc619cf674c94,1,"static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,
			     struct mschmd_header *chm, int entire)
{
  unsigned int section, name_len, x, errors, num_chunks;
  unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;
  struct mschmd_file *fi, *link = NULL;
  off_t offset, length;
  int num_entries;

  /* initialise pointers */
  chm->files         = NULL;
  chm->sysfiles      = NULL;
  chm->chunk_cache   = NULL;
  chm->sec0.base.chm = chm;
  chm->sec0.base.id  = 0;
  chm->sec1.base.chm = chm;
  chm->sec1.base.id  = 1;
  chm->sec1.content  = NULL;
  chm->sec1.control  = NULL;
  chm->sec1.spaninfo = NULL;
  chm->sec1.rtable   = NULL;

  /* read the first header */
  if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {
    return MSPACK_ERR_READ;
  }

  /* check ITSF signature */
  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {
    return MSPACK_ERR_SIGNATURE;
  }

  /* check both header GUIDs */
  if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {
    D((""incorrect GUIDs""))
    return MSPACK_ERR_SIGNATURE;
  }

  chm->version   = EndGetI32(&buf[chmhead_Version]);
  chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);
  chm->language  = EndGetI32(&buf[chmhead_LanguageID]);
  if (chm->version > 3) {
    sys->message(fh, ""WARNING; CHM version > 3"");
  }

  /* read the header section table */
  if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {
    return MSPACK_ERR_READ;
  }

  /* chmhst3_OffsetCS0 does not exist in version 1 or 2 CHM files.
   * The offset will be corrected later, once HS1 is read.
   */
  if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||
      read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||
      read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))
  {
    return MSPACK_ERR_DATAFORMAT;
  }

  /* seek to header section 0 */
  if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {
    return MSPACK_ERR_SEEK;
  }

  /* read header section 0 */
  if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {
    return MSPACK_ERR_READ;
  }
  if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {
    return MSPACK_ERR_DATAFORMAT;
  }

  /* seek to header section 1 */
  if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {
    return MSPACK_ERR_SEEK;
  }

  /* read header section 1 */
  if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {
    return MSPACK_ERR_READ;
  }

  chm->dir_offset = sys->tell(fh);
  chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);
  chm->density    = EndGetI32(&buf[chmhs1_Density]);
  chm->depth      = EndGetI32(&buf[chmhs1_Depth]);
  chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);
  chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);
  chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);
  chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);

  if (chm->version < 3) {
    /* versions before 3 don't have chmhst3_OffsetCS0 */
    chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);
  }

  /* check if content offset or file size is wrong */
  if (chm->sec0.offset > chm->length) {
    D((""content section begins after file has ended""))
    return MSPACK_ERR_DATAFORMAT;
  }
  
  /* ensure there are chunks and that chunk size is
   * large enough for signature and num_entries */
  if (chm->chunk_size < (pmgl_Entries + 2)) {
    D((""chunk size not large enough""))
    return MSPACK_ERR_DATAFORMAT;
  }
  if (chm->num_chunks == 0) {
    D((""no chunks""))
    return MSPACK_ERR_DATAFORMAT;
  }

  /* The chunk_cache data structure is not great; large values for num_chunks
   * or num_chunks*chunk_size can exhaust all memory. Until a better chunk
   * cache is implemented, put arbitrary limits on num_chunks and chunk size.
   */
  if (chm->num_chunks > 100000) {
    D((""more than 100,000 chunks""))
    return MSPACK_ERR_DATAFORMAT;
  }   
  if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {
    D((""chunks larger than entire file""))
    return MSPACK_ERR_DATAFORMAT;
  }

  /* common sense checks on header section 1 fields */
  if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {
    sys->message(fh, ""WARNING; chunk size is not a power of two"");
  }
  if (chm->first_pmgl != 0) {
    sys->message(fh, ""WARNING; first PMGL chunk is not zero"");
  }
  if (chm->first_pmgl > chm->last_pmgl) {
    D((""first pmgl chunk is after last pmgl chunk""))
    return MSPACK_ERR_DATAFORMAT;
  }
  if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) {
    D((""index_root outside valid range""))
    return MSPACK_ERR_DATAFORMAT;
  }

  /* if we are doing a quick read, stop here! */
  if (!entire) {
    return MSPACK_ERR_OK;
  }

  /* seek to the first PMGL chunk, and reduce the number of chunks to read */
  if ((x = chm->first_pmgl) != 0) {
    if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {
      return MSPACK_ERR_SEEK;
    }
  }
  num_chunks = chm->last_pmgl - x + 1;

  if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {
    return MSPACK_ERR_NOMEMORY;
  }

  /* read and process all chunks from FirstPMGL to LastPMGL */
  errors = 0;
  while (num_chunks--) {
    /* read next chunk */
    if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {
      sys->free(chunk);
      return MSPACK_ERR_READ;
    }

    /* process only directory (PMGL) chunks */
    if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;

    if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {
      sys->message(fh, ""WARNING; PMGL quickref area is too small"");
    }
    if (EndGetI32(&chunk[pmgl_QuickRefSize]) > 
	((int)chm->chunk_size - pmgl_Entries))
    {
      sys->message(fh, ""WARNING; PMGL quickref area is too large"");
    }

    p = &chunk[pmgl_Entries];
    end = &chunk[chm->chunk_size - 2];
    num_entries = EndGetI16(end);

     while (num_entries--) {
       READ_ENCINT(name_len);
       if (name_len > (unsigned int) (end - p)) goto chunk_end;
//flaw_line_below:
      /* consider blank filenames to be an error */
//flaw_line_below:
      if (name_len == 0) goto chunk_end;
       name = p; p += name_len;
//flaw_line_below:

       READ_ENCINT(section);
       READ_ENCINT(offset);
       READ_ENCINT(length);
 
//fix_flaw_line_below:
//      /* ignore blank or one-char (e.g. ""/"") filenames we'd return as blank */
//fix_flaw_line_below:
//      if (name_len < 2 || !name[0] || !name[1]) continue;
//fix_flaw_line_below:
//
       /* empty files and directory names are stored as a file entry at
        * offset 0 with length 0. We want to keep empty files, but not
        * directory names, which end with a ""/"" */
      if ((offset == 0) && (length == 0)) {
	if ((name_len > 0) && (name[name_len-1] == '/')) continue;
      }

      if (section > 1) {
	sys->message(fh, ""invalid section number '%u'."", section);
	continue;
      }

      if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {
	sys->free(chunk);
	return MSPACK_ERR_NOMEMORY;
      }

      fi->next     = NULL;
      fi->filename = (char *) &fi[1];
      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)
		                     : (struct mschmd_section *) (&chm->sec1));
      fi->offset   = offset;
      fi->length   = length;
      sys->copy(name, fi->filename, (size_t) name_len);
      fi->filename[name_len] = '\0';

      if (name[0] == ':' && name[1] == ':') {
	/* system file */
	if (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) {
	  if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) {
	    chm->sec1.content = fi;
	  }
	  else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) {
	    chm->sec1.control = fi;
	  }
	  else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {
	    chm->sec1.spaninfo = fi;
	  }
	  else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) {
	    chm->sec1.rtable = fi;
	  }
	}
	fi->next = chm->sysfiles;
	chm->sysfiles = fi;
      }
      else {
	/* normal file */
	if (link) link->next = fi; else chm->files = fi;
	link = fi;
      }
    }

    /* this is reached either when num_entries runs out, or if
     * reading data from the chunk reached a premature end of chunk */
  chunk_end:
    if (num_entries >= 0) {
      D((""chunk ended before all entries could be read""))
      errors++;
    }

  }
  sys->free(chunk);
  return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;
}
"
4524,182260,,Local,Not required,Partial,CVE-2018-15863,https://www.cvedetails.com/cve/CVE-2018-15863/,CWE-476,Low,,,,2018-08-25,2.1,Unchecked NULL pointer usage in ResolveStateAndPredicate in xkbcomp/compat.c in xkbcommon before 0.8.2 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file with a no-op modmask expression.,2019-08-06,,2,https://github.com/xkbcommon/libxkbcommon/commit/96df3106d49438e442510c59acad306e94f3db4d,96df3106d49438e442510c59acad306e94f3db4d,"xkbcomp: Don't crash on no-op modmask expressions

If we have an expression of the form 'l1' in an interp section, we
unconditionally try to dereference its args, even if it has none.

Signed-off-by: Daniel Stone <daniels@collabora.com>",1,src/xkbcomp/compat.c,"{""sha"": ""bd587c8db94cfc92abb30e90a7826c172ba6f941"", ""filename"": ""src/xkbcomp/compat.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/xkbcommon/libxkbcommon/blob/96df3106d49438e442510c59acad306e94f3db4d/src/xkbcomp/compat.c"", ""raw_url"": ""https://github.com/xkbcommon/libxkbcommon/raw/96df3106d49438e442510c59acad306e94f3db4d/src/xkbcomp/compat.c"", ""contents_url"": ""https://api.github.com/repos/xkbcommon/libxkbcommon/contents/src/xkbcomp/compat.c?ref=96df3106d49438e442510c59acad306e94f3db4d"", ""patch"": ""@@ -264,7 +264,8 @@ ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n     *pred_rtrn = MATCH_EXACTLY;\n     if (expr->expr.op == EXPR_ACTION_DECL) {\n         const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n-        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {\n+        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn) ||\n+            !expr->action.args) {\n             log_err(info->ctx,\n                     \""Illegal modifier predicate \\\""%s\\\""; Ignored\\n\"", pred_txt);\n             return false;""}","ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,
                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)
{
    if (expr == NULL) {
        *pred_rtrn = MATCH_ANY_OR_NONE;
        *mods_rtrn = MOD_REAL_MASK_ALL;
        return true;
    }

     *pred_rtrn = MATCH_EXACTLY;
     if (expr->expr.op == EXPR_ACTION_DECL) {
         const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);
        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn) ||
            !expr->action.args) {
             log_err(info->ctx,
                     ""Illegal modifier predicate \""%s\""; Ignored\n"", pred_txt);
             return false;
        }
        expr = expr->action.args;
    }
    else if (expr->expr.op == EXPR_IDENT) {
        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);
        if (pred_txt && istreq(pred_txt, ""any"")) {
            *pred_rtrn = MATCH_ANY;
            *mods_rtrn = MOD_REAL_MASK_ALL;
            return true;
        }
    }

    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,
                              mods_rtrn);
}
","ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,
                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)
{
    if (expr == NULL) {
        *pred_rtrn = MATCH_ANY_OR_NONE;
        *mods_rtrn = MOD_REAL_MASK_ALL;
        return true;
    }

     *pred_rtrn = MATCH_EXACTLY;
     if (expr->expr.op == EXPR_ACTION_DECL) {
         const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);
        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {
             log_err(info->ctx,
                     ""Illegal modifier predicate \""%s\""; Ignored\n"", pred_txt);
             return false;
        }
        expr = expr->action.args;
    }
    else if (expr->expr.op == EXPR_IDENT) {
        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);
        if (pred_txt && istreq(pred_txt, ""any"")) {
            *pred_rtrn = MATCH_ANY;
            *mods_rtrn = MOD_REAL_MASK_ALL;
            return true;
        }
    }

    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,
                              mods_rtrn);
}
",C,"        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn) ||
            !expr->action.args) {
","        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {
",,"@@ -264,7 +264,8 @@ ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,
     *pred_rtrn = MATCH_EXACTLY;
     if (expr->expr.op == EXPR_ACTION_DECL) {
         const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);
-        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {
+        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn) ||
+            !expr->action.args) {
             log_err(info->ctx,
                     ""Illegal modifier predicate \""%s\""; Ignored\n"", pred_txt);
             return false;",libxkbcommon,96df3106d49438e442510c59acad306e94f3db4d,a8ea7a1d3daa7bdcb877615ae0a252c189153bd2,1,"ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,
                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)
{
    if (expr == NULL) {
        *pred_rtrn = MATCH_ANY_OR_NONE;
        *mods_rtrn = MOD_REAL_MASK_ALL;
        return true;
    }

     *pred_rtrn = MATCH_EXACTLY;
     if (expr->expr.op == EXPR_ACTION_DECL) {
         const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);
//flaw_line_below:
        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {
//fix_flaw_line_below:
//        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn) ||
//fix_flaw_line_below:
//            !expr->action.args) {
             log_err(info->ctx,
                     ""Illegal modifier predicate \""%s\""; Ignored\n"", pred_txt);
             return false;
        }
        expr = expr->action.args;
    }
    else if (expr->expr.op == EXPR_IDENT) {
        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);
        if (pred_txt && istreq(pred_txt, ""any"")) {
            *pred_rtrn = MATCH_ANY;
            *mods_rtrn = MOD_REAL_MASK_ALL;
            return true;
        }
    }

    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,
                              mods_rtrn);
}
"
4525,182261,,Local,Not required,Partial,CVE-2018-15862,https://www.cvedetails.com/cve/CVE-2018-15862/,CWE-476,Low,,,,2018-08-25,2.1,Unchecked NULL pointer usage in LookupModMask in xkbcomp/expr.c in xkbcommon before 0.8.2 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file with invalid virtual modifiers.,2019-08-06,,2,https://github.com/xkbcommon/libxkbcommon/commit/4e2ee9c3f6050d773f8bbe05bc0edb17f1ff8371,4e2ee9c3f6050d773f8bbe05bc0edb17f1ff8371,"xkbcomp: Don't explode on invalid virtual modifiers

testcase: 'virtualModifiers=LevelThreC'

Signed-off-by: Daniel Stone <daniels@collabora.com>",0,src/xkbcomp/expr.c,"{""sha"": ""91713daecb623dee395cb89da7cbceb115fee80e"", ""filename"": ""src/xkbcomp/expr.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/xkbcommon/libxkbcommon/blob/4e2ee9c3f6050d773f8bbe05bc0edb17f1ff8371/src/xkbcomp/expr.c"", ""raw_url"": ""https://github.com/xkbcommon/libxkbcommon/raw/4e2ee9c3f6050d773f8bbe05bc0edb17f1ff8371/src/xkbcomp/expr.c"", ""contents_url"": ""https://api.github.com/repos/xkbcommon/libxkbcommon/contents/src/xkbcomp/expr.c?ref=4e2ee9c3f6050d773f8bbe05bc0edb17f1ff8371"", ""patch"": ""@@ -101,6 +101,8 @@ LookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,\n         return false;\n \n     str = xkb_atom_text(ctx, field);\n+    if (!str)\n+        return false;\n \n     if (istreq(str, \""all\"")) {\n         *val_rtrn  = MOD_REAL_MASK_ALL;""}","LookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,
              enum expr_value_type type, xkb_mod_mask_t *val_rtrn)
{
    const char *str;
    xkb_mod_index_t ndx;
    const LookupModMaskPriv *arg = priv;
    const struct xkb_mod_set *mods = arg->mods;
    enum mod_type mod_type = arg->mod_type;

    if (type != EXPR_TYPE_INT)
         return false;
 
     str = xkb_atom_text(ctx, field);
    if (!str)
        return false;
 
     if (istreq(str, ""all"")) {
         *val_rtrn  = MOD_REAL_MASK_ALL;
        return true;
    }

    if (istreq(str, ""none"")) {
        *val_rtrn = 0;
        return true;
    }

    ndx = XkbModNameToIndex(mods, field, mod_type);
    if (ndx == XKB_MOD_INVALID)
        return false;

    *val_rtrn = (1u << ndx);
    return true;
}
","LookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,
              enum expr_value_type type, xkb_mod_mask_t *val_rtrn)
{
    const char *str;
    xkb_mod_index_t ndx;
    const LookupModMaskPriv *arg = priv;
    const struct xkb_mod_set *mods = arg->mods;
    enum mod_type mod_type = arg->mod_type;

    if (type != EXPR_TYPE_INT)
         return false;
 
     str = xkb_atom_text(ctx, field);
 
     if (istreq(str, ""all"")) {
         *val_rtrn  = MOD_REAL_MASK_ALL;
        return true;
    }

    if (istreq(str, ""none"")) {
        *val_rtrn = 0;
        return true;
    }

    ndx = XkbModNameToIndex(mods, field, mod_type);
    if (ndx == XKB_MOD_INVALID)
        return false;

    *val_rtrn = (1u << ndx);
    return true;
}
",C,"    if (!str)
        return false;
",,,"@@ -101,6 +101,8 @@ LookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,
         return false;
 
     str = xkb_atom_text(ctx, field);
+    if (!str)
+        return false;
 
     if (istreq(str, ""all"")) {
         *val_rtrn  = MOD_REAL_MASK_ALL;",libxkbcommon,4e2ee9c3f6050d773f8bbe05bc0edb17f1ff8371,96df3106d49438e442510c59acad306e94f3db4d,1,"LookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,
              enum expr_value_type type, xkb_mod_mask_t *val_rtrn)
{
    const char *str;
    xkb_mod_index_t ndx;
    const LookupModMaskPriv *arg = priv;
    const struct xkb_mod_set *mods = arg->mods;
    enum mod_type mod_type = arg->mod_type;

    if (type != EXPR_TYPE_INT)
         return false;
 
     str = xkb_atom_text(ctx, field);
//fix_flaw_line_below:
//    if (!str)
//fix_flaw_line_below:
//        return false;
 
     if (istreq(str, ""all"")) {
         *val_rtrn  = MOD_REAL_MASK_ALL;
        return true;
    }

    if (istreq(str, ""none"")) {
        *val_rtrn = 0;
        return true;
    }

    ndx = XkbModNameToIndex(mods, field, mod_type);
    if (ndx == XKB_MOD_INVALID)
        return false;

    *val_rtrn = (1u << ndx);
    return true;
}
"
4526,182262,,Local,Not required,Partial,CVE-2018-15861,https://www.cvedetails.com/cve/CVE-2018-15861/,CWE-476,Low,,,,2018-08-25,2.1,Unchecked NULL pointer usage in ExprResolveLhs in xkbcomp/expr.c in xkbcommon before 0.8.2 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file that triggers an xkb_intern_atom failure.,2019-08-06,,1,https://github.com/xkbcommon/libxkbcommon/commit/38e1766bc6e20108948aec8a0b222a4bad0254e9,38e1766bc6e20108948aec8a0b222a4bad0254e9,"xkbcomp: Don't falsely promise from ExprResolveLhs

Every user of ExprReturnLhs goes on to unconditionally dereference the
field return, which can be NULL if xkb_intern_atom fails. Return false
if this is the case, so we fail safely.

testcase: splice geometry data into interp

Signed-off-by: Daniel Stone <daniels@collabora.com>",1,src/xkbcomp/expr.c,"{""sha"": ""b5ab7170858049e1edf5cd665604fc4cf701fdd4"", ""filename"": ""src/xkbcomp/expr.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/xkbcommon/libxkbcommon/blob/38e1766bc6e20108948aec8a0b222a4bad0254e9/src/xkbcomp/expr.c"", ""raw_url"": ""https://github.com/xkbcommon/libxkbcommon/raw/38e1766bc6e20108948aec8a0b222a4bad0254e9/src/xkbcomp/expr.c"", ""contents_url"": ""https://api.github.com/repos/xkbcommon/libxkbcommon/contents/src/xkbcomp/expr.c?ref=38e1766bc6e20108948aec8a0b222a4bad0254e9"", ""patch"": ""@@ -42,7 +42,7 @@ ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n         *elem_rtrn = NULL;\n         *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n         *index_rtrn = NULL;\n-        return true;\n+        return (*field_rtrn != NULL);\n     case EXPR_FIELD_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);""}","ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,
               const char **elem_rtrn, const char **field_rtrn,
               ExprDef **index_rtrn)
{
    switch (expr->expr.op) {
    case EXPR_IDENT:
         *elem_rtrn = NULL;
         *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);
         *index_rtrn = NULL;
        return (*field_rtrn != NULL);
     case EXPR_FIELD_REF:
         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);
         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);
        *index_rtrn = NULL;
        return true;
    case EXPR_ARRAY_REF:
        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);
        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);
        *index_rtrn = expr->array_ref.entry;
        return true;
    default:
        break;
    }
    log_wsgo(ctx, ""Unexpected operator %d in ResolveLhs\n"", expr->expr.op);
    return false;
}
","ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,
               const char **elem_rtrn, const char **field_rtrn,
               ExprDef **index_rtrn)
{
    switch (expr->expr.op) {
    case EXPR_IDENT:
         *elem_rtrn = NULL;
         *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);
         *index_rtrn = NULL;
        return true;
     case EXPR_FIELD_REF:
         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);
         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);
        *index_rtrn = NULL;
        return true;
    case EXPR_ARRAY_REF:
        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);
        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);
        *index_rtrn = expr->array_ref.entry;
        return true;
    default:
        break;
    }
    log_wsgo(ctx, ""Unexpected operator %d in ResolveLhs\n"", expr->expr.op);
    return false;
}
",C,"        return (*field_rtrn != NULL);
","        return true;
",,"@@ -42,7 +42,7 @@ ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,
         *elem_rtrn = NULL;
         *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);
         *index_rtrn = NULL;
-        return true;
+        return (*field_rtrn != NULL);
     case EXPR_FIELD_REF:
         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);
         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);",libxkbcommon,38e1766bc6e20108948aec8a0b222a4bad0254e9,4e2ee9c3f6050d773f8bbe05bc0edb17f1ff8371,1,"ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,
               const char **elem_rtrn, const char **field_rtrn,
               ExprDef **index_rtrn)
{
    switch (expr->expr.op) {
    case EXPR_IDENT:
         *elem_rtrn = NULL;
         *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);
         *index_rtrn = NULL;
//flaw_line_below:
        return true;
//fix_flaw_line_below:
//        return (*field_rtrn != NULL);
     case EXPR_FIELD_REF:
         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);
         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);
        *index_rtrn = NULL;
        return true;
    case EXPR_ARRAY_REF:
        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);
        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);
        *index_rtrn = expr->array_ref.entry;
        return true;
    default:
        break;
    }
    log_wsgo(ctx, ""Unexpected operator %d in ResolveLhs\n"", expr->expr.op);
    return false;
}
"
4527,182263,,Local,Not required,Partial,CVE-2018-15859,https://www.cvedetails.com/cve/CVE-2018-15859/,CWE-476,Low,,,,2018-08-25,2.1,"Unchecked NULL pointer usage when parsing invalid atoms in ExprResolveLhs in xkbcomp/expr.c in xkbcommon before 0.8.2 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file, because lookup failures are mishandled.",2019-08-06,,5,https://github.com/xkbcommon/libxkbcommon/commit/bb4909d2d8fa6b08155e449986a478101e2b2634,bb4909d2d8fa6b08155e449986a478101e2b2634,"Fail expression lookup on invalid atoms

If we fail atom lookup, then we should not claim that we successfully
looked up the expression.

Signed-off-by: Daniel Stone <daniels@collabora.com>",1,src/xkbcomp/expr.c,"{""sha"": ""b2567de3ebfafb80ea88fd6f4d619495d62c7791"", ""filename"": ""src/xkbcomp/expr.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/xkbcommon/libxkbcommon/blob/bb4909d2d8fa6b08155e449986a478101e2b2634/src/xkbcomp/expr.c"", ""raw_url"": ""https://github.com/xkbcommon/libxkbcommon/raw/bb4909d2d8fa6b08155e449986a478101e2b2634/src/xkbcomp/expr.c"", ""contents_url"": ""https://api.github.com/repos/xkbcommon/libxkbcommon/contents/src/xkbcomp/expr.c?ref=bb4909d2d8fa6b08155e449986a478101e2b2634"", ""patch"": ""@@ -47,11 +47,15 @@ ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n         *index_rtrn = NULL;\n-        return true;\n+        return (*elem_rtrn != NULL && *field_rtrn != NULL);\n     case EXPR_ARRAY_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n         *index_rtrn = expr->array_ref.entry;\n+\tif (expr->array_ref.element != XKB_ATOM_NONE && *elem_rtrn == NULL)\n+\t\treturn false;\n+\tif (*field_rtrn == NULL)\n+\t\treturn false;\n         return true;\n     default:\n         break;""}","ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,
               const char **elem_rtrn, const char **field_rtrn,
               ExprDef **index_rtrn)
{
    switch (expr->expr.op) {
    case EXPR_IDENT:
        *elem_rtrn = NULL;
        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);
        *index_rtrn = NULL;
        return (*field_rtrn != NULL);
    case EXPR_FIELD_REF:
         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);
         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);
         *index_rtrn = NULL;
        return (*elem_rtrn != NULL && *field_rtrn != NULL);
     case EXPR_ARRAY_REF:
         *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);
         *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);
         *index_rtrn = expr->array_ref.entry;
	if (expr->array_ref.element != XKB_ATOM_NONE && *elem_rtrn == NULL)
		return false;
	if (*field_rtrn == NULL)
		return false;
         return true;
     default:
         break;
    }
    log_wsgo(ctx, ""Unexpected operator %d in ResolveLhs\n"", expr->expr.op);
    return false;
}
","ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,
               const char **elem_rtrn, const char **field_rtrn,
               ExprDef **index_rtrn)
{
    switch (expr->expr.op) {
    case EXPR_IDENT:
        *elem_rtrn = NULL;
        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);
        *index_rtrn = NULL;
        return (*field_rtrn != NULL);
    case EXPR_FIELD_REF:
         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);
         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);
         *index_rtrn = NULL;
        return true;
     case EXPR_ARRAY_REF:
         *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);
         *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);
         *index_rtrn = expr->array_ref.entry;
         return true;
     default:
         break;
    }
    log_wsgo(ctx, ""Unexpected operator %d in ResolveLhs\n"", expr->expr.op);
    return false;
}
",C,"        return (*elem_rtrn != NULL && *field_rtrn != NULL);
	if (expr->array_ref.element != XKB_ATOM_NONE && *elem_rtrn == NULL)
		return false;
	if (*field_rtrn == NULL)
		return false;
","        return true;
",,"@@ -47,11 +47,15 @@ ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,
         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);
         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);
         *index_rtrn = NULL;
-        return true;
+        return (*elem_rtrn != NULL && *field_rtrn != NULL);
     case EXPR_ARRAY_REF:
         *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);
         *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);
         *index_rtrn = expr->array_ref.entry;
+	if (expr->array_ref.element != XKB_ATOM_NONE && *elem_rtrn == NULL)
+		return false;
+	if (*field_rtrn == NULL)
+		return false;
         return true;
     default:
         break;",libxkbcommon,bb4909d2d8fa6b08155e449986a478101e2b2634,5440aaa5222b02275b4fd982f5326c92c072982b,1,"ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,
               const char **elem_rtrn, const char **field_rtrn,
               ExprDef **index_rtrn)
{
    switch (expr->expr.op) {
    case EXPR_IDENT:
        *elem_rtrn = NULL;
        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);
        *index_rtrn = NULL;
        return (*field_rtrn != NULL);
    case EXPR_FIELD_REF:
         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);
         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);
         *index_rtrn = NULL;
//flaw_line_below:
        return true;
//fix_flaw_line_below:
//        return (*elem_rtrn != NULL && *field_rtrn != NULL);
     case EXPR_ARRAY_REF:
         *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);
         *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);
         *index_rtrn = expr->array_ref.entry;
//fix_flaw_line_below:
//	if (expr->array_ref.element != XKB_ATOM_NONE && *elem_rtrn == NULL)
//fix_flaw_line_below:
//		return false;
//fix_flaw_line_below:
//	if (*field_rtrn == NULL)
//fix_flaw_line_below:
//		return false;
         return true;
     default:
         break;
    }
    log_wsgo(ctx, ""Unexpected operator %d in ResolveLhs\n"", expr->expr.op);
    return false;
}
"
4528,182264,,Local,Not required,Partial,CVE-2018-15858,https://www.cvedetails.com/cve/CVE-2018-15858/,CWE-476,Low,,,,2018-08-25,2.1,Unchecked NULL pointer usage when handling invalid aliases in CopyKeyAliasesToKeymap in xkbcomp/keycodes.c in xkbcommon before 0.8.1 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file.,2018-11-07,,7,https://github.com/xkbcommon/libxkbcommon/commit/badb428e63387140720f22486b3acbd3d738859f,badb428e63387140720f22486b3acbd3d738859f,"keycodes: don't try to copy zero key aliases

Move the aliases copy to within the (num_key_aliases > 0) block.

Passing info->aliases into this fuction with invalid aliases will
cause log messages but num_key_aliases stays on 0. The key_aliases array
is never allocated and remains NULL. We then loop through the aliases, causing
a null-pointer dereference.

Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>",7,src/xkbcomp/keycodes.c,"{""sha"": ""491da510677ec08ae94af3a8d7ab2f380bd5a6e0"", ""filename"": ""src/xkbcomp/keycodes.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 7, ""changes"": 14, ""blob_url"": ""https://github.com/xkbcommon/libxkbcommon/blob/badb428e63387140720f22486b3acbd3d738859f/src/xkbcomp/keycodes.c"", ""raw_url"": ""https://github.com/xkbcommon/libxkbcommon/raw/badb428e63387140720f22486b3acbd3d738859f/src/xkbcomp/keycodes.c"", ""contents_url"": ""https://api.github.com/repos/xkbcommon/libxkbcommon/contents/src/xkbcomp/keycodes.c?ref=badb428e63387140720f22486b3acbd3d738859f"", ""patch"": ""@@ -596,14 +596,14 @@ CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n         key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n         if (!key_aliases)\n             return false;\n-    }\n \n-    i = 0;\n-    darray_foreach(alias, info->aliases) {\n-        if (alias->real != XKB_ATOM_NONE) {\n-            key_aliases[i].alias = alias->alias;\n-            key_aliases[i].real = alias->real;\n-            i++;\n+        i = 0;\n+        darray_foreach(alias, info->aliases) {\n+            if (alias->real != XKB_ATOM_NONE) {\n+                key_aliases[i].alias = alias->alias;\n+                key_aliases[i].real = alias->real;\n+                i++;\n+            }\n         }\n     }\n ""}","CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)
{
    AliasInfo *alias;
    unsigned i, num_key_aliases;
    struct xkb_key_alias *key_aliases;

    /*
     * Do some sanity checking on the aliases. We can't do it before
     * because keys and their aliases may be added out-of-order.
     */
    num_key_aliases = 0;
    darray_foreach(alias, info->aliases) {
        /* Check that ->real is a key. */
        if (!XkbKeyByName(keymap, alias->real, false)) {
            log_vrb(info->ctx, 5,
                    ""Attempt to alias %s to non-existent key %s; Ignored\n"",
                    KeyNameText(info->ctx, alias->alias),
                    KeyNameText(info->ctx, alias->real));
            alias->real = XKB_ATOM_NONE;
            continue;
        }

        /* Check that ->alias is not a key. */
        if (XkbKeyByName(keymap, alias->alias, false)) {
            log_vrb(info->ctx, 5,
                    ""Attempt to create alias with the name of a real key; ""
                    ""Alias \""%s = %s\"" ignored\n"",
                    KeyNameText(info->ctx, alias->alias),
                    KeyNameText(info->ctx, alias->real));
            alias->real = XKB_ATOM_NONE;
            continue;
        }

        num_key_aliases++;
    }

    /* Copy key aliases. */
    key_aliases = NULL;
    if (num_key_aliases > 0) {
         key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));
         if (!key_aliases)
             return false;
 
        i = 0;
        darray_foreach(alias, info->aliases) {
            if (alias->real != XKB_ATOM_NONE) {
                key_aliases[i].alias = alias->alias;
                key_aliases[i].real = alias->real;
                i++;
            }
         }
     }
 
    keymap->num_key_aliases = num_key_aliases;
    keymap->key_aliases = key_aliases;
    return true;
}
","CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)
{
    AliasInfo *alias;
    unsigned i, num_key_aliases;
    struct xkb_key_alias *key_aliases;

    /*
     * Do some sanity checking on the aliases. We can't do it before
     * because keys and their aliases may be added out-of-order.
     */
    num_key_aliases = 0;
    darray_foreach(alias, info->aliases) {
        /* Check that ->real is a key. */
        if (!XkbKeyByName(keymap, alias->real, false)) {
            log_vrb(info->ctx, 5,
                    ""Attempt to alias %s to non-existent key %s; Ignored\n"",
                    KeyNameText(info->ctx, alias->alias),
                    KeyNameText(info->ctx, alias->real));
            alias->real = XKB_ATOM_NONE;
            continue;
        }

        /* Check that ->alias is not a key. */
        if (XkbKeyByName(keymap, alias->alias, false)) {
            log_vrb(info->ctx, 5,
                    ""Attempt to create alias with the name of a real key; ""
                    ""Alias \""%s = %s\"" ignored\n"",
                    KeyNameText(info->ctx, alias->alias),
                    KeyNameText(info->ctx, alias->real));
            alias->real = XKB_ATOM_NONE;
            continue;
        }

        num_key_aliases++;
    }

    /* Copy key aliases. */
    key_aliases = NULL;
    if (num_key_aliases > 0) {
         key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));
         if (!key_aliases)
             return false;
    }
 
    i = 0;
    darray_foreach(alias, info->aliases) {
        if (alias->real != XKB_ATOM_NONE) {
            key_aliases[i].alias = alias->alias;
            key_aliases[i].real = alias->real;
            i++;
         }
     }
 
    keymap->num_key_aliases = num_key_aliases;
    keymap->key_aliases = key_aliases;
    return true;
}
",C,"        i = 0;
        darray_foreach(alias, info->aliases) {
            if (alias->real != XKB_ATOM_NONE) {
                key_aliases[i].alias = alias->alias;
                key_aliases[i].real = alias->real;
                i++;
            }
","    }
    i = 0;
    darray_foreach(alias, info->aliases) {
        if (alias->real != XKB_ATOM_NONE) {
            key_aliases[i].alias = alias->alias;
            key_aliases[i].real = alias->real;
            i++;
",,"@@ -596,14 +596,14 @@ CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)
         key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));
         if (!key_aliases)
             return false;
-    }
 
-    i = 0;
-    darray_foreach(alias, info->aliases) {
-        if (alias->real != XKB_ATOM_NONE) {
-            key_aliases[i].alias = alias->alias;
-            key_aliases[i].real = alias->real;
-            i++;
+        i = 0;
+        darray_foreach(alias, info->aliases) {
+            if (alias->real != XKB_ATOM_NONE) {
+                key_aliases[i].alias = alias->alias;
+                key_aliases[i].real = alias->real;
+                i++;
+            }
         }
     }
 ",libxkbcommon,badb428e63387140720f22486b3acbd3d738859f,9045b035981e4273ddbb64bfb31577bbf92d8597,1,"CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)
{
    AliasInfo *alias;
    unsigned i, num_key_aliases;
    struct xkb_key_alias *key_aliases;

    /*
     * Do some sanity checking on the aliases. We can't do it before
     * because keys and their aliases may be added out-of-order.
     */
    num_key_aliases = 0;
    darray_foreach(alias, info->aliases) {
        /* Check that ->real is a key. */
        if (!XkbKeyByName(keymap, alias->real, false)) {
            log_vrb(info->ctx, 5,
                    ""Attempt to alias %s to non-existent key %s; Ignored\n"",
                    KeyNameText(info->ctx, alias->alias),
                    KeyNameText(info->ctx, alias->real));
            alias->real = XKB_ATOM_NONE;
            continue;
        }

        /* Check that ->alias is not a key. */
        if (XkbKeyByName(keymap, alias->alias, false)) {
            log_vrb(info->ctx, 5,
                    ""Attempt to create alias with the name of a real key; ""
                    ""Alias \""%s = %s\"" ignored\n"",
                    KeyNameText(info->ctx, alias->alias),
                    KeyNameText(info->ctx, alias->real));
            alias->real = XKB_ATOM_NONE;
            continue;
        }

        num_key_aliases++;
    }

    /* Copy key aliases. */
    key_aliases = NULL;
    if (num_key_aliases > 0) {
         key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));
         if (!key_aliases)
             return false;
//flaw_line_below:
    }
 
//flaw_line_below:
    i = 0;
//flaw_line_below:
    darray_foreach(alias, info->aliases) {
//flaw_line_below:
        if (alias->real != XKB_ATOM_NONE) {
//flaw_line_below:
            key_aliases[i].alias = alias->alias;
//flaw_line_below:
            key_aliases[i].real = alias->real;
//flaw_line_below:
            i++;
//fix_flaw_line_below:
//        i = 0;
//fix_flaw_line_below:
//        darray_foreach(alias, info->aliases) {
//fix_flaw_line_below:
//            if (alias->real != XKB_ATOM_NONE) {
//fix_flaw_line_below:
//                key_aliases[i].alias = alias->alias;
//fix_flaw_line_below:
//                key_aliases[i].real = alias->real;
//fix_flaw_line_below:
//                i++;
//fix_flaw_line_below:
//            }
         }
     }
 
    keymap->num_key_aliases = num_key_aliases;
    keymap->key_aliases = key_aliases;
    return true;
}
"
4531,182267,,Local,Not required,Partial,CVE-2018-15855,https://www.cvedetails.com/cve/CVE-2018-15855/,CWE-476,Low,,,,2018-08-25,2.1,"Unchecked NULL pointer usage in xkbcommon before 0.8.1 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file, because the XkbFile for an xkb_geometry section was mishandled.",2019-08-06,,7,https://github.com/xkbcommon/libxkbcommon/commit/917636b1d0d70205a13f89062b95e3a0fc31d4ff,917636b1d0d70205a13f89062b95e3a0fc31d4ff,"xkbcomp: fix crash when parsing an xkb_geometry section

xkb_geometry sections are ignored; previously the had done so by
returning NULL for the section's XkbFile, however some sections of the
code do not expect this. Instead, create an XkbFile for it, it will
never be processes and discarded later.

Caught with the afl fuzzer.

Signed-off-by: Ran Benita <ran234@gmail.com>",2,src/xkbcomp/keymap.c,"{""sha"": ""e95e50c37117cf2243c21f40447bc01d8a48be0f"", ""filename"": ""src/xkbcomp/keymap.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 2, ""changes"": 9, ""blob_url"": ""https://github.com/xkbcommon/libxkbcommon/blob/917636b1d0d70205a13f89062b95e3a0fc31d4ff/src/xkbcomp/keymap.c"", ""raw_url"": ""https://github.com/xkbcommon/libxkbcommon/raw/917636b1d0d70205a13f89062b95e3a0fc31d4ff/src/xkbcomp/keymap.c"", ""contents_url"": ""https://api.github.com/repos/xkbcommon/libxkbcommon/contents/src/xkbcomp/keymap.c?ref=917636b1d0d70205a13f89062b95e3a0fc31d4ff"", ""patch"": ""@@ -241,8 +241,13 @@ CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n          file = (XkbFile *) file->common.next) {\n         if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n             file->file_type > LAST_KEYMAP_FILE_TYPE) {\n-            log_err(ctx, \""Cannot define %s in a keymap file\\n\"",\n-                    xkb_file_type_to_string(file->file_type));\n+            if (file->file_type == FILE_TYPE_GEOMETRY) {\n+                log_vrb(ctx, 1,\n+                        \""Geometry sections are not supported; ignoring\\n\"");\n+            } else {\n+                log_err(ctx, \""Cannot define %s in a keymap file\\n\"",\n+                        xkb_file_type_to_string(file->file_type));\n+            }\n             continue;\n         }\n ""}<_**next**_>{""sha"": ""b555bc254dc13935cf9e0c16318682aa0fbd2733"", ""filename"": ""src/xkbcomp/parser.y"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 8, ""changes"": 9, ""blob_url"": ""https://github.com/xkbcommon/libxkbcommon/blob/917636b1d0d70205a13f89062b95e3a0fc31d4ff/src/xkbcomp/parser.y"", ""raw_url"": ""https://github.com/xkbcommon/libxkbcommon/raw/917636b1d0d70205a13f89062b95e3a0fc31d4ff/src/xkbcomp/parser.y"", ""contents_url"": ""https://api.github.com/repos/xkbcommon/libxkbcommon/contents/src/xkbcomp/parser.y?ref=917636b1d0d70205a13f89062b95e3a0fc31d4ff"", ""patch"": ""@@ -273,14 +273,7 @@ XkbMapConfig    :       OptFlags FileType OptMapName OBRACE\n                             DeclList\n                         CBRACE SEMI\n                         {\n-                            if ($2 == FILE_TYPE_GEOMETRY) {\n-                                free($3);\n-                                FreeStmt($5);\n-                                $$ = NULL;\n-                            }\n-                            else {\n-                                $$ = XkbFileCreate($2, $3, $5, $1);\n-                            }\n+                            $$ = XkbFileCreate($2, $3, $5, $1);\n                         }\n                 ;\n ""}","CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)
{
    bool ok;
    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };
    enum xkb_file_type type;
    struct xkb_context *ctx = keymap->ctx;

    /* Collect section files and check for duplicates. */
    for (file = (XkbFile *) file->defs; file;
          file = (XkbFile *) file->common.next) {
         if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||
             file->file_type > LAST_KEYMAP_FILE_TYPE) {
            if (file->file_type == FILE_TYPE_GEOMETRY) {
                log_vrb(ctx, 1,
                        ""Geometry sections are not supported; ignoring\n"");
            } else {
                log_err(ctx, ""Cannot define %s in a keymap file\n"",
                        xkb_file_type_to_string(file->file_type));
            }
             continue;
         }
 
        if (files[file->file_type]) {
            log_err(ctx,
                    ""More than one %s section in keymap file; ""
                    ""All sections after the first ignored\n"",
                    xkb_file_type_to_string(file->file_type));
            continue;
        }

        files[file->file_type] = file;
    }

    /*
     * Check that all required section were provided.
     * Report everything before failing.
     */
    ok = true;
    for (type = FIRST_KEYMAP_FILE_TYPE;
         type <= LAST_KEYMAP_FILE_TYPE;
         type++) {
        if (files[type] == NULL) {
            log_err(ctx, ""Required section %s missing from keymap\n"",
                    xkb_file_type_to_string(type));
            ok = false;
        }
    }
    if (!ok)
        return false;

    /* Compile sections. */
    for (type = FIRST_KEYMAP_FILE_TYPE;
         type <= LAST_KEYMAP_FILE_TYPE;
         type++) {
        log_dbg(ctx, ""Compiling %s \""%s\""\n"",
                xkb_file_type_to_string(type), files[type]->name);

        ok = compile_file_fns[type](files[type], keymap, merge);
        if (!ok) {
            log_err(ctx, ""Failed to compile %s\n"",
                    xkb_file_type_to_string(type));
            return false;
        }
    }

    return UpdateDerivedKeymapFields(keymap);
}
","CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)
{
    bool ok;
    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };
    enum xkb_file_type type;
    struct xkb_context *ctx = keymap->ctx;

    /* Collect section files and check for duplicates. */
    for (file = (XkbFile *) file->defs; file;
          file = (XkbFile *) file->common.next) {
         if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||
             file->file_type > LAST_KEYMAP_FILE_TYPE) {
            log_err(ctx, ""Cannot define %s in a keymap file\n"",
                    xkb_file_type_to_string(file->file_type));
             continue;
         }
 
        if (files[file->file_type]) {
            log_err(ctx,
                    ""More than one %s section in keymap file; ""
                    ""All sections after the first ignored\n"",
                    xkb_file_type_to_string(file->file_type));
            continue;
        }

        files[file->file_type] = file;
    }

    /*
     * Check that all required section were provided.
     * Report everything before failing.
     */
    ok = true;
    for (type = FIRST_KEYMAP_FILE_TYPE;
         type <= LAST_KEYMAP_FILE_TYPE;
         type++) {
        if (files[type] == NULL) {
            log_err(ctx, ""Required section %s missing from keymap\n"",
                    xkb_file_type_to_string(type));
            ok = false;
        }
    }
    if (!ok)
        return false;

    /* Compile sections. */
    for (type = FIRST_KEYMAP_FILE_TYPE;
         type <= LAST_KEYMAP_FILE_TYPE;
         type++) {
        log_dbg(ctx, ""Compiling %s \""%s\""\n"",
                xkb_file_type_to_string(type), files[type]->name);

        ok = compile_file_fns[type](files[type], keymap, merge);
        if (!ok) {
            log_err(ctx, ""Failed to compile %s\n"",
                    xkb_file_type_to_string(type));
            return false;
        }
    }

    return UpdateDerivedKeymapFields(keymap);
}
",C,"            if (file->file_type == FILE_TYPE_GEOMETRY) {
                log_vrb(ctx, 1,
                        ""Geometry sections are not supported; ignoring\n"");
            } else {
                log_err(ctx, ""Cannot define %s in a keymap file\n"",
                        xkb_file_type_to_string(file->file_type));
            }
","            log_err(ctx, ""Cannot define %s in a keymap file\n"",
                    xkb_file_type_to_string(file->file_type));
",,"@@ -241,8 +241,13 @@ CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)
          file = (XkbFile *) file->common.next) {
         if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||
             file->file_type > LAST_KEYMAP_FILE_TYPE) {
-            log_err(ctx, ""Cannot define %s in a keymap file\n"",
-                    xkb_file_type_to_string(file->file_type));
+            if (file->file_type == FILE_TYPE_GEOMETRY) {
+                log_vrb(ctx, 1,
+                        ""Geometry sections are not supported; ignoring\n"");
+            } else {
+                log_err(ctx, ""Cannot define %s in a keymap file\n"",
+                        xkb_file_type_to_string(file->file_type));
+            }
             continue;
         }
 ",libxkbcommon,917636b1d0d70205a13f89062b95e3a0fc31d4ff,e3cacae7b1bfda0d839c280494f23284a1187adf,1,"CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)
{
    bool ok;
    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };
    enum xkb_file_type type;
    struct xkb_context *ctx = keymap->ctx;

    /* Collect section files and check for duplicates. */
    for (file = (XkbFile *) file->defs; file;
          file = (XkbFile *) file->common.next) {
         if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||
             file->file_type > LAST_KEYMAP_FILE_TYPE) {
//flaw_line_below:
            log_err(ctx, ""Cannot define %s in a keymap file\n"",
//flaw_line_below:
                    xkb_file_type_to_string(file->file_type));
//fix_flaw_line_below:
//            if (file->file_type == FILE_TYPE_GEOMETRY) {
//fix_flaw_line_below:
//                log_vrb(ctx, 1,
//fix_flaw_line_below:
//                        ""Geometry sections are not supported; ignoring\n"");
//fix_flaw_line_below:
//            } else {
//fix_flaw_line_below:
//                log_err(ctx, ""Cannot define %s in a keymap file\n"",
//fix_flaw_line_below:
//                        xkb_file_type_to_string(file->file_type));
//fix_flaw_line_below:
//            }
             continue;
         }
 
        if (files[file->file_type]) {
            log_err(ctx,
                    ""More than one %s section in keymap file; ""
                    ""All sections after the first ignored\n"",
                    xkb_file_type_to_string(file->file_type));
            continue;
        }

        files[file->file_type] = file;
    }

    /*
     * Check that all required section were provided.
     * Report everything before failing.
     */
    ok = true;
    for (type = FIRST_KEYMAP_FILE_TYPE;
         type <= LAST_KEYMAP_FILE_TYPE;
         type++) {
        if (files[type] == NULL) {
            log_err(ctx, ""Required section %s missing from keymap\n"",
                    xkb_file_type_to_string(type));
            ok = false;
        }
    }
    if (!ok)
        return false;

    /* Compile sections. */
    for (type = FIRST_KEYMAP_FILE_TYPE;
         type <= LAST_KEYMAP_FILE_TYPE;
         type++) {
        log_dbg(ctx, ""Compiling %s \""%s\""\n"",
                xkb_file_type_to_string(type), files[type]->name);

        ok = compile_file_fns[type](files[type], keymap, merge);
        if (!ok) {
            log_err(ctx, ""Failed to compile %s\n"",
                    xkb_file_type_to_string(type));
            return false;
        }
    }

    return UpdateDerivedKeymapFields(keymap);
}
"
4594,182330,,Remote,Not required,Partial,CVE-2018-13303,https://www.cvedetails.com/cve/CVE-2018-13303/,CWE-476,Medium,,,,2018-07-05,4.3,"In FFmpeg 4.0.1, a missing check for failure of a call to init_get_bits8() in the avpriv_ac3_parse_header function in libavcodec/ac3_parser.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.",2018-07-18,DoS ,3,https://github.com/FFmpeg/FFmpeg/commit/00e8181bd97c834fe60751b0c511d4bb97875f78,00e8181bd97c834fe60751b0c511d4bb97875f78,"avcodec/ac3_parser: Check init_get_bits8() for failure

Fixes: null pointer dereference
Fixes: ffmpeg_crash_6.avi

Found-by: Thuan Pham, Marcel Böhme, Andrew Santosa and Alexandru Razvan Caciulescu with AFLSmart
Reviewed-by: Paul B Mahol <onemda@gmail.com>
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",1,libavcodec/ac3_parser.c,"{""sha"": ""1e203ae6ac233df247d799c562dc3f41a45c680d"", ""filename"": ""libavcodec/ac3_parser.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/00e8181bd97c834fe60751b0c511d4bb97875f78/libavcodec/ac3_parser.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/00e8181bd97c834fe60751b0c511d4bb97875f78/libavcodec/ac3_parser.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavcodec/ac3_parser.c?ref=00e8181bd97c834fe60751b0c511d4bb97875f78"", ""patch"": ""@@ -162,7 +162,9 @@ int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n         return AVERROR(ENOMEM);\n     hdr = *phdr;\n \n-    init_get_bits8(&gb, buf, size);\n+    err = init_get_bits8(&gb, buf, size);\n+    if (err < 0)\n+        return AVERROR_INVALIDDATA;\n     err = ff_ac3_parse_header(&gb, hdr);\n     if (err < 0)\n         return AVERROR_INVALIDDATA;""}","int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,
                            size_t size)
{
    GetBitContext gb;
    AC3HeaderInfo *hdr;
    int err;

    if (!*phdr)
        *phdr = av_mallocz(sizeof(AC3HeaderInfo));
    if (!*phdr)
         return AVERROR(ENOMEM);
     hdr = *phdr;
 
    err = init_get_bits8(&gb, buf, size);
    if (err < 0)
        return AVERROR_INVALIDDATA;
     err = ff_ac3_parse_header(&gb, hdr);
     if (err < 0)
         return AVERROR_INVALIDDATA;

    return get_bits_count(&gb);
}
","int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,
                            size_t size)
{
    GetBitContext gb;
    AC3HeaderInfo *hdr;
    int err;

    if (!*phdr)
        *phdr = av_mallocz(sizeof(AC3HeaderInfo));
    if (!*phdr)
         return AVERROR(ENOMEM);
     hdr = *phdr;
 
    init_get_bits8(&gb, buf, size);
     err = ff_ac3_parse_header(&gb, hdr);
     if (err < 0)
         return AVERROR_INVALIDDATA;

    return get_bits_count(&gb);
}
",C,"    err = init_get_bits8(&gb, buf, size);
    if (err < 0)
        return AVERROR_INVALIDDATA;
","    init_get_bits8(&gb, buf, size);
",,"@@ -162,7 +162,9 @@ int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,
         return AVERROR(ENOMEM);
     hdr = *phdr;
 
-    init_get_bits8(&gb, buf, size);
+    err = init_get_bits8(&gb, buf, size);
+    if (err < 0)
+        return AVERROR_INVALIDDATA;
     err = ff_ac3_parse_header(&gb, hdr);
     if (err < 0)
         return AVERROR_INVALIDDATA;",FFmpeg,00e8181bd97c834fe60751b0c511d4bb97875f78,ed22dc22216f74c75ee7901f82649e1ff725ba50,1,"int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,
                            size_t size)
{
    GetBitContext gb;
    AC3HeaderInfo *hdr;
    int err;

    if (!*phdr)
        *phdr = av_mallocz(sizeof(AC3HeaderInfo));
    if (!*phdr)
         return AVERROR(ENOMEM);
     hdr = *phdr;
 
//flaw_line_below:
    init_get_bits8(&gb, buf, size);
//fix_flaw_line_below:
//    err = init_get_bits8(&gb, buf, size);
//fix_flaw_line_below:
//    if (err < 0)
//fix_flaw_line_below:
//        return AVERROR_INVALIDDATA;
     err = ff_ac3_parse_header(&gb, hdr);
     if (err < 0)
         return AVERROR_INVALIDDATA;

    return get_bits_count(&gb);
}
"
4596,182332,,Remote,Not required,Partial,CVE-2018-13301,https://www.cvedetails.com/cve/CVE-2018-13301/,CWE-476,Medium,,,,2018-07-05,4.3,"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.",2018-07-18,DoS ,10,https://github.com/FFmpeg/FFmpeg/commit/2aa9047486dbff12d9e040f917e5f799ed2fd78b,2aa9047486dbff12d9e040f917e5f799ed2fd78b,"avcodec/mpeg4videodec: Check read profile before setting it

Fixes: null pointer dereference
Fixes: ffmpeg_crash_7.avi

Found-by: Thuan Pham, Marcel Böhme, Andrew Santosa and Alexandru Razvan Caciulescu with AFLSmart
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",3,libavcodec/mpeg4videodec.c,"{""sha"": ""54a84962444f4935fe874734ef769a7fcb485497"", ""filename"": ""libavcodec/mpeg4videodec.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 8, ""changes"": 23, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/2aa9047486dbff12d9e040f917e5f799ed2fd78b/libavcodec/mpeg4videodec.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/2aa9047486dbff12d9e040f917e5f799ed2fd78b/libavcodec/mpeg4videodec.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavcodec/mpeg4videodec.c?ref=2aa9047486dbff12d9e040f917e5f799ed2fd78b"", ""patch"": ""@@ -1980,15 +1980,15 @@ static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)\n     return 0;\n }\n \n-static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb)\n+static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)\n {\n \n-    s->avctx->profile = get_bits(gb, 4);\n-    s->avctx->level   = get_bits(gb, 4);\n+    *profile = get_bits(gb, 4);\n+    *level   = get_bits(gb, 4);\n \n     // for Simple profile, level 0\n-    if (s->avctx->profile == 0 && s->avctx->level == 8) {\n-        s->avctx->level = 0;\n+    if (*profile == 0 && *level == 8) {\n+        *level = 0;\n     }\n \n     return 0;\n@@ -3211,13 +3211,19 @@ int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n         } else if (startcode == GOP_STARTCODE) {\n             mpeg4_decode_gop_header(s, gb);\n         } else if (startcode == VOS_STARTCODE) {\n-            mpeg4_decode_profile_level(s, gb);\n-            if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n-                (s->avctx->level > 0 && s->avctx->level < 9)) {\n+            int profile, level;\n+            mpeg4_decode_profile_level(s, gb, &profile, &level);\n+            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n+                (level > 0 && level < 9)) {\n                 s->studio_profile = 1;\n                 next_start_code_studio(gb);\n                 extension_and_user_data(s, gb, 0);\n+            } else if (s->studio_profile) {\n+                avpriv_request_sample(s->avctx, \""Mixes studio and non studio profile\\n\"");\n+                return AVERROR_PATCHWELCOME;\n             }\n+            s->avctx->profile = profile;\n+            s->avctx->level   = level;\n         } else if (startcode == VISUAL_OBJ_STARTCODE) {\n             if (s->studio_profile) {\n                 if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n@@ -3238,6 +3244,7 @@ int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n     s->avctx->has_b_frames = !s->low_delay;\n \n     if (s->studio_profile) {\n+        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n         if (!s->avctx->bits_per_raw_sample) {\n             av_log(s->avctx, AV_LOG_ERROR, \""Missing VOL header\\n\"");\n             return AVERROR_INVALIDDATA;""}","int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)
{
    MpegEncContext *s = &ctx->m;
    unsigned startcode, v;
    int ret;
    int vol = 0;

    /* search next start code */
    align_get_bits(gb);

    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)
        s->avctx->bits_per_raw_sample = 0;

    if (s->codec_tag == AV_RL32(""WV1F"") && show_bits(gb, 24) == 0x575630) {
        skip_bits(gb, 24);
        if (get_bits(gb, 8) == 0xF0)
            goto end;
    }

    startcode = 0xff;
    for (;;) {
        if (get_bits_count(gb) >= gb->size_in_bits) {
            if (gb->size_in_bits == 8 &&
                (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(""QMP4"")) {
                av_log(s->avctx, AV_LOG_VERBOSE, ""frame skip %d\n"", gb->size_in_bits);
                return FRAME_SKIPPED;  // divx bug
            } else
                return AVERROR_INVALIDDATA;  // end of stream
        }

        /* use the bits after the test */
        v = get_bits(gb, 8);
        startcode = ((startcode << 8) | v) & 0xffffffff;

        if ((startcode & 0xFFFFFF00) != 0x100)
            continue;  // no startcode

        if (s->avctx->debug & FF_DEBUG_STARTCODE) {
            av_log(s->avctx, AV_LOG_DEBUG, ""startcode: %3X "", startcode);
            if (startcode <= 0x11F)
                av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Start"");
            else if (startcode <= 0x12F)
                av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Layer Start"");
            else if (startcode <= 0x13F)
                av_log(s->avctx, AV_LOG_DEBUG, ""Reserved"");
            else if (startcode <= 0x15F)
                av_log(s->avctx, AV_LOG_DEBUG, ""FGS bp start"");
            else if (startcode <= 0x1AF)
                av_log(s->avctx, AV_LOG_DEBUG, ""Reserved"");
            else if (startcode == 0x1B0)
                av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Seq Start"");
            else if (startcode == 0x1B1)
                av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Seq End"");
            else if (startcode == 0x1B2)
                av_log(s->avctx, AV_LOG_DEBUG, ""User Data"");
            else if (startcode == 0x1B3)
                av_log(s->avctx, AV_LOG_DEBUG, ""Group of VOP start"");
            else if (startcode == 0x1B4)
                av_log(s->avctx, AV_LOG_DEBUG, ""Video Session Error"");
            else if (startcode == 0x1B5)
                av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Start"");
            else if (startcode == 0x1B6)
                av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Plane start"");
            else if (startcode == 0x1B7)
                av_log(s->avctx, AV_LOG_DEBUG, ""slice start"");
            else if (startcode == 0x1B8)
                av_log(s->avctx, AV_LOG_DEBUG, ""extension start"");
            else if (startcode == 0x1B9)
                av_log(s->avctx, AV_LOG_DEBUG, ""fgs start"");
            else if (startcode == 0x1BA)
                av_log(s->avctx, AV_LOG_DEBUG, ""FBA Object start"");
            else if (startcode == 0x1BB)
                av_log(s->avctx, AV_LOG_DEBUG, ""FBA Object Plane start"");
            else if (startcode == 0x1BC)
                av_log(s->avctx, AV_LOG_DEBUG, ""Mesh Object start"");
            else if (startcode == 0x1BD)
                av_log(s->avctx, AV_LOG_DEBUG, ""Mesh Object Plane start"");
            else if (startcode == 0x1BE)
                av_log(s->avctx, AV_LOG_DEBUG, ""Still Texture Object start"");
            else if (startcode == 0x1BF)
                av_log(s->avctx, AV_LOG_DEBUG, ""Texture Spatial Layer start"");
            else if (startcode == 0x1C0)
                av_log(s->avctx, AV_LOG_DEBUG, ""Texture SNR Layer start"");
            else if (startcode == 0x1C1)
                av_log(s->avctx, AV_LOG_DEBUG, ""Texture Tile start"");
            else if (startcode == 0x1C2)
                av_log(s->avctx, AV_LOG_DEBUG, ""Texture Shape Layer start"");
            else if (startcode == 0x1C3)
                av_log(s->avctx, AV_LOG_DEBUG, ""stuffing start"");
            else if (startcode <= 0x1C5)
                av_log(s->avctx, AV_LOG_DEBUG, ""reserved"");
            else if (startcode <= 0x1FF)
                av_log(s->avctx, AV_LOG_DEBUG, ""System start"");
            av_log(s->avctx, AV_LOG_DEBUG, "" at %d\n"", get_bits_count(gb));
        }

        if (startcode >= 0x120 && startcode <= 0x12F) {
            if (vol) {
                av_log(s->avctx, AV_LOG_WARNING, ""Ignoring multiple VOL headers\n"");
                continue;
            }
            vol++;
            if ((ret = decode_vol_header(ctx, gb)) < 0)
                return ret;
        } else if (startcode == USER_DATA_STARTCODE) {
            decode_user_data(ctx, gb);
         } else if (startcode == GOP_STARTCODE) {
             mpeg4_decode_gop_header(s, gb);
         } else if (startcode == VOS_STARTCODE) {
            int profile, level;
            mpeg4_decode_profile_level(s, gb, &profile, &level);
            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&
                (level > 0 && level < 9)) {
                 s->studio_profile = 1;
                 next_start_code_studio(gb);
                 extension_and_user_data(s, gb, 0);
            } else if (s->studio_profile) {
                avpriv_request_sample(s->avctx, ""Mixes studio and non studio profile\n"");
                return AVERROR_PATCHWELCOME;
             }
            s->avctx->profile = profile;
            s->avctx->level   = level;
         } else if (startcode == VISUAL_OBJ_STARTCODE) {
             if (s->studio_profile) {
                 if ((ret = decode_studiovisualobject(ctx, gb)) < 0)
                    return ret;
            } else
                mpeg4_decode_visual_object(s, gb);
        } else if (startcode == VOP_STARTCODE) {
            break;
        }

        align_get_bits(gb);
        startcode = 0xff;
    }

end:
    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)
        s->low_delay = 1;
     s->avctx->has_b_frames = !s->low_delay;
 
     if (s->studio_profile) {
        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
         if (!s->avctx->bits_per_raw_sample) {
             av_log(s->avctx, AV_LOG_ERROR, ""Missing VOL header\n"");
             return AVERROR_INVALIDDATA;
        }
        return decode_studio_vop_header(ctx, gb);
    } else
        return decode_vop_header(ctx, gb);
}
","int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)
{
    MpegEncContext *s = &ctx->m;
    unsigned startcode, v;
    int ret;
    int vol = 0;

    /* search next start code */
    align_get_bits(gb);

    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)
        s->avctx->bits_per_raw_sample = 0;

    if (s->codec_tag == AV_RL32(""WV1F"") && show_bits(gb, 24) == 0x575630) {
        skip_bits(gb, 24);
        if (get_bits(gb, 8) == 0xF0)
            goto end;
    }

    startcode = 0xff;
    for (;;) {
        if (get_bits_count(gb) >= gb->size_in_bits) {
            if (gb->size_in_bits == 8 &&
                (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(""QMP4"")) {
                av_log(s->avctx, AV_LOG_VERBOSE, ""frame skip %d\n"", gb->size_in_bits);
                return FRAME_SKIPPED;  // divx bug
            } else
                return AVERROR_INVALIDDATA;  // end of stream
        }

        /* use the bits after the test */
        v = get_bits(gb, 8);
        startcode = ((startcode << 8) | v) & 0xffffffff;

        if ((startcode & 0xFFFFFF00) != 0x100)
            continue;  // no startcode

        if (s->avctx->debug & FF_DEBUG_STARTCODE) {
            av_log(s->avctx, AV_LOG_DEBUG, ""startcode: %3X "", startcode);
            if (startcode <= 0x11F)
                av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Start"");
            else if (startcode <= 0x12F)
                av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Layer Start"");
            else if (startcode <= 0x13F)
                av_log(s->avctx, AV_LOG_DEBUG, ""Reserved"");
            else if (startcode <= 0x15F)
                av_log(s->avctx, AV_LOG_DEBUG, ""FGS bp start"");
            else if (startcode <= 0x1AF)
                av_log(s->avctx, AV_LOG_DEBUG, ""Reserved"");
            else if (startcode == 0x1B0)
                av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Seq Start"");
            else if (startcode == 0x1B1)
                av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Seq End"");
            else if (startcode == 0x1B2)
                av_log(s->avctx, AV_LOG_DEBUG, ""User Data"");
            else if (startcode == 0x1B3)
                av_log(s->avctx, AV_LOG_DEBUG, ""Group of VOP start"");
            else if (startcode == 0x1B4)
                av_log(s->avctx, AV_LOG_DEBUG, ""Video Session Error"");
            else if (startcode == 0x1B5)
                av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Start"");
            else if (startcode == 0x1B6)
                av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Plane start"");
            else if (startcode == 0x1B7)
                av_log(s->avctx, AV_LOG_DEBUG, ""slice start"");
            else if (startcode == 0x1B8)
                av_log(s->avctx, AV_LOG_DEBUG, ""extension start"");
            else if (startcode == 0x1B9)
                av_log(s->avctx, AV_LOG_DEBUG, ""fgs start"");
            else if (startcode == 0x1BA)
                av_log(s->avctx, AV_LOG_DEBUG, ""FBA Object start"");
            else if (startcode == 0x1BB)
                av_log(s->avctx, AV_LOG_DEBUG, ""FBA Object Plane start"");
            else if (startcode == 0x1BC)
                av_log(s->avctx, AV_LOG_DEBUG, ""Mesh Object start"");
            else if (startcode == 0x1BD)
                av_log(s->avctx, AV_LOG_DEBUG, ""Mesh Object Plane start"");
            else if (startcode == 0x1BE)
                av_log(s->avctx, AV_LOG_DEBUG, ""Still Texture Object start"");
            else if (startcode == 0x1BF)
                av_log(s->avctx, AV_LOG_DEBUG, ""Texture Spatial Layer start"");
            else if (startcode == 0x1C0)
                av_log(s->avctx, AV_LOG_DEBUG, ""Texture SNR Layer start"");
            else if (startcode == 0x1C1)
                av_log(s->avctx, AV_LOG_DEBUG, ""Texture Tile start"");
            else if (startcode == 0x1C2)
                av_log(s->avctx, AV_LOG_DEBUG, ""Texture Shape Layer start"");
            else if (startcode == 0x1C3)
                av_log(s->avctx, AV_LOG_DEBUG, ""stuffing start"");
            else if (startcode <= 0x1C5)
                av_log(s->avctx, AV_LOG_DEBUG, ""reserved"");
            else if (startcode <= 0x1FF)
                av_log(s->avctx, AV_LOG_DEBUG, ""System start"");
            av_log(s->avctx, AV_LOG_DEBUG, "" at %d\n"", get_bits_count(gb));
        }

        if (startcode >= 0x120 && startcode <= 0x12F) {
            if (vol) {
                av_log(s->avctx, AV_LOG_WARNING, ""Ignoring multiple VOL headers\n"");
                continue;
            }
            vol++;
            if ((ret = decode_vol_header(ctx, gb)) < 0)
                return ret;
        } else if (startcode == USER_DATA_STARTCODE) {
            decode_user_data(ctx, gb);
         } else if (startcode == GOP_STARTCODE) {
             mpeg4_decode_gop_header(s, gb);
         } else if (startcode == VOS_STARTCODE) {
            mpeg4_decode_profile_level(s, gb);
            if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&
                (s->avctx->level > 0 && s->avctx->level < 9)) {
                 s->studio_profile = 1;
                 next_start_code_studio(gb);
                 extension_and_user_data(s, gb, 0);
             }
         } else if (startcode == VISUAL_OBJ_STARTCODE) {
             if (s->studio_profile) {
                 if ((ret = decode_studiovisualobject(ctx, gb)) < 0)
                    return ret;
            } else
                mpeg4_decode_visual_object(s, gb);
        } else if (startcode == VOP_STARTCODE) {
            break;
        }

        align_get_bits(gb);
        startcode = 0xff;
    }

end:
    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)
        s->low_delay = 1;
     s->avctx->has_b_frames = !s->low_delay;
 
     if (s->studio_profile) {
         if (!s->avctx->bits_per_raw_sample) {
             av_log(s->avctx, AV_LOG_ERROR, ""Missing VOL header\n"");
             return AVERROR_INVALIDDATA;
        }
        return decode_studio_vop_header(ctx, gb);
    } else
        return decode_vop_header(ctx, gb);
}
",C,"            int profile, level;
            mpeg4_decode_profile_level(s, gb, &profile, &level);
            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&
                (level > 0 && level < 9)) {
            } else if (s->studio_profile) {
                avpriv_request_sample(s->avctx, ""Mixes studio and non studio profile\n"");
                return AVERROR_PATCHWELCOME;
            s->avctx->profile = profile;
            s->avctx->level   = level;
        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
","            mpeg4_decode_profile_level(s, gb);
            if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&
                (s->avctx->level > 0 && s->avctx->level < 9)) {
",,"@@ -1980,15 +1980,15 @@ static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)
     return 0;
 }
 
-static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb)
+static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)
 {
 
-    s->avctx->profile = get_bits(gb, 4);
-    s->avctx->level   = get_bits(gb, 4);
+    *profile = get_bits(gb, 4);
+    *level   = get_bits(gb, 4);
 
     // for Simple profile, level 0
-    if (s->avctx->profile == 0 && s->avctx->level == 8) {
-        s->avctx->level = 0;
+    if (*profile == 0 && *level == 8) {
+        *level = 0;
     }
 
     return 0;
@@ -3211,13 +3211,19 @@ int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)
         } else if (startcode == GOP_STARTCODE) {
             mpeg4_decode_gop_header(s, gb);
         } else if (startcode == VOS_STARTCODE) {
-            mpeg4_decode_profile_level(s, gb);
-            if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&
-                (s->avctx->level > 0 && s->avctx->level < 9)) {
+            int profile, level;
+            mpeg4_decode_profile_level(s, gb, &profile, &level);
+            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&
+                (level > 0 && level < 9)) {
                 s->studio_profile = 1;
                 next_start_code_studio(gb);
                 extension_and_user_data(s, gb, 0);
+            } else if (s->studio_profile) {
+                avpriv_request_sample(s->avctx, ""Mixes studio and non studio profile\n"");
+                return AVERROR_PATCHWELCOME;
             }
+            s->avctx->profile = profile;
+            s->avctx->level   = level;
         } else if (startcode == VISUAL_OBJ_STARTCODE) {
             if (s->studio_profile) {
                 if ((ret = decode_studiovisualobject(ctx, gb)) < 0)
@@ -3238,6 +3244,7 @@ int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)
     s->avctx->has_b_frames = !s->low_delay;
 
     if (s->studio_profile) {
+        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
         if (!s->avctx->bits_per_raw_sample) {
             av_log(s->avctx, AV_LOG_ERROR, ""Missing VOL header\n"");
             return AVERROR_INVALIDDATA;",FFmpeg,2aa9047486dbff12d9e040f917e5f799ed2fd78b,95556e27e2c1d56d9e18f5db34d6f756f3011148,1,"int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)
{
    MpegEncContext *s = &ctx->m;
    unsigned startcode, v;
    int ret;
    int vol = 0;

    /* search next start code */
    align_get_bits(gb);

    // If we have not switched to studio profile than we also did not switch bps
    // that means something else (like a previous instance) outside set bps which
    // would be inconsistant with the currect state, thus reset it
    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)
        s->avctx->bits_per_raw_sample = 0;

    if (s->codec_tag == AV_RL32(""WV1F"") && show_bits(gb, 24) == 0x575630) {
        skip_bits(gb, 24);
        if (get_bits(gb, 8) == 0xF0)
            goto end;
    }

    startcode = 0xff;
    for (;;) {
        if (get_bits_count(gb) >= gb->size_in_bits) {
            if (gb->size_in_bits == 8 &&
                (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(""QMP4"")) {
                av_log(s->avctx, AV_LOG_VERBOSE, ""frame skip %d\n"", gb->size_in_bits);
                return FRAME_SKIPPED;  // divx bug
            } else
                return AVERROR_INVALIDDATA;  // end of stream
        }

        /* use the bits after the test */
        v = get_bits(gb, 8);
        startcode = ((startcode << 8) | v) & 0xffffffff;

        if ((startcode & 0xFFFFFF00) != 0x100)
            continue;  // no startcode

        if (s->avctx->debug & FF_DEBUG_STARTCODE) {
            av_log(s->avctx, AV_LOG_DEBUG, ""startcode: %3X "", startcode);
            if (startcode <= 0x11F)
                av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Start"");
            else if (startcode <= 0x12F)
                av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Layer Start"");
            else if (startcode <= 0x13F)
                av_log(s->avctx, AV_LOG_DEBUG, ""Reserved"");
            else if (startcode <= 0x15F)
                av_log(s->avctx, AV_LOG_DEBUG, ""FGS bp start"");
            else if (startcode <= 0x1AF)
                av_log(s->avctx, AV_LOG_DEBUG, ""Reserved"");
            else if (startcode == 0x1B0)
                av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Seq Start"");
            else if (startcode == 0x1B1)
                av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Seq End"");
            else if (startcode == 0x1B2)
                av_log(s->avctx, AV_LOG_DEBUG, ""User Data"");
            else if (startcode == 0x1B3)
                av_log(s->avctx, AV_LOG_DEBUG, ""Group of VOP start"");
            else if (startcode == 0x1B4)
                av_log(s->avctx, AV_LOG_DEBUG, ""Video Session Error"");
            else if (startcode == 0x1B5)
                av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Start"");
            else if (startcode == 0x1B6)
                av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Plane start"");
            else if (startcode == 0x1B7)
                av_log(s->avctx, AV_LOG_DEBUG, ""slice start"");
            else if (startcode == 0x1B8)
                av_log(s->avctx, AV_LOG_DEBUG, ""extension start"");
            else if (startcode == 0x1B9)
                av_log(s->avctx, AV_LOG_DEBUG, ""fgs start"");
            else if (startcode == 0x1BA)
                av_log(s->avctx, AV_LOG_DEBUG, ""FBA Object start"");
            else if (startcode == 0x1BB)
                av_log(s->avctx, AV_LOG_DEBUG, ""FBA Object Plane start"");
            else if (startcode == 0x1BC)
                av_log(s->avctx, AV_LOG_DEBUG, ""Mesh Object start"");
            else if (startcode == 0x1BD)
                av_log(s->avctx, AV_LOG_DEBUG, ""Mesh Object Plane start"");
            else if (startcode == 0x1BE)
                av_log(s->avctx, AV_LOG_DEBUG, ""Still Texture Object start"");
            else if (startcode == 0x1BF)
                av_log(s->avctx, AV_LOG_DEBUG, ""Texture Spatial Layer start"");
            else if (startcode == 0x1C0)
                av_log(s->avctx, AV_LOG_DEBUG, ""Texture SNR Layer start"");
            else if (startcode == 0x1C1)
                av_log(s->avctx, AV_LOG_DEBUG, ""Texture Tile start"");
            else if (startcode == 0x1C2)
                av_log(s->avctx, AV_LOG_DEBUG, ""Texture Shape Layer start"");
            else if (startcode == 0x1C3)
                av_log(s->avctx, AV_LOG_DEBUG, ""stuffing start"");
            else if (startcode <= 0x1C5)
                av_log(s->avctx, AV_LOG_DEBUG, ""reserved"");
            else if (startcode <= 0x1FF)
                av_log(s->avctx, AV_LOG_DEBUG, ""System start"");
            av_log(s->avctx, AV_LOG_DEBUG, "" at %d\n"", get_bits_count(gb));
        }

        if (startcode >= 0x120 && startcode <= 0x12F) {
            if (vol) {
                av_log(s->avctx, AV_LOG_WARNING, ""Ignoring multiple VOL headers\n"");
                continue;
            }
            vol++;
            if ((ret = decode_vol_header(ctx, gb)) < 0)
                return ret;
        } else if (startcode == USER_DATA_STARTCODE) {
            decode_user_data(ctx, gb);
         } else if (startcode == GOP_STARTCODE) {
             mpeg4_decode_gop_header(s, gb);
         } else if (startcode == VOS_STARTCODE) {
//flaw_line_below:
            mpeg4_decode_profile_level(s, gb);
//flaw_line_below:
            if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&
//flaw_line_below:
                (s->avctx->level > 0 && s->avctx->level < 9)) {
//fix_flaw_line_below:
//            int profile, level;
//fix_flaw_line_below:
//            mpeg4_decode_profile_level(s, gb, &profile, &level);
//fix_flaw_line_below:
//            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&
//fix_flaw_line_below:
//                (level > 0 && level < 9)) {
                 s->studio_profile = 1;
                 next_start_code_studio(gb);
                 extension_and_user_data(s, gb, 0);
//fix_flaw_line_below:
//            } else if (s->studio_profile) {
//fix_flaw_line_below:
//                avpriv_request_sample(s->avctx, ""Mixes studio and non studio profile\n"");
//fix_flaw_line_below:
//                return AVERROR_PATCHWELCOME;
             }
//fix_flaw_line_below:
//            s->avctx->profile = profile;
//fix_flaw_line_below:
//            s->avctx->level   = level;
         } else if (startcode == VISUAL_OBJ_STARTCODE) {
             if (s->studio_profile) {
                 if ((ret = decode_studiovisualobject(ctx, gb)) < 0)
                    return ret;
            } else
                mpeg4_decode_visual_object(s, gb);
        } else if (startcode == VOP_STARTCODE) {
            break;
        }

        align_get_bits(gb);
        startcode = 0xff;
    }

end:
    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)
        s->low_delay = 1;
     s->avctx->has_b_frames = !s->low_delay;
 
     if (s->studio_profile) {
//fix_flaw_line_below:
//        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
         if (!s->avctx->bits_per_raw_sample) {
             av_log(s->avctx, AV_LOG_ERROR, ""Missing VOL header\n"");
             return AVERROR_INVALIDDATA;
        }
        return decode_studio_vop_header(ctx, gb);
    } else
        return decode_vop_header(ctx, gb);
}
"
4597,182333,,Remote,Not required,Partial,CVE-2018-13301,https://www.cvedetails.com/cve/CVE-2018-13301/,CWE-476,Medium,,,,2018-07-05,4.3,"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.",2018-07-18,DoS ,5,https://github.com/FFmpeg/FFmpeg/commit/2aa9047486dbff12d9e040f917e5f799ed2fd78b,2aa9047486dbff12d9e040f917e5f799ed2fd78b,"avcodec/mpeg4videodec: Check read profile before setting it

Fixes: null pointer dereference
Fixes: ffmpeg_crash_7.avi

Found-by: Thuan Pham, Marcel Böhme, Andrew Santosa and Alexandru Razvan Caciulescu with AFLSmart
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",4,libavcodec/mpeg4videodec.c,"{""sha"": ""54a84962444f4935fe874734ef769a7fcb485497"", ""filename"": ""libavcodec/mpeg4videodec.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 8, ""changes"": 23, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/2aa9047486dbff12d9e040f917e5f799ed2fd78b/libavcodec/mpeg4videodec.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/2aa9047486dbff12d9e040f917e5f799ed2fd78b/libavcodec/mpeg4videodec.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavcodec/mpeg4videodec.c?ref=2aa9047486dbff12d9e040f917e5f799ed2fd78b"", ""patch"": ""@@ -1980,15 +1980,15 @@ static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)\n     return 0;\n }\n \n-static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb)\n+static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)\n {\n \n-    s->avctx->profile = get_bits(gb, 4);\n-    s->avctx->level   = get_bits(gb, 4);\n+    *profile = get_bits(gb, 4);\n+    *level   = get_bits(gb, 4);\n \n     // for Simple profile, level 0\n-    if (s->avctx->profile == 0 && s->avctx->level == 8) {\n-        s->avctx->level = 0;\n+    if (*profile == 0 && *level == 8) {\n+        *level = 0;\n     }\n \n     return 0;\n@@ -3211,13 +3211,19 @@ int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n         } else if (startcode == GOP_STARTCODE) {\n             mpeg4_decode_gop_header(s, gb);\n         } else if (startcode == VOS_STARTCODE) {\n-            mpeg4_decode_profile_level(s, gb);\n-            if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n-                (s->avctx->level > 0 && s->avctx->level < 9)) {\n+            int profile, level;\n+            mpeg4_decode_profile_level(s, gb, &profile, &level);\n+            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n+                (level > 0 && level < 9)) {\n                 s->studio_profile = 1;\n                 next_start_code_studio(gb);\n                 extension_and_user_data(s, gb, 0);\n+            } else if (s->studio_profile) {\n+                avpriv_request_sample(s->avctx, \""Mixes studio and non studio profile\\n\"");\n+                return AVERROR_PATCHWELCOME;\n             }\n+            s->avctx->profile = profile;\n+            s->avctx->level   = level;\n         } else if (startcode == VISUAL_OBJ_STARTCODE) {\n             if (s->studio_profile) {\n                 if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n@@ -3238,6 +3244,7 @@ int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n     s->avctx->has_b_frames = !s->low_delay;\n \n     if (s->studio_profile) {\n+        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n         if (!s->avctx->bits_per_raw_sample) {\n             av_log(s->avctx, AV_LOG_ERROR, \""Missing VOL header\\n\"");\n             return AVERROR_INVALIDDATA;""}","static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb)
static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)
 {
 
    *profile = get_bits(gb, 4);
    *level   = get_bits(gb, 4);
 
    if (*profile == 0 && *level == 8) {
        *level = 0;
     }
 
     return 0;
}
","static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb)
 {
 
    s->avctx->profile = get_bits(gb, 4);
    s->avctx->level   = get_bits(gb, 4);
 
    if (s->avctx->profile == 0 && s->avctx->level == 8) {
        s->avctx->level = 0;
     }
 
     return 0;
}
",C,"static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)
    *profile = get_bits(gb, 4);
    *level   = get_bits(gb, 4);
    if (*profile == 0 && *level == 8) {
        *level = 0;
","    s->avctx->profile = get_bits(gb, 4);
    s->avctx->level   = get_bits(gb, 4);
    if (s->avctx->profile == 0 && s->avctx->level == 8) {
        s->avctx->level = 0;
",,"@@ -1980,15 +1980,15 @@ static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)
     return 0;
 }
 
-static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb)
+static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)
 {
 
-    s->avctx->profile = get_bits(gb, 4);
-    s->avctx->level   = get_bits(gb, 4);
+    *profile = get_bits(gb, 4);
+    *level   = get_bits(gb, 4);
 
     // for Simple profile, level 0
-    if (s->avctx->profile == 0 && s->avctx->level == 8) {
-        s->avctx->level = 0;
+    if (*profile == 0 && *level == 8) {
+        *level = 0;
     }
 
     return 0;
@@ -3211,13 +3211,19 @@ int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)
         } else if (startcode == GOP_STARTCODE) {
             mpeg4_decode_gop_header(s, gb);
         } else if (startcode == VOS_STARTCODE) {
-            mpeg4_decode_profile_level(s, gb);
-            if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&
-                (s->avctx->level > 0 && s->avctx->level < 9)) {
+            int profile, level;
+            mpeg4_decode_profile_level(s, gb, &profile, &level);
+            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&
+                (level > 0 && level < 9)) {
                 s->studio_profile = 1;
                 next_start_code_studio(gb);
                 extension_and_user_data(s, gb, 0);
+            } else if (s->studio_profile) {
+                avpriv_request_sample(s->avctx, ""Mixes studio and non studio profile\n"");
+                return AVERROR_PATCHWELCOME;
             }
+            s->avctx->profile = profile;
+            s->avctx->level   = level;
         } else if (startcode == VISUAL_OBJ_STARTCODE) {
             if (s->studio_profile) {
                 if ((ret = decode_studiovisualobject(ctx, gb)) < 0)
@@ -3238,6 +3244,7 @@ int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)
     s->avctx->has_b_frames = !s->low_delay;
 
     if (s->studio_profile) {
+        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
         if (!s->avctx->bits_per_raw_sample) {
             av_log(s->avctx, AV_LOG_ERROR, ""Missing VOL header\n"");
             return AVERROR_INVALIDDATA;",FFmpeg,2aa9047486dbff12d9e040f917e5f799ed2fd78b,95556e27e2c1d56d9e18f5db34d6f756f3011148,1,"static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb)
//fix_flaw_line_below:
//static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)
 {
 
//flaw_line_below:
    s->avctx->profile = get_bits(gb, 4);
//flaw_line_below:
    s->avctx->level   = get_bits(gb, 4);
//fix_flaw_line_below:
//    *profile = get_bits(gb, 4);
//fix_flaw_line_below:
//    *level   = get_bits(gb, 4);
 
     // for Simple profile, level 0
//flaw_line_below:
    if (s->avctx->profile == 0 && s->avctx->level == 8) {
//flaw_line_below:
        s->avctx->level = 0;
//fix_flaw_line_below:
//    if (*profile == 0 && *level == 8) {
//fix_flaw_line_below:
//        *level = 0;
     }
 
     return 0;
}
"
4599,182335,,Remote,Not required,Partial,CVE-2018-13095,https://www.cvedetails.com/cve/CVE-2018-13095/,CWE-476,Medium,,,,2018-07-03,4.3,"An issue was discovered in fs/xfs/libxfs/xfs_inode_buf.c in the Linux kernel through 4.17.3. A denial of service (memory corruption and BUG) can occur for a corrupted xfs image upon encountering an inode that is in extent format, but has more extents than fit in the inode fork.",2019-06-04,DoS Mem. Corr. ,6,https://github.com/torvalds/linux/commit/23fcb3340d033d9f081e21e6c12c2db7eaa541d3,23fcb3340d033d9f081e21e6c12c2db7eaa541d3,"xfs: More robust inode extent count validation

When the inode is in extent format, it can't have more extents that
fit in the inode fork. We don't currenty check this, and so this
corruption goes unnoticed by the inode verifiers. This can lead to
crashes operating on invalid in-memory structures.

Attempts to access such a inode will now error out in the verifier
rather than allowing modification operations to proceed.

Reported-by: Wen Xu <wen.xu@gatech.edu>
Signed-off-by: Dave Chinner <dchinner@redhat.com>
Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
[darrick: fix a typedef, add some braces and breaks to shut up compiler warnings]
Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>",29,fs/xfs/libxfs/xfs_inode_buf.c,"{""sha"": ""7b4a43deb83e0c4017e8df1c2756147c88c1716d"", ""filename"": ""fs/xfs/libxfs/xfs_format.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/23fcb3340d033d9f081e21e6c12c2db7eaa541d3/fs/xfs/libxfs/xfs_format.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/23fcb3340d033d9f081e21e6c12c2db7eaa541d3/fs/xfs/libxfs/xfs_format.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/libxfs/xfs_format.h?ref=23fcb3340d033d9f081e21e6c12c2db7eaa541d3"", ""patch"": ""@@ -962,6 +962,9 @@ typedef enum xfs_dinode_fmt {\n \t\tXFS_DFORK_DSIZE(dip, mp) : \\\n \t\tXFS_DFORK_ASIZE(dip, mp))\n \n+#define XFS_DFORK_MAXEXT(dip, mp, w) \\\n+\t(XFS_DFORK_SIZE(dip, mp, w) / sizeof(struct xfs_bmbt_rec))\n+\n /*\n  * Return pointers to the data or attribute forks.\n  */""}<_**next**_>{""sha"": ""33dc34655ac3ddb32a5a5fa4711048285c8a0343"", ""filename"": ""fs/xfs/libxfs/xfs_inode_buf.c"", ""status"": ""modified"", ""additions"": 47, ""deletions"": 29, ""changes"": 76, ""blob_url"": ""https://github.com/torvalds/linux/blob/23fcb3340d033d9f081e21e6c12c2db7eaa541d3/fs/xfs/libxfs/xfs_inode_buf.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/23fcb3340d033d9f081e21e6c12c2db7eaa541d3/fs/xfs/libxfs/xfs_inode_buf.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/libxfs/xfs_inode_buf.c?ref=23fcb3340d033d9f081e21e6c12c2db7eaa541d3"", ""patch"": ""@@ -374,6 +374,47 @@ xfs_log_dinode_to_disk(\n \t}\n }\n \n+static xfs_failaddr_t\n+xfs_dinode_verify_fork(\n+\tstruct xfs_dinode\t*dip,\n+\tstruct xfs_mount\t*mp,\n+\tint\t\t\twhichfork)\n+{\n+\tuint32_t\t\tdi_nextents = XFS_DFORK_NEXTENTS(dip, whichfork);\n+\n+\tswitch (XFS_DFORK_FORMAT(dip, whichfork)) {\n+\tcase XFS_DINODE_FMT_LOCAL:\n+\t\t/*\n+\t\t * no local regular files yet\n+\t\t */\n+\t\tif (whichfork == XFS_DATA_FORK) {\n+\t\t\tif (S_ISREG(be16_to_cpu(dip->di_mode)))\n+\t\t\t\treturn __this_address;\n+\t\t\tif (be64_to_cpu(dip->di_size) >\n+\t\t\t\t\tXFS_DFORK_SIZE(dip, mp, whichfork))\n+\t\t\t\treturn __this_address;\n+\t\t}\n+\t\tif (di_nextents)\n+\t\t\treturn __this_address;\n+\t\tbreak;\n+\tcase XFS_DINODE_FMT_EXTENTS:\n+\t\tif (di_nextents > XFS_DFORK_MAXEXT(dip, mp, whichfork))\n+\t\t\treturn __this_address;\n+\t\tbreak;\n+\tcase XFS_DINODE_FMT_BTREE:\n+\t\tif (whichfork == XFS_ATTR_FORK) {\n+\t\t\tif (di_nextents > MAXAEXTNUM)\n+\t\t\t\treturn __this_address;\n+\t\t} else if (di_nextents > MAXEXTNUM) {\n+\t\t\treturn __this_address;\n+\t\t}\n+\t\tbreak;\n+\tdefault:\n+\t\treturn __this_address;\n+\t}\n+\treturn NULL;\n+}\n+\n xfs_failaddr_t\n xfs_dinode_verify(\n \tstruct xfs_mount\t*mp,\n@@ -441,24 +482,9 @@ xfs_dinode_verify(\n \tcase S_IFREG:\n \tcase S_IFLNK:\n \tcase S_IFDIR:\n-\t\tswitch (dip->di_format) {\n-\t\tcase XFS_DINODE_FMT_LOCAL:\n-\t\t\t/*\n-\t\t\t * no local regular files yet\n-\t\t\t */\n-\t\t\tif (S_ISREG(mode))\n-\t\t\t\treturn __this_address;\n-\t\t\tif (di_size > XFS_DFORK_DSIZE(dip, mp))\n-\t\t\t\treturn __this_address;\n-\t\t\tif (dip->di_nextents)\n-\t\t\t\treturn __this_address;\n-\t\t\t/* fall through */\n-\t\tcase XFS_DINODE_FMT_EXTENTS:\n-\t\tcase XFS_DINODE_FMT_BTREE:\n-\t\t\tbreak;\n-\t\tdefault:\n-\t\t\treturn __this_address;\n-\t\t}\n+\t\tfa = xfs_dinode_verify_fork(dip, mp, XFS_DATA_FORK);\n+\t\tif (fa)\n+\t\t\treturn fa;\n \t\tbreak;\n \tcase 0:\n \t\t/* Uninitialized inode ok. */\n@@ -468,17 +494,9 @@ xfs_dinode_verify(\n \t}\n \n \tif (XFS_DFORK_Q(dip)) {\n-\t\tswitch (dip->di_aformat) {\n-\t\tcase XFS_DINODE_FMT_LOCAL:\n-\t\t\tif (dip->di_anextents)\n-\t\t\t\treturn __this_address;\n-\t\t/* fall through */\n-\t\tcase XFS_DINODE_FMT_EXTENTS:\n-\t\tcase XFS_DINODE_FMT_BTREE:\n-\t\t\tbreak;\n-\t\tdefault:\n-\t\t\treturn __this_address;\n-\t\t}\n+\t\tfa = xfs_dinode_verify_fork(dip, mp, XFS_ATTR_FORK);\n+\t\tif (fa)\n+\t\t\treturn fa;\n \t} else {\n \t\t/*\n \t\t * If there is no fork offset, this may be a freshly-made inode""}"," xfs_dinode_verify(
 	struct xfs_mount	*mp,
	xfs_ino_t		ino,
	struct xfs_dinode	*dip)
{
	xfs_failaddr_t		fa;
	uint16_t		mode;
	uint16_t		flags;
	uint64_t		flags2;
	uint64_t		di_size;

	if (dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC))
		return __this_address;

	/* Verify v3 integrity information first */
	if (dip->di_version >= 3) {
		if (!xfs_sb_version_hascrc(&mp->m_sb))
			return __this_address;
		if (!xfs_verify_cksum((char *)dip, mp->m_sb.sb_inodesize,
				      XFS_DINODE_CRC_OFF))
			return __this_address;
		if (be64_to_cpu(dip->di_ino) != ino)
			return __this_address;
		if (!uuid_equal(&dip->di_uuid, &mp->m_sb.sb_meta_uuid))
			return __this_address;
	}

	/* don't allow invalid i_size */
	di_size = be64_to_cpu(dip->di_size);
	if (di_size & (1ULL << 63))
		return __this_address;

	mode = be16_to_cpu(dip->di_mode);
	if (mode && xfs_mode_to_ftype(mode) == XFS_DIR3_FT_UNKNOWN)
		return __this_address;

	/* No zero-length symlinks/dirs. */
	if ((S_ISLNK(mode) || S_ISDIR(mode)) && di_size == 0)
		return __this_address;

	/* Fork checks carried over from xfs_iformat_fork */
	if (mode &&
	    be32_to_cpu(dip->di_nextents) + be16_to_cpu(dip->di_anextents) >
			be64_to_cpu(dip->di_nblocks))
		return __this_address;

	if (mode && XFS_DFORK_BOFF(dip) > mp->m_sb.sb_inodesize)
		return __this_address;

	flags = be16_to_cpu(dip->di_flags);

	if (mode && (flags & XFS_DIFLAG_REALTIME) && !mp->m_rtdev_targp)
		return __this_address;

	/* Do we have appropriate data fork formats for the mode? */
	switch (mode & S_IFMT) {
	case S_IFIFO:
	case S_IFCHR:
	case S_IFBLK:
	case S_IFSOCK:
		if (dip->di_format != XFS_DINODE_FMT_DEV)
			return __this_address;
		break;
 	case S_IFREG:
 	case S_IFLNK:
 	case S_IFDIR:
		fa = xfs_dinode_verify_fork(dip, mp, XFS_DATA_FORK);
		if (fa)
			return fa;
 		break;
 	case 0:
 		/* Uninitialized inode ok. */
		break;
	default:
		return __this_address;
 	}
 
 	if (XFS_DFORK_Q(dip)) {
		fa = xfs_dinode_verify_fork(dip, mp, XFS_ATTR_FORK);
		if (fa)
			return fa;
 	} else {
 		/*
 		 * If there is no fork offset, this may be a freshly-made inode
		 * in a new disk cluster, in which case di_aformat is zeroed.
		 * Otherwise, such an inode must be in EXTENTS format; this goes
		 * for freed inodes as well.
		 */
		switch (dip->di_aformat) {
		case 0:
		case XFS_DINODE_FMT_EXTENTS:
			break;
		default:
			return __this_address;
		}
		if (dip->di_anextents)
			return __this_address;
	}

	/* extent size hint validation */
	fa = xfs_inode_validate_extsize(mp, be32_to_cpu(dip->di_extsize),
			mode, flags);
	if (fa)
		return fa;

	/* only version 3 or greater inodes are extensively verified here */
	if (dip->di_version < 3)
		return NULL;

	flags2 = be64_to_cpu(dip->di_flags2);

	/* don't allow reflink/cowextsize if we don't have reflink */
	if ((flags2 & (XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE)) &&
	     !xfs_sb_version_hasreflink(&mp->m_sb))
		return __this_address;

	/* only regular files get reflink */
	if ((flags2 & XFS_DIFLAG2_REFLINK) && (mode & S_IFMT) != S_IFREG)
		return __this_address;

	/* don't let reflink and realtime mix */
	if ((flags2 & XFS_DIFLAG2_REFLINK) && (flags & XFS_DIFLAG_REALTIME))
		return __this_address;

	/* don't let reflink and dax mix */
	if ((flags2 & XFS_DIFLAG2_REFLINK) && (flags2 & XFS_DIFLAG2_DAX))
		return __this_address;

	/* COW extent size hint validation */
	fa = xfs_inode_validate_cowextsize(mp, be32_to_cpu(dip->di_cowextsize),
			mode, flags, flags2);
	if (fa)
		return fa;

	return NULL;
}
"," xfs_dinode_verify(
 	struct xfs_mount	*mp,
	xfs_ino_t		ino,
	struct xfs_dinode	*dip)
{
	xfs_failaddr_t		fa;
	uint16_t		mode;
	uint16_t		flags;
	uint64_t		flags2;
	uint64_t		di_size;

	if (dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC))
		return __this_address;

	/* Verify v3 integrity information first */
	if (dip->di_version >= 3) {
		if (!xfs_sb_version_hascrc(&mp->m_sb))
			return __this_address;
		if (!xfs_verify_cksum((char *)dip, mp->m_sb.sb_inodesize,
				      XFS_DINODE_CRC_OFF))
			return __this_address;
		if (be64_to_cpu(dip->di_ino) != ino)
			return __this_address;
		if (!uuid_equal(&dip->di_uuid, &mp->m_sb.sb_meta_uuid))
			return __this_address;
	}

	/* don't allow invalid i_size */
	di_size = be64_to_cpu(dip->di_size);
	if (di_size & (1ULL << 63))
		return __this_address;

	mode = be16_to_cpu(dip->di_mode);
	if (mode && xfs_mode_to_ftype(mode) == XFS_DIR3_FT_UNKNOWN)
		return __this_address;

	/* No zero-length symlinks/dirs. */
	if ((S_ISLNK(mode) || S_ISDIR(mode)) && di_size == 0)
		return __this_address;

	/* Fork checks carried over from xfs_iformat_fork */
	if (mode &&
	    be32_to_cpu(dip->di_nextents) + be16_to_cpu(dip->di_anextents) >
			be64_to_cpu(dip->di_nblocks))
		return __this_address;

	if (mode && XFS_DFORK_BOFF(dip) > mp->m_sb.sb_inodesize)
		return __this_address;

	flags = be16_to_cpu(dip->di_flags);

	if (mode && (flags & XFS_DIFLAG_REALTIME) && !mp->m_rtdev_targp)
		return __this_address;

	/* Do we have appropriate data fork formats for the mode? */
	switch (mode & S_IFMT) {
	case S_IFIFO:
	case S_IFCHR:
	case S_IFBLK:
	case S_IFSOCK:
		if (dip->di_format != XFS_DINODE_FMT_DEV)
			return __this_address;
		break;
 	case S_IFREG:
 	case S_IFLNK:
 	case S_IFDIR:
		switch (dip->di_format) {
		case XFS_DINODE_FMT_LOCAL:
			/*
			 * no local regular files yet
			 */
			if (S_ISREG(mode))
				return __this_address;
			if (di_size > XFS_DFORK_DSIZE(dip, mp))
				return __this_address;
			if (dip->di_nextents)
				return __this_address;
			/* fall through */
		case XFS_DINODE_FMT_EXTENTS:
		case XFS_DINODE_FMT_BTREE:
			break;
		default:
			return __this_address;
		}
 		break;
 	case 0:
 		/* Uninitialized inode ok. */
		break;
	default:
		return __this_address;
 	}
 
 	if (XFS_DFORK_Q(dip)) {
		switch (dip->di_aformat) {
		case XFS_DINODE_FMT_LOCAL:
			if (dip->di_anextents)
				return __this_address;
		/* fall through */
		case XFS_DINODE_FMT_EXTENTS:
		case XFS_DINODE_FMT_BTREE:
			break;
		default:
			return __this_address;
		}
 	} else {
 		/*
 		 * If there is no fork offset, this may be a freshly-made inode
		 * in a new disk cluster, in which case di_aformat is zeroed.
		 * Otherwise, such an inode must be in EXTENTS format; this goes
		 * for freed inodes as well.
		 */
		switch (dip->di_aformat) {
		case 0:
		case XFS_DINODE_FMT_EXTENTS:
			break;
		default:
			return __this_address;
		}
		if (dip->di_anextents)
			return __this_address;
	}

	/* extent size hint validation */
	fa = xfs_inode_validate_extsize(mp, be32_to_cpu(dip->di_extsize),
			mode, flags);
	if (fa)
		return fa;

	/* only version 3 or greater inodes are extensively verified here */
	if (dip->di_version < 3)
		return NULL;

	flags2 = be64_to_cpu(dip->di_flags2);

	/* don't allow reflink/cowextsize if we don't have reflink */
	if ((flags2 & (XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE)) &&
	     !xfs_sb_version_hasreflink(&mp->m_sb))
		return __this_address;

	/* only regular files get reflink */
	if ((flags2 & XFS_DIFLAG2_REFLINK) && (mode & S_IFMT) != S_IFREG)
		return __this_address;

	/* don't let reflink and realtime mix */
	if ((flags2 & XFS_DIFLAG2_REFLINK) && (flags & XFS_DIFLAG_REALTIME))
		return __this_address;

	/* don't let reflink and dax mix */
	if ((flags2 & XFS_DIFLAG2_REFLINK) && (flags2 & XFS_DIFLAG2_DAX))
		return __this_address;

	/* COW extent size hint validation */
	fa = xfs_inode_validate_cowextsize(mp, be32_to_cpu(dip->di_cowextsize),
			mode, flags, flags2);
	if (fa)
		return fa;

	return NULL;
}
",C,"		fa = xfs_dinode_verify_fork(dip, mp, XFS_DATA_FORK);
		if (fa)
			return fa;
		fa = xfs_dinode_verify_fork(dip, mp, XFS_ATTR_FORK);
		if (fa)
			return fa;
","		switch (dip->di_format) {
		case XFS_DINODE_FMT_LOCAL:
			/*
			 * no local regular files yet
			 */
			if (S_ISREG(mode))
				return __this_address;
			if (di_size > XFS_DFORK_DSIZE(dip, mp))
				return __this_address;
			if (dip->di_nextents)
				return __this_address;
			/* fall through */
		case XFS_DINODE_FMT_EXTENTS:
		case XFS_DINODE_FMT_BTREE:
			break;
		default:
			return __this_address;
		}
		switch (dip->di_aformat) {
		case XFS_DINODE_FMT_LOCAL:
			if (dip->di_anextents)
				return __this_address;
		/* fall through */
		case XFS_DINODE_FMT_EXTENTS:
		case XFS_DINODE_FMT_BTREE:
			break;
		default:
			return __this_address;
		}
",,"@@ -374,6 +374,47 @@ xfs_log_dinode_to_disk(
 	}
 }
 
+static xfs_failaddr_t
+xfs_dinode_verify_fork(
+	struct xfs_dinode	*dip,
+	struct xfs_mount	*mp,
+	int			whichfork)
+{
+	uint32_t		di_nextents = XFS_DFORK_NEXTENTS(dip, whichfork);
+
+	switch (XFS_DFORK_FORMAT(dip, whichfork)) {
+	case XFS_DINODE_FMT_LOCAL:
+		/*
+		 * no local regular files yet
+		 */
+		if (whichfork == XFS_DATA_FORK) {
+			if (S_ISREG(be16_to_cpu(dip->di_mode)))
+				return __this_address;
+			if (be64_to_cpu(dip->di_size) >
+					XFS_DFORK_SIZE(dip, mp, whichfork))
+				return __this_address;
+		}
+		if (di_nextents)
+			return __this_address;
+		break;
+	case XFS_DINODE_FMT_EXTENTS:
+		if (di_nextents > XFS_DFORK_MAXEXT(dip, mp, whichfork))
+			return __this_address;
+		break;
+	case XFS_DINODE_FMT_BTREE:
+		if (whichfork == XFS_ATTR_FORK) {
+			if (di_nextents > MAXAEXTNUM)
+				return __this_address;
+		} else if (di_nextents > MAXEXTNUM) {
+			return __this_address;
+		}
+		break;
+	default:
+		return __this_address;
+	}
+	return NULL;
+}
+
 xfs_failaddr_t
 xfs_dinode_verify(
 	struct xfs_mount	*mp,
@@ -441,24 +482,9 @@ xfs_dinode_verify(
 	case S_IFREG:
 	case S_IFLNK:
 	case S_IFDIR:
-		switch (dip->di_format) {
-		case XFS_DINODE_FMT_LOCAL:
-			/*
-			 * no local regular files yet
-			 */
-			if (S_ISREG(mode))
-				return __this_address;
-			if (di_size > XFS_DFORK_DSIZE(dip, mp))
-				return __this_address;
-			if (dip->di_nextents)
-				return __this_address;
-			/* fall through */
-		case XFS_DINODE_FMT_EXTENTS:
-		case XFS_DINODE_FMT_BTREE:
-			break;
-		default:
-			return __this_address;
-		}
+		fa = xfs_dinode_verify_fork(dip, mp, XFS_DATA_FORK);
+		if (fa)
+			return fa;
 		break;
 	case 0:
 		/* Uninitialized inode ok. */
@@ -468,17 +494,9 @@ xfs_dinode_verify(
 	}
 
 	if (XFS_DFORK_Q(dip)) {
-		switch (dip->di_aformat) {
-		case XFS_DINODE_FMT_LOCAL:
-			if (dip->di_anextents)
-				return __this_address;
-		/* fall through */
-		case XFS_DINODE_FMT_EXTENTS:
-		case XFS_DINODE_FMT_BTREE:
-			break;
-		default:
-			return __this_address;
-		}
+		fa = xfs_dinode_verify_fork(dip, mp, XFS_ATTR_FORK);
+		if (fa)
+			return fa;
 	} else {
 		/*
 		 * If there is no fork offset, this may be a freshly-made inode",linux,23fcb3340d033d9f081e21e6c12c2db7eaa541d3,e2ac836307e346969737c60075fdb01bed1af503,1," xfs_dinode_verify(
 	struct xfs_mount	*mp,
	xfs_ino_t		ino,
	struct xfs_dinode	*dip)
{
	xfs_failaddr_t		fa;
	uint16_t		mode;
	uint16_t		flags;
	uint64_t		flags2;
	uint64_t		di_size;

	if (dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC))
		return __this_address;

	/* Verify v3 integrity information first */
	if (dip->di_version >= 3) {
		if (!xfs_sb_version_hascrc(&mp->m_sb))
			return __this_address;
		if (!xfs_verify_cksum((char *)dip, mp->m_sb.sb_inodesize,
				      XFS_DINODE_CRC_OFF))
			return __this_address;
		if (be64_to_cpu(dip->di_ino) != ino)
			return __this_address;
		if (!uuid_equal(&dip->di_uuid, &mp->m_sb.sb_meta_uuid))
			return __this_address;
	}

	/* don't allow invalid i_size */
	di_size = be64_to_cpu(dip->di_size);
	if (di_size & (1ULL << 63))
		return __this_address;

	mode = be16_to_cpu(dip->di_mode);
	if (mode && xfs_mode_to_ftype(mode) == XFS_DIR3_FT_UNKNOWN)
		return __this_address;

	/* No zero-length symlinks/dirs. */
	if ((S_ISLNK(mode) || S_ISDIR(mode)) && di_size == 0)
		return __this_address;

	/* Fork checks carried over from xfs_iformat_fork */
	if (mode &&
	    be32_to_cpu(dip->di_nextents) + be16_to_cpu(dip->di_anextents) >
			be64_to_cpu(dip->di_nblocks))
		return __this_address;

	if (mode && XFS_DFORK_BOFF(dip) > mp->m_sb.sb_inodesize)
		return __this_address;

	flags = be16_to_cpu(dip->di_flags);

	if (mode && (flags & XFS_DIFLAG_REALTIME) && !mp->m_rtdev_targp)
		return __this_address;

	/* Do we have appropriate data fork formats for the mode? */
	switch (mode & S_IFMT) {
	case S_IFIFO:
	case S_IFCHR:
	case S_IFBLK:
	case S_IFSOCK:
		if (dip->di_format != XFS_DINODE_FMT_DEV)
			return __this_address;
		break;
 	case S_IFREG:
 	case S_IFLNK:
 	case S_IFDIR:
//flaw_line_below:
		switch (dip->di_format) {
//flaw_line_below:
		case XFS_DINODE_FMT_LOCAL:
//flaw_line_below:
			/*
//flaw_line_below:
			 * no local regular files yet
//flaw_line_below:
			 */
//flaw_line_below:
			if (S_ISREG(mode))
//flaw_line_below:
				return __this_address;
//flaw_line_below:
			if (di_size > XFS_DFORK_DSIZE(dip, mp))
//flaw_line_below:
				return __this_address;
//flaw_line_below:
			if (dip->di_nextents)
//flaw_line_below:
				return __this_address;
//flaw_line_below:
			/* fall through */
//flaw_line_below:
		case XFS_DINODE_FMT_EXTENTS:
//flaw_line_below:
		case XFS_DINODE_FMT_BTREE:
//flaw_line_below:
			break;
//flaw_line_below:
		default:
//flaw_line_below:
			return __this_address;
//flaw_line_below:
		}
//fix_flaw_line_below:
//		fa = xfs_dinode_verify_fork(dip, mp, XFS_DATA_FORK);
//fix_flaw_line_below:
//		if (fa)
//fix_flaw_line_below:
//			return fa;
 		break;
 	case 0:
 		/* Uninitialized inode ok. */
		break;
	default:
		return __this_address;
 	}
 
 	if (XFS_DFORK_Q(dip)) {
//flaw_line_below:
		switch (dip->di_aformat) {
//flaw_line_below:
		case XFS_DINODE_FMT_LOCAL:
//flaw_line_below:
			if (dip->di_anextents)
//flaw_line_below:
				return __this_address;
//flaw_line_below:
		/* fall through */
//flaw_line_below:
		case XFS_DINODE_FMT_EXTENTS:
//flaw_line_below:
		case XFS_DINODE_FMT_BTREE:
//flaw_line_below:
			break;
//flaw_line_below:
		default:
//flaw_line_below:
			return __this_address;
//flaw_line_below:
		}
//fix_flaw_line_below:
//		fa = xfs_dinode_verify_fork(dip, mp, XFS_ATTR_FORK);
//fix_flaw_line_below:
//		if (fa)
//fix_flaw_line_below:
//			return fa;
 	} else {
 		/*
 		 * If there is no fork offset, this may be a freshly-made inode
		 * in a new disk cluster, in which case di_aformat is zeroed.
		 * Otherwise, such an inode must be in EXTENTS format; this goes
		 * for freed inodes as well.
		 */
		switch (dip->di_aformat) {
		case 0:
		case XFS_DINODE_FMT_EXTENTS:
			break;
		default:
			return __this_address;
		}
		if (dip->di_anextents)
			return __this_address;
	}

	/* extent size hint validation */
	fa = xfs_inode_validate_extsize(mp, be32_to_cpu(dip->di_extsize),
			mode, flags);
	if (fa)
		return fa;

	/* only version 3 or greater inodes are extensively verified here */
	if (dip->di_version < 3)
		return NULL;

	flags2 = be64_to_cpu(dip->di_flags2);

	/* don't allow reflink/cowextsize if we don't have reflink */
	if ((flags2 & (XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE)) &&
	     !xfs_sb_version_hasreflink(&mp->m_sb))
		return __this_address;

	/* only regular files get reflink */
	if ((flags2 & XFS_DIFLAG2_REFLINK) && (mode & S_IFMT) != S_IFREG)
		return __this_address;

	/* don't let reflink and realtime mix */
	if ((flags2 & XFS_DIFLAG2_REFLINK) && (flags & XFS_DIFLAG_REALTIME))
		return __this_address;

	/* don't let reflink and dax mix */
	if ((flags2 & XFS_DIFLAG2_REFLINK) && (flags2 & XFS_DIFLAG2_DAX))
		return __this_address;

	/* COW extent size hint validation */
	fa = xfs_inode_validate_cowextsize(mp, be32_to_cpu(dip->di_cowextsize),
			mode, flags, flags2);
	if (fa)
		return fa;

	return NULL;
}
"
4600,182336,,Remote,Not required,Partial,CVE-2018-13094,https://www.cvedetails.com/cve/CVE-2018-13094/,CWE-476,Medium,,,,2018-07-03,4.3,An issue was discovered in fs/xfs/libxfs/xfs_attr_leaf.c in the Linux kernel through 4.17.3. An OOPS may occur for a corrupted xfs image after xfs_da_shrink_inode() is called with a NULL bp.,2019-04-23,,2,https://github.com/torvalds/linux/commit/bb3d48dcf86a97dc25fe9fc2c11938e19cb4399a,bb3d48dcf86a97dc25fe9fc2c11938e19cb4399a,"xfs: don't call xfs_da_shrink_inode with NULL bp

xfs_attr3_leaf_create may have errored out before instantiating a buffer,
for example if the blkno is out of range.  In that case there is no work
to do to remove it, and in fact xfs_da_shrink_inode will lead to an oops
if we try.

This also seems to fix a flaw where the original error from
xfs_attr3_leaf_create gets overwritten in the cleanup case, and it
removes a pointless assignment to bp which isn't used after this.

Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=199969
Reported-by: Xu, Wen <wen.xu@gatech.edu>
Tested-by: Xu, Wen <wen.xu@gatech.edu>
Signed-off-by: Eric Sandeen <sandeen@redhat.com>
Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>",3,fs/xfs/libxfs/xfs_attr_leaf.c,"{""sha"": ""76e90046731cad79b4127396d78a26050a9e4a8a"", ""filename"": ""fs/xfs/libxfs/xfs_attr_leaf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/bb3d48dcf86a97dc25fe9fc2c11938e19cb4399a/fs/xfs/libxfs/xfs_attr_leaf.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bb3d48dcf86a97dc25fe9fc2c11938e19cb4399a/fs/xfs/libxfs/xfs_attr_leaf.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/libxfs/xfs_attr_leaf.c?ref=bb3d48dcf86a97dc25fe9fc2c11938e19cb4399a"", ""patch"": ""@@ -791,9 +791,8 @@ xfs_attr_shortform_to_leaf(\n \tASSERT(blkno == 0);\n \terror = xfs_attr3_leaf_create(args, blkno, &bp);\n \tif (error) {\n-\t\terror = xfs_da_shrink_inode(args, 0, bp);\n-\t\tbp = NULL;\n-\t\tif (error)\n+\t\t/* xfs_attr3_leaf_create may not have instantiated a block */\n+\t\tif (bp && (xfs_da_shrink_inode(args, 0, bp) != 0))\n \t\t\tgoto out;\n \t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n \t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */""}","xfs_attr_shortform_to_leaf(
	struct xfs_da_args	*args,
	struct xfs_buf		**leaf_bp)
{
	xfs_inode_t *dp;
	xfs_attr_shortform_t *sf;
	xfs_attr_sf_entry_t *sfe;
	xfs_da_args_t nargs;
	char *tmpbuffer;
	int error, i, size;
	xfs_dablk_t blkno;
	struct xfs_buf *bp;
	xfs_ifork_t *ifp;

	trace_xfs_attr_sf_to_leaf(args);

	dp = args->dp;
	ifp = dp->i_afp;
	sf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;
	size = be16_to_cpu(sf->hdr.totsize);
	tmpbuffer = kmem_alloc(size, KM_SLEEP);
	ASSERT(tmpbuffer != NULL);
	memcpy(tmpbuffer, ifp->if_u1.if_data, size);
	sf = (xfs_attr_shortform_t *)tmpbuffer;

	xfs_idata_realloc(dp, -size, XFS_ATTR_FORK);
	xfs_bmap_local_to_extents_empty(dp, XFS_ATTR_FORK);

	bp = NULL;
	error = xfs_da_grow_inode(args, &blkno);
	if (error) {
		/*
		 * If we hit an IO error middle of the transaction inside
		 * grow_inode(), we may have inconsistent data. Bail out.
		 */
		if (error == -EIO)
			goto out;
		xfs_idata_realloc(dp, size, XFS_ATTR_FORK);	/* try to put */
		memcpy(ifp->if_u1.if_data, tmpbuffer, size);	/* it back */
		goto out;
	}

 	ASSERT(blkno == 0);
 	error = xfs_attr3_leaf_create(args, blkno, &bp);
 	if (error) {
		/* xfs_attr3_leaf_create may not have instantiated a block */
		if (bp && (xfs_da_shrink_inode(args, 0, bp) != 0))
 			goto out;
 		xfs_idata_realloc(dp, size, XFS_ATTR_FORK);	/* try to put */
 		memcpy(ifp->if_u1.if_data, tmpbuffer, size);	/* it back */
		goto out;
	}

	memset((char *)&nargs, 0, sizeof(nargs));
	nargs.dp = dp;
	nargs.geo = args->geo;
	nargs.firstblock = args->firstblock;
	nargs.dfops = args->dfops;
	nargs.total = args->total;
	nargs.whichfork = XFS_ATTR_FORK;
	nargs.trans = args->trans;
	nargs.op_flags = XFS_DA_OP_OKNOENT;

	sfe = &sf->list[0];
	for (i = 0; i < sf->hdr.count; i++) {
		nargs.name = sfe->nameval;
		nargs.namelen = sfe->namelen;
		nargs.value = &sfe->nameval[nargs.namelen];
		nargs.valuelen = sfe->valuelen;
		nargs.hashval = xfs_da_hashname(sfe->nameval,
						sfe->namelen);
		nargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(sfe->flags);
		error = xfs_attr3_leaf_lookup_int(bp, &nargs); /* set a->index */
		ASSERT(error == -ENOATTR);
		error = xfs_attr3_leaf_add(bp, &nargs);
		ASSERT(error != -ENOSPC);
		if (error)
			goto out;
		sfe = XFS_ATTR_SF_NEXTENTRY(sfe);
	}
	error = 0;
	*leaf_bp = bp;
out:
	kmem_free(tmpbuffer);
	return error;
}
","xfs_attr_shortform_to_leaf(
	struct xfs_da_args	*args,
	struct xfs_buf		**leaf_bp)
{
	xfs_inode_t *dp;
	xfs_attr_shortform_t *sf;
	xfs_attr_sf_entry_t *sfe;
	xfs_da_args_t nargs;
	char *tmpbuffer;
	int error, i, size;
	xfs_dablk_t blkno;
	struct xfs_buf *bp;
	xfs_ifork_t *ifp;

	trace_xfs_attr_sf_to_leaf(args);

	dp = args->dp;
	ifp = dp->i_afp;
	sf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;
	size = be16_to_cpu(sf->hdr.totsize);
	tmpbuffer = kmem_alloc(size, KM_SLEEP);
	ASSERT(tmpbuffer != NULL);
	memcpy(tmpbuffer, ifp->if_u1.if_data, size);
	sf = (xfs_attr_shortform_t *)tmpbuffer;

	xfs_idata_realloc(dp, -size, XFS_ATTR_FORK);
	xfs_bmap_local_to_extents_empty(dp, XFS_ATTR_FORK);

	bp = NULL;
	error = xfs_da_grow_inode(args, &blkno);
	if (error) {
		/*
		 * If we hit an IO error middle of the transaction inside
		 * grow_inode(), we may have inconsistent data. Bail out.
		 */
		if (error == -EIO)
			goto out;
		xfs_idata_realloc(dp, size, XFS_ATTR_FORK);	/* try to put */
		memcpy(ifp->if_u1.if_data, tmpbuffer, size);	/* it back */
		goto out;
	}

 	ASSERT(blkno == 0);
 	error = xfs_attr3_leaf_create(args, blkno, &bp);
 	if (error) {
		error = xfs_da_shrink_inode(args, 0, bp);
		bp = NULL;
		if (error)
 			goto out;
 		xfs_idata_realloc(dp, size, XFS_ATTR_FORK);	/* try to put */
 		memcpy(ifp->if_u1.if_data, tmpbuffer, size);	/* it back */
		goto out;
	}

	memset((char *)&nargs, 0, sizeof(nargs));
	nargs.dp = dp;
	nargs.geo = args->geo;
	nargs.firstblock = args->firstblock;
	nargs.dfops = args->dfops;
	nargs.total = args->total;
	nargs.whichfork = XFS_ATTR_FORK;
	nargs.trans = args->trans;
	nargs.op_flags = XFS_DA_OP_OKNOENT;

	sfe = &sf->list[0];
	for (i = 0; i < sf->hdr.count; i++) {
		nargs.name = sfe->nameval;
		nargs.namelen = sfe->namelen;
		nargs.value = &sfe->nameval[nargs.namelen];
		nargs.valuelen = sfe->valuelen;
		nargs.hashval = xfs_da_hashname(sfe->nameval,
						sfe->namelen);
		nargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(sfe->flags);
		error = xfs_attr3_leaf_lookup_int(bp, &nargs); /* set a->index */
		ASSERT(error == -ENOATTR);
		error = xfs_attr3_leaf_add(bp, &nargs);
		ASSERT(error != -ENOSPC);
		if (error)
			goto out;
		sfe = XFS_ATTR_SF_NEXTENTRY(sfe);
	}
	error = 0;
	*leaf_bp = bp;
out:
	kmem_free(tmpbuffer);
	return error;
}
",C,"		/* xfs_attr3_leaf_create may not have instantiated a block */
		if (bp && (xfs_da_shrink_inode(args, 0, bp) != 0))
","		error = xfs_da_shrink_inode(args, 0, bp);
		bp = NULL;
		if (error)
",,"@@ -791,9 +791,8 @@ xfs_attr_shortform_to_leaf(
 	ASSERT(blkno == 0);
 	error = xfs_attr3_leaf_create(args, blkno, &bp);
 	if (error) {
-		error = xfs_da_shrink_inode(args, 0, bp);
-		bp = NULL;
-		if (error)
+		/* xfs_attr3_leaf_create may not have instantiated a block */
+		if (bp && (xfs_da_shrink_inode(args, 0, bp) != 0))
 			goto out;
 		xfs_idata_realloc(dp, size, XFS_ATTR_FORK);	/* try to put */
 		memcpy(ifp->if_u1.if_data, tmpbuffer, size);	/* it back */",linux,bb3d48dcf86a97dc25fe9fc2c11938e19cb4399a,9bb54cb56ae8498d35392745f8f050112cec5dcb,1,"xfs_attr_shortform_to_leaf(
	struct xfs_da_args	*args,
	struct xfs_buf		**leaf_bp)
{
	xfs_inode_t *dp;
	xfs_attr_shortform_t *sf;
	xfs_attr_sf_entry_t *sfe;
	xfs_da_args_t nargs;
	char *tmpbuffer;
	int error, i, size;
	xfs_dablk_t blkno;
	struct xfs_buf *bp;
	xfs_ifork_t *ifp;

	trace_xfs_attr_sf_to_leaf(args);

	dp = args->dp;
	ifp = dp->i_afp;
	sf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;
	size = be16_to_cpu(sf->hdr.totsize);
	tmpbuffer = kmem_alloc(size, KM_SLEEP);
	ASSERT(tmpbuffer != NULL);
	memcpy(tmpbuffer, ifp->if_u1.if_data, size);
	sf = (xfs_attr_shortform_t *)tmpbuffer;

	xfs_idata_realloc(dp, -size, XFS_ATTR_FORK);
	xfs_bmap_local_to_extents_empty(dp, XFS_ATTR_FORK);

	bp = NULL;
	error = xfs_da_grow_inode(args, &blkno);
	if (error) {
		/*
		 * If we hit an IO error middle of the transaction inside
		 * grow_inode(), we may have inconsistent data. Bail out.
		 */
		if (error == -EIO)
			goto out;
		xfs_idata_realloc(dp, size, XFS_ATTR_FORK);	/* try to put */
		memcpy(ifp->if_u1.if_data, tmpbuffer, size);	/* it back */
		goto out;
	}

 	ASSERT(blkno == 0);
 	error = xfs_attr3_leaf_create(args, blkno, &bp);
 	if (error) {
//flaw_line_below:
		error = xfs_da_shrink_inode(args, 0, bp);
//flaw_line_below:
		bp = NULL;
//flaw_line_below:
		if (error)
//fix_flaw_line_below:
//		/* xfs_attr3_leaf_create may not have instantiated a block */
//fix_flaw_line_below:
//		if (bp && (xfs_da_shrink_inode(args, 0, bp) != 0))
 			goto out;
 		xfs_idata_realloc(dp, size, XFS_ATTR_FORK);	/* try to put */
 		memcpy(ifp->if_u1.if_data, tmpbuffer, size);	/* it back */
		goto out;
	}

	memset((char *)&nargs, 0, sizeof(nargs));
	nargs.dp = dp;
	nargs.geo = args->geo;
	nargs.firstblock = args->firstblock;
	nargs.dfops = args->dfops;
	nargs.total = args->total;
	nargs.whichfork = XFS_ATTR_FORK;
	nargs.trans = args->trans;
	nargs.op_flags = XFS_DA_OP_OKNOENT;

	sfe = &sf->list[0];
	for (i = 0; i < sf->hdr.count; i++) {
		nargs.name = sfe->nameval;
		nargs.namelen = sfe->namelen;
		nargs.value = &sfe->nameval[nargs.namelen];
		nargs.valuelen = sfe->valuelen;
		nargs.hashval = xfs_da_hashname(sfe->nameval,
						sfe->namelen);
		nargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(sfe->flags);
		error = xfs_attr3_leaf_lookup_int(bp, &nargs); /* set a->index */
		ASSERT(error == -ENOATTR);
		error = xfs_attr3_leaf_add(bp, &nargs);
		ASSERT(error != -ENOSPC);
		if (error)
			goto out;
		sfe = XFS_ATTR_SF_NEXTENTRY(sfe);
	}
	error = 0;
	*leaf_bp = bp;
out:
	kmem_free(tmpbuffer);
	return error;
}
"
4601,182337,,Remote,Not required,Partial,CVE-2018-13093,https://www.cvedetails.com/cve/CVE-2018-13093/,CWE-476,Medium,,,,2018-07-03,4.3,An issue was discovered in fs/xfs/xfs_icache.c in the Linux kernel through 4.17.3. There is a NULL pointer dereference and panic in lookup_slow() on a NULL inode->i_ops pointer when doing pathwalks on a corrupted xfs image. This occurs because of a lack of proper validation that cached inodes are free during allocation.,2019-08-06,,4,https://github.com/torvalds/linux/commit/afca6c5b2595fc44383919fba740c194b0b76aff,afca6c5b2595fc44383919fba740c194b0b76aff,"xfs: validate cached inodes are free when allocated

A recent fuzzed filesystem image cached random dcache corruption
when the reproducer was run. This often showed up as panics in
lookup_slow() on a null inode->i_ops pointer when doing pathwalks.

BUG: unable to handle kernel NULL pointer dereference at 0000000000000000
....
Call Trace:
 lookup_slow+0x44/0x60
 walk_component+0x3dd/0x9f0
 link_path_walk+0x4a7/0x830
 path_lookupat+0xc1/0x470
 filename_lookup+0x129/0x270
 user_path_at_empty+0x36/0x40
 path_listxattr+0x98/0x110
 SyS_listxattr+0x13/0x20
 do_syscall_64+0xf5/0x280
 entry_SYSCALL_64_after_hwframe+0x42/0xb7

but had many different failure modes including deadlocks trying to
lock the inode that was just allocated or KASAN reports of
use-after-free violations.

The cause of the problem was a corrupt INOBT on a v4 fs where the
root inode was marked as free in the inobt record. Hence when we
allocated an inode, it chose the root inode to allocate, found it in
the cache and re-initialised it.

We recently fixed a similar inode allocation issue caused by inobt
record corruption problem in xfs_iget_cache_miss() in commit
ee457001ed6c (""xfs: catch inode allocation state mismatch
corruption""). This change adds similar checks to the cache-hit path
to catch it, and turns the reproducer into a corruption shutdown
situation.

Reported-by: Wen Xu <wen.xu@gatech.edu>
Signed-Off-By: Dave Chinner <dchinner@redhat.com>
Reviewed-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Carlos Maiolino <cmaiolino@redhat.com>
Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
[darrick: fix typos in comment]
Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>",4,fs/xfs/xfs_icache.c,"{""sha"": ""817899961f48ad5325e825ee27583ac372bdcacf"", ""filename"": ""fs/xfs/xfs_icache.c"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 25, ""changes"": 73, ""blob_url"": ""https://github.com/torvalds/linux/blob/afca6c5b2595fc44383919fba740c194b0b76aff/fs/xfs/xfs_icache.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/afca6c5b2595fc44383919fba740c194b0b76aff/fs/xfs/xfs_icache.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_icache.c?ref=afca6c5b2595fc44383919fba740c194b0b76aff"", ""patch"": ""@@ -308,6 +308,46 @@ xfs_reinit_inode(\n \treturn error;\n }\n \n+/*\n+ * If we are allocating a new inode, then check what was returned is\n+ * actually a free, empty inode. If we are not allocating an inode,\n+ * then check we didn't find a free inode.\n+ *\n+ * Returns:\n+ *\t0\t\tif the inode free state matches the lookup context\n+ *\t-ENOENT\t\tif the inode is free and we are not allocating\n+ *\t-EFSCORRUPTED\tif there is any state mismatch at all\n+ */\n+static int\n+xfs_iget_check_free_state(\n+\tstruct xfs_inode\t*ip,\n+\tint\t\t\tflags)\n+{\n+\tif (flags & XFS_IGET_CREATE) {\n+\t\t/* should be a free inode */\n+\t\tif (VFS_I(ip)->i_mode != 0) {\n+\t\t\txfs_warn(ip->i_mount,\n+\""Corruption detected! Free inode 0x%llx not marked free! (mode 0x%x)\"",\n+\t\t\t\tip->i_ino, VFS_I(ip)->i_mode);\n+\t\t\treturn -EFSCORRUPTED;\n+\t\t}\n+\n+\t\tif (ip->i_d.di_nblocks != 0) {\n+\t\t\txfs_warn(ip->i_mount,\n+\""Corruption detected! Free inode 0x%llx has blocks allocated!\"",\n+\t\t\t\tip->i_ino);\n+\t\t\treturn -EFSCORRUPTED;\n+\t\t}\n+\t\treturn 0;\n+\t}\n+\n+\t/* should be an allocated inode */\n+\tif (VFS_I(ip)->i_mode == 0)\n+\t\treturn -ENOENT;\n+\n+\treturn 0;\n+}\n+\n /*\n  * Check the validity of the inode we just found it the cache\n  */\n@@ -357,12 +397,12 @@ xfs_iget_cache_hit(\n \t}\n \n \t/*\n-\t * If lookup is racing with unlink return an error immediately.\n+\t * Check the inode free state is valid. This also detects lookup\n+\t * racing with unlinks.\n \t */\n-\tif (VFS_I(ip)->i_mode == 0 && !(flags & XFS_IGET_CREATE)) {\n-\t\terror = -ENOENT;\n+\terror = xfs_iget_check_free_state(ip, flags);\n+\tif (error)\n \t\tgoto out_error;\n-\t}\n \n \t/*\n \t * If IRECLAIMABLE is set, we've torn down the VFS inode already.\n@@ -485,29 +525,12 @@ xfs_iget_cache_miss(\n \n \n \t/*\n-\t * If we are allocating a new inode, then check what was returned is\n-\t * actually a free, empty inode. If we are not allocating an inode,\n-\t * the check we didn't find a free inode.\n+\t * Check the inode free state is valid. This also detects lookup\n+\t * racing with unlinks.\n \t */\n-\tif (flags & XFS_IGET_CREATE) {\n-\t\tif (VFS_I(ip)->i_mode != 0) {\n-\t\t\txfs_warn(mp,\n-\""Corruption detected! Free inode 0x%llx not marked free on disk\"",\n-\t\t\t\tino);\n-\t\t\terror = -EFSCORRUPTED;\n-\t\t\tgoto out_destroy;\n-\t\t}\n-\t\tif (ip->i_d.di_nblocks != 0) {\n-\t\t\txfs_warn(mp,\n-\""Corruption detected! Free inode 0x%llx has blocks allocated!\"",\n-\t\t\t\tino);\n-\t\t\terror = -EFSCORRUPTED;\n-\t\t\tgoto out_destroy;\n-\t\t}\n-\t} else if (VFS_I(ip)->i_mode == 0) {\n-\t\terror = -ENOENT;\n+\terror = xfs_iget_check_free_state(ip, flags);\n+\tif (error)\n \t\tgoto out_destroy;\n-\t}\n \n \t/*\n \t * Preload the radix tree so we can insert safely under the""}","	int			lock_flags) __releases(RCU)
{
	struct inode		*inode = VFS_I(ip);
	struct xfs_mount	*mp = ip->i_mount;
	int			error;

	/*
	 * check for re-use of an inode within an RCU grace period due to the
	 * radix tree nodes not being updated yet. We monitor for this by
	 * setting the inode number to zero before freeing the inode structure.
	 * If the inode has been reallocated and set up, then the inode number
	 * will not match, so check for that, too.
	 */
	spin_lock(&ip->i_flags_lock);
	if (ip->i_ino != ino) {
		trace_xfs_iget_skip(ip);
		XFS_STATS_INC(mp, xs_ig_frecycle);
		error = -EAGAIN;
		goto out_error;
	}


	/*
	 * If we are racing with another cache hit that is currently
	 * instantiating this inode or currently recycling it out of
	 * reclaimabe state, wait for the initialisation to complete
	 * before continuing.
	 *
	 * XXX(hch): eventually we should do something equivalent to
	 *	     wait_on_inode to wait for these flags to be cleared
	 *	     instead of polling for it.
	 */
	if (ip->i_flags & (XFS_INEW|XFS_IRECLAIM)) {
		trace_xfs_iget_skip(ip);
		XFS_STATS_INC(mp, xs_ig_frecycle);
		error = -EAGAIN;
		goto out_error;
 	}
 
 	/*
	 * Check the inode free state is valid. This also detects lookup
	 * racing with unlinks.
 	 */
	error = xfs_iget_check_free_state(ip, flags);
	if (error)
 		goto out_error;
 
 	/*
 	 * If IRECLAIMABLE is set, we've torn down the VFS inode already.
	 * Need to carefully get it back into useable state.
	 */
	if (ip->i_flags & XFS_IRECLAIMABLE) {
		trace_xfs_iget_reclaim(ip);

		if (flags & XFS_IGET_INCORE) {
			error = -EAGAIN;
			goto out_error;
		}

		/*
		 * We need to set XFS_IRECLAIM to prevent xfs_reclaim_inode
		 * from stomping over us while we recycle the inode.  We can't
		 * clear the radix tree reclaimable tag yet as it requires
		 * pag_ici_lock to be held exclusive.
		 */
		ip->i_flags |= XFS_IRECLAIM;

		spin_unlock(&ip->i_flags_lock);
		rcu_read_unlock();

		error = xfs_reinit_inode(mp, inode);
		if (error) {
			bool wake;
			/*
			 * Re-initializing the inode failed, and we are in deep
			 * trouble.  Try to re-add it to the reclaim list.
			 */
			rcu_read_lock();
			spin_lock(&ip->i_flags_lock);
			wake = !!__xfs_iflags_test(ip, XFS_INEW);
			ip->i_flags &= ~(XFS_INEW | XFS_IRECLAIM);
			if (wake)
				wake_up_bit(&ip->i_flags, __XFS_INEW_BIT);
			ASSERT(ip->i_flags & XFS_IRECLAIMABLE);
			trace_xfs_iget_reclaim_fail(ip);
			goto out_error;
		}

		spin_lock(&pag->pag_ici_lock);
		spin_lock(&ip->i_flags_lock);

		/*
		 * Clear the per-lifetime state in the inode as we are now
		 * effectively a new inode and need to return to the initial
		 * state before reuse occurs.
		 */
		ip->i_flags &= ~XFS_IRECLAIM_RESET_FLAGS;
		ip->i_flags |= XFS_INEW;
		xfs_inode_clear_reclaim_tag(pag, ip->i_ino);
		inode->i_state = I_NEW;

		ASSERT(!rwsem_is_locked(&inode->i_rwsem));
		init_rwsem(&inode->i_rwsem);

		spin_unlock(&ip->i_flags_lock);
		spin_unlock(&pag->pag_ici_lock);
	} else {
		/* If the VFS inode is being torn down, pause and try again. */
		if (!igrab(inode)) {
			trace_xfs_iget_skip(ip);
			error = -EAGAIN;
			goto out_error;
		}

		/* We've got a live one. */
		spin_unlock(&ip->i_flags_lock);
		rcu_read_unlock();
		trace_xfs_iget_hit(ip);
	}

	if (lock_flags != 0)
		xfs_ilock(ip, lock_flags);

	if (!(flags & XFS_IGET_INCORE))
		xfs_iflags_clear(ip, XFS_ISTALE | XFS_IDONTCACHE);
	XFS_STATS_INC(mp, xs_ig_found);

	return 0;

out_error:
	spin_unlock(&ip->i_flags_lock);
	rcu_read_unlock();
	return error;
}
","	int			lock_flags) __releases(RCU)
{
	struct inode		*inode = VFS_I(ip);
	struct xfs_mount	*mp = ip->i_mount;
	int			error;

	/*
	 * check for re-use of an inode within an RCU grace period due to the
	 * radix tree nodes not being updated yet. We monitor for this by
	 * setting the inode number to zero before freeing the inode structure.
	 * If the inode has been reallocated and set up, then the inode number
	 * will not match, so check for that, too.
	 */
	spin_lock(&ip->i_flags_lock);
	if (ip->i_ino != ino) {
		trace_xfs_iget_skip(ip);
		XFS_STATS_INC(mp, xs_ig_frecycle);
		error = -EAGAIN;
		goto out_error;
	}


	/*
	 * If we are racing with another cache hit that is currently
	 * instantiating this inode or currently recycling it out of
	 * reclaimabe state, wait for the initialisation to complete
	 * before continuing.
	 *
	 * XXX(hch): eventually we should do something equivalent to
	 *	     wait_on_inode to wait for these flags to be cleared
	 *	     instead of polling for it.
	 */
	if (ip->i_flags & (XFS_INEW|XFS_IRECLAIM)) {
		trace_xfs_iget_skip(ip);
		XFS_STATS_INC(mp, xs_ig_frecycle);
		error = -EAGAIN;
		goto out_error;
 	}
 
 	/*
	 * If lookup is racing with unlink return an error immediately.
 	 */
	if (VFS_I(ip)->i_mode == 0 && !(flags & XFS_IGET_CREATE)) {
		error = -ENOENT;
 		goto out_error;
	}
 
 	/*
 	 * If IRECLAIMABLE is set, we've torn down the VFS inode already.
	 * Need to carefully get it back into useable state.
	 */
	if (ip->i_flags & XFS_IRECLAIMABLE) {
		trace_xfs_iget_reclaim(ip);

		if (flags & XFS_IGET_INCORE) {
			error = -EAGAIN;
			goto out_error;
		}

		/*
		 * We need to set XFS_IRECLAIM to prevent xfs_reclaim_inode
		 * from stomping over us while we recycle the inode.  We can't
		 * clear the radix tree reclaimable tag yet as it requires
		 * pag_ici_lock to be held exclusive.
		 */
		ip->i_flags |= XFS_IRECLAIM;

		spin_unlock(&ip->i_flags_lock);
		rcu_read_unlock();

		error = xfs_reinit_inode(mp, inode);
		if (error) {
			bool wake;
			/*
			 * Re-initializing the inode failed, and we are in deep
			 * trouble.  Try to re-add it to the reclaim list.
			 */
			rcu_read_lock();
			spin_lock(&ip->i_flags_lock);
			wake = !!__xfs_iflags_test(ip, XFS_INEW);
			ip->i_flags &= ~(XFS_INEW | XFS_IRECLAIM);
			if (wake)
				wake_up_bit(&ip->i_flags, __XFS_INEW_BIT);
			ASSERT(ip->i_flags & XFS_IRECLAIMABLE);
			trace_xfs_iget_reclaim_fail(ip);
			goto out_error;
		}

		spin_lock(&pag->pag_ici_lock);
		spin_lock(&ip->i_flags_lock);

		/*
		 * Clear the per-lifetime state in the inode as we are now
		 * effectively a new inode and need to return to the initial
		 * state before reuse occurs.
		 */
		ip->i_flags &= ~XFS_IRECLAIM_RESET_FLAGS;
		ip->i_flags |= XFS_INEW;
		xfs_inode_clear_reclaim_tag(pag, ip->i_ino);
		inode->i_state = I_NEW;

		ASSERT(!rwsem_is_locked(&inode->i_rwsem));
		init_rwsem(&inode->i_rwsem);

		spin_unlock(&ip->i_flags_lock);
		spin_unlock(&pag->pag_ici_lock);
	} else {
		/* If the VFS inode is being torn down, pause and try again. */
		if (!igrab(inode)) {
			trace_xfs_iget_skip(ip);
			error = -EAGAIN;
			goto out_error;
		}

		/* We've got a live one. */
		spin_unlock(&ip->i_flags_lock);
		rcu_read_unlock();
		trace_xfs_iget_hit(ip);
	}

	if (lock_flags != 0)
		xfs_ilock(ip, lock_flags);

	if (!(flags & XFS_IGET_INCORE))
		xfs_iflags_clear(ip, XFS_ISTALE | XFS_IDONTCACHE);
	XFS_STATS_INC(mp, xs_ig_found);

	return 0;

out_error:
	spin_unlock(&ip->i_flags_lock);
	rcu_read_unlock();
	return error;
}
",C,"	 * Check the inode free state is valid. This also detects lookup
	 * racing with unlinks.
	error = xfs_iget_check_free_state(ip, flags);
	if (error)
","	 * If lookup is racing with unlink return an error immediately.
	if (VFS_I(ip)->i_mode == 0 && !(flags & XFS_IGET_CREATE)) {
		error = -ENOENT;
	}
",,"@@ -308,6 +308,46 @@ xfs_reinit_inode(
 	return error;
 }
 
+/*
+ * If we are allocating a new inode, then check what was returned is
+ * actually a free, empty inode. If we are not allocating an inode,
+ * then check we didn't find a free inode.
+ *
+ * Returns:
+ *	0		if the inode free state matches the lookup context
+ *	-ENOENT		if the inode is free and we are not allocating
+ *	-EFSCORRUPTED	if there is any state mismatch at all
+ */
+static int
+xfs_iget_check_free_state(
+	struct xfs_inode	*ip,
+	int			flags)
+{
+	if (flags & XFS_IGET_CREATE) {
+		/* should be a free inode */
+		if (VFS_I(ip)->i_mode != 0) {
+			xfs_warn(ip->i_mount,
+""Corruption detected! Free inode 0x%llx not marked free! (mode 0x%x)"",
+				ip->i_ino, VFS_I(ip)->i_mode);
+			return -EFSCORRUPTED;
+		}
+
+		if (ip->i_d.di_nblocks != 0) {
+			xfs_warn(ip->i_mount,
+""Corruption detected! Free inode 0x%llx has blocks allocated!"",
+				ip->i_ino);
+			return -EFSCORRUPTED;
+		}
+		return 0;
+	}
+
+	/* should be an allocated inode */
+	if (VFS_I(ip)->i_mode == 0)
+		return -ENOENT;
+
+	return 0;
+}
+
 /*
  * Check the validity of the inode we just found it the cache
  */
@@ -357,12 +397,12 @@ xfs_iget_cache_hit(
 	}
 
 	/*
-	 * If lookup is racing with unlink return an error immediately.
+	 * Check the inode free state is valid. This also detects lookup
+	 * racing with unlinks.
 	 */
-	if (VFS_I(ip)->i_mode == 0 && !(flags & XFS_IGET_CREATE)) {
-		error = -ENOENT;
+	error = xfs_iget_check_free_state(ip, flags);
+	if (error)
 		goto out_error;
-	}
 
 	/*
 	 * If IRECLAIMABLE is set, we've torn down the VFS inode already.
@@ -485,29 +525,12 @@ xfs_iget_cache_miss(
 
 
 	/*
-	 * If we are allocating a new inode, then check what was returned is
-	 * actually a free, empty inode. If we are not allocating an inode,
-	 * the check we didn't find a free inode.
+	 * Check the inode free state is valid. This also detects lookup
+	 * racing with unlinks.
 	 */
-	if (flags & XFS_IGET_CREATE) {
-		if (VFS_I(ip)->i_mode != 0) {
-			xfs_warn(mp,
-""Corruption detected! Free inode 0x%llx not marked free on disk"",
-				ino);
-			error = -EFSCORRUPTED;
-			goto out_destroy;
-		}
-		if (ip->i_d.di_nblocks != 0) {
-			xfs_warn(mp,
-""Corruption detected! Free inode 0x%llx has blocks allocated!"",
-				ino);
-			error = -EFSCORRUPTED;
-			goto out_destroy;
-		}
-	} else if (VFS_I(ip)->i_mode == 0) {
-		error = -ENOENT;
+	error = xfs_iget_check_free_state(ip, flags);
+	if (error)
 		goto out_destroy;
-	}
 
 	/*
 	 * Preload the radix tree so we can insert safely under the",linux,afca6c5b2595fc44383919fba740c194b0b76aff,75bc37fefc4471e718ba8e651aa74673d4e0a9eb,1,"	int			lock_flags) __releases(RCU)
{
	struct inode		*inode = VFS_I(ip);
	struct xfs_mount	*mp = ip->i_mount;
	int			error;

	/*
	 * check for re-use of an inode within an RCU grace period due to the
	 * radix tree nodes not being updated yet. We monitor for this by
	 * setting the inode number to zero before freeing the inode structure.
	 * If the inode has been reallocated and set up, then the inode number
	 * will not match, so check for that, too.
	 */
	spin_lock(&ip->i_flags_lock);
	if (ip->i_ino != ino) {
		trace_xfs_iget_skip(ip);
		XFS_STATS_INC(mp, xs_ig_frecycle);
		error = -EAGAIN;
		goto out_error;
	}


	/*
	 * If we are racing with another cache hit that is currently
	 * instantiating this inode or currently recycling it out of
	 * reclaimabe state, wait for the initialisation to complete
	 * before continuing.
	 *
	 * XXX(hch): eventually we should do something equivalent to
	 *	     wait_on_inode to wait for these flags to be cleared
	 *	     instead of polling for it.
	 */
	if (ip->i_flags & (XFS_INEW|XFS_IRECLAIM)) {
		trace_xfs_iget_skip(ip);
		XFS_STATS_INC(mp, xs_ig_frecycle);
		error = -EAGAIN;
		goto out_error;
 	}
 
 	/*
//flaw_line_below:
	 * If lookup is racing with unlink return an error immediately.
//fix_flaw_line_below:
//	 * Check the inode free state is valid. This also detects lookup
//fix_flaw_line_below:
//	 * racing with unlinks.
 	 */
//flaw_line_below:
	if (VFS_I(ip)->i_mode == 0 && !(flags & XFS_IGET_CREATE)) {
//flaw_line_below:
		error = -ENOENT;
//fix_flaw_line_below:
//	error = xfs_iget_check_free_state(ip, flags);
//fix_flaw_line_below:
//	if (error)
 		goto out_error;
//flaw_line_below:
	}
 
 	/*
 	 * If IRECLAIMABLE is set, we've torn down the VFS inode already.
	 * Need to carefully get it back into useable state.
	 */
	if (ip->i_flags & XFS_IRECLAIMABLE) {
		trace_xfs_iget_reclaim(ip);

		if (flags & XFS_IGET_INCORE) {
			error = -EAGAIN;
			goto out_error;
		}

		/*
		 * We need to set XFS_IRECLAIM to prevent xfs_reclaim_inode
		 * from stomping over us while we recycle the inode.  We can't
		 * clear the radix tree reclaimable tag yet as it requires
		 * pag_ici_lock to be held exclusive.
		 */
		ip->i_flags |= XFS_IRECLAIM;

		spin_unlock(&ip->i_flags_lock);
		rcu_read_unlock();

		error = xfs_reinit_inode(mp, inode);
		if (error) {
			bool wake;
			/*
			 * Re-initializing the inode failed, and we are in deep
			 * trouble.  Try to re-add it to the reclaim list.
			 */
			rcu_read_lock();
			spin_lock(&ip->i_flags_lock);
			wake = !!__xfs_iflags_test(ip, XFS_INEW);
			ip->i_flags &= ~(XFS_INEW | XFS_IRECLAIM);
			if (wake)
				wake_up_bit(&ip->i_flags, __XFS_INEW_BIT);
			ASSERT(ip->i_flags & XFS_IRECLAIMABLE);
			trace_xfs_iget_reclaim_fail(ip);
			goto out_error;
		}

		spin_lock(&pag->pag_ici_lock);
		spin_lock(&ip->i_flags_lock);

		/*
		 * Clear the per-lifetime state in the inode as we are now
		 * effectively a new inode and need to return to the initial
		 * state before reuse occurs.
		 */
		ip->i_flags &= ~XFS_IRECLAIM_RESET_FLAGS;
		ip->i_flags |= XFS_INEW;
		xfs_inode_clear_reclaim_tag(pag, ip->i_ino);
		inode->i_state = I_NEW;

		ASSERT(!rwsem_is_locked(&inode->i_rwsem));
		init_rwsem(&inode->i_rwsem);

		spin_unlock(&ip->i_flags_lock);
		spin_unlock(&pag->pag_ici_lock);
	} else {
		/* If the VFS inode is being torn down, pause and try again. */
		if (!igrab(inode)) {
			trace_xfs_iget_skip(ip);
			error = -EAGAIN;
			goto out_error;
		}

		/* We've got a live one. */
		spin_unlock(&ip->i_flags_lock);
		rcu_read_unlock();
		trace_xfs_iget_hit(ip);
	}

	if (lock_flags != 0)
		xfs_ilock(ip, lock_flags);

	if (!(flags & XFS_IGET_INCORE))
		xfs_iflags_clear(ip, XFS_ISTALE | XFS_IDONTCACHE);
	XFS_STATS_INC(mp, xs_ig_found);

	return 0;

out_error:
	spin_unlock(&ip->i_flags_lock);
	rcu_read_unlock();
	return error;
}
"
4602,182338,,Remote,Not required,Partial,CVE-2018-13093,https://www.cvedetails.com/cve/CVE-2018-13093/,CWE-476,Medium,,,,2018-07-03,4.3,An issue was discovered in fs/xfs/xfs_icache.c in the Linux kernel through 4.17.3. There is a NULL pointer dereference and panic in lookup_slow() on a NULL inode->i_ops pointer when doing pathwalks on a corrupted xfs image. This occurs because of a lack of proper validation that cached inodes are free during allocation.,2019-08-06,,4,https://github.com/torvalds/linux/commit/afca6c5b2595fc44383919fba740c194b0b76aff,afca6c5b2595fc44383919fba740c194b0b76aff,"xfs: validate cached inodes are free when allocated

A recent fuzzed filesystem image cached random dcache corruption
when the reproducer was run. This often showed up as panics in
lookup_slow() on a null inode->i_ops pointer when doing pathwalks.

BUG: unable to handle kernel NULL pointer dereference at 0000000000000000
....
Call Trace:
 lookup_slow+0x44/0x60
 walk_component+0x3dd/0x9f0
 link_path_walk+0x4a7/0x830
 path_lookupat+0xc1/0x470
 filename_lookup+0x129/0x270
 user_path_at_empty+0x36/0x40
 path_listxattr+0x98/0x110
 SyS_listxattr+0x13/0x20
 do_syscall_64+0xf5/0x280
 entry_SYSCALL_64_after_hwframe+0x42/0xb7

but had many different failure modes including deadlocks trying to
lock the inode that was just allocated or KASAN reports of
use-after-free violations.

The cause of the problem was a corrupt INOBT on a v4 fs where the
root inode was marked as free in the inobt record. Hence when we
allocated an inode, it chose the root inode to allocate, found it in
the cache and re-initialised it.

We recently fixed a similar inode allocation issue caused by inobt
record corruption problem in xfs_iget_cache_miss() in commit
ee457001ed6c (""xfs: catch inode allocation state mismatch
corruption""). This change adds similar checks to the cache-hit path
to catch it, and turns the reproducer into a corruption shutdown
situation.

Reported-by: Wen Xu <wen.xu@gatech.edu>
Signed-Off-By: Dave Chinner <dchinner@redhat.com>
Reviewed-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Carlos Maiolino <cmaiolino@redhat.com>
Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
[darrick: fix typos in comment]
Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>",21,fs/xfs/xfs_icache.c,"{""sha"": ""817899961f48ad5325e825ee27583ac372bdcacf"", ""filename"": ""fs/xfs/xfs_icache.c"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 25, ""changes"": 73, ""blob_url"": ""https://github.com/torvalds/linux/blob/afca6c5b2595fc44383919fba740c194b0b76aff/fs/xfs/xfs_icache.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/afca6c5b2595fc44383919fba740c194b0b76aff/fs/xfs/xfs_icache.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_icache.c?ref=afca6c5b2595fc44383919fba740c194b0b76aff"", ""patch"": ""@@ -308,6 +308,46 @@ xfs_reinit_inode(\n \treturn error;\n }\n \n+/*\n+ * If we are allocating a new inode, then check what was returned is\n+ * actually a free, empty inode. If we are not allocating an inode,\n+ * then check we didn't find a free inode.\n+ *\n+ * Returns:\n+ *\t0\t\tif the inode free state matches the lookup context\n+ *\t-ENOENT\t\tif the inode is free and we are not allocating\n+ *\t-EFSCORRUPTED\tif there is any state mismatch at all\n+ */\n+static int\n+xfs_iget_check_free_state(\n+\tstruct xfs_inode\t*ip,\n+\tint\t\t\tflags)\n+{\n+\tif (flags & XFS_IGET_CREATE) {\n+\t\t/* should be a free inode */\n+\t\tif (VFS_I(ip)->i_mode != 0) {\n+\t\t\txfs_warn(ip->i_mount,\n+\""Corruption detected! Free inode 0x%llx not marked free! (mode 0x%x)\"",\n+\t\t\t\tip->i_ino, VFS_I(ip)->i_mode);\n+\t\t\treturn -EFSCORRUPTED;\n+\t\t}\n+\n+\t\tif (ip->i_d.di_nblocks != 0) {\n+\t\t\txfs_warn(ip->i_mount,\n+\""Corruption detected! Free inode 0x%llx has blocks allocated!\"",\n+\t\t\t\tip->i_ino);\n+\t\t\treturn -EFSCORRUPTED;\n+\t\t}\n+\t\treturn 0;\n+\t}\n+\n+\t/* should be an allocated inode */\n+\tif (VFS_I(ip)->i_mode == 0)\n+\t\treturn -ENOENT;\n+\n+\treturn 0;\n+}\n+\n /*\n  * Check the validity of the inode we just found it the cache\n  */\n@@ -357,12 +397,12 @@ xfs_iget_cache_hit(\n \t}\n \n \t/*\n-\t * If lookup is racing with unlink return an error immediately.\n+\t * Check the inode free state is valid. This also detects lookup\n+\t * racing with unlinks.\n \t */\n-\tif (VFS_I(ip)->i_mode == 0 && !(flags & XFS_IGET_CREATE)) {\n-\t\terror = -ENOENT;\n+\terror = xfs_iget_check_free_state(ip, flags);\n+\tif (error)\n \t\tgoto out_error;\n-\t}\n \n \t/*\n \t * If IRECLAIMABLE is set, we've torn down the VFS inode already.\n@@ -485,29 +525,12 @@ xfs_iget_cache_miss(\n \n \n \t/*\n-\t * If we are allocating a new inode, then check what was returned is\n-\t * actually a free, empty inode. If we are not allocating an inode,\n-\t * the check we didn't find a free inode.\n+\t * Check the inode free state is valid. This also detects lookup\n+\t * racing with unlinks.\n \t */\n-\tif (flags & XFS_IGET_CREATE) {\n-\t\tif (VFS_I(ip)->i_mode != 0) {\n-\t\t\txfs_warn(mp,\n-\""Corruption detected! Free inode 0x%llx not marked free on disk\"",\n-\t\t\t\tino);\n-\t\t\terror = -EFSCORRUPTED;\n-\t\t\tgoto out_destroy;\n-\t\t}\n-\t\tif (ip->i_d.di_nblocks != 0) {\n-\t\t\txfs_warn(mp,\n-\""Corruption detected! Free inode 0x%llx has blocks allocated!\"",\n-\t\t\t\tino);\n-\t\t\terror = -EFSCORRUPTED;\n-\t\t\tgoto out_destroy;\n-\t\t}\n-\t} else if (VFS_I(ip)->i_mode == 0) {\n-\t\terror = -ENOENT;\n+\terror = xfs_iget_check_free_state(ip, flags);\n+\tif (error)\n \t\tgoto out_destroy;\n-\t}\n \n \t/*\n \t * Preload the radix tree so we can insert safely under the""}","xfs_iget_cache_miss(
	struct xfs_mount	*mp,
	struct xfs_perag	*pag,
	xfs_trans_t		*tp,
	xfs_ino_t		ino,
	struct xfs_inode	**ipp,
	int			flags,
	int			lock_flags)
{
	struct xfs_inode	*ip;
	int			error;
	xfs_agino_t		agino = XFS_INO_TO_AGINO(mp, ino);
	int			iflags;

	ip = xfs_inode_alloc(mp, ino);
	if (!ip)
		return -ENOMEM;

	error = xfs_iread(mp, tp, ip, flags);
	if (error)
		goto out_destroy;

	if (!xfs_inode_verify_forks(ip)) {
		error = -EFSCORRUPTED;
		goto out_destroy;
	}

	trace_xfs_iget_miss(ip);
 
 
 	/*
	 * Check the inode free state is valid. This also detects lookup
	 * racing with unlinks.
 	 */
	error = xfs_iget_check_free_state(ip, flags);
	if (error)
 		goto out_destroy;
 
 	/*
 	 * Preload the radix tree so we can insert safely under the
	 * write spinlock. Note that we cannot sleep inside the preload
	 * region. Since we can be called from transaction context, don't
	 * recurse into the file system.
	 */
	if (radix_tree_preload(GFP_NOFS)) {
		error = -EAGAIN;
		goto out_destroy;
	}

	/*
	 * Because the inode hasn't been added to the radix-tree yet it can't
	 * be found by another thread, so we can do the non-sleeping lock here.
	 */
	if (lock_flags) {
		if (!xfs_ilock_nowait(ip, lock_flags))
			BUG();
	}

	/*
	 * These values must be set before inserting the inode into the radix
	 * tree as the moment it is inserted a concurrent lookup (allowed by the
	 * RCU locking mechanism) can find it and that lookup must see that this
	 * is an inode currently under construction (i.e. that XFS_INEW is set).
	 * The ip->i_flags_lock that protects the XFS_INEW flag forms the
	 * memory barrier that ensures this detection works correctly at lookup
	 * time.
	 */
	iflags = XFS_INEW;
	if (flags & XFS_IGET_DONTCACHE)
		iflags |= XFS_IDONTCACHE;
	ip->i_udquot = NULL;
	ip->i_gdquot = NULL;
	ip->i_pdquot = NULL;
	xfs_iflags_set(ip, iflags);

	/* insert the new inode */
	spin_lock(&pag->pag_ici_lock);
	error = radix_tree_insert(&pag->pag_ici_root, agino, ip);
	if (unlikely(error)) {
		WARN_ON(error != -EEXIST);
		XFS_STATS_INC(mp, xs_ig_dup);
		error = -EAGAIN;
		goto out_preload_end;
	}
	spin_unlock(&pag->pag_ici_lock);
	radix_tree_preload_end();

	*ipp = ip;
	return 0;

out_preload_end:
	spin_unlock(&pag->pag_ici_lock);
	radix_tree_preload_end();
	if (lock_flags)
		xfs_iunlock(ip, lock_flags);
out_destroy:
	__destroy_inode(VFS_I(ip));
	xfs_inode_free(ip);
	return error;
}
","xfs_iget_cache_miss(
	struct xfs_mount	*mp,
	struct xfs_perag	*pag,
	xfs_trans_t		*tp,
	xfs_ino_t		ino,
	struct xfs_inode	**ipp,
	int			flags,
	int			lock_flags)
{
	struct xfs_inode	*ip;
	int			error;
	xfs_agino_t		agino = XFS_INO_TO_AGINO(mp, ino);
	int			iflags;

	ip = xfs_inode_alloc(mp, ino);
	if (!ip)
		return -ENOMEM;

	error = xfs_iread(mp, tp, ip, flags);
	if (error)
		goto out_destroy;

	if (!xfs_inode_verify_forks(ip)) {
		error = -EFSCORRUPTED;
		goto out_destroy;
	}

	trace_xfs_iget_miss(ip);
 
 
 	/*
	 * If we are allocating a new inode, then check what was returned is
	 * actually a free, empty inode. If we are not allocating an inode,
	 * the check we didn't find a free inode.
 	 */
	if (flags & XFS_IGET_CREATE) {
		if (VFS_I(ip)->i_mode != 0) {
			xfs_warn(mp,
""Corruption detected! Free inode 0x%llx not marked free on disk"",
				ino);
			error = -EFSCORRUPTED;
			goto out_destroy;
		}
		if (ip->i_d.di_nblocks != 0) {
			xfs_warn(mp,
""Corruption detected! Free inode 0x%llx has blocks allocated!"",
				ino);
			error = -EFSCORRUPTED;
			goto out_destroy;
		}
	} else if (VFS_I(ip)->i_mode == 0) {
		error = -ENOENT;
 		goto out_destroy;
	}
 
 	/*
 	 * Preload the radix tree so we can insert safely under the
	 * write spinlock. Note that we cannot sleep inside the preload
	 * region. Since we can be called from transaction context, don't
	 * recurse into the file system.
	 */
	if (radix_tree_preload(GFP_NOFS)) {
		error = -EAGAIN;
		goto out_destroy;
	}

	/*
	 * Because the inode hasn't been added to the radix-tree yet it can't
	 * be found by another thread, so we can do the non-sleeping lock here.
	 */
	if (lock_flags) {
		if (!xfs_ilock_nowait(ip, lock_flags))
			BUG();
	}

	/*
	 * These values must be set before inserting the inode into the radix
	 * tree as the moment it is inserted a concurrent lookup (allowed by the
	 * RCU locking mechanism) can find it and that lookup must see that this
	 * is an inode currently under construction (i.e. that XFS_INEW is set).
	 * The ip->i_flags_lock that protects the XFS_INEW flag forms the
	 * memory barrier that ensures this detection works correctly at lookup
	 * time.
	 */
	iflags = XFS_INEW;
	if (flags & XFS_IGET_DONTCACHE)
		iflags |= XFS_IDONTCACHE;
	ip->i_udquot = NULL;
	ip->i_gdquot = NULL;
	ip->i_pdquot = NULL;
	xfs_iflags_set(ip, iflags);

	/* insert the new inode */
	spin_lock(&pag->pag_ici_lock);
	error = radix_tree_insert(&pag->pag_ici_root, agino, ip);
	if (unlikely(error)) {
		WARN_ON(error != -EEXIST);
		XFS_STATS_INC(mp, xs_ig_dup);
		error = -EAGAIN;
		goto out_preload_end;
	}
	spin_unlock(&pag->pag_ici_lock);
	radix_tree_preload_end();

	*ipp = ip;
	return 0;

out_preload_end:
	spin_unlock(&pag->pag_ici_lock);
	radix_tree_preload_end();
	if (lock_flags)
		xfs_iunlock(ip, lock_flags);
out_destroy:
	__destroy_inode(VFS_I(ip));
	xfs_inode_free(ip);
	return error;
}
",C,"	 * Check the inode free state is valid. This also detects lookup
	 * racing with unlinks.
	error = xfs_iget_check_free_state(ip, flags);
	if (error)
","	 * If we are allocating a new inode, then check what was returned is
	 * actually a free, empty inode. If we are not allocating an inode,
	 * the check we didn't find a free inode.
	if (flags & XFS_IGET_CREATE) {
		if (VFS_I(ip)->i_mode != 0) {
			xfs_warn(mp,
""Corruption detected! Free inode 0x%llx not marked free on disk"",
				ino);
			error = -EFSCORRUPTED;
			goto out_destroy;
		}
		if (ip->i_d.di_nblocks != 0) {
			xfs_warn(mp,
""Corruption detected! Free inode 0x%llx has blocks allocated!"",
				ino);
			error = -EFSCORRUPTED;
			goto out_destroy;
		}
	} else if (VFS_I(ip)->i_mode == 0) {
		error = -ENOENT;
	}
",,"@@ -308,6 +308,46 @@ xfs_reinit_inode(
 	return error;
 }
 
+/*
+ * If we are allocating a new inode, then check what was returned is
+ * actually a free, empty inode. If we are not allocating an inode,
+ * then check we didn't find a free inode.
+ *
+ * Returns:
+ *	0		if the inode free state matches the lookup context
+ *	-ENOENT		if the inode is free and we are not allocating
+ *	-EFSCORRUPTED	if there is any state mismatch at all
+ */
+static int
+xfs_iget_check_free_state(
+	struct xfs_inode	*ip,
+	int			flags)
+{
+	if (flags & XFS_IGET_CREATE) {
+		/* should be a free inode */
+		if (VFS_I(ip)->i_mode != 0) {
+			xfs_warn(ip->i_mount,
+""Corruption detected! Free inode 0x%llx not marked free! (mode 0x%x)"",
+				ip->i_ino, VFS_I(ip)->i_mode);
+			return -EFSCORRUPTED;
+		}
+
+		if (ip->i_d.di_nblocks != 0) {
+			xfs_warn(ip->i_mount,
+""Corruption detected! Free inode 0x%llx has blocks allocated!"",
+				ip->i_ino);
+			return -EFSCORRUPTED;
+		}
+		return 0;
+	}
+
+	/* should be an allocated inode */
+	if (VFS_I(ip)->i_mode == 0)
+		return -ENOENT;
+
+	return 0;
+}
+
 /*
  * Check the validity of the inode we just found it the cache
  */
@@ -357,12 +397,12 @@ xfs_iget_cache_hit(
 	}
 
 	/*
-	 * If lookup is racing with unlink return an error immediately.
+	 * Check the inode free state is valid. This also detects lookup
+	 * racing with unlinks.
 	 */
-	if (VFS_I(ip)->i_mode == 0 && !(flags & XFS_IGET_CREATE)) {
-		error = -ENOENT;
+	error = xfs_iget_check_free_state(ip, flags);
+	if (error)
 		goto out_error;
-	}
 
 	/*
 	 * If IRECLAIMABLE is set, we've torn down the VFS inode already.
@@ -485,29 +525,12 @@ xfs_iget_cache_miss(
 
 
 	/*
-	 * If we are allocating a new inode, then check what was returned is
-	 * actually a free, empty inode. If we are not allocating an inode,
-	 * the check we didn't find a free inode.
+	 * Check the inode free state is valid. This also detects lookup
+	 * racing with unlinks.
 	 */
-	if (flags & XFS_IGET_CREATE) {
-		if (VFS_I(ip)->i_mode != 0) {
-			xfs_warn(mp,
-""Corruption detected! Free inode 0x%llx not marked free on disk"",
-				ino);
-			error = -EFSCORRUPTED;
-			goto out_destroy;
-		}
-		if (ip->i_d.di_nblocks != 0) {
-			xfs_warn(mp,
-""Corruption detected! Free inode 0x%llx has blocks allocated!"",
-				ino);
-			error = -EFSCORRUPTED;
-			goto out_destroy;
-		}
-	} else if (VFS_I(ip)->i_mode == 0) {
-		error = -ENOENT;
+	error = xfs_iget_check_free_state(ip, flags);
+	if (error)
 		goto out_destroy;
-	}
 
 	/*
 	 * Preload the radix tree so we can insert safely under the",linux,afca6c5b2595fc44383919fba740c194b0b76aff,75bc37fefc4471e718ba8e651aa74673d4e0a9eb,1,"xfs_iget_cache_miss(
	struct xfs_mount	*mp,
	struct xfs_perag	*pag,
	xfs_trans_t		*tp,
	xfs_ino_t		ino,
	struct xfs_inode	**ipp,
	int			flags,
	int			lock_flags)
{
	struct xfs_inode	*ip;
	int			error;
	xfs_agino_t		agino = XFS_INO_TO_AGINO(mp, ino);
	int			iflags;

	ip = xfs_inode_alloc(mp, ino);
	if (!ip)
		return -ENOMEM;

	error = xfs_iread(mp, tp, ip, flags);
	if (error)
		goto out_destroy;

	if (!xfs_inode_verify_forks(ip)) {
		error = -EFSCORRUPTED;
		goto out_destroy;
	}

	trace_xfs_iget_miss(ip);
 
 
 	/*
//flaw_line_below:
	 * If we are allocating a new inode, then check what was returned is
//flaw_line_below:
	 * actually a free, empty inode. If we are not allocating an inode,
//flaw_line_below:
	 * the check we didn't find a free inode.
//fix_flaw_line_below:
//	 * Check the inode free state is valid. This also detects lookup
//fix_flaw_line_below:
//	 * racing with unlinks.
 	 */
//flaw_line_below:
	if (flags & XFS_IGET_CREATE) {
//flaw_line_below:
		if (VFS_I(ip)->i_mode != 0) {
//flaw_line_below:
			xfs_warn(mp,
//flaw_line_below:
""Corruption detected! Free inode 0x%llx not marked free on disk"",
//flaw_line_below:
				ino);
//flaw_line_below:
			error = -EFSCORRUPTED;
//flaw_line_below:
			goto out_destroy;
//flaw_line_below:
		}
//flaw_line_below:
		if (ip->i_d.di_nblocks != 0) {
//flaw_line_below:
			xfs_warn(mp,
//flaw_line_below:
""Corruption detected! Free inode 0x%llx has blocks allocated!"",
//flaw_line_below:
				ino);
//flaw_line_below:
			error = -EFSCORRUPTED;
//flaw_line_below:
			goto out_destroy;
//flaw_line_below:
		}
//flaw_line_below:
	} else if (VFS_I(ip)->i_mode == 0) {
//flaw_line_below:
		error = -ENOENT;
//fix_flaw_line_below:
//	error = xfs_iget_check_free_state(ip, flags);
//fix_flaw_line_below:
//	if (error)
 		goto out_destroy;
//flaw_line_below:
	}
 
 	/*
 	 * Preload the radix tree so we can insert safely under the
	 * write spinlock. Note that we cannot sleep inside the preload
	 * region. Since we can be called from transaction context, don't
	 * recurse into the file system.
	 */
	if (radix_tree_preload(GFP_NOFS)) {
		error = -EAGAIN;
		goto out_destroy;
	}

	/*
	 * Because the inode hasn't been added to the radix-tree yet it can't
	 * be found by another thread, so we can do the non-sleeping lock here.
	 */
	if (lock_flags) {
		if (!xfs_ilock_nowait(ip, lock_flags))
			BUG();
	}

	/*
	 * These values must be set before inserting the inode into the radix
	 * tree as the moment it is inserted a concurrent lookup (allowed by the
	 * RCU locking mechanism) can find it and that lookup must see that this
	 * is an inode currently under construction (i.e. that XFS_INEW is set).
	 * The ip->i_flags_lock that protects the XFS_INEW flag forms the
	 * memory barrier that ensures this detection works correctly at lookup
	 * time.
	 */
	iflags = XFS_INEW;
	if (flags & XFS_IGET_DONTCACHE)
		iflags |= XFS_IDONTCACHE;
	ip->i_udquot = NULL;
	ip->i_gdquot = NULL;
	ip->i_pdquot = NULL;
	xfs_iflags_set(ip, iflags);

	/* insert the new inode */
	spin_lock(&pag->pag_ici_lock);
	error = radix_tree_insert(&pag->pag_ici_root, agino, ip);
	if (unlikely(error)) {
		WARN_ON(error != -EEXIST);
		XFS_STATS_INC(mp, xs_ig_dup);
		error = -EAGAIN;
		goto out_preload_end;
	}
	spin_unlock(&pag->pag_ici_lock);
	radix_tree_preload_end();

	*ipp = ip;
	return 0;

out_preload_end:
	spin_unlock(&pag->pag_ici_lock);
	radix_tree_preload_end();
	if (lock_flags)
		xfs_iunlock(ip, lock_flags);
out_destroy:
	__destroy_inode(VFS_I(ip));
	xfs_inode_free(ip);
	return error;
}
"
4625,182361,,Remote,Not required,Partial,CVE-2018-12460,https://www.cvedetails.com/cve/CVE-2018-12460/,CWE-476,Medium,,,,2018-06-15,4.3,"libavcodec in FFmpeg 4.0 may trigger a NULL pointer dereference if the studio profile is incorrectly detected while converting a crafted AVI file to MPEG4, leading to a denial of service, related to idctdsp.c and mpegvideo.c.",2018-08-02,DoS ,1,https://github.com/FFmpeg/FFmpeg/commit/b3332a182f8ba33a34542e4a0370f38b914ccf7d,b3332a182f8ba33a34542e4a0370f38b914ccf7d,"avcodec/idctdsp: Transmit studio_profile to init instead of using AVCodecContext profile

These 2 fields are not always the same, it is simpler to always use the same field
for detecting studio profile

Fixes: null pointer dereference
Fixes: ffmpeg_crash_3.avi

Found-by: Thuan Pham <thuanpv@comp.nus.edu.sg>, Marcel Böhme, Andrew Santosa and Alexandru RazvanCaciulescu with AFLSmart
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",1,libavcodec/idctdsp.c,"{""sha"": ""954066a5e3c5ff8ad31dc062346d2bcfec393d02"", ""filename"": ""libavcodec/idctdsp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/b3332a182f8ba33a34542e4a0370f38b914ccf7d/libavcodec/idctdsp.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/b3332a182f8ba33a34542e4a0370f38b914ccf7d/libavcodec/idctdsp.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavcodec/idctdsp.c?ref=b3332a182f8ba33a34542e4a0370f38b914ccf7d"", ""patch"": ""@@ -258,7 +258,7 @@ av_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx)\n         if (avctx->bits_per_raw_sample == 10 || avctx->bits_per_raw_sample == 9) {\n             /* 10-bit MPEG-4 Simple Studio Profile requires a higher precision IDCT\n                However, it only uses idct_put */\n-            if (avctx->codec_id == AV_CODEC_ID_MPEG4 && avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO)\n+            if (c->mpeg4_studio_profile)\n                 c->idct_put              = ff_simple_idct_put_int32_10bit;\n             else {\n                 c->idct_put              = ff_simple_idct_put_int16_10bit;""}<_**next**_>{""sha"": ""ca21a31a028cebf20977f3767166d3a2cc9d64f2"", ""filename"": ""libavcodec/idctdsp.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/b3332a182f8ba33a34542e4a0370f38b914ccf7d/libavcodec/idctdsp.h"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/b3332a182f8ba33a34542e4a0370f38b914ccf7d/libavcodec/idctdsp.h"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavcodec/idctdsp.h?ref=b3332a182f8ba33a34542e4a0370f38b914ccf7d"", ""patch"": ""@@ -95,6 +95,8 @@ typedef struct IDCTDSPContext {\n      */\n     uint8_t idct_permutation[64];\n     enum idct_permutation_type perm_type;\n+\n+    int mpeg4_studio_profile;\n } IDCTDSPContext;\n \n void ff_put_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,""}<_**next**_>{""sha"": ""f75c0fd9b3647f1ecc6a8ed3d6fe7105b78349ce"", ""filename"": ""libavcodec/mpegvideo.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/b3332a182f8ba33a34542e4a0370f38b914ccf7d/libavcodec/mpegvideo.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/b3332a182f8ba33a34542e4a0370f38b914ccf7d/libavcodec/mpegvideo.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavcodec/mpegvideo.c?ref=b3332a182f8ba33a34542e4a0370f38b914ccf7d"", ""patch"": ""@@ -329,6 +329,8 @@ static av_cold int dct_init(MpegEncContext *s)\n \n av_cold void ff_mpv_idct_init(MpegEncContext *s)\n {\n+    if (s->codec_id == AV_CODEC_ID_MPEG4)\n+        s->idsp.mpeg4_studio_profile = s->studio_profile;\n     ff_idctdsp_init(&s->idsp, s->avctx);\n \n     /* load & permutate scantables""}","av_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx)
{
    const unsigned high_bit_depth = avctx->bits_per_raw_sample > 8;

    if (avctx->lowres==1) {
        c->idct_put  = ff_jref_idct4_put;
        c->idct_add  = ff_jref_idct4_add;
        c->idct      = ff_j_rev_dct4;
        c->perm_type = FF_IDCT_PERM_NONE;
    } else if (avctx->lowres==2) {
        c->idct_put  = ff_jref_idct2_put;
        c->idct_add  = ff_jref_idct2_add;
        c->idct      = ff_j_rev_dct2;
        c->perm_type = FF_IDCT_PERM_NONE;
    } else if (avctx->lowres==3) {
        c->idct_put  = ff_jref_idct1_put;
        c->idct_add  = ff_jref_idct1_add;
        c->idct      = ff_j_rev_dct1;
        c->perm_type = FF_IDCT_PERM_NONE;
    } else {
         if (avctx->bits_per_raw_sample == 10 || avctx->bits_per_raw_sample == 9) {
             /* 10-bit MPEG-4 Simple Studio Profile requires a higher precision IDCT
                However, it only uses idct_put */
            if (c->mpeg4_studio_profile)
                 c->idct_put              = ff_simple_idct_put_int32_10bit;
             else {
                 c->idct_put              = ff_simple_idct_put_int16_10bit;
                c->idct_add              = ff_simple_idct_add_int16_10bit;
                c->idct                  = ff_simple_idct_int16_10bit;
            }
            c->perm_type             = FF_IDCT_PERM_NONE;
        } else if (avctx->bits_per_raw_sample == 12) {
            c->idct_put              = ff_simple_idct_put_int16_12bit;
            c->idct_add              = ff_simple_idct_add_int16_12bit;
            c->idct                  = ff_simple_idct_int16_12bit;
            c->perm_type             = FF_IDCT_PERM_NONE;
        } else {
            if (avctx->idct_algo == FF_IDCT_INT) {
                c->idct_put  = ff_jref_idct_put;
                c->idct_add  = ff_jref_idct_add;
                c->idct      = ff_j_rev_dct;
                c->perm_type = FF_IDCT_PERM_LIBMPEG2;
#if CONFIG_FAANIDCT
            } else if (avctx->idct_algo == FF_IDCT_FAAN) {
                c->idct_put  = ff_faanidct_put;
                c->idct_add  = ff_faanidct_add;
                c->idct      = ff_faanidct;
                c->perm_type = FF_IDCT_PERM_NONE;
#endif /* CONFIG_FAANIDCT */
            } else { // accurate/default
                /* Be sure FF_IDCT_NONE will select this one, since it uses FF_IDCT_PERM_NONE */
                c->idct_put  = ff_simple_idct_put_int16_8bit;
                c->idct_add  = ff_simple_idct_add_int16_8bit;
                c->idct      = ff_simple_idct_int16_8bit;
                c->perm_type = FF_IDCT_PERM_NONE;
            }
        }
    }

    c->put_pixels_clamped        = ff_put_pixels_clamped_c;
    c->put_signed_pixels_clamped = put_signed_pixels_clamped_c;
    c->add_pixels_clamped        = ff_add_pixels_clamped_c;

    if (CONFIG_MPEG4_DECODER && avctx->idct_algo == FF_IDCT_XVID)
        ff_xvid_idct_init(c, avctx);

    if (ARCH_AARCH64)
        ff_idctdsp_init_aarch64(c, avctx, high_bit_depth);
    if (ARCH_ALPHA)
        ff_idctdsp_init_alpha(c, avctx, high_bit_depth);
    if (ARCH_ARM)
        ff_idctdsp_init_arm(c, avctx, high_bit_depth);
    if (ARCH_PPC)
        ff_idctdsp_init_ppc(c, avctx, high_bit_depth);
    if (ARCH_X86)
        ff_idctdsp_init_x86(c, avctx, high_bit_depth);
    if (ARCH_MIPS)
        ff_idctdsp_init_mips(c, avctx, high_bit_depth);

    ff_init_scantable_permutation(c->idct_permutation,
                                  c->perm_type);
}
","av_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx)
{
    const unsigned high_bit_depth = avctx->bits_per_raw_sample > 8;

    if (avctx->lowres==1) {
        c->idct_put  = ff_jref_idct4_put;
        c->idct_add  = ff_jref_idct4_add;
        c->idct      = ff_j_rev_dct4;
        c->perm_type = FF_IDCT_PERM_NONE;
    } else if (avctx->lowres==2) {
        c->idct_put  = ff_jref_idct2_put;
        c->idct_add  = ff_jref_idct2_add;
        c->idct      = ff_j_rev_dct2;
        c->perm_type = FF_IDCT_PERM_NONE;
    } else if (avctx->lowres==3) {
        c->idct_put  = ff_jref_idct1_put;
        c->idct_add  = ff_jref_idct1_add;
        c->idct      = ff_j_rev_dct1;
        c->perm_type = FF_IDCT_PERM_NONE;
    } else {
         if (avctx->bits_per_raw_sample == 10 || avctx->bits_per_raw_sample == 9) {
             /* 10-bit MPEG-4 Simple Studio Profile requires a higher precision IDCT
                However, it only uses idct_put */
            if (avctx->codec_id == AV_CODEC_ID_MPEG4 && avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO)
                 c->idct_put              = ff_simple_idct_put_int32_10bit;
             else {
                 c->idct_put              = ff_simple_idct_put_int16_10bit;
                c->idct_add              = ff_simple_idct_add_int16_10bit;
                c->idct                  = ff_simple_idct_int16_10bit;
            }
            c->perm_type             = FF_IDCT_PERM_NONE;
        } else if (avctx->bits_per_raw_sample == 12) {
            c->idct_put              = ff_simple_idct_put_int16_12bit;
            c->idct_add              = ff_simple_idct_add_int16_12bit;
            c->idct                  = ff_simple_idct_int16_12bit;
            c->perm_type             = FF_IDCT_PERM_NONE;
        } else {
            if (avctx->idct_algo == FF_IDCT_INT) {
                c->idct_put  = ff_jref_idct_put;
                c->idct_add  = ff_jref_idct_add;
                c->idct      = ff_j_rev_dct;
                c->perm_type = FF_IDCT_PERM_LIBMPEG2;
#if CONFIG_FAANIDCT
            } else if (avctx->idct_algo == FF_IDCT_FAAN) {
                c->idct_put  = ff_faanidct_put;
                c->idct_add  = ff_faanidct_add;
                c->idct      = ff_faanidct;
                c->perm_type = FF_IDCT_PERM_NONE;
#endif /* CONFIG_FAANIDCT */
            } else { // accurate/default
                /* Be sure FF_IDCT_NONE will select this one, since it uses FF_IDCT_PERM_NONE */
                c->idct_put  = ff_simple_idct_put_int16_8bit;
                c->idct_add  = ff_simple_idct_add_int16_8bit;
                c->idct      = ff_simple_idct_int16_8bit;
                c->perm_type = FF_IDCT_PERM_NONE;
            }
        }
    }

    c->put_pixels_clamped        = ff_put_pixels_clamped_c;
    c->put_signed_pixels_clamped = put_signed_pixels_clamped_c;
    c->add_pixels_clamped        = ff_add_pixels_clamped_c;

    if (CONFIG_MPEG4_DECODER && avctx->idct_algo == FF_IDCT_XVID)
        ff_xvid_idct_init(c, avctx);

    if (ARCH_AARCH64)
        ff_idctdsp_init_aarch64(c, avctx, high_bit_depth);
    if (ARCH_ALPHA)
        ff_idctdsp_init_alpha(c, avctx, high_bit_depth);
    if (ARCH_ARM)
        ff_idctdsp_init_arm(c, avctx, high_bit_depth);
    if (ARCH_PPC)
        ff_idctdsp_init_ppc(c, avctx, high_bit_depth);
    if (ARCH_X86)
        ff_idctdsp_init_x86(c, avctx, high_bit_depth);
    if (ARCH_MIPS)
        ff_idctdsp_init_mips(c, avctx, high_bit_depth);

    ff_init_scantable_permutation(c->idct_permutation,
                                  c->perm_type);
}
",C,"            if (c->mpeg4_studio_profile)
","            if (avctx->codec_id == AV_CODEC_ID_MPEG4 && avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO)
",,"@@ -258,7 +258,7 @@ av_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx)
         if (avctx->bits_per_raw_sample == 10 || avctx->bits_per_raw_sample == 9) {
             /* 10-bit MPEG-4 Simple Studio Profile requires a higher precision IDCT
                However, it only uses idct_put */
-            if (avctx->codec_id == AV_CODEC_ID_MPEG4 && avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO)
+            if (c->mpeg4_studio_profile)
                 c->idct_put              = ff_simple_idct_put_int32_10bit;
             else {
                 c->idct_put              = ff_simple_idct_put_int16_10bit;",FFmpeg,b3332a182f8ba33a34542e4a0370f38b914ccf7d,1aa519245193485cd74a52aacc99fd3fec58d0b4,1,"av_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx)
{
    const unsigned high_bit_depth = avctx->bits_per_raw_sample > 8;

    if (avctx->lowres==1) {
        c->idct_put  = ff_jref_idct4_put;
        c->idct_add  = ff_jref_idct4_add;
        c->idct      = ff_j_rev_dct4;
        c->perm_type = FF_IDCT_PERM_NONE;
    } else if (avctx->lowres==2) {
        c->idct_put  = ff_jref_idct2_put;
        c->idct_add  = ff_jref_idct2_add;
        c->idct      = ff_j_rev_dct2;
        c->perm_type = FF_IDCT_PERM_NONE;
    } else if (avctx->lowres==3) {
        c->idct_put  = ff_jref_idct1_put;
        c->idct_add  = ff_jref_idct1_add;
        c->idct      = ff_j_rev_dct1;
        c->perm_type = FF_IDCT_PERM_NONE;
    } else {
         if (avctx->bits_per_raw_sample == 10 || avctx->bits_per_raw_sample == 9) {
             /* 10-bit MPEG-4 Simple Studio Profile requires a higher precision IDCT
                However, it only uses idct_put */
//flaw_line_below:
            if (avctx->codec_id == AV_CODEC_ID_MPEG4 && avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO)
//fix_flaw_line_below:
//            if (c->mpeg4_studio_profile)
                 c->idct_put              = ff_simple_idct_put_int32_10bit;
             else {
                 c->idct_put              = ff_simple_idct_put_int16_10bit;
                c->idct_add              = ff_simple_idct_add_int16_10bit;
                c->idct                  = ff_simple_idct_int16_10bit;
            }
            c->perm_type             = FF_IDCT_PERM_NONE;
        } else if (avctx->bits_per_raw_sample == 12) {
            c->idct_put              = ff_simple_idct_put_int16_12bit;
            c->idct_add              = ff_simple_idct_add_int16_12bit;
            c->idct                  = ff_simple_idct_int16_12bit;
            c->perm_type             = FF_IDCT_PERM_NONE;
        } else {
            if (avctx->idct_algo == FF_IDCT_INT) {
                c->idct_put  = ff_jref_idct_put;
                c->idct_add  = ff_jref_idct_add;
                c->idct      = ff_j_rev_dct;
                c->perm_type = FF_IDCT_PERM_LIBMPEG2;
#if CONFIG_FAANIDCT
            } else if (avctx->idct_algo == FF_IDCT_FAAN) {
                c->idct_put  = ff_faanidct_put;
                c->idct_add  = ff_faanidct_add;
                c->idct      = ff_faanidct;
                c->perm_type = FF_IDCT_PERM_NONE;
#endif /* CONFIG_FAANIDCT */
            } else { // accurate/default
                /* Be sure FF_IDCT_NONE will select this one, since it uses FF_IDCT_PERM_NONE */
                c->idct_put  = ff_simple_idct_put_int16_8bit;
                c->idct_add  = ff_simple_idct_add_int16_8bit;
                c->idct      = ff_simple_idct_int16_8bit;
                c->perm_type = FF_IDCT_PERM_NONE;
            }
        }
    }

    c->put_pixels_clamped        = ff_put_pixels_clamped_c;
    c->put_signed_pixels_clamped = put_signed_pixels_clamped_c;
    c->add_pixels_clamped        = ff_add_pixels_clamped_c;

    if (CONFIG_MPEG4_DECODER && avctx->idct_algo == FF_IDCT_XVID)
        ff_xvid_idct_init(c, avctx);

    if (ARCH_AARCH64)
        ff_idctdsp_init_aarch64(c, avctx, high_bit_depth);
    if (ARCH_ALPHA)
        ff_idctdsp_init_alpha(c, avctx, high_bit_depth);
    if (ARCH_ARM)
        ff_idctdsp_init_arm(c, avctx, high_bit_depth);
    if (ARCH_PPC)
        ff_idctdsp_init_ppc(c, avctx, high_bit_depth);
    if (ARCH_X86)
        ff_idctdsp_init_x86(c, avctx, high_bit_depth);
    if (ARCH_MIPS)
        ff_idctdsp_init_mips(c, avctx, high_bit_depth);

    ff_init_scantable_permutation(c->idct_permutation,
                                  c->perm_type);
}
"
4626,182362,,Remote,Not required,Partial,CVE-2018-12460,https://www.cvedetails.com/cve/CVE-2018-12460/,CWE-476,Medium,,,,2018-06-15,4.3,"libavcodec in FFmpeg 4.0 may trigger a NULL pointer dereference if the studio profile is incorrectly detected while converting a crafted AVI file to MPEG4, leading to a denial of service, related to idctdsp.c and mpegvideo.c.",2018-08-02,DoS ,2,https://github.com/FFmpeg/FFmpeg/commit/b3332a182f8ba33a34542e4a0370f38b914ccf7d,b3332a182f8ba33a34542e4a0370f38b914ccf7d,"avcodec/idctdsp: Transmit studio_profile to init instead of using AVCodecContext profile

These 2 fields are not always the same, it is simpler to always use the same field
for detecting studio profile

Fixes: null pointer dereference
Fixes: ffmpeg_crash_3.avi

Found-by: Thuan Pham <thuanpv@comp.nus.edu.sg>, Marcel Böhme, Andrew Santosa and Alexandru RazvanCaciulescu with AFLSmart
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",0,libavcodec/mpegvideo.c,"{""sha"": ""954066a5e3c5ff8ad31dc062346d2bcfec393d02"", ""filename"": ""libavcodec/idctdsp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/b3332a182f8ba33a34542e4a0370f38b914ccf7d/libavcodec/idctdsp.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/b3332a182f8ba33a34542e4a0370f38b914ccf7d/libavcodec/idctdsp.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavcodec/idctdsp.c?ref=b3332a182f8ba33a34542e4a0370f38b914ccf7d"", ""patch"": ""@@ -258,7 +258,7 @@ av_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx)\n         if (avctx->bits_per_raw_sample == 10 || avctx->bits_per_raw_sample == 9) {\n             /* 10-bit MPEG-4 Simple Studio Profile requires a higher precision IDCT\n                However, it only uses idct_put */\n-            if (avctx->codec_id == AV_CODEC_ID_MPEG4 && avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO)\n+            if (c->mpeg4_studio_profile)\n                 c->idct_put              = ff_simple_idct_put_int32_10bit;\n             else {\n                 c->idct_put              = ff_simple_idct_put_int16_10bit;""}<_**next**_>{""sha"": ""ca21a31a028cebf20977f3767166d3a2cc9d64f2"", ""filename"": ""libavcodec/idctdsp.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/b3332a182f8ba33a34542e4a0370f38b914ccf7d/libavcodec/idctdsp.h"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/b3332a182f8ba33a34542e4a0370f38b914ccf7d/libavcodec/idctdsp.h"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavcodec/idctdsp.h?ref=b3332a182f8ba33a34542e4a0370f38b914ccf7d"", ""patch"": ""@@ -95,6 +95,8 @@ typedef struct IDCTDSPContext {\n      */\n     uint8_t idct_permutation[64];\n     enum idct_permutation_type perm_type;\n+\n+    int mpeg4_studio_profile;\n } IDCTDSPContext;\n \n void ff_put_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,""}<_**next**_>{""sha"": ""f75c0fd9b3647f1ecc6a8ed3d6fe7105b78349ce"", ""filename"": ""libavcodec/mpegvideo.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/b3332a182f8ba33a34542e4a0370f38b914ccf7d/libavcodec/mpegvideo.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/b3332a182f8ba33a34542e4a0370f38b914ccf7d/libavcodec/mpegvideo.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavcodec/mpegvideo.c?ref=b3332a182f8ba33a34542e4a0370f38b914ccf7d"", ""patch"": ""@@ -329,6 +329,8 @@ static av_cold int dct_init(MpegEncContext *s)\n \n av_cold void ff_mpv_idct_init(MpegEncContext *s)\n {\n+    if (s->codec_id == AV_CODEC_ID_MPEG4)\n+        s->idsp.mpeg4_studio_profile = s->studio_profile;\n     ff_idctdsp_init(&s->idsp, s->avctx);\n \n     /* load & permutate scantables""}"," av_cold void ff_mpv_idct_init(MpegEncContext *s)
 {
    if (s->codec_id == AV_CODEC_ID_MPEG4)
        s->idsp.mpeg4_studio_profile = s->studio_profile;
     ff_idctdsp_init(&s->idsp, s->avctx);
 
     /* load & permutate scantables
     * note: only wmv uses different ones
     */
    if (s->alternate_scan) {
        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);
        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);
    } else {
        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);
        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);
    }
    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);
    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);
}
"," av_cold void ff_mpv_idct_init(MpegEncContext *s)
 {
     ff_idctdsp_init(&s->idsp, s->avctx);
 
     /* load & permutate scantables
     * note: only wmv uses different ones
     */
    if (s->alternate_scan) {
        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);
        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);
    } else {
        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);
        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);
    }
    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);
    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);
}
",C,"    if (s->codec_id == AV_CODEC_ID_MPEG4)
        s->idsp.mpeg4_studio_profile = s->studio_profile;
",,,"@@ -329,6 +329,8 @@ static av_cold int dct_init(MpegEncContext *s)
 
 av_cold void ff_mpv_idct_init(MpegEncContext *s)
 {
+    if (s->codec_id == AV_CODEC_ID_MPEG4)
+        s->idsp.mpeg4_studio_profile = s->studio_profile;
     ff_idctdsp_init(&s->idsp, s->avctx);
 
     /* load & permutate scantables",FFmpeg,b3332a182f8ba33a34542e4a0370f38b914ccf7d,1aa519245193485cd74a52aacc99fd3fec58d0b4,1," av_cold void ff_mpv_idct_init(MpegEncContext *s)
 {
//fix_flaw_line_below:
//    if (s->codec_id == AV_CODEC_ID_MPEG4)
//fix_flaw_line_below:
//        s->idsp.mpeg4_studio_profile = s->studio_profile;
     ff_idctdsp_init(&s->idsp, s->avctx);
 
     /* load & permutate scantables
     * note: only wmv uses different ones
     */
    if (s->alternate_scan) {
        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);
        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);
    } else {
        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);
        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);
    }
    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);
    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);
}
"
4636,182372,,Remote,Not required,Partial,CVE-2018-12249,https://www.cvedetails.com/cve/CVE-2018-12249/,CWE-476,Low,,,,2018-06-12,5.0,An issue was discovered in mruby 1.4.1. There is a NULL pointer dereference in mrb_class_real because *class BasicObject* is not properly supported in class.c.,2018-08-02,,2,https://github.com/mruby/mruby/commit/faa4eaf6803bd11669bc324b4c34e7162286bfa3,faa4eaf6803bd11669bc324b4c34e7162286bfa3,`mrb_class_real()` did not work for `BasicObject`; fix #4037,2,src/class.c,"{""sha"": ""a9439d7d7d4bc2781cf4c97b17d583b0dd831eee"", ""filename"": ""src/class.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/mruby/mruby/blob/faa4eaf6803bd11669bc324b4c34e7162286bfa3/src/class.c"", ""raw_url"": ""https://github.com/mruby/mruby/raw/faa4eaf6803bd11669bc324b4c34e7162286bfa3/src/class.c"", ""contents_url"": ""https://api.github.com/repos/mruby/mruby/contents/src/class.c?ref=faa4eaf6803bd11669bc324b4c34e7162286bfa3"", ""patch"": ""@@ -1763,10 +1763,10 @@ mrb_class_path(mrb_state *mrb, struct RClass *c)\n MRB_API struct RClass*\n mrb_class_real(struct RClass* cl)\n {\n-  if (cl == 0)\n-    return NULL;\n+  if (cl == 0) return NULL;\n   while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n     cl = cl->super;\n+    if (cl == 0) return NULL;\n   }\n   return cl;\n }""}"," mrb_class_real(struct RClass* cl)
 {
  if (cl == 0) return NULL;
   while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {
     cl = cl->super;
    if (cl == 0) return NULL;
   }
   return cl;
 }
"," mrb_class_real(struct RClass* cl)
 {
  if (cl == 0)
    return NULL;
   while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {
     cl = cl->super;
   }
   return cl;
 }
",C,"  if (cl == 0) return NULL;
    if (cl == 0) return NULL;
","  if (cl == 0)
    return NULL;
",,"@@ -1763,10 +1763,10 @@ mrb_class_path(mrb_state *mrb, struct RClass *c)
 MRB_API struct RClass*
 mrb_class_real(struct RClass* cl)
 {
-  if (cl == 0)
-    return NULL;
+  if (cl == 0) return NULL;
   while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {
     cl = cl->super;
+    if (cl == 0) return NULL;
   }
   return cl;
 }",mruby,faa4eaf6803bd11669bc324b4c34e7162286bfa3,55edae0226409de25e59922807cb09acb45731a2,1," mrb_class_real(struct RClass* cl)
 {
//flaw_line_below:
  if (cl == 0)
//flaw_line_below:
    return NULL;
//fix_flaw_line_below:
//  if (cl == 0) return NULL;
   while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {
     cl = cl->super;
//fix_flaw_line_below:
//    if (cl == 0) return NULL;
   }
   return cl;
 }
"
4638,182374,,Remote,Not required,Partial,CVE-2018-12247,https://www.cvedetails.com/cve/CVE-2018-12247/,CWE-476,Low,,,,2018-06-12,5.0,"An issue was discovered in mruby 1.4.1. There is a NULL pointer dereference in mrb_class, related to certain .clone usage, because mrb_obj_clone in kernel.c copies flags other than the MRB_FLAG_IS_FROZEN flag (e.g., the embedded flag).",2018-08-01,,1,https://github.com/mruby/mruby/commit/55edae0226409de25e59922807cb09acb45731a2,55edae0226409de25e59922807cb09acb45731a2,"Allow `Object#clone` to copy frozen status only; fix #4036

Copying all flags from the original object may overwrite the clone's
flags e.g. the embedded flag.",1,src/kernel.c,"{""sha"": ""bbe6e8bb7524bbb1c139525f95cba815d8dfeeb4"", ""filename"": ""src/kernel.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/mruby/mruby/blob/55edae0226409de25e59922807cb09acb45731a2/src/kernel.c"", ""raw_url"": ""https://github.com/mruby/mruby/raw/55edae0226409de25e59922807cb09acb45731a2/src/kernel.c"", ""contents_url"": ""https://api.github.com/repos/mruby/mruby/contents/src/kernel.c?ref=55edae0226409de25e59922807cb09acb45731a2"", ""patch"": ""@@ -348,7 +348,7 @@ mrb_obj_clone(mrb_state *mrb, mrb_value self)\n   mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n   clone = mrb_obj_value(p);\n   init_copy(mrb, clone, self);\n-  p->flags = mrb_obj_ptr(self)->flags;\n+  p->flags |= mrb_obj_ptr(self)->flags & MRB_FLAG_IS_FROZEN;\n \n   return clone;\n }""}","mrb_obj_clone(mrb_state *mrb, mrb_value self)
{
  struct RObject *p;
  mrb_value clone;

  if (mrb_immediate_p(self)) {
    mrb_raisef(mrb, E_TYPE_ERROR, ""can't clone %S"", self);
  }
  if (mrb_type(self) == MRB_TT_SCLASS) {
    mrb_raise(mrb, E_TYPE_ERROR, ""can't clone singleton class"");
  }
  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));
  p->c = mrb_singleton_class_clone(mrb, self);
   mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);
   clone = mrb_obj_value(p);
   init_copy(mrb, clone, self);
  p->flags |= mrb_obj_ptr(self)->flags & MRB_FLAG_IS_FROZEN;
 
   return clone;
 }
","mrb_obj_clone(mrb_state *mrb, mrb_value self)
{
  struct RObject *p;
  mrb_value clone;

  if (mrb_immediate_p(self)) {
    mrb_raisef(mrb, E_TYPE_ERROR, ""can't clone %S"", self);
  }
  if (mrb_type(self) == MRB_TT_SCLASS) {
    mrb_raise(mrb, E_TYPE_ERROR, ""can't clone singleton class"");
  }
  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));
  p->c = mrb_singleton_class_clone(mrb, self);
   mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);
   clone = mrb_obj_value(p);
   init_copy(mrb, clone, self);
  p->flags = mrb_obj_ptr(self)->flags;
 
   return clone;
 }
",C,"  p->flags |= mrb_obj_ptr(self)->flags & MRB_FLAG_IS_FROZEN;
","  p->flags = mrb_obj_ptr(self)->flags;
",,"@@ -348,7 +348,7 @@ mrb_obj_clone(mrb_state *mrb, mrb_value self)
   mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);
   clone = mrb_obj_value(p);
   init_copy(mrb, clone, self);
-  p->flags = mrb_obj_ptr(self)->flags;
+  p->flags |= mrb_obj_ptr(self)->flags & MRB_FLAG_IS_FROZEN;
 
   return clone;
 }",mruby,55edae0226409de25e59922807cb09acb45731a2,cfd0c93d7d9dad13e6677beb7b7bd822a7572f8d,1,"mrb_obj_clone(mrb_state *mrb, mrb_value self)
{
  struct RObject *p;
  mrb_value clone;

  if (mrb_immediate_p(self)) {
    mrb_raisef(mrb, E_TYPE_ERROR, ""can't clone %S"", self);
  }
  if (mrb_type(self) == MRB_TT_SCLASS) {
    mrb_raise(mrb, E_TYPE_ERROR, ""can't clone singleton class"");
  }
  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));
  p->c = mrb_singleton_class_clone(mrb, self);
   mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);
   clone = mrb_obj_value(p);
   init_copy(mrb, clone, self);
//flaw_line_below:
  p->flags = mrb_obj_ptr(self)->flags;
//fix_flaw_line_below:
//  p->flags |= mrb_obj_ptr(self)->flags & MRB_FLAG_IS_FROZEN;
 
   return clone;
 }
"
4653,182389,,Remote,Not required,Partial,CVE-2018-11591,https://www.cvedetails.com/cve/CVE-2018-11591/,CWE-476,Medium,,,,2018-05-31,4.3,Espruino before 1.98 allows attackers to cause a denial of service (application crash) with a user crafted input file via a NULL pointer dereference during syntax parsing. This was addressed by adding validation for a debug trace print statement in jsvar.c.,2018-06-08,DoS ,1,https://github.com/espruino/Espruino/commit/b6d362f6a1f2de0b3e7604848116efb509196bf4,b6d362f6a1f2de0b3e7604848116efb509196bf4,Add sanity check for debug trace print statement (fix #1420),1,src/jsvar.c,"{""sha"": ""793ab99a2c54f29fec821a6fe1d15f0082ab5494"", ""filename"": ""ChangeLog"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/espruino/Espruino/blob/b6d362f6a1f2de0b3e7604848116efb509196bf4/ChangeLog"", ""raw_url"": ""https://github.com/espruino/Espruino/raw/b6d362f6a1f2de0b3e7604848116efb509196bf4/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/espruino/Espruino/contents/ChangeLog?ref=b6d362f6a1f2de0b3e7604848116efb509196bf4"", ""patch"": ""@@ -22,6 +22,7 @@\n             Move default I2C bitrate to 100kbit/sec\n             Linux: don't create a espruino.flash file if we're not writing to flash\n             Add height check for Graphics.createArrayBuffer(...vertical_byte:true) (fix #1421)\n+            Add sanity check for debug trace print statement (fix #1420)\n \n      1v97 : nRF52: fix NRF.on('connect',...) issue\n             STM32: Fix setDeviceClockCmd error for USB.setConsole()""}<_**next**_>{""sha"": ""8edb27b6e4d3994592e8ca5232642733616b231a"", ""filename"": ""src/jsvar.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/espruino/Espruino/blob/b6d362f6a1f2de0b3e7604848116efb509196bf4/src/jsvar.c"", ""raw_url"": ""https://github.com/espruino/Espruino/raw/b6d362f6a1f2de0b3e7604848116efb509196bf4/src/jsvar.c"", ""contents_url"": ""https://api.github.com/repos/espruino/Espruino/contents/src/jsvar.c?ref=b6d362f6a1f2de0b3e7604848116efb509196bf4"", ""patch"": ""@@ -3314,7 +3314,7 @@ void _jsvTrace(JsVar *var, int indent, JsVar *baseVar, int level) {\n   else if (jsvIsFloat(var)) jsiConsolePrintf(\""Double %f\"", jsvGetFloat(var));\n   else if (jsvIsFunctionParameter(var)) jsiConsolePrintf(\""Param %q \"", var);\n   else if (jsvIsArrayBufferName(var)) jsiConsolePrintf(\""ArrayBufferName[%d] \"", jsvGetInteger(var));\n-  else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(\""%s \"", jswGetBasicObjectName(var)); // way to get nice name\n+  else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(\""%s \"", jswGetBasicObjectName(var)?jswGetBasicObjectName(var):\""unknown ArrayBuffer\""); // way to get nice name\n   else if (jsvIsString(var)) {\n     size_t blocks = 1;\n     if (jsvGetLastChild(var)) {""}","void _jsvTrace(JsVar *var, int indent, JsVar *baseVar, int level) {
#ifdef SAVE_ON_FLASH
  jsiConsolePrint(""Trace unimplemented in this version.\n"");
#else
  int i;
  for (i=0;i<indent;i++) jsiConsolePrint("" "");

  if (!var) {
    jsiConsolePrint(""undefined"");
    return;
  }

  jsvTraceLockInfo(var);

  int lowestLevel = _jsvTraceGetLowestLevel(baseVar, var);
  if (lowestLevel < level) {
    jsiConsolePrint(""...\n"");
    return;
  }

  if (jsvIsName(var)) jsiConsolePrint(""Name "");

  char endBracket = ' ';
  if (jsvIsObject(var)) { jsiConsolePrint(""Object { ""); endBracket = '}'; }
  else if (jsvIsArray(var)) { jsiConsolePrintf(""Array(%d) [ "", var->varData.integer); endBracket = ']'; }
  else if (jsvIsNativeFunction(var)) { jsiConsolePrintf(""NativeFunction 0x%x (%d) { "", var->varData.native.ptr, var->varData.native.argTypes); endBracket = '}'; }
  else if (jsvIsFunction(var)) {
    jsiConsolePrint(""Function { "");
    if (jsvIsFunctionReturn(var)) jsiConsolePrint(""return "");
    endBracket = '}';
  } else if (jsvIsPin(var)) jsiConsolePrintf(""Pin %d"", jsvGetInteger(var));
  else if (jsvIsInt(var)) jsiConsolePrintf(""Integer %d"", jsvGetInteger(var));
  else if (jsvIsBoolean(var)) jsiConsolePrintf(""Bool %s"", jsvGetBool(var)?""true"":""false"");
   else if (jsvIsFloat(var)) jsiConsolePrintf(""Double %f"", jsvGetFloat(var));
   else if (jsvIsFunctionParameter(var)) jsiConsolePrintf(""Param %q "", var);
   else if (jsvIsArrayBufferName(var)) jsiConsolePrintf(""ArrayBufferName[%d] "", jsvGetInteger(var));
  else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(""%s "", jswGetBasicObjectName(var)?jswGetBasicObjectName(var):""unknown ArrayBuffer""); // way to get nice name
   else if (jsvIsString(var)) {
     size_t blocks = 1;
     if (jsvGetLastChild(var)) {
      JsVar *v = jsvLock(jsvGetLastChild(var));
      blocks += jsvCountJsVarsUsed(v);
      jsvUnLock(v);
    }
    if (jsvIsFlatString(var)) {
      blocks += jsvGetFlatStringBlocks(var);
    }
    jsiConsolePrintf(""%sString [%d blocks] %q"", jsvIsFlatString(var)?""Flat"":(jsvIsNativeString(var)?""Native"":""""), blocks, var);
  } else {
    jsiConsolePrintf(""Unknown %d"", var->flags & (JsVarFlags)~(JSV_LOCK_MASK));
  }

  if (jsvIsNameInt(var)) {
    jsiConsolePrintf(""= int %d\n"", (int)jsvGetFirstChildSigned(var));
    return;
  } else if (jsvIsNameIntBool(var)) {
    jsiConsolePrintf(""= bool %s\n"", jsvGetFirstChild(var)?""true"":""false"");
    return;
  }

  if (jsvHasSingleChild(var)) {
    JsVar *child = jsvGetFirstChild(var) ? jsvLock(jsvGetFirstChild(var)) : 0;
    _jsvTrace(child, indent+2, baseVar, level+1);
    jsvUnLock(child);
  } else if (jsvHasChildren(var)) {
    JsvIterator it;
    jsvIteratorNew(&it, var, JSIF_DEFINED_ARRAY_ElEMENTS);
    bool first = true;
    while (jsvIteratorHasElement(&it) && !jspIsInterrupted()) {
      if (first) jsiConsolePrintf(""\n"");
      first = false;
      JsVar *child = jsvIteratorGetKey(&it);
      _jsvTrace(child, indent+2, baseVar, level+1);
      jsvUnLock(child);
      jsiConsolePrintf(""\n"");
      jsvIteratorNext(&it);
    }
    jsvIteratorFree(&it);
    if (!first)
      for (i=0;i<indent;i++) jsiConsolePrint("" "");
  }
  jsiConsolePrintf(""%c"", endBracket);
#endif
}
","void _jsvTrace(JsVar *var, int indent, JsVar *baseVar, int level) {
#ifdef SAVE_ON_FLASH
  jsiConsolePrint(""Trace unimplemented in this version.\n"");
#else
  int i;
  for (i=0;i<indent;i++) jsiConsolePrint("" "");

  if (!var) {
    jsiConsolePrint(""undefined"");
    return;
  }

  jsvTraceLockInfo(var);

  int lowestLevel = _jsvTraceGetLowestLevel(baseVar, var);
  if (lowestLevel < level) {
    jsiConsolePrint(""...\n"");
    return;
  }

  if (jsvIsName(var)) jsiConsolePrint(""Name "");

  char endBracket = ' ';
  if (jsvIsObject(var)) { jsiConsolePrint(""Object { ""); endBracket = '}'; }
  else if (jsvIsArray(var)) { jsiConsolePrintf(""Array(%d) [ "", var->varData.integer); endBracket = ']'; }
  else if (jsvIsNativeFunction(var)) { jsiConsolePrintf(""NativeFunction 0x%x (%d) { "", var->varData.native.ptr, var->varData.native.argTypes); endBracket = '}'; }
  else if (jsvIsFunction(var)) {
    jsiConsolePrint(""Function { "");
    if (jsvIsFunctionReturn(var)) jsiConsolePrint(""return "");
    endBracket = '}';
  } else if (jsvIsPin(var)) jsiConsolePrintf(""Pin %d"", jsvGetInteger(var));
  else if (jsvIsInt(var)) jsiConsolePrintf(""Integer %d"", jsvGetInteger(var));
  else if (jsvIsBoolean(var)) jsiConsolePrintf(""Bool %s"", jsvGetBool(var)?""true"":""false"");
   else if (jsvIsFloat(var)) jsiConsolePrintf(""Double %f"", jsvGetFloat(var));
   else if (jsvIsFunctionParameter(var)) jsiConsolePrintf(""Param %q "", var);
   else if (jsvIsArrayBufferName(var)) jsiConsolePrintf(""ArrayBufferName[%d] "", jsvGetInteger(var));
  else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(""%s "", jswGetBasicObjectName(var)); // way to get nice name
   else if (jsvIsString(var)) {
     size_t blocks = 1;
     if (jsvGetLastChild(var)) {
      JsVar *v = jsvLock(jsvGetLastChild(var));
      blocks += jsvCountJsVarsUsed(v);
      jsvUnLock(v);
    }
    if (jsvIsFlatString(var)) {
      blocks += jsvGetFlatStringBlocks(var);
    }
    jsiConsolePrintf(""%sString [%d blocks] %q"", jsvIsFlatString(var)?""Flat"":(jsvIsNativeString(var)?""Native"":""""), blocks, var);
  } else {
    jsiConsolePrintf(""Unknown %d"", var->flags & (JsVarFlags)~(JSV_LOCK_MASK));
  }

  if (jsvIsNameInt(var)) {
    jsiConsolePrintf(""= int %d\n"", (int)jsvGetFirstChildSigned(var));
    return;
  } else if (jsvIsNameIntBool(var)) {
    jsiConsolePrintf(""= bool %s\n"", jsvGetFirstChild(var)?""true"":""false"");
    return;
  }

  if (jsvHasSingleChild(var)) {
    JsVar *child = jsvGetFirstChild(var) ? jsvLock(jsvGetFirstChild(var)) : 0;
    _jsvTrace(child, indent+2, baseVar, level+1);
    jsvUnLock(child);
  } else if (jsvHasChildren(var)) {
    JsvIterator it;
    jsvIteratorNew(&it, var, JSIF_DEFINED_ARRAY_ElEMENTS);
    bool first = true;
    while (jsvIteratorHasElement(&it) && !jspIsInterrupted()) {
      if (first) jsiConsolePrintf(""\n"");
      first = false;
      JsVar *child = jsvIteratorGetKey(&it);
      _jsvTrace(child, indent+2, baseVar, level+1);
      jsvUnLock(child);
      jsiConsolePrintf(""\n"");
      jsvIteratorNext(&it);
    }
    jsvIteratorFree(&it);
    if (!first)
      for (i=0;i<indent;i++) jsiConsolePrint("" "");
  }
  jsiConsolePrintf(""%c"", endBracket);
#endif
}
",C,"  else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(""%s "", jswGetBasicObjectName(var)?jswGetBasicObjectName(var):""unknown ArrayBuffer""); // way to get nice name
","  else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(""%s "", jswGetBasicObjectName(var)); // way to get nice name
",,"@@ -3314,7 +3314,7 @@ void _jsvTrace(JsVar *var, int indent, JsVar *baseVar, int level) {
   else if (jsvIsFloat(var)) jsiConsolePrintf(""Double %f"", jsvGetFloat(var));
   else if (jsvIsFunctionParameter(var)) jsiConsolePrintf(""Param %q "", var);
   else if (jsvIsArrayBufferName(var)) jsiConsolePrintf(""ArrayBufferName[%d] "", jsvGetInteger(var));
-  else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(""%s "", jswGetBasicObjectName(var)); // way to get nice name
+  else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(""%s "", jswGetBasicObjectName(var)?jswGetBasicObjectName(var):""unknown ArrayBuffer""); // way to get nice name
   else if (jsvIsString(var)) {
     size_t blocks = 1;
     if (jsvGetLastChild(var)) {",Espruino,b6d362f6a1f2de0b3e7604848116efb509196bf4,8a44b04b584b3d3ab1cb68fed410f7ecb165e50e,1,"void _jsvTrace(JsVar *var, int indent, JsVar *baseVar, int level) {
#ifdef SAVE_ON_FLASH
  jsiConsolePrint(""Trace unimplemented in this version.\n"");
#else
  int i;
  for (i=0;i<indent;i++) jsiConsolePrint("" "");

  if (!var) {
    jsiConsolePrint(""undefined"");
    return;
  }

  jsvTraceLockInfo(var);

  int lowestLevel = _jsvTraceGetLowestLevel(baseVar, var);
  if (lowestLevel < level) {
    // If this data is available elsewhere in the tree (but nearer the root)
    // then don't print it. This makes the dump significantly more readable!
    // It also stops us getting in recursive loops ...
    jsiConsolePrint(""...\n"");
    return;
  }

  if (jsvIsName(var)) jsiConsolePrint(""Name "");

  char endBracket = ' ';
  if (jsvIsObject(var)) { jsiConsolePrint(""Object { ""); endBracket = '}'; }
  else if (jsvIsArray(var)) { jsiConsolePrintf(""Array(%d) [ "", var->varData.integer); endBracket = ']'; }
  else if (jsvIsNativeFunction(var)) { jsiConsolePrintf(""NativeFunction 0x%x (%d) { "", var->varData.native.ptr, var->varData.native.argTypes); endBracket = '}'; }
  else if (jsvIsFunction(var)) {
    jsiConsolePrint(""Function { "");
    if (jsvIsFunctionReturn(var)) jsiConsolePrint(""return "");
    endBracket = '}';
  } else if (jsvIsPin(var)) jsiConsolePrintf(""Pin %d"", jsvGetInteger(var));
  else if (jsvIsInt(var)) jsiConsolePrintf(""Integer %d"", jsvGetInteger(var));
  else if (jsvIsBoolean(var)) jsiConsolePrintf(""Bool %s"", jsvGetBool(var)?""true"":""false"");
   else if (jsvIsFloat(var)) jsiConsolePrintf(""Double %f"", jsvGetFloat(var));
   else if (jsvIsFunctionParameter(var)) jsiConsolePrintf(""Param %q "", var);
   else if (jsvIsArrayBufferName(var)) jsiConsolePrintf(""ArrayBufferName[%d] "", jsvGetInteger(var));
//flaw_line_below:
  else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(""%s "", jswGetBasicObjectName(var)); // way to get nice name
//fix_flaw_line_below:
//  else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(""%s "", jswGetBasicObjectName(var)?jswGetBasicObjectName(var):""unknown ArrayBuffer""); // way to get nice name
   else if (jsvIsString(var)) {
     size_t blocks = 1;
     if (jsvGetLastChild(var)) {
      JsVar *v = jsvLock(jsvGetLastChild(var));
      blocks += jsvCountJsVarsUsed(v);
      jsvUnLock(v);
    }
    if (jsvIsFlatString(var)) {
      blocks += jsvGetFlatStringBlocks(var);
    }
    jsiConsolePrintf(""%sString [%d blocks] %q"", jsvIsFlatString(var)?""Flat"":(jsvIsNativeString(var)?""Native"":""""), blocks, var);
  } else {
    jsiConsolePrintf(""Unknown %d"", var->flags & (JsVarFlags)~(JSV_LOCK_MASK));
  }

  // print a value if it was stored in here as well...
  if (jsvIsNameInt(var)) {
    jsiConsolePrintf(""= int %d\n"", (int)jsvGetFirstChildSigned(var));
    return;
  } else if (jsvIsNameIntBool(var)) {
    jsiConsolePrintf(""= bool %s\n"", jsvGetFirstChild(var)?""true"":""false"");
    return;
  }

  if (jsvHasSingleChild(var)) {
    JsVar *child = jsvGetFirstChild(var) ? jsvLock(jsvGetFirstChild(var)) : 0;
    _jsvTrace(child, indent+2, baseVar, level+1);
    jsvUnLock(child);
  } else if (jsvHasChildren(var)) {
    JsvIterator it;
    jsvIteratorNew(&it, var, JSIF_DEFINED_ARRAY_ElEMENTS);
    bool first = true;
    while (jsvIteratorHasElement(&it) && !jspIsInterrupted()) {
      if (first) jsiConsolePrintf(""\n"");
      first = false;
      JsVar *child = jsvIteratorGetKey(&it);
      _jsvTrace(child, indent+2, baseVar, level+1);
      jsvUnLock(child);
      jsiConsolePrintf(""\n"");
      jsvIteratorNext(&it);
    }
    jsvIteratorFree(&it);
    if (!first)
      for (i=0;i<indent;i++) jsiConsolePrint("" "");
  }
  jsiConsolePrintf(""%c"", endBracket);
#endif
}
"
4695,182431,,Local,Not required,Complete,CVE-2018-10074,https://www.cvedetails.com/cve/CVE-2018-10074/,CWE-476,Low,,,,2018-04-12,4.9,The hi3660_stub_clk_probe function in drivers/clk/hisilicon/clk-hi3660-stub.c in the Linux kernel before 4.16 allows local users to cause a denial of service (NULL pointer dereference) by triggering a failure of resource retrieval.,2018-05-22,DoS ,2,https://github.com/torvalds/linux/commit/9903e41ae1f5d50c93f268ca3304d4d7c64b9311,9903e41ae1f5d50c93f268ca3304d4d7c64b9311,"clk: hisilicon: hi3660：Fix potential NULL dereference in hi3660_stub_clk_probe()

platform_get_resource() may return NULL, add proper check to
avoid potential NULL dereferencing.

This is detected by Coccinelle semantic patch.

@@
expression pdev, res, n, t, e, e1, e2;
@@

res = platform_get_resource(pdev, t, n);
+ if (!res)
+   return -EINVAL;
... when != res == NULL
e = devm_ioremap(e1, res->start, e2);

Fixes: 4f16f7ff3bc0 (""clk: hisilicon: Add support for Hi3660 stub clocks"")
Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
Signed-off-by: Stephen Boyd <sboyd@kernel.org>",0,drivers/clk/hisilicon/clk-hi3660-stub.c,"{""sha"": ""e8b2c43b1bb86f17612b63534172a7332f44f6eb"", ""filename"": ""drivers/clk/hisilicon/clk-hi3660-stub.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9903e41ae1f5d50c93f268ca3304d4d7c64b9311/drivers/clk/hisilicon/clk-hi3660-stub.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9903e41ae1f5d50c93f268ca3304d4d7c64b9311/drivers/clk/hisilicon/clk-hi3660-stub.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/clk/hisilicon/clk-hi3660-stub.c?ref=9903e41ae1f5d50c93f268ca3304d4d7c64b9311"", ""patch"": ""@@ -149,6 +149,8 @@ static int hi3660_stub_clk_probe(struct platform_device *pdev)\n \t\treturn PTR_ERR(stub_clk_chan.mbox);\n \n \tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n+\tif (!res)\n+\t\treturn -EINVAL;\n \tfreq_reg = devm_ioremap(dev, res->start, resource_size(res));\n \tif (!freq_reg)\n \t\treturn -ENOMEM;""}","static int hi3660_stub_clk_probe(struct platform_device *pdev)
{
	struct device *dev = &pdev->dev;
	struct resource *res;
	unsigned int i;
	int ret;

	/* Use mailbox client without blocking */
	stub_clk_chan.cl.dev = dev;
	stub_clk_chan.cl.tx_done = NULL;
	stub_clk_chan.cl.tx_block = false;
	stub_clk_chan.cl.knows_txdone = false;

	/* Allocate mailbox channel */
	stub_clk_chan.mbox = mbox_request_channel(&stub_clk_chan.cl, 0);
	if (IS_ERR(stub_clk_chan.mbox))
 		return PTR_ERR(stub_clk_chan.mbox);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	if (!res)
		return -EINVAL;
 	freq_reg = devm_ioremap(dev, res->start, resource_size(res));
 	if (!freq_reg)
 		return -ENOMEM;

	freq_reg += HI3660_STUB_CLOCK_DATA;

	for (i = 0; i < HI3660_CLK_STUB_NUM; i++) {
		ret = devm_clk_hw_register(&pdev->dev, &hi3660_stub_clks[i].hw);
		if (ret)
			return ret;
	}

	return devm_of_clk_add_hw_provider(&pdev->dev, hi3660_stub_clk_hw_get,
					   hi3660_stub_clks);
}
","static int hi3660_stub_clk_probe(struct platform_device *pdev)
{
	struct device *dev = &pdev->dev;
	struct resource *res;
	unsigned int i;
	int ret;

	/* Use mailbox client without blocking */
	stub_clk_chan.cl.dev = dev;
	stub_clk_chan.cl.tx_done = NULL;
	stub_clk_chan.cl.tx_block = false;
	stub_clk_chan.cl.knows_txdone = false;

	/* Allocate mailbox channel */
	stub_clk_chan.mbox = mbox_request_channel(&stub_clk_chan.cl, 0);
	if (IS_ERR(stub_clk_chan.mbox))
 		return PTR_ERR(stub_clk_chan.mbox);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	freq_reg = devm_ioremap(dev, res->start, resource_size(res));
 	if (!freq_reg)
 		return -ENOMEM;

	freq_reg += HI3660_STUB_CLOCK_DATA;

	for (i = 0; i < HI3660_CLK_STUB_NUM; i++) {
		ret = devm_clk_hw_register(&pdev->dev, &hi3660_stub_clks[i].hw);
		if (ret)
			return ret;
	}

	return devm_of_clk_add_hw_provider(&pdev->dev, hi3660_stub_clk_hw_get,
					   hi3660_stub_clks);
}
",C,"	if (!res)
		return -EINVAL;
",,,"@@ -149,6 +149,8 @@ static int hi3660_stub_clk_probe(struct platform_device *pdev)
 		return PTR_ERR(stub_clk_chan.mbox);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -EINVAL;
 	freq_reg = devm_ioremap(dev, res->start, resource_size(res));
 	if (!freq_reg)
 		return -ENOMEM;",linux,9903e41ae1f5d50c93f268ca3304d4d7c64b9311,56e1ee3539437a26ebec358167d1f8cd07253c3d,1,"static int hi3660_stub_clk_probe(struct platform_device *pdev)
{
	struct device *dev = &pdev->dev;
	struct resource *res;
	unsigned int i;
	int ret;

	/* Use mailbox client without blocking */
	stub_clk_chan.cl.dev = dev;
	stub_clk_chan.cl.tx_done = NULL;
	stub_clk_chan.cl.tx_block = false;
	stub_clk_chan.cl.knows_txdone = false;

	/* Allocate mailbox channel */
	stub_clk_chan.mbox = mbox_request_channel(&stub_clk_chan.cl, 0);
	if (IS_ERR(stub_clk_chan.mbox))
 		return PTR_ERR(stub_clk_chan.mbox);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
//fix_flaw_line_below:
//	if (!res)
//fix_flaw_line_below:
//		return -EINVAL;
 	freq_reg = devm_ioremap(dev, res->start, resource_size(res));
 	if (!freq_reg)
 		return -ENOMEM;

	freq_reg += HI3660_STUB_CLOCK_DATA;

	for (i = 0; i < HI3660_CLK_STUB_NUM; i++) {
		ret = devm_clk_hw_register(&pdev->dev, &hi3660_stub_clks[i].hw);
		if (ret)
			return ret;
	}

	return devm_of_clk_add_hw_provider(&pdev->dev, hi3660_stub_clk_hw_get,
					   hi3660_stub_clks);
}
"
4739,182475,,Local,Not required,Partial,CVE-2018-8043,https://www.cvedetails.com/cve/CVE-2018-8043/,CWE-476,Low,,,,2018-03-10,2.1,"The unimac_mdio_probe function in drivers/net/phy/mdio-bcm-unimac.c in the Linux kernel through 4.15.8 does not validate certain resource availability, which allows local users to cause a denial of service (NULL pointer dereference).",2018-05-09,DoS ,2,https://github.com/torvalds/linux/commit/297a6961ffb8ff4dc66c9fbf53b924bd1dda05d5,297a6961ffb8ff4dc66c9fbf53b924bd1dda05d5,"net: phy: mdio-bcm-unimac: fix potential NULL dereference in unimac_mdio_probe()

platform_get_resource() may fail and return NULL, so we should
better check it's return value to avoid a NULL pointer dereference
a bit later in the code.

This is detected by Coccinelle semantic patch.

@@
expression pdev, res, n, t, e, e1, e2;
@@

res = platform_get_resource(pdev, t, n);
+ if (!res)
+   return -EINVAL;
... when != res == NULL
e = devm_ioremap(e1, res->start, e2);

Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,drivers/net/phy/mdio-bcm-unimac.c,"{""sha"": ""8d370667fa1b3e5ada10b299ee35e35294bca798"", ""filename"": ""drivers/net/phy/mdio-bcm-unimac.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/297a6961ffb8ff4dc66c9fbf53b924bd1dda05d5/drivers/net/phy/mdio-bcm-unimac.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/297a6961ffb8ff4dc66c9fbf53b924bd1dda05d5/drivers/net/phy/mdio-bcm-unimac.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/phy/mdio-bcm-unimac.c?ref=297a6961ffb8ff4dc66c9fbf53b924bd1dda05d5"", ""patch"": ""@@ -205,6 +205,8 @@ static int unimac_mdio_probe(struct platform_device *pdev)\n \t\treturn -ENOMEM;\n \n \tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n+\tif (!r)\n+\t\treturn -EINVAL;\n \n \t/* Just ioremap, as this MDIO block is usually integrated into an\n \t * Ethernet MAC controller register range""}","static int unimac_mdio_probe(struct platform_device *pdev)
{
	struct unimac_mdio_pdata *pdata = pdev->dev.platform_data;
	struct unimac_mdio_priv *priv;
	struct device_node *np;
	struct mii_bus *bus;
	struct resource *r;
	int ret;

	np = pdev->dev.of_node;

	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
	if (!priv)
 		return -ENOMEM;
 
 	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	if (!r)
		return -EINVAL;
 
 	/* Just ioremap, as this MDIO block is usually integrated into an
 	 * Ethernet MAC controller register range
	 */
	priv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));
	if (!priv->base) {
		dev_err(&pdev->dev, ""failed to remap register\n"");
		return -ENOMEM;
	}

	priv->mii_bus = mdiobus_alloc();
	if (!priv->mii_bus)
		return -ENOMEM;

	bus = priv->mii_bus;
	bus->priv = priv;
	if (pdata) {
		bus->name = pdata->bus_name;
		priv->wait_func = pdata->wait_func;
		priv->wait_func_data = pdata->wait_func_data;
		bus->phy_mask = ~pdata->phy_mask;
	} else {
		bus->name = ""unimac MII bus"";
		priv->wait_func_data = priv;
		priv->wait_func = unimac_mdio_poll;
	}
	bus->parent = &pdev->dev;
	bus->read = unimac_mdio_read;
	bus->write = unimac_mdio_write;
	bus->reset = unimac_mdio_reset;
	snprintf(bus->id, MII_BUS_ID_SIZE, ""%s-%d"", pdev->name, pdev->id);

	ret = of_mdiobus_register(bus, np);
	if (ret) {
		dev_err(&pdev->dev, ""MDIO bus registration failed\n"");
		goto out_mdio_free;
	}

	platform_set_drvdata(pdev, priv);

	dev_info(&pdev->dev, ""Broadcom UniMAC MDIO bus at 0x%p\n"", priv->base);

	return 0;

out_mdio_free:
	mdiobus_free(bus);
	return ret;
}
","static int unimac_mdio_probe(struct platform_device *pdev)
{
	struct unimac_mdio_pdata *pdata = pdev->dev.platform_data;
	struct unimac_mdio_priv *priv;
	struct device_node *np;
	struct mii_bus *bus;
	struct resource *r;
	int ret;

	np = pdev->dev.of_node;

	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
	if (!priv)
 		return -ENOMEM;
 
 	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 
 	/* Just ioremap, as this MDIO block is usually integrated into an
 	 * Ethernet MAC controller register range
	 */
	priv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));
	if (!priv->base) {
		dev_err(&pdev->dev, ""failed to remap register\n"");
		return -ENOMEM;
	}

	priv->mii_bus = mdiobus_alloc();
	if (!priv->mii_bus)
		return -ENOMEM;

	bus = priv->mii_bus;
	bus->priv = priv;
	if (pdata) {
		bus->name = pdata->bus_name;
		priv->wait_func = pdata->wait_func;
		priv->wait_func_data = pdata->wait_func_data;
		bus->phy_mask = ~pdata->phy_mask;
	} else {
		bus->name = ""unimac MII bus"";
		priv->wait_func_data = priv;
		priv->wait_func = unimac_mdio_poll;
	}
	bus->parent = &pdev->dev;
	bus->read = unimac_mdio_read;
	bus->write = unimac_mdio_write;
	bus->reset = unimac_mdio_reset;
	snprintf(bus->id, MII_BUS_ID_SIZE, ""%s-%d"", pdev->name, pdev->id);

	ret = of_mdiobus_register(bus, np);
	if (ret) {
		dev_err(&pdev->dev, ""MDIO bus registration failed\n"");
		goto out_mdio_free;
	}

	platform_set_drvdata(pdev, priv);

	dev_info(&pdev->dev, ""Broadcom UniMAC MDIO bus at 0x%p\n"", priv->base);

	return 0;

out_mdio_free:
	mdiobus_free(bus);
	return ret;
}
",C,"	if (!r)
		return -EINVAL;
",,,"@@ -205,6 +205,8 @@ static int unimac_mdio_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!r)
+		return -EINVAL;
 
 	/* Just ioremap, as this MDIO block is usually integrated into an
 	 * Ethernet MAC controller register range",linux,297a6961ffb8ff4dc66c9fbf53b924bd1dda05d5,ecb10288a370b439e3b4552adea40d22900b9f64,1,"static int unimac_mdio_probe(struct platform_device *pdev)
{
	struct unimac_mdio_pdata *pdata = pdev->dev.platform_data;
	struct unimac_mdio_priv *priv;
	struct device_node *np;
	struct mii_bus *bus;
	struct resource *r;
	int ret;

	np = pdev->dev.of_node;

	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
	if (!priv)
 		return -ENOMEM;
 
 	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
//fix_flaw_line_below:
//	if (!r)
//fix_flaw_line_below:
//		return -EINVAL;
 
 	/* Just ioremap, as this MDIO block is usually integrated into an
 	 * Ethernet MAC controller register range
	 */
	priv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));
	if (!priv->base) {
		dev_err(&pdev->dev, ""failed to remap register\n"");
		return -ENOMEM;
	}

	priv->mii_bus = mdiobus_alloc();
	if (!priv->mii_bus)
		return -ENOMEM;

	bus = priv->mii_bus;
	bus->priv = priv;
	if (pdata) {
		bus->name = pdata->bus_name;
		priv->wait_func = pdata->wait_func;
		priv->wait_func_data = pdata->wait_func_data;
		bus->phy_mask = ~pdata->phy_mask;
	} else {
		bus->name = ""unimac MII bus"";
		priv->wait_func_data = priv;
		priv->wait_func = unimac_mdio_poll;
	}
	bus->parent = &pdev->dev;
	bus->read = unimac_mdio_read;
	bus->write = unimac_mdio_write;
	bus->reset = unimac_mdio_reset;
	snprintf(bus->id, MII_BUS_ID_SIZE, ""%s-%d"", pdev->name, pdev->id);

	ret = of_mdiobus_register(bus, np);
	if (ret) {
		dev_err(&pdev->dev, ""MDIO bus registration failed\n"");
		goto out_mdio_free;
	}

	platform_set_drvdata(pdev, priv);

	dev_info(&pdev->dev, ""Broadcom UniMAC MDIO bus at 0x%p\n"", priv->base);

	return 0;

out_mdio_free:
	mdiobus_free(bus);
	return ret;
}
"
4745,182481,,Local,Not required,Complete,CVE-2018-7492,https://www.cvedetails.com/cve/CVE-2018-7492/,CWE-476,Low,,,,2018-02-26,4.9,"A NULL pointer dereference was found in the net/rds/rdma.c __rds_rdma_map() function in the Linux kernel before 4.14.7 allowing local attackers to cause a system panic and a denial-of-service, related to RDS_GET_MR and RDS_GET_MR_FOR_DEST.",2018-06-15,,1,https://github.com/torvalds/linux/commit/f3069c6d33f6ae63a1668737bc78aaaa51bff7ca,f3069c6d33f6ae63a1668737bc78aaaa51bff7ca,"rds: Fix NULL pointer dereference in __rds_rdma_map

This is a fix for syzkaller719569, where memory registration was
attempted without any underlying transport being loaded.

Analysis of the case reveals that it is the setsockopt() RDS_GET_MR
(2) and RDS_GET_MR_FOR_DEST (7) that are vulnerable.

Here is an example stack trace when the bug is hit:

BUG: unable to handle kernel NULL pointer dereference at 00000000000000c0
IP: __rds_rdma_map+0x36/0x440 [rds]
PGD 2f93d03067 P4D 2f93d03067 PUD 2f93d02067 PMD 0
Oops: 0000 [#1] SMP
Modules linked in: bridge stp llc tun rpcsec_gss_krb5 nfsv4
dns_resolver nfs fscache rds binfmt_misc sb_edac intel_powerclamp
coretemp kvm_intel kvm irqbypass crct10dif_pclmul c rc32_pclmul
ghash_clmulni_intel pcbc aesni_intel crypto_simd glue_helper cryptd
iTCO_wdt mei_me sg iTCO_vendor_support ipmi_si mei ipmi_devintf nfsd
shpchp pcspkr i2c_i801 ioatd ma ipmi_msghandler wmi lpc_ich mfd_core
auth_rpcgss nfs_acl lockd grace sunrpc ip_tables ext4 mbcache jbd2
mgag200 i2c_algo_bit drm_kms_helper ixgbe syscopyarea ahci sysfillrect
sysimgblt libahci mdio fb_sys_fops ttm ptp libata sd_mod mlx4_core drm
crc32c_intel pps_core megaraid_sas i2c_core dca dm_mirror
dm_region_hash dm_log dm_mod
CPU: 48 PID: 45787 Comm: repro_set2 Not tainted 4.14.2-3.el7uek.x86_64 #2
Hardware name: Oracle Corporation ORACLE SERVER X5-2L/ASM,MOBO TRAY,2U, BIOS 31110000 03/03/2017
task: ffff882f9190db00 task.stack: ffffc9002b994000
RIP: 0010:__rds_rdma_map+0x36/0x440 [rds]
RSP: 0018:ffffc9002b997df0 EFLAGS: 00010202
RAX: 0000000000000000 RBX: ffff882fa2182580 RCX: 0000000000000000
RDX: 0000000000000000 RSI: ffffc9002b997e40 RDI: ffff882fa2182580
RBP: ffffc9002b997e30 R08: 0000000000000000 R09: 0000000000000002
R10: ffff885fb29e3838 R11: 0000000000000000 R12: ffff882fa2182580
R13: ffff882fa2182580 R14: 0000000000000002 R15: 0000000020000ffc
FS:  00007fbffa20b700(0000) GS:ffff882fbfb80000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00000000000000c0 CR3: 0000002f98a66006 CR4: 00000000001606e0
Call Trace:
 rds_get_mr+0x56/0x80 [rds]
 rds_setsockopt+0x172/0x340 [rds]
 ? __fget_light+0x25/0x60
 ? __fdget+0x13/0x20
 SyS_setsockopt+0x80/0xe0
 do_syscall_64+0x67/0x1b0
 entry_SYSCALL64_slow_path+0x25/0x25
RIP: 0033:0x7fbff9b117f9
RSP: 002b:00007fbffa20aed8 EFLAGS: 00000293 ORIG_RAX: 0000000000000036
RAX: ffffffffffffffda RBX: 00000000000c84a4 RCX: 00007fbff9b117f9
RDX: 0000000000000002 RSI: 0000400000000114 RDI: 000000000000109b
RBP: 00007fbffa20af10 R08: 0000000000000020 R09: 00007fbff9dd7860
R10: 0000000020000ffc R11: 0000000000000293 R12: 0000000000000000
R13: 00007fbffa20b9c0 R14: 00007fbffa20b700 R15: 0000000000000021

Code: 41 56 41 55 49 89 fd 41 54 53 48 83 ec 18 8b 87 f0 02 00 00 48
89 55 d0 48 89 4d c8 85 c0 0f 84 2d 03 00 00 48 8b 87 00 03 00 00 <48>
83 b8 c0 00 00 00 00 0f 84 25 03 00 0 0 48 8b 06 48 8b 56 08

The fix is to check the existence of an underlying transport in
__rds_rdma_map().

Signed-off-by: Håkon Bugge <haakon.bugge@oracle.com>
Reported-by: syzbot <syzkaller@googlegroups.com>
Acked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/rds/rdma.c,"{""sha"": ""bc2f1e0977d657ec09f176cfcecf28839eb1fab0"", ""filename"": ""net/rds/rdma.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/f3069c6d33f6ae63a1668737bc78aaaa51bff7ca/net/rds/rdma.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f3069c6d33f6ae63a1668737bc78aaaa51bff7ca/net/rds/rdma.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/rds/rdma.c?ref=f3069c6d33f6ae63a1668737bc78aaaa51bff7ca"", ""patch"": ""@@ -183,7 +183,7 @@ static int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,\n \tlong i;\n \tint ret;\n \n-\tif (rs->rs_bound_addr == 0) {\n+\tif (rs->rs_bound_addr == 0 || !rs->rs_transport) {\n \t\tret = -ENOTCONN; /* XXX not a great errno */\n \t\tgoto out;\n \t}""}","static int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,
				u64 *cookie_ret, struct rds_mr **mr_ret)
{
	struct rds_mr *mr = NULL, *found;
	unsigned int nr_pages;
	struct page **pages = NULL;
	struct scatterlist *sg;
	void *trans_private;
	unsigned long flags;
	rds_rdma_cookie_t cookie;
	unsigned int nents;
 	long i;
 	int ret;
 
	if (rs->rs_bound_addr == 0 || !rs->rs_transport) {
 		ret = -ENOTCONN; /* XXX not a great errno */
 		goto out;
 	}

	if (!rs->rs_transport->get_mr) {
		ret = -EOPNOTSUPP;
		goto out;
	}

	nr_pages = rds_pages_in_vec(&args->vec);
	if (nr_pages == 0) {
		ret = -EINVAL;
		goto out;
	}

	/* Restrict the size of mr irrespective of underlying transport
	 * To account for unaligned mr regions, subtract one from nr_pages
	 */
	if ((nr_pages - 1) > (RDS_MAX_MSG_SIZE >> PAGE_SHIFT)) {
		ret = -EMSGSIZE;
		goto out;
	}

	rdsdebug(""RDS: get_mr addr %llx len %llu nr_pages %u\n"",
		args->vec.addr, args->vec.bytes, nr_pages);

	/* XXX clamp nr_pages to limit the size of this alloc? */
	pages = kcalloc(nr_pages, sizeof(struct page *), GFP_KERNEL);
	if (!pages) {
		ret = -ENOMEM;
		goto out;
	}

	mr = kzalloc(sizeof(struct rds_mr), GFP_KERNEL);
	if (!mr) {
		ret = -ENOMEM;
		goto out;
	}

	refcount_set(&mr->r_refcount, 1);
	RB_CLEAR_NODE(&mr->r_rb_node);
	mr->r_trans = rs->rs_transport;
	mr->r_sock = rs;

	if (args->flags & RDS_RDMA_USE_ONCE)
		mr->r_use_once = 1;
	if (args->flags & RDS_RDMA_INVALIDATE)
		mr->r_invalidate = 1;
	if (args->flags & RDS_RDMA_READWRITE)
		mr->r_write = 1;

	/*
	 * Pin the pages that make up the user buffer and transfer the page
	 * pointers to the mr's sg array.  We check to see if we've mapped
	 * the whole region after transferring the partial page references
	 * to the sg array so that we can have one page ref cleanup path.
	 *
	 * For now we have no flag that tells us whether the mapping is
	 * r/o or r/w. We need to assume r/w, or we'll do a lot of RDMA to
	 * the zero page.
	 */
	ret = rds_pin_pages(args->vec.addr, nr_pages, pages, 1);
	if (ret < 0)
		goto out;

	nents = ret;
	sg = kcalloc(nents, sizeof(*sg), GFP_KERNEL);
	if (!sg) {
		ret = -ENOMEM;
		goto out;
	}
	WARN_ON(!nents);
	sg_init_table(sg, nents);

	/* Stick all pages into the scatterlist */
	for (i = 0 ; i < nents; i++)
		sg_set_page(&sg[i], pages[i], PAGE_SIZE, 0);

	rdsdebug(""RDS: trans_private nents is %u\n"", nents);

	/* Obtain a transport specific MR. If this succeeds, the
	 * s/g list is now owned by the MR.
	 * Note that dma_map() implies that pending writes are
	 * flushed to RAM, so no dma_sync is needed here. */
	trans_private = rs->rs_transport->get_mr(sg, nents, rs,
						 &mr->r_key);

	if (IS_ERR(trans_private)) {
		for (i = 0 ; i < nents; i++)
			put_page(sg_page(&sg[i]));
		kfree(sg);
		ret = PTR_ERR(trans_private);
		goto out;
	}

	mr->r_trans_private = trans_private;

	rdsdebug(""RDS: get_mr put_user key is %x cookie_addr %p\n"",
	       mr->r_key, (void *)(unsigned long) args->cookie_addr);

	/* The user may pass us an unaligned address, but we can only
	 * map page aligned regions. So we keep the offset, and build
	 * a 64bit cookie containing <R_Key, offset> and pass that
	 * around. */
	cookie = rds_rdma_make_cookie(mr->r_key, args->vec.addr & ~PAGE_MASK);
	if (cookie_ret)
		*cookie_ret = cookie;

	if (args->cookie_addr && put_user(cookie, (u64 __user *)(unsigned long) args->cookie_addr)) {
		ret = -EFAULT;
		goto out;
	}

	/* Inserting the new MR into the rbtree bumps its
	 * reference count. */
	spin_lock_irqsave(&rs->rs_rdma_lock, flags);
	found = rds_mr_tree_walk(&rs->rs_rdma_keys, mr->r_key, mr);
	spin_unlock_irqrestore(&rs->rs_rdma_lock, flags);

	BUG_ON(found && found != mr);

	rdsdebug(""RDS: get_mr key is %x\n"", mr->r_key);
	if (mr_ret) {
		refcount_inc(&mr->r_refcount);
		*mr_ret = mr;
	}

	ret = 0;
out:
	kfree(pages);
	if (mr)
		rds_mr_put(mr);
	return ret;
}
","static int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,
				u64 *cookie_ret, struct rds_mr **mr_ret)
{
	struct rds_mr *mr = NULL, *found;
	unsigned int nr_pages;
	struct page **pages = NULL;
	struct scatterlist *sg;
	void *trans_private;
	unsigned long flags;
	rds_rdma_cookie_t cookie;
	unsigned int nents;
 	long i;
 	int ret;
 
	if (rs->rs_bound_addr == 0) {
 		ret = -ENOTCONN; /* XXX not a great errno */
 		goto out;
 	}

	if (!rs->rs_transport->get_mr) {
		ret = -EOPNOTSUPP;
		goto out;
	}

	nr_pages = rds_pages_in_vec(&args->vec);
	if (nr_pages == 0) {
		ret = -EINVAL;
		goto out;
	}

	/* Restrict the size of mr irrespective of underlying transport
	 * To account for unaligned mr regions, subtract one from nr_pages
	 */
	if ((nr_pages - 1) > (RDS_MAX_MSG_SIZE >> PAGE_SHIFT)) {
		ret = -EMSGSIZE;
		goto out;
	}

	rdsdebug(""RDS: get_mr addr %llx len %llu nr_pages %u\n"",
		args->vec.addr, args->vec.bytes, nr_pages);

	/* XXX clamp nr_pages to limit the size of this alloc? */
	pages = kcalloc(nr_pages, sizeof(struct page *), GFP_KERNEL);
	if (!pages) {
		ret = -ENOMEM;
		goto out;
	}

	mr = kzalloc(sizeof(struct rds_mr), GFP_KERNEL);
	if (!mr) {
		ret = -ENOMEM;
		goto out;
	}

	refcount_set(&mr->r_refcount, 1);
	RB_CLEAR_NODE(&mr->r_rb_node);
	mr->r_trans = rs->rs_transport;
	mr->r_sock = rs;

	if (args->flags & RDS_RDMA_USE_ONCE)
		mr->r_use_once = 1;
	if (args->flags & RDS_RDMA_INVALIDATE)
		mr->r_invalidate = 1;
	if (args->flags & RDS_RDMA_READWRITE)
		mr->r_write = 1;

	/*
	 * Pin the pages that make up the user buffer and transfer the page
	 * pointers to the mr's sg array.  We check to see if we've mapped
	 * the whole region after transferring the partial page references
	 * to the sg array so that we can have one page ref cleanup path.
	 *
	 * For now we have no flag that tells us whether the mapping is
	 * r/o or r/w. We need to assume r/w, or we'll do a lot of RDMA to
	 * the zero page.
	 */
	ret = rds_pin_pages(args->vec.addr, nr_pages, pages, 1);
	if (ret < 0)
		goto out;

	nents = ret;
	sg = kcalloc(nents, sizeof(*sg), GFP_KERNEL);
	if (!sg) {
		ret = -ENOMEM;
		goto out;
	}
	WARN_ON(!nents);
	sg_init_table(sg, nents);

	/* Stick all pages into the scatterlist */
	for (i = 0 ; i < nents; i++)
		sg_set_page(&sg[i], pages[i], PAGE_SIZE, 0);

	rdsdebug(""RDS: trans_private nents is %u\n"", nents);

	/* Obtain a transport specific MR. If this succeeds, the
	 * s/g list is now owned by the MR.
	 * Note that dma_map() implies that pending writes are
	 * flushed to RAM, so no dma_sync is needed here. */
	trans_private = rs->rs_transport->get_mr(sg, nents, rs,
						 &mr->r_key);

	if (IS_ERR(trans_private)) {
		for (i = 0 ; i < nents; i++)
			put_page(sg_page(&sg[i]));
		kfree(sg);
		ret = PTR_ERR(trans_private);
		goto out;
	}

	mr->r_trans_private = trans_private;

	rdsdebug(""RDS: get_mr put_user key is %x cookie_addr %p\n"",
	       mr->r_key, (void *)(unsigned long) args->cookie_addr);

	/* The user may pass us an unaligned address, but we can only
	 * map page aligned regions. So we keep the offset, and build
	 * a 64bit cookie containing <R_Key, offset> and pass that
	 * around. */
	cookie = rds_rdma_make_cookie(mr->r_key, args->vec.addr & ~PAGE_MASK);
	if (cookie_ret)
		*cookie_ret = cookie;

	if (args->cookie_addr && put_user(cookie, (u64 __user *)(unsigned long) args->cookie_addr)) {
		ret = -EFAULT;
		goto out;
	}

	/* Inserting the new MR into the rbtree bumps its
	 * reference count. */
	spin_lock_irqsave(&rs->rs_rdma_lock, flags);
	found = rds_mr_tree_walk(&rs->rs_rdma_keys, mr->r_key, mr);
	spin_unlock_irqrestore(&rs->rs_rdma_lock, flags);

	BUG_ON(found && found != mr);

	rdsdebug(""RDS: get_mr key is %x\n"", mr->r_key);
	if (mr_ret) {
		refcount_inc(&mr->r_refcount);
		*mr_ret = mr;
	}

	ret = 0;
out:
	kfree(pages);
	if (mr)
		rds_mr_put(mr);
	return ret;
}
",C,"	if (rs->rs_bound_addr == 0 || !rs->rs_transport) {
","	if (rs->rs_bound_addr == 0) {
",,"@@ -183,7 +183,7 @@ static int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,
 	long i;
 	int ret;
 
-	if (rs->rs_bound_addr == 0) {
+	if (rs->rs_bound_addr == 0 || !rs->rs_transport) {
 		ret = -ENOTCONN; /* XXX not a great errno */
 		goto out;
 	}",linux,f3069c6d33f6ae63a1668737bc78aaaa51bff7ca,32d3e51a82d453762ef148b2c4fbc8a7ec374a88,1,"static int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,
				u64 *cookie_ret, struct rds_mr **mr_ret)
{
	struct rds_mr *mr = NULL, *found;
	unsigned int nr_pages;
	struct page **pages = NULL;
	struct scatterlist *sg;
	void *trans_private;
	unsigned long flags;
	rds_rdma_cookie_t cookie;
	unsigned int nents;
 	long i;
 	int ret;
 
//flaw_line_below:
	if (rs->rs_bound_addr == 0) {
//fix_flaw_line_below:
//	if (rs->rs_bound_addr == 0 || !rs->rs_transport) {
 		ret = -ENOTCONN; /* XXX not a great errno */
 		goto out;
 	}

	if (!rs->rs_transport->get_mr) {
		ret = -EOPNOTSUPP;
		goto out;
	}

	nr_pages = rds_pages_in_vec(&args->vec);
	if (nr_pages == 0) {
		ret = -EINVAL;
		goto out;
	}

	/* Restrict the size of mr irrespective of underlying transport
	 * To account for unaligned mr regions, subtract one from nr_pages
	 */
	if ((nr_pages - 1) > (RDS_MAX_MSG_SIZE >> PAGE_SHIFT)) {
		ret = -EMSGSIZE;
		goto out;
	}

	rdsdebug(""RDS: get_mr addr %llx len %llu nr_pages %u\n"",
		args->vec.addr, args->vec.bytes, nr_pages);

	/* XXX clamp nr_pages to limit the size of this alloc? */
	pages = kcalloc(nr_pages, sizeof(struct page *), GFP_KERNEL);
	if (!pages) {
		ret = -ENOMEM;
		goto out;
	}

	mr = kzalloc(sizeof(struct rds_mr), GFP_KERNEL);
	if (!mr) {
		ret = -ENOMEM;
		goto out;
	}

	refcount_set(&mr->r_refcount, 1);
	RB_CLEAR_NODE(&mr->r_rb_node);
	mr->r_trans = rs->rs_transport;
	mr->r_sock = rs;

	if (args->flags & RDS_RDMA_USE_ONCE)
		mr->r_use_once = 1;
	if (args->flags & RDS_RDMA_INVALIDATE)
		mr->r_invalidate = 1;
	if (args->flags & RDS_RDMA_READWRITE)
		mr->r_write = 1;

	/*
	 * Pin the pages that make up the user buffer and transfer the page
	 * pointers to the mr's sg array.  We check to see if we've mapped
	 * the whole region after transferring the partial page references
	 * to the sg array so that we can have one page ref cleanup path.
	 *
	 * For now we have no flag that tells us whether the mapping is
	 * r/o or r/w. We need to assume r/w, or we'll do a lot of RDMA to
	 * the zero page.
	 */
	ret = rds_pin_pages(args->vec.addr, nr_pages, pages, 1);
	if (ret < 0)
		goto out;

	nents = ret;
	sg = kcalloc(nents, sizeof(*sg), GFP_KERNEL);
	if (!sg) {
		ret = -ENOMEM;
		goto out;
	}
	WARN_ON(!nents);
	sg_init_table(sg, nents);

	/* Stick all pages into the scatterlist */
	for (i = 0 ; i < nents; i++)
		sg_set_page(&sg[i], pages[i], PAGE_SIZE, 0);

	rdsdebug(""RDS: trans_private nents is %u\n"", nents);

	/* Obtain a transport specific MR. If this succeeds, the
	 * s/g list is now owned by the MR.
	 * Note that dma_map() implies that pending writes are
	 * flushed to RAM, so no dma_sync is needed here. */
	trans_private = rs->rs_transport->get_mr(sg, nents, rs,
						 &mr->r_key);

	if (IS_ERR(trans_private)) {
		for (i = 0 ; i < nents; i++)
			put_page(sg_page(&sg[i]));
		kfree(sg);
		ret = PTR_ERR(trans_private);
		goto out;
	}

	mr->r_trans_private = trans_private;

	rdsdebug(""RDS: get_mr put_user key is %x cookie_addr %p\n"",
	       mr->r_key, (void *)(unsigned long) args->cookie_addr);

	/* The user may pass us an unaligned address, but we can only
	 * map page aligned regions. So we keep the offset, and build
	 * a 64bit cookie containing <R_Key, offset> and pass that
	 * around. */
	cookie = rds_rdma_make_cookie(mr->r_key, args->vec.addr & ~PAGE_MASK);
	if (cookie_ret)
		*cookie_ret = cookie;

	if (args->cookie_addr && put_user(cookie, (u64 __user *)(unsigned long) args->cookie_addr)) {
		ret = -EFAULT;
		goto out;
	}

	/* Inserting the new MR into the rbtree bumps its
	 * reference count. */
	spin_lock_irqsave(&rs->rs_rdma_lock, flags);
	found = rds_mr_tree_walk(&rs->rs_rdma_keys, mr->r_key, mr);
	spin_unlock_irqrestore(&rs->rs_rdma_lock, flags);

	BUG_ON(found && found != mr);

	rdsdebug(""RDS: get_mr key is %x\n"", mr->r_key);
	if (mr_ret) {
		refcount_inc(&mr->r_refcount);
		*mr_ret = mr;
	}

	ret = 0;
out:
	kfree(pages);
	if (mr)
		rds_mr_put(mr);
	return ret;
}
"
4783,182519,,Remote,Not required,Partial,CVE-2018-6197,https://www.cvedetails.com/cve/CVE-2018-6197/,CWE-476,Low,,,,2018-01-24,5.0,w3m through 0.5.3 is prone to a NULL pointer dereference flaw in formUpdateBuffer in form.c.,2019-04-04,,2,https://github.com/tats/w3m/commit/7fdc83b0364005a0b5ed869230dd81752ba022e8,7fdc83b0364005a0b5ed869230dd81752ba022e8,"Prevent invalid columnPos() call in formUpdateBuffer()

Bug-Debian: https://github.com/tats/w3m/issues/89",0,form.c,"{""sha"": ""bc14d39fed0625e0d083454a47a59cc3c30e8921"", ""filename"": ""form.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/tats/w3m/blob/7fdc83b0364005a0b5ed869230dd81752ba022e8/form.c"", ""raw_url"": ""https://github.com/tats/w3m/raw/7fdc83b0364005a0b5ed869230dd81752ba022e8/form.c"", ""contents_url"": ""https://api.github.com/repos/tats/w3m/contents/form.c?ref=7fdc83b0364005a0b5ed869230dd81752ba022e8"", ""patch"": ""@@ -482,6 +482,8 @@ formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n \trows = form->rows ? form->rows : 1;\n \tcol = COLPOS(l, a->start.pos);\n \tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n+\t    if (l == NULL)\n+\t\tbreak;\n \t    if (rows > 1) {\n \t\tpos = columnPos(l, col);\n \t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);""}","formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)
{
    Buffer save;
    char *p;
    int spos, epos, rows, c_rows, pos, col = 0;
    Line *l;

    copyBuffer(&save, buf);
    gotoLine(buf, a->start.line);
    switch (form->type) {
    case FORM_TEXTAREA:
    case FORM_INPUT_TEXT:
    case FORM_INPUT_FILE:
    case FORM_INPUT_PASSWORD:
    case FORM_INPUT_CHECKBOX:
    case FORM_INPUT_RADIO:
#ifdef MENU_SELECT
    case FORM_SELECT:
#endif				/* MENU_SELECT */
	spos = a->start.pos;
	epos = a->end.pos;
	break;
    default:
	spos = a->start.pos + 1;
	epos = a->end.pos - 1;
    }
    switch (form->type) {
    case FORM_INPUT_CHECKBOX:
    case FORM_INPUT_RADIO:
	if (buf->currentLine == NULL ||
	    spos >= buf->currentLine->len || spos < 0)
	    break;
	if (form->checked)
	    buf->currentLine->lineBuf[spos] = '*';
	else
	    buf->currentLine->lineBuf[spos] = ' ';
	break;
    case FORM_INPUT_TEXT:
    case FORM_INPUT_FILE:
    case FORM_INPUT_PASSWORD:
    case FORM_TEXTAREA:
#ifdef MENU_SELECT
    case FORM_SELECT:
	if (form->type == FORM_SELECT) {
	    p = form->label->ptr;
	    updateSelectOption(form, form->select_option);
	}
	else
#endif				/* MENU_SELECT */
	{
	    if (!form->value)
		break;
	    p = form->value->ptr;
	}
	l = buf->currentLine;
	if (!l)
	    break;
	if (form->type == FORM_TEXTAREA) {
	    int n = a->y - buf->currentLine->linenumber;
	    if (n > 0)
		for (; l && n; l = l->prev, n--) ;
	    else if (n < 0)
		for (; l && n; l = l->prev, n++) ;
	    if (!l)
		break;
	}
 	rows = form->rows ? form->rows : 1;
 	col = COLPOS(l, a->start.pos);
 	for (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {
	    if (l == NULL)
		break;
 	    if (rows > 1) {
 		pos = columnPos(l, col);
 		a = retrieveAnchor(buf->formitem, l->linenumber, pos);
		if (a == NULL)
		    break;
		spos = a->start.pos;
		epos = a->end.pos;
	    }
	    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||
		spos < 0 || epos < 0 || COLPOS(l, epos) < col)
		break;
	    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,
				   rows > 1,
				   form->type == FORM_INPUT_PASSWORD);
	    if (pos != epos) {
		shiftAnchorPosition(buf->href, buf->hmarklist,
				    a->start.line, spos, pos - epos);
		shiftAnchorPosition(buf->name, buf->hmarklist,
				    a->start.line, spos, pos - epos);
		shiftAnchorPosition(buf->img, buf->hmarklist,
				    a->start.line, spos, pos - epos);
		shiftAnchorPosition(buf->formitem, buf->hmarklist,
				    a->start.line, spos, pos - epos);
	    }
	}
	break;
    }
    copyBuffer(buf, &save);
    arrangeLine(buf);
}
","formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)
{
    Buffer save;
    char *p;
    int spos, epos, rows, c_rows, pos, col = 0;
    Line *l;

    copyBuffer(&save, buf);
    gotoLine(buf, a->start.line);
    switch (form->type) {
    case FORM_TEXTAREA:
    case FORM_INPUT_TEXT:
    case FORM_INPUT_FILE:
    case FORM_INPUT_PASSWORD:
    case FORM_INPUT_CHECKBOX:
    case FORM_INPUT_RADIO:
#ifdef MENU_SELECT
    case FORM_SELECT:
#endif				/* MENU_SELECT */
	spos = a->start.pos;
	epos = a->end.pos;
	break;
    default:
	spos = a->start.pos + 1;
	epos = a->end.pos - 1;
    }
    switch (form->type) {
    case FORM_INPUT_CHECKBOX:
    case FORM_INPUT_RADIO:
	if (buf->currentLine == NULL ||
	    spos >= buf->currentLine->len || spos < 0)
	    break;
	if (form->checked)
	    buf->currentLine->lineBuf[spos] = '*';
	else
	    buf->currentLine->lineBuf[spos] = ' ';
	break;
    case FORM_INPUT_TEXT:
    case FORM_INPUT_FILE:
    case FORM_INPUT_PASSWORD:
    case FORM_TEXTAREA:
#ifdef MENU_SELECT
    case FORM_SELECT:
	if (form->type == FORM_SELECT) {
	    p = form->label->ptr;
	    updateSelectOption(form, form->select_option);
	}
	else
#endif				/* MENU_SELECT */
	{
	    if (!form->value)
		break;
	    p = form->value->ptr;
	}
	l = buf->currentLine;
	if (!l)
	    break;
	if (form->type == FORM_TEXTAREA) {
	    int n = a->y - buf->currentLine->linenumber;
	    if (n > 0)
		for (; l && n; l = l->prev, n--) ;
	    else if (n < 0)
		for (; l && n; l = l->prev, n++) ;
	    if (!l)
		break;
	}
 	rows = form->rows ? form->rows : 1;
 	col = COLPOS(l, a->start.pos);
 	for (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {
 	    if (rows > 1) {
 		pos = columnPos(l, col);
 		a = retrieveAnchor(buf->formitem, l->linenumber, pos);
		if (a == NULL)
		    break;
		spos = a->start.pos;
		epos = a->end.pos;
	    }
	    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||
		spos < 0 || epos < 0 || COLPOS(l, epos) < col)
		break;
	    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,
				   rows > 1,
				   form->type == FORM_INPUT_PASSWORD);
	    if (pos != epos) {
		shiftAnchorPosition(buf->href, buf->hmarklist,
				    a->start.line, spos, pos - epos);
		shiftAnchorPosition(buf->name, buf->hmarklist,
				    a->start.line, spos, pos - epos);
		shiftAnchorPosition(buf->img, buf->hmarklist,
				    a->start.line, spos, pos - epos);
		shiftAnchorPosition(buf->formitem, buf->hmarklist,
				    a->start.line, spos, pos - epos);
	    }
	}
	break;
    }
    copyBuffer(buf, &save);
    arrangeLine(buf);
}
",C,"	    if (l == NULL)
		break;
",,,"@@ -482,6 +482,8 @@ formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)
 	rows = form->rows ? form->rows : 1;
 	col = COLPOS(l, a->start.pos);
 	for (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {
+	    if (l == NULL)
+		break;
 	    if (rows > 1) {
 		pos = columnPos(l, col);
 		a = retrieveAnchor(buf->formitem, l->linenumber, pos);",w3m,7fdc83b0364005a0b5ed869230dd81752ba022e8,1fd08f383d99e9ffe32f3a336623ceb086eb36b8,1,"formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)
{
    Buffer save;
    char *p;
    int spos, epos, rows, c_rows, pos, col = 0;
    Line *l;

    copyBuffer(&save, buf);
    gotoLine(buf, a->start.line);
    switch (form->type) {
    case FORM_TEXTAREA:
    case FORM_INPUT_TEXT:
    case FORM_INPUT_FILE:
    case FORM_INPUT_PASSWORD:
    case FORM_INPUT_CHECKBOX:
    case FORM_INPUT_RADIO:
#ifdef MENU_SELECT
    case FORM_SELECT:
#endif				/* MENU_SELECT */
	spos = a->start.pos;
	epos = a->end.pos;
	break;
    default:
	spos = a->start.pos + 1;
	epos = a->end.pos - 1;
    }
    switch (form->type) {
    case FORM_INPUT_CHECKBOX:
    case FORM_INPUT_RADIO:
	if (buf->currentLine == NULL ||
	    spos >= buf->currentLine->len || spos < 0)
	    break;
	if (form->checked)
	    buf->currentLine->lineBuf[spos] = '*';
	else
	    buf->currentLine->lineBuf[spos] = ' ';
	break;
    case FORM_INPUT_TEXT:
    case FORM_INPUT_FILE:
    case FORM_INPUT_PASSWORD:
    case FORM_TEXTAREA:
#ifdef MENU_SELECT
    case FORM_SELECT:
	if (form->type == FORM_SELECT) {
	    p = form->label->ptr;
	    updateSelectOption(form, form->select_option);
	}
	else
#endif				/* MENU_SELECT */
	{
	    if (!form->value)
		break;
	    p = form->value->ptr;
	}
	l = buf->currentLine;
	if (!l)
	    break;
	if (form->type == FORM_TEXTAREA) {
	    int n = a->y - buf->currentLine->linenumber;
	    if (n > 0)
		for (; l && n; l = l->prev, n--) ;
	    else if (n < 0)
		for (; l && n; l = l->prev, n++) ;
	    if (!l)
		break;
	}
 	rows = form->rows ? form->rows : 1;
 	col = COLPOS(l, a->start.pos);
 	for (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {
//fix_flaw_line_below:
//	    if (l == NULL)
//fix_flaw_line_below:
//		break;
 	    if (rows > 1) {
 		pos = columnPos(l, col);
 		a = retrieveAnchor(buf->formitem, l->linenumber, pos);
		if (a == NULL)
		    break;
		spos = a->start.pos;
		epos = a->end.pos;
	    }
	    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||
		spos < 0 || epos < 0 || COLPOS(l, epos) < col)
		break;
	    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,
				   rows > 1,
				   form->type == FORM_INPUT_PASSWORD);
	    if (pos != epos) {
		shiftAnchorPosition(buf->href, buf->hmarklist,
				    a->start.line, spos, pos - epos);
		shiftAnchorPosition(buf->name, buf->hmarklist,
				    a->start.line, spos, pos - epos);
		shiftAnchorPosition(buf->img, buf->hmarklist,
				    a->start.line, spos, pos - epos);
		shiftAnchorPosition(buf->formitem, buf->hmarklist,
				    a->start.line, spos, pos - epos);
	    }
	}
	break;
    }
    copyBuffer(buf, &save);
    arrangeLine(buf);
}
"
4789,182525,,Local,Not required,Complete,CVE-2018-5333,https://www.cvedetails.com/cve/CVE-2018-5333/,CWE-476,Low,,,,2018-01-11,4.9,"In the Linux kernel through 4.14.13, the rds_cmsg_atomic function in net/rds/rdma.c mishandles cases where page pinning fails or an invalid address is supplied, leading to an rds_atomic_free_op NULL pointer dereference.",2018-05-03,,1,https://github.com/torvalds/linux/commit/7d11f77f84b27cef452cee332f4e469503084737,7d11f77f84b27cef452cee332f4e469503084737,"RDS: null pointer dereference in rds_atomic_free_op

set rm->atomic.op_active to 0 when rds_pin_pages() fails
or the user supplied address is invalid,
this prevents a NULL pointer usage in rds_atomic_free_op()

Signed-off-by: Mohamed Ghannam <simo.ghannam@gmail.com>
Acked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/rds/rdma.c,"{""sha"": ""634cfcb7bba6833bde376706947c99f1cb103199"", ""filename"": ""net/rds/rdma.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/7d11f77f84b27cef452cee332f4e469503084737/net/rds/rdma.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/7d11f77f84b27cef452cee332f4e469503084737/net/rds/rdma.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/rds/rdma.c?ref=7d11f77f84b27cef452cee332f4e469503084737"", ""patch"": ""@@ -877,6 +877,7 @@ int rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm,\n err:\n \tif (page)\n \t\tput_page(page);\n+\trm->atomic.op_active = 0;\n \tkfree(rm->atomic.op_notifier);\n \n \treturn ret;""}","int rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm,
		    struct cmsghdr *cmsg)
{
	struct page *page = NULL;
	struct rds_atomic_args *args;
	int ret = 0;

	if (cmsg->cmsg_len < CMSG_LEN(sizeof(struct rds_atomic_args))
	 || rm->atomic.op_active)
		return -EINVAL;

	args = CMSG_DATA(cmsg);

	/* Nonmasked & masked cmsg ops converted to masked hw ops */
	switch (cmsg->cmsg_type) {
	case RDS_CMSG_ATOMIC_FADD:
		rm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;
		rm->atomic.op_m_fadd.add = args->fadd.add;
		rm->atomic.op_m_fadd.nocarry_mask = 0;
		break;
	case RDS_CMSG_MASKED_ATOMIC_FADD:
		rm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;
		rm->atomic.op_m_fadd.add = args->m_fadd.add;
		rm->atomic.op_m_fadd.nocarry_mask = args->m_fadd.nocarry_mask;
		break;
	case RDS_CMSG_ATOMIC_CSWP:
		rm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;
		rm->atomic.op_m_cswp.compare = args->cswp.compare;
		rm->atomic.op_m_cswp.swap = args->cswp.swap;
		rm->atomic.op_m_cswp.compare_mask = ~0;
		rm->atomic.op_m_cswp.swap_mask = ~0;
		break;
	case RDS_CMSG_MASKED_ATOMIC_CSWP:
		rm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;
		rm->atomic.op_m_cswp.compare = args->m_cswp.compare;
		rm->atomic.op_m_cswp.swap = args->m_cswp.swap;
		rm->atomic.op_m_cswp.compare_mask = args->m_cswp.compare_mask;
		rm->atomic.op_m_cswp.swap_mask = args->m_cswp.swap_mask;
		break;
	default:
		BUG(); /* should never happen */
	}

	rm->atomic.op_notify = !!(args->flags & RDS_RDMA_NOTIFY_ME);
	rm->atomic.op_silent = !!(args->flags & RDS_RDMA_SILENT);
	rm->atomic.op_active = 1;
	rm->atomic.op_recverr = rs->rs_recverr;
	rm->atomic.op_sg = rds_message_alloc_sgs(rm, 1);
	if (!rm->atomic.op_sg) {
		ret = -ENOMEM;
		goto err;
	}

	/* verify 8 byte-aligned */
	if (args->local_addr & 0x7) {
		ret = -EFAULT;
		goto err;
	}

	ret = rds_pin_pages(args->local_addr, 1, &page, 1);
	if (ret != 1)
		goto err;
	ret = 0;

	sg_set_page(rm->atomic.op_sg, page, 8, offset_in_page(args->local_addr));

	if (rm->atomic.op_notify || rm->atomic.op_recverr) {
		/* We allocate an uninitialized notifier here, because
		 * we don't want to do that in the completion handler. We
		 * would have to use GFP_ATOMIC there, and don't want to deal
		 * with failed allocations.
		 */
		rm->atomic.op_notifier = kmalloc(sizeof(*rm->atomic.op_notifier), GFP_KERNEL);
		if (!rm->atomic.op_notifier) {
			ret = -ENOMEM;
			goto err;
		}

		rm->atomic.op_notifier->n_user_token = args->user_token;
		rm->atomic.op_notifier->n_status = RDS_RDMA_SUCCESS;
	}

	rm->atomic.op_rkey = rds_rdma_cookie_key(args->cookie);
	rm->atomic.op_remote_addr = args->remote_addr + rds_rdma_cookie_offset(args->cookie);

	return ret;
 err:
 	if (page)
 		put_page(page);
	rm->atomic.op_active = 0;
 	kfree(rm->atomic.op_notifier);
 
 	return ret;
}
","int rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm,
		    struct cmsghdr *cmsg)
{
	struct page *page = NULL;
	struct rds_atomic_args *args;
	int ret = 0;

	if (cmsg->cmsg_len < CMSG_LEN(sizeof(struct rds_atomic_args))
	 || rm->atomic.op_active)
		return -EINVAL;

	args = CMSG_DATA(cmsg);

	/* Nonmasked & masked cmsg ops converted to masked hw ops */
	switch (cmsg->cmsg_type) {
	case RDS_CMSG_ATOMIC_FADD:
		rm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;
		rm->atomic.op_m_fadd.add = args->fadd.add;
		rm->atomic.op_m_fadd.nocarry_mask = 0;
		break;
	case RDS_CMSG_MASKED_ATOMIC_FADD:
		rm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;
		rm->atomic.op_m_fadd.add = args->m_fadd.add;
		rm->atomic.op_m_fadd.nocarry_mask = args->m_fadd.nocarry_mask;
		break;
	case RDS_CMSG_ATOMIC_CSWP:
		rm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;
		rm->atomic.op_m_cswp.compare = args->cswp.compare;
		rm->atomic.op_m_cswp.swap = args->cswp.swap;
		rm->atomic.op_m_cswp.compare_mask = ~0;
		rm->atomic.op_m_cswp.swap_mask = ~0;
		break;
	case RDS_CMSG_MASKED_ATOMIC_CSWP:
		rm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;
		rm->atomic.op_m_cswp.compare = args->m_cswp.compare;
		rm->atomic.op_m_cswp.swap = args->m_cswp.swap;
		rm->atomic.op_m_cswp.compare_mask = args->m_cswp.compare_mask;
		rm->atomic.op_m_cswp.swap_mask = args->m_cswp.swap_mask;
		break;
	default:
		BUG(); /* should never happen */
	}

	rm->atomic.op_notify = !!(args->flags & RDS_RDMA_NOTIFY_ME);
	rm->atomic.op_silent = !!(args->flags & RDS_RDMA_SILENT);
	rm->atomic.op_active = 1;
	rm->atomic.op_recverr = rs->rs_recverr;
	rm->atomic.op_sg = rds_message_alloc_sgs(rm, 1);
	if (!rm->atomic.op_sg) {
		ret = -ENOMEM;
		goto err;
	}

	/* verify 8 byte-aligned */
	if (args->local_addr & 0x7) {
		ret = -EFAULT;
		goto err;
	}

	ret = rds_pin_pages(args->local_addr, 1, &page, 1);
	if (ret != 1)
		goto err;
	ret = 0;

	sg_set_page(rm->atomic.op_sg, page, 8, offset_in_page(args->local_addr));

	if (rm->atomic.op_notify || rm->atomic.op_recverr) {
		/* We allocate an uninitialized notifier here, because
		 * we don't want to do that in the completion handler. We
		 * would have to use GFP_ATOMIC there, and don't want to deal
		 * with failed allocations.
		 */
		rm->atomic.op_notifier = kmalloc(sizeof(*rm->atomic.op_notifier), GFP_KERNEL);
		if (!rm->atomic.op_notifier) {
			ret = -ENOMEM;
			goto err;
		}

		rm->atomic.op_notifier->n_user_token = args->user_token;
		rm->atomic.op_notifier->n_status = RDS_RDMA_SUCCESS;
	}

	rm->atomic.op_rkey = rds_rdma_cookie_key(args->cookie);
	rm->atomic.op_remote_addr = args->remote_addr + rds_rdma_cookie_offset(args->cookie);

	return ret;
 err:
 	if (page)
 		put_page(page);
 	kfree(rm->atomic.op_notifier);
 
 	return ret;
}
",C,"	rm->atomic.op_active = 0;
",,,"@@ -877,6 +877,7 @@ int rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm,
 err:
 	if (page)
 		put_page(page);
+	rm->atomic.op_active = 0;
 	kfree(rm->atomic.op_notifier);
 
 	return ret;",linux,7d11f77f84b27cef452cee332f4e469503084737,dfe8266b8dd10e12a731c985b725fcf7f0e537f0,1,"int rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm,
		    struct cmsghdr *cmsg)
{
	struct page *page = NULL;
	struct rds_atomic_args *args;
	int ret = 0;

	if (cmsg->cmsg_len < CMSG_LEN(sizeof(struct rds_atomic_args))
	 || rm->atomic.op_active)
		return -EINVAL;

	args = CMSG_DATA(cmsg);

	/* Nonmasked & masked cmsg ops converted to masked hw ops */
	switch (cmsg->cmsg_type) {
	case RDS_CMSG_ATOMIC_FADD:
		rm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;
		rm->atomic.op_m_fadd.add = args->fadd.add;
		rm->atomic.op_m_fadd.nocarry_mask = 0;
		break;
	case RDS_CMSG_MASKED_ATOMIC_FADD:
		rm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;
		rm->atomic.op_m_fadd.add = args->m_fadd.add;
		rm->atomic.op_m_fadd.nocarry_mask = args->m_fadd.nocarry_mask;
		break;
	case RDS_CMSG_ATOMIC_CSWP:
		rm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;
		rm->atomic.op_m_cswp.compare = args->cswp.compare;
		rm->atomic.op_m_cswp.swap = args->cswp.swap;
		rm->atomic.op_m_cswp.compare_mask = ~0;
		rm->atomic.op_m_cswp.swap_mask = ~0;
		break;
	case RDS_CMSG_MASKED_ATOMIC_CSWP:
		rm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;
		rm->atomic.op_m_cswp.compare = args->m_cswp.compare;
		rm->atomic.op_m_cswp.swap = args->m_cswp.swap;
		rm->atomic.op_m_cswp.compare_mask = args->m_cswp.compare_mask;
		rm->atomic.op_m_cswp.swap_mask = args->m_cswp.swap_mask;
		break;
	default:
		BUG(); /* should never happen */
	}

	rm->atomic.op_notify = !!(args->flags & RDS_RDMA_NOTIFY_ME);
	rm->atomic.op_silent = !!(args->flags & RDS_RDMA_SILENT);
	rm->atomic.op_active = 1;
	rm->atomic.op_recverr = rs->rs_recverr;
	rm->atomic.op_sg = rds_message_alloc_sgs(rm, 1);
	if (!rm->atomic.op_sg) {
		ret = -ENOMEM;
		goto err;
	}

	/* verify 8 byte-aligned */
	if (args->local_addr & 0x7) {
		ret = -EFAULT;
		goto err;
	}

	ret = rds_pin_pages(args->local_addr, 1, &page, 1);
	if (ret != 1)
		goto err;
	ret = 0;

	sg_set_page(rm->atomic.op_sg, page, 8, offset_in_page(args->local_addr));

	if (rm->atomic.op_notify || rm->atomic.op_recverr) {
		/* We allocate an uninitialized notifier here, because
		 * we don't want to do that in the completion handler. We
		 * would have to use GFP_ATOMIC there, and don't want to deal
		 * with failed allocations.
		 */
		rm->atomic.op_notifier = kmalloc(sizeof(*rm->atomic.op_notifier), GFP_KERNEL);
		if (!rm->atomic.op_notifier) {
			ret = -ENOMEM;
			goto err;
		}

		rm->atomic.op_notifier->n_user_token = args->user_token;
		rm->atomic.op_notifier->n_status = RDS_RDMA_SUCCESS;
	}

	rm->atomic.op_rkey = rds_rdma_cookie_key(args->cookie);
	rm->atomic.op_remote_addr = args->remote_addr + rds_rdma_cookie_offset(args->cookie);

	return ret;
 err:
 	if (page)
 		put_page(page);
//fix_flaw_line_below:
//	rm->atomic.op_active = 0;
 	kfree(rm->atomic.op_notifier);
 
 	return ret;
}
"
4795,182531,,Remote,Not required,Complete,CVE-2018-1066,https://www.cvedetails.com/cve/CVE-2018-1066/,CWE-476,Medium,,,,2018-03-02,7.1,"The Linux kernel before version 4.11 is vulnerable to a NULL pointer dereference in fs/cifs/cifsencrypt.c:setup_ntlmv2_rsp() that allows an attacker controlling a CIFS server to kernel panic a client that has this server mounted, because an empty TargetInfo field in an NTLMSSP setup negotiation response is mishandled during session recovery.",2019-04-23,,5,https://github.com/torvalds/linux/commit/cabfb3680f78981d26c078a26e5c748531257ebb,cabfb3680f78981d26c078a26e5c748531257ebb,"CIFS: Enable encryption during session setup phase

In order to allow encryption on SMB connection we need to exchange
a session key and generate encryption and decryption keys.

Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>",6,fs/cifs/sess.c,"{""sha"": ""dcbcc927399a0ffbaecf07c1f52fec42afeb3459"", ""filename"": ""fs/cifs/sess.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 12, ""changes"": 22, ""blob_url"": ""https://github.com/torvalds/linux/blob/cabfb3680f78981d26c078a26e5c748531257ebb/fs/cifs/sess.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/cabfb3680f78981d26c078a26e5c748531257ebb/fs/cifs/sess.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/sess.c?ref=cabfb3680f78981d26c078a26e5c748531257ebb"", ""patch"": ""@@ -344,13 +344,12 @@ void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n \t/* BB is NTLMV2 session security format easier to use here? */\n \tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n \t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n-\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n-\tif (ses->server->sign) {\n+\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |\n+\t\tNTLMSSP_NEGOTIATE_SEAL;\n+\tif (ses->server->sign)\n \t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n-\t\tif (!ses->server->session_estab ||\n-\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n-\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n-\t}\n+\tif (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)\n+\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n \n \tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n \n@@ -407,13 +406,12 @@ int build_ntlmssp_auth_blob(unsigned char **pbuffer,\n \tflags = NTLMSSP_NEGOTIATE_56 |\n \t\tNTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |\n \t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n-\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n-\tif (ses->server->sign) {\n+\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |\n+\t\tNTLMSSP_NEGOTIATE_SEAL;\n+\tif (ses->server->sign)\n \t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n-\t\tif (!ses->server->session_estab ||\n-\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n-\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n-\t}\n+\tif (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)\n+\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n \n \ttmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);\n \tsec_blob->NegotiateFlags = cpu_to_le32(flags);""}<_**next**_>{""sha"": ""b088c50271113224f8d3cb839923331f4735e204"", ""filename"": ""fs/cifs/smb2pdu.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 10, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/cabfb3680f78981d26c078a26e5c748531257ebb/fs/cifs/smb2pdu.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/cabfb3680f78981d26c078a26e5c748531257ebb/fs/cifs/smb2pdu.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/smb2pdu.c?ref=cabfb3680f78981d26c078a26e5c748531257ebb"", ""patch"": ""@@ -756,15 +756,13 @@ SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n \tstruct cifs_ses *ses = sess_data->ses;\n \n \tmutex_lock(&ses->server->srv_mutex);\n-\tif (ses->server->sign && ses->server->ops->generate_signingkey) {\n+\tif (ses->server->ops->generate_signingkey) {\n \t\trc = ses->server->ops->generate_signingkey(ses);\n-\t\tkfree(ses->auth_key.response);\n-\t\tses->auth_key.response = NULL;\n \t\tif (rc) {\n \t\t\tcifs_dbg(FYI,\n \t\t\t\t\""SMB3 session key generation failed\\n\"");\n \t\t\tmutex_unlock(&ses->server->srv_mutex);\n-\t\t\tgoto keygen_exit;\n+\t\t\treturn rc;\n \t\t}\n \t}\n \tif (!ses->server->session_estab) {\n@@ -778,12 +776,6 @@ SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n \tses->status = CifsGood;\n \tses->need_reconnect = false;\n \tspin_unlock(&GlobalMid_Lock);\n-\n-keygen_exit:\n-\tif (!ses->server->sign) {\n-\t\tkfree(ses->auth_key.response);\n-\t\tses->auth_key.response = NULL;\n-\t}\n \treturn rc;\n }\n ""}","int build_ntlmssp_auth_blob(unsigned char **pbuffer,
					u16 *buflen,
				   struct cifs_ses *ses,
				   const struct nls_table *nls_cp)
{
	int rc;
	AUTHENTICATE_MESSAGE *sec_blob;
	__u32 flags;
	unsigned char *tmp;

	rc = setup_ntlmv2_rsp(ses, nls_cp);
	if (rc) {
		cifs_dbg(VFS, ""Error %d during NTLMSSP authentication\n"", rc);
		*buflen = 0;
		goto setup_ntlmv2_ret;
	}
	*pbuffer = kmalloc(size_of_ntlmssp_blob(ses), GFP_KERNEL);
	sec_blob = (AUTHENTICATE_MESSAGE *)*pbuffer;

	memcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);
	sec_blob->MessageType = NtLmAuthenticate;

 	flags = NTLMSSP_NEGOTIATE_56 |
 		NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |
 		NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |
		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |
		NTLMSSP_NEGOTIATE_SEAL;
	if (ses->server->sign)
 		flags |= NTLMSSP_NEGOTIATE_SIGN;
	if (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)
		flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
 
 	tmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);
 	sec_blob->NegotiateFlags = cpu_to_le32(flags);

	sec_blob->LmChallengeResponse.BufferOffset =
				cpu_to_le32(sizeof(AUTHENTICATE_MESSAGE));
	sec_blob->LmChallengeResponse.Length = 0;
	sec_blob->LmChallengeResponse.MaximumLength = 0;

	sec_blob->NtChallengeResponse.BufferOffset =
				cpu_to_le32(tmp - *pbuffer);
	if (ses->user_name != NULL) {
		memcpy(tmp, ses->auth_key.response + CIFS_SESS_KEY_SIZE,
				ses->auth_key.len - CIFS_SESS_KEY_SIZE);
		tmp += ses->auth_key.len - CIFS_SESS_KEY_SIZE;

		sec_blob->NtChallengeResponse.Length =
				cpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);
		sec_blob->NtChallengeResponse.MaximumLength =
				cpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);
	} else {
		/*
		 * don't send an NT Response for anonymous access
		 */
		sec_blob->NtChallengeResponse.Length = 0;
		sec_blob->NtChallengeResponse.MaximumLength = 0;
	}

	if (ses->domainName == NULL) {
		sec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->DomainName.Length = 0;
		sec_blob->DomainName.MaximumLength = 0;
		tmp += 2;
	} else {
		int len;
		len = cifs_strtoUTF16((__le16 *)tmp, ses->domainName,
				      CIFS_MAX_DOMAINNAME_LEN, nls_cp);
		len *= 2; /* unicode is 2 bytes each */
		sec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->DomainName.Length = cpu_to_le16(len);
		sec_blob->DomainName.MaximumLength = cpu_to_le16(len);
		tmp += len;
	}

	if (ses->user_name == NULL) {
		sec_blob->UserName.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->UserName.Length = 0;
		sec_blob->UserName.MaximumLength = 0;
		tmp += 2;
	} else {
		int len;
		len = cifs_strtoUTF16((__le16 *)tmp, ses->user_name,
				      CIFS_MAX_USERNAME_LEN, nls_cp);
		len *= 2; /* unicode is 2 bytes each */
		sec_blob->UserName.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->UserName.Length = cpu_to_le16(len);
		sec_blob->UserName.MaximumLength = cpu_to_le16(len);
		tmp += len;
	}

	sec_blob->WorkstationName.BufferOffset = cpu_to_le32(tmp - *pbuffer);
	sec_blob->WorkstationName.Length = 0;
	sec_blob->WorkstationName.MaximumLength = 0;
	tmp += 2;

	if (((ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_KEY_XCH) ||
		(ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_EXTENDED_SEC))
			&& !calc_seckey(ses)) {
		memcpy(tmp, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);
		sec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->SessionKey.Length = cpu_to_le16(CIFS_CPHTXT_SIZE);
		sec_blob->SessionKey.MaximumLength =
				cpu_to_le16(CIFS_CPHTXT_SIZE);
		tmp += CIFS_CPHTXT_SIZE;
	} else {
		sec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->SessionKey.Length = 0;
		sec_blob->SessionKey.MaximumLength = 0;
	}

	*buflen = tmp - *pbuffer;
setup_ntlmv2_ret:
	return rc;
}
","int build_ntlmssp_auth_blob(unsigned char **pbuffer,
					u16 *buflen,
				   struct cifs_ses *ses,
				   const struct nls_table *nls_cp)
{
	int rc;
	AUTHENTICATE_MESSAGE *sec_blob;
	__u32 flags;
	unsigned char *tmp;

	rc = setup_ntlmv2_rsp(ses, nls_cp);
	if (rc) {
		cifs_dbg(VFS, ""Error %d during NTLMSSP authentication\n"", rc);
		*buflen = 0;
		goto setup_ntlmv2_ret;
	}
	*pbuffer = kmalloc(size_of_ntlmssp_blob(ses), GFP_KERNEL);
	sec_blob = (AUTHENTICATE_MESSAGE *)*pbuffer;

	memcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);
	sec_blob->MessageType = NtLmAuthenticate;

 	flags = NTLMSSP_NEGOTIATE_56 |
 		NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |
 		NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |
		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;
	if (ses->server->sign) {
 		flags |= NTLMSSP_NEGOTIATE_SIGN;
		if (!ses->server->session_estab ||
				ses->ntlmssp->sesskey_per_smbsess)
			flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
	}
 
 	tmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);
 	sec_blob->NegotiateFlags = cpu_to_le32(flags);

	sec_blob->LmChallengeResponse.BufferOffset =
				cpu_to_le32(sizeof(AUTHENTICATE_MESSAGE));
	sec_blob->LmChallengeResponse.Length = 0;
	sec_blob->LmChallengeResponse.MaximumLength = 0;

	sec_blob->NtChallengeResponse.BufferOffset =
				cpu_to_le32(tmp - *pbuffer);
	if (ses->user_name != NULL) {
		memcpy(tmp, ses->auth_key.response + CIFS_SESS_KEY_SIZE,
				ses->auth_key.len - CIFS_SESS_KEY_SIZE);
		tmp += ses->auth_key.len - CIFS_SESS_KEY_SIZE;

		sec_blob->NtChallengeResponse.Length =
				cpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);
		sec_blob->NtChallengeResponse.MaximumLength =
				cpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);
	} else {
		/*
		 * don't send an NT Response for anonymous access
		 */
		sec_blob->NtChallengeResponse.Length = 0;
		sec_blob->NtChallengeResponse.MaximumLength = 0;
	}

	if (ses->domainName == NULL) {
		sec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->DomainName.Length = 0;
		sec_blob->DomainName.MaximumLength = 0;
		tmp += 2;
	} else {
		int len;
		len = cifs_strtoUTF16((__le16 *)tmp, ses->domainName,
				      CIFS_MAX_DOMAINNAME_LEN, nls_cp);
		len *= 2; /* unicode is 2 bytes each */
		sec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->DomainName.Length = cpu_to_le16(len);
		sec_blob->DomainName.MaximumLength = cpu_to_le16(len);
		tmp += len;
	}

	if (ses->user_name == NULL) {
		sec_blob->UserName.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->UserName.Length = 0;
		sec_blob->UserName.MaximumLength = 0;
		tmp += 2;
	} else {
		int len;
		len = cifs_strtoUTF16((__le16 *)tmp, ses->user_name,
				      CIFS_MAX_USERNAME_LEN, nls_cp);
		len *= 2; /* unicode is 2 bytes each */
		sec_blob->UserName.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->UserName.Length = cpu_to_le16(len);
		sec_blob->UserName.MaximumLength = cpu_to_le16(len);
		tmp += len;
	}

	sec_blob->WorkstationName.BufferOffset = cpu_to_le32(tmp - *pbuffer);
	sec_blob->WorkstationName.Length = 0;
	sec_blob->WorkstationName.MaximumLength = 0;
	tmp += 2;

	if (((ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_KEY_XCH) ||
		(ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_EXTENDED_SEC))
			&& !calc_seckey(ses)) {
		memcpy(tmp, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);
		sec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->SessionKey.Length = cpu_to_le16(CIFS_CPHTXT_SIZE);
		sec_blob->SessionKey.MaximumLength =
				cpu_to_le16(CIFS_CPHTXT_SIZE);
		tmp += CIFS_CPHTXT_SIZE;
	} else {
		sec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->SessionKey.Length = 0;
		sec_blob->SessionKey.MaximumLength = 0;
	}

	*buflen = tmp - *pbuffer;
setup_ntlmv2_ret:
	return rc;
}
",C,"		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |
		NTLMSSP_NEGOTIATE_SEAL;
	if (ses->server->sign)
	if (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)
		flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
","		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;
	if (ses->server->sign) {
		if (!ses->server->session_estab ||
				ses->ntlmssp->sesskey_per_smbsess)
			flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
	}
",,"@@ -344,13 +344,12 @@ void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,
 	/* BB is NTLMV2 session security format easier to use here? */
 	flags = NTLMSSP_NEGOTIATE_56 |	NTLMSSP_REQUEST_TARGET |
 		NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |
-		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;
-	if (ses->server->sign) {
+		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |
+		NTLMSSP_NEGOTIATE_SEAL;
+	if (ses->server->sign)
 		flags |= NTLMSSP_NEGOTIATE_SIGN;
-		if (!ses->server->session_estab ||
-				ses->ntlmssp->sesskey_per_smbsess)
-			flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
-	}
+	if (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)
+		flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
 
 	sec_blob->NegotiateFlags = cpu_to_le32(flags);
 
@@ -407,13 +406,12 @@ int build_ntlmssp_auth_blob(unsigned char **pbuffer,
 	flags = NTLMSSP_NEGOTIATE_56 |
 		NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |
 		NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |
-		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;
-	if (ses->server->sign) {
+		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |
+		NTLMSSP_NEGOTIATE_SEAL;
+	if (ses->server->sign)
 		flags |= NTLMSSP_NEGOTIATE_SIGN;
-		if (!ses->server->session_estab ||
-				ses->ntlmssp->sesskey_per_smbsess)
-			flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
-	}
+	if (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)
+		flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
 
 	tmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);
 	sec_blob->NegotiateFlags = cpu_to_le32(flags);",linux,cabfb3680f78981d26c078a26e5c748531257ebb,7fb8986e7449d0a5cebd84d059927afa423fbf85,1,"int build_ntlmssp_auth_blob(unsigned char **pbuffer,
					u16 *buflen,
				   struct cifs_ses *ses,
				   const struct nls_table *nls_cp)
{
	int rc;
	AUTHENTICATE_MESSAGE *sec_blob;
	__u32 flags;
	unsigned char *tmp;

	rc = setup_ntlmv2_rsp(ses, nls_cp);
	if (rc) {
		cifs_dbg(VFS, ""Error %d during NTLMSSP authentication\n"", rc);
		*buflen = 0;
		goto setup_ntlmv2_ret;
	}
	*pbuffer = kmalloc(size_of_ntlmssp_blob(ses), GFP_KERNEL);
	sec_blob = (AUTHENTICATE_MESSAGE *)*pbuffer;

	memcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);
	sec_blob->MessageType = NtLmAuthenticate;

 	flags = NTLMSSP_NEGOTIATE_56 |
 		NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |
 		NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |
//flaw_line_below:
		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;
//flaw_line_below:
	if (ses->server->sign) {
//fix_flaw_line_below:
//		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |
//fix_flaw_line_below:
//		NTLMSSP_NEGOTIATE_SEAL;
//fix_flaw_line_below:
//	if (ses->server->sign)
 		flags |= NTLMSSP_NEGOTIATE_SIGN;
//flaw_line_below:
		if (!ses->server->session_estab ||
//flaw_line_below:
				ses->ntlmssp->sesskey_per_smbsess)
//flaw_line_below:
			flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
//flaw_line_below:
	}
//fix_flaw_line_below:
//	if (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)
//fix_flaw_line_below:
//		flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
 
 	tmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);
 	sec_blob->NegotiateFlags = cpu_to_le32(flags);

	sec_blob->LmChallengeResponse.BufferOffset =
				cpu_to_le32(sizeof(AUTHENTICATE_MESSAGE));
	sec_blob->LmChallengeResponse.Length = 0;
	sec_blob->LmChallengeResponse.MaximumLength = 0;

	sec_blob->NtChallengeResponse.BufferOffset =
				cpu_to_le32(tmp - *pbuffer);
	if (ses->user_name != NULL) {
		memcpy(tmp, ses->auth_key.response + CIFS_SESS_KEY_SIZE,
				ses->auth_key.len - CIFS_SESS_KEY_SIZE);
		tmp += ses->auth_key.len - CIFS_SESS_KEY_SIZE;

		sec_blob->NtChallengeResponse.Length =
				cpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);
		sec_blob->NtChallengeResponse.MaximumLength =
				cpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);
	} else {
		/*
		 * don't send an NT Response for anonymous access
		 */
		sec_blob->NtChallengeResponse.Length = 0;
		sec_blob->NtChallengeResponse.MaximumLength = 0;
	}

	if (ses->domainName == NULL) {
		sec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->DomainName.Length = 0;
		sec_blob->DomainName.MaximumLength = 0;
		tmp += 2;
	} else {
		int len;
		len = cifs_strtoUTF16((__le16 *)tmp, ses->domainName,
				      CIFS_MAX_DOMAINNAME_LEN, nls_cp);
		len *= 2; /* unicode is 2 bytes each */
		sec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->DomainName.Length = cpu_to_le16(len);
		sec_blob->DomainName.MaximumLength = cpu_to_le16(len);
		tmp += len;
	}

	if (ses->user_name == NULL) {
		sec_blob->UserName.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->UserName.Length = 0;
		sec_blob->UserName.MaximumLength = 0;
		tmp += 2;
	} else {
		int len;
		len = cifs_strtoUTF16((__le16 *)tmp, ses->user_name,
				      CIFS_MAX_USERNAME_LEN, nls_cp);
		len *= 2; /* unicode is 2 bytes each */
		sec_blob->UserName.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->UserName.Length = cpu_to_le16(len);
		sec_blob->UserName.MaximumLength = cpu_to_le16(len);
		tmp += len;
	}

	sec_blob->WorkstationName.BufferOffset = cpu_to_le32(tmp - *pbuffer);
	sec_blob->WorkstationName.Length = 0;
	sec_blob->WorkstationName.MaximumLength = 0;
	tmp += 2;

	if (((ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_KEY_XCH) ||
		(ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_EXTENDED_SEC))
			&& !calc_seckey(ses)) {
		memcpy(tmp, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);
		sec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->SessionKey.Length = cpu_to_le16(CIFS_CPHTXT_SIZE);
		sec_blob->SessionKey.MaximumLength =
				cpu_to_le16(CIFS_CPHTXT_SIZE);
		tmp += CIFS_CPHTXT_SIZE;
	} else {
		sec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->SessionKey.Length = 0;
		sec_blob->SessionKey.MaximumLength = 0;
	}

	*buflen = tmp - *pbuffer;
setup_ntlmv2_ret:
	return rc;
}
"
4796,182532,,Remote,Not required,Complete,CVE-2018-1066,https://www.cvedetails.com/cve/CVE-2018-1066/,CWE-476,Medium,,,,2018-03-02,7.1,"The Linux kernel before version 4.11 is vulnerable to a NULL pointer dereference in fs/cifs/cifsencrypt.c:setup_ntlmv2_rsp() that allows an attacker controlling a CIFS server to kernel panic a client that has this server mounted, because an empty TargetInfo field in an NTLMSSP setup negotiation response is mishandled during session recovery.",2019-04-23,,5,https://github.com/torvalds/linux/commit/cabfb3680f78981d26c078a26e5c748531257ebb,cabfb3680f78981d26c078a26e5c748531257ebb,"CIFS: Enable encryption during session setup phase

In order to allow encryption on SMB connection we need to exchange
a session key and generate encryption and decryption keys.

Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>",6,fs/cifs/sess.c,"{""sha"": ""dcbcc927399a0ffbaecf07c1f52fec42afeb3459"", ""filename"": ""fs/cifs/sess.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 12, ""changes"": 22, ""blob_url"": ""https://github.com/torvalds/linux/blob/cabfb3680f78981d26c078a26e5c748531257ebb/fs/cifs/sess.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/cabfb3680f78981d26c078a26e5c748531257ebb/fs/cifs/sess.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/sess.c?ref=cabfb3680f78981d26c078a26e5c748531257ebb"", ""patch"": ""@@ -344,13 +344,12 @@ void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n \t/* BB is NTLMV2 session security format easier to use here? */\n \tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n \t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n-\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n-\tif (ses->server->sign) {\n+\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |\n+\t\tNTLMSSP_NEGOTIATE_SEAL;\n+\tif (ses->server->sign)\n \t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n-\t\tif (!ses->server->session_estab ||\n-\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n-\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n-\t}\n+\tif (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)\n+\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n \n \tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n \n@@ -407,13 +406,12 @@ int build_ntlmssp_auth_blob(unsigned char **pbuffer,\n \tflags = NTLMSSP_NEGOTIATE_56 |\n \t\tNTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |\n \t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n-\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n-\tif (ses->server->sign) {\n+\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |\n+\t\tNTLMSSP_NEGOTIATE_SEAL;\n+\tif (ses->server->sign)\n \t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n-\t\tif (!ses->server->session_estab ||\n-\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n-\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n-\t}\n+\tif (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)\n+\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n \n \ttmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);\n \tsec_blob->NegotiateFlags = cpu_to_le32(flags);""}<_**next**_>{""sha"": ""b088c50271113224f8d3cb839923331f4735e204"", ""filename"": ""fs/cifs/smb2pdu.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 10, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/cabfb3680f78981d26c078a26e5c748531257ebb/fs/cifs/smb2pdu.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/cabfb3680f78981d26c078a26e5c748531257ebb/fs/cifs/smb2pdu.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/smb2pdu.c?ref=cabfb3680f78981d26c078a26e5c748531257ebb"", ""patch"": ""@@ -756,15 +756,13 @@ SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n \tstruct cifs_ses *ses = sess_data->ses;\n \n \tmutex_lock(&ses->server->srv_mutex);\n-\tif (ses->server->sign && ses->server->ops->generate_signingkey) {\n+\tif (ses->server->ops->generate_signingkey) {\n \t\trc = ses->server->ops->generate_signingkey(ses);\n-\t\tkfree(ses->auth_key.response);\n-\t\tses->auth_key.response = NULL;\n \t\tif (rc) {\n \t\t\tcifs_dbg(FYI,\n \t\t\t\t\""SMB3 session key generation failed\\n\"");\n \t\t\tmutex_unlock(&ses->server->srv_mutex);\n-\t\t\tgoto keygen_exit;\n+\t\t\treturn rc;\n \t\t}\n \t}\n \tif (!ses->server->session_estab) {\n@@ -778,12 +776,6 @@ SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n \tses->status = CifsGood;\n \tses->need_reconnect = false;\n \tspin_unlock(&GlobalMid_Lock);\n-\n-keygen_exit:\n-\tif (!ses->server->sign) {\n-\t\tkfree(ses->auth_key.response);\n-\t\tses->auth_key.response = NULL;\n-\t}\n \treturn rc;\n }\n ""}","void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,
					 struct cifs_ses *ses)
{
	NEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;
	__u32 flags;

	memset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));
	memcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);
	sec_blob->MessageType = NtLmNegotiate;

 	/* BB is NTLMV2 session security format easier to use here? */
 	flags = NTLMSSP_NEGOTIATE_56 |	NTLMSSP_REQUEST_TARGET |
 		NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |
		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |
		NTLMSSP_NEGOTIATE_SEAL;
	if (ses->server->sign)
 		flags |= NTLMSSP_NEGOTIATE_SIGN;
	if (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)
		flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
 
 	sec_blob->NegotiateFlags = cpu_to_le32(flags);
 
	sec_blob->WorkstationName.BufferOffset = 0;
	sec_blob->WorkstationName.Length = 0;
	sec_blob->WorkstationName.MaximumLength = 0;

	/* Domain name is sent on the Challenge not Negotiate NTLMSSP request */
	sec_blob->DomainName.BufferOffset = 0;
	sec_blob->DomainName.Length = 0;
	sec_blob->DomainName.MaximumLength = 0;
}
","void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,
					 struct cifs_ses *ses)
{
	NEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;
	__u32 flags;

	memset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));
	memcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);
	sec_blob->MessageType = NtLmNegotiate;

 	/* BB is NTLMV2 session security format easier to use here? */
 	flags = NTLMSSP_NEGOTIATE_56 |	NTLMSSP_REQUEST_TARGET |
 		NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |
		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;
	if (ses->server->sign) {
 		flags |= NTLMSSP_NEGOTIATE_SIGN;
		if (!ses->server->session_estab ||
				ses->ntlmssp->sesskey_per_smbsess)
			flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
	}
 
 	sec_blob->NegotiateFlags = cpu_to_le32(flags);
 
	sec_blob->WorkstationName.BufferOffset = 0;
	sec_blob->WorkstationName.Length = 0;
	sec_blob->WorkstationName.MaximumLength = 0;

	/* Domain name is sent on the Challenge not Negotiate NTLMSSP request */
	sec_blob->DomainName.BufferOffset = 0;
	sec_blob->DomainName.Length = 0;
	sec_blob->DomainName.MaximumLength = 0;
}
",C,"		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |
		NTLMSSP_NEGOTIATE_SEAL;
	if (ses->server->sign)
	if (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)
		flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
","		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;
	if (ses->server->sign) {
		if (!ses->server->session_estab ||
				ses->ntlmssp->sesskey_per_smbsess)
			flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
	}
",,"@@ -344,13 +344,12 @@ void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,
 	/* BB is NTLMV2 session security format easier to use here? */
 	flags = NTLMSSP_NEGOTIATE_56 |	NTLMSSP_REQUEST_TARGET |
 		NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |
-		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;
-	if (ses->server->sign) {
+		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |
+		NTLMSSP_NEGOTIATE_SEAL;
+	if (ses->server->sign)
 		flags |= NTLMSSP_NEGOTIATE_SIGN;
-		if (!ses->server->session_estab ||
-				ses->ntlmssp->sesskey_per_smbsess)
-			flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
-	}
+	if (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)
+		flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
 
 	sec_blob->NegotiateFlags = cpu_to_le32(flags);
 
@@ -407,13 +406,12 @@ int build_ntlmssp_auth_blob(unsigned char **pbuffer,
 	flags = NTLMSSP_NEGOTIATE_56 |
 		NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |
 		NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |
-		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;
-	if (ses->server->sign) {
+		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |
+		NTLMSSP_NEGOTIATE_SEAL;
+	if (ses->server->sign)
 		flags |= NTLMSSP_NEGOTIATE_SIGN;
-		if (!ses->server->session_estab ||
-				ses->ntlmssp->sesskey_per_smbsess)
-			flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
-	}
+	if (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)
+		flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
 
 	tmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);
 	sec_blob->NegotiateFlags = cpu_to_le32(flags);",linux,cabfb3680f78981d26c078a26e5c748531257ebb,7fb8986e7449d0a5cebd84d059927afa423fbf85,1,"void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,
					 struct cifs_ses *ses)
{
	NEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;
	__u32 flags;

	memset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));
	memcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);
	sec_blob->MessageType = NtLmNegotiate;

 	/* BB is NTLMV2 session security format easier to use here? */
 	flags = NTLMSSP_NEGOTIATE_56 |	NTLMSSP_REQUEST_TARGET |
 		NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |
//flaw_line_below:
		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;
//flaw_line_below:
	if (ses->server->sign) {
//fix_flaw_line_below:
//		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |
//fix_flaw_line_below:
//		NTLMSSP_NEGOTIATE_SEAL;
//fix_flaw_line_below:
//	if (ses->server->sign)
 		flags |= NTLMSSP_NEGOTIATE_SIGN;
//flaw_line_below:
		if (!ses->server->session_estab ||
//flaw_line_below:
				ses->ntlmssp->sesskey_per_smbsess)
//flaw_line_below:
			flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
//flaw_line_below:
	}
//fix_flaw_line_below:
//	if (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)
//fix_flaw_line_below:
//		flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
 
 	sec_blob->NegotiateFlags = cpu_to_le32(flags);
 
	sec_blob->WorkstationName.BufferOffset = 0;
	sec_blob->WorkstationName.Length = 0;
	sec_blob->WorkstationName.MaximumLength = 0;

	/* Domain name is sent on the Challenge not Negotiate NTLMSSP request */
	sec_blob->DomainName.BufferOffset = 0;
	sec_blob->DomainName.Length = 0;
	sec_blob->DomainName.MaximumLength = 0;
}
"
4797,182533,,Remote,Not required,Complete,CVE-2018-1066,https://www.cvedetails.com/cve/CVE-2018-1066/,CWE-476,Medium,,,,2018-03-02,7.1,"The Linux kernel before version 4.11 is vulnerable to a NULL pointer dereference in fs/cifs/cifsencrypt.c:setup_ntlmv2_rsp() that allows an attacker controlling a CIFS server to kernel panic a client that has this server mounted, because an empty TargetInfo field in an NTLMSSP setup negotiation response is mishandled during session recovery.",2019-04-23,,2,https://github.com/torvalds/linux/commit/cabfb3680f78981d26c078a26e5c748531257ebb,cabfb3680f78981d26c078a26e5c748531257ebb,"CIFS: Enable encryption during session setup phase

In order to allow encryption on SMB connection we need to exchange
a session key and generate encryption and decryption keys.

Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>",9,fs/cifs/smb2pdu.c,"{""sha"": ""dcbcc927399a0ffbaecf07c1f52fec42afeb3459"", ""filename"": ""fs/cifs/sess.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 12, ""changes"": 22, ""blob_url"": ""https://github.com/torvalds/linux/blob/cabfb3680f78981d26c078a26e5c748531257ebb/fs/cifs/sess.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/cabfb3680f78981d26c078a26e5c748531257ebb/fs/cifs/sess.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/sess.c?ref=cabfb3680f78981d26c078a26e5c748531257ebb"", ""patch"": ""@@ -344,13 +344,12 @@ void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n \t/* BB is NTLMV2 session security format easier to use here? */\n \tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n \t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n-\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n-\tif (ses->server->sign) {\n+\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |\n+\t\tNTLMSSP_NEGOTIATE_SEAL;\n+\tif (ses->server->sign)\n \t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n-\t\tif (!ses->server->session_estab ||\n-\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n-\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n-\t}\n+\tif (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)\n+\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n \n \tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n \n@@ -407,13 +406,12 @@ int build_ntlmssp_auth_blob(unsigned char **pbuffer,\n \tflags = NTLMSSP_NEGOTIATE_56 |\n \t\tNTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |\n \t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n-\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n-\tif (ses->server->sign) {\n+\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |\n+\t\tNTLMSSP_NEGOTIATE_SEAL;\n+\tif (ses->server->sign)\n \t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n-\t\tif (!ses->server->session_estab ||\n-\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n-\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n-\t}\n+\tif (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)\n+\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n \n \ttmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);\n \tsec_blob->NegotiateFlags = cpu_to_le32(flags);""}<_**next**_>{""sha"": ""b088c50271113224f8d3cb839923331f4735e204"", ""filename"": ""fs/cifs/smb2pdu.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 10, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/cabfb3680f78981d26c078a26e5c748531257ebb/fs/cifs/smb2pdu.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/cabfb3680f78981d26c078a26e5c748531257ebb/fs/cifs/smb2pdu.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/smb2pdu.c?ref=cabfb3680f78981d26c078a26e5c748531257ebb"", ""patch"": ""@@ -756,15 +756,13 @@ SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n \tstruct cifs_ses *ses = sess_data->ses;\n \n \tmutex_lock(&ses->server->srv_mutex);\n-\tif (ses->server->sign && ses->server->ops->generate_signingkey) {\n+\tif (ses->server->ops->generate_signingkey) {\n \t\trc = ses->server->ops->generate_signingkey(ses);\n-\t\tkfree(ses->auth_key.response);\n-\t\tses->auth_key.response = NULL;\n \t\tif (rc) {\n \t\t\tcifs_dbg(FYI,\n \t\t\t\t\""SMB3 session key generation failed\\n\"");\n \t\t\tmutex_unlock(&ses->server->srv_mutex);\n-\t\t\tgoto keygen_exit;\n+\t\t\treturn rc;\n \t\t}\n \t}\n \tif (!ses->server->session_estab) {\n@@ -778,12 +776,6 @@ SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n \tses->status = CifsGood;\n \tses->need_reconnect = false;\n \tspin_unlock(&GlobalMid_Lock);\n-\n-keygen_exit:\n-\tif (!ses->server->sign) {\n-\t\tkfree(ses->auth_key.response);\n-\t\tses->auth_key.response = NULL;\n-\t}\n \treturn rc;\n }\n ""}","SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)
{
	int rc = 0;
 	struct cifs_ses *ses = sess_data->ses;
 
 	mutex_lock(&ses->server->srv_mutex);
	if (ses->server->ops->generate_signingkey) {
 		rc = ses->server->ops->generate_signingkey(ses);
 		if (rc) {
 			cifs_dbg(FYI,
 				""SMB3 session key generation failed\n"");
 			mutex_unlock(&ses->server->srv_mutex);
			return rc;
 		}
 	}
 	if (!ses->server->session_estab) {
		ses->server->sequence_number = 0x2;
		ses->server->session_estab = true;
	}
	mutex_unlock(&ses->server->srv_mutex);

	cifs_dbg(FYI, ""SMB2/3 session established successfully\n"");
	spin_lock(&GlobalMid_Lock);
 	ses->status = CifsGood;
 	ses->need_reconnect = false;
 	spin_unlock(&GlobalMid_Lock);
 	return rc;
 }
","SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)
{
	int rc = 0;
 	struct cifs_ses *ses = sess_data->ses;
 
 	mutex_lock(&ses->server->srv_mutex);
	if (ses->server->sign && ses->server->ops->generate_signingkey) {
 		rc = ses->server->ops->generate_signingkey(ses);
		kfree(ses->auth_key.response);
		ses->auth_key.response = NULL;
 		if (rc) {
 			cifs_dbg(FYI,
 				""SMB3 session key generation failed\n"");
 			mutex_unlock(&ses->server->srv_mutex);
			goto keygen_exit;
 		}
 	}
 	if (!ses->server->session_estab) {
		ses->server->sequence_number = 0x2;
		ses->server->session_estab = true;
	}
	mutex_unlock(&ses->server->srv_mutex);

	cifs_dbg(FYI, ""SMB2/3 session established successfully\n"");
	spin_lock(&GlobalMid_Lock);
 	ses->status = CifsGood;
 	ses->need_reconnect = false;
 	spin_unlock(&GlobalMid_Lock);
keygen_exit:
	if (!ses->server->sign) {
		kfree(ses->auth_key.response);
		ses->auth_key.response = NULL;
	}
 	return rc;
 }
",C,"	if (ses->server->ops->generate_signingkey) {
			return rc;
","	if (ses->server->sign && ses->server->ops->generate_signingkey) {
		kfree(ses->auth_key.response);
		ses->auth_key.response = NULL;
			goto keygen_exit;
keygen_exit:
	if (!ses->server->sign) {
		kfree(ses->auth_key.response);
		ses->auth_key.response = NULL;
	}
",,"@@ -756,15 +756,13 @@ SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)
 	struct cifs_ses *ses = sess_data->ses;
 
 	mutex_lock(&ses->server->srv_mutex);
-	if (ses->server->sign && ses->server->ops->generate_signingkey) {
+	if (ses->server->ops->generate_signingkey) {
 		rc = ses->server->ops->generate_signingkey(ses);
-		kfree(ses->auth_key.response);
-		ses->auth_key.response = NULL;
 		if (rc) {
 			cifs_dbg(FYI,
 				""SMB3 session key generation failed\n"");
 			mutex_unlock(&ses->server->srv_mutex);
-			goto keygen_exit;
+			return rc;
 		}
 	}
 	if (!ses->server->session_estab) {
@@ -778,12 +776,6 @@ SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)
 	ses->status = CifsGood;
 	ses->need_reconnect = false;
 	spin_unlock(&GlobalMid_Lock);
-
-keygen_exit:
-	if (!ses->server->sign) {
-		kfree(ses->auth_key.response);
-		ses->auth_key.response = NULL;
-	}
 	return rc;
 }
 ",linux,cabfb3680f78981d26c078a26e5c748531257ebb,7fb8986e7449d0a5cebd84d059927afa423fbf85,1,"SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)
{
	int rc = 0;
 	struct cifs_ses *ses = sess_data->ses;
 
 	mutex_lock(&ses->server->srv_mutex);
//flaw_line_below:
	if (ses->server->sign && ses->server->ops->generate_signingkey) {
//fix_flaw_line_below:
//	if (ses->server->ops->generate_signingkey) {
 		rc = ses->server->ops->generate_signingkey(ses);
//flaw_line_below:
		kfree(ses->auth_key.response);
//flaw_line_below:
		ses->auth_key.response = NULL;
 		if (rc) {
 			cifs_dbg(FYI,
 				""SMB3 session key generation failed\n"");
 			mutex_unlock(&ses->server->srv_mutex);
//flaw_line_below:
			goto keygen_exit;
//fix_flaw_line_below:
//			return rc;
 		}
 	}
 	if (!ses->server->session_estab) {
		ses->server->sequence_number = 0x2;
		ses->server->session_estab = true;
	}
	mutex_unlock(&ses->server->srv_mutex);

	cifs_dbg(FYI, ""SMB2/3 session established successfully\n"");
	spin_lock(&GlobalMid_Lock);
 	ses->status = CifsGood;
 	ses->need_reconnect = false;
 	spin_unlock(&GlobalMid_Lock);
//flaw_line_below:

//flaw_line_below:
keygen_exit:
//flaw_line_below:
	if (!ses->server->sign) {
//flaw_line_below:
		kfree(ses->auth_key.response);
//flaw_line_below:
		ses->auth_key.response = NULL;
//flaw_line_below:
	}
 	return rc;
 }
"
4798,182534,,Local,Not required,Complete,CVE-2018-1065,https://www.cvedetails.com/cve/CVE-2018-1065/,CWE-476,Medium,,,,2018-03-02,4.7,"The netfilter subsystem in the Linux kernel through 4.15.7 mishandles the case of a rule blob that contains a jump but lacks a user-defined chain, which allows local users to cause a denial of service (NULL pointer dereference) by leveraging the CAP_NET_RAW or CAP_NET_ADMIN capability, related to arpt_do_table in net/ipv4/netfilter/arp_tables.c, ipt_do_table in net/ipv4/netfilter/ip_tables.c, and ip6t_do_table in net/ipv6/netfilter/ip6_tables.c.",2018-10-31,DoS ,4,https://github.com/torvalds/linux/commit/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8,57ebd808a97d7c5b1e1afb937c2db22beba3c1f8,"netfilter: add back stackpointer size checks

The rationale for removing the check is only correct for rulesets
generated by ip(6)tables.

In iptables, a jump can only occur to a user-defined chain, i.e.
because we size the stack based on number of user-defined chains we
cannot exceed stack size.

However, the underlying binary format has no such restriction,
and the validation step only ensures that the jump target is a
valid rule start point.

IOW, its possible to build a rule blob that has no user-defined
chains but does contain a jump.

If this happens, no jump stack gets allocated and crash occurs
because no jumpstack was allocated.

Fixes: 7814b6ec6d0d6 (""netfilter: xtables: don't save/restore jumpstack offset"")
Reported-by: syzbot+e783f671527912cd9403@syzkaller.appspotmail.com
Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",0,net/ipv4/netfilter/arp_tables.c,"{""sha"": ""e3e420f3ba7b2de96be867912695efb3ae2b193c"", ""filename"": ""net/ipv4/netfilter/arp_tables.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8/net/ipv4/netfilter/arp_tables.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8/net/ipv4/netfilter/arp_tables.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/netfilter/arp_tables.c?ref=57ebd808a97d7c5b1e1afb937c2db22beba3c1f8"", ""patch"": ""@@ -252,6 +252,10 @@ unsigned int arpt_do_table(struct sk_buff *skb,\n \t\t\t}\n \t\t\tif (table_base + v\n \t\t\t    != arpt_next_entry(e)) {\n+\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n+\t\t\t\t\tverdict = NF_DROP;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tjumpstack[stackidx++] = e;\n \t\t\t}\n ""}<_**next**_>{""sha"": ""e38395a8dcf2806677cde272f72b3809c4f404a8"", ""filename"": ""net/ipv4/netfilter/ip_tables.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8/net/ipv4/netfilter/ip_tables.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8/net/ipv4/netfilter/ip_tables.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/netfilter/ip_tables.c?ref=57ebd808a97d7c5b1e1afb937c2db22beba3c1f8"", ""patch"": ""@@ -330,8 +330,13 @@ ipt_do_table(struct sk_buff *skb,\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif (table_base + v != ipt_next_entry(e) &&\n-\t\t\t    !(e->ip.flags & IPT_F_GOTO))\n+\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n+\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n+\t\t\t\t\tverdict = NF_DROP;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tjumpstack[stackidx++] = e;\n+\t\t\t}\n \n \t\t\te = get_entry(table_base, v);\n \t\t\tcontinue;""}<_**next**_>{""sha"": ""62358b93bbac5250676a067464c11e4e3d649faa"", ""filename"": ""net/ipv6/netfilter/ip6_tables.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8/net/ipv6/netfilter/ip6_tables.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8/net/ipv6/netfilter/ip6_tables.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/netfilter/ip6_tables.c?ref=57ebd808a97d7c5b1e1afb937c2db22beba3c1f8"", ""patch"": ""@@ -352,6 +352,10 @@ ip6t_do_table(struct sk_buff *skb,\n \t\t\t}\n \t\t\tif (table_base + v != ip6t_next_entry(e) &&\n \t\t\t    !(e->ipv6.flags & IP6T_F_GOTO)) {\n+\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n+\t\t\t\t\tverdict = NF_DROP;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tjumpstack[stackidx++] = e;\n \t\t\t}\n ""}","unsigned int arpt_do_table(struct sk_buff *skb,
			   const struct nf_hook_state *state,
			   struct xt_table *table)
{
	unsigned int hook = state->hook;
	static const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));
	unsigned int verdict = NF_DROP;
	const struct arphdr *arp;
	struct arpt_entry *e, **jumpstack;
	const char *indev, *outdev;
	const void *table_base;
	unsigned int cpu, stackidx = 0;
	const struct xt_table_info *private;
	struct xt_action_param acpar;
	unsigned int addend;

	if (!pskb_may_pull(skb, arp_hdr_len(skb->dev)))
		return NF_DROP;

	indev = state->in ? state->in->name : nulldevname;
	outdev = state->out ? state->out->name : nulldevname;

	local_bh_disable();
	addend = xt_write_recseq_begin();
	private = READ_ONCE(table->private); /* Address dependency. */
	cpu     = smp_processor_id();
	table_base = private->entries;
	jumpstack  = (struct arpt_entry **)private->jumpstack[cpu];

	/* No TEE support for arptables, so no need to switch to alternate
	 * stack.  All targets that reenter must return absolute verdicts.
	 */
	e = get_entry(table_base, private->hook_entry[hook]);

	acpar.state   = state;
	acpar.hotdrop = false;

	arp = arp_hdr(skb);
	do {
		const struct xt_entry_target *t;
		struct xt_counters *counter;

		if (!arp_packet_match(arp, skb->dev, indev, outdev, &e->arp)) {
			e = arpt_next_entry(e);
			continue;
		}

		counter = xt_get_this_cpu_counter(&e->counters);
		ADD_COUNTER(*counter, arp_hdr_len(skb->dev), 1);

		t = arpt_get_target_c(e);

		/* Standard target? */
		if (!t->u.kernel.target->target) {
			int v;

			v = ((struct xt_standard_target *)t)->verdict;
			if (v < 0) {
				/* Pop from stack? */
				if (v != XT_RETURN) {
					verdict = (unsigned int)(-v) - 1;
					break;
				}
				if (stackidx == 0) {
					e = get_entry(table_base,
						      private->underflow[hook]);
				} else {
					e = jumpstack[--stackidx];
					e = arpt_next_entry(e);
				}
				continue;
 			}
 			if (table_base + v
 			    != arpt_next_entry(e)) {
				if (unlikely(stackidx >= private->stacksize)) {
					verdict = NF_DROP;
					break;
				}
 				jumpstack[stackidx++] = e;
 			}
 
			e = get_entry(table_base, v);
			continue;
		}

		acpar.target   = t->u.kernel.target;
		acpar.targinfo = t->data;
		verdict = t->u.kernel.target->target(skb, &acpar);

		if (verdict == XT_CONTINUE) {
			/* Target might have changed stuff. */
			arp = arp_hdr(skb);
			e = arpt_next_entry(e);
		} else {
			/* Verdict */
			break;
		}
	} while (!acpar.hotdrop);
	xt_write_recseq_end(addend);
	local_bh_enable();

	if (acpar.hotdrop)
		return NF_DROP;
	else
		return verdict;
}
","unsigned int arpt_do_table(struct sk_buff *skb,
			   const struct nf_hook_state *state,
			   struct xt_table *table)
{
	unsigned int hook = state->hook;
	static const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));
	unsigned int verdict = NF_DROP;
	const struct arphdr *arp;
	struct arpt_entry *e, **jumpstack;
	const char *indev, *outdev;
	const void *table_base;
	unsigned int cpu, stackidx = 0;
	const struct xt_table_info *private;
	struct xt_action_param acpar;
	unsigned int addend;

	if (!pskb_may_pull(skb, arp_hdr_len(skb->dev)))
		return NF_DROP;

	indev = state->in ? state->in->name : nulldevname;
	outdev = state->out ? state->out->name : nulldevname;

	local_bh_disable();
	addend = xt_write_recseq_begin();
	private = READ_ONCE(table->private); /* Address dependency. */
	cpu     = smp_processor_id();
	table_base = private->entries;
	jumpstack  = (struct arpt_entry **)private->jumpstack[cpu];

	/* No TEE support for arptables, so no need to switch to alternate
	 * stack.  All targets that reenter must return absolute verdicts.
	 */
	e = get_entry(table_base, private->hook_entry[hook]);

	acpar.state   = state;
	acpar.hotdrop = false;

	arp = arp_hdr(skb);
	do {
		const struct xt_entry_target *t;
		struct xt_counters *counter;

		if (!arp_packet_match(arp, skb->dev, indev, outdev, &e->arp)) {
			e = arpt_next_entry(e);
			continue;
		}

		counter = xt_get_this_cpu_counter(&e->counters);
		ADD_COUNTER(*counter, arp_hdr_len(skb->dev), 1);

		t = arpt_get_target_c(e);

		/* Standard target? */
		if (!t->u.kernel.target->target) {
			int v;

			v = ((struct xt_standard_target *)t)->verdict;
			if (v < 0) {
				/* Pop from stack? */
				if (v != XT_RETURN) {
					verdict = (unsigned int)(-v) - 1;
					break;
				}
				if (stackidx == 0) {
					e = get_entry(table_base,
						      private->underflow[hook]);
				} else {
					e = jumpstack[--stackidx];
					e = arpt_next_entry(e);
				}
				continue;
 			}
 			if (table_base + v
 			    != arpt_next_entry(e)) {
 				jumpstack[stackidx++] = e;
 			}
 
			e = get_entry(table_base, v);
			continue;
		}

		acpar.target   = t->u.kernel.target;
		acpar.targinfo = t->data;
		verdict = t->u.kernel.target->target(skb, &acpar);

		if (verdict == XT_CONTINUE) {
			/* Target might have changed stuff. */
			arp = arp_hdr(skb);
			e = arpt_next_entry(e);
		} else {
			/* Verdict */
			break;
		}
	} while (!acpar.hotdrop);
	xt_write_recseq_end(addend);
	local_bh_enable();

	if (acpar.hotdrop)
		return NF_DROP;
	else
		return verdict;
}
",C,"				if (unlikely(stackidx >= private->stacksize)) {
					verdict = NF_DROP;
					break;
				}
",,,"@@ -252,6 +252,10 @@ unsigned int arpt_do_table(struct sk_buff *skb,
 			}
 			if (table_base + v
 			    != arpt_next_entry(e)) {
+				if (unlikely(stackidx >= private->stacksize)) {
+					verdict = NF_DROP;
+					break;
+				}
 				jumpstack[stackidx++] = e;
 			}
 ",linux,57ebd808a97d7c5b1e1afb937c2db22beba3c1f8,01ea306f2ac2baff98d472da719193e738759d93,1,"unsigned int arpt_do_table(struct sk_buff *skb,
			   const struct nf_hook_state *state,
			   struct xt_table *table)
{
	unsigned int hook = state->hook;
	static const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));
	unsigned int verdict = NF_DROP;
	const struct arphdr *arp;
	struct arpt_entry *e, **jumpstack;
	const char *indev, *outdev;
	const void *table_base;
	unsigned int cpu, stackidx = 0;
	const struct xt_table_info *private;
	struct xt_action_param acpar;
	unsigned int addend;

	if (!pskb_may_pull(skb, arp_hdr_len(skb->dev)))
		return NF_DROP;

	indev = state->in ? state->in->name : nulldevname;
	outdev = state->out ? state->out->name : nulldevname;

	local_bh_disable();
	addend = xt_write_recseq_begin();
	private = READ_ONCE(table->private); /* Address dependency. */
	cpu     = smp_processor_id();
	table_base = private->entries;
	jumpstack  = (struct arpt_entry **)private->jumpstack[cpu];

	/* No TEE support for arptables, so no need to switch to alternate
	 * stack.  All targets that reenter must return absolute verdicts.
	 */
	e = get_entry(table_base, private->hook_entry[hook]);

	acpar.state   = state;
	acpar.hotdrop = false;

	arp = arp_hdr(skb);
	do {
		const struct xt_entry_target *t;
		struct xt_counters *counter;

		if (!arp_packet_match(arp, skb->dev, indev, outdev, &e->arp)) {
			e = arpt_next_entry(e);
			continue;
		}

		counter = xt_get_this_cpu_counter(&e->counters);
		ADD_COUNTER(*counter, arp_hdr_len(skb->dev), 1);

		t = arpt_get_target_c(e);

		/* Standard target? */
		if (!t->u.kernel.target->target) {
			int v;

			v = ((struct xt_standard_target *)t)->verdict;
			if (v < 0) {
				/* Pop from stack? */
				if (v != XT_RETURN) {
					verdict = (unsigned int)(-v) - 1;
					break;
				}
				if (stackidx == 0) {
					e = get_entry(table_base,
						      private->underflow[hook]);
				} else {
					e = jumpstack[--stackidx];
					e = arpt_next_entry(e);
				}
				continue;
 			}
 			if (table_base + v
 			    != arpt_next_entry(e)) {
//fix_flaw_line_below:
//				if (unlikely(stackidx >= private->stacksize)) {
//fix_flaw_line_below:
//					verdict = NF_DROP;
//fix_flaw_line_below:
//					break;
//fix_flaw_line_below:
//				}
 				jumpstack[stackidx++] = e;
 			}
 
			e = get_entry(table_base, v);
			continue;
		}

		acpar.target   = t->u.kernel.target;
		acpar.targinfo = t->data;
		verdict = t->u.kernel.target->target(skb, &acpar);

		if (verdict == XT_CONTINUE) {
			/* Target might have changed stuff. */
			arp = arp_hdr(skb);
			e = arpt_next_entry(e);
		} else {
			/* Verdict */
			break;
		}
	} while (!acpar.hotdrop);
	xt_write_recseq_end(addend);
	local_bh_enable();

	if (acpar.hotdrop)
		return NF_DROP;
	else
		return verdict;
}
"
4799,182535,,Local,Not required,Complete,CVE-2018-1065,https://www.cvedetails.com/cve/CVE-2018-1065/,CWE-476,Medium,,,,2018-03-02,4.7,"The netfilter subsystem in the Linux kernel through 4.15.7 mishandles the case of a rule blob that contains a jump but lacks a user-defined chain, which allows local users to cause a denial of service (NULL pointer dereference) by leveraging the CAP_NET_RAW or CAP_NET_ADMIN capability, related to arpt_do_table in net/ipv4/netfilter/arp_tables.c, ipt_do_table in net/ipv4/netfilter/ip_tables.c, and ip6t_do_table in net/ipv6/netfilter/ip6_tables.c.",2018-10-31,DoS ,6,https://github.com/torvalds/linux/commit/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8,57ebd808a97d7c5b1e1afb937c2db22beba3c1f8,"netfilter: add back stackpointer size checks

The rationale for removing the check is only correct for rulesets
generated by ip(6)tables.

In iptables, a jump can only occur to a user-defined chain, i.e.
because we size the stack based on number of user-defined chains we
cannot exceed stack size.

However, the underlying binary format has no such restriction,
and the validation step only ensures that the jump target is a
valid rule start point.

IOW, its possible to build a rule blob that has no user-defined
chains but does contain a jump.

If this happens, no jump stack gets allocated and crash occurs
because no jumpstack was allocated.

Fixes: 7814b6ec6d0d6 (""netfilter: xtables: don't save/restore jumpstack offset"")
Reported-by: syzbot+e783f671527912cd9403@syzkaller.appspotmail.com
Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",1,net/ipv4/netfilter/ip_tables.c,"{""sha"": ""e3e420f3ba7b2de96be867912695efb3ae2b193c"", ""filename"": ""net/ipv4/netfilter/arp_tables.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8/net/ipv4/netfilter/arp_tables.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8/net/ipv4/netfilter/arp_tables.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/netfilter/arp_tables.c?ref=57ebd808a97d7c5b1e1afb937c2db22beba3c1f8"", ""patch"": ""@@ -252,6 +252,10 @@ unsigned int arpt_do_table(struct sk_buff *skb,\n \t\t\t}\n \t\t\tif (table_base + v\n \t\t\t    != arpt_next_entry(e)) {\n+\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n+\t\t\t\t\tverdict = NF_DROP;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tjumpstack[stackidx++] = e;\n \t\t\t}\n ""}<_**next**_>{""sha"": ""e38395a8dcf2806677cde272f72b3809c4f404a8"", ""filename"": ""net/ipv4/netfilter/ip_tables.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8/net/ipv4/netfilter/ip_tables.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8/net/ipv4/netfilter/ip_tables.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/netfilter/ip_tables.c?ref=57ebd808a97d7c5b1e1afb937c2db22beba3c1f8"", ""patch"": ""@@ -330,8 +330,13 @@ ipt_do_table(struct sk_buff *skb,\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif (table_base + v != ipt_next_entry(e) &&\n-\t\t\t    !(e->ip.flags & IPT_F_GOTO))\n+\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n+\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n+\t\t\t\t\tverdict = NF_DROP;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tjumpstack[stackidx++] = e;\n+\t\t\t}\n \n \t\t\te = get_entry(table_base, v);\n \t\t\tcontinue;""}<_**next**_>{""sha"": ""62358b93bbac5250676a067464c11e4e3d649faa"", ""filename"": ""net/ipv6/netfilter/ip6_tables.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8/net/ipv6/netfilter/ip6_tables.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8/net/ipv6/netfilter/ip6_tables.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/netfilter/ip6_tables.c?ref=57ebd808a97d7c5b1e1afb937c2db22beba3c1f8"", ""patch"": ""@@ -352,6 +352,10 @@ ip6t_do_table(struct sk_buff *skb,\n \t\t\t}\n \t\t\tif (table_base + v != ip6t_next_entry(e) &&\n \t\t\t    !(e->ipv6.flags & IP6T_F_GOTO)) {\n+\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n+\t\t\t\t\tverdict = NF_DROP;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tjumpstack[stackidx++] = e;\n \t\t\t}\n ""}","ipt_do_table(struct sk_buff *skb,
	     const struct nf_hook_state *state,
	     struct xt_table *table)
{
	unsigned int hook = state->hook;
	static const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));
	const struct iphdr *ip;
	/* Initializing verdict to NF_DROP keeps gcc happy. */
	unsigned int verdict = NF_DROP;
	const char *indev, *outdev;
	const void *table_base;
	struct ipt_entry *e, **jumpstack;
	unsigned int stackidx, cpu;
	const struct xt_table_info *private;
	struct xt_action_param acpar;
	unsigned int addend;

	/* Initialization */
	stackidx = 0;
	ip = ip_hdr(skb);
	indev = state->in ? state->in->name : nulldevname;
	outdev = state->out ? state->out->name : nulldevname;
	/* We handle fragments by dealing with the first fragment as
	 * if it was a normal packet.  All other fragments are treated
	 * normally, except that they will NEVER match rules that ask
	 * things we don't know, ie. tcp syn flag or ports).  If the
	 * rule is also a fragment-specific rule, non-fragments won't
	 * match it. */
	acpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;
	acpar.thoff   = ip_hdrlen(skb);
	acpar.hotdrop = false;
	acpar.state   = state;

	WARN_ON(!(table->valid_hooks & (1 << hook)));
	local_bh_disable();
	addend = xt_write_recseq_begin();
	private = READ_ONCE(table->private); /* Address dependency. */
	cpu        = smp_processor_id();
	table_base = private->entries;
	jumpstack  = (struct ipt_entry **)private->jumpstack[cpu];

	/* Switch to alternate jumpstack if we're being invoked via TEE.
	 * TEE issues XT_CONTINUE verdict on original skb so we must not
	 * clobber the jumpstack.
	 *
	 * For recursion via REJECT or SYNPROXY the stack will be clobbered
	 * but it is no problem since absolute verdict is issued by these.
	 */
	if (static_key_false(&xt_tee_enabled))
		jumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);

	e = get_entry(table_base, private->hook_entry[hook]);

	do {
		const struct xt_entry_target *t;
		const struct xt_entry_match *ematch;
		struct xt_counters *counter;

		WARN_ON(!e);
		if (!ip_packet_match(ip, indev, outdev,
		    &e->ip, acpar.fragoff)) {
 no_match:
			e = ipt_next_entry(e);
			continue;
		}

		xt_ematch_foreach(ematch, e) {
			acpar.match     = ematch->u.kernel.match;
			acpar.matchinfo = ematch->data;
			if (!acpar.match->match(skb, &acpar))
				goto no_match;
		}

		counter = xt_get_this_cpu_counter(&e->counters);
		ADD_COUNTER(*counter, skb->len, 1);

		t = ipt_get_target(e);
		WARN_ON(!t->u.kernel.target);

#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)
		/* The packet is traced: log it */
		if (unlikely(skb->nf_trace))
			trace_packet(state->net, skb, hook, state->in,
				     state->out, table->name, private, e);
#endif
		/* Standard target? */
		if (!t->u.kernel.target->target) {
			int v;

			v = ((struct xt_standard_target *)t)->verdict;
			if (v < 0) {
				/* Pop from stack? */
				if (v != XT_RETURN) {
					verdict = (unsigned int)(-v) - 1;
					break;
				}
				if (stackidx == 0) {
					e = get_entry(table_base,
					    private->underflow[hook]);
				} else {
					e = jumpstack[--stackidx];
					e = ipt_next_entry(e);
				}
 				continue;
 			}
 			if (table_base + v != ipt_next_entry(e) &&
			    !(e->ip.flags & IPT_F_GOTO)) {
				if (unlikely(stackidx >= private->stacksize)) {
					verdict = NF_DROP;
					break;
				}
 				jumpstack[stackidx++] = e;
			}
 
 			e = get_entry(table_base, v);
 			continue;
		}

		acpar.target   = t->u.kernel.target;
		acpar.targinfo = t->data;

		verdict = t->u.kernel.target->target(skb, &acpar);
		if (verdict == XT_CONTINUE) {
			/* Target might have changed stuff. */
			ip = ip_hdr(skb);
			e = ipt_next_entry(e);
		} else {
			/* Verdict */
			break;
		}
	} while (!acpar.hotdrop);

	xt_write_recseq_end(addend);
	local_bh_enable();

	if (acpar.hotdrop)
		return NF_DROP;
	else return verdict;
}
","ipt_do_table(struct sk_buff *skb,
	     const struct nf_hook_state *state,
	     struct xt_table *table)
{
	unsigned int hook = state->hook;
	static const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));
	const struct iphdr *ip;
	/* Initializing verdict to NF_DROP keeps gcc happy. */
	unsigned int verdict = NF_DROP;
	const char *indev, *outdev;
	const void *table_base;
	struct ipt_entry *e, **jumpstack;
	unsigned int stackidx, cpu;
	const struct xt_table_info *private;
	struct xt_action_param acpar;
	unsigned int addend;

	/* Initialization */
	stackidx = 0;
	ip = ip_hdr(skb);
	indev = state->in ? state->in->name : nulldevname;
	outdev = state->out ? state->out->name : nulldevname;
	/* We handle fragments by dealing with the first fragment as
	 * if it was a normal packet.  All other fragments are treated
	 * normally, except that they will NEVER match rules that ask
	 * things we don't know, ie. tcp syn flag or ports).  If the
	 * rule is also a fragment-specific rule, non-fragments won't
	 * match it. */
	acpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;
	acpar.thoff   = ip_hdrlen(skb);
	acpar.hotdrop = false;
	acpar.state   = state;

	WARN_ON(!(table->valid_hooks & (1 << hook)));
	local_bh_disable();
	addend = xt_write_recseq_begin();
	private = READ_ONCE(table->private); /* Address dependency. */
	cpu        = smp_processor_id();
	table_base = private->entries;
	jumpstack  = (struct ipt_entry **)private->jumpstack[cpu];

	/* Switch to alternate jumpstack if we're being invoked via TEE.
	 * TEE issues XT_CONTINUE verdict on original skb so we must not
	 * clobber the jumpstack.
	 *
	 * For recursion via REJECT or SYNPROXY the stack will be clobbered
	 * but it is no problem since absolute verdict is issued by these.
	 */
	if (static_key_false(&xt_tee_enabled))
		jumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);

	e = get_entry(table_base, private->hook_entry[hook]);

	do {
		const struct xt_entry_target *t;
		const struct xt_entry_match *ematch;
		struct xt_counters *counter;

		WARN_ON(!e);
		if (!ip_packet_match(ip, indev, outdev,
		    &e->ip, acpar.fragoff)) {
 no_match:
			e = ipt_next_entry(e);
			continue;
		}

		xt_ematch_foreach(ematch, e) {
			acpar.match     = ematch->u.kernel.match;
			acpar.matchinfo = ematch->data;
			if (!acpar.match->match(skb, &acpar))
				goto no_match;
		}

		counter = xt_get_this_cpu_counter(&e->counters);
		ADD_COUNTER(*counter, skb->len, 1);

		t = ipt_get_target(e);
		WARN_ON(!t->u.kernel.target);

#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)
		/* The packet is traced: log it */
		if (unlikely(skb->nf_trace))
			trace_packet(state->net, skb, hook, state->in,
				     state->out, table->name, private, e);
#endif
		/* Standard target? */
		if (!t->u.kernel.target->target) {
			int v;

			v = ((struct xt_standard_target *)t)->verdict;
			if (v < 0) {
				/* Pop from stack? */
				if (v != XT_RETURN) {
					verdict = (unsigned int)(-v) - 1;
					break;
				}
				if (stackidx == 0) {
					e = get_entry(table_base,
					    private->underflow[hook]);
				} else {
					e = jumpstack[--stackidx];
					e = ipt_next_entry(e);
				}
 				continue;
 			}
 			if (table_base + v != ipt_next_entry(e) &&
			    !(e->ip.flags & IPT_F_GOTO))
 				jumpstack[stackidx++] = e;
 
 			e = get_entry(table_base, v);
 			continue;
		}

		acpar.target   = t->u.kernel.target;
		acpar.targinfo = t->data;

		verdict = t->u.kernel.target->target(skb, &acpar);
		if (verdict == XT_CONTINUE) {
			/* Target might have changed stuff. */
			ip = ip_hdr(skb);
			e = ipt_next_entry(e);
		} else {
			/* Verdict */
			break;
		}
	} while (!acpar.hotdrop);

	xt_write_recseq_end(addend);
	local_bh_enable();

	if (acpar.hotdrop)
		return NF_DROP;
	else return verdict;
}
",C,"			    !(e->ip.flags & IPT_F_GOTO)) {
				if (unlikely(stackidx >= private->stacksize)) {
					verdict = NF_DROP;
					break;
				}
			}
","			    !(e->ip.flags & IPT_F_GOTO))
",,"@@ -330,8 +330,13 @@ ipt_do_table(struct sk_buff *skb,
 				continue;
 			}
 			if (table_base + v != ipt_next_entry(e) &&
-			    !(e->ip.flags & IPT_F_GOTO))
+			    !(e->ip.flags & IPT_F_GOTO)) {
+				if (unlikely(stackidx >= private->stacksize)) {
+					verdict = NF_DROP;
+					break;
+				}
 				jumpstack[stackidx++] = e;
+			}
 
 			e = get_entry(table_base, v);
 			continue;",linux,57ebd808a97d7c5b1e1afb937c2db22beba3c1f8,01ea306f2ac2baff98d472da719193e738759d93,1,"ipt_do_table(struct sk_buff *skb,
	     const struct nf_hook_state *state,
	     struct xt_table *table)
{
	unsigned int hook = state->hook;
	static const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));
	const struct iphdr *ip;
	/* Initializing verdict to NF_DROP keeps gcc happy. */
	unsigned int verdict = NF_DROP;
	const char *indev, *outdev;
	const void *table_base;
	struct ipt_entry *e, **jumpstack;
	unsigned int stackidx, cpu;
	const struct xt_table_info *private;
	struct xt_action_param acpar;
	unsigned int addend;

	/* Initialization */
	stackidx = 0;
	ip = ip_hdr(skb);
	indev = state->in ? state->in->name : nulldevname;
	outdev = state->out ? state->out->name : nulldevname;
	/* We handle fragments by dealing with the first fragment as
	 * if it was a normal packet.  All other fragments are treated
	 * normally, except that they will NEVER match rules that ask
	 * things we don't know, ie. tcp syn flag or ports).  If the
	 * rule is also a fragment-specific rule, non-fragments won't
	 * match it. */
	acpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;
	acpar.thoff   = ip_hdrlen(skb);
	acpar.hotdrop = false;
	acpar.state   = state;

	WARN_ON(!(table->valid_hooks & (1 << hook)));
	local_bh_disable();
	addend = xt_write_recseq_begin();
	private = READ_ONCE(table->private); /* Address dependency. */
	cpu        = smp_processor_id();
	table_base = private->entries;
	jumpstack  = (struct ipt_entry **)private->jumpstack[cpu];

	/* Switch to alternate jumpstack if we're being invoked via TEE.
	 * TEE issues XT_CONTINUE verdict on original skb so we must not
	 * clobber the jumpstack.
	 *
	 * For recursion via REJECT or SYNPROXY the stack will be clobbered
	 * but it is no problem since absolute verdict is issued by these.
	 */
	if (static_key_false(&xt_tee_enabled))
		jumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);

	e = get_entry(table_base, private->hook_entry[hook]);

	do {
		const struct xt_entry_target *t;
		const struct xt_entry_match *ematch;
		struct xt_counters *counter;

		WARN_ON(!e);
		if (!ip_packet_match(ip, indev, outdev,
		    &e->ip, acpar.fragoff)) {
 no_match:
			e = ipt_next_entry(e);
			continue;
		}

		xt_ematch_foreach(ematch, e) {
			acpar.match     = ematch->u.kernel.match;
			acpar.matchinfo = ematch->data;
			if (!acpar.match->match(skb, &acpar))
				goto no_match;
		}

		counter = xt_get_this_cpu_counter(&e->counters);
		ADD_COUNTER(*counter, skb->len, 1);

		t = ipt_get_target(e);
		WARN_ON(!t->u.kernel.target);

#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)
		/* The packet is traced: log it */
		if (unlikely(skb->nf_trace))
			trace_packet(state->net, skb, hook, state->in,
				     state->out, table->name, private, e);
#endif
		/* Standard target? */
		if (!t->u.kernel.target->target) {
			int v;

			v = ((struct xt_standard_target *)t)->verdict;
			if (v < 0) {
				/* Pop from stack? */
				if (v != XT_RETURN) {
					verdict = (unsigned int)(-v) - 1;
					break;
				}
				if (stackidx == 0) {
					e = get_entry(table_base,
					    private->underflow[hook]);
				} else {
					e = jumpstack[--stackidx];
					e = ipt_next_entry(e);
				}
 				continue;
 			}
 			if (table_base + v != ipt_next_entry(e) &&
//flaw_line_below:
			    !(e->ip.flags & IPT_F_GOTO))
//fix_flaw_line_below:
//			    !(e->ip.flags & IPT_F_GOTO)) {
//fix_flaw_line_below:
//				if (unlikely(stackidx >= private->stacksize)) {
//fix_flaw_line_below:
//					verdict = NF_DROP;
//fix_flaw_line_below:
//					break;
//fix_flaw_line_below:
//				}
 				jumpstack[stackidx++] = e;
//fix_flaw_line_below:
//			}
 
 			e = get_entry(table_base, v);
 			continue;
		}

		acpar.target   = t->u.kernel.target;
		acpar.targinfo = t->data;

		verdict = t->u.kernel.target->target(skb, &acpar);
		if (verdict == XT_CONTINUE) {
			/* Target might have changed stuff. */
			ip = ip_hdr(skb);
			e = ipt_next_entry(e);
		} else {
			/* Verdict */
			break;
		}
	} while (!acpar.hotdrop);

	xt_write_recseq_end(addend);
	local_bh_enable();

	if (acpar.hotdrop)
		return NF_DROP;
	else return verdict;
}
"
4800,182536,,Local,Not required,Complete,CVE-2018-1065,https://www.cvedetails.com/cve/CVE-2018-1065/,CWE-476,Medium,,,,2018-03-02,4.7,"The netfilter subsystem in the Linux kernel through 4.15.7 mishandles the case of a rule blob that contains a jump but lacks a user-defined chain, which allows local users to cause a denial of service (NULL pointer dereference) by leveraging the CAP_NET_RAW or CAP_NET_ADMIN capability, related to arpt_do_table in net/ipv4/netfilter/arp_tables.c, ipt_do_table in net/ipv4/netfilter/ip_tables.c, and ip6t_do_table in net/ipv6/netfilter/ip6_tables.c.",2018-10-31,DoS ,4,https://github.com/torvalds/linux/commit/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8,57ebd808a97d7c5b1e1afb937c2db22beba3c1f8,"netfilter: add back stackpointer size checks

The rationale for removing the check is only correct for rulesets
generated by ip(6)tables.

In iptables, a jump can only occur to a user-defined chain, i.e.
because we size the stack based on number of user-defined chains we
cannot exceed stack size.

However, the underlying binary format has no such restriction,
and the validation step only ensures that the jump target is a
valid rule start point.

IOW, its possible to build a rule blob that has no user-defined
chains but does contain a jump.

If this happens, no jump stack gets allocated and crash occurs
because no jumpstack was allocated.

Fixes: 7814b6ec6d0d6 (""netfilter: xtables: don't save/restore jumpstack offset"")
Reported-by: syzbot+e783f671527912cd9403@syzkaller.appspotmail.com
Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",0,net/ipv6/netfilter/ip6_tables.c,"{""sha"": ""e3e420f3ba7b2de96be867912695efb3ae2b193c"", ""filename"": ""net/ipv4/netfilter/arp_tables.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8/net/ipv4/netfilter/arp_tables.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8/net/ipv4/netfilter/arp_tables.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/netfilter/arp_tables.c?ref=57ebd808a97d7c5b1e1afb937c2db22beba3c1f8"", ""patch"": ""@@ -252,6 +252,10 @@ unsigned int arpt_do_table(struct sk_buff *skb,\n \t\t\t}\n \t\t\tif (table_base + v\n \t\t\t    != arpt_next_entry(e)) {\n+\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n+\t\t\t\t\tverdict = NF_DROP;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tjumpstack[stackidx++] = e;\n \t\t\t}\n ""}<_**next**_>{""sha"": ""e38395a8dcf2806677cde272f72b3809c4f404a8"", ""filename"": ""net/ipv4/netfilter/ip_tables.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8/net/ipv4/netfilter/ip_tables.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8/net/ipv4/netfilter/ip_tables.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/netfilter/ip_tables.c?ref=57ebd808a97d7c5b1e1afb937c2db22beba3c1f8"", ""patch"": ""@@ -330,8 +330,13 @@ ipt_do_table(struct sk_buff *skb,\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif (table_base + v != ipt_next_entry(e) &&\n-\t\t\t    !(e->ip.flags & IPT_F_GOTO))\n+\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n+\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n+\t\t\t\t\tverdict = NF_DROP;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tjumpstack[stackidx++] = e;\n+\t\t\t}\n \n \t\t\te = get_entry(table_base, v);\n \t\t\tcontinue;""}<_**next**_>{""sha"": ""62358b93bbac5250676a067464c11e4e3d649faa"", ""filename"": ""net/ipv6/netfilter/ip6_tables.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8/net/ipv6/netfilter/ip6_tables.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8/net/ipv6/netfilter/ip6_tables.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/netfilter/ip6_tables.c?ref=57ebd808a97d7c5b1e1afb937c2db22beba3c1f8"", ""patch"": ""@@ -352,6 +352,10 @@ ip6t_do_table(struct sk_buff *skb,\n \t\t\t}\n \t\t\tif (table_base + v != ip6t_next_entry(e) &&\n \t\t\t    !(e->ipv6.flags & IP6T_F_GOTO)) {\n+\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n+\t\t\t\t\tverdict = NF_DROP;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tjumpstack[stackidx++] = e;\n \t\t\t}\n ""}","ip6t_do_table(struct sk_buff *skb,
	      const struct nf_hook_state *state,
	      struct xt_table *table)
{
	unsigned int hook = state->hook;
	static const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));
	/* Initializing verdict to NF_DROP keeps gcc happy. */
	unsigned int verdict = NF_DROP;
	const char *indev, *outdev;
	const void *table_base;
	struct ip6t_entry *e, **jumpstack;
	unsigned int stackidx, cpu;
	const struct xt_table_info *private;
	struct xt_action_param acpar;
	unsigned int addend;

	/* Initialization */
	stackidx = 0;
	indev = state->in ? state->in->name : nulldevname;
	outdev = state->out ? state->out->name : nulldevname;
	/* We handle fragments by dealing with the first fragment as
	 * if it was a normal packet.  All other fragments are treated
	 * normally, except that they will NEVER match rules that ask
	 * things we don't know, ie. tcp syn flag or ports).  If the
	 * rule is also a fragment-specific rule, non-fragments won't
	 * match it. */
	acpar.hotdrop = false;
	acpar.state   = state;

	WARN_ON(!(table->valid_hooks & (1 << hook)));

	local_bh_disable();
	addend = xt_write_recseq_begin();
	private = READ_ONCE(table->private); /* Address dependency. */
	cpu        = smp_processor_id();
	table_base = private->entries;
	jumpstack  = (struct ip6t_entry **)private->jumpstack[cpu];

	/* Switch to alternate jumpstack if we're being invoked via TEE.
	 * TEE issues XT_CONTINUE verdict on original skb so we must not
	 * clobber the jumpstack.
	 *
	 * For recursion via REJECT or SYNPROXY the stack will be clobbered
	 * but it is no problem since absolute verdict is issued by these.
	 */
	if (static_key_false(&xt_tee_enabled))
		jumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);

	e = get_entry(table_base, private->hook_entry[hook]);

	do {
		const struct xt_entry_target *t;
		const struct xt_entry_match *ematch;
		struct xt_counters *counter;

		WARN_ON(!e);
		acpar.thoff = 0;
		if (!ip6_packet_match(skb, indev, outdev, &e->ipv6,
		    &acpar.thoff, &acpar.fragoff, &acpar.hotdrop)) {
 no_match:
			e = ip6t_next_entry(e);
			continue;
		}

		xt_ematch_foreach(ematch, e) {
			acpar.match     = ematch->u.kernel.match;
			acpar.matchinfo = ematch->data;
			if (!acpar.match->match(skb, &acpar))
				goto no_match;
		}

		counter = xt_get_this_cpu_counter(&e->counters);
		ADD_COUNTER(*counter, skb->len, 1);

		t = ip6t_get_target_c(e);
		WARN_ON(!t->u.kernel.target);

#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)
		/* The packet is traced: log it */
		if (unlikely(skb->nf_trace))
			trace_packet(state->net, skb, hook, state->in,
				     state->out, table->name, private, e);
#endif
		/* Standard target? */
		if (!t->u.kernel.target->target) {
			int v;

			v = ((struct xt_standard_target *)t)->verdict;
			if (v < 0) {
				/* Pop from stack? */
				if (v != XT_RETURN) {
					verdict = (unsigned int)(-v) - 1;
					break;
				}
				if (stackidx == 0)
					e = get_entry(table_base,
					    private->underflow[hook]);
				else
					e = ip6t_next_entry(jumpstack[--stackidx]);
				continue;
 			}
 			if (table_base + v != ip6t_next_entry(e) &&
 			    !(e->ipv6.flags & IP6T_F_GOTO)) {
				if (unlikely(stackidx >= private->stacksize)) {
					verdict = NF_DROP;
					break;
				}
 				jumpstack[stackidx++] = e;
 			}
 
			e = get_entry(table_base, v);
			continue;
		}

		acpar.target   = t->u.kernel.target;
		acpar.targinfo = t->data;

		verdict = t->u.kernel.target->target(skb, &acpar);
		if (verdict == XT_CONTINUE)
			e = ip6t_next_entry(e);
		else
			/* Verdict */
			break;
	} while (!acpar.hotdrop);

	xt_write_recseq_end(addend);
	local_bh_enable();

	if (acpar.hotdrop)
		return NF_DROP;
	else return verdict;
}
","ip6t_do_table(struct sk_buff *skb,
	      const struct nf_hook_state *state,
	      struct xt_table *table)
{
	unsigned int hook = state->hook;
	static const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));
	/* Initializing verdict to NF_DROP keeps gcc happy. */
	unsigned int verdict = NF_DROP;
	const char *indev, *outdev;
	const void *table_base;
	struct ip6t_entry *e, **jumpstack;
	unsigned int stackidx, cpu;
	const struct xt_table_info *private;
	struct xt_action_param acpar;
	unsigned int addend;

	/* Initialization */
	stackidx = 0;
	indev = state->in ? state->in->name : nulldevname;
	outdev = state->out ? state->out->name : nulldevname;
	/* We handle fragments by dealing with the first fragment as
	 * if it was a normal packet.  All other fragments are treated
	 * normally, except that they will NEVER match rules that ask
	 * things we don't know, ie. tcp syn flag or ports).  If the
	 * rule is also a fragment-specific rule, non-fragments won't
	 * match it. */
	acpar.hotdrop = false;
	acpar.state   = state;

	WARN_ON(!(table->valid_hooks & (1 << hook)));

	local_bh_disable();
	addend = xt_write_recseq_begin();
	private = READ_ONCE(table->private); /* Address dependency. */
	cpu        = smp_processor_id();
	table_base = private->entries;
	jumpstack  = (struct ip6t_entry **)private->jumpstack[cpu];

	/* Switch to alternate jumpstack if we're being invoked via TEE.
	 * TEE issues XT_CONTINUE verdict on original skb so we must not
	 * clobber the jumpstack.
	 *
	 * For recursion via REJECT or SYNPROXY the stack will be clobbered
	 * but it is no problem since absolute verdict is issued by these.
	 */
	if (static_key_false(&xt_tee_enabled))
		jumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);

	e = get_entry(table_base, private->hook_entry[hook]);

	do {
		const struct xt_entry_target *t;
		const struct xt_entry_match *ematch;
		struct xt_counters *counter;

		WARN_ON(!e);
		acpar.thoff = 0;
		if (!ip6_packet_match(skb, indev, outdev, &e->ipv6,
		    &acpar.thoff, &acpar.fragoff, &acpar.hotdrop)) {
 no_match:
			e = ip6t_next_entry(e);
			continue;
		}

		xt_ematch_foreach(ematch, e) {
			acpar.match     = ematch->u.kernel.match;
			acpar.matchinfo = ematch->data;
			if (!acpar.match->match(skb, &acpar))
				goto no_match;
		}

		counter = xt_get_this_cpu_counter(&e->counters);
		ADD_COUNTER(*counter, skb->len, 1);

		t = ip6t_get_target_c(e);
		WARN_ON(!t->u.kernel.target);

#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)
		/* The packet is traced: log it */
		if (unlikely(skb->nf_trace))
			trace_packet(state->net, skb, hook, state->in,
				     state->out, table->name, private, e);
#endif
		/* Standard target? */
		if (!t->u.kernel.target->target) {
			int v;

			v = ((struct xt_standard_target *)t)->verdict;
			if (v < 0) {
				/* Pop from stack? */
				if (v != XT_RETURN) {
					verdict = (unsigned int)(-v) - 1;
					break;
				}
				if (stackidx == 0)
					e = get_entry(table_base,
					    private->underflow[hook]);
				else
					e = ip6t_next_entry(jumpstack[--stackidx]);
				continue;
 			}
 			if (table_base + v != ip6t_next_entry(e) &&
 			    !(e->ipv6.flags & IP6T_F_GOTO)) {
 				jumpstack[stackidx++] = e;
 			}
 
			e = get_entry(table_base, v);
			continue;
		}

		acpar.target   = t->u.kernel.target;
		acpar.targinfo = t->data;

		verdict = t->u.kernel.target->target(skb, &acpar);
		if (verdict == XT_CONTINUE)
			e = ip6t_next_entry(e);
		else
			/* Verdict */
			break;
	} while (!acpar.hotdrop);

	xt_write_recseq_end(addend);
	local_bh_enable();

	if (acpar.hotdrop)
		return NF_DROP;
	else return verdict;
}
",C,"				if (unlikely(stackidx >= private->stacksize)) {
					verdict = NF_DROP;
					break;
				}
",,,"@@ -352,6 +352,10 @@ ip6t_do_table(struct sk_buff *skb,
 			}
 			if (table_base + v != ip6t_next_entry(e) &&
 			    !(e->ipv6.flags & IP6T_F_GOTO)) {
+				if (unlikely(stackidx >= private->stacksize)) {
+					verdict = NF_DROP;
+					break;
+				}
 				jumpstack[stackidx++] = e;
 			}
 ",linux,57ebd808a97d7c5b1e1afb937c2db22beba3c1f8,01ea306f2ac2baff98d472da719193e738759d93,1,"ip6t_do_table(struct sk_buff *skb,
	      const struct nf_hook_state *state,
	      struct xt_table *table)
{
	unsigned int hook = state->hook;
	static const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));
	/* Initializing verdict to NF_DROP keeps gcc happy. */
	unsigned int verdict = NF_DROP;
	const char *indev, *outdev;
	const void *table_base;
	struct ip6t_entry *e, **jumpstack;
	unsigned int stackidx, cpu;
	const struct xt_table_info *private;
	struct xt_action_param acpar;
	unsigned int addend;

	/* Initialization */
	stackidx = 0;
	indev = state->in ? state->in->name : nulldevname;
	outdev = state->out ? state->out->name : nulldevname;
	/* We handle fragments by dealing with the first fragment as
	 * if it was a normal packet.  All other fragments are treated
	 * normally, except that they will NEVER match rules that ask
	 * things we don't know, ie. tcp syn flag or ports).  If the
	 * rule is also a fragment-specific rule, non-fragments won't
	 * match it. */
	acpar.hotdrop = false;
	acpar.state   = state;

	WARN_ON(!(table->valid_hooks & (1 << hook)));

	local_bh_disable();
	addend = xt_write_recseq_begin();
	private = READ_ONCE(table->private); /* Address dependency. */
	cpu        = smp_processor_id();
	table_base = private->entries;
	jumpstack  = (struct ip6t_entry **)private->jumpstack[cpu];

	/* Switch to alternate jumpstack if we're being invoked via TEE.
	 * TEE issues XT_CONTINUE verdict on original skb so we must not
	 * clobber the jumpstack.
	 *
	 * For recursion via REJECT or SYNPROXY the stack will be clobbered
	 * but it is no problem since absolute verdict is issued by these.
	 */
	if (static_key_false(&xt_tee_enabled))
		jumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);

	e = get_entry(table_base, private->hook_entry[hook]);

	do {
		const struct xt_entry_target *t;
		const struct xt_entry_match *ematch;
		struct xt_counters *counter;

		WARN_ON(!e);
		acpar.thoff = 0;
		if (!ip6_packet_match(skb, indev, outdev, &e->ipv6,
		    &acpar.thoff, &acpar.fragoff, &acpar.hotdrop)) {
 no_match:
			e = ip6t_next_entry(e);
			continue;
		}

		xt_ematch_foreach(ematch, e) {
			acpar.match     = ematch->u.kernel.match;
			acpar.matchinfo = ematch->data;
			if (!acpar.match->match(skb, &acpar))
				goto no_match;
		}

		counter = xt_get_this_cpu_counter(&e->counters);
		ADD_COUNTER(*counter, skb->len, 1);

		t = ip6t_get_target_c(e);
		WARN_ON(!t->u.kernel.target);

#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)
		/* The packet is traced: log it */
		if (unlikely(skb->nf_trace))
			trace_packet(state->net, skb, hook, state->in,
				     state->out, table->name, private, e);
#endif
		/* Standard target? */
		if (!t->u.kernel.target->target) {
			int v;

			v = ((struct xt_standard_target *)t)->verdict;
			if (v < 0) {
				/* Pop from stack? */
				if (v != XT_RETURN) {
					verdict = (unsigned int)(-v) - 1;
					break;
				}
				if (stackidx == 0)
					e = get_entry(table_base,
					    private->underflow[hook]);
				else
					e = ip6t_next_entry(jumpstack[--stackidx]);
				continue;
 			}
 			if (table_base + v != ip6t_next_entry(e) &&
 			    !(e->ipv6.flags & IP6T_F_GOTO)) {
//fix_flaw_line_below:
//				if (unlikely(stackidx >= private->stacksize)) {
//fix_flaw_line_below:
//					verdict = NF_DROP;
//fix_flaw_line_below:
//					break;
//fix_flaw_line_below:
//				}
 				jumpstack[stackidx++] = e;
 			}
 
			e = get_entry(table_base, v);
			continue;
		}

		acpar.target   = t->u.kernel.target;
		acpar.targinfo = t->data;

		verdict = t->u.kernel.target->target(skb, &acpar);
		if (verdict == XT_CONTINUE)
			e = ip6t_next_entry(e);
		else
			/* Verdict */
			break;
	} while (!acpar.hotdrop);

	xt_write_recseq_end(addend);
	local_bh_enable();

	if (acpar.hotdrop)
		return NF_DROP;
	else return verdict;
}
"
4817,182553,,Local,Not required,Complete,CVE-2017-18241,https://www.cvedetails.com/cve/CVE-2017-18241/,CWE-476,Low,,,,2018-03-21,4.9,fs/f2fs/segment.c in the Linux kernel before 4.13 allows local users to cause a denial of service (NULL pointer dereference and panic) by using a noflush_merge option that triggers a NULL value for a flush_cmd_control data structure.,2018-05-02,DoS ,1,https://github.com/torvalds/linux/commit/d4fdf8ba0e5808ba9ad6b44337783bd9935e0982,d4fdf8ba0e5808ba9ad6b44337783bd9935e0982,"f2fs: fix a panic caused by NULL flush_cmd_control

Mount fs with option noflush_merge, boot failed for illegal address
fcc in function f2fs_issue_flush:

        if (!test_opt(sbi, FLUSH_MERGE)) {
                ret = submit_flush_wait(sbi);
                atomic_inc(&fcc->issued_flush);   ->  Here, fcc illegal
                return ret;
        }

Signed-off-by: Yunlei He <heyunlei@huawei.com>
Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",1,fs/f2fs/segment.c,"{""sha"": ""c1026b78cdfc1a92ad6b44507a8c23c2b1569988"", ""filename"": ""fs/f2fs/segment.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/d4fdf8ba0e5808ba9ad6b44337783bd9935e0982/fs/f2fs/segment.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d4fdf8ba0e5808ba9ad6b44337783bd9935e0982/fs/f2fs/segment.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/f2fs/segment.c?ref=d4fdf8ba0e5808ba9ad6b44337783bd9935e0982"", ""patch"": ""@@ -566,6 +566,9 @@ int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n \tinit_waitqueue_head(&fcc->flush_wait_queue);\n \tinit_llist_head(&fcc->issue_list);\n \tSM_I(sbi)->fcc_info = fcc;\n+\tif (!test_opt(sbi, FLUSH_MERGE))\n+\t\treturn err;\n+\n init_thread:\n \tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n \t\t\t\t\""f2fs_flush-%u:%u\"", MAJOR(dev), MINOR(dev));\n@@ -3240,7 +3243,7 @@ int build_segment_manager(struct f2fs_sb_info *sbi)\n \n \tINIT_LIST_HEAD(&sm_info->sit_entry_set);\n \n-\tif (test_opt(sbi, FLUSH_MERGE) && !f2fs_readonly(sbi->sb)) {\n+\tif (!f2fs_readonly(sbi->sb)) {\n \t\terr = create_flush_cmd_control(sbi);\n \t\tif (err)\n \t\t\treturn err;""}","int build_segment_manager(struct f2fs_sb_info *sbi)
{
	struct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);
	struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
	struct f2fs_sm_info *sm_info;
	int err;

	sm_info = kzalloc(sizeof(struct f2fs_sm_info), GFP_KERNEL);
	if (!sm_info)
		return -ENOMEM;

	/* init sm info */
	sbi->sm_info = sm_info;
	sm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);
	sm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);
	sm_info->segment_count = le32_to_cpu(raw_super->segment_count);
	sm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);
	sm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);
	sm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);
	sm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);
	sm_info->rec_prefree_segments = sm_info->main_segments *
					DEF_RECLAIM_PREFREE_SEGMENTS / 100;
	if (sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS)
		sm_info->rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS;

	if (!test_opt(sbi, LFS))
		sm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;
	sm_info->min_ipu_util = DEF_MIN_IPU_UTIL;
	sm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;
	sm_info->min_hot_blocks = DEF_MIN_HOT_BLOCKS;

	sm_info->trim_sections = DEF_BATCHED_TRIM_SECTIONS;
 
 	INIT_LIST_HEAD(&sm_info->sit_entry_set);
 
	if (!f2fs_readonly(sbi->sb)) {
 		err = create_flush_cmd_control(sbi);
 		if (err)
 			return err;
	}

	err = create_discard_cmd_control(sbi);
	if (err)
		return err;

	err = build_sit_info(sbi);
	if (err)
		return err;
	err = build_free_segmap(sbi);
	if (err)
		return err;
	err = build_curseg(sbi);
	if (err)
		return err;

	/* reinit free segmap based on SIT */
	build_sit_entries(sbi);

	init_free_segmap(sbi);
	err = build_dirty_segmap(sbi);
	if (err)
		return err;

	init_min_max_mtime(sbi);
	return 0;
}
","int build_segment_manager(struct f2fs_sb_info *sbi)
{
	struct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);
	struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
	struct f2fs_sm_info *sm_info;
	int err;

	sm_info = kzalloc(sizeof(struct f2fs_sm_info), GFP_KERNEL);
	if (!sm_info)
		return -ENOMEM;

	/* init sm info */
	sbi->sm_info = sm_info;
	sm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);
	sm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);
	sm_info->segment_count = le32_to_cpu(raw_super->segment_count);
	sm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);
	sm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);
	sm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);
	sm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);
	sm_info->rec_prefree_segments = sm_info->main_segments *
					DEF_RECLAIM_PREFREE_SEGMENTS / 100;
	if (sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS)
		sm_info->rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS;

	if (!test_opt(sbi, LFS))
		sm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;
	sm_info->min_ipu_util = DEF_MIN_IPU_UTIL;
	sm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;
	sm_info->min_hot_blocks = DEF_MIN_HOT_BLOCKS;

	sm_info->trim_sections = DEF_BATCHED_TRIM_SECTIONS;
 
 	INIT_LIST_HEAD(&sm_info->sit_entry_set);
 
	if (test_opt(sbi, FLUSH_MERGE) && !f2fs_readonly(sbi->sb)) {
 		err = create_flush_cmd_control(sbi);
 		if (err)
 			return err;
	}

	err = create_discard_cmd_control(sbi);
	if (err)
		return err;

	err = build_sit_info(sbi);
	if (err)
		return err;
	err = build_free_segmap(sbi);
	if (err)
		return err;
	err = build_curseg(sbi);
	if (err)
		return err;

	/* reinit free segmap based on SIT */
	build_sit_entries(sbi);

	init_free_segmap(sbi);
	err = build_dirty_segmap(sbi);
	if (err)
		return err;

	init_min_max_mtime(sbi);
	return 0;
}
",C,"	if (!f2fs_readonly(sbi->sb)) {
","	if (test_opt(sbi, FLUSH_MERGE) && !f2fs_readonly(sbi->sb)) {
",,"@@ -566,6 +566,9 @@ int create_flush_cmd_control(struct f2fs_sb_info *sbi)
 	init_waitqueue_head(&fcc->flush_wait_queue);
 	init_llist_head(&fcc->issue_list);
 	SM_I(sbi)->fcc_info = fcc;
+	if (!test_opt(sbi, FLUSH_MERGE))
+		return err;
+
 init_thread:
 	fcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,
 				""f2fs_flush-%u:%u"", MAJOR(dev), MINOR(dev));
@@ -3240,7 +3243,7 @@ int build_segment_manager(struct f2fs_sb_info *sbi)
 
 	INIT_LIST_HEAD(&sm_info->sit_entry_set);
 
-	if (test_opt(sbi, FLUSH_MERGE) && !f2fs_readonly(sbi->sb)) {
+	if (!f2fs_readonly(sbi->sb)) {
 		err = create_flush_cmd_control(sbi);
 		if (err)
 			return err;",linux,d4fdf8ba0e5808ba9ad6b44337783bd9935e0982,68390dd9bd5b2ef7c3ec69c23010b39981e264a4,1,"int build_segment_manager(struct f2fs_sb_info *sbi)
{
	struct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);
	struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
	struct f2fs_sm_info *sm_info;
	int err;

	sm_info = kzalloc(sizeof(struct f2fs_sm_info), GFP_KERNEL);
	if (!sm_info)
		return -ENOMEM;

	/* init sm info */
	sbi->sm_info = sm_info;
	sm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);
	sm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);
	sm_info->segment_count = le32_to_cpu(raw_super->segment_count);
	sm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);
	sm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);
	sm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);
	sm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);
	sm_info->rec_prefree_segments = sm_info->main_segments *
					DEF_RECLAIM_PREFREE_SEGMENTS / 100;
	if (sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS)
		sm_info->rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS;

	if (!test_opt(sbi, LFS))
		sm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;
	sm_info->min_ipu_util = DEF_MIN_IPU_UTIL;
	sm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;
	sm_info->min_hot_blocks = DEF_MIN_HOT_BLOCKS;

	sm_info->trim_sections = DEF_BATCHED_TRIM_SECTIONS;
 
 	INIT_LIST_HEAD(&sm_info->sit_entry_set);
 
//flaw_line_below:
	if (test_opt(sbi, FLUSH_MERGE) && !f2fs_readonly(sbi->sb)) {
//fix_flaw_line_below:
//	if (!f2fs_readonly(sbi->sb)) {
 		err = create_flush_cmd_control(sbi);
 		if (err)
 			return err;
	}

	err = create_discard_cmd_control(sbi);
	if (err)
		return err;

	err = build_sit_info(sbi);
	if (err)
		return err;
	err = build_free_segmap(sbi);
	if (err)
		return err;
	err = build_curseg(sbi);
	if (err)
		return err;

	/* reinit free segmap based on SIT */
	build_sit_entries(sbi);

	init_free_segmap(sbi);
	err = build_dirty_segmap(sbi);
	if (err)
		return err;

	init_min_max_mtime(sbi);
	return 0;
}
"
4818,182554,,Local,Not required,Complete,CVE-2017-18241,https://www.cvedetails.com/cve/CVE-2017-18241/,CWE-476,Low,,,,2018-03-21,4.9,fs/f2fs/segment.c in the Linux kernel before 4.13 allows local users to cause a denial of service (NULL pointer dereference and panic) by using a noflush_merge option that triggers a NULL value for a flush_cmd_control data structure.,2018-05-02,DoS ,3,https://github.com/torvalds/linux/commit/d4fdf8ba0e5808ba9ad6b44337783bd9935e0982,d4fdf8ba0e5808ba9ad6b44337783bd9935e0982,"f2fs: fix a panic caused by NULL flush_cmd_control

Mount fs with option noflush_merge, boot failed for illegal address
fcc in function f2fs_issue_flush:

        if (!test_opt(sbi, FLUSH_MERGE)) {
                ret = submit_flush_wait(sbi);
                atomic_inc(&fcc->issued_flush);   ->  Here, fcc illegal
                return ret;
        }

Signed-off-by: Yunlei He <heyunlei@huawei.com>
Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",0,fs/f2fs/segment.c,"{""sha"": ""c1026b78cdfc1a92ad6b44507a8c23c2b1569988"", ""filename"": ""fs/f2fs/segment.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/d4fdf8ba0e5808ba9ad6b44337783bd9935e0982/fs/f2fs/segment.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d4fdf8ba0e5808ba9ad6b44337783bd9935e0982/fs/f2fs/segment.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/f2fs/segment.c?ref=d4fdf8ba0e5808ba9ad6b44337783bd9935e0982"", ""patch"": ""@@ -566,6 +566,9 @@ int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n \tinit_waitqueue_head(&fcc->flush_wait_queue);\n \tinit_llist_head(&fcc->issue_list);\n \tSM_I(sbi)->fcc_info = fcc;\n+\tif (!test_opt(sbi, FLUSH_MERGE))\n+\t\treturn err;\n+\n init_thread:\n \tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n \t\t\t\t\""f2fs_flush-%u:%u\"", MAJOR(dev), MINOR(dev));\n@@ -3240,7 +3243,7 @@ int build_segment_manager(struct f2fs_sb_info *sbi)\n \n \tINIT_LIST_HEAD(&sm_info->sit_entry_set);\n \n-\tif (test_opt(sbi, FLUSH_MERGE) && !f2fs_readonly(sbi->sb)) {\n+\tif (!f2fs_readonly(sbi->sb)) {\n \t\terr = create_flush_cmd_control(sbi);\n \t\tif (err)\n \t\t\treturn err;""}","int create_flush_cmd_control(struct f2fs_sb_info *sbi)
{
	dev_t dev = sbi->sb->s_bdev->bd_dev;
	struct flush_cmd_control *fcc;
	int err = 0;

	if (SM_I(sbi)->fcc_info) {
		fcc = SM_I(sbi)->fcc_info;
		goto init_thread;
	}

	fcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);
	if (!fcc)
		return -ENOMEM;
	atomic_set(&fcc->issued_flush, 0);
	atomic_set(&fcc->issing_flush, 0);
 	init_waitqueue_head(&fcc->flush_wait_queue);
 	init_llist_head(&fcc->issue_list);
 	SM_I(sbi)->fcc_info = fcc;
	if (!test_opt(sbi, FLUSH_MERGE))
		return err;

 init_thread:
 	fcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,
 				""f2fs_flush-%u:%u"", MAJOR(dev), MINOR(dev));
	if (IS_ERR(fcc->f2fs_issue_flush)) {
		err = PTR_ERR(fcc->f2fs_issue_flush);
		kfree(fcc);
		SM_I(sbi)->fcc_info = NULL;
		return err;
	}

	return err;
}
","int create_flush_cmd_control(struct f2fs_sb_info *sbi)
{
	dev_t dev = sbi->sb->s_bdev->bd_dev;
	struct flush_cmd_control *fcc;
	int err = 0;

	if (SM_I(sbi)->fcc_info) {
		fcc = SM_I(sbi)->fcc_info;
		goto init_thread;
	}

	fcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);
	if (!fcc)
		return -ENOMEM;
	atomic_set(&fcc->issued_flush, 0);
	atomic_set(&fcc->issing_flush, 0);
 	init_waitqueue_head(&fcc->flush_wait_queue);
 	init_llist_head(&fcc->issue_list);
 	SM_I(sbi)->fcc_info = fcc;
 init_thread:
 	fcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,
 				""f2fs_flush-%u:%u"", MAJOR(dev), MINOR(dev));
	if (IS_ERR(fcc->f2fs_issue_flush)) {
		err = PTR_ERR(fcc->f2fs_issue_flush);
		kfree(fcc);
		SM_I(sbi)->fcc_info = NULL;
		return err;
	}

	return err;
}
",C,"	if (!test_opt(sbi, FLUSH_MERGE))
		return err;

",,,"@@ -566,6 +566,9 @@ int create_flush_cmd_control(struct f2fs_sb_info *sbi)
 	init_waitqueue_head(&fcc->flush_wait_queue);
 	init_llist_head(&fcc->issue_list);
 	SM_I(sbi)->fcc_info = fcc;
+	if (!test_opt(sbi, FLUSH_MERGE))
+		return err;
+
 init_thread:
 	fcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,
 				""f2fs_flush-%u:%u"", MAJOR(dev), MINOR(dev));
@@ -3240,7 +3243,7 @@ int build_segment_manager(struct f2fs_sb_info *sbi)
 
 	INIT_LIST_HEAD(&sm_info->sit_entry_set);
 
-	if (test_opt(sbi, FLUSH_MERGE) && !f2fs_readonly(sbi->sb)) {
+	if (!f2fs_readonly(sbi->sb)) {
 		err = create_flush_cmd_control(sbi);
 		if (err)
 			return err;",linux,d4fdf8ba0e5808ba9ad6b44337783bd9935e0982,68390dd9bd5b2ef7c3ec69c23010b39981e264a4,1,"int create_flush_cmd_control(struct f2fs_sb_info *sbi)
{
	dev_t dev = sbi->sb->s_bdev->bd_dev;
	struct flush_cmd_control *fcc;
	int err = 0;

	if (SM_I(sbi)->fcc_info) {
		fcc = SM_I(sbi)->fcc_info;
		goto init_thread;
	}

	fcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);
	if (!fcc)
		return -ENOMEM;
	atomic_set(&fcc->issued_flush, 0);
	atomic_set(&fcc->issing_flush, 0);
 	init_waitqueue_head(&fcc->flush_wait_queue);
 	init_llist_head(&fcc->issue_list);
 	SM_I(sbi)->fcc_info = fcc;
//fix_flaw_line_below:
//	if (!test_opt(sbi, FLUSH_MERGE))
//fix_flaw_line_below:
//		return err;
//fix_flaw_line_below:
//
 init_thread:
 	fcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,
 				""f2fs_flush-%u:%u"", MAJOR(dev), MINOR(dev));
	if (IS_ERR(fcc->f2fs_issue_flush)) {
		err = PTR_ERR(fcc->f2fs_issue_flush);
		kfree(fcc);
		SM_I(sbi)->fcc_info = NULL;
		return err;
	}

	return err;
}
"
4841,182577,,Local,Not required,Partial,CVE-2017-18216,https://www.cvedetails.com/cve/CVE-2017-18216/,CWE-476,Low,,,,2018-03-05,2.1,"In fs/ocfs2/cluster/nodemanager.c in the Linux kernel before 4.15, local users can cause a denial of service (NULL pointer dereference and BUG) because a required mutex is not used.",2018-10-30,DoS ,10,https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,"ocfs2: subsystem.su_mutex is required while accessing the item->ci_parent

The subsystem.su_mutex is required while accessing the item->ci_parent,
otherwise, NULL pointer dereference to the item->ci_parent will be
triggered in the following situation:

add node                     delete node
sys_write
 vfs_write
  configfs_write_file
   o2nm_node_store
    o2nm_node_local_write
                             do_rmdir
                              vfs_rmdir
                               configfs_rmdir
                                mutex_lock(&subsys->su_mutex);
                                unlink_obj
                                 item->ci_group = NULL;
                                 item->ci_parent = NULL;
	 to_o2nm_cluster_from_node
	  node->nd_item.ci_parent->ci_parent
	  BUG since of NULL pointer dereference to nd_item.ci_parent

Moreover, the o2nm_cluster also should be protected by the
subsystem.su_mutex.

[alex.chen@huawei.com: v2]
  Link: http://lkml.kernel.org/r/59EEAA69.9080703@huawei.com
Link: http://lkml.kernel.org/r/59E9B36A.10700@huawei.com
Signed-off-by: Alex Chen <alex.chen@huawei.com>
Reviewed-by: Jun Piao <piaojun@huawei.com>
Reviewed-by: Joseph Qi <jiangqi903@gmail.com>
Cc: Mark Fasheh <mfasheh@versity.com>
Cc: Joel Becker <jlbec@evilplan.org>
Cc: Junxiao Bi <junxiao.bi@oracle.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",1,fs/ocfs2/cluster/nodemanager.c,"{""sha"": ""da64c3a20eebd23567944363296d4cdfca60f508"", ""filename"": ""fs/ocfs2/cluster/nodemanager.c"", ""status"": ""modified"", ""additions"": 55, ""deletions"": 8, ""changes"": 63, ""blob_url"": ""https://github.com/torvalds/linux/blob/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2/fs/ocfs2/cluster/nodemanager.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2/fs/ocfs2/cluster/nodemanager.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ocfs2/cluster/nodemanager.c?ref=853bc26a7ea39e354b9f8889ae7ad1492ffa28d2"", ""patch"": ""@@ -40,6 +40,9 @@ char *o2nm_fence_method_desc[O2NM_FENCE_METHODS] = {\n \t\t\""panic\"",\t/* O2NM_FENCE_PANIC */\n };\n \n+static inline void o2nm_lock_subsystem(void);\n+static inline void o2nm_unlock_subsystem(void);\n+\n struct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n {\n \tstruct o2nm_node *node = NULL;\n@@ -181,7 +184,10 @@ static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n {\n \t/* through the first node_set .parent\n \t * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */\n-\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n+\tif (node->nd_item.ci_parent)\n+\t\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n+\telse\n+\t\treturn NULL;\n }\n \n enum {\n@@ -194,7 +200,7 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n \t\t\t\t   size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n-\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n+\tstruct o2nm_cluster *cluster;\n \tunsigned long tmp;\n \tchar *p = (char *)page;\n \tint ret = 0;\n@@ -214,6 +220,13 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n \t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n \t\treturn -EINVAL; /* XXX */\n \n+\to2nm_lock_subsystem();\n+\tcluster = to_o2nm_cluster_from_node(node);\n+\tif (!cluster) {\n+\t\to2nm_unlock_subsystem();\n+\t\treturn -EINVAL;\n+\t}\n+\n \twrite_lock(&cluster->cl_nodes_lock);\n \tif (cluster->cl_nodes[tmp])\n \t\tret = -EEXIST;\n@@ -226,6 +239,8 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n \t\tset_bit(tmp, cluster->cl_nodes_bitmap);\n \t}\n \twrite_unlock(&cluster->cl_nodes_lock);\n+\to2nm_unlock_subsystem();\n+\n \tif (ret)\n \t\treturn ret;\n \n@@ -269,7 +284,7 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n \t\t\t\t\t    size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n-\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n+\tstruct o2nm_cluster *cluster;\n \tint ret, i;\n \tstruct rb_node **p, *parent;\n \tunsigned int octets[4];\n@@ -286,6 +301,13 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n \t\tbe32_add_cpu(&ipv4_addr, octets[i] << (i * 8));\n \t}\n \n+\to2nm_lock_subsystem();\n+\tcluster = to_o2nm_cluster_from_node(node);\n+\tif (!cluster) {\n+\t\to2nm_unlock_subsystem();\n+\t\treturn -EINVAL;\n+\t}\n+\n \tret = 0;\n \twrite_lock(&cluster->cl_nodes_lock);\n \tif (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))\n@@ -298,6 +320,8 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n \t\trb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n \t}\n \twrite_unlock(&cluster->cl_nodes_lock);\n+\to2nm_unlock_subsystem();\n+\n \tif (ret)\n \t\treturn ret;\n \n@@ -315,7 +339,7 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n \t\t\t\t     size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n-\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n+\tstruct o2nm_cluster *cluster;\n \tunsigned long tmp;\n \tchar *p = (char *)page;\n \tssize_t ret;\n@@ -333,17 +357,26 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n \t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n \t\treturn -EINVAL; /* XXX */\n \n+\to2nm_lock_subsystem();\n+\tcluster = to_o2nm_cluster_from_node(node);\n+\tif (!cluster) {\n+\t\tret = -EINVAL;\n+\t\tgoto out;\n+\t}\n+\n \t/* the only failure case is trying to set a new local node\n \t * when a different one is already set */\n \tif (tmp && tmp == cluster->cl_has_local &&\n-\t    cluster->cl_local_node != node->nd_num)\n-\t\treturn -EBUSY;\n+\t    cluster->cl_local_node != node->nd_num) {\n+\t\tret = -EBUSY;\n+\t\tgoto out;\n+\t}\n \n \t/* bring up the rx thread if we're setting the new local node. */\n \tif (tmp && !cluster->cl_has_local) {\n \t\tret = o2net_start_listening(node);\n \t\tif (ret)\n-\t\t\treturn ret;\n+\t\t\tgoto out;\n \t}\n \n \tif (!tmp && cluster->cl_has_local &&\n@@ -358,7 +391,11 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n \t\tcluster->cl_local_node = node->nd_num;\n \t}\n \n-\treturn count;\n+\tret = count;\n+\n+out:\n+\to2nm_unlock_subsystem();\n+\treturn ret;\n }\n \n CONFIGFS_ATTR(o2nm_node_, num);\n@@ -738,6 +775,16 @@ static struct o2nm_cluster_group o2nm_cluster_group = {\n \t},\n };\n \n+static inline void o2nm_lock_subsystem(void)\n+{\n+\tmutex_lock(&o2nm_cluster_group.cs_subsys.su_mutex);\n+}\n+\n+static inline void o2nm_unlock_subsystem(void)\n+{\n+\tmutex_unlock(&o2nm_cluster_group.cs_subsys.su_mutex);\n+}\n+\n int o2nm_depend_item(struct config_item *item)\n {\n \treturn configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);""}","static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,
					    const char *page,
 					    size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
	struct o2nm_cluster *cluster;
 	int ret, i;
 	struct rb_node **p, *parent;
 	unsigned int octets[4];
	__be32 ipv4_addr = 0;

	ret = sscanf(page, ""%3u.%3u.%3u.%3u"", &octets[3], &octets[2],
		     &octets[1], &octets[0]);
	if (ret != 4)
		return -EINVAL;

	for (i = 0; i < ARRAY_SIZE(octets); i++) {
		if (octets[i] > 255)
			return -ERANGE;
 		be32_add_cpu(&ipv4_addr, octets[i] << (i * 8));
 	}
 
	o2nm_lock_subsystem();
	cluster = to_o2nm_cluster_from_node(node);
	if (!cluster) {
		o2nm_unlock_subsystem();
		return -EINVAL;
	}

 	ret = 0;
 	write_lock(&cluster->cl_nodes_lock);
 	if (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))
		ret = -EEXIST;
	else if (test_and_set_bit(O2NM_NODE_ATTR_ADDRESS,
			&node->nd_set_attributes))
		ret = -EBUSY;
	else {
		rb_link_node(&node->nd_ip_node, parent, p);
 		rb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);
 	}
 	write_unlock(&cluster->cl_nodes_lock);
	o2nm_unlock_subsystem();

 	if (ret)
 		return ret;
 
	memcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr));

	return count;
}
","static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,
					    const char *page,
 					    size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
 	int ret, i;
 	struct rb_node **p, *parent;
 	unsigned int octets[4];
	__be32 ipv4_addr = 0;

	ret = sscanf(page, ""%3u.%3u.%3u.%3u"", &octets[3], &octets[2],
		     &octets[1], &octets[0]);
	if (ret != 4)
		return -EINVAL;

	for (i = 0; i < ARRAY_SIZE(octets); i++) {
		if (octets[i] > 255)
			return -ERANGE;
 		be32_add_cpu(&ipv4_addr, octets[i] << (i * 8));
 	}
 
 	ret = 0;
 	write_lock(&cluster->cl_nodes_lock);
 	if (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))
		ret = -EEXIST;
	else if (test_and_set_bit(O2NM_NODE_ATTR_ADDRESS,
			&node->nd_set_attributes))
		ret = -EBUSY;
	else {
		rb_link_node(&node->nd_ip_node, parent, p);
 		rb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);
 	}
 	write_unlock(&cluster->cl_nodes_lock);
 	if (ret)
 		return ret;
 
	memcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr));

	return count;
}
",C,"	struct o2nm_cluster *cluster;
	o2nm_lock_subsystem();
	cluster = to_o2nm_cluster_from_node(node);
	if (!cluster) {
		o2nm_unlock_subsystem();
		return -EINVAL;
	}

	o2nm_unlock_subsystem();

","	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
",,"@@ -40,6 +40,9 @@ char *o2nm_fence_method_desc[O2NM_FENCE_METHODS] = {
 		""panic"",	/* O2NM_FENCE_PANIC */
 };
 
+static inline void o2nm_lock_subsystem(void);
+static inline void o2nm_unlock_subsystem(void);
+
 struct o2nm_node *o2nm_get_node_by_num(u8 node_num)
 {
 	struct o2nm_node *node = NULL;
@@ -181,7 +184,10 @@ static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)
 {
 	/* through the first node_set .parent
 	 * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */
-	return to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);
+	if (node->nd_item.ci_parent)
+		return to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);
+	else
+		return NULL;
 }
 
 enum {
@@ -194,7 +200,7 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
 				   size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
-	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
+	struct o2nm_cluster *cluster;
 	unsigned long tmp;
 	char *p = (char *)page;
 	int ret = 0;
@@ -214,6 +220,13 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
 	    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
 		return -EINVAL; /* XXX */
 
+	o2nm_lock_subsystem();
+	cluster = to_o2nm_cluster_from_node(node);
+	if (!cluster) {
+		o2nm_unlock_subsystem();
+		return -EINVAL;
+	}
+
 	write_lock(&cluster->cl_nodes_lock);
 	if (cluster->cl_nodes[tmp])
 		ret = -EEXIST;
@@ -226,6 +239,8 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
 		set_bit(tmp, cluster->cl_nodes_bitmap);
 	}
 	write_unlock(&cluster->cl_nodes_lock);
+	o2nm_unlock_subsystem();
+
 	if (ret)
 		return ret;
 
@@ -269,7 +284,7 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,
 					    size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
-	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
+	struct o2nm_cluster *cluster;
 	int ret, i;
 	struct rb_node **p, *parent;
 	unsigned int octets[4];
@@ -286,6 +301,13 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,
 		be32_add_cpu(&ipv4_addr, octets[i] << (i * 8));
 	}
 
+	o2nm_lock_subsystem();
+	cluster = to_o2nm_cluster_from_node(node);
+	if (!cluster) {
+		o2nm_unlock_subsystem();
+		return -EINVAL;
+	}
+
 	ret = 0;
 	write_lock(&cluster->cl_nodes_lock);
 	if (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))
@@ -298,6 +320,8 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,
 		rb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);
 	}
 	write_unlock(&cluster->cl_nodes_lock);
+	o2nm_unlock_subsystem();
+
 	if (ret)
 		return ret;
 
@@ -315,7 +339,7 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,
 				     size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
-	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
+	struct o2nm_cluster *cluster;
 	unsigned long tmp;
 	char *p = (char *)page;
 	ssize_t ret;
@@ -333,17 +357,26 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,
 	    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
 		return -EINVAL; /* XXX */
 
+	o2nm_lock_subsystem();
+	cluster = to_o2nm_cluster_from_node(node);
+	if (!cluster) {
+		ret = -EINVAL;
+		goto out;
+	}
+
 	/* the only failure case is trying to set a new local node
 	 * when a different one is already set */
 	if (tmp && tmp == cluster->cl_has_local &&
-	    cluster->cl_local_node != node->nd_num)
-		return -EBUSY;
+	    cluster->cl_local_node != node->nd_num) {
+		ret = -EBUSY;
+		goto out;
+	}
 
 	/* bring up the rx thread if we're setting the new local node. */
 	if (tmp && !cluster->cl_has_local) {
 		ret = o2net_start_listening(node);
 		if (ret)
-			return ret;
+			goto out;
 	}
 
 	if (!tmp && cluster->cl_has_local &&
@@ -358,7 +391,11 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,
 		cluster->cl_local_node = node->nd_num;
 	}
 
-	return count;
+	ret = count;
+
+out:
+	o2nm_unlock_subsystem();
+	return ret;
 }
 
 CONFIGFS_ATTR(o2nm_node_, num);
@@ -738,6 +775,16 @@ static struct o2nm_cluster_group o2nm_cluster_group = {
 	},
 };
 
+static inline void o2nm_lock_subsystem(void)
+{
+	mutex_lock(&o2nm_cluster_group.cs_subsys.su_mutex);
+}
+
+static inline void o2nm_unlock_subsystem(void)
+{
+	mutex_unlock(&o2nm_cluster_group.cs_subsys.su_mutex);
+}
+
 int o2nm_depend_item(struct config_item *item)
 {
 	return configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);",linux,853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,3e4c56d41eef5595035872a2ec5a483f42e8917f,1,"static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,
					    const char *page,
 					    size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
//flaw_line_below:
	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
//fix_flaw_line_below:
//	struct o2nm_cluster *cluster;
 	int ret, i;
 	struct rb_node **p, *parent;
 	unsigned int octets[4];
	__be32 ipv4_addr = 0;

	ret = sscanf(page, ""%3u.%3u.%3u.%3u"", &octets[3], &octets[2],
		     &octets[1], &octets[0]);
	if (ret != 4)
		return -EINVAL;

	for (i = 0; i < ARRAY_SIZE(octets); i++) {
		if (octets[i] > 255)
			return -ERANGE;
 		be32_add_cpu(&ipv4_addr, octets[i] << (i * 8));
 	}
 
//fix_flaw_line_below:
//	o2nm_lock_subsystem();
//fix_flaw_line_below:
//	cluster = to_o2nm_cluster_from_node(node);
//fix_flaw_line_below:
//	if (!cluster) {
//fix_flaw_line_below:
//		o2nm_unlock_subsystem();
//fix_flaw_line_below:
//		return -EINVAL;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	ret = 0;
 	write_lock(&cluster->cl_nodes_lock);
 	if (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))
		ret = -EEXIST;
	else if (test_and_set_bit(O2NM_NODE_ATTR_ADDRESS,
			&node->nd_set_attributes))
		ret = -EBUSY;
	else {
		rb_link_node(&node->nd_ip_node, parent, p);
 		rb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);
 	}
 	write_unlock(&cluster->cl_nodes_lock);
//fix_flaw_line_below:
//	o2nm_unlock_subsystem();
//fix_flaw_line_below:
//
 	if (ret)
 		return ret;
 
	memcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr));

	return count;
}
"
4842,182578,,Local,Not required,Partial,CVE-2017-18216,https://www.cvedetails.com/cve/CVE-2017-18216/,CWE-476,Low,,,,2018-03-05,2.1,"In fs/ocfs2/cluster/nodemanager.c in the Linux kernel before 4.15, local users can cause a denial of service (NULL pointer dereference and BUG) because a required mutex is not used.",2018-10-30,DoS ,18,https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,"ocfs2: subsystem.su_mutex is required while accessing the item->ci_parent

The subsystem.su_mutex is required while accessing the item->ci_parent,
otherwise, NULL pointer dereference to the item->ci_parent will be
triggered in the following situation:

add node                     delete node
sys_write
 vfs_write
  configfs_write_file
   o2nm_node_store
    o2nm_node_local_write
                             do_rmdir
                              vfs_rmdir
                               configfs_rmdir
                                mutex_lock(&subsys->su_mutex);
                                unlink_obj
                                 item->ci_group = NULL;
                                 item->ci_parent = NULL;
	 to_o2nm_cluster_from_node
	  node->nd_item.ci_parent->ci_parent
	  BUG since of NULL pointer dereference to nd_item.ci_parent

Moreover, the o2nm_cluster also should be protected by the
subsystem.su_mutex.

[alex.chen@huawei.com: v2]
  Link: http://lkml.kernel.org/r/59EEAA69.9080703@huawei.com
Link: http://lkml.kernel.org/r/59E9B36A.10700@huawei.com
Signed-off-by: Alex Chen <alex.chen@huawei.com>
Reviewed-by: Jun Piao <piaojun@huawei.com>
Reviewed-by: Joseph Qi <jiangqi903@gmail.com>
Cc: Mark Fasheh <mfasheh@versity.com>
Cc: Joel Becker <jlbec@evilplan.org>
Cc: Junxiao Bi <junxiao.bi@oracle.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",5,fs/ocfs2/cluster/nodemanager.c,"{""sha"": ""da64c3a20eebd23567944363296d4cdfca60f508"", ""filename"": ""fs/ocfs2/cluster/nodemanager.c"", ""status"": ""modified"", ""additions"": 55, ""deletions"": 8, ""changes"": 63, ""blob_url"": ""https://github.com/torvalds/linux/blob/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2/fs/ocfs2/cluster/nodemanager.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2/fs/ocfs2/cluster/nodemanager.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ocfs2/cluster/nodemanager.c?ref=853bc26a7ea39e354b9f8889ae7ad1492ffa28d2"", ""patch"": ""@@ -40,6 +40,9 @@ char *o2nm_fence_method_desc[O2NM_FENCE_METHODS] = {\n \t\t\""panic\"",\t/* O2NM_FENCE_PANIC */\n };\n \n+static inline void o2nm_lock_subsystem(void);\n+static inline void o2nm_unlock_subsystem(void);\n+\n struct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n {\n \tstruct o2nm_node *node = NULL;\n@@ -181,7 +184,10 @@ static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n {\n \t/* through the first node_set .parent\n \t * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */\n-\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n+\tif (node->nd_item.ci_parent)\n+\t\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n+\telse\n+\t\treturn NULL;\n }\n \n enum {\n@@ -194,7 +200,7 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n \t\t\t\t   size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n-\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n+\tstruct o2nm_cluster *cluster;\n \tunsigned long tmp;\n \tchar *p = (char *)page;\n \tint ret = 0;\n@@ -214,6 +220,13 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n \t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n \t\treturn -EINVAL; /* XXX */\n \n+\to2nm_lock_subsystem();\n+\tcluster = to_o2nm_cluster_from_node(node);\n+\tif (!cluster) {\n+\t\to2nm_unlock_subsystem();\n+\t\treturn -EINVAL;\n+\t}\n+\n \twrite_lock(&cluster->cl_nodes_lock);\n \tif (cluster->cl_nodes[tmp])\n \t\tret = -EEXIST;\n@@ -226,6 +239,8 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n \t\tset_bit(tmp, cluster->cl_nodes_bitmap);\n \t}\n \twrite_unlock(&cluster->cl_nodes_lock);\n+\to2nm_unlock_subsystem();\n+\n \tif (ret)\n \t\treturn ret;\n \n@@ -269,7 +284,7 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n \t\t\t\t\t    size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n-\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n+\tstruct o2nm_cluster *cluster;\n \tint ret, i;\n \tstruct rb_node **p, *parent;\n \tunsigned int octets[4];\n@@ -286,6 +301,13 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n \t\tbe32_add_cpu(&ipv4_addr, octets[i] << (i * 8));\n \t}\n \n+\to2nm_lock_subsystem();\n+\tcluster = to_o2nm_cluster_from_node(node);\n+\tif (!cluster) {\n+\t\to2nm_unlock_subsystem();\n+\t\treturn -EINVAL;\n+\t}\n+\n \tret = 0;\n \twrite_lock(&cluster->cl_nodes_lock);\n \tif (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))\n@@ -298,6 +320,8 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n \t\trb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n \t}\n \twrite_unlock(&cluster->cl_nodes_lock);\n+\to2nm_unlock_subsystem();\n+\n \tif (ret)\n \t\treturn ret;\n \n@@ -315,7 +339,7 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n \t\t\t\t     size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n-\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n+\tstruct o2nm_cluster *cluster;\n \tunsigned long tmp;\n \tchar *p = (char *)page;\n \tssize_t ret;\n@@ -333,17 +357,26 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n \t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n \t\treturn -EINVAL; /* XXX */\n \n+\to2nm_lock_subsystem();\n+\tcluster = to_o2nm_cluster_from_node(node);\n+\tif (!cluster) {\n+\t\tret = -EINVAL;\n+\t\tgoto out;\n+\t}\n+\n \t/* the only failure case is trying to set a new local node\n \t * when a different one is already set */\n \tif (tmp && tmp == cluster->cl_has_local &&\n-\t    cluster->cl_local_node != node->nd_num)\n-\t\treturn -EBUSY;\n+\t    cluster->cl_local_node != node->nd_num) {\n+\t\tret = -EBUSY;\n+\t\tgoto out;\n+\t}\n \n \t/* bring up the rx thread if we're setting the new local node. */\n \tif (tmp && !cluster->cl_has_local) {\n \t\tret = o2net_start_listening(node);\n \t\tif (ret)\n-\t\t\treturn ret;\n+\t\t\tgoto out;\n \t}\n \n \tif (!tmp && cluster->cl_has_local &&\n@@ -358,7 +391,11 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n \t\tcluster->cl_local_node = node->nd_num;\n \t}\n \n-\treturn count;\n+\tret = count;\n+\n+out:\n+\to2nm_unlock_subsystem();\n+\treturn ret;\n }\n \n CONFIGFS_ATTR(o2nm_node_, num);\n@@ -738,6 +775,16 @@ static struct o2nm_cluster_group o2nm_cluster_group = {\n \t},\n };\n \n+static inline void o2nm_lock_subsystem(void)\n+{\n+\tmutex_lock(&o2nm_cluster_group.cs_subsys.su_mutex);\n+}\n+\n+static inline void o2nm_unlock_subsystem(void)\n+{\n+\tmutex_unlock(&o2nm_cluster_group.cs_subsys.su_mutex);\n+}\n+\n int o2nm_depend_item(struct config_item *item)\n {\n \treturn configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);""}","static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,
 				     size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
	struct o2nm_cluster *cluster;
 	unsigned long tmp;
 	char *p = (char *)page;
 	ssize_t ret;

	tmp = simple_strtoul(p, &p, 0);
	if (!p || (*p && (*p != '\n')))
		return -EINVAL;

	tmp = !!tmp; /* boolean of whether this node wants to be local */

	/* setting local turns on networking rx for now so we require having
	 * set everything else first */
	if (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||
	    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||
 	    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
 		return -EINVAL; /* XXX */
 
	o2nm_lock_subsystem();
	cluster = to_o2nm_cluster_from_node(node);
	if (!cluster) {
		ret = -EINVAL;
		goto out;
	}

 	/* the only failure case is trying to set a new local node
 	 * when a different one is already set */
 	if (tmp && tmp == cluster->cl_has_local &&
	    cluster->cl_local_node != node->nd_num) {
		ret = -EBUSY;
		goto out;
	}
 
 	/* bring up the rx thread if we're setting the new local node. */
 	if (tmp && !cluster->cl_has_local) {
 		ret = o2net_start_listening(node);
 		if (ret)
			goto out;
 	}
 
 	if (!tmp && cluster->cl_has_local &&
	    cluster->cl_local_node == node->nd_num) {
		o2net_stop_listening(node);
		cluster->cl_local_node = O2NM_INVALID_NODE_NUM;
	}

	node->nd_local = tmp;
	if (node->nd_local) {
		cluster->cl_has_local = tmp;
 		cluster->cl_local_node = node->nd_num;
 	}
 
	ret = count;

out:
	o2nm_unlock_subsystem();
	return ret;
 }
","static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,
 				     size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
 	unsigned long tmp;
 	char *p = (char *)page;
 	ssize_t ret;

	tmp = simple_strtoul(p, &p, 0);
	if (!p || (*p && (*p != '\n')))
		return -EINVAL;

	tmp = !!tmp; /* boolean of whether this node wants to be local */

	/* setting local turns on networking rx for now so we require having
	 * set everything else first */
	if (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||
	    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||
 	    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
 		return -EINVAL; /* XXX */
 
 	/* the only failure case is trying to set a new local node
 	 * when a different one is already set */
 	if (tmp && tmp == cluster->cl_has_local &&
	    cluster->cl_local_node != node->nd_num)
		return -EBUSY;
 
 	/* bring up the rx thread if we're setting the new local node. */
 	if (tmp && !cluster->cl_has_local) {
 		ret = o2net_start_listening(node);
 		if (ret)
			return ret;
 	}
 
 	if (!tmp && cluster->cl_has_local &&
	    cluster->cl_local_node == node->nd_num) {
		o2net_stop_listening(node);
		cluster->cl_local_node = O2NM_INVALID_NODE_NUM;
	}

	node->nd_local = tmp;
	if (node->nd_local) {
		cluster->cl_has_local = tmp;
 		cluster->cl_local_node = node->nd_num;
 	}
 
	return count;
 }
",C,"	struct o2nm_cluster *cluster;
	o2nm_lock_subsystem();
	cluster = to_o2nm_cluster_from_node(node);
	if (!cluster) {
		ret = -EINVAL;
		goto out;
	}

	    cluster->cl_local_node != node->nd_num) {
		ret = -EBUSY;
		goto out;
	}
			goto out;
	ret = count;

out:
	o2nm_unlock_subsystem();
	return ret;
","	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
	    cluster->cl_local_node != node->nd_num)
		return -EBUSY;
			return ret;
	return count;
",,"@@ -40,6 +40,9 @@ char *o2nm_fence_method_desc[O2NM_FENCE_METHODS] = {
 		""panic"",	/* O2NM_FENCE_PANIC */
 };
 
+static inline void o2nm_lock_subsystem(void);
+static inline void o2nm_unlock_subsystem(void);
+
 struct o2nm_node *o2nm_get_node_by_num(u8 node_num)
 {
 	struct o2nm_node *node = NULL;
@@ -181,7 +184,10 @@ static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)
 {
 	/* through the first node_set .parent
 	 * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */
-	return to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);
+	if (node->nd_item.ci_parent)
+		return to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);
+	else
+		return NULL;
 }
 
 enum {
@@ -194,7 +200,7 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
 				   size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
-	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
+	struct o2nm_cluster *cluster;
 	unsigned long tmp;
 	char *p = (char *)page;
 	int ret = 0;
@@ -214,6 +220,13 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
 	    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
 		return -EINVAL; /* XXX */
 
+	o2nm_lock_subsystem();
+	cluster = to_o2nm_cluster_from_node(node);
+	if (!cluster) {
+		o2nm_unlock_subsystem();
+		return -EINVAL;
+	}
+
 	write_lock(&cluster->cl_nodes_lock);
 	if (cluster->cl_nodes[tmp])
 		ret = -EEXIST;
@@ -226,6 +239,8 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
 		set_bit(tmp, cluster->cl_nodes_bitmap);
 	}
 	write_unlock(&cluster->cl_nodes_lock);
+	o2nm_unlock_subsystem();
+
 	if (ret)
 		return ret;
 
@@ -269,7 +284,7 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,
 					    size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
-	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
+	struct o2nm_cluster *cluster;
 	int ret, i;
 	struct rb_node **p, *parent;
 	unsigned int octets[4];
@@ -286,6 +301,13 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,
 		be32_add_cpu(&ipv4_addr, octets[i] << (i * 8));
 	}
 
+	o2nm_lock_subsystem();
+	cluster = to_o2nm_cluster_from_node(node);
+	if (!cluster) {
+		o2nm_unlock_subsystem();
+		return -EINVAL;
+	}
+
 	ret = 0;
 	write_lock(&cluster->cl_nodes_lock);
 	if (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))
@@ -298,6 +320,8 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,
 		rb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);
 	}
 	write_unlock(&cluster->cl_nodes_lock);
+	o2nm_unlock_subsystem();
+
 	if (ret)
 		return ret;
 
@@ -315,7 +339,7 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,
 				     size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
-	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
+	struct o2nm_cluster *cluster;
 	unsigned long tmp;
 	char *p = (char *)page;
 	ssize_t ret;
@@ -333,17 +357,26 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,
 	    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
 		return -EINVAL; /* XXX */
 
+	o2nm_lock_subsystem();
+	cluster = to_o2nm_cluster_from_node(node);
+	if (!cluster) {
+		ret = -EINVAL;
+		goto out;
+	}
+
 	/* the only failure case is trying to set a new local node
 	 * when a different one is already set */
 	if (tmp && tmp == cluster->cl_has_local &&
-	    cluster->cl_local_node != node->nd_num)
-		return -EBUSY;
+	    cluster->cl_local_node != node->nd_num) {
+		ret = -EBUSY;
+		goto out;
+	}
 
 	/* bring up the rx thread if we're setting the new local node. */
 	if (tmp && !cluster->cl_has_local) {
 		ret = o2net_start_listening(node);
 		if (ret)
-			return ret;
+			goto out;
 	}
 
 	if (!tmp && cluster->cl_has_local &&
@@ -358,7 +391,11 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,
 		cluster->cl_local_node = node->nd_num;
 	}
 
-	return count;
+	ret = count;
+
+out:
+	o2nm_unlock_subsystem();
+	return ret;
 }
 
 CONFIGFS_ATTR(o2nm_node_, num);
@@ -738,6 +775,16 @@ static struct o2nm_cluster_group o2nm_cluster_group = {
 	},
 };
 
+static inline void o2nm_lock_subsystem(void)
+{
+	mutex_lock(&o2nm_cluster_group.cs_subsys.su_mutex);
+}
+
+static inline void o2nm_unlock_subsystem(void)
+{
+	mutex_unlock(&o2nm_cluster_group.cs_subsys.su_mutex);
+}
+
 int o2nm_depend_item(struct config_item *item)
 {
 	return configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);",linux,853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,3e4c56d41eef5595035872a2ec5a483f42e8917f,1,"static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,
 				     size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
//flaw_line_below:
	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
//fix_flaw_line_below:
//	struct o2nm_cluster *cluster;
 	unsigned long tmp;
 	char *p = (char *)page;
 	ssize_t ret;

	tmp = simple_strtoul(p, &p, 0);
	if (!p || (*p && (*p != '\n')))
		return -EINVAL;

	tmp = !!tmp; /* boolean of whether this node wants to be local */

	/* setting local turns on networking rx for now so we require having
	 * set everything else first */
	if (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||
	    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||
 	    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
 		return -EINVAL; /* XXX */
 
//fix_flaw_line_below:
//	o2nm_lock_subsystem();
//fix_flaw_line_below:
//	cluster = to_o2nm_cluster_from_node(node);
//fix_flaw_line_below:
//	if (!cluster) {
//fix_flaw_line_below:
//		ret = -EINVAL;
//fix_flaw_line_below:
//		goto out;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	/* the only failure case is trying to set a new local node
 	 * when a different one is already set */
 	if (tmp && tmp == cluster->cl_has_local &&
//flaw_line_below:
	    cluster->cl_local_node != node->nd_num)
//flaw_line_below:
		return -EBUSY;
//fix_flaw_line_below:
//	    cluster->cl_local_node != node->nd_num) {
//fix_flaw_line_below:
//		ret = -EBUSY;
//fix_flaw_line_below:
//		goto out;
//fix_flaw_line_below:
//	}
 
 	/* bring up the rx thread if we're setting the new local node. */
 	if (tmp && !cluster->cl_has_local) {
 		ret = o2net_start_listening(node);
 		if (ret)
//flaw_line_below:
			return ret;
//fix_flaw_line_below:
//			goto out;
 	}
 
 	if (!tmp && cluster->cl_has_local &&
	    cluster->cl_local_node == node->nd_num) {
		o2net_stop_listening(node);
		cluster->cl_local_node = O2NM_INVALID_NODE_NUM;
	}

	node->nd_local = tmp;
	if (node->nd_local) {
		cluster->cl_has_local = tmp;
 		cluster->cl_local_node = node->nd_num;
 	}
 
//flaw_line_below:
	return count;
//fix_flaw_line_below:
//	ret = count;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//out:
//fix_flaw_line_below:
//	o2nm_unlock_subsystem();
//fix_flaw_line_below:
//	return ret;
 }
"
4843,182579,,Local,Not required,Partial,CVE-2017-18216,https://www.cvedetails.com/cve/CVE-2017-18216/,CWE-476,Low,,,,2018-03-05,2.1,"In fs/ocfs2/cluster/nodemanager.c in the Linux kernel before 4.15, local users can cause a denial of service (NULL pointer dereference and BUG) because a required mutex is not used.",2018-10-30,DoS ,10,https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,"ocfs2: subsystem.su_mutex is required while accessing the item->ci_parent

The subsystem.su_mutex is required while accessing the item->ci_parent,
otherwise, NULL pointer dereference to the item->ci_parent will be
triggered in the following situation:

add node                     delete node
sys_write
 vfs_write
  configfs_write_file
   o2nm_node_store
    o2nm_node_local_write
                             do_rmdir
                              vfs_rmdir
                               configfs_rmdir
                                mutex_lock(&subsys->su_mutex);
                                unlink_obj
                                 item->ci_group = NULL;
                                 item->ci_parent = NULL;
	 to_o2nm_cluster_from_node
	  node->nd_item.ci_parent->ci_parent
	  BUG since of NULL pointer dereference to nd_item.ci_parent

Moreover, the o2nm_cluster also should be protected by the
subsystem.su_mutex.

[alex.chen@huawei.com: v2]
  Link: http://lkml.kernel.org/r/59EEAA69.9080703@huawei.com
Link: http://lkml.kernel.org/r/59E9B36A.10700@huawei.com
Signed-off-by: Alex Chen <alex.chen@huawei.com>
Reviewed-by: Jun Piao <piaojun@huawei.com>
Reviewed-by: Joseph Qi <jiangqi903@gmail.com>
Cc: Mark Fasheh <mfasheh@versity.com>
Cc: Joel Becker <jlbec@evilplan.org>
Cc: Junxiao Bi <junxiao.bi@oracle.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",1,fs/ocfs2/cluster/nodemanager.c,"{""sha"": ""da64c3a20eebd23567944363296d4cdfca60f508"", ""filename"": ""fs/ocfs2/cluster/nodemanager.c"", ""status"": ""modified"", ""additions"": 55, ""deletions"": 8, ""changes"": 63, ""blob_url"": ""https://github.com/torvalds/linux/blob/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2/fs/ocfs2/cluster/nodemanager.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2/fs/ocfs2/cluster/nodemanager.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ocfs2/cluster/nodemanager.c?ref=853bc26a7ea39e354b9f8889ae7ad1492ffa28d2"", ""patch"": ""@@ -40,6 +40,9 @@ char *o2nm_fence_method_desc[O2NM_FENCE_METHODS] = {\n \t\t\""panic\"",\t/* O2NM_FENCE_PANIC */\n };\n \n+static inline void o2nm_lock_subsystem(void);\n+static inline void o2nm_unlock_subsystem(void);\n+\n struct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n {\n \tstruct o2nm_node *node = NULL;\n@@ -181,7 +184,10 @@ static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n {\n \t/* through the first node_set .parent\n \t * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */\n-\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n+\tif (node->nd_item.ci_parent)\n+\t\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n+\telse\n+\t\treturn NULL;\n }\n \n enum {\n@@ -194,7 +200,7 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n \t\t\t\t   size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n-\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n+\tstruct o2nm_cluster *cluster;\n \tunsigned long tmp;\n \tchar *p = (char *)page;\n \tint ret = 0;\n@@ -214,6 +220,13 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n \t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n \t\treturn -EINVAL; /* XXX */\n \n+\to2nm_lock_subsystem();\n+\tcluster = to_o2nm_cluster_from_node(node);\n+\tif (!cluster) {\n+\t\to2nm_unlock_subsystem();\n+\t\treturn -EINVAL;\n+\t}\n+\n \twrite_lock(&cluster->cl_nodes_lock);\n \tif (cluster->cl_nodes[tmp])\n \t\tret = -EEXIST;\n@@ -226,6 +239,8 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n \t\tset_bit(tmp, cluster->cl_nodes_bitmap);\n \t}\n \twrite_unlock(&cluster->cl_nodes_lock);\n+\to2nm_unlock_subsystem();\n+\n \tif (ret)\n \t\treturn ret;\n \n@@ -269,7 +284,7 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n \t\t\t\t\t    size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n-\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n+\tstruct o2nm_cluster *cluster;\n \tint ret, i;\n \tstruct rb_node **p, *parent;\n \tunsigned int octets[4];\n@@ -286,6 +301,13 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n \t\tbe32_add_cpu(&ipv4_addr, octets[i] << (i * 8));\n \t}\n \n+\to2nm_lock_subsystem();\n+\tcluster = to_o2nm_cluster_from_node(node);\n+\tif (!cluster) {\n+\t\to2nm_unlock_subsystem();\n+\t\treturn -EINVAL;\n+\t}\n+\n \tret = 0;\n \twrite_lock(&cluster->cl_nodes_lock);\n \tif (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))\n@@ -298,6 +320,8 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n \t\trb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n \t}\n \twrite_unlock(&cluster->cl_nodes_lock);\n+\to2nm_unlock_subsystem();\n+\n \tif (ret)\n \t\treturn ret;\n \n@@ -315,7 +339,7 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n \t\t\t\t     size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n-\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n+\tstruct o2nm_cluster *cluster;\n \tunsigned long tmp;\n \tchar *p = (char *)page;\n \tssize_t ret;\n@@ -333,17 +357,26 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n \t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n \t\treturn -EINVAL; /* XXX */\n \n+\to2nm_lock_subsystem();\n+\tcluster = to_o2nm_cluster_from_node(node);\n+\tif (!cluster) {\n+\t\tret = -EINVAL;\n+\t\tgoto out;\n+\t}\n+\n \t/* the only failure case is trying to set a new local node\n \t * when a different one is already set */\n \tif (tmp && tmp == cluster->cl_has_local &&\n-\t    cluster->cl_local_node != node->nd_num)\n-\t\treturn -EBUSY;\n+\t    cluster->cl_local_node != node->nd_num) {\n+\t\tret = -EBUSY;\n+\t\tgoto out;\n+\t}\n \n \t/* bring up the rx thread if we're setting the new local node. */\n \tif (tmp && !cluster->cl_has_local) {\n \t\tret = o2net_start_listening(node);\n \t\tif (ret)\n-\t\t\treturn ret;\n+\t\t\tgoto out;\n \t}\n \n \tif (!tmp && cluster->cl_has_local &&\n@@ -358,7 +391,11 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n \t\tcluster->cl_local_node = node->nd_num;\n \t}\n \n-\treturn count;\n+\tret = count;\n+\n+out:\n+\to2nm_unlock_subsystem();\n+\treturn ret;\n }\n \n CONFIGFS_ATTR(o2nm_node_, num);\n@@ -738,6 +775,16 @@ static struct o2nm_cluster_group o2nm_cluster_group = {\n \t},\n };\n \n+static inline void o2nm_lock_subsystem(void)\n+{\n+\tmutex_lock(&o2nm_cluster_group.cs_subsys.su_mutex);\n+}\n+\n+static inline void o2nm_unlock_subsystem(void)\n+{\n+\tmutex_unlock(&o2nm_cluster_group.cs_subsys.su_mutex);\n+}\n+\n int o2nm_depend_item(struct config_item *item)\n {\n \treturn configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);""}","static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
 				   size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
	struct o2nm_cluster *cluster;
 	unsigned long tmp;
 	char *p = (char *)page;
 	int ret = 0;

	tmp = simple_strtoul(p, &p, 0);
	if (!p || (*p && (*p != '\n')))
		return -EINVAL;

	if (tmp >= O2NM_MAX_NODES)
		return -ERANGE;

	/* once we're in the cl_nodes tree networking can look us up by
	 * node number and try to use our address and port attributes
	 * to connect to this node.. make sure that they've been set
	 * before writing the node attribute? */
	if (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||
 	    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
 		return -EINVAL; /* XXX */
 
	o2nm_lock_subsystem();
	cluster = to_o2nm_cluster_from_node(node);
	if (!cluster) {
		o2nm_unlock_subsystem();
		return -EINVAL;
	}

 	write_lock(&cluster->cl_nodes_lock);
 	if (cluster->cl_nodes[tmp])
 		ret = -EEXIST;
	else if (test_and_set_bit(O2NM_NODE_ATTR_NUM,
			&node->nd_set_attributes))
		ret = -EBUSY;
	else  {
		cluster->cl_nodes[tmp] = node;
		node->nd_num = tmp;
 		set_bit(tmp, cluster->cl_nodes_bitmap);
 	}
 	write_unlock(&cluster->cl_nodes_lock);
	o2nm_unlock_subsystem();

 	if (ret)
 		return ret;
 
	return count;
}
","static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
 				   size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
 	unsigned long tmp;
 	char *p = (char *)page;
 	int ret = 0;

	tmp = simple_strtoul(p, &p, 0);
	if (!p || (*p && (*p != '\n')))
		return -EINVAL;

	if (tmp >= O2NM_MAX_NODES)
		return -ERANGE;

	/* once we're in the cl_nodes tree networking can look us up by
	 * node number and try to use our address and port attributes
	 * to connect to this node.. make sure that they've been set
	 * before writing the node attribute? */
	if (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||
 	    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
 		return -EINVAL; /* XXX */
 
 	write_lock(&cluster->cl_nodes_lock);
 	if (cluster->cl_nodes[tmp])
 		ret = -EEXIST;
	else if (test_and_set_bit(O2NM_NODE_ATTR_NUM,
			&node->nd_set_attributes))
		ret = -EBUSY;
	else  {
		cluster->cl_nodes[tmp] = node;
		node->nd_num = tmp;
 		set_bit(tmp, cluster->cl_nodes_bitmap);
 	}
 	write_unlock(&cluster->cl_nodes_lock);
 	if (ret)
 		return ret;
 
	return count;
}
",C,"	struct o2nm_cluster *cluster;
	o2nm_lock_subsystem();
	cluster = to_o2nm_cluster_from_node(node);
	if (!cluster) {
		o2nm_unlock_subsystem();
		return -EINVAL;
	}

	o2nm_unlock_subsystem();

","	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
",,"@@ -40,6 +40,9 @@ char *o2nm_fence_method_desc[O2NM_FENCE_METHODS] = {
 		""panic"",	/* O2NM_FENCE_PANIC */
 };
 
+static inline void o2nm_lock_subsystem(void);
+static inline void o2nm_unlock_subsystem(void);
+
 struct o2nm_node *o2nm_get_node_by_num(u8 node_num)
 {
 	struct o2nm_node *node = NULL;
@@ -181,7 +184,10 @@ static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)
 {
 	/* through the first node_set .parent
 	 * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */
-	return to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);
+	if (node->nd_item.ci_parent)
+		return to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);
+	else
+		return NULL;
 }
 
 enum {
@@ -194,7 +200,7 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
 				   size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
-	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
+	struct o2nm_cluster *cluster;
 	unsigned long tmp;
 	char *p = (char *)page;
 	int ret = 0;
@@ -214,6 +220,13 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
 	    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
 		return -EINVAL; /* XXX */
 
+	o2nm_lock_subsystem();
+	cluster = to_o2nm_cluster_from_node(node);
+	if (!cluster) {
+		o2nm_unlock_subsystem();
+		return -EINVAL;
+	}
+
 	write_lock(&cluster->cl_nodes_lock);
 	if (cluster->cl_nodes[tmp])
 		ret = -EEXIST;
@@ -226,6 +239,8 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
 		set_bit(tmp, cluster->cl_nodes_bitmap);
 	}
 	write_unlock(&cluster->cl_nodes_lock);
+	o2nm_unlock_subsystem();
+
 	if (ret)
 		return ret;
 
@@ -269,7 +284,7 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,
 					    size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
-	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
+	struct o2nm_cluster *cluster;
 	int ret, i;
 	struct rb_node **p, *parent;
 	unsigned int octets[4];
@@ -286,6 +301,13 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,
 		be32_add_cpu(&ipv4_addr, octets[i] << (i * 8));
 	}
 
+	o2nm_lock_subsystem();
+	cluster = to_o2nm_cluster_from_node(node);
+	if (!cluster) {
+		o2nm_unlock_subsystem();
+		return -EINVAL;
+	}
+
 	ret = 0;
 	write_lock(&cluster->cl_nodes_lock);
 	if (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))
@@ -298,6 +320,8 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,
 		rb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);
 	}
 	write_unlock(&cluster->cl_nodes_lock);
+	o2nm_unlock_subsystem();
+
 	if (ret)
 		return ret;
 
@@ -315,7 +339,7 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,
 				     size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
-	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
+	struct o2nm_cluster *cluster;
 	unsigned long tmp;
 	char *p = (char *)page;
 	ssize_t ret;
@@ -333,17 +357,26 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,
 	    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
 		return -EINVAL; /* XXX */
 
+	o2nm_lock_subsystem();
+	cluster = to_o2nm_cluster_from_node(node);
+	if (!cluster) {
+		ret = -EINVAL;
+		goto out;
+	}
+
 	/* the only failure case is trying to set a new local node
 	 * when a different one is already set */
 	if (tmp && tmp == cluster->cl_has_local &&
-	    cluster->cl_local_node != node->nd_num)
-		return -EBUSY;
+	    cluster->cl_local_node != node->nd_num) {
+		ret = -EBUSY;
+		goto out;
+	}
 
 	/* bring up the rx thread if we're setting the new local node. */
 	if (tmp && !cluster->cl_has_local) {
 		ret = o2net_start_listening(node);
 		if (ret)
-			return ret;
+			goto out;
 	}
 
 	if (!tmp && cluster->cl_has_local &&
@@ -358,7 +391,11 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,
 		cluster->cl_local_node = node->nd_num;
 	}
 
-	return count;
+	ret = count;
+
+out:
+	o2nm_unlock_subsystem();
+	return ret;
 }
 
 CONFIGFS_ATTR(o2nm_node_, num);
@@ -738,6 +775,16 @@ static struct o2nm_cluster_group o2nm_cluster_group = {
 	},
 };
 
+static inline void o2nm_lock_subsystem(void)
+{
+	mutex_lock(&o2nm_cluster_group.cs_subsys.su_mutex);
+}
+
+static inline void o2nm_unlock_subsystem(void)
+{
+	mutex_unlock(&o2nm_cluster_group.cs_subsys.su_mutex);
+}
+
 int o2nm_depend_item(struct config_item *item)
 {
 	return configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);",linux,853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,3e4c56d41eef5595035872a2ec5a483f42e8917f,1,"static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
 				   size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
//flaw_line_below:
	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
//fix_flaw_line_below:
//	struct o2nm_cluster *cluster;
 	unsigned long tmp;
 	char *p = (char *)page;
 	int ret = 0;

	tmp = simple_strtoul(p, &p, 0);
	if (!p || (*p && (*p != '\n')))
		return -EINVAL;

	if (tmp >= O2NM_MAX_NODES)
		return -ERANGE;

	/* once we're in the cl_nodes tree networking can look us up by
	 * node number and try to use our address and port attributes
	 * to connect to this node.. make sure that they've been set
	 * before writing the node attribute? */
	if (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||
 	    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
 		return -EINVAL; /* XXX */
 
//fix_flaw_line_below:
//	o2nm_lock_subsystem();
//fix_flaw_line_below:
//	cluster = to_o2nm_cluster_from_node(node);
//fix_flaw_line_below:
//	if (!cluster) {
//fix_flaw_line_below:
//		o2nm_unlock_subsystem();
//fix_flaw_line_below:
//		return -EINVAL;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	write_lock(&cluster->cl_nodes_lock);
 	if (cluster->cl_nodes[tmp])
 		ret = -EEXIST;
	else if (test_and_set_bit(O2NM_NODE_ATTR_NUM,
			&node->nd_set_attributes))
		ret = -EBUSY;
	else  {
		cluster->cl_nodes[tmp] = node;
		node->nd_num = tmp;
 		set_bit(tmp, cluster->cl_nodes_bitmap);
 	}
 	write_unlock(&cluster->cl_nodes_lock);
//fix_flaw_line_below:
//	o2nm_unlock_subsystem();
//fix_flaw_line_below:
//
 	if (ret)
 		return ret;
 
	return count;
}
"
4844,182580,,Local,Not required,Partial,CVE-2017-18216,https://www.cvedetails.com/cve/CVE-2017-18216/,CWE-476,Low,,,,2018-03-05,2.1,"In fs/ocfs2/cluster/nodemanager.c in the Linux kernel before 4.15, local users can cause a denial of service (NULL pointer dereference and BUG) because a required mutex is not used.",2018-10-30,DoS ,4,https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,"ocfs2: subsystem.su_mutex is required while accessing the item->ci_parent

The subsystem.su_mutex is required while accessing the item->ci_parent,
otherwise, NULL pointer dereference to the item->ci_parent will be
triggered in the following situation:

add node                     delete node
sys_write
 vfs_write
  configfs_write_file
   o2nm_node_store
    o2nm_node_local_write
                             do_rmdir
                              vfs_rmdir
                               configfs_rmdir
                                mutex_lock(&subsys->su_mutex);
                                unlink_obj
                                 item->ci_group = NULL;
                                 item->ci_parent = NULL;
	 to_o2nm_cluster_from_node
	  node->nd_item.ci_parent->ci_parent
	  BUG since of NULL pointer dereference to nd_item.ci_parent

Moreover, the o2nm_cluster also should be protected by the
subsystem.su_mutex.

[alex.chen@huawei.com: v2]
  Link: http://lkml.kernel.org/r/59EEAA69.9080703@huawei.com
Link: http://lkml.kernel.org/r/59E9B36A.10700@huawei.com
Signed-off-by: Alex Chen <alex.chen@huawei.com>
Reviewed-by: Jun Piao <piaojun@huawei.com>
Reviewed-by: Joseph Qi <jiangqi903@gmail.com>
Cc: Mark Fasheh <mfasheh@versity.com>
Cc: Joel Becker <jlbec@evilplan.org>
Cc: Junxiao Bi <junxiao.bi@oracle.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",1,fs/ocfs2/cluster/nodemanager.c,"{""sha"": ""da64c3a20eebd23567944363296d4cdfca60f508"", ""filename"": ""fs/ocfs2/cluster/nodemanager.c"", ""status"": ""modified"", ""additions"": 55, ""deletions"": 8, ""changes"": 63, ""blob_url"": ""https://github.com/torvalds/linux/blob/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2/fs/ocfs2/cluster/nodemanager.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2/fs/ocfs2/cluster/nodemanager.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ocfs2/cluster/nodemanager.c?ref=853bc26a7ea39e354b9f8889ae7ad1492ffa28d2"", ""patch"": ""@@ -40,6 +40,9 @@ char *o2nm_fence_method_desc[O2NM_FENCE_METHODS] = {\n \t\t\""panic\"",\t/* O2NM_FENCE_PANIC */\n };\n \n+static inline void o2nm_lock_subsystem(void);\n+static inline void o2nm_unlock_subsystem(void);\n+\n struct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n {\n \tstruct o2nm_node *node = NULL;\n@@ -181,7 +184,10 @@ static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n {\n \t/* through the first node_set .parent\n \t * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */\n-\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n+\tif (node->nd_item.ci_parent)\n+\t\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n+\telse\n+\t\treturn NULL;\n }\n \n enum {\n@@ -194,7 +200,7 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n \t\t\t\t   size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n-\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n+\tstruct o2nm_cluster *cluster;\n \tunsigned long tmp;\n \tchar *p = (char *)page;\n \tint ret = 0;\n@@ -214,6 +220,13 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n \t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n \t\treturn -EINVAL; /* XXX */\n \n+\to2nm_lock_subsystem();\n+\tcluster = to_o2nm_cluster_from_node(node);\n+\tif (!cluster) {\n+\t\to2nm_unlock_subsystem();\n+\t\treturn -EINVAL;\n+\t}\n+\n \twrite_lock(&cluster->cl_nodes_lock);\n \tif (cluster->cl_nodes[tmp])\n \t\tret = -EEXIST;\n@@ -226,6 +239,8 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n \t\tset_bit(tmp, cluster->cl_nodes_bitmap);\n \t}\n \twrite_unlock(&cluster->cl_nodes_lock);\n+\to2nm_unlock_subsystem();\n+\n \tif (ret)\n \t\treturn ret;\n \n@@ -269,7 +284,7 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n \t\t\t\t\t    size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n-\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n+\tstruct o2nm_cluster *cluster;\n \tint ret, i;\n \tstruct rb_node **p, *parent;\n \tunsigned int octets[4];\n@@ -286,6 +301,13 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n \t\tbe32_add_cpu(&ipv4_addr, octets[i] << (i * 8));\n \t}\n \n+\to2nm_lock_subsystem();\n+\tcluster = to_o2nm_cluster_from_node(node);\n+\tif (!cluster) {\n+\t\to2nm_unlock_subsystem();\n+\t\treturn -EINVAL;\n+\t}\n+\n \tret = 0;\n \twrite_lock(&cluster->cl_nodes_lock);\n \tif (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))\n@@ -298,6 +320,8 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n \t\trb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n \t}\n \twrite_unlock(&cluster->cl_nodes_lock);\n+\to2nm_unlock_subsystem();\n+\n \tif (ret)\n \t\treturn ret;\n \n@@ -315,7 +339,7 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n \t\t\t\t     size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n-\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n+\tstruct o2nm_cluster *cluster;\n \tunsigned long tmp;\n \tchar *p = (char *)page;\n \tssize_t ret;\n@@ -333,17 +357,26 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n \t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n \t\treturn -EINVAL; /* XXX */\n \n+\to2nm_lock_subsystem();\n+\tcluster = to_o2nm_cluster_from_node(node);\n+\tif (!cluster) {\n+\t\tret = -EINVAL;\n+\t\tgoto out;\n+\t}\n+\n \t/* the only failure case is trying to set a new local node\n \t * when a different one is already set */\n \tif (tmp && tmp == cluster->cl_has_local &&\n-\t    cluster->cl_local_node != node->nd_num)\n-\t\treturn -EBUSY;\n+\t    cluster->cl_local_node != node->nd_num) {\n+\t\tret = -EBUSY;\n+\t\tgoto out;\n+\t}\n \n \t/* bring up the rx thread if we're setting the new local node. */\n \tif (tmp && !cluster->cl_has_local) {\n \t\tret = o2net_start_listening(node);\n \t\tif (ret)\n-\t\t\treturn ret;\n+\t\t\tgoto out;\n \t}\n \n \tif (!tmp && cluster->cl_has_local &&\n@@ -358,7 +391,11 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n \t\tcluster->cl_local_node = node->nd_num;\n \t}\n \n-\treturn count;\n+\tret = count;\n+\n+out:\n+\to2nm_unlock_subsystem();\n+\treturn ret;\n }\n \n CONFIGFS_ATTR(o2nm_node_, num);\n@@ -738,6 +775,16 @@ static struct o2nm_cluster_group o2nm_cluster_group = {\n \t},\n };\n \n+static inline void o2nm_lock_subsystem(void)\n+{\n+\tmutex_lock(&o2nm_cluster_group.cs_subsys.su_mutex);\n+}\n+\n+static inline void o2nm_unlock_subsystem(void)\n+{\n+\tmutex_unlock(&o2nm_cluster_group.cs_subsys.su_mutex);\n+}\n+\n int o2nm_depend_item(struct config_item *item)\n {\n \treturn configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);""}","static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)
 {
 	/* through the first node_set .parent
 	 * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */
	if (node->nd_item.ci_parent)
		return to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);
	else
		return NULL;
 }
","static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)
 {
 	/* through the first node_set .parent
 	 * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */
	return to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);
 }
",C,"	if (node->nd_item.ci_parent)
		return to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);
	else
		return NULL;
","	return to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);
",,"@@ -40,6 +40,9 @@ char *o2nm_fence_method_desc[O2NM_FENCE_METHODS] = {
 		""panic"",	/* O2NM_FENCE_PANIC */
 };
 
+static inline void o2nm_lock_subsystem(void);
+static inline void o2nm_unlock_subsystem(void);
+
 struct o2nm_node *o2nm_get_node_by_num(u8 node_num)
 {
 	struct o2nm_node *node = NULL;
@@ -181,7 +184,10 @@ static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)
 {
 	/* through the first node_set .parent
 	 * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */
-	return to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);
+	if (node->nd_item.ci_parent)
+		return to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);
+	else
+		return NULL;
 }
 
 enum {
@@ -194,7 +200,7 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
 				   size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
-	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
+	struct o2nm_cluster *cluster;
 	unsigned long tmp;
 	char *p = (char *)page;
 	int ret = 0;
@@ -214,6 +220,13 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
 	    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
 		return -EINVAL; /* XXX */
 
+	o2nm_lock_subsystem();
+	cluster = to_o2nm_cluster_from_node(node);
+	if (!cluster) {
+		o2nm_unlock_subsystem();
+		return -EINVAL;
+	}
+
 	write_lock(&cluster->cl_nodes_lock);
 	if (cluster->cl_nodes[tmp])
 		ret = -EEXIST;
@@ -226,6 +239,8 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
 		set_bit(tmp, cluster->cl_nodes_bitmap);
 	}
 	write_unlock(&cluster->cl_nodes_lock);
+	o2nm_unlock_subsystem();
+
 	if (ret)
 		return ret;
 
@@ -269,7 +284,7 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,
 					    size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
-	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
+	struct o2nm_cluster *cluster;
 	int ret, i;
 	struct rb_node **p, *parent;
 	unsigned int octets[4];
@@ -286,6 +301,13 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,
 		be32_add_cpu(&ipv4_addr, octets[i] << (i * 8));
 	}
 
+	o2nm_lock_subsystem();
+	cluster = to_o2nm_cluster_from_node(node);
+	if (!cluster) {
+		o2nm_unlock_subsystem();
+		return -EINVAL;
+	}
+
 	ret = 0;
 	write_lock(&cluster->cl_nodes_lock);
 	if (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))
@@ -298,6 +320,8 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,
 		rb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);
 	}
 	write_unlock(&cluster->cl_nodes_lock);
+	o2nm_unlock_subsystem();
+
 	if (ret)
 		return ret;
 
@@ -315,7 +339,7 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,
 				     size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
-	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
+	struct o2nm_cluster *cluster;
 	unsigned long tmp;
 	char *p = (char *)page;
 	ssize_t ret;
@@ -333,17 +357,26 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,
 	    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
 		return -EINVAL; /* XXX */
 
+	o2nm_lock_subsystem();
+	cluster = to_o2nm_cluster_from_node(node);
+	if (!cluster) {
+		ret = -EINVAL;
+		goto out;
+	}
+
 	/* the only failure case is trying to set a new local node
 	 * when a different one is already set */
 	if (tmp && tmp == cluster->cl_has_local &&
-	    cluster->cl_local_node != node->nd_num)
-		return -EBUSY;
+	    cluster->cl_local_node != node->nd_num) {
+		ret = -EBUSY;
+		goto out;
+	}
 
 	/* bring up the rx thread if we're setting the new local node. */
 	if (tmp && !cluster->cl_has_local) {
 		ret = o2net_start_listening(node);
 		if (ret)
-			return ret;
+			goto out;
 	}
 
 	if (!tmp && cluster->cl_has_local &&
@@ -358,7 +391,11 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,
 		cluster->cl_local_node = node->nd_num;
 	}
 
-	return count;
+	ret = count;
+
+out:
+	o2nm_unlock_subsystem();
+	return ret;
 }
 
 CONFIGFS_ATTR(o2nm_node_, num);
@@ -738,6 +775,16 @@ static struct o2nm_cluster_group o2nm_cluster_group = {
 	},
 };
 
+static inline void o2nm_lock_subsystem(void)
+{
+	mutex_lock(&o2nm_cluster_group.cs_subsys.su_mutex);
+}
+
+static inline void o2nm_unlock_subsystem(void)
+{
+	mutex_unlock(&o2nm_cluster_group.cs_subsys.su_mutex);
+}
+
 int o2nm_depend_item(struct config_item *item)
 {
 	return configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);",linux,853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,3e4c56d41eef5595035872a2ec5a483f42e8917f,1,"static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)
 {
 	/* through the first node_set .parent
 	 * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */
//flaw_line_below:
	return to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);
//fix_flaw_line_below:
//	if (node->nd_item.ci_parent)
//fix_flaw_line_below:
//		return to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);
//fix_flaw_line_below:
//	else
//fix_flaw_line_below:
//		return NULL;
 }
"
4857,182593,,Local,Not required,Complete,CVE-2017-18079,https://www.cvedetails.com/cve/CVE-2017-18079/,CWE-476,Low,Complete,Complete,,2018-01-29,7.2,drivers/input/serio/i8042.c in the Linux kernel before 4.12.4 allows attackers to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact because the port->exists value can change after it is validated.,2019-01-19,DoS ,1,https://github.com/torvalds/linux/commit/340d394a789518018f834ff70f7534fc463d3226,340d394a789518018f834ff70f7534fc463d3226,"Input: i8042 - fix crash at boot time

The driver checks port->exists twice in i8042_interrupt(), first when
trying to assign temporary ""serio"" variable, and second time when deciding
whether it should call serio_interrupt(). The value of port->exists may
change between the 2 checks, and we may end up calling serio_interrupt()
with a NULL pointer:

BUG: unable to handle kernel NULL pointer dereference at 0000000000000050
IP: [<ffffffff8150feaf>] _spin_lock_irqsave+0x1f/0x40
PGD 0
Oops: 0002 [#1] SMP
last sysfs file:
CPU 0
Modules linked in:

Pid: 1, comm: swapper Not tainted 2.6.32-358.el6.x86_64 #1 QEMU Standard PC (i440FX + PIIX, 1996)
RIP: 0010:[<ffffffff8150feaf>]  [<ffffffff8150feaf>] _spin_lock_irqsave+0x1f/0x40
RSP: 0018:ffff880028203cc0  EFLAGS: 00010082
RAX: 0000000000010000 RBX: 0000000000000000 RCX: 0000000000000000
RDX: 0000000000000282 RSI: 0000000000000098 RDI: 0000000000000050
RBP: ffff880028203cc0 R08: ffff88013e79c000 R09: ffff880028203ee0
R10: 0000000000000298 R11: 0000000000000282 R12: 0000000000000050
R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000098
FS:  0000000000000000(0000) GS:ffff880028200000(0000) knlGS:0000000000000000
CS:  0010 DS: 0018 ES: 0018 CR0: 000000008005003b
CR2: 0000000000000050 CR3: 0000000001a85000 CR4: 00000000001407f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
Process swapper (pid: 1, threadinfo ffff88013e79c000, task ffff88013e79b500)
Stack:
ffff880028203d00 ffffffff813de186 ffffffffffffff02 0000000000000000
<d> 0000000000000000 0000000000000000 0000000000000000 0000000000000098
<d> ffff880028203d70 ffffffff813e0162 ffff880028203d20 ffffffff8103b8ac
Call Trace:
<IRQ>
 [<ffffffff813de186>] serio_interrupt+0x36/0xa0
[<ffffffff813e0162>] i8042_interrupt+0x132/0x3a0
[<ffffffff8103b8ac>] ? kvm_clock_read+0x1c/0x20
[<ffffffff8103b8b9>] ? kvm_clock_get_cycles+0x9/0x10
[<ffffffff810e1640>] handle_IRQ_event+0x60/0x170
[<ffffffff8103b154>] ? kvm_guest_apic_eoi_write+0x44/0x50
[<ffffffff810e3d8e>] handle_edge_irq+0xde/0x180
[<ffffffff8100de89>] handle_irq+0x49/0xa0
[<ffffffff81516c8c>] do_IRQ+0x6c/0xf0
[<ffffffff8100b9d3>] ret_from_intr+0x0/0x11
[<ffffffff81076f63>] ? __do_softirq+0x73/0x1e0
[<ffffffff8109b75b>] ? hrtimer_interrupt+0x14b/0x260
[<ffffffff8100c1cc>] ? call_softirq+0x1c/0x30
[<ffffffff8100de05>] ? do_softirq+0x65/0xa0
[<ffffffff81076d95>] ? irq_exit+0x85/0x90
[<ffffffff81516d80>] ? smp_apic_timer_interrupt+0x70/0x9b
[<ffffffff8100bb93>] ? apic_timer_interrupt+0x13/0x20

To avoid the issue let's change the second check to test whether serio is
NULL or not.

Also, let's take i8042_lock in i8042_start() and i8042_stop() instead of
trying to be overly smart and using memory barriers.

Signed-off-by: Chen Hong <chenhong3@huawei.com>
[dtor: take lock in i8042_start()/i8042_stop()]
Cc: stable@vger.kernel.org
Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>",1,drivers/input/serio/i8042.c,"{""sha"": ""824f4c1c1f3103dab4596ffc287c438fbc0345b3"", ""filename"": ""drivers/input/serio/i8042.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 3, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/340d394a789518018f834ff70f7534fc463d3226/drivers/input/serio/i8042.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/340d394a789518018f834ff70f7534fc463d3226/drivers/input/serio/i8042.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/input/serio/i8042.c?ref=340d394a789518018f834ff70f7534fc463d3226"", ""patch"": ""@@ -436,8 +436,10 @@ static int i8042_start(struct serio *serio)\n {\n \tstruct i8042_port *port = serio->port_data;\n \n+\tspin_lock_irq(&i8042_lock);\n \tport->exists = true;\n-\tmb();\n+\tspin_unlock_irq(&i8042_lock);\n+\n \treturn 0;\n }\n \n@@ -450,16 +452,20 @@ static void i8042_stop(struct serio *serio)\n {\n \tstruct i8042_port *port = serio->port_data;\n \n+\tspin_lock_irq(&i8042_lock);\n \tport->exists = false;\n+\tport->serio = NULL;\n+\tspin_unlock_irq(&i8042_lock);\n \n \t/*\n+\t * We need to make sure that interrupt handler finishes using\n+\t * our serio port before we return from this function.\n \t * We synchronize with both AUX and KBD IRQs because there is\n \t * a (very unlikely) chance that AUX IRQ is raised for KBD port\n \t * and vice versa.\n \t */\n \tsynchronize_irq(I8042_AUX_IRQ);\n \tsynchronize_irq(I8042_KBD_IRQ);\n-\tport->serio = NULL;\n }\n \n /*\n@@ -576,7 +582,7 @@ static irqreturn_t i8042_interrupt(int irq, void *dev_id)\n \n \tspin_unlock_irqrestore(&i8042_lock, flags);\n \n-\tif (likely(port->exists && !filtered))\n+\tif (likely(serio && !filtered))\n \t\tserio_interrupt(serio, data, dfl);\n \n  out:""}","static irqreturn_t i8042_interrupt(int irq, void *dev_id)
{
	struct i8042_port *port;
	struct serio *serio;
	unsigned long flags;
	unsigned char str, data;
	unsigned int dfl;
	unsigned int port_no;
	bool filtered;
	int ret = 1;

	spin_lock_irqsave(&i8042_lock, flags);

	str = i8042_read_status();
	if (unlikely(~str & I8042_STR_OBF)) {
		spin_unlock_irqrestore(&i8042_lock, flags);
		if (irq)
			dbg(""Interrupt %d, without any data\n"", irq);
		ret = 0;
		goto out;
	}

	data = i8042_read_data();

	if (i8042_mux_present && (str & I8042_STR_AUXDATA)) {
		static unsigned long last_transmit;
		static unsigned char last_str;

		dfl = 0;
		if (str & I8042_STR_MUXERR) {
			dbg(""MUX error, status is %02x, data is %02x\n"",
			    str, data);
/*
 * When MUXERR condition is signalled the data register can only contain
 * 0xfd, 0xfe or 0xff if implementation follows the spec. Unfortunately
 * it is not always the case. Some KBCs also report 0xfc when there is
 * nothing connected to the port while others sometimes get confused which
 * port the data came from and signal error leaving the data intact. They
 * _do not_ revert to legacy mode (actually I've never seen KBC reverting
 * to legacy mode yet, when we see one we'll add proper handling).
 * Anyway, we process 0xfc, 0xfd, 0xfe and 0xff as timeouts, and for the
 * rest assume that the data came from the same serio last byte
 * was transmitted (if transmission happened not too long ago).
 */

			switch (data) {
				default:
					if (time_before(jiffies, last_transmit + HZ/10)) {
						str = last_str;
						break;
					}
					/* fall through - report timeout */
				case 0xfc:
				case 0xfd:
				case 0xfe: dfl = SERIO_TIMEOUT; data = 0xfe; break;
				case 0xff: dfl = SERIO_PARITY;  data = 0xfe; break;
			}
		}

		port_no = I8042_MUX_PORT_NO + ((str >> 6) & 3);
		last_str = str;
		last_transmit = jiffies;
	} else {

		dfl = ((str & I8042_STR_PARITY) ? SERIO_PARITY : 0) |
		      ((str & I8042_STR_TIMEOUT && !i8042_notimeout) ? SERIO_TIMEOUT : 0);

		port_no = (str & I8042_STR_AUXDATA) ?
				I8042_AUX_PORT_NO : I8042_KBD_PORT_NO;
	}

	port = &i8042_ports[port_no];
	serio = port->exists ? port->serio : NULL;

	filter_dbg(port->driver_bound, data, ""<- i8042 (interrupt, %d, %d%s%s)\n"",
		   port_no, irq,
		   dfl & SERIO_PARITY ? "", bad parity"" : """",
		   dfl & SERIO_TIMEOUT ? "", timeout"" : """");

	filtered = i8042_filter(data, str, serio);
 
 	spin_unlock_irqrestore(&i8042_lock, flags);
 
	if (likely(serio && !filtered))
 		serio_interrupt(serio, data, dfl);
 
  out:
	return IRQ_RETVAL(ret);
}
","static irqreturn_t i8042_interrupt(int irq, void *dev_id)
{
	struct i8042_port *port;
	struct serio *serio;
	unsigned long flags;
	unsigned char str, data;
	unsigned int dfl;
	unsigned int port_no;
	bool filtered;
	int ret = 1;

	spin_lock_irqsave(&i8042_lock, flags);

	str = i8042_read_status();
	if (unlikely(~str & I8042_STR_OBF)) {
		spin_unlock_irqrestore(&i8042_lock, flags);
		if (irq)
			dbg(""Interrupt %d, without any data\n"", irq);
		ret = 0;
		goto out;
	}

	data = i8042_read_data();

	if (i8042_mux_present && (str & I8042_STR_AUXDATA)) {
		static unsigned long last_transmit;
		static unsigned char last_str;

		dfl = 0;
		if (str & I8042_STR_MUXERR) {
			dbg(""MUX error, status is %02x, data is %02x\n"",
			    str, data);
/*
 * When MUXERR condition is signalled the data register can only contain
 * 0xfd, 0xfe or 0xff if implementation follows the spec. Unfortunately
 * it is not always the case. Some KBCs also report 0xfc when there is
 * nothing connected to the port while others sometimes get confused which
 * port the data came from and signal error leaving the data intact. They
 * _do not_ revert to legacy mode (actually I've never seen KBC reverting
 * to legacy mode yet, when we see one we'll add proper handling).
 * Anyway, we process 0xfc, 0xfd, 0xfe and 0xff as timeouts, and for the
 * rest assume that the data came from the same serio last byte
 * was transmitted (if transmission happened not too long ago).
 */

			switch (data) {
				default:
					if (time_before(jiffies, last_transmit + HZ/10)) {
						str = last_str;
						break;
					}
					/* fall through - report timeout */
				case 0xfc:
				case 0xfd:
				case 0xfe: dfl = SERIO_TIMEOUT; data = 0xfe; break;
				case 0xff: dfl = SERIO_PARITY;  data = 0xfe; break;
			}
		}

		port_no = I8042_MUX_PORT_NO + ((str >> 6) & 3);
		last_str = str;
		last_transmit = jiffies;
	} else {

		dfl = ((str & I8042_STR_PARITY) ? SERIO_PARITY : 0) |
		      ((str & I8042_STR_TIMEOUT && !i8042_notimeout) ? SERIO_TIMEOUT : 0);

		port_no = (str & I8042_STR_AUXDATA) ?
				I8042_AUX_PORT_NO : I8042_KBD_PORT_NO;
	}

	port = &i8042_ports[port_no];
	serio = port->exists ? port->serio : NULL;

	filter_dbg(port->driver_bound, data, ""<- i8042 (interrupt, %d, %d%s%s)\n"",
		   port_no, irq,
		   dfl & SERIO_PARITY ? "", bad parity"" : """",
		   dfl & SERIO_TIMEOUT ? "", timeout"" : """");

	filtered = i8042_filter(data, str, serio);
 
 	spin_unlock_irqrestore(&i8042_lock, flags);
 
	if (likely(port->exists && !filtered))
 		serio_interrupt(serio, data, dfl);
 
  out:
	return IRQ_RETVAL(ret);
}
",C,"	if (likely(serio && !filtered))
","	if (likely(port->exists && !filtered))
",,"@@ -436,8 +436,10 @@ static int i8042_start(struct serio *serio)
 {
 	struct i8042_port *port = serio->port_data;
 
+	spin_lock_irq(&i8042_lock);
 	port->exists = true;
-	mb();
+	spin_unlock_irq(&i8042_lock);
+
 	return 0;
 }
 
@@ -450,16 +452,20 @@ static void i8042_stop(struct serio *serio)
 {
 	struct i8042_port *port = serio->port_data;
 
+	spin_lock_irq(&i8042_lock);
 	port->exists = false;
+	port->serio = NULL;
+	spin_unlock_irq(&i8042_lock);
 
 	/*
+	 * We need to make sure that interrupt handler finishes using
+	 * our serio port before we return from this function.
 	 * We synchronize with both AUX and KBD IRQs because there is
 	 * a (very unlikely) chance that AUX IRQ is raised for KBD port
 	 * and vice versa.
 	 */
 	synchronize_irq(I8042_AUX_IRQ);
 	synchronize_irq(I8042_KBD_IRQ);
-	port->serio = NULL;
 }
 
 /*
@@ -576,7 +582,7 @@ static irqreturn_t i8042_interrupt(int irq, void *dev_id)
 
 	spin_unlock_irqrestore(&i8042_lock, flags);
 
-	if (likely(port->exists && !filtered))
+	if (likely(serio && !filtered))
 		serio_interrupt(serio, data, dfl);
 
  out:",linux,340d394a789518018f834ff70f7534fc463d3226,0f107573da417c7f5c6d3a0160ebacc3adb019c4,1,"static irqreturn_t i8042_interrupt(int irq, void *dev_id)
{
	struct i8042_port *port;
	struct serio *serio;
	unsigned long flags;
	unsigned char str, data;
	unsigned int dfl;
	unsigned int port_no;
	bool filtered;
	int ret = 1;

	spin_lock_irqsave(&i8042_lock, flags);

	str = i8042_read_status();
	if (unlikely(~str & I8042_STR_OBF)) {
		spin_unlock_irqrestore(&i8042_lock, flags);
		if (irq)
			dbg(""Interrupt %d, without any data\n"", irq);
		ret = 0;
		goto out;
	}

	data = i8042_read_data();

	if (i8042_mux_present && (str & I8042_STR_AUXDATA)) {
		static unsigned long last_transmit;
		static unsigned char last_str;

		dfl = 0;
		if (str & I8042_STR_MUXERR) {
			dbg(""MUX error, status is %02x, data is %02x\n"",
			    str, data);
/*
 * When MUXERR condition is signalled the data register can only contain
 * 0xfd, 0xfe or 0xff if implementation follows the spec. Unfortunately
 * it is not always the case. Some KBCs also report 0xfc when there is
 * nothing connected to the port while others sometimes get confused which
 * port the data came from and signal error leaving the data intact. They
 * _do not_ revert to legacy mode (actually I've never seen KBC reverting
 * to legacy mode yet, when we see one we'll add proper handling).
 * Anyway, we process 0xfc, 0xfd, 0xfe and 0xff as timeouts, and for the
 * rest assume that the data came from the same serio last byte
 * was transmitted (if transmission happened not too long ago).
 */

			switch (data) {
				default:
					if (time_before(jiffies, last_transmit + HZ/10)) {
						str = last_str;
						break;
					}
					/* fall through - report timeout */
				case 0xfc:
				case 0xfd:
				case 0xfe: dfl = SERIO_TIMEOUT; data = 0xfe; break;
				case 0xff: dfl = SERIO_PARITY;  data = 0xfe; break;
			}
		}

		port_no = I8042_MUX_PORT_NO + ((str >> 6) & 3);
		last_str = str;
		last_transmit = jiffies;
	} else {

		dfl = ((str & I8042_STR_PARITY) ? SERIO_PARITY : 0) |
		      ((str & I8042_STR_TIMEOUT && !i8042_notimeout) ? SERIO_TIMEOUT : 0);

		port_no = (str & I8042_STR_AUXDATA) ?
				I8042_AUX_PORT_NO : I8042_KBD_PORT_NO;
	}

	port = &i8042_ports[port_no];
	serio = port->exists ? port->serio : NULL;

	filter_dbg(port->driver_bound, data, ""<- i8042 (interrupt, %d, %d%s%s)\n"",
		   port_no, irq,
		   dfl & SERIO_PARITY ? "", bad parity"" : """",
		   dfl & SERIO_TIMEOUT ? "", timeout"" : """");

	filtered = i8042_filter(data, str, serio);
 
 	spin_unlock_irqrestore(&i8042_lock, flags);
 
//flaw_line_below:
	if (likely(port->exists && !filtered))
//fix_flaw_line_below:
//	if (likely(serio && !filtered))
 		serio_interrupt(serio, data, dfl);
 
  out:
	return IRQ_RETVAL(ret);
}
"
4858,182594,,Local,Not required,Complete,CVE-2017-18079,https://www.cvedetails.com/cve/CVE-2017-18079/,CWE-476,Low,Complete,Complete,,2018-01-29,7.2,drivers/input/serio/i8042.c in the Linux kernel before 4.12.4 allows attackers to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact because the port->exists value can change after it is validated.,2019-01-19,DoS ,3,https://github.com/torvalds/linux/commit/340d394a789518018f834ff70f7534fc463d3226,340d394a789518018f834ff70f7534fc463d3226,"Input: i8042 - fix crash at boot time

The driver checks port->exists twice in i8042_interrupt(), first when
trying to assign temporary ""serio"" variable, and second time when deciding
whether it should call serio_interrupt(). The value of port->exists may
change between the 2 checks, and we may end up calling serio_interrupt()
with a NULL pointer:

BUG: unable to handle kernel NULL pointer dereference at 0000000000000050
IP: [<ffffffff8150feaf>] _spin_lock_irqsave+0x1f/0x40
PGD 0
Oops: 0002 [#1] SMP
last sysfs file:
CPU 0
Modules linked in:

Pid: 1, comm: swapper Not tainted 2.6.32-358.el6.x86_64 #1 QEMU Standard PC (i440FX + PIIX, 1996)
RIP: 0010:[<ffffffff8150feaf>]  [<ffffffff8150feaf>] _spin_lock_irqsave+0x1f/0x40
RSP: 0018:ffff880028203cc0  EFLAGS: 00010082
RAX: 0000000000010000 RBX: 0000000000000000 RCX: 0000000000000000
RDX: 0000000000000282 RSI: 0000000000000098 RDI: 0000000000000050
RBP: ffff880028203cc0 R08: ffff88013e79c000 R09: ffff880028203ee0
R10: 0000000000000298 R11: 0000000000000282 R12: 0000000000000050
R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000098
FS:  0000000000000000(0000) GS:ffff880028200000(0000) knlGS:0000000000000000
CS:  0010 DS: 0018 ES: 0018 CR0: 000000008005003b
CR2: 0000000000000050 CR3: 0000000001a85000 CR4: 00000000001407f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
Process swapper (pid: 1, threadinfo ffff88013e79c000, task ffff88013e79b500)
Stack:
ffff880028203d00 ffffffff813de186 ffffffffffffff02 0000000000000000
<d> 0000000000000000 0000000000000000 0000000000000000 0000000000000098
<d> ffff880028203d70 ffffffff813e0162 ffff880028203d20 ffffffff8103b8ac
Call Trace:
<IRQ>
 [<ffffffff813de186>] serio_interrupt+0x36/0xa0
[<ffffffff813e0162>] i8042_interrupt+0x132/0x3a0
[<ffffffff8103b8ac>] ? kvm_clock_read+0x1c/0x20
[<ffffffff8103b8b9>] ? kvm_clock_get_cycles+0x9/0x10
[<ffffffff810e1640>] handle_IRQ_event+0x60/0x170
[<ffffffff8103b154>] ? kvm_guest_apic_eoi_write+0x44/0x50
[<ffffffff810e3d8e>] handle_edge_irq+0xde/0x180
[<ffffffff8100de89>] handle_irq+0x49/0xa0
[<ffffffff81516c8c>] do_IRQ+0x6c/0xf0
[<ffffffff8100b9d3>] ret_from_intr+0x0/0x11
[<ffffffff81076f63>] ? __do_softirq+0x73/0x1e0
[<ffffffff8109b75b>] ? hrtimer_interrupt+0x14b/0x260
[<ffffffff8100c1cc>] ? call_softirq+0x1c/0x30
[<ffffffff8100de05>] ? do_softirq+0x65/0xa0
[<ffffffff81076d95>] ? irq_exit+0x85/0x90
[<ffffffff81516d80>] ? smp_apic_timer_interrupt+0x70/0x9b
[<ffffffff8100bb93>] ? apic_timer_interrupt+0x13/0x20

To avoid the issue let's change the second check to test whether serio is
NULL or not.

Also, let's take i8042_lock in i8042_start() and i8042_stop() instead of
trying to be overly smart and using memory barriers.

Signed-off-by: Chen Hong <chenhong3@huawei.com>
[dtor: take lock in i8042_start()/i8042_stop()]
Cc: stable@vger.kernel.org
Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>",1,drivers/input/serio/i8042.c,"{""sha"": ""824f4c1c1f3103dab4596ffc287c438fbc0345b3"", ""filename"": ""drivers/input/serio/i8042.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 3, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/340d394a789518018f834ff70f7534fc463d3226/drivers/input/serio/i8042.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/340d394a789518018f834ff70f7534fc463d3226/drivers/input/serio/i8042.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/input/serio/i8042.c?ref=340d394a789518018f834ff70f7534fc463d3226"", ""patch"": ""@@ -436,8 +436,10 @@ static int i8042_start(struct serio *serio)\n {\n \tstruct i8042_port *port = serio->port_data;\n \n+\tspin_lock_irq(&i8042_lock);\n \tport->exists = true;\n-\tmb();\n+\tspin_unlock_irq(&i8042_lock);\n+\n \treturn 0;\n }\n \n@@ -450,16 +452,20 @@ static void i8042_stop(struct serio *serio)\n {\n \tstruct i8042_port *port = serio->port_data;\n \n+\tspin_lock_irq(&i8042_lock);\n \tport->exists = false;\n+\tport->serio = NULL;\n+\tspin_unlock_irq(&i8042_lock);\n \n \t/*\n+\t * We need to make sure that interrupt handler finishes using\n+\t * our serio port before we return from this function.\n \t * We synchronize with both AUX and KBD IRQs because there is\n \t * a (very unlikely) chance that AUX IRQ is raised for KBD port\n \t * and vice versa.\n \t */\n \tsynchronize_irq(I8042_AUX_IRQ);\n \tsynchronize_irq(I8042_KBD_IRQ);\n-\tport->serio = NULL;\n }\n \n /*\n@@ -576,7 +582,7 @@ static irqreturn_t i8042_interrupt(int irq, void *dev_id)\n \n \tspin_unlock_irqrestore(&i8042_lock, flags);\n \n-\tif (likely(port->exists && !filtered))\n+\tif (likely(serio && !filtered))\n \t\tserio_interrupt(serio, data, dfl);\n \n  out:""}","static int i8042_start(struct serio *serio)
 {
 	struct i8042_port *port = serio->port_data;
 
	spin_lock_irq(&i8042_lock);
 	port->exists = true;
	spin_unlock_irq(&i8042_lock);

 	return 0;
 }
","static int i8042_start(struct serio *serio)
 {
 	struct i8042_port *port = serio->port_data;
 
 	port->exists = true;
	mb();
 	return 0;
 }
",C,"	spin_lock_irq(&i8042_lock);
	spin_unlock_irq(&i8042_lock);

","	mb();
",,"@@ -436,8 +436,10 @@ static int i8042_start(struct serio *serio)
 {
 	struct i8042_port *port = serio->port_data;
 
+	spin_lock_irq(&i8042_lock);
 	port->exists = true;
-	mb();
+	spin_unlock_irq(&i8042_lock);
+
 	return 0;
 }
 
@@ -450,16 +452,20 @@ static void i8042_stop(struct serio *serio)
 {
 	struct i8042_port *port = serio->port_data;
 
+	spin_lock_irq(&i8042_lock);
 	port->exists = false;
+	port->serio = NULL;
+	spin_unlock_irq(&i8042_lock);
 
 	/*
+	 * We need to make sure that interrupt handler finishes using
+	 * our serio port before we return from this function.
 	 * We synchronize with both AUX and KBD IRQs because there is
 	 * a (very unlikely) chance that AUX IRQ is raised for KBD port
 	 * and vice versa.
 	 */
 	synchronize_irq(I8042_AUX_IRQ);
 	synchronize_irq(I8042_KBD_IRQ);
-	port->serio = NULL;
 }
 
 /*
@@ -576,7 +582,7 @@ static irqreturn_t i8042_interrupt(int irq, void *dev_id)
 
 	spin_unlock_irqrestore(&i8042_lock, flags);
 
-	if (likely(port->exists && !filtered))
+	if (likely(serio && !filtered))
 		serio_interrupt(serio, data, dfl);
 
  out:",linux,340d394a789518018f834ff70f7534fc463d3226,0f107573da417c7f5c6d3a0160ebacc3adb019c4,1,"static int i8042_start(struct serio *serio)
 {
 	struct i8042_port *port = serio->port_data;
 
//fix_flaw_line_below:
//	spin_lock_irq(&i8042_lock);
 	port->exists = true;
//flaw_line_below:
	mb();
//fix_flaw_line_below:
//	spin_unlock_irq(&i8042_lock);
//fix_flaw_line_below:
//
 	return 0;
 }
"
4859,182595,,Local,Not required,Complete,CVE-2017-18079,https://www.cvedetails.com/cve/CVE-2017-18079/,CWE-476,Low,Complete,Complete,,2018-01-29,7.2,drivers/input/serio/i8042.c in the Linux kernel before 4.12.4 allows attackers to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact because the port->exists value can change after it is validated.,2019-01-19,DoS ,5,https://github.com/torvalds/linux/commit/340d394a789518018f834ff70f7534fc463d3226,340d394a789518018f834ff70f7534fc463d3226,"Input: i8042 - fix crash at boot time

The driver checks port->exists twice in i8042_interrupt(), first when
trying to assign temporary ""serio"" variable, and second time when deciding
whether it should call serio_interrupt(). The value of port->exists may
change between the 2 checks, and we may end up calling serio_interrupt()
with a NULL pointer:

BUG: unable to handle kernel NULL pointer dereference at 0000000000000050
IP: [<ffffffff8150feaf>] _spin_lock_irqsave+0x1f/0x40
PGD 0
Oops: 0002 [#1] SMP
last sysfs file:
CPU 0
Modules linked in:

Pid: 1, comm: swapper Not tainted 2.6.32-358.el6.x86_64 #1 QEMU Standard PC (i440FX + PIIX, 1996)
RIP: 0010:[<ffffffff8150feaf>]  [<ffffffff8150feaf>] _spin_lock_irqsave+0x1f/0x40
RSP: 0018:ffff880028203cc0  EFLAGS: 00010082
RAX: 0000000000010000 RBX: 0000000000000000 RCX: 0000000000000000
RDX: 0000000000000282 RSI: 0000000000000098 RDI: 0000000000000050
RBP: ffff880028203cc0 R08: ffff88013e79c000 R09: ffff880028203ee0
R10: 0000000000000298 R11: 0000000000000282 R12: 0000000000000050
R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000098
FS:  0000000000000000(0000) GS:ffff880028200000(0000) knlGS:0000000000000000
CS:  0010 DS: 0018 ES: 0018 CR0: 000000008005003b
CR2: 0000000000000050 CR3: 0000000001a85000 CR4: 00000000001407f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
Process swapper (pid: 1, threadinfo ffff88013e79c000, task ffff88013e79b500)
Stack:
ffff880028203d00 ffffffff813de186 ffffffffffffff02 0000000000000000
<d> 0000000000000000 0000000000000000 0000000000000000 0000000000000098
<d> ffff880028203d70 ffffffff813e0162 ffff880028203d20 ffffffff8103b8ac
Call Trace:
<IRQ>
 [<ffffffff813de186>] serio_interrupt+0x36/0xa0
[<ffffffff813e0162>] i8042_interrupt+0x132/0x3a0
[<ffffffff8103b8ac>] ? kvm_clock_read+0x1c/0x20
[<ffffffff8103b8b9>] ? kvm_clock_get_cycles+0x9/0x10
[<ffffffff810e1640>] handle_IRQ_event+0x60/0x170
[<ffffffff8103b154>] ? kvm_guest_apic_eoi_write+0x44/0x50
[<ffffffff810e3d8e>] handle_edge_irq+0xde/0x180
[<ffffffff8100de89>] handle_irq+0x49/0xa0
[<ffffffff81516c8c>] do_IRQ+0x6c/0xf0
[<ffffffff8100b9d3>] ret_from_intr+0x0/0x11
[<ffffffff81076f63>] ? __do_softirq+0x73/0x1e0
[<ffffffff8109b75b>] ? hrtimer_interrupt+0x14b/0x260
[<ffffffff8100c1cc>] ? call_softirq+0x1c/0x30
[<ffffffff8100de05>] ? do_softirq+0x65/0xa0
[<ffffffff81076d95>] ? irq_exit+0x85/0x90
[<ffffffff81516d80>] ? smp_apic_timer_interrupt+0x70/0x9b
[<ffffffff8100bb93>] ? apic_timer_interrupt+0x13/0x20

To avoid the issue let's change the second check to test whether serio is
NULL or not.

Also, let's take i8042_lock in i8042_start() and i8042_stop() instead of
trying to be overly smart and using memory barriers.

Signed-off-by: Chen Hong <chenhong3@huawei.com>
[dtor: take lock in i8042_start()/i8042_stop()]
Cc: stable@vger.kernel.org
Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>",1,drivers/input/serio/i8042.c,"{""sha"": ""824f4c1c1f3103dab4596ffc287c438fbc0345b3"", ""filename"": ""drivers/input/serio/i8042.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 3, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/340d394a789518018f834ff70f7534fc463d3226/drivers/input/serio/i8042.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/340d394a789518018f834ff70f7534fc463d3226/drivers/input/serio/i8042.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/input/serio/i8042.c?ref=340d394a789518018f834ff70f7534fc463d3226"", ""patch"": ""@@ -436,8 +436,10 @@ static int i8042_start(struct serio *serio)\n {\n \tstruct i8042_port *port = serio->port_data;\n \n+\tspin_lock_irq(&i8042_lock);\n \tport->exists = true;\n-\tmb();\n+\tspin_unlock_irq(&i8042_lock);\n+\n \treturn 0;\n }\n \n@@ -450,16 +452,20 @@ static void i8042_stop(struct serio *serio)\n {\n \tstruct i8042_port *port = serio->port_data;\n \n+\tspin_lock_irq(&i8042_lock);\n \tport->exists = false;\n+\tport->serio = NULL;\n+\tspin_unlock_irq(&i8042_lock);\n \n \t/*\n+\t * We need to make sure that interrupt handler finishes using\n+\t * our serio port before we return from this function.\n \t * We synchronize with both AUX and KBD IRQs because there is\n \t * a (very unlikely) chance that AUX IRQ is raised for KBD port\n \t * and vice versa.\n \t */\n \tsynchronize_irq(I8042_AUX_IRQ);\n \tsynchronize_irq(I8042_KBD_IRQ);\n-\tport->serio = NULL;\n }\n \n /*\n@@ -576,7 +582,7 @@ static irqreturn_t i8042_interrupt(int irq, void *dev_id)\n \n \tspin_unlock_irqrestore(&i8042_lock, flags);\n \n-\tif (likely(port->exists && !filtered))\n+\tif (likely(serio && !filtered))\n \t\tserio_interrupt(serio, data, dfl);\n \n  out:""}","static void i8042_stop(struct serio *serio)
 {
 	struct i8042_port *port = serio->port_data;
 
	spin_lock_irq(&i8042_lock);
 	port->exists = false;
	port->serio = NULL;
	spin_unlock_irq(&i8042_lock);
 
 	/*
	 * We need to make sure that interrupt handler finishes using
	 * our serio port before we return from this function.
 	 * We synchronize with both AUX and KBD IRQs because there is
 	 * a (very unlikely) chance that AUX IRQ is raised for KBD port
 	 * and vice versa.
 	 */
 	synchronize_irq(I8042_AUX_IRQ);
 	synchronize_irq(I8042_KBD_IRQ);
 }
","static void i8042_stop(struct serio *serio)
 {
 	struct i8042_port *port = serio->port_data;
 
 	port->exists = false;
 
 	/*
 	 * We synchronize with both AUX and KBD IRQs because there is
 	 * a (very unlikely) chance that AUX IRQ is raised for KBD port
 	 * and vice versa.
 	 */
 	synchronize_irq(I8042_AUX_IRQ);
 	synchronize_irq(I8042_KBD_IRQ);
	port->serio = NULL;
 }
",C,"	spin_lock_irq(&i8042_lock);
	port->serio = NULL;
	spin_unlock_irq(&i8042_lock);
	 * We need to make sure that interrupt handler finishes using
	 * our serio port before we return from this function.
","	port->serio = NULL;
",,"@@ -436,8 +436,10 @@ static int i8042_start(struct serio *serio)
 {
 	struct i8042_port *port = serio->port_data;
 
+	spin_lock_irq(&i8042_lock);
 	port->exists = true;
-	mb();
+	spin_unlock_irq(&i8042_lock);
+
 	return 0;
 }
 
@@ -450,16 +452,20 @@ static void i8042_stop(struct serio *serio)
 {
 	struct i8042_port *port = serio->port_data;
 
+	spin_lock_irq(&i8042_lock);
 	port->exists = false;
+	port->serio = NULL;
+	spin_unlock_irq(&i8042_lock);
 
 	/*
+	 * We need to make sure that interrupt handler finishes using
+	 * our serio port before we return from this function.
 	 * We synchronize with both AUX and KBD IRQs because there is
 	 * a (very unlikely) chance that AUX IRQ is raised for KBD port
 	 * and vice versa.
 	 */
 	synchronize_irq(I8042_AUX_IRQ);
 	synchronize_irq(I8042_KBD_IRQ);
-	port->serio = NULL;
 }
 
 /*
@@ -576,7 +582,7 @@ static irqreturn_t i8042_interrupt(int irq, void *dev_id)
 
 	spin_unlock_irqrestore(&i8042_lock, flags);
 
-	if (likely(port->exists && !filtered))
+	if (likely(serio && !filtered))
 		serio_interrupt(serio, data, dfl);
 
  out:",linux,340d394a789518018f834ff70f7534fc463d3226,0f107573da417c7f5c6d3a0160ebacc3adb019c4,1,"static void i8042_stop(struct serio *serio)
 {
 	struct i8042_port *port = serio->port_data;
 
//fix_flaw_line_below:
//	spin_lock_irq(&i8042_lock);
 	port->exists = false;
//fix_flaw_line_below:
//	port->serio = NULL;
//fix_flaw_line_below:
//	spin_unlock_irq(&i8042_lock);
 
 	/*
//fix_flaw_line_below:
//	 * We need to make sure that interrupt handler finishes using
//fix_flaw_line_below:
//	 * our serio port before we return from this function.
 	 * We synchronize with both AUX and KBD IRQs because there is
 	 * a (very unlikely) chance that AUX IRQ is raised for KBD port
 	 * and vice versa.
 	 */
 	synchronize_irq(I8042_AUX_IRQ);
 	synchronize_irq(I8042_KBD_IRQ);
//flaw_line_below:
	port->serio = NULL;
 }
"
4952,182688,,Local,Not required,Complete,CVE-2019-15924,https://www.cvedetails.com/cve/CVE-2019-15924/,CWE-476,Low,,,,2019-09-04,4.9,An issue was discovered in the Linux kernel before 5.0.11. fm10k_init_module in drivers/net/ethernet/intel/fm10k/fm10k_main.c has a NULL pointer dereference because there is no -ENOMEM upon an alloc_workqueue failure.,2019-09-14,,2,https://github.com/torvalds/linux/commit/01ca667133d019edc9f0a1f70a272447c84ec41f,01ca667133d019edc9f0a1f70a272447c84ec41f,"fm10k: Fix a potential NULL pointer dereference

Syzkaller report this:

kasan: GPF could be caused by NULL-ptr deref or user memory access
general protection fault: 0000 [#1] SMP KASAN PTI
CPU: 0 PID: 4378 Comm: syz-executor.0 Tainted: G         C        5.0.0+ #5
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
RIP: 0010:__lock_acquire+0x95b/0x3200 kernel/locking/lockdep.c:3573
Code: 00 0f 85 28 1e 00 00 48 81 c4 08 01 00 00 5b 5d 41 5c 41 5d 41 5e 41 5f c3 4c 89 ea 48 b8 00 00 00 00 00 fc ff df 48 c1 ea 03 <80> 3c 02 00 0f 85 cc 24 00 00 49 81 7d 00 e0 de 03 a6 41 bc 00 00
RSP: 0018:ffff8881e3c07a40 EFLAGS: 00010002
RAX: dffffc0000000000 RBX: 0000000000000000 RCX: 0000000000000000
RDX: 0000000000000010 RSI: 0000000000000000 RDI: 0000000000000080
RBP: 0000000000000000 R08: 0000000000000001 R09: 0000000000000000
R10: ffff8881e3c07d98 R11: ffff8881c7f21f80 R12: 0000000000000001
R13: 0000000000000080 R14: 0000000000000000 R15: 0000000000000001
FS:  00007fce2252e700(0000) GS:ffff8881f2400000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007fffc7eb0228 CR3: 00000001e5bea002 CR4: 00000000007606f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
PKRU: 55555554
Call Trace:
 lock_acquire+0xff/0x2c0 kernel/locking/lockdep.c:4211
 __mutex_lock_common kernel/locking/mutex.c:925 [inline]
 __mutex_lock+0xdf/0x1050 kernel/locking/mutex.c:1072
 drain_workqueue+0x24/0x3f0 kernel/workqueue.c:2934
 destroy_workqueue+0x23/0x630 kernel/workqueue.c:4319
 __do_sys_delete_module kernel/module.c:1018 [inline]
 __se_sys_delete_module kernel/module.c:961 [inline]
 __x64_sys_delete_module+0x30c/0x480 kernel/module.c:961
 do_syscall_64+0x9f/0x450 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x49/0xbe
RIP: 0033:0x462e99
Code: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007fce2252dc58 EFLAGS: 00000246 ORIG_RAX: 00000000000000b0
RAX: ffffffffffffffda RBX: 000000000073bf00 RCX: 0000000000462e99
RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000020000140
RBP: 0000000000000002 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 00007fce2252e6bc
R13: 00000000004bcca9 R14: 00000000006f6b48 R15: 00000000ffffffff

If alloc_workqueue fails, it should return -ENOMEM, otherwise may
trigger this NULL pointer dereference while unloading drivers.

Reported-by: Hulk Robot <hulkci@huawei.com>
Fixes: 0a38c17a21a0 (""fm10k: Remove create_workqueue"")
Signed-off-by: Yue Haibing <yuehaibing@huawei.com>
Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>",0,drivers/net/ethernet/intel/fm10k/fm10k_main.c,"{""sha"": ""ecef949f3baae022d46082f4a1dc32d18cb082ec"", ""filename"": ""drivers/net/ethernet/intel/fm10k/fm10k_main.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/01ca667133d019edc9f0a1f70a272447c84ec41f/drivers/net/ethernet/intel/fm10k/fm10k_main.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/01ca667133d019edc9f0a1f70a272447c84ec41f/drivers/net/ethernet/intel/fm10k/fm10k_main.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ethernet/intel/fm10k/fm10k_main.c?ref=01ca667133d019edc9f0a1f70a272447c84ec41f"", ""patch"": ""@@ -41,6 +41,8 @@ static int __init fm10k_init_module(void)\n \t/* create driver workqueue */\n \tfm10k_workqueue = alloc_workqueue(\""%s\"", WQ_MEM_RECLAIM, 0,\n \t\t\t\t\t  fm10k_driver_name);\n+\tif (!fm10k_workqueue)\n+\t\treturn -ENOMEM;\n \n \tfm10k_dbg_init();\n ""}","static int __init fm10k_init_module(void)
{
	pr_info(""%s - version %s\n"", fm10k_driver_string, fm10k_driver_version);
	pr_info(""%s\n"", fm10k_copyright);

 	/* create driver workqueue */
 	fm10k_workqueue = alloc_workqueue(""%s"", WQ_MEM_RECLAIM, 0,
 					  fm10k_driver_name);
	if (!fm10k_workqueue)
		return -ENOMEM;
 
 	fm10k_dbg_init();
 
	return fm10k_register_pci_driver();
}
","static int __init fm10k_init_module(void)
{
	pr_info(""%s - version %s\n"", fm10k_driver_string, fm10k_driver_version);
	pr_info(""%s\n"", fm10k_copyright);

 	/* create driver workqueue */
 	fm10k_workqueue = alloc_workqueue(""%s"", WQ_MEM_RECLAIM, 0,
 					  fm10k_driver_name);
 
 	fm10k_dbg_init();
 
	return fm10k_register_pci_driver();
}
",C,"	if (!fm10k_workqueue)
		return -ENOMEM;
",,,"@@ -41,6 +41,8 @@ static int __init fm10k_init_module(void)
 	/* create driver workqueue */
 	fm10k_workqueue = alloc_workqueue(""%s"", WQ_MEM_RECLAIM, 0,
 					  fm10k_driver_name);
+	if (!fm10k_workqueue)
+		return -ENOMEM;
 
 	fm10k_dbg_init();
 ",linux,01ca667133d019edc9f0a1f70a272447c84ec41f,f669d24f3dd00beab452c0fc9257f6a942ffca9b,1,"static int __init fm10k_init_module(void)
{
	pr_info(""%s - version %s\n"", fm10k_driver_string, fm10k_driver_version);
	pr_info(""%s\n"", fm10k_copyright);

 	/* create driver workqueue */
 	fm10k_workqueue = alloc_workqueue(""%s"", WQ_MEM_RECLAIM, 0,
 					  fm10k_driver_name);
//fix_flaw_line_below:
//	if (!fm10k_workqueue)
//fix_flaw_line_below:
//		return -ENOMEM;
 
 	fm10k_dbg_init();
 
	return fm10k_register_pci_driver();
}
"
4953,182689,,Local,Not required,Complete,CVE-2019-15923,https://www.cvedetails.com/cve/CVE-2019-15923/,CWE-476,Low,,,,2019-09-04,4.9,An issue was discovered in the Linux kernel before 5.0.9. There is a NULL pointer dereference for a cd data structure if alloc_disk fails in drivers/block/paride/pf.c.,2019-10-04,,2,https://github.com/torvalds/linux/commit/f0d1762554014ce0ae347b9f0d088f2c157c8c72,f0d1762554014ce0ae347b9f0d088f2c157c8c72,"paride/pcd: Fix potential NULL pointer dereference and mem leak

Syzkaller report this:

pcd: pcd version 1.07, major 46, nice 0
pcd0: Autoprobe failed
pcd: No CD-ROM drive found
kasan: CONFIG_KASAN_INLINE enabled
kasan: GPF could be caused by NULL-ptr deref or user memory access
general protection fault: 0000 [#1] SMP KASAN PTI
CPU: 1 PID: 4525 Comm: syz-executor.0 Not tainted 5.1.0-rc3+ #8
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
RIP: 0010:pcd_init+0x95c/0x1000 [pcd]
Code: c4 ab f7 48 89 d8 48 c1 e8 03 80 3c 28 00 74 08 48 89 df e8 56 a3 da f7 4c 8b 23 49 8d bc 24 80 05 00 00 48 89 f8 48 c1 e8 03 <80> 3c 28 00 74 05 e8 39 a3 da f7 49 8b bc 24 80 05 00 00 e8 cc b2
RSP: 0018:ffff8881e84df880 EFLAGS: 00010202
RAX: 00000000000000b0 RBX: ffffffffc155a088 RCX: ffffffffc1508935
RDX: 0000000000040000 RSI: ffffc900014f0000 RDI: 0000000000000580
RBP: dffffc0000000000 R08: ffffed103ee658b8 R09: ffffed103ee658b8
R10: 0000000000000001 R11: ffffed103ee658b7 R12: 0000000000000000
R13: ffffffffc155a778 R14: ffffffffc155a4a8 R15: 0000000000000003
FS:  00007fe71bee3700(0000) GS:ffff8881f7300000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 000055a7334441a8 CR3: 00000001e9674003 CR4: 00000000007606e0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
PKRU: 55555554
Call Trace:
 ? 0xffffffffc1508000
 ? 0xffffffffc1508000
 do_one_initcall+0xbc/0x47d init/main.c:901
 do_init_module+0x1b5/0x547 kernel/module.c:3456
 load_module+0x6405/0x8c10 kernel/module.c:3804
 __do_sys_finit_module+0x162/0x190 kernel/module.c:3898
 do_syscall_64+0x9f/0x450 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x49/0xbe
RIP: 0033:0x462e99
Code: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007fe71bee2c58 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
RAX: ffffffffffffffda RBX: 000000000073bf00 RCX: 0000000000462e99
RDX: 0000000000000000 RSI: 0000000020000180 RDI: 0000000000000003
RBP: 00007fe71bee2c70 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 00007fe71bee36bc
R13: 00000000004bcefa R14: 00000000006f6fb0 R15: 0000000000000004
Modules linked in: pcd(+) paride solos_pci atm ts_fsm rtc_mt6397 mac80211 nhc_mobility nhc_udp nhc_ipv6 nhc_hop nhc_dest nhc_fragment nhc_routing 6lowpan rtc_cros_ec memconsole intel_xhci_usb_role_switch roles rtc_wm8350 usbcore industrialio_triggered_buffer kfifo_buf industrialio asc7621 dm_era dm_persistent_data dm_bufio dm_mod tpm gnss_ubx gnss_serial serdev gnss max2165 cpufreq_dt hid_penmount hid menf21bmc_wdt rc_core n_tracesink ide_gd_mod cdns_csi2tx v4l2_fwnode videodev media pinctrl_lewisburg pinctrl_intel iptable_security iptable_raw iptable_mangle iptable_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 iptable_filter bpfilter ip6_vti ip_vti ip_gre ipip sit tunnel4 ip_tunnel hsr veth netdevsim vxcan batman_adv cfg80211 rfkill chnl_net caif nlmon dummy team bonding vcan bridge stp llc ip6_gre gre ip6_tunnel tunnel6 tun joydev mousedev ppdev kvm_intel kvm irqbypass crct10dif_pclmul crc32_pclmul crc32c_intel ghash_clmulni_intel aesni_intel aes_x86_64 crypto_simd
 ide_pci_generic piix input_leds cryptd glue_helper psmouse ide_core intel_agp serio_raw intel_gtt ata_generic i2c_piix4 agpgart pata_acpi parport_pc parport floppy rtc_cmos sch_fq_codel ip_tables x_tables sha1_ssse3 sha1_generic ipv6 [last unloaded: bmc150_magn]
Dumping ftrace buffer:
   (ftrace buffer empty)
---[ end trace d873691c3cd69f56 ]---

If alloc_disk fails in pcd_init_units, cd->disk will be
NULL, however in pcd_detect and pcd_exit, it's not check
this before free.It may result a NULL pointer dereference.

Also when register_blkdev failed, blk_cleanup_queue() and
blk_mq_free_tag_set() should be called to free resources.

Reported-by: Hulk Robot <hulkci@huawei.com>
Fixes: 81b74ac68c28 (""paride/pcd: cleanup queues when detection fails"")
Signed-off-by: YueHaibing <yuehaibing@huawei.com>

Signed-off-by: Jens Axboe <axboe@kernel.dk>",0,drivers/block/paride/pcd.c,"{""sha"": ""6d415b20fb70651c10aa87af6b7f18e53f0aaddd"", ""filename"": ""drivers/block/paride/pcd.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 1, ""changes"": 14, ""blob_url"": ""https://github.com/torvalds/linux/blob/f0d1762554014ce0ae347b9f0d088f2c157c8c72/drivers/block/paride/pcd.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f0d1762554014ce0ae347b9f0d088f2c157c8c72/drivers/block/paride/pcd.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/block/paride/pcd.c?ref=f0d1762554014ce0ae347b9f0d088f2c157c8c72"", ""patch"": ""@@ -314,6 +314,7 @@ static void pcd_init_units(void)\n \t\tdisk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops,\n \t\t\t\t\t\t   1, BLK_MQ_F_SHOULD_MERGE);\n \t\tif (IS_ERR(disk->queue)) {\n+\t\t\tput_disk(disk);\n \t\t\tdisk->queue = NULL;\n \t\t\tcontinue;\n \t\t}\n@@ -750,6 +751,8 @@ static int pcd_detect(void)\n \n \tprintk(\""%s: No CD-ROM drive found\\n\"", name);\n \tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n+\t\tif (!cd->disk)\n+\t\t\tcontinue;\n \t\tblk_cleanup_queue(cd->disk->queue);\n \t\tcd->disk->queue = NULL;\n \t\tblk_mq_free_tag_set(&cd->tag_set);\n@@ -1010,8 +1013,14 @@ static int __init pcd_init(void)\n \tpcd_probe_capabilities();\n \n \tif (register_blkdev(major, name)) {\n-\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)\n+\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n+\t\t\tif (!cd->disk)\n+\t\t\t\tcontinue;\n+\n+\t\t\tblk_cleanup_queue(cd->disk->queue);\n+\t\t\tblk_mq_free_tag_set(&cd->tag_set);\n \t\t\tput_disk(cd->disk);\n+\t\t}\n \t\treturn -EBUSY;\n \t}\n \n@@ -1032,6 +1041,9 @@ static void __exit pcd_exit(void)\n \tint unit;\n \n \tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n+\t\tif (!cd->disk)\n+\t\t\tcontinue;\n+\n \t\tif (cd->present) {\n \t\t\tdel_gendisk(cd->disk);\n \t\t\tpi_release(cd->pi);""}","static int pcd_detect(void)
{
	char id[18];
	int k, unit;
	struct pcd_unit *cd;

	printk(""%s: %s version %s, major %d, nice %d\n"",
	       name, name, PCD_VERSION, major, nice);

	par_drv = pi_register_driver(name);
	if (!par_drv) {
		pr_err(""failed to register %s driver\n"", name);
		return -1;
	}

	k = 0;
	if (pcd_drive_count == 0) { /* nothing spec'd - so autoprobe for 1 */
		cd = pcd;
		if (pi_init(cd->pi, 1, -1, -1, -1, -1, -1, pcd_buffer,
			    PI_PCD, verbose, cd->name)) {
			if (!pcd_probe(cd, -1, id) && cd->disk) {
				cd->present = 1;
				k++;
			} else
				pi_release(cd->pi);
		}
	} else {
		for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
			int *conf = *drives[unit];
			if (!conf[D_PRT])
				continue;
			if (!pi_init(cd->pi, 0, conf[D_PRT], conf[D_MOD],
				     conf[D_UNI], conf[D_PRO], conf[D_DLY],
				     pcd_buffer, PI_PCD, verbose, cd->name)) 
				continue;
			if (!pcd_probe(cd, conf[D_SLV], id) && cd->disk) {
				cd->present = 1;
				k++;
			} else
				pi_release(cd->pi);
		}
	}
	if (k)
		return 0;
 
 	printk(""%s: No CD-ROM drive found\n"", name);
 	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
		if (!cd->disk)
			continue;
 		blk_cleanup_queue(cd->disk->queue);
 		cd->disk->queue = NULL;
 		blk_mq_free_tag_set(&cd->tag_set);
		put_disk(cd->disk);
	}
	pi_unregister_driver(par_drv);
	return -1;
}
","static int pcd_detect(void)
{
	char id[18];
	int k, unit;
	struct pcd_unit *cd;

	printk(""%s: %s version %s, major %d, nice %d\n"",
	       name, name, PCD_VERSION, major, nice);

	par_drv = pi_register_driver(name);
	if (!par_drv) {
		pr_err(""failed to register %s driver\n"", name);
		return -1;
	}

	k = 0;
	if (pcd_drive_count == 0) { /* nothing spec'd - so autoprobe for 1 */
		cd = pcd;
		if (pi_init(cd->pi, 1, -1, -1, -1, -1, -1, pcd_buffer,
			    PI_PCD, verbose, cd->name)) {
			if (!pcd_probe(cd, -1, id) && cd->disk) {
				cd->present = 1;
				k++;
			} else
				pi_release(cd->pi);
		}
	} else {
		for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
			int *conf = *drives[unit];
			if (!conf[D_PRT])
				continue;
			if (!pi_init(cd->pi, 0, conf[D_PRT], conf[D_MOD],
				     conf[D_UNI], conf[D_PRO], conf[D_DLY],
				     pcd_buffer, PI_PCD, verbose, cd->name)) 
				continue;
			if (!pcd_probe(cd, conf[D_SLV], id) && cd->disk) {
				cd->present = 1;
				k++;
			} else
				pi_release(cd->pi);
		}
	}
	if (k)
		return 0;
 
 	printk(""%s: No CD-ROM drive found\n"", name);
 	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
 		blk_cleanup_queue(cd->disk->queue);
 		cd->disk->queue = NULL;
 		blk_mq_free_tag_set(&cd->tag_set);
		put_disk(cd->disk);
	}
	pi_unregister_driver(par_drv);
	return -1;
}
",C,"		if (!cd->disk)
			continue;
",,,"@@ -314,6 +314,7 @@ static void pcd_init_units(void)
 		disk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops,
 						   1, BLK_MQ_F_SHOULD_MERGE);
 		if (IS_ERR(disk->queue)) {
+			put_disk(disk);
 			disk->queue = NULL;
 			continue;
 		}
@@ -750,6 +751,8 @@ static int pcd_detect(void)
 
 	printk(""%s: No CD-ROM drive found\n"", name);
 	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
+		if (!cd->disk)
+			continue;
 		blk_cleanup_queue(cd->disk->queue);
 		cd->disk->queue = NULL;
 		blk_mq_free_tag_set(&cd->tag_set);
@@ -1010,8 +1013,14 @@ static int __init pcd_init(void)
 	pcd_probe_capabilities();
 
 	if (register_blkdev(major, name)) {
-		for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)
+		for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
+			if (!cd->disk)
+				continue;
+
+			blk_cleanup_queue(cd->disk->queue);
+			blk_mq_free_tag_set(&cd->tag_set);
 			put_disk(cd->disk);
+		}
 		return -EBUSY;
 	}
 
@@ -1032,6 +1041,9 @@ static void __exit pcd_exit(void)
 	int unit;
 
 	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
+		if (!cd->disk)
+			continue;
+
 		if (cd->present) {
 			del_gendisk(cd->disk);
 			pi_release(cd->pi);",linux,f0d1762554014ce0ae347b9f0d088f2c157c8c72,bcc816dfe51ab86ca94663c7b225f2d6eb0fddb9,1,"static int pcd_detect(void)
{
	char id[18];
	int k, unit;
	struct pcd_unit *cd;

	printk(""%s: %s version %s, major %d, nice %d\n"",
	       name, name, PCD_VERSION, major, nice);

	par_drv = pi_register_driver(name);
	if (!par_drv) {
		pr_err(""failed to register %s driver\n"", name);
		return -1;
	}

	k = 0;
	if (pcd_drive_count == 0) { /* nothing spec'd - so autoprobe for 1 */
		cd = pcd;
		if (pi_init(cd->pi, 1, -1, -1, -1, -1, -1, pcd_buffer,
			    PI_PCD, verbose, cd->name)) {
			if (!pcd_probe(cd, -1, id) && cd->disk) {
				cd->present = 1;
				k++;
			} else
				pi_release(cd->pi);
		}
	} else {
		for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
			int *conf = *drives[unit];
			if (!conf[D_PRT])
				continue;
			if (!pi_init(cd->pi, 0, conf[D_PRT], conf[D_MOD],
				     conf[D_UNI], conf[D_PRO], conf[D_DLY],
				     pcd_buffer, PI_PCD, verbose, cd->name)) 
				continue;
			if (!pcd_probe(cd, conf[D_SLV], id) && cd->disk) {
				cd->present = 1;
				k++;
			} else
				pi_release(cd->pi);
		}
	}
	if (k)
		return 0;
 
 	printk(""%s: No CD-ROM drive found\n"", name);
 	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
//fix_flaw_line_below:
//		if (!cd->disk)
//fix_flaw_line_below:
//			continue;
 		blk_cleanup_queue(cd->disk->queue);
 		cd->disk->queue = NULL;
 		blk_mq_free_tag_set(&cd->tag_set);
		put_disk(cd->disk);
	}
	pi_unregister_driver(par_drv);
	return -1;
}
"
4954,182690,,Local,Not required,Complete,CVE-2019-15923,https://www.cvedetails.com/cve/CVE-2019-15923/,CWE-476,Low,,,,2019-09-04,4.9,An issue was discovered in the Linux kernel before 5.0.9. There is a NULL pointer dereference for a cd data structure if alloc_disk fails in drivers/block/paride/pf.c.,2019-10-04,,3,https://github.com/torvalds/linux/commit/f0d1762554014ce0ae347b9f0d088f2c157c8c72,f0d1762554014ce0ae347b9f0d088f2c157c8c72,"paride/pcd: Fix potential NULL pointer dereference and mem leak

Syzkaller report this:

pcd: pcd version 1.07, major 46, nice 0
pcd0: Autoprobe failed
pcd: No CD-ROM drive found
kasan: CONFIG_KASAN_INLINE enabled
kasan: GPF could be caused by NULL-ptr deref or user memory access
general protection fault: 0000 [#1] SMP KASAN PTI
CPU: 1 PID: 4525 Comm: syz-executor.0 Not tainted 5.1.0-rc3+ #8
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
RIP: 0010:pcd_init+0x95c/0x1000 [pcd]
Code: c4 ab f7 48 89 d8 48 c1 e8 03 80 3c 28 00 74 08 48 89 df e8 56 a3 da f7 4c 8b 23 49 8d bc 24 80 05 00 00 48 89 f8 48 c1 e8 03 <80> 3c 28 00 74 05 e8 39 a3 da f7 49 8b bc 24 80 05 00 00 e8 cc b2
RSP: 0018:ffff8881e84df880 EFLAGS: 00010202
RAX: 00000000000000b0 RBX: ffffffffc155a088 RCX: ffffffffc1508935
RDX: 0000000000040000 RSI: ffffc900014f0000 RDI: 0000000000000580
RBP: dffffc0000000000 R08: ffffed103ee658b8 R09: ffffed103ee658b8
R10: 0000000000000001 R11: ffffed103ee658b7 R12: 0000000000000000
R13: ffffffffc155a778 R14: ffffffffc155a4a8 R15: 0000000000000003
FS:  00007fe71bee3700(0000) GS:ffff8881f7300000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 000055a7334441a8 CR3: 00000001e9674003 CR4: 00000000007606e0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
PKRU: 55555554
Call Trace:
 ? 0xffffffffc1508000
 ? 0xffffffffc1508000
 do_one_initcall+0xbc/0x47d init/main.c:901
 do_init_module+0x1b5/0x547 kernel/module.c:3456
 load_module+0x6405/0x8c10 kernel/module.c:3804
 __do_sys_finit_module+0x162/0x190 kernel/module.c:3898
 do_syscall_64+0x9f/0x450 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x49/0xbe
RIP: 0033:0x462e99
Code: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007fe71bee2c58 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
RAX: ffffffffffffffda RBX: 000000000073bf00 RCX: 0000000000462e99
RDX: 0000000000000000 RSI: 0000000020000180 RDI: 0000000000000003
RBP: 00007fe71bee2c70 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 00007fe71bee36bc
R13: 00000000004bcefa R14: 00000000006f6fb0 R15: 0000000000000004
Modules linked in: pcd(+) paride solos_pci atm ts_fsm rtc_mt6397 mac80211 nhc_mobility nhc_udp nhc_ipv6 nhc_hop nhc_dest nhc_fragment nhc_routing 6lowpan rtc_cros_ec memconsole intel_xhci_usb_role_switch roles rtc_wm8350 usbcore industrialio_triggered_buffer kfifo_buf industrialio asc7621 dm_era dm_persistent_data dm_bufio dm_mod tpm gnss_ubx gnss_serial serdev gnss max2165 cpufreq_dt hid_penmount hid menf21bmc_wdt rc_core n_tracesink ide_gd_mod cdns_csi2tx v4l2_fwnode videodev media pinctrl_lewisburg pinctrl_intel iptable_security iptable_raw iptable_mangle iptable_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 iptable_filter bpfilter ip6_vti ip_vti ip_gre ipip sit tunnel4 ip_tunnel hsr veth netdevsim vxcan batman_adv cfg80211 rfkill chnl_net caif nlmon dummy team bonding vcan bridge stp llc ip6_gre gre ip6_tunnel tunnel6 tun joydev mousedev ppdev kvm_intel kvm irqbypass crct10dif_pclmul crc32_pclmul crc32c_intel ghash_clmulni_intel aesni_intel aes_x86_64 crypto_simd
 ide_pci_generic piix input_leds cryptd glue_helper psmouse ide_core intel_agp serio_raw intel_gtt ata_generic i2c_piix4 agpgart pata_acpi parport_pc parport floppy rtc_cmos sch_fq_codel ip_tables x_tables sha1_ssse3 sha1_generic ipv6 [last unloaded: bmc150_magn]
Dumping ftrace buffer:
   (ftrace buffer empty)
---[ end trace d873691c3cd69f56 ]---

If alloc_disk fails in pcd_init_units, cd->disk will be
NULL, however in pcd_detect and pcd_exit, it's not check
this before free.It may result a NULL pointer dereference.

Also when register_blkdev failed, blk_cleanup_queue() and
blk_mq_free_tag_set() should be called to free resources.

Reported-by: Hulk Robot <hulkci@huawei.com>
Fixes: 81b74ac68c28 (""paride/pcd: cleanup queues when detection fails"")
Signed-off-by: YueHaibing <yuehaibing@huawei.com>

Signed-off-by: Jens Axboe <axboe@kernel.dk>",0,drivers/block/paride/pcd.c,"{""sha"": ""6d415b20fb70651c10aa87af6b7f18e53f0aaddd"", ""filename"": ""drivers/block/paride/pcd.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 1, ""changes"": 14, ""blob_url"": ""https://github.com/torvalds/linux/blob/f0d1762554014ce0ae347b9f0d088f2c157c8c72/drivers/block/paride/pcd.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f0d1762554014ce0ae347b9f0d088f2c157c8c72/drivers/block/paride/pcd.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/block/paride/pcd.c?ref=f0d1762554014ce0ae347b9f0d088f2c157c8c72"", ""patch"": ""@@ -314,6 +314,7 @@ static void pcd_init_units(void)\n \t\tdisk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops,\n \t\t\t\t\t\t   1, BLK_MQ_F_SHOULD_MERGE);\n \t\tif (IS_ERR(disk->queue)) {\n+\t\t\tput_disk(disk);\n \t\t\tdisk->queue = NULL;\n \t\t\tcontinue;\n \t\t}\n@@ -750,6 +751,8 @@ static int pcd_detect(void)\n \n \tprintk(\""%s: No CD-ROM drive found\\n\"", name);\n \tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n+\t\tif (!cd->disk)\n+\t\t\tcontinue;\n \t\tblk_cleanup_queue(cd->disk->queue);\n \t\tcd->disk->queue = NULL;\n \t\tblk_mq_free_tag_set(&cd->tag_set);\n@@ -1010,8 +1013,14 @@ static int __init pcd_init(void)\n \tpcd_probe_capabilities();\n \n \tif (register_blkdev(major, name)) {\n-\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)\n+\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n+\t\t\tif (!cd->disk)\n+\t\t\t\tcontinue;\n+\n+\t\t\tblk_cleanup_queue(cd->disk->queue);\n+\t\t\tblk_mq_free_tag_set(&cd->tag_set);\n \t\t\tput_disk(cd->disk);\n+\t\t}\n \t\treturn -EBUSY;\n \t}\n \n@@ -1032,6 +1041,9 @@ static void __exit pcd_exit(void)\n \tint unit;\n \n \tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n+\t\tif (!cd->disk)\n+\t\t\tcontinue;\n+\n \t\tif (cd->present) {\n \t\t\tdel_gendisk(cd->disk);\n \t\t\tpi_release(cd->pi);""}","static void __exit pcd_exit(void)
{
	struct pcd_unit *cd;
 	int unit;
 
 	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
		if (!cd->disk)
			continue;

 		if (cd->present) {
 			del_gendisk(cd->disk);
 			pi_release(cd->pi);
			unregister_cdrom(&cd->info);
		}
		blk_cleanup_queue(cd->disk->queue);
		blk_mq_free_tag_set(&cd->tag_set);
		put_disk(cd->disk);
	}
	unregister_blkdev(major, name);
	pi_unregister_driver(par_drv);
}
","static void __exit pcd_exit(void)
{
	struct pcd_unit *cd;
 	int unit;
 
 	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
 		if (cd->present) {
 			del_gendisk(cd->disk);
 			pi_release(cd->pi);
			unregister_cdrom(&cd->info);
		}
		blk_cleanup_queue(cd->disk->queue);
		blk_mq_free_tag_set(&cd->tag_set);
		put_disk(cd->disk);
	}
	unregister_blkdev(major, name);
	pi_unregister_driver(par_drv);
}
",C,"		if (!cd->disk)
			continue;

",,,"@@ -314,6 +314,7 @@ static void pcd_init_units(void)
 		disk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops,
 						   1, BLK_MQ_F_SHOULD_MERGE);
 		if (IS_ERR(disk->queue)) {
+			put_disk(disk);
 			disk->queue = NULL;
 			continue;
 		}
@@ -750,6 +751,8 @@ static int pcd_detect(void)
 
 	printk(""%s: No CD-ROM drive found\n"", name);
 	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
+		if (!cd->disk)
+			continue;
 		blk_cleanup_queue(cd->disk->queue);
 		cd->disk->queue = NULL;
 		blk_mq_free_tag_set(&cd->tag_set);
@@ -1010,8 +1013,14 @@ static int __init pcd_init(void)
 	pcd_probe_capabilities();
 
 	if (register_blkdev(major, name)) {
-		for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)
+		for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
+			if (!cd->disk)
+				continue;
+
+			blk_cleanup_queue(cd->disk->queue);
+			blk_mq_free_tag_set(&cd->tag_set);
 			put_disk(cd->disk);
+		}
 		return -EBUSY;
 	}
 
@@ -1032,6 +1041,9 @@ static void __exit pcd_exit(void)
 	int unit;
 
 	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
+		if (!cd->disk)
+			continue;
+
 		if (cd->present) {
 			del_gendisk(cd->disk);
 			pi_release(cd->pi);",linux,f0d1762554014ce0ae347b9f0d088f2c157c8c72,bcc816dfe51ab86ca94663c7b225f2d6eb0fddb9,1,"static void __exit pcd_exit(void)
{
	struct pcd_unit *cd;
 	int unit;
 
 	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
//fix_flaw_line_below:
//		if (!cd->disk)
//fix_flaw_line_below:
//			continue;
//fix_flaw_line_below:
//
 		if (cd->present) {
 			del_gendisk(cd->disk);
 			pi_release(cd->pi);
			unregister_cdrom(&cd->info);
		}
		blk_cleanup_queue(cd->disk->queue);
		blk_mq_free_tag_set(&cd->tag_set);
		put_disk(cd->disk);
	}
	unregister_blkdev(major, name);
	pi_unregister_driver(par_drv);
}
"
4955,182691,,Local,Not required,Complete,CVE-2019-15923,https://www.cvedetails.com/cve/CVE-2019-15923/,CWE-476,Low,,,,2019-09-04,4.9,An issue was discovered in the Linux kernel before 5.0.9. There is a NULL pointer dereference for a cd data structure if alloc_disk fails in drivers/block/paride/pf.c.,2019-10-04,,7,https://github.com/torvalds/linux/commit/f0d1762554014ce0ae347b9f0d088f2c157c8c72,f0d1762554014ce0ae347b9f0d088f2c157c8c72,"paride/pcd: Fix potential NULL pointer dereference and mem leak

Syzkaller report this:

pcd: pcd version 1.07, major 46, nice 0
pcd0: Autoprobe failed
pcd: No CD-ROM drive found
kasan: CONFIG_KASAN_INLINE enabled
kasan: GPF could be caused by NULL-ptr deref or user memory access
general protection fault: 0000 [#1] SMP KASAN PTI
CPU: 1 PID: 4525 Comm: syz-executor.0 Not tainted 5.1.0-rc3+ #8
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
RIP: 0010:pcd_init+0x95c/0x1000 [pcd]
Code: c4 ab f7 48 89 d8 48 c1 e8 03 80 3c 28 00 74 08 48 89 df e8 56 a3 da f7 4c 8b 23 49 8d bc 24 80 05 00 00 48 89 f8 48 c1 e8 03 <80> 3c 28 00 74 05 e8 39 a3 da f7 49 8b bc 24 80 05 00 00 e8 cc b2
RSP: 0018:ffff8881e84df880 EFLAGS: 00010202
RAX: 00000000000000b0 RBX: ffffffffc155a088 RCX: ffffffffc1508935
RDX: 0000000000040000 RSI: ffffc900014f0000 RDI: 0000000000000580
RBP: dffffc0000000000 R08: ffffed103ee658b8 R09: ffffed103ee658b8
R10: 0000000000000001 R11: ffffed103ee658b7 R12: 0000000000000000
R13: ffffffffc155a778 R14: ffffffffc155a4a8 R15: 0000000000000003
FS:  00007fe71bee3700(0000) GS:ffff8881f7300000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 000055a7334441a8 CR3: 00000001e9674003 CR4: 00000000007606e0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
PKRU: 55555554
Call Trace:
 ? 0xffffffffc1508000
 ? 0xffffffffc1508000
 do_one_initcall+0xbc/0x47d init/main.c:901
 do_init_module+0x1b5/0x547 kernel/module.c:3456
 load_module+0x6405/0x8c10 kernel/module.c:3804
 __do_sys_finit_module+0x162/0x190 kernel/module.c:3898
 do_syscall_64+0x9f/0x450 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x49/0xbe
RIP: 0033:0x462e99
Code: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007fe71bee2c58 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
RAX: ffffffffffffffda RBX: 000000000073bf00 RCX: 0000000000462e99
RDX: 0000000000000000 RSI: 0000000020000180 RDI: 0000000000000003
RBP: 00007fe71bee2c70 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 00007fe71bee36bc
R13: 00000000004bcefa R14: 00000000006f6fb0 R15: 0000000000000004
Modules linked in: pcd(+) paride solos_pci atm ts_fsm rtc_mt6397 mac80211 nhc_mobility nhc_udp nhc_ipv6 nhc_hop nhc_dest nhc_fragment nhc_routing 6lowpan rtc_cros_ec memconsole intel_xhci_usb_role_switch roles rtc_wm8350 usbcore industrialio_triggered_buffer kfifo_buf industrialio asc7621 dm_era dm_persistent_data dm_bufio dm_mod tpm gnss_ubx gnss_serial serdev gnss max2165 cpufreq_dt hid_penmount hid menf21bmc_wdt rc_core n_tracesink ide_gd_mod cdns_csi2tx v4l2_fwnode videodev media pinctrl_lewisburg pinctrl_intel iptable_security iptable_raw iptable_mangle iptable_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 iptable_filter bpfilter ip6_vti ip_vti ip_gre ipip sit tunnel4 ip_tunnel hsr veth netdevsim vxcan batman_adv cfg80211 rfkill chnl_net caif nlmon dummy team bonding vcan bridge stp llc ip6_gre gre ip6_tunnel tunnel6 tun joydev mousedev ppdev kvm_intel kvm irqbypass crct10dif_pclmul crc32_pclmul crc32c_intel ghash_clmulni_intel aesni_intel aes_x86_64 crypto_simd
 ide_pci_generic piix input_leds cryptd glue_helper psmouse ide_core intel_agp serio_raw intel_gtt ata_generic i2c_piix4 agpgart pata_acpi parport_pc parport floppy rtc_cmos sch_fq_codel ip_tables x_tables sha1_ssse3 sha1_generic ipv6 [last unloaded: bmc150_magn]
Dumping ftrace buffer:
   (ftrace buffer empty)
---[ end trace d873691c3cd69f56 ]---

If alloc_disk fails in pcd_init_units, cd->disk will be
NULL, however in pcd_detect and pcd_exit, it's not check
this before free.It may result a NULL pointer dereference.

Also when register_blkdev failed, blk_cleanup_queue() and
blk_mq_free_tag_set() should be called to free resources.

Reported-by: Hulk Robot <hulkci@huawei.com>
Fixes: 81b74ac68c28 (""paride/pcd: cleanup queues when detection fails"")
Signed-off-by: YueHaibing <yuehaibing@huawei.com>

Signed-off-by: Jens Axboe <axboe@kernel.dk>",1,drivers/block/paride/pcd.c,"{""sha"": ""6d415b20fb70651c10aa87af6b7f18e53f0aaddd"", ""filename"": ""drivers/block/paride/pcd.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 1, ""changes"": 14, ""blob_url"": ""https://github.com/torvalds/linux/blob/f0d1762554014ce0ae347b9f0d088f2c157c8c72/drivers/block/paride/pcd.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f0d1762554014ce0ae347b9f0d088f2c157c8c72/drivers/block/paride/pcd.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/block/paride/pcd.c?ref=f0d1762554014ce0ae347b9f0d088f2c157c8c72"", ""patch"": ""@@ -314,6 +314,7 @@ static void pcd_init_units(void)\n \t\tdisk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops,\n \t\t\t\t\t\t   1, BLK_MQ_F_SHOULD_MERGE);\n \t\tif (IS_ERR(disk->queue)) {\n+\t\t\tput_disk(disk);\n \t\t\tdisk->queue = NULL;\n \t\t\tcontinue;\n \t\t}\n@@ -750,6 +751,8 @@ static int pcd_detect(void)\n \n \tprintk(\""%s: No CD-ROM drive found\\n\"", name);\n \tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n+\t\tif (!cd->disk)\n+\t\t\tcontinue;\n \t\tblk_cleanup_queue(cd->disk->queue);\n \t\tcd->disk->queue = NULL;\n \t\tblk_mq_free_tag_set(&cd->tag_set);\n@@ -1010,8 +1013,14 @@ static int __init pcd_init(void)\n \tpcd_probe_capabilities();\n \n \tif (register_blkdev(major, name)) {\n-\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)\n+\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n+\t\t\tif (!cd->disk)\n+\t\t\t\tcontinue;\n+\n+\t\t\tblk_cleanup_queue(cd->disk->queue);\n+\t\t\tblk_mq_free_tag_set(&cd->tag_set);\n \t\t\tput_disk(cd->disk);\n+\t\t}\n \t\treturn -EBUSY;\n \t}\n \n@@ -1032,6 +1041,9 @@ static void __exit pcd_exit(void)\n \tint unit;\n \n \tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n+\t\tif (!cd->disk)\n+\t\t\tcontinue;\n+\n \t\tif (cd->present) {\n \t\t\tdel_gendisk(cd->disk);\n \t\t\tpi_release(cd->pi);""}","static int __init pcd_init(void)
{
	struct pcd_unit *cd;
	int unit;

	if (disable)
		return -EINVAL;

	pcd_init_units();

	if (pcd_detect())
		return -ENODEV;

	/* get the atapi capabilities page */
 	pcd_probe_capabilities();
 
 	if (register_blkdev(major, name)) {
		for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
			if (!cd->disk)
				continue;

			blk_cleanup_queue(cd->disk->queue);
			blk_mq_free_tag_set(&cd->tag_set);
 			put_disk(cd->disk);
		}
 		return -EBUSY;
 	}
 
	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
		if (cd->present) {
			register_cdrom(&cd->info);
			cd->disk->private_data = cd;
			add_disk(cd->disk);
		}
	}

	return 0;
}
","static int __init pcd_init(void)
{
	struct pcd_unit *cd;
	int unit;

	if (disable)
		return -EINVAL;

	pcd_init_units();

	if (pcd_detect())
		return -ENODEV;

	/* get the atapi capabilities page */
 	pcd_probe_capabilities();
 
 	if (register_blkdev(major, name)) {
		for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)
 			put_disk(cd->disk);
 		return -EBUSY;
 	}
 
	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
		if (cd->present) {
			register_cdrom(&cd->info);
			cd->disk->private_data = cd;
			add_disk(cd->disk);
		}
	}

	return 0;
}
",C,"		for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
			if (!cd->disk)
				continue;

			blk_cleanup_queue(cd->disk->queue);
			blk_mq_free_tag_set(&cd->tag_set);
		}
","		for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)
",,"@@ -314,6 +314,7 @@ static void pcd_init_units(void)
 		disk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops,
 						   1, BLK_MQ_F_SHOULD_MERGE);
 		if (IS_ERR(disk->queue)) {
+			put_disk(disk);
 			disk->queue = NULL;
 			continue;
 		}
@@ -750,6 +751,8 @@ static int pcd_detect(void)
 
 	printk(""%s: No CD-ROM drive found\n"", name);
 	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
+		if (!cd->disk)
+			continue;
 		blk_cleanup_queue(cd->disk->queue);
 		cd->disk->queue = NULL;
 		blk_mq_free_tag_set(&cd->tag_set);
@@ -1010,8 +1013,14 @@ static int __init pcd_init(void)
 	pcd_probe_capabilities();
 
 	if (register_blkdev(major, name)) {
-		for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)
+		for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
+			if (!cd->disk)
+				continue;
+
+			blk_cleanup_queue(cd->disk->queue);
+			blk_mq_free_tag_set(&cd->tag_set);
 			put_disk(cd->disk);
+		}
 		return -EBUSY;
 	}
 
@@ -1032,6 +1041,9 @@ static void __exit pcd_exit(void)
 	int unit;
 
 	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
+		if (!cd->disk)
+			continue;
+
 		if (cd->present) {
 			del_gendisk(cd->disk);
 			pi_release(cd->pi);",linux,f0d1762554014ce0ae347b9f0d088f2c157c8c72,bcc816dfe51ab86ca94663c7b225f2d6eb0fddb9,1,"static int __init pcd_init(void)
{
	struct pcd_unit *cd;
	int unit;

	if (disable)
		return -EINVAL;

	pcd_init_units();

	if (pcd_detect())
		return -ENODEV;

	/* get the atapi capabilities page */
 	pcd_probe_capabilities();
 
 	if (register_blkdev(major, name)) {
//flaw_line_below:
		for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)
//fix_flaw_line_below:
//		for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
//fix_flaw_line_below:
//			if (!cd->disk)
//fix_flaw_line_below:
//				continue;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//			blk_cleanup_queue(cd->disk->queue);
//fix_flaw_line_below:
//			blk_mq_free_tag_set(&cd->tag_set);
 			put_disk(cd->disk);
//fix_flaw_line_below:
//		}
 		return -EBUSY;
 	}
 
	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
		if (cd->present) {
			register_cdrom(&cd->info);
			cd->disk->private_data = cd;
			add_disk(cd->disk);
		}
	}

	return 0;
}
"
4956,182692,,Local,Not required,Complete,CVE-2019-15923,https://www.cvedetails.com/cve/CVE-2019-15923/,CWE-476,Low,,,,2019-09-04,4.9,An issue was discovered in the Linux kernel before 5.0.9. There is a NULL pointer dereference for a cd data structure if alloc_disk fails in drivers/block/paride/pf.c.,2019-10-04,,1,https://github.com/torvalds/linux/commit/f0d1762554014ce0ae347b9f0d088f2c157c8c72,f0d1762554014ce0ae347b9f0d088f2c157c8c72,"paride/pcd: Fix potential NULL pointer dereference and mem leak

Syzkaller report this:

pcd: pcd version 1.07, major 46, nice 0
pcd0: Autoprobe failed
pcd: No CD-ROM drive found
kasan: CONFIG_KASAN_INLINE enabled
kasan: GPF could be caused by NULL-ptr deref or user memory access
general protection fault: 0000 [#1] SMP KASAN PTI
CPU: 1 PID: 4525 Comm: syz-executor.0 Not tainted 5.1.0-rc3+ #8
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
RIP: 0010:pcd_init+0x95c/0x1000 [pcd]
Code: c4 ab f7 48 89 d8 48 c1 e8 03 80 3c 28 00 74 08 48 89 df e8 56 a3 da f7 4c 8b 23 49 8d bc 24 80 05 00 00 48 89 f8 48 c1 e8 03 <80> 3c 28 00 74 05 e8 39 a3 da f7 49 8b bc 24 80 05 00 00 e8 cc b2
RSP: 0018:ffff8881e84df880 EFLAGS: 00010202
RAX: 00000000000000b0 RBX: ffffffffc155a088 RCX: ffffffffc1508935
RDX: 0000000000040000 RSI: ffffc900014f0000 RDI: 0000000000000580
RBP: dffffc0000000000 R08: ffffed103ee658b8 R09: ffffed103ee658b8
R10: 0000000000000001 R11: ffffed103ee658b7 R12: 0000000000000000
R13: ffffffffc155a778 R14: ffffffffc155a4a8 R15: 0000000000000003
FS:  00007fe71bee3700(0000) GS:ffff8881f7300000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 000055a7334441a8 CR3: 00000001e9674003 CR4: 00000000007606e0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
PKRU: 55555554
Call Trace:
 ? 0xffffffffc1508000
 ? 0xffffffffc1508000
 do_one_initcall+0xbc/0x47d init/main.c:901
 do_init_module+0x1b5/0x547 kernel/module.c:3456
 load_module+0x6405/0x8c10 kernel/module.c:3804
 __do_sys_finit_module+0x162/0x190 kernel/module.c:3898
 do_syscall_64+0x9f/0x450 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x49/0xbe
RIP: 0033:0x462e99
Code: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007fe71bee2c58 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
RAX: ffffffffffffffda RBX: 000000000073bf00 RCX: 0000000000462e99
RDX: 0000000000000000 RSI: 0000000020000180 RDI: 0000000000000003
RBP: 00007fe71bee2c70 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 00007fe71bee36bc
R13: 00000000004bcefa R14: 00000000006f6fb0 R15: 0000000000000004
Modules linked in: pcd(+) paride solos_pci atm ts_fsm rtc_mt6397 mac80211 nhc_mobility nhc_udp nhc_ipv6 nhc_hop nhc_dest nhc_fragment nhc_routing 6lowpan rtc_cros_ec memconsole intel_xhci_usb_role_switch roles rtc_wm8350 usbcore industrialio_triggered_buffer kfifo_buf industrialio asc7621 dm_era dm_persistent_data dm_bufio dm_mod tpm gnss_ubx gnss_serial serdev gnss max2165 cpufreq_dt hid_penmount hid menf21bmc_wdt rc_core n_tracesink ide_gd_mod cdns_csi2tx v4l2_fwnode videodev media pinctrl_lewisburg pinctrl_intel iptable_security iptable_raw iptable_mangle iptable_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 iptable_filter bpfilter ip6_vti ip_vti ip_gre ipip sit tunnel4 ip_tunnel hsr veth netdevsim vxcan batman_adv cfg80211 rfkill chnl_net caif nlmon dummy team bonding vcan bridge stp llc ip6_gre gre ip6_tunnel tunnel6 tun joydev mousedev ppdev kvm_intel kvm irqbypass crct10dif_pclmul crc32_pclmul crc32c_intel ghash_clmulni_intel aesni_intel aes_x86_64 crypto_simd
 ide_pci_generic piix input_leds cryptd glue_helper psmouse ide_core intel_agp serio_raw intel_gtt ata_generic i2c_piix4 agpgart pata_acpi parport_pc parport floppy rtc_cmos sch_fq_codel ip_tables x_tables sha1_ssse3 sha1_generic ipv6 [last unloaded: bmc150_magn]
Dumping ftrace buffer:
   (ftrace buffer empty)
---[ end trace d873691c3cd69f56 ]---

If alloc_disk fails in pcd_init_units, cd->disk will be
NULL, however in pcd_detect and pcd_exit, it's not check
this before free.It may result a NULL pointer dereference.

Also when register_blkdev failed, blk_cleanup_queue() and
blk_mq_free_tag_set() should be called to free resources.

Reported-by: Hulk Robot <hulkci@huawei.com>
Fixes: 81b74ac68c28 (""paride/pcd: cleanup queues when detection fails"")
Signed-off-by: YueHaibing <yuehaibing@huawei.com>

Signed-off-by: Jens Axboe <axboe@kernel.dk>",0,drivers/block/paride/pcd.c,"{""sha"": ""6d415b20fb70651c10aa87af6b7f18e53f0aaddd"", ""filename"": ""drivers/block/paride/pcd.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 1, ""changes"": 14, ""blob_url"": ""https://github.com/torvalds/linux/blob/f0d1762554014ce0ae347b9f0d088f2c157c8c72/drivers/block/paride/pcd.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f0d1762554014ce0ae347b9f0d088f2c157c8c72/drivers/block/paride/pcd.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/block/paride/pcd.c?ref=f0d1762554014ce0ae347b9f0d088f2c157c8c72"", ""patch"": ""@@ -314,6 +314,7 @@ static void pcd_init_units(void)\n \t\tdisk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops,\n \t\t\t\t\t\t   1, BLK_MQ_F_SHOULD_MERGE);\n \t\tif (IS_ERR(disk->queue)) {\n+\t\t\tput_disk(disk);\n \t\t\tdisk->queue = NULL;\n \t\t\tcontinue;\n \t\t}\n@@ -750,6 +751,8 @@ static int pcd_detect(void)\n \n \tprintk(\""%s: No CD-ROM drive found\\n\"", name);\n \tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n+\t\tif (!cd->disk)\n+\t\t\tcontinue;\n \t\tblk_cleanup_queue(cd->disk->queue);\n \t\tcd->disk->queue = NULL;\n \t\tblk_mq_free_tag_set(&cd->tag_set);\n@@ -1010,8 +1013,14 @@ static int __init pcd_init(void)\n \tpcd_probe_capabilities();\n \n \tif (register_blkdev(major, name)) {\n-\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)\n+\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n+\t\t\tif (!cd->disk)\n+\t\t\t\tcontinue;\n+\n+\t\t\tblk_cleanup_queue(cd->disk->queue);\n+\t\t\tblk_mq_free_tag_set(&cd->tag_set);\n \t\t\tput_disk(cd->disk);\n+\t\t}\n \t\treturn -EBUSY;\n \t}\n \n@@ -1032,6 +1041,9 @@ static void __exit pcd_exit(void)\n \tint unit;\n \n \tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n+\t\tif (!cd->disk)\n+\t\t\tcontinue;\n+\n \t\tif (cd->present) {\n \t\t\tdel_gendisk(cd->disk);\n \t\t\tpi_release(cd->pi);""}","static void pcd_init_units(void)
{
	struct pcd_unit *cd;
	int unit;

	pcd_drive_count = 0;
	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
		struct gendisk *disk = alloc_disk(1);

		if (!disk)
			continue;

 		disk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops,
 						   1, BLK_MQ_F_SHOULD_MERGE);
 		if (IS_ERR(disk->queue)) {
			put_disk(disk);
 			disk->queue = NULL;
 			continue;
 		}

		INIT_LIST_HEAD(&cd->rq_list);
		disk->queue->queuedata = cd;
		blk_queue_bounce_limit(disk->queue, BLK_BOUNCE_HIGH);
		cd->disk = disk;
		cd->pi = &cd->pia;
		cd->present = 0;
		cd->last_sense = 0;
		cd->changed = 1;
		cd->drive = (*drives[unit])[D_SLV];
		if ((*drives[unit])[D_PRT])
			pcd_drive_count++;

		cd->name = &cd->info.name[0];
		snprintf(cd->name, sizeof(cd->info.name), ""%s%d"", name, unit);
		cd->info.ops = &pcd_dops;
		cd->info.handle = cd;
		cd->info.speed = 0;
		cd->info.capacity = 1;
		cd->info.mask = 0;
		disk->major = major;
		disk->first_minor = unit;
		strcpy(disk->disk_name, cd->name);	/* umm... */
		disk->fops = &pcd_bdops;
		disk->flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE;
	}
}
","static void pcd_init_units(void)
{
	struct pcd_unit *cd;
	int unit;

	pcd_drive_count = 0;
	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
		struct gendisk *disk = alloc_disk(1);

		if (!disk)
			continue;

 		disk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops,
 						   1, BLK_MQ_F_SHOULD_MERGE);
 		if (IS_ERR(disk->queue)) {
 			disk->queue = NULL;
 			continue;
 		}

		INIT_LIST_HEAD(&cd->rq_list);
		disk->queue->queuedata = cd;
		blk_queue_bounce_limit(disk->queue, BLK_BOUNCE_HIGH);
		cd->disk = disk;
		cd->pi = &cd->pia;
		cd->present = 0;
		cd->last_sense = 0;
		cd->changed = 1;
		cd->drive = (*drives[unit])[D_SLV];
		if ((*drives[unit])[D_PRT])
			pcd_drive_count++;

		cd->name = &cd->info.name[0];
		snprintf(cd->name, sizeof(cd->info.name), ""%s%d"", name, unit);
		cd->info.ops = &pcd_dops;
		cd->info.handle = cd;
		cd->info.speed = 0;
		cd->info.capacity = 1;
		cd->info.mask = 0;
		disk->major = major;
		disk->first_minor = unit;
		strcpy(disk->disk_name, cd->name);	/* umm... */
		disk->fops = &pcd_bdops;
		disk->flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE;
	}
}
",C,"			put_disk(disk);
",,,"@@ -314,6 +314,7 @@ static void pcd_init_units(void)
 		disk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops,
 						   1, BLK_MQ_F_SHOULD_MERGE);
 		if (IS_ERR(disk->queue)) {
+			put_disk(disk);
 			disk->queue = NULL;
 			continue;
 		}
@@ -750,6 +751,8 @@ static int pcd_detect(void)
 
 	printk(""%s: No CD-ROM drive found\n"", name);
 	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
+		if (!cd->disk)
+			continue;
 		blk_cleanup_queue(cd->disk->queue);
 		cd->disk->queue = NULL;
 		blk_mq_free_tag_set(&cd->tag_set);
@@ -1010,8 +1013,14 @@ static int __init pcd_init(void)
 	pcd_probe_capabilities();
 
 	if (register_blkdev(major, name)) {
-		for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)
+		for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
+			if (!cd->disk)
+				continue;
+
+			blk_cleanup_queue(cd->disk->queue);
+			blk_mq_free_tag_set(&cd->tag_set);
 			put_disk(cd->disk);
+		}
 		return -EBUSY;
 	}
 
@@ -1032,6 +1041,9 @@ static void __exit pcd_exit(void)
 	int unit;
 
 	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
+		if (!cd->disk)
+			continue;
+
 		if (cd->present) {
 			del_gendisk(cd->disk);
 			pi_release(cd->pi);",linux,f0d1762554014ce0ae347b9f0d088f2c157c8c72,bcc816dfe51ab86ca94663c7b225f2d6eb0fddb9,1,"static void pcd_init_units(void)
{
	struct pcd_unit *cd;
	int unit;

	pcd_drive_count = 0;
	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
		struct gendisk *disk = alloc_disk(1);

		if (!disk)
			continue;

 		disk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops,
 						   1, BLK_MQ_F_SHOULD_MERGE);
 		if (IS_ERR(disk->queue)) {
//fix_flaw_line_below:
//			put_disk(disk);
 			disk->queue = NULL;
 			continue;
 		}

		INIT_LIST_HEAD(&cd->rq_list);
		disk->queue->queuedata = cd;
		blk_queue_bounce_limit(disk->queue, BLK_BOUNCE_HIGH);
		cd->disk = disk;
		cd->pi = &cd->pia;
		cd->present = 0;
		cd->last_sense = 0;
		cd->changed = 1;
		cd->drive = (*drives[unit])[D_SLV];
		if ((*drives[unit])[D_PRT])
			pcd_drive_count++;

		cd->name = &cd->info.name[0];
		snprintf(cd->name, sizeof(cd->info.name), ""%s%d"", name, unit);
		cd->info.ops = &pcd_dops;
		cd->info.handle = cd;
		cd->info.speed = 0;
		cd->info.capacity = 1;
		cd->info.mask = 0;
		disk->major = major;
		disk->first_minor = unit;
		strcpy(disk->disk_name, cd->name);	/* umm... */
		disk->fops = &pcd_bdops;
		disk->flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE;
	}
}
"
4957,182693,,Local,Not required,Complete,CVE-2019-15922,https://www.cvedetails.com/cve/CVE-2019-15922/,CWE-476,Low,,,,2019-09-04,4.9,An issue was discovered in the Linux kernel before 5.0.9. There is a NULL pointer dereference for a pf data structure if alloc_disk fails in drivers/block/paride/pf.c.,2019-10-04,,2,https://github.com/torvalds/linux/commit/58ccd2d31e502c37e108b285bf3d343eb00c235b,58ccd2d31e502c37e108b285bf3d343eb00c235b,"paride/pf: Fix potential NULL pointer dereference

Syzkaller report this:

pf: pf version 1.04, major 47, cluster 64, nice 0
pf: No ATAPI disk detected
kasan: CONFIG_KASAN_INLINE enabled
kasan: GPF could be caused by NULL-ptr deref or user memory access
general protection fault: 0000 [#1] SMP KASAN PTI
CPU: 0 PID: 9887 Comm: syz-executor.0 Tainted: G         C        5.1.0-rc3+ #8
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
RIP: 0010:pf_init+0x7af/0x1000 [pf]
Code: 46 77 d2 48 89 d8 48 c1 e8 03 80 3c 28 00 74 08 48 89 df e8 03 25 a6 d2 4c 8b 23 49 8d bc 24 80 05 00 00 48 89 f8 48 c1 e8 03 <80> 3c 28 00 74 05 e8 e6 24 a6 d2 49 8b bc 24 80 05 00 00 e8 79 34
RSP: 0018:ffff8881abcbf998 EFLAGS: 00010202
RAX: 00000000000000b0 RBX: ffffffffc1e4a8a8 RCX: ffffffffaec50788
RDX: 0000000000039b10 RSI: ffffc9000153c000 RDI: 0000000000000580
RBP: dffffc0000000000 R08: ffffed103ee44e59 R09: ffffed103ee44e59
R10: 0000000000000001 R11: ffffed103ee44e58 R12: 0000000000000000
R13: ffffffffc1e4b028 R14: 0000000000000000 R15: 0000000000000020
FS:  00007f1b78a91700(0000) GS:ffff8881f7200000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f6d72b207f8 CR3: 00000001d5790004 CR4: 00000000007606f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
PKRU: 55555554
Call Trace:
 ? 0xffffffffc1e50000
 do_one_initcall+0xbc/0x47d init/main.c:901
 do_init_module+0x1b5/0x547 kernel/module.c:3456
 load_module+0x6405/0x8c10 kernel/module.c:3804
 __do_sys_finit_module+0x162/0x190 kernel/module.c:3898
 do_syscall_64+0x9f/0x450 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x49/0xbe
RIP: 0033:0x462e99
Code: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007f1b78a90c58 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
RAX: ffffffffffffffda RBX: 000000000073bf00 RCX: 0000000000462e99
RDX: 0000000000000000 RSI: 0000000020000180 RDI: 0000000000000003
RBP: 00007f1b78a90c70 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 00007f1b78a916bc
R13: 00000000004bcefa R14: 00000000006f6fb0 R15: 0000000000000004
Modules linked in: pf(+) paride gpio_tps65218 tps65218 i2c_cht_wc ati_remote dc395x act_meta_skbtcindex act_ife ife ecdh_generic rc_xbox_dvd sky81452_regulator v4l2_fwnode leds_blinkm snd_usb_hiface comedi(C) aes_ti slhc cfi_cmdset_0020 mtd cfi_util sx8654 mdio_gpio of_mdio fixed_phy mdio_bitbang libphy alcor_pci matrix_keymap hid_uclogic usbhid scsi_transport_fc videobuf2_v4l2 videobuf2_dma_sg snd_soc_pcm179x_spi snd_soc_pcm179x_codec i2c_demux_pinctrl mdev snd_indigodj isl6405 mii enc28j60 cmac adt7316_i2c(C) adt7316(C) fmc_trivial fmc nf_reject_ipv4 authenc rc_dtt200u rtc_ds1672 dvb_usb_dibusb_mc dvb_usb_dibusb_mc_common dib3000mc dibx000_common dvb_usb_dibusb_common dvb_usb dvb_core videobuf2_common videobuf2_vmalloc videobuf2_memops regulator_haptic adf7242 mac802154 ieee802154 s5h1409 da9034_ts snd_intel8x0m wmi cx24120 usbcore sdhci_cadence sdhci_pltfm sdhci mmc_core joydev i2c_algo_bit scsi_transport_iscsi iscsi_boot_sysfs ves1820 lockd grace nfs_acl auth_rpcgss sunrp
 c
 ip_vs snd_soc_adau7002 snd_cs4281 snd_rawmidi gameport snd_opl3_lib snd_seq_device snd_hwdep snd_ac97_codec ad7418 hid_primax hid snd_soc_cs4265 snd_soc_core snd_pcm_dmaengine snd_pcm snd_timer ac97_bus snd_compress snd soundcore ti_adc108s102 eeprom_93cx6 i2c_algo_pca mlxreg_hotplug st_pressure st_sensors industrialio_triggered_buffer kfifo_buf industrialio v4l2_common videodev media snd_soc_adau_utils rc_pinnacle_grey rc_core pps_gpio leds_lm3692x nandcore ledtrig_pattern iptable_security iptable_raw iptable_mangle iptable_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 iptable_filter bpfilter ip6_vti ip_vti ip_gre ipip sit tunnel4 ip_tunnel hsr veth netdevsim vxcan batman_adv cfg80211 rfkill chnl_net caif nlmon dummy team bonding vcan bridge stp llc ip6_gre gre ip6_tunnel tunnel6 tun mousedev ppdev tpm kvm_intel kvm irqbypass crct10dif_pclmul crc32_pclmul crc32c_intel ghash_clmulni_intel aesni_intel ide_pci_generic aes_x86_64 piix crypto_simd input_leds psmouse cryp
 td
 glue_helper ide_core intel_agp serio_raw intel_gtt agpgart ata_generic i2c_piix4 pata_acpi parport_pc parport rtc_cmos floppy sch_fq_codel ip_tables x_tables sha1_ssse3 sha1_generic ipv6 [last unloaded: paride]
Dumping ftrace buffer:
  (ftrace buffer empty)
---[ end trace 7a818cf5f210d79e ]---

If alloc_disk fails in pf_init_units, pf->disk will be
NULL, however in pf_detect and pf_exit, it's not check
this before free.It may result a NULL pointer dereference.

Also when register_blkdev failed, blk_cleanup_queue() and
blk_mq_free_tag_set() should be called to free resources.

Reported-by: Hulk Robot <hulkci@huawei.com>
Fixes: 6ce59025f118 (""paride/pf: cleanup queues when detection fails"")
Signed-off-by: YueHaibing <yuehaibing@huawei.com>

Signed-off-by: Jens Axboe <axboe@kernel.dk>",0,drivers/block/paride/pf.c,"{""sha"": ""35e6e271b219ccbe524e60499f78ff65fcb67994"", ""filename"": ""drivers/block/paride/pf.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 1, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/58ccd2d31e502c37e108b285bf3d343eb00c235b/drivers/block/paride/pf.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/58ccd2d31e502c37e108b285bf3d343eb00c235b/drivers/block/paride/pf.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/block/paride/pf.c?ref=58ccd2d31e502c37e108b285bf3d343eb00c235b"", ""patch"": ""@@ -762,6 +762,8 @@ static int pf_detect(void)\n \n \tprintk(\""%s: No ATAPI disk detected\\n\"", name);\n \tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n+\t\tif (!pf->disk)\n+\t\t\tcontinue;\n \t\tblk_cleanup_queue(pf->disk->queue);\n \t\tpf->disk->queue = NULL;\n \t\tblk_mq_free_tag_set(&pf->tag_set);\n@@ -1029,8 +1031,13 @@ static int __init pf_init(void)\n \tpf_busy = 0;\n \n \tif (register_blkdev(major, name)) {\n-\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)\n+\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n+\t\t\tif (!pf->disk)\n+\t\t\t\tcontinue;\n+\t\t\tblk_cleanup_queue(pf->disk->queue);\n+\t\t\tblk_mq_free_tag_set(&pf->tag_set);\n \t\t\tput_disk(pf->disk);\n+\t\t}\n \t\treturn -EBUSY;\n \t}\n \n@@ -1051,6 +1058,9 @@ static void __exit pf_exit(void)\n \tint unit;\n \tunregister_blkdev(major, name);\n \tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n+\t\tif (!pf->disk)\n+\t\t\tcontinue;\n+\n \t\tif (pf->present)\n \t\t\tdel_gendisk(pf->disk);\n ""}","static int pf_detect(void)
{
	struct pf_unit *pf = units;
	int k, unit;

	printk(""%s: %s version %s, major %d, cluster %d, nice %d\n"",
	       name, name, PF_VERSION, major, cluster, nice);

	par_drv = pi_register_driver(name);
	if (!par_drv) {
		pr_err(""failed to register %s driver\n"", name);
		return -1;
	}
	k = 0;
	if (pf_drive_count == 0) {
		if (pi_init(pf->pi, 1, -1, -1, -1, -1, -1, pf_scratch, PI_PF,
			    verbose, pf->name)) {
			if (!pf_probe(pf) && pf->disk) {
				pf->present = 1;
				k++;
			} else
				pi_release(pf->pi);
		}

	} else
		for (unit = 0; unit < PF_UNITS; unit++, pf++) {
			int *conf = *drives[unit];
			if (!conf[D_PRT])
				continue;
			if (pi_init(pf->pi, 0, conf[D_PRT], conf[D_MOD],
				    conf[D_UNI], conf[D_PRO], conf[D_DLY],
				    pf_scratch, PI_PF, verbose, pf->name)) {
				if (pf->disk && !pf_probe(pf)) {
					pf->present = 1;
					k++;
				} else
					pi_release(pf->pi);
			}
		}
	if (k)
		return 0;
 
 	printk(""%s: No ATAPI disk detected\n"", name);
 	for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
		if (!pf->disk)
			continue;
 		blk_cleanup_queue(pf->disk->queue);
 		pf->disk->queue = NULL;
 		blk_mq_free_tag_set(&pf->tag_set);
		put_disk(pf->disk);
	}
	pi_unregister_driver(par_drv);
	return -1;
}
","static int pf_detect(void)
{
	struct pf_unit *pf = units;
	int k, unit;

	printk(""%s: %s version %s, major %d, cluster %d, nice %d\n"",
	       name, name, PF_VERSION, major, cluster, nice);

	par_drv = pi_register_driver(name);
	if (!par_drv) {
		pr_err(""failed to register %s driver\n"", name);
		return -1;
	}
	k = 0;
	if (pf_drive_count == 0) {
		if (pi_init(pf->pi, 1, -1, -1, -1, -1, -1, pf_scratch, PI_PF,
			    verbose, pf->name)) {
			if (!pf_probe(pf) && pf->disk) {
				pf->present = 1;
				k++;
			} else
				pi_release(pf->pi);
		}

	} else
		for (unit = 0; unit < PF_UNITS; unit++, pf++) {
			int *conf = *drives[unit];
			if (!conf[D_PRT])
				continue;
			if (pi_init(pf->pi, 0, conf[D_PRT], conf[D_MOD],
				    conf[D_UNI], conf[D_PRO], conf[D_DLY],
				    pf_scratch, PI_PF, verbose, pf->name)) {
				if (pf->disk && !pf_probe(pf)) {
					pf->present = 1;
					k++;
				} else
					pi_release(pf->pi);
			}
		}
	if (k)
		return 0;
 
 	printk(""%s: No ATAPI disk detected\n"", name);
 	for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
 		blk_cleanup_queue(pf->disk->queue);
 		pf->disk->queue = NULL;
 		blk_mq_free_tag_set(&pf->tag_set);
		put_disk(pf->disk);
	}
	pi_unregister_driver(par_drv);
	return -1;
}
",C,"		if (!pf->disk)
			continue;
",,,"@@ -762,6 +762,8 @@ static int pf_detect(void)
 
 	printk(""%s: No ATAPI disk detected\n"", name);
 	for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
+		if (!pf->disk)
+			continue;
 		blk_cleanup_queue(pf->disk->queue);
 		pf->disk->queue = NULL;
 		blk_mq_free_tag_set(&pf->tag_set);
@@ -1029,8 +1031,13 @@ static int __init pf_init(void)
 	pf_busy = 0;
 
 	if (register_blkdev(major, name)) {
-		for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)
+		for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
+			if (!pf->disk)
+				continue;
+			blk_cleanup_queue(pf->disk->queue);
+			blk_mq_free_tag_set(&pf->tag_set);
 			put_disk(pf->disk);
+		}
 		return -EBUSY;
 	}
 
@@ -1051,6 +1058,9 @@ static void __exit pf_exit(void)
 	int unit;
 	unregister_blkdev(major, name);
 	for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
+		if (!pf->disk)
+			continue;
+
 		if (pf->present)
 			del_gendisk(pf->disk);
 ",linux,58ccd2d31e502c37e108b285bf3d343eb00c235b,25adf50fe25d506d3fc12070a5ff4be858a1ac1b,1,"static int pf_detect(void)
{
	struct pf_unit *pf = units;
	int k, unit;

	printk(""%s: %s version %s, major %d, cluster %d, nice %d\n"",
	       name, name, PF_VERSION, major, cluster, nice);

	par_drv = pi_register_driver(name);
	if (!par_drv) {
		pr_err(""failed to register %s driver\n"", name);
		return -1;
	}
	k = 0;
	if (pf_drive_count == 0) {
		if (pi_init(pf->pi, 1, -1, -1, -1, -1, -1, pf_scratch, PI_PF,
			    verbose, pf->name)) {
			if (!pf_probe(pf) && pf->disk) {
				pf->present = 1;
				k++;
			} else
				pi_release(pf->pi);
		}

	} else
		for (unit = 0; unit < PF_UNITS; unit++, pf++) {
			int *conf = *drives[unit];
			if (!conf[D_PRT])
				continue;
			if (pi_init(pf->pi, 0, conf[D_PRT], conf[D_MOD],
				    conf[D_UNI], conf[D_PRO], conf[D_DLY],
				    pf_scratch, PI_PF, verbose, pf->name)) {
				if (pf->disk && !pf_probe(pf)) {
					pf->present = 1;
					k++;
				} else
					pi_release(pf->pi);
			}
		}
	if (k)
		return 0;
 
 	printk(""%s: No ATAPI disk detected\n"", name);
 	for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
//fix_flaw_line_below:
//		if (!pf->disk)
//fix_flaw_line_below:
//			continue;
 		blk_cleanup_queue(pf->disk->queue);
 		pf->disk->queue = NULL;
 		blk_mq_free_tag_set(&pf->tag_set);
		put_disk(pf->disk);
	}
	pi_unregister_driver(par_drv);
	return -1;
}
"
4958,182694,,Local,Not required,Complete,CVE-2019-15922,https://www.cvedetails.com/cve/CVE-2019-15922/,CWE-476,Low,,,,2019-09-04,4.9,An issue was discovered in the Linux kernel before 5.0.9. There is a NULL pointer dereference for a pf data structure if alloc_disk fails in drivers/block/paride/pf.c.,2019-10-04,,3,https://github.com/torvalds/linux/commit/58ccd2d31e502c37e108b285bf3d343eb00c235b,58ccd2d31e502c37e108b285bf3d343eb00c235b,"paride/pf: Fix potential NULL pointer dereference

Syzkaller report this:

pf: pf version 1.04, major 47, cluster 64, nice 0
pf: No ATAPI disk detected
kasan: CONFIG_KASAN_INLINE enabled
kasan: GPF could be caused by NULL-ptr deref or user memory access
general protection fault: 0000 [#1] SMP KASAN PTI
CPU: 0 PID: 9887 Comm: syz-executor.0 Tainted: G         C        5.1.0-rc3+ #8
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
RIP: 0010:pf_init+0x7af/0x1000 [pf]
Code: 46 77 d2 48 89 d8 48 c1 e8 03 80 3c 28 00 74 08 48 89 df e8 03 25 a6 d2 4c 8b 23 49 8d bc 24 80 05 00 00 48 89 f8 48 c1 e8 03 <80> 3c 28 00 74 05 e8 e6 24 a6 d2 49 8b bc 24 80 05 00 00 e8 79 34
RSP: 0018:ffff8881abcbf998 EFLAGS: 00010202
RAX: 00000000000000b0 RBX: ffffffffc1e4a8a8 RCX: ffffffffaec50788
RDX: 0000000000039b10 RSI: ffffc9000153c000 RDI: 0000000000000580
RBP: dffffc0000000000 R08: ffffed103ee44e59 R09: ffffed103ee44e59
R10: 0000000000000001 R11: ffffed103ee44e58 R12: 0000000000000000
R13: ffffffffc1e4b028 R14: 0000000000000000 R15: 0000000000000020
FS:  00007f1b78a91700(0000) GS:ffff8881f7200000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f6d72b207f8 CR3: 00000001d5790004 CR4: 00000000007606f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
PKRU: 55555554
Call Trace:
 ? 0xffffffffc1e50000
 do_one_initcall+0xbc/0x47d init/main.c:901
 do_init_module+0x1b5/0x547 kernel/module.c:3456
 load_module+0x6405/0x8c10 kernel/module.c:3804
 __do_sys_finit_module+0x162/0x190 kernel/module.c:3898
 do_syscall_64+0x9f/0x450 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x49/0xbe
RIP: 0033:0x462e99
Code: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007f1b78a90c58 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
RAX: ffffffffffffffda RBX: 000000000073bf00 RCX: 0000000000462e99
RDX: 0000000000000000 RSI: 0000000020000180 RDI: 0000000000000003
RBP: 00007f1b78a90c70 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 00007f1b78a916bc
R13: 00000000004bcefa R14: 00000000006f6fb0 R15: 0000000000000004
Modules linked in: pf(+) paride gpio_tps65218 tps65218 i2c_cht_wc ati_remote dc395x act_meta_skbtcindex act_ife ife ecdh_generic rc_xbox_dvd sky81452_regulator v4l2_fwnode leds_blinkm snd_usb_hiface comedi(C) aes_ti slhc cfi_cmdset_0020 mtd cfi_util sx8654 mdio_gpio of_mdio fixed_phy mdio_bitbang libphy alcor_pci matrix_keymap hid_uclogic usbhid scsi_transport_fc videobuf2_v4l2 videobuf2_dma_sg snd_soc_pcm179x_spi snd_soc_pcm179x_codec i2c_demux_pinctrl mdev snd_indigodj isl6405 mii enc28j60 cmac adt7316_i2c(C) adt7316(C) fmc_trivial fmc nf_reject_ipv4 authenc rc_dtt200u rtc_ds1672 dvb_usb_dibusb_mc dvb_usb_dibusb_mc_common dib3000mc dibx000_common dvb_usb_dibusb_common dvb_usb dvb_core videobuf2_common videobuf2_vmalloc videobuf2_memops regulator_haptic adf7242 mac802154 ieee802154 s5h1409 da9034_ts snd_intel8x0m wmi cx24120 usbcore sdhci_cadence sdhci_pltfm sdhci mmc_core joydev i2c_algo_bit scsi_transport_iscsi iscsi_boot_sysfs ves1820 lockd grace nfs_acl auth_rpcgss sunrp
 c
 ip_vs snd_soc_adau7002 snd_cs4281 snd_rawmidi gameport snd_opl3_lib snd_seq_device snd_hwdep snd_ac97_codec ad7418 hid_primax hid snd_soc_cs4265 snd_soc_core snd_pcm_dmaengine snd_pcm snd_timer ac97_bus snd_compress snd soundcore ti_adc108s102 eeprom_93cx6 i2c_algo_pca mlxreg_hotplug st_pressure st_sensors industrialio_triggered_buffer kfifo_buf industrialio v4l2_common videodev media snd_soc_adau_utils rc_pinnacle_grey rc_core pps_gpio leds_lm3692x nandcore ledtrig_pattern iptable_security iptable_raw iptable_mangle iptable_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 iptable_filter bpfilter ip6_vti ip_vti ip_gre ipip sit tunnel4 ip_tunnel hsr veth netdevsim vxcan batman_adv cfg80211 rfkill chnl_net caif nlmon dummy team bonding vcan bridge stp llc ip6_gre gre ip6_tunnel tunnel6 tun mousedev ppdev tpm kvm_intel kvm irqbypass crct10dif_pclmul crc32_pclmul crc32c_intel ghash_clmulni_intel aesni_intel ide_pci_generic aes_x86_64 piix crypto_simd input_leds psmouse cryp
 td
 glue_helper ide_core intel_agp serio_raw intel_gtt agpgart ata_generic i2c_piix4 pata_acpi parport_pc parport rtc_cmos floppy sch_fq_codel ip_tables x_tables sha1_ssse3 sha1_generic ipv6 [last unloaded: paride]
Dumping ftrace buffer:
  (ftrace buffer empty)
---[ end trace 7a818cf5f210d79e ]---

If alloc_disk fails in pf_init_units, pf->disk will be
NULL, however in pf_detect and pf_exit, it's not check
this before free.It may result a NULL pointer dereference.

Also when register_blkdev failed, blk_cleanup_queue() and
blk_mq_free_tag_set() should be called to free resources.

Reported-by: Hulk Robot <hulkci@huawei.com>
Fixes: 6ce59025f118 (""paride/pf: cleanup queues when detection fails"")
Signed-off-by: YueHaibing <yuehaibing@huawei.com>

Signed-off-by: Jens Axboe <axboe@kernel.dk>",0,drivers/block/paride/pf.c,"{""sha"": ""35e6e271b219ccbe524e60499f78ff65fcb67994"", ""filename"": ""drivers/block/paride/pf.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 1, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/58ccd2d31e502c37e108b285bf3d343eb00c235b/drivers/block/paride/pf.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/58ccd2d31e502c37e108b285bf3d343eb00c235b/drivers/block/paride/pf.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/block/paride/pf.c?ref=58ccd2d31e502c37e108b285bf3d343eb00c235b"", ""patch"": ""@@ -762,6 +762,8 @@ static int pf_detect(void)\n \n \tprintk(\""%s: No ATAPI disk detected\\n\"", name);\n \tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n+\t\tif (!pf->disk)\n+\t\t\tcontinue;\n \t\tblk_cleanup_queue(pf->disk->queue);\n \t\tpf->disk->queue = NULL;\n \t\tblk_mq_free_tag_set(&pf->tag_set);\n@@ -1029,8 +1031,13 @@ static int __init pf_init(void)\n \tpf_busy = 0;\n \n \tif (register_blkdev(major, name)) {\n-\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)\n+\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n+\t\t\tif (!pf->disk)\n+\t\t\t\tcontinue;\n+\t\t\tblk_cleanup_queue(pf->disk->queue);\n+\t\t\tblk_mq_free_tag_set(&pf->tag_set);\n \t\t\tput_disk(pf->disk);\n+\t\t}\n \t\treturn -EBUSY;\n \t}\n \n@@ -1051,6 +1058,9 @@ static void __exit pf_exit(void)\n \tint unit;\n \tunregister_blkdev(major, name);\n \tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n+\t\tif (!pf->disk)\n+\t\t\tcontinue;\n+\n \t\tif (pf->present)\n \t\t\tdel_gendisk(pf->disk);\n ""}","static void __exit pf_exit(void)
{
	struct pf_unit *pf;
 	int unit;
 	unregister_blkdev(major, name);
 	for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
		if (!pf->disk)
			continue;

 		if (pf->present)
 			del_gendisk(pf->disk);
 
		blk_cleanup_queue(pf->disk->queue);
		blk_mq_free_tag_set(&pf->tag_set);
		put_disk(pf->disk);

		if (pf->present)
			pi_release(pf->pi);
	}
}
","static void __exit pf_exit(void)
{
	struct pf_unit *pf;
 	int unit;
 	unregister_blkdev(major, name);
 	for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
 		if (pf->present)
 			del_gendisk(pf->disk);
 
		blk_cleanup_queue(pf->disk->queue);
		blk_mq_free_tag_set(&pf->tag_set);
		put_disk(pf->disk);

		if (pf->present)
			pi_release(pf->pi);
	}
}
",C,"		if (!pf->disk)
			continue;

",,,"@@ -762,6 +762,8 @@ static int pf_detect(void)
 
 	printk(""%s: No ATAPI disk detected\n"", name);
 	for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
+		if (!pf->disk)
+			continue;
 		blk_cleanup_queue(pf->disk->queue);
 		pf->disk->queue = NULL;
 		blk_mq_free_tag_set(&pf->tag_set);
@@ -1029,8 +1031,13 @@ static int __init pf_init(void)
 	pf_busy = 0;
 
 	if (register_blkdev(major, name)) {
-		for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)
+		for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
+			if (!pf->disk)
+				continue;
+			blk_cleanup_queue(pf->disk->queue);
+			blk_mq_free_tag_set(&pf->tag_set);
 			put_disk(pf->disk);
+		}
 		return -EBUSY;
 	}
 
@@ -1051,6 +1058,9 @@ static void __exit pf_exit(void)
 	int unit;
 	unregister_blkdev(major, name);
 	for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
+		if (!pf->disk)
+			continue;
+
 		if (pf->present)
 			del_gendisk(pf->disk);
 ",linux,58ccd2d31e502c37e108b285bf3d343eb00c235b,25adf50fe25d506d3fc12070a5ff4be858a1ac1b,1,"static void __exit pf_exit(void)
{
	struct pf_unit *pf;
 	int unit;
 	unregister_blkdev(major, name);
 	for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
//fix_flaw_line_below:
//		if (!pf->disk)
//fix_flaw_line_below:
//			continue;
//fix_flaw_line_below:
//
 		if (pf->present)
 			del_gendisk(pf->disk);
 
		blk_cleanup_queue(pf->disk->queue);
		blk_mq_free_tag_set(&pf->tag_set);
		put_disk(pf->disk);

		if (pf->present)
			pi_release(pf->pi);
	}
}
"
4959,182695,,Local,Not required,Complete,CVE-2019-15922,https://www.cvedetails.com/cve/CVE-2019-15922/,CWE-476,Low,,,,2019-09-04,4.9,An issue was discovered in the Linux kernel before 5.0.9. There is a NULL pointer dereference for a pf data structure if alloc_disk fails in drivers/block/paride/pf.c.,2019-10-04,,6,https://github.com/torvalds/linux/commit/58ccd2d31e502c37e108b285bf3d343eb00c235b,58ccd2d31e502c37e108b285bf3d343eb00c235b,"paride/pf: Fix potential NULL pointer dereference

Syzkaller report this:

pf: pf version 1.04, major 47, cluster 64, nice 0
pf: No ATAPI disk detected
kasan: CONFIG_KASAN_INLINE enabled
kasan: GPF could be caused by NULL-ptr deref or user memory access
general protection fault: 0000 [#1] SMP KASAN PTI
CPU: 0 PID: 9887 Comm: syz-executor.0 Tainted: G         C        5.1.0-rc3+ #8
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
RIP: 0010:pf_init+0x7af/0x1000 [pf]
Code: 46 77 d2 48 89 d8 48 c1 e8 03 80 3c 28 00 74 08 48 89 df e8 03 25 a6 d2 4c 8b 23 49 8d bc 24 80 05 00 00 48 89 f8 48 c1 e8 03 <80> 3c 28 00 74 05 e8 e6 24 a6 d2 49 8b bc 24 80 05 00 00 e8 79 34
RSP: 0018:ffff8881abcbf998 EFLAGS: 00010202
RAX: 00000000000000b0 RBX: ffffffffc1e4a8a8 RCX: ffffffffaec50788
RDX: 0000000000039b10 RSI: ffffc9000153c000 RDI: 0000000000000580
RBP: dffffc0000000000 R08: ffffed103ee44e59 R09: ffffed103ee44e59
R10: 0000000000000001 R11: ffffed103ee44e58 R12: 0000000000000000
R13: ffffffffc1e4b028 R14: 0000000000000000 R15: 0000000000000020
FS:  00007f1b78a91700(0000) GS:ffff8881f7200000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f6d72b207f8 CR3: 00000001d5790004 CR4: 00000000007606f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
PKRU: 55555554
Call Trace:
 ? 0xffffffffc1e50000
 do_one_initcall+0xbc/0x47d init/main.c:901
 do_init_module+0x1b5/0x547 kernel/module.c:3456
 load_module+0x6405/0x8c10 kernel/module.c:3804
 __do_sys_finit_module+0x162/0x190 kernel/module.c:3898
 do_syscall_64+0x9f/0x450 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x49/0xbe
RIP: 0033:0x462e99
Code: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007f1b78a90c58 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
RAX: ffffffffffffffda RBX: 000000000073bf00 RCX: 0000000000462e99
RDX: 0000000000000000 RSI: 0000000020000180 RDI: 0000000000000003
RBP: 00007f1b78a90c70 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 00007f1b78a916bc
R13: 00000000004bcefa R14: 00000000006f6fb0 R15: 0000000000000004
Modules linked in: pf(+) paride gpio_tps65218 tps65218 i2c_cht_wc ati_remote dc395x act_meta_skbtcindex act_ife ife ecdh_generic rc_xbox_dvd sky81452_regulator v4l2_fwnode leds_blinkm snd_usb_hiface comedi(C) aes_ti slhc cfi_cmdset_0020 mtd cfi_util sx8654 mdio_gpio of_mdio fixed_phy mdio_bitbang libphy alcor_pci matrix_keymap hid_uclogic usbhid scsi_transport_fc videobuf2_v4l2 videobuf2_dma_sg snd_soc_pcm179x_spi snd_soc_pcm179x_codec i2c_demux_pinctrl mdev snd_indigodj isl6405 mii enc28j60 cmac adt7316_i2c(C) adt7316(C) fmc_trivial fmc nf_reject_ipv4 authenc rc_dtt200u rtc_ds1672 dvb_usb_dibusb_mc dvb_usb_dibusb_mc_common dib3000mc dibx000_common dvb_usb_dibusb_common dvb_usb dvb_core videobuf2_common videobuf2_vmalloc videobuf2_memops regulator_haptic adf7242 mac802154 ieee802154 s5h1409 da9034_ts snd_intel8x0m wmi cx24120 usbcore sdhci_cadence sdhci_pltfm sdhci mmc_core joydev i2c_algo_bit scsi_transport_iscsi iscsi_boot_sysfs ves1820 lockd grace nfs_acl auth_rpcgss sunrp
 c
 ip_vs snd_soc_adau7002 snd_cs4281 snd_rawmidi gameport snd_opl3_lib snd_seq_device snd_hwdep snd_ac97_codec ad7418 hid_primax hid snd_soc_cs4265 snd_soc_core snd_pcm_dmaengine snd_pcm snd_timer ac97_bus snd_compress snd soundcore ti_adc108s102 eeprom_93cx6 i2c_algo_pca mlxreg_hotplug st_pressure st_sensors industrialio_triggered_buffer kfifo_buf industrialio v4l2_common videodev media snd_soc_adau_utils rc_pinnacle_grey rc_core pps_gpio leds_lm3692x nandcore ledtrig_pattern iptable_security iptable_raw iptable_mangle iptable_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 iptable_filter bpfilter ip6_vti ip_vti ip_gre ipip sit tunnel4 ip_tunnel hsr veth netdevsim vxcan batman_adv cfg80211 rfkill chnl_net caif nlmon dummy team bonding vcan bridge stp llc ip6_gre gre ip6_tunnel tunnel6 tun mousedev ppdev tpm kvm_intel kvm irqbypass crct10dif_pclmul crc32_pclmul crc32c_intel ghash_clmulni_intel aesni_intel ide_pci_generic aes_x86_64 piix crypto_simd input_leds psmouse cryp
 td
 glue_helper ide_core intel_agp serio_raw intel_gtt agpgart ata_generic i2c_piix4 pata_acpi parport_pc parport rtc_cmos floppy sch_fq_codel ip_tables x_tables sha1_ssse3 sha1_generic ipv6 [last unloaded: paride]
Dumping ftrace buffer:
  (ftrace buffer empty)
---[ end trace 7a818cf5f210d79e ]---

If alloc_disk fails in pf_init_units, pf->disk will be
NULL, however in pf_detect and pf_exit, it's not check
this before free.It may result a NULL pointer dereference.

Also when register_blkdev failed, blk_cleanup_queue() and
blk_mq_free_tag_set() should be called to free resources.

Reported-by: Hulk Robot <hulkci@huawei.com>
Fixes: 6ce59025f118 (""paride/pf: cleanup queues when detection fails"")
Signed-off-by: YueHaibing <yuehaibing@huawei.com>

Signed-off-by: Jens Axboe <axboe@kernel.dk>",1,drivers/block/paride/pf.c,"{""sha"": ""35e6e271b219ccbe524e60499f78ff65fcb67994"", ""filename"": ""drivers/block/paride/pf.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 1, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/58ccd2d31e502c37e108b285bf3d343eb00c235b/drivers/block/paride/pf.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/58ccd2d31e502c37e108b285bf3d343eb00c235b/drivers/block/paride/pf.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/block/paride/pf.c?ref=58ccd2d31e502c37e108b285bf3d343eb00c235b"", ""patch"": ""@@ -762,6 +762,8 @@ static int pf_detect(void)\n \n \tprintk(\""%s: No ATAPI disk detected\\n\"", name);\n \tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n+\t\tif (!pf->disk)\n+\t\t\tcontinue;\n \t\tblk_cleanup_queue(pf->disk->queue);\n \t\tpf->disk->queue = NULL;\n \t\tblk_mq_free_tag_set(&pf->tag_set);\n@@ -1029,8 +1031,13 @@ static int __init pf_init(void)\n \tpf_busy = 0;\n \n \tif (register_blkdev(major, name)) {\n-\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)\n+\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n+\t\t\tif (!pf->disk)\n+\t\t\t\tcontinue;\n+\t\t\tblk_cleanup_queue(pf->disk->queue);\n+\t\t\tblk_mq_free_tag_set(&pf->tag_set);\n \t\t\tput_disk(pf->disk);\n+\t\t}\n \t\treturn -EBUSY;\n \t}\n \n@@ -1051,6 +1058,9 @@ static void __exit pf_exit(void)\n \tint unit;\n \tunregister_blkdev(major, name);\n \tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n+\t\tif (!pf->disk)\n+\t\t\tcontinue;\n+\n \t\tif (pf->present)\n \t\t\tdel_gendisk(pf->disk);\n ""}","static int __init pf_init(void)
{				/* preliminary initialisation */
	struct pf_unit *pf;
	int unit;

	if (disable)
		return -EINVAL;

	pf_init_units();

	if (pf_detect())
		return -ENODEV;
 	pf_busy = 0;
 
 	if (register_blkdev(major, name)) {
		for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
			if (!pf->disk)
				continue;
			blk_cleanup_queue(pf->disk->queue);
			blk_mq_free_tag_set(&pf->tag_set);
 			put_disk(pf->disk);
		}
 		return -EBUSY;
 	}
 
	for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
		struct gendisk *disk = pf->disk;

		if (!pf->present)
			continue;
		disk->private_data = pf;
		add_disk(disk);
	}
	return 0;
}
","static int __init pf_init(void)
{				/* preliminary initialisation */
	struct pf_unit *pf;
	int unit;

	if (disable)
		return -EINVAL;

	pf_init_units();

	if (pf_detect())
		return -ENODEV;
 	pf_busy = 0;
 
 	if (register_blkdev(major, name)) {
		for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)
 			put_disk(pf->disk);
 		return -EBUSY;
 	}
 
	for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
		struct gendisk *disk = pf->disk;

		if (!pf->present)
			continue;
		disk->private_data = pf;
		add_disk(disk);
	}
	return 0;
}
",C,"		for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
			if (!pf->disk)
				continue;
			blk_cleanup_queue(pf->disk->queue);
			blk_mq_free_tag_set(&pf->tag_set);
		}
","		for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)
",,"@@ -762,6 +762,8 @@ static int pf_detect(void)
 
 	printk(""%s: No ATAPI disk detected\n"", name);
 	for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
+		if (!pf->disk)
+			continue;
 		blk_cleanup_queue(pf->disk->queue);
 		pf->disk->queue = NULL;
 		blk_mq_free_tag_set(&pf->tag_set);
@@ -1029,8 +1031,13 @@ static int __init pf_init(void)
 	pf_busy = 0;
 
 	if (register_blkdev(major, name)) {
-		for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)
+		for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
+			if (!pf->disk)
+				continue;
+			blk_cleanup_queue(pf->disk->queue);
+			blk_mq_free_tag_set(&pf->tag_set);
 			put_disk(pf->disk);
+		}
 		return -EBUSY;
 	}
 
@@ -1051,6 +1058,9 @@ static void __exit pf_exit(void)
 	int unit;
 	unregister_blkdev(major, name);
 	for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
+		if (!pf->disk)
+			continue;
+
 		if (pf->present)
 			del_gendisk(pf->disk);
 ",linux,58ccd2d31e502c37e108b285bf3d343eb00c235b,25adf50fe25d506d3fc12070a5ff4be858a1ac1b,1,"static int __init pf_init(void)
{				/* preliminary initialisation */
	struct pf_unit *pf;
	int unit;

	if (disable)
		return -EINVAL;

	pf_init_units();

	if (pf_detect())
		return -ENODEV;
 	pf_busy = 0;
 
 	if (register_blkdev(major, name)) {
//flaw_line_below:
		for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)
//fix_flaw_line_below:
//		for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
//fix_flaw_line_below:
//			if (!pf->disk)
//fix_flaw_line_below:
//				continue;
//fix_flaw_line_below:
//			blk_cleanup_queue(pf->disk->queue);
//fix_flaw_line_below:
//			blk_mq_free_tag_set(&pf->tag_set);
 			put_disk(pf->disk);
//fix_flaw_line_below:
//		}
 		return -EBUSY;
 	}
 
	for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
		struct gendisk *disk = pf->disk;

		if (!pf->present)
			continue;
		disk->private_data = pf;
		add_disk(disk);
	}
	return 0;
}
"
4977,182713,,Remote,Not required,Partial,CVE-2019-15163,https://www.cvedetails.com/cve/CVE-2019-15163/,CWE-476,Low,,,,2019-10-03,5.0,rpcapd/daemon.c in libpcap before 1.9.1 allows attackers to cause a denial of service (NULL pointer dereference and daemon crash) if a crypt() call fails.,2019-10-08,DoS ,8,https://github.com/the-tcpdump-group/libpcap/commit/437b273761adedcbd880f714bfa44afeec186a31,437b273761adedcbd880f714bfa44afeec186a31,"Don't crash if crypt() fails.

It can fail, so make sure it doesn't before comparing its result with
the password.

This addresses Include Security issue F12: [libpcap] Remote Packet
Capture Daemon Null Pointer Dereference Denial of Service.",1,rpcapd/daemon.c,"{""sha"": ""c9b44aafb568db49e47da5b7f540390e78225c56"", ""filename"": ""rpcapd/daemon.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 1, ""changes"": 9, ""blob_url"": ""https://github.com/the-tcpdump-group/libpcap/blob/437b273761adedcbd880f714bfa44afeec186a31/rpcapd/daemon.c"", ""raw_url"": ""https://github.com/the-tcpdump-group/libpcap/raw/437b273761adedcbd880f714bfa44afeec186a31/rpcapd/daemon.c"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/libpcap/contents/rpcapd/daemon.c?ref=437b273761adedcbd880f714bfa44afeec186a31"", ""patch"": ""@@ -1222,6 +1222,7 @@ daemon_AuthUserPwd(char *username, char *password, char *errbuf)\n #ifdef HAVE_GETSPNAM\n \tstruct spwd *usersp;\n #endif\n+\tchar *crypt_password;\n \n \t// This call is needed to get the uid\n \tif ((user = getpwnam(username)) == NULL)\n@@ -1252,7 +1253,13 @@ daemon_AuthUserPwd(char *username, char *password, char *errbuf)\n \tuser_password = user->pw_passwd;\n #endif\n \n-\tif (strcmp(user_password, (char *) crypt(password, user_password)) != 0)\n+\tcrypt_password = crypt(password, user_password);\n+\tif (crypt_password == NULL)\n+\t{\n+\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \""Authentication failed\"");\n+\t\treturn -1;\n+\t}\n+\tif (strcmp(user_password, crypt_password) != 0)\n \t{\n \t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \""Authentication failed: user name or password incorrect\"");\n \t\treturn -1;""}","daemon_AuthUserPwd(char *username, char *password, char *errbuf)
{
#ifdef _WIN32
	/*
	 * Warning: the user which launches the process must have the
	 * SE_TCB_NAME right.
	 * This corresponds to have the ""Act as part of the Operating System""
	 * turned on (administrative tools, local security settings, local
	 * policies, user right assignment)
	 * However, it seems to me that if you run it as a service, this
	 * right should be provided by default.
	 *
	 * XXX - hopefully, this returns errors such as ERROR_LOGON_FAILURE,
	 * which merely indicates that the user name or password is
	 * incorrect, not whether it's the user name or the password
	 * that's incorrect, so a client that's trying to brute-force
	 * accounts doesn't know whether it's the user name or the
	 * password that's incorrect, so it doesn't know whether to
	 * stop trying to log in with a given user name and move on
	 * to another user name.
	 */
	HANDLE Token;
	if (LogonUser(username, ""."", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)
	{
		pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
		    GetLastError(), ""LogonUser() failed"");
		return -1;
	}

	if (ImpersonateLoggedOnUser(Token) == 0)
	{
		pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
		    GetLastError(), ""ImpersonateLoggedOnUser() failed"");
		CloseHandle(Token);
		return -1;
	}

	CloseHandle(Token);
	return 0;

#else
	/*
	 * See
	 *
	 *	http://www.unixpapa.com/incnote/passwd.html
	 *
	 * We use the Solaris/Linux shadow password authentication if
	 * we have getspnam(), otherwise we just do traditional
	 * authentication, which, on some platforms, might work, even
	 * with shadow passwords, if we're running as root.  Traditional
	 * authenticaion won't work if we're not running as root, as
	 * I think these days all UN*Xes either won't return the password
	 * at all with getpwnam() or will only do so if you're root.
	 *
	 * XXX - perhaps what we *should* be using is PAM, if we have
	 * it.  That might hide all the details of username/password
	 * authentication, whether it's done with a visible-to-root-
	 * only password database or some other authentication mechanism,
	 * behind its API.
	 */
	struct passwd *user;
	char *user_password;
 #ifdef HAVE_GETSPNAM
 	struct spwd *usersp;
 #endif
	char *crypt_password;
 
 	if ((user = getpwnam(username)) == NULL)
	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
		return -1;
	}

#ifdef HAVE_GETSPNAM
	if ((usersp = getspnam(username)) == NULL)
	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
		return -1;
	}
	user_password = usersp->sp_pwdp;
#else
	/*
	 * XXX - what about other platforms?
	 * The unixpapa.com page claims this Just Works on *BSD if you're
	 * running as root - it's from 2000, so it doesn't indicate whether
	 * macOS (which didn't come out until 2001, under the name Mac OS
	 * X) behaves like the *BSDs or not, and might also work on AIX.
	 * HP-UX does something else.
	 *
	 * Again, hopefully PAM hides all that.
	 */
 	user_password = user->pw_passwd;
 #endif
 
	crypt_password = crypt(password, user_password);
	if (crypt_password == NULL)
	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
		return -1;
	}
	if (strcmp(user_password, crypt_password) != 0)
 	{
 		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
 		return -1;
	}

	if (setuid(user->pw_uid))
	{
		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
		    errno, ""setuid"");
		return -1;
	}

/*	if (setgid(user->pw_gid))
	{
		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
		    errno, ""setgid"");
		return -1;
	}
*/
	return 0;

#endif

}
","daemon_AuthUserPwd(char *username, char *password, char *errbuf)
{
#ifdef _WIN32
	/*
	 * Warning: the user which launches the process must have the
	 * SE_TCB_NAME right.
	 * This corresponds to have the ""Act as part of the Operating System""
	 * turned on (administrative tools, local security settings, local
	 * policies, user right assignment)
	 * However, it seems to me that if you run it as a service, this
	 * right should be provided by default.
	 *
	 * XXX - hopefully, this returns errors such as ERROR_LOGON_FAILURE,
	 * which merely indicates that the user name or password is
	 * incorrect, not whether it's the user name or the password
	 * that's incorrect, so a client that's trying to brute-force
	 * accounts doesn't know whether it's the user name or the
	 * password that's incorrect, so it doesn't know whether to
	 * stop trying to log in with a given user name and move on
	 * to another user name.
	 */
	HANDLE Token;
	if (LogonUser(username, ""."", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)
	{
		pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
		    GetLastError(), ""LogonUser() failed"");
		return -1;
	}

	if (ImpersonateLoggedOnUser(Token) == 0)
	{
		pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
		    GetLastError(), ""ImpersonateLoggedOnUser() failed"");
		CloseHandle(Token);
		return -1;
	}

	CloseHandle(Token);
	return 0;

#else
	/*
	 * See
	 *
	 *	http://www.unixpapa.com/incnote/passwd.html
	 *
	 * We use the Solaris/Linux shadow password authentication if
	 * we have getspnam(), otherwise we just do traditional
	 * authentication, which, on some platforms, might work, even
	 * with shadow passwords, if we're running as root.  Traditional
	 * authenticaion won't work if we're not running as root, as
	 * I think these days all UN*Xes either won't return the password
	 * at all with getpwnam() or will only do so if you're root.
	 *
	 * XXX - perhaps what we *should* be using is PAM, if we have
	 * it.  That might hide all the details of username/password
	 * authentication, whether it's done with a visible-to-root-
	 * only password database or some other authentication mechanism,
	 * behind its API.
	 */
	struct passwd *user;
	char *user_password;
 #ifdef HAVE_GETSPNAM
 	struct spwd *usersp;
 #endif
 
 	if ((user = getpwnam(username)) == NULL)
	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
		return -1;
	}

#ifdef HAVE_GETSPNAM
	if ((usersp = getspnam(username)) == NULL)
	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
		return -1;
	}
	user_password = usersp->sp_pwdp;
#else
	/*
	 * XXX - what about other platforms?
	 * The unixpapa.com page claims this Just Works on *BSD if you're
	 * running as root - it's from 2000, so it doesn't indicate whether
	 * macOS (which didn't come out until 2001, under the name Mac OS
	 * X) behaves like the *BSDs or not, and might also work on AIX.
	 * HP-UX does something else.
	 *
	 * Again, hopefully PAM hides all that.
	 */
 	user_password = user->pw_passwd;
 #endif
 
	if (strcmp(user_password, (char *) crypt(password, user_password)) != 0)
 	{
 		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
 		return -1;
	}

	if (setuid(user->pw_uid))
	{
		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
		    errno, ""setuid"");
		return -1;
	}

/*	if (setgid(user->pw_gid))
	{
		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
		    errno, ""setgid"");
		return -1;
	}
*/
	return 0;

#endif

}
",C,"	char *crypt_password;
	crypt_password = crypt(password, user_password);
	if (crypt_password == NULL)
	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
		return -1;
	}
	if (strcmp(user_password, crypt_password) != 0)
","	if (strcmp(user_password, (char *) crypt(password, user_password)) != 0)
",,"@@ -1222,6 +1222,7 @@ daemon_AuthUserPwd(char *username, char *password, char *errbuf)
 #ifdef HAVE_GETSPNAM
 	struct spwd *usersp;
 #endif
+	char *crypt_password;
 
 	// This call is needed to get the uid
 	if ((user = getpwnam(username)) == NULL)
@@ -1252,7 +1253,13 @@ daemon_AuthUserPwd(char *username, char *password, char *errbuf)
 	user_password = user->pw_passwd;
 #endif
 
-	if (strcmp(user_password, (char *) crypt(password, user_password)) != 0)
+	crypt_password = crypt(password, user_password);
+	if (crypt_password == NULL)
+	{
+		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
+		return -1;
+	}
+	if (strcmp(user_password, crypt_password) != 0)
 	{
 		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
 		return -1;",libpcap,437b273761adedcbd880f714bfa44afeec186a31,bf4a63bda7e9eb142402693248a347a5705f9740,1,"daemon_AuthUserPwd(char *username, char *password, char *errbuf)
{
#ifdef _WIN32
	/*
	 * Warning: the user which launches the process must have the
	 * SE_TCB_NAME right.
	 * This corresponds to have the ""Act as part of the Operating System""
	 * turned on (administrative tools, local security settings, local
	 * policies, user right assignment)
	 * However, it seems to me that if you run it as a service, this
	 * right should be provided by default.
	 *
	 * XXX - hopefully, this returns errors such as ERROR_LOGON_FAILURE,
	 * which merely indicates that the user name or password is
	 * incorrect, not whether it's the user name or the password
	 * that's incorrect, so a client that's trying to brute-force
	 * accounts doesn't know whether it's the user name or the
	 * password that's incorrect, so it doesn't know whether to
	 * stop trying to log in with a given user name and move on
	 * to another user name.
	 */
	HANDLE Token;
	if (LogonUser(username, ""."", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)
	{
		pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
		    GetLastError(), ""LogonUser() failed"");
		return -1;
	}

	// This call should change the current thread to the selected user.
	// I didn't test it.
	if (ImpersonateLoggedOnUser(Token) == 0)
	{
		pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
		    GetLastError(), ""ImpersonateLoggedOnUser() failed"");
		CloseHandle(Token);
		return -1;
	}

	CloseHandle(Token);
	return 0;

#else
	/*
	 * See
	 *
	 *	http://www.unixpapa.com/incnote/passwd.html
	 *
	 * We use the Solaris/Linux shadow password authentication if
	 * we have getspnam(), otherwise we just do traditional
	 * authentication, which, on some platforms, might work, even
	 * with shadow passwords, if we're running as root.  Traditional
	 * authenticaion won't work if we're not running as root, as
	 * I think these days all UN*Xes either won't return the password
	 * at all with getpwnam() or will only do so if you're root.
	 *
	 * XXX - perhaps what we *should* be using is PAM, if we have
	 * it.  That might hide all the details of username/password
	 * authentication, whether it's done with a visible-to-root-
	 * only password database or some other authentication mechanism,
	 * behind its API.
	 */
	struct passwd *user;
	char *user_password;
 #ifdef HAVE_GETSPNAM
 	struct spwd *usersp;
 #endif
//fix_flaw_line_below:
//	char *crypt_password;
 
 	// This call is needed to get the uid
 	if ((user = getpwnam(username)) == NULL)
	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
		return -1;
	}

#ifdef HAVE_GETSPNAM
	// This call is needed to get the password; otherwise 'x' is returned
	if ((usersp = getspnam(username)) == NULL)
	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
		return -1;
	}
	user_password = usersp->sp_pwdp;
#else
	/*
	 * XXX - what about other platforms?
	 * The unixpapa.com page claims this Just Works on *BSD if you're
	 * running as root - it's from 2000, so it doesn't indicate whether
	 * macOS (which didn't come out until 2001, under the name Mac OS
	 * X) behaves like the *BSDs or not, and might also work on AIX.
	 * HP-UX does something else.
	 *
	 * Again, hopefully PAM hides all that.
	 */
 	user_password = user->pw_passwd;
 #endif
 
//flaw_line_below:
	if (strcmp(user_password, (char *) crypt(password, user_password)) != 0)
//fix_flaw_line_below:
//	crypt_password = crypt(password, user_password);
//fix_flaw_line_below:
//	if (crypt_password == NULL)
//fix_flaw_line_below:
//	{
//fix_flaw_line_below:
//		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
//fix_flaw_line_below:
//		return -1;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//	if (strcmp(user_password, crypt_password) != 0)
 	{
 		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
 		return -1;
	}

	if (setuid(user->pw_uid))
	{
		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
		    errno, ""setuid"");
		return -1;
	}

/*	if (setgid(user->pw_gid))
	{
		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
		    errno, ""setgid"");
		return -1;
	}
*/
	return 0;

#endif

}
"
5047,182783,,Remote,Not required,Partial,CVE-2019-13225,https://www.cvedetails.com/cve/CVE-2019-13225/,CWE-476,Low,,,,2019-07-10,5.0,"A NULL Pointer Dereference in match_at() in regexec.c in Oniguruma 6.9.2 allows attackers to potentially cause denial of service by providing a crafted regular expression. Oniguruma issues often affect Ruby, as well as common optional libraries for PHP and Rust.",2019-07-30,DoS ,15,https://github.com/kkos/oniguruma/commit/c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c,c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c,Fix CVE-2019-13225: problem in converting if-then-else pattern to bytecode.,7,src/regcomp.c,"{""sha"": ""ff3431f03645f540350a26f07c52d59141a6ba13"", ""filename"": ""src/regcomp.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 8, ""changes"": 25, ""blob_url"": ""https://github.com/kkos/oniguruma/blob/c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c/src/regcomp.c"", ""raw_url"": ""https://github.com/kkos/oniguruma/raw/c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c/src/regcomp.c"", ""contents_url"": ""https://api.github.com/repos/kkos/oniguruma/contents/src/regcomp.c?ref=c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c"", ""patch"": ""@@ -1307,8 +1307,9 @@ compile_length_bag_node(BagNode* node, regex_t* reg)\n         len += tlen;\n       }\n \n+      len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END;\n+\n       if (IS_NOT_NULL(Else)) {\n-        len += SIZE_OP_JUMP;\n         tlen = compile_length_tree(Else, reg);\n         if (tlen < 0) return tlen;\n         len += tlen;\n@@ -1455,7 +1456,7 @@ compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)\n \n   case BAG_IF_ELSE:\n     {\n-      int cond_len, then_len, jump_len;\n+      int cond_len, then_len, else_len, jump_len;\n       Node* cond = NODE_BAG_BODY(node);\n       Node* Then = node->te.Then;\n       Node* Else = node->te.Else;\n@@ -1472,8 +1473,7 @@ compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)\n       else\n         then_len = 0;\n \n-      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;\n-      if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;\n+      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP;\n \n       r = add_op(reg, OP_PUSH);\n       if (r != 0) return r;\n@@ -1490,11 +1490,20 @@ compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)\n       }\n \n       if (IS_NOT_NULL(Else)) {\n-        int else_len = compile_length_tree(Else, reg);\n-        r = add_op(reg, OP_JUMP);\n-        if (r != 0) return r;\n-        COP(reg)->jump.addr = else_len + SIZE_INC_OP;\n+        else_len = compile_length_tree(Else, reg);\n+        if (else_len < 0) return else_len;\n+      }\n+      else\n+        else_len = 0;\n \n+      r = add_op(reg, OP_JUMP);\n+      if (r != 0) return r;\n+      COP(reg)->jump.addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP;\n+\n+      r = add_op(reg, OP_ATOMIC_END);\n+      if (r != 0) return r;\n+\n+      if (IS_NOT_NULL(Else)) {\n         r = compile_tree(Else, reg, env);\n       }\n     }""}","compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)
{
  int r, len;

  switch (node->type) {
  case BAG_MEMORY:
    r = compile_bag_memory_node(node, reg, env);
    break;

  case BAG_OPTION:
    r = compile_option_node(node, reg, env);
    break;

  case BAG_STOP_BACKTRACK:
    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {
      QuantNode* qn = QUANT_(NODE_BAG_BODY(node));
      r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);
      if (r != 0) return r;

      len = compile_length_tree(NODE_QUANT_BODY(qn), reg);
      if (len < 0) return len;

      r = add_op(reg, OP_PUSH);
      if (r != 0) return r;
      COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;

      r = compile_tree(NODE_QUANT_BODY(qn), reg, env);
      if (r != 0) return r;
      r = add_op(reg, OP_POP_OUT);
      if (r != 0) return r;

      r = add_op(reg, OP_JUMP);
      if (r != 0) return r;
      COP(reg)->jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);
    }
    else {
      r = add_op(reg, OP_ATOMIC_START);
      if (r != 0) return r;
      r = compile_tree(NODE_BAG_BODY(node), reg, env);
      if (r != 0) return r;
      r = add_op(reg, OP_ATOMIC_END);
    }
    break;
 
   case BAG_IF_ELSE:
     {
      int cond_len, then_len, else_len, jump_len;
       Node* cond = NODE_BAG_BODY(node);
       Node* Then = node->te.Then;
       Node* Else = node->te.Else;

      r = add_op(reg, OP_ATOMIC_START);
      if (r != 0) return r;

      cond_len = compile_length_tree(cond, reg);
      if (cond_len < 0) return cond_len;
      if (IS_NOT_NULL(Then)) {
        then_len = compile_length_tree(Then, reg);
        if (then_len < 0) return then_len;
      }
       else
         then_len = 0;
 
      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP;
 
       r = add_op(reg, OP_PUSH);
       if (r != 0) return r;
      COP(reg)->push.addr = SIZE_INC_OP + jump_len;

      r = compile_tree(cond, reg, env);
      if (r != 0) return r;
      r = add_op(reg, OP_ATOMIC_END);
      if (r != 0) return r;

      if (IS_NOT_NULL(Then)) {
        r = compile_tree(Then, reg, env);
        if (r != 0) return r;
       }
 
       if (IS_NOT_NULL(Else)) {
        else_len = compile_length_tree(Else, reg);
        if (else_len < 0) return else_len;
      }
      else
        else_len = 0;
 
      r = add_op(reg, OP_JUMP);
      if (r != 0) return r;
      COP(reg)->jump.addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP;

      r = add_op(reg, OP_ATOMIC_END);
      if (r != 0) return r;

      if (IS_NOT_NULL(Else)) {
         r = compile_tree(Else, reg, env);
       }
     }
    break;
  }

  return r;
}
","compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)
{
  int r, len;

  switch (node->type) {
  case BAG_MEMORY:
    r = compile_bag_memory_node(node, reg, env);
    break;

  case BAG_OPTION:
    r = compile_option_node(node, reg, env);
    break;

  case BAG_STOP_BACKTRACK:
    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {
      QuantNode* qn = QUANT_(NODE_BAG_BODY(node));
      r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);
      if (r != 0) return r;

      len = compile_length_tree(NODE_QUANT_BODY(qn), reg);
      if (len < 0) return len;

      r = add_op(reg, OP_PUSH);
      if (r != 0) return r;
      COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;

      r = compile_tree(NODE_QUANT_BODY(qn), reg, env);
      if (r != 0) return r;
      r = add_op(reg, OP_POP_OUT);
      if (r != 0) return r;

      r = add_op(reg, OP_JUMP);
      if (r != 0) return r;
      COP(reg)->jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);
    }
    else {
      r = add_op(reg, OP_ATOMIC_START);
      if (r != 0) return r;
      r = compile_tree(NODE_BAG_BODY(node), reg, env);
      if (r != 0) return r;
      r = add_op(reg, OP_ATOMIC_END);
    }
    break;
 
   case BAG_IF_ELSE:
     {
      int cond_len, then_len, jump_len;
       Node* cond = NODE_BAG_BODY(node);
       Node* Then = node->te.Then;
       Node* Else = node->te.Else;

      r = add_op(reg, OP_ATOMIC_START);
      if (r != 0) return r;

      cond_len = compile_length_tree(cond, reg);
      if (cond_len < 0) return cond_len;
      if (IS_NOT_NULL(Then)) {
        then_len = compile_length_tree(Then, reg);
        if (then_len < 0) return then_len;
      }
       else
         then_len = 0;
 
      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;
      if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;
 
       r = add_op(reg, OP_PUSH);
       if (r != 0) return r;
      COP(reg)->push.addr = SIZE_INC_OP + jump_len;

      r = compile_tree(cond, reg, env);
      if (r != 0) return r;
      r = add_op(reg, OP_ATOMIC_END);
      if (r != 0) return r;

      if (IS_NOT_NULL(Then)) {
        r = compile_tree(Then, reg, env);
        if (r != 0) return r;
       }
 
       if (IS_NOT_NULL(Else)) {
        int else_len = compile_length_tree(Else, reg);
        r = add_op(reg, OP_JUMP);
        if (r != 0) return r;
        COP(reg)->jump.addr = else_len + SIZE_INC_OP;
 
         r = compile_tree(Else, reg, env);
       }
     }
    break;
  }

  return r;
}
",C,"      int cond_len, then_len, else_len, jump_len;
      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP;
        else_len = compile_length_tree(Else, reg);
        if (else_len < 0) return else_len;
      }
      else
        else_len = 0;
      r = add_op(reg, OP_JUMP);
      if (r != 0) return r;
      COP(reg)->jump.addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP;

      r = add_op(reg, OP_ATOMIC_END);
      if (r != 0) return r;

      if (IS_NOT_NULL(Else)) {
","      int cond_len, then_len, jump_len;
      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;
      if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;
        int else_len = compile_length_tree(Else, reg);
        r = add_op(reg, OP_JUMP);
        if (r != 0) return r;
        COP(reg)->jump.addr = else_len + SIZE_INC_OP;
",,"@@ -1307,8 +1307,9 @@ compile_length_bag_node(BagNode* node, regex_t* reg)
         len += tlen;
       }
 
+      len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END;
+
       if (IS_NOT_NULL(Else)) {
-        len += SIZE_OP_JUMP;
         tlen = compile_length_tree(Else, reg);
         if (tlen < 0) return tlen;
         len += tlen;
@@ -1455,7 +1456,7 @@ compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)
 
   case BAG_IF_ELSE:
     {
-      int cond_len, then_len, jump_len;
+      int cond_len, then_len, else_len, jump_len;
       Node* cond = NODE_BAG_BODY(node);
       Node* Then = node->te.Then;
       Node* Else = node->te.Else;
@@ -1472,8 +1473,7 @@ compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)
       else
         then_len = 0;
 
-      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;
-      if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;
+      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP;
 
       r = add_op(reg, OP_PUSH);
       if (r != 0) return r;
@@ -1490,11 +1490,20 @@ compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)
       }
 
       if (IS_NOT_NULL(Else)) {
-        int else_len = compile_length_tree(Else, reg);
-        r = add_op(reg, OP_JUMP);
-        if (r != 0) return r;
-        COP(reg)->jump.addr = else_len + SIZE_INC_OP;
+        else_len = compile_length_tree(Else, reg);
+        if (else_len < 0) return else_len;
+      }
+      else
+        else_len = 0;
 
+      r = add_op(reg, OP_JUMP);
+      if (r != 0) return r;
+      COP(reg)->jump.addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP;
+
+      r = add_op(reg, OP_ATOMIC_END);
+      if (r != 0) return r;
+
+      if (IS_NOT_NULL(Else)) {
         r = compile_tree(Else, reg, env);
       }
     }",oniguruma,c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c,4cf9f4795cb88ba639d6fd68890950ae737f89d7,1,"compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)
{
  int r, len;

  switch (node->type) {
  case BAG_MEMORY:
    r = compile_bag_memory_node(node, reg, env);
    break;

  case BAG_OPTION:
    r = compile_option_node(node, reg, env);
    break;

  case BAG_STOP_BACKTRACK:
    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {
      QuantNode* qn = QUANT_(NODE_BAG_BODY(node));
      r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);
      if (r != 0) return r;

      len = compile_length_tree(NODE_QUANT_BODY(qn), reg);
      if (len < 0) return len;

      r = add_op(reg, OP_PUSH);
      if (r != 0) return r;
      COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;

      r = compile_tree(NODE_QUANT_BODY(qn), reg, env);
      if (r != 0) return r;
      r = add_op(reg, OP_POP_OUT);
      if (r != 0) return r;

      r = add_op(reg, OP_JUMP);
      if (r != 0) return r;
      COP(reg)->jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);
    }
    else {
      r = add_op(reg, OP_ATOMIC_START);
      if (r != 0) return r;
      r = compile_tree(NODE_BAG_BODY(node), reg, env);
      if (r != 0) return r;
      r = add_op(reg, OP_ATOMIC_END);
    }
    break;
 
   case BAG_IF_ELSE:
     {
//flaw_line_below:
      int cond_len, then_len, jump_len;
//fix_flaw_line_below:
//      int cond_len, then_len, else_len, jump_len;
       Node* cond = NODE_BAG_BODY(node);
       Node* Then = node->te.Then;
       Node* Else = node->te.Else;

      r = add_op(reg, OP_ATOMIC_START);
      if (r != 0) return r;

      cond_len = compile_length_tree(cond, reg);
      if (cond_len < 0) return cond_len;
      if (IS_NOT_NULL(Then)) {
        then_len = compile_length_tree(Then, reg);
        if (then_len < 0) return then_len;
      }
       else
         then_len = 0;
 
//flaw_line_below:
      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;
//flaw_line_below:
      if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;
//fix_flaw_line_below:
//      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP;
 
       r = add_op(reg, OP_PUSH);
       if (r != 0) return r;
      COP(reg)->push.addr = SIZE_INC_OP + jump_len;

      r = compile_tree(cond, reg, env);
      if (r != 0) return r;
      r = add_op(reg, OP_ATOMIC_END);
      if (r != 0) return r;

      if (IS_NOT_NULL(Then)) {
        r = compile_tree(Then, reg, env);
        if (r != 0) return r;
       }
 
       if (IS_NOT_NULL(Else)) {
//flaw_line_below:
        int else_len = compile_length_tree(Else, reg);
//flaw_line_below:
        r = add_op(reg, OP_JUMP);
//flaw_line_below:
        if (r != 0) return r;
//flaw_line_below:
        COP(reg)->jump.addr = else_len + SIZE_INC_OP;
//fix_flaw_line_below:
//        else_len = compile_length_tree(Else, reg);
//fix_flaw_line_below:
//        if (else_len < 0) return else_len;
//fix_flaw_line_below:
//      }
//fix_flaw_line_below:
//      else
//fix_flaw_line_below:
//        else_len = 0;
 
//fix_flaw_line_below:
//      r = add_op(reg, OP_JUMP);
//fix_flaw_line_below:
//      if (r != 0) return r;
//fix_flaw_line_below:
//      COP(reg)->jump.addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//      r = add_op(reg, OP_ATOMIC_END);
//fix_flaw_line_below:
//      if (r != 0) return r;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//      if (IS_NOT_NULL(Else)) {
         r = compile_tree(Else, reg, env);
       }
     }
    break;
  }

  return r;
}
"
5048,182784,,Remote,Not required,Partial,CVE-2019-13225,https://www.cvedetails.com/cve/CVE-2019-13225/,CWE-476,Low,,,,2019-07-10,5.0,"A NULL Pointer Dereference in match_at() in regexec.c in Oniguruma 6.9.2 allows attackers to potentially cause denial of service by providing a crafted regular expression. Oniguruma issues often affect Ruby, as well as common optional libraries for PHP and Rust.",2019-07-30,DoS ,2,https://github.com/kkos/oniguruma/commit/c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c,c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c,Fix CVE-2019-13225: problem in converting if-then-else pattern to bytecode.,1,src/regcomp.c,"{""sha"": ""ff3431f03645f540350a26f07c52d59141a6ba13"", ""filename"": ""src/regcomp.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 8, ""changes"": 25, ""blob_url"": ""https://github.com/kkos/oniguruma/blob/c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c/src/regcomp.c"", ""raw_url"": ""https://github.com/kkos/oniguruma/raw/c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c/src/regcomp.c"", ""contents_url"": ""https://api.github.com/repos/kkos/oniguruma/contents/src/regcomp.c?ref=c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c"", ""patch"": ""@@ -1307,8 +1307,9 @@ compile_length_bag_node(BagNode* node, regex_t* reg)\n         len += tlen;\n       }\n \n+      len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END;\n+\n       if (IS_NOT_NULL(Else)) {\n-        len += SIZE_OP_JUMP;\n         tlen = compile_length_tree(Else, reg);\n         if (tlen < 0) return tlen;\n         len += tlen;\n@@ -1455,7 +1456,7 @@ compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)\n \n   case BAG_IF_ELSE:\n     {\n-      int cond_len, then_len, jump_len;\n+      int cond_len, then_len, else_len, jump_len;\n       Node* cond = NODE_BAG_BODY(node);\n       Node* Then = node->te.Then;\n       Node* Else = node->te.Else;\n@@ -1472,8 +1473,7 @@ compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)\n       else\n         then_len = 0;\n \n-      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;\n-      if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;\n+      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP;\n \n       r = add_op(reg, OP_PUSH);\n       if (r != 0) return r;\n@@ -1490,11 +1490,20 @@ compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)\n       }\n \n       if (IS_NOT_NULL(Else)) {\n-        int else_len = compile_length_tree(Else, reg);\n-        r = add_op(reg, OP_JUMP);\n-        if (r != 0) return r;\n-        COP(reg)->jump.addr = else_len + SIZE_INC_OP;\n+        else_len = compile_length_tree(Else, reg);\n+        if (else_len < 0) return else_len;\n+      }\n+      else\n+        else_len = 0;\n \n+      r = add_op(reg, OP_JUMP);\n+      if (r != 0) return r;\n+      COP(reg)->jump.addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP;\n+\n+      r = add_op(reg, OP_ATOMIC_END);\n+      if (r != 0) return r;\n+\n+      if (IS_NOT_NULL(Else)) {\n         r = compile_tree(Else, reg, env);\n       }\n     }""}","compile_length_bag_node(BagNode* node, regex_t* reg)
{
  int len;
  int tlen;

  if (node->type == BAG_OPTION)
    return compile_length_option_node(node, reg);

  if (NODE_BAG_BODY(node)) {
    tlen = compile_length_tree(NODE_BAG_BODY(node), reg);
    if (tlen < 0) return tlen;
  }
  else
    tlen = 0;

  switch (node->type) {
  case BAG_MEMORY:
#ifdef USE_CALL

    if (node->m.regnum == 0 && NODE_IS_CALLED(node)) {
      len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;
      return len;
    }

    if (NODE_IS_CALLED(node)) {
      len = SIZE_OP_MEMORY_START_PUSH + tlen
        + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;
      if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))
        len += (NODE_IS_RECURSION(node)
                ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH);
      else
        len += (NODE_IS_RECURSION(node)
                ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END);
    }
    else if (NODE_IS_RECURSION(node)) {
      len = SIZE_OP_MEMORY_START_PUSH;
      len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)
                     ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC);
    }
    else
#endif
    {
      if (MEM_STATUS_AT0(reg->bt_mem_start, node->m.regnum))
        len = SIZE_OP_MEMORY_START_PUSH;
      else
        len = SIZE_OP_MEMORY_START;

      len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)
                     ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END);
    }
    break;

  case BAG_STOP_BACKTRACK:
    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {
      int v;
      QuantNode* qn;

      qn = QUANT_(NODE_BAG_BODY(node));
      tlen = compile_length_tree(NODE_QUANT_BODY(qn), reg);
      if (tlen < 0) return tlen;

      v = onig_positive_int_multiply(qn->lower, tlen);
      if (v < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;
      len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP;
    }
    else {
      len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END;
    }
    break;

  case BAG_IF_ELSE:
    {
      Node* cond = NODE_BAG_BODY(node);
      Node* Then = node->te.Then;
      Node* Else = node->te.Else;

      len = compile_length_tree(cond, reg);
      if (len < 0) return len;
      len += SIZE_OP_PUSH;
      len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END;

      if (IS_NOT_NULL(Then)) {
        tlen = compile_length_tree(Then, reg);
        if (tlen < 0) return tlen;
         len += tlen;
       }
 
      len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END;

       if (IS_NOT_NULL(Else)) {
         tlen = compile_length_tree(Else, reg);
         if (tlen < 0) return tlen;
         len += tlen;
      }
    }
    break;

  case BAG_OPTION:
    /* never come here, but set for escape warning */
    len = 0;
    break;
  }

  return len;
}
","compile_length_bag_node(BagNode* node, regex_t* reg)
{
  int len;
  int tlen;

  if (node->type == BAG_OPTION)
    return compile_length_option_node(node, reg);

  if (NODE_BAG_BODY(node)) {
    tlen = compile_length_tree(NODE_BAG_BODY(node), reg);
    if (tlen < 0) return tlen;
  }
  else
    tlen = 0;

  switch (node->type) {
  case BAG_MEMORY:
#ifdef USE_CALL

    if (node->m.regnum == 0 && NODE_IS_CALLED(node)) {
      len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;
      return len;
    }

    if (NODE_IS_CALLED(node)) {
      len = SIZE_OP_MEMORY_START_PUSH + tlen
        + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;
      if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))
        len += (NODE_IS_RECURSION(node)
                ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH);
      else
        len += (NODE_IS_RECURSION(node)
                ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END);
    }
    else if (NODE_IS_RECURSION(node)) {
      len = SIZE_OP_MEMORY_START_PUSH;
      len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)
                     ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC);
    }
    else
#endif
    {
      if (MEM_STATUS_AT0(reg->bt_mem_start, node->m.regnum))
        len = SIZE_OP_MEMORY_START_PUSH;
      else
        len = SIZE_OP_MEMORY_START;

      len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)
                     ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END);
    }
    break;

  case BAG_STOP_BACKTRACK:
    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {
      int v;
      QuantNode* qn;

      qn = QUANT_(NODE_BAG_BODY(node));
      tlen = compile_length_tree(NODE_QUANT_BODY(qn), reg);
      if (tlen < 0) return tlen;

      v = onig_positive_int_multiply(qn->lower, tlen);
      if (v < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;
      len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP;
    }
    else {
      len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END;
    }
    break;

  case BAG_IF_ELSE:
    {
      Node* cond = NODE_BAG_BODY(node);
      Node* Then = node->te.Then;
      Node* Else = node->te.Else;

      len = compile_length_tree(cond, reg);
      if (len < 0) return len;
      len += SIZE_OP_PUSH;
      len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END;

      if (IS_NOT_NULL(Then)) {
        tlen = compile_length_tree(Then, reg);
        if (tlen < 0) return tlen;
         len += tlen;
       }
 
       if (IS_NOT_NULL(Else)) {
        len += SIZE_OP_JUMP;
         tlen = compile_length_tree(Else, reg);
         if (tlen < 0) return tlen;
         len += tlen;
      }
    }
    break;

  case BAG_OPTION:
    /* never come here, but set for escape warning */
    len = 0;
    break;
  }

  return len;
}
",C,"      len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END;

","        len += SIZE_OP_JUMP;
",,"@@ -1307,8 +1307,9 @@ compile_length_bag_node(BagNode* node, regex_t* reg)
         len += tlen;
       }
 
+      len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END;
+
       if (IS_NOT_NULL(Else)) {
-        len += SIZE_OP_JUMP;
         tlen = compile_length_tree(Else, reg);
         if (tlen < 0) return tlen;
         len += tlen;
@@ -1455,7 +1456,7 @@ compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)
 
   case BAG_IF_ELSE:
     {
-      int cond_len, then_len, jump_len;
+      int cond_len, then_len, else_len, jump_len;
       Node* cond = NODE_BAG_BODY(node);
       Node* Then = node->te.Then;
       Node* Else = node->te.Else;
@@ -1472,8 +1473,7 @@ compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)
       else
         then_len = 0;
 
-      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;
-      if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;
+      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP;
 
       r = add_op(reg, OP_PUSH);
       if (r != 0) return r;
@@ -1490,11 +1490,20 @@ compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)
       }
 
       if (IS_NOT_NULL(Else)) {
-        int else_len = compile_length_tree(Else, reg);
-        r = add_op(reg, OP_JUMP);
-        if (r != 0) return r;
-        COP(reg)->jump.addr = else_len + SIZE_INC_OP;
+        else_len = compile_length_tree(Else, reg);
+        if (else_len < 0) return else_len;
+      }
+      else
+        else_len = 0;
 
+      r = add_op(reg, OP_JUMP);
+      if (r != 0) return r;
+      COP(reg)->jump.addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP;
+
+      r = add_op(reg, OP_ATOMIC_END);
+      if (r != 0) return r;
+
+      if (IS_NOT_NULL(Else)) {
         r = compile_tree(Else, reg, env);
       }
     }",oniguruma,c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c,4cf9f4795cb88ba639d6fd68890950ae737f89d7,1,"compile_length_bag_node(BagNode* node, regex_t* reg)
{
  int len;
  int tlen;

  if (node->type == BAG_OPTION)
    return compile_length_option_node(node, reg);

  if (NODE_BAG_BODY(node)) {
    tlen = compile_length_tree(NODE_BAG_BODY(node), reg);
    if (tlen < 0) return tlen;
  }
  else
    tlen = 0;

  switch (node->type) {
  case BAG_MEMORY:
#ifdef USE_CALL

    if (node->m.regnum == 0 && NODE_IS_CALLED(node)) {
      len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;
      return len;
    }

    if (NODE_IS_CALLED(node)) {
      len = SIZE_OP_MEMORY_START_PUSH + tlen
        + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;
      if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))
        len += (NODE_IS_RECURSION(node)
                ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH);
      else
        len += (NODE_IS_RECURSION(node)
                ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END);
    }
    else if (NODE_IS_RECURSION(node)) {
      len = SIZE_OP_MEMORY_START_PUSH;
      len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)
                     ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC);
    }
    else
#endif
    {
      if (MEM_STATUS_AT0(reg->bt_mem_start, node->m.regnum))
        len = SIZE_OP_MEMORY_START_PUSH;
      else
        len = SIZE_OP_MEMORY_START;

      len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)
                     ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END);
    }
    break;

  case BAG_STOP_BACKTRACK:
    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {
      int v;
      QuantNode* qn;

      qn = QUANT_(NODE_BAG_BODY(node));
      tlen = compile_length_tree(NODE_QUANT_BODY(qn), reg);
      if (tlen < 0) return tlen;

      v = onig_positive_int_multiply(qn->lower, tlen);
      if (v < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;
      len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP;
    }
    else {
      len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END;
    }
    break;

  case BAG_IF_ELSE:
    {
      Node* cond = NODE_BAG_BODY(node);
      Node* Then = node->te.Then;
      Node* Else = node->te.Else;

      len = compile_length_tree(cond, reg);
      if (len < 0) return len;
      len += SIZE_OP_PUSH;
      len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END;

      if (IS_NOT_NULL(Then)) {
        tlen = compile_length_tree(Then, reg);
        if (tlen < 0) return tlen;
         len += tlen;
       }
 
//fix_flaw_line_below:
//      len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END;
//fix_flaw_line_below:
//
       if (IS_NOT_NULL(Else)) {
//flaw_line_below:
        len += SIZE_OP_JUMP;
         tlen = compile_length_tree(Else, reg);
         if (tlen < 0) return tlen;
         len += tlen;
      }
    }
    break;

  case BAG_OPTION:
    /* never come here, but set for escape warning */
    len = 0;
    break;
  }

  return len;
}
"
5081,182817,,Remote,Not required,Partial,CVE-2019-12984,https://www.cvedetails.com/cve/CVE-2019-12984/,CWE-476,Medium,,,,2019-06-26,4.3,"A NULL pointer dereference vulnerability in the function nfc_genl_deactivate_target() in net/nfc/netlink.c in the Linux kernel before 5.1.13 can be triggered by a malicious user-mode program that omits certain NFC attributes, leading to denial of service.",2019-08-06,DoS ,2,https://github.com/torvalds/linux/commit/385097a3675749cbc9e97c085c0e5dfe4269ca51,385097a3675749cbc9e97c085c0e5dfe4269ca51,"nfc: Ensure presence of required attributes in the deactivate_target handler

Check that the NFC_ATTR_TARGET_INDEX attributes (in addition to
NFC_ATTR_DEVICE_INDEX) are provided by the netlink client prior to
accessing them. This prevents potential unhandled NULL pointer dereference
exceptions which can be triggered by malicious user-mode programs,
if they omit one or both of these attributes.

Signed-off-by: Young Xiao <92siuyang@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/nfc/netlink.c,"{""sha"": ""ea64c90b14e8c8c5385c8357b69efe1a1eac9d4c"", ""filename"": ""net/nfc/netlink.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/385097a3675749cbc9e97c085c0e5dfe4269ca51/net/nfc/netlink.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/385097a3675749cbc9e97c085c0e5dfe4269ca51/net/nfc/netlink.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/nfc/netlink.c?ref=385097a3675749cbc9e97c085c0e5dfe4269ca51"", ""patch"": ""@@ -911,7 +911,8 @@ static int nfc_genl_deactivate_target(struct sk_buff *skb,\n \tu32 device_idx, target_idx;\n \tint rc;\n \n-\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n+\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n+\t    !info->attrs[NFC_ATTR_TARGET_INDEX])\n \t\treturn -EINVAL;\n \n \tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);""}","static int nfc_genl_deactivate_target(struct sk_buff *skb,
				      struct genl_info *info)
{
	struct nfc_dev *dev;
 	u32 device_idx, target_idx;
 	int rc;
 
	if (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||
	    !info->attrs[NFC_ATTR_TARGET_INDEX])
 		return -EINVAL;
 
 	device_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);

	dev = nfc_get_device(device_idx);
	if (!dev)
		return -ENODEV;

	target_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);

	rc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);

	nfc_put_device(dev);
	return rc;
}
","static int nfc_genl_deactivate_target(struct sk_buff *skb,
				      struct genl_info *info)
{
	struct nfc_dev *dev;
 	u32 device_idx, target_idx;
 	int rc;
 
	if (!info->attrs[NFC_ATTR_DEVICE_INDEX])
 		return -EINVAL;
 
 	device_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);

	dev = nfc_get_device(device_idx);
	if (!dev)
		return -ENODEV;

	target_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);

	rc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);

	nfc_put_device(dev);
	return rc;
}
",C,"	if (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||
	    !info->attrs[NFC_ATTR_TARGET_INDEX])
","	if (!info->attrs[NFC_ATTR_DEVICE_INDEX])
",,"@@ -911,7 +911,8 @@ static int nfc_genl_deactivate_target(struct sk_buff *skb,
 	u32 device_idx, target_idx;
 	int rc;
 
-	if (!info->attrs[NFC_ATTR_DEVICE_INDEX])
+	if (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||
+	    !info->attrs[NFC_ATTR_TARGET_INDEX])
 		return -EINVAL;
 
 	device_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);",linux,385097a3675749cbc9e97c085c0e5dfe4269ca51,b8003cef2e639fbf462a05ff739aae524d72ca3c,1,"static int nfc_genl_deactivate_target(struct sk_buff *skb,
				      struct genl_info *info)
{
	struct nfc_dev *dev;
 	u32 device_idx, target_idx;
 	int rc;
 
//flaw_line_below:
	if (!info->attrs[NFC_ATTR_DEVICE_INDEX])
//fix_flaw_line_below:
//	if (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||
//fix_flaw_line_below:
//	    !info->attrs[NFC_ATTR_TARGET_INDEX])
 		return -EINVAL;
 
 	device_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);

	dev = nfc_get_device(device_idx);
	if (!dev)
		return -ENODEV;

	target_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);

	rc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);

	nfc_put_device(dev);
	return rc;
}
"
5089,182825,,Remote,Not required,Partial,CVE-2019-12818,https://www.cvedetails.com/cve/CVE-2019-12818/,CWE-476,Low,,,,2019-06-13,5.0,"An issue was discovered in the Linux kernel before 4.20.15. The nfc_llcp_build_tlv function in net/nfc/llcp_commands.c may return NULL. If the caller does not check for this, it will trigger a NULL pointer dereference. This will cause denial of service. This affects nfc_llcp_build_gb in net/nfc/llcp_core.c.",2019-06-18,DoS ,8,https://github.com/torvalds/linux/commit/58bdd544e2933a21a51eecf17c3f5f94038261b5,58bdd544e2933a21a51eecf17c3f5f94038261b5,"net: nfc: Fix NULL dereference on nfc_llcp_build_tlv fails

KASAN report this:

BUG: KASAN: null-ptr-deref in nfc_llcp_build_gb+0x37f/0x540 [nfc]
Read of size 3 at addr 0000000000000000 by task syz-executor.0/5401

CPU: 0 PID: 5401 Comm: syz-executor.0 Not tainted 5.0.0-rc7+ #45
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
Call Trace:
 __dump_stack lib/dump_stack.c:77 [inline]
 dump_stack+0xfa/0x1ce lib/dump_stack.c:113
 kasan_report+0x171/0x18d mm/kasan/report.c:321
 memcpy+0x1f/0x50 mm/kasan/common.c:130
 nfc_llcp_build_gb+0x37f/0x540 [nfc]
 nfc_llcp_register_device+0x6eb/0xb50 [nfc]
 nfc_register_device+0x50/0x1d0 [nfc]
 nfcsim_device_new+0x394/0x67d [nfcsim]
 ? 0xffffffffc1080000
 nfcsim_init+0x6b/0x1000 [nfcsim]
 do_one_initcall+0xfa/0x5ca init/main.c:887
 do_init_module+0x204/0x5f6 kernel/module.c:3460
 load_module+0x66b2/0x8570 kernel/module.c:3808
 __do_sys_finit_module+0x238/0x2a0 kernel/module.c:3902
 do_syscall_64+0x147/0x600 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x49/0xbe
RIP: 0033:0x462e99
Code: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007f9cb79dcc58 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
RAX: ffffffffffffffda RBX: 000000000073bf00 RCX: 0000000000462e99
RDX: 0000000000000000 RSI: 0000000020000280 RDI: 0000000000000003
RBP: 00007f9cb79dcc70 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 00007f9cb79dd6bc
R13: 00000000004bcefb R14: 00000000006f7030 R15: 0000000000000004

nfc_llcp_build_tlv will return NULL on fails, caller should check it,
otherwise will trigger a NULL dereference.

Reported-by: Hulk Robot <hulkci@huawei.com>
Fixes: eda21f16a5ed (""NFC: Set MIU and RW values from CONNECT and CC LLCP frames"")
Fixes: d646960f7986 (""NFC: Initial LLCP support"")
Signed-off-by: YueHaibing <yuehaibing@huawei.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/nfc/llcp_commands.c,"{""sha"": ""d1fc019e932e0c92caccab7d2ef3dc43e12880f0"", ""filename"": ""net/nfc/llcp_commands.c"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 0, ""changes"": 20, ""blob_url"": ""https://github.com/torvalds/linux/blob/58bdd544e2933a21a51eecf17c3f5f94038261b5/net/nfc/llcp_commands.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/58bdd544e2933a21a51eecf17c3f5f94038261b5/net/nfc/llcp_commands.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/nfc/llcp_commands.c?ref=58bdd544e2933a21a51eecf17c3f5f94038261b5"", ""patch"": ""@@ -419,6 +419,10 @@ int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)\n \t\t\t\t\t\t      sock->service_name,\n \t\t\t\t\t\t      sock->service_name_len,\n \t\t\t\t\t\t      &service_name_tlv_length);\n+\t\tif (!service_name_tlv) {\n+\t\t\terr = -ENOMEM;\n+\t\t\tgoto error_tlv;\n+\t\t}\n \t\tsize += service_name_tlv_length;\n \t}\n \n@@ -429,9 +433,17 @@ int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)\n \n \tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n \t\t\t\t      &miux_tlv_length);\n+\tif (!miux_tlv) {\n+\t\terr = -ENOMEM;\n+\t\tgoto error_tlv;\n+\t}\n \tsize += miux_tlv_length;\n \n \trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n+\tif (!rw_tlv) {\n+\t\terr = -ENOMEM;\n+\t\tgoto error_tlv;\n+\t}\n \tsize += rw_tlv_length;\n \n \tpr_debug(\""SKB size %d SN length %zu\\n\"", size, sock->service_name_len);\n@@ -484,9 +496,17 @@ int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)\n \n \tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n \t\t\t\t      &miux_tlv_length);\n+\tif (!miux_tlv) {\n+\t\terr = -ENOMEM;\n+\t\tgoto error_tlv;\n+\t}\n \tsize += miux_tlv_length;\n \n \trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n+\tif (!rw_tlv) {\n+\t\terr = -ENOMEM;\n+\t\tgoto error_tlv;\n+\t}\n \tsize += rw_tlv_length;\n \n \tskb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);""}<_**next**_>{""sha"": ""4fa015208aab1c5e59e291cb55dd8e296c02eeca"", ""filename"": ""net/nfc/llcp_core.c"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 4, ""changes"": 24, ""blob_url"": ""https://github.com/torvalds/linux/blob/58bdd544e2933a21a51eecf17c3f5f94038261b5/net/nfc/llcp_core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/58bdd544e2933a21a51eecf17c3f5f94038261b5/net/nfc/llcp_core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/nfc/llcp_core.c?ref=58bdd544e2933a21a51eecf17c3f5f94038261b5"", ""patch"": ""@@ -532,28 +532,44 @@ static u8 nfc_llcp_reserve_sdp_ssap(struct nfc_llcp_local *local)\n \n static int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n {\n-\tu8 *gb_cur, *version_tlv, version, version_length;\n-\tu8 *lto_tlv, lto_length;\n-\tu8 *wks_tlv, wks_length;\n-\tu8 *miux_tlv, miux_length;\n+\tu8 *gb_cur, version, version_length;\n+\tu8 lto_length, wks_length, miux_length;\n+\tu8 *version_tlv = NULL, *lto_tlv = NULL,\n+\t   *wks_tlv = NULL, *miux_tlv = NULL;\n \t__be16 wks = cpu_to_be16(local->local_wks);\n \tu8 gb_len = 0;\n \tint ret = 0;\n \n \tversion = LLCP_VERSION_11;\n \tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n \t\t\t\t\t 1, &version_length);\n+\tif (!version_tlv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n \tgb_len += version_length;\n \n \tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n+\tif (!lto_tlv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n \tgb_len += lto_length;\n \n \tpr_debug(\""Local wks 0x%lx\\n\"", local->local_wks);\n \twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n+\tif (!wks_tlv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n \tgb_len += wks_length;\n \n \tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n \t\t\t\t      &miux_length);\n+\tif (!miux_tlv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n \tgb_len += miux_length;\n \n \tgb_len += ARRAY_SIZE(llcp_magic);""}","int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)
{
	struct nfc_llcp_local *local;
	struct sk_buff *skb;
	u8 *miux_tlv = NULL, miux_tlv_length;
	u8 *rw_tlv = NULL, rw_tlv_length, rw;
	int err;
	u16 size = 0;
	__be16 miux;

	pr_debug(""Sending CC\n"");

	local = sock->local;
	if (local == NULL)
		return -ENODEV;

	/* If the socket parameters are not set, use the local ones */
	miux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?
		local->miux : sock->miux;
	rw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;
 
 	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,
 				      &miux_tlv_length);
	if (!miux_tlv) {
		err = -ENOMEM;
		goto error_tlv;
	}
 	size += miux_tlv_length;
 
 	rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);
	if (!rw_tlv) {
		err = -ENOMEM;
		goto error_tlv;
	}
 	size += rw_tlv_length;
 
 	skb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);
	if (skb == NULL) {
		err = -ENOMEM;
		goto error_tlv;
	}

	llcp_add_tlv(skb, miux_tlv, miux_tlv_length);
	llcp_add_tlv(skb, rw_tlv, rw_tlv_length);

	skb_queue_tail(&local->tx_queue, skb);

	err = 0;

error_tlv:
	if (err)
		pr_err(""error %d\n"", err);

	kfree(miux_tlv);
	kfree(rw_tlv);

	return err;
}
","int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)
{
	struct nfc_llcp_local *local;
	struct sk_buff *skb;
	u8 *miux_tlv = NULL, miux_tlv_length;
	u8 *rw_tlv = NULL, rw_tlv_length, rw;
	int err;
	u16 size = 0;
	__be16 miux;

	pr_debug(""Sending CC\n"");

	local = sock->local;
	if (local == NULL)
		return -ENODEV;

	/* If the socket parameters are not set, use the local ones */
	miux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?
		local->miux : sock->miux;
	rw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;
 
 	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,
 				      &miux_tlv_length);
 	size += miux_tlv_length;
 
 	rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);
 	size += rw_tlv_length;
 
 	skb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);
	if (skb == NULL) {
		err = -ENOMEM;
		goto error_tlv;
	}

	llcp_add_tlv(skb, miux_tlv, miux_tlv_length);
	llcp_add_tlv(skb, rw_tlv, rw_tlv_length);

	skb_queue_tail(&local->tx_queue, skb);

	err = 0;

error_tlv:
	if (err)
		pr_err(""error %d\n"", err);

	kfree(miux_tlv);
	kfree(rw_tlv);

	return err;
}
",C,"	if (!miux_tlv) {
		err = -ENOMEM;
		goto error_tlv;
	}
	if (!rw_tlv) {
		err = -ENOMEM;
		goto error_tlv;
	}
",,,"@@ -419,6 +419,10 @@ int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)
 						      sock->service_name,
 						      sock->service_name_len,
 						      &service_name_tlv_length);
+		if (!service_name_tlv) {
+			err = -ENOMEM;
+			goto error_tlv;
+		}
 		size += service_name_tlv_length;
 	}
 
@@ -429,9 +433,17 @@ int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)
 
 	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,
 				      &miux_tlv_length);
+	if (!miux_tlv) {
+		err = -ENOMEM;
+		goto error_tlv;
+	}
 	size += miux_tlv_length;
 
 	rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);
+	if (!rw_tlv) {
+		err = -ENOMEM;
+		goto error_tlv;
+	}
 	size += rw_tlv_length;
 
 	pr_debug(""SKB size %d SN length %zu\n"", size, sock->service_name_len);
@@ -484,9 +496,17 @@ int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)
 
 	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,
 				      &miux_tlv_length);
+	if (!miux_tlv) {
+		err = -ENOMEM;
+		goto error_tlv;
+	}
 	size += miux_tlv_length;
 
 	rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);
+	if (!rw_tlv) {
+		err = -ENOMEM;
+		goto error_tlv;
+	}
 	size += rw_tlv_length;
 
 	skb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);",linux,58bdd544e2933a21a51eecf17c3f5f94038261b5,232ba3a51cc224b339c7114888ed7f0d4d95695e,1,"int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)
{
	struct nfc_llcp_local *local;
	struct sk_buff *skb;
	u8 *miux_tlv = NULL, miux_tlv_length;
	u8 *rw_tlv = NULL, rw_tlv_length, rw;
	int err;
	u16 size = 0;
	__be16 miux;

	pr_debug(""Sending CC\n"");

	local = sock->local;
	if (local == NULL)
		return -ENODEV;

	/* If the socket parameters are not set, use the local ones */
	miux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?
		local->miux : sock->miux;
	rw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;
 
 	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,
 				      &miux_tlv_length);
//fix_flaw_line_below:
//	if (!miux_tlv) {
//fix_flaw_line_below:
//		err = -ENOMEM;
//fix_flaw_line_below:
//		goto error_tlv;
//fix_flaw_line_below:
//	}
 	size += miux_tlv_length;
 
 	rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);
//fix_flaw_line_below:
//	if (!rw_tlv) {
//fix_flaw_line_below:
//		err = -ENOMEM;
//fix_flaw_line_below:
//		goto error_tlv;
//fix_flaw_line_below:
//	}
 	size += rw_tlv_length;
 
 	skb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);
	if (skb == NULL) {
		err = -ENOMEM;
		goto error_tlv;
	}

	llcp_add_tlv(skb, miux_tlv, miux_tlv_length);
	llcp_add_tlv(skb, rw_tlv, rw_tlv_length);

	skb_queue_tail(&local->tx_queue, skb);

	err = 0;

error_tlv:
	if (err)
		pr_err(""error %d\n"", err);

	kfree(miux_tlv);
	kfree(rw_tlv);

	return err;
}
"
5090,182826,,Remote,Not required,Partial,CVE-2019-12818,https://www.cvedetails.com/cve/CVE-2019-12818/,CWE-476,Low,,,,2019-06-13,5.0,"An issue was discovered in the Linux kernel before 4.20.15. The nfc_llcp_build_tlv function in net/nfc/llcp_commands.c may return NULL. If the caller does not check for this, it will trigger a NULL pointer dereference. This will cause denial of service. This affects nfc_llcp_build_gb in net/nfc/llcp_core.c.",2019-06-18,DoS ,12,https://github.com/torvalds/linux/commit/58bdd544e2933a21a51eecf17c3f5f94038261b5,58bdd544e2933a21a51eecf17c3f5f94038261b5,"net: nfc: Fix NULL dereference on nfc_llcp_build_tlv fails

KASAN report this:

BUG: KASAN: null-ptr-deref in nfc_llcp_build_gb+0x37f/0x540 [nfc]
Read of size 3 at addr 0000000000000000 by task syz-executor.0/5401

CPU: 0 PID: 5401 Comm: syz-executor.0 Not tainted 5.0.0-rc7+ #45
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
Call Trace:
 __dump_stack lib/dump_stack.c:77 [inline]
 dump_stack+0xfa/0x1ce lib/dump_stack.c:113
 kasan_report+0x171/0x18d mm/kasan/report.c:321
 memcpy+0x1f/0x50 mm/kasan/common.c:130
 nfc_llcp_build_gb+0x37f/0x540 [nfc]
 nfc_llcp_register_device+0x6eb/0xb50 [nfc]
 nfc_register_device+0x50/0x1d0 [nfc]
 nfcsim_device_new+0x394/0x67d [nfcsim]
 ? 0xffffffffc1080000
 nfcsim_init+0x6b/0x1000 [nfcsim]
 do_one_initcall+0xfa/0x5ca init/main.c:887
 do_init_module+0x204/0x5f6 kernel/module.c:3460
 load_module+0x66b2/0x8570 kernel/module.c:3808
 __do_sys_finit_module+0x238/0x2a0 kernel/module.c:3902
 do_syscall_64+0x147/0x600 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x49/0xbe
RIP: 0033:0x462e99
Code: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007f9cb79dcc58 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
RAX: ffffffffffffffda RBX: 000000000073bf00 RCX: 0000000000462e99
RDX: 0000000000000000 RSI: 0000000020000280 RDI: 0000000000000003
RBP: 00007f9cb79dcc70 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 00007f9cb79dd6bc
R13: 00000000004bcefb R14: 00000000006f7030 R15: 0000000000000004

nfc_llcp_build_tlv will return NULL on fails, caller should check it,
otherwise will trigger a NULL dereference.

Reported-by: Hulk Robot <hulkci@huawei.com>
Fixes: eda21f16a5ed (""NFC: Set MIU and RW values from CONNECT and CC LLCP frames"")
Fixes: d646960f7986 (""NFC: Initial LLCP support"")
Signed-off-by: YueHaibing <yuehaibing@huawei.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/nfc/llcp_commands.c,"{""sha"": ""d1fc019e932e0c92caccab7d2ef3dc43e12880f0"", ""filename"": ""net/nfc/llcp_commands.c"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 0, ""changes"": 20, ""blob_url"": ""https://github.com/torvalds/linux/blob/58bdd544e2933a21a51eecf17c3f5f94038261b5/net/nfc/llcp_commands.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/58bdd544e2933a21a51eecf17c3f5f94038261b5/net/nfc/llcp_commands.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/nfc/llcp_commands.c?ref=58bdd544e2933a21a51eecf17c3f5f94038261b5"", ""patch"": ""@@ -419,6 +419,10 @@ int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)\n \t\t\t\t\t\t      sock->service_name,\n \t\t\t\t\t\t      sock->service_name_len,\n \t\t\t\t\t\t      &service_name_tlv_length);\n+\t\tif (!service_name_tlv) {\n+\t\t\terr = -ENOMEM;\n+\t\t\tgoto error_tlv;\n+\t\t}\n \t\tsize += service_name_tlv_length;\n \t}\n \n@@ -429,9 +433,17 @@ int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)\n \n \tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n \t\t\t\t      &miux_tlv_length);\n+\tif (!miux_tlv) {\n+\t\terr = -ENOMEM;\n+\t\tgoto error_tlv;\n+\t}\n \tsize += miux_tlv_length;\n \n \trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n+\tif (!rw_tlv) {\n+\t\terr = -ENOMEM;\n+\t\tgoto error_tlv;\n+\t}\n \tsize += rw_tlv_length;\n \n \tpr_debug(\""SKB size %d SN length %zu\\n\"", size, sock->service_name_len);\n@@ -484,9 +496,17 @@ int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)\n \n \tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n \t\t\t\t      &miux_tlv_length);\n+\tif (!miux_tlv) {\n+\t\terr = -ENOMEM;\n+\t\tgoto error_tlv;\n+\t}\n \tsize += miux_tlv_length;\n \n \trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n+\tif (!rw_tlv) {\n+\t\terr = -ENOMEM;\n+\t\tgoto error_tlv;\n+\t}\n \tsize += rw_tlv_length;\n \n \tskb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);""}<_**next**_>{""sha"": ""4fa015208aab1c5e59e291cb55dd8e296c02eeca"", ""filename"": ""net/nfc/llcp_core.c"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 4, ""changes"": 24, ""blob_url"": ""https://github.com/torvalds/linux/blob/58bdd544e2933a21a51eecf17c3f5f94038261b5/net/nfc/llcp_core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/58bdd544e2933a21a51eecf17c3f5f94038261b5/net/nfc/llcp_core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/nfc/llcp_core.c?ref=58bdd544e2933a21a51eecf17c3f5f94038261b5"", ""patch"": ""@@ -532,28 +532,44 @@ static u8 nfc_llcp_reserve_sdp_ssap(struct nfc_llcp_local *local)\n \n static int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n {\n-\tu8 *gb_cur, *version_tlv, version, version_length;\n-\tu8 *lto_tlv, lto_length;\n-\tu8 *wks_tlv, wks_length;\n-\tu8 *miux_tlv, miux_length;\n+\tu8 *gb_cur, version, version_length;\n+\tu8 lto_length, wks_length, miux_length;\n+\tu8 *version_tlv = NULL, *lto_tlv = NULL,\n+\t   *wks_tlv = NULL, *miux_tlv = NULL;\n \t__be16 wks = cpu_to_be16(local->local_wks);\n \tu8 gb_len = 0;\n \tint ret = 0;\n \n \tversion = LLCP_VERSION_11;\n \tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n \t\t\t\t\t 1, &version_length);\n+\tif (!version_tlv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n \tgb_len += version_length;\n \n \tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n+\tif (!lto_tlv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n \tgb_len += lto_length;\n \n \tpr_debug(\""Local wks 0x%lx\\n\"", local->local_wks);\n \twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n+\tif (!wks_tlv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n \tgb_len += wks_length;\n \n \tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n \t\t\t\t      &miux_length);\n+\tif (!miux_tlv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n \tgb_len += miux_length;\n \n \tgb_len += ARRAY_SIZE(llcp_magic);""}","int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)
{
	struct nfc_llcp_local *local;
	struct sk_buff *skb;
	u8 *service_name_tlv = NULL, service_name_tlv_length;
	u8 *miux_tlv = NULL, miux_tlv_length;
	u8 *rw_tlv = NULL, rw_tlv_length, rw;
	int err;
	u16 size = 0;
	__be16 miux;

	pr_debug(""Sending CONNECT\n"");

	local = sock->local;
	if (local == NULL)
		return -ENODEV;

	if (sock->service_name != NULL) {
		service_name_tlv = nfc_llcp_build_tlv(LLCP_TLV_SN,
 						      sock->service_name,
 						      sock->service_name_len,
 						      &service_name_tlv_length);
		if (!service_name_tlv) {
			err = -ENOMEM;
			goto error_tlv;
		}
 		size += service_name_tlv_length;
 	}
 
	/* If the socket parameters are not set, use the local ones */
	miux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?
		local->miux : sock->miux;
	rw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;
 
 	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,
 				      &miux_tlv_length);
	if (!miux_tlv) {
		err = -ENOMEM;
		goto error_tlv;
	}
 	size += miux_tlv_length;
 
 	rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);
	if (!rw_tlv) {
		err = -ENOMEM;
		goto error_tlv;
	}
 	size += rw_tlv_length;
 
 	pr_debug(""SKB size %d SN length %zu\n"", size, sock->service_name_len);

	skb = llcp_allocate_pdu(sock, LLCP_PDU_CONNECT, size);
	if (skb == NULL) {
		err = -ENOMEM;
		goto error_tlv;
	}

	llcp_add_tlv(skb, service_name_tlv, service_name_tlv_length);
	llcp_add_tlv(skb, miux_tlv, miux_tlv_length);
	llcp_add_tlv(skb, rw_tlv, rw_tlv_length);

	skb_queue_tail(&local->tx_queue, skb);

	err = 0;

error_tlv:
	if (err)
		pr_err(""error %d\n"", err);

	kfree(service_name_tlv);
	kfree(miux_tlv);
	kfree(rw_tlv);

	return err;
}
","int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)
{
	struct nfc_llcp_local *local;
	struct sk_buff *skb;
	u8 *service_name_tlv = NULL, service_name_tlv_length;
	u8 *miux_tlv = NULL, miux_tlv_length;
	u8 *rw_tlv = NULL, rw_tlv_length, rw;
	int err;
	u16 size = 0;
	__be16 miux;

	pr_debug(""Sending CONNECT\n"");

	local = sock->local;
	if (local == NULL)
		return -ENODEV;

	if (sock->service_name != NULL) {
		service_name_tlv = nfc_llcp_build_tlv(LLCP_TLV_SN,
 						      sock->service_name,
 						      sock->service_name_len,
 						      &service_name_tlv_length);
 		size += service_name_tlv_length;
 	}
 
	/* If the socket parameters are not set, use the local ones */
	miux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?
		local->miux : sock->miux;
	rw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;
 
 	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,
 				      &miux_tlv_length);
 	size += miux_tlv_length;
 
 	rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);
 	size += rw_tlv_length;
 
 	pr_debug(""SKB size %d SN length %zu\n"", size, sock->service_name_len);

	skb = llcp_allocate_pdu(sock, LLCP_PDU_CONNECT, size);
	if (skb == NULL) {
		err = -ENOMEM;
		goto error_tlv;
	}

	llcp_add_tlv(skb, service_name_tlv, service_name_tlv_length);
	llcp_add_tlv(skb, miux_tlv, miux_tlv_length);
	llcp_add_tlv(skb, rw_tlv, rw_tlv_length);

	skb_queue_tail(&local->tx_queue, skb);

	err = 0;

error_tlv:
	if (err)
		pr_err(""error %d\n"", err);

	kfree(service_name_tlv);
	kfree(miux_tlv);
	kfree(rw_tlv);

	return err;
}
",C,"		if (!service_name_tlv) {
			err = -ENOMEM;
			goto error_tlv;
		}
	if (!miux_tlv) {
		err = -ENOMEM;
		goto error_tlv;
	}
	if (!rw_tlv) {
		err = -ENOMEM;
		goto error_tlv;
	}
",,,"@@ -419,6 +419,10 @@ int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)
 						      sock->service_name,
 						      sock->service_name_len,
 						      &service_name_tlv_length);
+		if (!service_name_tlv) {
+			err = -ENOMEM;
+			goto error_tlv;
+		}
 		size += service_name_tlv_length;
 	}
 
@@ -429,9 +433,17 @@ int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)
 
 	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,
 				      &miux_tlv_length);
+	if (!miux_tlv) {
+		err = -ENOMEM;
+		goto error_tlv;
+	}
 	size += miux_tlv_length;
 
 	rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);
+	if (!rw_tlv) {
+		err = -ENOMEM;
+		goto error_tlv;
+	}
 	size += rw_tlv_length;
 
 	pr_debug(""SKB size %d SN length %zu\n"", size, sock->service_name_len);
@@ -484,9 +496,17 @@ int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)
 
 	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,
 				      &miux_tlv_length);
+	if (!miux_tlv) {
+		err = -ENOMEM;
+		goto error_tlv;
+	}
 	size += miux_tlv_length;
 
 	rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);
+	if (!rw_tlv) {
+		err = -ENOMEM;
+		goto error_tlv;
+	}
 	size += rw_tlv_length;
 
 	skb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);",linux,58bdd544e2933a21a51eecf17c3f5f94038261b5,232ba3a51cc224b339c7114888ed7f0d4d95695e,1,"int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)
{
	struct nfc_llcp_local *local;
	struct sk_buff *skb;
	u8 *service_name_tlv = NULL, service_name_tlv_length;
	u8 *miux_tlv = NULL, miux_tlv_length;
	u8 *rw_tlv = NULL, rw_tlv_length, rw;
	int err;
	u16 size = 0;
	__be16 miux;

	pr_debug(""Sending CONNECT\n"");

	local = sock->local;
	if (local == NULL)
		return -ENODEV;

	if (sock->service_name != NULL) {
		service_name_tlv = nfc_llcp_build_tlv(LLCP_TLV_SN,
 						      sock->service_name,
 						      sock->service_name_len,
 						      &service_name_tlv_length);
//fix_flaw_line_below:
//		if (!service_name_tlv) {
//fix_flaw_line_below:
//			err = -ENOMEM;
//fix_flaw_line_below:
//			goto error_tlv;
//fix_flaw_line_below:
//		}
 		size += service_name_tlv_length;
 	}
 
	/* If the socket parameters are not set, use the local ones */
	miux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?
		local->miux : sock->miux;
	rw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;
 
 	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,
 				      &miux_tlv_length);
//fix_flaw_line_below:
//	if (!miux_tlv) {
//fix_flaw_line_below:
//		err = -ENOMEM;
//fix_flaw_line_below:
//		goto error_tlv;
//fix_flaw_line_below:
//	}
 	size += miux_tlv_length;
 
 	rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);
//fix_flaw_line_below:
//	if (!rw_tlv) {
//fix_flaw_line_below:
//		err = -ENOMEM;
//fix_flaw_line_below:
//		goto error_tlv;
//fix_flaw_line_below:
//	}
 	size += rw_tlv_length;
 
 	pr_debug(""SKB size %d SN length %zu\n"", size, sock->service_name_len);

	skb = llcp_allocate_pdu(sock, LLCP_PDU_CONNECT, size);
	if (skb == NULL) {
		err = -ENOMEM;
		goto error_tlv;
	}

	llcp_add_tlv(skb, service_name_tlv, service_name_tlv_length);
	llcp_add_tlv(skb, miux_tlv, miux_tlv_length);
	llcp_add_tlv(skb, rw_tlv, rw_tlv_length);

	skb_queue_tail(&local->tx_queue, skb);

	err = 0;

error_tlv:
	if (err)
		pr_err(""error %d\n"", err);

	kfree(service_name_tlv);
	kfree(miux_tlv);
	kfree(rw_tlv);

	return err;
}
"
5091,182827,,Remote,Not required,Partial,CVE-2019-12818,https://www.cvedetails.com/cve/CVE-2019-12818/,CWE-476,Low,,,,2019-06-13,5.0,"An issue was discovered in the Linux kernel before 4.20.15. The nfc_llcp_build_tlv function in net/nfc/llcp_commands.c may return NULL. If the caller does not check for this, it will trigger a NULL pointer dereference. This will cause denial of service. This affects nfc_llcp_build_gb in net/nfc/llcp_core.c.",2019-06-18,DoS ,20,https://github.com/torvalds/linux/commit/58bdd544e2933a21a51eecf17c3f5f94038261b5,58bdd544e2933a21a51eecf17c3f5f94038261b5,"net: nfc: Fix NULL dereference on nfc_llcp_build_tlv fails

KASAN report this:

BUG: KASAN: null-ptr-deref in nfc_llcp_build_gb+0x37f/0x540 [nfc]
Read of size 3 at addr 0000000000000000 by task syz-executor.0/5401

CPU: 0 PID: 5401 Comm: syz-executor.0 Not tainted 5.0.0-rc7+ #45
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
Call Trace:
 __dump_stack lib/dump_stack.c:77 [inline]
 dump_stack+0xfa/0x1ce lib/dump_stack.c:113
 kasan_report+0x171/0x18d mm/kasan/report.c:321
 memcpy+0x1f/0x50 mm/kasan/common.c:130
 nfc_llcp_build_gb+0x37f/0x540 [nfc]
 nfc_llcp_register_device+0x6eb/0xb50 [nfc]
 nfc_register_device+0x50/0x1d0 [nfc]
 nfcsim_device_new+0x394/0x67d [nfcsim]
 ? 0xffffffffc1080000
 nfcsim_init+0x6b/0x1000 [nfcsim]
 do_one_initcall+0xfa/0x5ca init/main.c:887
 do_init_module+0x204/0x5f6 kernel/module.c:3460
 load_module+0x66b2/0x8570 kernel/module.c:3808
 __do_sys_finit_module+0x238/0x2a0 kernel/module.c:3902
 do_syscall_64+0x147/0x600 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x49/0xbe
RIP: 0033:0x462e99
Code: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007f9cb79dcc58 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
RAX: ffffffffffffffda RBX: 000000000073bf00 RCX: 0000000000462e99
RDX: 0000000000000000 RSI: 0000000020000280 RDI: 0000000000000003
RBP: 00007f9cb79dcc70 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 00007f9cb79dd6bc
R13: 00000000004bcefb R14: 00000000006f7030 R15: 0000000000000004

nfc_llcp_build_tlv will return NULL on fails, caller should check it,
otherwise will trigger a NULL dereference.

Reported-by: Hulk Robot <hulkci@huawei.com>
Fixes: eda21f16a5ed (""NFC: Set MIU and RW values from CONNECT and CC LLCP frames"")
Fixes: d646960f7986 (""NFC: Initial LLCP support"")
Signed-off-by: YueHaibing <yuehaibing@huawei.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",4,net/nfc/llcp_core.c,"{""sha"": ""d1fc019e932e0c92caccab7d2ef3dc43e12880f0"", ""filename"": ""net/nfc/llcp_commands.c"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 0, ""changes"": 20, ""blob_url"": ""https://github.com/torvalds/linux/blob/58bdd544e2933a21a51eecf17c3f5f94038261b5/net/nfc/llcp_commands.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/58bdd544e2933a21a51eecf17c3f5f94038261b5/net/nfc/llcp_commands.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/nfc/llcp_commands.c?ref=58bdd544e2933a21a51eecf17c3f5f94038261b5"", ""patch"": ""@@ -419,6 +419,10 @@ int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)\n \t\t\t\t\t\t      sock->service_name,\n \t\t\t\t\t\t      sock->service_name_len,\n \t\t\t\t\t\t      &service_name_tlv_length);\n+\t\tif (!service_name_tlv) {\n+\t\t\terr = -ENOMEM;\n+\t\t\tgoto error_tlv;\n+\t\t}\n \t\tsize += service_name_tlv_length;\n \t}\n \n@@ -429,9 +433,17 @@ int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)\n \n \tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n \t\t\t\t      &miux_tlv_length);\n+\tif (!miux_tlv) {\n+\t\terr = -ENOMEM;\n+\t\tgoto error_tlv;\n+\t}\n \tsize += miux_tlv_length;\n \n \trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n+\tif (!rw_tlv) {\n+\t\terr = -ENOMEM;\n+\t\tgoto error_tlv;\n+\t}\n \tsize += rw_tlv_length;\n \n \tpr_debug(\""SKB size %d SN length %zu\\n\"", size, sock->service_name_len);\n@@ -484,9 +496,17 @@ int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)\n \n \tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n \t\t\t\t      &miux_tlv_length);\n+\tif (!miux_tlv) {\n+\t\terr = -ENOMEM;\n+\t\tgoto error_tlv;\n+\t}\n \tsize += miux_tlv_length;\n \n \trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n+\tif (!rw_tlv) {\n+\t\terr = -ENOMEM;\n+\t\tgoto error_tlv;\n+\t}\n \tsize += rw_tlv_length;\n \n \tskb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);""}<_**next**_>{""sha"": ""4fa015208aab1c5e59e291cb55dd8e296c02eeca"", ""filename"": ""net/nfc/llcp_core.c"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 4, ""changes"": 24, ""blob_url"": ""https://github.com/torvalds/linux/blob/58bdd544e2933a21a51eecf17c3f5f94038261b5/net/nfc/llcp_core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/58bdd544e2933a21a51eecf17c3f5f94038261b5/net/nfc/llcp_core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/nfc/llcp_core.c?ref=58bdd544e2933a21a51eecf17c3f5f94038261b5"", ""patch"": ""@@ -532,28 +532,44 @@ static u8 nfc_llcp_reserve_sdp_ssap(struct nfc_llcp_local *local)\n \n static int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n {\n-\tu8 *gb_cur, *version_tlv, version, version_length;\n-\tu8 *lto_tlv, lto_length;\n-\tu8 *wks_tlv, wks_length;\n-\tu8 *miux_tlv, miux_length;\n+\tu8 *gb_cur, version, version_length;\n+\tu8 lto_length, wks_length, miux_length;\n+\tu8 *version_tlv = NULL, *lto_tlv = NULL,\n+\t   *wks_tlv = NULL, *miux_tlv = NULL;\n \t__be16 wks = cpu_to_be16(local->local_wks);\n \tu8 gb_len = 0;\n \tint ret = 0;\n \n \tversion = LLCP_VERSION_11;\n \tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n \t\t\t\t\t 1, &version_length);\n+\tif (!version_tlv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n \tgb_len += version_length;\n \n \tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n+\tif (!lto_tlv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n \tgb_len += lto_length;\n \n \tpr_debug(\""Local wks 0x%lx\\n\"", local->local_wks);\n \twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n+\tif (!wks_tlv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n \tgb_len += wks_length;\n \n \tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n \t\t\t\t      &miux_length);\n+\tif (!miux_tlv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n \tgb_len += miux_length;\n \n \tgb_len += ARRAY_SIZE(llcp_magic);""}"," static int nfc_llcp_build_gb(struct nfc_llcp_local *local)
 {
	u8 *gb_cur, version, version_length;
	u8 lto_length, wks_length, miux_length;
	u8 *version_tlv = NULL, *lto_tlv = NULL,
	   *wks_tlv = NULL, *miux_tlv = NULL;
 	__be16 wks = cpu_to_be16(local->local_wks);
 	u8 gb_len = 0;
 	int ret = 0;
 
 	version = LLCP_VERSION_11;
 	version_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,
 					 1, &version_length);
	if (!version_tlv) {
		ret = -ENOMEM;
		goto out;
	}
 	gb_len += version_length;
 
 	lto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);
	if (!lto_tlv) {
		ret = -ENOMEM;
		goto out;
	}
 	gb_len += lto_length;
 
 	pr_debug(""Local wks 0x%lx\n"", local->local_wks);
 	wks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);
	if (!wks_tlv) {
		ret = -ENOMEM;
		goto out;
	}
 	gb_len += wks_length;
 
 	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,
 				      &miux_length);
	if (!miux_tlv) {
		ret = -ENOMEM;
		goto out;
	}
 	gb_len += miux_length;
 
 	gb_len += ARRAY_SIZE(llcp_magic);

	if (gb_len > NFC_MAX_GT_LEN) {
		ret = -EINVAL;
		goto out;
	}

	gb_cur = local->gb;

	memcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic));
	gb_cur += ARRAY_SIZE(llcp_magic);

	memcpy(gb_cur, version_tlv, version_length);
	gb_cur += version_length;

	memcpy(gb_cur, lto_tlv, lto_length);
	gb_cur += lto_length;

	memcpy(gb_cur, wks_tlv, wks_length);
	gb_cur += wks_length;

	memcpy(gb_cur, miux_tlv, miux_length);
	gb_cur += miux_length;

	local->gb_len = gb_len;

out:
	kfree(version_tlv);
	kfree(lto_tlv);
	kfree(wks_tlv);
	kfree(miux_tlv);

	return ret;
}
"," static int nfc_llcp_build_gb(struct nfc_llcp_local *local)
 {
	u8 *gb_cur, *version_tlv, version, version_length;
	u8 *lto_tlv, lto_length;
	u8 *wks_tlv, wks_length;
	u8 *miux_tlv, miux_length;
 	__be16 wks = cpu_to_be16(local->local_wks);
 	u8 gb_len = 0;
 	int ret = 0;
 
 	version = LLCP_VERSION_11;
 	version_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,
 					 1, &version_length);
 	gb_len += version_length;
 
 	lto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);
 	gb_len += lto_length;
 
 	pr_debug(""Local wks 0x%lx\n"", local->local_wks);
 	wks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);
 	gb_len += wks_length;
 
 	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,
 				      &miux_length);
 	gb_len += miux_length;
 
 	gb_len += ARRAY_SIZE(llcp_magic);

	if (gb_len > NFC_MAX_GT_LEN) {
		ret = -EINVAL;
		goto out;
	}

	gb_cur = local->gb;

	memcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic));
	gb_cur += ARRAY_SIZE(llcp_magic);

	memcpy(gb_cur, version_tlv, version_length);
	gb_cur += version_length;

	memcpy(gb_cur, lto_tlv, lto_length);
	gb_cur += lto_length;

	memcpy(gb_cur, wks_tlv, wks_length);
	gb_cur += wks_length;

	memcpy(gb_cur, miux_tlv, miux_length);
	gb_cur += miux_length;

	local->gb_len = gb_len;

out:
	kfree(version_tlv);
	kfree(lto_tlv);
	kfree(wks_tlv);
	kfree(miux_tlv);

	return ret;
}
",C,"	u8 *gb_cur, version, version_length;
	u8 lto_length, wks_length, miux_length;
	u8 *version_tlv = NULL, *lto_tlv = NULL,
	   *wks_tlv = NULL, *miux_tlv = NULL;
	if (!version_tlv) {
		ret = -ENOMEM;
		goto out;
	}
	if (!lto_tlv) {
		ret = -ENOMEM;
		goto out;
	}
	if (!wks_tlv) {
		ret = -ENOMEM;
		goto out;
	}
	if (!miux_tlv) {
		ret = -ENOMEM;
		goto out;
	}
","	u8 *gb_cur, *version_tlv, version, version_length;
	u8 *lto_tlv, lto_length;
	u8 *wks_tlv, wks_length;
	u8 *miux_tlv, miux_length;
",,"@@ -532,28 +532,44 @@ static u8 nfc_llcp_reserve_sdp_ssap(struct nfc_llcp_local *local)
 
 static int nfc_llcp_build_gb(struct nfc_llcp_local *local)
 {
-	u8 *gb_cur, *version_tlv, version, version_length;
-	u8 *lto_tlv, lto_length;
-	u8 *wks_tlv, wks_length;
-	u8 *miux_tlv, miux_length;
+	u8 *gb_cur, version, version_length;
+	u8 lto_length, wks_length, miux_length;
+	u8 *version_tlv = NULL, *lto_tlv = NULL,
+	   *wks_tlv = NULL, *miux_tlv = NULL;
 	__be16 wks = cpu_to_be16(local->local_wks);
 	u8 gb_len = 0;
 	int ret = 0;
 
 	version = LLCP_VERSION_11;
 	version_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,
 					 1, &version_length);
+	if (!version_tlv) {
+		ret = -ENOMEM;
+		goto out;
+	}
 	gb_len += version_length;
 
 	lto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);
+	if (!lto_tlv) {
+		ret = -ENOMEM;
+		goto out;
+	}
 	gb_len += lto_length;
 
 	pr_debug(""Local wks 0x%lx\n"", local->local_wks);
 	wks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);
+	if (!wks_tlv) {
+		ret = -ENOMEM;
+		goto out;
+	}
 	gb_len += wks_length;
 
 	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,
 				      &miux_length);
+	if (!miux_tlv) {
+		ret = -ENOMEM;
+		goto out;
+	}
 	gb_len += miux_length;
 
 	gb_len += ARRAY_SIZE(llcp_magic);",linux,58bdd544e2933a21a51eecf17c3f5f94038261b5,232ba3a51cc224b339c7114888ed7f0d4d95695e,1," static int nfc_llcp_build_gb(struct nfc_llcp_local *local)
 {
//flaw_line_below:
	u8 *gb_cur, *version_tlv, version, version_length;
//flaw_line_below:
	u8 *lto_tlv, lto_length;
//flaw_line_below:
	u8 *wks_tlv, wks_length;
//flaw_line_below:
	u8 *miux_tlv, miux_length;
//fix_flaw_line_below:
//	u8 *gb_cur, version, version_length;
//fix_flaw_line_below:
//	u8 lto_length, wks_length, miux_length;
//fix_flaw_line_below:
//	u8 *version_tlv = NULL, *lto_tlv = NULL,
//fix_flaw_line_below:
//	   *wks_tlv = NULL, *miux_tlv = NULL;
 	__be16 wks = cpu_to_be16(local->local_wks);
 	u8 gb_len = 0;
 	int ret = 0;
 
 	version = LLCP_VERSION_11;
 	version_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,
 					 1, &version_length);
//fix_flaw_line_below:
//	if (!version_tlv) {
//fix_flaw_line_below:
//		ret = -ENOMEM;
//fix_flaw_line_below:
//		goto out;
//fix_flaw_line_below:
//	}
 	gb_len += version_length;
 
 	lto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);
//fix_flaw_line_below:
//	if (!lto_tlv) {
//fix_flaw_line_below:
//		ret = -ENOMEM;
//fix_flaw_line_below:
//		goto out;
//fix_flaw_line_below:
//	}
 	gb_len += lto_length;
 
 	pr_debug(""Local wks 0x%lx\n"", local->local_wks);
 	wks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);
//fix_flaw_line_below:
//	if (!wks_tlv) {
//fix_flaw_line_below:
//		ret = -ENOMEM;
//fix_flaw_line_below:
//		goto out;
//fix_flaw_line_below:
//	}
 	gb_len += wks_length;
 
 	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,
 				      &miux_length);
//fix_flaw_line_below:
//	if (!miux_tlv) {
//fix_flaw_line_below:
//		ret = -ENOMEM;
//fix_flaw_line_below:
//		goto out;
//fix_flaw_line_below:
//	}
 	gb_len += miux_length;
 
 	gb_len += ARRAY_SIZE(llcp_magic);

	if (gb_len > NFC_MAX_GT_LEN) {
		ret = -EINVAL;
		goto out;
	}

	gb_cur = local->gb;

	memcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic));
	gb_cur += ARRAY_SIZE(llcp_magic);

	memcpy(gb_cur, version_tlv, version_length);
	gb_cur += version_length;

	memcpy(gb_cur, lto_tlv, lto_length);
	gb_cur += lto_length;

	memcpy(gb_cur, wks_tlv, wks_length);
	gb_cur += wks_length;

	memcpy(gb_cur, miux_tlv, miux_length);
	gb_cur += miux_length;

	local->gb_len = gb_len;

out:
	kfree(version_tlv);
	kfree(lto_tlv);
	kfree(wks_tlv);
	kfree(miux_tlv);

	return ret;
}
"
5101,182837,,Remote,Not required,Partial,CVE-2019-12111,https://www.cvedetails.com/cve/CVE-2019-12111/,CWE-476,Low,,,,2019-05-15,5.0,A Denial Of Service vulnerability in MiniUPnP MiniUPnPd through 2.1 exists due to a NULL pointer dereference in copyIPv6IfDifferent in pcpserver.c.,2019-05-30,DoS ,1,https://github.com/miniupnp/miniupnp/commit/cb8a02af7a5677cf608e86d57ab04241cf34e24f,cb8a02af7a5677cf608e86d57ab04241cf34e24f,pcpserver.c: copyIPv6IfDifferent() check for NULL src argument,1,miniupnpd/pcpserver.c,"{""sha"": ""a964aa9fde3ba4dfd14c65cbf0e8c05705788bb0"", ""filename"": ""miniupnpd/pcpserver.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/miniupnp/miniupnp/blob/cb8a02af7a5677cf608e86d57ab04241cf34e24f/miniupnpd/pcpserver.c"", ""raw_url"": ""https://github.com/miniupnp/miniupnp/raw/cb8a02af7a5677cf608e86d57ab04241cf34e24f/miniupnpd/pcpserver.c"", ""contents_url"": ""https://api.github.com/repos/miniupnp/miniupnp/contents/miniupnpd/pcpserver.c?ref=cb8a02af7a5677cf608e86d57ab04241cf34e24f"", ""patch"": ""@@ -177,7 +177,7 @@ static const char * getPCPOpCodeStr(uint8_t opcode)\n  * buffers are same */\n static void copyIPv6IfDifferent(void * dest, const void * src)\n {\n-\tif(dest != src) {\n+\tif(dest != src && src != NULL) {\n \t\tmemcpy(dest, src, sizeof(struct in6_addr));\n \t}\n }""}"," static void copyIPv6IfDifferent(void * dest, const void * src)
 {
	if(dest != src && src != NULL) {
 		memcpy(dest, src, sizeof(struct in6_addr));
 	}
 }
"," static void copyIPv6IfDifferent(void * dest, const void * src)
 {
	if(dest != src) {
 		memcpy(dest, src, sizeof(struct in6_addr));
 	}
 }
",C,"	if(dest != src && src != NULL) {
","	if(dest != src) {
",,"@@ -177,7 +177,7 @@ static const char * getPCPOpCodeStr(uint8_t opcode)
  * buffers are same */
 static void copyIPv6IfDifferent(void * dest, const void * src)
 {
-	if(dest != src) {
+	if(dest != src && src != NULL) {
 		memcpy(dest, src, sizeof(struct in6_addr));
 	}
 }",miniupnp,cb8a02af7a5677cf608e86d57ab04241cf34e24f,f321c2066b96d18afa5158dfa2d2873a2957ef38,1," static void copyIPv6IfDifferent(void * dest, const void * src)
 {
//flaw_line_below:
	if(dest != src) {
//fix_flaw_line_below:
//	if(dest != src && src != NULL) {
 		memcpy(dest, src, sizeof(struct in6_addr));
 	}
 }
"
5102,182838,,Remote,Not required,Partial,CVE-2019-12110,https://www.cvedetails.com/cve/CVE-2019-12110/,CWE-476,Low,,,,2019-05-15,5.0,An AddPortMapping Denial Of Service vulnerability in MiniUPnP MiniUPnPd through 2.1 exists due to a NULL pointer dereference in upnpredirect.c.,2019-05-30,DoS ,4,https://github.com/miniupnp/miniupnp/commit/f321c2066b96d18afa5158dfa2d2873a2957ef38,f321c2066b96d18afa5158dfa2d2873a2957ef38,upnp_redirect(): accept NULL desc argument,0,miniupnpd/upnpredirect.c,"{""sha"": ""74926f08325cd105552b466069572039b89bca27"", ""filename"": ""miniupnpd/upnpredirect.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/miniupnp/miniupnp/blob/f321c2066b96d18afa5158dfa2d2873a2957ef38/miniupnpd/upnpredirect.c"", ""raw_url"": ""https://github.com/miniupnp/miniupnp/raw/f321c2066b96d18afa5158dfa2d2873a2957ef38/miniupnpd/upnpredirect.c"", ""contents_url"": ""https://api.github.com/repos/miniupnp/miniupnp/contents/miniupnpd/upnpredirect.c?ref=f321c2066b96d18afa5158dfa2d2873a2957ef38"", ""patch"": ""@@ -356,6 +356,10 @@ upnp_redirect(const char * rhost, unsigned short eport,\n \t\t                 \""%hu->%s:%hu %s\"", eport, iaddr, iport, protocol);\n \t\treturn -3;\n \t}\n+\n+\tif (desc == NULL)\n+\t\tdesc = \""\"";\t/* assume empty description */\n+\n \t/* IGDv1 (WANIPConnection:1 Service Template Version 1.01 / Nov 12, 2001)\n \t * - 2.2.20.PortMappingDescription :\n \t *  Overwriting Previous / Existing Port Mappings:""}","upnp_redirect(const char * rhost, unsigned short eport,
              const char * iaddr, unsigned short iport,
              const char * protocol, const char * desc,
              unsigned int leaseduration)
{
	int proto, r;
	char iaddr_old[32];
	char rhost_old[32];
	unsigned short iport_old;
	struct in_addr address;
	unsigned int timestamp;

	proto = proto_atoi(protocol);
	if(inet_aton(iaddr, &address) <= 0) {
		syslog(LOG_ERR, ""inet_aton(%s) FAILED"", iaddr);
		return -1;
	}

	if(!check_upnp_rule_against_permissions(upnppermlist, num_upnpperm,
	                                        eport, address, iport)) {
		syslog(LOG_INFO, ""redirection permission check failed for ""
 		                 ""%hu->%s:%hu %s"", eport, iaddr, iport, protocol);
 		return -3;
 	}

	if (desc == NULL)
		desc = """";	/* assume empty description */

 	/* IGDv1 (WANIPConnection:1 Service Template Version 1.01 / Nov 12, 2001)
 	 * - 2.2.20.PortMappingDescription :
 	 *  Overwriting Previous / Existing Port Mappings:
	 * If the RemoteHost, ExternalPort, PortMappingProtocol and InternalClient
	 * are exactly the same as an existing mapping, the existing mapping values
	 * for InternalPort, PortMappingDescription, PortMappingEnabled and
	 * PortMappingLeaseDuration are overwritten.
	 *  Rejecting a New Port Mapping:
	 * In cases where the RemoteHost, ExternalPort and PortMappingProtocol
	 * are the same as an existing mapping, but the InternalClient is
	 * different, the action is rejected with an appropriate error.
	 *  Add or Reject New Port Mapping behavior based on vendor implementation:
	 * In cases where the ExternalPort, PortMappingProtocol and InternalClient
	 * are the same, but RemoteHost is different, the vendor can choose to
	 * support both mappings simultaneously, or reject the second mapping
	 * with an appropriate error.
	 *
	 * - 2.4.16.AddPortMapping
	 * This action creates a new port mapping or overwrites an existing
	 * mapping with the same internal client. If the ExternalPort and
	 * PortMappingProtocol pair is already mapped to another internal client,
	 * an error is returned.
	 *
	 * IGDv2 (WANIPConnection:2 Service Standardized DCP (SDCP) Sep 10, 2010)
	 * Protocol ExternalPort RemoteHost InternalClient Result
	 *     =         =           ≠           ≠         Failure
	 *     =         =           ≠           =         Failure or success
	 *                                                 (vendor specific)
	 *     =         =           =           ≠         Failure
	 *     =         =           =           =         Success (overwrite)
	 */
	rhost_old[0] = '\0';
	r = get_redirect_rule(ext_if_name, eport, proto,
	                      iaddr_old, sizeof(iaddr_old), &iport_old, 0, 0,
	                      rhost_old, sizeof(rhost_old),
	                      &timestamp, 0, 0);
	if(r == 0) {
		if(strcmp(iaddr, iaddr_old)==0 &&
		   ((rhost == NULL && rhost_old[0]=='\0') ||
		    (rhost && (strcmp(rhost, ""*"") == 0) && rhost_old[0]=='\0') ||
		    (rhost && (strcmp(rhost, rhost_old) == 0)))) {
			syslog(LOG_INFO, ""updating existing port mapping %hu %s (rhost '%s') => %s:%hu"",
				eport, protocol, rhost_old, iaddr_old, iport_old);
			timestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;
			if(iport != iport_old) {
				r = update_portmapping(ext_if_name, eport, proto, iport, desc, timestamp);
			} else {
				r = update_portmapping_desc_timestamp(ext_if_name, eport, proto, desc, timestamp);
			}
#ifdef ENABLE_LEASEFILE
			if(r == 0) {
				lease_file_remove(eport, proto);
				lease_file_add(eport, iaddr, iport, proto, desc, timestamp);
			}
#endif /* ENABLE_LEASEFILE */
			return r;
		} else {
			syslog(LOG_INFO, ""port %hu %s (rhost '%s') already redirected to %s:%hu"",
				eport, protocol, rhost_old, iaddr_old, iport_old);
			return -2;
		}
#ifdef CHECK_PORTINUSE
	} else if (port_in_use(ext_if_name, eport, proto, iaddr, iport) > 0) {
		syslog(LOG_INFO, ""port %hu protocol %s already in use"",
		       eport, protocol);
		return -4;
#endif /* CHECK_PORTINUSE */
	} else {
		timestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;
		syslog(LOG_INFO, ""redirecting port %hu to %s:%hu protocol %s for: %s"",
			eport, iaddr, iport, protocol, desc);
		return upnp_redirect_internal(rhost, eport, iaddr, iport, proto,
		                              desc, timestamp);
	}
}
","upnp_redirect(const char * rhost, unsigned short eport,
              const char * iaddr, unsigned short iport,
              const char * protocol, const char * desc,
              unsigned int leaseduration)
{
	int proto, r;
	char iaddr_old[32];
	char rhost_old[32];
	unsigned short iport_old;
	struct in_addr address;
	unsigned int timestamp;

	proto = proto_atoi(protocol);
	if(inet_aton(iaddr, &address) <= 0) {
		syslog(LOG_ERR, ""inet_aton(%s) FAILED"", iaddr);
		return -1;
	}

	if(!check_upnp_rule_against_permissions(upnppermlist, num_upnpperm,
	                                        eport, address, iport)) {
		syslog(LOG_INFO, ""redirection permission check failed for ""
 		                 ""%hu->%s:%hu %s"", eport, iaddr, iport, protocol);
 		return -3;
 	}
 	/* IGDv1 (WANIPConnection:1 Service Template Version 1.01 / Nov 12, 2001)
 	 * - 2.2.20.PortMappingDescription :
 	 *  Overwriting Previous / Existing Port Mappings:
	 * If the RemoteHost, ExternalPort, PortMappingProtocol and InternalClient
	 * are exactly the same as an existing mapping, the existing mapping values
	 * for InternalPort, PortMappingDescription, PortMappingEnabled and
	 * PortMappingLeaseDuration are overwritten.
	 *  Rejecting a New Port Mapping:
	 * In cases where the RemoteHost, ExternalPort and PortMappingProtocol
	 * are the same as an existing mapping, but the InternalClient is
	 * different, the action is rejected with an appropriate error.
	 *  Add or Reject New Port Mapping behavior based on vendor implementation:
	 * In cases where the ExternalPort, PortMappingProtocol and InternalClient
	 * are the same, but RemoteHost is different, the vendor can choose to
	 * support both mappings simultaneously, or reject the second mapping
	 * with an appropriate error.
	 *
	 * - 2.4.16.AddPortMapping
	 * This action creates a new port mapping or overwrites an existing
	 * mapping with the same internal client. If the ExternalPort and
	 * PortMappingProtocol pair is already mapped to another internal client,
	 * an error is returned.
	 *
	 * IGDv2 (WANIPConnection:2 Service Standardized DCP (SDCP) Sep 10, 2010)
	 * Protocol ExternalPort RemoteHost InternalClient Result
	 *     =         =           ≠           ≠         Failure
	 *     =         =           ≠           =         Failure or success
	 *                                                 (vendor specific)
	 *     =         =           =           ≠         Failure
	 *     =         =           =           =         Success (overwrite)
	 */
	rhost_old[0] = '\0';
	r = get_redirect_rule(ext_if_name, eport, proto,
	                      iaddr_old, sizeof(iaddr_old), &iport_old, 0, 0,
	                      rhost_old, sizeof(rhost_old),
	                      &timestamp, 0, 0);
	if(r == 0) {
		if(strcmp(iaddr, iaddr_old)==0 &&
		   ((rhost == NULL && rhost_old[0]=='\0') ||
		    (rhost && (strcmp(rhost, ""*"") == 0) && rhost_old[0]=='\0') ||
		    (rhost && (strcmp(rhost, rhost_old) == 0)))) {
			syslog(LOG_INFO, ""updating existing port mapping %hu %s (rhost '%s') => %s:%hu"",
				eport, protocol, rhost_old, iaddr_old, iport_old);
			timestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;
			if(iport != iport_old) {
				r = update_portmapping(ext_if_name, eport, proto, iport, desc, timestamp);
			} else {
				r = update_portmapping_desc_timestamp(ext_if_name, eport, proto, desc, timestamp);
			}
#ifdef ENABLE_LEASEFILE
			if(r == 0) {
				lease_file_remove(eport, proto);
				lease_file_add(eport, iaddr, iport, proto, desc, timestamp);
			}
#endif /* ENABLE_LEASEFILE */
			return r;
		} else {
			syslog(LOG_INFO, ""port %hu %s (rhost '%s') already redirected to %s:%hu"",
				eport, protocol, rhost_old, iaddr_old, iport_old);
			return -2;
		}
#ifdef CHECK_PORTINUSE
	} else if (port_in_use(ext_if_name, eport, proto, iaddr, iport) > 0) {
		syslog(LOG_INFO, ""port %hu protocol %s already in use"",
		       eport, protocol);
		return -4;
#endif /* CHECK_PORTINUSE */
	} else {
		timestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;
		syslog(LOG_INFO, ""redirecting port %hu to %s:%hu protocol %s for: %s"",
			eport, iaddr, iport, protocol, desc);
		return upnp_redirect_internal(rhost, eport, iaddr, iport, proto,
		                              desc, timestamp);
	}
}
",C,"
	if (desc == NULL)
		desc = """";	/* assume empty description */

",,,"@@ -356,6 +356,10 @@ upnp_redirect(const char * rhost, unsigned short eport,
 		                 ""%hu->%s:%hu %s"", eport, iaddr, iport, protocol);
 		return -3;
 	}
+
+	if (desc == NULL)
+		desc = """";	/* assume empty description */
+
 	/* IGDv1 (WANIPConnection:1 Service Template Version 1.01 / Nov 12, 2001)
 	 * - 2.2.20.PortMappingDescription :
 	 *  Overwriting Previous / Existing Port Mappings:",miniupnp,f321c2066b96d18afa5158dfa2d2873a2957ef38,13585f15c7f7dc28bbbba1661efb280d530d114c,1,"upnp_redirect(const char * rhost, unsigned short eport,
              const char * iaddr, unsigned short iport,
              const char * protocol, const char * desc,
              unsigned int leaseduration)
{
	int proto, r;
	char iaddr_old[32];
	char rhost_old[32];
	unsigned short iport_old;
	struct in_addr address;
	unsigned int timestamp;

	proto = proto_atoi(protocol);
	if(inet_aton(iaddr, &address) <= 0) {
		syslog(LOG_ERR, ""inet_aton(%s) FAILED"", iaddr);
		return -1;
	}

	if(!check_upnp_rule_against_permissions(upnppermlist, num_upnpperm,
	                                        eport, address, iport)) {
		syslog(LOG_INFO, ""redirection permission check failed for ""
 		                 ""%hu->%s:%hu %s"", eport, iaddr, iport, protocol);
 		return -3;
 	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (desc == NULL)
//fix_flaw_line_below:
//		desc = """";	/* assume empty description */
//fix_flaw_line_below:
//
 	/* IGDv1 (WANIPConnection:1 Service Template Version 1.01 / Nov 12, 2001)
 	 * - 2.2.20.PortMappingDescription :
 	 *  Overwriting Previous / Existing Port Mappings:
	 * If the RemoteHost, ExternalPort, PortMappingProtocol and InternalClient
	 * are exactly the same as an existing mapping, the existing mapping values
	 * for InternalPort, PortMappingDescription, PortMappingEnabled and
	 * PortMappingLeaseDuration are overwritten.
	 *  Rejecting a New Port Mapping:
	 * In cases where the RemoteHost, ExternalPort and PortMappingProtocol
	 * are the same as an existing mapping, but the InternalClient is
	 * different, the action is rejected with an appropriate error.
	 *  Add or Reject New Port Mapping behavior based on vendor implementation:
	 * In cases where the ExternalPort, PortMappingProtocol and InternalClient
	 * are the same, but RemoteHost is different, the vendor can choose to
	 * support both mappings simultaneously, or reject the second mapping
	 * with an appropriate error.
	 *
	 * - 2.4.16.AddPortMapping
	 * This action creates a new port mapping or overwrites an existing
	 * mapping with the same internal client. If the ExternalPort and
	 * PortMappingProtocol pair is already mapped to another internal client,
	 * an error is returned.
	 *
	 * IGDv2 (WANIPConnection:2 Service Standardized DCP (SDCP) Sep 10, 2010)
	 * Protocol ExternalPort RemoteHost InternalClient Result
	 *     =         =           ≠           ≠         Failure
	 *     =         =           ≠           =         Failure or success
	 *                                                 (vendor specific)
	 *     =         =           =           ≠         Failure
	 *     =         =           =           =         Success (overwrite)
	 */
	rhost_old[0] = '\0';
	r = get_redirect_rule(ext_if_name, eport, proto,
	                      iaddr_old, sizeof(iaddr_old), &iport_old, 0, 0,
	                      rhost_old, sizeof(rhost_old),
	                      &timestamp, 0, 0);
	if(r == 0) {
		if(strcmp(iaddr, iaddr_old)==0 &&
		   ((rhost == NULL && rhost_old[0]=='\0') ||
		    (rhost && (strcmp(rhost, ""*"") == 0) && rhost_old[0]=='\0') ||
		    (rhost && (strcmp(rhost, rhost_old) == 0)))) {
			syslog(LOG_INFO, ""updating existing port mapping %hu %s (rhost '%s') => %s:%hu"",
				eport, protocol, rhost_old, iaddr_old, iport_old);
			timestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;
			if(iport != iport_old) {
				r = update_portmapping(ext_if_name, eport, proto, iport, desc, timestamp);
			} else {
				r = update_portmapping_desc_timestamp(ext_if_name, eport, proto, desc, timestamp);
			}
#ifdef ENABLE_LEASEFILE
			if(r == 0) {
				lease_file_remove(eport, proto);
				lease_file_add(eport, iaddr, iport, proto, desc, timestamp);
			}
#endif /* ENABLE_LEASEFILE */
			return r;
		} else {
			syslog(LOG_INFO, ""port %hu %s (rhost '%s') already redirected to %s:%hu"",
				eport, protocol, rhost_old, iaddr_old, iport_old);
			return -2;
		}
#ifdef CHECK_PORTINUSE
	} else if (port_in_use(ext_if_name, eport, proto, iaddr, iport) > 0) {
		syslog(LOG_INFO, ""port %hu protocol %s already in use"",
		       eport, protocol);
		return -4;
#endif /* CHECK_PORTINUSE */
	} else {
		timestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;
		syslog(LOG_INFO, ""redirecting port %hu to %s:%hu protocol %s for: %s"",
			eport, iaddr, iport, protocol, desc);
		return upnp_redirect_internal(rhost, eport, iaddr, iport, proto,
		                              desc, timestamp);
	}
}
"
5103,182839,,Remote,Not required,Partial,CVE-2019-12109,https://www.cvedetails.com/cve/CVE-2019-12109/,CWE-476,Low,,,,2019-05-15,5.0,A Denial Of Service vulnerability in MiniUPnP MiniUPnPd through 2.1 exists due to a NULL pointer dereference in GetOutboundPinholeTimeout in upnpsoap.c for rem_port.,2019-05-30,DoS ,7,https://github.com/miniupnp/miniupnp/commit/13585f15c7f7dc28bbbba1661efb280d530d114c,13585f15c7f7dc28bbbba1661efb280d530d114c,GetOutboundPinholeTimeout: check args,0,miniupnpd/upnpsoap.c,"{""sha"": ""997b32541ef7e41e3161e406263e464ddeba43ba"", ""filename"": ""miniupnpd/upnpsoap.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/miniupnp/miniupnp/blob/13585f15c7f7dc28bbbba1661efb280d530d114c/miniupnpd/upnpsoap.c"", ""raw_url"": ""https://github.com/miniupnp/miniupnp/raw/13585f15c7f7dc28bbbba1661efb280d530d114c/miniupnpd/upnpsoap.c"", ""contents_url"": ""https://api.github.com/repos/miniupnp/miniupnp/contents/miniupnpd/upnpsoap.c?ref=13585f15c7f7dc28bbbba1661efb280d530d114c"", ""patch"": ""@@ -1850,6 +1850,13 @@ GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char *\n \trem_port = GetValueFromNameValueList(&data, \""RemotePort\"");\n \tprotocol = GetValueFromNameValueList(&data, \""Protocol\"");\n \n+\tif (!int_port || !ext_port || !protocol)\n+\t{\n+\t\tClearNameValueList(&data);\n+\t\tSoapError(h, 402, \""Invalid Args\"");\n+\t\treturn;\n+\t}\n+\n \trport = (unsigned short)atoi(rem_port);\n \tiport = (unsigned short)atoi(int_port);\n \t/*proto = atoi(protocol);*/""}","GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)
{
	int r;

	static const char resp[] =
		""<u:%sResponse ""
		""xmlns:u=\""%s\"">""
		""<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>""
		""</u:%sResponse>"";

	char body[512];
	int bodylen;
	struct NameValueParserData data;
	char * int_ip, * int_port, * rem_host, * rem_port, * protocol;
	int opt=0;
	/*int proto=0;*/
	unsigned short iport, rport;

	if (GETFLAG(IPV6FCFWDISABLEDMASK))
	{
		SoapError(h, 702, ""FirewallDisabled"");
		return;
	}

	ParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);
	int_ip = GetValueFromNameValueList(&data, ""InternalClient"");
	int_port = GetValueFromNameValueList(&data, ""InternalPort"");
	rem_host = GetValueFromNameValueList(&data, ""RemoteHost"");
 	rem_port = GetValueFromNameValueList(&data, ""RemotePort"");
 	protocol = GetValueFromNameValueList(&data, ""Protocol"");
 
	if (!int_port || !ext_port || !protocol)
	{
		ClearNameValueList(&data);
		SoapError(h, 402, ""Invalid Args"");
		return;
	}

 	rport = (unsigned short)atoi(rem_port);
 	iport = (unsigned short)atoi(int_port);
 	/*proto = atoi(protocol);*/

	syslog(LOG_INFO, ""%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s"", action, int_ip, iport,rem_host, rport, protocol);

	/* TODO */
	r = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/

	switch(r)
	{
		case 1:	/* success */
			bodylen = snprintf(body, sizeof(body), resp,
			                   action, ns/*""urn:schemas-upnp-org:service:WANIPv6FirewallControl:1""*/,
			                   opt, action);
			BuildSendAndCloseSoapResp(h, body, bodylen);
			break;
		case -5:	/* Protocol not supported */
			SoapError(h, 705, ""ProtocolNotSupported"");
			break;
		default:
			SoapError(h, 501, ""ActionFailed"");
	}
	ClearNameValueList(&data);
}
","GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)
{
	int r;

	static const char resp[] =
		""<u:%sResponse ""
		""xmlns:u=\""%s\"">""
		""<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>""
		""</u:%sResponse>"";

	char body[512];
	int bodylen;
	struct NameValueParserData data;
	char * int_ip, * int_port, * rem_host, * rem_port, * protocol;
	int opt=0;
	/*int proto=0;*/
	unsigned short iport, rport;

	if (GETFLAG(IPV6FCFWDISABLEDMASK))
	{
		SoapError(h, 702, ""FirewallDisabled"");
		return;
	}

	ParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);
	int_ip = GetValueFromNameValueList(&data, ""InternalClient"");
	int_port = GetValueFromNameValueList(&data, ""InternalPort"");
	rem_host = GetValueFromNameValueList(&data, ""RemoteHost"");
 	rem_port = GetValueFromNameValueList(&data, ""RemotePort"");
 	protocol = GetValueFromNameValueList(&data, ""Protocol"");
 
 	rport = (unsigned short)atoi(rem_port);
 	iport = (unsigned short)atoi(int_port);
 	/*proto = atoi(protocol);*/

	syslog(LOG_INFO, ""%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s"", action, int_ip, iport,rem_host, rport, protocol);

	/* TODO */
	r = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/

	switch(r)
	{
		case 1:	/* success */
			bodylen = snprintf(body, sizeof(body), resp,
			                   action, ns/*""urn:schemas-upnp-org:service:WANIPv6FirewallControl:1""*/,
			                   opt, action);
			BuildSendAndCloseSoapResp(h, body, bodylen);
			break;
		case -5:	/* Protocol not supported */
			SoapError(h, 705, ""ProtocolNotSupported"");
			break;
		default:
			SoapError(h, 501, ""ActionFailed"");
	}
	ClearNameValueList(&data);
}
",C,"	if (!int_port || !ext_port || !protocol)
	{
		ClearNameValueList(&data);
		SoapError(h, 402, ""Invalid Args"");
		return;
	}

",,,"@@ -1850,6 +1850,13 @@ GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char *
 	rem_port = GetValueFromNameValueList(&data, ""RemotePort"");
 	protocol = GetValueFromNameValueList(&data, ""Protocol"");
 
+	if (!int_port || !ext_port || !protocol)
+	{
+		ClearNameValueList(&data);
+		SoapError(h, 402, ""Invalid Args"");
+		return;
+	}
+
 	rport = (unsigned short)atoi(rem_port);
 	iport = (unsigned short)atoi(int_port);
 	/*proto = atoi(protocol);*/",miniupnp,13585f15c7f7dc28bbbba1661efb280d530d114c,bec6ccec63cadc95655721bc0e1dd49dac759d94,1,"GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)
{
	int r;

	static const char resp[] =
		""<u:%sResponse ""
		""xmlns:u=\""%s\"">""
		""<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>""
		""</u:%sResponse>"";

	char body[512];
	int bodylen;
	struct NameValueParserData data;
	char * int_ip, * int_port, * rem_host, * rem_port, * protocol;
	int opt=0;
	/*int proto=0;*/
	unsigned short iport, rport;

	if (GETFLAG(IPV6FCFWDISABLEDMASK))
	{
		SoapError(h, 702, ""FirewallDisabled"");
		return;
	}

	ParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);
	int_ip = GetValueFromNameValueList(&data, ""InternalClient"");
	int_port = GetValueFromNameValueList(&data, ""InternalPort"");
	rem_host = GetValueFromNameValueList(&data, ""RemoteHost"");
 	rem_port = GetValueFromNameValueList(&data, ""RemotePort"");
 	protocol = GetValueFromNameValueList(&data, ""Protocol"");
 
//fix_flaw_line_below:
//	if (!int_port || !ext_port || !protocol)
//fix_flaw_line_below:
//	{
//fix_flaw_line_below:
//		ClearNameValueList(&data);
//fix_flaw_line_below:
//		SoapError(h, 402, ""Invalid Args"");
//fix_flaw_line_below:
//		return;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	rport = (unsigned short)atoi(rem_port);
 	iport = (unsigned short)atoi(int_port);
 	/*proto = atoi(protocol);*/

	syslog(LOG_INFO, ""%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s"", action, int_ip, iport,rem_host, rport, protocol);

	/* TODO */
	r = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/

	switch(r)
	{
		case 1:	/* success */
			bodylen = snprintf(body, sizeof(body), resp,
			                   action, ns/*""urn:schemas-upnp-org:service:WANIPv6FirewallControl:1""*/,
			                   opt, action);
			BuildSendAndCloseSoapResp(h, body, bodylen);
			break;
		case -5:	/* Protocol not supported */
			SoapError(h, 705, ""ProtocolNotSupported"");
			break;
		default:
			SoapError(h, 501, ""ActionFailed"");
	}
	ClearNameValueList(&data);
}
"
5119,182855,,Remote,Not required,Complete,CVE-2019-11810,https://www.cvedetails.com/cve/CVE-2019-11810/,CWE-476,Low,,,,2019-05-07,7.8,"An issue was discovered in the Linux kernel before 5.0.7. A NULL pointer dereference can occur when megasas_create_frame_pool() fails in megasas_alloc_cmds() in drivers/scsi/megaraid/megaraid_sas_base.c. This causes a Denial of Service, related to a use-after-free.",2019-06-07,DoS ,1,https://github.com/torvalds/linux/commit/bcf3b67d16a4c8ffae0aa79de5853435e683945c,bcf3b67d16a4c8ffae0aa79de5853435e683945c,"scsi: megaraid_sas: return error when create DMA pool failed

when create DMA pool for cmd frames failed, we should return -ENOMEM,
instead of 0.
In some case in:

    megasas_init_adapter_fusion()

    -->megasas_alloc_cmds()
       -->megasas_create_frame_pool
          create DMA pool failed,
        --> megasas_free_cmds() [1]

    -->megasas_alloc_cmds_fusion()
       failed, then goto fail_alloc_cmds.
    -->megasas_free_cmds() [2]

we will call megasas_free_cmds twice, [1] will kfree cmd_list,
[2] will use cmd_list.it will cause a problem:

Unable to handle kernel NULL pointer dereference at virtual address
00000000
pgd = ffffffc000f70000
[00000000] *pgd=0000001fbf893003, *pud=0000001fbf893003,
*pmd=0000001fbf894003, *pte=006000006d000707
Internal error: Oops: 96000005 [#1] SMP
 Modules linked in:
 CPU: 18 PID: 1 Comm: swapper/0 Not tainted
 task: ffffffdfb9290000 ti: ffffffdfb923c000 task.ti: ffffffdfb923c000
 PC is at megasas_free_cmds+0x30/0x70
 LR is at megasas_free_cmds+0x24/0x70
 ...
 Call trace:
 [<ffffffc0005b779c>] megasas_free_cmds+0x30/0x70
 [<ffffffc0005bca74>] megasas_init_adapter_fusion+0x2f4/0x4d8
 [<ffffffc0005b926c>] megasas_init_fw+0x2dc/0x760
 [<ffffffc0005b9ab0>] megasas_probe_one+0x3c0/0xcd8
 [<ffffffc0004a5abc>] local_pci_probe+0x4c/0xb4
 [<ffffffc0004a5c40>] pci_device_probe+0x11c/0x14c
 [<ffffffc00053a5e4>] driver_probe_device+0x1ec/0x430
 [<ffffffc00053a92c>] __driver_attach+0xa8/0xb0
 [<ffffffc000538178>] bus_for_each_dev+0x74/0xc8
  [<ffffffc000539e88>] driver_attach+0x28/0x34
 [<ffffffc000539a18>] bus_add_driver+0x16c/0x248
 [<ffffffc00053b234>] driver_register+0x6c/0x138
 [<ffffffc0004a5350>] __pci_register_driver+0x5c/0x6c
 [<ffffffc000ce3868>] megasas_init+0xc0/0x1a8
 [<ffffffc000082a58>] do_one_initcall+0xe8/0x1ec
 [<ffffffc000ca7be8>] kernel_init_freeable+0x1c8/0x284
 [<ffffffc0008d90b8>] kernel_init+0x1c/0xe4

Signed-off-by: Jason Yan <yanaijie@huawei.com>
Acked-by: Sumit Saxena <sumit.saxena@broadcom.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>",0,drivers/scsi/megaraid/megaraid_sas_base.c,"{""sha"": ""8a2ee4cf26b078e31f935711fea2c74610a879ea"", ""filename"": ""drivers/scsi/megaraid/megaraid_sas_base.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/bcf3b67d16a4c8ffae0aa79de5853435e683945c/drivers/scsi/megaraid/megaraid_sas_base.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bcf3b67d16a4c8ffae0aa79de5853435e683945c/drivers/scsi/megaraid/megaraid_sas_base.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/scsi/megaraid/megaraid_sas_base.c?ref=bcf3b67d16a4c8ffae0aa79de5853435e683945c"", ""patch"": ""@@ -4188,6 +4188,7 @@ int megasas_alloc_cmds(struct megasas_instance *instance)\n \tif (megasas_create_frame_pool(instance)) {\n \t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \""Error creating frame DMA pool\\n\"");\n \t\tmegasas_free_cmds(instance);\n+\t\treturn -ENOMEM;\n \t}\n \n \treturn 0;""}","int megasas_alloc_cmds(struct megasas_instance *instance)
{
	int i;
	int j;
	u16 max_cmd;
	struct megasas_cmd *cmd;

	max_cmd = instance->max_mfi_cmds;

	/*
	 * instance->cmd_list is an array of struct megasas_cmd pointers.
	 * Allocate the dynamic array first and then allocate individual
	 * commands.
	 */
	instance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);

	if (!instance->cmd_list) {
		dev_printk(KERN_DEBUG, &instance->pdev->dev, ""out of memory\n"");
		return -ENOMEM;
	}

	memset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);

	for (i = 0; i < max_cmd; i++) {
		instance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),
						GFP_KERNEL);

		if (!instance->cmd_list[i]) {

			for (j = 0; j < i; j++)
				kfree(instance->cmd_list[j]);

			kfree(instance->cmd_list);
			instance->cmd_list = NULL;

			return -ENOMEM;
		}
	}

	for (i = 0; i < max_cmd; i++) {
		cmd = instance->cmd_list[i];
		memset(cmd, 0, sizeof(struct megasas_cmd));
		cmd->index = i;
		cmd->scmd = NULL;
		cmd->instance = instance;

		list_add_tail(&cmd->list, &instance->cmd_pool);
	}

	/*
	 * Create a frame pool and assign one frame to each cmd
	 */
 	if (megasas_create_frame_pool(instance)) {
 		dev_printk(KERN_DEBUG, &instance->pdev->dev, ""Error creating frame DMA pool\n"");
 		megasas_free_cmds(instance);
		return -ENOMEM;
 	}
 
 	return 0;
}
","int megasas_alloc_cmds(struct megasas_instance *instance)
{
	int i;
	int j;
	u16 max_cmd;
	struct megasas_cmd *cmd;

	max_cmd = instance->max_mfi_cmds;

	/*
	 * instance->cmd_list is an array of struct megasas_cmd pointers.
	 * Allocate the dynamic array first and then allocate individual
	 * commands.
	 */
	instance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);

	if (!instance->cmd_list) {
		dev_printk(KERN_DEBUG, &instance->pdev->dev, ""out of memory\n"");
		return -ENOMEM;
	}

	memset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);

	for (i = 0; i < max_cmd; i++) {
		instance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),
						GFP_KERNEL);

		if (!instance->cmd_list[i]) {

			for (j = 0; j < i; j++)
				kfree(instance->cmd_list[j]);

			kfree(instance->cmd_list);
			instance->cmd_list = NULL;

			return -ENOMEM;
		}
	}

	for (i = 0; i < max_cmd; i++) {
		cmd = instance->cmd_list[i];
		memset(cmd, 0, sizeof(struct megasas_cmd));
		cmd->index = i;
		cmd->scmd = NULL;
		cmd->instance = instance;

		list_add_tail(&cmd->list, &instance->cmd_pool);
	}

	/*
	 * Create a frame pool and assign one frame to each cmd
	 */
 	if (megasas_create_frame_pool(instance)) {
 		dev_printk(KERN_DEBUG, &instance->pdev->dev, ""Error creating frame DMA pool\n"");
 		megasas_free_cmds(instance);
 	}
 
 	return 0;
}
",C,"		return -ENOMEM;
",,,"@@ -4188,6 +4188,7 @@ int megasas_alloc_cmds(struct megasas_instance *instance)
 	if (megasas_create_frame_pool(instance)) {
 		dev_printk(KERN_DEBUG, &instance->pdev->dev, ""Error creating frame DMA pool\n"");
 		megasas_free_cmds(instance);
+		return -ENOMEM;
 	}
 
 	return 0;",linux,bcf3b67d16a4c8ffae0aa79de5853435e683945c,f3e026951771bceb17319a4d0d6121ca58746c88,1,"int megasas_alloc_cmds(struct megasas_instance *instance)
{
	int i;
	int j;
	u16 max_cmd;
	struct megasas_cmd *cmd;

	max_cmd = instance->max_mfi_cmds;

	/*
	 * instance->cmd_list is an array of struct megasas_cmd pointers.
	 * Allocate the dynamic array first and then allocate individual
	 * commands.
	 */
	instance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);

	if (!instance->cmd_list) {
		dev_printk(KERN_DEBUG, &instance->pdev->dev, ""out of memory\n"");
		return -ENOMEM;
	}

	memset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);

	for (i = 0; i < max_cmd; i++) {
		instance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),
						GFP_KERNEL);

		if (!instance->cmd_list[i]) {

			for (j = 0; j < i; j++)
				kfree(instance->cmd_list[j]);

			kfree(instance->cmd_list);
			instance->cmd_list = NULL;

			return -ENOMEM;
		}
	}

	for (i = 0; i < max_cmd; i++) {
		cmd = instance->cmd_list[i];
		memset(cmd, 0, sizeof(struct megasas_cmd));
		cmd->index = i;
		cmd->scmd = NULL;
		cmd->instance = instance;

		list_add_tail(&cmd->list, &instance->cmd_pool);
	}

	/*
	 * Create a frame pool and assign one frame to each cmd
	 */
 	if (megasas_create_frame_pool(instance)) {
 		dev_printk(KERN_DEBUG, &instance->pdev->dev, ""Error creating frame DMA pool\n"");
 		megasas_free_cmds(instance);
//fix_flaw_line_below:
//		return -ENOMEM;
 	}
 
 	return 0;
}
"
5142,182878,,Remote,Not required,Partial,CVE-2019-11338,https://www.cvedetails.com/cve/CVE-2019-11338/,CWE-476,Medium,Partial,Partial,,2019-04-18,6.8,"libavcodec/hevcdec.c in FFmpeg 4.1.2 mishandles detection of duplicate first slices, which allows remote attackers to cause a denial of service (NULL pointer dereference and out-of-array access) or possibly have unspecified other impact via crafted HEVC data.",2019-05-29,DoS ,5,https://github.com/FFmpeg/FFmpeg/commit/54655623a82632e7624714d7b2a3e039dc5faa7e,54655623a82632e7624714d7b2a3e039dc5faa7e,"avcodec/hevcdec: Avoid only partly skiping duplicate first slices

Fixes: NULL pointer dereference and out of array access
Fixes: 13871/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_HEVC_fuzzer-5746167087890432
Fixes: 13845/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_HEVC_fuzzer-5650370728034304

This also fixes the return code for explode mode

Found-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/projects/ffmpeg
Reviewed-by: James Almer <jamrial@gmail.com>
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",4,libavcodec/hevcdec.c,"{""sha"": ""857c10dd122ff414b27997406ccea58e5cc2c0a5"", ""filename"": ""libavcodec/hevcdec.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 4, ""changes"": 14, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/54655623a82632e7624714d7b2a3e039dc5faa7e/libavcodec/hevcdec.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/54655623a82632e7624714d7b2a3e039dc5faa7e/libavcodec/hevcdec.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavcodec/hevcdec.c?ref=54655623a82632e7624714d7b2a3e039dc5faa7e"", ""patch"": ""@@ -488,6 +488,11 @@ static int hls_slice_header(HEVCContext *s)\n \n     // Coded parameters\n     sh->first_slice_in_pic_flag = get_bits1(gb);\n+    if (s->ref && sh->first_slice_in_pic_flag) {\n+        av_log(s->avctx, AV_LOG_ERROR, \""Two slices reporting being the first in the same frame.\\n\"");\n+        return 1; // This slice will be skiped later, do not corrupt state\n+    }\n+\n     if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {\n         s->seq_decode = (s->seq_decode + 1) & 0xff;\n         s->max_ra     = INT_MAX;\n@@ -2918,6 +2923,11 @@ static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)\n         ret = hls_slice_header(s);\n         if (ret < 0)\n             return ret;\n+        if (ret == 1) {\n+            ret = AVERROR_INVALIDDATA;\n+            goto fail;\n+        }\n+\n \n         if (\n             (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||\n@@ -2927,10 +2937,6 @@ static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)\n         }\n \n         if (s->sh.first_slice_in_pic_flag) {\n-            if (s->ref) {\n-                av_log(s->avctx, AV_LOG_ERROR, \""Two slices reporting being the first in the same frame.\\n\"");\n-                goto fail;\n-            }\n             if (s->max_ra == INT_MAX) {\n                 if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {\n                     s->max_ra = s->poc;""}","static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)
{
    HEVCLocalContext *lc = s->HEVClc;
    GetBitContext *gb    = &lc->gb;
    int ctb_addr_ts, ret;

    *gb              = nal->gb;
    s->nal_unit_type = nal->type;
    s->temporal_id   = nal->temporal_id;

    switch (s->nal_unit_type) {
    case HEVC_NAL_VPS:
        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
            ret = s->avctx->hwaccel->decode_params(s->avctx,
                                                   nal->type,
                                                   nal->raw_data,
                                                   nal->raw_size);
            if (ret < 0)
                goto fail;
        }
        ret = ff_hevc_decode_nal_vps(gb, s->avctx, &s->ps);
        if (ret < 0)
            goto fail;
        break;
    case HEVC_NAL_SPS:
        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
            ret = s->avctx->hwaccel->decode_params(s->avctx,
                                                   nal->type,
                                                   nal->raw_data,
                                                   nal->raw_size);
            if (ret < 0)
                goto fail;
        }
        ret = ff_hevc_decode_nal_sps(gb, s->avctx, &s->ps,
                                     s->apply_defdispwin);
        if (ret < 0)
            goto fail;
        break;
    case HEVC_NAL_PPS:
        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
            ret = s->avctx->hwaccel->decode_params(s->avctx,
                                                   nal->type,
                                                   nal->raw_data,
                                                   nal->raw_size);
            if (ret < 0)
                goto fail;
        }
        ret = ff_hevc_decode_nal_pps(gb, s->avctx, &s->ps);
        if (ret < 0)
            goto fail;
        break;
    case HEVC_NAL_SEI_PREFIX:
    case HEVC_NAL_SEI_SUFFIX:
        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
            ret = s->avctx->hwaccel->decode_params(s->avctx,
                                                   nal->type,
                                                   nal->raw_data,
                                                   nal->raw_size);
            if (ret < 0)
                goto fail;
        }
        ret = ff_hevc_decode_nal_sei(gb, s->avctx, &s->sei, &s->ps, s->nal_unit_type);
        if (ret < 0)
            goto fail;
        break;
    case HEVC_NAL_TRAIL_R:
    case HEVC_NAL_TRAIL_N:
    case HEVC_NAL_TSA_N:
    case HEVC_NAL_TSA_R:
    case HEVC_NAL_STSA_N:
    case HEVC_NAL_STSA_R:
    case HEVC_NAL_BLA_W_LP:
    case HEVC_NAL_BLA_W_RADL:
    case HEVC_NAL_BLA_N_LP:
    case HEVC_NAL_IDR_W_RADL:
    case HEVC_NAL_IDR_N_LP:
    case HEVC_NAL_CRA_NUT:
    case HEVC_NAL_RADL_N:
    case HEVC_NAL_RADL_R:
    case HEVC_NAL_RASL_N:
    case HEVC_NAL_RASL_R:
         ret = hls_slice_header(s);
         if (ret < 0)
             return ret;
        if (ret == 1) {
            ret = AVERROR_INVALIDDATA;
            goto fail;
        }

 
         if (
             (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||
            (s->avctx->skip_frame >= AVDISCARD_NONINTRA && s->sh.slice_type != HEVC_SLICE_I) ||
            (s->avctx->skip_frame >= AVDISCARD_NONKEY && !IS_IRAP(s))) {
            break;
         }
 
         if (s->sh.first_slice_in_pic_flag) {
             if (s->max_ra == INT_MAX) {
                 if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {
                     s->max_ra = s->poc;
                } else {
                    if (IS_IDR(s))
                        s->max_ra = INT_MIN;
                }
            }

            if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&
                s->poc <= s->max_ra) {
                s->is_decoded = 0;
                break;
            } else {
                if (s->nal_unit_type == HEVC_NAL_RASL_R && s->poc > s->max_ra)
                    s->max_ra = INT_MIN;
            }

            s->overlap ++;
            ret = hevc_frame_start(s);
            if (ret < 0)
                return ret;
        } else if (!s->ref) {
            av_log(s->avctx, AV_LOG_ERROR, ""First slice in a frame missing.\n"");
            goto fail;
        }

        if (s->nal_unit_type != s->first_nal_type) {
            av_log(s->avctx, AV_LOG_ERROR,
                   ""Non-matching NAL types of the VCL NALUs: %d %d\n"",
                   s->first_nal_type, s->nal_unit_type);
            return AVERROR_INVALIDDATA;
        }

        if (!s->sh.dependent_slice_segment_flag &&
            s->sh.slice_type != HEVC_SLICE_I) {
            ret = ff_hevc_slice_rpl(s);
            if (ret < 0) {
                av_log(s->avctx, AV_LOG_WARNING,
                       ""Error constructing the reference lists for the current slice.\n"");
                goto fail;
            }
        }

        if (s->sh.first_slice_in_pic_flag && s->avctx->hwaccel) {
            ret = s->avctx->hwaccel->start_frame(s->avctx, NULL, 0);
            if (ret < 0)
                goto fail;
        }

        if (s->avctx->hwaccel) {
            ret = s->avctx->hwaccel->decode_slice(s->avctx, nal->raw_data, nal->raw_size);
            if (ret < 0)
                goto fail;
        } else {
            if (s->threads_number > 1 && s->sh.num_entry_point_offsets > 0)
                ctb_addr_ts = hls_slice_data_wpp(s, nal);
            else
                ctb_addr_ts = hls_slice_data(s);
            if (ctb_addr_ts >= (s->ps.sps->ctb_width * s->ps.sps->ctb_height)) {
                s->is_decoded = 1;
            }

            if (ctb_addr_ts < 0) {
                ret = ctb_addr_ts;
                goto fail;
            }
        }
        break;
    case HEVC_NAL_EOS_NUT:
    case HEVC_NAL_EOB_NUT:
        s->seq_decode = (s->seq_decode + 1) & 0xff;
        s->max_ra     = INT_MAX;
        break;
    case HEVC_NAL_AUD:
    case HEVC_NAL_FD_NUT:
        break;
    default:
        av_log(s->avctx, AV_LOG_INFO,
               ""Skipping NAL unit %d\n"", s->nal_unit_type);
    }

    return 0;
fail:
    if (s->avctx->err_recognition & AV_EF_EXPLODE)
        return ret;
    return 0;
}
","static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)
{
    HEVCLocalContext *lc = s->HEVClc;
    GetBitContext *gb    = &lc->gb;
    int ctb_addr_ts, ret;

    *gb              = nal->gb;
    s->nal_unit_type = nal->type;
    s->temporal_id   = nal->temporal_id;

    switch (s->nal_unit_type) {
    case HEVC_NAL_VPS:
        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
            ret = s->avctx->hwaccel->decode_params(s->avctx,
                                                   nal->type,
                                                   nal->raw_data,
                                                   nal->raw_size);
            if (ret < 0)
                goto fail;
        }
        ret = ff_hevc_decode_nal_vps(gb, s->avctx, &s->ps);
        if (ret < 0)
            goto fail;
        break;
    case HEVC_NAL_SPS:
        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
            ret = s->avctx->hwaccel->decode_params(s->avctx,
                                                   nal->type,
                                                   nal->raw_data,
                                                   nal->raw_size);
            if (ret < 0)
                goto fail;
        }
        ret = ff_hevc_decode_nal_sps(gb, s->avctx, &s->ps,
                                     s->apply_defdispwin);
        if (ret < 0)
            goto fail;
        break;
    case HEVC_NAL_PPS:
        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
            ret = s->avctx->hwaccel->decode_params(s->avctx,
                                                   nal->type,
                                                   nal->raw_data,
                                                   nal->raw_size);
            if (ret < 0)
                goto fail;
        }
        ret = ff_hevc_decode_nal_pps(gb, s->avctx, &s->ps);
        if (ret < 0)
            goto fail;
        break;
    case HEVC_NAL_SEI_PREFIX:
    case HEVC_NAL_SEI_SUFFIX:
        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
            ret = s->avctx->hwaccel->decode_params(s->avctx,
                                                   nal->type,
                                                   nal->raw_data,
                                                   nal->raw_size);
            if (ret < 0)
                goto fail;
        }
        ret = ff_hevc_decode_nal_sei(gb, s->avctx, &s->sei, &s->ps, s->nal_unit_type);
        if (ret < 0)
            goto fail;
        break;
    case HEVC_NAL_TRAIL_R:
    case HEVC_NAL_TRAIL_N:
    case HEVC_NAL_TSA_N:
    case HEVC_NAL_TSA_R:
    case HEVC_NAL_STSA_N:
    case HEVC_NAL_STSA_R:
    case HEVC_NAL_BLA_W_LP:
    case HEVC_NAL_BLA_W_RADL:
    case HEVC_NAL_BLA_N_LP:
    case HEVC_NAL_IDR_W_RADL:
    case HEVC_NAL_IDR_N_LP:
    case HEVC_NAL_CRA_NUT:
    case HEVC_NAL_RADL_N:
    case HEVC_NAL_RADL_R:
    case HEVC_NAL_RASL_N:
    case HEVC_NAL_RASL_R:
         ret = hls_slice_header(s);
         if (ret < 0)
             return ret;
 
         if (
             (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||
            (s->avctx->skip_frame >= AVDISCARD_NONINTRA && s->sh.slice_type != HEVC_SLICE_I) ||
            (s->avctx->skip_frame >= AVDISCARD_NONKEY && !IS_IRAP(s))) {
            break;
         }
 
         if (s->sh.first_slice_in_pic_flag) {
            if (s->ref) {
                av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");
                goto fail;
            }
             if (s->max_ra == INT_MAX) {
                 if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {
                     s->max_ra = s->poc;
                } else {
                    if (IS_IDR(s))
                        s->max_ra = INT_MIN;
                }
            }

            if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&
                s->poc <= s->max_ra) {
                s->is_decoded = 0;
                break;
            } else {
                if (s->nal_unit_type == HEVC_NAL_RASL_R && s->poc > s->max_ra)
                    s->max_ra = INT_MIN;
            }

            s->overlap ++;
            ret = hevc_frame_start(s);
            if (ret < 0)
                return ret;
        } else if (!s->ref) {
            av_log(s->avctx, AV_LOG_ERROR, ""First slice in a frame missing.\n"");
            goto fail;
        }

        if (s->nal_unit_type != s->first_nal_type) {
            av_log(s->avctx, AV_LOG_ERROR,
                   ""Non-matching NAL types of the VCL NALUs: %d %d\n"",
                   s->first_nal_type, s->nal_unit_type);
            return AVERROR_INVALIDDATA;
        }

        if (!s->sh.dependent_slice_segment_flag &&
            s->sh.slice_type != HEVC_SLICE_I) {
            ret = ff_hevc_slice_rpl(s);
            if (ret < 0) {
                av_log(s->avctx, AV_LOG_WARNING,
                       ""Error constructing the reference lists for the current slice.\n"");
                goto fail;
            }
        }

        if (s->sh.first_slice_in_pic_flag && s->avctx->hwaccel) {
            ret = s->avctx->hwaccel->start_frame(s->avctx, NULL, 0);
            if (ret < 0)
                goto fail;
        }

        if (s->avctx->hwaccel) {
            ret = s->avctx->hwaccel->decode_slice(s->avctx, nal->raw_data, nal->raw_size);
            if (ret < 0)
                goto fail;
        } else {
            if (s->threads_number > 1 && s->sh.num_entry_point_offsets > 0)
                ctb_addr_ts = hls_slice_data_wpp(s, nal);
            else
                ctb_addr_ts = hls_slice_data(s);
            if (ctb_addr_ts >= (s->ps.sps->ctb_width * s->ps.sps->ctb_height)) {
                s->is_decoded = 1;
            }

            if (ctb_addr_ts < 0) {
                ret = ctb_addr_ts;
                goto fail;
            }
        }
        break;
    case HEVC_NAL_EOS_NUT:
    case HEVC_NAL_EOB_NUT:
        s->seq_decode = (s->seq_decode + 1) & 0xff;
        s->max_ra     = INT_MAX;
        break;
    case HEVC_NAL_AUD:
    case HEVC_NAL_FD_NUT:
        break;
    default:
        av_log(s->avctx, AV_LOG_INFO,
               ""Skipping NAL unit %d\n"", s->nal_unit_type);
    }

    return 0;
fail:
    if (s->avctx->err_recognition & AV_EF_EXPLODE)
        return ret;
    return 0;
}
",C,"        if (ret == 1) {
            ret = AVERROR_INVALIDDATA;
            goto fail;
        }

","            if (s->ref) {
                av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");
                goto fail;
            }
",,"@@ -488,6 +488,11 @@ static int hls_slice_header(HEVCContext *s)
 
     // Coded parameters
     sh->first_slice_in_pic_flag = get_bits1(gb);
+    if (s->ref && sh->first_slice_in_pic_flag) {
+        av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");
+        return 1; // This slice will be skiped later, do not corrupt state
+    }
+
     if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {
         s->seq_decode = (s->seq_decode + 1) & 0xff;
         s->max_ra     = INT_MAX;
@@ -2918,6 +2923,11 @@ static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)
         ret = hls_slice_header(s);
         if (ret < 0)
             return ret;
+        if (ret == 1) {
+            ret = AVERROR_INVALIDDATA;
+            goto fail;
+        }
+
 
         if (
             (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||
@@ -2927,10 +2937,6 @@ static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)
         }
 
         if (s->sh.first_slice_in_pic_flag) {
-            if (s->ref) {
-                av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");
-                goto fail;
-            }
             if (s->max_ra == INT_MAX) {
                 if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {
                     s->max_ra = s->poc;",FFmpeg,54655623a82632e7624714d7b2a3e039dc5faa7e,681957b88d18f51d0f52add4f7bb1c9fc5d8323b,1,"static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)
{
    HEVCLocalContext *lc = s->HEVClc;
    GetBitContext *gb    = &lc->gb;
    int ctb_addr_ts, ret;

    *gb              = nal->gb;
    s->nal_unit_type = nal->type;
    s->temporal_id   = nal->temporal_id;

    switch (s->nal_unit_type) {
    case HEVC_NAL_VPS:
        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
            ret = s->avctx->hwaccel->decode_params(s->avctx,
                                                   nal->type,
                                                   nal->raw_data,
                                                   nal->raw_size);
            if (ret < 0)
                goto fail;
        }
        ret = ff_hevc_decode_nal_vps(gb, s->avctx, &s->ps);
        if (ret < 0)
            goto fail;
        break;
    case HEVC_NAL_SPS:
        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
            ret = s->avctx->hwaccel->decode_params(s->avctx,
                                                   nal->type,
                                                   nal->raw_data,
                                                   nal->raw_size);
            if (ret < 0)
                goto fail;
        }
        ret = ff_hevc_decode_nal_sps(gb, s->avctx, &s->ps,
                                     s->apply_defdispwin);
        if (ret < 0)
            goto fail;
        break;
    case HEVC_NAL_PPS:
        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
            ret = s->avctx->hwaccel->decode_params(s->avctx,
                                                   nal->type,
                                                   nal->raw_data,
                                                   nal->raw_size);
            if (ret < 0)
                goto fail;
        }
        ret = ff_hevc_decode_nal_pps(gb, s->avctx, &s->ps);
        if (ret < 0)
            goto fail;
        break;
    case HEVC_NAL_SEI_PREFIX:
    case HEVC_NAL_SEI_SUFFIX:
        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
            ret = s->avctx->hwaccel->decode_params(s->avctx,
                                                   nal->type,
                                                   nal->raw_data,
                                                   nal->raw_size);
            if (ret < 0)
                goto fail;
        }
        ret = ff_hevc_decode_nal_sei(gb, s->avctx, &s->sei, &s->ps, s->nal_unit_type);
        if (ret < 0)
            goto fail;
        break;
    case HEVC_NAL_TRAIL_R:
    case HEVC_NAL_TRAIL_N:
    case HEVC_NAL_TSA_N:
    case HEVC_NAL_TSA_R:
    case HEVC_NAL_STSA_N:
    case HEVC_NAL_STSA_R:
    case HEVC_NAL_BLA_W_LP:
    case HEVC_NAL_BLA_W_RADL:
    case HEVC_NAL_BLA_N_LP:
    case HEVC_NAL_IDR_W_RADL:
    case HEVC_NAL_IDR_N_LP:
    case HEVC_NAL_CRA_NUT:
    case HEVC_NAL_RADL_N:
    case HEVC_NAL_RADL_R:
    case HEVC_NAL_RASL_N:
    case HEVC_NAL_RASL_R:
         ret = hls_slice_header(s);
         if (ret < 0)
             return ret;
//fix_flaw_line_below:
//        if (ret == 1) {
//fix_flaw_line_below:
//            ret = AVERROR_INVALIDDATA;
//fix_flaw_line_below:
//            goto fail;
//fix_flaw_line_below:
//        }
//fix_flaw_line_below:
//
 
         if (
             (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||
            (s->avctx->skip_frame >= AVDISCARD_NONINTRA && s->sh.slice_type != HEVC_SLICE_I) ||
            (s->avctx->skip_frame >= AVDISCARD_NONKEY && !IS_IRAP(s))) {
            break;
         }
 
         if (s->sh.first_slice_in_pic_flag) {
//flaw_line_below:
            if (s->ref) {
//flaw_line_below:
                av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");
//flaw_line_below:
                goto fail;
//flaw_line_below:
            }
             if (s->max_ra == INT_MAX) {
                 if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {
                     s->max_ra = s->poc;
                } else {
                    if (IS_IDR(s))
                        s->max_ra = INT_MIN;
                }
            }

            if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&
                s->poc <= s->max_ra) {
                s->is_decoded = 0;
                break;
            } else {
                if (s->nal_unit_type == HEVC_NAL_RASL_R && s->poc > s->max_ra)
                    s->max_ra = INT_MIN;
            }

            s->overlap ++;
            ret = hevc_frame_start(s);
            if (ret < 0)
                return ret;
        } else if (!s->ref) {
            av_log(s->avctx, AV_LOG_ERROR, ""First slice in a frame missing.\n"");
            goto fail;
        }

        if (s->nal_unit_type != s->first_nal_type) {
            av_log(s->avctx, AV_LOG_ERROR,
                   ""Non-matching NAL types of the VCL NALUs: %d %d\n"",
                   s->first_nal_type, s->nal_unit_type);
            return AVERROR_INVALIDDATA;
        }

        if (!s->sh.dependent_slice_segment_flag &&
            s->sh.slice_type != HEVC_SLICE_I) {
            ret = ff_hevc_slice_rpl(s);
            if (ret < 0) {
                av_log(s->avctx, AV_LOG_WARNING,
                       ""Error constructing the reference lists for the current slice.\n"");
                goto fail;
            }
        }

        if (s->sh.first_slice_in_pic_flag && s->avctx->hwaccel) {
            ret = s->avctx->hwaccel->start_frame(s->avctx, NULL, 0);
            if (ret < 0)
                goto fail;
        }

        if (s->avctx->hwaccel) {
            ret = s->avctx->hwaccel->decode_slice(s->avctx, nal->raw_data, nal->raw_size);
            if (ret < 0)
                goto fail;
        } else {
            if (s->threads_number > 1 && s->sh.num_entry_point_offsets > 0)
                ctb_addr_ts = hls_slice_data_wpp(s, nal);
            else
                ctb_addr_ts = hls_slice_data(s);
            if (ctb_addr_ts >= (s->ps.sps->ctb_width * s->ps.sps->ctb_height)) {
                s->is_decoded = 1;
            }

            if (ctb_addr_ts < 0) {
                ret = ctb_addr_ts;
                goto fail;
            }
        }
        break;
    case HEVC_NAL_EOS_NUT:
    case HEVC_NAL_EOB_NUT:
        s->seq_decode = (s->seq_decode + 1) & 0xff;
        s->max_ra     = INT_MAX;
        break;
    case HEVC_NAL_AUD:
    case HEVC_NAL_FD_NUT:
        break;
    default:
        av_log(s->avctx, AV_LOG_INFO,
               ""Skipping NAL unit %d\n"", s->nal_unit_type);
    }

    return 0;
fail:
    if (s->avctx->err_recognition & AV_EF_EXPLODE)
        return ret;
    return 0;
}
"
5143,182879,,Remote,Not required,Partial,CVE-2019-11338,https://www.cvedetails.com/cve/CVE-2019-11338/,CWE-476,Medium,Partial,Partial,,2019-04-18,6.8,"libavcodec/hevcdec.c in FFmpeg 4.1.2 mishandles detection of duplicate first slices, which allows remote attackers to cause a denial of service (NULL pointer dereference and out-of-array access) or possibly have unspecified other impact via crafted HEVC data.",2019-05-29,DoS ,5,https://github.com/FFmpeg/FFmpeg/commit/54655623a82632e7624714d7b2a3e039dc5faa7e,54655623a82632e7624714d7b2a3e039dc5faa7e,"avcodec/hevcdec: Avoid only partly skiping duplicate first slices

Fixes: NULL pointer dereference and out of array access
Fixes: 13871/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_HEVC_fuzzer-5746167087890432
Fixes: 13845/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_HEVC_fuzzer-5650370728034304

This also fixes the return code for explode mode

Found-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/projects/ffmpeg
Reviewed-by: James Almer <jamrial@gmail.com>
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",0,libavcodec/hevcdec.c,"{""sha"": ""857c10dd122ff414b27997406ccea58e5cc2c0a5"", ""filename"": ""libavcodec/hevcdec.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 4, ""changes"": 14, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/54655623a82632e7624714d7b2a3e039dc5faa7e/libavcodec/hevcdec.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/54655623a82632e7624714d7b2a3e039dc5faa7e/libavcodec/hevcdec.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavcodec/hevcdec.c?ref=54655623a82632e7624714d7b2a3e039dc5faa7e"", ""patch"": ""@@ -488,6 +488,11 @@ static int hls_slice_header(HEVCContext *s)\n \n     // Coded parameters\n     sh->first_slice_in_pic_flag = get_bits1(gb);\n+    if (s->ref && sh->first_slice_in_pic_flag) {\n+        av_log(s->avctx, AV_LOG_ERROR, \""Two slices reporting being the first in the same frame.\\n\"");\n+        return 1; // This slice will be skiped later, do not corrupt state\n+    }\n+\n     if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {\n         s->seq_decode = (s->seq_decode + 1) & 0xff;\n         s->max_ra     = INT_MAX;\n@@ -2918,6 +2923,11 @@ static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)\n         ret = hls_slice_header(s);\n         if (ret < 0)\n             return ret;\n+        if (ret == 1) {\n+            ret = AVERROR_INVALIDDATA;\n+            goto fail;\n+        }\n+\n \n         if (\n             (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||\n@@ -2927,10 +2937,6 @@ static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)\n         }\n \n         if (s->sh.first_slice_in_pic_flag) {\n-            if (s->ref) {\n-                av_log(s->avctx, AV_LOG_ERROR, \""Two slices reporting being the first in the same frame.\\n\"");\n-                goto fail;\n-            }\n             if (s->max_ra == INT_MAX) {\n                 if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {\n                     s->max_ra = s->poc;""}","static int hls_slice_header(HEVCContext *s)
{
    GetBitContext *gb = &s->HEVClc->gb;
    SliceHeader *sh   = &s->sh;
    int i, ret;
 
     sh->first_slice_in_pic_flag = get_bits1(gb);
    if (s->ref && sh->first_slice_in_pic_flag) {
        av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");
        return 1; // This slice will be skiped later, do not corrupt state
    }

     if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {
         s->seq_decode = (s->seq_decode + 1) & 0xff;
         s->max_ra     = INT_MAX;
        if (IS_IDR(s))
            ff_hevc_clear_refs(s);
    }
    sh->no_output_of_prior_pics_flag = 0;
    if (IS_IRAP(s))
        sh->no_output_of_prior_pics_flag = get_bits1(gb);

    sh->pps_id = get_ue_golomb_long(gb);
    if (sh->pps_id >= HEVC_MAX_PPS_COUNT || !s->ps.pps_list[sh->pps_id]) {
        av_log(s->avctx, AV_LOG_ERROR, ""PPS id out of range: %d\n"", sh->pps_id);
        return AVERROR_INVALIDDATA;
    }
    if (!sh->first_slice_in_pic_flag &&
        s->ps.pps != (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data) {
        av_log(s->avctx, AV_LOG_ERROR, ""PPS changed between slices.\n"");
        return AVERROR_INVALIDDATA;
    }
    s->ps.pps = (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data;
    if (s->nal_unit_type == HEVC_NAL_CRA_NUT && s->last_eos == 1)
        sh->no_output_of_prior_pics_flag = 1;

    if (s->ps.sps != (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data) {
        const HEVCSPS *sps = (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data;
        const HEVCSPS *last_sps = s->ps.sps;
        enum AVPixelFormat pix_fmt;

        if (last_sps && IS_IRAP(s) && s->nal_unit_type != HEVC_NAL_CRA_NUT) {
            if (sps->width != last_sps->width || sps->height != last_sps->height ||
                sps->temporal_layer[sps->max_sub_layers - 1].max_dec_pic_buffering !=
                last_sps->temporal_layer[last_sps->max_sub_layers - 1].max_dec_pic_buffering)
                sh->no_output_of_prior_pics_flag = 0;
        }
        ff_hevc_clear_refs(s);

        ret = set_sps(s, sps, sps->pix_fmt);
        if (ret < 0)
            return ret;

        pix_fmt = get_format(s, sps);
        if (pix_fmt < 0)
            return pix_fmt;
        s->avctx->pix_fmt = pix_fmt;

        s->seq_decode = (s->seq_decode + 1) & 0xff;
        s->max_ra     = INT_MAX;
    }

    sh->dependent_slice_segment_flag = 0;
    if (!sh->first_slice_in_pic_flag) {
        int slice_address_length;

        if (s->ps.pps->dependent_slice_segments_enabled_flag)
            sh->dependent_slice_segment_flag = get_bits1(gb);

        slice_address_length = av_ceil_log2(s->ps.sps->ctb_width *
                                            s->ps.sps->ctb_height);
        sh->slice_segment_addr = get_bitsz(gb, slice_address_length);
        if (sh->slice_segment_addr >= s->ps.sps->ctb_width * s->ps.sps->ctb_height) {
            av_log(s->avctx, AV_LOG_ERROR,
                   ""Invalid slice segment address: %u.\n"",
                   sh->slice_segment_addr);
            return AVERROR_INVALIDDATA;
        }

        if (!sh->dependent_slice_segment_flag) {
            sh->slice_addr = sh->slice_segment_addr;
            s->slice_idx++;
        }
    } else {
        sh->slice_segment_addr = sh->slice_addr = 0;
        s->slice_idx           = 0;
        s->slice_initialized   = 0;
    }

    if (!sh->dependent_slice_segment_flag) {
        s->slice_initialized = 0;

        for (i = 0; i < s->ps.pps->num_extra_slice_header_bits; i++)
            skip_bits(gb, 1);  // slice_reserved_undetermined_flag[]

        sh->slice_type = get_ue_golomb_long(gb);
        if (!(sh->slice_type == HEVC_SLICE_I ||
              sh->slice_type == HEVC_SLICE_P ||
              sh->slice_type == HEVC_SLICE_B)) {
            av_log(s->avctx, AV_LOG_ERROR, ""Unknown slice type: %d.\n"",
                   sh->slice_type);
            return AVERROR_INVALIDDATA;
        }
        if (IS_IRAP(s) && sh->slice_type != HEVC_SLICE_I) {
            av_log(s->avctx, AV_LOG_ERROR, ""Inter slices in an IRAP frame.\n"");
            return AVERROR_INVALIDDATA;
        }

        sh->pic_output_flag = 1;
        if (s->ps.pps->output_flag_present_flag)
            sh->pic_output_flag = get_bits1(gb);

        if (s->ps.sps->separate_colour_plane_flag)
            sh->colour_plane_id = get_bits(gb, 2);

        if (!IS_IDR(s)) {
            int poc, pos;

            sh->pic_order_cnt_lsb = get_bits(gb, s->ps.sps->log2_max_poc_lsb);
            poc = ff_hevc_compute_poc(s->ps.sps, s->pocTid0, sh->pic_order_cnt_lsb, s->nal_unit_type);
            if (!sh->first_slice_in_pic_flag && poc != s->poc) {
                av_log(s->avctx, AV_LOG_WARNING,
                       ""Ignoring POC change between slices: %d -> %d\n"", s->poc, poc);
                if (s->avctx->err_recognition & AV_EF_EXPLODE)
                    return AVERROR_INVALIDDATA;
                poc = s->poc;
            }
            s->poc = poc;

            sh->short_term_ref_pic_set_sps_flag = get_bits1(gb);
            pos = get_bits_left(gb);
            if (!sh->short_term_ref_pic_set_sps_flag) {
                ret = ff_hevc_decode_short_term_rps(gb, s->avctx, &sh->slice_rps, s->ps.sps, 1);
                if (ret < 0)
                    return ret;

                sh->short_term_rps = &sh->slice_rps;
            } else {
                int numbits, rps_idx;

                if (!s->ps.sps->nb_st_rps) {
                    av_log(s->avctx, AV_LOG_ERROR, ""No ref lists in the SPS.\n"");
                    return AVERROR_INVALIDDATA;
                }

                numbits = av_ceil_log2(s->ps.sps->nb_st_rps);
                rps_idx = numbits > 0 ? get_bits(gb, numbits) : 0;
                sh->short_term_rps = &s->ps.sps->st_rps[rps_idx];
            }
            sh->short_term_ref_pic_set_size = pos - get_bits_left(gb);

            pos = get_bits_left(gb);
            ret = decode_lt_rps(s, &sh->long_term_rps, gb);
            if (ret < 0) {
                av_log(s->avctx, AV_LOG_WARNING, ""Invalid long term RPS.\n"");
                if (s->avctx->err_recognition & AV_EF_EXPLODE)
                    return AVERROR_INVALIDDATA;
            }
            sh->long_term_ref_pic_set_size = pos - get_bits_left(gb);

            if (s->ps.sps->sps_temporal_mvp_enabled_flag)
                sh->slice_temporal_mvp_enabled_flag = get_bits1(gb);
            else
                sh->slice_temporal_mvp_enabled_flag = 0;
        } else {
            s->sh.short_term_rps = NULL;
            s->poc               = 0;
        }

        /* 8.3.1 */
        if (sh->first_slice_in_pic_flag && s->temporal_id == 0 &&
            s->nal_unit_type != HEVC_NAL_TRAIL_N &&
            s->nal_unit_type != HEVC_NAL_TSA_N   &&
            s->nal_unit_type != HEVC_NAL_STSA_N  &&
            s->nal_unit_type != HEVC_NAL_RADL_N  &&
            s->nal_unit_type != HEVC_NAL_RADL_R  &&
            s->nal_unit_type != HEVC_NAL_RASL_N  &&
            s->nal_unit_type != HEVC_NAL_RASL_R)
            s->pocTid0 = s->poc;

        if (s->ps.sps->sao_enabled) {
            sh->slice_sample_adaptive_offset_flag[0] = get_bits1(gb);
            if (s->ps.sps->chroma_format_idc) {
                sh->slice_sample_adaptive_offset_flag[1] =
                sh->slice_sample_adaptive_offset_flag[2] = get_bits1(gb);
            }
        } else {
            sh->slice_sample_adaptive_offset_flag[0] = 0;
            sh->slice_sample_adaptive_offset_flag[1] = 0;
            sh->slice_sample_adaptive_offset_flag[2] = 0;
        }

        sh->nb_refs[L0] = sh->nb_refs[L1] = 0;
        if (sh->slice_type == HEVC_SLICE_P || sh->slice_type == HEVC_SLICE_B) {
            int nb_refs;

            sh->nb_refs[L0] = s->ps.pps->num_ref_idx_l0_default_active;
            if (sh->slice_type == HEVC_SLICE_B)
                sh->nb_refs[L1] = s->ps.pps->num_ref_idx_l1_default_active;

            if (get_bits1(gb)) { // num_ref_idx_active_override_flag
                sh->nb_refs[L0] = get_ue_golomb_long(gb) + 1;
                if (sh->slice_type == HEVC_SLICE_B)
                    sh->nb_refs[L1] = get_ue_golomb_long(gb) + 1;
            }
            if (sh->nb_refs[L0] > HEVC_MAX_REFS || sh->nb_refs[L1] > HEVC_MAX_REFS) {
                av_log(s->avctx, AV_LOG_ERROR, ""Too many refs: %d/%d.\n"",
                       sh->nb_refs[L0], sh->nb_refs[L1]);
                return AVERROR_INVALIDDATA;
            }

            sh->rpl_modification_flag[0] = 0;
            sh->rpl_modification_flag[1] = 0;
            nb_refs = ff_hevc_frame_nb_refs(s);
            if (!nb_refs) {
                av_log(s->avctx, AV_LOG_ERROR, ""Zero refs for a frame with P or B slices.\n"");
                return AVERROR_INVALIDDATA;
            }

            if (s->ps.pps->lists_modification_present_flag && nb_refs > 1) {
                sh->rpl_modification_flag[0] = get_bits1(gb);
                if (sh->rpl_modification_flag[0]) {
                    for (i = 0; i < sh->nb_refs[L0]; i++)
                        sh->list_entry_lx[0][i] = get_bits(gb, av_ceil_log2(nb_refs));
                }

                if (sh->slice_type == HEVC_SLICE_B) {
                    sh->rpl_modification_flag[1] = get_bits1(gb);
                    if (sh->rpl_modification_flag[1] == 1)
                        for (i = 0; i < sh->nb_refs[L1]; i++)
                            sh->list_entry_lx[1][i] = get_bits(gb, av_ceil_log2(nb_refs));
                }
            }

            if (sh->slice_type == HEVC_SLICE_B)
                sh->mvd_l1_zero_flag = get_bits1(gb);

            if (s->ps.pps->cabac_init_present_flag)
                sh->cabac_init_flag = get_bits1(gb);
            else
                sh->cabac_init_flag = 0;

            sh->collocated_ref_idx = 0;
            if (sh->slice_temporal_mvp_enabled_flag) {
                sh->collocated_list = L0;
                if (sh->slice_type == HEVC_SLICE_B)
                    sh->collocated_list = !get_bits1(gb);

                if (sh->nb_refs[sh->collocated_list] > 1) {
                    sh->collocated_ref_idx = get_ue_golomb_long(gb);
                    if (sh->collocated_ref_idx >= sh->nb_refs[sh->collocated_list]) {
                        av_log(s->avctx, AV_LOG_ERROR,
                               ""Invalid collocated_ref_idx: %d.\n"",
                               sh->collocated_ref_idx);
                        return AVERROR_INVALIDDATA;
                    }
                }
            }

            if ((s->ps.pps->weighted_pred_flag   && sh->slice_type == HEVC_SLICE_P) ||
                (s->ps.pps->weighted_bipred_flag && sh->slice_type == HEVC_SLICE_B)) {
                int ret = pred_weight_table(s, gb);
                if (ret < 0)
                    return ret;
            }

            sh->max_num_merge_cand = 5 - get_ue_golomb_long(gb);
            if (sh->max_num_merge_cand < 1 || sh->max_num_merge_cand > 5) {
                av_log(s->avctx, AV_LOG_ERROR,
                       ""Invalid number of merging MVP candidates: %d.\n"",
                       sh->max_num_merge_cand);
                return AVERROR_INVALIDDATA;
            }
        }

        sh->slice_qp_delta = get_se_golomb(gb);

        if (s->ps.pps->pic_slice_level_chroma_qp_offsets_present_flag) {
            sh->slice_cb_qp_offset = get_se_golomb(gb);
            sh->slice_cr_qp_offset = get_se_golomb(gb);
        } else {
            sh->slice_cb_qp_offset = 0;
            sh->slice_cr_qp_offset = 0;
        }

        if (s->ps.pps->chroma_qp_offset_list_enabled_flag)
            sh->cu_chroma_qp_offset_enabled_flag = get_bits1(gb);
        else
            sh->cu_chroma_qp_offset_enabled_flag = 0;

        if (s->ps.pps->deblocking_filter_control_present_flag) {
            int deblocking_filter_override_flag = 0;

            if (s->ps.pps->deblocking_filter_override_enabled_flag)
                deblocking_filter_override_flag = get_bits1(gb);

            if (deblocking_filter_override_flag) {
                sh->disable_deblocking_filter_flag = get_bits1(gb);
                if (!sh->disable_deblocking_filter_flag) {
                    int beta_offset_div2 = get_se_golomb(gb);
                    int tc_offset_div2   = get_se_golomb(gb) ;
                    if (beta_offset_div2 < -6 || beta_offset_div2 > 6 ||
                        tc_offset_div2   < -6 || tc_offset_div2   > 6) {
                        av_log(s->avctx, AV_LOG_ERROR,
                            ""Invalid deblock filter offsets: %d, %d\n"",
                            beta_offset_div2, tc_offset_div2);
                        return AVERROR_INVALIDDATA;
                    }
                    sh->beta_offset = beta_offset_div2 * 2;
                    sh->tc_offset   =   tc_offset_div2 * 2;
                }
            } else {
                sh->disable_deblocking_filter_flag = s->ps.pps->disable_dbf;
                sh->beta_offset                    = s->ps.pps->beta_offset;
                sh->tc_offset                      = s->ps.pps->tc_offset;
            }
        } else {
            sh->disable_deblocking_filter_flag = 0;
            sh->beta_offset                    = 0;
            sh->tc_offset                      = 0;
        }

        if (s->ps.pps->seq_loop_filter_across_slices_enabled_flag &&
            (sh->slice_sample_adaptive_offset_flag[0] ||
             sh->slice_sample_adaptive_offset_flag[1] ||
             !sh->disable_deblocking_filter_flag)) {
            sh->slice_loop_filter_across_slices_enabled_flag = get_bits1(gb);
        } else {
            sh->slice_loop_filter_across_slices_enabled_flag = s->ps.pps->seq_loop_filter_across_slices_enabled_flag;
        }
    } else if (!s->slice_initialized) {
        av_log(s->avctx, AV_LOG_ERROR, ""Independent slice segment missing.\n"");
        return AVERROR_INVALIDDATA;
    }

    sh->num_entry_point_offsets = 0;
    if (s->ps.pps->tiles_enabled_flag || s->ps.pps->entropy_coding_sync_enabled_flag) {
        unsigned num_entry_point_offsets = get_ue_golomb_long(gb);
        if (num_entry_point_offsets > get_bits_left(gb)) {
            av_log(s->avctx, AV_LOG_ERROR, ""num_entry_point_offsets %d is invalid\n"", num_entry_point_offsets);
            return AVERROR_INVALIDDATA;
        }

        sh->num_entry_point_offsets = num_entry_point_offsets;
        if (sh->num_entry_point_offsets > 0) {
            int offset_len = get_ue_golomb_long(gb) + 1;

            if (offset_len < 1 || offset_len > 32) {
                sh->num_entry_point_offsets = 0;
                av_log(s->avctx, AV_LOG_ERROR, ""offset_len %d is invalid\n"", offset_len);
                return AVERROR_INVALIDDATA;
            }

            av_freep(&sh->entry_point_offset);
            av_freep(&sh->offset);
            av_freep(&sh->size);
            sh->entry_point_offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(unsigned));
            sh->offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));
            sh->size = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));
            if (!sh->entry_point_offset || !sh->offset || !sh->size) {
                sh->num_entry_point_offsets = 0;
                av_log(s->avctx, AV_LOG_ERROR, ""Failed to allocate memory\n"");
                return AVERROR(ENOMEM);
            }
            for (i = 0; i < sh->num_entry_point_offsets; i++) {
                unsigned val = get_bits_long(gb, offset_len);
                sh->entry_point_offset[i] = val + 1; // +1; // +1 to get the size
            }
            if (s->threads_number > 1 && (s->ps.pps->num_tile_rows > 1 || s->ps.pps->num_tile_columns > 1)) {
                s->enable_parallel_tiles = 0; // TODO: you can enable tiles in parallel here
                s->threads_number = 1;
            } else
                s->enable_parallel_tiles = 0;
        } else
            s->enable_parallel_tiles = 0;
    }

    if (s->ps.pps->slice_header_extension_present_flag) {
        unsigned int length = get_ue_golomb_long(gb);
        if (length*8LL > get_bits_left(gb)) {
            av_log(s->avctx, AV_LOG_ERROR, ""too many slice_header_extension_data_bytes\n"");
            return AVERROR_INVALIDDATA;
        }
        for (i = 0; i < length; i++)
            skip_bits(gb, 8);  // slice_header_extension_data_byte
    }

    sh->slice_qp = 26U + s->ps.pps->pic_init_qp_minus26 + sh->slice_qp_delta;
    if (sh->slice_qp > 51 ||
        sh->slice_qp < -s->ps.sps->qp_bd_offset) {
        av_log(s->avctx, AV_LOG_ERROR,
               ""The slice_qp %d is outside the valid range ""
               ""[%d, 51].\n"",
               sh->slice_qp,
               -s->ps.sps->qp_bd_offset);
        return AVERROR_INVALIDDATA;
    }

    sh->slice_ctb_addr_rs = sh->slice_segment_addr;

    if (!s->sh.slice_ctb_addr_rs && s->sh.dependent_slice_segment_flag) {
        av_log(s->avctx, AV_LOG_ERROR, ""Impossible slice segment.\n"");
        return AVERROR_INVALIDDATA;
    }

    if (get_bits_left(gb) < 0) {
        av_log(s->avctx, AV_LOG_ERROR,
               ""Overread slice header by %d bits\n"", -get_bits_left(gb));
        return AVERROR_INVALIDDATA;
    }

    s->HEVClc->first_qp_group = !s->sh.dependent_slice_segment_flag;

    if (!s->ps.pps->cu_qp_delta_enabled_flag)
        s->HEVClc->qp_y = s->sh.slice_qp;

    s->slice_initialized = 1;
    s->HEVClc->tu.cu_qp_offset_cb = 0;
    s->HEVClc->tu.cu_qp_offset_cr = 0;

    return 0;
}
","static int hls_slice_header(HEVCContext *s)
{
    GetBitContext *gb = &s->HEVClc->gb;
    SliceHeader *sh   = &s->sh;
    int i, ret;
 
     sh->first_slice_in_pic_flag = get_bits1(gb);
     if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {
         s->seq_decode = (s->seq_decode + 1) & 0xff;
         s->max_ra     = INT_MAX;
        if (IS_IDR(s))
            ff_hevc_clear_refs(s);
    }
    sh->no_output_of_prior_pics_flag = 0;
    if (IS_IRAP(s))
        sh->no_output_of_prior_pics_flag = get_bits1(gb);

    sh->pps_id = get_ue_golomb_long(gb);
    if (sh->pps_id >= HEVC_MAX_PPS_COUNT || !s->ps.pps_list[sh->pps_id]) {
        av_log(s->avctx, AV_LOG_ERROR, ""PPS id out of range: %d\n"", sh->pps_id);
        return AVERROR_INVALIDDATA;
    }
    if (!sh->first_slice_in_pic_flag &&
        s->ps.pps != (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data) {
        av_log(s->avctx, AV_LOG_ERROR, ""PPS changed between slices.\n"");
        return AVERROR_INVALIDDATA;
    }
    s->ps.pps = (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data;
    if (s->nal_unit_type == HEVC_NAL_CRA_NUT && s->last_eos == 1)
        sh->no_output_of_prior_pics_flag = 1;

    if (s->ps.sps != (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data) {
        const HEVCSPS *sps = (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data;
        const HEVCSPS *last_sps = s->ps.sps;
        enum AVPixelFormat pix_fmt;

        if (last_sps && IS_IRAP(s) && s->nal_unit_type != HEVC_NAL_CRA_NUT) {
            if (sps->width != last_sps->width || sps->height != last_sps->height ||
                sps->temporal_layer[sps->max_sub_layers - 1].max_dec_pic_buffering !=
                last_sps->temporal_layer[last_sps->max_sub_layers - 1].max_dec_pic_buffering)
                sh->no_output_of_prior_pics_flag = 0;
        }
        ff_hevc_clear_refs(s);

        ret = set_sps(s, sps, sps->pix_fmt);
        if (ret < 0)
            return ret;

        pix_fmt = get_format(s, sps);
        if (pix_fmt < 0)
            return pix_fmt;
        s->avctx->pix_fmt = pix_fmt;

        s->seq_decode = (s->seq_decode + 1) & 0xff;
        s->max_ra     = INT_MAX;
    }

    sh->dependent_slice_segment_flag = 0;
    if (!sh->first_slice_in_pic_flag) {
        int slice_address_length;

        if (s->ps.pps->dependent_slice_segments_enabled_flag)
            sh->dependent_slice_segment_flag = get_bits1(gb);

        slice_address_length = av_ceil_log2(s->ps.sps->ctb_width *
                                            s->ps.sps->ctb_height);
        sh->slice_segment_addr = get_bitsz(gb, slice_address_length);
        if (sh->slice_segment_addr >= s->ps.sps->ctb_width * s->ps.sps->ctb_height) {
            av_log(s->avctx, AV_LOG_ERROR,
                   ""Invalid slice segment address: %u.\n"",
                   sh->slice_segment_addr);
            return AVERROR_INVALIDDATA;
        }

        if (!sh->dependent_slice_segment_flag) {
            sh->slice_addr = sh->slice_segment_addr;
            s->slice_idx++;
        }
    } else {
        sh->slice_segment_addr = sh->slice_addr = 0;
        s->slice_idx           = 0;
        s->slice_initialized   = 0;
    }

    if (!sh->dependent_slice_segment_flag) {
        s->slice_initialized = 0;

        for (i = 0; i < s->ps.pps->num_extra_slice_header_bits; i++)
            skip_bits(gb, 1);  // slice_reserved_undetermined_flag[]

        sh->slice_type = get_ue_golomb_long(gb);
        if (!(sh->slice_type == HEVC_SLICE_I ||
              sh->slice_type == HEVC_SLICE_P ||
              sh->slice_type == HEVC_SLICE_B)) {
            av_log(s->avctx, AV_LOG_ERROR, ""Unknown slice type: %d.\n"",
                   sh->slice_type);
            return AVERROR_INVALIDDATA;
        }
        if (IS_IRAP(s) && sh->slice_type != HEVC_SLICE_I) {
            av_log(s->avctx, AV_LOG_ERROR, ""Inter slices in an IRAP frame.\n"");
            return AVERROR_INVALIDDATA;
        }

        sh->pic_output_flag = 1;
        if (s->ps.pps->output_flag_present_flag)
            sh->pic_output_flag = get_bits1(gb);

        if (s->ps.sps->separate_colour_plane_flag)
            sh->colour_plane_id = get_bits(gb, 2);

        if (!IS_IDR(s)) {
            int poc, pos;

            sh->pic_order_cnt_lsb = get_bits(gb, s->ps.sps->log2_max_poc_lsb);
            poc = ff_hevc_compute_poc(s->ps.sps, s->pocTid0, sh->pic_order_cnt_lsb, s->nal_unit_type);
            if (!sh->first_slice_in_pic_flag && poc != s->poc) {
                av_log(s->avctx, AV_LOG_WARNING,
                       ""Ignoring POC change between slices: %d -> %d\n"", s->poc, poc);
                if (s->avctx->err_recognition & AV_EF_EXPLODE)
                    return AVERROR_INVALIDDATA;
                poc = s->poc;
            }
            s->poc = poc;

            sh->short_term_ref_pic_set_sps_flag = get_bits1(gb);
            pos = get_bits_left(gb);
            if (!sh->short_term_ref_pic_set_sps_flag) {
                ret = ff_hevc_decode_short_term_rps(gb, s->avctx, &sh->slice_rps, s->ps.sps, 1);
                if (ret < 0)
                    return ret;

                sh->short_term_rps = &sh->slice_rps;
            } else {
                int numbits, rps_idx;

                if (!s->ps.sps->nb_st_rps) {
                    av_log(s->avctx, AV_LOG_ERROR, ""No ref lists in the SPS.\n"");
                    return AVERROR_INVALIDDATA;
                }

                numbits = av_ceil_log2(s->ps.sps->nb_st_rps);
                rps_idx = numbits > 0 ? get_bits(gb, numbits) : 0;
                sh->short_term_rps = &s->ps.sps->st_rps[rps_idx];
            }
            sh->short_term_ref_pic_set_size = pos - get_bits_left(gb);

            pos = get_bits_left(gb);
            ret = decode_lt_rps(s, &sh->long_term_rps, gb);
            if (ret < 0) {
                av_log(s->avctx, AV_LOG_WARNING, ""Invalid long term RPS.\n"");
                if (s->avctx->err_recognition & AV_EF_EXPLODE)
                    return AVERROR_INVALIDDATA;
            }
            sh->long_term_ref_pic_set_size = pos - get_bits_left(gb);

            if (s->ps.sps->sps_temporal_mvp_enabled_flag)
                sh->slice_temporal_mvp_enabled_flag = get_bits1(gb);
            else
                sh->slice_temporal_mvp_enabled_flag = 0;
        } else {
            s->sh.short_term_rps = NULL;
            s->poc               = 0;
        }

        /* 8.3.1 */
        if (sh->first_slice_in_pic_flag && s->temporal_id == 0 &&
            s->nal_unit_type != HEVC_NAL_TRAIL_N &&
            s->nal_unit_type != HEVC_NAL_TSA_N   &&
            s->nal_unit_type != HEVC_NAL_STSA_N  &&
            s->nal_unit_type != HEVC_NAL_RADL_N  &&
            s->nal_unit_type != HEVC_NAL_RADL_R  &&
            s->nal_unit_type != HEVC_NAL_RASL_N  &&
            s->nal_unit_type != HEVC_NAL_RASL_R)
            s->pocTid0 = s->poc;

        if (s->ps.sps->sao_enabled) {
            sh->slice_sample_adaptive_offset_flag[0] = get_bits1(gb);
            if (s->ps.sps->chroma_format_idc) {
                sh->slice_sample_adaptive_offset_flag[1] =
                sh->slice_sample_adaptive_offset_flag[2] = get_bits1(gb);
            }
        } else {
            sh->slice_sample_adaptive_offset_flag[0] = 0;
            sh->slice_sample_adaptive_offset_flag[1] = 0;
            sh->slice_sample_adaptive_offset_flag[2] = 0;
        }

        sh->nb_refs[L0] = sh->nb_refs[L1] = 0;
        if (sh->slice_type == HEVC_SLICE_P || sh->slice_type == HEVC_SLICE_B) {
            int nb_refs;

            sh->nb_refs[L0] = s->ps.pps->num_ref_idx_l0_default_active;
            if (sh->slice_type == HEVC_SLICE_B)
                sh->nb_refs[L1] = s->ps.pps->num_ref_idx_l1_default_active;

            if (get_bits1(gb)) { // num_ref_idx_active_override_flag
                sh->nb_refs[L0] = get_ue_golomb_long(gb) + 1;
                if (sh->slice_type == HEVC_SLICE_B)
                    sh->nb_refs[L1] = get_ue_golomb_long(gb) + 1;
            }
            if (sh->nb_refs[L0] > HEVC_MAX_REFS || sh->nb_refs[L1] > HEVC_MAX_REFS) {
                av_log(s->avctx, AV_LOG_ERROR, ""Too many refs: %d/%d.\n"",
                       sh->nb_refs[L0], sh->nb_refs[L1]);
                return AVERROR_INVALIDDATA;
            }

            sh->rpl_modification_flag[0] = 0;
            sh->rpl_modification_flag[1] = 0;
            nb_refs = ff_hevc_frame_nb_refs(s);
            if (!nb_refs) {
                av_log(s->avctx, AV_LOG_ERROR, ""Zero refs for a frame with P or B slices.\n"");
                return AVERROR_INVALIDDATA;
            }

            if (s->ps.pps->lists_modification_present_flag && nb_refs > 1) {
                sh->rpl_modification_flag[0] = get_bits1(gb);
                if (sh->rpl_modification_flag[0]) {
                    for (i = 0; i < sh->nb_refs[L0]; i++)
                        sh->list_entry_lx[0][i] = get_bits(gb, av_ceil_log2(nb_refs));
                }

                if (sh->slice_type == HEVC_SLICE_B) {
                    sh->rpl_modification_flag[1] = get_bits1(gb);
                    if (sh->rpl_modification_flag[1] == 1)
                        for (i = 0; i < sh->nb_refs[L1]; i++)
                            sh->list_entry_lx[1][i] = get_bits(gb, av_ceil_log2(nb_refs));
                }
            }

            if (sh->slice_type == HEVC_SLICE_B)
                sh->mvd_l1_zero_flag = get_bits1(gb);

            if (s->ps.pps->cabac_init_present_flag)
                sh->cabac_init_flag = get_bits1(gb);
            else
                sh->cabac_init_flag = 0;

            sh->collocated_ref_idx = 0;
            if (sh->slice_temporal_mvp_enabled_flag) {
                sh->collocated_list = L0;
                if (sh->slice_type == HEVC_SLICE_B)
                    sh->collocated_list = !get_bits1(gb);

                if (sh->nb_refs[sh->collocated_list] > 1) {
                    sh->collocated_ref_idx = get_ue_golomb_long(gb);
                    if (sh->collocated_ref_idx >= sh->nb_refs[sh->collocated_list]) {
                        av_log(s->avctx, AV_LOG_ERROR,
                               ""Invalid collocated_ref_idx: %d.\n"",
                               sh->collocated_ref_idx);
                        return AVERROR_INVALIDDATA;
                    }
                }
            }

            if ((s->ps.pps->weighted_pred_flag   && sh->slice_type == HEVC_SLICE_P) ||
                (s->ps.pps->weighted_bipred_flag && sh->slice_type == HEVC_SLICE_B)) {
                int ret = pred_weight_table(s, gb);
                if (ret < 0)
                    return ret;
            }

            sh->max_num_merge_cand = 5 - get_ue_golomb_long(gb);
            if (sh->max_num_merge_cand < 1 || sh->max_num_merge_cand > 5) {
                av_log(s->avctx, AV_LOG_ERROR,
                       ""Invalid number of merging MVP candidates: %d.\n"",
                       sh->max_num_merge_cand);
                return AVERROR_INVALIDDATA;
            }
        }

        sh->slice_qp_delta = get_se_golomb(gb);

        if (s->ps.pps->pic_slice_level_chroma_qp_offsets_present_flag) {
            sh->slice_cb_qp_offset = get_se_golomb(gb);
            sh->slice_cr_qp_offset = get_se_golomb(gb);
        } else {
            sh->slice_cb_qp_offset = 0;
            sh->slice_cr_qp_offset = 0;
        }

        if (s->ps.pps->chroma_qp_offset_list_enabled_flag)
            sh->cu_chroma_qp_offset_enabled_flag = get_bits1(gb);
        else
            sh->cu_chroma_qp_offset_enabled_flag = 0;

        if (s->ps.pps->deblocking_filter_control_present_flag) {
            int deblocking_filter_override_flag = 0;

            if (s->ps.pps->deblocking_filter_override_enabled_flag)
                deblocking_filter_override_flag = get_bits1(gb);

            if (deblocking_filter_override_flag) {
                sh->disable_deblocking_filter_flag = get_bits1(gb);
                if (!sh->disable_deblocking_filter_flag) {
                    int beta_offset_div2 = get_se_golomb(gb);
                    int tc_offset_div2   = get_se_golomb(gb) ;
                    if (beta_offset_div2 < -6 || beta_offset_div2 > 6 ||
                        tc_offset_div2   < -6 || tc_offset_div2   > 6) {
                        av_log(s->avctx, AV_LOG_ERROR,
                            ""Invalid deblock filter offsets: %d, %d\n"",
                            beta_offset_div2, tc_offset_div2);
                        return AVERROR_INVALIDDATA;
                    }
                    sh->beta_offset = beta_offset_div2 * 2;
                    sh->tc_offset   =   tc_offset_div2 * 2;
                }
            } else {
                sh->disable_deblocking_filter_flag = s->ps.pps->disable_dbf;
                sh->beta_offset                    = s->ps.pps->beta_offset;
                sh->tc_offset                      = s->ps.pps->tc_offset;
            }
        } else {
            sh->disable_deblocking_filter_flag = 0;
            sh->beta_offset                    = 0;
            sh->tc_offset                      = 0;
        }

        if (s->ps.pps->seq_loop_filter_across_slices_enabled_flag &&
            (sh->slice_sample_adaptive_offset_flag[0] ||
             sh->slice_sample_adaptive_offset_flag[1] ||
             !sh->disable_deblocking_filter_flag)) {
            sh->slice_loop_filter_across_slices_enabled_flag = get_bits1(gb);
        } else {
            sh->slice_loop_filter_across_slices_enabled_flag = s->ps.pps->seq_loop_filter_across_slices_enabled_flag;
        }
    } else if (!s->slice_initialized) {
        av_log(s->avctx, AV_LOG_ERROR, ""Independent slice segment missing.\n"");
        return AVERROR_INVALIDDATA;
    }

    sh->num_entry_point_offsets = 0;
    if (s->ps.pps->tiles_enabled_flag || s->ps.pps->entropy_coding_sync_enabled_flag) {
        unsigned num_entry_point_offsets = get_ue_golomb_long(gb);
        if (num_entry_point_offsets > get_bits_left(gb)) {
            av_log(s->avctx, AV_LOG_ERROR, ""num_entry_point_offsets %d is invalid\n"", num_entry_point_offsets);
            return AVERROR_INVALIDDATA;
        }

        sh->num_entry_point_offsets = num_entry_point_offsets;
        if (sh->num_entry_point_offsets > 0) {
            int offset_len = get_ue_golomb_long(gb) + 1;

            if (offset_len < 1 || offset_len > 32) {
                sh->num_entry_point_offsets = 0;
                av_log(s->avctx, AV_LOG_ERROR, ""offset_len %d is invalid\n"", offset_len);
                return AVERROR_INVALIDDATA;
            }

            av_freep(&sh->entry_point_offset);
            av_freep(&sh->offset);
            av_freep(&sh->size);
            sh->entry_point_offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(unsigned));
            sh->offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));
            sh->size = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));
            if (!sh->entry_point_offset || !sh->offset || !sh->size) {
                sh->num_entry_point_offsets = 0;
                av_log(s->avctx, AV_LOG_ERROR, ""Failed to allocate memory\n"");
                return AVERROR(ENOMEM);
            }
            for (i = 0; i < sh->num_entry_point_offsets; i++) {
                unsigned val = get_bits_long(gb, offset_len);
                sh->entry_point_offset[i] = val + 1; // +1; // +1 to get the size
            }
            if (s->threads_number > 1 && (s->ps.pps->num_tile_rows > 1 || s->ps.pps->num_tile_columns > 1)) {
                s->enable_parallel_tiles = 0; // TODO: you can enable tiles in parallel here
                s->threads_number = 1;
            } else
                s->enable_parallel_tiles = 0;
        } else
            s->enable_parallel_tiles = 0;
    }

    if (s->ps.pps->slice_header_extension_present_flag) {
        unsigned int length = get_ue_golomb_long(gb);
        if (length*8LL > get_bits_left(gb)) {
            av_log(s->avctx, AV_LOG_ERROR, ""too many slice_header_extension_data_bytes\n"");
            return AVERROR_INVALIDDATA;
        }
        for (i = 0; i < length; i++)
            skip_bits(gb, 8);  // slice_header_extension_data_byte
    }

    sh->slice_qp = 26U + s->ps.pps->pic_init_qp_minus26 + sh->slice_qp_delta;
    if (sh->slice_qp > 51 ||
        sh->slice_qp < -s->ps.sps->qp_bd_offset) {
        av_log(s->avctx, AV_LOG_ERROR,
               ""The slice_qp %d is outside the valid range ""
               ""[%d, 51].\n"",
               sh->slice_qp,
               -s->ps.sps->qp_bd_offset);
        return AVERROR_INVALIDDATA;
    }

    sh->slice_ctb_addr_rs = sh->slice_segment_addr;

    if (!s->sh.slice_ctb_addr_rs && s->sh.dependent_slice_segment_flag) {
        av_log(s->avctx, AV_LOG_ERROR, ""Impossible slice segment.\n"");
        return AVERROR_INVALIDDATA;
    }

    if (get_bits_left(gb) < 0) {
        av_log(s->avctx, AV_LOG_ERROR,
               ""Overread slice header by %d bits\n"", -get_bits_left(gb));
        return AVERROR_INVALIDDATA;
    }

    s->HEVClc->first_qp_group = !s->sh.dependent_slice_segment_flag;

    if (!s->ps.pps->cu_qp_delta_enabled_flag)
        s->HEVClc->qp_y = s->sh.slice_qp;

    s->slice_initialized = 1;
    s->HEVClc->tu.cu_qp_offset_cb = 0;
    s->HEVClc->tu.cu_qp_offset_cr = 0;

    return 0;
}
",C,"    if (s->ref && sh->first_slice_in_pic_flag) {
        av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");
        return 1; // This slice will be skiped later, do not corrupt state
    }

",,,"@@ -488,6 +488,11 @@ static int hls_slice_header(HEVCContext *s)
 
     // Coded parameters
     sh->first_slice_in_pic_flag = get_bits1(gb);
+    if (s->ref && sh->first_slice_in_pic_flag) {
+        av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");
+        return 1; // This slice will be skiped later, do not corrupt state
+    }
+
     if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {
         s->seq_decode = (s->seq_decode + 1) & 0xff;
         s->max_ra     = INT_MAX;
@@ -2918,6 +2923,11 @@ static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)
         ret = hls_slice_header(s);
         if (ret < 0)
             return ret;
+        if (ret == 1) {
+            ret = AVERROR_INVALIDDATA;
+            goto fail;
+        }
+
 
         if (
             (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||
@@ -2927,10 +2937,6 @@ static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)
         }
 
         if (s->sh.first_slice_in_pic_flag) {
-            if (s->ref) {
-                av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");
-                goto fail;
-            }
             if (s->max_ra == INT_MAX) {
                 if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {
                     s->max_ra = s->poc;",FFmpeg,54655623a82632e7624714d7b2a3e039dc5faa7e,681957b88d18f51d0f52add4f7bb1c9fc5d8323b,1,"static int hls_slice_header(HEVCContext *s)
{
    GetBitContext *gb = &s->HEVClc->gb;
    SliceHeader *sh   = &s->sh;
    int i, ret;
 
     // Coded parameters
     sh->first_slice_in_pic_flag = get_bits1(gb);
//fix_flaw_line_below:
//    if (s->ref && sh->first_slice_in_pic_flag) {
//fix_flaw_line_below:
//        av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");
//fix_flaw_line_below:
//        return 1; // This slice will be skiped later, do not corrupt state
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {
         s->seq_decode = (s->seq_decode + 1) & 0xff;
         s->max_ra     = INT_MAX;
        if (IS_IDR(s))
            ff_hevc_clear_refs(s);
    }
    sh->no_output_of_prior_pics_flag = 0;
    if (IS_IRAP(s))
        sh->no_output_of_prior_pics_flag = get_bits1(gb);

    sh->pps_id = get_ue_golomb_long(gb);
    if (sh->pps_id >= HEVC_MAX_PPS_COUNT || !s->ps.pps_list[sh->pps_id]) {
        av_log(s->avctx, AV_LOG_ERROR, ""PPS id out of range: %d\n"", sh->pps_id);
        return AVERROR_INVALIDDATA;
    }
    if (!sh->first_slice_in_pic_flag &&
        s->ps.pps != (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data) {
        av_log(s->avctx, AV_LOG_ERROR, ""PPS changed between slices.\n"");
        return AVERROR_INVALIDDATA;
    }
    s->ps.pps = (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data;
    if (s->nal_unit_type == HEVC_NAL_CRA_NUT && s->last_eos == 1)
        sh->no_output_of_prior_pics_flag = 1;

    if (s->ps.sps != (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data) {
        const HEVCSPS *sps = (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data;
        const HEVCSPS *last_sps = s->ps.sps;
        enum AVPixelFormat pix_fmt;

        if (last_sps && IS_IRAP(s) && s->nal_unit_type != HEVC_NAL_CRA_NUT) {
            if (sps->width != last_sps->width || sps->height != last_sps->height ||
                sps->temporal_layer[sps->max_sub_layers - 1].max_dec_pic_buffering !=
                last_sps->temporal_layer[last_sps->max_sub_layers - 1].max_dec_pic_buffering)
                sh->no_output_of_prior_pics_flag = 0;
        }
        ff_hevc_clear_refs(s);

        ret = set_sps(s, sps, sps->pix_fmt);
        if (ret < 0)
            return ret;

        pix_fmt = get_format(s, sps);
        if (pix_fmt < 0)
            return pix_fmt;
        s->avctx->pix_fmt = pix_fmt;

        s->seq_decode = (s->seq_decode + 1) & 0xff;
        s->max_ra     = INT_MAX;
    }

    sh->dependent_slice_segment_flag = 0;
    if (!sh->first_slice_in_pic_flag) {
        int slice_address_length;

        if (s->ps.pps->dependent_slice_segments_enabled_flag)
            sh->dependent_slice_segment_flag = get_bits1(gb);

        slice_address_length = av_ceil_log2(s->ps.sps->ctb_width *
                                            s->ps.sps->ctb_height);
        sh->slice_segment_addr = get_bitsz(gb, slice_address_length);
        if (sh->slice_segment_addr >= s->ps.sps->ctb_width * s->ps.sps->ctb_height) {
            av_log(s->avctx, AV_LOG_ERROR,
                   ""Invalid slice segment address: %u.\n"",
                   sh->slice_segment_addr);
            return AVERROR_INVALIDDATA;
        }

        if (!sh->dependent_slice_segment_flag) {
            sh->slice_addr = sh->slice_segment_addr;
            s->slice_idx++;
        }
    } else {
        sh->slice_segment_addr = sh->slice_addr = 0;
        s->slice_idx           = 0;
        s->slice_initialized   = 0;
    }

    if (!sh->dependent_slice_segment_flag) {
        s->slice_initialized = 0;

        for (i = 0; i < s->ps.pps->num_extra_slice_header_bits; i++)
            skip_bits(gb, 1);  // slice_reserved_undetermined_flag[]

        sh->slice_type = get_ue_golomb_long(gb);
        if (!(sh->slice_type == HEVC_SLICE_I ||
              sh->slice_type == HEVC_SLICE_P ||
              sh->slice_type == HEVC_SLICE_B)) {
            av_log(s->avctx, AV_LOG_ERROR, ""Unknown slice type: %d.\n"",
                   sh->slice_type);
            return AVERROR_INVALIDDATA;
        }
        if (IS_IRAP(s) && sh->slice_type != HEVC_SLICE_I) {
            av_log(s->avctx, AV_LOG_ERROR, ""Inter slices in an IRAP frame.\n"");
            return AVERROR_INVALIDDATA;
        }

        // when flag is not present, picture is inferred to be output
        sh->pic_output_flag = 1;
        if (s->ps.pps->output_flag_present_flag)
            sh->pic_output_flag = get_bits1(gb);

        if (s->ps.sps->separate_colour_plane_flag)
            sh->colour_plane_id = get_bits(gb, 2);

        if (!IS_IDR(s)) {
            int poc, pos;

            sh->pic_order_cnt_lsb = get_bits(gb, s->ps.sps->log2_max_poc_lsb);
            poc = ff_hevc_compute_poc(s->ps.sps, s->pocTid0, sh->pic_order_cnt_lsb, s->nal_unit_type);
            if (!sh->first_slice_in_pic_flag && poc != s->poc) {
                av_log(s->avctx, AV_LOG_WARNING,
                       ""Ignoring POC change between slices: %d -> %d\n"", s->poc, poc);
                if (s->avctx->err_recognition & AV_EF_EXPLODE)
                    return AVERROR_INVALIDDATA;
                poc = s->poc;
            }
            s->poc = poc;

            sh->short_term_ref_pic_set_sps_flag = get_bits1(gb);
            pos = get_bits_left(gb);
            if (!sh->short_term_ref_pic_set_sps_flag) {
                ret = ff_hevc_decode_short_term_rps(gb, s->avctx, &sh->slice_rps, s->ps.sps, 1);
                if (ret < 0)
                    return ret;

                sh->short_term_rps = &sh->slice_rps;
            } else {
                int numbits, rps_idx;

                if (!s->ps.sps->nb_st_rps) {
                    av_log(s->avctx, AV_LOG_ERROR, ""No ref lists in the SPS.\n"");
                    return AVERROR_INVALIDDATA;
                }

                numbits = av_ceil_log2(s->ps.sps->nb_st_rps);
                rps_idx = numbits > 0 ? get_bits(gb, numbits) : 0;
                sh->short_term_rps = &s->ps.sps->st_rps[rps_idx];
            }
            sh->short_term_ref_pic_set_size = pos - get_bits_left(gb);

            pos = get_bits_left(gb);
            ret = decode_lt_rps(s, &sh->long_term_rps, gb);
            if (ret < 0) {
                av_log(s->avctx, AV_LOG_WARNING, ""Invalid long term RPS.\n"");
                if (s->avctx->err_recognition & AV_EF_EXPLODE)
                    return AVERROR_INVALIDDATA;
            }
            sh->long_term_ref_pic_set_size = pos - get_bits_left(gb);

            if (s->ps.sps->sps_temporal_mvp_enabled_flag)
                sh->slice_temporal_mvp_enabled_flag = get_bits1(gb);
            else
                sh->slice_temporal_mvp_enabled_flag = 0;
        } else {
            s->sh.short_term_rps = NULL;
            s->poc               = 0;
        }

        /* 8.3.1 */
        if (sh->first_slice_in_pic_flag && s->temporal_id == 0 &&
            s->nal_unit_type != HEVC_NAL_TRAIL_N &&
            s->nal_unit_type != HEVC_NAL_TSA_N   &&
            s->nal_unit_type != HEVC_NAL_STSA_N  &&
            s->nal_unit_type != HEVC_NAL_RADL_N  &&
            s->nal_unit_type != HEVC_NAL_RADL_R  &&
            s->nal_unit_type != HEVC_NAL_RASL_N  &&
            s->nal_unit_type != HEVC_NAL_RASL_R)
            s->pocTid0 = s->poc;

        if (s->ps.sps->sao_enabled) {
            sh->slice_sample_adaptive_offset_flag[0] = get_bits1(gb);
            if (s->ps.sps->chroma_format_idc) {
                sh->slice_sample_adaptive_offset_flag[1] =
                sh->slice_sample_adaptive_offset_flag[2] = get_bits1(gb);
            }
        } else {
            sh->slice_sample_adaptive_offset_flag[0] = 0;
            sh->slice_sample_adaptive_offset_flag[1] = 0;
            sh->slice_sample_adaptive_offset_flag[2] = 0;
        }

        sh->nb_refs[L0] = sh->nb_refs[L1] = 0;
        if (sh->slice_type == HEVC_SLICE_P || sh->slice_type == HEVC_SLICE_B) {
            int nb_refs;

            sh->nb_refs[L0] = s->ps.pps->num_ref_idx_l0_default_active;
            if (sh->slice_type == HEVC_SLICE_B)
                sh->nb_refs[L1] = s->ps.pps->num_ref_idx_l1_default_active;

            if (get_bits1(gb)) { // num_ref_idx_active_override_flag
                sh->nb_refs[L0] = get_ue_golomb_long(gb) + 1;
                if (sh->slice_type == HEVC_SLICE_B)
                    sh->nb_refs[L1] = get_ue_golomb_long(gb) + 1;
            }
            if (sh->nb_refs[L0] > HEVC_MAX_REFS || sh->nb_refs[L1] > HEVC_MAX_REFS) {
                av_log(s->avctx, AV_LOG_ERROR, ""Too many refs: %d/%d.\n"",
                       sh->nb_refs[L0], sh->nb_refs[L1]);
                return AVERROR_INVALIDDATA;
            }

            sh->rpl_modification_flag[0] = 0;
            sh->rpl_modification_flag[1] = 0;
            nb_refs = ff_hevc_frame_nb_refs(s);
            if (!nb_refs) {
                av_log(s->avctx, AV_LOG_ERROR, ""Zero refs for a frame with P or B slices.\n"");
                return AVERROR_INVALIDDATA;
            }

            if (s->ps.pps->lists_modification_present_flag && nb_refs > 1) {
                sh->rpl_modification_flag[0] = get_bits1(gb);
                if (sh->rpl_modification_flag[0]) {
                    for (i = 0; i < sh->nb_refs[L0]; i++)
                        sh->list_entry_lx[0][i] = get_bits(gb, av_ceil_log2(nb_refs));
                }

                if (sh->slice_type == HEVC_SLICE_B) {
                    sh->rpl_modification_flag[1] = get_bits1(gb);
                    if (sh->rpl_modification_flag[1] == 1)
                        for (i = 0; i < sh->nb_refs[L1]; i++)
                            sh->list_entry_lx[1][i] = get_bits(gb, av_ceil_log2(nb_refs));
                }
            }

            if (sh->slice_type == HEVC_SLICE_B)
                sh->mvd_l1_zero_flag = get_bits1(gb);

            if (s->ps.pps->cabac_init_present_flag)
                sh->cabac_init_flag = get_bits1(gb);
            else
                sh->cabac_init_flag = 0;

            sh->collocated_ref_idx = 0;
            if (sh->slice_temporal_mvp_enabled_flag) {
                sh->collocated_list = L0;
                if (sh->slice_type == HEVC_SLICE_B)
                    sh->collocated_list = !get_bits1(gb);

                if (sh->nb_refs[sh->collocated_list] > 1) {
                    sh->collocated_ref_idx = get_ue_golomb_long(gb);
                    if (sh->collocated_ref_idx >= sh->nb_refs[sh->collocated_list]) {
                        av_log(s->avctx, AV_LOG_ERROR,
                               ""Invalid collocated_ref_idx: %d.\n"",
                               sh->collocated_ref_idx);
                        return AVERROR_INVALIDDATA;
                    }
                }
            }

            if ((s->ps.pps->weighted_pred_flag   && sh->slice_type == HEVC_SLICE_P) ||
                (s->ps.pps->weighted_bipred_flag && sh->slice_type == HEVC_SLICE_B)) {
                int ret = pred_weight_table(s, gb);
                if (ret < 0)
                    return ret;
            }

            sh->max_num_merge_cand = 5 - get_ue_golomb_long(gb);
            if (sh->max_num_merge_cand < 1 || sh->max_num_merge_cand > 5) {
                av_log(s->avctx, AV_LOG_ERROR,
                       ""Invalid number of merging MVP candidates: %d.\n"",
                       sh->max_num_merge_cand);
                return AVERROR_INVALIDDATA;
            }
        }

        sh->slice_qp_delta = get_se_golomb(gb);

        if (s->ps.pps->pic_slice_level_chroma_qp_offsets_present_flag) {
            sh->slice_cb_qp_offset = get_se_golomb(gb);
            sh->slice_cr_qp_offset = get_se_golomb(gb);
        } else {
            sh->slice_cb_qp_offset = 0;
            sh->slice_cr_qp_offset = 0;
        }

        if (s->ps.pps->chroma_qp_offset_list_enabled_flag)
            sh->cu_chroma_qp_offset_enabled_flag = get_bits1(gb);
        else
            sh->cu_chroma_qp_offset_enabled_flag = 0;

        if (s->ps.pps->deblocking_filter_control_present_flag) {
            int deblocking_filter_override_flag = 0;

            if (s->ps.pps->deblocking_filter_override_enabled_flag)
                deblocking_filter_override_flag = get_bits1(gb);

            if (deblocking_filter_override_flag) {
                sh->disable_deblocking_filter_flag = get_bits1(gb);
                if (!sh->disable_deblocking_filter_flag) {
                    int beta_offset_div2 = get_se_golomb(gb);
                    int tc_offset_div2   = get_se_golomb(gb) ;
                    if (beta_offset_div2 < -6 || beta_offset_div2 > 6 ||
                        tc_offset_div2   < -6 || tc_offset_div2   > 6) {
                        av_log(s->avctx, AV_LOG_ERROR,
                            ""Invalid deblock filter offsets: %d, %d\n"",
                            beta_offset_div2, tc_offset_div2);
                        return AVERROR_INVALIDDATA;
                    }
                    sh->beta_offset = beta_offset_div2 * 2;
                    sh->tc_offset   =   tc_offset_div2 * 2;
                }
            } else {
                sh->disable_deblocking_filter_flag = s->ps.pps->disable_dbf;
                sh->beta_offset                    = s->ps.pps->beta_offset;
                sh->tc_offset                      = s->ps.pps->tc_offset;
            }
        } else {
            sh->disable_deblocking_filter_flag = 0;
            sh->beta_offset                    = 0;
            sh->tc_offset                      = 0;
        }

        if (s->ps.pps->seq_loop_filter_across_slices_enabled_flag &&
            (sh->slice_sample_adaptive_offset_flag[0] ||
             sh->slice_sample_adaptive_offset_flag[1] ||
             !sh->disable_deblocking_filter_flag)) {
            sh->slice_loop_filter_across_slices_enabled_flag = get_bits1(gb);
        } else {
            sh->slice_loop_filter_across_slices_enabled_flag = s->ps.pps->seq_loop_filter_across_slices_enabled_flag;
        }
    } else if (!s->slice_initialized) {
        av_log(s->avctx, AV_LOG_ERROR, ""Independent slice segment missing.\n"");
        return AVERROR_INVALIDDATA;
    }

    sh->num_entry_point_offsets = 0;
    if (s->ps.pps->tiles_enabled_flag || s->ps.pps->entropy_coding_sync_enabled_flag) {
        unsigned num_entry_point_offsets = get_ue_golomb_long(gb);
        // It would be possible to bound this tighter but this here is simpler
        if (num_entry_point_offsets > get_bits_left(gb)) {
            av_log(s->avctx, AV_LOG_ERROR, ""num_entry_point_offsets %d is invalid\n"", num_entry_point_offsets);
            return AVERROR_INVALIDDATA;
        }

        sh->num_entry_point_offsets = num_entry_point_offsets;
        if (sh->num_entry_point_offsets > 0) {
            int offset_len = get_ue_golomb_long(gb) + 1;

            if (offset_len < 1 || offset_len > 32) {
                sh->num_entry_point_offsets = 0;
                av_log(s->avctx, AV_LOG_ERROR, ""offset_len %d is invalid\n"", offset_len);
                return AVERROR_INVALIDDATA;
            }

            av_freep(&sh->entry_point_offset);
            av_freep(&sh->offset);
            av_freep(&sh->size);
            sh->entry_point_offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(unsigned));
            sh->offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));
            sh->size = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));
            if (!sh->entry_point_offset || !sh->offset || !sh->size) {
                sh->num_entry_point_offsets = 0;
                av_log(s->avctx, AV_LOG_ERROR, ""Failed to allocate memory\n"");
                return AVERROR(ENOMEM);
            }
            for (i = 0; i < sh->num_entry_point_offsets; i++) {
                unsigned val = get_bits_long(gb, offset_len);
                sh->entry_point_offset[i] = val + 1; // +1; // +1 to get the size
            }
            if (s->threads_number > 1 && (s->ps.pps->num_tile_rows > 1 || s->ps.pps->num_tile_columns > 1)) {
                s->enable_parallel_tiles = 0; // TODO: you can enable tiles in parallel here
                s->threads_number = 1;
            } else
                s->enable_parallel_tiles = 0;
        } else
            s->enable_parallel_tiles = 0;
    }

    if (s->ps.pps->slice_header_extension_present_flag) {
        unsigned int length = get_ue_golomb_long(gb);
        if (length*8LL > get_bits_left(gb)) {
            av_log(s->avctx, AV_LOG_ERROR, ""too many slice_header_extension_data_bytes\n"");
            return AVERROR_INVALIDDATA;
        }
        for (i = 0; i < length; i++)
            skip_bits(gb, 8);  // slice_header_extension_data_byte
    }

    // Inferred parameters
    sh->slice_qp = 26U + s->ps.pps->pic_init_qp_minus26 + sh->slice_qp_delta;
    if (sh->slice_qp > 51 ||
        sh->slice_qp < -s->ps.sps->qp_bd_offset) {
        av_log(s->avctx, AV_LOG_ERROR,
               ""The slice_qp %d is outside the valid range ""
               ""[%d, 51].\n"",
               sh->slice_qp,
               -s->ps.sps->qp_bd_offset);
        return AVERROR_INVALIDDATA;
    }

    sh->slice_ctb_addr_rs = sh->slice_segment_addr;

    if (!s->sh.slice_ctb_addr_rs && s->sh.dependent_slice_segment_flag) {
        av_log(s->avctx, AV_LOG_ERROR, ""Impossible slice segment.\n"");
        return AVERROR_INVALIDDATA;
    }

    if (get_bits_left(gb) < 0) {
        av_log(s->avctx, AV_LOG_ERROR,
               ""Overread slice header by %d bits\n"", -get_bits_left(gb));
        return AVERROR_INVALIDDATA;
    }

    s->HEVClc->first_qp_group = !s->sh.dependent_slice_segment_flag;

    if (!s->ps.pps->cu_qp_delta_enabled_flag)
        s->HEVClc->qp_y = s->sh.slice_qp;

    s->slice_initialized = 1;
    s->HEVClc->tu.cu_qp_offset_cb = 0;
    s->HEVClc->tu.cu_qp_offset_cr = 0;

    return 0;
}
"
5158,182894,,Local,Not required,Complete,CVE-2019-9213,https://www.cvedetails.com/cve/CVE-2019-9213/,CWE-476,Low,,,,2019-03-05,4.9,"In the Linux kernel before 4.20.14, expand_downwards in mm/mmap.c lacks a check for the mmap minimum address, which makes it easier for attackers to exploit kernel NULL pointer dereferences on non-SMAP platforms. This is related to a capability check for the wrong task.",2019-06-17,,3,https://github.com/torvalds/linux/commit/0a1d52994d440e21def1c2174932410b4f2a98a1,0a1d52994d440e21def1c2174932410b4f2a98a1,"mm: enforce min addr even if capable() in expand_downwards()

security_mmap_addr() does a capability check with current_cred(), but
we can reach this code from contexts like a VFS write handler where
current_cred() must not be used.

This can be abused on systems without SMAP to make NULL pointer
dereferences exploitable again.

Fixes: 8869477a49c3 (""security: protect from stack expansion into low vm addresses"")
Cc: stable@kernel.org
Signed-off-by: Jann Horn <jannh@google.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",4,mm/mmap.c,"{""sha"": ""fc1809b1bed67bcf4e473bc609dcad5072f38b88"", ""filename"": ""mm/mmap.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/0a1d52994d440e21def1c2174932410b4f2a98a1/mm/mmap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0a1d52994d440e21def1c2174932410b4f2a98a1/mm/mmap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/mmap.c?ref=0a1d52994d440e21def1c2174932410b4f2a98a1"", ""patch"": ""@@ -2426,12 +2426,11 @@ int expand_downwards(struct vm_area_struct *vma,\n {\n \tstruct mm_struct *mm = vma->vm_mm;\n \tstruct vm_area_struct *prev;\n-\tint error;\n+\tint error = 0;\n \n \taddress &= PAGE_MASK;\n-\terror = security_mmap_addr(address);\n-\tif (error)\n-\t\treturn error;\n+\tif (address < mmap_min_addr)\n+\t\treturn -EPERM;\n \n \t/* Enforce stack_guard_gap */\n \tprev = vma->vm_prev;""}","int expand_downwards(struct vm_area_struct *vma,
				   unsigned long address)
 {
 	struct mm_struct *mm = vma->vm_mm;
 	struct vm_area_struct *prev;
	int error = 0;
 
 	address &= PAGE_MASK;
	if (address < mmap_min_addr)
		return -EPERM;
 
 	/* Enforce stack_guard_gap */
 	prev = vma->vm_prev;
	/* Check that both stack segments have the same anon_vma? */
	if (prev && !(prev->vm_flags & VM_GROWSDOWN) &&
			(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {
		if (address - prev->vm_end < stack_guard_gap)
			return -ENOMEM;
	}

	/* We must make sure the anon_vma is allocated. */
	if (unlikely(anon_vma_prepare(vma)))
		return -ENOMEM;

	/*
	 * vma->vm_start/vm_end cannot change under us because the caller
	 * is required to hold the mmap_sem in read mode.  We need the
	 * anon_vma lock to serialize against concurrent expand_stacks.
	 */
	anon_vma_lock_write(vma->anon_vma);

	/* Somebody else might have raced and expanded it already */
	if (address < vma->vm_start) {
		unsigned long size, grow;

		size = vma->vm_end - address;
		grow = (vma->vm_start - address) >> PAGE_SHIFT;

		error = -ENOMEM;
		if (grow <= vma->vm_pgoff) {
			error = acct_stack_growth(vma, size, grow);
			if (!error) {
				/*
				 * vma_gap_update() doesn't support concurrent
				 * updates, but we only hold a shared mmap_sem
				 * lock here, so we need to protect against
				 * concurrent vma expansions.
				 * anon_vma_lock_write() doesn't help here, as
				 * we don't guarantee that all growable vmas
				 * in a mm share the same root anon vma.
				 * So, we reuse mm->page_table_lock to guard
				 * against concurrent vma expansions.
				 */
				spin_lock(&mm->page_table_lock);
				if (vma->vm_flags & VM_LOCKED)
					mm->locked_vm += grow;
				vm_stat_account(mm, vma->vm_flags, grow);
				anon_vma_interval_tree_pre_update_vma(vma);
				vma->vm_start = address;
				vma->vm_pgoff -= grow;
				anon_vma_interval_tree_post_update_vma(vma);
				vma_gap_update(vma);
				spin_unlock(&mm->page_table_lock);

				perf_event_mmap(vma);
			}
		}
	}
	anon_vma_unlock_write(vma->anon_vma);
	khugepaged_enter_vma_merge(vma, vma->vm_flags);
	validate_mm(mm);
	return error;
}
","int expand_downwards(struct vm_area_struct *vma,
				   unsigned long address)
 {
 	struct mm_struct *mm = vma->vm_mm;
 	struct vm_area_struct *prev;
	int error;
 
 	address &= PAGE_MASK;
	error = security_mmap_addr(address);
	if (error)
		return error;
 
 	/* Enforce stack_guard_gap */
 	prev = vma->vm_prev;
	/* Check that both stack segments have the same anon_vma? */
	if (prev && !(prev->vm_flags & VM_GROWSDOWN) &&
			(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {
		if (address - prev->vm_end < stack_guard_gap)
			return -ENOMEM;
	}

	/* We must make sure the anon_vma is allocated. */
	if (unlikely(anon_vma_prepare(vma)))
		return -ENOMEM;

	/*
	 * vma->vm_start/vm_end cannot change under us because the caller
	 * is required to hold the mmap_sem in read mode.  We need the
	 * anon_vma lock to serialize against concurrent expand_stacks.
	 */
	anon_vma_lock_write(vma->anon_vma);

	/* Somebody else might have raced and expanded it already */
	if (address < vma->vm_start) {
		unsigned long size, grow;

		size = vma->vm_end - address;
		grow = (vma->vm_start - address) >> PAGE_SHIFT;

		error = -ENOMEM;
		if (grow <= vma->vm_pgoff) {
			error = acct_stack_growth(vma, size, grow);
			if (!error) {
				/*
				 * vma_gap_update() doesn't support concurrent
				 * updates, but we only hold a shared mmap_sem
				 * lock here, so we need to protect against
				 * concurrent vma expansions.
				 * anon_vma_lock_write() doesn't help here, as
				 * we don't guarantee that all growable vmas
				 * in a mm share the same root anon vma.
				 * So, we reuse mm->page_table_lock to guard
				 * against concurrent vma expansions.
				 */
				spin_lock(&mm->page_table_lock);
				if (vma->vm_flags & VM_LOCKED)
					mm->locked_vm += grow;
				vm_stat_account(mm, vma->vm_flags, grow);
				anon_vma_interval_tree_pre_update_vma(vma);
				vma->vm_start = address;
				vma->vm_pgoff -= grow;
				anon_vma_interval_tree_post_update_vma(vma);
				vma_gap_update(vma);
				spin_unlock(&mm->page_table_lock);

				perf_event_mmap(vma);
			}
		}
	}
	anon_vma_unlock_write(vma->anon_vma);
	khugepaged_enter_vma_merge(vma, vma->vm_flags);
	validate_mm(mm);
	return error;
}
",C,"	int error = 0;
	if (address < mmap_min_addr)
		return -EPERM;
","	int error;
	error = security_mmap_addr(address);
	if (error)
		return error;
",,"@@ -2426,12 +2426,11 @@ int expand_downwards(struct vm_area_struct *vma,
 {
 	struct mm_struct *mm = vma->vm_mm;
 	struct vm_area_struct *prev;
-	int error;
+	int error = 0;
 
 	address &= PAGE_MASK;
-	error = security_mmap_addr(address);
-	if (error)
-		return error;
+	if (address < mmap_min_addr)
+		return -EPERM;
 
 	/* Enforce stack_guard_gap */
 	prev = vma->vm_prev;",linux,0a1d52994d440e21def1c2174932410b4f2a98a1,7d762d69145a54d169f58e56d6dac57a5508debc,1,"int expand_downwards(struct vm_area_struct *vma,
				   unsigned long address)
 {
 	struct mm_struct *mm = vma->vm_mm;
 	struct vm_area_struct *prev;
//flaw_line_below:
	int error;
//fix_flaw_line_below:
//	int error = 0;
 
 	address &= PAGE_MASK;
//flaw_line_below:
	error = security_mmap_addr(address);
//flaw_line_below:
	if (error)
//flaw_line_below:
		return error;
//fix_flaw_line_below:
//	if (address < mmap_min_addr)
//fix_flaw_line_below:
//		return -EPERM;
 
 	/* Enforce stack_guard_gap */
 	prev = vma->vm_prev;
	/* Check that both stack segments have the same anon_vma? */
	if (prev && !(prev->vm_flags & VM_GROWSDOWN) &&
			(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {
		if (address - prev->vm_end < stack_guard_gap)
			return -ENOMEM;
	}

	/* We must make sure the anon_vma is allocated. */
	if (unlikely(anon_vma_prepare(vma)))
		return -ENOMEM;

	/*
	 * vma->vm_start/vm_end cannot change under us because the caller
	 * is required to hold the mmap_sem in read mode.  We need the
	 * anon_vma lock to serialize against concurrent expand_stacks.
	 */
	anon_vma_lock_write(vma->anon_vma);

	/* Somebody else might have raced and expanded it already */
	if (address < vma->vm_start) {
		unsigned long size, grow;

		size = vma->vm_end - address;
		grow = (vma->vm_start - address) >> PAGE_SHIFT;

		error = -ENOMEM;
		if (grow <= vma->vm_pgoff) {
			error = acct_stack_growth(vma, size, grow);
			if (!error) {
				/*
				 * vma_gap_update() doesn't support concurrent
				 * updates, but we only hold a shared mmap_sem
				 * lock here, so we need to protect against
				 * concurrent vma expansions.
				 * anon_vma_lock_write() doesn't help here, as
				 * we don't guarantee that all growable vmas
				 * in a mm share the same root anon vma.
				 * So, we reuse mm->page_table_lock to guard
				 * against concurrent vma expansions.
				 */
				spin_lock(&mm->page_table_lock);
				if (vma->vm_flags & VM_LOCKED)
					mm->locked_vm += grow;
				vm_stat_account(mm, vma->vm_flags, grow);
				anon_vma_interval_tree_pre_update_vma(vma);
				vma->vm_start = address;
				vma->vm_pgoff -= grow;
				anon_vma_interval_tree_post_update_vma(vma);
				vma_gap_update(vma);
				spin_unlock(&mm->page_table_lock);

				perf_event_mmap(vma);
			}
		}
	}
	anon_vma_unlock_write(vma->anon_vma);
	khugepaged_enter_vma_merge(vma, vma->vm_flags);
	validate_mm(mm);
	return error;
}
"
5290,183026,,Local,Not required,Complete,CVE-2018-7191,https://www.cvedetails.com/cve/CVE-2018-7191/,CWE-476,Low,,,,2019-05-17,4.9,"In the tun subsystem in the Linux kernel before 4.13.14, dev_get_valid_name is not called before register_netdevice. This allows local users to cause a denial of service (NULL pointer dereference and panic) via an ioctl(TUNSETIFF) call with a dev name containing a / character. This is similar to CVE-2013-4343.",2019-05-31,DoS ,3,https://github.com/torvalds/linux/commit/0ad646c81b2182f7fa67ec0c8c825e0ee165696d,0ad646c81b2182f7fa67ec0c8c825e0ee165696d,"tun: call dev_get_valid_name() before register_netdevice()

register_netdevice() could fail early when we have an invalid
dev name, in which case ->ndo_uninit() is not called. For tun
device, this is a problem because a timer etc. are already
initialized and it expects ->ndo_uninit() to clean them up.

We could move these initializations into a ->ndo_init() so
that register_netdevice() knows better, however this is still
complicated due to the logic in tun_detach().

Therefore, I choose to just call dev_get_valid_name() before
register_netdevice(), which is quicker and much easier to audit.
And for this specific case, it is already enough.

Fixes: 96442e42429e (""tuntap: choose the txq based on rxq"")
Reported-by: Dmitry Alexeev <avekceeb@gmail.com>
Cc: Jason Wang <jasowang@redhat.com>
Cc: ""Michael S. Tsirkin"" <mst@redhat.com>
Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,drivers/net/tun.c,"{""sha"": ""e21bf90b819f8f77e4886a6d1ff7c7b5ca12bad0"", ""filename"": ""drivers/net/tun.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0ad646c81b2182f7fa67ec0c8c825e0ee165696d/drivers/net/tun.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0ad646c81b2182f7fa67ec0c8c825e0ee165696d/drivers/net/tun.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/tun.c?ref=0ad646c81b2182f7fa67ec0c8c825e0ee165696d"", ""patch"": ""@@ -2027,6 +2027,9 @@ static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)\n \n \t\tif (!dev)\n \t\t\treturn -ENOMEM;\n+\t\terr = dev_get_valid_name(net, dev, name);\n+\t\tif (err)\n+\t\t\tgoto err_free_dev;\n \n \t\tdev_net_set(dev, net);\n \t\tdev->rtnl_link_ops = &tun_link_ops;""}<_**next**_>{""sha"": ""2eaac7d75af4f1bbdaf876acc55b4bd0d37a7f36"", ""filename"": ""include/linux/netdevice.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0ad646c81b2182f7fa67ec0c8c825e0ee165696d/include/linux/netdevice.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0ad646c81b2182f7fa67ec0c8c825e0ee165696d/include/linux/netdevice.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/netdevice.h?ref=0ad646c81b2182f7fa67ec0c8c825e0ee165696d"", ""patch"": ""@@ -3694,6 +3694,9 @@ struct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,\n \t\t\t\t    unsigned char name_assign_type,\n \t\t\t\t    void (*setup)(struct net_device *),\n \t\t\t\t    unsigned int txqs, unsigned int rxqs);\n+int dev_get_valid_name(struct net *net, struct net_device *dev,\n+\t\t       const char *name);\n+\n #define alloc_netdev(sizeof_priv, name, name_assign_type, setup) \\\n \talloc_netdev_mqs(sizeof_priv, name, name_assign_type, setup, 1, 1)\n ""}<_**next**_>{""sha"": ""11596a302a265212cb5dfe40f51b5b01fb20d0ce"", ""filename"": ""net/core/dev.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/0ad646c81b2182f7fa67ec0c8c825e0ee165696d/net/core/dev.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0ad646c81b2182f7fa67ec0c8c825e0ee165696d/net/core/dev.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/core/dev.c?ref=0ad646c81b2182f7fa67ec0c8c825e0ee165696d"", ""patch"": ""@@ -1147,9 +1147,8 @@ static int dev_alloc_name_ns(struct net *net,\n \treturn ret;\n }\n \n-static int dev_get_valid_name(struct net *net,\n-\t\t\t      struct net_device *dev,\n-\t\t\t      const char *name)\n+int dev_get_valid_name(struct net *net, struct net_device *dev,\n+\t\t       const char *name)\n {\n \tBUG_ON(!net);\n \n@@ -1165,6 +1164,7 @@ static int dev_get_valid_name(struct net *net,\n \n \treturn 0;\n }\n+EXPORT_SYMBOL(dev_get_valid_name);\n \n /**\n  *\tdev_change_name - change name of a device""}","static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)
{
	struct tun_struct *tun;
	struct tun_file *tfile = file->private_data;
	struct net_device *dev;
	int err;

	if (tfile->detached)
		return -EINVAL;

	dev = __dev_get_by_name(net, ifr->ifr_name);
	if (dev) {
		if (ifr->ifr_flags & IFF_TUN_EXCL)
			return -EBUSY;
		if ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)
			tun = netdev_priv(dev);
		else if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)
			tun = netdev_priv(dev);
		else
			return -EINVAL;

		if (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=
		    !!(tun->flags & IFF_MULTI_QUEUE))
			return -EINVAL;

		if (tun_not_capable(tun))
			return -EPERM;
		err = security_tun_dev_open(tun->security);
		if (err < 0)
			return err;

		err = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER);
		if (err < 0)
			return err;

		if (tun->flags & IFF_MULTI_QUEUE &&
		    (tun->numqueues + tun->numdisabled > 1)) {
			/* One or more queue has already been attached, no need
			 * to initialize the device again.
			 */
			return 0;
		}
	}
	else {
		char *name;
		unsigned long flags = 0;
		int queues = ifr->ifr_flags & IFF_MULTI_QUEUE ?
			     MAX_TAP_QUEUES : 1;

		if (!ns_capable(net->user_ns, CAP_NET_ADMIN))
			return -EPERM;
		err = security_tun_dev_create();
		if (err < 0)
			return err;

		/* Set dev type */
		if (ifr->ifr_flags & IFF_TUN) {
			/* TUN device */
			flags |= IFF_TUN;
			name = ""tun%d"";
		} else if (ifr->ifr_flags & IFF_TAP) {
			/* TAP device */
			flags |= IFF_TAP;
			name = ""tap%d"";
		} else
			return -EINVAL;

		if (*ifr->ifr_name)
			name = ifr->ifr_name;

		dev = alloc_netdev_mqs(sizeof(struct tun_struct), name,
				       NET_NAME_UNKNOWN, tun_setup, queues,
				       queues);
 
 		if (!dev)
 			return -ENOMEM;
		err = dev_get_valid_name(net, dev, name);
		if (err)
			goto err_free_dev;
 
 		dev_net_set(dev, net);
 		dev->rtnl_link_ops = &tun_link_ops;
		dev->ifindex = tfile->ifindex;
		dev->sysfs_groups[0] = &tun_attr_group;

		tun = netdev_priv(dev);
		tun->dev = dev;
		tun->flags = flags;
		tun->txflt.count = 0;
		tun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);

		tun->align = NET_SKB_PAD;
		tun->filter_attached = false;
		tun->sndbuf = tfile->socket.sk->sk_sndbuf;
		tun->rx_batched = 0;

		tun->pcpu_stats = netdev_alloc_pcpu_stats(struct tun_pcpu_stats);
		if (!tun->pcpu_stats) {
			err = -ENOMEM;
			goto err_free_dev;
		}

		spin_lock_init(&tun->lock);

		err = security_tun_dev_alloc_security(&tun->security);
		if (err < 0)
			goto err_free_stat;

		tun_net_init(dev);
		tun_flow_init(tun);

		dev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |
				   TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |
				   NETIF_F_HW_VLAN_STAG_TX;
		dev->features = dev->hw_features | NETIF_F_LLTX;
		dev->vlan_features = dev->features &
				     ~(NETIF_F_HW_VLAN_CTAG_TX |
				       NETIF_F_HW_VLAN_STAG_TX);

		INIT_LIST_HEAD(&tun->disabled);
		err = tun_attach(tun, file, false);
		if (err < 0)
			goto err_free_flow;

		err = register_netdevice(tun->dev);
		if (err < 0)
			goto err_detach;
	}

	netif_carrier_on(tun->dev);

	tun_debug(KERN_INFO, tun, ""tun_set_iff\n"");

	tun->flags = (tun->flags & ~TUN_FEATURES) |
		(ifr->ifr_flags & TUN_FEATURES);

	/* Make sure persistent devices do not get stuck in
	 * xoff state.
	 */
	if (netif_running(tun->dev))
		netif_tx_wake_all_queues(tun->dev);

	strcpy(ifr->ifr_name, tun->dev->name);
	return 0;

err_detach:
	tun_detach_all(dev);
	/* register_netdevice() already called tun_free_netdev() */
	goto err_free_dev;

err_free_flow:
	tun_flow_uninit(tun);
	security_tun_dev_free_security(tun->security);
err_free_stat:
	free_percpu(tun->pcpu_stats);
err_free_dev:
	free_netdev(dev);
	return err;
}
","static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)
{
	struct tun_struct *tun;
	struct tun_file *tfile = file->private_data;
	struct net_device *dev;
	int err;

	if (tfile->detached)
		return -EINVAL;

	dev = __dev_get_by_name(net, ifr->ifr_name);
	if (dev) {
		if (ifr->ifr_flags & IFF_TUN_EXCL)
			return -EBUSY;
		if ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)
			tun = netdev_priv(dev);
		else if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)
			tun = netdev_priv(dev);
		else
			return -EINVAL;

		if (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=
		    !!(tun->flags & IFF_MULTI_QUEUE))
			return -EINVAL;

		if (tun_not_capable(tun))
			return -EPERM;
		err = security_tun_dev_open(tun->security);
		if (err < 0)
			return err;

		err = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER);
		if (err < 0)
			return err;

		if (tun->flags & IFF_MULTI_QUEUE &&
		    (tun->numqueues + tun->numdisabled > 1)) {
			/* One or more queue has already been attached, no need
			 * to initialize the device again.
			 */
			return 0;
		}
	}
	else {
		char *name;
		unsigned long flags = 0;
		int queues = ifr->ifr_flags & IFF_MULTI_QUEUE ?
			     MAX_TAP_QUEUES : 1;

		if (!ns_capable(net->user_ns, CAP_NET_ADMIN))
			return -EPERM;
		err = security_tun_dev_create();
		if (err < 0)
			return err;

		/* Set dev type */
		if (ifr->ifr_flags & IFF_TUN) {
			/* TUN device */
			flags |= IFF_TUN;
			name = ""tun%d"";
		} else if (ifr->ifr_flags & IFF_TAP) {
			/* TAP device */
			flags |= IFF_TAP;
			name = ""tap%d"";
		} else
			return -EINVAL;

		if (*ifr->ifr_name)
			name = ifr->ifr_name;

		dev = alloc_netdev_mqs(sizeof(struct tun_struct), name,
				       NET_NAME_UNKNOWN, tun_setup, queues,
				       queues);
 
 		if (!dev)
 			return -ENOMEM;
 
 		dev_net_set(dev, net);
 		dev->rtnl_link_ops = &tun_link_ops;
		dev->ifindex = tfile->ifindex;
		dev->sysfs_groups[0] = &tun_attr_group;

		tun = netdev_priv(dev);
		tun->dev = dev;
		tun->flags = flags;
		tun->txflt.count = 0;
		tun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);

		tun->align = NET_SKB_PAD;
		tun->filter_attached = false;
		tun->sndbuf = tfile->socket.sk->sk_sndbuf;
		tun->rx_batched = 0;

		tun->pcpu_stats = netdev_alloc_pcpu_stats(struct tun_pcpu_stats);
		if (!tun->pcpu_stats) {
			err = -ENOMEM;
			goto err_free_dev;
		}

		spin_lock_init(&tun->lock);

		err = security_tun_dev_alloc_security(&tun->security);
		if (err < 0)
			goto err_free_stat;

		tun_net_init(dev);
		tun_flow_init(tun);

		dev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |
				   TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |
				   NETIF_F_HW_VLAN_STAG_TX;
		dev->features = dev->hw_features | NETIF_F_LLTX;
		dev->vlan_features = dev->features &
				     ~(NETIF_F_HW_VLAN_CTAG_TX |
				       NETIF_F_HW_VLAN_STAG_TX);

		INIT_LIST_HEAD(&tun->disabled);
		err = tun_attach(tun, file, false);
		if (err < 0)
			goto err_free_flow;

		err = register_netdevice(tun->dev);
		if (err < 0)
			goto err_detach;
	}

	netif_carrier_on(tun->dev);

	tun_debug(KERN_INFO, tun, ""tun_set_iff\n"");

	tun->flags = (tun->flags & ~TUN_FEATURES) |
		(ifr->ifr_flags & TUN_FEATURES);

	/* Make sure persistent devices do not get stuck in
	 * xoff state.
	 */
	if (netif_running(tun->dev))
		netif_tx_wake_all_queues(tun->dev);

	strcpy(ifr->ifr_name, tun->dev->name);
	return 0;

err_detach:
	tun_detach_all(dev);
	/* register_netdevice() already called tun_free_netdev() */
	goto err_free_dev;

err_free_flow:
	tun_flow_uninit(tun);
	security_tun_dev_free_security(tun->security);
err_free_stat:
	free_percpu(tun->pcpu_stats);
err_free_dev:
	free_netdev(dev);
	return err;
}
",C,"		err = dev_get_valid_name(net, dev, name);
		if (err)
			goto err_free_dev;
",,,"@@ -2027,6 +2027,9 @@ static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)
 
 		if (!dev)
 			return -ENOMEM;
+		err = dev_get_valid_name(net, dev, name);
+		if (err)
+			goto err_free_dev;
 
 		dev_net_set(dev, net);
 		dev->rtnl_link_ops = &tun_link_ops;",linux,0ad646c81b2182f7fa67ec0c8c825e0ee165696d,2459b4c635858094df78abb9ca87d99f89fe8ca5,1,"static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)
{
	struct tun_struct *tun;
	struct tun_file *tfile = file->private_data;
	struct net_device *dev;
	int err;

	if (tfile->detached)
		return -EINVAL;

	dev = __dev_get_by_name(net, ifr->ifr_name);
	if (dev) {
		if (ifr->ifr_flags & IFF_TUN_EXCL)
			return -EBUSY;
		if ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)
			tun = netdev_priv(dev);
		else if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)
			tun = netdev_priv(dev);
		else
			return -EINVAL;

		if (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=
		    !!(tun->flags & IFF_MULTI_QUEUE))
			return -EINVAL;

		if (tun_not_capable(tun))
			return -EPERM;
		err = security_tun_dev_open(tun->security);
		if (err < 0)
			return err;

		err = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER);
		if (err < 0)
			return err;

		if (tun->flags & IFF_MULTI_QUEUE &&
		    (tun->numqueues + tun->numdisabled > 1)) {
			/* One or more queue has already been attached, no need
			 * to initialize the device again.
			 */
			return 0;
		}
	}
	else {
		char *name;
		unsigned long flags = 0;
		int queues = ifr->ifr_flags & IFF_MULTI_QUEUE ?
			     MAX_TAP_QUEUES : 1;

		if (!ns_capable(net->user_ns, CAP_NET_ADMIN))
			return -EPERM;
		err = security_tun_dev_create();
		if (err < 0)
			return err;

		/* Set dev type */
		if (ifr->ifr_flags & IFF_TUN) {
			/* TUN device */
			flags |= IFF_TUN;
			name = ""tun%d"";
		} else if (ifr->ifr_flags & IFF_TAP) {
			/* TAP device */
			flags |= IFF_TAP;
			name = ""tap%d"";
		} else
			return -EINVAL;

		if (*ifr->ifr_name)
			name = ifr->ifr_name;

		dev = alloc_netdev_mqs(sizeof(struct tun_struct), name,
				       NET_NAME_UNKNOWN, tun_setup, queues,
				       queues);
 
 		if (!dev)
 			return -ENOMEM;
//fix_flaw_line_below:
//		err = dev_get_valid_name(net, dev, name);
//fix_flaw_line_below:
//		if (err)
//fix_flaw_line_below:
//			goto err_free_dev;
 
 		dev_net_set(dev, net);
 		dev->rtnl_link_ops = &tun_link_ops;
		dev->ifindex = tfile->ifindex;
		dev->sysfs_groups[0] = &tun_attr_group;

		tun = netdev_priv(dev);
		tun->dev = dev;
		tun->flags = flags;
		tun->txflt.count = 0;
		tun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);

		tun->align = NET_SKB_PAD;
		tun->filter_attached = false;
		tun->sndbuf = tfile->socket.sk->sk_sndbuf;
		tun->rx_batched = 0;

		tun->pcpu_stats = netdev_alloc_pcpu_stats(struct tun_pcpu_stats);
		if (!tun->pcpu_stats) {
			err = -ENOMEM;
			goto err_free_dev;
		}

		spin_lock_init(&tun->lock);

		err = security_tun_dev_alloc_security(&tun->security);
		if (err < 0)
			goto err_free_stat;

		tun_net_init(dev);
		tun_flow_init(tun);

		dev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |
				   TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |
				   NETIF_F_HW_VLAN_STAG_TX;
		dev->features = dev->hw_features | NETIF_F_LLTX;
		dev->vlan_features = dev->features &
				     ~(NETIF_F_HW_VLAN_CTAG_TX |
				       NETIF_F_HW_VLAN_STAG_TX);

		INIT_LIST_HEAD(&tun->disabled);
		err = tun_attach(tun, file, false);
		if (err < 0)
			goto err_free_flow;

		err = register_netdevice(tun->dev);
		if (err < 0)
			goto err_detach;
	}

	netif_carrier_on(tun->dev);

	tun_debug(KERN_INFO, tun, ""tun_set_iff\n"");

	tun->flags = (tun->flags & ~TUN_FEATURES) |
		(ifr->ifr_flags & TUN_FEATURES);

	/* Make sure persistent devices do not get stuck in
	 * xoff state.
	 */
	if (netif_running(tun->dev))
		netif_tx_wake_all_queues(tun->dev);

	strcpy(ifr->ifr_name, tun->dev->name);
	return 0;

err_detach:
	tun_detach_all(dev);
	/* register_netdevice() already called tun_free_netdev() */
	goto err_free_dev;

err_free_flow:
	tun_flow_uninit(tun);
	security_tun_dev_free_security(tun->security);
err_free_stat:
	free_percpu(tun->pcpu_stats);
err_free_dev:
	free_netdev(dev);
	return err;
}
"
5291,183027,,Local,Not required,Complete,CVE-2018-7191,https://www.cvedetails.com/cve/CVE-2018-7191/,CWE-476,Low,,,,2019-05-17,4.9,"In the tun subsystem in the Linux kernel before 4.13.14, dev_get_valid_name is not called before register_netdevice. This allows local users to cause a denial of service (NULL pointer dereference and panic) via an ioctl(TUNSETIFF) call with a dev name containing a / character. This is similar to CVE-2013-4343.",2019-05-31,DoS ,2,https://github.com/torvalds/linux/commit/0ad646c81b2182f7fa67ec0c8c825e0ee165696d,0ad646c81b2182f7fa67ec0c8c825e0ee165696d,"tun: call dev_get_valid_name() before register_netdevice()

register_netdevice() could fail early when we have an invalid
dev name, in which case ->ndo_uninit() is not called. For tun
device, this is a problem because a timer etc. are already
initialized and it expects ->ndo_uninit() to clean them up.

We could move these initializations into a ->ndo_init() so
that register_netdevice() knows better, however this is still
complicated due to the logic in tun_detach().

Therefore, I choose to just call dev_get_valid_name() before
register_netdevice(), which is quicker and much easier to audit.
And for this specific case, it is already enough.

Fixes: 96442e42429e (""tuntap: choose the txq based on rxq"")
Reported-by: Dmitry Alexeev <avekceeb@gmail.com>
Cc: Jason Wang <jasowang@redhat.com>
Cc: ""Michael S. Tsirkin"" <mst@redhat.com>
Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",2,net/core/dev.c,"{""sha"": ""e21bf90b819f8f77e4886a6d1ff7c7b5ca12bad0"", ""filename"": ""drivers/net/tun.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0ad646c81b2182f7fa67ec0c8c825e0ee165696d/drivers/net/tun.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0ad646c81b2182f7fa67ec0c8c825e0ee165696d/drivers/net/tun.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/tun.c?ref=0ad646c81b2182f7fa67ec0c8c825e0ee165696d"", ""patch"": ""@@ -2027,6 +2027,9 @@ static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)\n \n \t\tif (!dev)\n \t\t\treturn -ENOMEM;\n+\t\terr = dev_get_valid_name(net, dev, name);\n+\t\tif (err)\n+\t\t\tgoto err_free_dev;\n \n \t\tdev_net_set(dev, net);\n \t\tdev->rtnl_link_ops = &tun_link_ops;""}<_**next**_>{""sha"": ""2eaac7d75af4f1bbdaf876acc55b4bd0d37a7f36"", ""filename"": ""include/linux/netdevice.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/0ad646c81b2182f7fa67ec0c8c825e0ee165696d/include/linux/netdevice.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0ad646c81b2182f7fa67ec0c8c825e0ee165696d/include/linux/netdevice.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/netdevice.h?ref=0ad646c81b2182f7fa67ec0c8c825e0ee165696d"", ""patch"": ""@@ -3694,6 +3694,9 @@ struct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,\n \t\t\t\t    unsigned char name_assign_type,\n \t\t\t\t    void (*setup)(struct net_device *),\n \t\t\t\t    unsigned int txqs, unsigned int rxqs);\n+int dev_get_valid_name(struct net *net, struct net_device *dev,\n+\t\t       const char *name);\n+\n #define alloc_netdev(sizeof_priv, name, name_assign_type, setup) \\\n \talloc_netdev_mqs(sizeof_priv, name, name_assign_type, setup, 1, 1)\n ""}<_**next**_>{""sha"": ""11596a302a265212cb5dfe40f51b5b01fb20d0ce"", ""filename"": ""net/core/dev.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/0ad646c81b2182f7fa67ec0c8c825e0ee165696d/net/core/dev.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0ad646c81b2182f7fa67ec0c8c825e0ee165696d/net/core/dev.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/core/dev.c?ref=0ad646c81b2182f7fa67ec0c8c825e0ee165696d"", ""patch"": ""@@ -1147,9 +1147,8 @@ static int dev_alloc_name_ns(struct net *net,\n \treturn ret;\n }\n \n-static int dev_get_valid_name(struct net *net,\n-\t\t\t      struct net_device *dev,\n-\t\t\t      const char *name)\n+int dev_get_valid_name(struct net *net, struct net_device *dev,\n+\t\t       const char *name)\n {\n \tBUG_ON(!net);\n \n@@ -1165,6 +1164,7 @@ static int dev_get_valid_name(struct net *net,\n \n \treturn 0;\n }\n+EXPORT_SYMBOL(dev_get_valid_name);\n \n /**\n  *\tdev_change_name - change name of a device""}","static int dev_get_valid_name(struct net *net,
int dev_get_valid_name(struct net *net, struct net_device *dev,
		       const char *name)
 {
 	BUG_ON(!net);
 
	if (!dev_valid_name(name))
		return -EINVAL;

	if (strchr(name, '%'))
		return dev_alloc_name_ns(net, dev, name);
	else if (__dev_get_by_name(net, name))
		return -EEXIST;
	else if (dev->name != name)
		strlcpy(dev->name, name, IFNAMSIZ);
 
 	return 0;
 }
","static int dev_get_valid_name(struct net *net,
			      struct net_device *dev,
			      const char *name)
 {
 	BUG_ON(!net);
 
	if (!dev_valid_name(name))
		return -EINVAL;

	if (strchr(name, '%'))
		return dev_alloc_name_ns(net, dev, name);
	else if (__dev_get_by_name(net, name))
		return -EEXIST;
	else if (dev->name != name)
		strlcpy(dev->name, name, IFNAMSIZ);
 
 	return 0;
 }
",C,"int dev_get_valid_name(struct net *net, struct net_device *dev,
		       const char *name)
","			      struct net_device *dev,
			      const char *name)
",,"@@ -1147,9 +1147,8 @@ static int dev_alloc_name_ns(struct net *net,
 	return ret;
 }
 
-static int dev_get_valid_name(struct net *net,
-			      struct net_device *dev,
-			      const char *name)
+int dev_get_valid_name(struct net *net, struct net_device *dev,
+		       const char *name)
 {
 	BUG_ON(!net);
 
@@ -1165,6 +1164,7 @@ static int dev_get_valid_name(struct net *net,
 
 	return 0;
 }
+EXPORT_SYMBOL(dev_get_valid_name);
 
 /**
  *	dev_change_name - change name of a device",linux,0ad646c81b2182f7fa67ec0c8c825e0ee165696d,2459b4c635858094df78abb9ca87d99f89fe8ca5,1,"static int dev_get_valid_name(struct net *net,
//flaw_line_below:
			      struct net_device *dev,
//flaw_line_below:
			      const char *name)
//fix_flaw_line_below:
//int dev_get_valid_name(struct net *net, struct net_device *dev,
//fix_flaw_line_below:
//		       const char *name)
 {
 	BUG_ON(!net);
 
	if (!dev_valid_name(name))
		return -EINVAL;

	if (strchr(name, '%'))
		return dev_alloc_name_ns(net, dev, name);
	else if (__dev_get_by_name(net, name))
		return -EEXIST;
	else if (dev->name != name)
		strlcpy(dev->name, name, IFNAMSIZ);
 
 	return 0;
 }
"
5449,183185,,Remote,Not required,Partial,CVE-2017-16359,https://www.cvedetails.com/cve/CVE-2017-16359/,CWE-476,Medium,,,,2017-11-01,4.3,"In radare 2.0.1, a pointer wraparound vulnerability exists in store_versioninfo_gnu_verdef() in libr/bin/format/elf/elf.c.",2017-11-13,,1,https://github.com/radare/radare2/commit/d21e91f075a7a7a8ed23baa5c1bb1fac48313882,d21e91f075a7a7a8ed23baa5c1bb1fac48313882,Fix #8764 differently since ptr diff might not fit in ptrdiff_t,1,libr/bin/format/elf/elf.c,"{""sha"": ""eb0ebe0ed23aa00065360f8e6b06c3eacde4647f"", ""filename"": ""libr/bin/format/elf/elf.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/radareorg/radare2/blob/d21e91f075a7a7a8ed23baa5c1bb1fac48313882/libr/bin/format/elf/elf.c"", ""raw_url"": ""https://github.com/radareorg/radare2/raw/d21e91f075a7a7a8ed23baa5c1bb1fac48313882/libr/bin/format/elf/elf.c"", ""contents_url"": ""https://api.github.com/repos/radareorg/radare2/contents/libr/bin/format/elf/elf.c?ref=d21e91f075a7a7a8ed23baa5c1bb1fac48313882"", ""patch"": ""@@ -749,7 +749,7 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)\n \t\tverdef->vd_aux = READ32 (dfs, j)\n \t\tverdef->vd_next = READ32 (dfs, j)\n \t\tint vdaux = verdef->vd_aux;\n-\t\tif (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {\n+\t\tif (vdaux < 1 || vstart + vdaux < vstart) {\n \t\t\tsdb_free (sdb_verdef);\n \t\t\tgoto out_error;\n \t\t}""}","static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {
	const char *section_name = """";
	const char *link_section_name = """";
	char *end = NULL;
	Elf_(Shdr) *link_shdr = NULL;
	ut8 dfs[sizeof (Elf_(Verdef))] = {0};
	Sdb *sdb;
	int cnt, i;
	if (shdr->sh_link > bin->ehdr.e_shnum) {
		return false;
	}
	link_shdr = &bin->shdr[shdr->sh_link];
	if (shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {
		return false;
	}
	Elf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));
	if (!defs) {
		return false;
	}
	if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {
		section_name = &bin->shstrtab[shdr->sh_name];
	}
	if (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {
		link_section_name = &bin->shstrtab[link_shdr->sh_name];
	}
	if (!defs) {
		bprintf (""Warning: Cannot allocate memory (Check Elf_(Verdef))\n"");
		return NULL;
	}
	sdb = sdb_new0 ();
	end = (char *)defs + shdr->sh_size;
	sdb_set (sdb, ""section_name"", section_name, 0);
	sdb_num_set (sdb, ""entries"", shdr->sh_info, 0);
	sdb_num_set (sdb, ""addr"", shdr->sh_addr, 0);
	sdb_num_set (sdb, ""offset"", shdr->sh_offset, 0);
	sdb_num_set (sdb, ""link"", shdr->sh_link, 0);
	sdb_set (sdb, ""link_section_name"", link_section_name, 0);

	for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && (end - (char *)defs > i); ++cnt) {
		Sdb *sdb_verdef = sdb_new0 ();
		char *vstart = ((char*)defs) + i;
		char key[32] = {0};
		Elf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;
		Elf_(Verdaux) aux = {0};
		int j = 0;
		int isum = 0;

		r_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));
		verdef->vd_version = READ16 (dfs, j)
		verdef->vd_flags = READ16 (dfs, j)
		verdef->vd_ndx = READ16 (dfs, j)
		verdef->vd_cnt = READ16 (dfs, j)
		verdef->vd_hash = READ32 (dfs, j)
 		verdef->vd_aux = READ32 (dfs, j)
 		verdef->vd_next = READ32 (dfs, j)
 		int vdaux = verdef->vd_aux;
		if (vdaux < 1 || vstart + vdaux < vstart) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
		vstart += vdaux;
		if (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {
			sdb_free (sdb_verdef);
			goto out_error;
		}

		j = 0;
		aux.vda_name = READ32 (vstart, j)
		aux.vda_next = READ32 (vstart, j)

		isum = i + verdef->vd_aux;
		if (aux.vda_name > bin->dynstr_size) {
			sdb_free (sdb_verdef);
			goto out_error;
		}

		sdb_num_set (sdb_verdef, ""idx"", i, 0);
		sdb_num_set (sdb_verdef, ""vd_version"", verdef->vd_version, 0);
		sdb_num_set (sdb_verdef, ""vd_ndx"", verdef->vd_ndx, 0);
		sdb_num_set (sdb_verdef, ""vd_cnt"", verdef->vd_cnt, 0);
		sdb_set (sdb_verdef, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
		sdb_set (sdb_verdef, ""flags"", get_ver_flags (verdef->vd_flags), 0);

		for (j = 1; j < verdef->vd_cnt; ++j) {
			int k;
			Sdb *sdb_parent = sdb_new0 ();
			isum += aux.vda_next;
			vstart += aux.vda_next;
			if (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {
				sdb_free (sdb_verdef);
				sdb_free (sdb_parent);
				goto out_error;
			}
			k = 0;
			aux.vda_name = READ32 (vstart, k)
			aux.vda_next = READ32 (vstart, k)
			if (aux.vda_name > bin->dynstr_size) {
				sdb_free (sdb_verdef);
				sdb_free (sdb_parent);
				goto out_error;
			}
			sdb_num_set (sdb_parent, ""idx"", isum, 0);
			sdb_num_set (sdb_parent, ""parent"", j, 0);
			sdb_set (sdb_parent, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
			snprintf (key, sizeof (key), ""parent%d"", j - 1);
			sdb_ns_set (sdb_verdef, key, sdb_parent);
		}

		snprintf (key, sizeof (key), ""verdef%d"", cnt);
		sdb_ns_set (sdb, key, sdb_verdef);
		if (!verdef->vd_next) {
			sdb_free (sdb_verdef);
			goto out_error;
		}
		if ((st32)verdef->vd_next < 1) {
			eprintf (""Warning: Invalid vd_next in the ELF version\n"");
			break;
		}
		i += verdef->vd_next;
	}
	free (defs);
	return sdb;
out_error:
	free (defs);
	sdb_free (sdb);
	return NULL;
}
","static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {
	const char *section_name = """";
	const char *link_section_name = """";
	char *end = NULL;
	Elf_(Shdr) *link_shdr = NULL;
	ut8 dfs[sizeof (Elf_(Verdef))] = {0};
	Sdb *sdb;
	int cnt, i;
	if (shdr->sh_link > bin->ehdr.e_shnum) {
		return false;
	}
	link_shdr = &bin->shdr[shdr->sh_link];
	if (shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {
		return false;
	}
	Elf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));
	if (!defs) {
		return false;
	}
	if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {
		section_name = &bin->shstrtab[shdr->sh_name];
	}
	if (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {
		link_section_name = &bin->shstrtab[link_shdr->sh_name];
	}
	if (!defs) {
		bprintf (""Warning: Cannot allocate memory (Check Elf_(Verdef))\n"");
		return NULL;
	}
	sdb = sdb_new0 ();
	end = (char *)defs + shdr->sh_size;
	sdb_set (sdb, ""section_name"", section_name, 0);
	sdb_num_set (sdb, ""entries"", shdr->sh_info, 0);
	sdb_num_set (sdb, ""addr"", shdr->sh_addr, 0);
	sdb_num_set (sdb, ""offset"", shdr->sh_offset, 0);
	sdb_num_set (sdb, ""link"", shdr->sh_link, 0);
	sdb_set (sdb, ""link_section_name"", link_section_name, 0);

	for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && (end - (char *)defs > i); ++cnt) {
		Sdb *sdb_verdef = sdb_new0 ();
		char *vstart = ((char*)defs) + i;
		char key[32] = {0};
		Elf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;
		Elf_(Verdaux) aux = {0};
		int j = 0;
		int isum = 0;

		r_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));
		verdef->vd_version = READ16 (dfs, j)
		verdef->vd_flags = READ16 (dfs, j)
		verdef->vd_ndx = READ16 (dfs, j)
		verdef->vd_cnt = READ16 (dfs, j)
		verdef->vd_hash = READ32 (dfs, j)
 		verdef->vd_aux = READ32 (dfs, j)
 		verdef->vd_next = READ32 (dfs, j)
 		int vdaux = verdef->vd_aux;
		if (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
		vstart += vdaux;
		if (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {
			sdb_free (sdb_verdef);
			goto out_error;
		}

		j = 0;
		aux.vda_name = READ32 (vstart, j)
		aux.vda_next = READ32 (vstart, j)

		isum = i + verdef->vd_aux;
		if (aux.vda_name > bin->dynstr_size) {
			sdb_free (sdb_verdef);
			goto out_error;
		}

		sdb_num_set (sdb_verdef, ""idx"", i, 0);
		sdb_num_set (sdb_verdef, ""vd_version"", verdef->vd_version, 0);
		sdb_num_set (sdb_verdef, ""vd_ndx"", verdef->vd_ndx, 0);
		sdb_num_set (sdb_verdef, ""vd_cnt"", verdef->vd_cnt, 0);
		sdb_set (sdb_verdef, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
		sdb_set (sdb_verdef, ""flags"", get_ver_flags (verdef->vd_flags), 0);

		for (j = 1; j < verdef->vd_cnt; ++j) {
			int k;
			Sdb *sdb_parent = sdb_new0 ();
			isum += aux.vda_next;
			vstart += aux.vda_next;
			if (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {
				sdb_free (sdb_verdef);
				sdb_free (sdb_parent);
				goto out_error;
			}
			k = 0;
			aux.vda_name = READ32 (vstart, k)
			aux.vda_next = READ32 (vstart, k)
			if (aux.vda_name > bin->dynstr_size) {
				sdb_free (sdb_verdef);
				sdb_free (sdb_parent);
				goto out_error;
			}
			sdb_num_set (sdb_parent, ""idx"", isum, 0);
			sdb_num_set (sdb_parent, ""parent"", j, 0);
			sdb_set (sdb_parent, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
			snprintf (key, sizeof (key), ""parent%d"", j - 1);
			sdb_ns_set (sdb_verdef, key, sdb_parent);
		}

		snprintf (key, sizeof (key), ""verdef%d"", cnt);
		sdb_ns_set (sdb, key, sdb_verdef);
		if (!verdef->vd_next) {
			sdb_free (sdb_verdef);
			goto out_error;
		}
		if ((st32)verdef->vd_next < 1) {
			eprintf (""Warning: Invalid vd_next in the ELF version\n"");
			break;
		}
		i += verdef->vd_next;
	}
	free (defs);
	return sdb;
out_error:
	free (defs);
	sdb_free (sdb);
	return NULL;
}
",C,"		if (vdaux < 1 || vstart + vdaux < vstart) {
","		if (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {
",,"@@ -749,7 +749,7 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 		verdef->vd_aux = READ32 (dfs, j)
 		verdef->vd_next = READ32 (dfs, j)
 		int vdaux = verdef->vd_aux;
-		if (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {
+		if (vdaux < 1 || vstart + vdaux < vstart) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}",radare2,d21e91f075a7a7a8ed23baa5c1bb1fac48313882,675b582fa7c53314ad11f3a438c9c7e2d8065377,1,"static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {
	const char *section_name = """";
	const char *link_section_name = """";
	char *end = NULL;
	Elf_(Shdr) *link_shdr = NULL;
	ut8 dfs[sizeof (Elf_(Verdef))] = {0};
	Sdb *sdb;
	int cnt, i;
	if (shdr->sh_link > bin->ehdr.e_shnum) {
		return false;
	}
	link_shdr = &bin->shdr[shdr->sh_link];
	if (shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {
		return false;
	}
	Elf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));
	if (!defs) {
		return false;
	}
	if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {
		section_name = &bin->shstrtab[shdr->sh_name];
	}
	if (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {
		link_section_name = &bin->shstrtab[link_shdr->sh_name];
	}
	if (!defs) {
		bprintf (""Warning: Cannot allocate memory (Check Elf_(Verdef))\n"");
		return NULL;
	}
	sdb = sdb_new0 ();
	end = (char *)defs + shdr->sh_size;
	sdb_set (sdb, ""section_name"", section_name, 0);
	sdb_num_set (sdb, ""entries"", shdr->sh_info, 0);
	sdb_num_set (sdb, ""addr"", shdr->sh_addr, 0);
	sdb_num_set (sdb, ""offset"", shdr->sh_offset, 0);
	sdb_num_set (sdb, ""link"", shdr->sh_link, 0);
	sdb_set (sdb, ""link_section_name"", link_section_name, 0);

	for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && (end - (char *)defs > i); ++cnt) {
		Sdb *sdb_verdef = sdb_new0 ();
		char *vstart = ((char*)defs) + i;
		char key[32] = {0};
		Elf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;
		Elf_(Verdaux) aux = {0};
		int j = 0;
		int isum = 0;

		r_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));
		verdef->vd_version = READ16 (dfs, j)
		verdef->vd_flags = READ16 (dfs, j)
		verdef->vd_ndx = READ16 (dfs, j)
		verdef->vd_cnt = READ16 (dfs, j)
		verdef->vd_hash = READ32 (dfs, j)
 		verdef->vd_aux = READ32 (dfs, j)
 		verdef->vd_next = READ32 (dfs, j)
 		int vdaux = verdef->vd_aux;
//flaw_line_below:
		if (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {
//fix_flaw_line_below:
//		if (vdaux < 1 || vstart + vdaux < vstart) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
		vstart += vdaux;
		if (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {
			sdb_free (sdb_verdef);
			goto out_error;
		}

		j = 0;
		aux.vda_name = READ32 (vstart, j)
		aux.vda_next = READ32 (vstart, j)

		isum = i + verdef->vd_aux;
		if (aux.vda_name > bin->dynstr_size) {
			sdb_free (sdb_verdef);
			goto out_error;
		}

		sdb_num_set (sdb_verdef, ""idx"", i, 0);
		sdb_num_set (sdb_verdef, ""vd_version"", verdef->vd_version, 0);
		sdb_num_set (sdb_verdef, ""vd_ndx"", verdef->vd_ndx, 0);
		sdb_num_set (sdb_verdef, ""vd_cnt"", verdef->vd_cnt, 0);
		sdb_set (sdb_verdef, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
		sdb_set (sdb_verdef, ""flags"", get_ver_flags (verdef->vd_flags), 0);

		for (j = 1; j < verdef->vd_cnt; ++j) {
			int k;
			Sdb *sdb_parent = sdb_new0 ();
			isum += aux.vda_next;
			vstart += aux.vda_next;
			if (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {
				sdb_free (sdb_verdef);
				sdb_free (sdb_parent);
				goto out_error;
			}
			k = 0;
			aux.vda_name = READ32 (vstart, k)
			aux.vda_next = READ32 (vstart, k)
			if (aux.vda_name > bin->dynstr_size) {
				sdb_free (sdb_verdef);
				sdb_free (sdb_parent);
				goto out_error;
			}
			sdb_num_set (sdb_parent, ""idx"", isum, 0);
			sdb_num_set (sdb_parent, ""parent"", j, 0);
			sdb_set (sdb_parent, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
			snprintf (key, sizeof (key), ""parent%d"", j - 1);
			sdb_ns_set (sdb_verdef, key, sdb_parent);
		}

		snprintf (key, sizeof (key), ""verdef%d"", cnt);
		sdb_ns_set (sdb, key, sdb_verdef);
		if (!verdef->vd_next) {
			sdb_free (sdb_verdef);
			goto out_error;
		}
		if ((st32)verdef->vd_next < 1) {
			eprintf (""Warning: Invalid vd_next in the ELF version\n"");
			break;
		}
		i += verdef->vd_next;
	}
	free (defs);
	return sdb;
out_error:
	free (defs);
	sdb_free (sdb);
	return NULL;
}
"
5450,183186,,Remote,Not required,Partial,CVE-2017-16359,https://www.cvedetails.com/cve/CVE-2017-16359/,CWE-476,Medium,,,,2017-11-01,4.3,"In radare 2.0.1, a pointer wraparound vulnerability exists in store_versioninfo_gnu_verdef() in libr/bin/format/elf/elf.c.",2017-11-13,,4,https://github.com/radare/radare2/commit/fbaf24bce7ea4211e4608b3ab6c1b45702cb243d,fbaf24bce7ea4211e4608b3ab6c1b45702cb243d,Fix #8764 a 3rd time since 2nd time is UB and can be optimized away,1,libr/bin/format/elf/elf.c,"{""sha"": ""0c47f22e674f8c11d7b3b0d8ad135dd7788670dc"", ""filename"": ""libr/bin/format/elf/elf.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/radareorg/radare2/blob/fbaf24bce7ea4211e4608b3ab6c1b45702cb243d/libr/bin/format/elf/elf.c"", ""raw_url"": ""https://github.com/radareorg/radare2/raw/fbaf24bce7ea4211e4608b3ab6c1b45702cb243d/libr/bin/format/elf/elf.c"", ""contents_url"": ""https://api.github.com/repos/radareorg/radare2/contents/libr/bin/format/elf/elf.c?ref=fbaf24bce7ea4211e4608b3ab6c1b45702cb243d"", ""patch"": ""@@ -734,6 +734,7 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)\n \tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {\n \t\tSdb *sdb_verdef = sdb_new0 ();\n \t\tchar *vstart = ((char*)defs) + i;\n+\t\tsize_t vstart_off = i;\n \t\tchar key[32] = {0};\n \t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n \t\tElf_(Verdaux) aux = {0};\n@@ -749,11 +750,12 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)\n \t\tverdef->vd_aux = READ32 (dfs, j)\n \t\tverdef->vd_next = READ32 (dfs, j)\n \t\tint vdaux = verdef->vd_aux;\n-\t\tif (vdaux < 1 || vstart + vdaux < vstart) {\n+\t\tif (vdaux < 1 || shdr->sh_size - vstart_off < vdaux) {\n \t\t\tsdb_free (sdb_verdef);\n \t\t\tgoto out_error;\n \t\t}\n \t\tvstart += vdaux;\n+\t\tvstart_off += vdaux;\n \t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n \t\t\tsdb_free (sdb_verdef);\n \t\t\tgoto out_error;\n@@ -781,6 +783,7 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)\n \t\t\tSdb *sdb_parent = sdb_new0 ();\n \t\t\tisum += aux.vda_next;\n \t\t\tvstart += aux.vda_next;\n+\t\t\tvstart_off += aux.vda_next;\n \t\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n \t\t\t\tsdb_free (sdb_verdef);\n \t\t\t\tsdb_free (sdb_parent);""}","static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {
	const char *section_name = """";
	const char *link_section_name = """";
	char *end = NULL;
	Elf_(Shdr) *link_shdr = NULL;
	ut8 dfs[sizeof (Elf_(Verdef))] = {0};
	Sdb *sdb;
	int cnt, i;
	if (shdr->sh_link > bin->ehdr.e_shnum) {
		return false;
	}
	link_shdr = &bin->shdr[shdr->sh_link];
	if ((int)shdr->sh_size < 1) {
		return false;
	}
	Elf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));
	if (!defs) {
		return false;
	}
	if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {
		section_name = &bin->shstrtab[shdr->sh_name];
	}
	if (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {
		link_section_name = &bin->shstrtab[link_shdr->sh_name];
	}
	if (!defs) {
		bprintf (""Warning: Cannot allocate memory (Check Elf_(Verdef))\n"");
		return NULL;
	}
	sdb = sdb_new0 ();
	end = (char *)defs + shdr->sh_size;
	sdb_set (sdb, ""section_name"", section_name, 0);
	sdb_num_set (sdb, ""entries"", shdr->sh_info, 0);
	sdb_num_set (sdb, ""addr"", shdr->sh_addr, 0);
	sdb_num_set (sdb, ""offset"", shdr->sh_offset, 0);
	sdb_num_set (sdb, ""link"", shdr->sh_link, 0);
	sdb_set (sdb, ""link_section_name"", link_section_name, 0);

 	for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {
 		Sdb *sdb_verdef = sdb_new0 ();
 		char *vstart = ((char*)defs) + i;
		size_t vstart_off = i;
 		char key[32] = {0};
 		Elf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;
 		Elf_(Verdaux) aux = {0};
		int j = 0;
		int isum = 0;

		r_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));
		verdef->vd_version = READ16 (dfs, j)
		verdef->vd_flags = READ16 (dfs, j)
		verdef->vd_ndx = READ16 (dfs, j)
		verdef->vd_cnt = READ16 (dfs, j)
		verdef->vd_hash = READ32 (dfs, j)
 		verdef->vd_aux = READ32 (dfs, j)
 		verdef->vd_next = READ32 (dfs, j)
 		int vdaux = verdef->vd_aux;
		if (vdaux < 1 || shdr->sh_size - vstart_off < vdaux) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
 		vstart += vdaux;
		vstart_off += vdaux;
 		if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {
 			sdb_free (sdb_verdef);
 			goto out_error;
		}

		j = 0;
		aux.vda_name = READ32 (vstart, j)
		aux.vda_next = READ32 (vstart, j)

		isum = i + verdef->vd_aux;
		if (aux.vda_name > bin->dynstr_size) {
			sdb_free (sdb_verdef);
			goto out_error;
		}

		sdb_num_set (sdb_verdef, ""idx"", i, 0);
		sdb_num_set (sdb_verdef, ""vd_version"", verdef->vd_version, 0);
		sdb_num_set (sdb_verdef, ""vd_ndx"", verdef->vd_ndx, 0);
		sdb_num_set (sdb_verdef, ""vd_cnt"", verdef->vd_cnt, 0);
		sdb_set (sdb_verdef, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
		sdb_set (sdb_verdef, ""flags"", get_ver_flags (verdef->vd_flags), 0);

		for (j = 1; j < verdef->vd_cnt; ++j) {
			int k;
 			Sdb *sdb_parent = sdb_new0 ();
 			isum += aux.vda_next;
 			vstart += aux.vda_next;
			vstart_off += aux.vda_next;
 			if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {
 				sdb_free (sdb_verdef);
 				sdb_free (sdb_parent);
				goto out_error;
			}
			k = 0;
			aux.vda_name = READ32 (vstart, k)
			aux.vda_next = READ32 (vstart, k)
			if (aux.vda_name > bin->dynstr_size) {
				sdb_free (sdb_verdef);
				sdb_free (sdb_parent);
				goto out_error;
			}
			sdb_num_set (sdb_parent, ""idx"", isum, 0);
			sdb_num_set (sdb_parent, ""parent"", j, 0);
			sdb_set (sdb_parent, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
			snprintf (key, sizeof (key), ""parent%d"", j - 1);
			sdb_ns_set (sdb_verdef, key, sdb_parent);
		}

		snprintf (key, sizeof (key), ""verdef%d"", cnt);
		sdb_ns_set (sdb, key, sdb_verdef);
		if (!verdef->vd_next) {
			sdb_free (sdb_verdef);
			goto out_error;
		}
		if ((st32)verdef->vd_next < 1) {
			eprintf (""Warning: Invalid vd_next in the ELF version\n"");
			break;
		}
		i += verdef->vd_next;
	}
	free (defs);
	return sdb;
out_error:
	free (defs);
	sdb_free (sdb);
	return NULL;
}
","static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {
	const char *section_name = """";
	const char *link_section_name = """";
	char *end = NULL;
	Elf_(Shdr) *link_shdr = NULL;
	ut8 dfs[sizeof (Elf_(Verdef))] = {0};
	Sdb *sdb;
	int cnt, i;
	if (shdr->sh_link > bin->ehdr.e_shnum) {
		return false;
	}
	link_shdr = &bin->shdr[shdr->sh_link];
	if ((int)shdr->sh_size < 1) {
		return false;
	}
	Elf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));
	if (!defs) {
		return false;
	}
	if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {
		section_name = &bin->shstrtab[shdr->sh_name];
	}
	if (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {
		link_section_name = &bin->shstrtab[link_shdr->sh_name];
	}
	if (!defs) {
		bprintf (""Warning: Cannot allocate memory (Check Elf_(Verdef))\n"");
		return NULL;
	}
	sdb = sdb_new0 ();
	end = (char *)defs + shdr->sh_size;
	sdb_set (sdb, ""section_name"", section_name, 0);
	sdb_num_set (sdb, ""entries"", shdr->sh_info, 0);
	sdb_num_set (sdb, ""addr"", shdr->sh_addr, 0);
	sdb_num_set (sdb, ""offset"", shdr->sh_offset, 0);
	sdb_num_set (sdb, ""link"", shdr->sh_link, 0);
	sdb_set (sdb, ""link_section_name"", link_section_name, 0);

 	for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {
 		Sdb *sdb_verdef = sdb_new0 ();
 		char *vstart = ((char*)defs) + i;
 		char key[32] = {0};
 		Elf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;
 		Elf_(Verdaux) aux = {0};
		int j = 0;
		int isum = 0;

		r_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));
		verdef->vd_version = READ16 (dfs, j)
		verdef->vd_flags = READ16 (dfs, j)
		verdef->vd_ndx = READ16 (dfs, j)
		verdef->vd_cnt = READ16 (dfs, j)
		verdef->vd_hash = READ32 (dfs, j)
 		verdef->vd_aux = READ32 (dfs, j)
 		verdef->vd_next = READ32 (dfs, j)
 		int vdaux = verdef->vd_aux;
		if (vdaux < 1 || vstart + vdaux < vstart) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
 		vstart += vdaux;
 		if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {
 			sdb_free (sdb_verdef);
 			goto out_error;
		}

		j = 0;
		aux.vda_name = READ32 (vstart, j)
		aux.vda_next = READ32 (vstart, j)

		isum = i + verdef->vd_aux;
		if (aux.vda_name > bin->dynstr_size) {
			sdb_free (sdb_verdef);
			goto out_error;
		}

		sdb_num_set (sdb_verdef, ""idx"", i, 0);
		sdb_num_set (sdb_verdef, ""vd_version"", verdef->vd_version, 0);
		sdb_num_set (sdb_verdef, ""vd_ndx"", verdef->vd_ndx, 0);
		sdb_num_set (sdb_verdef, ""vd_cnt"", verdef->vd_cnt, 0);
		sdb_set (sdb_verdef, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
		sdb_set (sdb_verdef, ""flags"", get_ver_flags (verdef->vd_flags), 0);

		for (j = 1; j < verdef->vd_cnt; ++j) {
			int k;
 			Sdb *sdb_parent = sdb_new0 ();
 			isum += aux.vda_next;
 			vstart += aux.vda_next;
 			if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {
 				sdb_free (sdb_verdef);
 				sdb_free (sdb_parent);
				goto out_error;
			}
			k = 0;
			aux.vda_name = READ32 (vstart, k)
			aux.vda_next = READ32 (vstart, k)
			if (aux.vda_name > bin->dynstr_size) {
				sdb_free (sdb_verdef);
				sdb_free (sdb_parent);
				goto out_error;
			}
			sdb_num_set (sdb_parent, ""idx"", isum, 0);
			sdb_num_set (sdb_parent, ""parent"", j, 0);
			sdb_set (sdb_parent, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
			snprintf (key, sizeof (key), ""parent%d"", j - 1);
			sdb_ns_set (sdb_verdef, key, sdb_parent);
		}

		snprintf (key, sizeof (key), ""verdef%d"", cnt);
		sdb_ns_set (sdb, key, sdb_verdef);
		if (!verdef->vd_next) {
			sdb_free (sdb_verdef);
			goto out_error;
		}
		if ((st32)verdef->vd_next < 1) {
			eprintf (""Warning: Invalid vd_next in the ELF version\n"");
			break;
		}
		i += verdef->vd_next;
	}
	free (defs);
	return sdb;
out_error:
	free (defs);
	sdb_free (sdb);
	return NULL;
}
",C,"		size_t vstart_off = i;
		if (vdaux < 1 || shdr->sh_size - vstart_off < vdaux) {
		vstart_off += vdaux;
			vstart_off += aux.vda_next;
","		if (vdaux < 1 || vstart + vdaux < vstart) {
",,"@@ -734,6 +734,7 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 	for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {
 		Sdb *sdb_verdef = sdb_new0 ();
 		char *vstart = ((char*)defs) + i;
+		size_t vstart_off = i;
 		char key[32] = {0};
 		Elf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;
 		Elf_(Verdaux) aux = {0};
@@ -749,11 +750,12 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 		verdef->vd_aux = READ32 (dfs, j)
 		verdef->vd_next = READ32 (dfs, j)
 		int vdaux = verdef->vd_aux;
-		if (vdaux < 1 || vstart + vdaux < vstart) {
+		if (vdaux < 1 || shdr->sh_size - vstart_off < vdaux) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
 		vstart += vdaux;
+		vstart_off += vdaux;
 		if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {
 			sdb_free (sdb_verdef);
 			goto out_error;
@@ -781,6 +783,7 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 			Sdb *sdb_parent = sdb_new0 ();
 			isum += aux.vda_next;
 			vstart += aux.vda_next;
+			vstart_off += aux.vda_next;
 			if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {
 				sdb_free (sdb_verdef);
 				sdb_free (sdb_parent);",radare2,fbaf24bce7ea4211e4608b3ab6c1b45702cb243d,7040985edabc2081e8f707ef98bf1faeedb34fe6,1,"static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {
	const char *section_name = """";
	const char *link_section_name = """";
	char *end = NULL;
	Elf_(Shdr) *link_shdr = NULL;
	ut8 dfs[sizeof (Elf_(Verdef))] = {0};
	Sdb *sdb;
	int cnt, i;
	if (shdr->sh_link > bin->ehdr.e_shnum) {
		return false;
	}
	link_shdr = &bin->shdr[shdr->sh_link];
	if ((int)shdr->sh_size < 1) {
		return false;
	}
	Elf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));
	if (!defs) {
		return false;
	}
	if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {
		section_name = &bin->shstrtab[shdr->sh_name];
	}
	if (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {
		link_section_name = &bin->shstrtab[link_shdr->sh_name];
	}
	if (!defs) {
		bprintf (""Warning: Cannot allocate memory (Check Elf_(Verdef))\n"");
		return NULL;
	}
	sdb = sdb_new0 ();
	end = (char *)defs + shdr->sh_size;
	sdb_set (sdb, ""section_name"", section_name, 0);
	sdb_num_set (sdb, ""entries"", shdr->sh_info, 0);
	sdb_num_set (sdb, ""addr"", shdr->sh_addr, 0);
	sdb_num_set (sdb, ""offset"", shdr->sh_offset, 0);
	sdb_num_set (sdb, ""link"", shdr->sh_link, 0);
	sdb_set (sdb, ""link_section_name"", link_section_name, 0);

 	for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {
 		Sdb *sdb_verdef = sdb_new0 ();
 		char *vstart = ((char*)defs) + i;
//fix_flaw_line_below:
//		size_t vstart_off = i;
 		char key[32] = {0};
 		Elf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;
 		Elf_(Verdaux) aux = {0};
		int j = 0;
		int isum = 0;

		r_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));
		verdef->vd_version = READ16 (dfs, j)
		verdef->vd_flags = READ16 (dfs, j)
		verdef->vd_ndx = READ16 (dfs, j)
		verdef->vd_cnt = READ16 (dfs, j)
		verdef->vd_hash = READ32 (dfs, j)
 		verdef->vd_aux = READ32 (dfs, j)
 		verdef->vd_next = READ32 (dfs, j)
 		int vdaux = verdef->vd_aux;
//flaw_line_below:
		if (vdaux < 1 || vstart + vdaux < vstart) {
//fix_flaw_line_below:
//		if (vdaux < 1 || shdr->sh_size - vstart_off < vdaux) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
 		vstart += vdaux;
//fix_flaw_line_below:
//		vstart_off += vdaux;
 		if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {
 			sdb_free (sdb_verdef);
 			goto out_error;
		}

		j = 0;
		aux.vda_name = READ32 (vstart, j)
		aux.vda_next = READ32 (vstart, j)

		isum = i + verdef->vd_aux;
		if (aux.vda_name > bin->dynstr_size) {
			sdb_free (sdb_verdef);
			goto out_error;
		}

		sdb_num_set (sdb_verdef, ""idx"", i, 0);
		sdb_num_set (sdb_verdef, ""vd_version"", verdef->vd_version, 0);
		sdb_num_set (sdb_verdef, ""vd_ndx"", verdef->vd_ndx, 0);
		sdb_num_set (sdb_verdef, ""vd_cnt"", verdef->vd_cnt, 0);
		sdb_set (sdb_verdef, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
		sdb_set (sdb_verdef, ""flags"", get_ver_flags (verdef->vd_flags), 0);

		for (j = 1; j < verdef->vd_cnt; ++j) {
			int k;
 			Sdb *sdb_parent = sdb_new0 ();
 			isum += aux.vda_next;
 			vstart += aux.vda_next;
//fix_flaw_line_below:
//			vstart_off += aux.vda_next;
 			if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {
 				sdb_free (sdb_verdef);
 				sdb_free (sdb_parent);
				goto out_error;
			}
			k = 0;
			aux.vda_name = READ32 (vstart, k)
			aux.vda_next = READ32 (vstart, k)
			if (aux.vda_name > bin->dynstr_size) {
				sdb_free (sdb_verdef);
				sdb_free (sdb_parent);
				goto out_error;
			}
			sdb_num_set (sdb_parent, ""idx"", isum, 0);
			sdb_num_set (sdb_parent, ""parent"", j, 0);
			sdb_set (sdb_parent, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
			snprintf (key, sizeof (key), ""parent%d"", j - 1);
			sdb_ns_set (sdb_verdef, key, sdb_parent);
		}

		snprintf (key, sizeof (key), ""verdef%d"", cnt);
		sdb_ns_set (sdb, key, sdb_verdef);
		if (!verdef->vd_next) {
			sdb_free (sdb_verdef);
			goto out_error;
		}
		if ((st32)verdef->vd_next < 1) {
			eprintf (""Warning: Invalid vd_next in the ELF version\n"");
			break;
		}
		i += verdef->vd_next;
	}
	free (defs);
	return sdb;
out_error:
	free (defs);
	sdb_free (sdb);
	return NULL;
}
"
5481,183217,,Remote,Not required,Partial,CVE-2017-9608,https://www.cvedetails.com/cve/CVE-2017-9608/,CWE-476,Medium,,,,2017-12-27,4.3,"The dnxhd decoder in FFmpeg before 3.2.6, and 3.3.x before 3.3.3 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted mov file.",2018-01-17,DoS ,7,https://github.com/FFmpeg/FFmpeg/commit/611b35627488a8d0763e75c25ee0875c5b7987dd,611b35627488a8d0763e75c25ee0875c5b7987dd,"avcodec/dnxhd_parser: Do not return invalid value from dnxhd_find_frame_end() on error

Fixes: Null pointer dereference

Fixes: CVE-2017-9608
Found-by: Yihan Lian
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",5,libavcodec/dnxhd_parser.c,"{""sha"": ""79ca1d6718845ffaab35bbf806f78795013c5510"", ""filename"": ""libavcodec/dnxhd_parser.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 5, ""changes"": 12, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/611b35627488a8d0763e75c25ee0875c5b7987dd/libavcodec/dnxhd_parser.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/611b35627488a8d0763e75c25ee0875c5b7987dd/libavcodec/dnxhd_parser.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavcodec/dnxhd_parser.c?ref=611b35627488a8d0763e75c25ee0875c5b7987dd"", ""patch"": ""@@ -68,16 +68,18 @@ static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                 dctx->w = (state >> 32) & 0xFFFF;\n             } else if (dctx->cur_byte == 42) {\n                 int cid = (state >> 32) & 0xFFFFFFFF;\n+                int remaining;\n \n                 if (cid <= 0)\n                     continue;\n \n-                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n-                if (dctx->remaining <= 0) {\n-                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n-                    if (dctx->remaining <= 0)\n-                        return dctx->remaining;\n+                remaining = avpriv_dnxhd_get_frame_size(cid);\n+                if (remaining <= 0) {\n+                    remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n+                    if (remaining <= 0)\n+                        continue;\n                 }\n+                dctx->remaining = remaining;\n                 if (buf_size - i + 47 >= dctx->remaining) {\n                     int remaining = dctx->remaining;\n ""}","static int dnxhd_find_frame_end(DNXHDParserContext *dctx,
                                const uint8_t *buf, int buf_size)
{
    ParseContext *pc = &dctx->pc;
    uint64_t state = pc->state64;
    int pic_found = pc->frame_start_found;
    int i = 0;

    if (!pic_found) {
        for (i = 0; i < buf_size; i++) {
            state = (state << 8) | buf[i];
            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {
                i++;
                pic_found = 1;
                dctx->cur_byte = 0;
                dctx->remaining = 0;
                break;
            }
        }
    }

    if (pic_found && !dctx->remaining) {
        if (!buf_size) /* EOF considered as end of frame */
            return 0;
        for (; i < buf_size; i++) {
            dctx->cur_byte++;
            state = (state << 8) | buf[i];

            if (dctx->cur_byte == 24) {
                dctx->h = (state >> 32) & 0xFFFF;
            } else if (dctx->cur_byte == 26) {
                 dctx->w = (state >> 32) & 0xFFFF;
             } else if (dctx->cur_byte == 42) {
                 int cid = (state >> 32) & 0xFFFFFFFF;
                int remaining;
 
                 if (cid <= 0)
                     continue;
 
                remaining = avpriv_dnxhd_get_frame_size(cid);
                if (remaining <= 0) {
                    remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                    if (remaining <= 0)
                        continue;
                 }
                dctx->remaining = remaining;
                 if (buf_size - i + 47 >= dctx->remaining) {
                     int remaining = dctx->remaining;
 
                    pc->frame_start_found = 0;
                    pc->state64 = -1;
                    dctx->cur_byte = 0;
                    dctx->remaining = 0;
                    return remaining;
                } else {
                    dctx->remaining -= buf_size;
                }
            }
        }
    } else if (pic_found) {
        if (dctx->remaining > buf_size) {
            dctx->remaining -= buf_size;
        } else {
            int remaining = dctx->remaining;

            pc->frame_start_found = 0;
            pc->state64 = -1;
            dctx->cur_byte = 0;
            dctx->remaining = 0;
            return remaining;
        }
    }
    pc->frame_start_found = pic_found;
    pc->state64 = state;
    return END_NOT_FOUND;
}
","static int dnxhd_find_frame_end(DNXHDParserContext *dctx,
                                const uint8_t *buf, int buf_size)
{
    ParseContext *pc = &dctx->pc;
    uint64_t state = pc->state64;
    int pic_found = pc->frame_start_found;
    int i = 0;

    if (!pic_found) {
        for (i = 0; i < buf_size; i++) {
            state = (state << 8) | buf[i];
            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {
                i++;
                pic_found = 1;
                dctx->cur_byte = 0;
                dctx->remaining = 0;
                break;
            }
        }
    }

    if (pic_found && !dctx->remaining) {
        if (!buf_size) /* EOF considered as end of frame */
            return 0;
        for (; i < buf_size; i++) {
            dctx->cur_byte++;
            state = (state << 8) | buf[i];

            if (dctx->cur_byte == 24) {
                dctx->h = (state >> 32) & 0xFFFF;
            } else if (dctx->cur_byte == 26) {
                 dctx->w = (state >> 32) & 0xFFFF;
             } else if (dctx->cur_byte == 42) {
                 int cid = (state >> 32) & 0xFFFFFFFF;
 
                 if (cid <= 0)
                     continue;
 
                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
                if (dctx->remaining <= 0) {
                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                    if (dctx->remaining <= 0)
                        return dctx->remaining;
                 }
                 if (buf_size - i + 47 >= dctx->remaining) {
                     int remaining = dctx->remaining;
 
                    pc->frame_start_found = 0;
                    pc->state64 = -1;
                    dctx->cur_byte = 0;
                    dctx->remaining = 0;
                    return remaining;
                } else {
                    dctx->remaining -= buf_size;
                }
            }
        }
    } else if (pic_found) {
        if (dctx->remaining > buf_size) {
            dctx->remaining -= buf_size;
        } else {
            int remaining = dctx->remaining;

            pc->frame_start_found = 0;
            pc->state64 = -1;
            dctx->cur_byte = 0;
            dctx->remaining = 0;
            return remaining;
        }
    }
    pc->frame_start_found = pic_found;
    pc->state64 = state;
    return END_NOT_FOUND;
}
",C,"                int remaining;
                remaining = avpriv_dnxhd_get_frame_size(cid);
                if (remaining <= 0) {
                    remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                    if (remaining <= 0)
                        continue;
                dctx->remaining = remaining;
","                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
                if (dctx->remaining <= 0) {
                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                    if (dctx->remaining <= 0)
                        return dctx->remaining;
",,"@@ -68,16 +68,18 @@ static int dnxhd_find_frame_end(DNXHDParserContext *dctx,
                 dctx->w = (state >> 32) & 0xFFFF;
             } else if (dctx->cur_byte == 42) {
                 int cid = (state >> 32) & 0xFFFFFFFF;
+                int remaining;
 
                 if (cid <= 0)
                     continue;
 
-                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
-                if (dctx->remaining <= 0) {
-                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
-                    if (dctx->remaining <= 0)
-                        return dctx->remaining;
+                remaining = avpriv_dnxhd_get_frame_size(cid);
+                if (remaining <= 0) {
+                    remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
+                    if (remaining <= 0)
+                        continue;
                 }
+                dctx->remaining = remaining;
                 if (buf_size - i + 47 >= dctx->remaining) {
                     int remaining = dctx->remaining;
 ",FFmpeg,611b35627488a8d0763e75c25ee0875c5b7987dd,b52b398c30a729dda38c0dd5a0cdeef160c4ca54,1,"static int dnxhd_find_frame_end(DNXHDParserContext *dctx,
                                const uint8_t *buf, int buf_size)
{
    ParseContext *pc = &dctx->pc;
    uint64_t state = pc->state64;
    int pic_found = pc->frame_start_found;
    int i = 0;

    if (!pic_found) {
        for (i = 0; i < buf_size; i++) {
            state = (state << 8) | buf[i];
            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {
                i++;
                pic_found = 1;
                dctx->cur_byte = 0;
                dctx->remaining = 0;
                break;
            }
        }
    }

    if (pic_found && !dctx->remaining) {
        if (!buf_size) /* EOF considered as end of frame */
            return 0;
        for (; i < buf_size; i++) {
            dctx->cur_byte++;
            state = (state << 8) | buf[i];

            if (dctx->cur_byte == 24) {
                dctx->h = (state >> 32) & 0xFFFF;
            } else if (dctx->cur_byte == 26) {
                 dctx->w = (state >> 32) & 0xFFFF;
             } else if (dctx->cur_byte == 42) {
                 int cid = (state >> 32) & 0xFFFFFFFF;
//fix_flaw_line_below:
//                int remaining;
 
                 if (cid <= 0)
                     continue;
 
//flaw_line_below:
                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
//flaw_line_below:
                if (dctx->remaining <= 0) {
//flaw_line_below:
                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
//flaw_line_below:
                    if (dctx->remaining <= 0)
//flaw_line_below:
                        return dctx->remaining;
//fix_flaw_line_below:
//                remaining = avpriv_dnxhd_get_frame_size(cid);
//fix_flaw_line_below:
//                if (remaining <= 0) {
//fix_flaw_line_below:
//                    remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
//fix_flaw_line_below:
//                    if (remaining <= 0)
//fix_flaw_line_below:
//                        continue;
                 }
//fix_flaw_line_below:
//                dctx->remaining = remaining;
                 if (buf_size - i + 47 >= dctx->remaining) {
                     int remaining = dctx->remaining;
 
                    pc->frame_start_found = 0;
                    pc->state64 = -1;
                    dctx->cur_byte = 0;
                    dctx->remaining = 0;
                    return remaining;
                } else {
                    dctx->remaining -= buf_size;
                }
            }
        }
    } else if (pic_found) {
        if (dctx->remaining > buf_size) {
            dctx->remaining -= buf_size;
        } else {
            int remaining = dctx->remaining;

            pc->frame_start_found = 0;
            pc->state64 = -1;
            dctx->cur_byte = 0;
            dctx->remaining = 0;
            return remaining;
        }
    }
    pc->frame_start_found = pic_found;
    pc->state64 = state;
    return END_NOT_FOUND;
}
"
5482,183218,,Remote,Not required,Partial,CVE-2017-9608,https://www.cvedetails.com/cve/CVE-2017-9608/,CWE-476,Medium,,,,2017-12-27,4.3,"The dnxhd decoder in FFmpeg before 3.2.6, and 3.3.x before 3.3.3 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted mov file.",2018-01-17,DoS ,7,https://github.com/FFmpeg/FFmpeg/commit/0a709e2a10b8288a0cc383547924ecfe285cef89,0a709e2a10b8288a0cc383547924ecfe285cef89,"avcodec/dnxhd_parser: Do not return invalid value from dnxhd_find_frame_end() on error

Fixes: Null pointer dereference

Fixes: CVE-2017-9608
Found-by: Yihan Lian
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>
(cherry picked from commit 611b35627488a8d0763e75c25ee0875c5b7987dd)
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",5,libavcodec/dnxhd_parser.c,"{""sha"": ""f1166be10077c0b4bbb636b08c3887d02afe14f7"", ""filename"": ""libavcodec/dnxhd_parser.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 5, ""changes"": 12, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/0a709e2a10b8288a0cc383547924ecfe285cef89/libavcodec/dnxhd_parser.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/0a709e2a10b8288a0cc383547924ecfe285cef89/libavcodec/dnxhd_parser.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavcodec/dnxhd_parser.c?ref=0a709e2a10b8288a0cc383547924ecfe285cef89"", ""patch"": ""@@ -81,16 +81,18 @@ static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                 dctx->w = (state >> 32) & 0xFFFF;\n             } else if (dctx->cur_byte == 42) {\n                 int cid = (state >> 32) & 0xFFFFFFFF;\n+                int remaining;\n \n                 if (cid <= 0)\n                     continue;\n \n-                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n-                if (dctx->remaining <= 0) {\n-                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n-                    if (dctx->remaining <= 0)\n-                        return dctx->remaining;\n+                remaining = avpriv_dnxhd_get_frame_size(cid);\n+                if (remaining <= 0) {\n+                    remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n+                    if (remaining <= 0)\n+                        continue;\n                 }\n+                dctx->remaining = remaining;\n                 if (buf_size - i + 47 >= dctx->remaining) {\n                     int remaining = dctx->remaining;\n ""}","static int dnxhd_find_frame_end(DNXHDParserContext *dctx,
                                const uint8_t *buf, int buf_size)
{
    ParseContext *pc = &dctx->pc;
    uint64_t state = pc->state64;
    int pic_found = pc->frame_start_found;
    int i = 0;

    if (!pic_found) {
        for (i = 0; i < buf_size; i++) {
            state = (state << 8) | buf[i];
            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {
                i++;
                pic_found = 1;
                dctx->cur_byte = 0;
                dctx->remaining = 0;
                break;
            }
        }
    }

    if (pic_found && !dctx->remaining) {
        if (!buf_size) /* EOF considered as end of frame */
            return 0;
        for (; i < buf_size; i++) {
            dctx->cur_byte++;
            state = (state << 8) | buf[i];

            if (dctx->cur_byte == 24) {
                dctx->h = (state >> 32) & 0xFFFF;
            } else if (dctx->cur_byte == 26) {
                 dctx->w = (state >> 32) & 0xFFFF;
             } else if (dctx->cur_byte == 42) {
                 int cid = (state >> 32) & 0xFFFFFFFF;
                int remaining;
 
                 if (cid <= 0)
                     continue;
 
                remaining = avpriv_dnxhd_get_frame_size(cid);
                if (remaining <= 0) {
                    remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                    if (remaining <= 0)
                        continue;
                 }
                dctx->remaining = remaining;
                 if (buf_size - i + 47 >= dctx->remaining) {
                     int remaining = dctx->remaining;
 
                    pc->frame_start_found = 0;
                    pc->state64 = -1;
                    dctx->cur_byte = 0;
                    dctx->remaining = 0;
                    return remaining;
                } else {
                    dctx->remaining -= buf_size;
                }
            }
        }
    } else if (pic_found) {
        if (dctx->remaining > buf_size) {
            dctx->remaining -= buf_size;
        } else {
            int remaining = dctx->remaining;

            pc->frame_start_found = 0;
            pc->state64 = -1;
            dctx->cur_byte = 0;
            dctx->remaining = 0;
            return remaining;
        }
    }
    pc->frame_start_found = pic_found;
    pc->state64 = state;
    return END_NOT_FOUND;
}
","static int dnxhd_find_frame_end(DNXHDParserContext *dctx,
                                const uint8_t *buf, int buf_size)
{
    ParseContext *pc = &dctx->pc;
    uint64_t state = pc->state64;
    int pic_found = pc->frame_start_found;
    int i = 0;

    if (!pic_found) {
        for (i = 0; i < buf_size; i++) {
            state = (state << 8) | buf[i];
            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {
                i++;
                pic_found = 1;
                dctx->cur_byte = 0;
                dctx->remaining = 0;
                break;
            }
        }
    }

    if (pic_found && !dctx->remaining) {
        if (!buf_size) /* EOF considered as end of frame */
            return 0;
        for (; i < buf_size; i++) {
            dctx->cur_byte++;
            state = (state << 8) | buf[i];

            if (dctx->cur_byte == 24) {
                dctx->h = (state >> 32) & 0xFFFF;
            } else if (dctx->cur_byte == 26) {
                 dctx->w = (state >> 32) & 0xFFFF;
             } else if (dctx->cur_byte == 42) {
                 int cid = (state >> 32) & 0xFFFFFFFF;
 
                 if (cid <= 0)
                     continue;
 
                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
                if (dctx->remaining <= 0) {
                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                    if (dctx->remaining <= 0)
                        return dctx->remaining;
                 }
                 if (buf_size - i + 47 >= dctx->remaining) {
                     int remaining = dctx->remaining;
 
                    pc->frame_start_found = 0;
                    pc->state64 = -1;
                    dctx->cur_byte = 0;
                    dctx->remaining = 0;
                    return remaining;
                } else {
                    dctx->remaining -= buf_size;
                }
            }
        }
    } else if (pic_found) {
        if (dctx->remaining > buf_size) {
            dctx->remaining -= buf_size;
        } else {
            int remaining = dctx->remaining;

            pc->frame_start_found = 0;
            pc->state64 = -1;
            dctx->cur_byte = 0;
            dctx->remaining = 0;
            return remaining;
        }
    }
    pc->frame_start_found = pic_found;
    pc->state64 = state;
    return END_NOT_FOUND;
}
",C,"                int remaining;
                remaining = avpriv_dnxhd_get_frame_size(cid);
                if (remaining <= 0) {
                    remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                    if (remaining <= 0)
                        continue;
                dctx->remaining = remaining;
","                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
                if (dctx->remaining <= 0) {
                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                    if (dctx->remaining <= 0)
                        return dctx->remaining;
",,"@@ -81,16 +81,18 @@ static int dnxhd_find_frame_end(DNXHDParserContext *dctx,
                 dctx->w = (state >> 32) & 0xFFFF;
             } else if (dctx->cur_byte == 42) {
                 int cid = (state >> 32) & 0xFFFFFFFF;
+                int remaining;
 
                 if (cid <= 0)
                     continue;
 
-                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
-                if (dctx->remaining <= 0) {
-                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
-                    if (dctx->remaining <= 0)
-                        return dctx->remaining;
+                remaining = avpriv_dnxhd_get_frame_size(cid);
+                if (remaining <= 0) {
+                    remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
+                    if (remaining <= 0)
+                        continue;
                 }
+                dctx->remaining = remaining;
                 if (buf_size - i + 47 >= dctx->remaining) {
                     int remaining = dctx->remaining;
 ",FFmpeg,0a709e2a10b8288a0cc383547924ecfe285cef89,10d821309b02014d7663b63635ff2a3294382558,1,"static int dnxhd_find_frame_end(DNXHDParserContext *dctx,
                                const uint8_t *buf, int buf_size)
{
    ParseContext *pc = &dctx->pc;
    uint64_t state = pc->state64;
    int pic_found = pc->frame_start_found;
    int i = 0;

    if (!pic_found) {
        for (i = 0; i < buf_size; i++) {
            state = (state << 8) | buf[i];
            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {
                i++;
                pic_found = 1;
                dctx->cur_byte = 0;
                dctx->remaining = 0;
                break;
            }
        }
    }

    if (pic_found && !dctx->remaining) {
        if (!buf_size) /* EOF considered as end of frame */
            return 0;
        for (; i < buf_size; i++) {
            dctx->cur_byte++;
            state = (state << 8) | buf[i];

            if (dctx->cur_byte == 24) {
                dctx->h = (state >> 32) & 0xFFFF;
            } else if (dctx->cur_byte == 26) {
                 dctx->w = (state >> 32) & 0xFFFF;
             } else if (dctx->cur_byte == 42) {
                 int cid = (state >> 32) & 0xFFFFFFFF;
//fix_flaw_line_below:
//                int remaining;
 
                 if (cid <= 0)
                     continue;
 
//flaw_line_below:
                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
//flaw_line_below:
                if (dctx->remaining <= 0) {
//flaw_line_below:
                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
//flaw_line_below:
                    if (dctx->remaining <= 0)
//flaw_line_below:
                        return dctx->remaining;
//fix_flaw_line_below:
//                remaining = avpriv_dnxhd_get_frame_size(cid);
//fix_flaw_line_below:
//                if (remaining <= 0) {
//fix_flaw_line_below:
//                    remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
//fix_flaw_line_below:
//                    if (remaining <= 0)
//fix_flaw_line_below:
//                        continue;
                 }
//fix_flaw_line_below:
//                dctx->remaining = remaining;
                 if (buf_size - i + 47 >= dctx->remaining) {
                     int remaining = dctx->remaining;
 
                    pc->frame_start_found = 0;
                    pc->state64 = -1;
                    dctx->cur_byte = 0;
                    dctx->remaining = 0;
                    return remaining;
                } else {
                    dctx->remaining -= buf_size;
                }
            }
        }
    } else if (pic_found) {
        if (dctx->remaining > buf_size) {
            dctx->remaining -= buf_size;
        } else {
            int remaining = dctx->remaining;

            pc->frame_start_found = 0;
            pc->state64 = -1;
            dctx->cur_byte = 0;
            dctx->remaining = 0;
            return remaining;
        }
    }
    pc->frame_start_found = pic_found;
    pc->state64 = state;
    return END_NOT_FOUND;
}
"
5546,183282,,Remote,Not required,Partial,CVE-2016-10129,https://www.cvedetails.com/cve/CVE-2016-10129/,CWE-476,Low,,,,2017-03-24,5.0,The Git Smart Protocol support in libgit2 before 0.24.6 and 0.25.x before 0.25.1 allows remote attackers to cause a denial of service (NULL pointer dereference) via an empty packet line.,2017-03-27,DoS ,0,https://github.com/libgit2/libgit2/commit/84d30d569ada986f3eef527cbdb932643c2dd037,84d30d569ada986f3eef527cbdb932643c2dd037,"smart_pkt: treat empty packet lines as error

The Git protocol does not specify what should happen in the case
of an empty packet line (that is a packet line ""0004""). We
currently indicate success, but do not return a packet in the
case where we hit an empty line. The smart protocol was not
prepared to handle such packets in all cases, though, resulting
in a `NULL` pointer dereference.

Fix the issue by returning an error instead. As such kind of
packets is not even specified by upstream, this is the right
thing to do.",7,src/transports/smart_protocol.c,"{""sha"": ""e05196cd8a4174f12aa751dba2a7d39a465f7633"", ""filename"": ""src/transports/smart_pkt.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/libgit2/libgit2/blob/84d30d569ada986f3eef527cbdb932643c2dd037/src/transports/smart_pkt.c"", ""raw_url"": ""https://github.com/libgit2/libgit2/raw/84d30d569ada986f3eef527cbdb932643c2dd037/src/transports/smart_pkt.c"", ""contents_url"": ""https://api.github.com/repos/libgit2/libgit2/contents/src/transports/smart_pkt.c?ref=84d30d569ada986f3eef527cbdb932643c2dd037"", ""patch"": ""@@ -437,13 +437,13 @@ int git_pkt_parse_line(\n \n \tline += PKT_LEN_SIZE;\n \t/*\n-\t * TODO: How do we deal with empty lines? Try again? with the next\n-\t * line?\n+\t * The Git protocol does not specify empty lines as part\n+\t * of the protocol. Not knowing what to do with an empty\n+\t * line, we should return an error upon hitting one.\n \t */\n \tif (len == PKT_LEN_SIZE) {\n-\t\t*head = NULL;\n-\t\t*out = line;\n-\t\treturn 0;\n+\t\tgiterr_set_str(GITERR_NET, \""Invalid empty packet\"");\n+\t\treturn GIT_ERROR;\n \t}\n \n \tif (len == 0) { /* Flush pkt */""}<_**next**_>{""sha"": ""02e1ecf7475c20ab046831f35ad1f34623c96ba7"", ""filename"": ""src/transports/smart_protocol.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 11, ""changes"": 11, ""blob_url"": ""https://github.com/libgit2/libgit2/blob/84d30d569ada986f3eef527cbdb932643c2dd037/src/transports/smart_protocol.c"", ""raw_url"": ""https://github.com/libgit2/libgit2/raw/84d30d569ada986f3eef527cbdb932643c2dd037/src/transports/smart_protocol.c"", ""contents_url"": ""https://api.github.com/repos/libgit2/libgit2/contents/src/transports/smart_protocol.c?ref=84d30d569ada986f3eef527cbdb932643c2dd037"", ""patch"": ""@@ -759,14 +759,6 @@ static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt,\n \t\tline_len -= (line_end - line);\n \t\tline = line_end;\n \n-\t\t/* When a valid packet with no content has been\n-\t\t * read, git_pkt_parse_line does not report an\n-\t\t * error, but the pkt pointer has not been set.\n-\t\t * Handle this by skipping over empty packets.\n-\t\t */\n-\t\tif (pkt == NULL)\n-\t\t\tcontinue;\n-\n \t\terror = add_push_report_pkt(push, pkt);\n \n \t\tgit_pkt_free(pkt);\n@@ -821,9 +813,6 @@ static int parse_report(transport_smart *transport, git_push *push)\n \n \t\terror = 0;\n \n-\t\tif (pkt == NULL)\n-\t\t\tcontinue;\n-\n \t\tswitch (pkt->type) {\n \t\t\tcase GIT_PKT_DATA:\n \t\t\t\t/* This is a sideband packet which contains other packets */""}","static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)
{
	git_pkt *pkt;
	const char *line, *line_end;
	size_t line_len;
	int error;
	int reading_from_buf = data_pkt_buf->size > 0;

	if (reading_from_buf) {
		/* We had an existing partial packet, so add the new
		 * packet to the buffer and parse the whole thing */
		git_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);
		line = data_pkt_buf->ptr;
		line_len = data_pkt_buf->size;
	}
	else {
		line = data_pkt->data;
		line_len = data_pkt->len;
	}

	while (line_len > 0) {
		error = git_pkt_parse_line(&pkt, line, &line_end, line_len);

		if (error == GIT_EBUFS) {
			/* Buffer the data when the inner packet is split
			 * across multiple sideband packets */
			if (!reading_from_buf)
				git_buf_put(data_pkt_buf, line, line_len);
			error = 0;
			goto done;
		}
		else if (error < 0)
			goto done;

		/* Advance in the buffer */
 		line_len -= (line_end - line);
 		line = line_end;
 
 		error = add_push_report_pkt(push, pkt);
 
 		git_pkt_free(pkt);

		if (error < 0 && error != GIT_ITEROVER)
			goto done;
	}

	error = 0;

done:
	if (reading_from_buf)
		git_buf_consume(data_pkt_buf, line_end);
	return error;
}
","static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)
{
	git_pkt *pkt;
	const char *line, *line_end;
	size_t line_len;
	int error;
	int reading_from_buf = data_pkt_buf->size > 0;

	if (reading_from_buf) {
		/* We had an existing partial packet, so add the new
		 * packet to the buffer and parse the whole thing */
		git_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);
		line = data_pkt_buf->ptr;
		line_len = data_pkt_buf->size;
	}
	else {
		line = data_pkt->data;
		line_len = data_pkt->len;
	}

	while (line_len > 0) {
		error = git_pkt_parse_line(&pkt, line, &line_end, line_len);

		if (error == GIT_EBUFS) {
			/* Buffer the data when the inner packet is split
			 * across multiple sideband packets */
			if (!reading_from_buf)
				git_buf_put(data_pkt_buf, line, line_len);
			error = 0;
			goto done;
		}
		else if (error < 0)
			goto done;

		/* Advance in the buffer */
 		line_len -= (line_end - line);
 		line = line_end;
 
		/* When a valid packet with no content has been
		 * read, git_pkt_parse_line does not report an
		 * error, but the pkt pointer has not been set.
		 * Handle this by skipping over empty packets.
		 */
		if (pkt == NULL)
			continue;
 		error = add_push_report_pkt(push, pkt);
 
 		git_pkt_free(pkt);

		if (error < 0 && error != GIT_ITEROVER)
			goto done;
	}

	error = 0;

done:
	if (reading_from_buf)
		git_buf_consume(data_pkt_buf, line_end);
	return error;
}
",C,,"		/* When a valid packet with no content has been
		 * read, git_pkt_parse_line does not report an
		 * error, but the pkt pointer has not been set.
		 * Handle this by skipping over empty packets.
		 */
		if (pkt == NULL)
			continue;
",,"@@ -759,14 +759,6 @@ static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt,
 		line_len -= (line_end - line);
 		line = line_end;
 
-		/* When a valid packet with no content has been
-		 * read, git_pkt_parse_line does not report an
-		 * error, but the pkt pointer has not been set.
-		 * Handle this by skipping over empty packets.
-		 */
-		if (pkt == NULL)
-			continue;
-
 		error = add_push_report_pkt(push, pkt);
 
 		git_pkt_free(pkt);
@@ -821,9 +813,6 @@ static int parse_report(transport_smart *transport, git_push *push)
 
 		error = 0;
 
-		if (pkt == NULL)
-			continue;
-
 		switch (pkt->type) {
 			case GIT_PKT_DATA:
 				/* This is a sideband packet which contains other packets */",libgit2,84d30d569ada986f3eef527cbdb932643c2dd037,4ac39c76c0153d1ee6889a0984c39e97731684b2,1,"static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)
{
	git_pkt *pkt;
	const char *line, *line_end;
	size_t line_len;
	int error;
	int reading_from_buf = data_pkt_buf->size > 0;

	if (reading_from_buf) {
		/* We had an existing partial packet, so add the new
		 * packet to the buffer and parse the whole thing */
		git_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);
		line = data_pkt_buf->ptr;
		line_len = data_pkt_buf->size;
	}
	else {
		line = data_pkt->data;
		line_len = data_pkt->len;
	}

	while (line_len > 0) {
		error = git_pkt_parse_line(&pkt, line, &line_end, line_len);

		if (error == GIT_EBUFS) {
			/* Buffer the data when the inner packet is split
			 * across multiple sideband packets */
			if (!reading_from_buf)
				git_buf_put(data_pkt_buf, line, line_len);
			error = 0;
			goto done;
		}
		else if (error < 0)
			goto done;

		/* Advance in the buffer */
 		line_len -= (line_end - line);
 		line = line_end;
 
//flaw_line_below:
		/* When a valid packet with no content has been
//flaw_line_below:
		 * read, git_pkt_parse_line does not report an
//flaw_line_below:
		 * error, but the pkt pointer has not been set.
//flaw_line_below:
		 * Handle this by skipping over empty packets.
//flaw_line_below:
		 */
//flaw_line_below:
		if (pkt == NULL)
//flaw_line_below:
			continue;
//flaw_line_below:

 		error = add_push_report_pkt(push, pkt);
 
 		git_pkt_free(pkt);

		if (error < 0 && error != GIT_ITEROVER)
			goto done;
	}

	error = 0;

done:
	if (reading_from_buf)
		git_buf_consume(data_pkt_buf, line_end);
	return error;
}
"
5568,183304,,Remote,Not required,Partial,CVE-2015-4054,https://www.cvedetails.com/cve/CVE-2015-4054/,CWE-476,Low,,,,2017-05-23,5.0,PgBouncer before 1.5.5 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) by sending a password packet before a startup packet.,2017-06-02,DoS ,6,https://github.com/pgbouncer/pgbouncer/commit/edab5be6665b9e8de66c25ba527509b229468573,edab5be6665b9e8de66c25ba527509b229468573,"Check if auth_user is set.

Fixes a crash if password packet appears before startup packet (#42).",0,src/client.c,"{""sha"": ""49b262445a1ca126783686963669899e073ab5b4"", ""filename"": ""src/client.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/pgbouncer/pgbouncer/blob/edab5be6665b9e8de66c25ba527509b229468573/src/client.c"", ""raw_url"": ""https://github.com/pgbouncer/pgbouncer/raw/edab5be6665b9e8de66c25ba527509b229468573/src/client.c"", ""contents_url"": ""https://api.github.com/repos/pgbouncer/pgbouncer/contents/src/client.c?ref=edab5be6665b9e8de66c25ba527509b229468573"", ""patch"": ""@@ -39,6 +39,12 @@ static bool check_client_passwd(PgSocket *client, const char *passwd)\n \tconst char *correct;\n \tPgUser *user = client->auth_user;\n \n+\t/* auth_user may be missing */\n+\tif (!user) {\n+\t\tslog_error(client, \""Password packet before auth packet?\"");\n+\t\treturn false;\n+\t}\n+\n \t/* disallow empty passwords */\n \tif (!*passwd || !*user->passwd)\n \t\treturn false;""}","static bool check_client_passwd(PgSocket *client, const char *passwd)
{
	char md5[MD5_PASSWD_LEN + 1];
 	const char *correct;
 	PgUser *user = client->auth_user;
 
	/* auth_user may be missing */
	if (!user) {
		slog_error(client, ""Password packet before auth packet?"");
		return false;
	}

 	/* disallow empty passwords */
 	if (!*passwd || !*user->passwd)
 		return false;

	switch (cf_auth_type) {
	case AUTH_PLAIN:
		return strcmp(user->passwd, passwd) == 0;
	case AUTH_CRYPT:
		correct = crypt(user->passwd, (char *)client->tmp_login_salt);
		return correct && strcmp(correct, passwd) == 0;
	case AUTH_MD5:
		if (strlen(passwd) != MD5_PASSWD_LEN)
			return false;
		if (!isMD5(user->passwd))
			pg_md5_encrypt(user->passwd, user->name, strlen(user->name), user->passwd);
		pg_md5_encrypt(user->passwd + 3, (char *)client->tmp_login_salt, 4, md5);
		return strcmp(md5, passwd) == 0;
	}
	return false;
}
","static bool check_client_passwd(PgSocket *client, const char *passwd)
{
	char md5[MD5_PASSWD_LEN + 1];
 	const char *correct;
 	PgUser *user = client->auth_user;
 
 	/* disallow empty passwords */
 	if (!*passwd || !*user->passwd)
 		return false;

	switch (cf_auth_type) {
	case AUTH_PLAIN:
		return strcmp(user->passwd, passwd) == 0;
	case AUTH_CRYPT:
		correct = crypt(user->passwd, (char *)client->tmp_login_salt);
		return correct && strcmp(correct, passwd) == 0;
	case AUTH_MD5:
		if (strlen(passwd) != MD5_PASSWD_LEN)
			return false;
		if (!isMD5(user->passwd))
			pg_md5_encrypt(user->passwd, user->name, strlen(user->name), user->passwd);
		pg_md5_encrypt(user->passwd + 3, (char *)client->tmp_login_salt, 4, md5);
		return strcmp(md5, passwd) == 0;
	}
	return false;
}
",C,"	/* auth_user may be missing */
	if (!user) {
		slog_error(client, ""Password packet before auth packet?"");
		return false;
	}

",,,"@@ -39,6 +39,12 @@ static bool check_client_passwd(PgSocket *client, const char *passwd)
 	const char *correct;
 	PgUser *user = client->auth_user;
 
+	/* auth_user may be missing */
+	if (!user) {
+		slog_error(client, ""Password packet before auth packet?"");
+		return false;
+	}
+
 	/* disallow empty passwords */
 	if (!*passwd || !*user->passwd)
 		return false;",pgbouncer,edab5be6665b9e8de66c25ba527509b229468573,31bedb6e6338a66b48f883c224a8bb8a19fde9bb,1,"static bool check_client_passwd(PgSocket *client, const char *passwd)
{
	char md5[MD5_PASSWD_LEN + 1];
 	const char *correct;
 	PgUser *user = client->auth_user;
 
//fix_flaw_line_below:
//	/* auth_user may be missing */
//fix_flaw_line_below:
//	if (!user) {
//fix_flaw_line_below:
//		slog_error(client, ""Password packet before auth packet?"");
//fix_flaw_line_below:
//		return false;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	/* disallow empty passwords */
 	if (!*passwd || !*user->passwd)
 		return false;

	switch (cf_auth_type) {
	case AUTH_PLAIN:
		return strcmp(user->passwd, passwd) == 0;
	case AUTH_CRYPT:
		correct = crypt(user->passwd, (char *)client->tmp_login_salt);
		return correct && strcmp(correct, passwd) == 0;
	case AUTH_MD5:
		if (strlen(passwd) != MD5_PASSWD_LEN)
			return false;
		if (!isMD5(user->passwd))
			pg_md5_encrypt(user->passwd, user->name, strlen(user->name), user->passwd);
		pg_md5_encrypt(user->passwd + 3, (char *)client->tmp_login_salt, 4, md5);
		return strcmp(md5, passwd) == 0;
	}
	return false;
}
"
5652,183388,,Remote,Not required,Partial,CVE-2019-12109,https://www.cvedetails.com/cve/CVE-2019-12109/,CWE-476,Low,,,,2019-05-15,5.0,A Denial Of Service vulnerability in MiniUPnP MiniUPnPd through 2.1 exists due to a NULL pointer dereference in GetOutboundPinholeTimeout in upnpsoap.c for rem_port.,2019-05-30,DoS ,1,https://github.com/miniupnp/miniupnp/commit/86030db849260dd8fb2ed975b9890aef1b62b692,86030db849260dd8fb2ed975b9890aef1b62b692,fix error from commit 13585f15c7f7dc28bbbba1661efb280d530d114c,1,miniupnpd/upnpsoap.c,"{""sha"": ""acd7fedf35cf8cada3370a39868c3c52e93ce25f"", ""filename"": ""miniupnpd/upnpsoap.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/miniupnp/miniupnp/blob/86030db849260dd8fb2ed975b9890aef1b62b692/miniupnpd/upnpsoap.c"", ""raw_url"": ""https://github.com/miniupnp/miniupnp/raw/86030db849260dd8fb2ed975b9890aef1b62b692/miniupnpd/upnpsoap.c"", ""contents_url"": ""https://api.github.com/repos/miniupnp/miniupnp/contents/miniupnpd/upnpsoap.c?ref=86030db849260dd8fb2ed975b9890aef1b62b692"", ""patch"": ""@@ -1850,7 +1850,7 @@ GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char *\n \trem_port = GetValueFromNameValueList(&data, \""RemotePort\"");\n \tprotocol = GetValueFromNameValueList(&data, \""Protocol\"");\n \n-\tif (!int_port || !ext_port || !protocol)\n+\tif (!int_port || !rem_port || !protocol)\n \t{\n \t\tClearNameValueList(&data);\n \t\tSoapError(h, 402, \""Invalid Args\"");""}","GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)
{
	int r;

	static const char resp[] =
		""<u:%sResponse ""
		""xmlns:u=\""%s\"">""
		""<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>""
		""</u:%sResponse>"";

	char body[512];
	int bodylen;
	struct NameValueParserData data;
	char * int_ip, * int_port, * rem_host, * rem_port, * protocol;
	int opt=0;
	/*int proto=0;*/
	unsigned short iport, rport;

	if (GETFLAG(IPV6FCFWDISABLEDMASK))
	{
		SoapError(h, 702, ""FirewallDisabled"");
		return;
	}

	ParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);
	int_ip = GetValueFromNameValueList(&data, ""InternalClient"");
	int_port = GetValueFromNameValueList(&data, ""InternalPort"");
	rem_host = GetValueFromNameValueList(&data, ""RemoteHost"");
 	rem_port = GetValueFromNameValueList(&data, ""RemotePort"");
 	protocol = GetValueFromNameValueList(&data, ""Protocol"");
 
	if (!int_port || !rem_port || !protocol)
 	{
 		ClearNameValueList(&data);
 		SoapError(h, 402, ""Invalid Args"");
		return;
	}

	rport = (unsigned short)atoi(rem_port);
	iport = (unsigned short)atoi(int_port);
	/*proto = atoi(protocol);*/

	syslog(LOG_INFO, ""%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s"", action, int_ip, iport,rem_host, rport, protocol);

	/* TODO */
	r = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/

	switch(r)
	{
		case 1:	/* success */
			bodylen = snprintf(body, sizeof(body), resp,
			                   action, ns/*""urn:schemas-upnp-org:service:WANIPv6FirewallControl:1""*/,
			                   opt, action);
			BuildSendAndCloseSoapResp(h, body, bodylen);
			break;
		case -5:	/* Protocol not supported */
			SoapError(h, 705, ""ProtocolNotSupported"");
			break;
		default:
			SoapError(h, 501, ""ActionFailed"");
	}
	ClearNameValueList(&data);
}
","GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)
{
	int r;

	static const char resp[] =
		""<u:%sResponse ""
		""xmlns:u=\""%s\"">""
		""<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>""
		""</u:%sResponse>"";

	char body[512];
	int bodylen;
	struct NameValueParserData data;
	char * int_ip, * int_port, * rem_host, * rem_port, * protocol;
	int opt=0;
	/*int proto=0;*/
	unsigned short iport, rport;

	if (GETFLAG(IPV6FCFWDISABLEDMASK))
	{
		SoapError(h, 702, ""FirewallDisabled"");
		return;
	}

	ParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);
	int_ip = GetValueFromNameValueList(&data, ""InternalClient"");
	int_port = GetValueFromNameValueList(&data, ""InternalPort"");
	rem_host = GetValueFromNameValueList(&data, ""RemoteHost"");
 	rem_port = GetValueFromNameValueList(&data, ""RemotePort"");
 	protocol = GetValueFromNameValueList(&data, ""Protocol"");
 
	if (!int_port || !ext_port || !protocol)
 	{
 		ClearNameValueList(&data);
 		SoapError(h, 402, ""Invalid Args"");
		return;
	}

	rport = (unsigned short)atoi(rem_port);
	iport = (unsigned short)atoi(int_port);
	/*proto = atoi(protocol);*/

	syslog(LOG_INFO, ""%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s"", action, int_ip, iport,rem_host, rport, protocol);

	/* TODO */
	r = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/

	switch(r)
	{
		case 1:	/* success */
			bodylen = snprintf(body, sizeof(body), resp,
			                   action, ns/*""urn:schemas-upnp-org:service:WANIPv6FirewallControl:1""*/,
			                   opt, action);
			BuildSendAndCloseSoapResp(h, body, bodylen);
			break;
		case -5:	/* Protocol not supported */
			SoapError(h, 705, ""ProtocolNotSupported"");
			break;
		default:
			SoapError(h, 501, ""ActionFailed"");
	}
	ClearNameValueList(&data);
}
",C,"	if (!int_port || !rem_port || !protocol)
","	if (!int_port || !ext_port || !protocol)
",,"@@ -1850,7 +1850,7 @@ GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char *
 	rem_port = GetValueFromNameValueList(&data, ""RemotePort"");
 	protocol = GetValueFromNameValueList(&data, ""Protocol"");
 
-	if (!int_port || !ext_port || !protocol)
+	if (!int_port || !rem_port || !protocol)
 	{
 		ClearNameValueList(&data);
 		SoapError(h, 402, ""Invalid Args"");",miniupnp,86030db849260dd8fb2ed975b9890aef1b62b692,cb8a02af7a5677cf608e86d57ab04241cf34e24f,1,"GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)
{
	int r;

	static const char resp[] =
		""<u:%sResponse ""
		""xmlns:u=\""%s\"">""
		""<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>""
		""</u:%sResponse>"";

	char body[512];
	int bodylen;
	struct NameValueParserData data;
	char * int_ip, * int_port, * rem_host, * rem_port, * protocol;
	int opt=0;
	/*int proto=0;*/
	unsigned short iport, rport;

	if (GETFLAG(IPV6FCFWDISABLEDMASK))
	{
		SoapError(h, 702, ""FirewallDisabled"");
		return;
	}

	ParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);
	int_ip = GetValueFromNameValueList(&data, ""InternalClient"");
	int_port = GetValueFromNameValueList(&data, ""InternalPort"");
	rem_host = GetValueFromNameValueList(&data, ""RemoteHost"");
 	rem_port = GetValueFromNameValueList(&data, ""RemotePort"");
 	protocol = GetValueFromNameValueList(&data, ""Protocol"");
 
//flaw_line_below:
	if (!int_port || !ext_port || !protocol)
//fix_flaw_line_below:
//	if (!int_port || !rem_port || !protocol)
 	{
 		ClearNameValueList(&data);
 		SoapError(h, 402, ""Invalid Args"");
		return;
	}

	rport = (unsigned short)atoi(rem_port);
	iport = (unsigned short)atoi(int_port);
	/*proto = atoi(protocol);*/

	syslog(LOG_INFO, ""%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s"", action, int_ip, iport,rem_host, rport, protocol);

	/* TODO */
	r = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/

	switch(r)
	{
		case 1:	/* success */
			bodylen = snprintf(body, sizeof(body), resp,
			                   action, ns/*""urn:schemas-upnp-org:service:WANIPv6FirewallControl:1""*/,
			                   opt, action);
			BuildSendAndCloseSoapResp(h, body, bodylen);
			break;
		case -5:	/* Protocol not supported */
			SoapError(h, 705, ""ProtocolNotSupported"");
			break;
		default:
			SoapError(h, 501, ""ActionFailed"");
	}
	ClearNameValueList(&data);
}
"
5683,183419,,Local,Not required,Complete,CVE-2018-7191,https://www.cvedetails.com/cve/CVE-2018-7191/,CWE-476,Low,,,,2019-05-17,4.9,"In the tun subsystem in the Linux kernel before 4.13.14, dev_get_valid_name is not called before register_netdevice. This allows local users to cause a denial of service (NULL pointer dereference and panic) via an ioctl(TUNSETIFF) call with a dev name containing a / character. This is similar to CVE-2013-4343.",2019-05-31,DoS ,1,https://github.com/torvalds/linux/commit/5c25f65fd1e42685f7ccd80e0621829c105785d9,5c25f65fd1e42685f7ccd80e0621829c105785d9,"tun: allow positive return values on dev_get_valid_name() call

If the name argument of dev_get_valid_name() contains ""%d"", it will try
to assign it a unit number in __dev__alloc_name() and return either the
unit number (>= 0) or an error code (< 0).
Considering positive values as error values prevent tun device creations
relying this mechanism, therefor we should only consider negative values
as errors here.

Signed-off-by: Julien Gomes <julien@arista.com>
Acked-by: Cong Wang <xiyou.wangcong@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,drivers/net/tun.c,"{""sha"": ""b9973fb868b79d5df8cea35780a4575703e70a53"", ""filename"": ""drivers/net/tun.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5c25f65fd1e42685f7ccd80e0621829c105785d9/drivers/net/tun.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5c25f65fd1e42685f7ccd80e0621829c105785d9/drivers/net/tun.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/tun.c?ref=5c25f65fd1e42685f7ccd80e0621829c105785d9"", ""patch"": ""@@ -2028,7 +2028,7 @@ static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)\n \t\tif (!dev)\n \t\t\treturn -ENOMEM;\n \t\terr = dev_get_valid_name(net, dev, name);\n-\t\tif (err)\n+\t\tif (err < 0)\n \t\t\tgoto err_free_dev;\n \n \t\tdev_net_set(dev, net);""}","static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)
{
	struct tun_struct *tun;
	struct tun_file *tfile = file->private_data;
	struct net_device *dev;
	int err;

	if (tfile->detached)
		return -EINVAL;

	dev = __dev_get_by_name(net, ifr->ifr_name);
	if (dev) {
		if (ifr->ifr_flags & IFF_TUN_EXCL)
			return -EBUSY;
		if ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)
			tun = netdev_priv(dev);
		else if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)
			tun = netdev_priv(dev);
		else
			return -EINVAL;

		if (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=
		    !!(tun->flags & IFF_MULTI_QUEUE))
			return -EINVAL;

		if (tun_not_capable(tun))
			return -EPERM;
		err = security_tun_dev_open(tun->security);
		if (err < 0)
			return err;

		err = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER);
		if (err < 0)
			return err;

		if (tun->flags & IFF_MULTI_QUEUE &&
		    (tun->numqueues + tun->numdisabled > 1)) {
			/* One or more queue has already been attached, no need
			 * to initialize the device again.
			 */
			return 0;
		}
	}
	else {
		char *name;
		unsigned long flags = 0;
		int queues = ifr->ifr_flags & IFF_MULTI_QUEUE ?
			     MAX_TAP_QUEUES : 1;

		if (!ns_capable(net->user_ns, CAP_NET_ADMIN))
			return -EPERM;
		err = security_tun_dev_create();
		if (err < 0)
			return err;

		/* Set dev type */
		if (ifr->ifr_flags & IFF_TUN) {
			/* TUN device */
			flags |= IFF_TUN;
			name = ""tun%d"";
		} else if (ifr->ifr_flags & IFF_TAP) {
			/* TAP device */
			flags |= IFF_TAP;
			name = ""tap%d"";
		} else
			return -EINVAL;

		if (*ifr->ifr_name)
			name = ifr->ifr_name;

		dev = alloc_netdev_mqs(sizeof(struct tun_struct), name,
				       NET_NAME_UNKNOWN, tun_setup, queues,
				       queues);

 		if (!dev)
 			return -ENOMEM;
 		err = dev_get_valid_name(net, dev, name);
		if (err < 0)
 			goto err_free_dev;
 
 		dev_net_set(dev, net);
		dev->rtnl_link_ops = &tun_link_ops;
		dev->ifindex = tfile->ifindex;
		dev->sysfs_groups[0] = &tun_attr_group;

		tun = netdev_priv(dev);
		tun->dev = dev;
		tun->flags = flags;
		tun->txflt.count = 0;
		tun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);

		tun->align = NET_SKB_PAD;
		tun->filter_attached = false;
		tun->sndbuf = tfile->socket.sk->sk_sndbuf;
		tun->rx_batched = 0;

		tun->pcpu_stats = netdev_alloc_pcpu_stats(struct tun_pcpu_stats);
		if (!tun->pcpu_stats) {
			err = -ENOMEM;
			goto err_free_dev;
		}

		spin_lock_init(&tun->lock);

		err = security_tun_dev_alloc_security(&tun->security);
		if (err < 0)
			goto err_free_stat;

		tun_net_init(dev);
		tun_flow_init(tun);

		dev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |
				   TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |
				   NETIF_F_HW_VLAN_STAG_TX;
		dev->features = dev->hw_features | NETIF_F_LLTX;
		dev->vlan_features = dev->features &
				     ~(NETIF_F_HW_VLAN_CTAG_TX |
				       NETIF_F_HW_VLAN_STAG_TX);

		INIT_LIST_HEAD(&tun->disabled);
		err = tun_attach(tun, file, false);
		if (err < 0)
			goto err_free_flow;

		err = register_netdevice(tun->dev);
		if (err < 0)
			goto err_detach;
	}

	netif_carrier_on(tun->dev);

	tun_debug(KERN_INFO, tun, ""tun_set_iff\n"");

	tun->flags = (tun->flags & ~TUN_FEATURES) |
		(ifr->ifr_flags & TUN_FEATURES);

	/* Make sure persistent devices do not get stuck in
	 * xoff state.
	 */
	if (netif_running(tun->dev))
		netif_tx_wake_all_queues(tun->dev);

	strcpy(ifr->ifr_name, tun->dev->name);
	return 0;

err_detach:
	tun_detach_all(dev);
	/* register_netdevice() already called tun_free_netdev() */
	goto err_free_dev;

err_free_flow:
	tun_flow_uninit(tun);
	security_tun_dev_free_security(tun->security);
err_free_stat:
	free_percpu(tun->pcpu_stats);
err_free_dev:
	free_netdev(dev);
	return err;
}
","static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)
{
	struct tun_struct *tun;
	struct tun_file *tfile = file->private_data;
	struct net_device *dev;
	int err;

	if (tfile->detached)
		return -EINVAL;

	dev = __dev_get_by_name(net, ifr->ifr_name);
	if (dev) {
		if (ifr->ifr_flags & IFF_TUN_EXCL)
			return -EBUSY;
		if ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)
			tun = netdev_priv(dev);
		else if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)
			tun = netdev_priv(dev);
		else
			return -EINVAL;

		if (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=
		    !!(tun->flags & IFF_MULTI_QUEUE))
			return -EINVAL;

		if (tun_not_capable(tun))
			return -EPERM;
		err = security_tun_dev_open(tun->security);
		if (err < 0)
			return err;

		err = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER);
		if (err < 0)
			return err;

		if (tun->flags & IFF_MULTI_QUEUE &&
		    (tun->numqueues + tun->numdisabled > 1)) {
			/* One or more queue has already been attached, no need
			 * to initialize the device again.
			 */
			return 0;
		}
	}
	else {
		char *name;
		unsigned long flags = 0;
		int queues = ifr->ifr_flags & IFF_MULTI_QUEUE ?
			     MAX_TAP_QUEUES : 1;

		if (!ns_capable(net->user_ns, CAP_NET_ADMIN))
			return -EPERM;
		err = security_tun_dev_create();
		if (err < 0)
			return err;

		/* Set dev type */
		if (ifr->ifr_flags & IFF_TUN) {
			/* TUN device */
			flags |= IFF_TUN;
			name = ""tun%d"";
		} else if (ifr->ifr_flags & IFF_TAP) {
			/* TAP device */
			flags |= IFF_TAP;
			name = ""tap%d"";
		} else
			return -EINVAL;

		if (*ifr->ifr_name)
			name = ifr->ifr_name;

		dev = alloc_netdev_mqs(sizeof(struct tun_struct), name,
				       NET_NAME_UNKNOWN, tun_setup, queues,
				       queues);

 		if (!dev)
 			return -ENOMEM;
 		err = dev_get_valid_name(net, dev, name);
		if (err)
 			goto err_free_dev;
 
 		dev_net_set(dev, net);
		dev->rtnl_link_ops = &tun_link_ops;
		dev->ifindex = tfile->ifindex;
		dev->sysfs_groups[0] = &tun_attr_group;

		tun = netdev_priv(dev);
		tun->dev = dev;
		tun->flags = flags;
		tun->txflt.count = 0;
		tun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);

		tun->align = NET_SKB_PAD;
		tun->filter_attached = false;
		tun->sndbuf = tfile->socket.sk->sk_sndbuf;
		tun->rx_batched = 0;

		tun->pcpu_stats = netdev_alloc_pcpu_stats(struct tun_pcpu_stats);
		if (!tun->pcpu_stats) {
			err = -ENOMEM;
			goto err_free_dev;
		}

		spin_lock_init(&tun->lock);

		err = security_tun_dev_alloc_security(&tun->security);
		if (err < 0)
			goto err_free_stat;

		tun_net_init(dev);
		tun_flow_init(tun);

		dev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |
				   TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |
				   NETIF_F_HW_VLAN_STAG_TX;
		dev->features = dev->hw_features | NETIF_F_LLTX;
		dev->vlan_features = dev->features &
				     ~(NETIF_F_HW_VLAN_CTAG_TX |
				       NETIF_F_HW_VLAN_STAG_TX);

		INIT_LIST_HEAD(&tun->disabled);
		err = tun_attach(tun, file, false);
		if (err < 0)
			goto err_free_flow;

		err = register_netdevice(tun->dev);
		if (err < 0)
			goto err_detach;
	}

	netif_carrier_on(tun->dev);

	tun_debug(KERN_INFO, tun, ""tun_set_iff\n"");

	tun->flags = (tun->flags & ~TUN_FEATURES) |
		(ifr->ifr_flags & TUN_FEATURES);

	/* Make sure persistent devices do not get stuck in
	 * xoff state.
	 */
	if (netif_running(tun->dev))
		netif_tx_wake_all_queues(tun->dev);

	strcpy(ifr->ifr_name, tun->dev->name);
	return 0;

err_detach:
	tun_detach_all(dev);
	/* register_netdevice() already called tun_free_netdev() */
	goto err_free_dev;

err_free_flow:
	tun_flow_uninit(tun);
	security_tun_dev_free_security(tun->security);
err_free_stat:
	free_percpu(tun->pcpu_stats);
err_free_dev:
	free_netdev(dev);
	return err;
}
",C,"		if (err < 0)
","		if (err)
",,"@@ -2028,7 +2028,7 @@ static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)
 		if (!dev)
 			return -ENOMEM;
 		err = dev_get_valid_name(net, dev, name);
-		if (err)
+		if (err < 0)
 			goto err_free_dev;
 
 		dev_net_set(dev, net);",linux,5c25f65fd1e42685f7ccd80e0621829c105785d9,d309ae5c6a00648198d1932e6db483d612c2e260,1,"static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)
{
	struct tun_struct *tun;
	struct tun_file *tfile = file->private_data;
	struct net_device *dev;
	int err;

	if (tfile->detached)
		return -EINVAL;

	dev = __dev_get_by_name(net, ifr->ifr_name);
	if (dev) {
		if (ifr->ifr_flags & IFF_TUN_EXCL)
			return -EBUSY;
		if ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)
			tun = netdev_priv(dev);
		else if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)
			tun = netdev_priv(dev);
		else
			return -EINVAL;

		if (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=
		    !!(tun->flags & IFF_MULTI_QUEUE))
			return -EINVAL;

		if (tun_not_capable(tun))
			return -EPERM;
		err = security_tun_dev_open(tun->security);
		if (err < 0)
			return err;

		err = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER);
		if (err < 0)
			return err;

		if (tun->flags & IFF_MULTI_QUEUE &&
		    (tun->numqueues + tun->numdisabled > 1)) {
			/* One or more queue has already been attached, no need
			 * to initialize the device again.
			 */
			return 0;
		}
	}
	else {
		char *name;
		unsigned long flags = 0;
		int queues = ifr->ifr_flags & IFF_MULTI_QUEUE ?
			     MAX_TAP_QUEUES : 1;

		if (!ns_capable(net->user_ns, CAP_NET_ADMIN))
			return -EPERM;
		err = security_tun_dev_create();
		if (err < 0)
			return err;

		/* Set dev type */
		if (ifr->ifr_flags & IFF_TUN) {
			/* TUN device */
			flags |= IFF_TUN;
			name = ""tun%d"";
		} else if (ifr->ifr_flags & IFF_TAP) {
			/* TAP device */
			flags |= IFF_TAP;
			name = ""tap%d"";
		} else
			return -EINVAL;

		if (*ifr->ifr_name)
			name = ifr->ifr_name;

		dev = alloc_netdev_mqs(sizeof(struct tun_struct), name,
				       NET_NAME_UNKNOWN, tun_setup, queues,
				       queues);

 		if (!dev)
 			return -ENOMEM;
 		err = dev_get_valid_name(net, dev, name);
//flaw_line_below:
		if (err)
//fix_flaw_line_below:
//		if (err < 0)
 			goto err_free_dev;
 
 		dev_net_set(dev, net);
		dev->rtnl_link_ops = &tun_link_ops;
		dev->ifindex = tfile->ifindex;
		dev->sysfs_groups[0] = &tun_attr_group;

		tun = netdev_priv(dev);
		tun->dev = dev;
		tun->flags = flags;
		tun->txflt.count = 0;
		tun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);

		tun->align = NET_SKB_PAD;
		tun->filter_attached = false;
		tun->sndbuf = tfile->socket.sk->sk_sndbuf;
		tun->rx_batched = 0;

		tun->pcpu_stats = netdev_alloc_pcpu_stats(struct tun_pcpu_stats);
		if (!tun->pcpu_stats) {
			err = -ENOMEM;
			goto err_free_dev;
		}

		spin_lock_init(&tun->lock);

		err = security_tun_dev_alloc_security(&tun->security);
		if (err < 0)
			goto err_free_stat;

		tun_net_init(dev);
		tun_flow_init(tun);

		dev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |
				   TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |
				   NETIF_F_HW_VLAN_STAG_TX;
		dev->features = dev->hw_features | NETIF_F_LLTX;
		dev->vlan_features = dev->features &
				     ~(NETIF_F_HW_VLAN_CTAG_TX |
				       NETIF_F_HW_VLAN_STAG_TX);

		INIT_LIST_HEAD(&tun->disabled);
		err = tun_attach(tun, file, false);
		if (err < 0)
			goto err_free_flow;

		err = register_netdevice(tun->dev);
		if (err < 0)
			goto err_detach;
	}

	netif_carrier_on(tun->dev);

	tun_debug(KERN_INFO, tun, ""tun_set_iff\n"");

	tun->flags = (tun->flags & ~TUN_FEATURES) |
		(ifr->ifr_flags & TUN_FEATURES);

	/* Make sure persistent devices do not get stuck in
	 * xoff state.
	 */
	if (netif_running(tun->dev))
		netif_tx_wake_all_queues(tun->dev);

	strcpy(ifr->ifr_name, tun->dev->name);
	return 0;

err_detach:
	tun_detach_all(dev);
	/* register_netdevice() already called tun_free_netdev() */
	goto err_free_dev;

err_free_flow:
	tun_flow_uninit(tun);
	security_tun_dev_free_security(tun->security);
err_free_stat:
	free_percpu(tun->pcpu_stats);
err_free_dev:
	free_netdev(dev);
	return err;
}
"
8725,186461,,Remote,Not required,Partial,CVE-2017-5023,https://www.cvedetails.com/cve/CVE-2017-5023/,CWE-476,Medium,,,,2017-02-17,4.3,"Type confusion in Histogram in Google Chrome prior to 56.0.2924.76 for Linux, Windows and Mac, and 56.0.2924.87 for Android, allowed a remote attacker to potentially exploit a near null dereference via a crafted HTML page.",2018-01-04,,1,https://github.com/chromium/chromium/commit/03c2e97746a2c471ae136b0c669f8d0c033fe168,03c2e97746a2c471ae136b0c669f8d0c033fe168,"Convert DCHECKs to CHECKs for histogram types

When a histogram is looked up by name, there is currently a DCHECK that
verifies the type of the stored histogram matches the expected type.

A mismatch represents a significant problem because the returned
HistogramBase is cast to a Histogram in ValidateRangeChecksum,
potentially causing a crash.

This CL converts the DCHECK to a CHECK to prevent the possibility of
type confusion in release builds.

BUG=651443
R=isherman@chromium.org

Review-Url: https://codereview.chromium.org/2381893003
Cr-Commit-Position: refs/heads/master@{#421929}",1,base/metrics/histogram.cc,"{""sha"": ""e1d0df6736fa326b5f74c717974f40bf711be0c9"", ""filename"": ""base/metrics/histogram.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/03c2e97746a2c471ae136b0c669f8d0c033fe168/base/metrics/histogram.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/03c2e97746a2c471ae136b0c669f8d0c033fe168/base/metrics/histogram.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/metrics/histogram.cc?ref=03c2e97746a2c471ae136b0c669f8d0c033fe168"", ""patch"": ""@@ -216,7 +216,7 @@ HistogramBase* Histogram::Factory::Build() {\n     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);\n   }\n \n-  DCHECK_EQ(histogram_type_, histogram->GetHistogramType()) << name_;\n+  CHECK_EQ(histogram_type_, histogram->GetHistogramType()) << name_;\n   if (bucket_count_ != 0 &&\n       !histogram->HasConstructionArguments(minimum_, maximum_, bucket_count_)) {\n     // The construction arguments do not match the existing histogram.  This can""}<_**next**_>{""sha"": ""415d7f943024a84965933cfb39af4024fd334ea6"", ""filename"": ""base/metrics/sparse_histogram.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/03c2e97746a2c471ae136b0c669f8d0c033fe168/base/metrics/sparse_histogram.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/03c2e97746a2c471ae136b0c669f8d0c033fe168/base/metrics/sparse_histogram.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/metrics/sparse_histogram.cc?ref=03c2e97746a2c471ae136b0c669f8d0c033fe168"", ""patch"": ""@@ -68,7 +68,7 @@ HistogramBase* SparseHistogram::FactoryGet(const std::string& name,\n     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);\n   }\n \n-  DCHECK_EQ(SPARSE_HISTOGRAM, histogram->GetHistogramType());\n+  CHECK_EQ(SPARSE_HISTOGRAM, histogram->GetHistogramType());\n   return histogram;\n }\n ""}","HistogramBase* Histogram::Factory::Build() {
  HistogramBase* histogram = StatisticsRecorder::FindHistogram(name_);
  if (!histogram) {
    const BucketRanges* created_ranges = CreateRanges();
    const BucketRanges* registered_ranges =
        StatisticsRecorder::RegisterOrDeleteDuplicateRanges(created_ranges);

    if (bucket_count_ == 0) {
      bucket_count_ = static_cast<uint32_t>(registered_ranges->bucket_count());
      minimum_ = registered_ranges->range(1);
      maximum_ = registered_ranges->range(bucket_count_ - 1);
    }

    PersistentHistogramAllocator::Reference histogram_ref = 0;
    std::unique_ptr<HistogramBase> tentative_histogram;
    PersistentHistogramAllocator* allocator = GlobalHistogramAllocator::Get();
    if (allocator) {
      tentative_histogram = allocator->AllocateHistogram(
          histogram_type_,
          name_,
          minimum_,
          maximum_,
          registered_ranges,
          flags_,
          &histogram_ref);
    }

    if (!tentative_histogram) {
      DCHECK(!histogram_ref);  // Should never have been set.
      DCHECK(!allocator);  // Shouldn't have failed.
      flags_ &= ~HistogramBase::kIsPersistent;
      tentative_histogram = HeapAlloc(registered_ranges);
      tentative_histogram->SetFlags(flags_);
    }

    FillHistogram(tentative_histogram.get());

    const void* tentative_histogram_ptr = tentative_histogram.get();
    histogram = StatisticsRecorder::RegisterOrDeleteDuplicate(
        tentative_histogram.release());

    if (histogram_ref) {
      allocator->FinalizeHistogram(histogram_ref,
                                   histogram == tentative_histogram_ptr);
    }

    ReportHistogramActivity(*histogram, HISTOGRAM_CREATED);
  } else {
     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);
   }
 
  CHECK_EQ(histogram_type_, histogram->GetHistogramType()) << name_;
   if (bucket_count_ != 0 &&
       !histogram->HasConstructionArguments(minimum_, maximum_, bucket_count_)) {
    DLOG(ERROR) << ""Histogram "" << name_ << "" has bad construction arguments"";
    return nullptr;
  }
  return histogram;
}
","HistogramBase* Histogram::Factory::Build() {
  HistogramBase* histogram = StatisticsRecorder::FindHistogram(name_);
  if (!histogram) {
    const BucketRanges* created_ranges = CreateRanges();
    const BucketRanges* registered_ranges =
        StatisticsRecorder::RegisterOrDeleteDuplicateRanges(created_ranges);

    if (bucket_count_ == 0) {
      bucket_count_ = static_cast<uint32_t>(registered_ranges->bucket_count());
      minimum_ = registered_ranges->range(1);
      maximum_ = registered_ranges->range(bucket_count_ - 1);
    }

    PersistentHistogramAllocator::Reference histogram_ref = 0;
    std::unique_ptr<HistogramBase> tentative_histogram;
    PersistentHistogramAllocator* allocator = GlobalHistogramAllocator::Get();
    if (allocator) {
      tentative_histogram = allocator->AllocateHistogram(
          histogram_type_,
          name_,
          minimum_,
          maximum_,
          registered_ranges,
          flags_,
          &histogram_ref);
    }

    if (!tentative_histogram) {
      DCHECK(!histogram_ref);  // Should never have been set.
      DCHECK(!allocator);  // Shouldn't have failed.
      flags_ &= ~HistogramBase::kIsPersistent;
      tentative_histogram = HeapAlloc(registered_ranges);
      tentative_histogram->SetFlags(flags_);
    }

    FillHistogram(tentative_histogram.get());

    const void* tentative_histogram_ptr = tentative_histogram.get();
    histogram = StatisticsRecorder::RegisterOrDeleteDuplicate(
        tentative_histogram.release());

    if (histogram_ref) {
      allocator->FinalizeHistogram(histogram_ref,
                                   histogram == tentative_histogram_ptr);
    }

    ReportHistogramActivity(*histogram, HISTOGRAM_CREATED);
  } else {
     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);
   }
 
  DCHECK_EQ(histogram_type_, histogram->GetHistogramType()) << name_;
   if (bucket_count_ != 0 &&
       !histogram->HasConstructionArguments(minimum_, maximum_, bucket_count_)) {
    DLOG(ERROR) << ""Histogram "" << name_ << "" has bad construction arguments"";
    return nullptr;
  }
  return histogram;
}
",C,"  CHECK_EQ(histogram_type_, histogram->GetHistogramType()) << name_;
","  DCHECK_EQ(histogram_type_, histogram->GetHistogramType()) << name_;
",,"@@ -216,7 +216,7 @@ HistogramBase* Histogram::Factory::Build() {
     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);
   }
 
-  DCHECK_EQ(histogram_type_, histogram->GetHistogramType()) << name_;
+  CHECK_EQ(histogram_type_, histogram->GetHistogramType()) << name_;
   if (bucket_count_ != 0 &&
       !histogram->HasConstructionArguments(minimum_, maximum_, bucket_count_)) {
     // The construction arguments do not match the existing histogram.  This can",Chrome,03c2e97746a2c471ae136b0c669f8d0c033fe168,990b6e2221f393d7ee2e3e0ea98427ac4613f8c5,1,"HistogramBase* Histogram::Factory::Build() {
  HistogramBase* histogram = StatisticsRecorder::FindHistogram(name_);
  if (!histogram) {
    // To avoid racy destruction at shutdown, the following will be leaked.
    const BucketRanges* created_ranges = CreateRanges();
    const BucketRanges* registered_ranges =
        StatisticsRecorder::RegisterOrDeleteDuplicateRanges(created_ranges);

    // In most cases, the bucket-count, minimum, and maximum values are known
    // when the code is written and so are passed in explicitly. In other
    // cases (such as with a CustomHistogram), they are calculated dynamically
    // at run-time. In the latter case, those ctor parameters are zero and
    // the results extracted from the result of CreateRanges().
    if (bucket_count_ == 0) {
      bucket_count_ = static_cast<uint32_t>(registered_ranges->bucket_count());
      minimum_ = registered_ranges->range(1);
      maximum_ = registered_ranges->range(bucket_count_ - 1);
    }

    // Try to create the histogram using a ""persistent"" allocator. As of
    // 2016-02-25, the availability of such is controlled by a base::Feature
    // that is off by default. If the allocator doesn't exist or if
    // allocating from it fails, code below will allocate the histogram from
    // the process heap.
    PersistentHistogramAllocator::Reference histogram_ref = 0;
    std::unique_ptr<HistogramBase> tentative_histogram;
    PersistentHistogramAllocator* allocator = GlobalHistogramAllocator::Get();
    if (allocator) {
      tentative_histogram = allocator->AllocateHistogram(
          histogram_type_,
          name_,
          minimum_,
          maximum_,
          registered_ranges,
          flags_,
          &histogram_ref);
    }

    // Handle the case where no persistent allocator is present or the
    // persistent allocation fails (perhaps because it is full).
    if (!tentative_histogram) {
      DCHECK(!histogram_ref);  // Should never have been set.
      DCHECK(!allocator);  // Shouldn't have failed.
      flags_ &= ~HistogramBase::kIsPersistent;
      tentative_histogram = HeapAlloc(registered_ranges);
      tentative_histogram->SetFlags(flags_);
    }

    FillHistogram(tentative_histogram.get());

    // Register this histogram with the StatisticsRecorder. Keep a copy of
    // the pointer value to tell later whether the locally created histogram
    // was registered or deleted. The type is ""void"" because it could point
    // to released memory after the following line.
    const void* tentative_histogram_ptr = tentative_histogram.get();
    histogram = StatisticsRecorder::RegisterOrDeleteDuplicate(
        tentative_histogram.release());

    // Persistent histograms need some follow-up processing.
    if (histogram_ref) {
      allocator->FinalizeHistogram(histogram_ref,
                                   histogram == tentative_histogram_ptr);
    }

    // Update report on created histograms.
    ReportHistogramActivity(*histogram, HISTOGRAM_CREATED);
  } else {
    // Update report on lookup histograms.
     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);
   }
 
//flaw_line_below:
  DCHECK_EQ(histogram_type_, histogram->GetHistogramType()) << name_;
//fix_flaw_line_below:
//  CHECK_EQ(histogram_type_, histogram->GetHistogramType()) << name_;
   if (bucket_count_ != 0 &&
       !histogram->HasConstructionArguments(minimum_, maximum_, bucket_count_)) {
     // The construction arguments do not match the existing histogram.  This can
    // come about if an extension updates in the middle of a chrome run and has
    // changed one of them, or simply by bad code within Chrome itself.  We
    // return NULL here with the expectation that bad code in Chrome will crash
    // on dereference, but extension/Pepper APIs will guard against NULL and not
    // crash.
    DLOG(ERROR) << ""Histogram "" << name_ << "" has bad construction arguments"";
    return nullptr;
  }
  return histogram;
}
"
8726,186462,,Remote,Not required,Partial,CVE-2017-5023,https://www.cvedetails.com/cve/CVE-2017-5023/,CWE-476,Medium,,,,2017-02-17,4.3,"Type confusion in Histogram in Google Chrome prior to 56.0.2924.76 for Linux, Windows and Mac, and 56.0.2924.87 for Android, allowed a remote attacker to potentially exploit a near null dereference via a crafted HTML page.",2018-01-04,,1,https://github.com/chromium/chromium/commit/03c2e97746a2c471ae136b0c669f8d0c033fe168,03c2e97746a2c471ae136b0c669f8d0c033fe168,"Convert DCHECKs to CHECKs for histogram types

When a histogram is looked up by name, there is currently a DCHECK that
verifies the type of the stored histogram matches the expected type.

A mismatch represents a significant problem because the returned
HistogramBase is cast to a Histogram in ValidateRangeChecksum,
potentially causing a crash.

This CL converts the DCHECK to a CHECK to prevent the possibility of
type confusion in release builds.

BUG=651443
R=isherman@chromium.org

Review-Url: https://codereview.chromium.org/2381893003
Cr-Commit-Position: refs/heads/master@{#421929}",1,base/metrics/sparse_histogram.cc,"{""sha"": ""e1d0df6736fa326b5f74c717974f40bf711be0c9"", ""filename"": ""base/metrics/histogram.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/03c2e97746a2c471ae136b0c669f8d0c033fe168/base/metrics/histogram.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/03c2e97746a2c471ae136b0c669f8d0c033fe168/base/metrics/histogram.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/metrics/histogram.cc?ref=03c2e97746a2c471ae136b0c669f8d0c033fe168"", ""patch"": ""@@ -216,7 +216,7 @@ HistogramBase* Histogram::Factory::Build() {\n     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);\n   }\n \n-  DCHECK_EQ(histogram_type_, histogram->GetHistogramType()) << name_;\n+  CHECK_EQ(histogram_type_, histogram->GetHistogramType()) << name_;\n   if (bucket_count_ != 0 &&\n       !histogram->HasConstructionArguments(minimum_, maximum_, bucket_count_)) {\n     // The construction arguments do not match the existing histogram.  This can""}<_**next**_>{""sha"": ""415d7f943024a84965933cfb39af4024fd334ea6"", ""filename"": ""base/metrics/sparse_histogram.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/03c2e97746a2c471ae136b0c669f8d0c033fe168/base/metrics/sparse_histogram.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/03c2e97746a2c471ae136b0c669f8d0c033fe168/base/metrics/sparse_histogram.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/metrics/sparse_histogram.cc?ref=03c2e97746a2c471ae136b0c669f8d0c033fe168"", ""patch"": ""@@ -68,7 +68,7 @@ HistogramBase* SparseHistogram::FactoryGet(const std::string& name,\n     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);\n   }\n \n-  DCHECK_EQ(SPARSE_HISTOGRAM, histogram->GetHistogramType());\n+  CHECK_EQ(SPARSE_HISTOGRAM, histogram->GetHistogramType());\n   return histogram;\n }\n ""}","HistogramBase* SparseHistogram::FactoryGet(const std::string& name,
                                           int32_t flags) {
  HistogramBase* histogram = StatisticsRecorder::FindHistogram(name);
  if (!histogram) {
    PersistentMemoryAllocator::Reference histogram_ref = 0;
    std::unique_ptr<HistogramBase> tentative_histogram;
    PersistentHistogramAllocator* allocator = GlobalHistogramAllocator::Get();
    if (allocator) {
      tentative_histogram = allocator->AllocateHistogram(
          SPARSE_HISTOGRAM, name, 0, 0, nullptr, flags, &histogram_ref);
    }

    if (!tentative_histogram) {
      DCHECK(!histogram_ref);  // Should never have been set.
      DCHECK(!allocator);      // Shouldn't have failed.
      flags &= ~HistogramBase::kIsPersistent;
      tentative_histogram.reset(new SparseHistogram(name));
      tentative_histogram->SetFlags(flags);
    }

    const void* tentative_histogram_ptr = tentative_histogram.get();
    histogram = StatisticsRecorder::RegisterOrDeleteDuplicate(
        tentative_histogram.release());

    if (histogram_ref) {
      allocator->FinalizeHistogram(histogram_ref,
                                   histogram == tentative_histogram_ptr);
    }

    ReportHistogramActivity(*histogram, HISTOGRAM_CREATED);
  } else {
     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);
   }
 
  CHECK_EQ(SPARSE_HISTOGRAM, histogram->GetHistogramType());
   return histogram;
 }
","HistogramBase* SparseHistogram::FactoryGet(const std::string& name,
                                           int32_t flags) {
  HistogramBase* histogram = StatisticsRecorder::FindHistogram(name);
  if (!histogram) {
    PersistentMemoryAllocator::Reference histogram_ref = 0;
    std::unique_ptr<HistogramBase> tentative_histogram;
    PersistentHistogramAllocator* allocator = GlobalHistogramAllocator::Get();
    if (allocator) {
      tentative_histogram = allocator->AllocateHistogram(
          SPARSE_HISTOGRAM, name, 0, 0, nullptr, flags, &histogram_ref);
    }

    if (!tentative_histogram) {
      DCHECK(!histogram_ref);  // Should never have been set.
      DCHECK(!allocator);      // Shouldn't have failed.
      flags &= ~HistogramBase::kIsPersistent;
      tentative_histogram.reset(new SparseHistogram(name));
      tentative_histogram->SetFlags(flags);
    }

    const void* tentative_histogram_ptr = tentative_histogram.get();
    histogram = StatisticsRecorder::RegisterOrDeleteDuplicate(
        tentative_histogram.release());

    if (histogram_ref) {
      allocator->FinalizeHistogram(histogram_ref,
                                   histogram == tentative_histogram_ptr);
    }

    ReportHistogramActivity(*histogram, HISTOGRAM_CREATED);
  } else {
     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);
   }
 
  DCHECK_EQ(SPARSE_HISTOGRAM, histogram->GetHistogramType());
   return histogram;
 }
",C,"  CHECK_EQ(SPARSE_HISTOGRAM, histogram->GetHistogramType());
","  DCHECK_EQ(SPARSE_HISTOGRAM, histogram->GetHistogramType());
",,"@@ -68,7 +68,7 @@ HistogramBase* SparseHistogram::FactoryGet(const std::string& name,
     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);
   }
 
-  DCHECK_EQ(SPARSE_HISTOGRAM, histogram->GetHistogramType());
+  CHECK_EQ(SPARSE_HISTOGRAM, histogram->GetHistogramType());
   return histogram;
 }
 ",Chrome,03c2e97746a2c471ae136b0c669f8d0c033fe168,990b6e2221f393d7ee2e3e0ea98427ac4613f8c5,1,"HistogramBase* SparseHistogram::FactoryGet(const std::string& name,
                                           int32_t flags) {
  HistogramBase* histogram = StatisticsRecorder::FindHistogram(name);
  if (!histogram) {
    // Try to create the histogram using a ""persistent"" allocator. As of
    // 2016-02-25, the availability of such is controlled by a base::Feature
    // that is off by default. If the allocator doesn't exist or if
    // allocating from it fails, code below will allocate the histogram from
    // the process heap.
    PersistentMemoryAllocator::Reference histogram_ref = 0;
    std::unique_ptr<HistogramBase> tentative_histogram;
    PersistentHistogramAllocator* allocator = GlobalHistogramAllocator::Get();
    if (allocator) {
      tentative_histogram = allocator->AllocateHistogram(
          SPARSE_HISTOGRAM, name, 0, 0, nullptr, flags, &histogram_ref);
    }

    // Handle the case where no persistent allocator is present or the
    // persistent allocation fails (perhaps because it is full).
    if (!tentative_histogram) {
      DCHECK(!histogram_ref);  // Should never have been set.
      DCHECK(!allocator);      // Shouldn't have failed.
      flags &= ~HistogramBase::kIsPersistent;
      tentative_histogram.reset(new SparseHistogram(name));
      tentative_histogram->SetFlags(flags);
    }

    // Register this histogram with the StatisticsRecorder. Keep a copy of
    // the pointer value to tell later whether the locally created histogram
    // was registered or deleted. The type is ""void"" because it could point
    // to released memory after the following line.
    const void* tentative_histogram_ptr = tentative_histogram.get();
    histogram = StatisticsRecorder::RegisterOrDeleteDuplicate(
        tentative_histogram.release());

    // Persistent histograms need some follow-up processing.
    if (histogram_ref) {
      allocator->FinalizeHistogram(histogram_ref,
                                   histogram == tentative_histogram_ptr);
    }

    ReportHistogramActivity(*histogram, HISTOGRAM_CREATED);
  } else {
     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);
   }
 
//flaw_line_below:
  DCHECK_EQ(SPARSE_HISTOGRAM, histogram->GetHistogramType());
//fix_flaw_line_below:
//  CHECK_EQ(SPARSE_HISTOGRAM, histogram->GetHistogramType());
   return histogram;
 }
"
9823,187559,,Remote,Not required,Partial,CVE-2016-3821,https://www.cvedetails.com/cve/CVE-2016-3821/,CWE-476,Low,Partial,Partial,,2016-08-05,7.5,"libmedia in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 has certain incorrect declarations, which allows remote attackers to execute arbitrary code or cause a denial of service (NULL pointer dereference or memory corruption) via a crafted media file, aka internal bug 28166152.",2016-11-28,DoS Exec Code Mem. Corr. ,1,https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69,42a25c46b844518ff0d0b920c20c519e1417be69,"Don't use sp<>&

because they may end up pointing to NULL after a NULL check was performed.

Bug: 28166152
Change-Id: Iab2ea30395b620628cc6f3d067dd4f6fcda824fe
",1,media/libmedia/mediaplayer.cpp,"{""filename"": ""include/media/IMediaDeathNotifier.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69/include/media/IMediaDeathNotifier.h"", ""patch"": ""@@ -30,7 +30,7 @@\n\n     virtual ~IMediaDeathNotifier() { removeObitRecipient(this); }\n \n     virtual void died() = 0;\n-    static const sp<IMediaPlayerService>& getMediaPlayerService();\n+    static const sp<IMediaPlayerService> getMediaPlayerService();\n \n private:\n     IMediaDeathNotifier &operator=(const IMediaDeathNotifier &);\n""}<_**next**_>{""filename"": ""media/libmedia/IMediaDeathNotifier.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69/media/libmedia/IMediaDeathNotifier.cpp"", ""patch"": ""@@ -31,7 +31,7 @@\n\n SortedVector< wp<IMediaDeathNotifier> > IMediaDeathNotifier::sObitRecipients;\n \n // establish binder interface to MediaPlayerService\n-/*static*/const sp<IMediaPlayerService>&\n+/*static*/const sp<IMediaPlayerService>\n IMediaDeathNotifier::getMediaPlayerService()\n {\n     ALOGV(\""getMediaPlayerService\"");\n""}<_**next**_>{""filename"": ""media/libmedia/mediaplayer.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69/media/libmedia/mediaplayer.cpp"", ""patch"": ""@@ -152,7 +152,7 @@\n\n     ALOGV(\""setDataSource(%s)\"", url);\n     status_t err = BAD_VALUE;\n     if (url != NULL) {\n-        const sp<IMediaPlayerService>& service(getMediaPlayerService());\n+        const sp<IMediaPlayerService> service(getMediaPlayerService());\n         if (service != 0) {\n             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n@@ -169,7 +169,7 @@\n\n {\n     ALOGV(\""setDataSource(%d, %\"" PRId64 \"", %\"" PRId64 \"")\"", fd, offset, length);\n     status_t err = UNKNOWN_ERROR;\n-    const sp<IMediaPlayerService>& service(getMediaPlayerService());\n+    const sp<IMediaPlayerService> service(getMediaPlayerService());\n     if (service != 0) {\n         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n@@ -185,7 +185,7 @@\n\n {\n     ALOGV(\""setDataSource\"");\n     status_t err = UNKNOWN_ERROR;\n-    const sp<IMediaPlayerService>& service(getMediaPlayerService());\n+    const sp<IMediaPlayerService> service(getMediaPlayerService());\n     if (service != 0) {\n         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n""}<_**next**_>{""filename"": ""media/libmedia/mediarecorder.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69/media/libmedia/mediarecorder.cpp"", ""patch"": ""@@ -617,7 +617,7 @@\n\n {\n     ALOGV(\""constructor\"");\n \n-    const sp<IMediaPlayerService>& service(getMediaPlayerService());\n+    const sp<IMediaPlayerService> service(getMediaPlayerService());\n     if (service != NULL) {\n         mMediaRecorder = service->createMediaRecorder(opPackageName);\n     }\n""}","status_t MediaPlayer::setDataSource(
 const sp<IMediaHTTPService> &httpService,
 const char *url, const KeyedVector<String8, String8> *headers)
{

     ALOGV(""setDataSource(%s)"", url);
     status_t err = BAD_VALUE;
     if (url != NULL) {
        const sp<IMediaPlayerService> service(getMediaPlayerService());
         if (service != 0) {
             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
 (NO_ERROR != player->setDataSource(httpService, url, headers))) {
                player.clear();
 }
            err = attachNewPlayer(player);
 }
 }
 return err;
}
","status_t MediaPlayer::setDataSource(
 const sp<IMediaHTTPService> &httpService,
 const char *url, const KeyedVector<String8, String8> *headers)
{

     ALOGV(""setDataSource(%s)"", url);
     status_t err = BAD_VALUE;
     if (url != NULL) {
        const sp<IMediaPlayerService>& service(getMediaPlayerService());
         if (service != 0) {
             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
 (NO_ERROR != player->setDataSource(httpService, url, headers))) {
                player.clear();
 }
            err = attachNewPlayer(player);
 }
 }
 return err;
}
",C,"        const sp<IMediaPlayerService> service(getMediaPlayerService());
","        const sp<IMediaPlayerService>& service(getMediaPlayerService());
",,"@@ -152,7 +152,7 @@

     ALOGV(""setDataSource(%s)"", url);
     status_t err = BAD_VALUE;
     if (url != NULL) {
-        const sp<IMediaPlayerService>& service(getMediaPlayerService());
+        const sp<IMediaPlayerService> service(getMediaPlayerService());
         if (service != 0) {
             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
@@ -169,7 +169,7 @@

 {
     ALOGV(""setDataSource(%d, %"" PRId64 "", %"" PRId64 "")"", fd, offset, length);
     status_t err = UNKNOWN_ERROR;
-    const sp<IMediaPlayerService>& service(getMediaPlayerService());
+    const sp<IMediaPlayerService> service(getMediaPlayerService());
     if (service != 0) {
         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
@@ -185,7 +185,7 @@

 {
     ALOGV(""setDataSource"");
     status_t err = UNKNOWN_ERROR;
-    const sp<IMediaPlayerService>& service(getMediaPlayerService());
+    const sp<IMediaPlayerService> service(getMediaPlayerService());
     if (service != 0) {
         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
",Android,https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69/,https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69%5E/,1,"status_t MediaPlayer::setDataSource(
 const sp<IMediaHTTPService> &httpService,
 const char *url, const KeyedVector<String8, String8> *headers)
{

     ALOGV(""setDataSource(%s)"", url);
     status_t err = BAD_VALUE;
     if (url != NULL) {
//flaw_line_below:
        const sp<IMediaPlayerService>& service(getMediaPlayerService());
//fix_flaw_line_below:
//        const sp<IMediaPlayerService> service(getMediaPlayerService());
         if (service != 0) {
             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
 (NO_ERROR != player->setDataSource(httpService, url, headers))) {
                player.clear();
 }
            err = attachNewPlayer(player);
 }
 }
 return err;
}
"
9824,187560,,Remote,Not required,Partial,CVE-2016-3821,https://www.cvedetails.com/cve/CVE-2016-3821/,CWE-476,Low,Partial,Partial,,2016-08-05,7.5,"libmedia in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 has certain incorrect declarations, which allows remote attackers to execute arbitrary code or cause a denial of service (NULL pointer dereference or memory corruption) via a crafted media file, aka internal bug 28166152.",2016-11-28,DoS Exec Code Mem. Corr. ,1,https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69,42a25c46b844518ff0d0b920c20c519e1417be69,"Don't use sp<>&

because they may end up pointing to NULL after a NULL check was performed.

Bug: 28166152
Change-Id: Iab2ea30395b620628cc6f3d067dd4f6fcda824fe
",1,media/libmedia/mediaplayer.cpp,"{""filename"": ""include/media/IMediaDeathNotifier.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69/include/media/IMediaDeathNotifier.h"", ""patch"": ""@@ -30,7 +30,7 @@\n\n     virtual ~IMediaDeathNotifier() { removeObitRecipient(this); }\n \n     virtual void died() = 0;\n-    static const sp<IMediaPlayerService>& getMediaPlayerService();\n+    static const sp<IMediaPlayerService> getMediaPlayerService();\n \n private:\n     IMediaDeathNotifier &operator=(const IMediaDeathNotifier &);\n""}<_**next**_>{""filename"": ""media/libmedia/IMediaDeathNotifier.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69/media/libmedia/IMediaDeathNotifier.cpp"", ""patch"": ""@@ -31,7 +31,7 @@\n\n SortedVector< wp<IMediaDeathNotifier> > IMediaDeathNotifier::sObitRecipients;\n \n // establish binder interface to MediaPlayerService\n-/*static*/const sp<IMediaPlayerService>&\n+/*static*/const sp<IMediaPlayerService>\n IMediaDeathNotifier::getMediaPlayerService()\n {\n     ALOGV(\""getMediaPlayerService\"");\n""}<_**next**_>{""filename"": ""media/libmedia/mediaplayer.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69/media/libmedia/mediaplayer.cpp"", ""patch"": ""@@ -152,7 +152,7 @@\n\n     ALOGV(\""setDataSource(%s)\"", url);\n     status_t err = BAD_VALUE;\n     if (url != NULL) {\n-        const sp<IMediaPlayerService>& service(getMediaPlayerService());\n+        const sp<IMediaPlayerService> service(getMediaPlayerService());\n         if (service != 0) {\n             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n@@ -169,7 +169,7 @@\n\n {\n     ALOGV(\""setDataSource(%d, %\"" PRId64 \"", %\"" PRId64 \"")\"", fd, offset, length);\n     status_t err = UNKNOWN_ERROR;\n-    const sp<IMediaPlayerService>& service(getMediaPlayerService());\n+    const sp<IMediaPlayerService> service(getMediaPlayerService());\n     if (service != 0) {\n         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n@@ -185,7 +185,7 @@\n\n {\n     ALOGV(\""setDataSource\"");\n     status_t err = UNKNOWN_ERROR;\n-    const sp<IMediaPlayerService>& service(getMediaPlayerService());\n+    const sp<IMediaPlayerService> service(getMediaPlayerService());\n     if (service != 0) {\n         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n""}<_**next**_>{""filename"": ""media/libmedia/mediarecorder.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69/media/libmedia/mediarecorder.cpp"", ""patch"": ""@@ -617,7 +617,7 @@\n\n {\n     ALOGV(\""constructor\"");\n \n-    const sp<IMediaPlayerService>& service(getMediaPlayerService());\n+    const sp<IMediaPlayerService> service(getMediaPlayerService());\n     if (service != NULL) {\n         mMediaRecorder = service->createMediaRecorder(opPackageName);\n     }\n""}","status_t MediaPlayer::setDataSource(int fd, int64_t offset, int64_t length)

 {
     ALOGV(""setDataSource(%d, %"" PRId64 "", %"" PRId64 "")"", fd, offset, length);
     status_t err = UNKNOWN_ERROR;
    const sp<IMediaPlayerService> service(getMediaPlayerService());
     if (service != 0) {
         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
 (NO_ERROR != player->setDataSource(fd, offset, length))) {
            player.clear();
 }
        err = attachNewPlayer(player);
 }
 return err;
}
","status_t MediaPlayer::setDataSource(int fd, int64_t offset, int64_t length)

 {
     ALOGV(""setDataSource(%d, %"" PRId64 "", %"" PRId64 "")"", fd, offset, length);
     status_t err = UNKNOWN_ERROR;
    const sp<IMediaPlayerService>& service(getMediaPlayerService());
     if (service != 0) {
         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
 (NO_ERROR != player->setDataSource(fd, offset, length))) {
            player.clear();
 }
        err = attachNewPlayer(player);
 }
 return err;
}
",C,"    const sp<IMediaPlayerService> service(getMediaPlayerService());
","    const sp<IMediaPlayerService>& service(getMediaPlayerService());
",,"@@ -152,7 +152,7 @@

     ALOGV(""setDataSource(%s)"", url);
     status_t err = BAD_VALUE;
     if (url != NULL) {
-        const sp<IMediaPlayerService>& service(getMediaPlayerService());
+        const sp<IMediaPlayerService> service(getMediaPlayerService());
         if (service != 0) {
             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
@@ -169,7 +169,7 @@

 {
     ALOGV(""setDataSource(%d, %"" PRId64 "", %"" PRId64 "")"", fd, offset, length);
     status_t err = UNKNOWN_ERROR;
-    const sp<IMediaPlayerService>& service(getMediaPlayerService());
+    const sp<IMediaPlayerService> service(getMediaPlayerService());
     if (service != 0) {
         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
@@ -185,7 +185,7 @@

 {
     ALOGV(""setDataSource"");
     status_t err = UNKNOWN_ERROR;
-    const sp<IMediaPlayerService>& service(getMediaPlayerService());
+    const sp<IMediaPlayerService> service(getMediaPlayerService());
     if (service != 0) {
         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
",Android,https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69/,https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69%5E/,1,"status_t MediaPlayer::setDataSource(int fd, int64_t offset, int64_t length)

 {
     ALOGV(""setDataSource(%d, %"" PRId64 "", %"" PRId64 "")"", fd, offset, length);
     status_t err = UNKNOWN_ERROR;
//flaw_line_below:
    const sp<IMediaPlayerService>& service(getMediaPlayerService());
//fix_flaw_line_below:
//    const sp<IMediaPlayerService> service(getMediaPlayerService());
     if (service != 0) {
         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
 (NO_ERROR != player->setDataSource(fd, offset, length))) {
            player.clear();
 }
        err = attachNewPlayer(player);
 }
 return err;
}
"
9825,187561,,Remote,Not required,Partial,CVE-2016-3821,https://www.cvedetails.com/cve/CVE-2016-3821/,CWE-476,Low,Partial,Partial,,2016-08-05,7.5,"libmedia in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 has certain incorrect declarations, which allows remote attackers to execute arbitrary code or cause a denial of service (NULL pointer dereference or memory corruption) via a crafted media file, aka internal bug 28166152.",2016-11-28,DoS Exec Code Mem. Corr. ,1,https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69,42a25c46b844518ff0d0b920c20c519e1417be69,"Don't use sp<>&

because they may end up pointing to NULL after a NULL check was performed.

Bug: 28166152
Change-Id: Iab2ea30395b620628cc6f3d067dd4f6fcda824fe
",1,media/libmedia/mediaplayer.cpp,"{""filename"": ""include/media/IMediaDeathNotifier.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69/include/media/IMediaDeathNotifier.h"", ""patch"": ""@@ -30,7 +30,7 @@\n\n     virtual ~IMediaDeathNotifier() { removeObitRecipient(this); }\n \n     virtual void died() = 0;\n-    static const sp<IMediaPlayerService>& getMediaPlayerService();\n+    static const sp<IMediaPlayerService> getMediaPlayerService();\n \n private:\n     IMediaDeathNotifier &operator=(const IMediaDeathNotifier &);\n""}<_**next**_>{""filename"": ""media/libmedia/IMediaDeathNotifier.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69/media/libmedia/IMediaDeathNotifier.cpp"", ""patch"": ""@@ -31,7 +31,7 @@\n\n SortedVector< wp<IMediaDeathNotifier> > IMediaDeathNotifier::sObitRecipients;\n \n // establish binder interface to MediaPlayerService\n-/*static*/const sp<IMediaPlayerService>&\n+/*static*/const sp<IMediaPlayerService>\n IMediaDeathNotifier::getMediaPlayerService()\n {\n     ALOGV(\""getMediaPlayerService\"");\n""}<_**next**_>{""filename"": ""media/libmedia/mediaplayer.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69/media/libmedia/mediaplayer.cpp"", ""patch"": ""@@ -152,7 +152,7 @@\n\n     ALOGV(\""setDataSource(%s)\"", url);\n     status_t err = BAD_VALUE;\n     if (url != NULL) {\n-        const sp<IMediaPlayerService>& service(getMediaPlayerService());\n+        const sp<IMediaPlayerService> service(getMediaPlayerService());\n         if (service != 0) {\n             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n@@ -169,7 +169,7 @@\n\n {\n     ALOGV(\""setDataSource(%d, %\"" PRId64 \"", %\"" PRId64 \"")\"", fd, offset, length);\n     status_t err = UNKNOWN_ERROR;\n-    const sp<IMediaPlayerService>& service(getMediaPlayerService());\n+    const sp<IMediaPlayerService> service(getMediaPlayerService());\n     if (service != 0) {\n         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n@@ -185,7 +185,7 @@\n\n {\n     ALOGV(\""setDataSource\"");\n     status_t err = UNKNOWN_ERROR;\n-    const sp<IMediaPlayerService>& service(getMediaPlayerService());\n+    const sp<IMediaPlayerService> service(getMediaPlayerService());\n     if (service != 0) {\n         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n""}<_**next**_>{""filename"": ""media/libmedia/mediarecorder.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69/media/libmedia/mediarecorder.cpp"", ""patch"": ""@@ -617,7 +617,7 @@\n\n {\n     ALOGV(\""constructor\"");\n \n-    const sp<IMediaPlayerService>& service(getMediaPlayerService());\n+    const sp<IMediaPlayerService> service(getMediaPlayerService());\n     if (service != NULL) {\n         mMediaRecorder = service->createMediaRecorder(opPackageName);\n     }\n""}","status_t MediaPlayer::setDataSource(const sp<IStreamSource> &source)

 {
     ALOGV(""setDataSource"");
     status_t err = UNKNOWN_ERROR;
    const sp<IMediaPlayerService> service(getMediaPlayerService());
     if (service != 0) {
         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
 (NO_ERROR != player->setDataSource(source))) {
            player.clear();
 }
        err = attachNewPlayer(player);
 }
 return err;
}
","status_t MediaPlayer::setDataSource(const sp<IStreamSource> &source)

 {
     ALOGV(""setDataSource"");
     status_t err = UNKNOWN_ERROR;
    const sp<IMediaPlayerService>& service(getMediaPlayerService());
     if (service != 0) {
         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
 (NO_ERROR != player->setDataSource(source))) {
            player.clear();
 }
        err = attachNewPlayer(player);
 }
 return err;
}
",C,"    const sp<IMediaPlayerService> service(getMediaPlayerService());
","    const sp<IMediaPlayerService>& service(getMediaPlayerService());
",,"@@ -152,7 +152,7 @@

     ALOGV(""setDataSource(%s)"", url);
     status_t err = BAD_VALUE;
     if (url != NULL) {
-        const sp<IMediaPlayerService>& service(getMediaPlayerService());
+        const sp<IMediaPlayerService> service(getMediaPlayerService());
         if (service != 0) {
             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
@@ -169,7 +169,7 @@

 {
     ALOGV(""setDataSource(%d, %"" PRId64 "", %"" PRId64 "")"", fd, offset, length);
     status_t err = UNKNOWN_ERROR;
-    const sp<IMediaPlayerService>& service(getMediaPlayerService());
+    const sp<IMediaPlayerService> service(getMediaPlayerService());
     if (service != 0) {
         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
@@ -185,7 +185,7 @@

 {
     ALOGV(""setDataSource"");
     status_t err = UNKNOWN_ERROR;
-    const sp<IMediaPlayerService>& service(getMediaPlayerService());
+    const sp<IMediaPlayerService> service(getMediaPlayerService());
     if (service != 0) {
         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
",Android,https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69/,https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69%5E/,1,"status_t MediaPlayer::setDataSource(const sp<IStreamSource> &source)

 {
     ALOGV(""setDataSource"");
     status_t err = UNKNOWN_ERROR;
//flaw_line_below:
    const sp<IMediaPlayerService>& service(getMediaPlayerService());
//fix_flaw_line_below:
//    const sp<IMediaPlayerService> service(getMediaPlayerService());
     if (service != 0) {
         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
 (NO_ERROR != player->setDataSource(source))) {
            player.clear();
 }
        err = attachNewPlayer(player);
 }
 return err;
}
"
9826,187562,,Remote,Not required,Partial,CVE-2016-3821,https://www.cvedetails.com/cve/CVE-2016-3821/,CWE-476,Low,Partial,Partial,,2016-08-05,7.5,"libmedia in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 has certain incorrect declarations, which allows remote attackers to execute arbitrary code or cause a denial of service (NULL pointer dereference or memory corruption) via a crafted media file, aka internal bug 28166152.",2016-11-28,DoS Exec Code Mem. Corr. ,1,https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69,42a25c46b844518ff0d0b920c20c519e1417be69,"Don't use sp<>&

because they may end up pointing to NULL after a NULL check was performed.

Bug: 28166152
Change-Id: Iab2ea30395b620628cc6f3d067dd4f6fcda824fe
",1,media/libmedia/mediarecorder.cpp,"{""filename"": ""include/media/IMediaDeathNotifier.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69/include/media/IMediaDeathNotifier.h"", ""patch"": ""@@ -30,7 +30,7 @@\n\n     virtual ~IMediaDeathNotifier() { removeObitRecipient(this); }\n \n     virtual void died() = 0;\n-    static const sp<IMediaPlayerService>& getMediaPlayerService();\n+    static const sp<IMediaPlayerService> getMediaPlayerService();\n \n private:\n     IMediaDeathNotifier &operator=(const IMediaDeathNotifier &);\n""}<_**next**_>{""filename"": ""media/libmedia/IMediaDeathNotifier.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69/media/libmedia/IMediaDeathNotifier.cpp"", ""patch"": ""@@ -31,7 +31,7 @@\n\n SortedVector< wp<IMediaDeathNotifier> > IMediaDeathNotifier::sObitRecipients;\n \n // establish binder interface to MediaPlayerService\n-/*static*/const sp<IMediaPlayerService>&\n+/*static*/const sp<IMediaPlayerService>\n IMediaDeathNotifier::getMediaPlayerService()\n {\n     ALOGV(\""getMediaPlayerService\"");\n""}<_**next**_>{""filename"": ""media/libmedia/mediaplayer.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69/media/libmedia/mediaplayer.cpp"", ""patch"": ""@@ -152,7 +152,7 @@\n\n     ALOGV(\""setDataSource(%s)\"", url);\n     status_t err = BAD_VALUE;\n     if (url != NULL) {\n-        const sp<IMediaPlayerService>& service(getMediaPlayerService());\n+        const sp<IMediaPlayerService> service(getMediaPlayerService());\n         if (service != 0) {\n             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n@@ -169,7 +169,7 @@\n\n {\n     ALOGV(\""setDataSource(%d, %\"" PRId64 \"", %\"" PRId64 \"")\"", fd, offset, length);\n     status_t err = UNKNOWN_ERROR;\n-    const sp<IMediaPlayerService>& service(getMediaPlayerService());\n+    const sp<IMediaPlayerService> service(getMediaPlayerService());\n     if (service != 0) {\n         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n@@ -185,7 +185,7 @@\n\n {\n     ALOGV(\""setDataSource\"");\n     status_t err = UNKNOWN_ERROR;\n-    const sp<IMediaPlayerService>& service(getMediaPlayerService());\n+    const sp<IMediaPlayerService> service(getMediaPlayerService());\n     if (service != 0) {\n         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n""}<_**next**_>{""filename"": ""media/libmedia/mediarecorder.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69/media/libmedia/mediarecorder.cpp"", ""patch"": ""@@ -617,7 +617,7 @@\n\n {\n     ALOGV(\""constructor\"");\n \n-    const sp<IMediaPlayerService>& service(getMediaPlayerService());\n+    const sp<IMediaPlayerService> service(getMediaPlayerService());\n     if (service != NULL) {\n         mMediaRecorder = service->createMediaRecorder(opPackageName);\n     }\n""}","MediaRecorder::MediaRecorder(const String16& opPackageName) : mSurfaceMediaSource(NULL)

 {
     ALOGV(""constructor"");
 
    const sp<IMediaPlayerService> service(getMediaPlayerService());
     if (service != NULL) {
         mMediaRecorder = service->createMediaRecorder(opPackageName);
     }
 if (mMediaRecorder != NULL) {
        mCurrentState = MEDIA_RECORDER_IDLE;
 }


    doCleanUp();
}
","MediaRecorder::MediaRecorder(const String16& opPackageName) : mSurfaceMediaSource(NULL)

 {
     ALOGV(""constructor"");
 
    const sp<IMediaPlayerService>& service(getMediaPlayerService());
     if (service != NULL) {
         mMediaRecorder = service->createMediaRecorder(opPackageName);
     }
 if (mMediaRecorder != NULL) {
        mCurrentState = MEDIA_RECORDER_IDLE;
 }


    doCleanUp();
}
",C,"    const sp<IMediaPlayerService> service(getMediaPlayerService());
","    const sp<IMediaPlayerService>& service(getMediaPlayerService());
",,"@@ -617,7 +617,7 @@

 {
     ALOGV(""constructor"");
 
-    const sp<IMediaPlayerService>& service(getMediaPlayerService());
+    const sp<IMediaPlayerService> service(getMediaPlayerService());
     if (service != NULL) {
         mMediaRecorder = service->createMediaRecorder(opPackageName);
     }
",Android,https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69/,https://android.googlesource.com/platform/frameworks/av/+/42a25c46b844518ff0d0b920c20c519e1417be69%5E/,1,"MediaRecorder::MediaRecorder(const String16& opPackageName) : mSurfaceMediaSource(NULL)

 {
     ALOGV(""constructor"");
 
//flaw_line_below:
    const sp<IMediaPlayerService>& service(getMediaPlayerService());
//fix_flaw_line_below:
//    const sp<IMediaPlayerService> service(getMediaPlayerService());
     if (service != NULL) {
         mMediaRecorder = service->createMediaRecorder(opPackageName);
     }
 if (mMediaRecorder != NULL) {
        mCurrentState = MEDIA_RECORDER_IDLE;
 }


    doCleanUp();
}
"
10287,188023,,Remote,Not required,Complete,CVE-2017-0635,https://www.cvedetails.com/cve/CVE-2017-0635/,CWE-476,Medium,,,,2017-05-12,7.1,"A remote denial of service vulnerability in HevcUtils.cpp in libstagefright in Mediaserver could enable an attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as Low due to details specific to the vulnerability. Product: Android. Versions: 7.0, 7.1.1, 7.1.2. Android ID: A-35467107.",2019-10-02,DoS ,16,https://android.googlesource.com/platform/frameworks/av/+/523f6b49c1a2289161f40cf9fe80b92e592e9441,523f6b49c1a2289161f40cf9fe80b92e592e9441,"Validate lengths in HEVC metadata parsing

Add code to validate the size parameter passed to
HecvParameterSets::addNalUnit().  Previously vulnerable
to decrementing an unsigned past 0, yielding a huge result value.

Bug: 35467107
Test: ran POC, no crash, emitted new ""bad length"" log entry
Change-Id: Ia169b9edc1e0f7c5302e3c68aa90a54e8863d79e
(cherry picked from commit e0dcf097cc029d056926029a29419e1650cbdf1b)
",0,media/libstagefright/HevcUtils.cpp,"{""filename"": ""media/libstagefright/HevcUtils.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/523f6b49c1a2289161f40cf9fe80b92e592e9441/media/libstagefright/HevcUtils.cpp"", ""patch"": ""@@ -45,16 +45,32 @@\n\n }\n \n status_t HevcParameterSets::addNalUnit(const uint8_t* data, size_t size) {\n+    if (size < 1) {\n+        ALOGE(\""empty NAL b/35467107\"");\n+        return ERROR_MALFORMED;\n+    }\n     uint8_t nalUnitType = (data[0] >> 1) & 0x3f;\n     status_t err = OK;\n     switch (nalUnitType) {\n         case 32:  // VPS\n+            if (size < 2) {\n+                ALOGE(\""invalid NAL/VPS size b/35467107\"");\n+                return ERROR_MALFORMED;\n+            }\n             err = parseVps(data + 2, size - 2);\n             break;\n         case 33:  // SPS\n+            if (size < 2) {\n+                ALOGE(\""invalid NAL/SPS size b/35467107\"");\n+                return ERROR_MALFORMED;\n+            }\n             err = parseSps(data + 2, size - 2);\n             break;\n         case 34:  // PPS\n+            if (size < 2) {\n+                ALOGE(\""invalid NAL/PPS size b/35467107\"");\n+                return ERROR_MALFORMED;\n+            }\n             err = parsePps(data + 2, size - 2);\n             break;\n         case 39:  // Prefix SEI\n""}"," status_t HevcParameterSets::addNalUnit(const uint8_t* data, size_t size) {
    if (size < 1) {
        ALOGE(""empty NAL b/35467107"");
        return ERROR_MALFORMED;
    }
     uint8_t nalUnitType = (data[0] >> 1) & 0x3f;
     status_t err = OK;
     switch (nalUnitType) {
         case 32:  // VPS
            if (size < 2) {
                ALOGE(""invalid NAL/VPS size b/35467107"");
                return ERROR_MALFORMED;
            }
             err = parseVps(data + 2, size - 2);
             break;
         case 33:  // SPS
            if (size < 2) {
                ALOGE(""invalid NAL/SPS size b/35467107"");
                return ERROR_MALFORMED;
            }
             err = parseSps(data + 2, size - 2);
             break;
         case 34:  // PPS
            if (size < 2) {
                ALOGE(""invalid NAL/PPS size b/35467107"");
                return ERROR_MALFORMED;
            }
             err = parsePps(data + 2, size - 2);
             break;
         case 39:  // Prefix SEI
 case 40: // Suffix SEI
 break;
 default:
            ALOGE(""Unrecognized NAL unit type."");
 return ERROR_MALFORMED;
 }

 if (err != OK) {
 return err;
 }

    sp<ABuffer> buffer = ABuffer::CreateAsCopy(data, size);
    buffer->setInt32Data(nalUnitType);
    mNalUnits.push(buffer);
 return OK;
}
"," status_t HevcParameterSets::addNalUnit(const uint8_t* data, size_t size) {
     uint8_t nalUnitType = (data[0] >> 1) & 0x3f;
     status_t err = OK;
     switch (nalUnitType) {
         case 32:  // VPS
             err = parseVps(data + 2, size - 2);
             break;
         case 33:  // SPS
             err = parseSps(data + 2, size - 2);
             break;
         case 34:  // PPS
             err = parsePps(data + 2, size - 2);
             break;
         case 39:  // Prefix SEI
 case 40: // Suffix SEI
 break;
 default:
            ALOGE(""Unrecognized NAL unit type."");
 return ERROR_MALFORMED;
 }

 if (err != OK) {
 return err;
 }

    sp<ABuffer> buffer = ABuffer::CreateAsCopy(data, size);
    buffer->setInt32Data(nalUnitType);
    mNalUnits.push(buffer);
 return OK;
}
",C,"    if (size < 1) {
        ALOGE(""empty NAL b/35467107"");
        return ERROR_MALFORMED;
    }
            if (size < 2) {
                ALOGE(""invalid NAL/VPS size b/35467107"");
                return ERROR_MALFORMED;
            }
            if (size < 2) {
                ALOGE(""invalid NAL/SPS size b/35467107"");
                return ERROR_MALFORMED;
            }
            if (size < 2) {
                ALOGE(""invalid NAL/PPS size b/35467107"");
                return ERROR_MALFORMED;
            }
",,,"@@ -45,16 +45,32 @@

 }
 
 status_t HevcParameterSets::addNalUnit(const uint8_t* data, size_t size) {
+    if (size < 1) {
+        ALOGE(""empty NAL b/35467107"");
+        return ERROR_MALFORMED;
+    }
     uint8_t nalUnitType = (data[0] >> 1) & 0x3f;
     status_t err = OK;
     switch (nalUnitType) {
         case 32:  // VPS
+            if (size < 2) {
+                ALOGE(""invalid NAL/VPS size b/35467107"");
+                return ERROR_MALFORMED;
+            }
             err = parseVps(data + 2, size - 2);
             break;
         case 33:  // SPS
+            if (size < 2) {
+                ALOGE(""invalid NAL/SPS size b/35467107"");
+                return ERROR_MALFORMED;
+            }
             err = parseSps(data + 2, size - 2);
             break;
         case 34:  // PPS
+            if (size < 2) {
+                ALOGE(""invalid NAL/PPS size b/35467107"");
+                return ERROR_MALFORMED;
+            }
             err = parsePps(data + 2, size - 2);
             break;
         case 39:  // Prefix SEI
",Android,https://android.googlesource.com/platform/frameworks/av/+/523f6b49c1a2289161f40cf9fe80b92e592e9441/,https://android.googlesource.com/platform/frameworks/av/+/523f6b49c1a2289161f40cf9fe80b92e592e9441%5E/,1," status_t HevcParameterSets::addNalUnit(const uint8_t* data, size_t size) {
//fix_flaw_line_below:
//    if (size < 1) {
//fix_flaw_line_below:
//        ALOGE(""empty NAL b/35467107"");
//fix_flaw_line_below:
//        return ERROR_MALFORMED;
//fix_flaw_line_below:
//    }
     uint8_t nalUnitType = (data[0] >> 1) & 0x3f;
     status_t err = OK;
     switch (nalUnitType) {
         case 32:  // VPS
//fix_flaw_line_below:
//            if (size < 2) {
//fix_flaw_line_below:
//                ALOGE(""invalid NAL/VPS size b/35467107"");
//fix_flaw_line_below:
//                return ERROR_MALFORMED;
//fix_flaw_line_below:
//            }
             err = parseVps(data + 2, size - 2);
             break;
         case 33:  // SPS
//fix_flaw_line_below:
//            if (size < 2) {
//fix_flaw_line_below:
//                ALOGE(""invalid NAL/SPS size b/35467107"");
//fix_flaw_line_below:
//                return ERROR_MALFORMED;
//fix_flaw_line_below:
//            }
             err = parseSps(data + 2, size - 2);
             break;
         case 34:  // PPS
//fix_flaw_line_below:
//            if (size < 2) {
//fix_flaw_line_below:
//                ALOGE(""invalid NAL/PPS size b/35467107"");
//fix_flaw_line_below:
//                return ERROR_MALFORMED;
//fix_flaw_line_below:
//            }
             err = parsePps(data + 2, size - 2);
             break;
         case 39:  // Prefix SEI
 case 40: // Suffix SEI
 // Ignore
 break;
 default:
            ALOGE(""Unrecognized NAL unit type."");
 return ERROR_MALFORMED;
 }

 if (err != OK) {
 return err;
 }

    sp<ABuffer> buffer = ABuffer::CreateAsCopy(data, size);
    buffer->setInt32Data(nalUnitType);
    mNalUnits.push(buffer);
 return OK;
}
"
