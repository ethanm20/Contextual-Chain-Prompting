,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
806,178542,,Remote,Not required,Partial,CVE-2017-18201,https://www.cvedetails.com/cve/CVE-2017-18201/,CWE-415,Low,Partial,Partial,,2018-02-26,7.5,An issue was discovered in GNU libcdio before 2.0.0. There is a double free in get_cdtext_generic() in lib/driver/_cdio_generic.c.,2018-10-31,,0,https://git.savannah.gnu.org/cgit/libcdio.git/commit/?id=f6f9c48fb40b8a1e8218799724b0b61a7161eb1d,f6f9c48fb40b8a1e8218799724b0b61a7161eb1d,,1,,,"get_cdtext_generic (void *p_user_data)
{
  generic_img_private_t *p_env = p_user_data;
  uint8_t *p_cdtext_data = NULL;
  size_t  len;

  if (!p_env) return NULL;

  if (p_env->b_cdtext_error) return NULL;

  if (NULL == p_env->cdtext) {
    p_cdtext_data = read_cdtext_generic (p_env);

    if (NULL != p_cdtext_data) {
      len = CDIO_MMC_GET_LEN16(p_cdtext_data)-2;
      p_env->cdtext = cdtext_init();
 
       if(len <= 0 || 0 != cdtext_data_init (p_env->cdtext, &p_cdtext_data[4], len)) {
         p_env->b_cdtext_error = true;
         free(p_env->cdtext);
         p_env->cdtext = NULL;
       }
      }

      free(p_cdtext_data);
    }
  }
","get_cdtext_generic (void *p_user_data)
{
  generic_img_private_t *p_env = p_user_data;
  uint8_t *p_cdtext_data = NULL;
  size_t  len;

  if (!p_env) return NULL;

  if (p_env->b_cdtext_error) return NULL;

  if (NULL == p_env->cdtext) {
    p_cdtext_data = read_cdtext_generic (p_env);

    if (NULL != p_cdtext_data) {
      len = CDIO_MMC_GET_LEN16(p_cdtext_data)-2;
      p_env->cdtext = cdtext_init();
 
       if(len <= 0 || 0 != cdtext_data_init (p_env->cdtext, &p_cdtext_data[4], len)) {
         p_env->b_cdtext_error = true;
        cdtext_destroy (p_env->cdtext);
         free(p_env->cdtext);
         p_env->cdtext = NULL;
       }
      }

      free(p_cdtext_data);
    }
  }
",C,,"        cdtext_destroy (p_env->cdtext);
",fc4df55c88100e9078cc0617c8754c7ecbadb339,"@@ -296,7 +296,6 @@ get_cdtext_generic (void *p_user_data)
 
       if(len <= 0 || 0 != cdtext_data_init (p_env->cdtext, &p_cdtext_data[4], len)) {
         p_env->b_cdtext_error = true;
-        cdtext_destroy (p_env->cdtext);
         free(p_env->cdtext);
         p_env->cdtext = NULL;
       }",savannah,https://git.savannah.gnu.org/cgit/libcdio.git/tree/lib/driver/_cdio_generic.c?id=f6f9c48fb40b8a1e8218799724b0b61a7161eb1d,https://git.savannah.gnu.org/cgit/libcdio.git/tree/lib/driver/_cdio_generic.c?id=fc4df55c88100e9078cc0617c8754c7ecbadb339,1,"get_cdtext_generic (void *p_user_data)
{
  generic_img_private_t *p_env = p_user_data;
  uint8_t *p_cdtext_data = NULL;
  size_t  len;

  if (!p_env) return NULL;

  if (p_env->b_cdtext_error) return NULL;

  if (NULL == p_env->cdtext) {
    p_cdtext_data = read_cdtext_generic (p_env);

    if (NULL != p_cdtext_data) {
      len = CDIO_MMC_GET_LEN16(p_cdtext_data)-2;
      p_env->cdtext = cdtext_init();
 
       if(len <= 0 || 0 != cdtext_data_init (p_env->cdtext, &p_cdtext_data[4], len)) {
         p_env->b_cdtext_error = true;
//flaw_line_below:
        cdtext_destroy (p_env->cdtext);
         free(p_env->cdtext);
         p_env->cdtext = NULL;
       }
      }

      free(p_cdtext_data);
    }
  }
"
1747,179483,,Remote,Not required,Complete,CVE-2014-4343,https://www.cvedetails.com/cve/CVE-2014-4343/,CWE-415,High,Complete,Complete,,2014-08-14,7.6,"Double free vulnerability in the init_ctx_reselect function in the SPNEGO initiator in lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) 1.10.x through 1.12.x before 1.12.2 allows remote attackers to cause a denial of service (memory corruption) or possibly execute arbitrary code via network traffic that appears to come from an intended acceptor, but specifies a security mechanism different from the one proposed by the initiator.",2017-08-28,DoS Exec Code Mem. Corr. ,0,https://github.com/krb5/krb5/commit/f18ddf5d82de0ab7591a36e465bc24225776940f,f18ddf5d82de0ab7591a36e465bc24225776940f,"Fix double-free in SPNEGO [CVE-2014-4343]

In commit cd7d6b08 (""Verify acceptor's mech in SPNEGO initiator"") the
pointer sc->internal_mech became an alias into sc->mech_set->elements,
which should be considered constant for the duration of the SPNEGO
context.  So don't free it.

CVE-2014-4343:

In MIT krb5 releases 1.10 and newer, an unauthenticated remote
attacker with the ability to spoof packets appearing to be from a
GSSAPI acceptor can cause a double-free condition in GSSAPI initiators
(clients) which are using the SPNEGO mechanism, by returning a
different underlying mechanism than was proposed by the initiator.  At
this stage of the negotiation, the acceptor is unauthenticated, and
the acceptor's response could be spoofed by an attacker with the
ability to inject traffic to the initiator.

Historically, some double-free vulnerabilities can be translated into
remote code execution, though the necessary exploits must be tailored
to the individual application and are usually quite
complicated. Double-frees can also be exploited to cause an
application crash, for a denial of service.  However, most GSSAPI
client applications are not vulnerable, as the SPNEGO mechanism is not
used by default (when GSS_C_NO_OID is passed as the mech_type argument
to gss_init_sec_context()).  The most common use of SPNEGO is for
HTTP-Negotiate, used in web browsers and other web clients.  Most such
clients are believed to not offer HTTP-Negotiate by default, instead
requiring a whitelist of sites for which it may be used to be
configured.  If the whitelist is configured to only allow
HTTP-Negotiate over TLS connections (""https://""), a successful
attacker must also spoof the web server's SSL certificate, due to the
way the WWW-Authenticate header is sent in a 401 (Unauthorized)
response message.  Unfortunately, many instructions for enabling
HTTP-Negotiate in common web browsers do not include a TLS
requirement.

    CVSSv2 Vector: AV:N/AC:H/Au:N/C:C/I:C/A:C/E:POC/RL:OF/RC:C

[kaduk@mit.edu: CVE summary and CVSSv2 vector]

ticket: 7969 (new)
target_version: 1.12.2
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""8f829d8c5920f1ac530d68fa9bbb307011e5eeaa"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/krb5/krb5/blob/f18ddf5d82de0ab7591a36e465bc24225776940f/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/f18ddf5d82de0ab7591a36e465bc24225776940f/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=f18ddf5d82de0ab7591a36e465bc24225776940f"", ""patch"": ""@@ -818,7 +818,6 @@ init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n \tOM_uint32 tmpmin;\n \tsize_t i;\n \n-\tgeneric_gss_release_oid(&tmpmin, &sc->internal_mech);\n \tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n \t\t\t       GSS_C_NO_BUFFER);\n ""}","init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,
		  OM_uint32 acc_negState, gss_OID supportedMech,
		  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,
		  OM_uint32 *negState, send_token_flag *tokflag)
{
 	OM_uint32 tmpmin;
 	size_t i;
 
 	gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
 			       GSS_C_NO_BUFFER);
 
	/* Find supportedMech in sc->mech_set. */
	for (i = 0; i < sc->mech_set->count; i++) {
		if (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))
			break;
	}
	if (i == sc->mech_set->count)
		return GSS_S_DEFECTIVE_TOKEN;
	sc->internal_mech = &sc->mech_set->elements[i];

	/*
	 * Windows 2003 and earlier don't correctly send a
	 * negState of request-mic when counter-proposing a
	 * mechanism.  They probably don't handle mechListMICs
	 * properly either.
	 */
	if (acc_negState != REQUEST_MIC)
		return GSS_S_DEFECTIVE_TOKEN;

	sc->mech_complete = 0;
	sc->mic_reqd = 1;
	*negState = REQUEST_MIC;
	*tokflag = CONT_TOKEN_SEND;
	return GSS_S_CONTINUE_NEEDED;
}
","init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,
		  OM_uint32 acc_negState, gss_OID supportedMech,
		  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,
		  OM_uint32 *negState, send_token_flag *tokflag)
{
 	OM_uint32 tmpmin;
 	size_t i;
 
	generic_gss_release_oid(&tmpmin, &sc->internal_mech);
 	gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
 			       GSS_C_NO_BUFFER);
 
	/* Find supportedMech in sc->mech_set. */
	for (i = 0; i < sc->mech_set->count; i++) {
		if (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))
			break;
	}
	if (i == sc->mech_set->count)
		return GSS_S_DEFECTIVE_TOKEN;
	sc->internal_mech = &sc->mech_set->elements[i];

	/*
	 * Windows 2003 and earlier don't correctly send a
	 * negState of request-mic when counter-proposing a
	 * mechanism.  They probably don't handle mechListMICs
	 * properly either.
	 */
	if (acc_negState != REQUEST_MIC)
		return GSS_S_DEFECTIVE_TOKEN;

	sc->mech_complete = 0;
	sc->mic_reqd = 1;
	*negState = REQUEST_MIC;
	*tokflag = CONT_TOKEN_SEND;
	return GSS_S_CONTINUE_NEEDED;
}
",C,,"	generic_gss_release_oid(&tmpmin, &sc->internal_mech);
",,"@@ -818,7 +818,6 @@ init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,
 	OM_uint32 tmpmin;
 	size_t i;
 
-	generic_gss_release_oid(&tmpmin, &sc->internal_mech);
 	gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
 			       GSS_C_NO_BUFFER);
 ",krb5,f18ddf5d82de0ab7591a36e465bc24225776940f,53362ba69fb5a60386dd358c3450bfcf4f6b7346,1,"init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,
		  OM_uint32 acc_negState, gss_OID supportedMech,
		  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,
		  OM_uint32 *negState, send_token_flag *tokflag)
{
 	OM_uint32 tmpmin;
 	size_t i;
 
//flaw_line_below:
	generic_gss_release_oid(&tmpmin, &sc->internal_mech);
 	gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
 			       GSS_C_NO_BUFFER);
 
	/* Find supportedMech in sc->mech_set. */
	for (i = 0; i < sc->mech_set->count; i++) {
		if (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))
			break;
	}
	if (i == sc->mech_set->count)
		return GSS_S_DEFECTIVE_TOKEN;
	sc->internal_mech = &sc->mech_set->elements[i];

	/*
	 * Windows 2003 and earlier don't correctly send a
	 * negState of request-mic when counter-proposing a
	 * mechanism.  They probably don't handle mechListMICs
	 * properly either.
	 */
	if (acc_negState != REQUEST_MIC)
		return GSS_S_DEFECTIVE_TOKEN;

	sc->mech_complete = 0;
	sc->mic_reqd = 1;
	*negState = REQUEST_MIC;
	*tokflag = CONT_TOKEN_SEND;
	return GSS_S_CONTINUE_NEEDED;
}
"
2280,180016,,Local,Not required,Complete,CVE-2016-9806,https://www.cvedetails.com/cve/CVE-2016-9806/,CWE-415,Low,Complete,Complete,,2016-12-28,7.2,"Race condition in the netlink_dump function in net/netlink/af_netlink.c in the Linux kernel before 4.6.3 allows local users to cause a denial of service (double free) or possibly have unspecified other impact via a crafted application that makes sendmsg system calls, leading to a free operation associated with a new dump that started earlier than anticipated.",2018-01-04,DoS ,5,https://github.com/torvalds/linux/commit/92964c79b357efd980812c4de5c1fd2ec8bb5520,92964c79b357efd980812c4de5c1fd2ec8bb5520,"netlink: Fix dump skb leak/double free

When we free cb->skb after a dump, we do it after releasing the
lock.  This means that a new dump could have started in the time
being and we'll end up freeing their skb instead of ours.

This patch saves the skb and module before we unlock so we free
the right memory.

Fixes: 16b304f3404f (""netlink: Eliminate kmalloc in netlink dump operation."")
Reported-by: Baozeng Ding <sploving1@gmail.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
Acked-by: Cong Wang <xiyou.wangcong@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",2,net/netlink/af_netlink.c,"{""sha"": ""627f898c05b96552318a881ce995ccc3342e1576"", ""filename"": ""net/netlink/af_netlink.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/92964c79b357efd980812c4de5c1fd2ec8bb5520/net/netlink/af_netlink.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/92964c79b357efd980812c4de5c1fd2ec8bb5520/net/netlink/af_netlink.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/netlink/af_netlink.c?ref=92964c79b357efd980812c4de5c1fd2ec8bb5520"", ""patch"": ""@@ -2059,6 +2059,7 @@ static int netlink_dump(struct sock *sk)\n \tstruct netlink_callback *cb;\n \tstruct sk_buff *skb = NULL;\n \tstruct nlmsghdr *nlh;\n+\tstruct module *module;\n \tint len, err = -ENOBUFS;\n \tint alloc_min_size;\n \tint alloc_size;\n@@ -2134,9 +2135,11 @@ static int netlink_dump(struct sock *sk)\n \t\tcb->done(cb);\n \n \tnlk->cb_running = false;\n+\tmodule = cb->module;\n+\tskb = cb->skb;\n \tmutex_unlock(nlk->cb_mutex);\n-\tmodule_put(cb->module);\n-\tconsume_skb(cb->skb);\n+\tmodule_put(module);\n+\tconsume_skb(skb);\n \treturn 0;\n \n errout_skb:""}","static int netlink_dump(struct sock *sk)
{
	struct netlink_sock *nlk = nlk_sk(sk);
 	struct netlink_callback *cb;
 	struct sk_buff *skb = NULL;
 	struct nlmsghdr *nlh;
	struct module *module;
 	int len, err = -ENOBUFS;
 	int alloc_min_size;
 	int alloc_size;

	mutex_lock(nlk->cb_mutex);
	if (!nlk->cb_running) {
		err = -EINVAL;
		goto errout_skb;
	}

	if (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)
		goto errout_skb;

	/* NLMSG_GOODSIZE is small to avoid high order allocations being
	 * required, but it makes sense to _attempt_ a 16K bytes allocation
	 * to reduce number of system calls on dump operations, if user
	 * ever provided a big enough buffer.
	 */
	cb = &nlk->cb;
	alloc_min_size = max_t(int, cb->min_dump_alloc, NLMSG_GOODSIZE);

	if (alloc_min_size < nlk->max_recvmsg_len) {
		alloc_size = nlk->max_recvmsg_len;
		skb = alloc_skb(alloc_size, GFP_KERNEL |
					    __GFP_NOWARN | __GFP_NORETRY);
	}
	if (!skb) {
		alloc_size = alloc_min_size;
		skb = alloc_skb(alloc_size, GFP_KERNEL);
	}
	if (!skb)
		goto errout_skb;

	/* Trim skb to allocated size. User is expected to provide buffer as
	 * large as max(min_dump_alloc, 16KiB (mac_recvmsg_len capped at
	 * netlink_recvmsg())). dump will pack as many smaller messages as
	 * could fit within the allocated skb. skb is typically allocated
	 * with larger space than required (could be as much as near 2x the
	 * requested size with align to next power of 2 approach). Allowing
	 * dump to use the excess space makes it difficult for a user to have a
	 * reasonable static buffer based on the expected largest dump of a
	 * single netdev. The outcome is MSG_TRUNC error.
	 */
	skb_reserve(skb, skb_tailroom(skb) - alloc_size);
	netlink_skb_set_owner_r(skb, sk);

	len = cb->dump(skb, cb);

	if (len > 0) {
		mutex_unlock(nlk->cb_mutex);

		if (sk_filter(sk, skb))
			kfree_skb(skb);
		else
			__netlink_sendskb(sk, skb);
		return 0;
	}

	nlh = nlmsg_put_answer(skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI);
	if (!nlh)
		goto errout_skb;

	nl_dump_check_consistent(cb, nlh);

	memcpy(nlmsg_data(nlh), &len, sizeof(len));

	if (sk_filter(sk, skb))
		kfree_skb(skb);
	else
		__netlink_sendskb(sk, skb);

	if (cb->done)
 		cb->done(cb);
 
 	nlk->cb_running = false;
	module = cb->module;
	skb = cb->skb;
 	mutex_unlock(nlk->cb_mutex);
	module_put(module);
	consume_skb(skb);
 	return 0;
 
 errout_skb:
	mutex_unlock(nlk->cb_mutex);
	kfree_skb(skb);
	return err;
}
","static int netlink_dump(struct sock *sk)
{
	struct netlink_sock *nlk = nlk_sk(sk);
 	struct netlink_callback *cb;
 	struct sk_buff *skb = NULL;
 	struct nlmsghdr *nlh;
 	int len, err = -ENOBUFS;
 	int alloc_min_size;
 	int alloc_size;

	mutex_lock(nlk->cb_mutex);
	if (!nlk->cb_running) {
		err = -EINVAL;
		goto errout_skb;
	}

	if (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)
		goto errout_skb;

	/* NLMSG_GOODSIZE is small to avoid high order allocations being
	 * required, but it makes sense to _attempt_ a 16K bytes allocation
	 * to reduce number of system calls on dump operations, if user
	 * ever provided a big enough buffer.
	 */
	cb = &nlk->cb;
	alloc_min_size = max_t(int, cb->min_dump_alloc, NLMSG_GOODSIZE);

	if (alloc_min_size < nlk->max_recvmsg_len) {
		alloc_size = nlk->max_recvmsg_len;
		skb = alloc_skb(alloc_size, GFP_KERNEL |
					    __GFP_NOWARN | __GFP_NORETRY);
	}
	if (!skb) {
		alloc_size = alloc_min_size;
		skb = alloc_skb(alloc_size, GFP_KERNEL);
	}
	if (!skb)
		goto errout_skb;

	/* Trim skb to allocated size. User is expected to provide buffer as
	 * large as max(min_dump_alloc, 16KiB (mac_recvmsg_len capped at
	 * netlink_recvmsg())). dump will pack as many smaller messages as
	 * could fit within the allocated skb. skb is typically allocated
	 * with larger space than required (could be as much as near 2x the
	 * requested size with align to next power of 2 approach). Allowing
	 * dump to use the excess space makes it difficult for a user to have a
	 * reasonable static buffer based on the expected largest dump of a
	 * single netdev. The outcome is MSG_TRUNC error.
	 */
	skb_reserve(skb, skb_tailroom(skb) - alloc_size);
	netlink_skb_set_owner_r(skb, sk);

	len = cb->dump(skb, cb);

	if (len > 0) {
		mutex_unlock(nlk->cb_mutex);

		if (sk_filter(sk, skb))
			kfree_skb(skb);
		else
			__netlink_sendskb(sk, skb);
		return 0;
	}

	nlh = nlmsg_put_answer(skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI);
	if (!nlh)
		goto errout_skb;

	nl_dump_check_consistent(cb, nlh);

	memcpy(nlmsg_data(nlh), &len, sizeof(len));

	if (sk_filter(sk, skb))
		kfree_skb(skb);
	else
		__netlink_sendskb(sk, skb);

	if (cb->done)
 		cb->done(cb);
 
 	nlk->cb_running = false;
 	mutex_unlock(nlk->cb_mutex);
	module_put(cb->module);
	consume_skb(cb->skb);
 	return 0;
 
 errout_skb:
	mutex_unlock(nlk->cb_mutex);
	kfree_skb(skb);
	return err;
}
",C,"	struct module *module;
	module = cb->module;
	skb = cb->skb;
	module_put(module);
	consume_skb(skb);
","	module_put(cb->module);
	consume_skb(cb->skb);
",,"@@ -2059,6 +2059,7 @@ static int netlink_dump(struct sock *sk)
 	struct netlink_callback *cb;
 	struct sk_buff *skb = NULL;
 	struct nlmsghdr *nlh;
+	struct module *module;
 	int len, err = -ENOBUFS;
 	int alloc_min_size;
 	int alloc_size;
@@ -2134,9 +2135,11 @@ static int netlink_dump(struct sock *sk)
 		cb->done(cb);
 
 	nlk->cb_running = false;
+	module = cb->module;
+	skb = cb->skb;
 	mutex_unlock(nlk->cb_mutex);
-	module_put(cb->module);
-	consume_skb(cb->skb);
+	module_put(module);
+	consume_skb(skb);
 	return 0;
 
 errout_skb:",linux,92964c79b357efd980812c4de5c1fd2ec8bb5520,45e093ae2830cd1264677d47ff9a95a71f5d9f9c,1,"static int netlink_dump(struct sock *sk)
{
	struct netlink_sock *nlk = nlk_sk(sk);
 	struct netlink_callback *cb;
 	struct sk_buff *skb = NULL;
 	struct nlmsghdr *nlh;
//fix_flaw_line_below:
//	struct module *module;
 	int len, err = -ENOBUFS;
 	int alloc_min_size;
 	int alloc_size;

	mutex_lock(nlk->cb_mutex);
	if (!nlk->cb_running) {
		err = -EINVAL;
		goto errout_skb;
	}

	if (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)
		goto errout_skb;

	/* NLMSG_GOODSIZE is small to avoid high order allocations being
	 * required, but it makes sense to _attempt_ a 16K bytes allocation
	 * to reduce number of system calls on dump operations, if user
	 * ever provided a big enough buffer.
	 */
	cb = &nlk->cb;
	alloc_min_size = max_t(int, cb->min_dump_alloc, NLMSG_GOODSIZE);

	if (alloc_min_size < nlk->max_recvmsg_len) {
		alloc_size = nlk->max_recvmsg_len;
		skb = alloc_skb(alloc_size, GFP_KERNEL |
					    __GFP_NOWARN | __GFP_NORETRY);
	}
	if (!skb) {
		alloc_size = alloc_min_size;
		skb = alloc_skb(alloc_size, GFP_KERNEL);
	}
	if (!skb)
		goto errout_skb;

	/* Trim skb to allocated size. User is expected to provide buffer as
	 * large as max(min_dump_alloc, 16KiB (mac_recvmsg_len capped at
	 * netlink_recvmsg())). dump will pack as many smaller messages as
	 * could fit within the allocated skb. skb is typically allocated
	 * with larger space than required (could be as much as near 2x the
	 * requested size with align to next power of 2 approach). Allowing
	 * dump to use the excess space makes it difficult for a user to have a
	 * reasonable static buffer based on the expected largest dump of a
	 * single netdev. The outcome is MSG_TRUNC error.
	 */
	skb_reserve(skb, skb_tailroom(skb) - alloc_size);
	netlink_skb_set_owner_r(skb, sk);

	len = cb->dump(skb, cb);

	if (len > 0) {
		mutex_unlock(nlk->cb_mutex);

		if (sk_filter(sk, skb))
			kfree_skb(skb);
		else
			__netlink_sendskb(sk, skb);
		return 0;
	}

	nlh = nlmsg_put_answer(skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI);
	if (!nlh)
		goto errout_skb;

	nl_dump_check_consistent(cb, nlh);

	memcpy(nlmsg_data(nlh), &len, sizeof(len));

	if (sk_filter(sk, skb))
		kfree_skb(skb);
	else
		__netlink_sendskb(sk, skb);

	if (cb->done)
 		cb->done(cb);
 
 	nlk->cb_running = false;
//fix_flaw_line_below:
//	module = cb->module;
//fix_flaw_line_below:
//	skb = cb->skb;
 	mutex_unlock(nlk->cb_mutex);
//flaw_line_below:
	module_put(cb->module);
//flaw_line_below:
	consume_skb(cb->skb);
//fix_flaw_line_below:
//	module_put(module);
//fix_flaw_line_below:
//	consume_skb(skb);
 	return 0;
 
 errout_skb:
	mutex_unlock(nlk->cb_mutex);
	kfree_skb(skb);
	return err;
}
"
2460,180196,,Remote,Not required,Partial,CVE-2016-5772,https://www.cvedetails.com/cve/CVE-2016-5772/,CWE-415,Low,Partial,Partial,,2016-08-07,7.5,"Double free vulnerability in the php_wddx_process_data function in wddx.c in the WDDX extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via crafted XML data that is mishandled in a wddx_deserialize call.",2018-01-04,DoS Exec Code ,4,https://github.com/php/php-src/commit/a44c89e8af7c2410f4bfc5e097be2a5d0639a60c?w=1,a44c89e8af7c2410f4bfc5e097be2a5d0639a60c?w=1,Fix bug #72340: Double Free Courruption in wddx_deserialize,0,ext/wddx/wddx.c,"{""sha"": ""8d694ca52e761a32d7190bb93e203f97240a38ce"", ""filename"": ""ext/wddx/tests/bug72340.phpt"", ""status"": ""added"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/php/php-src/blob/a44c89e8af7c2410f4bfc5e097be2a5d0639a60c/ext/wddx/tests/bug72340.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/a44c89e8af7c2410f4bfc5e097be2a5d0639a60c/ext/wddx/tests/bug72340.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/tests/bug72340.phpt?ref=a44c89e8af7c2410f4bfc5e097be2a5d0639a60c"", ""patch"": ""@@ -0,0 +1,24 @@\n+--TEST--\n+Bug #72340: Double Free Courruption in wddx_deserialize\n+--SKIPIF--\n+<?php\n+if (!extension_loaded(\""wddx\"")) print \""skip\"";\n+?>\n+--FILE--\n+<?php\n+$xml = <<<EOF\n+<?xml version='1.0' ?>\n+<!DOCTYPE wddxPacket SYSTEM 'wddx_0100.dtd'>\n+<wddxPacket version='1.0'>\n+\t<array><var name=\""XXXXXXXX\""><boolean value=\""none\"">TEST</boolean></var>\n+\t\t<var name=\""YYYYYYYY\""><var name=\""ZZZZZZZZ\""><var name=\""EZEZEZEZ\"">\n+\t\t</var></var></var>\n+\t</array>\n+</wddxPacket>\n+EOF;\n+$array = wddx_deserialize($xml);\n+var_dump($array);\n+?>\n+--EXPECT--\n+array(0) {\n+}""}<_**next**_>{""sha"": ""311d6aa4a567f1e04462413300342a86b5436c6c"", ""filename"": ""ext/wddx/wddx.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/php/php-src/blob/a44c89e8af7c2410f4bfc5e097be2a5d0639a60c/ext/wddx/wddx.c"", ""raw_url"": ""https://github.com/php/php-src/raw/a44c89e8af7c2410f4bfc5e097be2a5d0639a60c/ext/wddx/wddx.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/wddx.c?ref=a44c89e8af7c2410f4bfc5e097be2a5d0639a60c"", ""patch"": ""@@ -1096,6 +1096,9 @@ static void php_wddx_process_data(void *user_data, const XML_Char *s, int len)\n \t\t\t\tbreak;\n \n \t\t\tcase ST_BOOLEAN:\n+\t\t\t\tif(!ent->data) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tif (!strcmp(s, \""true\"")) {\n \t\t\t\t\tZ_LVAL_P(ent->data) = 1;\n \t\t\t\t} else if (!strcmp(s, \""false\"")) {\n@@ -1104,6 +1107,7 @@ static void php_wddx_process_data(void *user_data, const XML_Char *s, int len)\n \t\t\t\t\tzval_ptr_dtor(&ent->data);\n \t\t\t\t\tif (ent->varname) {\n \t\t\t\t\t\tefree(ent->varname);\n+\t\t\t\t\t\tent->varname = NULL;\n \t\t\t\t\t}\n \t\t\t\t\tent->data = NULL;\n \t\t\t\t}""}","static void php_wddx_process_data(void *user_data, const XML_Char *s, int len)
{
	st_entry *ent;
	wddx_stack *stack = (wddx_stack *)user_data;
	TSRMLS_FETCH();

	if (!wddx_stack_is_empty(stack) && !stack->done) {
		wddx_stack_top(stack, (void**)&ent);
		switch (ent->type) {
			case ST_STRING:
				if (Z_STRLEN_P(ent->data) == 0) {
					STR_FREE(Z_STRVAL_P(ent->data));
					Z_STRVAL_P(ent->data) = estrndup(s, len);
					Z_STRLEN_P(ent->data) = len;
				} else {
					Z_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);
					memcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);
					Z_STRLEN_P(ent->data) += len;
					Z_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\0';
				}
				break;

			case ST_BINARY:
				if (Z_STRLEN_P(ent->data) == 0) {
					STR_FREE(Z_STRVAL_P(ent->data));
					Z_STRVAL_P(ent->data) = estrndup(s, len + 1);
				} else {
					Z_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);
					memcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);
				}
				Z_STRLEN_P(ent->data) += len;
				Z_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\0';
				break;

			case ST_NUMBER:
				Z_TYPE_P(ent->data) = IS_STRING;
				Z_STRLEN_P(ent->data) = len;
				Z_STRVAL_P(ent->data) = estrndup(s, len);
				convert_scalar_to_number(ent->data TSRMLS_CC);
 				break;
 
 			case ST_BOOLEAN:
				if(!ent->data) {
					break;
				}
 				if (!strcmp(s, ""true"")) {
 					Z_LVAL_P(ent->data) = 1;
 				} else if (!strcmp(s, ""false"")) {
					Z_LVAL_P(ent->data) = 0;
				} else {
 					zval_ptr_dtor(&ent->data);
 					if (ent->varname) {
 						efree(ent->varname);
						ent->varname = NULL;
 					}
 					ent->data = NULL;
 				}
				break;

			case ST_DATETIME: {
				char *tmp;

				tmp = emalloc(len + 1);
				memcpy(tmp, s, len);
				tmp[len] = '\0';

				Z_LVAL_P(ent->data) = php_parse_date(tmp, NULL);
				/* date out of range < 1969 or > 2038 */
				if (Z_LVAL_P(ent->data) == -1) {
					Z_TYPE_P(ent->data) = IS_STRING;
					Z_STRLEN_P(ent->data) = len;
					Z_STRVAL_P(ent->data) = estrndup(s, len);
				}
				efree(tmp);
			}
				break;

			default:
				break;
		}
	}
}
","static void php_wddx_process_data(void *user_data, const XML_Char *s, int len)
{
	st_entry *ent;
	wddx_stack *stack = (wddx_stack *)user_data;
	TSRMLS_FETCH();

	if (!wddx_stack_is_empty(stack) && !stack->done) {
		wddx_stack_top(stack, (void**)&ent);
		switch (ent->type) {
			case ST_STRING:
				if (Z_STRLEN_P(ent->data) == 0) {
					STR_FREE(Z_STRVAL_P(ent->data));
					Z_STRVAL_P(ent->data) = estrndup(s, len);
					Z_STRLEN_P(ent->data) = len;
				} else {
					Z_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);
					memcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);
					Z_STRLEN_P(ent->data) += len;
					Z_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\0';
				}
				break;

			case ST_BINARY:
				if (Z_STRLEN_P(ent->data) == 0) {
					STR_FREE(Z_STRVAL_P(ent->data));
					Z_STRVAL_P(ent->data) = estrndup(s, len + 1);
				} else {
					Z_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);
					memcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);
				}
				Z_STRLEN_P(ent->data) += len;
				Z_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\0';
				break;

			case ST_NUMBER:
				Z_TYPE_P(ent->data) = IS_STRING;
				Z_STRLEN_P(ent->data) = len;
				Z_STRVAL_P(ent->data) = estrndup(s, len);
				convert_scalar_to_number(ent->data TSRMLS_CC);
 				break;
 
 			case ST_BOOLEAN:
 				if (!strcmp(s, ""true"")) {
 					Z_LVAL_P(ent->data) = 1;
 				} else if (!strcmp(s, ""false"")) {
					Z_LVAL_P(ent->data) = 0;
				} else {
 					zval_ptr_dtor(&ent->data);
 					if (ent->varname) {
 						efree(ent->varname);
 					}
 					ent->data = NULL;
 				}
				break;

			case ST_DATETIME: {
				char *tmp;

				tmp = emalloc(len + 1);
				memcpy(tmp, s, len);
				tmp[len] = '\0';

				Z_LVAL_P(ent->data) = php_parse_date(tmp, NULL);
				/* date out of range < 1969 or > 2038 */
				if (Z_LVAL_P(ent->data) == -1) {
					Z_TYPE_P(ent->data) = IS_STRING;
					Z_STRLEN_P(ent->data) = len;
					Z_STRVAL_P(ent->data) = estrndup(s, len);
				}
				efree(tmp);
			}
				break;

			default:
				break;
		}
	}
}
",C,"				if(!ent->data) {
					break;
				}
						ent->varname = NULL;
",,,"@@ -1096,6 +1096,9 @@ static void php_wddx_process_data(void *user_data, const XML_Char *s, int len)
 				break;
 
 			case ST_BOOLEAN:
+				if(!ent->data) {
+					break;
+				}
 				if (!strcmp(s, ""true"")) {
 					Z_LVAL_P(ent->data) = 1;
 				} else if (!strcmp(s, ""false"")) {
@@ -1104,6 +1107,7 @@ static void php_wddx_process_data(void *user_data, const XML_Char *s, int len)
 					zval_ptr_dtor(&ent->data);
 					if (ent->varname) {
 						efree(ent->varname);
+						ent->varname = NULL;
 					}
 					ent->data = NULL;
 				}",php-src,a44c89e8af7c2410f4bfc5e097be2a5d0639a60c?w=1,4dd03651f3c90a754600e9b76e33c9481bd9e720,1,"static void php_wddx_process_data(void *user_data, const XML_Char *s, int len)
{
	st_entry *ent;
	wddx_stack *stack = (wddx_stack *)user_data;
	TSRMLS_FETCH();

	if (!wddx_stack_is_empty(stack) && !stack->done) {
		wddx_stack_top(stack, (void**)&ent);
		switch (ent->type) {
			case ST_STRING:
				if (Z_STRLEN_P(ent->data) == 0) {
					STR_FREE(Z_STRVAL_P(ent->data));
					Z_STRVAL_P(ent->data) = estrndup(s, len);
					Z_STRLEN_P(ent->data) = len;
				} else {
					Z_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);
					memcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);
					Z_STRLEN_P(ent->data) += len;
					Z_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\0';
				}
				break;

			case ST_BINARY:
				if (Z_STRLEN_P(ent->data) == 0) {
					STR_FREE(Z_STRVAL_P(ent->data));
					Z_STRVAL_P(ent->data) = estrndup(s, len + 1);
				} else {
					Z_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);
					memcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);
				}
				Z_STRLEN_P(ent->data) += len;
				Z_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\0';
				break;

			case ST_NUMBER:
				Z_TYPE_P(ent->data) = IS_STRING;
				Z_STRLEN_P(ent->data) = len;
				Z_STRVAL_P(ent->data) = estrndup(s, len);
				convert_scalar_to_number(ent->data TSRMLS_CC);
 				break;
 
 			case ST_BOOLEAN:
//fix_flaw_line_below:
//				if(!ent->data) {
//fix_flaw_line_below:
//					break;
//fix_flaw_line_below:
//				}
 				if (!strcmp(s, ""true"")) {
 					Z_LVAL_P(ent->data) = 1;
 				} else if (!strcmp(s, ""false"")) {
					Z_LVAL_P(ent->data) = 0;
				} else {
 					zval_ptr_dtor(&ent->data);
 					if (ent->varname) {
 						efree(ent->varname);
//fix_flaw_line_below:
//						ent->varname = NULL;
 					}
 					ent->data = NULL;
 				}
				break;

			case ST_DATETIME: {
				char *tmp;

				tmp = emalloc(len + 1);
				memcpy(tmp, s, len);
				tmp[len] = '\0';

				Z_LVAL_P(ent->data) = php_parse_date(tmp, NULL);
				/* date out of range < 1969 or > 2038 */
				if (Z_LVAL_P(ent->data) == -1) {
					Z_TYPE_P(ent->data) = IS_STRING;
					Z_STRLEN_P(ent->data) = len;
					Z_STRVAL_P(ent->data) = estrndup(s, len);
				}
				efree(tmp);
			}
				break;

			default:
				break;
		}
	}
}
"
2551,180287,,Remote,Not required,Partial,CVE-2016-5768,https://www.cvedetails.com/cve/CVE-2016-5768/,CWE-415,Low,Partial,Partial,,2016-08-07,7.5,"Double free vulnerability in the _php_mb_regex_ereg_replace_exec function in php_mbregex.c in the mbstring extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to execute arbitrary code or cause a denial of service (application crash) by leveraging a callback exception.",2018-01-04,DoS Exec Code ,1,https://github.com/php/php-src/commit/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,Fix bug #72402: _php_mb_regex_ereg_replace_exec - double free,1,ext/mbstring/php_mbregex.c,"{""sha"": ""6cdee23c3e5999b467c4a206bf3f4827ebe121f6"", ""filename"": ""ext/mbstring/php_mbregex.c"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 33, ""changes"": 65, ""blob_url"": ""https://github.com/php/php-src/blob/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/php_mbregex.c"", ""raw_url"": ""https://github.com/php/php-src/raw/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/php_mbregex.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/mbstring/php_mbregex.c?ref=5b597a2e5b28e2d5a52fc1be13f425f08f47cb62"", ""patch"": ""@@ -32,7 +32,7 @@\n #include \""ext/standard/info.h\""\n #include \""php_mbregex.h\""\n #include \""mbstring.h\""\n- \n+\n #include \""php_onig_compat.h\"" /* must come prior to the oniguruma header */\n #include <oniguruma.h>\n #undef UChar\n@@ -55,7 +55,7 @@ struct _zend_mb_regex_globals {\n #define MBREX(g) (MBSTRG(mb_regex_globals)->g)\n \n /* {{{ static void php_mb_regex_free_cache() */\n-static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n+static void php_mb_regex_free_cache(php_mb_regex_t **pre)\n {\n \tonig_free(*pre);\n }\n@@ -78,7 +78,7 @@ static int _php_mb_regex_globals_ctor(zend_mb_regex_globals *pglobals TSRMLS_DC)\n /* }}} */\n \n /* {{{ _php_mb_regex_globals_dtor */\n-static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) \n+static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)\n {\n \tzend_hash_destroy(&pglobals->ht_rc);\n }\n@@ -466,7 +466,7 @@ static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patl\n \t\tretval = *rc;\n \t}\n out:\n-\treturn retval; \n+\treturn retval;\n }\n /* }}} */\n \n@@ -483,15 +483,15 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t\t--len_left;\n \t\t\t*(p++) = 'i';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tif ((option & ONIG_OPTION_EXTEND) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'x';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tif ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==\n@@ -500,37 +500,37 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t\t--len_left;\n \t\t\t*(p++) = 'p';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t} else {\n \t\tif ((option & ONIG_OPTION_MULTILINE) != 0) {\n \t\t\tif (len_left > 0) {\n \t\t\t\t--len_left;\n \t\t\t\t*(p++) = 'm';\n \t\t\t}\n-\t\t\t++len_req;\t\n+\t\t\t++len_req;\n \t\t}\n \n \t\tif ((option & ONIG_OPTION_SINGLELINE) != 0) {\n \t\t\tif (len_left > 0) {\n \t\t\t\t--len_left;\n \t\t\t\t*(p++) = 's';\n \t\t\t}\n-\t\t\t++len_req;\t\n+\t\t\t++len_req;\n \t\t}\n-\t}\t\n+\t}\n \tif ((option & ONIG_OPTION_FIND_LONGEST) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'l';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \tif ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'n';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tc = 0;\n@@ -566,7 +566,7 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t--len_left;\n \t\t*(p++) = '\\0';\n \t}\n-\t++len_req;\t\n+\t++len_req;\n \tif (len < len_req) {\n \t\treturn len_req;\n \t}\n@@ -577,11 +577,11 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \n /* {{{ _php_mb_regex_init_options */\n static void\n-_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) \n+_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)\n {\n \tint n;\n \tchar c;\n-\tint optm = 0; \n+\tint optm = 0;\n \n \t*syntax = ONIG_SYNTAX_RUBY;\n \n@@ -636,13 +636,13 @@ _php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, O\n \t\t\t\t\t*syntax = ONIG_SYNTAX_POSIX_EXTENDED;\n \t\t\t\t\tbreak;\n \t\t\t\tcase 'e':\n-\t\t\t\t\tif (eval != NULL) *eval = 1; \n+\t\t\t\t\tif (eval != NULL) *eval = 1;\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n-\t\tif (option != NULL) *option|=optm; \n+\t\tif (option != NULL) *option|=optm;\n \t}\n }\n /* }}} */\n@@ -860,11 +860,11 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t} else {\n \t\t/* FIXME: this code is not multibyte aware! */\n \t\tconvert_to_long_ex(arg_pattern_zval);\n-\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\t\n+\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\n \t\tpat_buf[1] = '\\0';\n \n \t\targ_pattern = pat_buf;\n-\t\targ_pattern_len = 1;\t\n+\t\targ_pattern_len = 1;\n \t}\n \t/* create regex pattern buffer */\n \tre = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);\n@@ -934,7 +934,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\t\t\n+\n \t\t\tif (eval) {\n \t\t\t\tzval v;\n \t\t\t\t/* null terminate buffer */\n@@ -953,32 +953,31 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\teval_buf.len = 0;\n \t\t\t\tzval_dtor(&v);\n \t\t\t} else if (is_callable) {\n-\t\t\t\tzval *retval_ptr;\n+\t\t\t\tzval *retval_ptr = NULL;\n \t\t\t\tzval **args[1];\n \t\t\t\tzval *subpats;\n \t\t\t\tint i;\n-\t\t\t\t\n+\n \t\t\t\tMAKE_STD_ZVAL(subpats);\n \t\t\t\tarray_init(subpats);\n-\t\t\t\t\n+\n \t\t\t\tfor (i = 0; i < regs->num_regs; i++) {\n \t\t\t\t\tadd_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);\n-\t\t\t\t}\t\t\t\t\n-\t\t\t\t\n+\t\t\t\t}\n+\n \t\t\t\targs[0] = &subpats;\n \t\t\t\t/* null terminate buffer */\n \t\t\t\tsmart_str_0(&eval_buf);\n-\t\t\t\t\n+\n \t\t\t\targ_replace_fci.param_count = 1;\n \t\t\t\targ_replace_fci.params = args;\n \t\t\t\targ_replace_fci.retval_ptr_ptr = &retval_ptr;\n-\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {\n+\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {\n \t\t\t\t\tconvert_to_string_ex(&retval_ptr);\n \t\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));\n \t\t\t\t\teval_buf.len = 0;\n \t\t\t\t\tzval_ptr_dtor(&retval_ptr);\n \t\t\t\t} else {\n-\t\t\t\t\tefree(description);\n \t\t\t\t\tif (!EG(exception)) {\n \t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to call custom replacement function\"");\n \t\t\t\t\t}\n@@ -991,7 +990,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\tpos = (OnigUChar *)string + n;\n \t\t\t} else {\n \t\t\t\tif (pos < string_lim) {\n-\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1); \n+\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1);\n \t\t\t\t}\n \t\t\t\tpos++;\n \t\t\t}\n@@ -1013,7 +1012,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \tsmart_str_free(&eval_buf);\n \n \tif (err <= -2) {\n-\t\tsmart_str_free(&out_buf);\t\n+\t\tsmart_str_free(&out_buf);\n \t\tRETVAL_FALSE;\n \t} else {\n \t\tsmart_str_appendc(&out_buf, '\\0');\n@@ -1063,7 +1062,7 @@ PHP_FUNCTION(mb_split)\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""ss|l\"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {\n \t\tRETURN_FALSE;\n-\t} \n+\t}\n \n \tif (count > 0) {\n \t\tcount--;\n@@ -1317,7 +1316,7 @@ PHP_FUNCTION(mb_ereg_search_init)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \""z|ss\"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc > 1 && arg_pattern_len == 0) {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Empty pattern\"");\n \t\tRETURN_FALSE;\n@@ -1416,7 +1415,7 @@ PHP_FUNCTION(mb_ereg_search_setpos)\n /* }}} */\n \n /* {{{ php_mb_regex_set_options */\n-static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) \n+static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)\n {\n \tif (prev_options != NULL) {\n \t\t*prev_options = MBREX(regex_default_options);""}<_**next**_>{""sha"": ""abb290bf4d8706ea51ecefd7ea68da62b4194f5d"", ""filename"": ""ext/mbstring/tests/bug72402.phpt"", ""status"": ""added"", ""additions"": 17, ""deletions"": 0, ""changes"": 17, ""blob_url"": ""https://github.com/php/php-src/blob/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/tests/bug72402.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/tests/bug72402.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/mbstring/tests/bug72402.phpt?ref=5b597a2e5b28e2d5a52fc1be13f425f08f47cb62"", ""patch"": ""@@ -0,0 +1,17 @@\n+--TEST--\n+Bug #72402: _php_mb_regex_ereg_replace_exec - double free\n+--SKIPIF--\n+<?php extension_loaded('mbstring') or die('skip mbstring not available'); ?>\n+--FILE--\n+<?php\n+function throwit() {\n+\tthrow new Exception('it');\n+}\n+$var10 = \""throwit\"";\n+try {\n+\t$var14 = mb_ereg_replace_callback(\""\"", $var10, \""\"");\n+} catch(Exception $e) {}\n+?>\n+DONE\n+--EXPECT--\n+DONE\n\\ No newline at end of file""}","PHP_FUNCTION(mb_split)
{
	char *arg_pattern;
	int arg_pattern_len;
	php_mb_regex_t *re;
	OnigRegion *regs = NULL;
	char *string;
	OnigUChar *pos, *chunk_pos;
	int string_len;

	int n, err;
	long count = -1;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|l"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {
 		RETURN_FALSE;
	}
 
 	if (count > 0) {
 		count--;
	}

	/* create regex pattern buffer */
	if ((re = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, MBREX(regex_default_options), MBREX(current_mbctype), MBREX(regex_default_syntax) TSRMLS_CC)) == NULL) {
		RETURN_FALSE;
	}

	array_init(return_value);

	chunk_pos = pos = (OnigUChar *)string;
	err = 0;
	regs = onig_region_new();
	/* churn through str, generating array entries as we go */
	while (count != 0 && (pos - (OnigUChar *)string) < string_len) {
		int beg, end;
		err = onig_search(re, (OnigUChar *)string, (OnigUChar *)(string + string_len), pos, (OnigUChar *)(string + string_len), regs, 0);
		if (err < 0) {
			break;
		}
		beg = regs->beg[0], end = regs->end[0];
		/* add it to the array */
		if ((pos - (OnigUChar *)string) < end) {
			if (beg < string_len && beg >= (chunk_pos - (OnigUChar *)string)) {
				add_next_index_stringl(return_value, (char *)chunk_pos, ((OnigUChar *)(string + beg) - chunk_pos), 1);
				--count;
			} else {
				err = -2;
				break;
			}
			/* point at our new starting point */
			chunk_pos = pos = (OnigUChar *)string + end;
		} else {
			pos++;
		}
		onig_region_free(regs, 0);
	}

	onig_region_free(regs, 1);

	/* see if we encountered an error */
	if (err <= -2) {
		OnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];
		onig_error_code_to_str(err_str, err);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""mbregex search failure in mbsplit(): %s"", err_str);
		zval_dtor(return_value);
		RETURN_FALSE;
	}

	/* otherwise we just have one last element to add to the array */
	n = ((OnigUChar *)(string + string_len) - chunk_pos);
	if (n > 0) {
		add_next_index_stringl(return_value, (char *)chunk_pos, n, 1);
	} else {
		add_next_index_stringl(return_value, """", 0, 1);
	}
}
","PHP_FUNCTION(mb_split)
{
	char *arg_pattern;
	int arg_pattern_len;
	php_mb_regex_t *re;
	OnigRegion *regs = NULL;
	char *string;
	OnigUChar *pos, *chunk_pos;
	int string_len;

	int n, err;
	long count = -1;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|l"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {
 		RETURN_FALSE;
	} 
 
 	if (count > 0) {
 		count--;
	}

	/* create regex pattern buffer */
	if ((re = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, MBREX(regex_default_options), MBREX(current_mbctype), MBREX(regex_default_syntax) TSRMLS_CC)) == NULL) {
		RETURN_FALSE;
	}

	array_init(return_value);

	chunk_pos = pos = (OnigUChar *)string;
	err = 0;
	regs = onig_region_new();
	/* churn through str, generating array entries as we go */
	while (count != 0 && (pos - (OnigUChar *)string) < string_len) {
		int beg, end;
		err = onig_search(re, (OnigUChar *)string, (OnigUChar *)(string + string_len), pos, (OnigUChar *)(string + string_len), regs, 0);
		if (err < 0) {
			break;
		}
		beg = regs->beg[0], end = regs->end[0];
		/* add it to the array */
		if ((pos - (OnigUChar *)string) < end) {
			if (beg < string_len && beg >= (chunk_pos - (OnigUChar *)string)) {
				add_next_index_stringl(return_value, (char *)chunk_pos, ((OnigUChar *)(string + beg) - chunk_pos), 1);
				--count;
			} else {
				err = -2;
				break;
			}
			/* point at our new starting point */
			chunk_pos = pos = (OnigUChar *)string + end;
		} else {
			pos++;
		}
		onig_region_free(regs, 0);
	}

	onig_region_free(regs, 1);

	/* see if we encountered an error */
	if (err <= -2) {
		OnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];
		onig_error_code_to_str(err_str, err);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""mbregex search failure in mbsplit(): %s"", err_str);
		zval_dtor(return_value);
		RETURN_FALSE;
	}

	/* otherwise we just have one last element to add to the array */
	n = ((OnigUChar *)(string + string_len) - chunk_pos);
	if (n > 0) {
		add_next_index_stringl(return_value, (char *)chunk_pos, n, 1);
	} else {
		add_next_index_stringl(return_value, """", 0, 1);
	}
}
",C,"	}
","	} 
",,"@@ -32,7 +32,7 @@
 #include ""ext/standard/info.h""
 #include ""php_mbregex.h""
 #include ""mbstring.h""
- 
+
 #include ""php_onig_compat.h"" /* must come prior to the oniguruma header */
 #include <oniguruma.h>
 #undef UChar
@@ -55,7 +55,7 @@ struct _zend_mb_regex_globals {
 #define MBREX(g) (MBSTRG(mb_regex_globals)->g)
 
 /* {{{ static void php_mb_regex_free_cache() */
-static void php_mb_regex_free_cache(php_mb_regex_t **pre) 
+static void php_mb_regex_free_cache(php_mb_regex_t **pre)
 {
 	onig_free(*pre);
 }
@@ -78,7 +78,7 @@ static int _php_mb_regex_globals_ctor(zend_mb_regex_globals *pglobals TSRMLS_DC)
 /* }}} */
 
 /* {{{ _php_mb_regex_globals_dtor */
-static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) 
+static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)
 {
 	zend_hash_destroy(&pglobals->ht_rc);
 }
@@ -466,7 +466,7 @@ static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patl
 		retval = *rc;
 	}
 out:
-	return retval; 
+	return retval;
 }
 /* }}} */
 
@@ -483,15 +483,15 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 			--len_left;
 			*(p++) = 'i';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	if ((option & ONIG_OPTION_EXTEND) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'x';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	if ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==
@@ -500,37 +500,37 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 			--len_left;
 			*(p++) = 'p';
 		}
-		++len_req;	
+		++len_req;
 	} else {
 		if ((option & ONIG_OPTION_MULTILINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 'm';
 			}
-			++len_req;	
+			++len_req;
 		}
 
 		if ((option & ONIG_OPTION_SINGLELINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 's';
 			}
-			++len_req;	
+			++len_req;
 		}
-	}	
+	}
 	if ((option & ONIG_OPTION_FIND_LONGEST) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'l';
 		}
-		++len_req;	
+		++len_req;
 	}
 	if ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'n';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	c = 0;
@@ -566,7 +566,7 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 		--len_left;
 		*(p++) = '\0';
 	}
-	++len_req;	
+	++len_req;
 	if (len < len_req) {
 		return len_req;
 	}
@@ -577,11 +577,11 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 
 /* {{{ _php_mb_regex_init_options */
 static void
-_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) 
+_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)
 {
 	int n;
 	char c;
-	int optm = 0; 
+	int optm = 0;
 
 	*syntax = ONIG_SYNTAX_RUBY;
 
@@ -636,13 +636,13 @@ _php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, O
 					*syntax = ONIG_SYNTAX_POSIX_EXTENDED;
 					break;
 				case 'e':
-					if (eval != NULL) *eval = 1; 
+					if (eval != NULL) *eval = 1;
 					break;
 				default:
 					break;
 			}
 		}
-		if (option != NULL) *option|=optm; 
+		if (option != NULL) *option|=optm;
 	}
 }
 /* }}} */
@@ -860,11 +860,11 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 	} else {
 		/* FIXME: this code is not multibyte aware! */
 		convert_to_long_ex(arg_pattern_zval);
-		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);	
+		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);
 		pat_buf[1] = '\0';
 
 		arg_pattern = pat_buf;
-		arg_pattern_len = 1;	
+		arg_pattern_len = 1;
 	}
 	/* create regex pattern buffer */
 	re = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);
@@ -934,7 +934,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 					}
 				}
 			}
-				
+
 			if (eval) {
 				zval v;
 				/* null terminate buffer */
@@ -953,32 +953,31 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 				eval_buf.len = 0;
 				zval_dtor(&v);
 			} else if (is_callable) {
-				zval *retval_ptr;
+				zval *retval_ptr = NULL;
 				zval **args[1];
 				zval *subpats;
 				int i;
-				
+
 				MAKE_STD_ZVAL(subpats);
 				array_init(subpats);
-				
+
 				for (i = 0; i < regs->num_regs; i++) {
 					add_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);
-				}				
-				
+				}
+
 				args[0] = &subpats;
 				/* null terminate buffer */
 				smart_str_0(&eval_buf);
-				
+
 				arg_replace_fci.param_count = 1;
 				arg_replace_fci.params = args;
 				arg_replace_fci.retval_ptr_ptr = &retval_ptr;
-				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {
+				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {
 					convert_to_string_ex(&retval_ptr);
 					smart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));
 					eval_buf.len = 0;
 					zval_ptr_dtor(&retval_ptr);
 				} else {
-					efree(description);
 					if (!EG(exception)) {
 						php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call custom replacement function"");
 					}
@@ -991,7 +990,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 				pos = (OnigUChar *)string + n;
 			} else {
 				if (pos < string_lim) {
-					smart_str_appendl(&out_buf, pos, 1); 
+					smart_str_appendl(&out_buf, pos, 1);
 				}
 				pos++;
 			}
@@ -1013,7 +1012,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 	smart_str_free(&eval_buf);
 
 	if (err <= -2) {
-		smart_str_free(&out_buf);	
+		smart_str_free(&out_buf);
 		RETVAL_FALSE;
 	} else {
 		smart_str_appendc(&out_buf, '\0');
@@ -1063,7 +1062,7 @@ PHP_FUNCTION(mb_split)
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|l"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {
 		RETURN_FALSE;
-	} 
+	}
 
 	if (count > 0) {
 		count--;
@@ -1317,7 +1316,7 @@ PHP_FUNCTION(mb_ereg_search_init)
 	if (zend_parse_parameters(argc TSRMLS_CC, ""z|ss"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {
 		return;
 	}
-	
+
 	if (argc > 1 && arg_pattern_len == 0) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty pattern"");
 		RETURN_FALSE;
@@ -1416,7 +1415,7 @@ PHP_FUNCTION(mb_ereg_search_setpos)
 /* }}} */
 
 /* {{{ php_mb_regex_set_options */
-static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) 
+static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)
 {
 	if (prev_options != NULL) {
 		*prev_options = MBREX(regex_default_options);",php-src,5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,e9ac8954be9f7d988189df44578d759ffdea3512,1,"PHP_FUNCTION(mb_split)
{
	char *arg_pattern;
	int arg_pattern_len;
	php_mb_regex_t *re;
	OnigRegion *regs = NULL;
	char *string;
	OnigUChar *pos, *chunk_pos;
	int string_len;

	int n, err;
	long count = -1;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|l"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {
 		RETURN_FALSE;
//flaw_line_below:
	} 
//fix_flaw_line_below:
//	}
 
 	if (count > 0) {
 		count--;
	}

	/* create regex pattern buffer */
	if ((re = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, MBREX(regex_default_options), MBREX(current_mbctype), MBREX(regex_default_syntax) TSRMLS_CC)) == NULL) {
		RETURN_FALSE;
	}

	array_init(return_value);

	chunk_pos = pos = (OnigUChar *)string;
	err = 0;
	regs = onig_region_new();
	/* churn through str, generating array entries as we go */
	while (count != 0 && (pos - (OnigUChar *)string) < string_len) {
		int beg, end;
		err = onig_search(re, (OnigUChar *)string, (OnigUChar *)(string + string_len), pos, (OnigUChar *)(string + string_len), regs, 0);
		if (err < 0) {
			break;
		}
		beg = regs->beg[0], end = regs->end[0];
		/* add it to the array */
		if ((pos - (OnigUChar *)string) < end) {
			if (beg < string_len && beg >= (chunk_pos - (OnigUChar *)string)) {
				add_next_index_stringl(return_value, (char *)chunk_pos, ((OnigUChar *)(string + beg) - chunk_pos), 1);
				--count;
			} else {
				err = -2;
				break;
			}
			/* point at our new starting point */
			chunk_pos = pos = (OnigUChar *)string + end;
		} else {
			pos++;
		}
		onig_region_free(regs, 0);
	}

	onig_region_free(regs, 1);

	/* see if we encountered an error */
	if (err <= -2) {
		OnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];
		onig_error_code_to_str(err_str, err);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""mbregex search failure in mbsplit(): %s"", err_str);
		zval_dtor(return_value);
		RETURN_FALSE;
	}

	/* otherwise we just have one last element to add to the array */
	n = ((OnigUChar *)(string + string_len) - chunk_pos);
	if (n > 0) {
		add_next_index_stringl(return_value, (char *)chunk_pos, n, 1);
	} else {
		add_next_index_stringl(return_value, """", 0, 1);
	}
}
"
2552,180288,,Remote,Not required,Partial,CVE-2016-5768,https://www.cvedetails.com/cve/CVE-2016-5768/,CWE-415,Low,Partial,Partial,,2016-08-07,7.5,"Double free vulnerability in the _php_mb_regex_ereg_replace_exec function in php_mbregex.c in the mbstring extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to execute arbitrary code or cause a denial of service (application crash) by leveraging a callback exception.",2018-01-04,DoS Exec Code ,1,https://github.com/php/php-src/commit/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,Fix bug #72402: _php_mb_regex_ereg_replace_exec - double free,0,ext/mbstring/php_mbregex.c,"{""sha"": ""6cdee23c3e5999b467c4a206bf3f4827ebe121f6"", ""filename"": ""ext/mbstring/php_mbregex.c"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 33, ""changes"": 65, ""blob_url"": ""https://github.com/php/php-src/blob/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/php_mbregex.c"", ""raw_url"": ""https://github.com/php/php-src/raw/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/php_mbregex.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/mbstring/php_mbregex.c?ref=5b597a2e5b28e2d5a52fc1be13f425f08f47cb62"", ""patch"": ""@@ -32,7 +32,7 @@\n #include \""ext/standard/info.h\""\n #include \""php_mbregex.h\""\n #include \""mbstring.h\""\n- \n+\n #include \""php_onig_compat.h\"" /* must come prior to the oniguruma header */\n #include <oniguruma.h>\n #undef UChar\n@@ -55,7 +55,7 @@ struct _zend_mb_regex_globals {\n #define MBREX(g) (MBSTRG(mb_regex_globals)->g)\n \n /* {{{ static void php_mb_regex_free_cache() */\n-static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n+static void php_mb_regex_free_cache(php_mb_regex_t **pre)\n {\n \tonig_free(*pre);\n }\n@@ -78,7 +78,7 @@ static int _php_mb_regex_globals_ctor(zend_mb_regex_globals *pglobals TSRMLS_DC)\n /* }}} */\n \n /* {{{ _php_mb_regex_globals_dtor */\n-static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) \n+static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)\n {\n \tzend_hash_destroy(&pglobals->ht_rc);\n }\n@@ -466,7 +466,7 @@ static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patl\n \t\tretval = *rc;\n \t}\n out:\n-\treturn retval; \n+\treturn retval;\n }\n /* }}} */\n \n@@ -483,15 +483,15 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t\t--len_left;\n \t\t\t*(p++) = 'i';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tif ((option & ONIG_OPTION_EXTEND) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'x';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tif ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==\n@@ -500,37 +500,37 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t\t--len_left;\n \t\t\t*(p++) = 'p';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t} else {\n \t\tif ((option & ONIG_OPTION_MULTILINE) != 0) {\n \t\t\tif (len_left > 0) {\n \t\t\t\t--len_left;\n \t\t\t\t*(p++) = 'm';\n \t\t\t}\n-\t\t\t++len_req;\t\n+\t\t\t++len_req;\n \t\t}\n \n \t\tif ((option & ONIG_OPTION_SINGLELINE) != 0) {\n \t\t\tif (len_left > 0) {\n \t\t\t\t--len_left;\n \t\t\t\t*(p++) = 's';\n \t\t\t}\n-\t\t\t++len_req;\t\n+\t\t\t++len_req;\n \t\t}\n-\t}\t\n+\t}\n \tif ((option & ONIG_OPTION_FIND_LONGEST) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'l';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \tif ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'n';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tc = 0;\n@@ -566,7 +566,7 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t--len_left;\n \t\t*(p++) = '\\0';\n \t}\n-\t++len_req;\t\n+\t++len_req;\n \tif (len < len_req) {\n \t\treturn len_req;\n \t}\n@@ -577,11 +577,11 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \n /* {{{ _php_mb_regex_init_options */\n static void\n-_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) \n+_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)\n {\n \tint n;\n \tchar c;\n-\tint optm = 0; \n+\tint optm = 0;\n \n \t*syntax = ONIG_SYNTAX_RUBY;\n \n@@ -636,13 +636,13 @@ _php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, O\n \t\t\t\t\t*syntax = ONIG_SYNTAX_POSIX_EXTENDED;\n \t\t\t\t\tbreak;\n \t\t\t\tcase 'e':\n-\t\t\t\t\tif (eval != NULL) *eval = 1; \n+\t\t\t\t\tif (eval != NULL) *eval = 1;\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n-\t\tif (option != NULL) *option|=optm; \n+\t\tif (option != NULL) *option|=optm;\n \t}\n }\n /* }}} */\n@@ -860,11 +860,11 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t} else {\n \t\t/* FIXME: this code is not multibyte aware! */\n \t\tconvert_to_long_ex(arg_pattern_zval);\n-\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\t\n+\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\n \t\tpat_buf[1] = '\\0';\n \n \t\targ_pattern = pat_buf;\n-\t\targ_pattern_len = 1;\t\n+\t\targ_pattern_len = 1;\n \t}\n \t/* create regex pattern buffer */\n \tre = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);\n@@ -934,7 +934,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\t\t\n+\n \t\t\tif (eval) {\n \t\t\t\tzval v;\n \t\t\t\t/* null terminate buffer */\n@@ -953,32 +953,31 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\teval_buf.len = 0;\n \t\t\t\tzval_dtor(&v);\n \t\t\t} else if (is_callable) {\n-\t\t\t\tzval *retval_ptr;\n+\t\t\t\tzval *retval_ptr = NULL;\n \t\t\t\tzval **args[1];\n \t\t\t\tzval *subpats;\n \t\t\t\tint i;\n-\t\t\t\t\n+\n \t\t\t\tMAKE_STD_ZVAL(subpats);\n \t\t\t\tarray_init(subpats);\n-\t\t\t\t\n+\n \t\t\t\tfor (i = 0; i < regs->num_regs; i++) {\n \t\t\t\t\tadd_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);\n-\t\t\t\t}\t\t\t\t\n-\t\t\t\t\n+\t\t\t\t}\n+\n \t\t\t\targs[0] = &subpats;\n \t\t\t\t/* null terminate buffer */\n \t\t\t\tsmart_str_0(&eval_buf);\n-\t\t\t\t\n+\n \t\t\t\targ_replace_fci.param_count = 1;\n \t\t\t\targ_replace_fci.params = args;\n \t\t\t\targ_replace_fci.retval_ptr_ptr = &retval_ptr;\n-\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {\n+\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {\n \t\t\t\t\tconvert_to_string_ex(&retval_ptr);\n \t\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));\n \t\t\t\t\teval_buf.len = 0;\n \t\t\t\t\tzval_ptr_dtor(&retval_ptr);\n \t\t\t\t} else {\n-\t\t\t\t\tefree(description);\n \t\t\t\t\tif (!EG(exception)) {\n \t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to call custom replacement function\"");\n \t\t\t\t\t}\n@@ -991,7 +990,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\tpos = (OnigUChar *)string + n;\n \t\t\t} else {\n \t\t\t\tif (pos < string_lim) {\n-\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1); \n+\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1);\n \t\t\t\t}\n \t\t\t\tpos++;\n \t\t\t}\n@@ -1013,7 +1012,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \tsmart_str_free(&eval_buf);\n \n \tif (err <= -2) {\n-\t\tsmart_str_free(&out_buf);\t\n+\t\tsmart_str_free(&out_buf);\n \t\tRETVAL_FALSE;\n \t} else {\n \t\tsmart_str_appendc(&out_buf, '\\0');\n@@ -1063,7 +1062,7 @@ PHP_FUNCTION(mb_split)\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""ss|l\"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {\n \t\tRETURN_FALSE;\n-\t} \n+\t}\n \n \tif (count > 0) {\n \t\tcount--;\n@@ -1317,7 +1316,7 @@ PHP_FUNCTION(mb_ereg_search_init)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \""z|ss\"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc > 1 && arg_pattern_len == 0) {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Empty pattern\"");\n \t\tRETURN_FALSE;\n@@ -1416,7 +1415,7 @@ PHP_FUNCTION(mb_ereg_search_setpos)\n /* }}} */\n \n /* {{{ php_mb_regex_set_options */\n-static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) \n+static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)\n {\n \tif (prev_options != NULL) {\n \t\t*prev_options = MBREX(regex_default_options);""}<_**next**_>{""sha"": ""abb290bf4d8706ea51ecefd7ea68da62b4194f5d"", ""filename"": ""ext/mbstring/tests/bug72402.phpt"", ""status"": ""added"", ""additions"": 17, ""deletions"": 0, ""changes"": 17, ""blob_url"": ""https://github.com/php/php-src/blob/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/tests/bug72402.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/tests/bug72402.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/mbstring/tests/bug72402.phpt?ref=5b597a2e5b28e2d5a52fc1be13f425f08f47cb62"", ""patch"": ""@@ -0,0 +1,17 @@\n+--TEST--\n+Bug #72402: _php_mb_regex_ereg_replace_exec - double free\n+--SKIPIF--\n+<?php extension_loaded('mbstring') or die('skip mbstring not available'); ?>\n+--FILE--\n+<?php\n+function throwit() {\n+\tthrow new Exception('it');\n+}\n+$var10 = \""throwit\"";\n+try {\n+\t$var14 = mb_ereg_replace_callback(\""\"", $var10, \""\"");\n+} catch(Exception $e) {}\n+?>\n+DONE\n+--EXPECT--\n+DONE\n\\ No newline at end of file""}","PHP_FUNCTION(mb_ereg_search_init)
{
	size_t argc = ZEND_NUM_ARGS();
	zval *arg_str;
	char *arg_pattern = NULL, *arg_options = NULL;
	int arg_pattern_len = 0, arg_options_len = 0;
	OnigSyntaxType *syntax = NULL;
	OnigOptionType option;

 	if (zend_parse_parameters(argc TSRMLS_CC, ""z|ss"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {
 		return;
 	}

 	if (argc > 1 && arg_pattern_len == 0) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty pattern"");
 		RETURN_FALSE;
	}

	option = MBREX(regex_default_options);
	syntax = MBREX(regex_default_syntax);

	if (argc == 3) {
		option = 0;
		_php_mb_regex_init_options(arg_options, arg_options_len, &option, &syntax, NULL);
	}

	if (argc > 1) {
		/* create regex pattern buffer */
		if ((MBREX(search_re) = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, option, MBREX(current_mbctype), syntax TSRMLS_CC)) == NULL) {
			RETURN_FALSE;
		}
	}

	if (MBREX(search_str) != NULL) {
		zval_ptr_dtor(&MBREX(search_str));
		MBREX(search_str) = (zval *)NULL;
	}

	MBREX(search_str) = arg_str;
	Z_ADDREF_P(MBREX(search_str));
	SEPARATE_ZVAL_IF_NOT_REF(&MBREX(search_str));

	MBREX(search_pos) = 0;

	if (MBREX(search_regs) != NULL) {
		onig_region_free(MBREX(search_regs), 1);
		MBREX(search_regs) = (OnigRegion *) NULL;
	}

	RETURN_TRUE;
}
","PHP_FUNCTION(mb_ereg_search_init)
{
	size_t argc = ZEND_NUM_ARGS();
	zval *arg_str;
	char *arg_pattern = NULL, *arg_options = NULL;
	int arg_pattern_len = 0, arg_options_len = 0;
	OnigSyntaxType *syntax = NULL;
	OnigOptionType option;

 	if (zend_parse_parameters(argc TSRMLS_CC, ""z|ss"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {
 		return;
 	}
 	if (argc > 1 && arg_pattern_len == 0) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty pattern"");
 		RETURN_FALSE;
	}

	option = MBREX(regex_default_options);
	syntax = MBREX(regex_default_syntax);

	if (argc == 3) {
		option = 0;
		_php_mb_regex_init_options(arg_options, arg_options_len, &option, &syntax, NULL);
	}

	if (argc > 1) {
		/* create regex pattern buffer */
		if ((MBREX(search_re) = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, option, MBREX(current_mbctype), syntax TSRMLS_CC)) == NULL) {
			RETURN_FALSE;
		}
	}

	if (MBREX(search_str) != NULL) {
		zval_ptr_dtor(&MBREX(search_str));
		MBREX(search_str) = (zval *)NULL;
	}

	MBREX(search_str) = arg_str;
	Z_ADDREF_P(MBREX(search_str));
	SEPARATE_ZVAL_IF_NOT_REF(&MBREX(search_str));

	MBREX(search_pos) = 0;

	if (MBREX(search_regs) != NULL) {
		onig_region_free(MBREX(search_regs), 1);
		MBREX(search_regs) = (OnigRegion *) NULL;
	}

	RETURN_TRUE;
}
",C,"
",,,"@@ -32,7 +32,7 @@
 #include ""ext/standard/info.h""
 #include ""php_mbregex.h""
 #include ""mbstring.h""
- 
+
 #include ""php_onig_compat.h"" /* must come prior to the oniguruma header */
 #include <oniguruma.h>
 #undef UChar
@@ -55,7 +55,7 @@ struct _zend_mb_regex_globals {
 #define MBREX(g) (MBSTRG(mb_regex_globals)->g)
 
 /* {{{ static void php_mb_regex_free_cache() */
-static void php_mb_regex_free_cache(php_mb_regex_t **pre) 
+static void php_mb_regex_free_cache(php_mb_regex_t **pre)
 {
 	onig_free(*pre);
 }
@@ -78,7 +78,7 @@ static int _php_mb_regex_globals_ctor(zend_mb_regex_globals *pglobals TSRMLS_DC)
 /* }}} */
 
 /* {{{ _php_mb_regex_globals_dtor */
-static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) 
+static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)
 {
 	zend_hash_destroy(&pglobals->ht_rc);
 }
@@ -466,7 +466,7 @@ static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patl
 		retval = *rc;
 	}
 out:
-	return retval; 
+	return retval;
 }
 /* }}} */
 
@@ -483,15 +483,15 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 			--len_left;
 			*(p++) = 'i';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	if ((option & ONIG_OPTION_EXTEND) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'x';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	if ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==
@@ -500,37 +500,37 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 			--len_left;
 			*(p++) = 'p';
 		}
-		++len_req;	
+		++len_req;
 	} else {
 		if ((option & ONIG_OPTION_MULTILINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 'm';
 			}
-			++len_req;	
+			++len_req;
 		}
 
 		if ((option & ONIG_OPTION_SINGLELINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 's';
 			}
-			++len_req;	
+			++len_req;
 		}
-	}	
+	}
 	if ((option & ONIG_OPTION_FIND_LONGEST) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'l';
 		}
-		++len_req;	
+		++len_req;
 	}
 	if ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'n';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	c = 0;
@@ -566,7 +566,7 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 		--len_left;
 		*(p++) = '\0';
 	}
-	++len_req;	
+	++len_req;
 	if (len < len_req) {
 		return len_req;
 	}
@@ -577,11 +577,11 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 
 /* {{{ _php_mb_regex_init_options */
 static void
-_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) 
+_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)
 {
 	int n;
 	char c;
-	int optm = 0; 
+	int optm = 0;
 
 	*syntax = ONIG_SYNTAX_RUBY;
 
@@ -636,13 +636,13 @@ _php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, O
 					*syntax = ONIG_SYNTAX_POSIX_EXTENDED;
 					break;
 				case 'e':
-					if (eval != NULL) *eval = 1; 
+					if (eval != NULL) *eval = 1;
 					break;
 				default:
 					break;
 			}
 		}
-		if (option != NULL) *option|=optm; 
+		if (option != NULL) *option|=optm;
 	}
 }
 /* }}} */
@@ -860,11 +860,11 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 	} else {
 		/* FIXME: this code is not multibyte aware! */
 		convert_to_long_ex(arg_pattern_zval);
-		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);	
+		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);
 		pat_buf[1] = '\0';
 
 		arg_pattern = pat_buf;
-		arg_pattern_len = 1;	
+		arg_pattern_len = 1;
 	}
 	/* create regex pattern buffer */
 	re = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);
@@ -934,7 +934,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 					}
 				}
 			}
-				
+
 			if (eval) {
 				zval v;
 				/* null terminate buffer */
@@ -953,32 +953,31 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 				eval_buf.len = 0;
 				zval_dtor(&v);
 			} else if (is_callable) {
-				zval *retval_ptr;
+				zval *retval_ptr = NULL;
 				zval **args[1];
 				zval *subpats;
 				int i;
-				
+
 				MAKE_STD_ZVAL(subpats);
 				array_init(subpats);
-				
+
 				for (i = 0; i < regs->num_regs; i++) {
 					add_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);
-				}				
-				
+				}
+
 				args[0] = &subpats;
 				/* null terminate buffer */
 				smart_str_0(&eval_buf);
-				
+
 				arg_replace_fci.param_count = 1;
 				arg_replace_fci.params = args;
 				arg_replace_fci.retval_ptr_ptr = &retval_ptr;
-				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {
+				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {
 					convert_to_string_ex(&retval_ptr);
 					smart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));
 					eval_buf.len = 0;
 					zval_ptr_dtor(&retval_ptr);
 				} else {
-					efree(description);
 					if (!EG(exception)) {
 						php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call custom replacement function"");
 					}
@@ -991,7 +990,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 				pos = (OnigUChar *)string + n;
 			} else {
 				if (pos < string_lim) {
-					smart_str_appendl(&out_buf, pos, 1); 
+					smart_str_appendl(&out_buf, pos, 1);
 				}
 				pos++;
 			}
@@ -1013,7 +1012,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 	smart_str_free(&eval_buf);
 
 	if (err <= -2) {
-		smart_str_free(&out_buf);	
+		smart_str_free(&out_buf);
 		RETVAL_FALSE;
 	} else {
 		smart_str_appendc(&out_buf, '\0');
@@ -1063,7 +1062,7 @@ PHP_FUNCTION(mb_split)
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|l"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {
 		RETURN_FALSE;
-	} 
+	}
 
 	if (count > 0) {
 		count--;
@@ -1317,7 +1316,7 @@ PHP_FUNCTION(mb_ereg_search_init)
 	if (zend_parse_parameters(argc TSRMLS_CC, ""z|ss"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {
 		return;
 	}
-	
+
 	if (argc > 1 && arg_pattern_len == 0) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty pattern"");
 		RETURN_FALSE;
@@ -1416,7 +1415,7 @@ PHP_FUNCTION(mb_ereg_search_setpos)
 /* }}} */
 
 /* {{{ php_mb_regex_set_options */
-static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) 
+static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)
 {
 	if (prev_options != NULL) {
 		*prev_options = MBREX(regex_default_options);",php-src,5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,e9ac8954be9f7d988189df44578d759ffdea3512,1,"PHP_FUNCTION(mb_ereg_search_init)
{
	size_t argc = ZEND_NUM_ARGS();
	zval *arg_str;
	char *arg_pattern = NULL, *arg_options = NULL;
	int arg_pattern_len = 0, arg_options_len = 0;
	OnigSyntaxType *syntax = NULL;
	OnigOptionType option;

 	if (zend_parse_parameters(argc TSRMLS_CC, ""z|ss"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {
 		return;
 	}
//flaw_line_below:
	
//fix_flaw_line_below:
//
 	if (argc > 1 && arg_pattern_len == 0) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty pattern"");
 		RETURN_FALSE;
	}

	option = MBREX(regex_default_options);
	syntax = MBREX(regex_default_syntax);

	if (argc == 3) {
		option = 0;
		_php_mb_regex_init_options(arg_options, arg_options_len, &option, &syntax, NULL);
	}

	if (argc > 1) {
		/* create regex pattern buffer */
		if ((MBREX(search_re) = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, option, MBREX(current_mbctype), syntax TSRMLS_CC)) == NULL) {
			RETURN_FALSE;
		}
	}

	if (MBREX(search_str) != NULL) {
		zval_ptr_dtor(&MBREX(search_str));
		MBREX(search_str) = (zval *)NULL;
	}

	MBREX(search_str) = arg_str;
	Z_ADDREF_P(MBREX(search_str));
	SEPARATE_ZVAL_IF_NOT_REF(&MBREX(search_str));

	MBREX(search_pos) = 0;

	if (MBREX(search_regs) != NULL) {
		onig_region_free(MBREX(search_regs), 1);
		MBREX(search_regs) = (OnigRegion *) NULL;
	}

	RETURN_TRUE;
}
"
2553,180289,,Remote,Not required,Partial,CVE-2016-5768,https://www.cvedetails.com/cve/CVE-2016-5768/,CWE-415,Low,Partial,Partial,,2016-08-07,7.5,"Double free vulnerability in the _php_mb_regex_ereg_replace_exec function in php_mbregex.c in the mbstring extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to execute arbitrary code or cause a denial of service (application crash) by leveraging a callback exception.",2018-01-04,DoS Exec Code ,12,https://github.com/php/php-src/commit/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,Fix bug #72402: _php_mb_regex_ereg_replace_exec - double free,8,ext/mbstring/php_mbregex.c,"{""sha"": ""6cdee23c3e5999b467c4a206bf3f4827ebe121f6"", ""filename"": ""ext/mbstring/php_mbregex.c"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 33, ""changes"": 65, ""blob_url"": ""https://github.com/php/php-src/blob/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/php_mbregex.c"", ""raw_url"": ""https://github.com/php/php-src/raw/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/php_mbregex.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/mbstring/php_mbregex.c?ref=5b597a2e5b28e2d5a52fc1be13f425f08f47cb62"", ""patch"": ""@@ -32,7 +32,7 @@\n #include \""ext/standard/info.h\""\n #include \""php_mbregex.h\""\n #include \""mbstring.h\""\n- \n+\n #include \""php_onig_compat.h\"" /* must come prior to the oniguruma header */\n #include <oniguruma.h>\n #undef UChar\n@@ -55,7 +55,7 @@ struct _zend_mb_regex_globals {\n #define MBREX(g) (MBSTRG(mb_regex_globals)->g)\n \n /* {{{ static void php_mb_regex_free_cache() */\n-static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n+static void php_mb_regex_free_cache(php_mb_regex_t **pre)\n {\n \tonig_free(*pre);\n }\n@@ -78,7 +78,7 @@ static int _php_mb_regex_globals_ctor(zend_mb_regex_globals *pglobals TSRMLS_DC)\n /* }}} */\n \n /* {{{ _php_mb_regex_globals_dtor */\n-static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) \n+static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)\n {\n \tzend_hash_destroy(&pglobals->ht_rc);\n }\n@@ -466,7 +466,7 @@ static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patl\n \t\tretval = *rc;\n \t}\n out:\n-\treturn retval; \n+\treturn retval;\n }\n /* }}} */\n \n@@ -483,15 +483,15 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t\t--len_left;\n \t\t\t*(p++) = 'i';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tif ((option & ONIG_OPTION_EXTEND) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'x';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tif ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==\n@@ -500,37 +500,37 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t\t--len_left;\n \t\t\t*(p++) = 'p';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t} else {\n \t\tif ((option & ONIG_OPTION_MULTILINE) != 0) {\n \t\t\tif (len_left > 0) {\n \t\t\t\t--len_left;\n \t\t\t\t*(p++) = 'm';\n \t\t\t}\n-\t\t\t++len_req;\t\n+\t\t\t++len_req;\n \t\t}\n \n \t\tif ((option & ONIG_OPTION_SINGLELINE) != 0) {\n \t\t\tif (len_left > 0) {\n \t\t\t\t--len_left;\n \t\t\t\t*(p++) = 's';\n \t\t\t}\n-\t\t\t++len_req;\t\n+\t\t\t++len_req;\n \t\t}\n-\t}\t\n+\t}\n \tif ((option & ONIG_OPTION_FIND_LONGEST) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'l';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \tif ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'n';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tc = 0;\n@@ -566,7 +566,7 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t--len_left;\n \t\t*(p++) = '\\0';\n \t}\n-\t++len_req;\t\n+\t++len_req;\n \tif (len < len_req) {\n \t\treturn len_req;\n \t}\n@@ -577,11 +577,11 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \n /* {{{ _php_mb_regex_init_options */\n static void\n-_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) \n+_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)\n {\n \tint n;\n \tchar c;\n-\tint optm = 0; \n+\tint optm = 0;\n \n \t*syntax = ONIG_SYNTAX_RUBY;\n \n@@ -636,13 +636,13 @@ _php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, O\n \t\t\t\t\t*syntax = ONIG_SYNTAX_POSIX_EXTENDED;\n \t\t\t\t\tbreak;\n \t\t\t\tcase 'e':\n-\t\t\t\t\tif (eval != NULL) *eval = 1; \n+\t\t\t\t\tif (eval != NULL) *eval = 1;\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n-\t\tif (option != NULL) *option|=optm; \n+\t\tif (option != NULL) *option|=optm;\n \t}\n }\n /* }}} */\n@@ -860,11 +860,11 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t} else {\n \t\t/* FIXME: this code is not multibyte aware! */\n \t\tconvert_to_long_ex(arg_pattern_zval);\n-\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\t\n+\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\n \t\tpat_buf[1] = '\\0';\n \n \t\targ_pattern = pat_buf;\n-\t\targ_pattern_len = 1;\t\n+\t\targ_pattern_len = 1;\n \t}\n \t/* create regex pattern buffer */\n \tre = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);\n@@ -934,7 +934,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\t\t\n+\n \t\t\tif (eval) {\n \t\t\t\tzval v;\n \t\t\t\t/* null terminate buffer */\n@@ -953,32 +953,31 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\teval_buf.len = 0;\n \t\t\t\tzval_dtor(&v);\n \t\t\t} else if (is_callable) {\n-\t\t\t\tzval *retval_ptr;\n+\t\t\t\tzval *retval_ptr = NULL;\n \t\t\t\tzval **args[1];\n \t\t\t\tzval *subpats;\n \t\t\t\tint i;\n-\t\t\t\t\n+\n \t\t\t\tMAKE_STD_ZVAL(subpats);\n \t\t\t\tarray_init(subpats);\n-\t\t\t\t\n+\n \t\t\t\tfor (i = 0; i < regs->num_regs; i++) {\n \t\t\t\t\tadd_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);\n-\t\t\t\t}\t\t\t\t\n-\t\t\t\t\n+\t\t\t\t}\n+\n \t\t\t\targs[0] = &subpats;\n \t\t\t\t/* null terminate buffer */\n \t\t\t\tsmart_str_0(&eval_buf);\n-\t\t\t\t\n+\n \t\t\t\targ_replace_fci.param_count = 1;\n \t\t\t\targ_replace_fci.params = args;\n \t\t\t\targ_replace_fci.retval_ptr_ptr = &retval_ptr;\n-\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {\n+\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {\n \t\t\t\t\tconvert_to_string_ex(&retval_ptr);\n \t\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));\n \t\t\t\t\teval_buf.len = 0;\n \t\t\t\t\tzval_ptr_dtor(&retval_ptr);\n \t\t\t\t} else {\n-\t\t\t\t\tefree(description);\n \t\t\t\t\tif (!EG(exception)) {\n \t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to call custom replacement function\"");\n \t\t\t\t\t}\n@@ -991,7 +990,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\tpos = (OnigUChar *)string + n;\n \t\t\t} else {\n \t\t\t\tif (pos < string_lim) {\n-\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1); \n+\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1);\n \t\t\t\t}\n \t\t\t\tpos++;\n \t\t\t}\n@@ -1013,7 +1012,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \tsmart_str_free(&eval_buf);\n \n \tif (err <= -2) {\n-\t\tsmart_str_free(&out_buf);\t\n+\t\tsmart_str_free(&out_buf);\n \t\tRETVAL_FALSE;\n \t} else {\n \t\tsmart_str_appendc(&out_buf, '\\0');\n@@ -1063,7 +1062,7 @@ PHP_FUNCTION(mb_split)\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""ss|l\"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {\n \t\tRETURN_FALSE;\n-\t} \n+\t}\n \n \tif (count > 0) {\n \t\tcount--;\n@@ -1317,7 +1316,7 @@ PHP_FUNCTION(mb_ereg_search_init)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \""z|ss\"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc > 1 && arg_pattern_len == 0) {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Empty pattern\"");\n \t\tRETURN_FALSE;\n@@ -1416,7 +1415,7 @@ PHP_FUNCTION(mb_ereg_search_setpos)\n /* }}} */\n \n /* {{{ php_mb_regex_set_options */\n-static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) \n+static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)\n {\n \tif (prev_options != NULL) {\n \t\t*prev_options = MBREX(regex_default_options);""}<_**next**_>{""sha"": ""abb290bf4d8706ea51ecefd7ea68da62b4194f5d"", ""filename"": ""ext/mbstring/tests/bug72402.phpt"", ""status"": ""added"", ""additions"": 17, ""deletions"": 0, ""changes"": 17, ""blob_url"": ""https://github.com/php/php-src/blob/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/tests/bug72402.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/tests/bug72402.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/mbstring/tests/bug72402.phpt?ref=5b597a2e5b28e2d5a52fc1be13f425f08f47cb62"", ""patch"": ""@@ -0,0 +1,17 @@\n+--TEST--\n+Bug #72402: _php_mb_regex_ereg_replace_exec - double free\n+--SKIPIF--\n+<?php extension_loaded('mbstring') or die('skip mbstring not available'); ?>\n+--FILE--\n+<?php\n+function throwit() {\n+\tthrow new Exception('it');\n+}\n+$var10 = \""throwit\"";\n+try {\n+\t$var14 = mb_ereg_replace_callback(\""\"", $var10, \""\"");\n+} catch(Exception $e) {}\n+?>\n+DONE\n+--EXPECT--\n+DONE\n\\ No newline at end of file""}","static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOptionType options, int is_callable)
{
	zval **arg_pattern_zval;

	char *arg_pattern;
	int arg_pattern_len;

	char *replace;
	int replace_len;

	zend_fcall_info arg_replace_fci;
	zend_fcall_info_cache arg_replace_fci_cache;

	char *string;
	int string_len;

	char *p;
	php_mb_regex_t *re;
	OnigSyntaxType *syntax;
	OnigRegion *regs = NULL;
	smart_str out_buf = { 0 };
	smart_str eval_buf = { 0 };
	smart_str *pbuf;
	int i, err, eval, n;
	OnigUChar *pos;
	OnigUChar *string_lim;
	char *description = NULL;
	char pat_buf[2];

	const mbfl_encoding *enc;

	{
		const char *current_enc_name;
		current_enc_name = _php_mb_regex_mbctype2name(MBREX(current_mbctype));
		if (current_enc_name == NULL ||
			(enc = mbfl_name2encoding(current_enc_name)) == NULL) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unknown error"");
			RETURN_FALSE;
		}
	}
	eval = 0;
	{
		char *option_str = NULL;
		int option_str_len = 0;

		if (!is_callable) {
			if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""Zss|s"",
						&arg_pattern_zval,
						&replace, &replace_len,
						&string, &string_len,
						&option_str, &option_str_len) == FAILURE) {
				RETURN_FALSE;
			}
		} else {
			if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""Zfs|s"",
						&arg_pattern_zval,
						&arg_replace_fci, &arg_replace_fci_cache,
						&string, &string_len,
						&option_str, &option_str_len) == FAILURE) {
				RETURN_FALSE;
			}
		}

		if (option_str != NULL) {
			_php_mb_regex_init_options(option_str, option_str_len, &options, &syntax, &eval);
		} else {
			options |= MBREX(regex_default_options);
			syntax = MBREX(regex_default_syntax);
		}
	}
	if (Z_TYPE_PP(arg_pattern_zval) == IS_STRING) {
		arg_pattern = Z_STRVAL_PP(arg_pattern_zval);
		arg_pattern_len = Z_STRLEN_PP(arg_pattern_zval);
 	} else {
 		/* FIXME: this code is not multibyte aware! */
 		convert_to_long_ex(arg_pattern_zval);
		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);
 		pat_buf[1] = '\0';
 
 		arg_pattern = pat_buf;
		arg_pattern_len = 1;
 	}
 	/* create regex pattern buffer */
 	re = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);
	if (re == NULL) {
		RETURN_FALSE;
	}

	if (eval || is_callable) {
		pbuf = &eval_buf;
		description = zend_make_compiled_string_description(""mbregex replace"" TSRMLS_CC);
	} else {
		pbuf = &out_buf;
		description = NULL;
	}

	if (is_callable) {
		if (eval) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Option 'e' cannot be used with replacement callback"");
			RETURN_FALSE;
		}
	}

	/* do the actual work */
	err = 0;
	pos = (OnigUChar *)string;
	string_lim = (OnigUChar*)(string + string_len);
	regs = onig_region_new();
	while (err >= 0) {
		err = onig_search(re, (OnigUChar *)string, (OnigUChar *)string_lim, pos, (OnigUChar *)string_lim, regs, 0);
		if (err <= -2) {
			OnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];
			onig_error_code_to_str(err_str, err);
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""mbregex search failure in php_mbereg_replace_exec(): %s"", err_str);
			break;
		}
		if (err >= 0) {
#if moriyoshi_0
			if (regs->beg[0] == regs->end[0]) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty regular expression"");
				break;
			}
#endif
			/* copy the part of the string before the match */
			smart_str_appendl(&out_buf, pos, (size_t)((OnigUChar *)(string + regs->beg[0]) - pos));

			if (!is_callable) {
				/* copy replacement and backrefs */
				i = 0;
				p = replace;
				while (i < replace_len) {
					int fwd = (int) php_mb_mbchar_bytes_ex(p, enc);
					n = -1;
					if ((replace_len - i) >= 2 && fwd == 1 &&
					p[0] == '\\' && p[1] >= '0' && p[1] <= '9') {
						n = p[1] - '0';
					}
					if (n >= 0 && n < regs->num_regs) {
						if (regs->beg[n] >= 0 && regs->beg[n] < regs->end[n] && regs->end[n] <= string_len) {
							smart_str_appendl(pbuf, string + regs->beg[n], regs->end[n] - regs->beg[n]);
						}
						p += 2;
						i += 2;
					} else {
						smart_str_appendl(pbuf, p, fwd);
						p += fwd;
						i += fwd;
 					}
 				}
 			}

 			if (eval) {
 				zval v;
 				/* null terminate buffer */
				smart_str_0(&eval_buf);
				/* do eval */
				if (zend_eval_stringl(eval_buf.c, eval_buf.len, &v, description TSRMLS_CC) == FAILURE) {
					efree(description);
					php_error_docref(NULL TSRMLS_CC,E_ERROR, ""Failed evaluating code: %s%s"", PHP_EOL, eval_buf.c);
					/* zend_error() does not return in this case */
				}

				/* result of eval */
				convert_to_string(&v);
				smart_str_appendl(&out_buf, Z_STRVAL(v), Z_STRLEN(v));
				/* Clean up */
 				eval_buf.len = 0;
 				zval_dtor(&v);
 			} else if (is_callable) {
				zval *retval_ptr = NULL;
 				zval **args[1];
 				zval *subpats;
 				int i;

 				MAKE_STD_ZVAL(subpats);
 				array_init(subpats);

 				for (i = 0; i < regs->num_regs; i++) {
 					add_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);
				}

 				args[0] = &subpats;
 				/* null terminate buffer */
 				smart_str_0(&eval_buf);

 				arg_replace_fci.param_count = 1;
 				arg_replace_fci.params = args;
 				arg_replace_fci.retval_ptr_ptr = &retval_ptr;
				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {
 					convert_to_string_ex(&retval_ptr);
 					smart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));
 					eval_buf.len = 0;
 					zval_ptr_dtor(&retval_ptr);
 				} else {
 					if (!EG(exception)) {
 						php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call custom replacement function"");
 					}
				}
				zval_ptr_dtor(&subpats);
			}

			n = regs->end[0];
			if ((pos - (OnigUChar *)string) < n) {
 				pos = (OnigUChar *)string + n;
 			} else {
 				if (pos < string_lim) {
					smart_str_appendl(&out_buf, pos, 1);
 				}
 				pos++;
 			}
		} else { /* nomatch */
			/* stick that last bit of string on our output */
			if (string_lim - pos > 0) {
				smart_str_appendl(&out_buf, pos, string_lim - pos);
			}
		}
		onig_region_free(regs, 0);
	}

	if (description) {
		efree(description);
	}
	if (regs != NULL) {
		onig_region_free(regs, 1);
	}
 	smart_str_free(&eval_buf);
 
 	if (err <= -2) {
		smart_str_free(&out_buf);
 		RETVAL_FALSE;
 	} else {
 		smart_str_appendc(&out_buf, '\0');
		RETVAL_STRINGL((char *)out_buf.c, out_buf.len - 1, 0);
	}
}
","static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOptionType options, int is_callable)
{
	zval **arg_pattern_zval;

	char *arg_pattern;
	int arg_pattern_len;

	char *replace;
	int replace_len;

	zend_fcall_info arg_replace_fci;
	zend_fcall_info_cache arg_replace_fci_cache;

	char *string;
	int string_len;

	char *p;
	php_mb_regex_t *re;
	OnigSyntaxType *syntax;
	OnigRegion *regs = NULL;
	smart_str out_buf = { 0 };
	smart_str eval_buf = { 0 };
	smart_str *pbuf;
	int i, err, eval, n;
	OnigUChar *pos;
	OnigUChar *string_lim;
	char *description = NULL;
	char pat_buf[2];

	const mbfl_encoding *enc;

	{
		const char *current_enc_name;
		current_enc_name = _php_mb_regex_mbctype2name(MBREX(current_mbctype));
		if (current_enc_name == NULL ||
			(enc = mbfl_name2encoding(current_enc_name)) == NULL) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unknown error"");
			RETURN_FALSE;
		}
	}
	eval = 0;
	{
		char *option_str = NULL;
		int option_str_len = 0;

		if (!is_callable) {
			if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""Zss|s"",
						&arg_pattern_zval,
						&replace, &replace_len,
						&string, &string_len,
						&option_str, &option_str_len) == FAILURE) {
				RETURN_FALSE;
			}
		} else {
			if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""Zfs|s"",
						&arg_pattern_zval,
						&arg_replace_fci, &arg_replace_fci_cache,
						&string, &string_len,
						&option_str, &option_str_len) == FAILURE) {
				RETURN_FALSE;
			}
		}

		if (option_str != NULL) {
			_php_mb_regex_init_options(option_str, option_str_len, &options, &syntax, &eval);
		} else {
			options |= MBREX(regex_default_options);
			syntax = MBREX(regex_default_syntax);
		}
	}
	if (Z_TYPE_PP(arg_pattern_zval) == IS_STRING) {
		arg_pattern = Z_STRVAL_PP(arg_pattern_zval);
		arg_pattern_len = Z_STRLEN_PP(arg_pattern_zval);
 	} else {
 		/* FIXME: this code is not multibyte aware! */
 		convert_to_long_ex(arg_pattern_zval);
		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);	
 		pat_buf[1] = '\0';
 
 		arg_pattern = pat_buf;
		arg_pattern_len = 1;	
 	}
 	/* create regex pattern buffer */
 	re = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);
	if (re == NULL) {
		RETURN_FALSE;
	}

	if (eval || is_callable) {
		pbuf = &eval_buf;
		description = zend_make_compiled_string_description(""mbregex replace"" TSRMLS_CC);
	} else {
		pbuf = &out_buf;
		description = NULL;
	}

	if (is_callable) {
		if (eval) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Option 'e' cannot be used with replacement callback"");
			RETURN_FALSE;
		}
	}

	/* do the actual work */
	err = 0;
	pos = (OnigUChar *)string;
	string_lim = (OnigUChar*)(string + string_len);
	regs = onig_region_new();
	while (err >= 0) {
		err = onig_search(re, (OnigUChar *)string, (OnigUChar *)string_lim, pos, (OnigUChar *)string_lim, regs, 0);
		if (err <= -2) {
			OnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];
			onig_error_code_to_str(err_str, err);
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""mbregex search failure in php_mbereg_replace_exec(): %s"", err_str);
			break;
		}
		if (err >= 0) {
#if moriyoshi_0
			if (regs->beg[0] == regs->end[0]) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty regular expression"");
				break;
			}
#endif
			/* copy the part of the string before the match */
			smart_str_appendl(&out_buf, pos, (size_t)((OnigUChar *)(string + regs->beg[0]) - pos));

			if (!is_callable) {
				/* copy replacement and backrefs */
				i = 0;
				p = replace;
				while (i < replace_len) {
					int fwd = (int) php_mb_mbchar_bytes_ex(p, enc);
					n = -1;
					if ((replace_len - i) >= 2 && fwd == 1 &&
					p[0] == '\\' && p[1] >= '0' && p[1] <= '9') {
						n = p[1] - '0';
					}
					if (n >= 0 && n < regs->num_regs) {
						if (regs->beg[n] >= 0 && regs->beg[n] < regs->end[n] && regs->end[n] <= string_len) {
							smart_str_appendl(pbuf, string + regs->beg[n], regs->end[n] - regs->beg[n]);
						}
						p += 2;
						i += 2;
					} else {
						smart_str_appendl(pbuf, p, fwd);
						p += fwd;
						i += fwd;
 					}
 				}
 			}
 			if (eval) {
 				zval v;
 				/* null terminate buffer */
				smart_str_0(&eval_buf);
				/* do eval */
				if (zend_eval_stringl(eval_buf.c, eval_buf.len, &v, description TSRMLS_CC) == FAILURE) {
					efree(description);
					php_error_docref(NULL TSRMLS_CC,E_ERROR, ""Failed evaluating code: %s%s"", PHP_EOL, eval_buf.c);
					/* zend_error() does not return in this case */
				}

				/* result of eval */
				convert_to_string(&v);
				smart_str_appendl(&out_buf, Z_STRVAL(v), Z_STRLEN(v));
				/* Clean up */
 				eval_buf.len = 0;
 				zval_dtor(&v);
 			} else if (is_callable) {
				zval *retval_ptr;
 				zval **args[1];
 				zval *subpats;
 				int i;
 				MAKE_STD_ZVAL(subpats);
 				array_init(subpats);
 				for (i = 0; i < regs->num_regs; i++) {
 					add_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);
				}				
 				args[0] = &subpats;
 				/* null terminate buffer */
 				smart_str_0(&eval_buf);
 				arg_replace_fci.param_count = 1;
 				arg_replace_fci.params = args;
 				arg_replace_fci.retval_ptr_ptr = &retval_ptr;
				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {
 					convert_to_string_ex(&retval_ptr);
 					smart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));
 					eval_buf.len = 0;
 					zval_ptr_dtor(&retval_ptr);
 				} else {
					efree(description);
 					if (!EG(exception)) {
 						php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call custom replacement function"");
 					}
				}
				zval_ptr_dtor(&subpats);
			}

			n = regs->end[0];
			if ((pos - (OnigUChar *)string) < n) {
 				pos = (OnigUChar *)string + n;
 			} else {
 				if (pos < string_lim) {
					smart_str_appendl(&out_buf, pos, 1); 
 				}
 				pos++;
 			}
		} else { /* nomatch */
			/* stick that last bit of string on our output */
			if (string_lim - pos > 0) {
				smart_str_appendl(&out_buf, pos, string_lim - pos);
			}
		}
		onig_region_free(regs, 0);
	}

	if (description) {
		efree(description);
	}
	if (regs != NULL) {
		onig_region_free(regs, 1);
	}
 	smart_str_free(&eval_buf);
 
 	if (err <= -2) {
		smart_str_free(&out_buf);	
 		RETVAL_FALSE;
 	} else {
 		smart_str_appendc(&out_buf, '\0');
		RETVAL_STRINGL((char *)out_buf.c, out_buf.len - 1, 0);
	}
}
",C,"		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);
		arg_pattern_len = 1;

				zval *retval_ptr = NULL;


				}


				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {
					smart_str_appendl(&out_buf, pos, 1);
		smart_str_free(&out_buf);
","		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);	
		arg_pattern_len = 1;	
				zval *retval_ptr;
				}				
				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {
					efree(description);
					smart_str_appendl(&out_buf, pos, 1); 
		smart_str_free(&out_buf);	
",,"@@ -32,7 +32,7 @@
 #include ""ext/standard/info.h""
 #include ""php_mbregex.h""
 #include ""mbstring.h""
- 
+
 #include ""php_onig_compat.h"" /* must come prior to the oniguruma header */
 #include <oniguruma.h>
 #undef UChar
@@ -55,7 +55,7 @@ struct _zend_mb_regex_globals {
 #define MBREX(g) (MBSTRG(mb_regex_globals)->g)
 
 /* {{{ static void php_mb_regex_free_cache() */
-static void php_mb_regex_free_cache(php_mb_regex_t **pre) 
+static void php_mb_regex_free_cache(php_mb_regex_t **pre)
 {
 	onig_free(*pre);
 }
@@ -78,7 +78,7 @@ static int _php_mb_regex_globals_ctor(zend_mb_regex_globals *pglobals TSRMLS_DC)
 /* }}} */
 
 /* {{{ _php_mb_regex_globals_dtor */
-static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) 
+static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)
 {
 	zend_hash_destroy(&pglobals->ht_rc);
 }
@@ -466,7 +466,7 @@ static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patl
 		retval = *rc;
 	}
 out:
-	return retval; 
+	return retval;
 }
 /* }}} */
 
@@ -483,15 +483,15 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 			--len_left;
 			*(p++) = 'i';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	if ((option & ONIG_OPTION_EXTEND) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'x';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	if ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==
@@ -500,37 +500,37 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 			--len_left;
 			*(p++) = 'p';
 		}
-		++len_req;	
+		++len_req;
 	} else {
 		if ((option & ONIG_OPTION_MULTILINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 'm';
 			}
-			++len_req;	
+			++len_req;
 		}
 
 		if ((option & ONIG_OPTION_SINGLELINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 's';
 			}
-			++len_req;	
+			++len_req;
 		}
-	}	
+	}
 	if ((option & ONIG_OPTION_FIND_LONGEST) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'l';
 		}
-		++len_req;	
+		++len_req;
 	}
 	if ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'n';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	c = 0;
@@ -566,7 +566,7 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 		--len_left;
 		*(p++) = '\0';
 	}
-	++len_req;	
+	++len_req;
 	if (len < len_req) {
 		return len_req;
 	}
@@ -577,11 +577,11 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 
 /* {{{ _php_mb_regex_init_options */
 static void
-_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) 
+_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)
 {
 	int n;
 	char c;
-	int optm = 0; 
+	int optm = 0;
 
 	*syntax = ONIG_SYNTAX_RUBY;
 
@@ -636,13 +636,13 @@ _php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, O
 					*syntax = ONIG_SYNTAX_POSIX_EXTENDED;
 					break;
 				case 'e':
-					if (eval != NULL) *eval = 1; 
+					if (eval != NULL) *eval = 1;
 					break;
 				default:
 					break;
 			}
 		}
-		if (option != NULL) *option|=optm; 
+		if (option != NULL) *option|=optm;
 	}
 }
 /* }}} */
@@ -860,11 +860,11 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 	} else {
 		/* FIXME: this code is not multibyte aware! */
 		convert_to_long_ex(arg_pattern_zval);
-		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);	
+		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);
 		pat_buf[1] = '\0';
 
 		arg_pattern = pat_buf;
-		arg_pattern_len = 1;	
+		arg_pattern_len = 1;
 	}
 	/* create regex pattern buffer */
 	re = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);
@@ -934,7 +934,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 					}
 				}
 			}
-				
+
 			if (eval) {
 				zval v;
 				/* null terminate buffer */
@@ -953,32 +953,31 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 				eval_buf.len = 0;
 				zval_dtor(&v);
 			} else if (is_callable) {
-				zval *retval_ptr;
+				zval *retval_ptr = NULL;
 				zval **args[1];
 				zval *subpats;
 				int i;
-				
+
 				MAKE_STD_ZVAL(subpats);
 				array_init(subpats);
-				
+
 				for (i = 0; i < regs->num_regs; i++) {
 					add_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);
-				}				
-				
+				}
+
 				args[0] = &subpats;
 				/* null terminate buffer */
 				smart_str_0(&eval_buf);
-				
+
 				arg_replace_fci.param_count = 1;
 				arg_replace_fci.params = args;
 				arg_replace_fci.retval_ptr_ptr = &retval_ptr;
-				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {
+				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {
 					convert_to_string_ex(&retval_ptr);
 					smart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));
 					eval_buf.len = 0;
 					zval_ptr_dtor(&retval_ptr);
 				} else {
-					efree(description);
 					if (!EG(exception)) {
 						php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call custom replacement function"");
 					}
@@ -991,7 +990,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 				pos = (OnigUChar *)string + n;
 			} else {
 				if (pos < string_lim) {
-					smart_str_appendl(&out_buf, pos, 1); 
+					smart_str_appendl(&out_buf, pos, 1);
 				}
 				pos++;
 			}
@@ -1013,7 +1012,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 	smart_str_free(&eval_buf);
 
 	if (err <= -2) {
-		smart_str_free(&out_buf);	
+		smart_str_free(&out_buf);
 		RETVAL_FALSE;
 	} else {
 		smart_str_appendc(&out_buf, '\0');
@@ -1063,7 +1062,7 @@ PHP_FUNCTION(mb_split)
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|l"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {
 		RETURN_FALSE;
-	} 
+	}
 
 	if (count > 0) {
 		count--;
@@ -1317,7 +1316,7 @@ PHP_FUNCTION(mb_ereg_search_init)
 	if (zend_parse_parameters(argc TSRMLS_CC, ""z|ss"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {
 		return;
 	}
-	
+
 	if (argc > 1 && arg_pattern_len == 0) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty pattern"");
 		RETURN_FALSE;
@@ -1416,7 +1415,7 @@ PHP_FUNCTION(mb_ereg_search_setpos)
 /* }}} */
 
 /* {{{ php_mb_regex_set_options */
-static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) 
+static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)
 {
 	if (prev_options != NULL) {
 		*prev_options = MBREX(regex_default_options);",php-src,5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,e9ac8954be9f7d988189df44578d759ffdea3512,1,"static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOptionType options, int is_callable)
{
	zval **arg_pattern_zval;

	char *arg_pattern;
	int arg_pattern_len;

	char *replace;
	int replace_len;

	zend_fcall_info arg_replace_fci;
	zend_fcall_info_cache arg_replace_fci_cache;

	char *string;
	int string_len;

	char *p;
	php_mb_regex_t *re;
	OnigSyntaxType *syntax;
	OnigRegion *regs = NULL;
	smart_str out_buf = { 0 };
	smart_str eval_buf = { 0 };
	smart_str *pbuf;
	int i, err, eval, n;
	OnigUChar *pos;
	OnigUChar *string_lim;
	char *description = NULL;
	char pat_buf[2];

	const mbfl_encoding *enc;

	{
		const char *current_enc_name;
		current_enc_name = _php_mb_regex_mbctype2name(MBREX(current_mbctype));
		if (current_enc_name == NULL ||
			(enc = mbfl_name2encoding(current_enc_name)) == NULL) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unknown error"");
			RETURN_FALSE;
		}
	}
	eval = 0;
	{
		char *option_str = NULL;
		int option_str_len = 0;

		if (!is_callable) {
			if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""Zss|s"",
						&arg_pattern_zval,
						&replace, &replace_len,
						&string, &string_len,
						&option_str, &option_str_len) == FAILURE) {
				RETURN_FALSE;
			}
		} else {
			if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""Zfs|s"",
						&arg_pattern_zval,
						&arg_replace_fci, &arg_replace_fci_cache,
						&string, &string_len,
						&option_str, &option_str_len) == FAILURE) {
				RETURN_FALSE;
			}
		}

		if (option_str != NULL) {
			_php_mb_regex_init_options(option_str, option_str_len, &options, &syntax, &eval);
		} else {
			options |= MBREX(regex_default_options);
			syntax = MBREX(regex_default_syntax);
		}
	}
	if (Z_TYPE_PP(arg_pattern_zval) == IS_STRING) {
		arg_pattern = Z_STRVAL_PP(arg_pattern_zval);
		arg_pattern_len = Z_STRLEN_PP(arg_pattern_zval);
 	} else {
 		/* FIXME: this code is not multibyte aware! */
 		convert_to_long_ex(arg_pattern_zval);
//flaw_line_below:
		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);	
//fix_flaw_line_below:
//		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);
 		pat_buf[1] = '\0';
 
 		arg_pattern = pat_buf;
//flaw_line_below:
		arg_pattern_len = 1;	
//fix_flaw_line_below:
//		arg_pattern_len = 1;
 	}
 	/* create regex pattern buffer */
 	re = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);
	if (re == NULL) {
		RETURN_FALSE;
	}

	if (eval || is_callable) {
		pbuf = &eval_buf;
		description = zend_make_compiled_string_description(""mbregex replace"" TSRMLS_CC);
	} else {
		pbuf = &out_buf;
		description = NULL;
	}

	if (is_callable) {
		if (eval) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Option 'e' cannot be used with replacement callback"");
			RETURN_FALSE;
		}
	}

	/* do the actual work */
	err = 0;
	pos = (OnigUChar *)string;
	string_lim = (OnigUChar*)(string + string_len);
	regs = onig_region_new();
	while (err >= 0) {
		err = onig_search(re, (OnigUChar *)string, (OnigUChar *)string_lim, pos, (OnigUChar *)string_lim, regs, 0);
		if (err <= -2) {
			OnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];
			onig_error_code_to_str(err_str, err);
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""mbregex search failure in php_mbereg_replace_exec(): %s"", err_str);
			break;
		}
		if (err >= 0) {
#if moriyoshi_0
			if (regs->beg[0] == regs->end[0]) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty regular expression"");
				break;
			}
#endif
			/* copy the part of the string before the match */
			smart_str_appendl(&out_buf, pos, (size_t)((OnigUChar *)(string + regs->beg[0]) - pos));

			if (!is_callable) {
				/* copy replacement and backrefs */
				i = 0;
				p = replace;
				while (i < replace_len) {
					int fwd = (int) php_mb_mbchar_bytes_ex(p, enc);
					n = -1;
					if ((replace_len - i) >= 2 && fwd == 1 &&
					p[0] == '\\' && p[1] >= '0' && p[1] <= '9') {
						n = p[1] - '0';
					}
					if (n >= 0 && n < regs->num_regs) {
						if (regs->beg[n] >= 0 && regs->beg[n] < regs->end[n] && regs->end[n] <= string_len) {
							smart_str_appendl(pbuf, string + regs->beg[n], regs->end[n] - regs->beg[n]);
						}
						p += 2;
						i += 2;
					} else {
						smart_str_appendl(pbuf, p, fwd);
						p += fwd;
						i += fwd;
 					}
 				}
 			}
//flaw_line_below:
				
//fix_flaw_line_below:
//
 			if (eval) {
 				zval v;
 				/* null terminate buffer */
				smart_str_0(&eval_buf);
				/* do eval */
				if (zend_eval_stringl(eval_buf.c, eval_buf.len, &v, description TSRMLS_CC) == FAILURE) {
					efree(description);
					php_error_docref(NULL TSRMLS_CC,E_ERROR, ""Failed evaluating code: %s%s"", PHP_EOL, eval_buf.c);
					/* zend_error() does not return in this case */
				}

				/* result of eval */
				convert_to_string(&v);
				smart_str_appendl(&out_buf, Z_STRVAL(v), Z_STRLEN(v));
				/* Clean up */
 				eval_buf.len = 0;
 				zval_dtor(&v);
 			} else if (is_callable) {
//flaw_line_below:
				zval *retval_ptr;
//fix_flaw_line_below:
//				zval *retval_ptr = NULL;
 				zval **args[1];
 				zval *subpats;
 				int i;
//flaw_line_below:
				
//fix_flaw_line_below:
//
 				MAKE_STD_ZVAL(subpats);
 				array_init(subpats);
//flaw_line_below:
				
//fix_flaw_line_below:
//
 				for (i = 0; i < regs->num_regs; i++) {
 					add_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);
//flaw_line_below:
				}				
//flaw_line_below:
				
//fix_flaw_line_below:
//				}
//fix_flaw_line_below:
//
 				args[0] = &subpats;
 				/* null terminate buffer */
 				smart_str_0(&eval_buf);
//flaw_line_below:
				
//fix_flaw_line_below:
//
 				arg_replace_fci.param_count = 1;
 				arg_replace_fci.params = args;
 				arg_replace_fci.retval_ptr_ptr = &retval_ptr;
//flaw_line_below:
				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {
//fix_flaw_line_below:
//				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {
 					convert_to_string_ex(&retval_ptr);
 					smart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));
 					eval_buf.len = 0;
 					zval_ptr_dtor(&retval_ptr);
 				} else {
//flaw_line_below:
					efree(description);
 					if (!EG(exception)) {
 						php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call custom replacement function"");
 					}
				}
				zval_ptr_dtor(&subpats);
			}

			n = regs->end[0];
			if ((pos - (OnigUChar *)string) < n) {
 				pos = (OnigUChar *)string + n;
 			} else {
 				if (pos < string_lim) {
//flaw_line_below:
					smart_str_appendl(&out_buf, pos, 1); 
//fix_flaw_line_below:
//					smart_str_appendl(&out_buf, pos, 1);
 				}
 				pos++;
 			}
		} else { /* nomatch */
			/* stick that last bit of string on our output */
			if (string_lim - pos > 0) {
				smart_str_appendl(&out_buf, pos, string_lim - pos);
			}
		}
		onig_region_free(regs, 0);
	}

	if (description) {
		efree(description);
	}
	if (regs != NULL) {
		onig_region_free(regs, 1);
	}
 	smart_str_free(&eval_buf);
 
 	if (err <= -2) {
//flaw_line_below:
		smart_str_free(&out_buf);	
//fix_flaw_line_below:
//		smart_str_free(&out_buf);
 		RETVAL_FALSE;
 	} else {
 		smart_str_appendc(&out_buf, '\0');
		RETVAL_STRINGL((char *)out_buf.c, out_buf.len - 1, 0);
	}
}
"
2554,180290,,Remote,Not required,Partial,CVE-2016-5768,https://www.cvedetails.com/cve/CVE-2016-5768/,CWE-415,Low,Partial,Partial,,2016-08-07,7.5,"Double free vulnerability in the _php_mb_regex_ereg_replace_exec function in php_mbregex.c in the mbstring extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to execute arbitrary code or cause a denial of service (application crash) by leveraging a callback exception.",2018-01-04,DoS Exec Code ,9,https://github.com/php/php-src/commit/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,Fix bug #72402: _php_mb_regex_ereg_replace_exec - double free,9,ext/mbstring/php_mbregex.c,"{""sha"": ""6cdee23c3e5999b467c4a206bf3f4827ebe121f6"", ""filename"": ""ext/mbstring/php_mbregex.c"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 33, ""changes"": 65, ""blob_url"": ""https://github.com/php/php-src/blob/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/php_mbregex.c"", ""raw_url"": ""https://github.com/php/php-src/raw/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/php_mbregex.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/mbstring/php_mbregex.c?ref=5b597a2e5b28e2d5a52fc1be13f425f08f47cb62"", ""patch"": ""@@ -32,7 +32,7 @@\n #include \""ext/standard/info.h\""\n #include \""php_mbregex.h\""\n #include \""mbstring.h\""\n- \n+\n #include \""php_onig_compat.h\"" /* must come prior to the oniguruma header */\n #include <oniguruma.h>\n #undef UChar\n@@ -55,7 +55,7 @@ struct _zend_mb_regex_globals {\n #define MBREX(g) (MBSTRG(mb_regex_globals)->g)\n \n /* {{{ static void php_mb_regex_free_cache() */\n-static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n+static void php_mb_regex_free_cache(php_mb_regex_t **pre)\n {\n \tonig_free(*pre);\n }\n@@ -78,7 +78,7 @@ static int _php_mb_regex_globals_ctor(zend_mb_regex_globals *pglobals TSRMLS_DC)\n /* }}} */\n \n /* {{{ _php_mb_regex_globals_dtor */\n-static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) \n+static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)\n {\n \tzend_hash_destroy(&pglobals->ht_rc);\n }\n@@ -466,7 +466,7 @@ static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patl\n \t\tretval = *rc;\n \t}\n out:\n-\treturn retval; \n+\treturn retval;\n }\n /* }}} */\n \n@@ -483,15 +483,15 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t\t--len_left;\n \t\t\t*(p++) = 'i';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tif ((option & ONIG_OPTION_EXTEND) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'x';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tif ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==\n@@ -500,37 +500,37 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t\t--len_left;\n \t\t\t*(p++) = 'p';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t} else {\n \t\tif ((option & ONIG_OPTION_MULTILINE) != 0) {\n \t\t\tif (len_left > 0) {\n \t\t\t\t--len_left;\n \t\t\t\t*(p++) = 'm';\n \t\t\t}\n-\t\t\t++len_req;\t\n+\t\t\t++len_req;\n \t\t}\n \n \t\tif ((option & ONIG_OPTION_SINGLELINE) != 0) {\n \t\t\tif (len_left > 0) {\n \t\t\t\t--len_left;\n \t\t\t\t*(p++) = 's';\n \t\t\t}\n-\t\t\t++len_req;\t\n+\t\t\t++len_req;\n \t\t}\n-\t}\t\n+\t}\n \tif ((option & ONIG_OPTION_FIND_LONGEST) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'l';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \tif ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'n';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tc = 0;\n@@ -566,7 +566,7 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t--len_left;\n \t\t*(p++) = '\\0';\n \t}\n-\t++len_req;\t\n+\t++len_req;\n \tif (len < len_req) {\n \t\treturn len_req;\n \t}\n@@ -577,11 +577,11 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \n /* {{{ _php_mb_regex_init_options */\n static void\n-_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) \n+_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)\n {\n \tint n;\n \tchar c;\n-\tint optm = 0; \n+\tint optm = 0;\n \n \t*syntax = ONIG_SYNTAX_RUBY;\n \n@@ -636,13 +636,13 @@ _php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, O\n \t\t\t\t\t*syntax = ONIG_SYNTAX_POSIX_EXTENDED;\n \t\t\t\t\tbreak;\n \t\t\t\tcase 'e':\n-\t\t\t\t\tif (eval != NULL) *eval = 1; \n+\t\t\t\t\tif (eval != NULL) *eval = 1;\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n-\t\tif (option != NULL) *option|=optm; \n+\t\tif (option != NULL) *option|=optm;\n \t}\n }\n /* }}} */\n@@ -860,11 +860,11 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t} else {\n \t\t/* FIXME: this code is not multibyte aware! */\n \t\tconvert_to_long_ex(arg_pattern_zval);\n-\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\t\n+\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\n \t\tpat_buf[1] = '\\0';\n \n \t\targ_pattern = pat_buf;\n-\t\targ_pattern_len = 1;\t\n+\t\targ_pattern_len = 1;\n \t}\n \t/* create regex pattern buffer */\n \tre = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);\n@@ -934,7 +934,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\t\t\n+\n \t\t\tif (eval) {\n \t\t\t\tzval v;\n \t\t\t\t/* null terminate buffer */\n@@ -953,32 +953,31 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\teval_buf.len = 0;\n \t\t\t\tzval_dtor(&v);\n \t\t\t} else if (is_callable) {\n-\t\t\t\tzval *retval_ptr;\n+\t\t\t\tzval *retval_ptr = NULL;\n \t\t\t\tzval **args[1];\n \t\t\t\tzval *subpats;\n \t\t\t\tint i;\n-\t\t\t\t\n+\n \t\t\t\tMAKE_STD_ZVAL(subpats);\n \t\t\t\tarray_init(subpats);\n-\t\t\t\t\n+\n \t\t\t\tfor (i = 0; i < regs->num_regs; i++) {\n \t\t\t\t\tadd_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);\n-\t\t\t\t}\t\t\t\t\n-\t\t\t\t\n+\t\t\t\t}\n+\n \t\t\t\targs[0] = &subpats;\n \t\t\t\t/* null terminate buffer */\n \t\t\t\tsmart_str_0(&eval_buf);\n-\t\t\t\t\n+\n \t\t\t\targ_replace_fci.param_count = 1;\n \t\t\t\targ_replace_fci.params = args;\n \t\t\t\targ_replace_fci.retval_ptr_ptr = &retval_ptr;\n-\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {\n+\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {\n \t\t\t\t\tconvert_to_string_ex(&retval_ptr);\n \t\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));\n \t\t\t\t\teval_buf.len = 0;\n \t\t\t\t\tzval_ptr_dtor(&retval_ptr);\n \t\t\t\t} else {\n-\t\t\t\t\tefree(description);\n \t\t\t\t\tif (!EG(exception)) {\n \t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to call custom replacement function\"");\n \t\t\t\t\t}\n@@ -991,7 +990,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\tpos = (OnigUChar *)string + n;\n \t\t\t} else {\n \t\t\t\tif (pos < string_lim) {\n-\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1); \n+\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1);\n \t\t\t\t}\n \t\t\t\tpos++;\n \t\t\t}\n@@ -1013,7 +1012,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \tsmart_str_free(&eval_buf);\n \n \tif (err <= -2) {\n-\t\tsmart_str_free(&out_buf);\t\n+\t\tsmart_str_free(&out_buf);\n \t\tRETVAL_FALSE;\n \t} else {\n \t\tsmart_str_appendc(&out_buf, '\\0');\n@@ -1063,7 +1062,7 @@ PHP_FUNCTION(mb_split)\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""ss|l\"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {\n \t\tRETURN_FALSE;\n-\t} \n+\t}\n \n \tif (count > 0) {\n \t\tcount--;\n@@ -1317,7 +1316,7 @@ PHP_FUNCTION(mb_ereg_search_init)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \""z|ss\"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc > 1 && arg_pattern_len == 0) {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Empty pattern\"");\n \t\tRETURN_FALSE;\n@@ -1416,7 +1415,7 @@ PHP_FUNCTION(mb_ereg_search_setpos)\n /* }}} */\n \n /* {{{ php_mb_regex_set_options */\n-static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) \n+static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)\n {\n \tif (prev_options != NULL) {\n \t\t*prev_options = MBREX(regex_default_options);""}<_**next**_>{""sha"": ""abb290bf4d8706ea51ecefd7ea68da62b4194f5d"", ""filename"": ""ext/mbstring/tests/bug72402.phpt"", ""status"": ""added"", ""additions"": 17, ""deletions"": 0, ""changes"": 17, ""blob_url"": ""https://github.com/php/php-src/blob/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/tests/bug72402.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/tests/bug72402.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/mbstring/tests/bug72402.phpt?ref=5b597a2e5b28e2d5a52fc1be13f425f08f47cb62"", ""patch"": ""@@ -0,0 +1,17 @@\n+--TEST--\n+Bug #72402: _php_mb_regex_ereg_replace_exec - double free\n+--SKIPIF--\n+<?php extension_loaded('mbstring') or die('skip mbstring not available'); ?>\n+--FILE--\n+<?php\n+function throwit() {\n+\tthrow new Exception('it');\n+}\n+$var10 = \""throwit\"";\n+try {\n+\t$var14 = mb_ereg_replace_callback(\""\"", $var10, \""\"");\n+} catch(Exception $e) {}\n+?>\n+DONE\n+--EXPECT--\n+DONE\n\\ No newline at end of file""}","static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionType option, OnigSyntaxType *syntax)
{
	size_t len_left = len;
	size_t len_req = 0;
	char *p = str;
	char c;

	if ((option & ONIG_OPTION_IGNORECASE) != 0) {
		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'i';
 		}
		++len_req;
 	}
 
 	if ((option & ONIG_OPTION_EXTEND) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'x';
 		}
		++len_req;
 	}
 
 	if ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==
			(ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) {
		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'p';
 		}
		++len_req;
 	} else {
 		if ((option & ONIG_OPTION_MULTILINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 'm';
 			}
			++len_req;
 		}
 
 		if ((option & ONIG_OPTION_SINGLELINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 's';
 			}
			++len_req;
 		}
	}
 	if ((option & ONIG_OPTION_FIND_LONGEST) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'l';
 		}
		++len_req;
 	}
 	if ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'n';
 		}
		++len_req;
 	}
 
 	c = 0;

	if (syntax == ONIG_SYNTAX_JAVA) {
		c = 'j';
	} else if (syntax == ONIG_SYNTAX_GNU_REGEX) {
		c = 'u';
	} else if (syntax == ONIG_SYNTAX_GREP) {
		c = 'g';
	} else if (syntax == ONIG_SYNTAX_EMACS) {
		c = 'c';
	} else if (syntax == ONIG_SYNTAX_RUBY) {
		c = 'r';
	} else if (syntax == ONIG_SYNTAX_PERL) {
		c = 'z';
	} else if (syntax == ONIG_SYNTAX_POSIX_BASIC) {
		c = 'b';
	} else if (syntax == ONIG_SYNTAX_POSIX_EXTENDED) {
		c = 'd';
	}

	if (c != 0) {
		if (len_left > 0) {
			--len_left;
			*(p++) = c;
		}
		++len_req;
	}


	if (len_left > 0) {
 		--len_left;
 		*(p++) = '\0';
 	}
	++len_req;
 	if (len < len_req) {
 		return len_req;
 	}

	return 0;
}
","static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionType option, OnigSyntaxType *syntax)
{
	size_t len_left = len;
	size_t len_req = 0;
	char *p = str;
	char c;

	if ((option & ONIG_OPTION_IGNORECASE) != 0) {
		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'i';
 		}
		++len_req;	
 	}
 
 	if ((option & ONIG_OPTION_EXTEND) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'x';
 		}
		++len_req;	
 	}
 
 	if ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==
			(ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) {
		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'p';
 		}
		++len_req;	
 	} else {
 		if ((option & ONIG_OPTION_MULTILINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 'm';
 			}
			++len_req;	
 		}
 
 		if ((option & ONIG_OPTION_SINGLELINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 's';
 			}
			++len_req;	
 		}
	}	
 	if ((option & ONIG_OPTION_FIND_LONGEST) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'l';
 		}
		++len_req;	
 	}
 	if ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'n';
 		}
		++len_req;	
 	}
 
 	c = 0;

	if (syntax == ONIG_SYNTAX_JAVA) {
		c = 'j';
	} else if (syntax == ONIG_SYNTAX_GNU_REGEX) {
		c = 'u';
	} else if (syntax == ONIG_SYNTAX_GREP) {
		c = 'g';
	} else if (syntax == ONIG_SYNTAX_EMACS) {
		c = 'c';
	} else if (syntax == ONIG_SYNTAX_RUBY) {
		c = 'r';
	} else if (syntax == ONIG_SYNTAX_PERL) {
		c = 'z';
	} else if (syntax == ONIG_SYNTAX_POSIX_BASIC) {
		c = 'b';
	} else if (syntax == ONIG_SYNTAX_POSIX_EXTENDED) {
		c = 'd';
	}

	if (c != 0) {
		if (len_left > 0) {
			--len_left;
			*(p++) = c;
		}
		++len_req;
	}


	if (len_left > 0) {
 		--len_left;
 		*(p++) = '\0';
 	}
	++len_req;	
 	if (len < len_req) {
 		return len_req;
 	}

	return 0;
}
",C,"		++len_req;
		++len_req;
		++len_req;
			++len_req;
			++len_req;
	}
		++len_req;
		++len_req;
	++len_req;
","		++len_req;	
		++len_req;	
		++len_req;	
			++len_req;	
			++len_req;	
	}	
		++len_req;	
		++len_req;	
	++len_req;	
",,"@@ -32,7 +32,7 @@
 #include ""ext/standard/info.h""
 #include ""php_mbregex.h""
 #include ""mbstring.h""
- 
+
 #include ""php_onig_compat.h"" /* must come prior to the oniguruma header */
 #include <oniguruma.h>
 #undef UChar
@@ -55,7 +55,7 @@ struct _zend_mb_regex_globals {
 #define MBREX(g) (MBSTRG(mb_regex_globals)->g)
 
 /* {{{ static void php_mb_regex_free_cache() */
-static void php_mb_regex_free_cache(php_mb_regex_t **pre) 
+static void php_mb_regex_free_cache(php_mb_regex_t **pre)
 {
 	onig_free(*pre);
 }
@@ -78,7 +78,7 @@ static int _php_mb_regex_globals_ctor(zend_mb_regex_globals *pglobals TSRMLS_DC)
 /* }}} */
 
 /* {{{ _php_mb_regex_globals_dtor */
-static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) 
+static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)
 {
 	zend_hash_destroy(&pglobals->ht_rc);
 }
@@ -466,7 +466,7 @@ static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patl
 		retval = *rc;
 	}
 out:
-	return retval; 
+	return retval;
 }
 /* }}} */
 
@@ -483,15 +483,15 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 			--len_left;
 			*(p++) = 'i';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	if ((option & ONIG_OPTION_EXTEND) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'x';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	if ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==
@@ -500,37 +500,37 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 			--len_left;
 			*(p++) = 'p';
 		}
-		++len_req;	
+		++len_req;
 	} else {
 		if ((option & ONIG_OPTION_MULTILINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 'm';
 			}
-			++len_req;	
+			++len_req;
 		}
 
 		if ((option & ONIG_OPTION_SINGLELINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 's';
 			}
-			++len_req;	
+			++len_req;
 		}
-	}	
+	}
 	if ((option & ONIG_OPTION_FIND_LONGEST) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'l';
 		}
-		++len_req;	
+		++len_req;
 	}
 	if ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'n';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	c = 0;
@@ -566,7 +566,7 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 		--len_left;
 		*(p++) = '\0';
 	}
-	++len_req;	
+	++len_req;
 	if (len < len_req) {
 		return len_req;
 	}
@@ -577,11 +577,11 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 
 /* {{{ _php_mb_regex_init_options */
 static void
-_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) 
+_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)
 {
 	int n;
 	char c;
-	int optm = 0; 
+	int optm = 0;
 
 	*syntax = ONIG_SYNTAX_RUBY;
 
@@ -636,13 +636,13 @@ _php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, O
 					*syntax = ONIG_SYNTAX_POSIX_EXTENDED;
 					break;
 				case 'e':
-					if (eval != NULL) *eval = 1; 
+					if (eval != NULL) *eval = 1;
 					break;
 				default:
 					break;
 			}
 		}
-		if (option != NULL) *option|=optm; 
+		if (option != NULL) *option|=optm;
 	}
 }
 /* }}} */
@@ -860,11 +860,11 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 	} else {
 		/* FIXME: this code is not multibyte aware! */
 		convert_to_long_ex(arg_pattern_zval);
-		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);	
+		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);
 		pat_buf[1] = '\0';
 
 		arg_pattern = pat_buf;
-		arg_pattern_len = 1;	
+		arg_pattern_len = 1;
 	}
 	/* create regex pattern buffer */
 	re = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);
@@ -934,7 +934,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 					}
 				}
 			}
-				
+
 			if (eval) {
 				zval v;
 				/* null terminate buffer */
@@ -953,32 +953,31 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 				eval_buf.len = 0;
 				zval_dtor(&v);
 			} else if (is_callable) {
-				zval *retval_ptr;
+				zval *retval_ptr = NULL;
 				zval **args[1];
 				zval *subpats;
 				int i;
-				
+
 				MAKE_STD_ZVAL(subpats);
 				array_init(subpats);
-				
+
 				for (i = 0; i < regs->num_regs; i++) {
 					add_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);
-				}				
-				
+				}
+
 				args[0] = &subpats;
 				/* null terminate buffer */
 				smart_str_0(&eval_buf);
-				
+
 				arg_replace_fci.param_count = 1;
 				arg_replace_fci.params = args;
 				arg_replace_fci.retval_ptr_ptr = &retval_ptr;
-				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {
+				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {
 					convert_to_string_ex(&retval_ptr);
 					smart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));
 					eval_buf.len = 0;
 					zval_ptr_dtor(&retval_ptr);
 				} else {
-					efree(description);
 					if (!EG(exception)) {
 						php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call custom replacement function"");
 					}
@@ -991,7 +990,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 				pos = (OnigUChar *)string + n;
 			} else {
 				if (pos < string_lim) {
-					smart_str_appendl(&out_buf, pos, 1); 
+					smart_str_appendl(&out_buf, pos, 1);
 				}
 				pos++;
 			}
@@ -1013,7 +1012,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 	smart_str_free(&eval_buf);
 
 	if (err <= -2) {
-		smart_str_free(&out_buf);	
+		smart_str_free(&out_buf);
 		RETVAL_FALSE;
 	} else {
 		smart_str_appendc(&out_buf, '\0');
@@ -1063,7 +1062,7 @@ PHP_FUNCTION(mb_split)
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|l"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {
 		RETURN_FALSE;
-	} 
+	}
 
 	if (count > 0) {
 		count--;
@@ -1317,7 +1316,7 @@ PHP_FUNCTION(mb_ereg_search_init)
 	if (zend_parse_parameters(argc TSRMLS_CC, ""z|ss"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {
 		return;
 	}
-	
+
 	if (argc > 1 && arg_pattern_len == 0) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty pattern"");
 		RETURN_FALSE;
@@ -1416,7 +1415,7 @@ PHP_FUNCTION(mb_ereg_search_setpos)
 /* }}} */
 
 /* {{{ php_mb_regex_set_options */
-static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) 
+static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)
 {
 	if (prev_options != NULL) {
 		*prev_options = MBREX(regex_default_options);",php-src,5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,e9ac8954be9f7d988189df44578d759ffdea3512,1,"static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionType option, OnigSyntaxType *syntax)
{
	size_t len_left = len;
	size_t len_req = 0;
	char *p = str;
	char c;

	if ((option & ONIG_OPTION_IGNORECASE) != 0) {
		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'i';
 		}
//flaw_line_below:
		++len_req;	
//fix_flaw_line_below:
//		++len_req;
 	}
 
 	if ((option & ONIG_OPTION_EXTEND) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'x';
 		}
//flaw_line_below:
		++len_req;	
//fix_flaw_line_below:
//		++len_req;
 	}
 
 	if ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==
			(ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) {
		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'p';
 		}
//flaw_line_below:
		++len_req;	
//fix_flaw_line_below:
//		++len_req;
 	} else {
 		if ((option & ONIG_OPTION_MULTILINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 'm';
 			}
//flaw_line_below:
			++len_req;	
//fix_flaw_line_below:
//			++len_req;
 		}
 
 		if ((option & ONIG_OPTION_SINGLELINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 's';
 			}
//flaw_line_below:
			++len_req;	
//fix_flaw_line_below:
//			++len_req;
 		}
//flaw_line_below:
	}	
//fix_flaw_line_below:
//	}
 	if ((option & ONIG_OPTION_FIND_LONGEST) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'l';
 		}
//flaw_line_below:
		++len_req;	
//fix_flaw_line_below:
//		++len_req;
 	}
 	if ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'n';
 		}
//flaw_line_below:
		++len_req;	
//fix_flaw_line_below:
//		++len_req;
 	}
 
 	c = 0;

	if (syntax == ONIG_SYNTAX_JAVA) {
		c = 'j';
	} else if (syntax == ONIG_SYNTAX_GNU_REGEX) {
		c = 'u';
	} else if (syntax == ONIG_SYNTAX_GREP) {
		c = 'g';
	} else if (syntax == ONIG_SYNTAX_EMACS) {
		c = 'c';
	} else if (syntax == ONIG_SYNTAX_RUBY) {
		c = 'r';
	} else if (syntax == ONIG_SYNTAX_PERL) {
		c = 'z';
	} else if (syntax == ONIG_SYNTAX_POSIX_BASIC) {
		c = 'b';
	} else if (syntax == ONIG_SYNTAX_POSIX_EXTENDED) {
		c = 'd';
	}

	if (c != 0) {
		if (len_left > 0) {
			--len_left;
			*(p++) = c;
		}
		++len_req;
	}


	if (len_left > 0) {
 		--len_left;
 		*(p++) = '\0';
 	}
//flaw_line_below:
	++len_req;	
//fix_flaw_line_below:
//	++len_req;
 	if (len < len_req) {
 		return len_req;
 	}

	return 0;
}
"
2555,180291,,Remote,Not required,Partial,CVE-2016-5768,https://www.cvedetails.com/cve/CVE-2016-5768/,CWE-415,Low,Partial,Partial,,2016-08-07,7.5,"Double free vulnerability in the _php_mb_regex_ereg_replace_exec function in php_mbregex.c in the mbstring extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to execute arbitrary code or cause a denial of service (application crash) by leveraging a callback exception.",2018-01-04,DoS Exec Code ,1,https://github.com/php/php-src/commit/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,Fix bug #72402: _php_mb_regex_ereg_replace_exec - double free,0,ext/mbstring/php_mbregex.c,"{""sha"": ""6cdee23c3e5999b467c4a206bf3f4827ebe121f6"", ""filename"": ""ext/mbstring/php_mbregex.c"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 33, ""changes"": 65, ""blob_url"": ""https://github.com/php/php-src/blob/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/php_mbregex.c"", ""raw_url"": ""https://github.com/php/php-src/raw/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/php_mbregex.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/mbstring/php_mbregex.c?ref=5b597a2e5b28e2d5a52fc1be13f425f08f47cb62"", ""patch"": ""@@ -32,7 +32,7 @@\n #include \""ext/standard/info.h\""\n #include \""php_mbregex.h\""\n #include \""mbstring.h\""\n- \n+\n #include \""php_onig_compat.h\"" /* must come prior to the oniguruma header */\n #include <oniguruma.h>\n #undef UChar\n@@ -55,7 +55,7 @@ struct _zend_mb_regex_globals {\n #define MBREX(g) (MBSTRG(mb_regex_globals)->g)\n \n /* {{{ static void php_mb_regex_free_cache() */\n-static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n+static void php_mb_regex_free_cache(php_mb_regex_t **pre)\n {\n \tonig_free(*pre);\n }\n@@ -78,7 +78,7 @@ static int _php_mb_regex_globals_ctor(zend_mb_regex_globals *pglobals TSRMLS_DC)\n /* }}} */\n \n /* {{{ _php_mb_regex_globals_dtor */\n-static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) \n+static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)\n {\n \tzend_hash_destroy(&pglobals->ht_rc);\n }\n@@ -466,7 +466,7 @@ static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patl\n \t\tretval = *rc;\n \t}\n out:\n-\treturn retval; \n+\treturn retval;\n }\n /* }}} */\n \n@@ -483,15 +483,15 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t\t--len_left;\n \t\t\t*(p++) = 'i';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tif ((option & ONIG_OPTION_EXTEND) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'x';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tif ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==\n@@ -500,37 +500,37 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t\t--len_left;\n \t\t\t*(p++) = 'p';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t} else {\n \t\tif ((option & ONIG_OPTION_MULTILINE) != 0) {\n \t\t\tif (len_left > 0) {\n \t\t\t\t--len_left;\n \t\t\t\t*(p++) = 'm';\n \t\t\t}\n-\t\t\t++len_req;\t\n+\t\t\t++len_req;\n \t\t}\n \n \t\tif ((option & ONIG_OPTION_SINGLELINE) != 0) {\n \t\t\tif (len_left > 0) {\n \t\t\t\t--len_left;\n \t\t\t\t*(p++) = 's';\n \t\t\t}\n-\t\t\t++len_req;\t\n+\t\t\t++len_req;\n \t\t}\n-\t}\t\n+\t}\n \tif ((option & ONIG_OPTION_FIND_LONGEST) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'l';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \tif ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'n';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tc = 0;\n@@ -566,7 +566,7 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t--len_left;\n \t\t*(p++) = '\\0';\n \t}\n-\t++len_req;\t\n+\t++len_req;\n \tif (len < len_req) {\n \t\treturn len_req;\n \t}\n@@ -577,11 +577,11 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \n /* {{{ _php_mb_regex_init_options */\n static void\n-_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) \n+_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)\n {\n \tint n;\n \tchar c;\n-\tint optm = 0; \n+\tint optm = 0;\n \n \t*syntax = ONIG_SYNTAX_RUBY;\n \n@@ -636,13 +636,13 @@ _php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, O\n \t\t\t\t\t*syntax = ONIG_SYNTAX_POSIX_EXTENDED;\n \t\t\t\t\tbreak;\n \t\t\t\tcase 'e':\n-\t\t\t\t\tif (eval != NULL) *eval = 1; \n+\t\t\t\t\tif (eval != NULL) *eval = 1;\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n-\t\tif (option != NULL) *option|=optm; \n+\t\tif (option != NULL) *option|=optm;\n \t}\n }\n /* }}} */\n@@ -860,11 +860,11 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t} else {\n \t\t/* FIXME: this code is not multibyte aware! */\n \t\tconvert_to_long_ex(arg_pattern_zval);\n-\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\t\n+\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\n \t\tpat_buf[1] = '\\0';\n \n \t\targ_pattern = pat_buf;\n-\t\targ_pattern_len = 1;\t\n+\t\targ_pattern_len = 1;\n \t}\n \t/* create regex pattern buffer */\n \tre = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);\n@@ -934,7 +934,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\t\t\n+\n \t\t\tif (eval) {\n \t\t\t\tzval v;\n \t\t\t\t/* null terminate buffer */\n@@ -953,32 +953,31 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\teval_buf.len = 0;\n \t\t\t\tzval_dtor(&v);\n \t\t\t} else if (is_callable) {\n-\t\t\t\tzval *retval_ptr;\n+\t\t\t\tzval *retval_ptr = NULL;\n \t\t\t\tzval **args[1];\n \t\t\t\tzval *subpats;\n \t\t\t\tint i;\n-\t\t\t\t\n+\n \t\t\t\tMAKE_STD_ZVAL(subpats);\n \t\t\t\tarray_init(subpats);\n-\t\t\t\t\n+\n \t\t\t\tfor (i = 0; i < regs->num_regs; i++) {\n \t\t\t\t\tadd_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);\n-\t\t\t\t}\t\t\t\t\n-\t\t\t\t\n+\t\t\t\t}\n+\n \t\t\t\targs[0] = &subpats;\n \t\t\t\t/* null terminate buffer */\n \t\t\t\tsmart_str_0(&eval_buf);\n-\t\t\t\t\n+\n \t\t\t\targ_replace_fci.param_count = 1;\n \t\t\t\targ_replace_fci.params = args;\n \t\t\t\targ_replace_fci.retval_ptr_ptr = &retval_ptr;\n-\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {\n+\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {\n \t\t\t\t\tconvert_to_string_ex(&retval_ptr);\n \t\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));\n \t\t\t\t\teval_buf.len = 0;\n \t\t\t\t\tzval_ptr_dtor(&retval_ptr);\n \t\t\t\t} else {\n-\t\t\t\t\tefree(description);\n \t\t\t\t\tif (!EG(exception)) {\n \t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to call custom replacement function\"");\n \t\t\t\t\t}\n@@ -991,7 +990,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\tpos = (OnigUChar *)string + n;\n \t\t\t} else {\n \t\t\t\tif (pos < string_lim) {\n-\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1); \n+\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1);\n \t\t\t\t}\n \t\t\t\tpos++;\n \t\t\t}\n@@ -1013,7 +1012,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \tsmart_str_free(&eval_buf);\n \n \tif (err <= -2) {\n-\t\tsmart_str_free(&out_buf);\t\n+\t\tsmart_str_free(&out_buf);\n \t\tRETVAL_FALSE;\n \t} else {\n \t\tsmart_str_appendc(&out_buf, '\\0');\n@@ -1063,7 +1062,7 @@ PHP_FUNCTION(mb_split)\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""ss|l\"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {\n \t\tRETURN_FALSE;\n-\t} \n+\t}\n \n \tif (count > 0) {\n \t\tcount--;\n@@ -1317,7 +1316,7 @@ PHP_FUNCTION(mb_ereg_search_init)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \""z|ss\"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc > 1 && arg_pattern_len == 0) {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Empty pattern\"");\n \t\tRETURN_FALSE;\n@@ -1416,7 +1415,7 @@ PHP_FUNCTION(mb_ereg_search_setpos)\n /* }}} */\n \n /* {{{ php_mb_regex_set_options */\n-static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) \n+static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)\n {\n \tif (prev_options != NULL) {\n \t\t*prev_options = MBREX(regex_default_options);""}<_**next**_>{""sha"": ""abb290bf4d8706ea51ecefd7ea68da62b4194f5d"", ""filename"": ""ext/mbstring/tests/bug72402.phpt"", ""status"": ""added"", ""additions"": 17, ""deletions"": 0, ""changes"": 17, ""blob_url"": ""https://github.com/php/php-src/blob/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/tests/bug72402.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/tests/bug72402.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/mbstring/tests/bug72402.phpt?ref=5b597a2e5b28e2d5a52fc1be13f425f08f47cb62"", ""patch"": ""@@ -0,0 +1,17 @@\n+--TEST--\n+Bug #72402: _php_mb_regex_ereg_replace_exec - double free\n+--SKIPIF--\n+<?php extension_loaded('mbstring') or die('skip mbstring not available'); ?>\n+--FILE--\n+<?php\n+function throwit() {\n+\tthrow new Exception('it');\n+}\n+$var10 = \""throwit\"";\n+try {\n+\t$var14 = mb_ereg_replace_callback(\""\"", $var10, \""\"");\n+} catch(Exception $e) {}\n+?>\n+DONE\n+--EXPECT--\n+DONE\n\\ No newline at end of file""}","static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) 
static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)
 {
 	zend_hash_destroy(&pglobals->ht_rc);
 }
","static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) 
 {
 	zend_hash_destroy(&pglobals->ht_rc);
 }
",C,"static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)
",,,"@@ -32,7 +32,7 @@
 #include ""ext/standard/info.h""
 #include ""php_mbregex.h""
 #include ""mbstring.h""
- 
+
 #include ""php_onig_compat.h"" /* must come prior to the oniguruma header */
 #include <oniguruma.h>
 #undef UChar
@@ -55,7 +55,7 @@ struct _zend_mb_regex_globals {
 #define MBREX(g) (MBSTRG(mb_regex_globals)->g)
 
 /* {{{ static void php_mb_regex_free_cache() */
-static void php_mb_regex_free_cache(php_mb_regex_t **pre) 
+static void php_mb_regex_free_cache(php_mb_regex_t **pre)
 {
 	onig_free(*pre);
 }
@@ -78,7 +78,7 @@ static int _php_mb_regex_globals_ctor(zend_mb_regex_globals *pglobals TSRMLS_DC)
 /* }}} */
 
 /* {{{ _php_mb_regex_globals_dtor */
-static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) 
+static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)
 {
 	zend_hash_destroy(&pglobals->ht_rc);
 }
@@ -466,7 +466,7 @@ static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patl
 		retval = *rc;
 	}
 out:
-	return retval; 
+	return retval;
 }
 /* }}} */
 
@@ -483,15 +483,15 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 			--len_left;
 			*(p++) = 'i';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	if ((option & ONIG_OPTION_EXTEND) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'x';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	if ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==
@@ -500,37 +500,37 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 			--len_left;
 			*(p++) = 'p';
 		}
-		++len_req;	
+		++len_req;
 	} else {
 		if ((option & ONIG_OPTION_MULTILINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 'm';
 			}
-			++len_req;	
+			++len_req;
 		}
 
 		if ((option & ONIG_OPTION_SINGLELINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 's';
 			}
-			++len_req;	
+			++len_req;
 		}
-	}	
+	}
 	if ((option & ONIG_OPTION_FIND_LONGEST) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'l';
 		}
-		++len_req;	
+		++len_req;
 	}
 	if ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'n';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	c = 0;
@@ -566,7 +566,7 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 		--len_left;
 		*(p++) = '\0';
 	}
-	++len_req;	
+	++len_req;
 	if (len < len_req) {
 		return len_req;
 	}
@@ -577,11 +577,11 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 
 /* {{{ _php_mb_regex_init_options */
 static void
-_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) 
+_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)
 {
 	int n;
 	char c;
-	int optm = 0; 
+	int optm = 0;
 
 	*syntax = ONIG_SYNTAX_RUBY;
 
@@ -636,13 +636,13 @@ _php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, O
 					*syntax = ONIG_SYNTAX_POSIX_EXTENDED;
 					break;
 				case 'e':
-					if (eval != NULL) *eval = 1; 
+					if (eval != NULL) *eval = 1;
 					break;
 				default:
 					break;
 			}
 		}
-		if (option != NULL) *option|=optm; 
+		if (option != NULL) *option|=optm;
 	}
 }
 /* }}} */
@@ -860,11 +860,11 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 	} else {
 		/* FIXME: this code is not multibyte aware! */
 		convert_to_long_ex(arg_pattern_zval);
-		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);	
+		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);
 		pat_buf[1] = '\0';
 
 		arg_pattern = pat_buf;
-		arg_pattern_len = 1;	
+		arg_pattern_len = 1;
 	}
 	/* create regex pattern buffer */
 	re = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);
@@ -934,7 +934,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 					}
 				}
 			}
-				
+
 			if (eval) {
 				zval v;
 				/* null terminate buffer */
@@ -953,32 +953,31 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 				eval_buf.len = 0;
 				zval_dtor(&v);
 			} else if (is_callable) {
-				zval *retval_ptr;
+				zval *retval_ptr = NULL;
 				zval **args[1];
 				zval *subpats;
 				int i;
-				
+
 				MAKE_STD_ZVAL(subpats);
 				array_init(subpats);
-				
+
 				for (i = 0; i < regs->num_regs; i++) {
 					add_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);
-				}				
-				
+				}
+
 				args[0] = &subpats;
 				/* null terminate buffer */
 				smart_str_0(&eval_buf);
-				
+
 				arg_replace_fci.param_count = 1;
 				arg_replace_fci.params = args;
 				arg_replace_fci.retval_ptr_ptr = &retval_ptr;
-				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {
+				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {
 					convert_to_string_ex(&retval_ptr);
 					smart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));
 					eval_buf.len = 0;
 					zval_ptr_dtor(&retval_ptr);
 				} else {
-					efree(description);
 					if (!EG(exception)) {
 						php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call custom replacement function"");
 					}
@@ -991,7 +990,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 				pos = (OnigUChar *)string + n;
 			} else {
 				if (pos < string_lim) {
-					smart_str_appendl(&out_buf, pos, 1); 
+					smart_str_appendl(&out_buf, pos, 1);
 				}
 				pos++;
 			}
@@ -1013,7 +1012,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 	smart_str_free(&eval_buf);
 
 	if (err <= -2) {
-		smart_str_free(&out_buf);	
+		smart_str_free(&out_buf);
 		RETVAL_FALSE;
 	} else {
 		smart_str_appendc(&out_buf, '\0');
@@ -1063,7 +1062,7 @@ PHP_FUNCTION(mb_split)
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|l"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {
 		RETURN_FALSE;
-	} 
+	}
 
 	if (count > 0) {
 		count--;
@@ -1317,7 +1316,7 @@ PHP_FUNCTION(mb_ereg_search_init)
 	if (zend_parse_parameters(argc TSRMLS_CC, ""z|ss"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {
 		return;
 	}
-	
+
 	if (argc > 1 && arg_pattern_len == 0) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty pattern"");
 		RETURN_FALSE;
@@ -1416,7 +1415,7 @@ PHP_FUNCTION(mb_ereg_search_setpos)
 /* }}} */
 
 /* {{{ php_mb_regex_set_options */
-static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) 
+static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)
 {
 	if (prev_options != NULL) {
 		*prev_options = MBREX(regex_default_options);",php-src,5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,e9ac8954be9f7d988189df44578d759ffdea3512,1,"static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) 
//fix_flaw_line_below:
//static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)
 {
 	zend_hash_destroy(&pglobals->ht_rc);
 }
"
2556,180292,,Remote,Not required,Partial,CVE-2016-5768,https://www.cvedetails.com/cve/CVE-2016-5768/,CWE-415,Low,Partial,Partial,,2016-08-07,7.5,"Double free vulnerability in the _php_mb_regex_ereg_replace_exec function in php_mbregex.c in the mbstring extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to execute arbitrary code or cause a denial of service (application crash) by leveraging a callback exception.",2018-01-04,DoS Exec Code ,4,https://github.com/php/php-src/commit/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,Fix bug #72402: _php_mb_regex_ereg_replace_exec - double free,3,ext/mbstring/php_mbregex.c,"{""sha"": ""6cdee23c3e5999b467c4a206bf3f4827ebe121f6"", ""filename"": ""ext/mbstring/php_mbregex.c"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 33, ""changes"": 65, ""blob_url"": ""https://github.com/php/php-src/blob/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/php_mbregex.c"", ""raw_url"": ""https://github.com/php/php-src/raw/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/php_mbregex.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/mbstring/php_mbregex.c?ref=5b597a2e5b28e2d5a52fc1be13f425f08f47cb62"", ""patch"": ""@@ -32,7 +32,7 @@\n #include \""ext/standard/info.h\""\n #include \""php_mbregex.h\""\n #include \""mbstring.h\""\n- \n+\n #include \""php_onig_compat.h\"" /* must come prior to the oniguruma header */\n #include <oniguruma.h>\n #undef UChar\n@@ -55,7 +55,7 @@ struct _zend_mb_regex_globals {\n #define MBREX(g) (MBSTRG(mb_regex_globals)->g)\n \n /* {{{ static void php_mb_regex_free_cache() */\n-static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n+static void php_mb_regex_free_cache(php_mb_regex_t **pre)\n {\n \tonig_free(*pre);\n }\n@@ -78,7 +78,7 @@ static int _php_mb_regex_globals_ctor(zend_mb_regex_globals *pglobals TSRMLS_DC)\n /* }}} */\n \n /* {{{ _php_mb_regex_globals_dtor */\n-static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) \n+static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)\n {\n \tzend_hash_destroy(&pglobals->ht_rc);\n }\n@@ -466,7 +466,7 @@ static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patl\n \t\tretval = *rc;\n \t}\n out:\n-\treturn retval; \n+\treturn retval;\n }\n /* }}} */\n \n@@ -483,15 +483,15 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t\t--len_left;\n \t\t\t*(p++) = 'i';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tif ((option & ONIG_OPTION_EXTEND) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'x';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tif ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==\n@@ -500,37 +500,37 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t\t--len_left;\n \t\t\t*(p++) = 'p';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t} else {\n \t\tif ((option & ONIG_OPTION_MULTILINE) != 0) {\n \t\t\tif (len_left > 0) {\n \t\t\t\t--len_left;\n \t\t\t\t*(p++) = 'm';\n \t\t\t}\n-\t\t\t++len_req;\t\n+\t\t\t++len_req;\n \t\t}\n \n \t\tif ((option & ONIG_OPTION_SINGLELINE) != 0) {\n \t\t\tif (len_left > 0) {\n \t\t\t\t--len_left;\n \t\t\t\t*(p++) = 's';\n \t\t\t}\n-\t\t\t++len_req;\t\n+\t\t\t++len_req;\n \t\t}\n-\t}\t\n+\t}\n \tif ((option & ONIG_OPTION_FIND_LONGEST) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'l';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \tif ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'n';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tc = 0;\n@@ -566,7 +566,7 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t--len_left;\n \t\t*(p++) = '\\0';\n \t}\n-\t++len_req;\t\n+\t++len_req;\n \tif (len < len_req) {\n \t\treturn len_req;\n \t}\n@@ -577,11 +577,11 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \n /* {{{ _php_mb_regex_init_options */\n static void\n-_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) \n+_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)\n {\n \tint n;\n \tchar c;\n-\tint optm = 0; \n+\tint optm = 0;\n \n \t*syntax = ONIG_SYNTAX_RUBY;\n \n@@ -636,13 +636,13 @@ _php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, O\n \t\t\t\t\t*syntax = ONIG_SYNTAX_POSIX_EXTENDED;\n \t\t\t\t\tbreak;\n \t\t\t\tcase 'e':\n-\t\t\t\t\tif (eval != NULL) *eval = 1; \n+\t\t\t\t\tif (eval != NULL) *eval = 1;\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n-\t\tif (option != NULL) *option|=optm; \n+\t\tif (option != NULL) *option|=optm;\n \t}\n }\n /* }}} */\n@@ -860,11 +860,11 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t} else {\n \t\t/* FIXME: this code is not multibyte aware! */\n \t\tconvert_to_long_ex(arg_pattern_zval);\n-\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\t\n+\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\n \t\tpat_buf[1] = '\\0';\n \n \t\targ_pattern = pat_buf;\n-\t\targ_pattern_len = 1;\t\n+\t\targ_pattern_len = 1;\n \t}\n \t/* create regex pattern buffer */\n \tre = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);\n@@ -934,7 +934,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\t\t\n+\n \t\t\tif (eval) {\n \t\t\t\tzval v;\n \t\t\t\t/* null terminate buffer */\n@@ -953,32 +953,31 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\teval_buf.len = 0;\n \t\t\t\tzval_dtor(&v);\n \t\t\t} else if (is_callable) {\n-\t\t\t\tzval *retval_ptr;\n+\t\t\t\tzval *retval_ptr = NULL;\n \t\t\t\tzval **args[1];\n \t\t\t\tzval *subpats;\n \t\t\t\tint i;\n-\t\t\t\t\n+\n \t\t\t\tMAKE_STD_ZVAL(subpats);\n \t\t\t\tarray_init(subpats);\n-\t\t\t\t\n+\n \t\t\t\tfor (i = 0; i < regs->num_regs; i++) {\n \t\t\t\t\tadd_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);\n-\t\t\t\t}\t\t\t\t\n-\t\t\t\t\n+\t\t\t\t}\n+\n \t\t\t\targs[0] = &subpats;\n \t\t\t\t/* null terminate buffer */\n \t\t\t\tsmart_str_0(&eval_buf);\n-\t\t\t\t\n+\n \t\t\t\targ_replace_fci.param_count = 1;\n \t\t\t\targ_replace_fci.params = args;\n \t\t\t\targ_replace_fci.retval_ptr_ptr = &retval_ptr;\n-\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {\n+\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {\n \t\t\t\t\tconvert_to_string_ex(&retval_ptr);\n \t\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));\n \t\t\t\t\teval_buf.len = 0;\n \t\t\t\t\tzval_ptr_dtor(&retval_ptr);\n \t\t\t\t} else {\n-\t\t\t\t\tefree(description);\n \t\t\t\t\tif (!EG(exception)) {\n \t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to call custom replacement function\"");\n \t\t\t\t\t}\n@@ -991,7 +990,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\tpos = (OnigUChar *)string + n;\n \t\t\t} else {\n \t\t\t\tif (pos < string_lim) {\n-\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1); \n+\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1);\n \t\t\t\t}\n \t\t\t\tpos++;\n \t\t\t}\n@@ -1013,7 +1012,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \tsmart_str_free(&eval_buf);\n \n \tif (err <= -2) {\n-\t\tsmart_str_free(&out_buf);\t\n+\t\tsmart_str_free(&out_buf);\n \t\tRETVAL_FALSE;\n \t} else {\n \t\tsmart_str_appendc(&out_buf, '\\0');\n@@ -1063,7 +1062,7 @@ PHP_FUNCTION(mb_split)\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""ss|l\"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {\n \t\tRETURN_FALSE;\n-\t} \n+\t}\n \n \tif (count > 0) {\n \t\tcount--;\n@@ -1317,7 +1316,7 @@ PHP_FUNCTION(mb_ereg_search_init)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \""z|ss\"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc > 1 && arg_pattern_len == 0) {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Empty pattern\"");\n \t\tRETURN_FALSE;\n@@ -1416,7 +1415,7 @@ PHP_FUNCTION(mb_ereg_search_setpos)\n /* }}} */\n \n /* {{{ php_mb_regex_set_options */\n-static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) \n+static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)\n {\n \tif (prev_options != NULL) {\n \t\t*prev_options = MBREX(regex_default_options);""}<_**next**_>{""sha"": ""abb290bf4d8706ea51ecefd7ea68da62b4194f5d"", ""filename"": ""ext/mbstring/tests/bug72402.phpt"", ""status"": ""added"", ""additions"": 17, ""deletions"": 0, ""changes"": 17, ""blob_url"": ""https://github.com/php/php-src/blob/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/tests/bug72402.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/tests/bug72402.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/mbstring/tests/bug72402.phpt?ref=5b597a2e5b28e2d5a52fc1be13f425f08f47cb62"", ""patch"": ""@@ -0,0 +1,17 @@\n+--TEST--\n+Bug #72402: _php_mb_regex_ereg_replace_exec - double free\n+--SKIPIF--\n+<?php extension_loaded('mbstring') or die('skip mbstring not available'); ?>\n+--FILE--\n+<?php\n+function throwit() {\n+\tthrow new Exception('it');\n+}\n+$var10 = \""throwit\"";\n+try {\n+\t$var14 = mb_ereg_replace_callback(\""\"", $var10, \""\"");\n+} catch(Exception $e) {}\n+?>\n+DONE\n+--EXPECT--\n+DONE\n\\ No newline at end of file""}","_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) 
_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)
 {
 	int n;
 	char c;
	int optm = 0;
 
 	*syntax = ONIG_SYNTAX_RUBY;
 
	if (parg != NULL) {
		n = 0;
		while(n < narg) {
			c = parg[n++];
			switch (c) {
				case 'i':
					optm |= ONIG_OPTION_IGNORECASE;
					break;
				case 'x':
					optm |= ONIG_OPTION_EXTEND;
					break;
				case 'm':
					optm |= ONIG_OPTION_MULTILINE;
					break;
				case 's':
					optm |= ONIG_OPTION_SINGLELINE;
					break;
				case 'p':
					optm |= ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE;
					break;
				case 'l':
					optm |= ONIG_OPTION_FIND_LONGEST;
					break;
				case 'n':
					optm |= ONIG_OPTION_FIND_NOT_EMPTY;
					break;
				case 'j':
					*syntax = ONIG_SYNTAX_JAVA;
					break;
				case 'u':
					*syntax = ONIG_SYNTAX_GNU_REGEX;
					break;
				case 'g':
					*syntax = ONIG_SYNTAX_GREP;
					break;
				case 'c':
					*syntax = ONIG_SYNTAX_EMACS;
					break;
				case 'r':
					*syntax = ONIG_SYNTAX_RUBY;
					break;
				case 'z':
					*syntax = ONIG_SYNTAX_PERL;
					break;
				case 'b':
					*syntax = ONIG_SYNTAX_POSIX_BASIC;
					break;
				case 'd':
 					*syntax = ONIG_SYNTAX_POSIX_EXTENDED;
 					break;
 				case 'e':
					if (eval != NULL) *eval = 1;
 					break;
 				default:
 					break;
 			}
 		}
		if (option != NULL) *option|=optm;
 	}
 }
","_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) 
 {
 	int n;
 	char c;
	int optm = 0; 
 
 	*syntax = ONIG_SYNTAX_RUBY;
 
	if (parg != NULL) {
		n = 0;
		while(n < narg) {
			c = parg[n++];
			switch (c) {
				case 'i':
					optm |= ONIG_OPTION_IGNORECASE;
					break;
				case 'x':
					optm |= ONIG_OPTION_EXTEND;
					break;
				case 'm':
					optm |= ONIG_OPTION_MULTILINE;
					break;
				case 's':
					optm |= ONIG_OPTION_SINGLELINE;
					break;
				case 'p':
					optm |= ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE;
					break;
				case 'l':
					optm |= ONIG_OPTION_FIND_LONGEST;
					break;
				case 'n':
					optm |= ONIG_OPTION_FIND_NOT_EMPTY;
					break;
				case 'j':
					*syntax = ONIG_SYNTAX_JAVA;
					break;
				case 'u':
					*syntax = ONIG_SYNTAX_GNU_REGEX;
					break;
				case 'g':
					*syntax = ONIG_SYNTAX_GREP;
					break;
				case 'c':
					*syntax = ONIG_SYNTAX_EMACS;
					break;
				case 'r':
					*syntax = ONIG_SYNTAX_RUBY;
					break;
				case 'z':
					*syntax = ONIG_SYNTAX_PERL;
					break;
				case 'b':
					*syntax = ONIG_SYNTAX_POSIX_BASIC;
					break;
				case 'd':
 					*syntax = ONIG_SYNTAX_POSIX_EXTENDED;
 					break;
 				case 'e':
					if (eval != NULL) *eval = 1; 
 					break;
 				default:
 					break;
 			}
 		}
		if (option != NULL) *option|=optm; 
 	}
 }
",C,"_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)
	int optm = 0;
					if (eval != NULL) *eval = 1;
		if (option != NULL) *option|=optm;
","	int optm = 0; 
					if (eval != NULL) *eval = 1; 
		if (option != NULL) *option|=optm; 
",,"@@ -32,7 +32,7 @@
 #include ""ext/standard/info.h""
 #include ""php_mbregex.h""
 #include ""mbstring.h""
- 
+
 #include ""php_onig_compat.h"" /* must come prior to the oniguruma header */
 #include <oniguruma.h>
 #undef UChar
@@ -55,7 +55,7 @@ struct _zend_mb_regex_globals {
 #define MBREX(g) (MBSTRG(mb_regex_globals)->g)
 
 /* {{{ static void php_mb_regex_free_cache() */
-static void php_mb_regex_free_cache(php_mb_regex_t **pre) 
+static void php_mb_regex_free_cache(php_mb_regex_t **pre)
 {
 	onig_free(*pre);
 }
@@ -78,7 +78,7 @@ static int _php_mb_regex_globals_ctor(zend_mb_regex_globals *pglobals TSRMLS_DC)
 /* }}} */
 
 /* {{{ _php_mb_regex_globals_dtor */
-static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) 
+static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)
 {
 	zend_hash_destroy(&pglobals->ht_rc);
 }
@@ -466,7 +466,7 @@ static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patl
 		retval = *rc;
 	}
 out:
-	return retval; 
+	return retval;
 }
 /* }}} */
 
@@ -483,15 +483,15 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 			--len_left;
 			*(p++) = 'i';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	if ((option & ONIG_OPTION_EXTEND) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'x';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	if ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==
@@ -500,37 +500,37 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 			--len_left;
 			*(p++) = 'p';
 		}
-		++len_req;	
+		++len_req;
 	} else {
 		if ((option & ONIG_OPTION_MULTILINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 'm';
 			}
-			++len_req;	
+			++len_req;
 		}
 
 		if ((option & ONIG_OPTION_SINGLELINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 's';
 			}
-			++len_req;	
+			++len_req;
 		}
-	}	
+	}
 	if ((option & ONIG_OPTION_FIND_LONGEST) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'l';
 		}
-		++len_req;	
+		++len_req;
 	}
 	if ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'n';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	c = 0;
@@ -566,7 +566,7 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 		--len_left;
 		*(p++) = '\0';
 	}
-	++len_req;	
+	++len_req;
 	if (len < len_req) {
 		return len_req;
 	}
@@ -577,11 +577,11 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 
 /* {{{ _php_mb_regex_init_options */
 static void
-_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) 
+_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)
 {
 	int n;
 	char c;
-	int optm = 0; 
+	int optm = 0;
 
 	*syntax = ONIG_SYNTAX_RUBY;
 
@@ -636,13 +636,13 @@ _php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, O
 					*syntax = ONIG_SYNTAX_POSIX_EXTENDED;
 					break;
 				case 'e':
-					if (eval != NULL) *eval = 1; 
+					if (eval != NULL) *eval = 1;
 					break;
 				default:
 					break;
 			}
 		}
-		if (option != NULL) *option|=optm; 
+		if (option != NULL) *option|=optm;
 	}
 }
 /* }}} */
@@ -860,11 +860,11 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 	} else {
 		/* FIXME: this code is not multibyte aware! */
 		convert_to_long_ex(arg_pattern_zval);
-		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);	
+		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);
 		pat_buf[1] = '\0';
 
 		arg_pattern = pat_buf;
-		arg_pattern_len = 1;	
+		arg_pattern_len = 1;
 	}
 	/* create regex pattern buffer */
 	re = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);
@@ -934,7 +934,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 					}
 				}
 			}
-				
+
 			if (eval) {
 				zval v;
 				/* null terminate buffer */
@@ -953,32 +953,31 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 				eval_buf.len = 0;
 				zval_dtor(&v);
 			} else if (is_callable) {
-				zval *retval_ptr;
+				zval *retval_ptr = NULL;
 				zval **args[1];
 				zval *subpats;
 				int i;
-				
+
 				MAKE_STD_ZVAL(subpats);
 				array_init(subpats);
-				
+
 				for (i = 0; i < regs->num_regs; i++) {
 					add_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);
-				}				
-				
+				}
+
 				args[0] = &subpats;
 				/* null terminate buffer */
 				smart_str_0(&eval_buf);
-				
+
 				arg_replace_fci.param_count = 1;
 				arg_replace_fci.params = args;
 				arg_replace_fci.retval_ptr_ptr = &retval_ptr;
-				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {
+				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {
 					convert_to_string_ex(&retval_ptr);
 					smart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));
 					eval_buf.len = 0;
 					zval_ptr_dtor(&retval_ptr);
 				} else {
-					efree(description);
 					if (!EG(exception)) {
 						php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call custom replacement function"");
 					}
@@ -991,7 +990,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 				pos = (OnigUChar *)string + n;
 			} else {
 				if (pos < string_lim) {
-					smart_str_appendl(&out_buf, pos, 1); 
+					smart_str_appendl(&out_buf, pos, 1);
 				}
 				pos++;
 			}
@@ -1013,7 +1012,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 	smart_str_free(&eval_buf);
 
 	if (err <= -2) {
-		smart_str_free(&out_buf);	
+		smart_str_free(&out_buf);
 		RETVAL_FALSE;
 	} else {
 		smart_str_appendc(&out_buf, '\0');
@@ -1063,7 +1062,7 @@ PHP_FUNCTION(mb_split)
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|l"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {
 		RETURN_FALSE;
-	} 
+	}
 
 	if (count > 0) {
 		count--;
@@ -1317,7 +1316,7 @@ PHP_FUNCTION(mb_ereg_search_init)
 	if (zend_parse_parameters(argc TSRMLS_CC, ""z|ss"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {
 		return;
 	}
-	
+
 	if (argc > 1 && arg_pattern_len == 0) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty pattern"");
 		RETURN_FALSE;
@@ -1416,7 +1415,7 @@ PHP_FUNCTION(mb_ereg_search_setpos)
 /* }}} */
 
 /* {{{ php_mb_regex_set_options */
-static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) 
+static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)
 {
 	if (prev_options != NULL) {
 		*prev_options = MBREX(regex_default_options);",php-src,5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,e9ac8954be9f7d988189df44578d759ffdea3512,1,"_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) 
//fix_flaw_line_below:
//_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)
 {
 	int n;
 	char c;
//flaw_line_below:
	int optm = 0; 
//fix_flaw_line_below:
//	int optm = 0;
 
 	*syntax = ONIG_SYNTAX_RUBY;
 
	if (parg != NULL) {
		n = 0;
		while(n < narg) {
			c = parg[n++];
			switch (c) {
				case 'i':
					optm |= ONIG_OPTION_IGNORECASE;
					break;
				case 'x':
					optm |= ONIG_OPTION_EXTEND;
					break;
				case 'm':
					optm |= ONIG_OPTION_MULTILINE;
					break;
				case 's':
					optm |= ONIG_OPTION_SINGLELINE;
					break;
				case 'p':
					optm |= ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE;
					break;
				case 'l':
					optm |= ONIG_OPTION_FIND_LONGEST;
					break;
				case 'n':
					optm |= ONIG_OPTION_FIND_NOT_EMPTY;
					break;
				case 'j':
					*syntax = ONIG_SYNTAX_JAVA;
					break;
				case 'u':
					*syntax = ONIG_SYNTAX_GNU_REGEX;
					break;
				case 'g':
					*syntax = ONIG_SYNTAX_GREP;
					break;
				case 'c':
					*syntax = ONIG_SYNTAX_EMACS;
					break;
				case 'r':
					*syntax = ONIG_SYNTAX_RUBY;
					break;
				case 'z':
					*syntax = ONIG_SYNTAX_PERL;
					break;
				case 'b':
					*syntax = ONIG_SYNTAX_POSIX_BASIC;
					break;
				case 'd':
 					*syntax = ONIG_SYNTAX_POSIX_EXTENDED;
 					break;
 				case 'e':
//flaw_line_below:
					if (eval != NULL) *eval = 1; 
//fix_flaw_line_below:
//					if (eval != NULL) *eval = 1;
 					break;
 				default:
 					break;
 			}
 		}
//flaw_line_below:
		if (option != NULL) *option|=optm; 
//fix_flaw_line_below:
//		if (option != NULL) *option|=optm;
 	}
 }
"
2557,180293,,Remote,Not required,Partial,CVE-2016-5768,https://www.cvedetails.com/cve/CVE-2016-5768/,CWE-415,Low,Partial,Partial,,2016-08-07,7.5,"Double free vulnerability in the _php_mb_regex_ereg_replace_exec function in php_mbregex.c in the mbstring extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to execute arbitrary code or cause a denial of service (application crash) by leveraging a callback exception.",2018-01-04,DoS Exec Code ,1,https://github.com/php/php-src/commit/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,Fix bug #72402: _php_mb_regex_ereg_replace_exec - double free,0,ext/mbstring/php_mbregex.c,"{""sha"": ""6cdee23c3e5999b467c4a206bf3f4827ebe121f6"", ""filename"": ""ext/mbstring/php_mbregex.c"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 33, ""changes"": 65, ""blob_url"": ""https://github.com/php/php-src/blob/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/php_mbregex.c"", ""raw_url"": ""https://github.com/php/php-src/raw/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/php_mbregex.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/mbstring/php_mbregex.c?ref=5b597a2e5b28e2d5a52fc1be13f425f08f47cb62"", ""patch"": ""@@ -32,7 +32,7 @@\n #include \""ext/standard/info.h\""\n #include \""php_mbregex.h\""\n #include \""mbstring.h\""\n- \n+\n #include \""php_onig_compat.h\"" /* must come prior to the oniguruma header */\n #include <oniguruma.h>\n #undef UChar\n@@ -55,7 +55,7 @@ struct _zend_mb_regex_globals {\n #define MBREX(g) (MBSTRG(mb_regex_globals)->g)\n \n /* {{{ static void php_mb_regex_free_cache() */\n-static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n+static void php_mb_regex_free_cache(php_mb_regex_t **pre)\n {\n \tonig_free(*pre);\n }\n@@ -78,7 +78,7 @@ static int _php_mb_regex_globals_ctor(zend_mb_regex_globals *pglobals TSRMLS_DC)\n /* }}} */\n \n /* {{{ _php_mb_regex_globals_dtor */\n-static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) \n+static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)\n {\n \tzend_hash_destroy(&pglobals->ht_rc);\n }\n@@ -466,7 +466,7 @@ static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patl\n \t\tretval = *rc;\n \t}\n out:\n-\treturn retval; \n+\treturn retval;\n }\n /* }}} */\n \n@@ -483,15 +483,15 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t\t--len_left;\n \t\t\t*(p++) = 'i';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tif ((option & ONIG_OPTION_EXTEND) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'x';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tif ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==\n@@ -500,37 +500,37 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t\t--len_left;\n \t\t\t*(p++) = 'p';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t} else {\n \t\tif ((option & ONIG_OPTION_MULTILINE) != 0) {\n \t\t\tif (len_left > 0) {\n \t\t\t\t--len_left;\n \t\t\t\t*(p++) = 'm';\n \t\t\t}\n-\t\t\t++len_req;\t\n+\t\t\t++len_req;\n \t\t}\n \n \t\tif ((option & ONIG_OPTION_SINGLELINE) != 0) {\n \t\t\tif (len_left > 0) {\n \t\t\t\t--len_left;\n \t\t\t\t*(p++) = 's';\n \t\t\t}\n-\t\t\t++len_req;\t\n+\t\t\t++len_req;\n \t\t}\n-\t}\t\n+\t}\n \tif ((option & ONIG_OPTION_FIND_LONGEST) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'l';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \tif ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'n';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tc = 0;\n@@ -566,7 +566,7 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t--len_left;\n \t\t*(p++) = '\\0';\n \t}\n-\t++len_req;\t\n+\t++len_req;\n \tif (len < len_req) {\n \t\treturn len_req;\n \t}\n@@ -577,11 +577,11 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \n /* {{{ _php_mb_regex_init_options */\n static void\n-_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) \n+_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)\n {\n \tint n;\n \tchar c;\n-\tint optm = 0; \n+\tint optm = 0;\n \n \t*syntax = ONIG_SYNTAX_RUBY;\n \n@@ -636,13 +636,13 @@ _php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, O\n \t\t\t\t\t*syntax = ONIG_SYNTAX_POSIX_EXTENDED;\n \t\t\t\t\tbreak;\n \t\t\t\tcase 'e':\n-\t\t\t\t\tif (eval != NULL) *eval = 1; \n+\t\t\t\t\tif (eval != NULL) *eval = 1;\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n-\t\tif (option != NULL) *option|=optm; \n+\t\tif (option != NULL) *option|=optm;\n \t}\n }\n /* }}} */\n@@ -860,11 +860,11 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t} else {\n \t\t/* FIXME: this code is not multibyte aware! */\n \t\tconvert_to_long_ex(arg_pattern_zval);\n-\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\t\n+\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\n \t\tpat_buf[1] = '\\0';\n \n \t\targ_pattern = pat_buf;\n-\t\targ_pattern_len = 1;\t\n+\t\targ_pattern_len = 1;\n \t}\n \t/* create regex pattern buffer */\n \tre = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);\n@@ -934,7 +934,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\t\t\n+\n \t\t\tif (eval) {\n \t\t\t\tzval v;\n \t\t\t\t/* null terminate buffer */\n@@ -953,32 +953,31 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\teval_buf.len = 0;\n \t\t\t\tzval_dtor(&v);\n \t\t\t} else if (is_callable) {\n-\t\t\t\tzval *retval_ptr;\n+\t\t\t\tzval *retval_ptr = NULL;\n \t\t\t\tzval **args[1];\n \t\t\t\tzval *subpats;\n \t\t\t\tint i;\n-\t\t\t\t\n+\n \t\t\t\tMAKE_STD_ZVAL(subpats);\n \t\t\t\tarray_init(subpats);\n-\t\t\t\t\n+\n \t\t\t\tfor (i = 0; i < regs->num_regs; i++) {\n \t\t\t\t\tadd_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);\n-\t\t\t\t}\t\t\t\t\n-\t\t\t\t\n+\t\t\t\t}\n+\n \t\t\t\targs[0] = &subpats;\n \t\t\t\t/* null terminate buffer */\n \t\t\t\tsmart_str_0(&eval_buf);\n-\t\t\t\t\n+\n \t\t\t\targ_replace_fci.param_count = 1;\n \t\t\t\targ_replace_fci.params = args;\n \t\t\t\targ_replace_fci.retval_ptr_ptr = &retval_ptr;\n-\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {\n+\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {\n \t\t\t\t\tconvert_to_string_ex(&retval_ptr);\n \t\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));\n \t\t\t\t\teval_buf.len = 0;\n \t\t\t\t\tzval_ptr_dtor(&retval_ptr);\n \t\t\t\t} else {\n-\t\t\t\t\tefree(description);\n \t\t\t\t\tif (!EG(exception)) {\n \t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to call custom replacement function\"");\n \t\t\t\t\t}\n@@ -991,7 +990,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\tpos = (OnigUChar *)string + n;\n \t\t\t} else {\n \t\t\t\tif (pos < string_lim) {\n-\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1); \n+\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1);\n \t\t\t\t}\n \t\t\t\tpos++;\n \t\t\t}\n@@ -1013,7 +1012,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \tsmart_str_free(&eval_buf);\n \n \tif (err <= -2) {\n-\t\tsmart_str_free(&out_buf);\t\n+\t\tsmart_str_free(&out_buf);\n \t\tRETVAL_FALSE;\n \t} else {\n \t\tsmart_str_appendc(&out_buf, '\\0');\n@@ -1063,7 +1062,7 @@ PHP_FUNCTION(mb_split)\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""ss|l\"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {\n \t\tRETURN_FALSE;\n-\t} \n+\t}\n \n \tif (count > 0) {\n \t\tcount--;\n@@ -1317,7 +1316,7 @@ PHP_FUNCTION(mb_ereg_search_init)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \""z|ss\"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc > 1 && arg_pattern_len == 0) {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Empty pattern\"");\n \t\tRETURN_FALSE;\n@@ -1416,7 +1415,7 @@ PHP_FUNCTION(mb_ereg_search_setpos)\n /* }}} */\n \n /* {{{ php_mb_regex_set_options */\n-static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) \n+static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)\n {\n \tif (prev_options != NULL) {\n \t\t*prev_options = MBREX(regex_default_options);""}<_**next**_>{""sha"": ""abb290bf4d8706ea51ecefd7ea68da62b4194f5d"", ""filename"": ""ext/mbstring/tests/bug72402.phpt"", ""status"": ""added"", ""additions"": 17, ""deletions"": 0, ""changes"": 17, ""blob_url"": ""https://github.com/php/php-src/blob/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/tests/bug72402.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/tests/bug72402.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/mbstring/tests/bug72402.phpt?ref=5b597a2e5b28e2d5a52fc1be13f425f08f47cb62"", ""patch"": ""@@ -0,0 +1,17 @@\n+--TEST--\n+Bug #72402: _php_mb_regex_ereg_replace_exec - double free\n+--SKIPIF--\n+<?php extension_loaded('mbstring') or die('skip mbstring not available'); ?>\n+--FILE--\n+<?php\n+function throwit() {\n+\tthrow new Exception('it');\n+}\n+$var10 = \""throwit\"";\n+try {\n+\t$var14 = mb_ereg_replace_callback(\""\"", $var10, \""\"");\n+} catch(Exception $e) {}\n+?>\n+DONE\n+--EXPECT--\n+DONE\n\\ No newline at end of file""}","static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) 
static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)
 {
 	if (prev_options != NULL) {
 		*prev_options = MBREX(regex_default_options);
	}
	if (prev_syntax != NULL) {
		*prev_syntax = MBREX(regex_default_syntax);
	}
	MBREX(regex_default_options) = options;
	MBREX(regex_default_syntax) = syntax;
}
","static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) 
 {
 	if (prev_options != NULL) {
 		*prev_options = MBREX(regex_default_options);
	}
	if (prev_syntax != NULL) {
		*prev_syntax = MBREX(regex_default_syntax);
	}
	MBREX(regex_default_options) = options;
	MBREX(regex_default_syntax) = syntax;
}
",C,"static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)
",,,"@@ -32,7 +32,7 @@
 #include ""ext/standard/info.h""
 #include ""php_mbregex.h""
 #include ""mbstring.h""
- 
+
 #include ""php_onig_compat.h"" /* must come prior to the oniguruma header */
 #include <oniguruma.h>
 #undef UChar
@@ -55,7 +55,7 @@ struct _zend_mb_regex_globals {
 #define MBREX(g) (MBSTRG(mb_regex_globals)->g)
 
 /* {{{ static void php_mb_regex_free_cache() */
-static void php_mb_regex_free_cache(php_mb_regex_t **pre) 
+static void php_mb_regex_free_cache(php_mb_regex_t **pre)
 {
 	onig_free(*pre);
 }
@@ -78,7 +78,7 @@ static int _php_mb_regex_globals_ctor(zend_mb_regex_globals *pglobals TSRMLS_DC)
 /* }}} */
 
 /* {{{ _php_mb_regex_globals_dtor */
-static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) 
+static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)
 {
 	zend_hash_destroy(&pglobals->ht_rc);
 }
@@ -466,7 +466,7 @@ static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patl
 		retval = *rc;
 	}
 out:
-	return retval; 
+	return retval;
 }
 /* }}} */
 
@@ -483,15 +483,15 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 			--len_left;
 			*(p++) = 'i';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	if ((option & ONIG_OPTION_EXTEND) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'x';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	if ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==
@@ -500,37 +500,37 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 			--len_left;
 			*(p++) = 'p';
 		}
-		++len_req;	
+		++len_req;
 	} else {
 		if ((option & ONIG_OPTION_MULTILINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 'm';
 			}
-			++len_req;	
+			++len_req;
 		}
 
 		if ((option & ONIG_OPTION_SINGLELINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 's';
 			}
-			++len_req;	
+			++len_req;
 		}
-	}	
+	}
 	if ((option & ONIG_OPTION_FIND_LONGEST) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'l';
 		}
-		++len_req;	
+		++len_req;
 	}
 	if ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'n';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	c = 0;
@@ -566,7 +566,7 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 		--len_left;
 		*(p++) = '\0';
 	}
-	++len_req;	
+	++len_req;
 	if (len < len_req) {
 		return len_req;
 	}
@@ -577,11 +577,11 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 
 /* {{{ _php_mb_regex_init_options */
 static void
-_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) 
+_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)
 {
 	int n;
 	char c;
-	int optm = 0; 
+	int optm = 0;
 
 	*syntax = ONIG_SYNTAX_RUBY;
 
@@ -636,13 +636,13 @@ _php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, O
 					*syntax = ONIG_SYNTAX_POSIX_EXTENDED;
 					break;
 				case 'e':
-					if (eval != NULL) *eval = 1; 
+					if (eval != NULL) *eval = 1;
 					break;
 				default:
 					break;
 			}
 		}
-		if (option != NULL) *option|=optm; 
+		if (option != NULL) *option|=optm;
 	}
 }
 /* }}} */
@@ -860,11 +860,11 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 	} else {
 		/* FIXME: this code is not multibyte aware! */
 		convert_to_long_ex(arg_pattern_zval);
-		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);	
+		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);
 		pat_buf[1] = '\0';
 
 		arg_pattern = pat_buf;
-		arg_pattern_len = 1;	
+		arg_pattern_len = 1;
 	}
 	/* create regex pattern buffer */
 	re = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);
@@ -934,7 +934,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 					}
 				}
 			}
-				
+
 			if (eval) {
 				zval v;
 				/* null terminate buffer */
@@ -953,32 +953,31 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 				eval_buf.len = 0;
 				zval_dtor(&v);
 			} else if (is_callable) {
-				zval *retval_ptr;
+				zval *retval_ptr = NULL;
 				zval **args[1];
 				zval *subpats;
 				int i;
-				
+
 				MAKE_STD_ZVAL(subpats);
 				array_init(subpats);
-				
+
 				for (i = 0; i < regs->num_regs; i++) {
 					add_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);
-				}				
-				
+				}
+
 				args[0] = &subpats;
 				/* null terminate buffer */
 				smart_str_0(&eval_buf);
-				
+
 				arg_replace_fci.param_count = 1;
 				arg_replace_fci.params = args;
 				arg_replace_fci.retval_ptr_ptr = &retval_ptr;
-				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {
+				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {
 					convert_to_string_ex(&retval_ptr);
 					smart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));
 					eval_buf.len = 0;
 					zval_ptr_dtor(&retval_ptr);
 				} else {
-					efree(description);
 					if (!EG(exception)) {
 						php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call custom replacement function"");
 					}
@@ -991,7 +990,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 				pos = (OnigUChar *)string + n;
 			} else {
 				if (pos < string_lim) {
-					smart_str_appendl(&out_buf, pos, 1); 
+					smart_str_appendl(&out_buf, pos, 1);
 				}
 				pos++;
 			}
@@ -1013,7 +1012,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 	smart_str_free(&eval_buf);
 
 	if (err <= -2) {
-		smart_str_free(&out_buf);	
+		smart_str_free(&out_buf);
 		RETVAL_FALSE;
 	} else {
 		smart_str_appendc(&out_buf, '\0');
@@ -1063,7 +1062,7 @@ PHP_FUNCTION(mb_split)
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|l"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {
 		RETURN_FALSE;
-	} 
+	}
 
 	if (count > 0) {
 		count--;
@@ -1317,7 +1316,7 @@ PHP_FUNCTION(mb_ereg_search_init)
 	if (zend_parse_parameters(argc TSRMLS_CC, ""z|ss"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {
 		return;
 	}
-	
+
 	if (argc > 1 && arg_pattern_len == 0) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty pattern"");
 		RETURN_FALSE;
@@ -1416,7 +1415,7 @@ PHP_FUNCTION(mb_ereg_search_setpos)
 /* }}} */
 
 /* {{{ php_mb_regex_set_options */
-static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) 
+static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)
 {
 	if (prev_options != NULL) {
 		*prev_options = MBREX(regex_default_options);",php-src,5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,e9ac8954be9f7d988189df44578d759ffdea3512,1,"static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) 
//fix_flaw_line_below:
//static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)
 {
 	if (prev_options != NULL) {
 		*prev_options = MBREX(regex_default_options);
	}
	if (prev_syntax != NULL) {
		*prev_syntax = MBREX(regex_default_syntax);
	}
	MBREX(regex_default_options) = options;
	MBREX(regex_default_syntax) = syntax;
}
"
2558,180294,,Remote,Not required,Partial,CVE-2016-5768,https://www.cvedetails.com/cve/CVE-2016-5768/,CWE-415,Low,Partial,Partial,,2016-08-07,7.5,"Double free vulnerability in the _php_mb_regex_ereg_replace_exec function in php_mbregex.c in the mbstring extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to execute arbitrary code or cause a denial of service (application crash) by leveraging a callback exception.",2018-01-04,DoS Exec Code ,1,https://github.com/php/php-src/commit/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,Fix bug #72402: _php_mb_regex_ereg_replace_exec - double free,0,ext/mbstring/php_mbregex.c,"{""sha"": ""6cdee23c3e5999b467c4a206bf3f4827ebe121f6"", ""filename"": ""ext/mbstring/php_mbregex.c"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 33, ""changes"": 65, ""blob_url"": ""https://github.com/php/php-src/blob/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/php_mbregex.c"", ""raw_url"": ""https://github.com/php/php-src/raw/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/php_mbregex.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/mbstring/php_mbregex.c?ref=5b597a2e5b28e2d5a52fc1be13f425f08f47cb62"", ""patch"": ""@@ -32,7 +32,7 @@\n #include \""ext/standard/info.h\""\n #include \""php_mbregex.h\""\n #include \""mbstring.h\""\n- \n+\n #include \""php_onig_compat.h\"" /* must come prior to the oniguruma header */\n #include <oniguruma.h>\n #undef UChar\n@@ -55,7 +55,7 @@ struct _zend_mb_regex_globals {\n #define MBREX(g) (MBSTRG(mb_regex_globals)->g)\n \n /* {{{ static void php_mb_regex_free_cache() */\n-static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n+static void php_mb_regex_free_cache(php_mb_regex_t **pre)\n {\n \tonig_free(*pre);\n }\n@@ -78,7 +78,7 @@ static int _php_mb_regex_globals_ctor(zend_mb_regex_globals *pglobals TSRMLS_DC)\n /* }}} */\n \n /* {{{ _php_mb_regex_globals_dtor */\n-static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) \n+static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)\n {\n \tzend_hash_destroy(&pglobals->ht_rc);\n }\n@@ -466,7 +466,7 @@ static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patl\n \t\tretval = *rc;\n \t}\n out:\n-\treturn retval; \n+\treturn retval;\n }\n /* }}} */\n \n@@ -483,15 +483,15 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t\t--len_left;\n \t\t\t*(p++) = 'i';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tif ((option & ONIG_OPTION_EXTEND) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'x';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tif ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==\n@@ -500,37 +500,37 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t\t--len_left;\n \t\t\t*(p++) = 'p';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t} else {\n \t\tif ((option & ONIG_OPTION_MULTILINE) != 0) {\n \t\t\tif (len_left > 0) {\n \t\t\t\t--len_left;\n \t\t\t\t*(p++) = 'm';\n \t\t\t}\n-\t\t\t++len_req;\t\n+\t\t\t++len_req;\n \t\t}\n \n \t\tif ((option & ONIG_OPTION_SINGLELINE) != 0) {\n \t\t\tif (len_left > 0) {\n \t\t\t\t--len_left;\n \t\t\t\t*(p++) = 's';\n \t\t\t}\n-\t\t\t++len_req;\t\n+\t\t\t++len_req;\n \t\t}\n-\t}\t\n+\t}\n \tif ((option & ONIG_OPTION_FIND_LONGEST) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'l';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \tif ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'n';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tc = 0;\n@@ -566,7 +566,7 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t--len_left;\n \t\t*(p++) = '\\0';\n \t}\n-\t++len_req;\t\n+\t++len_req;\n \tif (len < len_req) {\n \t\treturn len_req;\n \t}\n@@ -577,11 +577,11 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \n /* {{{ _php_mb_regex_init_options */\n static void\n-_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) \n+_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)\n {\n \tint n;\n \tchar c;\n-\tint optm = 0; \n+\tint optm = 0;\n \n \t*syntax = ONIG_SYNTAX_RUBY;\n \n@@ -636,13 +636,13 @@ _php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, O\n \t\t\t\t\t*syntax = ONIG_SYNTAX_POSIX_EXTENDED;\n \t\t\t\t\tbreak;\n \t\t\t\tcase 'e':\n-\t\t\t\t\tif (eval != NULL) *eval = 1; \n+\t\t\t\t\tif (eval != NULL) *eval = 1;\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n-\t\tif (option != NULL) *option|=optm; \n+\t\tif (option != NULL) *option|=optm;\n \t}\n }\n /* }}} */\n@@ -860,11 +860,11 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t} else {\n \t\t/* FIXME: this code is not multibyte aware! */\n \t\tconvert_to_long_ex(arg_pattern_zval);\n-\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\t\n+\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\n \t\tpat_buf[1] = '\\0';\n \n \t\targ_pattern = pat_buf;\n-\t\targ_pattern_len = 1;\t\n+\t\targ_pattern_len = 1;\n \t}\n \t/* create regex pattern buffer */\n \tre = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);\n@@ -934,7 +934,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\t\t\n+\n \t\t\tif (eval) {\n \t\t\t\tzval v;\n \t\t\t\t/* null terminate buffer */\n@@ -953,32 +953,31 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\teval_buf.len = 0;\n \t\t\t\tzval_dtor(&v);\n \t\t\t} else if (is_callable) {\n-\t\t\t\tzval *retval_ptr;\n+\t\t\t\tzval *retval_ptr = NULL;\n \t\t\t\tzval **args[1];\n \t\t\t\tzval *subpats;\n \t\t\t\tint i;\n-\t\t\t\t\n+\n \t\t\t\tMAKE_STD_ZVAL(subpats);\n \t\t\t\tarray_init(subpats);\n-\t\t\t\t\n+\n \t\t\t\tfor (i = 0; i < regs->num_regs; i++) {\n \t\t\t\t\tadd_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);\n-\t\t\t\t}\t\t\t\t\n-\t\t\t\t\n+\t\t\t\t}\n+\n \t\t\t\targs[0] = &subpats;\n \t\t\t\t/* null terminate buffer */\n \t\t\t\tsmart_str_0(&eval_buf);\n-\t\t\t\t\n+\n \t\t\t\targ_replace_fci.param_count = 1;\n \t\t\t\targ_replace_fci.params = args;\n \t\t\t\targ_replace_fci.retval_ptr_ptr = &retval_ptr;\n-\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {\n+\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {\n \t\t\t\t\tconvert_to_string_ex(&retval_ptr);\n \t\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));\n \t\t\t\t\teval_buf.len = 0;\n \t\t\t\t\tzval_ptr_dtor(&retval_ptr);\n \t\t\t\t} else {\n-\t\t\t\t\tefree(description);\n \t\t\t\t\tif (!EG(exception)) {\n \t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to call custom replacement function\"");\n \t\t\t\t\t}\n@@ -991,7 +990,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\tpos = (OnigUChar *)string + n;\n \t\t\t} else {\n \t\t\t\tif (pos < string_lim) {\n-\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1); \n+\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1);\n \t\t\t\t}\n \t\t\t\tpos++;\n \t\t\t}\n@@ -1013,7 +1012,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \tsmart_str_free(&eval_buf);\n \n \tif (err <= -2) {\n-\t\tsmart_str_free(&out_buf);\t\n+\t\tsmart_str_free(&out_buf);\n \t\tRETVAL_FALSE;\n \t} else {\n \t\tsmart_str_appendc(&out_buf, '\\0');\n@@ -1063,7 +1062,7 @@ PHP_FUNCTION(mb_split)\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""ss|l\"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {\n \t\tRETURN_FALSE;\n-\t} \n+\t}\n \n \tif (count > 0) {\n \t\tcount--;\n@@ -1317,7 +1316,7 @@ PHP_FUNCTION(mb_ereg_search_init)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \""z|ss\"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc > 1 && arg_pattern_len == 0) {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Empty pattern\"");\n \t\tRETURN_FALSE;\n@@ -1416,7 +1415,7 @@ PHP_FUNCTION(mb_ereg_search_setpos)\n /* }}} */\n \n /* {{{ php_mb_regex_set_options */\n-static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) \n+static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)\n {\n \tif (prev_options != NULL) {\n \t\t*prev_options = MBREX(regex_default_options);""}<_**next**_>{""sha"": ""abb290bf4d8706ea51ecefd7ea68da62b4194f5d"", ""filename"": ""ext/mbstring/tests/bug72402.phpt"", ""status"": ""added"", ""additions"": 17, ""deletions"": 0, ""changes"": 17, ""blob_url"": ""https://github.com/php/php-src/blob/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/tests/bug72402.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/tests/bug72402.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/mbstring/tests/bug72402.phpt?ref=5b597a2e5b28e2d5a52fc1be13f425f08f47cb62"", ""patch"": ""@@ -0,0 +1,17 @@\n+--TEST--\n+Bug #72402: _php_mb_regex_ereg_replace_exec - double free\n+--SKIPIF--\n+<?php extension_loaded('mbstring') or die('skip mbstring not available'); ?>\n+--FILE--\n+<?php\n+function throwit() {\n+\tthrow new Exception('it');\n+}\n+$var10 = \""throwit\"";\n+try {\n+\t$var14 = mb_ereg_replace_callback(\""\"", $var10, \""\"");\n+} catch(Exception $e) {}\n+?>\n+DONE\n+--EXPECT--\n+DONE\n\\ No newline at end of file""}","static void php_mb_regex_free_cache(php_mb_regex_t **pre) 
static void php_mb_regex_free_cache(php_mb_regex_t **pre)
 {
 	onig_free(*pre);
 }
","static void php_mb_regex_free_cache(php_mb_regex_t **pre) 
 {
 	onig_free(*pre);
 }
",C,"static void php_mb_regex_free_cache(php_mb_regex_t **pre)
",,,"@@ -32,7 +32,7 @@
 #include ""ext/standard/info.h""
 #include ""php_mbregex.h""
 #include ""mbstring.h""
- 
+
 #include ""php_onig_compat.h"" /* must come prior to the oniguruma header */
 #include <oniguruma.h>
 #undef UChar
@@ -55,7 +55,7 @@ struct _zend_mb_regex_globals {
 #define MBREX(g) (MBSTRG(mb_regex_globals)->g)
 
 /* {{{ static void php_mb_regex_free_cache() */
-static void php_mb_regex_free_cache(php_mb_regex_t **pre) 
+static void php_mb_regex_free_cache(php_mb_regex_t **pre)
 {
 	onig_free(*pre);
 }
@@ -78,7 +78,7 @@ static int _php_mb_regex_globals_ctor(zend_mb_regex_globals *pglobals TSRMLS_DC)
 /* }}} */
 
 /* {{{ _php_mb_regex_globals_dtor */
-static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) 
+static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)
 {
 	zend_hash_destroy(&pglobals->ht_rc);
 }
@@ -466,7 +466,7 @@ static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patl
 		retval = *rc;
 	}
 out:
-	return retval; 
+	return retval;
 }
 /* }}} */
 
@@ -483,15 +483,15 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 			--len_left;
 			*(p++) = 'i';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	if ((option & ONIG_OPTION_EXTEND) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'x';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	if ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==
@@ -500,37 +500,37 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 			--len_left;
 			*(p++) = 'p';
 		}
-		++len_req;	
+		++len_req;
 	} else {
 		if ((option & ONIG_OPTION_MULTILINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 'm';
 			}
-			++len_req;	
+			++len_req;
 		}
 
 		if ((option & ONIG_OPTION_SINGLELINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 's';
 			}
-			++len_req;	
+			++len_req;
 		}
-	}	
+	}
 	if ((option & ONIG_OPTION_FIND_LONGEST) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'l';
 		}
-		++len_req;	
+		++len_req;
 	}
 	if ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'n';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	c = 0;
@@ -566,7 +566,7 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 		--len_left;
 		*(p++) = '\0';
 	}
-	++len_req;	
+	++len_req;
 	if (len < len_req) {
 		return len_req;
 	}
@@ -577,11 +577,11 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 
 /* {{{ _php_mb_regex_init_options */
 static void
-_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) 
+_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)
 {
 	int n;
 	char c;
-	int optm = 0; 
+	int optm = 0;
 
 	*syntax = ONIG_SYNTAX_RUBY;
 
@@ -636,13 +636,13 @@ _php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, O
 					*syntax = ONIG_SYNTAX_POSIX_EXTENDED;
 					break;
 				case 'e':
-					if (eval != NULL) *eval = 1; 
+					if (eval != NULL) *eval = 1;
 					break;
 				default:
 					break;
 			}
 		}
-		if (option != NULL) *option|=optm; 
+		if (option != NULL) *option|=optm;
 	}
 }
 /* }}} */
@@ -860,11 +860,11 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 	} else {
 		/* FIXME: this code is not multibyte aware! */
 		convert_to_long_ex(arg_pattern_zval);
-		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);	
+		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);
 		pat_buf[1] = '\0';
 
 		arg_pattern = pat_buf;
-		arg_pattern_len = 1;	
+		arg_pattern_len = 1;
 	}
 	/* create regex pattern buffer */
 	re = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);
@@ -934,7 +934,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 					}
 				}
 			}
-				
+
 			if (eval) {
 				zval v;
 				/* null terminate buffer */
@@ -953,32 +953,31 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 				eval_buf.len = 0;
 				zval_dtor(&v);
 			} else if (is_callable) {
-				zval *retval_ptr;
+				zval *retval_ptr = NULL;
 				zval **args[1];
 				zval *subpats;
 				int i;
-				
+
 				MAKE_STD_ZVAL(subpats);
 				array_init(subpats);
-				
+
 				for (i = 0; i < regs->num_regs; i++) {
 					add_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);
-				}				
-				
+				}
+
 				args[0] = &subpats;
 				/* null terminate buffer */
 				smart_str_0(&eval_buf);
-				
+
 				arg_replace_fci.param_count = 1;
 				arg_replace_fci.params = args;
 				arg_replace_fci.retval_ptr_ptr = &retval_ptr;
-				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {
+				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {
 					convert_to_string_ex(&retval_ptr);
 					smart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));
 					eval_buf.len = 0;
 					zval_ptr_dtor(&retval_ptr);
 				} else {
-					efree(description);
 					if (!EG(exception)) {
 						php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call custom replacement function"");
 					}
@@ -991,7 +990,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 				pos = (OnigUChar *)string + n;
 			} else {
 				if (pos < string_lim) {
-					smart_str_appendl(&out_buf, pos, 1); 
+					smart_str_appendl(&out_buf, pos, 1);
 				}
 				pos++;
 			}
@@ -1013,7 +1012,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 	smart_str_free(&eval_buf);
 
 	if (err <= -2) {
-		smart_str_free(&out_buf);	
+		smart_str_free(&out_buf);
 		RETVAL_FALSE;
 	} else {
 		smart_str_appendc(&out_buf, '\0');
@@ -1063,7 +1062,7 @@ PHP_FUNCTION(mb_split)
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|l"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {
 		RETURN_FALSE;
-	} 
+	}
 
 	if (count > 0) {
 		count--;
@@ -1317,7 +1316,7 @@ PHP_FUNCTION(mb_ereg_search_init)
 	if (zend_parse_parameters(argc TSRMLS_CC, ""z|ss"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {
 		return;
 	}
-	
+
 	if (argc > 1 && arg_pattern_len == 0) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty pattern"");
 		RETURN_FALSE;
@@ -1416,7 +1415,7 @@ PHP_FUNCTION(mb_ereg_search_setpos)
 /* }}} */
 
 /* {{{ php_mb_regex_set_options */
-static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) 
+static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)
 {
 	if (prev_options != NULL) {
 		*prev_options = MBREX(regex_default_options);",php-src,5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,e9ac8954be9f7d988189df44578d759ffdea3512,1,"static void php_mb_regex_free_cache(php_mb_regex_t **pre) 
//fix_flaw_line_below:
//static void php_mb_regex_free_cache(php_mb_regex_t **pre)
 {
 	onig_free(*pre);
 }
"
2559,180295,,Remote,Not required,Partial,CVE-2016-5768,https://www.cvedetails.com/cve/CVE-2016-5768/,CWE-415,Low,Partial,Partial,,2016-08-07,7.5,"Double free vulnerability in the _php_mb_regex_ereg_replace_exec function in php_mbregex.c in the mbstring extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to execute arbitrary code or cause a denial of service (application crash) by leveraging a callback exception.",2018-01-04,DoS Exec Code ,1,https://github.com/php/php-src/commit/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,Fix bug #72402: _php_mb_regex_ereg_replace_exec - double free,1,ext/mbstring/php_mbregex.c,"{""sha"": ""6cdee23c3e5999b467c4a206bf3f4827ebe121f6"", ""filename"": ""ext/mbstring/php_mbregex.c"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 33, ""changes"": 65, ""blob_url"": ""https://github.com/php/php-src/blob/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/php_mbregex.c"", ""raw_url"": ""https://github.com/php/php-src/raw/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/php_mbregex.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/mbstring/php_mbregex.c?ref=5b597a2e5b28e2d5a52fc1be13f425f08f47cb62"", ""patch"": ""@@ -32,7 +32,7 @@\n #include \""ext/standard/info.h\""\n #include \""php_mbregex.h\""\n #include \""mbstring.h\""\n- \n+\n #include \""php_onig_compat.h\"" /* must come prior to the oniguruma header */\n #include <oniguruma.h>\n #undef UChar\n@@ -55,7 +55,7 @@ struct _zend_mb_regex_globals {\n #define MBREX(g) (MBSTRG(mb_regex_globals)->g)\n \n /* {{{ static void php_mb_regex_free_cache() */\n-static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n+static void php_mb_regex_free_cache(php_mb_regex_t **pre)\n {\n \tonig_free(*pre);\n }\n@@ -78,7 +78,7 @@ static int _php_mb_regex_globals_ctor(zend_mb_regex_globals *pglobals TSRMLS_DC)\n /* }}} */\n \n /* {{{ _php_mb_regex_globals_dtor */\n-static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) \n+static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)\n {\n \tzend_hash_destroy(&pglobals->ht_rc);\n }\n@@ -466,7 +466,7 @@ static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patl\n \t\tretval = *rc;\n \t}\n out:\n-\treturn retval; \n+\treturn retval;\n }\n /* }}} */\n \n@@ -483,15 +483,15 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t\t--len_left;\n \t\t\t*(p++) = 'i';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tif ((option & ONIG_OPTION_EXTEND) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'x';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tif ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==\n@@ -500,37 +500,37 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t\t--len_left;\n \t\t\t*(p++) = 'p';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t} else {\n \t\tif ((option & ONIG_OPTION_MULTILINE) != 0) {\n \t\t\tif (len_left > 0) {\n \t\t\t\t--len_left;\n \t\t\t\t*(p++) = 'm';\n \t\t\t}\n-\t\t\t++len_req;\t\n+\t\t\t++len_req;\n \t\t}\n \n \t\tif ((option & ONIG_OPTION_SINGLELINE) != 0) {\n \t\t\tif (len_left > 0) {\n \t\t\t\t--len_left;\n \t\t\t\t*(p++) = 's';\n \t\t\t}\n-\t\t\t++len_req;\t\n+\t\t\t++len_req;\n \t\t}\n-\t}\t\n+\t}\n \tif ((option & ONIG_OPTION_FIND_LONGEST) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'l';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \tif ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'n';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tc = 0;\n@@ -566,7 +566,7 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \t\t--len_left;\n \t\t*(p++) = '\\0';\n \t}\n-\t++len_req;\t\n+\t++len_req;\n \tif (len < len_req) {\n \t\treturn len_req;\n \t}\n@@ -577,11 +577,11 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT\n \n /* {{{ _php_mb_regex_init_options */\n static void\n-_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) \n+_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)\n {\n \tint n;\n \tchar c;\n-\tint optm = 0; \n+\tint optm = 0;\n \n \t*syntax = ONIG_SYNTAX_RUBY;\n \n@@ -636,13 +636,13 @@ _php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, O\n \t\t\t\t\t*syntax = ONIG_SYNTAX_POSIX_EXTENDED;\n \t\t\t\t\tbreak;\n \t\t\t\tcase 'e':\n-\t\t\t\t\tif (eval != NULL) *eval = 1; \n+\t\t\t\t\tif (eval != NULL) *eval = 1;\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n-\t\tif (option != NULL) *option|=optm; \n+\t\tif (option != NULL) *option|=optm;\n \t}\n }\n /* }}} */\n@@ -860,11 +860,11 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t} else {\n \t\t/* FIXME: this code is not multibyte aware! */\n \t\tconvert_to_long_ex(arg_pattern_zval);\n-\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\t\n+\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\n \t\tpat_buf[1] = '\\0';\n \n \t\targ_pattern = pat_buf;\n-\t\targ_pattern_len = 1;\t\n+\t\targ_pattern_len = 1;\n \t}\n \t/* create regex pattern buffer */\n \tre = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);\n@@ -934,7 +934,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\t\t\n+\n \t\t\tif (eval) {\n \t\t\t\tzval v;\n \t\t\t\t/* null terminate buffer */\n@@ -953,32 +953,31 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\teval_buf.len = 0;\n \t\t\t\tzval_dtor(&v);\n \t\t\t} else if (is_callable) {\n-\t\t\t\tzval *retval_ptr;\n+\t\t\t\tzval *retval_ptr = NULL;\n \t\t\t\tzval **args[1];\n \t\t\t\tzval *subpats;\n \t\t\t\tint i;\n-\t\t\t\t\n+\n \t\t\t\tMAKE_STD_ZVAL(subpats);\n \t\t\t\tarray_init(subpats);\n-\t\t\t\t\n+\n \t\t\t\tfor (i = 0; i < regs->num_regs; i++) {\n \t\t\t\t\tadd_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);\n-\t\t\t\t}\t\t\t\t\n-\t\t\t\t\n+\t\t\t\t}\n+\n \t\t\t\targs[0] = &subpats;\n \t\t\t\t/* null terminate buffer */\n \t\t\t\tsmart_str_0(&eval_buf);\n-\t\t\t\t\n+\n \t\t\t\targ_replace_fci.param_count = 1;\n \t\t\t\targ_replace_fci.params = args;\n \t\t\t\targ_replace_fci.retval_ptr_ptr = &retval_ptr;\n-\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {\n+\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {\n \t\t\t\t\tconvert_to_string_ex(&retval_ptr);\n \t\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));\n \t\t\t\t\teval_buf.len = 0;\n \t\t\t\t\tzval_ptr_dtor(&retval_ptr);\n \t\t\t\t} else {\n-\t\t\t\t\tefree(description);\n \t\t\t\t\tif (!EG(exception)) {\n \t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to call custom replacement function\"");\n \t\t\t\t\t}\n@@ -991,7 +990,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \t\t\t\tpos = (OnigUChar *)string + n;\n \t\t\t} else {\n \t\t\t\tif (pos < string_lim) {\n-\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1); \n+\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1);\n \t\t\t\t}\n \t\t\t\tpos++;\n \t\t\t}\n@@ -1013,7 +1012,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp\n \tsmart_str_free(&eval_buf);\n \n \tif (err <= -2) {\n-\t\tsmart_str_free(&out_buf);\t\n+\t\tsmart_str_free(&out_buf);\n \t\tRETVAL_FALSE;\n \t} else {\n \t\tsmart_str_appendc(&out_buf, '\\0');\n@@ -1063,7 +1062,7 @@ PHP_FUNCTION(mb_split)\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""ss|l\"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {\n \t\tRETURN_FALSE;\n-\t} \n+\t}\n \n \tif (count > 0) {\n \t\tcount--;\n@@ -1317,7 +1316,7 @@ PHP_FUNCTION(mb_ereg_search_init)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \""z|ss\"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc > 1 && arg_pattern_len == 0) {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Empty pattern\"");\n \t\tRETURN_FALSE;\n@@ -1416,7 +1415,7 @@ PHP_FUNCTION(mb_ereg_search_setpos)\n /* }}} */\n \n /* {{{ php_mb_regex_set_options */\n-static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) \n+static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)\n {\n \tif (prev_options != NULL) {\n \t\t*prev_options = MBREX(regex_default_options);""}<_**next**_>{""sha"": ""abb290bf4d8706ea51ecefd7ea68da62b4194f5d"", ""filename"": ""ext/mbstring/tests/bug72402.phpt"", ""status"": ""added"", ""additions"": 17, ""deletions"": 0, ""changes"": 17, ""blob_url"": ""https://github.com/php/php-src/blob/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/tests/bug72402.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62/ext/mbstring/tests/bug72402.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/mbstring/tests/bug72402.phpt?ref=5b597a2e5b28e2d5a52fc1be13f425f08f47cb62"", ""patch"": ""@@ -0,0 +1,17 @@\n+--TEST--\n+Bug #72402: _php_mb_regex_ereg_replace_exec - double free\n+--SKIPIF--\n+<?php extension_loaded('mbstring') or die('skip mbstring not available'); ?>\n+--FILE--\n+<?php\n+function throwit() {\n+\tthrow new Exception('it');\n+}\n+$var10 = \""throwit\"";\n+try {\n+\t$var14 = mb_ereg_replace_callback(\""\"", $var10, \""\"");\n+} catch(Exception $e) {}\n+?>\n+DONE\n+--EXPECT--\n+DONE\n\\ No newline at end of file""}","static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patlen, OnigOptionType options, OnigEncoding enc, OnigSyntaxType *syntax TSRMLS_DC)
{
	int err_code = 0;
	int found = 0;
	php_mb_regex_t *retval = NULL, **rc = NULL;
	OnigErrorInfo err_info;
	OnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];

	found = zend_hash_find(&MBREX(ht_rc), (char *)pattern, patlen+1, (void **) &rc);
	if (found == FAILURE || (*rc)->options != options || (*rc)->enc != enc || (*rc)->syntax != syntax) {
		if ((err_code = onig_new(&retval, (OnigUChar *)pattern, (OnigUChar *)(pattern + patlen), options, enc, syntax, &err_info)) != ONIG_NORMAL) {
			onig_error_code_to_str(err_str, err_code, err_info);
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""mbregex compile err: %s"", err_str);
			retval = NULL;
			goto out;
		}
		zend_hash_update(&MBREX(ht_rc), (char *) pattern, patlen + 1, (void *) &retval, sizeof(retval), NULL);
	} else if (found == SUCCESS) {
 		retval = *rc;
 	}
 out:
	return retval;
 }
","static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patlen, OnigOptionType options, OnigEncoding enc, OnigSyntaxType *syntax TSRMLS_DC)
{
	int err_code = 0;
	int found = 0;
	php_mb_regex_t *retval = NULL, **rc = NULL;
	OnigErrorInfo err_info;
	OnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];

	found = zend_hash_find(&MBREX(ht_rc), (char *)pattern, patlen+1, (void **) &rc);
	if (found == FAILURE || (*rc)->options != options || (*rc)->enc != enc || (*rc)->syntax != syntax) {
		if ((err_code = onig_new(&retval, (OnigUChar *)pattern, (OnigUChar *)(pattern + patlen), options, enc, syntax, &err_info)) != ONIG_NORMAL) {
			onig_error_code_to_str(err_str, err_code, err_info);
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""mbregex compile err: %s"", err_str);
			retval = NULL;
			goto out;
		}
		zend_hash_update(&MBREX(ht_rc), (char *) pattern, patlen + 1, (void *) &retval, sizeof(retval), NULL);
	} else if (found == SUCCESS) {
 		retval = *rc;
 	}
 out:
	return retval; 
 }
",C,"	return retval;
","	return retval; 
",,"@@ -32,7 +32,7 @@
 #include ""ext/standard/info.h""
 #include ""php_mbregex.h""
 #include ""mbstring.h""
- 
+
 #include ""php_onig_compat.h"" /* must come prior to the oniguruma header */
 #include <oniguruma.h>
 #undef UChar
@@ -55,7 +55,7 @@ struct _zend_mb_regex_globals {
 #define MBREX(g) (MBSTRG(mb_regex_globals)->g)
 
 /* {{{ static void php_mb_regex_free_cache() */
-static void php_mb_regex_free_cache(php_mb_regex_t **pre) 
+static void php_mb_regex_free_cache(php_mb_regex_t **pre)
 {
 	onig_free(*pre);
 }
@@ -78,7 +78,7 @@ static int _php_mb_regex_globals_ctor(zend_mb_regex_globals *pglobals TSRMLS_DC)
 /* }}} */
 
 /* {{{ _php_mb_regex_globals_dtor */
-static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) 
+static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)
 {
 	zend_hash_destroy(&pglobals->ht_rc);
 }
@@ -466,7 +466,7 @@ static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patl
 		retval = *rc;
 	}
 out:
-	return retval; 
+	return retval;
 }
 /* }}} */
 
@@ -483,15 +483,15 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 			--len_left;
 			*(p++) = 'i';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	if ((option & ONIG_OPTION_EXTEND) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'x';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	if ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==
@@ -500,37 +500,37 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 			--len_left;
 			*(p++) = 'p';
 		}
-		++len_req;	
+		++len_req;
 	} else {
 		if ((option & ONIG_OPTION_MULTILINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 'm';
 			}
-			++len_req;	
+			++len_req;
 		}
 
 		if ((option & ONIG_OPTION_SINGLELINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 's';
 			}
-			++len_req;	
+			++len_req;
 		}
-	}	
+	}
 	if ((option & ONIG_OPTION_FIND_LONGEST) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'l';
 		}
-		++len_req;	
+		++len_req;
 	}
 	if ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'n';
 		}
-		++len_req;	
+		++len_req;
 	}
 
 	c = 0;
@@ -566,7 +566,7 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 		--len_left;
 		*(p++) = '\0';
 	}
-	++len_req;	
+	++len_req;
 	if (len < len_req) {
 		return len_req;
 	}
@@ -577,11 +577,11 @@ static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 
 /* {{{ _php_mb_regex_init_options */
 static void
-_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) 
+_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)
 {
 	int n;
 	char c;
-	int optm = 0; 
+	int optm = 0;
 
 	*syntax = ONIG_SYNTAX_RUBY;
 
@@ -636,13 +636,13 @@ _php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, O
 					*syntax = ONIG_SYNTAX_POSIX_EXTENDED;
 					break;
 				case 'e':
-					if (eval != NULL) *eval = 1; 
+					if (eval != NULL) *eval = 1;
 					break;
 				default:
 					break;
 			}
 		}
-		if (option != NULL) *option|=optm; 
+		if (option != NULL) *option|=optm;
 	}
 }
 /* }}} */
@@ -860,11 +860,11 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 	} else {
 		/* FIXME: this code is not multibyte aware! */
 		convert_to_long_ex(arg_pattern_zval);
-		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);	
+		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);
 		pat_buf[1] = '\0';
 
 		arg_pattern = pat_buf;
-		arg_pattern_len = 1;	
+		arg_pattern_len = 1;
 	}
 	/* create regex pattern buffer */
 	re = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);
@@ -934,7 +934,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 					}
 				}
 			}
-				
+
 			if (eval) {
 				zval v;
 				/* null terminate buffer */
@@ -953,32 +953,31 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 				eval_buf.len = 0;
 				zval_dtor(&v);
 			} else if (is_callable) {
-				zval *retval_ptr;
+				zval *retval_ptr = NULL;
 				zval **args[1];
 				zval *subpats;
 				int i;
-				
+
 				MAKE_STD_ZVAL(subpats);
 				array_init(subpats);
-				
+
 				for (i = 0; i < regs->num_regs; i++) {
 					add_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);
-				}				
-				
+				}
+
 				args[0] = &subpats;
 				/* null terminate buffer */
 				smart_str_0(&eval_buf);
-				
+
 				arg_replace_fci.param_count = 1;
 				arg_replace_fci.params = args;
 				arg_replace_fci.retval_ptr_ptr = &retval_ptr;
-				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {
+				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {
 					convert_to_string_ex(&retval_ptr);
 					smart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));
 					eval_buf.len = 0;
 					zval_ptr_dtor(&retval_ptr);
 				} else {
-					efree(description);
 					if (!EG(exception)) {
 						php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call custom replacement function"");
 					}
@@ -991,7 +990,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 				pos = (OnigUChar *)string + n;
 			} else {
 				if (pos < string_lim) {
-					smart_str_appendl(&out_buf, pos, 1); 
+					smart_str_appendl(&out_buf, pos, 1);
 				}
 				pos++;
 			}
@@ -1013,7 +1012,7 @@ static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 	smart_str_free(&eval_buf);
 
 	if (err <= -2) {
-		smart_str_free(&out_buf);	
+		smart_str_free(&out_buf);
 		RETVAL_FALSE;
 	} else {
 		smart_str_appendc(&out_buf, '\0');
@@ -1063,7 +1062,7 @@ PHP_FUNCTION(mb_split)
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|l"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {
 		RETURN_FALSE;
-	} 
+	}
 
 	if (count > 0) {
 		count--;
@@ -1317,7 +1316,7 @@ PHP_FUNCTION(mb_ereg_search_init)
 	if (zend_parse_parameters(argc TSRMLS_CC, ""z|ss"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {
 		return;
 	}
-	
+
 	if (argc > 1 && arg_pattern_len == 0) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty pattern"");
 		RETURN_FALSE;
@@ -1416,7 +1415,7 @@ PHP_FUNCTION(mb_ereg_search_setpos)
 /* }}} */
 
 /* {{{ php_mb_regex_set_options */
-static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) 
+static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)
 {
 	if (prev_options != NULL) {
 		*prev_options = MBREX(regex_default_options);",php-src,5b597a2e5b28e2d5a52fc1be13f425f08f47cb62?w=1,e9ac8954be9f7d988189df44578d759ffdea3512,1,"static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patlen, OnigOptionType options, OnigEncoding enc, OnigSyntaxType *syntax TSRMLS_DC)
{
	int err_code = 0;
	int found = 0;
	php_mb_regex_t *retval = NULL, **rc = NULL;
	OnigErrorInfo err_info;
	OnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];

	found = zend_hash_find(&MBREX(ht_rc), (char *)pattern, patlen+1, (void **) &rc);
	if (found == FAILURE || (*rc)->options != options || (*rc)->enc != enc || (*rc)->syntax != syntax) {
		if ((err_code = onig_new(&retval, (OnigUChar *)pattern, (OnigUChar *)(pattern + patlen), options, enc, syntax, &err_info)) != ONIG_NORMAL) {
			onig_error_code_to_str(err_str, err_code, err_info);
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""mbregex compile err: %s"", err_str);
			retval = NULL;
			goto out;
		}
		zend_hash_update(&MBREX(ht_rc), (char *) pattern, patlen + 1, (void *) &retval, sizeof(retval), NULL);
	} else if (found == SUCCESS) {
 		retval = *rc;
 	}
 out:
//flaw_line_below:
	return retval; 
//fix_flaw_line_below:
//	return retval;
 }
"
2813,180549,,Remote,Not required,Partial,CVE-2016-3132,https://www.cvedetails.com/cve/CVE-2016-3132/,CWE-415,Low,Partial,Partial,,2016-08-07,7.5,Double free vulnerability in the SplDoublyLinkedList::offsetSet function in ext/spl/spl_dllist.c in PHP 7.x before 7.0.6 allows remote attackers to execute arbitrary code via a crafted index.,2016-11-28,Exec Code ,0,https://github.com/php/php-src/commit/28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5?w=1,28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5?w=1,Fix bug #71735: Double-free in SplDoublyLinkedList::offsetSet,1,ext/spl/spl_dllist.c,"{""sha"": ""fc6a40b806e144a1475dae8e12633af7e780c7ad"", ""filename"": ""NEWS"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/php/php-src/blob/28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5/NEWS"", ""raw_url"": ""https://github.com/php/php-src/raw/28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5/NEWS"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/NEWS?ref=28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5"", ""patch"": ""@@ -30,6 +30,7 @@ PHP                                                                        NEWS\n   . Fixed bug #52339 (SPL autoloader breaks class_exists()). (Nikita)\n   . Fixed bug #67582 (Cloned SplObjectStorage with overwritten getHash fails\n     offsetExists()). (Nikita)\n+  . Fixed bug #71735 (Double-free in SplDoublyLinkedList::offsetSet). (Stas)\n \n - Standard:\n   . Fixed bug #71837 (Wrong arrays behaviour). (Laruence)""}<_**next**_>{""sha"": ""1675c7eaf3a1d5b0a960512c7dd751a2f1d65a09"", ""filename"": ""ext/spl/spl_dllist.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/php/php-src/blob/28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5/ext/spl/spl_dllist.c"", ""raw_url"": ""https://github.com/php/php-src/raw/28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5/ext/spl/spl_dllist.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/spl/spl_dllist.c?ref=28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5"", ""patch"": ""@@ -830,7 +830,6 @@ SPL_METHOD(SplDoublyLinkedList, offsetSet)\n \t\tindex = spl_offset_convert_to_long(zindex);\n \n \t\tif (index < 0 || index >= intern->llist->count) {\n-\t\t\tzval_ptr_dtor(value);\n \t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \""Offset invalid or out of range\"", 0);\n \t\t\treturn;\n \t\t}""}<_**next**_>{""sha"": ""92568028c4ae200c6c6e4a679c6d43c211912a04"", ""filename"": ""ext/spl/tests/bug71735.phpt"", ""status"": ""added"", ""additions"": 15, ""deletions"": 0, ""changes"": 15, ""blob_url"": ""https://github.com/php/php-src/blob/28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5/ext/spl/tests/bug71735.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5/ext/spl/tests/bug71735.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/spl/tests/bug71735.phpt?ref=28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5"", ""patch"": ""@@ -0,0 +1,15 @@\n+--TEST--\n+Bug #71735 (Double-free in SplDoublyLinkedList::offsetSet)\n+--FILE--\n+<?php\n+try {\n+$var_1=new SplStack();\n+$var_1->offsetSet(100,new DateTime('2000-01-01'));\n+} catch(OutOfRangeException $e) {\n+\tprint $e->getMessage().\""\\n\"";\n+}\n+?>\n+===DONE===\n+--EXPECT--\n+Offset invalid or out of range\n+===DONE===\n\\ No newline at end of file""}","SPL_METHOD(SplDoublyLinkedList, offsetSet)
{
	zval                  *zindex, *value;
	spl_dllist_object     *intern;

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""zz"", &zindex, &value) == FAILURE) {
		return;
	}

	intern = Z_SPLDLLIST_P(getThis());

	if (Z_TYPE_P(zindex) == IS_NULL) {
		/* $obj[] = ... */
		spl_ptr_llist_push(intern->llist, value);
	} else {
		/* $obj[$foo] = ... */
		zend_long                   index;
		spl_ptr_llist_element *element;

 		index = spl_offset_convert_to_long(zindex);
 
 		if (index < 0 || index >= intern->llist->count) {
 			zend_throw_exception(spl_ce_OutOfRangeException, ""Offset invalid or out of range"", 0);
 			return;
 		}

		element = spl_ptr_llist_offset(intern->llist, index, intern->flags & SPL_DLLIST_IT_LIFO);

		if (element != NULL) {
			/* call dtor on the old element as in spl_ptr_llist_pop */
			if (intern->llist->dtor) {
				intern->llist->dtor(element);
			}

			/* the element is replaced, delref the old one as in
			 * SplDoublyLinkedList::pop() */
			zval_ptr_dtor(&element->data);
			ZVAL_COPY_VALUE(&element->data, value);

			/* new element, call ctor as in spl_ptr_llist_push */
			if (intern->llist->ctor) {
				intern->llist->ctor(element);
			}
		} else {
			zval_ptr_dtor(value);
			zend_throw_exception(spl_ce_OutOfRangeException, ""Offset invalid"", 0);
			return;
		}
	}
} /* }}} */

/* {{{ proto void SplDoublyLinkedList::offsetUnset(mixed index)
","SPL_METHOD(SplDoublyLinkedList, offsetSet)
{
	zval                  *zindex, *value;
	spl_dllist_object     *intern;

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""zz"", &zindex, &value) == FAILURE) {
		return;
	}

	intern = Z_SPLDLLIST_P(getThis());

	if (Z_TYPE_P(zindex) == IS_NULL) {
		/* $obj[] = ... */
		spl_ptr_llist_push(intern->llist, value);
	} else {
		/* $obj[$foo] = ... */
		zend_long                   index;
		spl_ptr_llist_element *element;

 		index = spl_offset_convert_to_long(zindex);
 
 		if (index < 0 || index >= intern->llist->count) {
			zval_ptr_dtor(value);
 			zend_throw_exception(spl_ce_OutOfRangeException, ""Offset invalid or out of range"", 0);
 			return;
 		}

		element = spl_ptr_llist_offset(intern->llist, index, intern->flags & SPL_DLLIST_IT_LIFO);

		if (element != NULL) {
			/* call dtor on the old element as in spl_ptr_llist_pop */
			if (intern->llist->dtor) {
				intern->llist->dtor(element);
			}

			/* the element is replaced, delref the old one as in
			 * SplDoublyLinkedList::pop() */
			zval_ptr_dtor(&element->data);
			ZVAL_COPY_VALUE(&element->data, value);

			/* new element, call ctor as in spl_ptr_llist_push */
			if (intern->llist->ctor) {
				intern->llist->ctor(element);
			}
		} else {
			zval_ptr_dtor(value);
			zend_throw_exception(spl_ce_OutOfRangeException, ""Offset invalid"", 0);
			return;
		}
	}
} /* }}} */

/* {{{ proto void SplDoublyLinkedList::offsetUnset(mixed index)
",C,,"			zval_ptr_dtor(value);
",,"@@ -830,7 +830,6 @@ SPL_METHOD(SplDoublyLinkedList, offsetSet)
 		index = spl_offset_convert_to_long(zindex);
 
 		if (index < 0 || index >= intern->llist->count) {
-			zval_ptr_dtor(value);
 			zend_throw_exception(spl_ce_OutOfRangeException, ""Offset invalid or out of range"", 0);
 			return;
 		}",php-src,28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5?w=1,f3309173f916e3c5cf37910975f04310706336b5,1,"SPL_METHOD(SplDoublyLinkedList, offsetSet)
{
	zval                  *zindex, *value;
	spl_dllist_object     *intern;

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""zz"", &zindex, &value) == FAILURE) {
		return;
	}

	intern = Z_SPLDLLIST_P(getThis());

	if (Z_TYPE_P(zindex) == IS_NULL) {
		/* $obj[] = ... */
		spl_ptr_llist_push(intern->llist, value);
	} else {
		/* $obj[$foo] = ... */
		zend_long                   index;
		spl_ptr_llist_element *element;

 		index = spl_offset_convert_to_long(zindex);
 
 		if (index < 0 || index >= intern->llist->count) {
//flaw_line_below:
			zval_ptr_dtor(value);
 			zend_throw_exception(spl_ce_OutOfRangeException, ""Offset invalid or out of range"", 0);
 			return;
 		}

		element = spl_ptr_llist_offset(intern->llist, index, intern->flags & SPL_DLLIST_IT_LIFO);

		if (element != NULL) {
			/* call dtor on the old element as in spl_ptr_llist_pop */
			if (intern->llist->dtor) {
				intern->llist->dtor(element);
			}

			/* the element is replaced, delref the old one as in
			 * SplDoublyLinkedList::pop() */
			zval_ptr_dtor(&element->data);
			ZVAL_COPY_VALUE(&element->data, value);

			/* new element, call ctor as in spl_ptr_llist_push */
			if (intern->llist->ctor) {
				intern->llist->ctor(element);
			}
		} else {
			zval_ptr_dtor(value);
			zend_throw_exception(spl_ce_OutOfRangeException, ""Offset invalid"", 0);
			return;
		}
	}
} /* }}} */

/* {{{ proto void SplDoublyLinkedList::offsetUnset(mixed index)
"
2900,180636,,Remote,Not required,Complete,CVE-2015-8962,https://www.cvedetails.com/cve/CVE-2015-8962/,CWE-415,Medium,Complete,Complete,,2016-11-16,9.3,Double free vulnerability in the sg_common_write function in drivers/scsi/sg.c in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (memory corruption and system crash) by detaching a device during an SG_IO ioctl call.,2017-01-17,DoS +Priv Mem. Corr. ,7,https://github.com/torvalds/linux/commit/f3951a3709ff50990bf3e188c27d346792103432,f3951a3709ff50990bf3e188c27d346792103432,"sg: Fix double-free when drives detach during SG_IO

In sg_common_write(), we free the block request and return -ENODEV if
the device is detached in the middle of the SG_IO ioctl().

Unfortunately, sg_finish_rem_req() also tries to free srp->rq, so we
end up freeing rq->cmd in the already free rq object, and then free
the object itself out from under the current user.

This ends up corrupting random memory via the list_head on the rq
object. The most common crash trace I saw is this:

  ------------[ cut here ]------------
  kernel BUG at block/blk-core.c:1420!
  Call Trace:
  [<ffffffff81281eab>] blk_put_request+0x5b/0x80
  [<ffffffffa0069e5b>] sg_finish_rem_req+0x6b/0x120 [sg]
  [<ffffffffa006bcb9>] sg_common_write.isra.14+0x459/0x5a0 [sg]
  [<ffffffff8125b328>] ? selinux_file_alloc_security+0x48/0x70
  [<ffffffffa006bf95>] sg_new_write.isra.17+0x195/0x2d0 [sg]
  [<ffffffffa006cef4>] sg_ioctl+0x644/0xdb0 [sg]
  [<ffffffff81170f80>] do_vfs_ioctl+0x90/0x520
  [<ffffffff81258967>] ? file_has_perm+0x97/0xb0
  [<ffffffff811714a1>] SyS_ioctl+0x91/0xb0
  [<ffffffff81602afb>] tracesys+0xdd/0xe2
    RIP [<ffffffff81281e04>] __blk_put_request+0x154/0x1a0

The solution is straightforward: just set srp->rq to NULL in the
failure branch so that sg_finish_rem_req() doesn't attempt to re-free
it.

Additionally, since sg_rq_end_io() will never be called on the object
when this happens, we need to free memory backing ->cmd if it isn't
embedded in the object itself.

KASAN was extremely helpful in finding the root cause of this bug.

Signed-off-by: Calvin Owens <calvinowens@fb.com>
Acked-by: Douglas Gilbert <dgilbert@interlog.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>",1,drivers/scsi/sg.c,"{""sha"": ""503ab8b46c0b4e8a73d7e826ba1aaf3be1abd6b0"", ""filename"": ""drivers/scsi/sg.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/f3951a3709ff50990bf3e188c27d346792103432/drivers/scsi/sg.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f3951a3709ff50990bf3e188c27d346792103432/drivers/scsi/sg.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/scsi/sg.c?ref=f3951a3709ff50990bf3e188c27d346792103432"", ""patch"": ""@@ -787,8 +787,14 @@ sg_common_write(Sg_fd * sfp, Sg_request * srp,\n \t\treturn k;\t/* probably out of space --> ENOMEM */\n \t}\n \tif (atomic_read(&sdp->detaching)) {\n-\t\tif (srp->bio)\n+\t\tif (srp->bio) {\n+\t\t\tif (srp->rq->cmd != srp->rq->__cmd)\n+\t\t\t\tkfree(srp->rq->cmd);\n+\n \t\t\tblk_end_request_all(srp->rq, -EIO);\n+\t\t\tsrp->rq = NULL;\n+\t\t}\n+\n \t\tsg_finish_rem_req(srp);\n \t\treturn -ENODEV;\n \t}""}","sg_common_write(Sg_fd * sfp, Sg_request * srp,
		unsigned char *cmnd, int timeout, int blocking)
{
	int k, at_head;
	Sg_device *sdp = sfp->parentdp;
	sg_io_hdr_t *hp = &srp->header;

	srp->data.cmd_opcode = cmnd[0];	/* hold opcode of command */
	hp->status = 0;
	hp->masked_status = 0;
	hp->msg_status = 0;
	hp->info = 0;
	hp->host_status = 0;
	hp->driver_status = 0;
	hp->resid = 0;
	SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,
			""sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\n"",
			(int) cmnd[0], (int) hp->cmd_len));

	k = sg_start_req(srp, cmnd);
	if (k) {
		SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sfp->parentdp,
			""sg_common_write: start_req err=%d\n"", k));
		sg_finish_rem_req(srp);
 		return k;	/* probably out of space --> ENOMEM */
 	}
 	if (atomic_read(&sdp->detaching)) {
		if (srp->bio) {
			if (srp->rq->cmd != srp->rq->__cmd)
				kfree(srp->rq->cmd);

 			blk_end_request_all(srp->rq, -EIO);
			srp->rq = NULL;
		}

 		sg_finish_rem_req(srp);
 		return -ENODEV;
 	}

	hp->duration = jiffies_to_msecs(jiffies);
	if (hp->interface_id != '\0' &&	/* v3 (or later) interface */
	    (SG_FLAG_Q_AT_TAIL & hp->flags))
		at_head = 0;
	else
		at_head = 1;

	srp->rq->timeout = timeout;
	kref_get(&sfp->f_ref); /* sg_rq_end_io() does kref_put(). */
	blk_execute_rq_nowait(sdp->device->request_queue, sdp->disk,
			      srp->rq, at_head, sg_rq_end_io);
	return 0;
}
","sg_common_write(Sg_fd * sfp, Sg_request * srp,
		unsigned char *cmnd, int timeout, int blocking)
{
	int k, at_head;
	Sg_device *sdp = sfp->parentdp;
	sg_io_hdr_t *hp = &srp->header;

	srp->data.cmd_opcode = cmnd[0];	/* hold opcode of command */
	hp->status = 0;
	hp->masked_status = 0;
	hp->msg_status = 0;
	hp->info = 0;
	hp->host_status = 0;
	hp->driver_status = 0;
	hp->resid = 0;
	SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,
			""sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\n"",
			(int) cmnd[0], (int) hp->cmd_len));

	k = sg_start_req(srp, cmnd);
	if (k) {
		SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sfp->parentdp,
			""sg_common_write: start_req err=%d\n"", k));
		sg_finish_rem_req(srp);
 		return k;	/* probably out of space --> ENOMEM */
 	}
 	if (atomic_read(&sdp->detaching)) {
		if (srp->bio)
 			blk_end_request_all(srp->rq, -EIO);
 		sg_finish_rem_req(srp);
 		return -ENODEV;
 	}

	hp->duration = jiffies_to_msecs(jiffies);
	if (hp->interface_id != '\0' &&	/* v3 (or later) interface */
	    (SG_FLAG_Q_AT_TAIL & hp->flags))
		at_head = 0;
	else
		at_head = 1;

	srp->rq->timeout = timeout;
	kref_get(&sfp->f_ref); /* sg_rq_end_io() does kref_put(). */
	blk_execute_rq_nowait(sdp->device->request_queue, sdp->disk,
			      srp->rq, at_head, sg_rq_end_io);
	return 0;
}
",C,"		if (srp->bio) {
			if (srp->rq->cmd != srp->rq->__cmd)
				kfree(srp->rq->cmd);

			srp->rq = NULL;
		}

","		if (srp->bio)
",,"@@ -787,8 +787,14 @@ sg_common_write(Sg_fd * sfp, Sg_request * srp,
 		return k;	/* probably out of space --> ENOMEM */
 	}
 	if (atomic_read(&sdp->detaching)) {
-		if (srp->bio)
+		if (srp->bio) {
+			if (srp->rq->cmd != srp->rq->__cmd)
+				kfree(srp->rq->cmd);
+
 			blk_end_request_all(srp->rq, -EIO);
+			srp->rq = NULL;
+		}
+
 		sg_finish_rem_req(srp);
 		return -ENODEV;
 	}",linux,f3951a3709ff50990bf3e188c27d346792103432,c913df3f3d6f7f5e5ed845e2786b0fc98a41482f,1,"sg_common_write(Sg_fd * sfp, Sg_request * srp,
		unsigned char *cmnd, int timeout, int blocking)
{
	int k, at_head;
	Sg_device *sdp = sfp->parentdp;
	sg_io_hdr_t *hp = &srp->header;

	srp->data.cmd_opcode = cmnd[0];	/* hold opcode of command */
	hp->status = 0;
	hp->masked_status = 0;
	hp->msg_status = 0;
	hp->info = 0;
	hp->host_status = 0;
	hp->driver_status = 0;
	hp->resid = 0;
	SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,
			""sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\n"",
			(int) cmnd[0], (int) hp->cmd_len));

	k = sg_start_req(srp, cmnd);
	if (k) {
		SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sfp->parentdp,
			""sg_common_write: start_req err=%d\n"", k));
		sg_finish_rem_req(srp);
 		return k;	/* probably out of space --> ENOMEM */
 	}
 	if (atomic_read(&sdp->detaching)) {
//flaw_line_below:
		if (srp->bio)
//fix_flaw_line_below:
//		if (srp->bio) {
//fix_flaw_line_below:
//			if (srp->rq->cmd != srp->rq->__cmd)
//fix_flaw_line_below:
//				kfree(srp->rq->cmd);
//fix_flaw_line_below:
//
 			blk_end_request_all(srp->rq, -EIO);
//fix_flaw_line_below:
//			srp->rq = NULL;
//fix_flaw_line_below:
//		}
//fix_flaw_line_below:
//
 		sg_finish_rem_req(srp);
 		return -ENODEV;
 	}

	hp->duration = jiffies_to_msecs(jiffies);
	if (hp->interface_id != '\0' &&	/* v3 (or later) interface */
	    (SG_FLAG_Q_AT_TAIL & hp->flags))
		at_head = 0;
	else
		at_head = 1;

	srp->rq->timeout = timeout;
	kref_get(&sfp->f_ref); /* sg_rq_end_io() does kref_put(). */
	blk_execute_rq_nowait(sdp->device->request_queue, sdp->disk,
			      srp->rq, at_head, sg_rq_end_io);
	return 0;
}
"
3103,180839,,Remote,Not required,Complete,CVE-2017-16820,https://www.cvedetails.com/cve/CVE-2017-16820/,CWE-415,Low,Complete,Complete,,2017-11-14,10.0,"The csnmp_read_table function in snmp.c in the SNMP plugin in collectd before 5.6.3 is susceptible to a double free in a certain error case, which could lead to a crash (or potentially have other impact).",2018-09-04,,2,https://github.com/collectd/collectd/commit/d16c24542b2f96a194d43a73c2e5778822b9cb47,d16c24542b2f96a194d43a73c2e5778822b9cb47,"snmp plugin: Fix double free of request PDU

snmp_sess_synch_response() always frees request PDU, in both case of request
error and success. If error condition occurs inside of `while (status == 0)`
loop, double free of `req` happens.

Issue: #2291
Signed-off-by: Florian Forster <octo@collectd.org>",5,src/snmp.c,"{""sha"": ""6e26ad59da4b2b05da4e8813754392fa66d3c43e"", ""filename"": ""src/snmp.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 5, ""changes"": 7, ""blob_url"": ""https://github.com/collectd/collectd/blob/d16c24542b2f96a194d43a73c2e5778822b9cb47/src/snmp.c"", ""raw_url"": ""https://github.com/collectd/collectd/raw/d16c24542b2f96a194d43a73c2e5778822b9cb47/src/snmp.c"", ""contents_url"": ""https://api.github.com/repos/collectd/collectd/contents/src/snmp.c?ref=d16c24542b2f96a194d43a73c2e5778822b9cb47"", ""patch"": ""@@ -1357,11 +1357,13 @@ static int csnmp_read_table(host_definition_t *host, data_definition_t *data) {\n     if (oid_list_todo_num == 0) {\n       /* The request is still empty - so we are finished */\n       DEBUG(\""snmp plugin: all variables have left their subtree\"");\n+      snmp_free_pdu(req);\n       status = 0;\n       break;\n     }\n \n     res = NULL;\n+    /* snmp_sess_synch_response always frees our req PDU */\n     status = snmp_sess_synch_response(host->sess_handle, req, &res);\n     if ((status != STAT_SUCCESS) || (res == NULL)) {\n       char *errstr = NULL;\n@@ -1376,8 +1378,6 @@ static int csnmp_read_table(host_definition_t *host, data_definition_t *data) {\n         snmp_free_pdu(res);\n       res = NULL;\n \n-      /* snmp_synch_response already freed our PDU */\n-      req = NULL;\n       sfree(errstr);\n       csnmp_host_close_session(host);\n \n@@ -1492,9 +1492,6 @@ static int csnmp_read_table(host_definition_t *host, data_definition_t *data) {\n     snmp_free_pdu(res);\n   res = NULL;\n \n-  if (req != NULL)\n-    snmp_free_pdu(req);\n-  req = NULL;\n \n   if (status == 0)\n     csnmp_dispatch_table(host, data, instance_list_head, value_list_head);""}","static int csnmp_read_table(host_definition_t *host, data_definition_t *data) {
  struct snmp_pdu *req;
  struct snmp_pdu *res = NULL;
  struct variable_list *vb;

  const data_set_t *ds;

  size_t oid_list_len = data->values_len + 1;
  /* Holds the last OID returned by the device. We use this in the GETNEXT
   * request to proceed. */
  oid_t oid_list[oid_list_len];
  /* Set to false when an OID has left its subtree so we don't re-request it
   * again. */
  _Bool oid_list_todo[oid_list_len];

  int status;
  size_t i;

  /* `value_list_head' and `value_list_tail' implement a linked list for each
   * value. `instance_list_head' and `instance_list_tail' implement a linked
   * list of
   * instance names. This is used to jump gaps in the table. */
  csnmp_list_instances_t *instance_list_head;
  csnmp_list_instances_t *instance_list_tail;
  csnmp_table_values_t **value_list_head;
  csnmp_table_values_t **value_list_tail;

  DEBUG(""snmp plugin: csnmp_read_table (host = %s, data = %s)"", host->name,
        data->name);

  if (host->sess_handle == NULL) {
    DEBUG(""snmp plugin: csnmp_read_table: host->sess_handle == NULL"");
    return (-1);
  }

  ds = plugin_get_ds(data->type);
  if (!ds) {
    ERROR(""snmp plugin: DataSet `%s' not defined."", data->type);
    return (-1);
  }

  if (ds->ds_num != data->values_len) {
    ERROR(""snmp plugin: DataSet `%s' requires %zu values, but config talks ""
          ""about %zu"",
          data->type, ds->ds_num, data->values_len);
    return (-1);
  }
  assert(data->values_len > 0);

  /* We need a copy of all the OIDs, because GETNEXT will destroy them. */
  memcpy(oid_list, data->values, data->values_len * sizeof(oid_t));
  if (data->instance.oid.oid_len > 0)
    memcpy(oid_list + data->values_len, &data->instance.oid, sizeof(oid_t));
  else /* no InstanceFrom option specified. */
    oid_list_len--;

  for (i = 0; i < oid_list_len; i++)
    oid_list_todo[i] = 1;

  /* We're going to construct n linked lists, one for each ""value"".
   * value_list_head will contain pointers to the heads of these linked lists,
   * value_list_tail will contain pointers to the tail of the lists. */
  value_list_head = calloc(data->values_len, sizeof(*value_list_head));
  value_list_tail = calloc(data->values_len, sizeof(*value_list_tail));
  if ((value_list_head == NULL) || (value_list_tail == NULL)) {
    ERROR(""snmp plugin: csnmp_read_table: calloc failed."");
    sfree(value_list_head);
    sfree(value_list_tail);
    return (-1);
  }

  instance_list_head = NULL;
  instance_list_tail = NULL;

  status = 0;
  while (status == 0) {
    int oid_list_todo_num;

    req = snmp_pdu_create(SNMP_MSG_GETNEXT);
    if (req == NULL) {
      ERROR(""snmp plugin: snmp_pdu_create failed."");
      status = -1;
      break;
    }

    oid_list_todo_num = 0;
    for (i = 0; i < oid_list_len; i++) {
      /* Do not rerequest already finished OIDs */
      if (!oid_list_todo[i])
        continue;
      oid_list_todo_num++;
      snmp_add_null_var(req, oid_list[i].oid, oid_list[i].oid_len);
    }

     if (oid_list_todo_num == 0) {
       /* The request is still empty - so we are finished */
       DEBUG(""snmp plugin: all variables have left their subtree"");
      snmp_free_pdu(req);
       status = 0;
       break;
     }
 
     res = NULL;
    /* snmp_sess_synch_response always frees our req PDU */
     status = snmp_sess_synch_response(host->sess_handle, req, &res);
     if ((status != STAT_SUCCESS) || (res == NULL)) {
       char *errstr = NULL;

      snmp_sess_error(host->sess_handle, NULL, NULL, &errstr);

      c_complain(LOG_ERR, &host->complaint,
                 ""snmp plugin: host %s: snmp_sess_synch_response failed: %s"",
                 host->name, (errstr == NULL) ? ""Unknown problem"" : errstr);

      if (res != NULL)
         snmp_free_pdu(res);
       res = NULL;
 
       sfree(errstr);
       csnmp_host_close_session(host);
 
      status = -1;
      break;
    }

    status = 0;
    assert(res != NULL);
    c_release(LOG_INFO, &host->complaint,
              ""snmp plugin: host %s: snmp_sess_synch_response successful."",
              host->name);

    vb = res->variables;
    if (vb == NULL) {
      status = -1;
      break;
    }

    for (vb = res->variables, i = 0; (vb != NULL);
         vb = vb->next_variable, i++) {
      /* Calculate value index from todo list */
      while ((i < oid_list_len) && !oid_list_todo[i])
        i++;

      /* An instance is configured and the res variable we process is the
       * instance value (last index) */
      if ((data->instance.oid.oid_len > 0) && (i == data->values_len)) {
        if ((vb->type == SNMP_ENDOFMIBVIEW) ||
            (snmp_oid_ncompare(
                 data->instance.oid.oid, data->instance.oid.oid_len, vb->name,
                 vb->name_length, data->instance.oid.oid_len) != 0)) {
          DEBUG(""snmp plugin: host = %s; data = %s; Instance left its subtree."",
                host->name, data->name);
          oid_list_todo[i] = 0;
          continue;
        }

        /* Allocate a new `csnmp_list_instances_t', insert the instance name and
         * add it to the list */
        if (csnmp_instance_list_add(&instance_list_head, &instance_list_tail,
                                    res, host, data) != 0) {
          ERROR(""snmp plugin: host %s: csnmp_instance_list_add failed."",
                host->name);
          status = -1;
          break;
        }
      } else /* The variable we are processing is a normal value */
      {
        csnmp_table_values_t *vt;
        oid_t vb_name;
        oid_t suffix;
        int ret;

        csnmp_oid_init(&vb_name, vb->name, vb->name_length);

        /* Calculate the current suffix. This is later used to check that the
         * suffix is increasing. This also checks if we left the subtree */
        ret = csnmp_oid_suffix(&suffix, &vb_name, data->values + i);
        if (ret != 0) {
          DEBUG(""snmp plugin: host = %s; data = %s; i = %zu; ""
                ""Value probably left its subtree."",
                host->name, data->name, i);
          oid_list_todo[i] = 0;
          continue;
        }

        /* Make sure the OIDs returned by the agent are increasing. Otherwise
         * our
         * table matching algorithm will get confused. */
        if ((value_list_tail[i] != NULL) &&
            (csnmp_oid_compare(&suffix, &value_list_tail[i]->suffix) <= 0)) {
          DEBUG(""snmp plugin: host = %s; data = %s; i = %zu; ""
                ""Suffix is not increasing."",
                host->name, data->name, i);
          oid_list_todo[i] = 0;
          continue;
        }

        vt = calloc(1, sizeof(*vt));
        if (vt == NULL) {
          ERROR(""snmp plugin: calloc failed."");
          status = -1;
          break;
        }

        vt->value =
            csnmp_value_list_to_value(vb, ds->ds[i].type, data->scale,
                                      data->shift, host->name, data->name);
        memcpy(&vt->suffix, &suffix, sizeof(vt->suffix));
        vt->next = NULL;

        if (value_list_tail[i] == NULL)
          value_list_head[i] = vt;
        else
          value_list_tail[i]->next = vt;
        value_list_tail[i] = vt;
      }

      /* Copy OID to oid_list[i] */
      memcpy(oid_list[i].oid, vb->name, sizeof(oid) * vb->name_length);
      oid_list[i].oid_len = vb->name_length;

    } /* for (vb = res->variables ...) */

    if (res != NULL)
      snmp_free_pdu(res);
    res = NULL;
  } /* while (status == 0) */

  if (res != NULL)
     snmp_free_pdu(res);
   res = NULL;
 
 
   if (status == 0)
     csnmp_dispatch_table(host, data, instance_list_head, value_list_head);

  /* Free all allocated variables here */
  while (instance_list_head != NULL) {
    csnmp_list_instances_t *next = instance_list_head->next;
    sfree(instance_list_head);
    instance_list_head = next;
  }

  for (i = 0; i < data->values_len; i++) {
    while (value_list_head[i] != NULL) {
      csnmp_table_values_t *next = value_list_head[i]->next;
      sfree(value_list_head[i]);
      value_list_head[i] = next;
    }
  }

  sfree(value_list_head);
  sfree(value_list_tail);

  return (0);
} /* int csnmp_read_table */
","static int csnmp_read_table(host_definition_t *host, data_definition_t *data) {
  struct snmp_pdu *req;
  struct snmp_pdu *res = NULL;
  struct variable_list *vb;

  const data_set_t *ds;

  size_t oid_list_len = data->values_len + 1;
  /* Holds the last OID returned by the device. We use this in the GETNEXT
   * request to proceed. */
  oid_t oid_list[oid_list_len];
  /* Set to false when an OID has left its subtree so we don't re-request it
   * again. */
  _Bool oid_list_todo[oid_list_len];

  int status;
  size_t i;

  /* `value_list_head' and `value_list_tail' implement a linked list for each
   * value. `instance_list_head' and `instance_list_tail' implement a linked
   * list of
   * instance names. This is used to jump gaps in the table. */
  csnmp_list_instances_t *instance_list_head;
  csnmp_list_instances_t *instance_list_tail;
  csnmp_table_values_t **value_list_head;
  csnmp_table_values_t **value_list_tail;

  DEBUG(""snmp plugin: csnmp_read_table (host = %s, data = %s)"", host->name,
        data->name);

  if (host->sess_handle == NULL) {
    DEBUG(""snmp plugin: csnmp_read_table: host->sess_handle == NULL"");
    return (-1);
  }

  ds = plugin_get_ds(data->type);
  if (!ds) {
    ERROR(""snmp plugin: DataSet `%s' not defined."", data->type);
    return (-1);
  }

  if (ds->ds_num != data->values_len) {
    ERROR(""snmp plugin: DataSet `%s' requires %zu values, but config talks ""
          ""about %zu"",
          data->type, ds->ds_num, data->values_len);
    return (-1);
  }
  assert(data->values_len > 0);

  /* We need a copy of all the OIDs, because GETNEXT will destroy them. */
  memcpy(oid_list, data->values, data->values_len * sizeof(oid_t));
  if (data->instance.oid.oid_len > 0)
    memcpy(oid_list + data->values_len, &data->instance.oid, sizeof(oid_t));
  else /* no InstanceFrom option specified. */
    oid_list_len--;

  for (i = 0; i < oid_list_len; i++)
    oid_list_todo[i] = 1;

  /* We're going to construct n linked lists, one for each ""value"".
   * value_list_head will contain pointers to the heads of these linked lists,
   * value_list_tail will contain pointers to the tail of the lists. */
  value_list_head = calloc(data->values_len, sizeof(*value_list_head));
  value_list_tail = calloc(data->values_len, sizeof(*value_list_tail));
  if ((value_list_head == NULL) || (value_list_tail == NULL)) {
    ERROR(""snmp plugin: csnmp_read_table: calloc failed."");
    sfree(value_list_head);
    sfree(value_list_tail);
    return (-1);
  }

  instance_list_head = NULL;
  instance_list_tail = NULL;

  status = 0;
  while (status == 0) {
    int oid_list_todo_num;

    req = snmp_pdu_create(SNMP_MSG_GETNEXT);
    if (req == NULL) {
      ERROR(""snmp plugin: snmp_pdu_create failed."");
      status = -1;
      break;
    }

    oid_list_todo_num = 0;
    for (i = 0; i < oid_list_len; i++) {
      /* Do not rerequest already finished OIDs */
      if (!oid_list_todo[i])
        continue;
      oid_list_todo_num++;
      snmp_add_null_var(req, oid_list[i].oid, oid_list[i].oid_len);
    }

     if (oid_list_todo_num == 0) {
       /* The request is still empty - so we are finished */
       DEBUG(""snmp plugin: all variables have left their subtree"");
       status = 0;
       break;
     }
 
     res = NULL;
     status = snmp_sess_synch_response(host->sess_handle, req, &res);
     if ((status != STAT_SUCCESS) || (res == NULL)) {
       char *errstr = NULL;

      snmp_sess_error(host->sess_handle, NULL, NULL, &errstr);

      c_complain(LOG_ERR, &host->complaint,
                 ""snmp plugin: host %s: snmp_sess_synch_response failed: %s"",
                 host->name, (errstr == NULL) ? ""Unknown problem"" : errstr);

      if (res != NULL)
         snmp_free_pdu(res);
       res = NULL;
 
      /* snmp_synch_response already freed our PDU */
      req = NULL;
       sfree(errstr);
       csnmp_host_close_session(host);
 
      status = -1;
      break;
    }

    status = 0;
    assert(res != NULL);
    c_release(LOG_INFO, &host->complaint,
              ""snmp plugin: host %s: snmp_sess_synch_response successful."",
              host->name);

    vb = res->variables;
    if (vb == NULL) {
      status = -1;
      break;
    }

    for (vb = res->variables, i = 0; (vb != NULL);
         vb = vb->next_variable, i++) {
      /* Calculate value index from todo list */
      while ((i < oid_list_len) && !oid_list_todo[i])
        i++;

      /* An instance is configured and the res variable we process is the
       * instance value (last index) */
      if ((data->instance.oid.oid_len > 0) && (i == data->values_len)) {
        if ((vb->type == SNMP_ENDOFMIBVIEW) ||
            (snmp_oid_ncompare(
                 data->instance.oid.oid, data->instance.oid.oid_len, vb->name,
                 vb->name_length, data->instance.oid.oid_len) != 0)) {
          DEBUG(""snmp plugin: host = %s; data = %s; Instance left its subtree."",
                host->name, data->name);
          oid_list_todo[i] = 0;
          continue;
        }

        /* Allocate a new `csnmp_list_instances_t', insert the instance name and
         * add it to the list */
        if (csnmp_instance_list_add(&instance_list_head, &instance_list_tail,
                                    res, host, data) != 0) {
          ERROR(""snmp plugin: host %s: csnmp_instance_list_add failed."",
                host->name);
          status = -1;
          break;
        }
      } else /* The variable we are processing is a normal value */
      {
        csnmp_table_values_t *vt;
        oid_t vb_name;
        oid_t suffix;
        int ret;

        csnmp_oid_init(&vb_name, vb->name, vb->name_length);

        /* Calculate the current suffix. This is later used to check that the
         * suffix is increasing. This also checks if we left the subtree */
        ret = csnmp_oid_suffix(&suffix, &vb_name, data->values + i);
        if (ret != 0) {
          DEBUG(""snmp plugin: host = %s; data = %s; i = %zu; ""
                ""Value probably left its subtree."",
                host->name, data->name, i);
          oid_list_todo[i] = 0;
          continue;
        }

        /* Make sure the OIDs returned by the agent are increasing. Otherwise
         * our
         * table matching algorithm will get confused. */
        if ((value_list_tail[i] != NULL) &&
            (csnmp_oid_compare(&suffix, &value_list_tail[i]->suffix) <= 0)) {
          DEBUG(""snmp plugin: host = %s; data = %s; i = %zu; ""
                ""Suffix is not increasing."",
                host->name, data->name, i);
          oid_list_todo[i] = 0;
          continue;
        }

        vt = calloc(1, sizeof(*vt));
        if (vt == NULL) {
          ERROR(""snmp plugin: calloc failed."");
          status = -1;
          break;
        }

        vt->value =
            csnmp_value_list_to_value(vb, ds->ds[i].type, data->scale,
                                      data->shift, host->name, data->name);
        memcpy(&vt->suffix, &suffix, sizeof(vt->suffix));
        vt->next = NULL;

        if (value_list_tail[i] == NULL)
          value_list_head[i] = vt;
        else
          value_list_tail[i]->next = vt;
        value_list_tail[i] = vt;
      }

      /* Copy OID to oid_list[i] */
      memcpy(oid_list[i].oid, vb->name, sizeof(oid) * vb->name_length);
      oid_list[i].oid_len = vb->name_length;

    } /* for (vb = res->variables ...) */

    if (res != NULL)
      snmp_free_pdu(res);
    res = NULL;
  } /* while (status == 0) */

  if (res != NULL)
     snmp_free_pdu(res);
   res = NULL;
 
  if (req != NULL)
    snmp_free_pdu(req);
  req = NULL;
 
   if (status == 0)
     csnmp_dispatch_table(host, data, instance_list_head, value_list_head);

  /* Free all allocated variables here */
  while (instance_list_head != NULL) {
    csnmp_list_instances_t *next = instance_list_head->next;
    sfree(instance_list_head);
    instance_list_head = next;
  }

  for (i = 0; i < data->values_len; i++) {
    while (value_list_head[i] != NULL) {
      csnmp_table_values_t *next = value_list_head[i]->next;
      sfree(value_list_head[i]);
      value_list_head[i] = next;
    }
  }

  sfree(value_list_head);
  sfree(value_list_tail);

  return (0);
} /* int csnmp_read_table */
",C,"      snmp_free_pdu(req);
    /* snmp_sess_synch_response always frees our req PDU */
","      /* snmp_synch_response already freed our PDU */
      req = NULL;
  if (req != NULL)
    snmp_free_pdu(req);
  req = NULL;
",,"@@ -1357,11 +1357,13 @@ static int csnmp_read_table(host_definition_t *host, data_definition_t *data) {
     if (oid_list_todo_num == 0) {
       /* The request is still empty - so we are finished */
       DEBUG(""snmp plugin: all variables have left their subtree"");
+      snmp_free_pdu(req);
       status = 0;
       break;
     }
 
     res = NULL;
+    /* snmp_sess_synch_response always frees our req PDU */
     status = snmp_sess_synch_response(host->sess_handle, req, &res);
     if ((status != STAT_SUCCESS) || (res == NULL)) {
       char *errstr = NULL;
@@ -1376,8 +1378,6 @@ static int csnmp_read_table(host_definition_t *host, data_definition_t *data) {
         snmp_free_pdu(res);
       res = NULL;
 
-      /* snmp_synch_response already freed our PDU */
-      req = NULL;
       sfree(errstr);
       csnmp_host_close_session(host);
 
@@ -1492,9 +1492,6 @@ static int csnmp_read_table(host_definition_t *host, data_definition_t *data) {
     snmp_free_pdu(res);
   res = NULL;
 
-  if (req != NULL)
-    snmp_free_pdu(req);
-  req = NULL;
 
   if (status == 0)
     csnmp_dispatch_table(host, data, instance_list_head, value_list_head);",collectd,d16c24542b2f96a194d43a73c2e5778822b9cb47,6c082e955466f0c451d608fb3cbb31481c02fa37,1,"static int csnmp_read_table(host_definition_t *host, data_definition_t *data) {
  struct snmp_pdu *req;
  struct snmp_pdu *res = NULL;
  struct variable_list *vb;

  const data_set_t *ds;

  size_t oid_list_len = data->values_len + 1;
  /* Holds the last OID returned by the device. We use this in the GETNEXT
   * request to proceed. */
  oid_t oid_list[oid_list_len];
  /* Set to false when an OID has left its subtree so we don't re-request it
   * again. */
  _Bool oid_list_todo[oid_list_len];

  int status;
  size_t i;

  /* `value_list_head' and `value_list_tail' implement a linked list for each
   * value. `instance_list_head' and `instance_list_tail' implement a linked
   * list of
   * instance names. This is used to jump gaps in the table. */
  csnmp_list_instances_t *instance_list_head;
  csnmp_list_instances_t *instance_list_tail;
  csnmp_table_values_t **value_list_head;
  csnmp_table_values_t **value_list_tail;

  DEBUG(""snmp plugin: csnmp_read_table (host = %s, data = %s)"", host->name,
        data->name);

  if (host->sess_handle == NULL) {
    DEBUG(""snmp plugin: csnmp_read_table: host->sess_handle == NULL"");
    return (-1);
  }

  ds = plugin_get_ds(data->type);
  if (!ds) {
    ERROR(""snmp plugin: DataSet `%s' not defined."", data->type);
    return (-1);
  }

  if (ds->ds_num != data->values_len) {
    ERROR(""snmp plugin: DataSet `%s' requires %zu values, but config talks ""
          ""about %zu"",
          data->type, ds->ds_num, data->values_len);
    return (-1);
  }
  assert(data->values_len > 0);

  /* We need a copy of all the OIDs, because GETNEXT will destroy them. */
  memcpy(oid_list, data->values, data->values_len * sizeof(oid_t));
  if (data->instance.oid.oid_len > 0)
    memcpy(oid_list + data->values_len, &data->instance.oid, sizeof(oid_t));
  else /* no InstanceFrom option specified. */
    oid_list_len--;

  for (i = 0; i < oid_list_len; i++)
    oid_list_todo[i] = 1;

  /* We're going to construct n linked lists, one for each ""value"".
   * value_list_head will contain pointers to the heads of these linked lists,
   * value_list_tail will contain pointers to the tail of the lists. */
  value_list_head = calloc(data->values_len, sizeof(*value_list_head));
  value_list_tail = calloc(data->values_len, sizeof(*value_list_tail));
  if ((value_list_head == NULL) || (value_list_tail == NULL)) {
    ERROR(""snmp plugin: csnmp_read_table: calloc failed."");
    sfree(value_list_head);
    sfree(value_list_tail);
    return (-1);
  }

  instance_list_head = NULL;
  instance_list_tail = NULL;

  status = 0;
  while (status == 0) {
    int oid_list_todo_num;

    req = snmp_pdu_create(SNMP_MSG_GETNEXT);
    if (req == NULL) {
      ERROR(""snmp plugin: snmp_pdu_create failed."");
      status = -1;
      break;
    }

    oid_list_todo_num = 0;
    for (i = 0; i < oid_list_len; i++) {
      /* Do not rerequest already finished OIDs */
      if (!oid_list_todo[i])
        continue;
      oid_list_todo_num++;
      snmp_add_null_var(req, oid_list[i].oid, oid_list[i].oid_len);
    }

     if (oid_list_todo_num == 0) {
       /* The request is still empty - so we are finished */
       DEBUG(""snmp plugin: all variables have left their subtree"");
//fix_flaw_line_below:
//      snmp_free_pdu(req);
       status = 0;
       break;
     }
 
     res = NULL;
//fix_flaw_line_below:
//    /* snmp_sess_synch_response always frees our req PDU */
     status = snmp_sess_synch_response(host->sess_handle, req, &res);
     if ((status != STAT_SUCCESS) || (res == NULL)) {
       char *errstr = NULL;

      snmp_sess_error(host->sess_handle, NULL, NULL, &errstr);

      c_complain(LOG_ERR, &host->complaint,
                 ""snmp plugin: host %s: snmp_sess_synch_response failed: %s"",
                 host->name, (errstr == NULL) ? ""Unknown problem"" : errstr);

      if (res != NULL)
         snmp_free_pdu(res);
       res = NULL;
 
//flaw_line_below:
      /* snmp_synch_response already freed our PDU */
//flaw_line_below:
      req = NULL;
       sfree(errstr);
       csnmp_host_close_session(host);
 
      status = -1;
      break;
    }

    status = 0;
    assert(res != NULL);
    c_release(LOG_INFO, &host->complaint,
              ""snmp plugin: host %s: snmp_sess_synch_response successful."",
              host->name);

    vb = res->variables;
    if (vb == NULL) {
      status = -1;
      break;
    }

    for (vb = res->variables, i = 0; (vb != NULL);
         vb = vb->next_variable, i++) {
      /* Calculate value index from todo list */
      while ((i < oid_list_len) && !oid_list_todo[i])
        i++;

      /* An instance is configured and the res variable we process is the
       * instance value (last index) */
      if ((data->instance.oid.oid_len > 0) && (i == data->values_len)) {
        if ((vb->type == SNMP_ENDOFMIBVIEW) ||
            (snmp_oid_ncompare(
                 data->instance.oid.oid, data->instance.oid.oid_len, vb->name,
                 vb->name_length, data->instance.oid.oid_len) != 0)) {
          DEBUG(""snmp plugin: host = %s; data = %s; Instance left its subtree."",
                host->name, data->name);
          oid_list_todo[i] = 0;
          continue;
        }

        /* Allocate a new `csnmp_list_instances_t', insert the instance name and
         * add it to the list */
        if (csnmp_instance_list_add(&instance_list_head, &instance_list_tail,
                                    res, host, data) != 0) {
          ERROR(""snmp plugin: host %s: csnmp_instance_list_add failed."",
                host->name);
          status = -1;
          break;
        }
      } else /* The variable we are processing is a normal value */
      {
        csnmp_table_values_t *vt;
        oid_t vb_name;
        oid_t suffix;
        int ret;

        csnmp_oid_init(&vb_name, vb->name, vb->name_length);

        /* Calculate the current suffix. This is later used to check that the
         * suffix is increasing. This also checks if we left the subtree */
        ret = csnmp_oid_suffix(&suffix, &vb_name, data->values + i);
        if (ret != 0) {
          DEBUG(""snmp plugin: host = %s; data = %s; i = %zu; ""
                ""Value probably left its subtree."",
                host->name, data->name, i);
          oid_list_todo[i] = 0;
          continue;
        }

        /* Make sure the OIDs returned by the agent are increasing. Otherwise
         * our
         * table matching algorithm will get confused. */
        if ((value_list_tail[i] != NULL) &&
            (csnmp_oid_compare(&suffix, &value_list_tail[i]->suffix) <= 0)) {
          DEBUG(""snmp plugin: host = %s; data = %s; i = %zu; ""
                ""Suffix is not increasing."",
                host->name, data->name, i);
          oid_list_todo[i] = 0;
          continue;
        }

        vt = calloc(1, sizeof(*vt));
        if (vt == NULL) {
          ERROR(""snmp plugin: calloc failed."");
          status = -1;
          break;
        }

        vt->value =
            csnmp_value_list_to_value(vb, ds->ds[i].type, data->scale,
                                      data->shift, host->name, data->name);
        memcpy(&vt->suffix, &suffix, sizeof(vt->suffix));
        vt->next = NULL;

        if (value_list_tail[i] == NULL)
          value_list_head[i] = vt;
        else
          value_list_tail[i]->next = vt;
        value_list_tail[i] = vt;
      }

      /* Copy OID to oid_list[i] */
      memcpy(oid_list[i].oid, vb->name, sizeof(oid) * vb->name_length);
      oid_list[i].oid_len = vb->name_length;

    } /* for (vb = res->variables ...) */

    if (res != NULL)
      snmp_free_pdu(res);
    res = NULL;
  } /* while (status == 0) */

  if (res != NULL)
     snmp_free_pdu(res);
   res = NULL;
 
//flaw_line_below:
  if (req != NULL)
//flaw_line_below:
    snmp_free_pdu(req);
//flaw_line_below:
  req = NULL;
 
   if (status == 0)
     csnmp_dispatch_table(host, data, instance_list_head, value_list_head);

  /* Free all allocated variables here */
  while (instance_list_head != NULL) {
    csnmp_list_instances_t *next = instance_list_head->next;
    sfree(instance_list_head);
    instance_list_head = next;
  }

  for (i = 0; i < data->values_len; i++) {
    while (value_list_head[i] != NULL) {
      csnmp_table_values_t *next = value_list_head[i]->next;
      sfree(value_list_head[i]);
      value_list_head[i] = next;
    }
  }

  sfree(value_list_head);
  sfree(value_list_tail);

  return (0);
} /* int csnmp_read_table */
"
3401,181137,,Remote,Not required,Partial,CVE-2017-12858,https://www.cvedetails.com/cve/CVE-2017-12858/,CWE-415,Low,Partial,Partial,,2017-08-23,7.5,Double free vulnerability in the _zip_dirent_read function in zip_dirent.c in libzip allows attackers to have unspecified impact via unknown vectors.,2017-08-26,,0,https://github.com/nih-at/libzip/commit/2217022b7d1142738656d891e00b3d2d9179b796,2217022b7d1142738656d891e00b3d2d9179b796,"Fix double free().

Found by Brian 'geeknik' Carpenter using AFL.",3,lib/zip_dirent.c,"{""sha"": ""a80ee1def1a24017d2e6e8992283262fe3bc55f7"", ""filename"": ""THANKS"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/nih-at/libzip/blob/2217022b7d1142738656d891e00b3d2d9179b796/THANKS"", ""raw_url"": ""https://github.com/nih-at/libzip/raw/2217022b7d1142738656d891e00b3d2d9179b796/THANKS"", ""contents_url"": ""https://api.github.com/repos/nih-at/libzip/contents/THANKS?ref=2217022b7d1142738656d891e00b3d2d9179b796"", ""patch"": ""@@ -12,6 +12,7 @@ BALATON Zoltan <balaton@eik.bme.hu>\n Benjamin Gilbert <bgilbert@backtick.net>\n Boaz Stolk <bstolk@aweta.nl>\n Bogdan <bogiebog@gmail.com>\n+Brian 'geeknik' Carpenter <geeknik@protonmail.ch>\n Chris Nehren <cnehren+libzip@pobox.com>\n Coverity <info@coverity.com>\n Dane Springmeyer <dane.springmeyer@gmail.com>""}<_**next**_>{""sha"": ""e5a7cc9dfd77d863adad84b6b02eddadc91a010e"", ""filename"": ""lib/zip_dirent.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/nih-at/libzip/blob/2217022b7d1142738656d891e00b3d2d9179b796/lib/zip_dirent.c"", ""raw_url"": ""https://github.com/nih-at/libzip/raw/2217022b7d1142738656d891e00b3d2d9179b796/lib/zip_dirent.c"", ""contents_url"": ""https://api.github.com/repos/nih-at/libzip/contents/lib/zip_dirent.c?ref=2217022b7d1142738656d891e00b3d2d9179b796"", ""patch"": ""@@ -579,9 +579,6 @@ _zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, boo\n     }\n \n     if (!_zip_dirent_process_winzip_aes(zde, error)) {\n-\tif (!from_buffer) {\n-\t    _zip_buffer_free(buffer);\n-\t}\n \treturn -1;\n     }\n ""}","_zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error)
{
    zip_uint8_t buf[CDENTRYSIZE];
    zip_uint16_t dostime, dosdate;
    zip_uint32_t size, variable_size;
    zip_uint16_t filename_len, comment_len, ef_len;

    bool from_buffer = (buffer != NULL);

    size = local ? LENTRYSIZE : CDENTRYSIZE;

    if (buffer) {
        if (_zip_buffer_left(buffer) < size) {
            zip_error_set(error, ZIP_ER_NOZIP, 0);
            return -1;
        }
    }
    else {
        if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) {
            return -1;
        }
    }

    if (memcmp(_zip_buffer_get(buffer, 4), (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {
	zip_error_set(error, ZIP_ER_NOZIP, 0);
        if (!from_buffer) {
            _zip_buffer_free(buffer);
        }
	return -1;
    }

    /* convert buffercontents to zip_dirent */

    _zip_dirent_init(zde);
    if (!local)
	zde->version_madeby = _zip_buffer_get_16(buffer);
    else
	zde->version_madeby = 0;
    zde->version_needed = _zip_buffer_get_16(buffer);
    zde->bitflags = _zip_buffer_get_16(buffer);
    zde->comp_method = _zip_buffer_get_16(buffer);

    /* convert to time_t */
    dostime = _zip_buffer_get_16(buffer);
    dosdate = _zip_buffer_get_16(buffer);
    zde->last_mod = _zip_d2u_time(dostime, dosdate);

    zde->crc = _zip_buffer_get_32(buffer);
    zde->comp_size = _zip_buffer_get_32(buffer);
    zde->uncomp_size = _zip_buffer_get_32(buffer);

    filename_len = _zip_buffer_get_16(buffer);
    ef_len = _zip_buffer_get_16(buffer);

    if (local) {
	comment_len = 0;
	zde->disk_number = 0;
	zde->int_attrib = 0;
	zde->ext_attrib = 0;
	zde->offset = 0;
    } else {
	comment_len = _zip_buffer_get_16(buffer);
	zde->disk_number = _zip_buffer_get_16(buffer);
	zde->int_attrib = _zip_buffer_get_16(buffer);
	zde->ext_attrib = _zip_buffer_get_32(buffer);
	zde->offset = _zip_buffer_get_32(buffer);
    }

    if (!_zip_buffer_ok(buffer)) {
        zip_error_set(error, ZIP_ER_INTERNAL, 0);
        if (!from_buffer) {
            _zip_buffer_free(buffer);
        }
        return -1;
    }

    if (zde->bitflags & ZIP_GPBF_ENCRYPTED) {
	if (zde->bitflags & ZIP_GPBF_STRONG_ENCRYPTION) {
	    /* TODO */
	    zde->encryption_method = ZIP_EM_UNKNOWN;
	}
	else {
	    zde->encryption_method = ZIP_EM_TRAD_PKWARE;
	}
    }
    else {
	zde->encryption_method = ZIP_EM_NONE;
    }

    zde->filename = NULL;
    zde->extra_fields = NULL;
    zde->comment = NULL;

    variable_size = (zip_uint32_t)filename_len+(zip_uint32_t)ef_len+(zip_uint32_t)comment_len;

    if (from_buffer) {
        if (_zip_buffer_left(buffer) < variable_size) {
            zip_error_set(error, ZIP_ER_INCONS, 0);
            return -1;
        }
    }
    else {
        _zip_buffer_free(buffer);

        if ((buffer = _zip_buffer_new_from_source(src, variable_size, NULL, error)) == NULL) {
            return -1;
        }
    }

    if (filename_len) {
	zde->filename = _zip_read_string(buffer, src, filename_len, 1, error);
        if (!zde->filename) {
            if (zip_error_code_zip(error) == ZIP_ER_EOF) {
                zip_error_set(error, ZIP_ER_INCONS, 0);
            }
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
	    return -1;
        }

	if (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {
	    if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {
		zip_error_set(error, ZIP_ER_INCONS, 0);
                if (!from_buffer) {
                    _zip_buffer_free(buffer);
                }
		return -1;
	    }
	}
    }

    if (ef_len) {
	zip_uint8_t *ef = _zip_read_data(buffer, src, ef_len, 0, error);

        if (ef == NULL) {
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
	    return -1;
        }
        if (!_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, &zde->extra_fields, error)) {
	    free(ef);
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
	    return -1;
	}
	free(ef);
	if (local)
	    zde->local_extra_fields_read = 1;
    }

    if (comment_len) {
	zde->comment = _zip_read_string(buffer, src, comment_len, 0, error);
        if (!zde->comment) {
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
	    return -1;
        }
	if (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {
	    if (_zip_guess_encoding(zde->comment, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {
		zip_error_set(error, ZIP_ER_INCONS, 0);
                if (!from_buffer) {
                    _zip_buffer_free(buffer);
                }
		return -1;
	    }
	}
    }

    zde->filename = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_NAME, zde->filename);
    zde->comment = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_COMMENT, zde->comment);

    /* Zip64 */

    if (zde->uncomp_size == ZIP_UINT32_MAX || zde->comp_size == ZIP_UINT32_MAX || zde->offset == ZIP_UINT32_MAX) {
	zip_uint16_t got_len;
        zip_buffer_t *ef_buffer;
	const zip_uint8_t *ef = _zip_ef_get_by_id(zde->extra_fields, &got_len, ZIP_EF_ZIP64, 0, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error);
	/* TODO: if got_len == 0 && !ZIP64_EOCD: no error, 0xffffffff is valid value */
        if (ef == NULL) {
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
	    return -1;
        }

        if ((ef_buffer = _zip_buffer_new((zip_uint8_t *)ef, got_len)) == NULL) {
            zip_error_set(error, ZIP_ER_MEMORY, 0);
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
            return -1;
        }

	if (zde->uncomp_size == ZIP_UINT32_MAX)
	    zde->uncomp_size = _zip_buffer_get_64(ef_buffer);
	else if (local) {
	    /* From appnote.txt: This entry in the Local header MUST
	       include BOTH original and compressed file size fields. */
            (void)_zip_buffer_skip(ef_buffer, 8); /* error is caught by _zip_buffer_eof() call */
	}
	if (zde->comp_size == ZIP_UINT32_MAX)
	    zde->comp_size = _zip_buffer_get_64(ef_buffer);
	if (!local) {
	    if (zde->offset == ZIP_UINT32_MAX)
		zde->offset = _zip_buffer_get_64(ef_buffer);
	    if (zde->disk_number == ZIP_UINT16_MAX)
		zde->disk_number = _zip_buffer_get_32(buffer);
	}

        if (!_zip_buffer_eof(ef_buffer)) {
            zip_error_set(error, ZIP_ER_INCONS, 0);
            _zip_buffer_free(ef_buffer);
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
            return -1;
        }
        _zip_buffer_free(ef_buffer);
    }

    if (!_zip_buffer_ok(buffer)) {
        zip_error_set(error, ZIP_ER_INTERNAL, 0);
        if (!from_buffer) {
            _zip_buffer_free(buffer);
        }
        return -1;
    }
    if (!from_buffer) {
        _zip_buffer_free(buffer);
    }

    /* zip_source_seek / zip_source_tell don't support values > ZIP_INT64_MAX */
    if (zde->offset > ZIP_INT64_MAX) {
	zip_error_set(error, ZIP_ER_SEEK, EFBIG);
	return -1;
     }
 
     if (!_zip_dirent_process_winzip_aes(zde, error)) {
 	return -1;
     }
 
    zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields);

    return (zip_int64_t)(size + variable_size);
}
","_zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error)
{
    zip_uint8_t buf[CDENTRYSIZE];
    zip_uint16_t dostime, dosdate;
    zip_uint32_t size, variable_size;
    zip_uint16_t filename_len, comment_len, ef_len;

    bool from_buffer = (buffer != NULL);

    size = local ? LENTRYSIZE : CDENTRYSIZE;

    if (buffer) {
        if (_zip_buffer_left(buffer) < size) {
            zip_error_set(error, ZIP_ER_NOZIP, 0);
            return -1;
        }
    }
    else {
        if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) {
            return -1;
        }
    }

    if (memcmp(_zip_buffer_get(buffer, 4), (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {
	zip_error_set(error, ZIP_ER_NOZIP, 0);
        if (!from_buffer) {
            _zip_buffer_free(buffer);
        }
	return -1;
    }

    /* convert buffercontents to zip_dirent */

    _zip_dirent_init(zde);
    if (!local)
	zde->version_madeby = _zip_buffer_get_16(buffer);
    else
	zde->version_madeby = 0;
    zde->version_needed = _zip_buffer_get_16(buffer);
    zde->bitflags = _zip_buffer_get_16(buffer);
    zde->comp_method = _zip_buffer_get_16(buffer);

    /* convert to time_t */
    dostime = _zip_buffer_get_16(buffer);
    dosdate = _zip_buffer_get_16(buffer);
    zde->last_mod = _zip_d2u_time(dostime, dosdate);

    zde->crc = _zip_buffer_get_32(buffer);
    zde->comp_size = _zip_buffer_get_32(buffer);
    zde->uncomp_size = _zip_buffer_get_32(buffer);

    filename_len = _zip_buffer_get_16(buffer);
    ef_len = _zip_buffer_get_16(buffer);

    if (local) {
	comment_len = 0;
	zde->disk_number = 0;
	zde->int_attrib = 0;
	zde->ext_attrib = 0;
	zde->offset = 0;
    } else {
	comment_len = _zip_buffer_get_16(buffer);
	zde->disk_number = _zip_buffer_get_16(buffer);
	zde->int_attrib = _zip_buffer_get_16(buffer);
	zde->ext_attrib = _zip_buffer_get_32(buffer);
	zde->offset = _zip_buffer_get_32(buffer);
    }

    if (!_zip_buffer_ok(buffer)) {
        zip_error_set(error, ZIP_ER_INTERNAL, 0);
        if (!from_buffer) {
            _zip_buffer_free(buffer);
        }
        return -1;
    }

    if (zde->bitflags & ZIP_GPBF_ENCRYPTED) {
	if (zde->bitflags & ZIP_GPBF_STRONG_ENCRYPTION) {
	    /* TODO */
	    zde->encryption_method = ZIP_EM_UNKNOWN;
	}
	else {
	    zde->encryption_method = ZIP_EM_TRAD_PKWARE;
	}
    }
    else {
	zde->encryption_method = ZIP_EM_NONE;
    }

    zde->filename = NULL;
    zde->extra_fields = NULL;
    zde->comment = NULL;

    variable_size = (zip_uint32_t)filename_len+(zip_uint32_t)ef_len+(zip_uint32_t)comment_len;

    if (from_buffer) {
        if (_zip_buffer_left(buffer) < variable_size) {
            zip_error_set(error, ZIP_ER_INCONS, 0);
            return -1;
        }
    }
    else {
        _zip_buffer_free(buffer);

        if ((buffer = _zip_buffer_new_from_source(src, variable_size, NULL, error)) == NULL) {
            return -1;
        }
    }

    if (filename_len) {
	zde->filename = _zip_read_string(buffer, src, filename_len, 1, error);
        if (!zde->filename) {
            if (zip_error_code_zip(error) == ZIP_ER_EOF) {
                zip_error_set(error, ZIP_ER_INCONS, 0);
            }
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
	    return -1;
        }

	if (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {
	    if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {
		zip_error_set(error, ZIP_ER_INCONS, 0);
                if (!from_buffer) {
                    _zip_buffer_free(buffer);
                }
		return -1;
	    }
	}
    }

    if (ef_len) {
	zip_uint8_t *ef = _zip_read_data(buffer, src, ef_len, 0, error);

        if (ef == NULL) {
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
	    return -1;
        }
        if (!_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, &zde->extra_fields, error)) {
	    free(ef);
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
	    return -1;
	}
	free(ef);
	if (local)
	    zde->local_extra_fields_read = 1;
    }

    if (comment_len) {
	zde->comment = _zip_read_string(buffer, src, comment_len, 0, error);
        if (!zde->comment) {
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
	    return -1;
        }
	if (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {
	    if (_zip_guess_encoding(zde->comment, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {
		zip_error_set(error, ZIP_ER_INCONS, 0);
                if (!from_buffer) {
                    _zip_buffer_free(buffer);
                }
		return -1;
	    }
	}
    }

    zde->filename = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_NAME, zde->filename);
    zde->comment = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_COMMENT, zde->comment);

    /* Zip64 */

    if (zde->uncomp_size == ZIP_UINT32_MAX || zde->comp_size == ZIP_UINT32_MAX || zde->offset == ZIP_UINT32_MAX) {
	zip_uint16_t got_len;
        zip_buffer_t *ef_buffer;
	const zip_uint8_t *ef = _zip_ef_get_by_id(zde->extra_fields, &got_len, ZIP_EF_ZIP64, 0, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error);
	/* TODO: if got_len == 0 && !ZIP64_EOCD: no error, 0xffffffff is valid value */
        if (ef == NULL) {
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
	    return -1;
        }

        if ((ef_buffer = _zip_buffer_new((zip_uint8_t *)ef, got_len)) == NULL) {
            zip_error_set(error, ZIP_ER_MEMORY, 0);
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
            return -1;
        }

	if (zde->uncomp_size == ZIP_UINT32_MAX)
	    zde->uncomp_size = _zip_buffer_get_64(ef_buffer);
	else if (local) {
	    /* From appnote.txt: This entry in the Local header MUST
	       include BOTH original and compressed file size fields. */
            (void)_zip_buffer_skip(ef_buffer, 8); /* error is caught by _zip_buffer_eof() call */
	}
	if (zde->comp_size == ZIP_UINT32_MAX)
	    zde->comp_size = _zip_buffer_get_64(ef_buffer);
	if (!local) {
	    if (zde->offset == ZIP_UINT32_MAX)
		zde->offset = _zip_buffer_get_64(ef_buffer);
	    if (zde->disk_number == ZIP_UINT16_MAX)
		zde->disk_number = _zip_buffer_get_32(buffer);
	}

        if (!_zip_buffer_eof(ef_buffer)) {
            zip_error_set(error, ZIP_ER_INCONS, 0);
            _zip_buffer_free(ef_buffer);
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
            return -1;
        }
        _zip_buffer_free(ef_buffer);
    }

    if (!_zip_buffer_ok(buffer)) {
        zip_error_set(error, ZIP_ER_INTERNAL, 0);
        if (!from_buffer) {
            _zip_buffer_free(buffer);
        }
        return -1;
    }
    if (!from_buffer) {
        _zip_buffer_free(buffer);
    }

    /* zip_source_seek / zip_source_tell don't support values > ZIP_INT64_MAX */
    if (zde->offset > ZIP_INT64_MAX) {
	zip_error_set(error, ZIP_ER_SEEK, EFBIG);
	return -1;
     }
 
     if (!_zip_dirent_process_winzip_aes(zde, error)) {
	if (!from_buffer) {
	    _zip_buffer_free(buffer);
	}
 	return -1;
     }
 
    zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields);

    return (zip_int64_t)(size + variable_size);
}
",C,,"	if (!from_buffer) {
	    _zip_buffer_free(buffer);
	}
",,"@@ -579,9 +579,6 @@ _zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, boo
     }
 
     if (!_zip_dirent_process_winzip_aes(zde, error)) {
-	if (!from_buffer) {
-	    _zip_buffer_free(buffer);
-	}
 	return -1;
     }
 ",libzip,2217022b7d1142738656d891e00b3d2d9179b796,f0b8ddaabe53b2ea34ea115dfba7879b9e7a29f0,1,"_zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error)
{
    zip_uint8_t buf[CDENTRYSIZE];
    zip_uint16_t dostime, dosdate;
    zip_uint32_t size, variable_size;
    zip_uint16_t filename_len, comment_len, ef_len;

    bool from_buffer = (buffer != NULL);

    size = local ? LENTRYSIZE : CDENTRYSIZE;

    if (buffer) {
        if (_zip_buffer_left(buffer) < size) {
            zip_error_set(error, ZIP_ER_NOZIP, 0);
            return -1;
        }
    }
    else {
        if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) {
            return -1;
        }
    }

    if (memcmp(_zip_buffer_get(buffer, 4), (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {
	zip_error_set(error, ZIP_ER_NOZIP, 0);
        if (!from_buffer) {
            _zip_buffer_free(buffer);
        }
	return -1;
    }

    /* convert buffercontents to zip_dirent */

    _zip_dirent_init(zde);
    if (!local)
	zde->version_madeby = _zip_buffer_get_16(buffer);
    else
	zde->version_madeby = 0;
    zde->version_needed = _zip_buffer_get_16(buffer);
    zde->bitflags = _zip_buffer_get_16(buffer);
    zde->comp_method = _zip_buffer_get_16(buffer);

    /* convert to time_t */
    dostime = _zip_buffer_get_16(buffer);
    dosdate = _zip_buffer_get_16(buffer);
    zde->last_mod = _zip_d2u_time(dostime, dosdate);

    zde->crc = _zip_buffer_get_32(buffer);
    zde->comp_size = _zip_buffer_get_32(buffer);
    zde->uncomp_size = _zip_buffer_get_32(buffer);

    filename_len = _zip_buffer_get_16(buffer);
    ef_len = _zip_buffer_get_16(buffer);

    if (local) {
	comment_len = 0;
	zde->disk_number = 0;
	zde->int_attrib = 0;
	zde->ext_attrib = 0;
	zde->offset = 0;
    } else {
	comment_len = _zip_buffer_get_16(buffer);
	zde->disk_number = _zip_buffer_get_16(buffer);
	zde->int_attrib = _zip_buffer_get_16(buffer);
	zde->ext_attrib = _zip_buffer_get_32(buffer);
	zde->offset = _zip_buffer_get_32(buffer);
    }

    if (!_zip_buffer_ok(buffer)) {
        zip_error_set(error, ZIP_ER_INTERNAL, 0);
        if (!from_buffer) {
            _zip_buffer_free(buffer);
        }
        return -1;
    }

    if (zde->bitflags & ZIP_GPBF_ENCRYPTED) {
	if (zde->bitflags & ZIP_GPBF_STRONG_ENCRYPTION) {
	    /* TODO */
	    zde->encryption_method = ZIP_EM_UNKNOWN;
	}
	else {
	    zde->encryption_method = ZIP_EM_TRAD_PKWARE;
	}
    }
    else {
	zde->encryption_method = ZIP_EM_NONE;
    }

    zde->filename = NULL;
    zde->extra_fields = NULL;
    zde->comment = NULL;

    variable_size = (zip_uint32_t)filename_len+(zip_uint32_t)ef_len+(zip_uint32_t)comment_len;

    if (from_buffer) {
        if (_zip_buffer_left(buffer) < variable_size) {
            zip_error_set(error, ZIP_ER_INCONS, 0);
            return -1;
        }
    }
    else {
        _zip_buffer_free(buffer);

        if ((buffer = _zip_buffer_new_from_source(src, variable_size, NULL, error)) == NULL) {
            return -1;
        }
    }

    if (filename_len) {
	zde->filename = _zip_read_string(buffer, src, filename_len, 1, error);
        if (!zde->filename) {
            if (zip_error_code_zip(error) == ZIP_ER_EOF) {
                zip_error_set(error, ZIP_ER_INCONS, 0);
            }
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
	    return -1;
        }

	if (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {
	    if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {
		zip_error_set(error, ZIP_ER_INCONS, 0);
                if (!from_buffer) {
                    _zip_buffer_free(buffer);
                }
		return -1;
	    }
	}
    }

    if (ef_len) {
	zip_uint8_t *ef = _zip_read_data(buffer, src, ef_len, 0, error);

        if (ef == NULL) {
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
	    return -1;
        }
        if (!_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, &zde->extra_fields, error)) {
	    free(ef);
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
	    return -1;
	}
	free(ef);
	if (local)
	    zde->local_extra_fields_read = 1;
    }

    if (comment_len) {
	zde->comment = _zip_read_string(buffer, src, comment_len, 0, error);
        if (!zde->comment) {
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
	    return -1;
        }
	if (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {
	    if (_zip_guess_encoding(zde->comment, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {
		zip_error_set(error, ZIP_ER_INCONS, 0);
                if (!from_buffer) {
                    _zip_buffer_free(buffer);
                }
		return -1;
	    }
	}
    }

    zde->filename = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_NAME, zde->filename);
    zde->comment = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_COMMENT, zde->comment);

    /* Zip64 */

    if (zde->uncomp_size == ZIP_UINT32_MAX || zde->comp_size == ZIP_UINT32_MAX || zde->offset == ZIP_UINT32_MAX) {
	zip_uint16_t got_len;
        zip_buffer_t *ef_buffer;
	const zip_uint8_t *ef = _zip_ef_get_by_id(zde->extra_fields, &got_len, ZIP_EF_ZIP64, 0, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error);
	/* TODO: if got_len == 0 && !ZIP64_EOCD: no error, 0xffffffff is valid value */
        if (ef == NULL) {
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
	    return -1;
        }

        if ((ef_buffer = _zip_buffer_new((zip_uint8_t *)ef, got_len)) == NULL) {
            zip_error_set(error, ZIP_ER_MEMORY, 0);
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
            return -1;
        }

	if (zde->uncomp_size == ZIP_UINT32_MAX)
	    zde->uncomp_size = _zip_buffer_get_64(ef_buffer);
	else if (local) {
	    /* From appnote.txt: This entry in the Local header MUST
	       include BOTH original and compressed file size fields. */
            (void)_zip_buffer_skip(ef_buffer, 8); /* error is caught by _zip_buffer_eof() call */
	}
	if (zde->comp_size == ZIP_UINT32_MAX)
	    zde->comp_size = _zip_buffer_get_64(ef_buffer);
	if (!local) {
	    if (zde->offset == ZIP_UINT32_MAX)
		zde->offset = _zip_buffer_get_64(ef_buffer);
	    if (zde->disk_number == ZIP_UINT16_MAX)
		zde->disk_number = _zip_buffer_get_32(buffer);
	}

        if (!_zip_buffer_eof(ef_buffer)) {
            zip_error_set(error, ZIP_ER_INCONS, 0);
            _zip_buffer_free(ef_buffer);
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
            return -1;
        }
        _zip_buffer_free(ef_buffer);
    }

    if (!_zip_buffer_ok(buffer)) {
        zip_error_set(error, ZIP_ER_INTERNAL, 0);
        if (!from_buffer) {
            _zip_buffer_free(buffer);
        }
        return -1;
    }
    if (!from_buffer) {
        _zip_buffer_free(buffer);
    }

    /* zip_source_seek / zip_source_tell don't support values > ZIP_INT64_MAX */
    if (zde->offset > ZIP_INT64_MAX) {
	zip_error_set(error, ZIP_ER_SEEK, EFBIG);
	return -1;
     }
 
     if (!_zip_dirent_process_winzip_aes(zde, error)) {
//flaw_line_below:
	if (!from_buffer) {
//flaw_line_below:
	    _zip_buffer_free(buffer);
//flaw_line_below:
	}
 	return -1;
     }
 
    zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields);

    return (zip_int64_t)(size + variable_size);
}
"
3447,181183,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,15,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",6,src/lib/gssapi/mechglue/g_accept_sec_context.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_accept_sec_context (minor_status,
                        context_handle,
                        verifier_cred_handle,
                        input_token_buffer,
                        input_chan_bindings,
                        src_name,
                        mech_type,
                        output_token,
                        ret_flags,
                        time_rec,
                        d_cred)

OM_uint32 *		minor_status;
gss_ctx_id_t *		context_handle;
gss_cred_id_t		verifier_cred_handle;
gss_buffer_t		input_token_buffer;
gss_channel_bindings_t	input_chan_bindings;
gss_name_t *		src_name;
gss_OID *		mech_type;
gss_buffer_t		output_token;
OM_uint32 *		ret_flags;
OM_uint32 *		time_rec;
gss_cred_id_t *		d_cred;

{
    OM_uint32		status, temp_status, temp_minor_status;
    OM_uint32		temp_ret_flags = 0;
    gss_union_ctx_id_t	union_ctx_id = NULL;
    gss_cred_id_t	input_cred_handle = GSS_C_NO_CREDENTIAL;
    gss_cred_id_t	tmp_d_cred = GSS_C_NO_CREDENTIAL;
    gss_name_t		internal_name = GSS_C_NO_NAME;
    gss_name_t		tmp_src_name = GSS_C_NO_NAME;
    gss_OID_desc	token_mech_type_desc;
    gss_OID		token_mech_type = &token_mech_type_desc;
    gss_OID		actual_mech = GSS_C_NO_OID;
    gss_OID		selected_mech = GSS_C_NO_OID;
    gss_OID		public_mech;
    gss_mechanism	mech = NULL;
    gss_union_cred_t	uc;
    int			i;

    status = val_acc_sec_ctx_args(minor_status,
				  context_handle,
				  verifier_cred_handle,
				  input_token_buffer,
				  input_chan_bindings,
				  src_name,
				  mech_type,
				  output_token,
				  ret_flags,
				  time_rec,
				  d_cred);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * if context_handle is GSS_C_NO_CONTEXT, allocate a union context
     * descriptor to hold the mech type information as well as the
     * underlying mechanism context handle. Otherwise, cast the
     * value of *context_handle to the union context variable.
     */

    if(*context_handle == GSS_C_NO_CONTEXT) {

	if (input_token_buffer == GSS_C_NO_BUFFER)
	    return (GSS_S_CALL_INACCESSIBLE_READ);

	/* Get the token mech type */
	status = gssint_get_mech_type(token_mech_type, input_token_buffer);
	if (status)
	    return status;

	/*
	 * An interposer calling back into the mechglue can't pass in a special
	 * mech, so we have to recognize it using verifier_cred_handle.  Use
	 * the mechanism for which we have matching creds, if available.
	 */
	if (verifier_cred_handle != GSS_C_NO_CREDENTIAL) {
	    uc = (gss_union_cred_t)verifier_cred_handle;
	    for (i = 0; i < uc->count; i++) {
		public_mech = gssint_get_public_oid(&uc->mechs_array[i]);
		if (public_mech && g_OID_equal(token_mech_type, public_mech)) {
		    selected_mech = &uc->mechs_array[i];
		    break;
		}
	    }
	}

	if (selected_mech == GSS_C_NO_OID) {
	    status = gssint_select_mech_type(minor_status, token_mech_type,
					     &selected_mech);
	    if (status)
		return status;
	}

     } else {
 	union_ctx_id = (gss_union_ctx_id_t)*context_handle;
 	selected_mech = union_ctx_id->mech_type;
	if (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)
	    return (GSS_S_NO_CONTEXT);
     }
 
     /* Now create a new context if we didn't get one. */
    if (*context_handle == GSS_C_NO_CONTEXT) {
	status = GSS_S_FAILURE;
	union_ctx_id = (gss_union_ctx_id_t)
	    malloc(sizeof(gss_union_ctx_id_desc));
	if (!union_ctx_id)
	    return (GSS_S_FAILURE);

	union_ctx_id->loopback = union_ctx_id;
	union_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;
	status = generic_gss_copy_oid(&temp_minor_status, selected_mech,
				      &union_ctx_id->mech_type);
	if (status != GSS_S_COMPLETE) {
 	    free(union_ctx_id);
 	    return (status);
 	}
     }
 
     /*
     * get the appropriate cred handle from the union cred struct.
     */
    if (verifier_cred_handle != GSS_C_NO_CREDENTIAL) {
	input_cred_handle =
	    gssint_get_mechanism_cred((gss_union_cred_t)verifier_cred_handle,
				      selected_mech);
	if (input_cred_handle == GSS_C_NO_CREDENTIAL) {
	    /* verifier credential specified but no acceptor credential found */
	    status = GSS_S_NO_CRED;
	    goto error_out;
	}
    } else if (!allow_mech_by_default(selected_mech)) {
	status = GSS_S_NO_CRED;
	goto error_out;
    }

    /*
     * now select the approprate underlying mechanism routine and
     * call it.
     */

    mech = gssint_get_mechanism(selected_mech);
    if (mech && mech->gss_accept_sec_context) {

	    status = mech->gss_accept_sec_context(minor_status,
						  &union_ctx_id->internal_ctx_id,
						  input_cred_handle,
						  input_token_buffer,
						  input_chan_bindings,
						  src_name ? &internal_name : NULL,
						  &actual_mech,
						  output_token,
						  &temp_ret_flags,
						  time_rec,
 					d_cred ? &tmp_d_cred : NULL);
 
 	    /* If there's more work to do, keep going... */
	    if (status == GSS_S_CONTINUE_NEEDED) {
		*context_handle = (gss_ctx_id_t)union_ctx_id;
 		return GSS_S_CONTINUE_NEEDED;
	    }
 
 	    /* if the call failed, return with failure */
 	    if (status != GSS_S_COMPLETE) {
		map_error(minor_status, mech);
		goto error_out;
	    }

	    /*
	     * if src_name is non-NULL,
	     * convert internal_name into a union name equivalent
	     * First call the mechanism specific display_name()
	     * then call gss_import_name() to create
	     * the union name struct cast to src_name
	     */
	    if (src_name != NULL) {
		if (internal_name != GSS_C_NO_NAME) {
		    /* consumes internal_name regardless of success */
		    temp_status = gssint_convert_name_to_union_name(
			    &temp_minor_status, mech,
			    internal_name, &tmp_src_name);
		    if (temp_status != GSS_S_COMPLETE) {
			status = temp_status;
			*minor_status = temp_minor_status;
			map_error(minor_status, mech);
			if (output_token->length)
			    (void) gss_release_buffer(&temp_minor_status,
						      output_token);
			goto error_out;
		    }
		    *src_name = tmp_src_name;
		} else
		    *src_name = GSS_C_NO_NAME;
	    }

#define g_OID_prefix_equal(o1, o2) \
        (((o1)->length >= (o2)->length) && \
        (memcmp((o1)->elements, (o2)->elements, (o2)->length) == 0))

	    /* Ensure we're returning correct creds format */
	    if ((temp_ret_flags & GSS_C_DELEG_FLAG) &&
		tmp_d_cred != GSS_C_NO_CREDENTIAL) {
		public_mech = gssint_get_public_oid(selected_mech);
		if (actual_mech != GSS_C_NO_OID &&
		    public_mech != GSS_C_NO_OID &&
		    !g_OID_prefix_equal(actual_mech, public_mech)) {
		    *d_cred = tmp_d_cred; /* unwrapped pseudo-mech */
		} else {
		    gss_union_cred_t d_u_cred = NULL;

		    d_u_cred = malloc(sizeof (gss_union_cred_desc));
		    if (d_u_cred == NULL) {
			status = GSS_S_FAILURE;
			goto error_out;
		    }
		    (void) memset(d_u_cred, 0, sizeof (gss_union_cred_desc));

		    d_u_cred->count = 1;

		    status = generic_gss_copy_oid(&temp_minor_status,
						  selected_mech,
						  &d_u_cred->mechs_array);

		    if (status != GSS_S_COMPLETE) {
			free(d_u_cred);
			goto error_out;
		    }

		    d_u_cred->cred_array = malloc(sizeof(gss_cred_id_t));
		    if (d_u_cred->cred_array != NULL) {
			d_u_cred->cred_array[0] = tmp_d_cred;
		    } else {
			free(d_u_cred);
			status = GSS_S_FAILURE;
			goto error_out;
		    }

		    d_u_cred->loopback = d_u_cred;
		    *d_cred = (gss_cred_id_t)d_u_cred;
		}
	    }

	    if (mech_type != NULL)
 		*mech_type = gssint_get_public_oid(actual_mech);
 	    if (ret_flags != NULL)
 		*ret_flags = temp_ret_flags;
	    *context_handle = (gss_ctx_id_t)union_ctx_id;
	    return GSS_S_COMPLETE;
     } else {
 
 	status = GSS_S_BAD_MECH;
     }
 
 error_out:
	/*
	 * RFC 2744 5.1 requires that we not create a context on a failed first
	 * call to accept, and recommends that on a failed subsequent call we
	 * make the caller responsible for calling gss_delete_sec_context.
	 * Even if the mech deleted its context, keep the union context around
	 * for the caller to delete.
	 */
    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {
 	if (union_ctx_id->mech_type) {
 	    if (union_ctx_id->mech_type->elements)
 		free(union_ctx_id->mech_type->elements);
	    free(union_ctx_id->mech_type);
	}
	if (union_ctx_id->internal_ctx_id && mech &&
	    mech->gss_delete_sec_context) {
	    mech->gss_delete_sec_context(&temp_minor_status,
					 &union_ctx_id->internal_ctx_id,
 					 GSS_C_NO_BUFFER);
 	}
 	free(union_ctx_id);
     }
 
     if (src_name)
	*src_name = GSS_C_NO_NAME;

    if (tmp_src_name != GSS_C_NO_NAME)
	(void) gss_release_buffer(&temp_minor_status,
				  (gss_buffer_t)tmp_src_name);

    return (status);
}
","gss_accept_sec_context (minor_status,
                        context_handle,
                        verifier_cred_handle,
                        input_token_buffer,
                        input_chan_bindings,
                        src_name,
                        mech_type,
                        output_token,
                        ret_flags,
                        time_rec,
                        d_cred)

OM_uint32 *		minor_status;
gss_ctx_id_t *		context_handle;
gss_cred_id_t		verifier_cred_handle;
gss_buffer_t		input_token_buffer;
gss_channel_bindings_t	input_chan_bindings;
gss_name_t *		src_name;
gss_OID *		mech_type;
gss_buffer_t		output_token;
OM_uint32 *		ret_flags;
OM_uint32 *		time_rec;
gss_cred_id_t *		d_cred;

{
    OM_uint32		status, temp_status, temp_minor_status;
    OM_uint32		temp_ret_flags = 0;
    gss_union_ctx_id_t	union_ctx_id = NULL;
    gss_cred_id_t	input_cred_handle = GSS_C_NO_CREDENTIAL;
    gss_cred_id_t	tmp_d_cred = GSS_C_NO_CREDENTIAL;
    gss_name_t		internal_name = GSS_C_NO_NAME;
    gss_name_t		tmp_src_name = GSS_C_NO_NAME;
    gss_OID_desc	token_mech_type_desc;
    gss_OID		token_mech_type = &token_mech_type_desc;
    gss_OID		actual_mech = GSS_C_NO_OID;
    gss_OID		selected_mech = GSS_C_NO_OID;
    gss_OID		public_mech;
    gss_mechanism	mech = NULL;
    gss_union_cred_t	uc;
    int			i;

    status = val_acc_sec_ctx_args(minor_status,
				  context_handle,
				  verifier_cred_handle,
				  input_token_buffer,
				  input_chan_bindings,
				  src_name,
				  mech_type,
				  output_token,
				  ret_flags,
				  time_rec,
				  d_cred);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * if context_handle is GSS_C_NO_CONTEXT, allocate a union context
     * descriptor to hold the mech type information as well as the
     * underlying mechanism context handle. Otherwise, cast the
     * value of *context_handle to the union context variable.
     */

    if(*context_handle == GSS_C_NO_CONTEXT) {

	if (input_token_buffer == GSS_C_NO_BUFFER)
	    return (GSS_S_CALL_INACCESSIBLE_READ);

	/* Get the token mech type */
	status = gssint_get_mech_type(token_mech_type, input_token_buffer);
	if (status)
	    return status;

	/*
	 * An interposer calling back into the mechglue can't pass in a special
	 * mech, so we have to recognize it using verifier_cred_handle.  Use
	 * the mechanism for which we have matching creds, if available.
	 */
	if (verifier_cred_handle != GSS_C_NO_CREDENTIAL) {
	    uc = (gss_union_cred_t)verifier_cred_handle;
	    for (i = 0; i < uc->count; i++) {
		public_mech = gssint_get_public_oid(&uc->mechs_array[i]);
		if (public_mech && g_OID_equal(token_mech_type, public_mech)) {
		    selected_mech = &uc->mechs_array[i];
		    break;
		}
	    }
	}

	if (selected_mech == GSS_C_NO_OID) {
	    status = gssint_select_mech_type(minor_status, token_mech_type,
					     &selected_mech);
	    if (status)
		return status;
	}

     } else {
 	union_ctx_id = (gss_union_ctx_id_t)*context_handle;
 	selected_mech = union_ctx_id->mech_type;
     }
 
     /* Now create a new context if we didn't get one. */
    if (*context_handle == GSS_C_NO_CONTEXT) {
	status = GSS_S_FAILURE;
	union_ctx_id = (gss_union_ctx_id_t)
	    malloc(sizeof(gss_union_ctx_id_desc));
	if (!union_ctx_id)
	    return (GSS_S_FAILURE);

	union_ctx_id->loopback = union_ctx_id;
	union_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;
	status = generic_gss_copy_oid(&temp_minor_status, selected_mech,
				      &union_ctx_id->mech_type);
	if (status != GSS_S_COMPLETE) {
 	    free(union_ctx_id);
 	    return (status);
 	}
	/* set the new context handle to caller's data */
	*context_handle = (gss_ctx_id_t)union_ctx_id;
     }
 
     /*
     * get the appropriate cred handle from the union cred struct.
     */
    if (verifier_cred_handle != GSS_C_NO_CREDENTIAL) {
	input_cred_handle =
	    gssint_get_mechanism_cred((gss_union_cred_t)verifier_cred_handle,
				      selected_mech);
	if (input_cred_handle == GSS_C_NO_CREDENTIAL) {
	    /* verifier credential specified but no acceptor credential found */
	    status = GSS_S_NO_CRED;
	    goto error_out;
	}
    } else if (!allow_mech_by_default(selected_mech)) {
	status = GSS_S_NO_CRED;
	goto error_out;
    }

    /*
     * now select the approprate underlying mechanism routine and
     * call it.
     */

    mech = gssint_get_mechanism(selected_mech);
    if (mech && mech->gss_accept_sec_context) {

	    status = mech->gss_accept_sec_context(minor_status,
						  &union_ctx_id->internal_ctx_id,
						  input_cred_handle,
						  input_token_buffer,
						  input_chan_bindings,
						  src_name ? &internal_name : NULL,
						  &actual_mech,
						  output_token,
						  &temp_ret_flags,
						  time_rec,
 					d_cred ? &tmp_d_cred : NULL);
 
 	    /* If there's more work to do, keep going... */
	    if (status == GSS_S_CONTINUE_NEEDED)
 		return GSS_S_CONTINUE_NEEDED;
 
 	    /* if the call failed, return with failure */
 	    if (status != GSS_S_COMPLETE) {
		map_error(minor_status, mech);
		goto error_out;
	    }

	    /*
	     * if src_name is non-NULL,
	     * convert internal_name into a union name equivalent
	     * First call the mechanism specific display_name()
	     * then call gss_import_name() to create
	     * the union name struct cast to src_name
	     */
	    if (src_name != NULL) {
		if (internal_name != GSS_C_NO_NAME) {
		    /* consumes internal_name regardless of success */
		    temp_status = gssint_convert_name_to_union_name(
			    &temp_minor_status, mech,
			    internal_name, &tmp_src_name);
		    if (temp_status != GSS_S_COMPLETE) {
			status = temp_status;
			*minor_status = temp_minor_status;
			map_error(minor_status, mech);
			if (output_token->length)
			    (void) gss_release_buffer(&temp_minor_status,
						      output_token);
			goto error_out;
		    }
		    *src_name = tmp_src_name;
		} else
		    *src_name = GSS_C_NO_NAME;
	    }

#define g_OID_prefix_equal(o1, o2) \
        (((o1)->length >= (o2)->length) && \
        (memcmp((o1)->elements, (o2)->elements, (o2)->length) == 0))

	    /* Ensure we're returning correct creds format */
	    if ((temp_ret_flags & GSS_C_DELEG_FLAG) &&
		tmp_d_cred != GSS_C_NO_CREDENTIAL) {
		public_mech = gssint_get_public_oid(selected_mech);
		if (actual_mech != GSS_C_NO_OID &&
		    public_mech != GSS_C_NO_OID &&
		    !g_OID_prefix_equal(actual_mech, public_mech)) {
		    *d_cred = tmp_d_cred; /* unwrapped pseudo-mech */
		} else {
		    gss_union_cred_t d_u_cred = NULL;

		    d_u_cred = malloc(sizeof (gss_union_cred_desc));
		    if (d_u_cred == NULL) {
			status = GSS_S_FAILURE;
			goto error_out;
		    }
		    (void) memset(d_u_cred, 0, sizeof (gss_union_cred_desc));

		    d_u_cred->count = 1;

		    status = generic_gss_copy_oid(&temp_minor_status,
						  selected_mech,
						  &d_u_cred->mechs_array);

		    if (status != GSS_S_COMPLETE) {
			free(d_u_cred);
			goto error_out;
		    }

		    d_u_cred->cred_array = malloc(sizeof(gss_cred_id_t));
		    if (d_u_cred->cred_array != NULL) {
			d_u_cred->cred_array[0] = tmp_d_cred;
		    } else {
			free(d_u_cred);
			status = GSS_S_FAILURE;
			goto error_out;
		    }

		    d_u_cred->loopback = d_u_cred;
		    *d_cred = (gss_cred_id_t)d_u_cred;
		}
	    }

	    if (mech_type != NULL)
 		*mech_type = gssint_get_public_oid(actual_mech);
 	    if (ret_flags != NULL)
 		*ret_flags = temp_ret_flags;
	    return	(status);
     } else {
 
 	status = GSS_S_BAD_MECH;
     }
 
 error_out:
    if (union_ctx_id) {
 	if (union_ctx_id->mech_type) {
 	    if (union_ctx_id->mech_type->elements)
 		free(union_ctx_id->mech_type->elements);
	    free(union_ctx_id->mech_type);
	}
	if (union_ctx_id->internal_ctx_id && mech &&
	    mech->gss_delete_sec_context) {
	    mech->gss_delete_sec_context(&temp_minor_status,
					 &union_ctx_id->internal_ctx_id,
 					 GSS_C_NO_BUFFER);
 	}
 	free(union_ctx_id);
	*context_handle = GSS_C_NO_CONTEXT;
     }
 
     if (src_name)
	*src_name = GSS_C_NO_NAME;

    if (tmp_src_name != GSS_C_NO_NAME)
	(void) gss_release_buffer(&temp_minor_status,
				  (gss_buffer_t)tmp_src_name);

    return (status);
}
",C,"	if (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)
	    return (GSS_S_NO_CONTEXT);
	    if (status == GSS_S_CONTINUE_NEEDED) {
		*context_handle = (gss_ctx_id_t)union_ctx_id;
	    }
	    *context_handle = (gss_ctx_id_t)union_ctx_id;
	    return GSS_S_COMPLETE;
	/*
	 * RFC 2744 5.1 requires that we not create a context on a failed first
	 * call to accept, and recommends that on a failed subsequent call we
	 * make the caller responsible for calling gss_delete_sec_context.
	 * Even if the mech deleted its context, keep the union context around
	 * for the caller to delete.
	 */
    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {
","	/* set the new context handle to caller's data */
	*context_handle = (gss_ctx_id_t)union_ctx_id;
	    if (status == GSS_S_CONTINUE_NEEDED)
	    return	(status);
    if (union_ctx_id) {
	*context_handle = GSS_C_NO_CONTEXT;
",,"@@ -216,6 +216,8 @@ gss_cred_id_t *		d_cred;
     } else {
 	union_ctx_id = (gss_union_ctx_id_t)*context_handle;
 	selected_mech = union_ctx_id->mech_type;
+	if (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
     }
 
     /* Now create a new context if we didn't get one. */
@@ -234,9 +236,6 @@ gss_cred_id_t *		d_cred;
 	    free(union_ctx_id);
 	    return (status);
 	}
-
-	/* set the new context handle to caller's data */
-	*context_handle = (gss_ctx_id_t)union_ctx_id;
     }
 
     /*
@@ -277,8 +276,10 @@ gss_cred_id_t *		d_cred;
 					d_cred ? &tmp_d_cred : NULL);
 
 	    /* If there's more work to do, keep going... */
-	    if (status == GSS_S_CONTINUE_NEEDED)
+	    if (status == GSS_S_CONTINUE_NEEDED) {
+		*context_handle = (gss_ctx_id_t)union_ctx_id;
 		return GSS_S_CONTINUE_NEEDED;
+	    }
 
 	    /* if the call failed, return with failure */
 	    if (status != GSS_S_COMPLETE) {
@@ -364,14 +365,22 @@ gss_cred_id_t *		d_cred;
 		*mech_type = gssint_get_public_oid(actual_mech);
 	    if (ret_flags != NULL)
 		*ret_flags = temp_ret_flags;
-	    return	(status);
+	    *context_handle = (gss_ctx_id_t)union_ctx_id;
+	    return GSS_S_COMPLETE;
     } else {
 
 	status = GSS_S_BAD_MECH;
     }
 
 error_out:
-    if (union_ctx_id) {
+	/*
+	 * RFC 2744 5.1 requires that we not create a context on a failed first
+	 * call to accept, and recommends that on a failed subsequent call we
+	 * make the caller responsible for calling gss_delete_sec_context.
+	 * Even if the mech deleted its context, keep the union context around
+	 * for the caller to delete.
+	 */
+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {
 	if (union_ctx_id->mech_type) {
 	    if (union_ctx_id->mech_type->elements)
 		free(union_ctx_id->mech_type->elements);
@@ -384,7 +393,6 @@ gss_cred_id_t *		d_cred;
 					 GSS_C_NO_BUFFER);
 	}
 	free(union_ctx_id);
-	*context_handle = GSS_C_NO_CONTEXT;
     }
 
     if (src_name)",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_accept_sec_context (minor_status,
                        context_handle,
                        verifier_cred_handle,
                        input_token_buffer,
                        input_chan_bindings,
                        src_name,
                        mech_type,
                        output_token,
                        ret_flags,
                        time_rec,
                        d_cred)

OM_uint32 *		minor_status;
gss_ctx_id_t *		context_handle;
gss_cred_id_t		verifier_cred_handle;
gss_buffer_t		input_token_buffer;
gss_channel_bindings_t	input_chan_bindings;
gss_name_t *		src_name;
gss_OID *		mech_type;
gss_buffer_t		output_token;
OM_uint32 *		ret_flags;
OM_uint32 *		time_rec;
gss_cred_id_t *		d_cred;

{
    OM_uint32		status, temp_status, temp_minor_status;
    OM_uint32		temp_ret_flags = 0;
    gss_union_ctx_id_t	union_ctx_id = NULL;
    gss_cred_id_t	input_cred_handle = GSS_C_NO_CREDENTIAL;
    gss_cred_id_t	tmp_d_cred = GSS_C_NO_CREDENTIAL;
    gss_name_t		internal_name = GSS_C_NO_NAME;
    gss_name_t		tmp_src_name = GSS_C_NO_NAME;
    gss_OID_desc	token_mech_type_desc;
    gss_OID		token_mech_type = &token_mech_type_desc;
    gss_OID		actual_mech = GSS_C_NO_OID;
    gss_OID		selected_mech = GSS_C_NO_OID;
    gss_OID		public_mech;
    gss_mechanism	mech = NULL;
    gss_union_cred_t	uc;
    int			i;

    status = val_acc_sec_ctx_args(minor_status,
				  context_handle,
				  verifier_cred_handle,
				  input_token_buffer,
				  input_chan_bindings,
				  src_name,
				  mech_type,
				  output_token,
				  ret_flags,
				  time_rec,
				  d_cred);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * if context_handle is GSS_C_NO_CONTEXT, allocate a union context
     * descriptor to hold the mech type information as well as the
     * underlying mechanism context handle. Otherwise, cast the
     * value of *context_handle to the union context variable.
     */

    if(*context_handle == GSS_C_NO_CONTEXT) {

	if (input_token_buffer == GSS_C_NO_BUFFER)
	    return (GSS_S_CALL_INACCESSIBLE_READ);

	/* Get the token mech type */
	status = gssint_get_mech_type(token_mech_type, input_token_buffer);
	if (status)
	    return status;

	/*
	 * An interposer calling back into the mechglue can't pass in a special
	 * mech, so we have to recognize it using verifier_cred_handle.  Use
	 * the mechanism for which we have matching creds, if available.
	 */
	if (verifier_cred_handle != GSS_C_NO_CREDENTIAL) {
	    uc = (gss_union_cred_t)verifier_cred_handle;
	    for (i = 0; i < uc->count; i++) {
		public_mech = gssint_get_public_oid(&uc->mechs_array[i]);
		if (public_mech && g_OID_equal(token_mech_type, public_mech)) {
		    selected_mech = &uc->mechs_array[i];
		    break;
		}
	    }
	}

	if (selected_mech == GSS_C_NO_OID) {
	    status = gssint_select_mech_type(minor_status, token_mech_type,
					     &selected_mech);
	    if (status)
		return status;
	}

     } else {
 	union_ctx_id = (gss_union_ctx_id_t)*context_handle;
 	selected_mech = union_ctx_id->mech_type;
//fix_flaw_line_below:
//	if (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//	    return (GSS_S_NO_CONTEXT);
     }
 
     /* Now create a new context if we didn't get one. */
    if (*context_handle == GSS_C_NO_CONTEXT) {
	status = GSS_S_FAILURE;
	union_ctx_id = (gss_union_ctx_id_t)
	    malloc(sizeof(gss_union_ctx_id_desc));
	if (!union_ctx_id)
	    return (GSS_S_FAILURE);

	union_ctx_id->loopback = union_ctx_id;
	union_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;
	status = generic_gss_copy_oid(&temp_minor_status, selected_mech,
				      &union_ctx_id->mech_type);
	if (status != GSS_S_COMPLETE) {
 	    free(union_ctx_id);
 	    return (status);
 	}
//flaw_line_below:

//flaw_line_below:
	/* set the new context handle to caller's data */
//flaw_line_below:
	*context_handle = (gss_ctx_id_t)union_ctx_id;
     }
 
     /*
     * get the appropriate cred handle from the union cred struct.
     */
    if (verifier_cred_handle != GSS_C_NO_CREDENTIAL) {
	input_cred_handle =
	    gssint_get_mechanism_cred((gss_union_cred_t)verifier_cred_handle,
				      selected_mech);
	if (input_cred_handle == GSS_C_NO_CREDENTIAL) {
	    /* verifier credential specified but no acceptor credential found */
	    status = GSS_S_NO_CRED;
	    goto error_out;
	}
    } else if (!allow_mech_by_default(selected_mech)) {
	status = GSS_S_NO_CRED;
	goto error_out;
    }

    /*
     * now select the approprate underlying mechanism routine and
     * call it.
     */

    mech = gssint_get_mechanism(selected_mech);
    if (mech && mech->gss_accept_sec_context) {

	    status = mech->gss_accept_sec_context(minor_status,
						  &union_ctx_id->internal_ctx_id,
						  input_cred_handle,
						  input_token_buffer,
						  input_chan_bindings,
						  src_name ? &internal_name : NULL,
						  &actual_mech,
						  output_token,
						  &temp_ret_flags,
						  time_rec,
 					d_cred ? &tmp_d_cred : NULL);
 
 	    /* If there's more work to do, keep going... */
//flaw_line_below:
	    if (status == GSS_S_CONTINUE_NEEDED)
//fix_flaw_line_below:
//	    if (status == GSS_S_CONTINUE_NEEDED) {
//fix_flaw_line_below:
//		*context_handle = (gss_ctx_id_t)union_ctx_id;
 		return GSS_S_CONTINUE_NEEDED;
//fix_flaw_line_below:
//	    }
 
 	    /* if the call failed, return with failure */
 	    if (status != GSS_S_COMPLETE) {
		map_error(minor_status, mech);
		goto error_out;
	    }

	    /*
	     * if src_name is non-NULL,
	     * convert internal_name into a union name equivalent
	     * First call the mechanism specific display_name()
	     * then call gss_import_name() to create
	     * the union name struct cast to src_name
	     */
	    if (src_name != NULL) {
		if (internal_name != GSS_C_NO_NAME) {
		    /* consumes internal_name regardless of success */
		    temp_status = gssint_convert_name_to_union_name(
			    &temp_minor_status, mech,
			    internal_name, &tmp_src_name);
		    if (temp_status != GSS_S_COMPLETE) {
			status = temp_status;
			*minor_status = temp_minor_status;
			map_error(minor_status, mech);
			if (output_token->length)
			    (void) gss_release_buffer(&temp_minor_status,
						      output_token);
			goto error_out;
		    }
		    *src_name = tmp_src_name;
		} else
		    *src_name = GSS_C_NO_NAME;
	    }

#define g_OID_prefix_equal(o1, o2) \
        (((o1)->length >= (o2)->length) && \
        (memcmp((o1)->elements, (o2)->elements, (o2)->length) == 0))

	    /* Ensure we're returning correct creds format */
	    if ((temp_ret_flags & GSS_C_DELEG_FLAG) &&
		tmp_d_cred != GSS_C_NO_CREDENTIAL) {
		public_mech = gssint_get_public_oid(selected_mech);
		if (actual_mech != GSS_C_NO_OID &&
		    public_mech != GSS_C_NO_OID &&
		    !g_OID_prefix_equal(actual_mech, public_mech)) {
		    *d_cred = tmp_d_cred; /* unwrapped pseudo-mech */
		} else {
		    gss_union_cred_t d_u_cred = NULL;

		    d_u_cred = malloc(sizeof (gss_union_cred_desc));
		    if (d_u_cred == NULL) {
			status = GSS_S_FAILURE;
			goto error_out;
		    }
		    (void) memset(d_u_cred, 0, sizeof (gss_union_cred_desc));

		    d_u_cred->count = 1;

		    status = generic_gss_copy_oid(&temp_minor_status,
						  selected_mech,
						  &d_u_cred->mechs_array);

		    if (status != GSS_S_COMPLETE) {
			free(d_u_cred);
			goto error_out;
		    }

		    d_u_cred->cred_array = malloc(sizeof(gss_cred_id_t));
		    if (d_u_cred->cred_array != NULL) {
			d_u_cred->cred_array[0] = tmp_d_cred;
		    } else {
			free(d_u_cred);
			status = GSS_S_FAILURE;
			goto error_out;
		    }

		    d_u_cred->loopback = d_u_cred;
		    *d_cred = (gss_cred_id_t)d_u_cred;
		}
	    }

	    if (mech_type != NULL)
 		*mech_type = gssint_get_public_oid(actual_mech);
 	    if (ret_flags != NULL)
 		*ret_flags = temp_ret_flags;
//flaw_line_below:
	    return	(status);
//fix_flaw_line_below:
//	    *context_handle = (gss_ctx_id_t)union_ctx_id;
//fix_flaw_line_below:
//	    return GSS_S_COMPLETE;
     } else {
 
 	status = GSS_S_BAD_MECH;
     }
 
 error_out:
//flaw_line_below:
    if (union_ctx_id) {
//fix_flaw_line_below:
//	/*
//fix_flaw_line_below:
//	 * RFC 2744 5.1 requires that we not create a context on a failed first
//fix_flaw_line_below:
//	 * call to accept, and recommends that on a failed subsequent call we
//fix_flaw_line_below:
//	 * make the caller responsible for calling gss_delete_sec_context.
//fix_flaw_line_below:
//	 * Even if the mech deleted its context, keep the union context around
//fix_flaw_line_below:
//	 * for the caller to delete.
//fix_flaw_line_below:
//	 */
//fix_flaw_line_below:
//    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {
 	if (union_ctx_id->mech_type) {
 	    if (union_ctx_id->mech_type->elements)
 		free(union_ctx_id->mech_type->elements);
	    free(union_ctx_id->mech_type);
	}
	if (union_ctx_id->internal_ctx_id && mech &&
	    mech->gss_delete_sec_context) {
	    mech->gss_delete_sec_context(&temp_minor_status,
					 &union_ctx_id->internal_ctx_id,
 					 GSS_C_NO_BUFFER);
 	}
 	free(union_ctx_id);
//flaw_line_below:
	*context_handle = GSS_C_NO_CONTEXT;
     }
 
     if (src_name)
	*src_name = GSS_C_NO_NAME;

    if (tmp_src_name != GSS_C_NO_NAME)
	(void) gss_release_buffer(&temp_minor_status,
				  (gss_buffer_t)tmp_src_name);

    return (status);
}
"
3448,181184,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,2,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",0,src/lib/gssapi/mechglue/g_complete_auth_token.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_complete_auth_token (OM_uint32 *minor_status,
	                 const gss_ctx_id_t context_handle,
	                 gss_buffer_t input_message_buffer)
{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    if (context_handle == GSS_C_NO_CONTEXT)
	return GSS_S_NO_CONTEXT;

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech != NULL) {
	if (mech->gss_complete_auth_token != NULL) {
	    status = mech->gss_complete_auth_token(minor_status,
						   ctx->internal_ctx_id,
						   input_message_buffer);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_COMPLETE;
    } else
	status = GSS_S_BAD_MECH;

    return status;
}
","gss_complete_auth_token (OM_uint32 *minor_status,
	                 const gss_ctx_id_t context_handle,
	                 gss_buffer_t input_message_buffer)
{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    if (context_handle == GSS_C_NO_CONTEXT)
	return GSS_S_NO_CONTEXT;

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech != NULL) {
	if (mech->gss_complete_auth_token != NULL) {
	    status = mech->gss_complete_auth_token(minor_status,
						   ctx->internal_ctx_id,
						   input_message_buffer);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_COMPLETE;
    } else
	status = GSS_S_BAD_MECH;

    return status;
}
",C,"    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return GSS_S_NO_CONTEXT;
",,,"@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech != NULL) {",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_complete_auth_token (OM_uint32 *minor_status,
	                 const gss_ctx_id_t context_handle,
	                 gss_buffer_t input_message_buffer)
{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    if (context_handle == GSS_C_NO_CONTEXT)
	return GSS_S_NO_CONTEXT;

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
//fix_flaw_line_below:
//    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech != NULL) {
	if (mech->gss_complete_auth_token != NULL) {
	    status = mech->gss_complete_auth_token(minor_status,
						   ctx->internal_ctx_id,
						   input_message_buffer);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_COMPLETE;
    } else
	status = GSS_S_BAD_MECH;

    return status;
}
"
3449,181185,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,2,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",0,src/lib/gssapi/mechglue/g_context_time.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_context_time (minor_status,
                  context_handle,
                  time_rec)

OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
OM_uint32 *		time_rec;

{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    if (minor_status == NULL)
	return (GSS_S_CALL_INACCESSIBLE_WRITE);
    *minor_status = 0;

    if (time_rec == NULL)
	return (GSS_S_CALL_INACCESSIBLE_WRITE);

    if (context_handle == GSS_C_NO_CONTEXT)
	return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {

	if (mech->gss_context_time) {
	    status = mech->gss_context_time(
					    minor_status,
					    ctx->internal_ctx_id,
					    time_rec);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }

    return (GSS_S_BAD_MECH);
}
","gss_context_time (minor_status,
                  context_handle,
                  time_rec)

OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
OM_uint32 *		time_rec;

{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    if (minor_status == NULL)
	return (GSS_S_CALL_INACCESSIBLE_WRITE);
    *minor_status = 0;

    if (time_rec == NULL)
	return (GSS_S_CALL_INACCESSIBLE_WRITE);

    if (context_handle == GSS_C_NO_CONTEXT)
	return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {

	if (mech->gss_context_time) {
	    status = mech->gss_context_time(
					    minor_status,
					    ctx->internal_ctx_id,
					    time_rec);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }

    return (GSS_S_BAD_MECH);
}
",C,"    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
",,,"@@ -58,6 +58,8 @@ OM_uint32 *		time_rec;
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_context_time (minor_status,
                  context_handle,
                  time_rec)

OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
OM_uint32 *		time_rec;

{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    if (minor_status == NULL)
	return (GSS_S_CALL_INACCESSIBLE_WRITE);
    *minor_status = 0;

    if (time_rec == NULL)
	return (GSS_S_CALL_INACCESSIBLE_WRITE);

    if (context_handle == GSS_C_NO_CONTEXT)
	return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
//fix_flaw_line_below:
//    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {

	if (mech->gss_context_time) {
	    status = mech->gss_context_time(
					    minor_status,
					    ctx->internal_ctx_id,
					    time_rec);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }

    return (GSS_S_BAD_MECH);
}
"
3450,181186,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,8,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",6,src/lib/gssapi/mechglue/g_delete_sec_context.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_delete_sec_context (minor_status,
                        context_handle,
                        output_token)

OM_uint32 *		minor_status;
gss_ctx_id_t *		context_handle;
gss_buffer_t		output_token;

{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;

    status = val_del_sec_ctx_args(minor_status, context_handle, output_token);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
     */

    ctx = (gss_union_ctx_id_t) *context_handle;
     if (GSSINT_CHK_LOOP(ctx))
 	return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);
 
    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {
	status = gssint_delete_internal_sec_context(minor_status,
						    ctx->mech_type,
						    &ctx->internal_ctx_id,
						    output_token);
	if (status)
	    return status;
    }
 
     /* now free up the space for the union context structure */
     free(ctx->mech_type->elements);
    free(ctx->mech_type);
    free(*context_handle);
    *context_handle = GSS_C_NO_CONTEXT;

    return (GSS_S_COMPLETE);
}
","gss_delete_sec_context (minor_status,
                        context_handle,
                        output_token)

OM_uint32 *		minor_status;
gss_ctx_id_t *		context_handle;
gss_buffer_t		output_token;

{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;

    status = val_del_sec_ctx_args(minor_status, context_handle, output_token);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
     */

    ctx = (gss_union_ctx_id_t) *context_handle;
     if (GSSINT_CHK_LOOP(ctx))
 	return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);
 
    status = gssint_delete_internal_sec_context(minor_status,
						ctx->mech_type,
						&ctx->internal_ctx_id,
						output_token);
    if (status)
	return status;
 
     /* now free up the space for the union context structure */
     free(ctx->mech_type->elements);
    free(ctx->mech_type);
    free(*context_handle);
    *context_handle = GSS_C_NO_CONTEXT;

    return (GSS_S_COMPLETE);
}
",C,"    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {
	status = gssint_delete_internal_sec_context(minor_status,
						    ctx->mech_type,
						    &ctx->internal_ctx_id,
						    output_token);
	if (status)
	    return status;
    }
","    status = gssint_delete_internal_sec_context(minor_status,
						ctx->mech_type,
						&ctx->internal_ctx_id,
						output_token);
    if (status)
	return status;
",,"@@ -87,12 +87,14 @@ gss_buffer_t		output_token;
     if (GSSINT_CHK_LOOP(ctx))
 	return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);
 
-    status = gssint_delete_internal_sec_context(minor_status,
-						ctx->mech_type,
-						&ctx->internal_ctx_id,
-						output_token);
-    if (status)
-	return status;
+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {
+	status = gssint_delete_internal_sec_context(minor_status,
+						    ctx->mech_type,
+						    &ctx->internal_ctx_id,
+						    output_token);
+	if (status)
+	    return status;
+    }
 
     /* now free up the space for the union context structure */
     free(ctx->mech_type->elements);",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_delete_sec_context (minor_status,
                        context_handle,
                        output_token)

OM_uint32 *		minor_status;
gss_ctx_id_t *		context_handle;
gss_buffer_t		output_token;

{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;

    status = val_del_sec_ctx_args(minor_status, context_handle, output_token);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
     */

    ctx = (gss_union_ctx_id_t) *context_handle;
     if (GSSINT_CHK_LOOP(ctx))
 	return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);
 
//flaw_line_below:
    status = gssint_delete_internal_sec_context(minor_status,
//flaw_line_below:
						ctx->mech_type,
//flaw_line_below:
						&ctx->internal_ctx_id,
//flaw_line_below:
						output_token);
//flaw_line_below:
    if (status)
//flaw_line_below:
	return status;
//fix_flaw_line_below:
//    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {
//fix_flaw_line_below:
//	status = gssint_delete_internal_sec_context(minor_status,
//fix_flaw_line_below:
//						    ctx->mech_type,
//fix_flaw_line_below:
//						    &ctx->internal_ctx_id,
//fix_flaw_line_below:
//						    output_token);
//fix_flaw_line_below:
//	if (status)
//fix_flaw_line_below:
//	    return status;
//fix_flaw_line_below:
//    }
 
     /* now free up the space for the union context structure */
     free(ctx->mech_type->elements);
    free(ctx->mech_type);
    free(*context_handle);
    *context_handle = GSS_C_NO_CONTEXT;

    return (GSS_S_COMPLETE);
}
"
3451,181187,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,2,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",0,src/lib/gssapi/mechglue/g_exp_sec_context.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_export_sec_context(minor_status,
                       context_handle,
                       interprocess_token)

OM_uint32 *		minor_status;
gss_ctx_id_t *		context_handle;
gss_buffer_t		interprocess_token;

{
    OM_uint32		status;
    OM_uint32 		length;
    gss_union_ctx_id_t	ctx = NULL;
    gss_mechanism	mech;
    gss_buffer_desc	token = GSS_C_EMPTY_BUFFER;
    char		*buf;

    status = val_exp_sec_ctx_args(minor_status,
				  context_handle, interprocess_token);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) *context_handle;
    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
     if (!mech)
 	return GSS_S_BAD_MECH;
    if (!mech->gss_export_sec_context)
	return (GSS_S_UNAVAILABLE);

    status = mech->gss_export_sec_context(minor_status,
					  &ctx->internal_ctx_id, &token);
    if (status != GSS_S_COMPLETE) {
	map_error(minor_status, mech);
	goto cleanup;
    }

    length = token.length + 4 + ctx->mech_type->length;
    interprocess_token->length = length;
    interprocess_token->value = malloc(length);
    if (interprocess_token->value == 0) {
	*minor_status = ENOMEM;
	status = GSS_S_FAILURE;
	goto cleanup;
    }
    buf = interprocess_token->value;
    length = ctx->mech_type->length;
    buf[3] = (unsigned char) (length & 0xFF);
    length >>= 8;
    buf[2] = (unsigned char) (length & 0xFF);
    length >>= 8;
    buf[1] = (unsigned char) (length & 0xFF);
    length >>= 8;
    buf[0] = (unsigned char) (length & 0xFF);
    memcpy(buf+4, ctx->mech_type->elements, (size_t) ctx->mech_type->length);
    memcpy(buf+4+ctx->mech_type->length, token.value, token.length);

    status = GSS_S_COMPLETE;

cleanup:
    (void) gss_release_buffer(minor_status, &token);
    if (ctx != NULL && ctx->internal_ctx_id == GSS_C_NO_CONTEXT) {
	/* If the mech deleted its context, delete the union context. */
	free(ctx->mech_type->elements);
	free(ctx->mech_type);
	free(ctx);
	*context_handle = GSS_C_NO_CONTEXT;
    }
    return status;
}
","gss_export_sec_context(minor_status,
                       context_handle,
                       interprocess_token)

OM_uint32 *		minor_status;
gss_ctx_id_t *		context_handle;
gss_buffer_t		interprocess_token;

{
    OM_uint32		status;
    OM_uint32 		length;
    gss_union_ctx_id_t	ctx = NULL;
    gss_mechanism	mech;
    gss_buffer_desc	token = GSS_C_EMPTY_BUFFER;
    char		*buf;

    status = val_exp_sec_ctx_args(minor_status,
				  context_handle, interprocess_token);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) *context_handle;
     mech = gssint_get_mechanism (ctx->mech_type);
     if (!mech)
 	return GSS_S_BAD_MECH;
    if (!mech->gss_export_sec_context)
	return (GSS_S_UNAVAILABLE);

    status = mech->gss_export_sec_context(minor_status,
					  &ctx->internal_ctx_id, &token);
    if (status != GSS_S_COMPLETE) {
	map_error(minor_status, mech);
	goto cleanup;
    }

    length = token.length + 4 + ctx->mech_type->length;
    interprocess_token->length = length;
    interprocess_token->value = malloc(length);
    if (interprocess_token->value == 0) {
	*minor_status = ENOMEM;
	status = GSS_S_FAILURE;
	goto cleanup;
    }
    buf = interprocess_token->value;
    length = ctx->mech_type->length;
    buf[3] = (unsigned char) (length & 0xFF);
    length >>= 8;
    buf[2] = (unsigned char) (length & 0xFF);
    length >>= 8;
    buf[1] = (unsigned char) (length & 0xFF);
    length >>= 8;
    buf[0] = (unsigned char) (length & 0xFF);
    memcpy(buf+4, ctx->mech_type->elements, (size_t) ctx->mech_type->length);
    memcpy(buf+4+ctx->mech_type->length, token.value, token.length);

    status = GSS_S_COMPLETE;

cleanup:
    (void) gss_release_buffer(minor_status, &token);
    if (ctx != NULL && ctx->internal_ctx_id == GSS_C_NO_CONTEXT) {
	/* If the mech deleted its context, delete the union context. */
	free(ctx->mech_type->elements);
	free(ctx->mech_type);
	free(ctx);
	*context_handle = GSS_C_NO_CONTEXT;
    }
    return status;
}
",C,"    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
",,,"@@ -95,6 +95,8 @@ gss_buffer_t		interprocess_token;
      */
 
     ctx = (gss_union_ctx_id_t) *context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
     if (!mech)
 	return GSS_S_BAD_MECH;",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_export_sec_context(minor_status,
                       context_handle,
                       interprocess_token)

OM_uint32 *		minor_status;
gss_ctx_id_t *		context_handle;
gss_buffer_t		interprocess_token;

{
    OM_uint32		status;
    OM_uint32 		length;
    gss_union_ctx_id_t	ctx = NULL;
    gss_mechanism	mech;
    gss_buffer_desc	token = GSS_C_EMPTY_BUFFER;
    char		*buf;

    status = val_exp_sec_ctx_args(minor_status,
				  context_handle, interprocess_token);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) *context_handle;
//fix_flaw_line_below:
//    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
     if (!mech)
 	return GSS_S_BAD_MECH;
    if (!mech->gss_export_sec_context)
	return (GSS_S_UNAVAILABLE);

    status = mech->gss_export_sec_context(minor_status,
					  &ctx->internal_ctx_id, &token);
    if (status != GSS_S_COMPLETE) {
	map_error(minor_status, mech);
	goto cleanup;
    }

    length = token.length + 4 + ctx->mech_type->length;
    interprocess_token->length = length;
    interprocess_token->value = malloc(length);
    if (interprocess_token->value == 0) {
	*minor_status = ENOMEM;
	status = GSS_S_FAILURE;
	goto cleanup;
    }
    buf = interprocess_token->value;
    length = ctx->mech_type->length;
    buf[3] = (unsigned char) (length & 0xFF);
    length >>= 8;
    buf[2] = (unsigned char) (length & 0xFF);
    length >>= 8;
    buf[1] = (unsigned char) (length & 0xFF);
    length >>= 8;
    buf[0] = (unsigned char) (length & 0xFF);
    memcpy(buf+4, ctx->mech_type->elements, (size_t) ctx->mech_type->length);
    memcpy(buf+4+ctx->mech_type->length, token.value, token.length);

    status = GSS_S_COMPLETE;

cleanup:
    (void) gss_release_buffer(minor_status, &token);
    if (ctx != NULL && ctx->internal_ctx_id == GSS_C_NO_CONTEXT) {
	/* If the mech deleted its context, delete the union context. */
	free(ctx->mech_type->elements);
	free(ctx->mech_type);
	free(ctx);
	*context_handle = GSS_C_NO_CONTEXT;
    }
    return status;
}
"
3452,181188,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,11,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",8,src/lib/gssapi/mechglue/g_init_sec_context.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_init_sec_context (minor_status,
                      claimant_cred_handle,
                      context_handle,
                      target_name,
                      req_mech_type,
                      req_flags,
                      time_req,
                      input_chan_bindings,
                      input_token,
                      actual_mech_type,
                      output_token,
                      ret_flags,
                      time_rec)

OM_uint32 *		minor_status;
gss_cred_id_t		claimant_cred_handle;
gss_ctx_id_t *		context_handle;
gss_name_t		target_name;
gss_OID			req_mech_type;
OM_uint32		req_flags;
OM_uint32		time_req;
gss_channel_bindings_t	input_chan_bindings;
gss_buffer_t		input_token;
gss_OID *		actual_mech_type;
gss_buffer_t		output_token;
OM_uint32 *		ret_flags;
OM_uint32 *		time_rec;

{
    OM_uint32		status, temp_minor_status;
    gss_union_name_t	union_name;
    gss_union_cred_t	union_cred;
    gss_name_t		internal_name;
    gss_union_ctx_id_t	union_ctx_id;
    gss_OID		selected_mech;
    gss_mechanism	mech;
    gss_cred_id_t	input_cred_handle;

    status = val_init_sec_ctx_args(minor_status,
				   claimant_cred_handle,
				   context_handle,
				   target_name,
				   req_mech_type,
				   req_flags,
				   time_req,
				   input_chan_bindings,
				   input_token,
				   actual_mech_type,
				   output_token,
				   ret_flags,
				   time_rec);
    if (status != GSS_S_COMPLETE)
	return (status);

    status = gssint_select_mech_type(minor_status, req_mech_type,
				     &selected_mech);
    if (status != GSS_S_COMPLETE)
	return (status);

    union_name = (gss_union_name_t)target_name;

    /*
     * obtain the gss mechanism information for the requested
     * mechanism.  If mech_type is NULL, set it to the resultant
     * mechanism
     */
    mech = gssint_get_mechanism(selected_mech);
    if (mech == NULL)
	return (GSS_S_BAD_MECH);

    if (mech->gss_init_sec_context == NULL)
	return (GSS_S_UNAVAILABLE);

    /*
     * If target_name is mechanism_specific, then it must match the
     * mech_type that we're about to use.  Otherwise, do an import on
     * the external_name form of the target name.
     */
    if (union_name->mech_type &&
	g_OID_equal(union_name->mech_type, selected_mech)) {
	internal_name = union_name->mech_name;
    } else {
	if ((status = gssint_import_internal_name(minor_status, selected_mech,
						 union_name,
						 &internal_name)) != GSS_S_COMPLETE)
	    return (status);
    }

    /*
     * if context_handle is GSS_C_NO_CONTEXT, allocate a union context
     * descriptor to hold the mech type information as well as the
     * underlying mechanism context handle. Otherwise, cast the
     * value of *context_handle to the union context variable.
     */

    if(*context_handle == GSS_C_NO_CONTEXT) {
	status = GSS_S_FAILURE;
	union_ctx_id = (gss_union_ctx_id_t)
	    malloc(sizeof(gss_union_ctx_id_desc));
	if (union_ctx_id == NULL)
	    goto end;

	if (generic_gss_copy_oid(&temp_minor_status, selected_mech,
				 &union_ctx_id->mech_type) != GSS_S_COMPLETE) {
	    free(union_ctx_id);
	    goto end;
	}
 
 	/* copy the supplied context handle */
 	union_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;
    } else {
 	union_ctx_id = (gss_union_ctx_id_t)*context_handle;
	if (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {
	    status = GSS_S_NO_CONTEXT;
	    goto end;
	}
    }
 
     /*
      * get the appropriate cred handle from the union cred struct.
     * defaults to GSS_C_NO_CREDENTIAL if there is no cred, which will
     * use the default credential.
     */
    union_cred = (gss_union_cred_t) claimant_cred_handle;
    input_cred_handle = gssint_get_mechanism_cred(union_cred, selected_mech);

    /*
     * now call the approprate underlying mechanism routine
     */

    status = mech->gss_init_sec_context(
	minor_status,
	input_cred_handle,
	&union_ctx_id->internal_ctx_id,
	internal_name,
	gssint_get_public_oid(selected_mech),
	req_flags,
	time_req,
	input_chan_bindings,
	input_token,
	actual_mech_type,
	output_token,
	ret_flags,
	time_rec);
 
     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {
 	/*
	 * RFC 2744 5.19 requires that we not create a context on a failed
	 * first call to init, and recommends that on a failed subsequent call
	 * we make the caller responsible for calling gss_delete_sec_context.
	 * Even if the mech deleted its context, keep the union context around
	 * for the caller to delete.
 	 */
 	map_error(minor_status, mech);
 	if (*context_handle == GSS_C_NO_CONTEXT) {
 	    free(union_ctx_id->mech_type->elements);
 	    free(union_ctx_id->mech_type);
	    free(union_ctx_id);
	}
    } else if (*context_handle == GSS_C_NO_CONTEXT) {
	union_ctx_id->loopback = union_ctx_id;
	*context_handle = (gss_ctx_id_t)union_ctx_id;
    }

end:
    if (union_name->mech_name == NULL ||
	union_name->mech_name != internal_name) {
	(void) gssint_release_internal_name(&temp_minor_status,
					    selected_mech, &internal_name);
    }

    return(status);
}
","gss_init_sec_context (minor_status,
                      claimant_cred_handle,
                      context_handle,
                      target_name,
                      req_mech_type,
                      req_flags,
                      time_req,
                      input_chan_bindings,
                      input_token,
                      actual_mech_type,
                      output_token,
                      ret_flags,
                      time_rec)

OM_uint32 *		minor_status;
gss_cred_id_t		claimant_cred_handle;
gss_ctx_id_t *		context_handle;
gss_name_t		target_name;
gss_OID			req_mech_type;
OM_uint32		req_flags;
OM_uint32		time_req;
gss_channel_bindings_t	input_chan_bindings;
gss_buffer_t		input_token;
gss_OID *		actual_mech_type;
gss_buffer_t		output_token;
OM_uint32 *		ret_flags;
OM_uint32 *		time_rec;

{
    OM_uint32		status, temp_minor_status;
    gss_union_name_t	union_name;
    gss_union_cred_t	union_cred;
    gss_name_t		internal_name;
    gss_union_ctx_id_t	union_ctx_id;
    gss_OID		selected_mech;
    gss_mechanism	mech;
    gss_cred_id_t	input_cred_handle;

    status = val_init_sec_ctx_args(minor_status,
				   claimant_cred_handle,
				   context_handle,
				   target_name,
				   req_mech_type,
				   req_flags,
				   time_req,
				   input_chan_bindings,
				   input_token,
				   actual_mech_type,
				   output_token,
				   ret_flags,
				   time_rec);
    if (status != GSS_S_COMPLETE)
	return (status);

    status = gssint_select_mech_type(minor_status, req_mech_type,
				     &selected_mech);
    if (status != GSS_S_COMPLETE)
	return (status);

    union_name = (gss_union_name_t)target_name;

    /*
     * obtain the gss mechanism information for the requested
     * mechanism.  If mech_type is NULL, set it to the resultant
     * mechanism
     */
    mech = gssint_get_mechanism(selected_mech);
    if (mech == NULL)
	return (GSS_S_BAD_MECH);

    if (mech->gss_init_sec_context == NULL)
	return (GSS_S_UNAVAILABLE);

    /*
     * If target_name is mechanism_specific, then it must match the
     * mech_type that we're about to use.  Otherwise, do an import on
     * the external_name form of the target name.
     */
    if (union_name->mech_type &&
	g_OID_equal(union_name->mech_type, selected_mech)) {
	internal_name = union_name->mech_name;
    } else {
	if ((status = gssint_import_internal_name(minor_status, selected_mech,
						 union_name,
						 &internal_name)) != GSS_S_COMPLETE)
	    return (status);
    }

    /*
     * if context_handle is GSS_C_NO_CONTEXT, allocate a union context
     * descriptor to hold the mech type information as well as the
     * underlying mechanism context handle. Otherwise, cast the
     * value of *context_handle to the union context variable.
     */

    if(*context_handle == GSS_C_NO_CONTEXT) {
	status = GSS_S_FAILURE;
	union_ctx_id = (gss_union_ctx_id_t)
	    malloc(sizeof(gss_union_ctx_id_desc));
	if (union_ctx_id == NULL)
	    goto end;

	if (generic_gss_copy_oid(&temp_minor_status, selected_mech,
				 &union_ctx_id->mech_type) != GSS_S_COMPLETE) {
	    free(union_ctx_id);
	    goto end;
	}
 
 	/* copy the supplied context handle */
 	union_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;
    } else
 	union_ctx_id = (gss_union_ctx_id_t)*context_handle;
 
     /*
      * get the appropriate cred handle from the union cred struct.
     * defaults to GSS_C_NO_CREDENTIAL if there is no cred, which will
     * use the default credential.
     */
    union_cred = (gss_union_cred_t) claimant_cred_handle;
    input_cred_handle = gssint_get_mechanism_cred(union_cred, selected_mech);

    /*
     * now call the approprate underlying mechanism routine
     */

    status = mech->gss_init_sec_context(
	minor_status,
	input_cred_handle,
	&union_ctx_id->internal_ctx_id,
	internal_name,
	gssint_get_public_oid(selected_mech),
	req_flags,
	time_req,
	input_chan_bindings,
	input_token,
	actual_mech_type,
	output_token,
	ret_flags,
	time_rec);
 
     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {
 	/*
	 * The spec says the preferred method is to delete all context info on
	 * the first call to init, and on all subsequent calls make the caller
	 * responsible for calling gss_delete_sec_context.  However, if the
	 * mechanism decided to delete the internal context, we should also
	 * delete the union context.
 	 */
 	map_error(minor_status, mech);
	if (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)
	    *context_handle = GSS_C_NO_CONTEXT;
 	if (*context_handle == GSS_C_NO_CONTEXT) {
 	    free(union_ctx_id->mech_type->elements);
 	    free(union_ctx_id->mech_type);
	    free(union_ctx_id);
	}
    } else if (*context_handle == GSS_C_NO_CONTEXT) {
	union_ctx_id->loopback = union_ctx_id;
	*context_handle = (gss_ctx_id_t)union_ctx_id;
    }

end:
    if (union_name->mech_name == NULL ||
	union_name->mech_name != internal_name) {
	(void) gssint_release_internal_name(&temp_minor_status,
					    selected_mech, &internal_name);
    }

    return(status);
}
",C,"    } else {
	if (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {
	    status = GSS_S_NO_CONTEXT;
	    goto end;
	}
    }
	 * RFC 2744 5.19 requires that we not create a context on a failed
	 * first call to init, and recommends that on a failed subsequent call
	 * we make the caller responsible for calling gss_delete_sec_context.
	 * Even if the mech deleted its context, keep the union context around
	 * for the caller to delete.
","    } else
	 * The spec says the preferred method is to delete all context info on
	 * the first call to init, and on all subsequent calls make the caller
	 * responsible for calling gss_delete_sec_context.  However, if the
	 * mechanism decided to delete the internal context, we should also
	 * delete the union context.
	if (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)
	    *context_handle = GSS_C_NO_CONTEXT;
",,"@@ -192,8 +192,13 @@ OM_uint32 *		time_rec;
 
 	/* copy the supplied context handle */
 	union_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;
-    } else
+    } else {
 	union_ctx_id = (gss_union_ctx_id_t)*context_handle;
+	if (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {
+	    status = GSS_S_NO_CONTEXT;
+	    goto end;
+	}
+    }
 
     /*
      * get the appropriate cred handle from the union cred struct.
@@ -224,15 +229,13 @@ OM_uint32 *		time_rec;
 
     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {
 	/*
-	 * The spec says the preferred method is to delete all context info on
-	 * the first call to init, and on all subsequent calls make the caller
-	 * responsible for calling gss_delete_sec_context.  However, if the
-	 * mechanism decided to delete the internal context, we should also
-	 * delete the union context.
+	 * RFC 2744 5.19 requires that we not create a context on a failed
+	 * first call to init, and recommends that on a failed subsequent call
+	 * we make the caller responsible for calling gss_delete_sec_context.
+	 * Even if the mech deleted its context, keep the union context around
+	 * for the caller to delete.
 	 */
 	map_error(minor_status, mech);
-	if (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)
-	    *context_handle = GSS_C_NO_CONTEXT;
 	if (*context_handle == GSS_C_NO_CONTEXT) {
 	    free(union_ctx_id->mech_type->elements);
 	    free(union_ctx_id->mech_type);",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_init_sec_context (minor_status,
                      claimant_cred_handle,
                      context_handle,
                      target_name,
                      req_mech_type,
                      req_flags,
                      time_req,
                      input_chan_bindings,
                      input_token,
                      actual_mech_type,
                      output_token,
                      ret_flags,
                      time_rec)

OM_uint32 *		minor_status;
gss_cred_id_t		claimant_cred_handle;
gss_ctx_id_t *		context_handle;
gss_name_t		target_name;
gss_OID			req_mech_type;
OM_uint32		req_flags;
OM_uint32		time_req;
gss_channel_bindings_t	input_chan_bindings;
gss_buffer_t		input_token;
gss_OID *		actual_mech_type;
gss_buffer_t		output_token;
OM_uint32 *		ret_flags;
OM_uint32 *		time_rec;

{
    OM_uint32		status, temp_minor_status;
    gss_union_name_t	union_name;
    gss_union_cred_t	union_cred;
    gss_name_t		internal_name;
    gss_union_ctx_id_t	union_ctx_id;
    gss_OID		selected_mech;
    gss_mechanism	mech;
    gss_cred_id_t	input_cred_handle;

    status = val_init_sec_ctx_args(minor_status,
				   claimant_cred_handle,
				   context_handle,
				   target_name,
				   req_mech_type,
				   req_flags,
				   time_req,
				   input_chan_bindings,
				   input_token,
				   actual_mech_type,
				   output_token,
				   ret_flags,
				   time_rec);
    if (status != GSS_S_COMPLETE)
	return (status);

    status = gssint_select_mech_type(minor_status, req_mech_type,
				     &selected_mech);
    if (status != GSS_S_COMPLETE)
	return (status);

    union_name = (gss_union_name_t)target_name;

    /*
     * obtain the gss mechanism information for the requested
     * mechanism.  If mech_type is NULL, set it to the resultant
     * mechanism
     */
    mech = gssint_get_mechanism(selected_mech);
    if (mech == NULL)
	return (GSS_S_BAD_MECH);

    if (mech->gss_init_sec_context == NULL)
	return (GSS_S_UNAVAILABLE);

    /*
     * If target_name is mechanism_specific, then it must match the
     * mech_type that we're about to use.  Otherwise, do an import on
     * the external_name form of the target name.
     */
    if (union_name->mech_type &&
	g_OID_equal(union_name->mech_type, selected_mech)) {
	internal_name = union_name->mech_name;
    } else {
	if ((status = gssint_import_internal_name(minor_status, selected_mech,
						 union_name,
						 &internal_name)) != GSS_S_COMPLETE)
	    return (status);
    }

    /*
     * if context_handle is GSS_C_NO_CONTEXT, allocate a union context
     * descriptor to hold the mech type information as well as the
     * underlying mechanism context handle. Otherwise, cast the
     * value of *context_handle to the union context variable.
     */

    if(*context_handle == GSS_C_NO_CONTEXT) {
	status = GSS_S_FAILURE;
	union_ctx_id = (gss_union_ctx_id_t)
	    malloc(sizeof(gss_union_ctx_id_desc));
	if (union_ctx_id == NULL)
	    goto end;

	if (generic_gss_copy_oid(&temp_minor_status, selected_mech,
				 &union_ctx_id->mech_type) != GSS_S_COMPLETE) {
	    free(union_ctx_id);
	    goto end;
	}
 
 	/* copy the supplied context handle */
 	union_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;
//flaw_line_below:
    } else
//fix_flaw_line_below:
//    } else {
 	union_ctx_id = (gss_union_ctx_id_t)*context_handle;
//fix_flaw_line_below:
//	if (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {
//fix_flaw_line_below:
//	    status = GSS_S_NO_CONTEXT;
//fix_flaw_line_below:
//	    goto end;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//    }
 
     /*
      * get the appropriate cred handle from the union cred struct.
     * defaults to GSS_C_NO_CREDENTIAL if there is no cred, which will
     * use the default credential.
     */
    union_cred = (gss_union_cred_t) claimant_cred_handle;
    input_cred_handle = gssint_get_mechanism_cred(union_cred, selected_mech);

    /*
     * now call the approprate underlying mechanism routine
     */

    status = mech->gss_init_sec_context(
	minor_status,
	input_cred_handle,
	&union_ctx_id->internal_ctx_id,
	internal_name,
	gssint_get_public_oid(selected_mech),
	req_flags,
	time_req,
	input_chan_bindings,
	input_token,
	actual_mech_type,
	output_token,
	ret_flags,
	time_rec);
 
     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {
 	/*
//flaw_line_below:
	 * The spec says the preferred method is to delete all context info on
//flaw_line_below:
	 * the first call to init, and on all subsequent calls make the caller
//flaw_line_below:
	 * responsible for calling gss_delete_sec_context.  However, if the
//flaw_line_below:
	 * mechanism decided to delete the internal context, we should also
//flaw_line_below:
	 * delete the union context.
//fix_flaw_line_below:
//	 * RFC 2744 5.19 requires that we not create a context on a failed
//fix_flaw_line_below:
//	 * first call to init, and recommends that on a failed subsequent call
//fix_flaw_line_below:
//	 * we make the caller responsible for calling gss_delete_sec_context.
//fix_flaw_line_below:
//	 * Even if the mech deleted its context, keep the union context around
//fix_flaw_line_below:
//	 * for the caller to delete.
 	 */
 	map_error(minor_status, mech);
//flaw_line_below:
	if (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)
//flaw_line_below:
	    *context_handle = GSS_C_NO_CONTEXT;
 	if (*context_handle == GSS_C_NO_CONTEXT) {
 	    free(union_ctx_id->mech_type->elements);
 	    free(union_ctx_id->mech_type);
	    free(union_ctx_id);
	}
    } else if (*context_handle == GSS_C_NO_CONTEXT) {
	union_ctx_id->loopback = union_ctx_id;
	*context_handle = (gss_ctx_id_t)union_ctx_id;
    }

end:
    if (union_name->mech_name == NULL ||
	union_name->mech_name != internal_name) {
	(void) gssint_release_internal_name(&temp_minor_status,
					    selected_mech, &internal_name);
    }

    return(status);
}
"
3453,181189,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,2,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",0,src/lib/gssapi/mechglue/g_inq_context.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_inquire_context(
	    OM_uint32 *minor_status,
	    gss_ctx_id_t context_handle,
	    gss_name_t *src_name,
	    gss_name_t *targ_name,
	    OM_uint32 *lifetime_rec,
	    gss_OID *mech_type,
	    OM_uint32 *ctx_flags,
	    int *locally_initiated,
	    int *opened)
{
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;
    OM_uint32		status, temp_minor;
    gss_OID		actual_mech;
    gss_name_t localTargName = NULL, localSourceName = NULL;

    status = val_inq_ctx_args(minor_status,
			      context_handle,
			      src_name, targ_name,
			      lifetime_rec,
			      mech_type, ctx_flags,
			      locally_initiated, opened);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||
	!mech->gss_release_name) {
	return (GSS_S_UNAVAILABLE);
    }

    status = mech->gss_inquire_context(
			minor_status,
			ctx->internal_ctx_id,
			(src_name ? &localSourceName : NULL),
			(targ_name ? &localTargName : NULL),
			lifetime_rec,
			&actual_mech,
			ctx_flags,
			locally_initiated,
			opened);

    if (status != GSS_S_COMPLETE) {
	map_error(minor_status, mech);
	return status;
    }

    /* need to convert names */

    if (src_name) {
	if (localSourceName) {
	    status = gssint_convert_name_to_union_name(minor_status, mech,
						      localSourceName, src_name);

	    if (status != GSS_S_COMPLETE) {
		if (localTargName)
		    mech->gss_release_name(&temp_minor, &localTargName);
		return (status);
	    }
	} else {
	    *src_name = GSS_C_NO_NAME;
	}
    }

    if (targ_name) {
        if (localTargName) {
	    status = gssint_convert_name_to_union_name(minor_status, mech,
						      localTargName, targ_name);

	    if (status != GSS_S_COMPLETE) {
		if (src_name)
		    (void) gss_release_name(&temp_minor, src_name);

		return (status);
	    }
        }
        else {
            *targ_name = GSS_C_NO_NAME;
        }
    }

    if (mech_type)
	*mech_type = gssint_get_public_oid(actual_mech);

    return(GSS_S_COMPLETE);
}
","gss_inquire_context(
	    OM_uint32 *minor_status,
	    gss_ctx_id_t context_handle,
	    gss_name_t *src_name,
	    gss_name_t *targ_name,
	    OM_uint32 *lifetime_rec,
	    gss_OID *mech_type,
	    OM_uint32 *ctx_flags,
	    int *locally_initiated,
	    int *opened)
{
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;
    OM_uint32		status, temp_minor;
    gss_OID		actual_mech;
    gss_name_t localTargName = NULL, localSourceName = NULL;

    status = val_inq_ctx_args(minor_status,
			      context_handle,
			      src_name, targ_name,
			      lifetime_rec,
			      mech_type, ctx_flags,
			      locally_initiated, opened);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||
	!mech->gss_release_name) {
	return (GSS_S_UNAVAILABLE);
    }

    status = mech->gss_inquire_context(
			minor_status,
			ctx->internal_ctx_id,
			(src_name ? &localSourceName : NULL),
			(targ_name ? &localTargName : NULL),
			lifetime_rec,
			&actual_mech,
			ctx_flags,
			locally_initiated,
			opened);

    if (status != GSS_S_COMPLETE) {
	map_error(minor_status, mech);
	return status;
    }

    /* need to convert names */

    if (src_name) {
	if (localSourceName) {
	    status = gssint_convert_name_to_union_name(minor_status, mech,
						      localSourceName, src_name);

	    if (status != GSS_S_COMPLETE) {
		if (localTargName)
		    mech->gss_release_name(&temp_minor, &localTargName);
		return (status);
	    }
	} else {
	    *src_name = GSS_C_NO_NAME;
	}
    }

    if (targ_name) {
        if (localTargName) {
	    status = gssint_convert_name_to_union_name(minor_status, mech,
						      localTargName, targ_name);

	    if (status != GSS_S_COMPLETE) {
		if (src_name)
		    (void) gss_release_name(&temp_minor, src_name);

		return (status);
	    }
        }
        else {
            *targ_name = GSS_C_NO_NAME;
        }
    }

    if (mech_type)
	*mech_type = gssint_get_public_oid(actual_mech);

    return(GSS_S_COMPLETE);
}
",C,"    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
",,,"@@ -104,6 +104,8 @@ gss_inquire_context(
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_inquire_context(
	    OM_uint32 *minor_status,
	    gss_ctx_id_t context_handle,
	    gss_name_t *src_name,
	    gss_name_t *targ_name,
	    OM_uint32 *lifetime_rec,
	    gss_OID *mech_type,
	    OM_uint32 *ctx_flags,
	    int *locally_initiated,
	    int *opened)
{
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;
    OM_uint32		status, temp_minor;
    gss_OID		actual_mech;
    gss_name_t localTargName = NULL, localSourceName = NULL;

    status = val_inq_ctx_args(minor_status,
			      context_handle,
			      src_name, targ_name,
			      lifetime_rec,
			      mech_type, ctx_flags,
			      locally_initiated, opened);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
//fix_flaw_line_below:
//    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||
	!mech->gss_release_name) {
	return (GSS_S_UNAVAILABLE);
    }

    status = mech->gss_inquire_context(
			minor_status,
			ctx->internal_ctx_id,
			(src_name ? &localSourceName : NULL),
			(targ_name ? &localTargName : NULL),
			lifetime_rec,
			&actual_mech,
			ctx_flags,
			locally_initiated,
			opened);

    if (status != GSS_S_COMPLETE) {
	map_error(minor_status, mech);
	return status;
    }

    /* need to convert names */

    if (src_name) {
	if (localSourceName) {
	    status = gssint_convert_name_to_union_name(minor_status, mech,
						      localSourceName, src_name);

	    if (status != GSS_S_COMPLETE) {
		if (localTargName)
		    mech->gss_release_name(&temp_minor, &localTargName);
		return (status);
	    }
	} else {
	    *src_name = GSS_C_NO_NAME;
	}
    }

    if (targ_name) {
        if (localTargName) {
	    status = gssint_convert_name_to_union_name(minor_status, mech,
						      localTargName, targ_name);

	    if (status != GSS_S_COMPLETE) {
		if (src_name)
		    (void) gss_release_name(&temp_minor, src_name);

		return (status);
	    }
        }
        else {
            *targ_name = GSS_C_NO_NAME;
        }
    }

    if (mech_type)
	*mech_type = gssint_get_public_oid(actual_mech);

    return(GSS_S_COMPLETE);
}
"
3454,181190,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,2,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",0,src/lib/gssapi/mechglue/g_prf.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_pseudo_random (OM_uint32 *minor_status,
	           gss_ctx_id_t context_handle,
	           int prf_key,
	           const gss_buffer_t prf_in,
	           ssize_t desired_output_len,
	           gss_buffer_t prf_out)
{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    if (minor_status == NULL)
	return GSS_S_CALL_INACCESSIBLE_WRITE;

    if (context_handle == GSS_C_NO_CONTEXT)
	return GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;

    if (prf_in == GSS_C_NO_BUFFER)
	return GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;

    if (prf_out == GSS_C_NO_BUFFER)
	return GSS_S_CALL_INACCESSIBLE_WRITE | GSS_S_NO_CONTEXT;

    prf_out->length = 0;
    prf_out->value = NULL;

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech != NULL) {
	if (mech->gss_pseudo_random != NULL) {
	    status = mech->gss_pseudo_random(minor_status,
					     ctx->internal_ctx_id,
					     prf_key,
					     prf_in,
					     desired_output_len,
					     prf_out);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return status;
    }

    return GSS_S_BAD_MECH;
}
","gss_pseudo_random (OM_uint32 *minor_status,
	           gss_ctx_id_t context_handle,
	           int prf_key,
	           const gss_buffer_t prf_in,
	           ssize_t desired_output_len,
	           gss_buffer_t prf_out)
{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    if (minor_status == NULL)
	return GSS_S_CALL_INACCESSIBLE_WRITE;

    if (context_handle == GSS_C_NO_CONTEXT)
	return GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;

    if (prf_in == GSS_C_NO_BUFFER)
	return GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;

    if (prf_out == GSS_C_NO_BUFFER)
	return GSS_S_CALL_INACCESSIBLE_WRITE | GSS_S_NO_CONTEXT;

    prf_out->length = 0;
    prf_out->value = NULL;

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech != NULL) {
	if (mech->gss_pseudo_random != NULL) {
	    status = mech->gss_pseudo_random(minor_status,
					     ctx->internal_ctx_id,
					     prf_key,
					     prf_in,
					     desired_output_len,
					     prf_out);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return status;
    }

    return GSS_S_BAD_MECH;
}
",C,"    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return GSS_S_NO_CONTEXT;
",,,"@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech != NULL) {",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_pseudo_random (OM_uint32 *minor_status,
	           gss_ctx_id_t context_handle,
	           int prf_key,
	           const gss_buffer_t prf_in,
	           ssize_t desired_output_len,
	           gss_buffer_t prf_out)
{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    if (minor_status == NULL)
	return GSS_S_CALL_INACCESSIBLE_WRITE;

    if (context_handle == GSS_C_NO_CONTEXT)
	return GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;

    if (prf_in == GSS_C_NO_BUFFER)
	return GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;

    if (prf_out == GSS_C_NO_BUFFER)
	return GSS_S_CALL_INACCESSIBLE_WRITE | GSS_S_NO_CONTEXT;

    prf_out->length = 0;
    prf_out->value = NULL;

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
//fix_flaw_line_below:
//    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech != NULL) {
	if (mech->gss_pseudo_random != NULL) {
	    status = mech->gss_pseudo_random(minor_status,
					     ctx->internal_ctx_id,
					     prf_key,
					     prf_in,
					     desired_output_len,
					     prf_out);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return status;
    }

    return GSS_S_BAD_MECH;
}
"
3455,181191,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,2,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",0,src/lib/gssapi/mechglue/g_process_context.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_process_context_token (minor_status,
                           context_handle,
                           token_buffer)

OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
gss_buffer_t		token_buffer;

{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    if (minor_status == NULL)
	return (GSS_S_CALL_INACCESSIBLE_WRITE);
    *minor_status = 0;

    if (context_handle == GSS_C_NO_CONTEXT)
	return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);

    if (token_buffer == GSS_C_NO_BUFFER)
	return (GSS_S_CALL_INACCESSIBLE_READ);

    if (GSS_EMPTY_BUFFER(token_buffer))
	return (GSS_S_CALL_INACCESSIBLE_READ);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {

	if (mech->gss_process_context_token) {
	    status = mech->gss_process_context_token(
						    minor_status,
						    ctx->internal_ctx_id,
						    token_buffer);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }

    return (GSS_S_BAD_MECH);
}
","gss_process_context_token (minor_status,
                           context_handle,
                           token_buffer)

OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
gss_buffer_t		token_buffer;

{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    if (minor_status == NULL)
	return (GSS_S_CALL_INACCESSIBLE_WRITE);
    *minor_status = 0;

    if (context_handle == GSS_C_NO_CONTEXT)
	return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);

    if (token_buffer == GSS_C_NO_BUFFER)
	return (GSS_S_CALL_INACCESSIBLE_READ);

    if (GSS_EMPTY_BUFFER(token_buffer))
	return (GSS_S_CALL_INACCESSIBLE_READ);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {

	if (mech->gss_process_context_token) {
	    status = mech->gss_process_context_token(
						    minor_status,
						    ctx->internal_ctx_id,
						    token_buffer);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }

    return (GSS_S_BAD_MECH);
}
",C,"    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
",,,"@@ -61,6 +61,8 @@ gss_buffer_t		token_buffer;
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_process_context_token (minor_status,
                           context_handle,
                           token_buffer)

OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
gss_buffer_t		token_buffer;

{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    if (minor_status == NULL)
	return (GSS_S_CALL_INACCESSIBLE_WRITE);
    *minor_status = 0;

    if (context_handle == GSS_C_NO_CONTEXT)
	return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);

    if (token_buffer == GSS_C_NO_BUFFER)
	return (GSS_S_CALL_INACCESSIBLE_READ);

    if (GSS_EMPTY_BUFFER(token_buffer))
	return (GSS_S_CALL_INACCESSIBLE_READ);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
//fix_flaw_line_below:
//    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {

	if (mech->gss_process_context_token) {
	    status = mech->gss_process_context_token(
						    minor_status,
						    ctx->internal_ctx_id,
						    token_buffer);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }

    return (GSS_S_BAD_MECH);
}
"
3456,181192,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,2,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",0,src/lib/gssapi/mechglue/g_seal.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_wrap( OM_uint32 *minor_status,
          gss_ctx_id_t context_handle,
          int conf_req_flag,
          gss_qop_t qop_req,
          gss_buffer_t input_message_buffer,
          int *conf_state,
          gss_buffer_t output_message_buffer)
{

    /* EXPORT DELETE START */

    OM_uint32           status;
    gss_union_ctx_id_t  ctx;
    gss_mechanism       mech;

    status = val_wrap_args(minor_status, context_handle,
                           conf_req_flag, qop_req,
                           input_message_buffer, conf_state,
                           output_message_buffer);
    if (status != GSS_S_COMPLETE)
        return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
        return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
        if (mech->gss_wrap) {
            status = mech->gss_wrap(minor_status,
                                    ctx->internal_ctx_id,
                                    conf_req_flag,
                                    qop_req,
                                    input_message_buffer,
                                    conf_state,
                                    output_message_buffer);
            if (status != GSS_S_COMPLETE)
                map_error(minor_status, mech);
        } else if (mech->gss_wrap_aead ||
                   (mech->gss_wrap_iov && mech->gss_wrap_iov_length)) {
            status = gssint_wrap_aead(mech,
                                      minor_status,
                                      ctx,
                                      conf_req_flag,
                                      (gss_qop_t)qop_req,
                                      GSS_C_NO_BUFFER,
                                      input_message_buffer,
                                      conf_state,
                                      output_message_buffer);
        } else
            status = GSS_S_UNAVAILABLE;

        return(status);
    }
    /* EXPORT DELETE END */

    return (GSS_S_BAD_MECH);
}
","gss_wrap( OM_uint32 *minor_status,
          gss_ctx_id_t context_handle,
          int conf_req_flag,
          gss_qop_t qop_req,
          gss_buffer_t input_message_buffer,
          int *conf_state,
          gss_buffer_t output_message_buffer)
{

    /* EXPORT DELETE START */

    OM_uint32           status;
    gss_union_ctx_id_t  ctx;
    gss_mechanism       mech;

    status = val_wrap_args(minor_status, context_handle,
                           conf_req_flag, qop_req,
                           input_message_buffer, conf_state,
                           output_message_buffer);
    if (status != GSS_S_COMPLETE)
        return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
        if (mech->gss_wrap) {
            status = mech->gss_wrap(minor_status,
                                    ctx->internal_ctx_id,
                                    conf_req_flag,
                                    qop_req,
                                    input_message_buffer,
                                    conf_state,
                                    output_message_buffer);
            if (status != GSS_S_COMPLETE)
                map_error(minor_status, mech);
        } else if (mech->gss_wrap_aead ||
                   (mech->gss_wrap_iov && mech->gss_wrap_iov_length)) {
            status = gssint_wrap_aead(mech,
                                      minor_status,
                                      ctx,
                                      conf_req_flag,
                                      (gss_qop_t)qop_req,
                                      GSS_C_NO_BUFFER,
                                      input_message_buffer,
                                      conf_state,
                                      output_message_buffer);
        } else
            status = GSS_S_UNAVAILABLE;

        return(status);
    }
    /* EXPORT DELETE END */

    return (GSS_S_BAD_MECH);
}
",C,"    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
        return (GSS_S_NO_CONTEXT);
",,,"@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+        return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+        return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (!mech)",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_wrap( OM_uint32 *minor_status,
          gss_ctx_id_t context_handle,
          int conf_req_flag,
          gss_qop_t qop_req,
          gss_buffer_t input_message_buffer,
          int *conf_state,
          gss_buffer_t output_message_buffer)
{

    /* EXPORT DELETE START */

    OM_uint32           status;
    gss_union_ctx_id_t  ctx;
    gss_mechanism       mech;

    status = val_wrap_args(minor_status, context_handle,
                           conf_req_flag, qop_req,
                           input_message_buffer, conf_state,
                           output_message_buffer);
    if (status != GSS_S_COMPLETE)
        return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
//fix_flaw_line_below:
//    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//        return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
        if (mech->gss_wrap) {
            status = mech->gss_wrap(minor_status,
                                    ctx->internal_ctx_id,
                                    conf_req_flag,
                                    qop_req,
                                    input_message_buffer,
                                    conf_state,
                                    output_message_buffer);
            if (status != GSS_S_COMPLETE)
                map_error(minor_status, mech);
        } else if (mech->gss_wrap_aead ||
                   (mech->gss_wrap_iov && mech->gss_wrap_iov_length)) {
            status = gssint_wrap_aead(mech,
                                      minor_status,
                                      ctx,
                                      conf_req_flag,
                                      (gss_qop_t)qop_req,
                                      GSS_C_NO_BUFFER,
                                      input_message_buffer,
                                      conf_state,
                                      output_message_buffer);
        } else
            status = GSS_S_UNAVAILABLE;

        return(status);
    }
    /* EXPORT DELETE END */

    return (GSS_S_BAD_MECH);
}
"
3457,181193,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,2,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",0,src/lib/gssapi/mechglue/g_seal.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_wrap_size_limit(OM_uint32  *minor_status,
                    gss_ctx_id_t context_handle,
                    int conf_req_flag,
                    gss_qop_t qop_req, OM_uint32 req_output_size, OM_uint32 *max_input_size)
{
    gss_union_ctx_id_t  ctx;
    gss_mechanism       mech;
    OM_uint32           major_status;

    if (minor_status == NULL)
        return (GSS_S_CALL_INACCESSIBLE_WRITE);
    *minor_status = 0;

    if (context_handle == GSS_C_NO_CONTEXT)
        return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);

    if (max_input_size == NULL)
        return (GSS_S_CALL_INACCESSIBLE_WRITE);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
        return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (!mech)
        return (GSS_S_BAD_MECH);

    if (mech->gss_wrap_size_limit)
        major_status = mech->gss_wrap_size_limit(minor_status,
                                                 ctx->internal_ctx_id,
                                                 conf_req_flag, qop_req,
                                                 req_output_size, max_input_size);
    else if (mech->gss_wrap_iov_length)
        major_status = gssint_wrap_size_limit_iov_shim(mech, minor_status,
                                                       ctx->internal_ctx_id,
                                                       conf_req_flag, qop_req,
                                                       req_output_size, max_input_size);
    else
        major_status = GSS_S_UNAVAILABLE;
    if (major_status != GSS_S_COMPLETE)
        map_error(minor_status, mech);
    return major_status;
}
","gss_wrap_size_limit(OM_uint32  *minor_status,
                    gss_ctx_id_t context_handle,
                    int conf_req_flag,
                    gss_qop_t qop_req, OM_uint32 req_output_size, OM_uint32 *max_input_size)
{
    gss_union_ctx_id_t  ctx;
    gss_mechanism       mech;
    OM_uint32           major_status;

    if (minor_status == NULL)
        return (GSS_S_CALL_INACCESSIBLE_WRITE);
    *minor_status = 0;

    if (context_handle == GSS_C_NO_CONTEXT)
        return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);

    if (max_input_size == NULL)
        return (GSS_S_CALL_INACCESSIBLE_WRITE);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (!mech)
        return (GSS_S_BAD_MECH);

    if (mech->gss_wrap_size_limit)
        major_status = mech->gss_wrap_size_limit(minor_status,
                                                 ctx->internal_ctx_id,
                                                 conf_req_flag, qop_req,
                                                 req_output_size, max_input_size);
    else if (mech->gss_wrap_iov_length)
        major_status = gssint_wrap_size_limit_iov_shim(mech, minor_status,
                                                       ctx->internal_ctx_id,
                                                       conf_req_flag, qop_req,
                                                       req_output_size, max_input_size);
    else
        major_status = GSS_S_UNAVAILABLE;
    if (major_status != GSS_S_COMPLETE)
        map_error(minor_status, mech);
    return major_status;
}
",C,"    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
        return (GSS_S_NO_CONTEXT);
",,,"@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+        return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+        return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (!mech)",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_wrap_size_limit(OM_uint32  *minor_status,
                    gss_ctx_id_t context_handle,
                    int conf_req_flag,
                    gss_qop_t qop_req, OM_uint32 req_output_size, OM_uint32 *max_input_size)
{
    gss_union_ctx_id_t  ctx;
    gss_mechanism       mech;
    OM_uint32           major_status;

    if (minor_status == NULL)
        return (GSS_S_CALL_INACCESSIBLE_WRITE);
    *minor_status = 0;

    if (context_handle == GSS_C_NO_CONTEXT)
        return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);

    if (max_input_size == NULL)
        return (GSS_S_CALL_INACCESSIBLE_WRITE);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
//fix_flaw_line_below:
//    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//        return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (!mech)
        return (GSS_S_BAD_MECH);

    if (mech->gss_wrap_size_limit)
        major_status = mech->gss_wrap_size_limit(minor_status,
                                                 ctx->internal_ctx_id,
                                                 conf_req_flag, qop_req,
                                                 req_output_size, max_input_size);
    else if (mech->gss_wrap_iov_length)
        major_status = gssint_wrap_size_limit_iov_shim(mech, minor_status,
                                                       ctx->internal_ctx_id,
                                                       conf_req_flag, qop_req,
                                                       req_output_size, max_input_size);
    else
        major_status = GSS_S_UNAVAILABLE;
    if (major_status != GSS_S_COMPLETE)
        map_error(minor_status, mech);
    return major_status;
}
"
3458,181194,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,2,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",0,src/lib/gssapi/mechglue/g_sign.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_get_mic (minor_status,
	     context_handle,
	     qop_req,
	     message_buffer,
	     msg_token)

OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
gss_qop_t		qop_req;
gss_buffer_t		message_buffer;
gss_buffer_t		msg_token;

{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    status = val_get_mic_args(minor_status, context_handle,
			      qop_req, message_buffer, msg_token);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
	if (mech->gss_get_mic) {
	    status = mech->gss_get_mic(
				    minor_status,
				    ctx->internal_ctx_id,
				    qop_req,
				    message_buffer,
				    msg_token);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }

    return (GSS_S_BAD_MECH);
}
","gss_get_mic (minor_status,
	     context_handle,
	     qop_req,
	     message_buffer,
	     msg_token)

OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
gss_qop_t		qop_req;
gss_buffer_t		message_buffer;
gss_buffer_t		msg_token;

{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    status = val_get_mic_args(minor_status, context_handle,
			      qop_req, message_buffer, msg_token);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
	if (mech->gss_get_mic) {
	    status = mech->gss_get_mic(
				    minor_status,
				    ctx->internal_ctx_id,
				    qop_req,
				    message_buffer,
				    msg_token);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }

    return (GSS_S_BAD_MECH);
}
",C,"    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
",,,"@@ -94,6 +94,8 @@ gss_buffer_t		msg_token;
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_get_mic (minor_status,
	     context_handle,
	     qop_req,
	     message_buffer,
	     msg_token)

OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
gss_qop_t		qop_req;
gss_buffer_t		message_buffer;
gss_buffer_t		msg_token;

{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    status = val_get_mic_args(minor_status, context_handle,
			      qop_req, message_buffer, msg_token);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
//fix_flaw_line_below:
//    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
	if (mech->gss_get_mic) {
	    status = mech->gss_get_mic(
				    minor_status,
				    ctx->internal_ctx_id,
				    qop_req,
				    message_buffer,
				    msg_token);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }

    return (GSS_S_BAD_MECH);
}
"
3459,181195,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,2,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",0,src/lib/gssapi/mechglue/g_unseal.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_unwrap (minor_status,
            context_handle,
            input_message_buffer,
            output_message_buffer,
            conf_state,
            qop_state)

OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
gss_buffer_t		input_message_buffer;
gss_buffer_t		output_message_buffer;
int *			conf_state;
gss_qop_t *		qop_state;

{
/* EXPORT DELETE START */
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    if (minor_status != NULL)
	*minor_status = 0;

    if (output_message_buffer != GSS_C_NO_BUFFER) {
	output_message_buffer->length = 0;
	output_message_buffer->value = NULL;
    }

    if (minor_status == NULL)
	return (GSS_S_CALL_INACCESSIBLE_WRITE);

    if (context_handle == GSS_C_NO_CONTEXT)
	return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);

    if (input_message_buffer == GSS_C_NO_BUFFER ||
	GSS_EMPTY_BUFFER(input_message_buffer))

	return (GSS_S_CALL_INACCESSIBLE_READ);

    if (output_message_buffer == GSS_C_NO_BUFFER)
	return (GSS_S_CALL_INACCESSIBLE_WRITE);

    /*
     * select the approprate underlying mechanism routine and
      * call it.
      */
     ctx = (gss_union_ctx_id_t) context_handle;
    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
	if (mech->gss_unwrap) {
	    status = mech->gss_unwrap(minor_status,
				      ctx->internal_ctx_id,
				      input_message_buffer,
				      output_message_buffer,
				      conf_state,
				      qop_state);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else if (mech->gss_unwrap_aead || mech->gss_unwrap_iov) {
	    status = gssint_unwrap_aead(mech,
					minor_status,
					ctx,
					input_message_buffer,
					GSS_C_NO_BUFFER,
					output_message_buffer,
					conf_state,
					(gss_qop_t *)qop_state);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }

/* EXPORT DELETE END */

    return (GSS_S_BAD_MECH);
}
","gss_unwrap (minor_status,
            context_handle,
            input_message_buffer,
            output_message_buffer,
            conf_state,
            qop_state)

OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
gss_buffer_t		input_message_buffer;
gss_buffer_t		output_message_buffer;
int *			conf_state;
gss_qop_t *		qop_state;

{
/* EXPORT DELETE START */
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    if (minor_status != NULL)
	*minor_status = 0;

    if (output_message_buffer != GSS_C_NO_BUFFER) {
	output_message_buffer->length = 0;
	output_message_buffer->value = NULL;
    }

    if (minor_status == NULL)
	return (GSS_S_CALL_INACCESSIBLE_WRITE);

    if (context_handle == GSS_C_NO_CONTEXT)
	return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);

    if (input_message_buffer == GSS_C_NO_BUFFER ||
	GSS_EMPTY_BUFFER(input_message_buffer))

	return (GSS_S_CALL_INACCESSIBLE_READ);

    if (output_message_buffer == GSS_C_NO_BUFFER)
	return (GSS_S_CALL_INACCESSIBLE_WRITE);

    /*
     * select the approprate underlying mechanism routine and
      * call it.
      */
     ctx = (gss_union_ctx_id_t) context_handle;
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
	if (mech->gss_unwrap) {
	    status = mech->gss_unwrap(minor_status,
				      ctx->internal_ctx_id,
				      input_message_buffer,
				      output_message_buffer,
				      conf_state,
				      qop_state);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else if (mech->gss_unwrap_aead || mech->gss_unwrap_iov) {
	    status = gssint_unwrap_aead(mech,
					minor_status,
					ctx,
					input_message_buffer,
					GSS_C_NO_BUFFER,
					output_message_buffer,
					conf_state,
					(gss_qop_t *)qop_state);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }

/* EXPORT DELETE END */

    return (GSS_S_BAD_MECH);
}
",C,"    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
",,,"@@ -76,6 +76,8 @@ gss_qop_t *		qop_state;
      * call it.
      */
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_unwrap (minor_status,
            context_handle,
            input_message_buffer,
            output_message_buffer,
            conf_state,
            qop_state)

OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
gss_buffer_t		input_message_buffer;
gss_buffer_t		output_message_buffer;
int *			conf_state;
gss_qop_t *		qop_state;

{
/* EXPORT DELETE START */
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    if (minor_status != NULL)
	*minor_status = 0;

    if (output_message_buffer != GSS_C_NO_BUFFER) {
	output_message_buffer->length = 0;
	output_message_buffer->value = NULL;
    }

    if (minor_status == NULL)
	return (GSS_S_CALL_INACCESSIBLE_WRITE);

    if (context_handle == GSS_C_NO_CONTEXT)
	return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);

    if (input_message_buffer == GSS_C_NO_BUFFER ||
	GSS_EMPTY_BUFFER(input_message_buffer))

	return (GSS_S_CALL_INACCESSIBLE_READ);

    if (output_message_buffer == GSS_C_NO_BUFFER)
	return (GSS_S_CALL_INACCESSIBLE_WRITE);

    /*
     * select the approprate underlying mechanism routine and
      * call it.
      */
     ctx = (gss_union_ctx_id_t) context_handle;
//fix_flaw_line_below:
//    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
	if (mech->gss_unwrap) {
	    status = mech->gss_unwrap(minor_status,
				      ctx->internal_ctx_id,
				      input_message_buffer,
				      output_message_buffer,
				      conf_state,
				      qop_state);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else if (mech->gss_unwrap_aead || mech->gss_unwrap_iov) {
	    status = gssint_unwrap_aead(mech,
					minor_status,
					ctx,
					input_message_buffer,
					GSS_C_NO_BUFFER,
					output_message_buffer,
					conf_state,
					(gss_qop_t *)qop_state);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }

/* EXPORT DELETE END */

    return (GSS_S_BAD_MECH);
}
"
3460,181196,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,2,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",0,src/lib/gssapi/mechglue/g_unwrap_aead.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_unwrap_aead (minor_status,
                 context_handle,
		 input_message_buffer,
		 input_assoc_buffer,
		 output_payload_buffer,
                 conf_state,
                 qop_state)
OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
gss_buffer_t		input_message_buffer;
gss_buffer_t		input_assoc_buffer;
gss_buffer_t		output_payload_buffer;
int 			*conf_state;
gss_qop_t		*qop_state;
{

    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    status = val_unwrap_aead_args(minor_status, context_handle,
				  input_message_buffer, input_assoc_buffer,
				  output_payload_buffer,
				  conf_state, qop_state);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
      * call it.
      */
     ctx = (gss_union_ctx_id_t) context_handle;
    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (!mech)
	return (GSS_S_BAD_MECH);

    return gssint_unwrap_aead(mech, minor_status, ctx,
			      input_message_buffer, input_assoc_buffer,
			      output_payload_buffer, conf_state, qop_state);
}
","gss_unwrap_aead (minor_status,
                 context_handle,
		 input_message_buffer,
		 input_assoc_buffer,
		 output_payload_buffer,
                 conf_state,
                 qop_state)
OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
gss_buffer_t		input_message_buffer;
gss_buffer_t		input_assoc_buffer;
gss_buffer_t		output_payload_buffer;
int 			*conf_state;
gss_qop_t		*qop_state;
{

    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    status = val_unwrap_aead_args(minor_status, context_handle,
				  input_message_buffer, input_assoc_buffer,
				  output_payload_buffer,
				  conf_state, qop_state);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
      * call it.
      */
     ctx = (gss_union_ctx_id_t) context_handle;
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (!mech)
	return (GSS_S_BAD_MECH);

    return gssint_unwrap_aead(mech, minor_status, ctx,
			      input_message_buffer, input_assoc_buffer,
			      output_payload_buffer, conf_state, qop_state);
}
",C,"    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
",,,"@@ -186,6 +186,8 @@ gss_qop_t		*qop_state;
      * call it.
      */
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (!mech)",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_unwrap_aead (minor_status,
                 context_handle,
		 input_message_buffer,
		 input_assoc_buffer,
		 output_payload_buffer,
                 conf_state,
                 qop_state)
OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
gss_buffer_t		input_message_buffer;
gss_buffer_t		input_assoc_buffer;
gss_buffer_t		output_payload_buffer;
int 			*conf_state;
gss_qop_t		*qop_state;
{

    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    status = val_unwrap_aead_args(minor_status, context_handle,
				  input_message_buffer, input_assoc_buffer,
				  output_payload_buffer,
				  conf_state, qop_state);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
      * call it.
      */
     ctx = (gss_union_ctx_id_t) context_handle;
//fix_flaw_line_below:
//    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (!mech)
	return (GSS_S_BAD_MECH);

    return gssint_unwrap_aead(mech, minor_status, ctx,
			      input_message_buffer, input_assoc_buffer,
			      output_payload_buffer, conf_state, qop_state);
}
"
3461,181197,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,2,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",0,src/lib/gssapi/mechglue/g_unwrap_iov.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_unwrap_iov (minor_status,
                context_handle,
                conf_state,
                qop_state,
                iov,
                iov_count)
OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
int *			conf_state;
gss_qop_t		*qop_state;
gss_iov_buffer_desc  *	iov;
int			iov_count;
{
 /* EXPORT DELETE START */

    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    status = val_unwrap_iov_args(minor_status, context_handle,
				 conf_state, qop_state, iov, iov_count);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
	if (mech->gss_unwrap_iov) {
	    status = mech->gss_unwrap_iov(
				 	  minor_status,
					  ctx->internal_ctx_id,
					  conf_state,
					  qop_state,
					  iov,
					  iov_count);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }
 /* EXPORT DELETE END */

    return (GSS_S_BAD_MECH);
}
","gss_unwrap_iov (minor_status,
                context_handle,
                conf_state,
                qop_state,
                iov,
                iov_count)
OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
int *			conf_state;
gss_qop_t		*qop_state;
gss_iov_buffer_desc  *	iov;
int			iov_count;
{
 /* EXPORT DELETE START */

    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    status = val_unwrap_iov_args(minor_status, context_handle,
				 conf_state, qop_state, iov, iov_count);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
	if (mech->gss_unwrap_iov) {
	    status = mech->gss_unwrap_iov(
				 	  minor_status,
					  ctx->internal_ctx_id,
					  conf_state,
					  qop_state,
					  iov,
					  iov_count);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }
 /* EXPORT DELETE END */

    return (GSS_S_BAD_MECH);
}
",C,"    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
",,,"@@ -89,6 +89,8 @@ int			iov_count;
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 
     /* Select the approprate underlying mechanism routine and call it. */
     ctx = (gss_union_ctx_id_t)context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism(ctx->mech_type);
     if (mech == NULL)
 	return GSS_S_BAD_MECH;",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_unwrap_iov (minor_status,
                context_handle,
                conf_state,
                qop_state,
                iov,
                iov_count)
OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
int *			conf_state;
gss_qop_t		*qop_state;
gss_iov_buffer_desc  *	iov;
int			iov_count;
{
 /* EXPORT DELETE START */

    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    status = val_unwrap_iov_args(minor_status, context_handle,
				 conf_state, qop_state, iov, iov_count);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
//fix_flaw_line_below:
//    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
	if (mech->gss_unwrap_iov) {
	    status = mech->gss_unwrap_iov(
				 	  minor_status,
					  ctx->internal_ctx_id,
					  conf_state,
					  qop_state,
					  iov,
					  iov_count);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }
 /* EXPORT DELETE END */

    return (GSS_S_BAD_MECH);
}
"
3462,181198,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,2,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",0,src/lib/gssapi/mechglue/g_unwrap_iov.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
		   gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
		   int iov_count)
{
    OM_uint32 status;
    gss_union_ctx_id_t ctx;
    gss_mechanism mech;

    status = val_unwrap_iov_args(minor_status, context_handle, NULL,
				 qop_state, iov, iov_count);
    if (status != GSS_S_COMPLETE)
	return status;
 
     /* Select the approprate underlying mechanism routine and call it. */
     ctx = (gss_union_ctx_id_t)context_handle;
    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism(ctx->mech_type);
     if (mech == NULL)
 	return GSS_S_BAD_MECH;
    if (mech->gss_verify_mic_iov == NULL)
	return GSS_S_UNAVAILABLE;
    status = mech->gss_verify_mic_iov(minor_status, ctx->internal_ctx_id,
				      qop_state, iov, iov_count);
    if (status != GSS_S_COMPLETE)
	map_error(minor_status, mech);
    return status;
}
","gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
		   gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
		   int iov_count)
{
    OM_uint32 status;
    gss_union_ctx_id_t ctx;
    gss_mechanism mech;

    status = val_unwrap_iov_args(minor_status, context_handle, NULL,
				 qop_state, iov, iov_count);
    if (status != GSS_S_COMPLETE)
	return status;
 
     /* Select the approprate underlying mechanism routine and call it. */
     ctx = (gss_union_ctx_id_t)context_handle;
     mech = gssint_get_mechanism(ctx->mech_type);
     if (mech == NULL)
 	return GSS_S_BAD_MECH;
    if (mech->gss_verify_mic_iov == NULL)
	return GSS_S_UNAVAILABLE;
    status = mech->gss_verify_mic_iov(minor_status, ctx->internal_ctx_id,
				      qop_state, iov, iov_count);
    if (status != GSS_S_COMPLETE)
	map_error(minor_status, mech);
    return status;
}
",C,"    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return GSS_S_NO_CONTEXT;
",,,"@@ -89,6 +89,8 @@ int			iov_count;
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 
     /* Select the approprate underlying mechanism routine and call it. */
     ctx = (gss_union_ctx_id_t)context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism(ctx->mech_type);
     if (mech == NULL)
 	return GSS_S_BAD_MECH;",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
		   gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
		   int iov_count)
{
    OM_uint32 status;
    gss_union_ctx_id_t ctx;
    gss_mechanism mech;

    status = val_unwrap_iov_args(minor_status, context_handle, NULL,
				 qop_state, iov, iov_count);
    if (status != GSS_S_COMPLETE)
	return status;
 
     /* Select the approprate underlying mechanism routine and call it. */
     ctx = (gss_union_ctx_id_t)context_handle;
//fix_flaw_line_below:
//    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism(ctx->mech_type);
     if (mech == NULL)
 	return GSS_S_BAD_MECH;
    if (mech->gss_verify_mic_iov == NULL)
	return GSS_S_UNAVAILABLE;
    status = mech->gss_verify_mic_iov(minor_status, ctx->internal_ctx_id,
				      qop_state, iov, iov_count);
    if (status != GSS_S_COMPLETE)
	map_error(minor_status, mech);
    return status;
}
"
3463,181199,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,2,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",0,src/lib/gssapi/mechglue/g_verify.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_verify_mic (minor_status,
		context_handle,
		message_buffer,
		token_buffer,
		qop_state)

OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
gss_buffer_t		message_buffer;
gss_buffer_t		token_buffer;
gss_qop_t *		qop_state;

{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;


    if (minor_status == NULL)
	return (GSS_S_CALL_INACCESSIBLE_WRITE);
    *minor_status = 0;

    if (context_handle == GSS_C_NO_CONTEXT)
	return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);

    if ((message_buffer == GSS_C_NO_BUFFER) ||
	GSS_EMPTY_BUFFER(token_buffer))

	return (GSS_S_CALL_INACCESSIBLE_READ);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
	if (mech->gss_verify_mic) {
	    status = mech->gss_verify_mic(
					  minor_status,
					  ctx->internal_ctx_id,
					  message_buffer,
					  token_buffer,
					  qop_state);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }

    return (GSS_S_BAD_MECH);
}
","gss_verify_mic (minor_status,
		context_handle,
		message_buffer,
		token_buffer,
		qop_state)

OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
gss_buffer_t		message_buffer;
gss_buffer_t		token_buffer;
gss_qop_t *		qop_state;

{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;


    if (minor_status == NULL)
	return (GSS_S_CALL_INACCESSIBLE_WRITE);
    *minor_status = 0;

    if (context_handle == GSS_C_NO_CONTEXT)
	return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);

    if ((message_buffer == GSS_C_NO_BUFFER) ||
	GSS_EMPTY_BUFFER(token_buffer))

	return (GSS_S_CALL_INACCESSIBLE_READ);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
	if (mech->gss_verify_mic) {
	    status = mech->gss_verify_mic(
					  minor_status,
					  ctx->internal_ctx_id,
					  message_buffer,
					  token_buffer,
					  qop_state);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }

    return (GSS_S_BAD_MECH);
}
",C,"    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
",,,"@@ -65,6 +65,8 @@ gss_qop_t *		qop_state;
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_verify_mic (minor_status,
		context_handle,
		message_buffer,
		token_buffer,
		qop_state)

OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
gss_buffer_t		message_buffer;
gss_buffer_t		token_buffer;
gss_qop_t *		qop_state;

{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;


    if (minor_status == NULL)
	return (GSS_S_CALL_INACCESSIBLE_WRITE);
    *minor_status = 0;

    if (context_handle == GSS_C_NO_CONTEXT)
	return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);

    if ((message_buffer == GSS_C_NO_BUFFER) ||
	GSS_EMPTY_BUFFER(token_buffer))

	return (GSS_S_CALL_INACCESSIBLE_READ);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
//fix_flaw_line_below:
//    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
	if (mech->gss_verify_mic) {
	    status = mech->gss_verify_mic(
					  minor_status,
					  ctx->internal_ctx_id,
					  message_buffer,
					  token_buffer,
					  qop_state);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }

    return (GSS_S_BAD_MECH);
}
"
3464,181200,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,2,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",0,src/lib/gssapi/mechglue/g_wrap_aead.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_wrap_aead (minor_status,
               context_handle,
               conf_req_flag,
               qop_req,
	       input_assoc_buffer,
	       input_payload_buffer,
               conf_state,
               output_message_buffer)
OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
int			conf_req_flag;
gss_qop_t		qop_req;
gss_buffer_t		input_assoc_buffer;
gss_buffer_t		input_payload_buffer;
int *			conf_state;
gss_buffer_t		output_message_buffer;
{
    OM_uint32		status;
    gss_mechanism	mech;
    gss_union_ctx_id_t	ctx;

    status = val_wrap_aead_args(minor_status, context_handle,
				conf_req_flag, qop_req,
				input_assoc_buffer, input_payload_buffer,
				conf_state, output_message_buffer);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
      * call it.
      */
     ctx = (gss_union_ctx_id_t)context_handle;
    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
     if (!mech)
 	return (GSS_S_BAD_MECH);

    return gssint_wrap_aead(mech, minor_status, ctx,
			    conf_req_flag, qop_req,
			    input_assoc_buffer, input_payload_buffer,
			    conf_state, output_message_buffer);
}
","gss_wrap_aead (minor_status,
               context_handle,
               conf_req_flag,
               qop_req,
	       input_assoc_buffer,
	       input_payload_buffer,
               conf_state,
               output_message_buffer)
OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
int			conf_req_flag;
gss_qop_t		qop_req;
gss_buffer_t		input_assoc_buffer;
gss_buffer_t		input_payload_buffer;
int *			conf_state;
gss_buffer_t		output_message_buffer;
{
    OM_uint32		status;
    gss_mechanism	mech;
    gss_union_ctx_id_t	ctx;

    status = val_wrap_aead_args(minor_status, context_handle,
				conf_req_flag, qop_req,
				input_assoc_buffer, input_payload_buffer,
				conf_state, output_message_buffer);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
      * call it.
      */
     ctx = (gss_union_ctx_id_t)context_handle;
     mech = gssint_get_mechanism (ctx->mech_type);
     if (!mech)
 	return (GSS_S_BAD_MECH);

    return gssint_wrap_aead(mech, minor_status, ctx,
			    conf_req_flag, qop_req,
			    input_assoc_buffer, input_payload_buffer,
			    conf_state, output_message_buffer);
}
",C,"    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
",,,"@@ -256,6 +256,8 @@ gss_buffer_t		output_message_buffer;
      * call it.
      */
     ctx = (gss_union_ctx_id_t)context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
     if (!mech)
 	return (GSS_S_BAD_MECH);",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_wrap_aead (minor_status,
               context_handle,
               conf_req_flag,
               qop_req,
	       input_assoc_buffer,
	       input_payload_buffer,
               conf_state,
               output_message_buffer)
OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
int			conf_req_flag;
gss_qop_t		qop_req;
gss_buffer_t		input_assoc_buffer;
gss_buffer_t		input_payload_buffer;
int *			conf_state;
gss_buffer_t		output_message_buffer;
{
    OM_uint32		status;
    gss_mechanism	mech;
    gss_union_ctx_id_t	ctx;

    status = val_wrap_aead_args(minor_status, context_handle,
				conf_req_flag, qop_req,
				input_assoc_buffer, input_payload_buffer,
				conf_state, output_message_buffer);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
      * call it.
      */
     ctx = (gss_union_ctx_id_t)context_handle;
//fix_flaw_line_below:
//    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
     if (!mech)
 	return (GSS_S_BAD_MECH);

    return gssint_wrap_aead(mech, minor_status, ctx,
			    conf_req_flag, qop_req,
			    input_assoc_buffer, input_payload_buffer,
			    conf_state, output_message_buffer);
}
"
3465,181201,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,2,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",0,src/lib/gssapi/mechglue/g_wrap_iov.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
		gss_qop_t qop_req, gss_iov_buffer_desc *iov, int iov_count)
{
    OM_uint32 status;
    gss_union_ctx_id_t ctx;
    gss_mechanism mech;

    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,
			       iov, iov_count);
    if (status != GSS_S_COMPLETE)
	return status;
 
     /* Select the approprate underlying mechanism routine and call it. */
     ctx = (gss_union_ctx_id_t)context_handle;
    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism(ctx->mech_type);
     if (mech == NULL)
 	return GSS_S_BAD_MECH;
    if (mech->gss_get_mic_iov == NULL)
	return GSS_S_UNAVAILABLE;
    status = mech->gss_get_mic_iov(minor_status, ctx->internal_ctx_id, qop_req,
				   iov, iov_count);
    if (status != GSS_S_COMPLETE)
	map_error(minor_status, mech);
    return status;
}
","gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
		gss_qop_t qop_req, gss_iov_buffer_desc *iov, int iov_count)
{
    OM_uint32 status;
    gss_union_ctx_id_t ctx;
    gss_mechanism mech;

    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,
			       iov, iov_count);
    if (status != GSS_S_COMPLETE)
	return status;
 
     /* Select the approprate underlying mechanism routine and call it. */
     ctx = (gss_union_ctx_id_t)context_handle;
     mech = gssint_get_mechanism(ctx->mech_type);
     if (mech == NULL)
 	return GSS_S_BAD_MECH;
    if (mech->gss_get_mic_iov == NULL)
	return GSS_S_UNAVAILABLE;
    status = mech->gss_get_mic_iov(minor_status, ctx->internal_ctx_id, qop_req,
				   iov, iov_count);
    if (status != GSS_S_COMPLETE)
	map_error(minor_status, mech);
    return status;
}
",C,"    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return GSS_S_NO_CONTEXT;
",,,"@@ -93,6 +93,8 @@ int			iov_count;
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
@@ -151,6 +153,8 @@ int			iov_count;
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 
     /* Select the approprate underlying mechanism routine and call it. */
     ctx = (gss_union_ctx_id_t)context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism(ctx->mech_type);
     if (mech == NULL)
 	return GSS_S_BAD_MECH;
@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 
     /* Select the approprate underlying mechanism routine and call it. */
     ctx = (gss_union_ctx_id_t)context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism(ctx->mech_type);
     if (mech == NULL)
 	return GSS_S_BAD_MECH;",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
		gss_qop_t qop_req, gss_iov_buffer_desc *iov, int iov_count)
{
    OM_uint32 status;
    gss_union_ctx_id_t ctx;
    gss_mechanism mech;

    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,
			       iov, iov_count);
    if (status != GSS_S_COMPLETE)
	return status;
 
     /* Select the approprate underlying mechanism routine and call it. */
     ctx = (gss_union_ctx_id_t)context_handle;
//fix_flaw_line_below:
//    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism(ctx->mech_type);
     if (mech == NULL)
 	return GSS_S_BAD_MECH;
    if (mech->gss_get_mic_iov == NULL)
	return GSS_S_UNAVAILABLE;
    status = mech->gss_get_mic_iov(minor_status, ctx->internal_ctx_id, qop_req,
				   iov, iov_count);
    if (status != GSS_S_COMPLETE)
	map_error(minor_status, mech);
    return status;
}
"
3466,181202,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,2,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",0,src/lib/gssapi/mechglue/g_wrap_iov.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
		       int iov_count)
{
    OM_uint32 status;
    gss_union_ctx_id_t ctx;
    gss_mechanism mech;

    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,
			       iov, iov_count);
    if (status != GSS_S_COMPLETE)
	return status;
 
     /* Select the approprate underlying mechanism routine and call it. */
     ctx = (gss_union_ctx_id_t)context_handle;
    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism(ctx->mech_type);
     if (mech == NULL)
 	return GSS_S_BAD_MECH;
    if (mech->gss_get_mic_iov_length == NULL)
	return GSS_S_UNAVAILABLE;
    status = mech->gss_get_mic_iov_length(minor_status, ctx->internal_ctx_id,
					  qop_req, iov, iov_count);
    if (status != GSS_S_COMPLETE)
	map_error(minor_status, mech);
    return status;
}
","gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
		       int iov_count)
{
    OM_uint32 status;
    gss_union_ctx_id_t ctx;
    gss_mechanism mech;

    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,
			       iov, iov_count);
    if (status != GSS_S_COMPLETE)
	return status;
 
     /* Select the approprate underlying mechanism routine and call it. */
     ctx = (gss_union_ctx_id_t)context_handle;
     mech = gssint_get_mechanism(ctx->mech_type);
     if (mech == NULL)
 	return GSS_S_BAD_MECH;
    if (mech->gss_get_mic_iov_length == NULL)
	return GSS_S_UNAVAILABLE;
    status = mech->gss_get_mic_iov_length(minor_status, ctx->internal_ctx_id,
					  qop_req, iov, iov_count);
    if (status != GSS_S_COMPLETE)
	map_error(minor_status, mech);
    return status;
}
",C,"    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return GSS_S_NO_CONTEXT;
",,,"@@ -93,6 +93,8 @@ int			iov_count;
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
@@ -151,6 +153,8 @@ int			iov_count;
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 
     /* Select the approprate underlying mechanism routine and call it. */
     ctx = (gss_union_ctx_id_t)context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism(ctx->mech_type);
     if (mech == NULL)
 	return GSS_S_BAD_MECH;
@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 
     /* Select the approprate underlying mechanism routine and call it. */
     ctx = (gss_union_ctx_id_t)context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism(ctx->mech_type);
     if (mech == NULL)
 	return GSS_S_BAD_MECH;",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
		       int iov_count)
{
    OM_uint32 status;
    gss_union_ctx_id_t ctx;
    gss_mechanism mech;

    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,
			       iov, iov_count);
    if (status != GSS_S_COMPLETE)
	return status;
 
     /* Select the approprate underlying mechanism routine and call it. */
     ctx = (gss_union_ctx_id_t)context_handle;
//fix_flaw_line_below:
//    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism(ctx->mech_type);
     if (mech == NULL)
 	return GSS_S_BAD_MECH;
    if (mech->gss_get_mic_iov_length == NULL)
	return GSS_S_UNAVAILABLE;
    status = mech->gss_get_mic_iov_length(minor_status, ctx->internal_ctx_id,
					  qop_req, iov, iov_count);
    if (status != GSS_S_COMPLETE)
	map_error(minor_status, mech);
    return status;
}
"
3467,181203,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,2,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",0,src/lib/gssapi/mechglue/g_wrap_iov.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_wrap_iov (minor_status,
              context_handle,
              conf_req_flag,
              qop_req,
              conf_state,
              iov,
              iov_count)
OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
int			conf_req_flag;
gss_qop_t		qop_req;
int *			conf_state;
gss_iov_buffer_desc  *	iov;
int			iov_count;
{
 /* EXPORT DELETE START */

    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    status = val_wrap_iov_args(minor_status, context_handle,
			       conf_req_flag, qop_req,
			       conf_state, iov, iov_count);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
	if (mech->gss_wrap_iov) {
	    status = mech->gss_wrap_iov(
					minor_status,
					ctx->internal_ctx_id,
					conf_req_flag,
					qop_req,
					conf_state,
					iov,
					iov_count);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }
 /* EXPORT DELETE END */

    return (GSS_S_BAD_MECH);
}
","gss_wrap_iov (minor_status,
              context_handle,
              conf_req_flag,
              qop_req,
              conf_state,
              iov,
              iov_count)
OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
int			conf_req_flag;
gss_qop_t		qop_req;
int *			conf_state;
gss_iov_buffer_desc  *	iov;
int			iov_count;
{
 /* EXPORT DELETE START */

    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    status = val_wrap_iov_args(minor_status, context_handle,
			       conf_req_flag, qop_req,
			       conf_state, iov, iov_count);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
	if (mech->gss_wrap_iov) {
	    status = mech->gss_wrap_iov(
					minor_status,
					ctx->internal_ctx_id,
					conf_req_flag,
					qop_req,
					conf_state,
					iov,
					iov_count);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }
 /* EXPORT DELETE END */

    return (GSS_S_BAD_MECH);
}
",C,"    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
",,,"@@ -93,6 +93,8 @@ int			iov_count;
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
@@ -151,6 +153,8 @@ int			iov_count;
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 
     /* Select the approprate underlying mechanism routine and call it. */
     ctx = (gss_union_ctx_id_t)context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism(ctx->mech_type);
     if (mech == NULL)
 	return GSS_S_BAD_MECH;
@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 
     /* Select the approprate underlying mechanism routine and call it. */
     ctx = (gss_union_ctx_id_t)context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism(ctx->mech_type);
     if (mech == NULL)
 	return GSS_S_BAD_MECH;",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_wrap_iov (minor_status,
              context_handle,
              conf_req_flag,
              qop_req,
              conf_state,
              iov,
              iov_count)
OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
int			conf_req_flag;
gss_qop_t		qop_req;
int *			conf_state;
gss_iov_buffer_desc  *	iov;
int			iov_count;
{
 /* EXPORT DELETE START */

    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    status = val_wrap_iov_args(minor_status, context_handle,
			       conf_req_flag, qop_req,
			       conf_state, iov, iov_count);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
//fix_flaw_line_below:
//    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
	if (mech->gss_wrap_iov) {
	    status = mech->gss_wrap_iov(
					minor_status,
					ctx->internal_ctx_id,
					conf_req_flag,
					qop_req,
					conf_state,
					iov,
					iov_count);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }
 /* EXPORT DELETE END */

    return (GSS_S_BAD_MECH);
}
"
3468,181204,,Remote,Not required,Partial,CVE-2017-11462,https://www.cvedetails.com/cve/CVE-2017-11462/,CWE-415,Low,Partial,Partial,,2017-09-13,7.5,Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.,2017-10-20,,2,https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,"Preserve GSS context on init/accept failure

After gss_init_sec_context() or gss_accept_sec_context() has created a
context, don't delete the mechglue context on failures from subsequent
calls, even if the mechanism deletes the mech-specific context (which
is allowed by RFC 2744 but not preferred).  Check for union contexts
with no mechanism context in each GSS function which accepts a
gss_ctx_id_t.

CVE-2017-11462:

RFC 2744 permits a GSS-API implementation to delete an existing
security context on a second or subsequent call to
gss_init_sec_context() or gss_accept_sec_context() if the call results
in an error.  This API behavior has been found to be dangerous,
leading to the possibility of memory errors in some callers.  For
safety, GSS-API implementations should instead preserve existing
security contexts on error until the caller deletes them.

All versions of MIT krb5 prior to this change may delete acceptor
contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through
1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on
error.

ticket: 8598 (new)
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",0,src/lib/gssapi/mechglue/g_wrap_iov.c,"{""sha"": ""f28e2b14a9036d3d79470a55cfc5bde7b52be247"", ""filename"": ""src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_accept_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_accept_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -216,6 +216,8 @@ gss_cred_id_t *\t\td_cred;\n     } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n \tselected_mech = union_ctx_id->mech_type;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n     }\n \n     /* Now create a new context if we didn't get one. */\n@@ -234,9 +236,6 @@ gss_cred_id_t *\t\td_cred;\n \t    free(union_ctx_id);\n \t    return (status);\n \t}\n-\n-\t/* set the new context handle to caller's data */\n-\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n     }\n \n     /*\n@@ -277,8 +276,10 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n \n \t    /* If there's more work to do, keep going... */\n-\t    if (status == GSS_S_CONTINUE_NEEDED)\n+\t    if (status == GSS_S_CONTINUE_NEEDED) {\n+\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n \t\treturn GSS_S_CONTINUE_NEEDED;\n+\t    }\n \n \t    /* if the call failed, return with failure */\n \t    if (status != GSS_S_COMPLETE) {\n@@ -364,14 +365,22 @@ gss_cred_id_t *\t\td_cred;\n \t\t*mech_type = gssint_get_public_oid(actual_mech);\n \t    if (ret_flags != NULL)\n \t\t*ret_flags = temp_ret_flags;\n-\t    return\t(status);\n+\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n+\t    return GSS_S_COMPLETE;\n     } else {\n \n \tstatus = GSS_S_BAD_MECH;\n     }\n \n error_out:\n-    if (union_ctx_id) {\n+\t/*\n+\t * RFC 2744 5.1 requires that we not create a context on a failed first\n+\t * call to accept, and recommends that on a failed subsequent call we\n+\t * make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n+\t */\n+    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n \tif (union_ctx_id->mech_type) {\n \t    if (union_ctx_id->mech_type->elements)\n \t\tfree(union_ctx_id->mech_type->elements);\n@@ -384,7 +393,6 @@ gss_cred_id_t *\t\td_cred;\n \t\t\t\t\t GSS_C_NO_BUFFER);\n \t}\n \tfree(union_ctx_id);\n-\t*context_handle = GSS_C_NO_CONTEXT;\n     }\n \n     if (src_name)""}<_**next**_>{""sha"": ""4bcb47e84b90e41218c82ae2ea698388f1373958"", ""filename"": ""src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_complete_auth_token.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_complete_auth_token.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -52,6 +52,8 @@ gss_complete_auth_token (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""c947e7646c10e1853888236ef481b5ef3bc0e0cc"", ""filename"": ""src/lib/gssapi/mechglue/g_context_time.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_context_time.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_context_time.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -58,6 +58,8 @@ OM_uint32 *\t\ttime_rec;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""574ff02944b02c74b3ec55db89ed51ab56963d0c"", ""filename"": ""src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_delete_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_delete_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -87,12 +87,14 @@ gss_buffer_t\t\toutput_token;\n     if (GSSINT_CHK_LOOP(ctx))\n \treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n \n-    status = gssint_delete_internal_sec_context(minor_status,\n-\t\t\t\t\t\tctx->mech_type,\n-\t\t\t\t\t\t&ctx->internal_ctx_id,\n-\t\t\t\t\t\toutput_token);\n-    if (status)\n-\treturn status;\n+    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n+\tstatus = gssint_delete_internal_sec_context(minor_status,\n+\t\t\t\t\t\t    ctx->mech_type,\n+\t\t\t\t\t\t    &ctx->internal_ctx_id,\n+\t\t\t\t\t\t    output_token);\n+\tif (status)\n+\t    return status;\n+    }\n \n     /* now free up the space for the union context structure */\n     free(ctx->mech_type->elements);""}<_**next**_>{""sha"": ""1d7990b1ca2871af8482b3d7e33a0f34147a2542"", ""filename"": ""src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_exp_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_exp_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -95,6 +95,8 @@ gss_buffer_t\t\tinterprocess_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""e2df1ce261d758e47950542e2127daaaf9bb1930"", ""filename"": ""src/lib/gssapi/mechglue/g_init_sec_context.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_init_sec_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_init_sec_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -192,8 +192,13 @@ OM_uint32 *\t\ttime_rec;\n \n \t/* copy the supplied context handle */\n \tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n-    } else\n+    } else {\n \tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n+\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n+\t    status = GSS_S_NO_CONTEXT;\n+\t    goto end;\n+\t}\n+    }\n \n     /*\n      * get the appropriate cred handle from the union cred struct.\n@@ -224,15 +229,13 @@ OM_uint32 *\t\ttime_rec;\n \n     if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n \t/*\n-\t * The spec says the preferred method is to delete all context info on\n-\t * the first call to init, and on all subsequent calls make the caller\n-\t * responsible for calling gss_delete_sec_context.  However, if the\n-\t * mechanism decided to delete the internal context, we should also\n-\t * delete the union context.\n+\t * RFC 2744 5.19 requires that we not create a context on a failed\n+\t * first call to init, and recommends that on a failed subsequent call\n+\t * we make the caller responsible for calling gss_delete_sec_context.\n+\t * Even if the mech deleted its context, keep the union context around\n+\t * for the caller to delete.\n \t */\n \tmap_error(minor_status, mech);\n-\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n-\t    *context_handle = GSS_C_NO_CONTEXT;\n \tif (*context_handle == GSS_C_NO_CONTEXT) {\n \t    free(union_ctx_id->mech_type->elements);\n \t    free(union_ctx_id->mech_type);""}<_**next**_>{""sha"": ""6c0d98dd3348dac76978694676cd70430e6c0a0b"", ""filename"": ""src/lib/gssapi/mechglue/g_inq_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_inq_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_inq_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -104,6 +104,8 @@ gss_inquire_context(\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||""}<_**next**_>{""sha"": ""9e168adfe0d620bb6deb4454b5f699677b08f593"", ""filename"": ""src/lib/gssapi/mechglue/g_prf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_prf.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_prf.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -59,6 +59,8 @@ gss_pseudo_random (OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {""}<_**next**_>{""sha"": ""3968b5d9c675a72ec240be811ed8a2615055c4ef"", ""filename"": ""src/lib/gssapi/mechglue/g_process_context.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_process_context.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_process_context.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -61,6 +61,8 @@ gss_buffer_t\t\ttoken_buffer;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""3db1ee095b394b56d6d7b3c2475ef66f8ff8bb72"", ""filename"": ""src/lib/gssapi/mechglue/g_seal.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_seal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_seal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -92,6 +92,8 @@ gss_wrap( OM_uint32 *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -226,6 +228,8 @@ gss_wrap_size_limit(OM_uint32  *minor_status,\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""03fbd8c01f3617b1ddd98b39a876e711ef9a0819"", ""filename"": ""src/lib/gssapi/mechglue/g_sign.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_sign.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_sign.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -94,6 +94,8 @@ gss_buffer_t\t\tmsg_token;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""c208635b676a8e410c805d8ead9ac991e7a69b13"", ""filename"": ""src/lib/gssapi/mechglue/g_unseal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unseal.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unseal.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -76,6 +76,8 @@ gss_qop_t *\t\tqop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""0682bd8998203266386c054ae3d3c4338d91e99a"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -186,6 +186,8 @@ gss_qop_t\t\t*qop_state;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)""}<_**next**_>{""sha"": ""599be2c7b2fcd27324a1015f92de2eb9b70b4361"", ""filename"": ""src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_unwrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_unwrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -89,6 +89,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -128,6 +130,8 @@ gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}<_**next**_>{""sha"": ""8996fce8d59639acee59938b64288fc40f498120"", ""filename"": ""src/lib/gssapi/mechglue/g_verify.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_verify.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_verify.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -65,6 +65,8 @@ gss_qop_t *\t\tqop_state;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {""}<_**next**_>{""sha"": ""7fe3b7b35bda5add95efe79c0e42075e8898bf67"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_aead.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_aead.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_aead.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -256,6 +256,8 @@ gss_buffer_t\t\toutput_message_buffer;\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);""}<_**next**_>{""sha"": ""14447c4ee1ada5810e9f841d440db1dd539a6e36"", ""filename"": ""src/lib/gssapi/mechglue/g_wrap_iov.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/krb5/krb5/blob/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf/src/lib/gssapi/mechglue/g_wrap_iov.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/g_wrap_iov.c?ref=56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"", ""patch"": ""@@ -93,6 +93,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -151,6 +153,8 @@ int\t\t\tiov_count;\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;""}","gss_wrap_iov_length (minor_status,
                     context_handle,
                     conf_req_flag,
                     qop_req,
                     conf_state,
                     iov,
                     iov_count)
OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
int			conf_req_flag;
gss_qop_t		qop_req;
int *			conf_state;
gss_iov_buffer_desc  *	iov;
int			iov_count;
{
 /* EXPORT DELETE START */

    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    status = val_wrap_iov_args(minor_status, context_handle,
			       conf_req_flag, qop_req,
			       conf_state, iov, iov_count);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
	if (mech->gss_wrap_iov_length) {
	    status = mech->gss_wrap_iov_length(
					      minor_status,
					      ctx->internal_ctx_id,
					      conf_req_flag,
					      qop_req,
					      conf_state,
					      iov,
					      iov_count);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }
 /* EXPORT DELETE END */

    return (GSS_S_BAD_MECH);
}
","gss_wrap_iov_length (minor_status,
                     context_handle,
                     conf_req_flag,
                     qop_req,
                     conf_state,
                     iov,
                     iov_count)
OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
int			conf_req_flag;
gss_qop_t		qop_req;
int *			conf_state;
gss_iov_buffer_desc  *	iov;
int			iov_count;
{
 /* EXPORT DELETE START */

    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    status = val_wrap_iov_args(minor_status, context_handle,
			       conf_req_flag, qop_req,
			       conf_state, iov, iov_count);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
	if (mech->gss_wrap_iov_length) {
	    status = mech->gss_wrap_iov_length(
					      minor_status,
					      ctx->internal_ctx_id,
					      conf_req_flag,
					      qop_req,
					      conf_state,
					      iov,
					      iov_count);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }
 /* EXPORT DELETE END */

    return (GSS_S_BAD_MECH);
}
",C,"    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return (GSS_S_NO_CONTEXT);
",,,"@@ -93,6 +93,8 @@ int			iov_count;
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
@@ -151,6 +153,8 @@ int			iov_count;
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
@@ -190,6 +194,8 @@ gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 
     /* Select the approprate underlying mechanism routine and call it. */
     ctx = (gss_union_ctx_id_t)context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism(ctx->mech_type);
     if (mech == NULL)
 	return GSS_S_BAD_MECH;
@@ -218,6 +224,8 @@ gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 
     /* Select the approprate underlying mechanism routine and call it. */
     ctx = (gss_union_ctx_id_t)context_handle;
+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
+	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism(ctx->mech_type);
     if (mech == NULL)
 	return GSS_S_BAD_MECH;",krb5,56f7b1bc95a2a3eeb420e069e7655fb181ade5cf,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"gss_wrap_iov_length (minor_status,
                     context_handle,
                     conf_req_flag,
                     qop_req,
                     conf_state,
                     iov,
                     iov_count)
OM_uint32 *		minor_status;
gss_ctx_id_t		context_handle;
int			conf_req_flag;
gss_qop_t		qop_req;
int *			conf_state;
gss_iov_buffer_desc  *	iov;
int			iov_count;
{
 /* EXPORT DELETE START */

    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    status = val_wrap_iov_args(minor_status, context_handle,
			       conf_req_flag, qop_req,
			       conf_state, iov, iov_count);
    if (status != GSS_S_COMPLETE)
	return (status);

    /*
     * select the approprate underlying mechanism routine and
     * call it.
      */
 
     ctx = (gss_union_ctx_id_t) context_handle;
//fix_flaw_line_below:
//    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//	return (GSS_S_NO_CONTEXT);
     mech = gssint_get_mechanism (ctx->mech_type);
 
     if (mech) {
	if (mech->gss_wrap_iov_length) {
	    status = mech->gss_wrap_iov_length(
					      minor_status,
					      ctx->internal_ctx_id,
					      conf_req_flag,
					      qop_req,
					      conf_state,
					      iov,
					      iov_count);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_UNAVAILABLE;

	return(status);
    }
 /* EXPORT DELETE END */

    return (GSS_S_BAD_MECH);
}
"
3626,181362,,Local,Not required,Complete,CVE-2017-8890,https://www.cvedetails.com/cve/CVE-2017-8890/,CWE-415,Low,Complete,Complete,,2017-05-10,7.2,The inet_csk_clone_lock function in net/ipv4/inet_connection_sock.c in the Linux kernel through 4.10.15 allows attackers to cause a denial of service (double free) or possibly have unspecified other impact by leveraging use of the accept system call.,2018-08-30,DoS ,2,https://github.com/torvalds/linux/commit/657831ffc38e30092a2d5f03d385d710eb88b09a,657831ffc38e30092a2d5f03d385d710eb88b09a,"dccp/tcp: do not inherit mc_list from parent

syzkaller found a way to trigger double frees from ip_mc_drop_socket()

It turns out that leave a copy of parent mc_list at accept() time,
which is very bad.

Very similar to commit 8b485ce69876 (""tcp: do not inherit
fastopen_req from parent"")

Initial report from Pray3r, completed by Andrey one.
Thanks a lot to them !

Signed-off-by: Eric Dumazet <edumazet@google.com>
Reported-by: Pray3r <pray3r.z@gmail.com>
Reported-by: Andrey Konovalov <andreyknvl@google.com>
Tested-by: Andrey Konovalov <andreyknvl@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/ipv4/inet_connection_sock.c,"{""sha"": ""1054d330bf9df3189a21dbb08e27c0e6ad136775"", ""filename"": ""net/ipv4/inet_connection_sock.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/657831ffc38e30092a2d5f03d385d710eb88b09a/net/ipv4/inet_connection_sock.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/657831ffc38e30092a2d5f03d385d710eb88b09a/net/ipv4/inet_connection_sock.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/inet_connection_sock.c?ref=657831ffc38e30092a2d5f03d385d710eb88b09a"", ""patch"": ""@@ -794,6 +794,8 @@ struct sock *inet_csk_clone_lock(const struct sock *sk,\n \t\t/* listeners have SOCK_RCU_FREE, not the children */\n \t\tsock_reset_flag(newsk, SOCK_RCU_FREE);\n \n+\t\tinet_sk(newsk)->mc_list = NULL;\n+\n \t\tnewsk->sk_mark = inet_rsk(req)->ir_mark;\n \t\tatomic64_set(&newsk->sk_cookie,\n \t\t\t     atomic64_read(&inet_rsk(req)->ir_cookie));""}","struct sock *inet_csk_clone_lock(const struct sock *sk,
				 const struct request_sock *req,
				 const gfp_t priority)
{
	struct sock *newsk = sk_clone_lock(sk, priority);

	if (newsk) {
		struct inet_connection_sock *newicsk = inet_csk(newsk);

		newsk->sk_state = TCP_SYN_RECV;
		newicsk->icsk_bind_hash = NULL;

		inet_sk(newsk)->inet_dport = inet_rsk(req)->ir_rmt_port;
		inet_sk(newsk)->inet_num = inet_rsk(req)->ir_num;
		inet_sk(newsk)->inet_sport = htons(inet_rsk(req)->ir_num);
		newsk->sk_write_space = sk_stream_write_space;

 		/* listeners have SOCK_RCU_FREE, not the children */
 		sock_reset_flag(newsk, SOCK_RCU_FREE);
 
		inet_sk(newsk)->mc_list = NULL;

 		newsk->sk_mark = inet_rsk(req)->ir_mark;
 		atomic64_set(&newsk->sk_cookie,
 			     atomic64_read(&inet_rsk(req)->ir_cookie));

		newicsk->icsk_retransmits = 0;
		newicsk->icsk_backoff	  = 0;
		newicsk->icsk_probes_out  = 0;

		/* Deinitialize accept_queue to trap illegal accesses. */
		memset(&newicsk->icsk_accept_queue, 0, sizeof(newicsk->icsk_accept_queue));

		security_inet_csk_clone(newsk, req);
	}
	return newsk;
}
","struct sock *inet_csk_clone_lock(const struct sock *sk,
				 const struct request_sock *req,
				 const gfp_t priority)
{
	struct sock *newsk = sk_clone_lock(sk, priority);

	if (newsk) {
		struct inet_connection_sock *newicsk = inet_csk(newsk);

		newsk->sk_state = TCP_SYN_RECV;
		newicsk->icsk_bind_hash = NULL;

		inet_sk(newsk)->inet_dport = inet_rsk(req)->ir_rmt_port;
		inet_sk(newsk)->inet_num = inet_rsk(req)->ir_num;
		inet_sk(newsk)->inet_sport = htons(inet_rsk(req)->ir_num);
		newsk->sk_write_space = sk_stream_write_space;

 		/* listeners have SOCK_RCU_FREE, not the children */
 		sock_reset_flag(newsk, SOCK_RCU_FREE);
 
 		newsk->sk_mark = inet_rsk(req)->ir_mark;
 		atomic64_set(&newsk->sk_cookie,
 			     atomic64_read(&inet_rsk(req)->ir_cookie));

		newicsk->icsk_retransmits = 0;
		newicsk->icsk_backoff	  = 0;
		newicsk->icsk_probes_out  = 0;

		/* Deinitialize accept_queue to trap illegal accesses. */
		memset(&newicsk->icsk_accept_queue, 0, sizeof(newicsk->icsk_accept_queue));

		security_inet_csk_clone(newsk, req);
	}
	return newsk;
}
",C,"		inet_sk(newsk)->mc_list = NULL;

",,,"@@ -794,6 +794,8 @@ struct sock *inet_csk_clone_lock(const struct sock *sk,
 		/* listeners have SOCK_RCU_FREE, not the children */
 		sock_reset_flag(newsk, SOCK_RCU_FREE);
 
+		inet_sk(newsk)->mc_list = NULL;
+
 		newsk->sk_mark = inet_rsk(req)->ir_mark;
 		atomic64_set(&newsk->sk_cookie,
 			     atomic64_read(&inet_rsk(req)->ir_cookie));",linux,657831ffc38e30092a2d5f03d385d710eb88b09a,e735da5ec09526f197f3d8dd837d9a00e45e72aa,1,"struct sock *inet_csk_clone_lock(const struct sock *sk,
				 const struct request_sock *req,
				 const gfp_t priority)
{
	struct sock *newsk = sk_clone_lock(sk, priority);

	if (newsk) {
		struct inet_connection_sock *newicsk = inet_csk(newsk);

		newsk->sk_state = TCP_SYN_RECV;
		newicsk->icsk_bind_hash = NULL;

		inet_sk(newsk)->inet_dport = inet_rsk(req)->ir_rmt_port;
		inet_sk(newsk)->inet_num = inet_rsk(req)->ir_num;
		inet_sk(newsk)->inet_sport = htons(inet_rsk(req)->ir_num);
		newsk->sk_write_space = sk_stream_write_space;

 		/* listeners have SOCK_RCU_FREE, not the children */
 		sock_reset_flag(newsk, SOCK_RCU_FREE);
 
//fix_flaw_line_below:
//		inet_sk(newsk)->mc_list = NULL;
//fix_flaw_line_below:
//
 		newsk->sk_mark = inet_rsk(req)->ir_mark;
 		atomic64_set(&newsk->sk_cookie,
 			     atomic64_read(&inet_rsk(req)->ir_cookie));

		newicsk->icsk_retransmits = 0;
		newicsk->icsk_backoff	  = 0;
		newicsk->icsk_probes_out  = 0;

		/* Deinitialize accept_queue to trap illegal accesses. */
		memset(&newicsk->icsk_accept_queue, 0, sizeof(newicsk->icsk_accept_queue));

		security_inet_csk_clone(newsk, req);
	}
	return newsk;
}
"
3778,181514,,Local,Not required,Complete,CVE-2017-6353,https://www.cvedetails.com/cve/CVE-2017-6353/,CWE-415,Low,,,,2017-03-01,4.9,"net/sctp/socket.c in the Linux kernel through 4.10.1 does not properly restrict association peel-off operations during certain wait states, which allows local users to cause a denial of service (invalid unlock and double free) via a multithreaded application.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2017-5986.",2017-11-03,DoS ,6,https://github.com/torvalds/linux/commit/dfcb9f4f99f1e9a49e43398a7bfbf56927544af1,dfcb9f4f99f1e9a49e43398a7bfbf56927544af1,"sctp: deny peeloff operation on asocs with threads sleeping on it

commit 2dcab5984841 (""sctp: avoid BUG_ON on sctp_wait_for_sndbuf"")
attempted to avoid a BUG_ON call when the association being used for a
sendmsg() is blocked waiting for more sndbuf and another thread did a
peeloff operation on such asoc, moving it to another socket.

As Ben Hutchings noticed, then in such case it would return without
locking back the socket and would cause two unlocks in a row.

Further analysis also revealed that it could allow a double free if the
application managed to peeloff the asoc that is created during the
sendmsg call, because then sctp_sendmsg() would try to free the asoc
that was created only for that call.

This patch takes another approach. It will deny the peeloff operation
if there is a thread sleeping on the asoc, so this situation doesn't
exist anymore. This avoids the issues described above and also honors
the syscalls that are already being handled (it can be multiple sendmsg
calls).

Joint work with Xin Long.

Fixes: 2dcab5984841 (""sctp: avoid BUG_ON on sctp_wait_for_sndbuf"")
Cc: Alexander Popov <alex.popov@linux.com>
Cc: Ben Hutchings <ben@decadent.org.uk>
Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Signed-off-by: Xin Long <lucien.xin@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/sctp/socket.c,"{""sha"": ""465a9c8464f9477f827c14cbdab6879ac181a507"", ""filename"": ""net/sctp/socket.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 2, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/dfcb9f4f99f1e9a49e43398a7bfbf56927544af1/net/sctp/socket.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/dfcb9f4f99f1e9a49e43398a7bfbf56927544af1/net/sctp/socket.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/sctp/socket.c?ref=dfcb9f4f99f1e9a49e43398a7bfbf56927544af1"", ""patch"": ""@@ -4862,6 +4862,12 @@ int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n \tif (!asoc)\n \t\treturn -EINVAL;\n \n+\t/* If there is a thread waiting on more sndbuf space for\n+\t * sending on this asoc, it cannot be peeled.\n+\t */\n+\tif (waitqueue_active(&asoc->wait))\n+\t\treturn -EBUSY;\n+\n \t/* An association cannot be branched off from an already peeled-off\n \t * socket, nor is this supported for tcp style sockets.\n \t */\n@@ -7599,8 +7605,6 @@ static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,\n \t\t */\n \t\trelease_sock(sk);\n \t\tcurrent_timeo = schedule_timeout(current_timeo);\n-\t\tif (sk != asoc->base.sk)\n-\t\t\tgoto do_error;\n \t\tlock_sock(sk);\n \n \t\t*timeo_p = current_timeo;""}","int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
	struct socket *sock;
	int err = 0;

 	if (!asoc)
 		return -EINVAL;
 
	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;

 	/* An association cannot be branched off from an already peeled-off
 	 * socket, nor is this supported for tcp style sockets.
 	 */
	if (!sctp_style(sk, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sk, sk, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
}
","int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
	struct socket *sock;
	int err = 0;

 	if (!asoc)
 		return -EINVAL;
 
 	/* An association cannot be branched off from an already peeled-off
 	 * socket, nor is this supported for tcp style sockets.
 	 */
	if (!sctp_style(sk, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sk, sk, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
}
",C,"	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;

",,,"@@ -4862,6 +4862,12 @@ int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
 	if (!asoc)
 		return -EINVAL;
 
+	/* If there is a thread waiting on more sndbuf space for
+	 * sending on this asoc, it cannot be peeled.
+	 */
+	if (waitqueue_active(&asoc->wait))
+		return -EBUSY;
+
 	/* An association cannot be branched off from an already peeled-off
 	 * socket, nor is this supported for tcp style sockets.
 	 */
@@ -7599,8 +7605,6 @@ static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
 		 */
 		release_sock(sk);
 		current_timeo = schedule_timeout(current_timeo);
-		if (sk != asoc->base.sk)
-			goto do_error;
 		lock_sock(sk);
 
 		*timeo_p = current_timeo;",linux,dfcb9f4f99f1e9a49e43398a7bfbf56927544af1,f1ef09fde17f9b77ca1435a5b53a28b203afb81c,1,"int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
	struct socket *sock;
	int err = 0;

 	if (!asoc)
 		return -EINVAL;
 
//fix_flaw_line_below:
//	/* If there is a thread waiting on more sndbuf space for
//fix_flaw_line_below:
//	 * sending on this asoc, it cannot be peeled.
//fix_flaw_line_below:
//	 */
//fix_flaw_line_below:
//	if (waitqueue_active(&asoc->wait))
//fix_flaw_line_below:
//		return -EBUSY;
//fix_flaw_line_below:
//
 	/* An association cannot be branched off from an already peeled-off
 	 * socket, nor is this supported for tcp style sockets.
 	 */
	if (!sctp_style(sk, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sk, sk, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
}
"
3779,181515,,Local,Not required,Complete,CVE-2017-6353,https://www.cvedetails.com/cve/CVE-2017-6353/,CWE-415,Low,,,,2017-03-01,4.9,"net/sctp/socket.c in the Linux kernel through 4.10.1 does not properly restrict association peel-off operations during certain wait states, which allows local users to cause a denial of service (invalid unlock and double free) via a multithreaded application.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2017-5986.",2017-11-03,DoS ,0,https://github.com/torvalds/linux/commit/dfcb9f4f99f1e9a49e43398a7bfbf56927544af1,dfcb9f4f99f1e9a49e43398a7bfbf56927544af1,"sctp: deny peeloff operation on asocs with threads sleeping on it

commit 2dcab5984841 (""sctp: avoid BUG_ON on sctp_wait_for_sndbuf"")
attempted to avoid a BUG_ON call when the association being used for a
sendmsg() is blocked waiting for more sndbuf and another thread did a
peeloff operation on such asoc, moving it to another socket.

As Ben Hutchings noticed, then in such case it would return without
locking back the socket and would cause two unlocks in a row.

Further analysis also revealed that it could allow a double free if the
application managed to peeloff the asoc that is created during the
sendmsg call, because then sctp_sendmsg() would try to free the asoc
that was created only for that call.

This patch takes another approach. It will deny the peeloff operation
if there is a thread sleeping on the asoc, so this situation doesn't
exist anymore. This avoids the issues described above and also honors
the syscalls that are already being handled (it can be multiple sendmsg
calls).

Joint work with Xin Long.

Fixes: 2dcab5984841 (""sctp: avoid BUG_ON on sctp_wait_for_sndbuf"")
Cc: Alexander Popov <alex.popov@linux.com>
Cc: Ben Hutchings <ben@decadent.org.uk>
Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Signed-off-by: Xin Long <lucien.xin@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",2,net/sctp/socket.c,"{""sha"": ""465a9c8464f9477f827c14cbdab6879ac181a507"", ""filename"": ""net/sctp/socket.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 2, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/dfcb9f4f99f1e9a49e43398a7bfbf56927544af1/net/sctp/socket.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/dfcb9f4f99f1e9a49e43398a7bfbf56927544af1/net/sctp/socket.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/sctp/socket.c?ref=dfcb9f4f99f1e9a49e43398a7bfbf56927544af1"", ""patch"": ""@@ -4862,6 +4862,12 @@ int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n \tif (!asoc)\n \t\treturn -EINVAL;\n \n+\t/* If there is a thread waiting on more sndbuf space for\n+\t * sending on this asoc, it cannot be peeled.\n+\t */\n+\tif (waitqueue_active(&asoc->wait))\n+\t\treturn -EBUSY;\n+\n \t/* An association cannot be branched off from an already peeled-off\n \t * socket, nor is this supported for tcp style sockets.\n \t */\n@@ -7599,8 +7605,6 @@ static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,\n \t\t */\n \t\trelease_sock(sk);\n \t\tcurrent_timeo = schedule_timeout(current_timeo);\n-\t\tif (sk != asoc->base.sk)\n-\t\t\tgoto do_error;\n \t\tlock_sock(sk);\n \n \t\t*timeo_p = current_timeo;""}","static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
				size_t msg_len)
{
	struct sock *sk = asoc->base.sk;
	int err = 0;
	long current_timeo = *timeo_p;
	DEFINE_WAIT(wait);

	pr_debug(""%s: asoc:%p, timeo:%ld, msg_len:%zu\n"", __func__, asoc,
		 *timeo_p, msg_len);

	/* Increment the association's refcnt.  */
	sctp_association_hold(asoc);

	/* Wait on the association specific sndbuf space. */
	for (;;) {
		prepare_to_wait_exclusive(&asoc->wait, &wait,
					  TASK_INTERRUPTIBLE);
		if (!*timeo_p)
			goto do_nonblock;
		if (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||
		    asoc->base.dead)
			goto do_error;
		if (signal_pending(current))
			goto do_interrupted;
		if (msg_len <= sctp_wspace(asoc))
			break;

		/* Let another process have a go.  Since we are going
		 * to sleep anyway.
 		 */
 		release_sock(sk);
 		current_timeo = schedule_timeout(current_timeo);
 		lock_sock(sk);
 
 		*timeo_p = current_timeo;
	}

out:
	finish_wait(&asoc->wait, &wait);

	/* Release the association's refcnt.  */
	sctp_association_put(asoc);

	return err;

do_error:
	err = -EPIPE;
	goto out;

do_interrupted:
	err = sock_intr_errno(*timeo_p);
	goto out;

do_nonblock:
	err = -EAGAIN;
	goto out;
}
","static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
				size_t msg_len)
{
	struct sock *sk = asoc->base.sk;
	int err = 0;
	long current_timeo = *timeo_p;
	DEFINE_WAIT(wait);

	pr_debug(""%s: asoc:%p, timeo:%ld, msg_len:%zu\n"", __func__, asoc,
		 *timeo_p, msg_len);

	/* Increment the association's refcnt.  */
	sctp_association_hold(asoc);

	/* Wait on the association specific sndbuf space. */
	for (;;) {
		prepare_to_wait_exclusive(&asoc->wait, &wait,
					  TASK_INTERRUPTIBLE);
		if (!*timeo_p)
			goto do_nonblock;
		if (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||
		    asoc->base.dead)
			goto do_error;
		if (signal_pending(current))
			goto do_interrupted;
		if (msg_len <= sctp_wspace(asoc))
			break;

		/* Let another process have a go.  Since we are going
		 * to sleep anyway.
 		 */
 		release_sock(sk);
 		current_timeo = schedule_timeout(current_timeo);
		if (sk != asoc->base.sk)
			goto do_error;
 		lock_sock(sk);
 
 		*timeo_p = current_timeo;
	}

out:
	finish_wait(&asoc->wait, &wait);

	/* Release the association's refcnt.  */
	sctp_association_put(asoc);

	return err;

do_error:
	err = -EPIPE;
	goto out;

do_interrupted:
	err = sock_intr_errno(*timeo_p);
	goto out;

do_nonblock:
	err = -EAGAIN;
	goto out;
}
",C,,"		if (sk != asoc->base.sk)
			goto do_error;
",,"@@ -4862,6 +4862,12 @@ int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
 	if (!asoc)
 		return -EINVAL;
 
+	/* If there is a thread waiting on more sndbuf space for
+	 * sending on this asoc, it cannot be peeled.
+	 */
+	if (waitqueue_active(&asoc->wait))
+		return -EBUSY;
+
 	/* An association cannot be branched off from an already peeled-off
 	 * socket, nor is this supported for tcp style sockets.
 	 */
@@ -7599,8 +7605,6 @@ static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
 		 */
 		release_sock(sk);
 		current_timeo = schedule_timeout(current_timeo);
-		if (sk != asoc->base.sk)
-			goto do_error;
 		lock_sock(sk);
 
 		*timeo_p = current_timeo;",linux,dfcb9f4f99f1e9a49e43398a7bfbf56927544af1,f1ef09fde17f9b77ca1435a5b53a28b203afb81c,1,"static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
				size_t msg_len)
{
	struct sock *sk = asoc->base.sk;
	int err = 0;
	long current_timeo = *timeo_p;
	DEFINE_WAIT(wait);

	pr_debug(""%s: asoc:%p, timeo:%ld, msg_len:%zu\n"", __func__, asoc,
		 *timeo_p, msg_len);

	/* Increment the association's refcnt.  */
	sctp_association_hold(asoc);

	/* Wait on the association specific sndbuf space. */
	for (;;) {
		prepare_to_wait_exclusive(&asoc->wait, &wait,
					  TASK_INTERRUPTIBLE);
		if (!*timeo_p)
			goto do_nonblock;
		if (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||
		    asoc->base.dead)
			goto do_error;
		if (signal_pending(current))
			goto do_interrupted;
		if (msg_len <= sctp_wspace(asoc))
			break;

		/* Let another process have a go.  Since we are going
		 * to sleep anyway.
 		 */
 		release_sock(sk);
 		current_timeo = schedule_timeout(current_timeo);
//flaw_line_below:
		if (sk != asoc->base.sk)
//flaw_line_below:
			goto do_error;
 		lock_sock(sk);
 
 		*timeo_p = current_timeo;
	}

out:
	finish_wait(&asoc->wait, &wait);

	/* Release the association's refcnt.  */
	sctp_association_put(asoc);

	return err;

do_error:
	err = -EPIPE;
	goto out;

do_interrupted:
	err = sock_intr_errno(*timeo_p);
	goto out;

do_nonblock:
	err = -EAGAIN;
	goto out;
}
"
3802,181538,,Local,Not required,Complete,CVE-2017-6074,https://www.cvedetails.com/cve/CVE-2017-6074/,CWE-415,Low,Complete,Complete,,2017-02-18,7.2,"The dccp_rcv_state_process function in net/dccp/input.c in the Linux kernel through 4.9.11 mishandles DCCP_PKT_REQUEST packet data structures in the LISTEN state, which allows local users to obtain root privileges or cause a denial of service (double free) via an application that makes an IPV6_RECVPKTINFO setsockopt system call.",2018-07-18,DoS ,2,https://github.com/torvalds/linux/commit/5edabca9d4cff7f1f2b68f0bac55ef99d9798ba4,5edabca9d4cff7f1f2b68f0bac55ef99d9798ba4,"dccp: fix freeing skb too early for IPV6_RECVPKTINFO

In the current DCCP implementation an skb for a DCCP_PKT_REQUEST packet
is forcibly freed via __kfree_skb in dccp_rcv_state_process if
dccp_v6_conn_request successfully returns.

However, if IPV6_RECVPKTINFO is set on a socket, the address of the skb
is saved to ireq->pktopts and the ref count for skb is incremented in
dccp_v6_conn_request, so skb is still in use. Nevertheless, it gets freed
in dccp_rcv_state_process.

Fix by calling consume_skb instead of doing goto discard and therefore
calling __kfree_skb.

Similar fixes for TCP:

fb7e2399ec17f1004c0e0ccfd17439f8759ede01 [TCP]: skb is unexpectedly freed.
0aea76d35c9651d55bbaf746e7914e5f9ae5a25d tcp: SYN packets are now
simply consumed

Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
Acked-by: Eric Dumazet <edumazet@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/dccp/input.c,"{""sha"": ""8fedc2d497709b3dea9202894f45bf5cab043361"", ""filename"": ""net/dccp/input.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/5edabca9d4cff7f1f2b68f0bac55ef99d9798ba4/net/dccp/input.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5edabca9d4cff7f1f2b68f0bac55ef99d9798ba4/net/dccp/input.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/dccp/input.c?ref=5edabca9d4cff7f1f2b68f0bac55ef99d9798ba4"", ""patch"": ""@@ -606,7 +606,8 @@ int dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,\n \t\t\tif (inet_csk(sk)->icsk_af_ops->conn_request(sk,\n \t\t\t\t\t\t\t\t    skb) < 0)\n \t\t\t\treturn 1;\n-\t\t\tgoto discard;\n+\t\t\tconsume_skb(skb);\n+\t\t\treturn 0;\n \t\t}\n \t\tif (dh->dccph_type == DCCP_PKT_RESET)\n \t\t\tgoto discard;""}","int dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
			   struct dccp_hdr *dh, unsigned int len)
{
	struct dccp_sock *dp = dccp_sk(sk);
	struct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);
	const int old_state = sk->sk_state;
	int queued = 0;

	/*
	 *  Step 3: Process LISTEN state
	 *
	 *     If S.state == LISTEN,
	 *	 If P.type == Request or P contains a valid Init Cookie option,
	 *	      (* Must scan the packet's options to check for Init
	 *		 Cookies.  Only Init Cookies are processed here,
	 *		 however; other options are processed in Step 8.  This
	 *		 scan need only be performed if the endpoint uses Init
	 *		 Cookies *)
	 *	      (* Generate a new socket and switch to that socket *)
	 *	      Set S := new socket for this port pair
	 *	      S.state = RESPOND
	 *	      Choose S.ISS (initial seqno) or set from Init Cookies
	 *	      Initialize S.GAR := S.ISS
	 *	      Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init
	 *	      Cookies Continue with S.state == RESPOND
	 *	      (* A Response packet will be generated in Step 11 *)
	 *	 Otherwise,
	 *	      Generate Reset(No Connection) unless P.type == Reset
	 *	      Drop packet and return
	 */
	if (sk->sk_state == DCCP_LISTEN) {
		if (dh->dccph_type == DCCP_PKT_REQUEST) {
 			if (inet_csk(sk)->icsk_af_ops->conn_request(sk,
 								    skb) < 0)
 				return 1;
			consume_skb(skb);
			return 0;
 		}
 		if (dh->dccph_type == DCCP_PKT_RESET)
 			goto discard;

		/* Caller (dccp_v4_do_rcv) will send Reset */
		dcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;
		return 1;
	} else if (sk->sk_state == DCCP_CLOSED) {
		dcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;
		return 1;
	}

	/* Step 6: Check sequence numbers (omitted in LISTEN/REQUEST state) */
	if (sk->sk_state != DCCP_REQUESTING && dccp_check_seqno(sk, skb))
		goto discard;

	/*
	 *   Step 7: Check for unexpected packet types
	 *      If (S.is_server and P.type == Response)
	 *	    or (S.is_client and P.type == Request)
	 *	    or (S.state == RESPOND and P.type == Data),
	 *	  Send Sync packet acknowledging P.seqno
	 *	  Drop packet and return
	 */
	if ((dp->dccps_role != DCCP_ROLE_CLIENT &&
	     dh->dccph_type == DCCP_PKT_RESPONSE) ||
	    (dp->dccps_role == DCCP_ROLE_CLIENT &&
	     dh->dccph_type == DCCP_PKT_REQUEST) ||
	    (sk->sk_state == DCCP_RESPOND && dh->dccph_type == DCCP_PKT_DATA)) {
		dccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNC);
		goto discard;
	}

	/*  Step 8: Process options */
	if (dccp_parse_options(sk, NULL, skb))
		return 1;

	/*
	 *  Step 9: Process Reset
	 *	If P.type == Reset,
	 *		Tear down connection
	 *		S.state := TIMEWAIT
	 *		Set TIMEWAIT timer
	 *		Drop packet and return
	 */
	if (dh->dccph_type == DCCP_PKT_RESET) {
		dccp_rcv_reset(sk, skb);
		return 0;
	} else if (dh->dccph_type == DCCP_PKT_CLOSEREQ) {	/* Step 13 */
		if (dccp_rcv_closereq(sk, skb))
			return 0;
		goto discard;
	} else if (dh->dccph_type == DCCP_PKT_CLOSE) {		/* Step 14 */
		if (dccp_rcv_close(sk, skb))
			return 0;
		goto discard;
	}

	switch (sk->sk_state) {
	case DCCP_REQUESTING:
		queued = dccp_rcv_request_sent_state_process(sk, skb, dh, len);
		if (queued >= 0)
			return queued;

		__kfree_skb(skb);
		return 0;

	case DCCP_PARTOPEN:
		/* Step 8: if using Ack Vectors, mark packet acknowledgeable */
		dccp_handle_ackvec_processing(sk, skb);
		dccp_deliver_input_to_ccids(sk, skb);
		/* fall through */
	case DCCP_RESPOND:
		queued = dccp_rcv_respond_partopen_state_process(sk, skb,
								 dh, len);
		break;
	}

	if (dh->dccph_type == DCCP_PKT_ACK ||
	    dh->dccph_type == DCCP_PKT_DATAACK) {
		switch (old_state) {
		case DCCP_PARTOPEN:
			sk->sk_state_change(sk);
			sk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);
			break;
		}
	} else if (unlikely(dh->dccph_type == DCCP_PKT_SYNC)) {
		dccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNCACK);
		goto discard;
	}

	if (!queued) {
discard:
		__kfree_skb(skb);
	}
	return 0;
}
","int dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
			   struct dccp_hdr *dh, unsigned int len)
{
	struct dccp_sock *dp = dccp_sk(sk);
	struct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);
	const int old_state = sk->sk_state;
	int queued = 0;

	/*
	 *  Step 3: Process LISTEN state
	 *
	 *     If S.state == LISTEN,
	 *	 If P.type == Request or P contains a valid Init Cookie option,
	 *	      (* Must scan the packet's options to check for Init
	 *		 Cookies.  Only Init Cookies are processed here,
	 *		 however; other options are processed in Step 8.  This
	 *		 scan need only be performed if the endpoint uses Init
	 *		 Cookies *)
	 *	      (* Generate a new socket and switch to that socket *)
	 *	      Set S := new socket for this port pair
	 *	      S.state = RESPOND
	 *	      Choose S.ISS (initial seqno) or set from Init Cookies
	 *	      Initialize S.GAR := S.ISS
	 *	      Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init
	 *	      Cookies Continue with S.state == RESPOND
	 *	      (* A Response packet will be generated in Step 11 *)
	 *	 Otherwise,
	 *	      Generate Reset(No Connection) unless P.type == Reset
	 *	      Drop packet and return
	 */
	if (sk->sk_state == DCCP_LISTEN) {
		if (dh->dccph_type == DCCP_PKT_REQUEST) {
 			if (inet_csk(sk)->icsk_af_ops->conn_request(sk,
 								    skb) < 0)
 				return 1;
			goto discard;
 		}
 		if (dh->dccph_type == DCCP_PKT_RESET)
 			goto discard;

		/* Caller (dccp_v4_do_rcv) will send Reset */
		dcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;
		return 1;
	} else if (sk->sk_state == DCCP_CLOSED) {
		dcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;
		return 1;
	}

	/* Step 6: Check sequence numbers (omitted in LISTEN/REQUEST state) */
	if (sk->sk_state != DCCP_REQUESTING && dccp_check_seqno(sk, skb))
		goto discard;

	/*
	 *   Step 7: Check for unexpected packet types
	 *      If (S.is_server and P.type == Response)
	 *	    or (S.is_client and P.type == Request)
	 *	    or (S.state == RESPOND and P.type == Data),
	 *	  Send Sync packet acknowledging P.seqno
	 *	  Drop packet and return
	 */
	if ((dp->dccps_role != DCCP_ROLE_CLIENT &&
	     dh->dccph_type == DCCP_PKT_RESPONSE) ||
	    (dp->dccps_role == DCCP_ROLE_CLIENT &&
	     dh->dccph_type == DCCP_PKT_REQUEST) ||
	    (sk->sk_state == DCCP_RESPOND && dh->dccph_type == DCCP_PKT_DATA)) {
		dccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNC);
		goto discard;
	}

	/*  Step 8: Process options */
	if (dccp_parse_options(sk, NULL, skb))
		return 1;

	/*
	 *  Step 9: Process Reset
	 *	If P.type == Reset,
	 *		Tear down connection
	 *		S.state := TIMEWAIT
	 *		Set TIMEWAIT timer
	 *		Drop packet and return
	 */
	if (dh->dccph_type == DCCP_PKT_RESET) {
		dccp_rcv_reset(sk, skb);
		return 0;
	} else if (dh->dccph_type == DCCP_PKT_CLOSEREQ) {	/* Step 13 */
		if (dccp_rcv_closereq(sk, skb))
			return 0;
		goto discard;
	} else if (dh->dccph_type == DCCP_PKT_CLOSE) {		/* Step 14 */
		if (dccp_rcv_close(sk, skb))
			return 0;
		goto discard;
	}

	switch (sk->sk_state) {
	case DCCP_REQUESTING:
		queued = dccp_rcv_request_sent_state_process(sk, skb, dh, len);
		if (queued >= 0)
			return queued;

		__kfree_skb(skb);
		return 0;

	case DCCP_PARTOPEN:
		/* Step 8: if using Ack Vectors, mark packet acknowledgeable */
		dccp_handle_ackvec_processing(sk, skb);
		dccp_deliver_input_to_ccids(sk, skb);
		/* fall through */
	case DCCP_RESPOND:
		queued = dccp_rcv_respond_partopen_state_process(sk, skb,
								 dh, len);
		break;
	}

	if (dh->dccph_type == DCCP_PKT_ACK ||
	    dh->dccph_type == DCCP_PKT_DATAACK) {
		switch (old_state) {
		case DCCP_PARTOPEN:
			sk->sk_state_change(sk);
			sk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);
			break;
		}
	} else if (unlikely(dh->dccph_type == DCCP_PKT_SYNC)) {
		dccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNCACK);
		goto discard;
	}

	if (!queued) {
discard:
		__kfree_skb(skb);
	}
	return 0;
}
",C,"			consume_skb(skb);
			return 0;
","			goto discard;
",,"@@ -606,7 +606,8 @@ int dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
 			if (inet_csk(sk)->icsk_af_ops->conn_request(sk,
 								    skb) < 0)
 				return 1;
-			goto discard;
+			consume_skb(skb);
+			return 0;
 		}
 		if (dh->dccph_type == DCCP_PKT_RESET)
 			goto discard;",linux,5edabca9d4cff7f1f2b68f0bac55ef99d9798ba4,785f35775d968e0f45231b754e945fcb3ed6bded,1,"int dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
			   struct dccp_hdr *dh, unsigned int len)
{
	struct dccp_sock *dp = dccp_sk(sk);
	struct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);
	const int old_state = sk->sk_state;
	int queued = 0;

	/*
	 *  Step 3: Process LISTEN state
	 *
	 *     If S.state == LISTEN,
	 *	 If P.type == Request or P contains a valid Init Cookie option,
	 *	      (* Must scan the packet's options to check for Init
	 *		 Cookies.  Only Init Cookies are processed here,
	 *		 however; other options are processed in Step 8.  This
	 *		 scan need only be performed if the endpoint uses Init
	 *		 Cookies *)
	 *	      (* Generate a new socket and switch to that socket *)
	 *	      Set S := new socket for this port pair
	 *	      S.state = RESPOND
	 *	      Choose S.ISS (initial seqno) or set from Init Cookies
	 *	      Initialize S.GAR := S.ISS
	 *	      Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init
	 *	      Cookies Continue with S.state == RESPOND
	 *	      (* A Response packet will be generated in Step 11 *)
	 *	 Otherwise,
	 *	      Generate Reset(No Connection) unless P.type == Reset
	 *	      Drop packet and return
	 */
	if (sk->sk_state == DCCP_LISTEN) {
		if (dh->dccph_type == DCCP_PKT_REQUEST) {
 			if (inet_csk(sk)->icsk_af_ops->conn_request(sk,
 								    skb) < 0)
 				return 1;
//flaw_line_below:
			goto discard;
//fix_flaw_line_below:
//			consume_skb(skb);
//fix_flaw_line_below:
//			return 0;
 		}
 		if (dh->dccph_type == DCCP_PKT_RESET)
 			goto discard;

		/* Caller (dccp_v4_do_rcv) will send Reset */
		dcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;
		return 1;
	} else if (sk->sk_state == DCCP_CLOSED) {
		dcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;
		return 1;
	}

	/* Step 6: Check sequence numbers (omitted in LISTEN/REQUEST state) */
	if (sk->sk_state != DCCP_REQUESTING && dccp_check_seqno(sk, skb))
		goto discard;

	/*
	 *   Step 7: Check for unexpected packet types
	 *      If (S.is_server and P.type == Response)
	 *	    or (S.is_client and P.type == Request)
	 *	    or (S.state == RESPOND and P.type == Data),
	 *	  Send Sync packet acknowledging P.seqno
	 *	  Drop packet and return
	 */
	if ((dp->dccps_role != DCCP_ROLE_CLIENT &&
	     dh->dccph_type == DCCP_PKT_RESPONSE) ||
	    (dp->dccps_role == DCCP_ROLE_CLIENT &&
	     dh->dccph_type == DCCP_PKT_REQUEST) ||
	    (sk->sk_state == DCCP_RESPOND && dh->dccph_type == DCCP_PKT_DATA)) {
		dccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNC);
		goto discard;
	}

	/*  Step 8: Process options */
	if (dccp_parse_options(sk, NULL, skb))
		return 1;

	/*
	 *  Step 9: Process Reset
	 *	If P.type == Reset,
	 *		Tear down connection
	 *		S.state := TIMEWAIT
	 *		Set TIMEWAIT timer
	 *		Drop packet and return
	 */
	if (dh->dccph_type == DCCP_PKT_RESET) {
		dccp_rcv_reset(sk, skb);
		return 0;
	} else if (dh->dccph_type == DCCP_PKT_CLOSEREQ) {	/* Step 13 */
		if (dccp_rcv_closereq(sk, skb))
			return 0;
		goto discard;
	} else if (dh->dccph_type == DCCP_PKT_CLOSE) {		/* Step 14 */
		if (dccp_rcv_close(sk, skb))
			return 0;
		goto discard;
	}

	switch (sk->sk_state) {
	case DCCP_REQUESTING:
		queued = dccp_rcv_request_sent_state_process(sk, skb, dh, len);
		if (queued >= 0)
			return queued;

		__kfree_skb(skb);
		return 0;

	case DCCP_PARTOPEN:
		/* Step 8: if using Ack Vectors, mark packet acknowledgeable */
		dccp_handle_ackvec_processing(sk, skb);
		dccp_deliver_input_to_ccids(sk, skb);
		/* fall through */
	case DCCP_RESPOND:
		queued = dccp_rcv_respond_partopen_state_process(sk, skb,
								 dh, len);
		break;
	}

	if (dh->dccph_type == DCCP_PKT_ACK ||
	    dh->dccph_type == DCCP_PKT_DATAACK) {
		switch (old_state) {
		case DCCP_PARTOPEN:
			sk->sk_state_change(sk);
			sk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);
			break;
		}
	} else if (unlikely(dh->dccph_type == DCCP_PKT_SYNC)) {
		dccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNCACK);
		goto discard;
	}

	if (!queued) {
discard:
		__kfree_skb(skb);
	}
	return 0;
}
"
3845,181581,,Remote,Not required,Partial,CVE-2017-5506,https://www.cvedetails.com/cve/CVE-2017-5506/,CWE-415,Medium,Partial,Partial,,2017-03-24,6.8,Double free vulnerability in magick/profile.c in ImageMagick allows remote attackers to have unspecified impact via a crafted file.,2017-11-03,,3,https://github.com/ImageMagick/ImageMagick/commit/6235f1f7a9f7b0f83b197f6cd0073dbb6602d0fb,6235f1f7a9f7b0f83b197f6cd0073dbb6602d0fb,https://github.com/ImageMagick/ImageMagick/issues/354,3,magick/profile.c,"{""sha"": ""6313388a2b13db99a73e4c84a223d8361150ca04"", ""filename"": ""magick/profile.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/6235f1f7a9f7b0f83b197f6cd0073dbb6602d0fb/magick/profile.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/6235f1f7a9f7b0f83b197f6cd0073dbb6602d0fb/magick/profile.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/magick/profile.c?ref=6235f1f7a9f7b0f83b197f6cd0073dbb6602d0fb"", ""patch"": ""@@ -2071,10 +2071,10 @@ static MagickBooleanType SyncExifProfile(Image *image, StringInfo *profile)\n             The directory entry contains an offset.\n           */\n           offset=(ssize_t) ReadProfileLong(endian,q+8);\n-          if ((ssize_t) (offset+number_bytes) < offset)\n-            continue;  /* prevent overflow */\n-          if ((size_t) (offset+number_bytes) > length)\n+          if ((offset < 0) || ((size_t) (offset+number_bytes) > length))\n             continue;\n+          if (~length < number_bytes)\n+            continue;  /* prevent overflow */\n           p=(unsigned char *) (exif+offset);\n         }\n       switch (tag_value)""}","static MagickBooleanType SyncExifProfile(Image *image, StringInfo *profile)
{
#define MaxDirectoryStack  16
#define EXIF_DELIMITER  ""\n""
#define EXIF_NUM_FORMATS  12
#define TAG_EXIF_OFFSET  0x8769
#define TAG_INTEROP_OFFSET  0xa005

  typedef struct _DirectoryInfo
  {
    unsigned char
      *directory;

    size_t
      entry;
  } DirectoryInfo;

  DirectoryInfo
    directory_stack[MaxDirectoryStack];

  EndianType
    endian;

  size_t
    entry,
    length,
    number_entries;

  SplayTreeInfo
    *exif_resources;

  ssize_t
    id,
    level,
    offset;

  static int
    format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};

  unsigned char
    *directory,
    *exif;

  /*
    Set EXIF resolution tag.
  */
  length=GetStringInfoLength(profile);
  exif=GetStringInfoDatum(profile);
  if (length < 16)
    return(MagickFalse);
  id=(ssize_t) ReadProfileShort(LSBEndian,exif);
  if ((id != 0x4949) && (id != 0x4D4D))
    {
      while (length != 0)
      {
        if (ReadProfileByte(&exif,&length) != 0x45)
          continue;
        if (ReadProfileByte(&exif,&length) != 0x78)
          continue;
        if (ReadProfileByte(&exif,&length) != 0x69)
          continue;
        if (ReadProfileByte(&exif,&length) != 0x66)
          continue;
        if (ReadProfileByte(&exif,&length) != 0x00)
          continue;
        if (ReadProfileByte(&exif,&length) != 0x00)
          continue;
        break;
      }
      if (length < 16)
        return(MagickFalse);
      id=(ssize_t) ReadProfileShort(LSBEndian,exif);
    }
  endian=LSBEndian;
  if (id == 0x4949)
    endian=LSBEndian;
  else
    if (id == 0x4D4D)
      endian=MSBEndian;
    else
      return(MagickFalse);
  if (ReadProfileShort(endian,exif+2) != 0x002a)
    return(MagickFalse);
  /*
    This the offset to the first IFD.
  */
  offset=(ssize_t) ReadProfileLong(endian,exif+4);
  if ((offset < 0) || ((size_t) offset >= length))
    return(MagickFalse);
  directory=exif+offset;
  level=0;
  entry=0;
  exif_resources=NewSplayTree((int (*)(const void *,const void *)) NULL,
    (void *(*)(void *)) NULL,(void *(*)(void *)) NULL);
  do
  {
    if (level > 0)
      {
        level--;
        directory=directory_stack[level].directory;
        entry=directory_stack[level].entry;
      }
    if ((directory < exif) || (directory > (exif+length-2)))
      break;
    /*
      Determine how many entries there are in the current IFD.
    */
    number_entries=ReadProfileShort(endian,directory);
    for ( ; entry < number_entries; entry++)
    {
      register unsigned char
        *p,
        *q;

      size_t
        number_bytes;

      ssize_t
        components,
        format,
        tag_value;

      q=(unsigned char *) (directory+2+(12*entry));
      if (q > (exif+length-12))
        break;  /* corrupt EXIF */
      if (GetValueFromSplayTree(exif_resources,q) == q)
        break;
      (void) AddValueToSplayTree(exif_resources,q,q);
      tag_value=(ssize_t) ReadProfileShort(endian,q);
      format=(ssize_t) ReadProfileShort(endian,q+2);
      if ((format < 0) || ((format-1) >= EXIF_NUM_FORMATS))
        break;
      components=(ssize_t) ReadProfileLong(endian,q+4);
      if (components < 0)
        break;  /* corrupt EXIF */
      number_bytes=(size_t) components*format_bytes[format];
      if ((ssize_t) number_bytes < components)
        break;  /* prevent overflow */
      if (number_bytes <= 4)
        p=q+8;
      else
        {
          /*
             The directory entry contains an offset.
           */
           offset=(ssize_t) ReadProfileLong(endian,q+8);
          if ((offset < 0) || ((size_t) (offset+number_bytes) > length))
             continue;
          if (~length < number_bytes)
            continue;  /* prevent overflow */
           p=(unsigned char *) (exif+offset);
         }
       switch (tag_value)
      {
        case 0x011a:
        {
          (void) WriteProfileLong(endian,(size_t) (image->x_resolution+0.5),p);
          (void) WriteProfileLong(endian,1UL,p+4);
          break;
        }
        case 0x011b:
        {
          (void) WriteProfileLong(endian,(size_t) (image->y_resolution+0.5),p);
          (void) WriteProfileLong(endian,1UL,p+4);
          break;
        }
        case 0x0112:
        {
          if (number_bytes == 4)
            {
              (void) WriteProfileLong(endian,(size_t) image->orientation,p);
              break;
            }
          (void) WriteProfileShort(endian,(unsigned short) image->orientation,
            p);
          break;
        }
        case 0x0128:
        {
          if (number_bytes == 4)
            {
              (void) WriteProfileLong(endian,(size_t) (image->units+1),p);
              break;
            }
          (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);
          break;
        }
        default:
          break;
      }
      if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))
        {
          offset=(ssize_t) ReadProfileLong(endian,p);
          if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))
            {
              directory_stack[level].directory=directory;
              entry++;
              directory_stack[level].entry=entry;
              level++;
              directory_stack[level].directory=exif+offset;
              directory_stack[level].entry=0;
              level++;
              if ((directory+2+(12*number_entries)) > (exif+length))
                break;
              offset=(ssize_t) ReadProfileLong(endian,directory+2+(12*
                number_entries));
              if ((offset != 0) && ((size_t) offset < length) &&
                  (level < (MaxDirectoryStack-2)))
                {
                  directory_stack[level].directory=exif+offset;
                  directory_stack[level].entry=0;
                  level++;
                }
            }
          break;
        }
    }
  } while (level > 0);
  exif_resources=DestroySplayTree(exif_resources);
  return(MagickTrue);
}
","static MagickBooleanType SyncExifProfile(Image *image, StringInfo *profile)
{
#define MaxDirectoryStack  16
#define EXIF_DELIMITER  ""\n""
#define EXIF_NUM_FORMATS  12
#define TAG_EXIF_OFFSET  0x8769
#define TAG_INTEROP_OFFSET  0xa005

  typedef struct _DirectoryInfo
  {
    unsigned char
      *directory;

    size_t
      entry;
  } DirectoryInfo;

  DirectoryInfo
    directory_stack[MaxDirectoryStack];

  EndianType
    endian;

  size_t
    entry,
    length,
    number_entries;

  SplayTreeInfo
    *exif_resources;

  ssize_t
    id,
    level,
    offset;

  static int
    format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};

  unsigned char
    *directory,
    *exif;

  /*
    Set EXIF resolution tag.
  */
  length=GetStringInfoLength(profile);
  exif=GetStringInfoDatum(profile);
  if (length < 16)
    return(MagickFalse);
  id=(ssize_t) ReadProfileShort(LSBEndian,exif);
  if ((id != 0x4949) && (id != 0x4D4D))
    {
      while (length != 0)
      {
        if (ReadProfileByte(&exif,&length) != 0x45)
          continue;
        if (ReadProfileByte(&exif,&length) != 0x78)
          continue;
        if (ReadProfileByte(&exif,&length) != 0x69)
          continue;
        if (ReadProfileByte(&exif,&length) != 0x66)
          continue;
        if (ReadProfileByte(&exif,&length) != 0x00)
          continue;
        if (ReadProfileByte(&exif,&length) != 0x00)
          continue;
        break;
      }
      if (length < 16)
        return(MagickFalse);
      id=(ssize_t) ReadProfileShort(LSBEndian,exif);
    }
  endian=LSBEndian;
  if (id == 0x4949)
    endian=LSBEndian;
  else
    if (id == 0x4D4D)
      endian=MSBEndian;
    else
      return(MagickFalse);
  if (ReadProfileShort(endian,exif+2) != 0x002a)
    return(MagickFalse);
  /*
    This the offset to the first IFD.
  */
  offset=(ssize_t) ReadProfileLong(endian,exif+4);
  if ((offset < 0) || ((size_t) offset >= length))
    return(MagickFalse);
  directory=exif+offset;
  level=0;
  entry=0;
  exif_resources=NewSplayTree((int (*)(const void *,const void *)) NULL,
    (void *(*)(void *)) NULL,(void *(*)(void *)) NULL);
  do
  {
    if (level > 0)
      {
        level--;
        directory=directory_stack[level].directory;
        entry=directory_stack[level].entry;
      }
    if ((directory < exif) || (directory > (exif+length-2)))
      break;
    /*
      Determine how many entries there are in the current IFD.
    */
    number_entries=ReadProfileShort(endian,directory);
    for ( ; entry < number_entries; entry++)
    {
      register unsigned char
        *p,
        *q;

      size_t
        number_bytes;

      ssize_t
        components,
        format,
        tag_value;

      q=(unsigned char *) (directory+2+(12*entry));
      if (q > (exif+length-12))
        break;  /* corrupt EXIF */
      if (GetValueFromSplayTree(exif_resources,q) == q)
        break;
      (void) AddValueToSplayTree(exif_resources,q,q);
      tag_value=(ssize_t) ReadProfileShort(endian,q);
      format=(ssize_t) ReadProfileShort(endian,q+2);
      if ((format < 0) || ((format-1) >= EXIF_NUM_FORMATS))
        break;
      components=(ssize_t) ReadProfileLong(endian,q+4);
      if (components < 0)
        break;  /* corrupt EXIF */
      number_bytes=(size_t) components*format_bytes[format];
      if ((ssize_t) number_bytes < components)
        break;  /* prevent overflow */
      if (number_bytes <= 4)
        p=q+8;
      else
        {
          /*
             The directory entry contains an offset.
           */
           offset=(ssize_t) ReadProfileLong(endian,q+8);
          if ((ssize_t) (offset+number_bytes) < offset)
            continue;  /* prevent overflow */
          if ((size_t) (offset+number_bytes) > length)
             continue;
           p=(unsigned char *) (exif+offset);
         }
       switch (tag_value)
      {
        case 0x011a:
        {
          (void) WriteProfileLong(endian,(size_t) (image->x_resolution+0.5),p);
          (void) WriteProfileLong(endian,1UL,p+4);
          break;
        }
        case 0x011b:
        {
          (void) WriteProfileLong(endian,(size_t) (image->y_resolution+0.5),p);
          (void) WriteProfileLong(endian,1UL,p+4);
          break;
        }
        case 0x0112:
        {
          if (number_bytes == 4)
            {
              (void) WriteProfileLong(endian,(size_t) image->orientation,p);
              break;
            }
          (void) WriteProfileShort(endian,(unsigned short) image->orientation,
            p);
          break;
        }
        case 0x0128:
        {
          if (number_bytes == 4)
            {
              (void) WriteProfileLong(endian,(size_t) (image->units+1),p);
              break;
            }
          (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);
          break;
        }
        default:
          break;
      }
      if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))
        {
          offset=(ssize_t) ReadProfileLong(endian,p);
          if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))
            {
              directory_stack[level].directory=directory;
              entry++;
              directory_stack[level].entry=entry;
              level++;
              directory_stack[level].directory=exif+offset;
              directory_stack[level].entry=0;
              level++;
              if ((directory+2+(12*number_entries)) > (exif+length))
                break;
              offset=(ssize_t) ReadProfileLong(endian,directory+2+(12*
                number_entries));
              if ((offset != 0) && ((size_t) offset < length) &&
                  (level < (MaxDirectoryStack-2)))
                {
                  directory_stack[level].directory=exif+offset;
                  directory_stack[level].entry=0;
                  level++;
                }
            }
          break;
        }
    }
  } while (level > 0);
  exif_resources=DestroySplayTree(exif_resources);
  return(MagickTrue);
}
",C,"          if ((offset < 0) || ((size_t) (offset+number_bytes) > length))
          if (~length < number_bytes)
            continue;  /* prevent overflow */
","          if ((ssize_t) (offset+number_bytes) < offset)
            continue;  /* prevent overflow */
          if ((size_t) (offset+number_bytes) > length)
",,"@@ -2071,10 +2071,10 @@ static MagickBooleanType SyncExifProfile(Image *image, StringInfo *profile)
             The directory entry contains an offset.
           */
           offset=(ssize_t) ReadProfileLong(endian,q+8);
-          if ((ssize_t) (offset+number_bytes) < offset)
-            continue;  /* prevent overflow */
-          if ((size_t) (offset+number_bytes) > length)
+          if ((offset < 0) || ((size_t) (offset+number_bytes) > length))
             continue;
+          if (~length < number_bytes)
+            continue;  /* prevent overflow */
           p=(unsigned char *) (exif+offset);
         }
       switch (tag_value)",ImageMagick,6235f1f7a9f7b0f83b197f6cd0073dbb6602d0fb,c9da43d6e2f1da3fba25035dafdb6646627b23b3,1,"static MagickBooleanType SyncExifProfile(Image *image, StringInfo *profile)
{
#define MaxDirectoryStack  16
#define EXIF_DELIMITER  ""\n""
#define EXIF_NUM_FORMATS  12
#define TAG_EXIF_OFFSET  0x8769
#define TAG_INTEROP_OFFSET  0xa005

  typedef struct _DirectoryInfo
  {
    unsigned char
      *directory;

    size_t
      entry;
  } DirectoryInfo;

  DirectoryInfo
    directory_stack[MaxDirectoryStack];

  EndianType
    endian;

  size_t
    entry,
    length,
    number_entries;

  SplayTreeInfo
    *exif_resources;

  ssize_t
    id,
    level,
    offset;

  static int
    format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};

  unsigned char
    *directory,
    *exif;

  /*
    Set EXIF resolution tag.
  */
  length=GetStringInfoLength(profile);
  exif=GetStringInfoDatum(profile);
  if (length < 16)
    return(MagickFalse);
  id=(ssize_t) ReadProfileShort(LSBEndian,exif);
  if ((id != 0x4949) && (id != 0x4D4D))
    {
      while (length != 0)
      {
        if (ReadProfileByte(&exif,&length) != 0x45)
          continue;
        if (ReadProfileByte(&exif,&length) != 0x78)
          continue;
        if (ReadProfileByte(&exif,&length) != 0x69)
          continue;
        if (ReadProfileByte(&exif,&length) != 0x66)
          continue;
        if (ReadProfileByte(&exif,&length) != 0x00)
          continue;
        if (ReadProfileByte(&exif,&length) != 0x00)
          continue;
        break;
      }
      if (length < 16)
        return(MagickFalse);
      id=(ssize_t) ReadProfileShort(LSBEndian,exif);
    }
  endian=LSBEndian;
  if (id == 0x4949)
    endian=LSBEndian;
  else
    if (id == 0x4D4D)
      endian=MSBEndian;
    else
      return(MagickFalse);
  if (ReadProfileShort(endian,exif+2) != 0x002a)
    return(MagickFalse);
  /*
    This the offset to the first IFD.
  */
  offset=(ssize_t) ReadProfileLong(endian,exif+4);
  if ((offset < 0) || ((size_t) offset >= length))
    return(MagickFalse);
  directory=exif+offset;
  level=0;
  entry=0;
  exif_resources=NewSplayTree((int (*)(const void *,const void *)) NULL,
    (void *(*)(void *)) NULL,(void *(*)(void *)) NULL);
  do
  {
    if (level > 0)
      {
        level--;
        directory=directory_stack[level].directory;
        entry=directory_stack[level].entry;
      }
    if ((directory < exif) || (directory > (exif+length-2)))
      break;
    /*
      Determine how many entries there are in the current IFD.
    */
    number_entries=ReadProfileShort(endian,directory);
    for ( ; entry < number_entries; entry++)
    {
      register unsigned char
        *p,
        *q;

      size_t
        number_bytes;

      ssize_t
        components,
        format,
        tag_value;

      q=(unsigned char *) (directory+2+(12*entry));
      if (q > (exif+length-12))
        break;  /* corrupt EXIF */
      if (GetValueFromSplayTree(exif_resources,q) == q)
        break;
      (void) AddValueToSplayTree(exif_resources,q,q);
      tag_value=(ssize_t) ReadProfileShort(endian,q);
      format=(ssize_t) ReadProfileShort(endian,q+2);
      if ((format < 0) || ((format-1) >= EXIF_NUM_FORMATS))
        break;
      components=(ssize_t) ReadProfileLong(endian,q+4);
      if (components < 0)
        break;  /* corrupt EXIF */
      number_bytes=(size_t) components*format_bytes[format];
      if ((ssize_t) number_bytes < components)
        break;  /* prevent overflow */
      if (number_bytes <= 4)
        p=q+8;
      else
        {
          /*
             The directory entry contains an offset.
           */
           offset=(ssize_t) ReadProfileLong(endian,q+8);
//flaw_line_below:
          if ((ssize_t) (offset+number_bytes) < offset)
//flaw_line_below:
            continue;  /* prevent overflow */
//flaw_line_below:
          if ((size_t) (offset+number_bytes) > length)
//fix_flaw_line_below:
//          if ((offset < 0) || ((size_t) (offset+number_bytes) > length))
             continue;
//fix_flaw_line_below:
//          if (~length < number_bytes)
//fix_flaw_line_below:
//            continue;  /* prevent overflow */
           p=(unsigned char *) (exif+offset);
         }
       switch (tag_value)
      {
        case 0x011a:
        {
          (void) WriteProfileLong(endian,(size_t) (image->x_resolution+0.5),p);
          (void) WriteProfileLong(endian,1UL,p+4);
          break;
        }
        case 0x011b:
        {
          (void) WriteProfileLong(endian,(size_t) (image->y_resolution+0.5),p);
          (void) WriteProfileLong(endian,1UL,p+4);
          break;
        }
        case 0x0112:
        {
          if (number_bytes == 4)
            {
              (void) WriteProfileLong(endian,(size_t) image->orientation,p);
              break;
            }
          (void) WriteProfileShort(endian,(unsigned short) image->orientation,
            p);
          break;
        }
        case 0x0128:
        {
          if (number_bytes == 4)
            {
              (void) WriteProfileLong(endian,(size_t) (image->units+1),p);
              break;
            }
          (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);
          break;
        }
        default:
          break;
      }
      if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))
        {
          offset=(ssize_t) ReadProfileLong(endian,p);
          if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))
            {
              directory_stack[level].directory=directory;
              entry++;
              directory_stack[level].entry=entry;
              level++;
              directory_stack[level].directory=exif+offset;
              directory_stack[level].entry=0;
              level++;
              if ((directory+2+(12*number_entries)) > (exif+length))
                break;
              offset=(ssize_t) ReadProfileLong(endian,directory+2+(12*
                number_entries));
              if ((offset != 0) && ((size_t) offset < length) &&
                  (level < (MaxDirectoryStack-2)))
                {
                  directory_stack[level].directory=exif+offset;
                  directory_stack[level].entry=0;
                  level++;
                }
            }
          break;
        }
    }
  } while (level > 0);
  exif_resources=DestroySplayTree(exif_resources);
  return(MagickTrue);
}
"
4195,181931,,Remote,Not required,Partial,CVE-2016-8693,https://www.cvedetails.com/cve/CVE-2016-8693/,CWE-415,Medium,Partial,Partial,,2017-02-15,6.8,Double free vulnerability in the mem_close function in jas_stream.c in JasPer before 1.900.10 allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a crafted BMP image to the imginfo command.,2018-10-30,DoS Exec Code ,3,https://github.com/mdadams/jasper/commit/44a524e367597af58d6265ae2014468b334d0309,44a524e367597af58d6265ae2014468b334d0309,"The memory stream interface allows for a buffer size of zero.
The case of a zero-sized buffer was not handled correctly, as it could
lead to a double free.
This problem has now been fixed (hopefully).
One might ask whether a zero-sized buffer should be allowed at all,
but this is a question for another day.",2,src/libjasper/base/jas_stream.c,"{""sha"": ""29e4291cb689b003502e1df40ba4c4b47af9df84"", ""filename"": ""src/libjasper/base/jas_stream.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/mdadams/jasper/blob/44a524e367597af58d6265ae2014468b334d0309/src/libjasper/base/jas_stream.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/44a524e367597af58d6265ae2014468b334d0309/src/libjasper/base/jas_stream.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/base/jas_stream.c?ref=44a524e367597af58d6265ae2014468b334d0309"", ""patch"": ""@@ -993,9 +993,10 @@ static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n {\n \tunsigned char *buf;\n \n-\tassert(m->buf_);\n+\t//assert(m->buf_);\n \tassert(bufsize >= 0);\n-\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {\n+\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n+\t  bufsize) {\n \t\treturn -1;\n \t}\n \tm->buf_ = buf;""}","static int mem_resize(jas_stream_memobj_t *m, int bufsize)
 {
 	unsigned char *buf;
 
	//assert(m->buf_);
 	assert(bufsize >= 0);
	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
	  bufsize) {
 		return -1;
 	}
 	m->buf_ = buf;
	m->bufsize_ = bufsize;
	return 0;
}
","static int mem_resize(jas_stream_memobj_t *m, int bufsize)
 {
 	unsigned char *buf;
 
	assert(m->buf_);
 	assert(bufsize >= 0);
	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {
 		return -1;
 	}
 	m->buf_ = buf;
	m->bufsize_ = bufsize;
	return 0;
}
",C,"	//assert(m->buf_);
	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
	  bufsize) {
","	assert(m->buf_);
	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {
",,"@@ -993,9 +993,10 @@ static int mem_resize(jas_stream_memobj_t *m, int bufsize)
 {
 	unsigned char *buf;
 
-	assert(m->buf_);
+	//assert(m->buf_);
 	assert(bufsize >= 0);
-	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {
+	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
+	  bufsize) {
 		return -1;
 	}
 	m->buf_ = buf;",jasper,44a524e367597af58d6265ae2014468b334d0309,efb88eb83089dcbfe0ae9d0de504b6fa24c1bc27,1,"static int mem_resize(jas_stream_memobj_t *m, int bufsize)
 {
 	unsigned char *buf;
 
//flaw_line_below:
	assert(m->buf_);
//fix_flaw_line_below:
//	//assert(m->buf_);
 	assert(bufsize >= 0);
//flaw_line_below:
	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {
//fix_flaw_line_below:
//	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
//fix_flaw_line_below:
//	  bufsize) {
 		return -1;
 	}
 	m->buf_ = buf;
	m->bufsize_ = bufsize;
	return 0;
}
"
4252,181988,,Remote,Not required,Partial,CVE-2016-6912,https://www.cvedetails.com/cve/CVE-2016-6912/,CWE-415,Low,Partial,Partial,,2017-01-26,7.5,Double free vulnerability in the gdImageWebPtr function in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to have unspecified impact via large width and height values.,2017-11-03,,1,https://github.com/libgd/libgd/commit/a49feeae76d41959d85ee733925a4cf40bac61b2,a49feeae76d41959d85ee733925a4cf40bac61b2,"Fix double-free in gdImageWebPtr()

The issue is that gdImageWebpCtx() (which is called by gdImageWebpPtr() and
the other WebP output functions to do the real work) does not return whether
it succeeded or failed, so this is not checked in gdImageWebpPtr() and the
function wrongly assumes everything is okay, which is not, in this case,
because there is a size limitation for WebP, namely that the width and
height must by less than 16383.

We can't change the signature of gdImageWebpCtx() for API compatibility
reasons, so we introduce the static helper _gdImageWebpCtx() which returns
success respective failure, so gdImageWebpPtr() and gdImageWebpPtrEx() can
check the return value. We leave it solely to libwebp for now to report
warnings regarding the failing write.

This issue had been reported by Ibrahim El-Sayed to security@libgd.org.

CVE-2016-6912",1,src/gd_webp.c,"{""sha"": ""b5ee2642634e55eb650e32638ae27272e564b07f"", ""filename"": ""src/gd_webp.c"", ""status"": ""modified"", ""additions"": 46, ""deletions"": 28, ""changes"": 74, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/src/gd_webp.c"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/src/gd_webp.c"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/src/gd_webp.c?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -162,54 +162,41 @@ BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpCtx (gdIOCtx * infile)\n \treturn im;\n }\n \n-/*\n-  Function: gdImageWebpCtx\n-\n-    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>\n-    for more details.\n-\n-  Parameters:\n-\n-    im      - The image to write.\n-    outfile - The output sink.\n-    quality - Image quality.\n \n-  Returns:\n-\n-    Nothing.\n-*/\n-BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n {\n \tuint8_t *argb;\n \tint x, y;\n \tuint8_t *p;\n \tuint8_t *out;\n \tsize_t out_size;\n+    int ret = 0;\n \n \tif (im == NULL) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \tif (!gdImageTrueColor(im)) {\n-\t\tgd_error(\""Paletter image not supported by webp\"");\n-\t\treturn;\n+\t\tgd_error(\""Palette image not supported by webp\"");\n+\t\treturn 1;\n \t}\n \n \tif (quality == -1) {\n \t\tquality = 80;\n \t}\n \n \tif (overflow2(gdImageSX(im), 4)) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n \tif (!argb) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \tp = argb;\n \tfor (y = 0; y < gdImageSY(im); y++) {\n@@ -232,13 +219,38 @@ BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n \tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n \tif (out_size == 0) {\n \t\tgd_error(\""gd-webp encoding failed\"");\n+        ret = 1;\n \t\tgoto freeargb;\n \t}\n \tgdPutBuf(out, out_size, outfile);\n \tfree(out);\n \n freeargb:\n \tgdFree(argb);\n+\n+    return ret;\n+}\n+\n+\n+/*\n+  Function: gdImageWebpCtx\n+\n+    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>\n+    for more details.\n+\n+  Parameters:\n+\n+    im      - The image to write.\n+    outfile - The output sink.\n+    quality - Image quality.\n+\n+  Returns:\n+\n+    Nothing.\n+*/\n+BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n+{\n+\t_gdImageWebpCtx(im, outfile, quality);\n }\n \n /*\n@@ -278,7 +290,7 @@ BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n \tif (out == NULL) {\n \t\treturn;\n \t}\n-\tgdImageWebpCtx(im, out, quality);\n+\t_gdImageWebpCtx(im, out, quality);\n \tout->gd_free(out);\n }\n \n@@ -302,7 +314,7 @@ BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n \tif (out == NULL) {\n \t\treturn;\n \t}\n-\tgdImageWebpCtx(im, out, -1);\n+\t_gdImageWebpCtx(im, out, -1);\n \tout->gd_free(out);\n }\n \n@@ -318,8 +330,11 @@ BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n \tif (out == NULL) {\n \t\treturn NULL;\n \t}\n-\tgdImageWebpCtx(im, out, -1);\n-\trv = gdDPExtractData(out, size);\n+\tif (_gdImageWebpCtx(im, out, -1)) {\n+\t\trv = NULL;\n+\t} else {\n+\t\trv = gdDPExtractData(out, size);\n+\t}\n \tout->gd_free(out);\n \n \treturn rv;\n@@ -337,8 +352,11 @@ BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n \tif (out == NULL) {\n \t\treturn NULL;\n \t}\n-\tgdImageWebpCtx(im, out, quality);\n-\trv = gdDPExtractData(out, size);\n+\tif (_gdImageWebpCtx(im, out, quality)) {\n+        rv = NULL;\n+    } else {\n+        rv = gdDPExtractData(out, size);\n+    }\n \tout->gd_free(out);\n \treturn rv;\n }""}<_**next**_>{""sha"": ""569ccda8b7da0bcee30be6cb003e1ec807dc2bda"", ""filename"": ""tests/webp/.gitignore"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/.gitignore"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/.gitignore"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/.gitignore?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -1 +1,2 @@\n /bug00111\n+/bug_double_free""}<_**next**_>{""sha"": ""ec27127b1d63cb86f42194c10c18f964f311d9ff"", ""filename"": ""tests/webp/CMakeLists.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/CMakeLists.txt"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/CMakeLists.txt"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/CMakeLists.txt?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -1,6 +1,7 @@\n IF(WEBP_FOUND)\n LIST(APPEND TESTS_FILES\n \tbug00111\n+\tbug_double_free\n )\n ENDIF(WEBP_FOUND)\n ""}<_**next**_>{""sha"": ""f01f9e672fcfb8fd70c20d79a74ca987d9a208df"", ""filename"": ""tests/webp/Makemodule.am"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/Makemodule.am"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/Makemodule.am"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/Makemodule.am?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -1,7 +1,9 @@\n if HAVE_LIBWEBP\n libgd_test_programs += \\\n-\twebp/bug00111\n+\twebp/bug00111 \\\n+\twebp/bug_double_free\n endif\n \n EXTRA_DIST += \\\n-\twebp/CMakeLists.txt\n+\twebp/CMakeLists.txt \\\n+\twebp/bug_double_free.jpg""}<_**next**_>{""sha"": ""43eececfc19e35d6ba72e0be2f3e6198ace8e2f3"", ""filename"": ""tests/webp/bug_double_free.c"", ""status"": ""added"", ""additions"": 29, ""deletions"": 0, ""changes"": 29, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/bug_double_free.c"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/bug_double_free.c"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/bug_double_free.c?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -0,0 +1,29 @@\n+/**\n+ * Test that a too large image doesn't trigger an double-free when written\n+ * to memory.\n+ */\n+\n+\n+#include \""gd.h\""\n+#include \""gdtest.h\""\n+\n+\n+int main()\n+{\n+    gdImagePtr im1, im2;\n+    FILE *fp;\n+    int size;\n+\n+    fp = gdTestFileOpen2(\""webp\"", \""bug_double_free.jpg\"");\n+    gdTestAssert(fp != NULL);\n+    im1 = gdImageCreateFromJpeg(fp);\n+    gdTestAssert(im1 != NULL);\n+    fclose(fp);\n+\n+    im2 = gdImageWebpPtr(im1, &size);\n+    gdTestAssert(im2 == NULL);\n+\n+    gdImageDestroy(im1);\n+\n+    return gdNumFailures();\n+}""}<_**next**_>{""sha"": ""9b792fb4a7d17578b445af1ba530e4df7ac47df1"", ""filename"": ""tests/webp/bug_double_free.jpg"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/bug_double_free.jpg"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/bug_double_free.jpg"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/bug_double_free.jpg?ref=a49feeae76d41959d85ee733925a4cf40bac61b2""}","BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)
{
	gdIOCtx *out = gdNewFileCtx(outFile);
 	if (out == NULL) {
 		return;
 	}
	_gdImageWebpCtx(im, out, -1);
 	out->gd_free(out);
 }
","BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)
{
	gdIOCtx *out = gdNewFileCtx(outFile);
 	if (out == NULL) {
 		return;
 	}
	gdImageWebpCtx(im, out, -1);
 	out->gd_free(out);
 }
",C,"	_gdImageWebpCtx(im, out, -1);
","	gdImageWebpCtx(im, out, -1);
",,"@@ -162,54 +162,41 @@ BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpCtx (gdIOCtx * infile)
 	return im;
 }
 
-/*
-  Function: gdImageWebpCtx
-
-    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>
-    for more details.
-
-  Parameters:
-
-    im      - The image to write.
-    outfile - The output sink.
-    quality - Image quality.
 
-  Returns:
-
-    Nothing.
-*/
-BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
+/* returns 0 on success, 1 on failure */
+static int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
 {
 	uint8_t *argb;
 	int x, y;
 	uint8_t *p;
 	uint8_t *out;
 	size_t out_size;
+    int ret = 0;
 
 	if (im == NULL) {
-		return;
+		return 1;
 	}
 
 	if (!gdImageTrueColor(im)) {
-		gd_error(""Paletter image not supported by webp"");
-		return;
+		gd_error(""Palette image not supported by webp"");
+		return 1;
 	}
 
 	if (quality == -1) {
 		quality = 80;
 	}
 
 	if (overflow2(gdImageSX(im), 4)) {
-		return;
+		return 1;
 	}
 
 	if (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {
-		return;
+		return 1;
 	}
 
 	argb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));
 	if (!argb) {
-		return;
+		return 1;
 	}
 	p = argb;
 	for (y = 0; y < gdImageSY(im); y++) {
@@ -232,13 +219,38 @@ BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
 	out_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);
 	if (out_size == 0) {
 		gd_error(""gd-webp encoding failed"");
+        ret = 1;
 		goto freeargb;
 	}
 	gdPutBuf(out, out_size, outfile);
 	free(out);
 
 freeargb:
 	gdFree(argb);
+
+    return ret;
+}
+
+
+/*
+  Function: gdImageWebpCtx
+
+    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>
+    for more details.
+
+  Parameters:
+
+    im      - The image to write.
+    outfile - The output sink.
+    quality - Image quality.
+
+  Returns:
+
+    Nothing.
+*/
+BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
+{
+	_gdImageWebpCtx(im, outfile, quality);
 }
 
 /*
@@ -278,7 +290,7 @@ BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)
 	if (out == NULL) {
 		return;
 	}
-	gdImageWebpCtx(im, out, quality);
+	_gdImageWebpCtx(im, out, quality);
 	out->gd_free(out);
 }
 
@@ -302,7 +314,7 @@ BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)
 	if (out == NULL) {
 		return;
 	}
-	gdImageWebpCtx(im, out, -1);
+	_gdImageWebpCtx(im, out, -1);
 	out->gd_free(out);
 }
 
@@ -318,8 +330,11 @@ BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)
 	if (out == NULL) {
 		return NULL;
 	}
-	gdImageWebpCtx(im, out, -1);
-	rv = gdDPExtractData(out, size);
+	if (_gdImageWebpCtx(im, out, -1)) {
+		rv = NULL;
+	} else {
+		rv = gdDPExtractData(out, size);
+	}
 	out->gd_free(out);
 
 	return rv;
@@ -337,8 +352,11 @@ BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
 	if (out == NULL) {
 		return NULL;
 	}
-	gdImageWebpCtx(im, out, quality);
-	rv = gdDPExtractData(out, size);
+	if (_gdImageWebpCtx(im, out, quality)) {
+        rv = NULL;
+    } else {
+        rv = gdDPExtractData(out, size);
+    }
 	out->gd_free(out);
 	return rv;
 }",libgd,a49feeae76d41959d85ee733925a4cf40bac61b2,4859d69e07504d4b0a4bdf9bcb4d9e3769ca35ae,1,"BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)
{
	gdIOCtx *out = gdNewFileCtx(outFile);
 	if (out == NULL) {
 		return;
 	}
//flaw_line_below:
	gdImageWebpCtx(im, out, -1);
//fix_flaw_line_below:
//	_gdImageWebpCtx(im, out, -1);
 	out->gd_free(out);
 }
"
4253,181989,,Remote,Not required,Partial,CVE-2016-6912,https://www.cvedetails.com/cve/CVE-2016-6912/,CWE-415,Low,Partial,Partial,,2017-01-26,7.5,Double free vulnerability in the gdImageWebPtr function in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to have unspecified impact via large width and height values.,2017-11-03,,34,https://github.com/libgd/libgd/commit/a49feeae76d41959d85ee733925a4cf40bac61b2,a49feeae76d41959d85ee733925a4cf40bac61b2,"Fix double-free in gdImageWebPtr()

The issue is that gdImageWebpCtx() (which is called by gdImageWebpPtr() and
the other WebP output functions to do the real work) does not return whether
it succeeded or failed, so this is not checked in gdImageWebpPtr() and the
function wrongly assumes everything is okay, which is not, in this case,
because there is a size limitation for WebP, namely that the width and
height must by less than 16383.

We can't change the signature of gdImageWebpCtx() for API compatibility
reasons, so we introduce the static helper _gdImageWebpCtx() which returns
success respective failure, so gdImageWebpPtr() and gdImageWebpPtrEx() can
check the return value. We leave it solely to libwebp for now to report
warnings regarding the failing write.

This issue had been reported by Ibrahim El-Sayed to security@libgd.org.

CVE-2016-6912",6,src/gd_webp.c,"{""sha"": ""b5ee2642634e55eb650e32638ae27272e564b07f"", ""filename"": ""src/gd_webp.c"", ""status"": ""modified"", ""additions"": 46, ""deletions"": 28, ""changes"": 74, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/src/gd_webp.c"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/src/gd_webp.c"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/src/gd_webp.c?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -162,54 +162,41 @@ BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpCtx (gdIOCtx * infile)\n \treturn im;\n }\n \n-/*\n-  Function: gdImageWebpCtx\n-\n-    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>\n-    for more details.\n-\n-  Parameters:\n-\n-    im      - The image to write.\n-    outfile - The output sink.\n-    quality - Image quality.\n \n-  Returns:\n-\n-    Nothing.\n-*/\n-BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n {\n \tuint8_t *argb;\n \tint x, y;\n \tuint8_t *p;\n \tuint8_t *out;\n \tsize_t out_size;\n+    int ret = 0;\n \n \tif (im == NULL) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \tif (!gdImageTrueColor(im)) {\n-\t\tgd_error(\""Paletter image not supported by webp\"");\n-\t\treturn;\n+\t\tgd_error(\""Palette image not supported by webp\"");\n+\t\treturn 1;\n \t}\n \n \tif (quality == -1) {\n \t\tquality = 80;\n \t}\n \n \tif (overflow2(gdImageSX(im), 4)) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n \tif (!argb) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \tp = argb;\n \tfor (y = 0; y < gdImageSY(im); y++) {\n@@ -232,13 +219,38 @@ BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n \tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n \tif (out_size == 0) {\n \t\tgd_error(\""gd-webp encoding failed\"");\n+        ret = 1;\n \t\tgoto freeargb;\n \t}\n \tgdPutBuf(out, out_size, outfile);\n \tfree(out);\n \n freeargb:\n \tgdFree(argb);\n+\n+    return ret;\n+}\n+\n+\n+/*\n+  Function: gdImageWebpCtx\n+\n+    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>\n+    for more details.\n+\n+  Parameters:\n+\n+    im      - The image to write.\n+    outfile - The output sink.\n+    quality - Image quality.\n+\n+  Returns:\n+\n+    Nothing.\n+*/\n+BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n+{\n+\t_gdImageWebpCtx(im, outfile, quality);\n }\n \n /*\n@@ -278,7 +290,7 @@ BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n \tif (out == NULL) {\n \t\treturn;\n \t}\n-\tgdImageWebpCtx(im, out, quality);\n+\t_gdImageWebpCtx(im, out, quality);\n \tout->gd_free(out);\n }\n \n@@ -302,7 +314,7 @@ BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n \tif (out == NULL) {\n \t\treturn;\n \t}\n-\tgdImageWebpCtx(im, out, -1);\n+\t_gdImageWebpCtx(im, out, -1);\n \tout->gd_free(out);\n }\n \n@@ -318,8 +330,11 @@ BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n \tif (out == NULL) {\n \t\treturn NULL;\n \t}\n-\tgdImageWebpCtx(im, out, -1);\n-\trv = gdDPExtractData(out, size);\n+\tif (_gdImageWebpCtx(im, out, -1)) {\n+\t\trv = NULL;\n+\t} else {\n+\t\trv = gdDPExtractData(out, size);\n+\t}\n \tout->gd_free(out);\n \n \treturn rv;\n@@ -337,8 +352,11 @@ BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n \tif (out == NULL) {\n \t\treturn NULL;\n \t}\n-\tgdImageWebpCtx(im, out, quality);\n-\trv = gdDPExtractData(out, size);\n+\tif (_gdImageWebpCtx(im, out, quality)) {\n+        rv = NULL;\n+    } else {\n+        rv = gdDPExtractData(out, size);\n+    }\n \tout->gd_free(out);\n \treturn rv;\n }""}<_**next**_>{""sha"": ""569ccda8b7da0bcee30be6cb003e1ec807dc2bda"", ""filename"": ""tests/webp/.gitignore"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/.gitignore"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/.gitignore"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/.gitignore?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -1 +1,2 @@\n /bug00111\n+/bug_double_free""}<_**next**_>{""sha"": ""ec27127b1d63cb86f42194c10c18f964f311d9ff"", ""filename"": ""tests/webp/CMakeLists.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/CMakeLists.txt"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/CMakeLists.txt"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/CMakeLists.txt?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -1,6 +1,7 @@\n IF(WEBP_FOUND)\n LIST(APPEND TESTS_FILES\n \tbug00111\n+\tbug_double_free\n )\n ENDIF(WEBP_FOUND)\n ""}<_**next**_>{""sha"": ""f01f9e672fcfb8fd70c20d79a74ca987d9a208df"", ""filename"": ""tests/webp/Makemodule.am"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/Makemodule.am"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/Makemodule.am"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/Makemodule.am?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -1,7 +1,9 @@\n if HAVE_LIBWEBP\n libgd_test_programs += \\\n-\twebp/bug00111\n+\twebp/bug00111 \\\n+\twebp/bug_double_free\n endif\n \n EXTRA_DIST += \\\n-\twebp/CMakeLists.txt\n+\twebp/CMakeLists.txt \\\n+\twebp/bug_double_free.jpg""}<_**next**_>{""sha"": ""43eececfc19e35d6ba72e0be2f3e6198ace8e2f3"", ""filename"": ""tests/webp/bug_double_free.c"", ""status"": ""added"", ""additions"": 29, ""deletions"": 0, ""changes"": 29, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/bug_double_free.c"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/bug_double_free.c"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/bug_double_free.c?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -0,0 +1,29 @@\n+/**\n+ * Test that a too large image doesn't trigger an double-free when written\n+ * to memory.\n+ */\n+\n+\n+#include \""gd.h\""\n+#include \""gdtest.h\""\n+\n+\n+int main()\n+{\n+    gdImagePtr im1, im2;\n+    FILE *fp;\n+    int size;\n+\n+    fp = gdTestFileOpen2(\""webp\"", \""bug_double_free.jpg\"");\n+    gdTestAssert(fp != NULL);\n+    im1 = gdImageCreateFromJpeg(fp);\n+    gdTestAssert(im1 != NULL);\n+    fclose(fp);\n+\n+    im2 = gdImageWebpPtr(im1, &size);\n+    gdTestAssert(im2 == NULL);\n+\n+    gdImageDestroy(im1);\n+\n+    return gdNumFailures();\n+}""}<_**next**_>{""sha"": ""9b792fb4a7d17578b445af1ba530e4df7ac47df1"", ""filename"": ""tests/webp/bug_double_free.jpg"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/bug_double_free.jpg"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/bug_double_free.jpg"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/bug_double_free.jpg?ref=a49feeae76d41959d85ee733925a4cf40bac61b2""}","BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
/* returns 0 on success, 1 on failure */
static int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
 {
 	uint8_t *argb;
 	int x, y;
 	uint8_t *p;
 	uint8_t *out;
 	size_t out_size;
    int ret = 0;
 
 	if (im == NULL) {
		return 1;
 	}
 
 	if (!gdImageTrueColor(im)) {
		gd_error(""Palette image not supported by webp"");
		return 1;
 	}
 
 	if (quality == -1) {
 		quality = 80;
 	}
 
 	if (overflow2(gdImageSX(im), 4)) {
		return 1;
 	}
 
 	if (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {
		return 1;
 	}
 
 	argb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));
 	if (!argb) {
		return 1;
 	}
 	p = argb;
 	for (y = 0; y < gdImageSY(im); y++) {
		for (x = 0; x < gdImageSX(im); x++) {
			register int c;
			register char a;
			c = im->tpixels[y][x];
			a = gdTrueColorGetAlpha(c);
			if (a == 127) {
				a = 0;
			} else {
				a = 255 - ((a << 1) + (a >> 6));
			}
			*(p++) = gdTrueColorGetRed(c);
			*(p++) = gdTrueColorGetGreen(c);
			*(p++) = gdTrueColorGetBlue(c); 
			*(p++) = a;
		}
	}
 	out_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);
 	if (out_size == 0) {
 		gd_error(""gd-webp encoding failed"");
        ret = 1;
 		goto freeargb;
 	}
 	gdPutBuf(out, out_size, outfile);
 	free(out);
 
 freeargb:
 	gdFree(argb);

    return ret;
}


/*
  Function: gdImageWebpCtx

    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>
    for more details.

  Parameters:

    im      - The image to write.
    outfile - The output sink.
    quality - Image quality.

  Returns:

    Nothing.
*/
BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
{
	_gdImageWebpCtx(im, outfile, quality);
 }
","BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
 {
 	uint8_t *argb;
 	int x, y;
 	uint8_t *p;
 	uint8_t *out;
 	size_t out_size;
 
 	if (im == NULL) {
		return;
 	}
 
 	if (!gdImageTrueColor(im)) {
		gd_error(""Paletter image not supported by webp"");
		return;
 	}
 
 	if (quality == -1) {
 		quality = 80;
 	}
 
 	if (overflow2(gdImageSX(im), 4)) {
		return;
 	}
 
 	if (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {
		return;
 	}
 
 	argb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));
 	if (!argb) {
		return;
 	}
 	p = argb;
 	for (y = 0; y < gdImageSY(im); y++) {
		for (x = 0; x < gdImageSX(im); x++) {
			register int c;
			register char a;
			c = im->tpixels[y][x];
			a = gdTrueColorGetAlpha(c);
			if (a == 127) {
				a = 0;
			} else {
				a = 255 - ((a << 1) + (a >> 6));
			}
			*(p++) = gdTrueColorGetRed(c);
			*(p++) = gdTrueColorGetGreen(c);
			*(p++) = gdTrueColorGetBlue(c); 
			*(p++) = a;
		}
	}
 	out_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);
 	if (out_size == 0) {
 		gd_error(""gd-webp encoding failed"");
 		goto freeargb;
 	}
 	gdPutBuf(out, out_size, outfile);
 	free(out);
 
 freeargb:
 	gdFree(argb);
 }
",C,"/* returns 0 on success, 1 on failure */
static int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
    int ret = 0;
		return 1;
		gd_error(""Palette image not supported by webp"");
		return 1;
		return 1;
		return 1;
		return 1;
        ret = 1;

    return ret;
}


/*
  Function: gdImageWebpCtx

    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>
    for more details.

  Parameters:

    im      - The image to write.
    outfile - The output sink.
    quality - Image quality.

  Returns:

    Nothing.
*/
BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
{
	_gdImageWebpCtx(im, outfile, quality);
","		return;
		gd_error(""Paletter image not supported by webp"");
		return;
		return;
		return;
		return;
",,"@@ -162,54 +162,41 @@ BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpCtx (gdIOCtx * infile)
 	return im;
 }
 
-/*
-  Function: gdImageWebpCtx
-
-    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>
-    for more details.
-
-  Parameters:
-
-    im      - The image to write.
-    outfile - The output sink.
-    quality - Image quality.
 
-  Returns:
-
-    Nothing.
-*/
-BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
+/* returns 0 on success, 1 on failure */
+static int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
 {
 	uint8_t *argb;
 	int x, y;
 	uint8_t *p;
 	uint8_t *out;
 	size_t out_size;
+    int ret = 0;
 
 	if (im == NULL) {
-		return;
+		return 1;
 	}
 
 	if (!gdImageTrueColor(im)) {
-		gd_error(""Paletter image not supported by webp"");
-		return;
+		gd_error(""Palette image not supported by webp"");
+		return 1;
 	}
 
 	if (quality == -1) {
 		quality = 80;
 	}
 
 	if (overflow2(gdImageSX(im), 4)) {
-		return;
+		return 1;
 	}
 
 	if (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {
-		return;
+		return 1;
 	}
 
 	argb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));
 	if (!argb) {
-		return;
+		return 1;
 	}
 	p = argb;
 	for (y = 0; y < gdImageSY(im); y++) {
@@ -232,13 +219,38 @@ BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
 	out_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);
 	if (out_size == 0) {
 		gd_error(""gd-webp encoding failed"");
+        ret = 1;
 		goto freeargb;
 	}
 	gdPutBuf(out, out_size, outfile);
 	free(out);
 
 freeargb:
 	gdFree(argb);
+
+    return ret;
+}
+
+
+/*
+  Function: gdImageWebpCtx
+
+    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>
+    for more details.
+
+  Parameters:
+
+    im      - The image to write.
+    outfile - The output sink.
+    quality - Image quality.
+
+  Returns:
+
+    Nothing.
+*/
+BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
+{
+	_gdImageWebpCtx(im, outfile, quality);
 }
 
 /*
@@ -278,7 +290,7 @@ BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)
 	if (out == NULL) {
 		return;
 	}
-	gdImageWebpCtx(im, out, quality);
+	_gdImageWebpCtx(im, out, quality);
 	out->gd_free(out);
 }
 
@@ -302,7 +314,7 @@ BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)
 	if (out == NULL) {
 		return;
 	}
-	gdImageWebpCtx(im, out, -1);
+	_gdImageWebpCtx(im, out, -1);
 	out->gd_free(out);
 }
 
@@ -318,8 +330,11 @@ BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)
 	if (out == NULL) {
 		return NULL;
 	}
-	gdImageWebpCtx(im, out, -1);
-	rv = gdDPExtractData(out, size);
+	if (_gdImageWebpCtx(im, out, -1)) {
+		rv = NULL;
+	} else {
+		rv = gdDPExtractData(out, size);
+	}
 	out->gd_free(out);
 
 	return rv;
@@ -337,8 +352,11 @@ BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
 	if (out == NULL) {
 		return NULL;
 	}
-	gdImageWebpCtx(im, out, quality);
-	rv = gdDPExtractData(out, size);
+	if (_gdImageWebpCtx(im, out, quality)) {
+        rv = NULL;
+    } else {
+        rv = gdDPExtractData(out, size);
+    }
 	out->gd_free(out);
 	return rv;
 }",libgd,a49feeae76d41959d85ee733925a4cf40bac61b2,4859d69e07504d4b0a4bdf9bcb4d9e3769ca35ae,1,"BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
//fix_flaw_line_below:
///* returns 0 on success, 1 on failure */
//fix_flaw_line_below:
//static int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
 {
 	uint8_t *argb;
 	int x, y;
 	uint8_t *p;
 	uint8_t *out;
 	size_t out_size;
//fix_flaw_line_below:
//    int ret = 0;
 
 	if (im == NULL) {
//flaw_line_below:
		return;
//fix_flaw_line_below:
//		return 1;
 	}
 
 	if (!gdImageTrueColor(im)) {
//flaw_line_below:
		gd_error(""Paletter image not supported by webp"");
//flaw_line_below:
		return;
//fix_flaw_line_below:
//		gd_error(""Palette image not supported by webp"");
//fix_flaw_line_below:
//		return 1;
 	}
 
 	if (quality == -1) {
 		quality = 80;
 	}
 
 	if (overflow2(gdImageSX(im), 4)) {
//flaw_line_below:
		return;
//fix_flaw_line_below:
//		return 1;
 	}
 
 	if (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {
//flaw_line_below:
		return;
//fix_flaw_line_below:
//		return 1;
 	}
 
 	argb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));
 	if (!argb) {
//flaw_line_below:
		return;
//fix_flaw_line_below:
//		return 1;
 	}
 	p = argb;
 	for (y = 0; y < gdImageSY(im); y++) {
		for (x = 0; x < gdImageSX(im); x++) {
			register int c;
			register char a;
			c = im->tpixels[y][x];
			a = gdTrueColorGetAlpha(c);
			if (a == 127) {
				a = 0;
			} else {
				a = 255 - ((a << 1) + (a >> 6));
			}
			*(p++) = gdTrueColorGetRed(c);
			*(p++) = gdTrueColorGetGreen(c);
			*(p++) = gdTrueColorGetBlue(c); 
			*(p++) = a;
		}
	}
 	out_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);
 	if (out_size == 0) {
 		gd_error(""gd-webp encoding failed"");
//fix_flaw_line_below:
//        ret = 1;
 		goto freeargb;
 	}
 	gdPutBuf(out, out_size, outfile);
 	free(out);
 
 freeargb:
 	gdFree(argb);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    return ret;
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//
//fix_flaw_line_below:
///*
//fix_flaw_line_below:
//  Function: gdImageWebpCtx
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>
//fix_flaw_line_below:
//    for more details.
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  Parameters:
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    im      - The image to write.
//fix_flaw_line_below:
//    outfile - The output sink.
//fix_flaw_line_below:
//    quality - Image quality.
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  Returns:
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    Nothing.
//fix_flaw_line_below:
//*/
//fix_flaw_line_below:
//BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
//fix_flaw_line_below:
//{
//fix_flaw_line_below:
//	_gdImageWebpCtx(im, outfile, quality);
 }
"
4254,181990,,Remote,Not required,Partial,CVE-2016-6912,https://www.cvedetails.com/cve/CVE-2016-6912/,CWE-415,Low,Partial,Partial,,2017-01-26,7.5,Double free vulnerability in the gdImageWebPtr function in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to have unspecified impact via large width and height values.,2017-11-03,,1,https://github.com/libgd/libgd/commit/a49feeae76d41959d85ee733925a4cf40bac61b2,a49feeae76d41959d85ee733925a4cf40bac61b2,"Fix double-free in gdImageWebPtr()

The issue is that gdImageWebpCtx() (which is called by gdImageWebpPtr() and
the other WebP output functions to do the real work) does not return whether
it succeeded or failed, so this is not checked in gdImageWebpPtr() and the
function wrongly assumes everything is okay, which is not, in this case,
because there is a size limitation for WebP, namely that the width and
height must by less than 16383.

We can't change the signature of gdImageWebpCtx() for API compatibility
reasons, so we introduce the static helper _gdImageWebpCtx() which returns
success respective failure, so gdImageWebpPtr() and gdImageWebpPtrEx() can
check the return value. We leave it solely to libwebp for now to report
warnings regarding the failing write.

This issue had been reported by Ibrahim El-Sayed to security@libgd.org.

CVE-2016-6912",1,src/gd_webp.c,"{""sha"": ""b5ee2642634e55eb650e32638ae27272e564b07f"", ""filename"": ""src/gd_webp.c"", ""status"": ""modified"", ""additions"": 46, ""deletions"": 28, ""changes"": 74, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/src/gd_webp.c"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/src/gd_webp.c"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/src/gd_webp.c?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -162,54 +162,41 @@ BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpCtx (gdIOCtx * infile)\n \treturn im;\n }\n \n-/*\n-  Function: gdImageWebpCtx\n-\n-    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>\n-    for more details.\n-\n-  Parameters:\n-\n-    im      - The image to write.\n-    outfile - The output sink.\n-    quality - Image quality.\n \n-  Returns:\n-\n-    Nothing.\n-*/\n-BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n {\n \tuint8_t *argb;\n \tint x, y;\n \tuint8_t *p;\n \tuint8_t *out;\n \tsize_t out_size;\n+    int ret = 0;\n \n \tif (im == NULL) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \tif (!gdImageTrueColor(im)) {\n-\t\tgd_error(\""Paletter image not supported by webp\"");\n-\t\treturn;\n+\t\tgd_error(\""Palette image not supported by webp\"");\n+\t\treturn 1;\n \t}\n \n \tif (quality == -1) {\n \t\tquality = 80;\n \t}\n \n \tif (overflow2(gdImageSX(im), 4)) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n \tif (!argb) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \tp = argb;\n \tfor (y = 0; y < gdImageSY(im); y++) {\n@@ -232,13 +219,38 @@ BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n \tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n \tif (out_size == 0) {\n \t\tgd_error(\""gd-webp encoding failed\"");\n+        ret = 1;\n \t\tgoto freeargb;\n \t}\n \tgdPutBuf(out, out_size, outfile);\n \tfree(out);\n \n freeargb:\n \tgdFree(argb);\n+\n+    return ret;\n+}\n+\n+\n+/*\n+  Function: gdImageWebpCtx\n+\n+    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>\n+    for more details.\n+\n+  Parameters:\n+\n+    im      - The image to write.\n+    outfile - The output sink.\n+    quality - Image quality.\n+\n+  Returns:\n+\n+    Nothing.\n+*/\n+BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n+{\n+\t_gdImageWebpCtx(im, outfile, quality);\n }\n \n /*\n@@ -278,7 +290,7 @@ BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n \tif (out == NULL) {\n \t\treturn;\n \t}\n-\tgdImageWebpCtx(im, out, quality);\n+\t_gdImageWebpCtx(im, out, quality);\n \tout->gd_free(out);\n }\n \n@@ -302,7 +314,7 @@ BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n \tif (out == NULL) {\n \t\treturn;\n \t}\n-\tgdImageWebpCtx(im, out, -1);\n+\t_gdImageWebpCtx(im, out, -1);\n \tout->gd_free(out);\n }\n \n@@ -318,8 +330,11 @@ BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n \tif (out == NULL) {\n \t\treturn NULL;\n \t}\n-\tgdImageWebpCtx(im, out, -1);\n-\trv = gdDPExtractData(out, size);\n+\tif (_gdImageWebpCtx(im, out, -1)) {\n+\t\trv = NULL;\n+\t} else {\n+\t\trv = gdDPExtractData(out, size);\n+\t}\n \tout->gd_free(out);\n \n \treturn rv;\n@@ -337,8 +352,11 @@ BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n \tif (out == NULL) {\n \t\treturn NULL;\n \t}\n-\tgdImageWebpCtx(im, out, quality);\n-\trv = gdDPExtractData(out, size);\n+\tif (_gdImageWebpCtx(im, out, quality)) {\n+        rv = NULL;\n+    } else {\n+        rv = gdDPExtractData(out, size);\n+    }\n \tout->gd_free(out);\n \treturn rv;\n }""}<_**next**_>{""sha"": ""569ccda8b7da0bcee30be6cb003e1ec807dc2bda"", ""filename"": ""tests/webp/.gitignore"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/.gitignore"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/.gitignore"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/.gitignore?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -1 +1,2 @@\n /bug00111\n+/bug_double_free""}<_**next**_>{""sha"": ""ec27127b1d63cb86f42194c10c18f964f311d9ff"", ""filename"": ""tests/webp/CMakeLists.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/CMakeLists.txt"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/CMakeLists.txt"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/CMakeLists.txt?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -1,6 +1,7 @@\n IF(WEBP_FOUND)\n LIST(APPEND TESTS_FILES\n \tbug00111\n+\tbug_double_free\n )\n ENDIF(WEBP_FOUND)\n ""}<_**next**_>{""sha"": ""f01f9e672fcfb8fd70c20d79a74ca987d9a208df"", ""filename"": ""tests/webp/Makemodule.am"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/Makemodule.am"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/Makemodule.am"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/Makemodule.am?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -1,7 +1,9 @@\n if HAVE_LIBWEBP\n libgd_test_programs += \\\n-\twebp/bug00111\n+\twebp/bug00111 \\\n+\twebp/bug_double_free\n endif\n \n EXTRA_DIST += \\\n-\twebp/CMakeLists.txt\n+\twebp/CMakeLists.txt \\\n+\twebp/bug_double_free.jpg""}<_**next**_>{""sha"": ""43eececfc19e35d6ba72e0be2f3e6198ace8e2f3"", ""filename"": ""tests/webp/bug_double_free.c"", ""status"": ""added"", ""additions"": 29, ""deletions"": 0, ""changes"": 29, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/bug_double_free.c"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/bug_double_free.c"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/bug_double_free.c?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -0,0 +1,29 @@\n+/**\n+ * Test that a too large image doesn't trigger an double-free when written\n+ * to memory.\n+ */\n+\n+\n+#include \""gd.h\""\n+#include \""gdtest.h\""\n+\n+\n+int main()\n+{\n+    gdImagePtr im1, im2;\n+    FILE *fp;\n+    int size;\n+\n+    fp = gdTestFileOpen2(\""webp\"", \""bug_double_free.jpg\"");\n+    gdTestAssert(fp != NULL);\n+    im1 = gdImageCreateFromJpeg(fp);\n+    gdTestAssert(im1 != NULL);\n+    fclose(fp);\n+\n+    im2 = gdImageWebpPtr(im1, &size);\n+    gdTestAssert(im2 == NULL);\n+\n+    gdImageDestroy(im1);\n+\n+    return gdNumFailures();\n+}""}<_**next**_>{""sha"": ""9b792fb4a7d17578b445af1ba530e4df7ac47df1"", ""filename"": ""tests/webp/bug_double_free.jpg"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/bug_double_free.jpg"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/bug_double_free.jpg"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/bug_double_free.jpg?ref=a49feeae76d41959d85ee733925a4cf40bac61b2""}","BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)
{
	gdIOCtx *out = gdNewFileCtx(outFile);
 	if (out == NULL) {
 		return;
 	}
	_gdImageWebpCtx(im, out, quality);
 	out->gd_free(out);
 }
","BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)
{
	gdIOCtx *out = gdNewFileCtx(outFile);
 	if (out == NULL) {
 		return;
 	}
	gdImageWebpCtx(im, out, quality);
 	out->gd_free(out);
 }
",C,"	_gdImageWebpCtx(im, out, quality);
","	gdImageWebpCtx(im, out, quality);
",,"@@ -162,54 +162,41 @@ BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpCtx (gdIOCtx * infile)
 	return im;
 }
 
-/*
-  Function: gdImageWebpCtx
-
-    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>
-    for more details.
-
-  Parameters:
-
-    im      - The image to write.
-    outfile - The output sink.
-    quality - Image quality.
 
-  Returns:
-
-    Nothing.
-*/
-BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
+/* returns 0 on success, 1 on failure */
+static int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
 {
 	uint8_t *argb;
 	int x, y;
 	uint8_t *p;
 	uint8_t *out;
 	size_t out_size;
+    int ret = 0;
 
 	if (im == NULL) {
-		return;
+		return 1;
 	}
 
 	if (!gdImageTrueColor(im)) {
-		gd_error(""Paletter image not supported by webp"");
-		return;
+		gd_error(""Palette image not supported by webp"");
+		return 1;
 	}
 
 	if (quality == -1) {
 		quality = 80;
 	}
 
 	if (overflow2(gdImageSX(im), 4)) {
-		return;
+		return 1;
 	}
 
 	if (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {
-		return;
+		return 1;
 	}
 
 	argb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));
 	if (!argb) {
-		return;
+		return 1;
 	}
 	p = argb;
 	for (y = 0; y < gdImageSY(im); y++) {
@@ -232,13 +219,38 @@ BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
 	out_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);
 	if (out_size == 0) {
 		gd_error(""gd-webp encoding failed"");
+        ret = 1;
 		goto freeargb;
 	}
 	gdPutBuf(out, out_size, outfile);
 	free(out);
 
 freeargb:
 	gdFree(argb);
+
+    return ret;
+}
+
+
+/*
+  Function: gdImageWebpCtx
+
+    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>
+    for more details.
+
+  Parameters:
+
+    im      - The image to write.
+    outfile - The output sink.
+    quality - Image quality.
+
+  Returns:
+
+    Nothing.
+*/
+BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
+{
+	_gdImageWebpCtx(im, outfile, quality);
 }
 
 /*
@@ -278,7 +290,7 @@ BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)
 	if (out == NULL) {
 		return;
 	}
-	gdImageWebpCtx(im, out, quality);
+	_gdImageWebpCtx(im, out, quality);
 	out->gd_free(out);
 }
 
@@ -302,7 +314,7 @@ BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)
 	if (out == NULL) {
 		return;
 	}
-	gdImageWebpCtx(im, out, -1);
+	_gdImageWebpCtx(im, out, -1);
 	out->gd_free(out);
 }
 
@@ -318,8 +330,11 @@ BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)
 	if (out == NULL) {
 		return NULL;
 	}
-	gdImageWebpCtx(im, out, -1);
-	rv = gdDPExtractData(out, size);
+	if (_gdImageWebpCtx(im, out, -1)) {
+		rv = NULL;
+	} else {
+		rv = gdDPExtractData(out, size);
+	}
 	out->gd_free(out);
 
 	return rv;
@@ -337,8 +352,11 @@ BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
 	if (out == NULL) {
 		return NULL;
 	}
-	gdImageWebpCtx(im, out, quality);
-	rv = gdDPExtractData(out, size);
+	if (_gdImageWebpCtx(im, out, quality)) {
+        rv = NULL;
+    } else {
+        rv = gdDPExtractData(out, size);
+    }
 	out->gd_free(out);
 	return rv;
 }",libgd,a49feeae76d41959d85ee733925a4cf40bac61b2,4859d69e07504d4b0a4bdf9bcb4d9e3769ca35ae,1,"BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)
{
	gdIOCtx *out = gdNewFileCtx(outFile);
 	if (out == NULL) {
 		return;
 	}
//flaw_line_below:
	gdImageWebpCtx(im, out, quality);
//fix_flaw_line_below:
//	_gdImageWebpCtx(im, out, quality);
 	out->gd_free(out);
 }
"
4255,181991,,Remote,Not required,Partial,CVE-2016-6912,https://www.cvedetails.com/cve/CVE-2016-6912/,CWE-415,Low,Partial,Partial,,2017-01-26,7.5,Double free vulnerability in the gdImageWebPtr function in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to have unspecified impact via large width and height values.,2017-11-03,,5,https://github.com/libgd/libgd/commit/a49feeae76d41959d85ee733925a4cf40bac61b2,a49feeae76d41959d85ee733925a4cf40bac61b2,"Fix double-free in gdImageWebPtr()

The issue is that gdImageWebpCtx() (which is called by gdImageWebpPtr() and
the other WebP output functions to do the real work) does not return whether
it succeeded or failed, so this is not checked in gdImageWebpPtr() and the
function wrongly assumes everything is okay, which is not, in this case,
because there is a size limitation for WebP, namely that the width and
height must by less than 16383.

We can't change the signature of gdImageWebpCtx() for API compatibility
reasons, so we introduce the static helper _gdImageWebpCtx() which returns
success respective failure, so gdImageWebpPtr() and gdImageWebpPtrEx() can
check the return value. We leave it solely to libwebp for now to report
warnings regarding the failing write.

This issue had been reported by Ibrahim El-Sayed to security@libgd.org.

CVE-2016-6912",2,src/gd_webp.c,"{""sha"": ""b5ee2642634e55eb650e32638ae27272e564b07f"", ""filename"": ""src/gd_webp.c"", ""status"": ""modified"", ""additions"": 46, ""deletions"": 28, ""changes"": 74, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/src/gd_webp.c"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/src/gd_webp.c"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/src/gd_webp.c?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -162,54 +162,41 @@ BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpCtx (gdIOCtx * infile)\n \treturn im;\n }\n \n-/*\n-  Function: gdImageWebpCtx\n-\n-    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>\n-    for more details.\n-\n-  Parameters:\n-\n-    im      - The image to write.\n-    outfile - The output sink.\n-    quality - Image quality.\n \n-  Returns:\n-\n-    Nothing.\n-*/\n-BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n {\n \tuint8_t *argb;\n \tint x, y;\n \tuint8_t *p;\n \tuint8_t *out;\n \tsize_t out_size;\n+    int ret = 0;\n \n \tif (im == NULL) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \tif (!gdImageTrueColor(im)) {\n-\t\tgd_error(\""Paletter image not supported by webp\"");\n-\t\treturn;\n+\t\tgd_error(\""Palette image not supported by webp\"");\n+\t\treturn 1;\n \t}\n \n \tif (quality == -1) {\n \t\tquality = 80;\n \t}\n \n \tif (overflow2(gdImageSX(im), 4)) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n \tif (!argb) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \tp = argb;\n \tfor (y = 0; y < gdImageSY(im); y++) {\n@@ -232,13 +219,38 @@ BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n \tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n \tif (out_size == 0) {\n \t\tgd_error(\""gd-webp encoding failed\"");\n+        ret = 1;\n \t\tgoto freeargb;\n \t}\n \tgdPutBuf(out, out_size, outfile);\n \tfree(out);\n \n freeargb:\n \tgdFree(argb);\n+\n+    return ret;\n+}\n+\n+\n+/*\n+  Function: gdImageWebpCtx\n+\n+    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>\n+    for more details.\n+\n+  Parameters:\n+\n+    im      - The image to write.\n+    outfile - The output sink.\n+    quality - Image quality.\n+\n+  Returns:\n+\n+    Nothing.\n+*/\n+BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n+{\n+\t_gdImageWebpCtx(im, outfile, quality);\n }\n \n /*\n@@ -278,7 +290,7 @@ BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n \tif (out == NULL) {\n \t\treturn;\n \t}\n-\tgdImageWebpCtx(im, out, quality);\n+\t_gdImageWebpCtx(im, out, quality);\n \tout->gd_free(out);\n }\n \n@@ -302,7 +314,7 @@ BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n \tif (out == NULL) {\n \t\treturn;\n \t}\n-\tgdImageWebpCtx(im, out, -1);\n+\t_gdImageWebpCtx(im, out, -1);\n \tout->gd_free(out);\n }\n \n@@ -318,8 +330,11 @@ BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n \tif (out == NULL) {\n \t\treturn NULL;\n \t}\n-\tgdImageWebpCtx(im, out, -1);\n-\trv = gdDPExtractData(out, size);\n+\tif (_gdImageWebpCtx(im, out, -1)) {\n+\t\trv = NULL;\n+\t} else {\n+\t\trv = gdDPExtractData(out, size);\n+\t}\n \tout->gd_free(out);\n \n \treturn rv;\n@@ -337,8 +352,11 @@ BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n \tif (out == NULL) {\n \t\treturn NULL;\n \t}\n-\tgdImageWebpCtx(im, out, quality);\n-\trv = gdDPExtractData(out, size);\n+\tif (_gdImageWebpCtx(im, out, quality)) {\n+        rv = NULL;\n+    } else {\n+        rv = gdDPExtractData(out, size);\n+    }\n \tout->gd_free(out);\n \treturn rv;\n }""}<_**next**_>{""sha"": ""569ccda8b7da0bcee30be6cb003e1ec807dc2bda"", ""filename"": ""tests/webp/.gitignore"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/.gitignore"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/.gitignore"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/.gitignore?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -1 +1,2 @@\n /bug00111\n+/bug_double_free""}<_**next**_>{""sha"": ""ec27127b1d63cb86f42194c10c18f964f311d9ff"", ""filename"": ""tests/webp/CMakeLists.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/CMakeLists.txt"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/CMakeLists.txt"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/CMakeLists.txt?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -1,6 +1,7 @@\n IF(WEBP_FOUND)\n LIST(APPEND TESTS_FILES\n \tbug00111\n+\tbug_double_free\n )\n ENDIF(WEBP_FOUND)\n ""}<_**next**_>{""sha"": ""f01f9e672fcfb8fd70c20d79a74ca987d9a208df"", ""filename"": ""tests/webp/Makemodule.am"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/Makemodule.am"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/Makemodule.am"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/Makemodule.am?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -1,7 +1,9 @@\n if HAVE_LIBWEBP\n libgd_test_programs += \\\n-\twebp/bug00111\n+\twebp/bug00111 \\\n+\twebp/bug_double_free\n endif\n \n EXTRA_DIST += \\\n-\twebp/CMakeLists.txt\n+\twebp/CMakeLists.txt \\\n+\twebp/bug_double_free.jpg""}<_**next**_>{""sha"": ""43eececfc19e35d6ba72e0be2f3e6198ace8e2f3"", ""filename"": ""tests/webp/bug_double_free.c"", ""status"": ""added"", ""additions"": 29, ""deletions"": 0, ""changes"": 29, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/bug_double_free.c"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/bug_double_free.c"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/bug_double_free.c?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -0,0 +1,29 @@\n+/**\n+ * Test that a too large image doesn't trigger an double-free when written\n+ * to memory.\n+ */\n+\n+\n+#include \""gd.h\""\n+#include \""gdtest.h\""\n+\n+\n+int main()\n+{\n+    gdImagePtr im1, im2;\n+    FILE *fp;\n+    int size;\n+\n+    fp = gdTestFileOpen2(\""webp\"", \""bug_double_free.jpg\"");\n+    gdTestAssert(fp != NULL);\n+    im1 = gdImageCreateFromJpeg(fp);\n+    gdTestAssert(im1 != NULL);\n+    fclose(fp);\n+\n+    im2 = gdImageWebpPtr(im1, &size);\n+    gdTestAssert(im2 == NULL);\n+\n+    gdImageDestroy(im1);\n+\n+    return gdNumFailures();\n+}""}<_**next**_>{""sha"": ""9b792fb4a7d17578b445af1ba530e4df7ac47df1"", ""filename"": ""tests/webp/bug_double_free.jpg"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/bug_double_free.jpg"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/bug_double_free.jpg"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/bug_double_free.jpg?ref=a49feeae76d41959d85ee733925a4cf40bac61b2""}","BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	if (_gdImageWebpCtx(im, out, -1)) {
		rv = NULL;
	} else {
		rv = gdDPExtractData(out, size);
	}
 	out->gd_free(out);
 
 	return rv;
}
","BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	gdImageWebpCtx(im, out, -1);
	rv = gdDPExtractData(out, size);
 	out->gd_free(out);
 
 	return rv;
}
",C,"	if (_gdImageWebpCtx(im, out, -1)) {
		rv = NULL;
	} else {
		rv = gdDPExtractData(out, size);
	}
","	gdImageWebpCtx(im, out, -1);
	rv = gdDPExtractData(out, size);
",,"@@ -162,54 +162,41 @@ BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpCtx (gdIOCtx * infile)
 	return im;
 }
 
-/*
-  Function: gdImageWebpCtx
-
-    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>
-    for more details.
-
-  Parameters:
-
-    im      - The image to write.
-    outfile - The output sink.
-    quality - Image quality.
 
-  Returns:
-
-    Nothing.
-*/
-BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
+/* returns 0 on success, 1 on failure */
+static int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
 {
 	uint8_t *argb;
 	int x, y;
 	uint8_t *p;
 	uint8_t *out;
 	size_t out_size;
+    int ret = 0;
 
 	if (im == NULL) {
-		return;
+		return 1;
 	}
 
 	if (!gdImageTrueColor(im)) {
-		gd_error(""Paletter image not supported by webp"");
-		return;
+		gd_error(""Palette image not supported by webp"");
+		return 1;
 	}
 
 	if (quality == -1) {
 		quality = 80;
 	}
 
 	if (overflow2(gdImageSX(im), 4)) {
-		return;
+		return 1;
 	}
 
 	if (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {
-		return;
+		return 1;
 	}
 
 	argb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));
 	if (!argb) {
-		return;
+		return 1;
 	}
 	p = argb;
 	for (y = 0; y < gdImageSY(im); y++) {
@@ -232,13 +219,38 @@ BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
 	out_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);
 	if (out_size == 0) {
 		gd_error(""gd-webp encoding failed"");
+        ret = 1;
 		goto freeargb;
 	}
 	gdPutBuf(out, out_size, outfile);
 	free(out);
 
 freeargb:
 	gdFree(argb);
+
+    return ret;
+}
+
+
+/*
+  Function: gdImageWebpCtx
+
+    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>
+    for more details.
+
+  Parameters:
+
+    im      - The image to write.
+    outfile - The output sink.
+    quality - Image quality.
+
+  Returns:
+
+    Nothing.
+*/
+BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
+{
+	_gdImageWebpCtx(im, outfile, quality);
 }
 
 /*
@@ -278,7 +290,7 @@ BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)
 	if (out == NULL) {
 		return;
 	}
-	gdImageWebpCtx(im, out, quality);
+	_gdImageWebpCtx(im, out, quality);
 	out->gd_free(out);
 }
 
@@ -302,7 +314,7 @@ BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)
 	if (out == NULL) {
 		return;
 	}
-	gdImageWebpCtx(im, out, -1);
+	_gdImageWebpCtx(im, out, -1);
 	out->gd_free(out);
 }
 
@@ -318,8 +330,11 @@ BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)
 	if (out == NULL) {
 		return NULL;
 	}
-	gdImageWebpCtx(im, out, -1);
-	rv = gdDPExtractData(out, size);
+	if (_gdImageWebpCtx(im, out, -1)) {
+		rv = NULL;
+	} else {
+		rv = gdDPExtractData(out, size);
+	}
 	out->gd_free(out);
 
 	return rv;
@@ -337,8 +352,11 @@ BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
 	if (out == NULL) {
 		return NULL;
 	}
-	gdImageWebpCtx(im, out, quality);
-	rv = gdDPExtractData(out, size);
+	if (_gdImageWebpCtx(im, out, quality)) {
+        rv = NULL;
+    } else {
+        rv = gdDPExtractData(out, size);
+    }
 	out->gd_free(out);
 	return rv;
 }",libgd,a49feeae76d41959d85ee733925a4cf40bac61b2,4859d69e07504d4b0a4bdf9bcb4d9e3769ca35ae,1,"BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
//flaw_line_below:
	gdImageWebpCtx(im, out, -1);
//flaw_line_below:
	rv = gdDPExtractData(out, size);
//fix_flaw_line_below:
//	if (_gdImageWebpCtx(im, out, -1)) {
//fix_flaw_line_below:
//		rv = NULL;
//fix_flaw_line_below:
//	} else {
//fix_flaw_line_below:
//		rv = gdDPExtractData(out, size);
//fix_flaw_line_below:
//	}
 	out->gd_free(out);
 
 	return rv;
}
"
4256,181992,,Remote,Not required,Partial,CVE-2016-6912,https://www.cvedetails.com/cve/CVE-2016-6912/,CWE-415,Low,Partial,Partial,,2017-01-26,7.5,Double free vulnerability in the gdImageWebPtr function in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to have unspecified impact via large width and height values.,2017-11-03,,5,https://github.com/libgd/libgd/commit/a49feeae76d41959d85ee733925a4cf40bac61b2,a49feeae76d41959d85ee733925a4cf40bac61b2,"Fix double-free in gdImageWebPtr()

The issue is that gdImageWebpCtx() (which is called by gdImageWebpPtr() and
the other WebP output functions to do the real work) does not return whether
it succeeded or failed, so this is not checked in gdImageWebpPtr() and the
function wrongly assumes everything is okay, which is not, in this case,
because there is a size limitation for WebP, namely that the width and
height must by less than 16383.

We can't change the signature of gdImageWebpCtx() for API compatibility
reasons, so we introduce the static helper _gdImageWebpCtx() which returns
success respective failure, so gdImageWebpPtr() and gdImageWebpPtrEx() can
check the return value. We leave it solely to libwebp for now to report
warnings regarding the failing write.

This issue had been reported by Ibrahim El-Sayed to security@libgd.org.

CVE-2016-6912",2,src/gd_webp.c,"{""sha"": ""b5ee2642634e55eb650e32638ae27272e564b07f"", ""filename"": ""src/gd_webp.c"", ""status"": ""modified"", ""additions"": 46, ""deletions"": 28, ""changes"": 74, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/src/gd_webp.c"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/src/gd_webp.c"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/src/gd_webp.c?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -162,54 +162,41 @@ BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpCtx (gdIOCtx * infile)\n \treturn im;\n }\n \n-/*\n-  Function: gdImageWebpCtx\n-\n-    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>\n-    for more details.\n-\n-  Parameters:\n-\n-    im      - The image to write.\n-    outfile - The output sink.\n-    quality - Image quality.\n \n-  Returns:\n-\n-    Nothing.\n-*/\n-BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n {\n \tuint8_t *argb;\n \tint x, y;\n \tuint8_t *p;\n \tuint8_t *out;\n \tsize_t out_size;\n+    int ret = 0;\n \n \tif (im == NULL) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \tif (!gdImageTrueColor(im)) {\n-\t\tgd_error(\""Paletter image not supported by webp\"");\n-\t\treturn;\n+\t\tgd_error(\""Palette image not supported by webp\"");\n+\t\treturn 1;\n \t}\n \n \tif (quality == -1) {\n \t\tquality = 80;\n \t}\n \n \tif (overflow2(gdImageSX(im), 4)) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n \tif (!argb) {\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \tp = argb;\n \tfor (y = 0; y < gdImageSY(im); y++) {\n@@ -232,13 +219,38 @@ BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n \tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n \tif (out_size == 0) {\n \t\tgd_error(\""gd-webp encoding failed\"");\n+        ret = 1;\n \t\tgoto freeargb;\n \t}\n \tgdPutBuf(out, out_size, outfile);\n \tfree(out);\n \n freeargb:\n \tgdFree(argb);\n+\n+    return ret;\n+}\n+\n+\n+/*\n+  Function: gdImageWebpCtx\n+\n+    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>\n+    for more details.\n+\n+  Parameters:\n+\n+    im      - The image to write.\n+    outfile - The output sink.\n+    quality - Image quality.\n+\n+  Returns:\n+\n+    Nothing.\n+*/\n+BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n+{\n+\t_gdImageWebpCtx(im, outfile, quality);\n }\n \n /*\n@@ -278,7 +290,7 @@ BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n \tif (out == NULL) {\n \t\treturn;\n \t}\n-\tgdImageWebpCtx(im, out, quality);\n+\t_gdImageWebpCtx(im, out, quality);\n \tout->gd_free(out);\n }\n \n@@ -302,7 +314,7 @@ BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n \tif (out == NULL) {\n \t\treturn;\n \t}\n-\tgdImageWebpCtx(im, out, -1);\n+\t_gdImageWebpCtx(im, out, -1);\n \tout->gd_free(out);\n }\n \n@@ -318,8 +330,11 @@ BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n \tif (out == NULL) {\n \t\treturn NULL;\n \t}\n-\tgdImageWebpCtx(im, out, -1);\n-\trv = gdDPExtractData(out, size);\n+\tif (_gdImageWebpCtx(im, out, -1)) {\n+\t\trv = NULL;\n+\t} else {\n+\t\trv = gdDPExtractData(out, size);\n+\t}\n \tout->gd_free(out);\n \n \treturn rv;\n@@ -337,8 +352,11 @@ BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n \tif (out == NULL) {\n \t\treturn NULL;\n \t}\n-\tgdImageWebpCtx(im, out, quality);\n-\trv = gdDPExtractData(out, size);\n+\tif (_gdImageWebpCtx(im, out, quality)) {\n+        rv = NULL;\n+    } else {\n+        rv = gdDPExtractData(out, size);\n+    }\n \tout->gd_free(out);\n \treturn rv;\n }""}<_**next**_>{""sha"": ""569ccda8b7da0bcee30be6cb003e1ec807dc2bda"", ""filename"": ""tests/webp/.gitignore"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/.gitignore"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/.gitignore"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/.gitignore?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -1 +1,2 @@\n /bug00111\n+/bug_double_free""}<_**next**_>{""sha"": ""ec27127b1d63cb86f42194c10c18f964f311d9ff"", ""filename"": ""tests/webp/CMakeLists.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/CMakeLists.txt"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/CMakeLists.txt"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/CMakeLists.txt?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -1,6 +1,7 @@\n IF(WEBP_FOUND)\n LIST(APPEND TESTS_FILES\n \tbug00111\n+\tbug_double_free\n )\n ENDIF(WEBP_FOUND)\n ""}<_**next**_>{""sha"": ""f01f9e672fcfb8fd70c20d79a74ca987d9a208df"", ""filename"": ""tests/webp/Makemodule.am"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/Makemodule.am"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/Makemodule.am"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/Makemodule.am?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -1,7 +1,9 @@\n if HAVE_LIBWEBP\n libgd_test_programs += \\\n-\twebp/bug00111\n+\twebp/bug00111 \\\n+\twebp/bug_double_free\n endif\n \n EXTRA_DIST += \\\n-\twebp/CMakeLists.txt\n+\twebp/CMakeLists.txt \\\n+\twebp/bug_double_free.jpg""}<_**next**_>{""sha"": ""43eececfc19e35d6ba72e0be2f3e6198ace8e2f3"", ""filename"": ""tests/webp/bug_double_free.c"", ""status"": ""added"", ""additions"": 29, ""deletions"": 0, ""changes"": 29, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/bug_double_free.c"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/bug_double_free.c"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/bug_double_free.c?ref=a49feeae76d41959d85ee733925a4cf40bac61b2"", ""patch"": ""@@ -0,0 +1,29 @@\n+/**\n+ * Test that a too large image doesn't trigger an double-free when written\n+ * to memory.\n+ */\n+\n+\n+#include \""gd.h\""\n+#include \""gdtest.h\""\n+\n+\n+int main()\n+{\n+    gdImagePtr im1, im2;\n+    FILE *fp;\n+    int size;\n+\n+    fp = gdTestFileOpen2(\""webp\"", \""bug_double_free.jpg\"");\n+    gdTestAssert(fp != NULL);\n+    im1 = gdImageCreateFromJpeg(fp);\n+    gdTestAssert(im1 != NULL);\n+    fclose(fp);\n+\n+    im2 = gdImageWebpPtr(im1, &size);\n+    gdTestAssert(im2 == NULL);\n+\n+    gdImageDestroy(im1);\n+\n+    return gdNumFailures();\n+}""}<_**next**_>{""sha"": ""9b792fb4a7d17578b445af1ba530e4df7ac47df1"", ""filename"": ""tests/webp/bug_double_free.jpg"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/libgd/libgd/blob/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/bug_double_free.jpg"", ""raw_url"": ""https://github.com/libgd/libgd/raw/a49feeae76d41959d85ee733925a4cf40bac61b2/tests/webp/bug_double_free.jpg"", ""contents_url"": ""https://api.github.com/repos/libgd/libgd/contents/tests/webp/bug_double_free.jpg?ref=a49feeae76d41959d85ee733925a4cf40bac61b2""}","BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	if (_gdImageWebpCtx(im, out, quality)) {
        rv = NULL;
    } else {
        rv = gdDPExtractData(out, size);
    }
 	out->gd_free(out);
 	return rv;
 }
","BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
 	out->gd_free(out);
 	return rv;
 }
",C,"	if (_gdImageWebpCtx(im, out, quality)) {
        rv = NULL;
    } else {
        rv = gdDPExtractData(out, size);
    }
","	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
",,"@@ -162,54 +162,41 @@ BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpCtx (gdIOCtx * infile)
 	return im;
 }
 
-/*
-  Function: gdImageWebpCtx
-
-    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>
-    for more details.
-
-  Parameters:
-
-    im      - The image to write.
-    outfile - The output sink.
-    quality - Image quality.
 
-  Returns:
-
-    Nothing.
-*/
-BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
+/* returns 0 on success, 1 on failure */
+static int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
 {
 	uint8_t *argb;
 	int x, y;
 	uint8_t *p;
 	uint8_t *out;
 	size_t out_size;
+    int ret = 0;
 
 	if (im == NULL) {
-		return;
+		return 1;
 	}
 
 	if (!gdImageTrueColor(im)) {
-		gd_error(""Paletter image not supported by webp"");
-		return;
+		gd_error(""Palette image not supported by webp"");
+		return 1;
 	}
 
 	if (quality == -1) {
 		quality = 80;
 	}
 
 	if (overflow2(gdImageSX(im), 4)) {
-		return;
+		return 1;
 	}
 
 	if (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {
-		return;
+		return 1;
 	}
 
 	argb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));
 	if (!argb) {
-		return;
+		return 1;
 	}
 	p = argb;
 	for (y = 0; y < gdImageSY(im); y++) {
@@ -232,13 +219,38 @@ BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
 	out_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);
 	if (out_size == 0) {
 		gd_error(""gd-webp encoding failed"");
+        ret = 1;
 		goto freeargb;
 	}
 	gdPutBuf(out, out_size, outfile);
 	free(out);
 
 freeargb:
 	gdFree(argb);
+
+    return ret;
+}
+
+
+/*
+  Function: gdImageWebpCtx
+
+    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>
+    for more details.
+
+  Parameters:
+
+    im      - The image to write.
+    outfile - The output sink.
+    quality - Image quality.
+
+  Returns:
+
+    Nothing.
+*/
+BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
+{
+	_gdImageWebpCtx(im, outfile, quality);
 }
 
 /*
@@ -278,7 +290,7 @@ BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)
 	if (out == NULL) {
 		return;
 	}
-	gdImageWebpCtx(im, out, quality);
+	_gdImageWebpCtx(im, out, quality);
 	out->gd_free(out);
 }
 
@@ -302,7 +314,7 @@ BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)
 	if (out == NULL) {
 		return;
 	}
-	gdImageWebpCtx(im, out, -1);
+	_gdImageWebpCtx(im, out, -1);
 	out->gd_free(out);
 }
 
@@ -318,8 +330,11 @@ BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)
 	if (out == NULL) {
 		return NULL;
 	}
-	gdImageWebpCtx(im, out, -1);
-	rv = gdDPExtractData(out, size);
+	if (_gdImageWebpCtx(im, out, -1)) {
+		rv = NULL;
+	} else {
+		rv = gdDPExtractData(out, size);
+	}
 	out->gd_free(out);
 
 	return rv;
@@ -337,8 +352,11 @@ BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
 	if (out == NULL) {
 		return NULL;
 	}
-	gdImageWebpCtx(im, out, quality);
-	rv = gdDPExtractData(out, size);
+	if (_gdImageWebpCtx(im, out, quality)) {
+        rv = NULL;
+    } else {
+        rv = gdDPExtractData(out, size);
+    }
 	out->gd_free(out);
 	return rv;
 }",libgd,a49feeae76d41959d85ee733925a4cf40bac61b2,4859d69e07504d4b0a4bdf9bcb4d9e3769ca35ae,1,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
//flaw_line_below:
	gdImageWebpCtx(im, out, quality);
//flaw_line_below:
	rv = gdDPExtractData(out, size);
//fix_flaw_line_below:
//	if (_gdImageWebpCtx(im, out, quality)) {
//fix_flaw_line_below:
//        rv = NULL;
//fix_flaw_line_below:
//    } else {
//fix_flaw_line_below:
//        rv = gdDPExtractData(out, size);
//fix_flaw_line_below:
//    }
 	out->gd_free(out);
 	return rv;
 }
"
4301,182037,,Remote,Not required,Partial,CVE-2015-8894,https://www.cvedetails.com/cve/CVE-2015-8894/,CWE-415,Medium,,,,2017-03-15,4.3,Double free vulnerability in coders/tga.c in ImageMagick 7.0.0 and later allows remote attackers to cause a denial of service (application crash) via a crafted tga file.,2017-03-17,DoS ,2,https://github.com/ImageMagick/ImageMagick/commit/4f68e9661518463fca523c9726bb5d940a2aa6d8,4f68e9661518463fca523c9726bb5d940a2aa6d8,https://bugs.launchpad.net/ubuntu/+source/imagemagick/+bug/1490362,0,coders/tga.c,"{""sha"": ""781933dfbd0c6bcba96c8af93819069282c63410"", ""filename"": ""coders/tga.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/4f68e9661518463fca523c9726bb5d940a2aa6d8/coders/tga.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/4f68e9661518463fca523c9726bb5d940a2aa6d8/coders/tga.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/tga.c?ref=4f68e9661518463fca523c9726bb5d940a2aa6d8"", ""patch"": ""@@ -315,6 +315,8 @@ static Image *ReadTGAImage(const ImageInfo *image_info,\n       /*\n         Read TGA raster colormap.\n       */\n+      if (image->colors < tga_info.colormap_index)\n+        image->colors=tga_info.colormap_index;\n       if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n         ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n       for (i=0; i < (ssize_t) tga_info.colormap_index; i++)""}","static Image *ReadTGAImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  Image
    *image;

  MagickBooleanType
    status;

  PixelInfo
    pixel;

  Quantum
    index;

  register Quantum
    *q;

  register ssize_t
    i,
    x;

  size_t
    base,
    flag,
    offset,
    real,
    skip;

  ssize_t
    count,
    y;

  TGAInfo
    tga_info;

  unsigned char
    j,
    k,
    pixels[4],
    runlength;

  unsigned int
    alpha_bits;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read TGA header information.
  */
  count=ReadBlob(image,1,&tga_info.id_length);
  tga_info.colormap_type=(unsigned char) ReadBlobByte(image);
  tga_info.image_type=(TGAImageType) ReadBlobByte(image);
  if ((count != 1) ||
      ((tga_info.image_type != TGAColormap) &&
       (tga_info.image_type != TGARGB) &&
       (tga_info.image_type != TGAMonochrome) &&
       (tga_info.image_type != TGARLEColormap) &&
       (tga_info.image_type != TGARLERGB) &&
       (tga_info.image_type != TGARLEMonochrome)) ||
      (((tga_info.image_type == TGAColormap) ||
       (tga_info.image_type == TGARLEColormap)) &&
       (tga_info.colormap_type == 0)))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  tga_info.colormap_index=ReadBlobLSBShort(image);
  tga_info.colormap_length=ReadBlobLSBShort(image);
  tga_info.colormap_size=(unsigned char) ReadBlobByte(image);
  tga_info.x_origin=ReadBlobLSBShort(image);
  tga_info.y_origin=ReadBlobLSBShort(image);
  tga_info.width=(unsigned short) ReadBlobLSBShort(image);
  tga_info.height=(unsigned short) ReadBlobLSBShort(image);
  tga_info.bits_per_pixel=(unsigned char) ReadBlobByte(image);
  tga_info.attributes=(unsigned char) ReadBlobByte(image);
  if (EOFBlob(image) != MagickFalse)
    ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
  if ((((tga_info.bits_per_pixel <= 1) || (tga_info.bits_per_pixel >= 17)) &&
       (tga_info.bits_per_pixel != 24) && (tga_info.bits_per_pixel != 32)))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  /*
    Initialize image structure.
  */
  image->columns=tga_info.width;
  image->rows=tga_info.height;
  alpha_bits=(tga_info.attributes & 0x0FU);
  image->alpha_trait=(alpha_bits > 0) || (tga_info.bits_per_pixel == 32) ||
    (tga_info.colormap_size == 32) ?  BlendPixelTrait : UndefinedPixelTrait;
  if ((tga_info.image_type != TGAColormap) &&
      (tga_info.image_type != TGARLEColormap))
    image->depth=(size_t) ((tga_info.bits_per_pixel <= 8) ? 8 :
      (tga_info.bits_per_pixel <= 16) ? 5 :
      (tga_info.bits_per_pixel == 24) ? 8 :
      (tga_info.bits_per_pixel == 32) ? 8 : 8);
  else
    image->depth=(size_t) ((tga_info.colormap_size <= 8) ? 8 :
      (tga_info.colormap_size <= 16) ? 5 :
      (tga_info.colormap_size == 24) ? 8 :
      (tga_info.colormap_size == 32) ? 8 : 8);
  if ((tga_info.image_type == TGAColormap) ||
      (tga_info.image_type == TGAMonochrome) ||
      (tga_info.image_type == TGARLEColormap) ||
      (tga_info.image_type == TGARLEMonochrome))
    image->storage_class=PseudoClass;
  image->compression=NoCompression;
  if ((tga_info.image_type == TGARLEColormap) ||
      (tga_info.image_type == TGARLEMonochrome) ||
      (tga_info.image_type == TGARLERGB))
    image->compression=RLECompression;
  if (image->storage_class == PseudoClass)
    {
      if (tga_info.colormap_type != 0)
        image->colors=tga_info.colormap_index+tga_info.colormap_length;
      else
        {
          size_t
            one;

          one=1;
          image->colors=one << tga_info.bits_per_pixel;
          if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
            ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        }
    }
  if (tga_info.id_length != 0)
    {
      char
        *comment;

      size_t
        length;

      /*
        TGA image comment.
      */
      length=(size_t) tga_info.id_length;
      comment=(char *) NULL;
      if (~length >= (MagickPathExtent-1))
        comment=(char *) AcquireQuantumMemory(length+MagickPathExtent,
          sizeof(*comment));
      if (comment == (char *) NULL)
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      count=ReadBlob(image,tga_info.id_length,(unsigned char *) comment);
      comment[tga_info.id_length]='\0';
      (void) SetImageProperty(image,""comment"",comment,exception);
      comment=DestroyString(comment);
    }
  if (image_info->ping != MagickFalse)
    {
      (void) CloseBlob(image);
      return(image);
    }
  status=SetImageExtent(image,image->columns,image->rows,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  (void) ResetMagickMemory(&pixel,0,sizeof(pixel));
  pixel.alpha=(MagickRealType) OpaqueAlpha;
  if (tga_info.colormap_type != 0)
    {
       /*
         Read TGA raster colormap.
       */
      if (image->colors < tga_info.colormap_index)
        image->colors=tga_info.colormap_index;
       if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
       for (i=0; i < (ssize_t) tga_info.colormap_index; i++)
        image->colormap[i]=pixel;
      for ( ; i < (ssize_t) image->colors; i++)
      {
        switch (tga_info.colormap_size)
        {
          case 8:
          default:
          {
            /*
              Gray scale.
            */
            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            pixel.green=pixel.red;
            pixel.blue=pixel.red;
            break;
          }
          case 15:
          case 16:
          {
            QuantumAny
              range;

            /*
              5 bits each of red green and blue.
            */
            j=(unsigned char) ReadBlobByte(image);
            k=(unsigned char) ReadBlobByte(image);
            range=GetQuantumRange(5UL);
            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,
              range);
            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*(k & 0x03)
              << 3)+(1UL*(j & 0xe0) >> 5),range);
            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);
            break;
          }
          case 24:
          {
            /*
              8 bits each of blue, green and red.
            */
            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            break;
          }
          case 32:
          {
            /*
              8 bits each of blue, green, red, and alpha.
            */
            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            pixel.alpha=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            break;
          }
        }
        image->colormap[i]=pixel;
      }
    }
  /*
    Convert TGA pixels to pixel packets.
  */
  base=0;
  flag=0;
  skip=MagickFalse;
  real=0;
  index=0;
  runlength=0;
  offset=0;
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    real=offset;
    if (((unsigned char) (tga_info.attributes & 0x20) >> 5) == 0)
      real=image->rows-real-1;
    q=QueueAuthenticPixels(image,0,(ssize_t) real,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      if ((tga_info.image_type == TGARLEColormap) ||
          (tga_info.image_type == TGARLERGB) ||
          (tga_info.image_type == TGARLEMonochrome))
        {
          if (runlength != 0)
            {
              runlength--;
              skip=flag != 0;
            }
          else
            {
              count=ReadBlob(image,1,&runlength);
              if (count != 1)
                ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
              flag=runlength & 0x80;
              if (flag != 0)
                runlength-=128;
              skip=MagickFalse;
            }
        }
      if (skip == MagickFalse)
        switch (tga_info.bits_per_pixel)
        {
          case 8:
          default:
          {
            /*
              Gray scale.
            */
            index=(Quantum) ReadBlobByte(image);
            if (tga_info.colormap_type != 0)
              pixel=image->colormap[(ssize_t) ConstrainColormapIndex(image,
                (ssize_t) index,exception)];
            else
              {
                pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)
                  index);
                pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)
                  index);
                pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)
                  index);
              }
            break;
          }
          case 15:
          case 16:
          {
            QuantumAny
              range;

            /*
              5 bits each of RGB.
            */
            if (ReadBlob(image,2,pixels) != 2)
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            j=pixels[0];
            k=pixels[1];
            range=GetQuantumRange(5UL);
            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,
              range);
            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*
              (k & 0x03) << 3)+(1UL*(j & 0xe0) >> 5),range);
            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);
            if (image->alpha_trait != UndefinedPixelTrait)
              pixel.alpha=(MagickRealType) ((k & 0x80) == 0 ? (Quantum)
                TransparentAlpha : (Quantum) OpaqueAlpha);
            if (image->storage_class == PseudoClass)
              index=(Quantum) ConstrainColormapIndex(image,((ssize_t) (k << 8))+
                j,exception);
            break;
          }
          case 24:
          {
            /*
              BGR pixels.
            */
            if (ReadBlob(image,3,pixels) != 3)
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);
            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);
            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);
            break;
          }
          case 32:
          {
            /*
              BGRA pixels.
            */
            if (ReadBlob(image,4,pixels) != 4)
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);
            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);
            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);
            pixel.alpha=(MagickRealType) ScaleCharToQuantum(pixels[3]);
            break;
          }
        }
      if (status == MagickFalse)
        ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
      if (image->storage_class == PseudoClass)
        SetPixelIndex(image,index,q);
      SetPixelRed(image,ClampToQuantum(pixel.red),q);
      SetPixelGreen(image,ClampToQuantum(pixel.green),q);
      SetPixelBlue(image,ClampToQuantum(pixel.blue),q);
      if (image->alpha_trait != UndefinedPixelTrait)
        SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);
      q+=GetPixelChannels(image);
    }
    /*
      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 4)
        offset+=4;
      else
    */
      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 2)
        offset+=2;
      else
        offset++;
    if (offset >= image->rows)
      {
        base++;
        offset=base;
      }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  if (EOFBlob(image) != MagickFalse)
    ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
      image->filename);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","static Image *ReadTGAImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  Image
    *image;

  MagickBooleanType
    status;

  PixelInfo
    pixel;

  Quantum
    index;

  register Quantum
    *q;

  register ssize_t
    i,
    x;

  size_t
    base,
    flag,
    offset,
    real,
    skip;

  ssize_t
    count,
    y;

  TGAInfo
    tga_info;

  unsigned char
    j,
    k,
    pixels[4],
    runlength;

  unsigned int
    alpha_bits;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read TGA header information.
  */
  count=ReadBlob(image,1,&tga_info.id_length);
  tga_info.colormap_type=(unsigned char) ReadBlobByte(image);
  tga_info.image_type=(TGAImageType) ReadBlobByte(image);
  if ((count != 1) ||
      ((tga_info.image_type != TGAColormap) &&
       (tga_info.image_type != TGARGB) &&
       (tga_info.image_type != TGAMonochrome) &&
       (tga_info.image_type != TGARLEColormap) &&
       (tga_info.image_type != TGARLERGB) &&
       (tga_info.image_type != TGARLEMonochrome)) ||
      (((tga_info.image_type == TGAColormap) ||
       (tga_info.image_type == TGARLEColormap)) &&
       (tga_info.colormap_type == 0)))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  tga_info.colormap_index=ReadBlobLSBShort(image);
  tga_info.colormap_length=ReadBlobLSBShort(image);
  tga_info.colormap_size=(unsigned char) ReadBlobByte(image);
  tga_info.x_origin=ReadBlobLSBShort(image);
  tga_info.y_origin=ReadBlobLSBShort(image);
  tga_info.width=(unsigned short) ReadBlobLSBShort(image);
  tga_info.height=(unsigned short) ReadBlobLSBShort(image);
  tga_info.bits_per_pixel=(unsigned char) ReadBlobByte(image);
  tga_info.attributes=(unsigned char) ReadBlobByte(image);
  if (EOFBlob(image) != MagickFalse)
    ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
  if ((((tga_info.bits_per_pixel <= 1) || (tga_info.bits_per_pixel >= 17)) &&
       (tga_info.bits_per_pixel != 24) && (tga_info.bits_per_pixel != 32)))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  /*
    Initialize image structure.
  */
  image->columns=tga_info.width;
  image->rows=tga_info.height;
  alpha_bits=(tga_info.attributes & 0x0FU);
  image->alpha_trait=(alpha_bits > 0) || (tga_info.bits_per_pixel == 32) ||
    (tga_info.colormap_size == 32) ?  BlendPixelTrait : UndefinedPixelTrait;
  if ((tga_info.image_type != TGAColormap) &&
      (tga_info.image_type != TGARLEColormap))
    image->depth=(size_t) ((tga_info.bits_per_pixel <= 8) ? 8 :
      (tga_info.bits_per_pixel <= 16) ? 5 :
      (tga_info.bits_per_pixel == 24) ? 8 :
      (tga_info.bits_per_pixel == 32) ? 8 : 8);
  else
    image->depth=(size_t) ((tga_info.colormap_size <= 8) ? 8 :
      (tga_info.colormap_size <= 16) ? 5 :
      (tga_info.colormap_size == 24) ? 8 :
      (tga_info.colormap_size == 32) ? 8 : 8);
  if ((tga_info.image_type == TGAColormap) ||
      (tga_info.image_type == TGAMonochrome) ||
      (tga_info.image_type == TGARLEColormap) ||
      (tga_info.image_type == TGARLEMonochrome))
    image->storage_class=PseudoClass;
  image->compression=NoCompression;
  if ((tga_info.image_type == TGARLEColormap) ||
      (tga_info.image_type == TGARLEMonochrome) ||
      (tga_info.image_type == TGARLERGB))
    image->compression=RLECompression;
  if (image->storage_class == PseudoClass)
    {
      if (tga_info.colormap_type != 0)
        image->colors=tga_info.colormap_index+tga_info.colormap_length;
      else
        {
          size_t
            one;

          one=1;
          image->colors=one << tga_info.bits_per_pixel;
          if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
            ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        }
    }
  if (tga_info.id_length != 0)
    {
      char
        *comment;

      size_t
        length;

      /*
        TGA image comment.
      */
      length=(size_t) tga_info.id_length;
      comment=(char *) NULL;
      if (~length >= (MagickPathExtent-1))
        comment=(char *) AcquireQuantumMemory(length+MagickPathExtent,
          sizeof(*comment));
      if (comment == (char *) NULL)
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      count=ReadBlob(image,tga_info.id_length,(unsigned char *) comment);
      comment[tga_info.id_length]='\0';
      (void) SetImageProperty(image,""comment"",comment,exception);
      comment=DestroyString(comment);
    }
  if (image_info->ping != MagickFalse)
    {
      (void) CloseBlob(image);
      return(image);
    }
  status=SetImageExtent(image,image->columns,image->rows,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  (void) ResetMagickMemory(&pixel,0,sizeof(pixel));
  pixel.alpha=(MagickRealType) OpaqueAlpha;
  if (tga_info.colormap_type != 0)
    {
       /*
         Read TGA raster colormap.
       */
       if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
       for (i=0; i < (ssize_t) tga_info.colormap_index; i++)
        image->colormap[i]=pixel;
      for ( ; i < (ssize_t) image->colors; i++)
      {
        switch (tga_info.colormap_size)
        {
          case 8:
          default:
          {
            /*
              Gray scale.
            */
            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            pixel.green=pixel.red;
            pixel.blue=pixel.red;
            break;
          }
          case 15:
          case 16:
          {
            QuantumAny
              range;

            /*
              5 bits each of red green and blue.
            */
            j=(unsigned char) ReadBlobByte(image);
            k=(unsigned char) ReadBlobByte(image);
            range=GetQuantumRange(5UL);
            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,
              range);
            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*(k & 0x03)
              << 3)+(1UL*(j & 0xe0) >> 5),range);
            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);
            break;
          }
          case 24:
          {
            /*
              8 bits each of blue, green and red.
            */
            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            break;
          }
          case 32:
          {
            /*
              8 bits each of blue, green, red, and alpha.
            */
            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            pixel.alpha=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            break;
          }
        }
        image->colormap[i]=pixel;
      }
    }
  /*
    Convert TGA pixels to pixel packets.
  */
  base=0;
  flag=0;
  skip=MagickFalse;
  real=0;
  index=0;
  runlength=0;
  offset=0;
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    real=offset;
    if (((unsigned char) (tga_info.attributes & 0x20) >> 5) == 0)
      real=image->rows-real-1;
    q=QueueAuthenticPixels(image,0,(ssize_t) real,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      if ((tga_info.image_type == TGARLEColormap) ||
          (tga_info.image_type == TGARLERGB) ||
          (tga_info.image_type == TGARLEMonochrome))
        {
          if (runlength != 0)
            {
              runlength--;
              skip=flag != 0;
            }
          else
            {
              count=ReadBlob(image,1,&runlength);
              if (count != 1)
                ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
              flag=runlength & 0x80;
              if (flag != 0)
                runlength-=128;
              skip=MagickFalse;
            }
        }
      if (skip == MagickFalse)
        switch (tga_info.bits_per_pixel)
        {
          case 8:
          default:
          {
            /*
              Gray scale.
            */
            index=(Quantum) ReadBlobByte(image);
            if (tga_info.colormap_type != 0)
              pixel=image->colormap[(ssize_t) ConstrainColormapIndex(image,
                (ssize_t) index,exception)];
            else
              {
                pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)
                  index);
                pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)
                  index);
                pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)
                  index);
              }
            break;
          }
          case 15:
          case 16:
          {
            QuantumAny
              range;

            /*
              5 bits each of RGB.
            */
            if (ReadBlob(image,2,pixels) != 2)
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            j=pixels[0];
            k=pixels[1];
            range=GetQuantumRange(5UL);
            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,
              range);
            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*
              (k & 0x03) << 3)+(1UL*(j & 0xe0) >> 5),range);
            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);
            if (image->alpha_trait != UndefinedPixelTrait)
              pixel.alpha=(MagickRealType) ((k & 0x80) == 0 ? (Quantum)
                TransparentAlpha : (Quantum) OpaqueAlpha);
            if (image->storage_class == PseudoClass)
              index=(Quantum) ConstrainColormapIndex(image,((ssize_t) (k << 8))+
                j,exception);
            break;
          }
          case 24:
          {
            /*
              BGR pixels.
            */
            if (ReadBlob(image,3,pixels) != 3)
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);
            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);
            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);
            break;
          }
          case 32:
          {
            /*
              BGRA pixels.
            */
            if (ReadBlob(image,4,pixels) != 4)
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);
            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);
            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);
            pixel.alpha=(MagickRealType) ScaleCharToQuantum(pixels[3]);
            break;
          }
        }
      if (status == MagickFalse)
        ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
      if (image->storage_class == PseudoClass)
        SetPixelIndex(image,index,q);
      SetPixelRed(image,ClampToQuantum(pixel.red),q);
      SetPixelGreen(image,ClampToQuantum(pixel.green),q);
      SetPixelBlue(image,ClampToQuantum(pixel.blue),q);
      if (image->alpha_trait != UndefinedPixelTrait)
        SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);
      q+=GetPixelChannels(image);
    }
    /*
      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 4)
        offset+=4;
      else
    */
      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 2)
        offset+=2;
      else
        offset++;
    if (offset >= image->rows)
      {
        base++;
        offset=base;
      }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  if (EOFBlob(image) != MagickFalse)
    ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
      image->filename);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",C,"      if (image->colors < tga_info.colormap_index)
        image->colors=tga_info.colormap_index;
",,,"@@ -315,6 +315,8 @@ static Image *ReadTGAImage(const ImageInfo *image_info,
       /*
         Read TGA raster colormap.
       */
+      if (image->colors < tga_info.colormap_index)
+        image->colors=tga_info.colormap_index;
       if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
       for (i=0; i < (ssize_t) tga_info.colormap_index; i++)",ImageMagick,4f68e9661518463fca523c9726bb5d940a2aa6d8,17435e6477f4c9dee1240319e86bee7785242078,1,"static Image *ReadTGAImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  Image
    *image;

  MagickBooleanType
    status;

  PixelInfo
    pixel;

  Quantum
    index;

  register Quantum
    *q;

  register ssize_t
    i,
    x;

  size_t
    base,
    flag,
    offset,
    real,
    skip;

  ssize_t
    count,
    y;

  TGAInfo
    tga_info;

  unsigned char
    j,
    k,
    pixels[4],
    runlength;

  unsigned int
    alpha_bits;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read TGA header information.
  */
  count=ReadBlob(image,1,&tga_info.id_length);
  tga_info.colormap_type=(unsigned char) ReadBlobByte(image);
  tga_info.image_type=(TGAImageType) ReadBlobByte(image);
  if ((count != 1) ||
      ((tga_info.image_type != TGAColormap) &&
       (tga_info.image_type != TGARGB) &&
       (tga_info.image_type != TGAMonochrome) &&
       (tga_info.image_type != TGARLEColormap) &&
       (tga_info.image_type != TGARLERGB) &&
       (tga_info.image_type != TGARLEMonochrome)) ||
      (((tga_info.image_type == TGAColormap) ||
       (tga_info.image_type == TGARLEColormap)) &&
       (tga_info.colormap_type == 0)))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  tga_info.colormap_index=ReadBlobLSBShort(image);
  tga_info.colormap_length=ReadBlobLSBShort(image);
  tga_info.colormap_size=(unsigned char) ReadBlobByte(image);
  tga_info.x_origin=ReadBlobLSBShort(image);
  tga_info.y_origin=ReadBlobLSBShort(image);
  tga_info.width=(unsigned short) ReadBlobLSBShort(image);
  tga_info.height=(unsigned short) ReadBlobLSBShort(image);
  tga_info.bits_per_pixel=(unsigned char) ReadBlobByte(image);
  tga_info.attributes=(unsigned char) ReadBlobByte(image);
  if (EOFBlob(image) != MagickFalse)
    ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
  if ((((tga_info.bits_per_pixel <= 1) || (tga_info.bits_per_pixel >= 17)) &&
       (tga_info.bits_per_pixel != 24) && (tga_info.bits_per_pixel != 32)))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  /*
    Initialize image structure.
  */
  image->columns=tga_info.width;
  image->rows=tga_info.height;
  alpha_bits=(tga_info.attributes & 0x0FU);
  image->alpha_trait=(alpha_bits > 0) || (tga_info.bits_per_pixel == 32) ||
    (tga_info.colormap_size == 32) ?  BlendPixelTrait : UndefinedPixelTrait;
  if ((tga_info.image_type != TGAColormap) &&
      (tga_info.image_type != TGARLEColormap))
    image->depth=(size_t) ((tga_info.bits_per_pixel <= 8) ? 8 :
      (tga_info.bits_per_pixel <= 16) ? 5 :
      (tga_info.bits_per_pixel == 24) ? 8 :
      (tga_info.bits_per_pixel == 32) ? 8 : 8);
  else
    image->depth=(size_t) ((tga_info.colormap_size <= 8) ? 8 :
      (tga_info.colormap_size <= 16) ? 5 :
      (tga_info.colormap_size == 24) ? 8 :
      (tga_info.colormap_size == 32) ? 8 : 8);
  if ((tga_info.image_type == TGAColormap) ||
      (tga_info.image_type == TGAMonochrome) ||
      (tga_info.image_type == TGARLEColormap) ||
      (tga_info.image_type == TGARLEMonochrome))
    image->storage_class=PseudoClass;
  image->compression=NoCompression;
  if ((tga_info.image_type == TGARLEColormap) ||
      (tga_info.image_type == TGARLEMonochrome) ||
      (tga_info.image_type == TGARLERGB))
    image->compression=RLECompression;
  if (image->storage_class == PseudoClass)
    {
      if (tga_info.colormap_type != 0)
        image->colors=tga_info.colormap_index+tga_info.colormap_length;
      else
        {
          size_t
            one;

          one=1;
          image->colors=one << tga_info.bits_per_pixel;
          if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
            ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        }
    }
  if (tga_info.id_length != 0)
    {
      char
        *comment;

      size_t
        length;

      /*
        TGA image comment.
      */
      length=(size_t) tga_info.id_length;
      comment=(char *) NULL;
      if (~length >= (MagickPathExtent-1))
        comment=(char *) AcquireQuantumMemory(length+MagickPathExtent,
          sizeof(*comment));
      if (comment == (char *) NULL)
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      count=ReadBlob(image,tga_info.id_length,(unsigned char *) comment);
      comment[tga_info.id_length]='\0';
      (void) SetImageProperty(image,""comment"",comment,exception);
      comment=DestroyString(comment);
    }
  if (image_info->ping != MagickFalse)
    {
      (void) CloseBlob(image);
      return(image);
    }
  status=SetImageExtent(image,image->columns,image->rows,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  (void) ResetMagickMemory(&pixel,0,sizeof(pixel));
  pixel.alpha=(MagickRealType) OpaqueAlpha;
  if (tga_info.colormap_type != 0)
    {
       /*
         Read TGA raster colormap.
       */
//fix_flaw_line_below:
//      if (image->colors < tga_info.colormap_index)
//fix_flaw_line_below:
//        image->colors=tga_info.colormap_index;
       if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
       for (i=0; i < (ssize_t) tga_info.colormap_index; i++)
        image->colormap[i]=pixel;
      for ( ; i < (ssize_t) image->colors; i++)
      {
        switch (tga_info.colormap_size)
        {
          case 8:
          default:
          {
            /*
              Gray scale.
            */
            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            pixel.green=pixel.red;
            pixel.blue=pixel.red;
            break;
          }
          case 15:
          case 16:
          {
            QuantumAny
              range;

            /*
              5 bits each of red green and blue.
            */
            j=(unsigned char) ReadBlobByte(image);
            k=(unsigned char) ReadBlobByte(image);
            range=GetQuantumRange(5UL);
            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,
              range);
            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*(k & 0x03)
              << 3)+(1UL*(j & 0xe0) >> 5),range);
            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);
            break;
          }
          case 24:
          {
            /*
              8 bits each of blue, green and red.
            */
            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            break;
          }
          case 32:
          {
            /*
              8 bits each of blue, green, red, and alpha.
            */
            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            pixel.alpha=(MagickRealType) ScaleCharToQuantum((unsigned char)
              ReadBlobByte(image));
            break;
          }
        }
        image->colormap[i]=pixel;
      }
    }
  /*
    Convert TGA pixels to pixel packets.
  */
  base=0;
  flag=0;
  skip=MagickFalse;
  real=0;
  index=0;
  runlength=0;
  offset=0;
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    real=offset;
    if (((unsigned char) (tga_info.attributes & 0x20) >> 5) == 0)
      real=image->rows-real-1;
    q=QueueAuthenticPixels(image,0,(ssize_t) real,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      if ((tga_info.image_type == TGARLEColormap) ||
          (tga_info.image_type == TGARLERGB) ||
          (tga_info.image_type == TGARLEMonochrome))
        {
          if (runlength != 0)
            {
              runlength--;
              skip=flag != 0;
            }
          else
            {
              count=ReadBlob(image,1,&runlength);
              if (count != 1)
                ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
              flag=runlength & 0x80;
              if (flag != 0)
                runlength-=128;
              skip=MagickFalse;
            }
        }
      if (skip == MagickFalse)
        switch (tga_info.bits_per_pixel)
        {
          case 8:
          default:
          {
            /*
              Gray scale.
            */
            index=(Quantum) ReadBlobByte(image);
            if (tga_info.colormap_type != 0)
              pixel=image->colormap[(ssize_t) ConstrainColormapIndex(image,
                (ssize_t) index,exception)];
            else
              {
                pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)
                  index);
                pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)
                  index);
                pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)
                  index);
              }
            break;
          }
          case 15:
          case 16:
          {
            QuantumAny
              range;

            /*
              5 bits each of RGB.
            */
            if (ReadBlob(image,2,pixels) != 2)
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            j=pixels[0];
            k=pixels[1];
            range=GetQuantumRange(5UL);
            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,
              range);
            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*
              (k & 0x03) << 3)+(1UL*(j & 0xe0) >> 5),range);
            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);
            if (image->alpha_trait != UndefinedPixelTrait)
              pixel.alpha=(MagickRealType) ((k & 0x80) == 0 ? (Quantum)
                TransparentAlpha : (Quantum) OpaqueAlpha);
            if (image->storage_class == PseudoClass)
              index=(Quantum) ConstrainColormapIndex(image,((ssize_t) (k << 8))+
                j,exception);
            break;
          }
          case 24:
          {
            /*
              BGR pixels.
            */
            if (ReadBlob(image,3,pixels) != 3)
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);
            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);
            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);
            break;
          }
          case 32:
          {
            /*
              BGRA pixels.
            */
            if (ReadBlob(image,4,pixels) != 4)
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);
            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);
            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);
            pixel.alpha=(MagickRealType) ScaleCharToQuantum(pixels[3]);
            break;
          }
        }
      if (status == MagickFalse)
        ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
      if (image->storage_class == PseudoClass)
        SetPixelIndex(image,index,q);
      SetPixelRed(image,ClampToQuantum(pixel.red),q);
      SetPixelGreen(image,ClampToQuantum(pixel.green),q);
      SetPixelBlue(image,ClampToQuantum(pixel.blue),q);
      if (image->alpha_trait != UndefinedPixelTrait)
        SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);
      q+=GetPixelChannels(image);
    }
    /*
      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 4)
        offset+=4;
      else
    */
      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 2)
        offset+=2;
      else
        offset++;
    if (offset >= image->rows)
      {
        base++;
        offset=base;
      }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  if (EOFBlob(image) != MagickFalse)
    ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
      image->filename);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
"
4364,182100,,Remote,Not required,Partial,CVE-2018-1000880,https://www.cvedetails.com/cve/CVE-2018-1000880/,CWE-415,Medium,,,,2018-12-20,4.3,"libarchive version commit 9693801580c0cf7c70e862d305270a16b52826a7 onwards (release v3.2.0 onwards) contains a CWE-20: Improper Input Validation vulnerability in WARC parser - libarchive/archive_read_support_format_warc.c, _warc_read() that can result in DoS - quasi-infinite run time and disk usage from tiny file. This attack appear to be exploitable via the victim must open a specially crafted WARC file.",2019-04-12,,5,https://github.com/libarchive/libarchive/pull/1105/commits/9c84b7426660c09c18cc349f6d70b5f8168b5680,9c84b7426660c09c18cc349f6d70b5f8168b5680,"warc: consume data once read

The warc decoder only used read ahead, it wouldn't actually consume
data that had previously been printed. This means that if you specify
an invalid content length, it will just reprint the same data over
and over and over again until it hits the desired length.

This means that a WARC resource with e.g.
Content-Length: 666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666665
but only a few hundred bytes of data, causes a quasi-infinite loop.

Consume data in subsequent calls to _warc_read.

Found with an AFL + afl-rb + qsym setup.",0,libarchive/archive_read_support_format_warc.c,"{""sha"": ""e8fc8428b41ed79bf969d776add480ad89081b1b"", ""filename"": ""libarchive/archive_read_support_format_warc.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/libarchive/libarchive/blob/9c84b7426660c09c18cc349f6d70b5f8168b5680/libarchive/archive_read_support_format_warc.c"", ""raw_url"": ""https://github.com/libarchive/libarchive/raw/9c84b7426660c09c18cc349f6d70b5f8168b5680/libarchive/archive_read_support_format_warc.c"", ""contents_url"": ""https://api.github.com/repos/libarchive/libarchive/contents/libarchive/archive_read_support_format_warc.c?ref=9c84b7426660c09c18cc349f6d70b5f8168b5680"", ""patch"": ""@@ -386,6 +386,11 @@ _warc_read(struct archive_read *a, const void **buf, size_t *bsz, int64_t *off)\n \t\treturn (ARCHIVE_EOF);\n \t}\n \n+\tif (w->unconsumed) {\n+\t\t__archive_read_consume(a, w->unconsumed);\n+\t\tw->unconsumed = 0U;\n+\t}\n+\n \trab = __archive_read_ahead(a, 1U, &nrd);\n \tif (nrd < 0) {\n \t\t*bsz = 0U;""}","_warc_read(struct archive_read *a, const void **buf, size_t *bsz, int64_t *off)
{
	struct warc_s *w = a->format->data;
	const char *rab;
	ssize_t nrd;

	if (w->cntoff >= w->cntlen) {
	eof:
		/* it's our lucky day, no work, we can leave early */
		*buf = NULL;
		*bsz = 0U;
		*off = w->cntoff + 4U/*for \r\n\r\n separator*/;
		w->unconsumed = 0U;
 		return (ARCHIVE_EOF);
 	}
 
	if (w->unconsumed) {
		__archive_read_consume(a, w->unconsumed);
		w->unconsumed = 0U;
	}

 	rab = __archive_read_ahead(a, 1U, &nrd);
 	if (nrd < 0) {
 		*bsz = 0U;
		/* big catastrophe */
		return (int)nrd;
	} else if (nrd == 0) {
		goto eof;
	} else if ((size_t)nrd > w->cntlen - w->cntoff) {
		/* clamp to content-length */
		nrd = w->cntlen - w->cntoff;
	}
	*off = w->cntoff;
	*bsz = nrd;
	*buf = rab;

	w->cntoff += nrd;
	w->unconsumed = (size_t)nrd;
	return (ARCHIVE_OK);
}
","_warc_read(struct archive_read *a, const void **buf, size_t *bsz, int64_t *off)
{
	struct warc_s *w = a->format->data;
	const char *rab;
	ssize_t nrd;

	if (w->cntoff >= w->cntlen) {
	eof:
		/* it's our lucky day, no work, we can leave early */
		*buf = NULL;
		*bsz = 0U;
		*off = w->cntoff + 4U/*for \r\n\r\n separator*/;
		w->unconsumed = 0U;
 		return (ARCHIVE_EOF);
 	}
 
 	rab = __archive_read_ahead(a, 1U, &nrd);
 	if (nrd < 0) {
 		*bsz = 0U;
		/* big catastrophe */
		return (int)nrd;
	} else if (nrd == 0) {
		goto eof;
	} else if ((size_t)nrd > w->cntlen - w->cntoff) {
		/* clamp to content-length */
		nrd = w->cntlen - w->cntoff;
	}
	*off = w->cntoff;
	*bsz = nrd;
	*buf = rab;

	w->cntoff += nrd;
	w->unconsumed = (size_t)nrd;
	return (ARCHIVE_OK);
}
",C,"	if (w->unconsumed) {
		__archive_read_consume(a, w->unconsumed);
		w->unconsumed = 0U;
	}

",,,"@@ -386,6 +386,11 @@ _warc_read(struct archive_read *a, const void **buf, size_t *bsz, int64_t *off)
 		return (ARCHIVE_EOF);
 	}
 
+	if (w->unconsumed) {
+		__archive_read_consume(a, w->unconsumed);
+		w->unconsumed = 0U;
+	}
+
 	rab = __archive_read_ahead(a, 1U, &nrd);
 	if (nrd < 0) {
 		*bsz = 0U;",libarchive,9c84b7426660c09c18cc349f6d70b5f8168b5680,15bf44fd2c1ad0e3fd87048b3fcc90c4dcff1175,1,"_warc_read(struct archive_read *a, const void **buf, size_t *bsz, int64_t *off)
{
	struct warc_s *w = a->format->data;
	const char *rab;
	ssize_t nrd;

	if (w->cntoff >= w->cntlen) {
	eof:
		/* it's our lucky day, no work, we can leave early */
		*buf = NULL;
		*bsz = 0U;
		*off = w->cntoff + 4U/*for \r\n\r\n separator*/;
		w->unconsumed = 0U;
 		return (ARCHIVE_EOF);
 	}
 
//fix_flaw_line_below:
//	if (w->unconsumed) {
//fix_flaw_line_below:
//		__archive_read_consume(a, w->unconsumed);
//fix_flaw_line_below:
//		w->unconsumed = 0U;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	rab = __archive_read_ahead(a, 1U, &nrd);
 	if (nrd < 0) {
 		*bsz = 0U;
		/* big catastrophe */
		return (int)nrd;
	} else if (nrd == 0) {
		goto eof;
	} else if ((size_t)nrd > w->cntlen - w->cntoff) {
		/* clamp to content-length */
		nrd = w->cntlen - w->cntoff;
	}
	*off = w->cntoff;
	*bsz = nrd;
	*buf = rab;

	w->cntoff += nrd;
	w->unconsumed = (size_t)nrd;
	return (ARCHIVE_OK);
}
"
4368,182104,,Remote,Not required,Partial,CVE-2018-1000877,https://www.cvedetails.com/cve/CVE-2018-1000877/,CWE-415,Medium,Partial,Partial,,2018-12-20,6.8,"libarchive version commit 416694915449219d505531b1096384f3237dd6cc onwards (release v3.1.0 onwards) contains a CWE-415: Double Free vulnerability in RAR decoder - libarchive/archive_read_support_format_rar.c, parse_codes(), realloc(rar->lzss.window, new_size) with new_size = 0 that can result in Crash/DoS. This attack appear to be exploitable via the victim must open a specially crafted RAR archive.",2019-04-12,,5,https://github.com/libarchive/libarchive/pull/1105/commits/021efa522ad729ff0f5806c4ce53e4a6cc1daa31,021efa522ad729ff0f5806c4ce53e4a6cc1daa31,"Avoid a double-free when a window size of 0 is specified

new_size can be 0 with a malicious or corrupted RAR archive.

realloc(area, 0) is equivalent to free(area), so the region would
be free()d here and the free()d again in the cleanup function.

Found with a setup running AFL, afl-rb, and qsym.",0,libarchive/archive_read_support_format_rar.c,"{""sha"": ""6f419c2708c4312cf8e68ed87397fc58ef4832f6"", ""filename"": ""libarchive/archive_read_support_format_rar.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/libarchive/libarchive/blob/021efa522ad729ff0f5806c4ce53e4a6cc1daa31/libarchive/archive_read_support_format_rar.c"", ""raw_url"": ""https://github.com/libarchive/libarchive/raw/021efa522ad729ff0f5806c4ce53e4a6cc1daa31/libarchive/archive_read_support_format_rar.c"", ""contents_url"": ""https://api.github.com/repos/libarchive/libarchive/contents/libarchive/archive_read_support_format_rar.c?ref=021efa522ad729ff0f5806c4ce53e4a6cc1daa31"", ""patch"": ""@@ -2300,6 +2300,11 @@ parse_codes(struct archive_read *a)\n       new_size = DICTIONARY_MAX_SIZE;\n     else\n       new_size = rar_fls((unsigned int)rar->unp_size) << 1;\n+    if (new_size == 0) {\n+      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n+                        \""Zero window size is invalid.\"");\n+      return (ARCHIVE_FATAL);\n+    }\n     new_window = realloc(rar->lzss.window, new_size);\n     if (new_window == NULL) {\n       archive_set_error(&a->archive, ENOMEM,""}","parse_codes(struct archive_read *a)
{
  int i, j, val, n, r;
  unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;
  unsigned int maxorder;
  struct huffman_code precode;
  struct rar *rar = (struct rar *)(a->format->data);
  struct rar_br *br = &(rar->br);

  free_codes(a);

  /* Skip to the next byte */
  rar_br_consume_unalined_bits(br);

  /* PPMd block flag */
  if (!rar_br_read_ahead(a, br, 1))
    goto truncated_data;
  if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0)
  {
    rar_br_consume(br, 1);
    if (!rar_br_read_ahead(a, br, 7))
      goto truncated_data;
    ppmd_flags = rar_br_bits(br, 7);
    rar_br_consume(br, 7);

    /* Memory is allocated in MB */
    if (ppmd_flags & 0x20)
    {
      if (!rar_br_read_ahead(a, br, 8))
        goto truncated_data;
      rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20;
      rar_br_consume(br, 8);
    }

    if (ppmd_flags & 0x40)
    {
      if (!rar_br_read_ahead(a, br, 8))
        goto truncated_data;
      rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8);
      rar_br_consume(br, 8);
    }
    else
      rar->ppmd_escape = 2;

    if (ppmd_flags & 0x20)
    {
      maxorder = (ppmd_flags & 0x1F) + 1;
      if(maxorder > 16)
        maxorder = 16 + (maxorder - 16) * 3;

      if (maxorder == 1)
      {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Truncated RAR file data"");
        return (ARCHIVE_FATAL);
      }

      /* Make sure ppmd7_contest is freed before Ppmd7_Construct
       * because reading a broken file cause this abnormal sequence. */
      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);

      rar->bytein.a = a;
      rar->bytein.Read = &ppmd_read;
      __archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);
      rar->range_dec.Stream = &rar->bytein;
      __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);

      if (rar->dictionary_size == 0) {
	      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Invalid zero dictionary size"");
	      return (ARCHIVE_FATAL);
      }

      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,
        rar->dictionary_size))
      {
        archive_set_error(&a->archive, ENOMEM,
                          ""Out of memory"");
        return (ARCHIVE_FATAL);
      }
      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))
      {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Unable to initialize PPMd range decoder"");
        return (ARCHIVE_FATAL);
      }
      __archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder);
      rar->ppmd_valid = 1;
    }
    else
    {
      if (!rar->ppmd_valid) {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Invalid PPMd sequence"");
        return (ARCHIVE_FATAL);
      }
      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))
      {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Unable to initialize PPMd range decoder"");
        return (ARCHIVE_FATAL);
      }
    }
  }
  else
  {
    rar_br_consume(br, 1);

    /* Keep existing table flag */
    if (!rar_br_read_ahead(a, br, 1))
      goto truncated_data;
    if (!rar_br_bits(br, 1))
      memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
    rar_br_consume(br, 1);

    memset(&bitlengths, 0, sizeof(bitlengths));
    for (i = 0; i < MAX_SYMBOLS;)
    {
      if (!rar_br_read_ahead(a, br, 4))
        goto truncated_data;
      bitlengths[i++] = rar_br_bits(br, 4);
      rar_br_consume(br, 4);
      if (bitlengths[i-1] == 0xF)
      {
        if (!rar_br_read_ahead(a, br, 4))
          goto truncated_data;
        zerocount = rar_br_bits(br, 4);
        rar_br_consume(br, 4);
        if (zerocount)
        {
          i--;
          for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++)
            bitlengths[i++] = 0;
        }
      }
    }

    memset(&precode, 0, sizeof(precode));
    r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK) {
      free(precode.tree);
      free(precode.table);
      return (r);
    }

    for (i = 0; i < HUFFMAN_TABLE_SIZE;)
    {
      if ((val = read_next_symbol(a, &precode)) < 0) {
        free(precode.tree);
        free(precode.table);
        return (ARCHIVE_FATAL);
      }
      if (val < 16)
      {
        rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF;
        i++;
      }
      else if (val < 18)
      {
        if (i == 0)
        {
          free(precode.tree);
          free(precode.table);
          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                            ""Internal error extracting RAR file."");
          return (ARCHIVE_FATAL);
        }

        if(val == 16) {
          if (!rar_br_read_ahead(a, br, 3)) {
            free(precode.tree);
            free(precode.table);
            goto truncated_data;
          }
          n = rar_br_bits(br, 3) + 3;
          rar_br_consume(br, 3);
        } else {
          if (!rar_br_read_ahead(a, br, 7)) {
            free(precode.tree);
            free(precode.table);
            goto truncated_data;
          }
          n = rar_br_bits(br, 7) + 11;
          rar_br_consume(br, 7);
        }

        for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)
        {
          rar->lengthtable[i] = rar->lengthtable[i-1];
          i++;
        }
      }
      else
      {
        if(val == 18) {
          if (!rar_br_read_ahead(a, br, 3)) {
            free(precode.tree);
            free(precode.table);
            goto truncated_data;
          }
          n = rar_br_bits(br, 3) + 3;
          rar_br_consume(br, 3);
        } else {
          if (!rar_br_read_ahead(a, br, 7)) {
            free(precode.tree);
            free(precode.table);
            goto truncated_data;
          }
          n = rar_br_bits(br, 7) + 11;
          rar_br_consume(br, 7);
        }

        for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)
          rar->lengthtable[i++] = 0;
      }
    }
    free(precode.tree);
    free(precode.table);

    r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE,
                MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK)
      return (r);
    r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE],
                OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK)
      return (r);
    r = create_code(a, &rar->lowoffsetcode,
                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE],
                LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK)
      return (r);
    r = create_code(a, &rar->lengthcode,
                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE +
                LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK)
      return (r);
  }

  if (!rar->dictionary_size || !rar->lzss.window)
  {
    /* Seems as though dictionary sizes are not used. Even so, minimize
     * memory usage as much as possible.
     */
    void *new_window;
    unsigned int new_size;

    if (rar->unp_size >= DICTIONARY_MAX_SIZE)
       new_size = DICTIONARY_MAX_SIZE;
     else
       new_size = rar_fls((unsigned int)rar->unp_size) << 1;
    if (new_size == 0) {
      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                        ""Zero window size is invalid."");
      return (ARCHIVE_FATAL);
    }
     new_window = realloc(rar->lzss.window, new_size);
     if (new_window == NULL) {
       archive_set_error(&a->archive, ENOMEM,
                        ""Unable to allocate memory for uncompressed data."");
      return (ARCHIVE_FATAL);
    }
    rar->lzss.window = (unsigned char *)new_window;
    rar->dictionary_size = new_size;
    memset(rar->lzss.window, 0, rar->dictionary_size);
    rar->lzss.mask = rar->dictionary_size - 1;
  }

  rar->start_new_table = 0;
  return (ARCHIVE_OK);
truncated_data:
  archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                    ""Truncated RAR file data"");
  rar->valid = 0;
  return (ARCHIVE_FATAL);
}
","parse_codes(struct archive_read *a)
{
  int i, j, val, n, r;
  unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;
  unsigned int maxorder;
  struct huffman_code precode;
  struct rar *rar = (struct rar *)(a->format->data);
  struct rar_br *br = &(rar->br);

  free_codes(a);

  /* Skip to the next byte */
  rar_br_consume_unalined_bits(br);

  /* PPMd block flag */
  if (!rar_br_read_ahead(a, br, 1))
    goto truncated_data;
  if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0)
  {
    rar_br_consume(br, 1);
    if (!rar_br_read_ahead(a, br, 7))
      goto truncated_data;
    ppmd_flags = rar_br_bits(br, 7);
    rar_br_consume(br, 7);

    /* Memory is allocated in MB */
    if (ppmd_flags & 0x20)
    {
      if (!rar_br_read_ahead(a, br, 8))
        goto truncated_data;
      rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20;
      rar_br_consume(br, 8);
    }

    if (ppmd_flags & 0x40)
    {
      if (!rar_br_read_ahead(a, br, 8))
        goto truncated_data;
      rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8);
      rar_br_consume(br, 8);
    }
    else
      rar->ppmd_escape = 2;

    if (ppmd_flags & 0x20)
    {
      maxorder = (ppmd_flags & 0x1F) + 1;
      if(maxorder > 16)
        maxorder = 16 + (maxorder - 16) * 3;

      if (maxorder == 1)
      {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Truncated RAR file data"");
        return (ARCHIVE_FATAL);
      }

      /* Make sure ppmd7_contest is freed before Ppmd7_Construct
       * because reading a broken file cause this abnormal sequence. */
      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);

      rar->bytein.a = a;
      rar->bytein.Read = &ppmd_read;
      __archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);
      rar->range_dec.Stream = &rar->bytein;
      __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);

      if (rar->dictionary_size == 0) {
	      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Invalid zero dictionary size"");
	      return (ARCHIVE_FATAL);
      }

      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,
        rar->dictionary_size))
      {
        archive_set_error(&a->archive, ENOMEM,
                          ""Out of memory"");
        return (ARCHIVE_FATAL);
      }
      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))
      {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Unable to initialize PPMd range decoder"");
        return (ARCHIVE_FATAL);
      }
      __archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder);
      rar->ppmd_valid = 1;
    }
    else
    {
      if (!rar->ppmd_valid) {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Invalid PPMd sequence"");
        return (ARCHIVE_FATAL);
      }
      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))
      {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Unable to initialize PPMd range decoder"");
        return (ARCHIVE_FATAL);
      }
    }
  }
  else
  {
    rar_br_consume(br, 1);

    /* Keep existing table flag */
    if (!rar_br_read_ahead(a, br, 1))
      goto truncated_data;
    if (!rar_br_bits(br, 1))
      memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
    rar_br_consume(br, 1);

    memset(&bitlengths, 0, sizeof(bitlengths));
    for (i = 0; i < MAX_SYMBOLS;)
    {
      if (!rar_br_read_ahead(a, br, 4))
        goto truncated_data;
      bitlengths[i++] = rar_br_bits(br, 4);
      rar_br_consume(br, 4);
      if (bitlengths[i-1] == 0xF)
      {
        if (!rar_br_read_ahead(a, br, 4))
          goto truncated_data;
        zerocount = rar_br_bits(br, 4);
        rar_br_consume(br, 4);
        if (zerocount)
        {
          i--;
          for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++)
            bitlengths[i++] = 0;
        }
      }
    }

    memset(&precode, 0, sizeof(precode));
    r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK) {
      free(precode.tree);
      free(precode.table);
      return (r);
    }

    for (i = 0; i < HUFFMAN_TABLE_SIZE;)
    {
      if ((val = read_next_symbol(a, &precode)) < 0) {
        free(precode.tree);
        free(precode.table);
        return (ARCHIVE_FATAL);
      }
      if (val < 16)
      {
        rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF;
        i++;
      }
      else if (val < 18)
      {
        if (i == 0)
        {
          free(precode.tree);
          free(precode.table);
          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                            ""Internal error extracting RAR file."");
          return (ARCHIVE_FATAL);
        }

        if(val == 16) {
          if (!rar_br_read_ahead(a, br, 3)) {
            free(precode.tree);
            free(precode.table);
            goto truncated_data;
          }
          n = rar_br_bits(br, 3) + 3;
          rar_br_consume(br, 3);
        } else {
          if (!rar_br_read_ahead(a, br, 7)) {
            free(precode.tree);
            free(precode.table);
            goto truncated_data;
          }
          n = rar_br_bits(br, 7) + 11;
          rar_br_consume(br, 7);
        }

        for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)
        {
          rar->lengthtable[i] = rar->lengthtable[i-1];
          i++;
        }
      }
      else
      {
        if(val == 18) {
          if (!rar_br_read_ahead(a, br, 3)) {
            free(precode.tree);
            free(precode.table);
            goto truncated_data;
          }
          n = rar_br_bits(br, 3) + 3;
          rar_br_consume(br, 3);
        } else {
          if (!rar_br_read_ahead(a, br, 7)) {
            free(precode.tree);
            free(precode.table);
            goto truncated_data;
          }
          n = rar_br_bits(br, 7) + 11;
          rar_br_consume(br, 7);
        }

        for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)
          rar->lengthtable[i++] = 0;
      }
    }
    free(precode.tree);
    free(precode.table);

    r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE,
                MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK)
      return (r);
    r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE],
                OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK)
      return (r);
    r = create_code(a, &rar->lowoffsetcode,
                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE],
                LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK)
      return (r);
    r = create_code(a, &rar->lengthcode,
                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE +
                LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK)
      return (r);
  }

  if (!rar->dictionary_size || !rar->lzss.window)
  {
    /* Seems as though dictionary sizes are not used. Even so, minimize
     * memory usage as much as possible.
     */
    void *new_window;
    unsigned int new_size;

    if (rar->unp_size >= DICTIONARY_MAX_SIZE)
       new_size = DICTIONARY_MAX_SIZE;
     else
       new_size = rar_fls((unsigned int)rar->unp_size) << 1;
     new_window = realloc(rar->lzss.window, new_size);
     if (new_window == NULL) {
       archive_set_error(&a->archive, ENOMEM,
                        ""Unable to allocate memory for uncompressed data."");
      return (ARCHIVE_FATAL);
    }
    rar->lzss.window = (unsigned char *)new_window;
    rar->dictionary_size = new_size;
    memset(rar->lzss.window, 0, rar->dictionary_size);
    rar->lzss.mask = rar->dictionary_size - 1;
  }

  rar->start_new_table = 0;
  return (ARCHIVE_OK);
truncated_data:
  archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                    ""Truncated RAR file data"");
  rar->valid = 0;
  return (ARCHIVE_FATAL);
}
",C,"    if (new_size == 0) {
      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                        ""Zero window size is invalid."");
      return (ARCHIVE_FATAL);
    }
",,,"@@ -2300,6 +2300,11 @@ parse_codes(struct archive_read *a)
       new_size = DICTIONARY_MAX_SIZE;
     else
       new_size = rar_fls((unsigned int)rar->unp_size) << 1;
+    if (new_size == 0) {
+      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                        ""Zero window size is invalid."");
+      return (ARCHIVE_FATAL);
+    }
     new_window = realloc(rar->lzss.window, new_size);
     if (new_window == NULL) {
       archive_set_error(&a->archive, ENOMEM,",libarchive,021efa522ad729ff0f5806c4ce53e4a6cc1daa31,851adb9602f1acdb090067bb4f297cd609dfa28c,1,"parse_codes(struct archive_read *a)
{
  int i, j, val, n, r;
  unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;
  unsigned int maxorder;
  struct huffman_code precode;
  struct rar *rar = (struct rar *)(a->format->data);
  struct rar_br *br = &(rar->br);

  free_codes(a);

  /* Skip to the next byte */
  rar_br_consume_unalined_bits(br);

  /* PPMd block flag */
  if (!rar_br_read_ahead(a, br, 1))
    goto truncated_data;
  if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0)
  {
    rar_br_consume(br, 1);
    if (!rar_br_read_ahead(a, br, 7))
      goto truncated_data;
    ppmd_flags = rar_br_bits(br, 7);
    rar_br_consume(br, 7);

    /* Memory is allocated in MB */
    if (ppmd_flags & 0x20)
    {
      if (!rar_br_read_ahead(a, br, 8))
        goto truncated_data;
      rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20;
      rar_br_consume(br, 8);
    }

    if (ppmd_flags & 0x40)
    {
      if (!rar_br_read_ahead(a, br, 8))
        goto truncated_data;
      rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8);
      rar_br_consume(br, 8);
    }
    else
      rar->ppmd_escape = 2;

    if (ppmd_flags & 0x20)
    {
      maxorder = (ppmd_flags & 0x1F) + 1;
      if(maxorder > 16)
        maxorder = 16 + (maxorder - 16) * 3;

      if (maxorder == 1)
      {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Truncated RAR file data"");
        return (ARCHIVE_FATAL);
      }

      /* Make sure ppmd7_contest is freed before Ppmd7_Construct
       * because reading a broken file cause this abnormal sequence. */
      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);

      rar->bytein.a = a;
      rar->bytein.Read = &ppmd_read;
      __archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);
      rar->range_dec.Stream = &rar->bytein;
      __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);

      if (rar->dictionary_size == 0) {
	      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Invalid zero dictionary size"");
	      return (ARCHIVE_FATAL);
      }

      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,
        rar->dictionary_size))
      {
        archive_set_error(&a->archive, ENOMEM,
                          ""Out of memory"");
        return (ARCHIVE_FATAL);
      }
      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))
      {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Unable to initialize PPMd range decoder"");
        return (ARCHIVE_FATAL);
      }
      __archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder);
      rar->ppmd_valid = 1;
    }
    else
    {
      if (!rar->ppmd_valid) {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Invalid PPMd sequence"");
        return (ARCHIVE_FATAL);
      }
      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))
      {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Unable to initialize PPMd range decoder"");
        return (ARCHIVE_FATAL);
      }
    }
  }
  else
  {
    rar_br_consume(br, 1);

    /* Keep existing table flag */
    if (!rar_br_read_ahead(a, br, 1))
      goto truncated_data;
    if (!rar_br_bits(br, 1))
      memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
    rar_br_consume(br, 1);

    memset(&bitlengths, 0, sizeof(bitlengths));
    for (i = 0; i < MAX_SYMBOLS;)
    {
      if (!rar_br_read_ahead(a, br, 4))
        goto truncated_data;
      bitlengths[i++] = rar_br_bits(br, 4);
      rar_br_consume(br, 4);
      if (bitlengths[i-1] == 0xF)
      {
        if (!rar_br_read_ahead(a, br, 4))
          goto truncated_data;
        zerocount = rar_br_bits(br, 4);
        rar_br_consume(br, 4);
        if (zerocount)
        {
          i--;
          for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++)
            bitlengths[i++] = 0;
        }
      }
    }

    memset(&precode, 0, sizeof(precode));
    r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK) {
      free(precode.tree);
      free(precode.table);
      return (r);
    }

    for (i = 0; i < HUFFMAN_TABLE_SIZE;)
    {
      if ((val = read_next_symbol(a, &precode)) < 0) {
        free(precode.tree);
        free(precode.table);
        return (ARCHIVE_FATAL);
      }
      if (val < 16)
      {
        rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF;
        i++;
      }
      else if (val < 18)
      {
        if (i == 0)
        {
          free(precode.tree);
          free(precode.table);
          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                            ""Internal error extracting RAR file."");
          return (ARCHIVE_FATAL);
        }

        if(val == 16) {
          if (!rar_br_read_ahead(a, br, 3)) {
            free(precode.tree);
            free(precode.table);
            goto truncated_data;
          }
          n = rar_br_bits(br, 3) + 3;
          rar_br_consume(br, 3);
        } else {
          if (!rar_br_read_ahead(a, br, 7)) {
            free(precode.tree);
            free(precode.table);
            goto truncated_data;
          }
          n = rar_br_bits(br, 7) + 11;
          rar_br_consume(br, 7);
        }

        for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)
        {
          rar->lengthtable[i] = rar->lengthtable[i-1];
          i++;
        }
      }
      else
      {
        if(val == 18) {
          if (!rar_br_read_ahead(a, br, 3)) {
            free(precode.tree);
            free(precode.table);
            goto truncated_data;
          }
          n = rar_br_bits(br, 3) + 3;
          rar_br_consume(br, 3);
        } else {
          if (!rar_br_read_ahead(a, br, 7)) {
            free(precode.tree);
            free(precode.table);
            goto truncated_data;
          }
          n = rar_br_bits(br, 7) + 11;
          rar_br_consume(br, 7);
        }

        for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)
          rar->lengthtable[i++] = 0;
      }
    }
    free(precode.tree);
    free(precode.table);

    r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE,
                MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK)
      return (r);
    r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE],
                OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK)
      return (r);
    r = create_code(a, &rar->lowoffsetcode,
                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE],
                LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK)
      return (r);
    r = create_code(a, &rar->lengthcode,
                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE +
                LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK)
      return (r);
  }

  if (!rar->dictionary_size || !rar->lzss.window)
  {
    /* Seems as though dictionary sizes are not used. Even so, minimize
     * memory usage as much as possible.
     */
    void *new_window;
    unsigned int new_size;

    if (rar->unp_size >= DICTIONARY_MAX_SIZE)
       new_size = DICTIONARY_MAX_SIZE;
     else
       new_size = rar_fls((unsigned int)rar->unp_size) << 1;
//fix_flaw_line_below:
//    if (new_size == 0) {
//fix_flaw_line_below:
//      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
//fix_flaw_line_below:
//                        ""Zero window size is invalid."");
//fix_flaw_line_below:
//      return (ARCHIVE_FATAL);
//fix_flaw_line_below:
//    }
     new_window = realloc(rar->lzss.window, new_size);
     if (new_window == NULL) {
       archive_set_error(&a->archive, ENOMEM,
                        ""Unable to allocate memory for uncompressed data."");
      return (ARCHIVE_FATAL);
    }
    rar->lzss.window = (unsigned char *)new_window;
    rar->dictionary_size = new_size;
    memset(rar->lzss.window, 0, rar->dictionary_size);
    rar->lzss.mask = rar->dictionary_size - 1;
  }

  rar->start_new_table = 0;
  return (ARCHIVE_OK);
truncated_data:
  archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                    ""Truncated RAR file data"");
  rar->valid = 0;
  return (ARCHIVE_FATAL);
}
"
4507,182243,,Local,Not required,Partial,CVE-2018-16425,https://www.cvedetails.com/cve/CVE-2018-16425/,CWE-415,Low,Partial,Partial,,2018-09-03,4.6,A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,2019-09-11,DoS ,1,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,"fixed out of bounds writes

Thanks to Eric Sesterhenn from X41 D-SEC GmbH
for reporting the problems.",1,src/libopensc/card-cac.c,"{""sha"": ""756788a0fbbbed8487e8cf33b6115bb4d4f58860"", ""filename"": ""src/libopensc/card-cac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-cac.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -794,7 +794,7 @@ static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri\n         }\n \tif (priv->cac_id_len) {\n \t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n-\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n+\t\tmemcpy(serial->value, priv->cac_id, serial->len);\n \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n \t}\n \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);""}<_**next**_>{""sha"": ""65a58f6740d38e6fd6204cbacb5015995067334f"", ""filename"": ""src/libopensc/card-epass2003.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-epass2003.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -951,7 +951,7 @@ decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned\n \twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n \t\tcipher_len--;\n \n-\tif (2 == cipher_len)\n+\tif (2 == cipher_len || *out_len < cipher_len - 2)\n \t\treturn -1;\n \n \tmemcpy(out, plaintext, cipher_len - 2);\n@@ -977,6 +977,7 @@ epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apd\n \tr = sc_check_sw(card, sm->sw1, sm->sw2);\n \tif (r == SC_SUCCESS) {\n \t\tif (exdata->sm) {\n+\t\t\tlen = plain->resplen;\n \t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n \t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n \t\t}""}<_**next**_>{""sha"": ""d247efabc9fd2d7978e4a24dc42bcaccd42f3bee"", ""filename"": ""src/libopensc/card-muscle.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-muscle.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -518,7 +518,9 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \tmscfs_check_cache(priv->fs);\n \n \tfor(x = 0; x < fs->cache.size; x++) {\n-\t\tu8* oid= fs->cache.array[x].objectId.id;\n+\t\tu8* oid = fs->cache.array[x].objectId.id;\n+\t\tif (bufLen < 2)\n+\t\t\tbreak;\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n \t\t\t\""FILE: %02X%02X%02X%02X\\n\"",\n \t\t\toid[0],oid[1],oid[2],oid[3]);\n@@ -527,7 +529,8 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \t\t\tbuf[1] = oid[3];\n \t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n \t\t\tbuf += 2;\n-\t\t\tcount+=2;\n+\t\t\tcount += 2;\n+\t\t\tbufLen -= 2;\n \t\t}\n \t}\n \treturn count;""}<_**next**_>{""sha"": ""3c86b1f4838a5837341ae9cfc9b7fdb5334fe138"", ""filename"": ""src/libopensc/card-tcos.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-tcos.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -408,7 +408,7 @@ static int tcos_select_file(sc_card_t *card,\n \tfile->path = *in_path;\n \n \tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n-\t\tint j, len=apdu.resp[i+1];\n+\t\tsize_t j, len=apdu.resp[i+1];\n \t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n \n \t\tswitch (type) {\n@@ -432,8 +432,8 @@ static int tcos_select_file(sc_card_t *card,\n \t\t\tfile->id = (d[0]<<8) | d[1];\n \t\t\tbreak;\n \t\tcase 0x84:\n-\t\t\tmemcpy(file->name, d, len);\n-\t\t\tfile->namelen = len;\n+\t\t\tfile->namelen = MIN(sizeof file->name, len);\n+\t\t\tmemcpy(file->name, d, file->namelen);\n \t\t\tbreak;\n \t\tcase 0x86:\n \t\t\tsc_file_set_sec_attr(file, d, len); ""}<_**next**_>{""sha"": ""2b8d66b913b0d3ce3c92c0578c43ae847f98d2c7"", ""filename"": ""src/libopensc/pkcs15-esteid.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-esteid.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -79,7 +79,7 @@ sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n \t/* read the serial (document number) */\n \tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \""read document number failed\"");\n-\tbuff[r] = '\\0';\n+\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n \tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n \n \tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION""}<_**next**_>{""sha"": ""3b220f7a5b37ea236b58ef543d01ca08c815b826"", ""filename"": ""src/libopensc/pkcs15-gemsafeV1.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-gemsafeV1.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -208,7 +208,7 @@ static int gemsafe_get_cert_len(sc_card_t *card)\n \t * the private key.\n \t */\n \tind = 2; /* skip length */\n-\twhile (ibuf[ind] == 0x01) {\n+\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n \t\tif (ibuf[ind+1] == 0xFE) {\n \t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n \t\t\tsc_log(card->ctx, \""Key container %d is allocated and uses key_ref %d\"",""}<_**next**_>{""sha"": ""1391bea15370cd020dfdf1cfb0d9c24db950a0c4"", ""filename"": ""src/libopensc/pkcs15-sc-hsm.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-sc-hsm.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -837,12 +837,14 @@ static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n \t\tr = read_file(p15card, (u8 *) \""\\x2F\\x02\"", efbin, &len, 1);\n \t\tLOG_TEST_RET(card->ctx, r, \""Skipping optional EF.C_DevAut\"");\n \n-\t\t/* save EF_C_DevAut for further use */\n-\t\tptr = realloc(priv->EF_C_DevAut, len);\n-\t\tif (ptr) {\n-\t\t\tmemcpy(ptr, efbin, len);\n-\t\t\tpriv->EF_C_DevAut = ptr;\n-\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\tif (len > 0) {\n+\t\t\t/* save EF_C_DevAut for further use */\n+\t\t\tptr = realloc(priv->EF_C_DevAut, len);\n+\t\t\tif (ptr) {\n+\t\t\t\tmemcpy(ptr, efbin, len);\n+\t\t\t\tpriv->EF_C_DevAut = ptr;\n+\t\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\t\t}\n \t\t}\n \n \t\tptr = efbin;""}<_**next**_>{""sha"": ""53fefb3e68eac554ed608a5a960cf3dd5f5b8dcb"", ""filename"": ""src/libopensc/sc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/sc.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -628,7 +628,7 @@ int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n \t\treturn SC_ERROR_INVALID_ARGUMENTS;\n \t}\n \n-\tif (sec_attr == NULL) {\n+\tif (sec_attr == NULL || sec_attr_len) {\n \t\tif (file->sec_attr != NULL)\n \t\t\tfree(file->sec_attr);\n \t\tfile->sec_attr = NULL;""}<_**next**_>{""sha"": ""662a028222a909f431f31c60bc421fa83d86d5b6"", ""filename"": ""src/tools/cryptoflex-tool.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/cryptoflex-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -21,6 +21,7 @@\n #include \""config.h\""\n \n #include \""libopensc/sc-ossl-compat.h\""\n+#include \""libopensc/internal.h\""\n #include <openssl/bn.h>\n #include <openssl/rsa.h>\n #include <openssl/x509.h>\n@@ -331,7 +332,7 @@ static int read_public_key(RSA *rsa)\n \t\tfprintf(stderr, \""Unable to select public key file: %s\\n\"", sc_strerror(r));\n \t\treturn 2;\n \t}\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {\n@@ -382,7 +383,7 @@ static int read_private_key(RSA *rsa)\n \te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n \tif (e == NULL || e->method == SC_AC_NEVER)\n \t\treturn 10;\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {""}<_**next**_>{""sha"": ""31360833b5284915ae8d93babeb3fdb1b279a0f3"", ""filename"": ""src/tools/egk-tool.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/egk-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -149,7 +149,7 @@ int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t\n \t\tgoto err;\n \t}\n \n-\tlen = file ? file->size : 4096;\n+\tlen = file && file->size > 0 ? file->size : 4096;\n \tp = realloc(*data, len);\n \tif (!p) {\n \t\tgoto err;""}<_**next**_>{""sha"": ""e49647a472e921663b2952ef5cf213c9fc974beb"", ""filename"": ""src/tools/util.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/util.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -339,10 +339,11 @@ const char * util_acl_to_str(const sc_acl_entry_t *e)\n \t\t\tstrcpy(buf, \""????\"");\n \t\t\tbreak;\n \t\t}\n-\t\tstrcat(line, buf);\n-\t\tstrcat(line, \"" \"");\n+\t\tstrncat(line, buf, sizeof line);\n+\t\tstrncat(line, \"" \"", sizeof line);\n \t\te = e->next;\n \t}\n+\tline[(sizeof line)-1] = '\\0'; /* make sure it's NUL terminated */\n \tline[strlen(line)-1] = 0; /* get rid of trailing space */\n \treturn line;\n }""}","static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)
{
	cac_private_data_t * priv = CAC_DATA(card);

	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_NORMAL);
        if (card->serialnr.len)   {
                *serial = card->serialnr;
                SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
         }
 	if (priv->cac_id_len) {
 		serial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);
		memcpy(serial->value, priv->cac_id, serial->len);
 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
 	}
 	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);
}
","static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)
{
	cac_private_data_t * priv = CAC_DATA(card);

	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_NORMAL);
        if (card->serialnr.len)   {
                *serial = card->serialnr;
                SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
         }
 	if (priv->cac_id_len) {
 		serial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);
		memcpy(serial->value, priv->cac_id, priv->cac_id_len);
 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
 	}
 	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);
}
",C,"		memcpy(serial->value, priv->cac_id, serial->len);
","		memcpy(serial->value, priv->cac_id, priv->cac_id_len);
",,"@@ -794,7 +794,7 @@ static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri
         }
 	if (priv->cac_id_len) {
 		serial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);
-		memcpy(serial->value, priv->cac_id, priv->cac_id_len);
+		memcpy(serial->value, priv->cac_id, serial->len);
 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
 	}
 	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);",OpenSC,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,8fe377e93b4b56060e5bbfb6f3142ceaeca744fa,1,"static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)
{
	cac_private_data_t * priv = CAC_DATA(card);

	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_NORMAL);
        if (card->serialnr.len)   {
                *serial = card->serialnr;
                SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
         }
 	if (priv->cac_id_len) {
 		serial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);
//flaw_line_below:
		memcpy(serial->value, priv->cac_id, priv->cac_id_len);
//fix_flaw_line_below:
//		memcpy(serial->value, priv->cac_id, serial->len);
 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
 	}
 	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);
}
"
4508,182244,,Local,Not required,Partial,CVE-2018-16425,https://www.cvedetails.com/cve/CVE-2018-16425/,CWE-415,Low,Partial,Partial,,2018-09-03,4.6,A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,2019-09-11,DoS ,1,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,"fixed out of bounds writes

Thanks to Eric Sesterhenn from X41 D-SEC GmbH
for reporting the problems.",1,src/libopensc/card-epass2003.c,"{""sha"": ""756788a0fbbbed8487e8cf33b6115bb4d4f58860"", ""filename"": ""src/libopensc/card-cac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-cac.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -794,7 +794,7 @@ static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri\n         }\n \tif (priv->cac_id_len) {\n \t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n-\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n+\t\tmemcpy(serial->value, priv->cac_id, serial->len);\n \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n \t}\n \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);""}<_**next**_>{""sha"": ""65a58f6740d38e6fd6204cbacb5015995067334f"", ""filename"": ""src/libopensc/card-epass2003.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-epass2003.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -951,7 +951,7 @@ decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned\n \twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n \t\tcipher_len--;\n \n-\tif (2 == cipher_len)\n+\tif (2 == cipher_len || *out_len < cipher_len - 2)\n \t\treturn -1;\n \n \tmemcpy(out, plaintext, cipher_len - 2);\n@@ -977,6 +977,7 @@ epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apd\n \tr = sc_check_sw(card, sm->sw1, sm->sw2);\n \tif (r == SC_SUCCESS) {\n \t\tif (exdata->sm) {\n+\t\t\tlen = plain->resplen;\n \t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n \t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n \t\t}""}<_**next**_>{""sha"": ""d247efabc9fd2d7978e4a24dc42bcaccd42f3bee"", ""filename"": ""src/libopensc/card-muscle.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-muscle.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -518,7 +518,9 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \tmscfs_check_cache(priv->fs);\n \n \tfor(x = 0; x < fs->cache.size; x++) {\n-\t\tu8* oid= fs->cache.array[x].objectId.id;\n+\t\tu8* oid = fs->cache.array[x].objectId.id;\n+\t\tif (bufLen < 2)\n+\t\t\tbreak;\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n \t\t\t\""FILE: %02X%02X%02X%02X\\n\"",\n \t\t\toid[0],oid[1],oid[2],oid[3]);\n@@ -527,7 +529,8 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \t\t\tbuf[1] = oid[3];\n \t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n \t\t\tbuf += 2;\n-\t\t\tcount+=2;\n+\t\t\tcount += 2;\n+\t\t\tbufLen -= 2;\n \t\t}\n \t}\n \treturn count;""}<_**next**_>{""sha"": ""3c86b1f4838a5837341ae9cfc9b7fdb5334fe138"", ""filename"": ""src/libopensc/card-tcos.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-tcos.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -408,7 +408,7 @@ static int tcos_select_file(sc_card_t *card,\n \tfile->path = *in_path;\n \n \tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n-\t\tint j, len=apdu.resp[i+1];\n+\t\tsize_t j, len=apdu.resp[i+1];\n \t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n \n \t\tswitch (type) {\n@@ -432,8 +432,8 @@ static int tcos_select_file(sc_card_t *card,\n \t\t\tfile->id = (d[0]<<8) | d[1];\n \t\t\tbreak;\n \t\tcase 0x84:\n-\t\t\tmemcpy(file->name, d, len);\n-\t\t\tfile->namelen = len;\n+\t\t\tfile->namelen = MIN(sizeof file->name, len);\n+\t\t\tmemcpy(file->name, d, file->namelen);\n \t\t\tbreak;\n \t\tcase 0x86:\n \t\t\tsc_file_set_sec_attr(file, d, len); ""}<_**next**_>{""sha"": ""2b8d66b913b0d3ce3c92c0578c43ae847f98d2c7"", ""filename"": ""src/libopensc/pkcs15-esteid.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-esteid.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -79,7 +79,7 @@ sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n \t/* read the serial (document number) */\n \tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \""read document number failed\"");\n-\tbuff[r] = '\\0';\n+\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n \tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n \n \tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION""}<_**next**_>{""sha"": ""3b220f7a5b37ea236b58ef543d01ca08c815b826"", ""filename"": ""src/libopensc/pkcs15-gemsafeV1.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-gemsafeV1.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -208,7 +208,7 @@ static int gemsafe_get_cert_len(sc_card_t *card)\n \t * the private key.\n \t */\n \tind = 2; /* skip length */\n-\twhile (ibuf[ind] == 0x01) {\n+\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n \t\tif (ibuf[ind+1] == 0xFE) {\n \t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n \t\t\tsc_log(card->ctx, \""Key container %d is allocated and uses key_ref %d\"",""}<_**next**_>{""sha"": ""1391bea15370cd020dfdf1cfb0d9c24db950a0c4"", ""filename"": ""src/libopensc/pkcs15-sc-hsm.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-sc-hsm.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -837,12 +837,14 @@ static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n \t\tr = read_file(p15card, (u8 *) \""\\x2F\\x02\"", efbin, &len, 1);\n \t\tLOG_TEST_RET(card->ctx, r, \""Skipping optional EF.C_DevAut\"");\n \n-\t\t/* save EF_C_DevAut for further use */\n-\t\tptr = realloc(priv->EF_C_DevAut, len);\n-\t\tif (ptr) {\n-\t\t\tmemcpy(ptr, efbin, len);\n-\t\t\tpriv->EF_C_DevAut = ptr;\n-\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\tif (len > 0) {\n+\t\t\t/* save EF_C_DevAut for further use */\n+\t\t\tptr = realloc(priv->EF_C_DevAut, len);\n+\t\t\tif (ptr) {\n+\t\t\t\tmemcpy(ptr, efbin, len);\n+\t\t\t\tpriv->EF_C_DevAut = ptr;\n+\t\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\t\t}\n \t\t}\n \n \t\tptr = efbin;""}<_**next**_>{""sha"": ""53fefb3e68eac554ed608a5a960cf3dd5f5b8dcb"", ""filename"": ""src/libopensc/sc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/sc.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -628,7 +628,7 @@ int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n \t\treturn SC_ERROR_INVALID_ARGUMENTS;\n \t}\n \n-\tif (sec_attr == NULL) {\n+\tif (sec_attr == NULL || sec_attr_len) {\n \t\tif (file->sec_attr != NULL)\n \t\t\tfree(file->sec_attr);\n \t\tfile->sec_attr = NULL;""}<_**next**_>{""sha"": ""662a028222a909f431f31c60bc421fa83d86d5b6"", ""filename"": ""src/tools/cryptoflex-tool.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/cryptoflex-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -21,6 +21,7 @@\n #include \""config.h\""\n \n #include \""libopensc/sc-ossl-compat.h\""\n+#include \""libopensc/internal.h\""\n #include <openssl/bn.h>\n #include <openssl/rsa.h>\n #include <openssl/x509.h>\n@@ -331,7 +332,7 @@ static int read_public_key(RSA *rsa)\n \t\tfprintf(stderr, \""Unable to select public key file: %s\\n\"", sc_strerror(r));\n \t\treturn 2;\n \t}\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {\n@@ -382,7 +383,7 @@ static int read_private_key(RSA *rsa)\n \te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n \tif (e == NULL || e->method == SC_AC_NEVER)\n \t\treturn 10;\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {""}<_**next**_>{""sha"": ""31360833b5284915ae8d93babeb3fdb1b279a0f3"", ""filename"": ""src/tools/egk-tool.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/egk-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -149,7 +149,7 @@ int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t\n \t\tgoto err;\n \t}\n \n-\tlen = file ? file->size : 4096;\n+\tlen = file && file->size > 0 ? file->size : 4096;\n \tp = realloc(*data, len);\n \tif (!p) {\n \t\tgoto err;""}<_**next**_>{""sha"": ""e49647a472e921663b2952ef5cf213c9fc974beb"", ""filename"": ""src/tools/util.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/util.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -339,10 +339,11 @@ const char * util_acl_to_str(const sc_acl_entry_t *e)\n \t\t\tstrcpy(buf, \""????\"");\n \t\t\tbreak;\n \t\t}\n-\t\tstrcat(line, buf);\n-\t\tstrcat(line, \"" \"");\n+\t\tstrncat(line, buf, sizeof line);\n+\t\tstrncat(line, \"" \"", sizeof line);\n \t\te = e->next;\n \t}\n+\tline[(sizeof line)-1] = '\\0'; /* make sure it's NUL terminated */\n \tline[strlen(line)-1] = 0; /* get rid of trailing space */\n \treturn line;\n }""}","decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned char *out, size_t * out_len)
{
	size_t cipher_len;
	size_t i;
	unsigned char iv[16] = { 0 };
	unsigned char plaintext[4096] = { 0 };
	epass2003_exdata *exdata = NULL;

	if (!card->drv_data) 
		return SC_ERROR_INVALID_ARGUMENTS;

	exdata = (epass2003_exdata *)card->drv_data;

	/* no cipher */
	if (in[0] == 0x99)
		return 0;

	/* parse cipher length */
	if (0x01 == in[2] && 0x82 != in[1]) {
		cipher_len = in[1];
		i = 3;
	}
	else if (0x01 == in[3] && 0x81 == in[1]) {
		cipher_len = in[2];
		i = 4;
	}
	else if (0x01 == in[4] && 0x82 == in[1]) {
		cipher_len = in[2] * 0x100;
		cipher_len += in[3];
		i = 5;
	}
	else {
		return -1;
	}

	if (cipher_len < 2 || i+cipher_len > inlen || cipher_len > sizeof plaintext)
		return -1;

	/* decrypt */
	if (KEY_TYPE_AES == exdata->smtype)
		aes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);
	else
		des3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);

	/* unpadding */
 	while (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))
 		cipher_len--;
 
	if (2 == cipher_len || *out_len < cipher_len - 2)
 		return -1;
 
 	memcpy(out, plaintext, cipher_len - 2);
	*out_len = cipher_len - 2;
	return 0;
}
","decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned char *out, size_t * out_len)
{
	size_t cipher_len;
	size_t i;
	unsigned char iv[16] = { 0 };
	unsigned char plaintext[4096] = { 0 };
	epass2003_exdata *exdata = NULL;

	if (!card->drv_data) 
		return SC_ERROR_INVALID_ARGUMENTS;

	exdata = (epass2003_exdata *)card->drv_data;

	/* no cipher */
	if (in[0] == 0x99)
		return 0;

	/* parse cipher length */
	if (0x01 == in[2] && 0x82 != in[1]) {
		cipher_len = in[1];
		i = 3;
	}
	else if (0x01 == in[3] && 0x81 == in[1]) {
		cipher_len = in[2];
		i = 4;
	}
	else if (0x01 == in[4] && 0x82 == in[1]) {
		cipher_len = in[2] * 0x100;
		cipher_len += in[3];
		i = 5;
	}
	else {
		return -1;
	}

	if (cipher_len < 2 || i+cipher_len > inlen || cipher_len > sizeof plaintext)
		return -1;

	/* decrypt */
	if (KEY_TYPE_AES == exdata->smtype)
		aes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);
	else
		des3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);

	/* unpadding */
 	while (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))
 		cipher_len--;
 
	if (2 == cipher_len)
 		return -1;
 
 	memcpy(out, plaintext, cipher_len - 2);
	*out_len = cipher_len - 2;
	return 0;
}
",C,"	if (2 == cipher_len || *out_len < cipher_len - 2)
","	if (2 == cipher_len)
",,"@@ -951,7 +951,7 @@ decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned
 	while (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))
 		cipher_len--;
 
-	if (2 == cipher_len)
+	if (2 == cipher_len || *out_len < cipher_len - 2)
 		return -1;
 
 	memcpy(out, plaintext, cipher_len - 2);
@@ -977,6 +977,7 @@ epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apd
 	r = sc_check_sw(card, sm->sw1, sm->sw2);
 	if (r == SC_SUCCESS) {
 		if (exdata->sm) {
+			len = plain->resplen;
 			if (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))
 				return SC_ERROR_CARD_CMD_FAILED;
 		}",OpenSC,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,8fe377e93b4b56060e5bbfb6f3142ceaeca744fa,1,"decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned char *out, size_t * out_len)
{
	size_t cipher_len;
	size_t i;
	unsigned char iv[16] = { 0 };
	unsigned char plaintext[4096] = { 0 };
	epass2003_exdata *exdata = NULL;

	if (!card->drv_data) 
		return SC_ERROR_INVALID_ARGUMENTS;

	exdata = (epass2003_exdata *)card->drv_data;

	/* no cipher */
	if (in[0] == 0x99)
		return 0;

	/* parse cipher length */
	if (0x01 == in[2] && 0x82 != in[1]) {
		cipher_len = in[1];
		i = 3;
	}
	else if (0x01 == in[3] && 0x81 == in[1]) {
		cipher_len = in[2];
		i = 4;
	}
	else if (0x01 == in[4] && 0x82 == in[1]) {
		cipher_len = in[2] * 0x100;
		cipher_len += in[3];
		i = 5;
	}
	else {
		return -1;
	}

	if (cipher_len < 2 || i+cipher_len > inlen || cipher_len > sizeof plaintext)
		return -1;

	/* decrypt */
	if (KEY_TYPE_AES == exdata->smtype)
		aes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);
	else
		des3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);

	/* unpadding */
 	while (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))
 		cipher_len--;
 
//flaw_line_below:
	if (2 == cipher_len)
//fix_flaw_line_below:
//	if (2 == cipher_len || *out_len < cipher_len - 2)
 		return -1;
 
 	memcpy(out, plaintext, cipher_len - 2);
	*out_len = cipher_len - 2;
	return 0;
}
"
4509,182245,,Local,Not required,Partial,CVE-2018-16425,https://www.cvedetails.com/cve/CVE-2018-16425/,CWE-415,Low,Partial,Partial,,2018-09-03,4.6,A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,2019-09-11,DoS ,1,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,"fixed out of bounds writes

Thanks to Eric Sesterhenn from X41 D-SEC GmbH
for reporting the problems.",0,src/libopensc/card-epass2003.c,"{""sha"": ""756788a0fbbbed8487e8cf33b6115bb4d4f58860"", ""filename"": ""src/libopensc/card-cac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-cac.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -794,7 +794,7 @@ static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri\n         }\n \tif (priv->cac_id_len) {\n \t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n-\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n+\t\tmemcpy(serial->value, priv->cac_id, serial->len);\n \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n \t}\n \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);""}<_**next**_>{""sha"": ""65a58f6740d38e6fd6204cbacb5015995067334f"", ""filename"": ""src/libopensc/card-epass2003.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-epass2003.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -951,7 +951,7 @@ decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned\n \twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n \t\tcipher_len--;\n \n-\tif (2 == cipher_len)\n+\tif (2 == cipher_len || *out_len < cipher_len - 2)\n \t\treturn -1;\n \n \tmemcpy(out, plaintext, cipher_len - 2);\n@@ -977,6 +977,7 @@ epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apd\n \tr = sc_check_sw(card, sm->sw1, sm->sw2);\n \tif (r == SC_SUCCESS) {\n \t\tif (exdata->sm) {\n+\t\t\tlen = plain->resplen;\n \t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n \t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n \t\t}""}<_**next**_>{""sha"": ""d247efabc9fd2d7978e4a24dc42bcaccd42f3bee"", ""filename"": ""src/libopensc/card-muscle.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-muscle.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -518,7 +518,9 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \tmscfs_check_cache(priv->fs);\n \n \tfor(x = 0; x < fs->cache.size; x++) {\n-\t\tu8* oid= fs->cache.array[x].objectId.id;\n+\t\tu8* oid = fs->cache.array[x].objectId.id;\n+\t\tif (bufLen < 2)\n+\t\t\tbreak;\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n \t\t\t\""FILE: %02X%02X%02X%02X\\n\"",\n \t\t\toid[0],oid[1],oid[2],oid[3]);\n@@ -527,7 +529,8 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \t\t\tbuf[1] = oid[3];\n \t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n \t\t\tbuf += 2;\n-\t\t\tcount+=2;\n+\t\t\tcount += 2;\n+\t\t\tbufLen -= 2;\n \t\t}\n \t}\n \treturn count;""}<_**next**_>{""sha"": ""3c86b1f4838a5837341ae9cfc9b7fdb5334fe138"", ""filename"": ""src/libopensc/card-tcos.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-tcos.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -408,7 +408,7 @@ static int tcos_select_file(sc_card_t *card,\n \tfile->path = *in_path;\n \n \tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n-\t\tint j, len=apdu.resp[i+1];\n+\t\tsize_t j, len=apdu.resp[i+1];\n \t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n \n \t\tswitch (type) {\n@@ -432,8 +432,8 @@ static int tcos_select_file(sc_card_t *card,\n \t\t\tfile->id = (d[0]<<8) | d[1];\n \t\t\tbreak;\n \t\tcase 0x84:\n-\t\t\tmemcpy(file->name, d, len);\n-\t\t\tfile->namelen = len;\n+\t\t\tfile->namelen = MIN(sizeof file->name, len);\n+\t\t\tmemcpy(file->name, d, file->namelen);\n \t\t\tbreak;\n \t\tcase 0x86:\n \t\t\tsc_file_set_sec_attr(file, d, len); ""}<_**next**_>{""sha"": ""2b8d66b913b0d3ce3c92c0578c43ae847f98d2c7"", ""filename"": ""src/libopensc/pkcs15-esteid.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-esteid.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -79,7 +79,7 @@ sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n \t/* read the serial (document number) */\n \tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \""read document number failed\"");\n-\tbuff[r] = '\\0';\n+\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n \tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n \n \tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION""}<_**next**_>{""sha"": ""3b220f7a5b37ea236b58ef543d01ca08c815b826"", ""filename"": ""src/libopensc/pkcs15-gemsafeV1.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-gemsafeV1.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -208,7 +208,7 @@ static int gemsafe_get_cert_len(sc_card_t *card)\n \t * the private key.\n \t */\n \tind = 2; /* skip length */\n-\twhile (ibuf[ind] == 0x01) {\n+\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n \t\tif (ibuf[ind+1] == 0xFE) {\n \t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n \t\t\tsc_log(card->ctx, \""Key container %d is allocated and uses key_ref %d\"",""}<_**next**_>{""sha"": ""1391bea15370cd020dfdf1cfb0d9c24db950a0c4"", ""filename"": ""src/libopensc/pkcs15-sc-hsm.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-sc-hsm.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -837,12 +837,14 @@ static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n \t\tr = read_file(p15card, (u8 *) \""\\x2F\\x02\"", efbin, &len, 1);\n \t\tLOG_TEST_RET(card->ctx, r, \""Skipping optional EF.C_DevAut\"");\n \n-\t\t/* save EF_C_DevAut for further use */\n-\t\tptr = realloc(priv->EF_C_DevAut, len);\n-\t\tif (ptr) {\n-\t\t\tmemcpy(ptr, efbin, len);\n-\t\t\tpriv->EF_C_DevAut = ptr;\n-\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\tif (len > 0) {\n+\t\t\t/* save EF_C_DevAut for further use */\n+\t\t\tptr = realloc(priv->EF_C_DevAut, len);\n+\t\t\tif (ptr) {\n+\t\t\t\tmemcpy(ptr, efbin, len);\n+\t\t\t\tpriv->EF_C_DevAut = ptr;\n+\t\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\t\t}\n \t\t}\n \n \t\tptr = efbin;""}<_**next**_>{""sha"": ""53fefb3e68eac554ed608a5a960cf3dd5f5b8dcb"", ""filename"": ""src/libopensc/sc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/sc.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -628,7 +628,7 @@ int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n \t\treturn SC_ERROR_INVALID_ARGUMENTS;\n \t}\n \n-\tif (sec_attr == NULL) {\n+\tif (sec_attr == NULL || sec_attr_len) {\n \t\tif (file->sec_attr != NULL)\n \t\t\tfree(file->sec_attr);\n \t\tfile->sec_attr = NULL;""}<_**next**_>{""sha"": ""662a028222a909f431f31c60bc421fa83d86d5b6"", ""filename"": ""src/tools/cryptoflex-tool.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/cryptoflex-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -21,6 +21,7 @@\n #include \""config.h\""\n \n #include \""libopensc/sc-ossl-compat.h\""\n+#include \""libopensc/internal.h\""\n #include <openssl/bn.h>\n #include <openssl/rsa.h>\n #include <openssl/x509.h>\n@@ -331,7 +332,7 @@ static int read_public_key(RSA *rsa)\n \t\tfprintf(stderr, \""Unable to select public key file: %s\\n\"", sc_strerror(r));\n \t\treturn 2;\n \t}\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {\n@@ -382,7 +383,7 @@ static int read_private_key(RSA *rsa)\n \te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n \tif (e == NULL || e->method == SC_AC_NEVER)\n \t\treturn 10;\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {""}<_**next**_>{""sha"": ""31360833b5284915ae8d93babeb3fdb1b279a0f3"", ""filename"": ""src/tools/egk-tool.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/egk-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -149,7 +149,7 @@ int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t\n \t\tgoto err;\n \t}\n \n-\tlen = file ? file->size : 4096;\n+\tlen = file && file->size > 0 ? file->size : 4096;\n \tp = realloc(*data, len);\n \tif (!p) {\n \t\tgoto err;""}<_**next**_>{""sha"": ""e49647a472e921663b2952ef5cf213c9fc974beb"", ""filename"": ""src/tools/util.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/util.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -339,10 +339,11 @@ const char * util_acl_to_str(const sc_acl_entry_t *e)\n \t\t\tstrcpy(buf, \""????\"");\n \t\t\tbreak;\n \t\t}\n-\t\tstrcat(line, buf);\n-\t\tstrcat(line, \"" \"");\n+\t\tstrncat(line, buf, sizeof line);\n+\t\tstrncat(line, \"" \"", sizeof line);\n \t\te = e->next;\n \t}\n+\tline[(sizeof line)-1] = '\\0'; /* make sure it's NUL terminated */\n \tline[strlen(line)-1] = 0; /* get rid of trailing space */\n \treturn line;\n }""}","epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)
{
	int r;
	size_t len = 0;
	epass2003_exdata *exdata = NULL;

	if (!card->drv_data) 
		return SC_ERROR_INVALID_ARGUMENTS;

	exdata = (epass2003_exdata *)card->drv_data;

	LOG_FUNC_CALLED(card->ctx);

 	r = sc_check_sw(card, sm->sw1, sm->sw2);
 	if (r == SC_SUCCESS) {
 		if (exdata->sm) {
			len = plain->resplen;
 			if (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))
 				return SC_ERROR_CARD_CMD_FAILED;
 		}
		else {
			memcpy(plain->resp, sm->resp, sm->resplen);
			len = sm->resplen;
		}
	}

	plain->resplen = len;
	plain->sw1 = sm->sw1;
	plain->sw2 = sm->sw2;

	sc_log(card->ctx,
	       ""unwrapped APDU: resplen %""SC_FORMAT_LEN_SIZE_T""u, SW %02X%02X"",
	       plain->resplen, plain->sw1, plain->sw2);
	LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);
}
","epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)
{
	int r;
	size_t len = 0;
	epass2003_exdata *exdata = NULL;

	if (!card->drv_data) 
		return SC_ERROR_INVALID_ARGUMENTS;

	exdata = (epass2003_exdata *)card->drv_data;

	LOG_FUNC_CALLED(card->ctx);

 	r = sc_check_sw(card, sm->sw1, sm->sw2);
 	if (r == SC_SUCCESS) {
 		if (exdata->sm) {
 			if (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))
 				return SC_ERROR_CARD_CMD_FAILED;
 		}
		else {
			memcpy(plain->resp, sm->resp, sm->resplen);
			len = sm->resplen;
		}
	}

	plain->resplen = len;
	plain->sw1 = sm->sw1;
	plain->sw2 = sm->sw2;

	sc_log(card->ctx,
	       ""unwrapped APDU: resplen %""SC_FORMAT_LEN_SIZE_T""u, SW %02X%02X"",
	       plain->resplen, plain->sw1, plain->sw2);
	LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);
}
",C,"			len = plain->resplen;
",,,"@@ -951,7 +951,7 @@ decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned
 	while (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))
 		cipher_len--;
 
-	if (2 == cipher_len)
+	if (2 == cipher_len || *out_len < cipher_len - 2)
 		return -1;
 
 	memcpy(out, plaintext, cipher_len - 2);
@@ -977,6 +977,7 @@ epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apd
 	r = sc_check_sw(card, sm->sw1, sm->sw2);
 	if (r == SC_SUCCESS) {
 		if (exdata->sm) {
+			len = plain->resplen;
 			if (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))
 				return SC_ERROR_CARD_CMD_FAILED;
 		}",OpenSC,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,8fe377e93b4b56060e5bbfb6f3142ceaeca744fa,1,"epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)
{
	int r;
	size_t len = 0;
	epass2003_exdata *exdata = NULL;

	if (!card->drv_data) 
		return SC_ERROR_INVALID_ARGUMENTS;

	exdata = (epass2003_exdata *)card->drv_data;

	LOG_FUNC_CALLED(card->ctx);

 	r = sc_check_sw(card, sm->sw1, sm->sw2);
 	if (r == SC_SUCCESS) {
 		if (exdata->sm) {
//fix_flaw_line_below:
//			len = plain->resplen;
 			if (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))
 				return SC_ERROR_CARD_CMD_FAILED;
 		}
		else {
			memcpy(plain->resp, sm->resp, sm->resplen);
			len = sm->resplen;
		}
	}

	plain->resplen = len;
	plain->sw1 = sm->sw1;
	plain->sw2 = sm->sw2;

	sc_log(card->ctx,
	       ""unwrapped APDU: resplen %""SC_FORMAT_LEN_SIZE_T""u, SW %02X%02X"",
	       plain->resplen, plain->sw1, plain->sw2);
	LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);
}
"
4510,182246,,Local,Not required,Partial,CVE-2018-16425,https://www.cvedetails.com/cve/CVE-2018-16425/,CWE-415,Low,Partial,Partial,,2018-09-03,4.6,A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,2019-09-11,DoS ,5,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,"fixed out of bounds writes

Thanks to Eric Sesterhenn from X41 D-SEC GmbH
for reporting the problems.",2,src/libopensc/card-muscle.c,"{""sha"": ""756788a0fbbbed8487e8cf33b6115bb4d4f58860"", ""filename"": ""src/libopensc/card-cac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-cac.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -794,7 +794,7 @@ static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri\n         }\n \tif (priv->cac_id_len) {\n \t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n-\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n+\t\tmemcpy(serial->value, priv->cac_id, serial->len);\n \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n \t}\n \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);""}<_**next**_>{""sha"": ""65a58f6740d38e6fd6204cbacb5015995067334f"", ""filename"": ""src/libopensc/card-epass2003.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-epass2003.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -951,7 +951,7 @@ decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned\n \twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n \t\tcipher_len--;\n \n-\tif (2 == cipher_len)\n+\tif (2 == cipher_len || *out_len < cipher_len - 2)\n \t\treturn -1;\n \n \tmemcpy(out, plaintext, cipher_len - 2);\n@@ -977,6 +977,7 @@ epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apd\n \tr = sc_check_sw(card, sm->sw1, sm->sw2);\n \tif (r == SC_SUCCESS) {\n \t\tif (exdata->sm) {\n+\t\t\tlen = plain->resplen;\n \t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n \t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n \t\t}""}<_**next**_>{""sha"": ""d247efabc9fd2d7978e4a24dc42bcaccd42f3bee"", ""filename"": ""src/libopensc/card-muscle.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-muscle.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -518,7 +518,9 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \tmscfs_check_cache(priv->fs);\n \n \tfor(x = 0; x < fs->cache.size; x++) {\n-\t\tu8* oid= fs->cache.array[x].objectId.id;\n+\t\tu8* oid = fs->cache.array[x].objectId.id;\n+\t\tif (bufLen < 2)\n+\t\t\tbreak;\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n \t\t\t\""FILE: %02X%02X%02X%02X\\n\"",\n \t\t\toid[0],oid[1],oid[2],oid[3]);\n@@ -527,7 +529,8 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \t\t\tbuf[1] = oid[3];\n \t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n \t\t\tbuf += 2;\n-\t\t\tcount+=2;\n+\t\t\tcount += 2;\n+\t\t\tbufLen -= 2;\n \t\t}\n \t}\n \treturn count;""}<_**next**_>{""sha"": ""3c86b1f4838a5837341ae9cfc9b7fdb5334fe138"", ""filename"": ""src/libopensc/card-tcos.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-tcos.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -408,7 +408,7 @@ static int tcos_select_file(sc_card_t *card,\n \tfile->path = *in_path;\n \n \tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n-\t\tint j, len=apdu.resp[i+1];\n+\t\tsize_t j, len=apdu.resp[i+1];\n \t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n \n \t\tswitch (type) {\n@@ -432,8 +432,8 @@ static int tcos_select_file(sc_card_t *card,\n \t\t\tfile->id = (d[0]<<8) | d[1];\n \t\t\tbreak;\n \t\tcase 0x84:\n-\t\t\tmemcpy(file->name, d, len);\n-\t\t\tfile->namelen = len;\n+\t\t\tfile->namelen = MIN(sizeof file->name, len);\n+\t\t\tmemcpy(file->name, d, file->namelen);\n \t\t\tbreak;\n \t\tcase 0x86:\n \t\t\tsc_file_set_sec_attr(file, d, len); ""}<_**next**_>{""sha"": ""2b8d66b913b0d3ce3c92c0578c43ae847f98d2c7"", ""filename"": ""src/libopensc/pkcs15-esteid.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-esteid.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -79,7 +79,7 @@ sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n \t/* read the serial (document number) */\n \tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \""read document number failed\"");\n-\tbuff[r] = '\\0';\n+\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n \tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n \n \tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION""}<_**next**_>{""sha"": ""3b220f7a5b37ea236b58ef543d01ca08c815b826"", ""filename"": ""src/libopensc/pkcs15-gemsafeV1.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-gemsafeV1.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -208,7 +208,7 @@ static int gemsafe_get_cert_len(sc_card_t *card)\n \t * the private key.\n \t */\n \tind = 2; /* skip length */\n-\twhile (ibuf[ind] == 0x01) {\n+\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n \t\tif (ibuf[ind+1] == 0xFE) {\n \t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n \t\t\tsc_log(card->ctx, \""Key container %d is allocated and uses key_ref %d\"",""}<_**next**_>{""sha"": ""1391bea15370cd020dfdf1cfb0d9c24db950a0c4"", ""filename"": ""src/libopensc/pkcs15-sc-hsm.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-sc-hsm.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -837,12 +837,14 @@ static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n \t\tr = read_file(p15card, (u8 *) \""\\x2F\\x02\"", efbin, &len, 1);\n \t\tLOG_TEST_RET(card->ctx, r, \""Skipping optional EF.C_DevAut\"");\n \n-\t\t/* save EF_C_DevAut for further use */\n-\t\tptr = realloc(priv->EF_C_DevAut, len);\n-\t\tif (ptr) {\n-\t\t\tmemcpy(ptr, efbin, len);\n-\t\t\tpriv->EF_C_DevAut = ptr;\n-\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\tif (len > 0) {\n+\t\t\t/* save EF_C_DevAut for further use */\n+\t\t\tptr = realloc(priv->EF_C_DevAut, len);\n+\t\t\tif (ptr) {\n+\t\t\t\tmemcpy(ptr, efbin, len);\n+\t\t\t\tpriv->EF_C_DevAut = ptr;\n+\t\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\t\t}\n \t\t}\n \n \t\tptr = efbin;""}<_**next**_>{""sha"": ""53fefb3e68eac554ed608a5a960cf3dd5f5b8dcb"", ""filename"": ""src/libopensc/sc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/sc.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -628,7 +628,7 @@ int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n \t\treturn SC_ERROR_INVALID_ARGUMENTS;\n \t}\n \n-\tif (sec_attr == NULL) {\n+\tif (sec_attr == NULL || sec_attr_len) {\n \t\tif (file->sec_attr != NULL)\n \t\t\tfree(file->sec_attr);\n \t\tfile->sec_attr = NULL;""}<_**next**_>{""sha"": ""662a028222a909f431f31c60bc421fa83d86d5b6"", ""filename"": ""src/tools/cryptoflex-tool.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/cryptoflex-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -21,6 +21,7 @@\n #include \""config.h\""\n \n #include \""libopensc/sc-ossl-compat.h\""\n+#include \""libopensc/internal.h\""\n #include <openssl/bn.h>\n #include <openssl/rsa.h>\n #include <openssl/x509.h>\n@@ -331,7 +332,7 @@ static int read_public_key(RSA *rsa)\n \t\tfprintf(stderr, \""Unable to select public key file: %s\\n\"", sc_strerror(r));\n \t\treturn 2;\n \t}\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {\n@@ -382,7 +383,7 @@ static int read_private_key(RSA *rsa)\n \te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n \tif (e == NULL || e->method == SC_AC_NEVER)\n \t\treturn 10;\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {""}<_**next**_>{""sha"": ""31360833b5284915ae8d93babeb3fdb1b279a0f3"", ""filename"": ""src/tools/egk-tool.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/egk-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -149,7 +149,7 @@ int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t\n \t\tgoto err;\n \t}\n \n-\tlen = file ? file->size : 4096;\n+\tlen = file && file->size > 0 ? file->size : 4096;\n \tp = realloc(*data, len);\n \tif (!p) {\n \t\tgoto err;""}<_**next**_>{""sha"": ""e49647a472e921663b2952ef5cf213c9fc974beb"", ""filename"": ""src/tools/util.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/util.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -339,10 +339,11 @@ const char * util_acl_to_str(const sc_acl_entry_t *e)\n \t\t\tstrcpy(buf, \""????\"");\n \t\t\tbreak;\n \t\t}\n-\t\tstrcat(line, buf);\n-\t\tstrcat(line, \"" \"");\n+\t\tstrncat(line, buf, sizeof line);\n+\t\tstrncat(line, \"" \"", sizeof line);\n \t\te = e->next;\n \t}\n+\tline[(sizeof line)-1] = '\\0'; /* make sure it's NUL terminated */\n \tline[strlen(line)-1] = 0; /* get rid of trailing space */\n \treturn line;\n }""}","static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)
{
	muscle_private_t* priv = MUSCLE_DATA(card);
	mscfs_t *fs = priv->fs;
	int x;
	int count = 0;

 	mscfs_check_cache(priv->fs);
 
 	for(x = 0; x < fs->cache.size; x++) {
		u8* oid = fs->cache.array[x].objectId.id;
		if (bufLen < 2)
			break;
 		sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,
 			""FILE: %02X%02X%02X%02X\n"",
 			oid[0],oid[1],oid[2],oid[3]);
		if(0 == memcmp(fs->currentPath, oid, 2)) {
			buf[0] = oid[2];
 			buf[1] = oid[3];
 			if(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */
 			buf += 2;
			count += 2;
			bufLen -= 2;
 		}
 	}
 	return count;
}
","static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)
{
	muscle_private_t* priv = MUSCLE_DATA(card);
	mscfs_t *fs = priv->fs;
	int x;
	int count = 0;

 	mscfs_check_cache(priv->fs);
 
 	for(x = 0; x < fs->cache.size; x++) {
		u8* oid= fs->cache.array[x].objectId.id;
 		sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,
 			""FILE: %02X%02X%02X%02X\n"",
 			oid[0],oid[1],oid[2],oid[3]);
		if(0 == memcmp(fs->currentPath, oid, 2)) {
			buf[0] = oid[2];
 			buf[1] = oid[3];
 			if(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */
 			buf += 2;
			count+=2;
 		}
 	}
 	return count;
}
",C,"		u8* oid = fs->cache.array[x].objectId.id;
		if (bufLen < 2)
			break;
			count += 2;
			bufLen -= 2;
","		u8* oid= fs->cache.array[x].objectId.id;
			count+=2;
",,"@@ -518,7 +518,9 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)
 	mscfs_check_cache(priv->fs);
 
 	for(x = 0; x < fs->cache.size; x++) {
-		u8* oid= fs->cache.array[x].objectId.id;
+		u8* oid = fs->cache.array[x].objectId.id;
+		if (bufLen < 2)
+			break;
 		sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,
 			""FILE: %02X%02X%02X%02X\n"",
 			oid[0],oid[1],oid[2],oid[3]);
@@ -527,7 +529,8 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)
 			buf[1] = oid[3];
 			if(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */
 			buf += 2;
-			count+=2;
+			count += 2;
+			bufLen -= 2;
 		}
 	}
 	return count;",OpenSC,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,8fe377e93b4b56060e5bbfb6f3142ceaeca744fa,1,"static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)
{
	muscle_private_t* priv = MUSCLE_DATA(card);
	mscfs_t *fs = priv->fs;
	int x;
	int count = 0;

 	mscfs_check_cache(priv->fs);
 
 	for(x = 0; x < fs->cache.size; x++) {
//flaw_line_below:
		u8* oid= fs->cache.array[x].objectId.id;
//fix_flaw_line_below:
//		u8* oid = fs->cache.array[x].objectId.id;
//fix_flaw_line_below:
//		if (bufLen < 2)
//fix_flaw_line_below:
//			break;
 		sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,
 			""FILE: %02X%02X%02X%02X\n"",
 			oid[0],oid[1],oid[2],oid[3]);
		if(0 == memcmp(fs->currentPath, oid, 2)) {
			buf[0] = oid[2];
 			buf[1] = oid[3];
 			if(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */
 			buf += 2;
//flaw_line_below:
			count+=2;
//fix_flaw_line_below:
//			count += 2;
//fix_flaw_line_below:
//			bufLen -= 2;
 		}
 	}
 	return count;
}
"
4511,182247,,Local,Not required,Partial,CVE-2018-16425,https://www.cvedetails.com/cve/CVE-2018-16425/,CWE-415,Low,Partial,Partial,,2018-09-03,4.6,A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,2019-09-11,DoS ,3,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,"fixed out of bounds writes

Thanks to Eric Sesterhenn from X41 D-SEC GmbH
for reporting the problems.",3,src/libopensc/card-tcos.c,"{""sha"": ""756788a0fbbbed8487e8cf33b6115bb4d4f58860"", ""filename"": ""src/libopensc/card-cac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-cac.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -794,7 +794,7 @@ static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri\n         }\n \tif (priv->cac_id_len) {\n \t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n-\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n+\t\tmemcpy(serial->value, priv->cac_id, serial->len);\n \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n \t}\n \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);""}<_**next**_>{""sha"": ""65a58f6740d38e6fd6204cbacb5015995067334f"", ""filename"": ""src/libopensc/card-epass2003.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-epass2003.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -951,7 +951,7 @@ decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned\n \twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n \t\tcipher_len--;\n \n-\tif (2 == cipher_len)\n+\tif (2 == cipher_len || *out_len < cipher_len - 2)\n \t\treturn -1;\n \n \tmemcpy(out, plaintext, cipher_len - 2);\n@@ -977,6 +977,7 @@ epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apd\n \tr = sc_check_sw(card, sm->sw1, sm->sw2);\n \tif (r == SC_SUCCESS) {\n \t\tif (exdata->sm) {\n+\t\t\tlen = plain->resplen;\n \t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n \t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n \t\t}""}<_**next**_>{""sha"": ""d247efabc9fd2d7978e4a24dc42bcaccd42f3bee"", ""filename"": ""src/libopensc/card-muscle.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-muscle.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -518,7 +518,9 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \tmscfs_check_cache(priv->fs);\n \n \tfor(x = 0; x < fs->cache.size; x++) {\n-\t\tu8* oid= fs->cache.array[x].objectId.id;\n+\t\tu8* oid = fs->cache.array[x].objectId.id;\n+\t\tif (bufLen < 2)\n+\t\t\tbreak;\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n \t\t\t\""FILE: %02X%02X%02X%02X\\n\"",\n \t\t\toid[0],oid[1],oid[2],oid[3]);\n@@ -527,7 +529,8 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \t\t\tbuf[1] = oid[3];\n \t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n \t\t\tbuf += 2;\n-\t\t\tcount+=2;\n+\t\t\tcount += 2;\n+\t\t\tbufLen -= 2;\n \t\t}\n \t}\n \treturn count;""}<_**next**_>{""sha"": ""3c86b1f4838a5837341ae9cfc9b7fdb5334fe138"", ""filename"": ""src/libopensc/card-tcos.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-tcos.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -408,7 +408,7 @@ static int tcos_select_file(sc_card_t *card,\n \tfile->path = *in_path;\n \n \tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n-\t\tint j, len=apdu.resp[i+1];\n+\t\tsize_t j, len=apdu.resp[i+1];\n \t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n \n \t\tswitch (type) {\n@@ -432,8 +432,8 @@ static int tcos_select_file(sc_card_t *card,\n \t\t\tfile->id = (d[0]<<8) | d[1];\n \t\t\tbreak;\n \t\tcase 0x84:\n-\t\t\tmemcpy(file->name, d, len);\n-\t\t\tfile->namelen = len;\n+\t\t\tfile->namelen = MIN(sizeof file->name, len);\n+\t\t\tmemcpy(file->name, d, file->namelen);\n \t\t\tbreak;\n \t\tcase 0x86:\n \t\t\tsc_file_set_sec_attr(file, d, len); ""}<_**next**_>{""sha"": ""2b8d66b913b0d3ce3c92c0578c43ae847f98d2c7"", ""filename"": ""src/libopensc/pkcs15-esteid.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-esteid.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -79,7 +79,7 @@ sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n \t/* read the serial (document number) */\n \tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \""read document number failed\"");\n-\tbuff[r] = '\\0';\n+\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n \tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n \n \tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION""}<_**next**_>{""sha"": ""3b220f7a5b37ea236b58ef543d01ca08c815b826"", ""filename"": ""src/libopensc/pkcs15-gemsafeV1.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-gemsafeV1.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -208,7 +208,7 @@ static int gemsafe_get_cert_len(sc_card_t *card)\n \t * the private key.\n \t */\n \tind = 2; /* skip length */\n-\twhile (ibuf[ind] == 0x01) {\n+\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n \t\tif (ibuf[ind+1] == 0xFE) {\n \t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n \t\t\tsc_log(card->ctx, \""Key container %d is allocated and uses key_ref %d\"",""}<_**next**_>{""sha"": ""1391bea15370cd020dfdf1cfb0d9c24db950a0c4"", ""filename"": ""src/libopensc/pkcs15-sc-hsm.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-sc-hsm.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -837,12 +837,14 @@ static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n \t\tr = read_file(p15card, (u8 *) \""\\x2F\\x02\"", efbin, &len, 1);\n \t\tLOG_TEST_RET(card->ctx, r, \""Skipping optional EF.C_DevAut\"");\n \n-\t\t/* save EF_C_DevAut for further use */\n-\t\tptr = realloc(priv->EF_C_DevAut, len);\n-\t\tif (ptr) {\n-\t\t\tmemcpy(ptr, efbin, len);\n-\t\t\tpriv->EF_C_DevAut = ptr;\n-\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\tif (len > 0) {\n+\t\t\t/* save EF_C_DevAut for further use */\n+\t\t\tptr = realloc(priv->EF_C_DevAut, len);\n+\t\t\tif (ptr) {\n+\t\t\t\tmemcpy(ptr, efbin, len);\n+\t\t\t\tpriv->EF_C_DevAut = ptr;\n+\t\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\t\t}\n \t\t}\n \n \t\tptr = efbin;""}<_**next**_>{""sha"": ""53fefb3e68eac554ed608a5a960cf3dd5f5b8dcb"", ""filename"": ""src/libopensc/sc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/sc.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -628,7 +628,7 @@ int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n \t\treturn SC_ERROR_INVALID_ARGUMENTS;\n \t}\n \n-\tif (sec_attr == NULL) {\n+\tif (sec_attr == NULL || sec_attr_len) {\n \t\tif (file->sec_attr != NULL)\n \t\t\tfree(file->sec_attr);\n \t\tfile->sec_attr = NULL;""}<_**next**_>{""sha"": ""662a028222a909f431f31c60bc421fa83d86d5b6"", ""filename"": ""src/tools/cryptoflex-tool.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/cryptoflex-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -21,6 +21,7 @@\n #include \""config.h\""\n \n #include \""libopensc/sc-ossl-compat.h\""\n+#include \""libopensc/internal.h\""\n #include <openssl/bn.h>\n #include <openssl/rsa.h>\n #include <openssl/x509.h>\n@@ -331,7 +332,7 @@ static int read_public_key(RSA *rsa)\n \t\tfprintf(stderr, \""Unable to select public key file: %s\\n\"", sc_strerror(r));\n \t\treturn 2;\n \t}\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {\n@@ -382,7 +383,7 @@ static int read_private_key(RSA *rsa)\n \te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n \tif (e == NULL || e->method == SC_AC_NEVER)\n \t\treturn 10;\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {""}<_**next**_>{""sha"": ""31360833b5284915ae8d93babeb3fdb1b279a0f3"", ""filename"": ""src/tools/egk-tool.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/egk-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -149,7 +149,7 @@ int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t\n \t\tgoto err;\n \t}\n \n-\tlen = file ? file->size : 4096;\n+\tlen = file && file->size > 0 ? file->size : 4096;\n \tp = realloc(*data, len);\n \tif (!p) {\n \t\tgoto err;""}<_**next**_>{""sha"": ""e49647a472e921663b2952ef5cf213c9fc974beb"", ""filename"": ""src/tools/util.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/util.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -339,10 +339,11 @@ const char * util_acl_to_str(const sc_acl_entry_t *e)\n \t\t\tstrcpy(buf, \""????\"");\n \t\t\tbreak;\n \t\t}\n-\t\tstrcat(line, buf);\n-\t\tstrcat(line, \"" \"");\n+\t\tstrncat(line, buf, sizeof line);\n+\t\tstrncat(line, \"" \"", sizeof line);\n \t\te = e->next;\n \t}\n+\tline[(sizeof line)-1] = '\\0'; /* make sure it's NUL terminated */\n \tline[strlen(line)-1] = 0; /* get rid of trailing space */\n \treturn line;\n }""}","static int tcos_select_file(sc_card_t *card,
			    const sc_path_t *in_path,
			    sc_file_t **file_out)
{
	sc_context_t *ctx;
	sc_apdu_t apdu;
	sc_file_t *file=NULL;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;
	unsigned int i;
	int r, pathlen;

	assert(card != NULL && in_path != NULL);
	ctx=card->ctx;
	memcpy(path, in_path->value, in_path->len);
	pathlen = in_path->len;

	sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);
	
	switch (in_path->type) {
	case SC_PATH_TYPE_FILE_ID:
		if (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;
		/* fall through */
	case SC_PATH_TYPE_FROM_CURRENT:
		apdu.p1 = 9;
		break;
	case SC_PATH_TYPE_DF_NAME:
		apdu.p1 = 4;
		break;
	case SC_PATH_TYPE_PATH:
		apdu.p1 = 8;
		if (pathlen >= 2 && memcmp(path, ""\x3F\x00"", 2) == 0) path += 2, pathlen -= 2;
		if (pathlen == 0) apdu.p1 = 0;
		break;
	case SC_PATH_TYPE_PARENT:
		apdu.p1 = 3;
		pathlen = 0;
		break;
	default:
		SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);
	}
	if( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;

	apdu.lc = pathlen;
	apdu.data = path;
	apdu.datalen = pathlen;

	if (file_out != NULL) {
		apdu.resp = buf;
		apdu.resplen = sizeof(buf);
		apdu.le = 256;
	} else {
		apdu.resplen = 0;
		apdu.le = 0; 
		apdu.p2 = 0x0C; 
		apdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;
	}

	r = sc_transmit_apdu(card, &apdu);
	SC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, ""APDU transmit failed"");
	r = sc_check_sw(card, apdu.sw1, apdu.sw2);
	if (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);

	if (apdu.resplen < 1 || apdu.resp[0] != 0x62){
		sc_debug(ctx, SC_LOG_DEBUG_NORMAL, ""received invalid template %02X\n"", apdu.resp[0]);
		SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);
	}

	file = sc_file_new();
	if (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);
	*file_out = file;
 	file->path = *in_path;
 
 	for(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){
		size_t j, len=apdu.resp[i+1];
 		unsigned char type=apdu.resp[i], *d=apdu.resp+i+2;
 
 		switch (type) {
		case 0x80:
		case 0x81:
			file->size=0;
			for(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];
			break;
		case 0x82:
			file->shareable = (d[0] & 0x40) ? 1 : 0;
			file->ef_structure = d[0] & 7;
			switch ((d[0]>>3) & 7) {
			case 0: file->type = SC_FILE_TYPE_WORKING_EF; break;
			case 7: file->type = SC_FILE_TYPE_DF; break;
			default:
				sc_debug(ctx, SC_LOG_DEBUG_NORMAL, ""invalid file type %02X in file descriptor\n"", d[0]);
				SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);
			}
			break;
		case 0x83:
 			file->id = (d[0]<<8) | d[1];
 			break;
 		case 0x84:
			file->namelen = MIN(sizeof file->name, len);
			memcpy(file->name, d, file->namelen);
 			break;
 		case 0x86:
 			sc_file_set_sec_attr(file, d, len); 
			break;
		default:
			if (len>0) sc_file_set_prop_attr(file, d, len); 
		}
	}
	file->magic = SC_FILE_MAGIC;

	parse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);

	return 0;
}
","static int tcos_select_file(sc_card_t *card,
			    const sc_path_t *in_path,
			    sc_file_t **file_out)
{
	sc_context_t *ctx;
	sc_apdu_t apdu;
	sc_file_t *file=NULL;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;
	unsigned int i;
	int r, pathlen;

	assert(card != NULL && in_path != NULL);
	ctx=card->ctx;
	memcpy(path, in_path->value, in_path->len);
	pathlen = in_path->len;

	sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);
	
	switch (in_path->type) {
	case SC_PATH_TYPE_FILE_ID:
		if (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;
		/* fall through */
	case SC_PATH_TYPE_FROM_CURRENT:
		apdu.p1 = 9;
		break;
	case SC_PATH_TYPE_DF_NAME:
		apdu.p1 = 4;
		break;
	case SC_PATH_TYPE_PATH:
		apdu.p1 = 8;
		if (pathlen >= 2 && memcmp(path, ""\x3F\x00"", 2) == 0) path += 2, pathlen -= 2;
		if (pathlen == 0) apdu.p1 = 0;
		break;
	case SC_PATH_TYPE_PARENT:
		apdu.p1 = 3;
		pathlen = 0;
		break;
	default:
		SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);
	}
	if( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;

	apdu.lc = pathlen;
	apdu.data = path;
	apdu.datalen = pathlen;

	if (file_out != NULL) {
		apdu.resp = buf;
		apdu.resplen = sizeof(buf);
		apdu.le = 256;
	} else {
		apdu.resplen = 0;
		apdu.le = 0; 
		apdu.p2 = 0x0C; 
		apdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;
	}

	r = sc_transmit_apdu(card, &apdu);
	SC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, ""APDU transmit failed"");
	r = sc_check_sw(card, apdu.sw1, apdu.sw2);
	if (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);

	if (apdu.resplen < 1 || apdu.resp[0] != 0x62){
		sc_debug(ctx, SC_LOG_DEBUG_NORMAL, ""received invalid template %02X\n"", apdu.resp[0]);
		SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);
	}

	file = sc_file_new();
	if (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);
	*file_out = file;
 	file->path = *in_path;
 
 	for(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){
		int j, len=apdu.resp[i+1];
 		unsigned char type=apdu.resp[i], *d=apdu.resp+i+2;
 
 		switch (type) {
		case 0x80:
		case 0x81:
			file->size=0;
			for(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];
			break;
		case 0x82:
			file->shareable = (d[0] & 0x40) ? 1 : 0;
			file->ef_structure = d[0] & 7;
			switch ((d[0]>>3) & 7) {
			case 0: file->type = SC_FILE_TYPE_WORKING_EF; break;
			case 7: file->type = SC_FILE_TYPE_DF; break;
			default:
				sc_debug(ctx, SC_LOG_DEBUG_NORMAL, ""invalid file type %02X in file descriptor\n"", d[0]);
				SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);
			}
			break;
		case 0x83:
 			file->id = (d[0]<<8) | d[1];
 			break;
 		case 0x84:
			memcpy(file->name, d, len);
			file->namelen = len;
 			break;
 		case 0x86:
 			sc_file_set_sec_attr(file, d, len); 
			break;
		default:
			if (len>0) sc_file_set_prop_attr(file, d, len); 
		}
	}
	file->magic = SC_FILE_MAGIC;

	parse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);

	return 0;
}
",C,"		size_t j, len=apdu.resp[i+1];
			file->namelen = MIN(sizeof file->name, len);
			memcpy(file->name, d, file->namelen);
","		int j, len=apdu.resp[i+1];
			memcpy(file->name, d, len);
			file->namelen = len;
",,"@@ -408,7 +408,7 @@ static int tcos_select_file(sc_card_t *card,
 	file->path = *in_path;
 
 	for(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){
-		int j, len=apdu.resp[i+1];
+		size_t j, len=apdu.resp[i+1];
 		unsigned char type=apdu.resp[i], *d=apdu.resp+i+2;
 
 		switch (type) {
@@ -432,8 +432,8 @@ static int tcos_select_file(sc_card_t *card,
 			file->id = (d[0]<<8) | d[1];
 			break;
 		case 0x84:
-			memcpy(file->name, d, len);
-			file->namelen = len;
+			file->namelen = MIN(sizeof file->name, len);
+			memcpy(file->name, d, file->namelen);
 			break;
 		case 0x86:
 			sc_file_set_sec_attr(file, d, len); ",OpenSC,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,8fe377e93b4b56060e5bbfb6f3142ceaeca744fa,1,"static int tcos_select_file(sc_card_t *card,
			    const sc_path_t *in_path,
			    sc_file_t **file_out)
{
	sc_context_t *ctx;
	sc_apdu_t apdu;
	sc_file_t *file=NULL;
	u8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;
	unsigned int i;
	int r, pathlen;

	assert(card != NULL && in_path != NULL);
	ctx=card->ctx;
	memcpy(path, in_path->value, in_path->len);
	pathlen = in_path->len;

	sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);
	
	switch (in_path->type) {
	case SC_PATH_TYPE_FILE_ID:
		if (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;
		/* fall through */
	case SC_PATH_TYPE_FROM_CURRENT:
		apdu.p1 = 9;
		break;
	case SC_PATH_TYPE_DF_NAME:
		apdu.p1 = 4;
		break;
	case SC_PATH_TYPE_PATH:
		apdu.p1 = 8;
		if (pathlen >= 2 && memcmp(path, ""\x3F\x00"", 2) == 0) path += 2, pathlen -= 2;
		if (pathlen == 0) apdu.p1 = 0;
		break;
	case SC_PATH_TYPE_PARENT:
		apdu.p1 = 3;
		pathlen = 0;
		break;
	default:
		SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);
	}
	if( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;

	apdu.lc = pathlen;
	apdu.data = path;
	apdu.datalen = pathlen;

	if (file_out != NULL) {
		apdu.resp = buf;
		apdu.resplen = sizeof(buf);
		apdu.le = 256;
	} else {
		apdu.resplen = 0;
		apdu.le = 0; 
		apdu.p2 = 0x0C; 
		apdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;
	}

	r = sc_transmit_apdu(card, &apdu);
	SC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, ""APDU transmit failed"");
	r = sc_check_sw(card, apdu.sw1, apdu.sw2);
	if (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);

	if (apdu.resplen < 1 || apdu.resp[0] != 0x62){
		sc_debug(ctx, SC_LOG_DEBUG_NORMAL, ""received invalid template %02X\n"", apdu.resp[0]);
		SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);
	}

	file = sc_file_new();
	if (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);
	*file_out = file;
 	file->path = *in_path;
 
 	for(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){
//flaw_line_below:
		int j, len=apdu.resp[i+1];
//fix_flaw_line_below:
//		size_t j, len=apdu.resp[i+1];
 		unsigned char type=apdu.resp[i], *d=apdu.resp+i+2;
 
 		switch (type) {
		case 0x80:
		case 0x81:
			file->size=0;
			for(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];
			break;
		case 0x82:
			file->shareable = (d[0] & 0x40) ? 1 : 0;
			file->ef_structure = d[0] & 7;
			switch ((d[0]>>3) & 7) {
			case 0: file->type = SC_FILE_TYPE_WORKING_EF; break;
			case 7: file->type = SC_FILE_TYPE_DF; break;
			default:
				sc_debug(ctx, SC_LOG_DEBUG_NORMAL, ""invalid file type %02X in file descriptor\n"", d[0]);
				SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);
			}
			break;
		case 0x83:
 			file->id = (d[0]<<8) | d[1];
 			break;
 		case 0x84:
//flaw_line_below:
			memcpy(file->name, d, len);
//flaw_line_below:
			file->namelen = len;
//fix_flaw_line_below:
//			file->namelen = MIN(sizeof file->name, len);
//fix_flaw_line_below:
//			memcpy(file->name, d, file->namelen);
 			break;
 		case 0x86:
 			sc_file_set_sec_attr(file, d, len); 
			break;
		default:
			if (len>0) sc_file_set_prop_attr(file, d, len); 
		}
	}
	file->magic = SC_FILE_MAGIC;

	parse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);

	return 0;
}
"
4512,182248,,Local,Not required,Partial,CVE-2018-16425,https://www.cvedetails.com/cve/CVE-2018-16425/,CWE-415,Low,Partial,Partial,,2018-09-03,4.6,A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,2019-09-11,DoS ,1,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,"fixed out of bounds writes

Thanks to Eric Sesterhenn from X41 D-SEC GmbH
for reporting the problems.",1,src/libopensc/pkcs15-esteid.c,"{""sha"": ""756788a0fbbbed8487e8cf33b6115bb4d4f58860"", ""filename"": ""src/libopensc/card-cac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-cac.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -794,7 +794,7 @@ static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri\n         }\n \tif (priv->cac_id_len) {\n \t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n-\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n+\t\tmemcpy(serial->value, priv->cac_id, serial->len);\n \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n \t}\n \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);""}<_**next**_>{""sha"": ""65a58f6740d38e6fd6204cbacb5015995067334f"", ""filename"": ""src/libopensc/card-epass2003.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-epass2003.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -951,7 +951,7 @@ decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned\n \twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n \t\tcipher_len--;\n \n-\tif (2 == cipher_len)\n+\tif (2 == cipher_len || *out_len < cipher_len - 2)\n \t\treturn -1;\n \n \tmemcpy(out, plaintext, cipher_len - 2);\n@@ -977,6 +977,7 @@ epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apd\n \tr = sc_check_sw(card, sm->sw1, sm->sw2);\n \tif (r == SC_SUCCESS) {\n \t\tif (exdata->sm) {\n+\t\t\tlen = plain->resplen;\n \t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n \t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n \t\t}""}<_**next**_>{""sha"": ""d247efabc9fd2d7978e4a24dc42bcaccd42f3bee"", ""filename"": ""src/libopensc/card-muscle.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-muscle.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -518,7 +518,9 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \tmscfs_check_cache(priv->fs);\n \n \tfor(x = 0; x < fs->cache.size; x++) {\n-\t\tu8* oid= fs->cache.array[x].objectId.id;\n+\t\tu8* oid = fs->cache.array[x].objectId.id;\n+\t\tif (bufLen < 2)\n+\t\t\tbreak;\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n \t\t\t\""FILE: %02X%02X%02X%02X\\n\"",\n \t\t\toid[0],oid[1],oid[2],oid[3]);\n@@ -527,7 +529,8 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \t\t\tbuf[1] = oid[3];\n \t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n \t\t\tbuf += 2;\n-\t\t\tcount+=2;\n+\t\t\tcount += 2;\n+\t\t\tbufLen -= 2;\n \t\t}\n \t}\n \treturn count;""}<_**next**_>{""sha"": ""3c86b1f4838a5837341ae9cfc9b7fdb5334fe138"", ""filename"": ""src/libopensc/card-tcos.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-tcos.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -408,7 +408,7 @@ static int tcos_select_file(sc_card_t *card,\n \tfile->path = *in_path;\n \n \tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n-\t\tint j, len=apdu.resp[i+1];\n+\t\tsize_t j, len=apdu.resp[i+1];\n \t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n \n \t\tswitch (type) {\n@@ -432,8 +432,8 @@ static int tcos_select_file(sc_card_t *card,\n \t\t\tfile->id = (d[0]<<8) | d[1];\n \t\t\tbreak;\n \t\tcase 0x84:\n-\t\t\tmemcpy(file->name, d, len);\n-\t\t\tfile->namelen = len;\n+\t\t\tfile->namelen = MIN(sizeof file->name, len);\n+\t\t\tmemcpy(file->name, d, file->namelen);\n \t\t\tbreak;\n \t\tcase 0x86:\n \t\t\tsc_file_set_sec_attr(file, d, len); ""}<_**next**_>{""sha"": ""2b8d66b913b0d3ce3c92c0578c43ae847f98d2c7"", ""filename"": ""src/libopensc/pkcs15-esteid.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-esteid.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -79,7 +79,7 @@ sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n \t/* read the serial (document number) */\n \tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \""read document number failed\"");\n-\tbuff[r] = '\\0';\n+\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n \tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n \n \tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION""}<_**next**_>{""sha"": ""3b220f7a5b37ea236b58ef543d01ca08c815b826"", ""filename"": ""src/libopensc/pkcs15-gemsafeV1.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-gemsafeV1.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -208,7 +208,7 @@ static int gemsafe_get_cert_len(sc_card_t *card)\n \t * the private key.\n \t */\n \tind = 2; /* skip length */\n-\twhile (ibuf[ind] == 0x01) {\n+\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n \t\tif (ibuf[ind+1] == 0xFE) {\n \t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n \t\t\tsc_log(card->ctx, \""Key container %d is allocated and uses key_ref %d\"",""}<_**next**_>{""sha"": ""1391bea15370cd020dfdf1cfb0d9c24db950a0c4"", ""filename"": ""src/libopensc/pkcs15-sc-hsm.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-sc-hsm.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -837,12 +837,14 @@ static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n \t\tr = read_file(p15card, (u8 *) \""\\x2F\\x02\"", efbin, &len, 1);\n \t\tLOG_TEST_RET(card->ctx, r, \""Skipping optional EF.C_DevAut\"");\n \n-\t\t/* save EF_C_DevAut for further use */\n-\t\tptr = realloc(priv->EF_C_DevAut, len);\n-\t\tif (ptr) {\n-\t\t\tmemcpy(ptr, efbin, len);\n-\t\t\tpriv->EF_C_DevAut = ptr;\n-\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\tif (len > 0) {\n+\t\t\t/* save EF_C_DevAut for further use */\n+\t\t\tptr = realloc(priv->EF_C_DevAut, len);\n+\t\t\tif (ptr) {\n+\t\t\t\tmemcpy(ptr, efbin, len);\n+\t\t\t\tpriv->EF_C_DevAut = ptr;\n+\t\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\t\t}\n \t\t}\n \n \t\tptr = efbin;""}<_**next**_>{""sha"": ""53fefb3e68eac554ed608a5a960cf3dd5f5b8dcb"", ""filename"": ""src/libopensc/sc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/sc.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -628,7 +628,7 @@ int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n \t\treturn SC_ERROR_INVALID_ARGUMENTS;\n \t}\n \n-\tif (sec_attr == NULL) {\n+\tif (sec_attr == NULL || sec_attr_len) {\n \t\tif (file->sec_attr != NULL)\n \t\t\tfree(file->sec_attr);\n \t\tfile->sec_attr = NULL;""}<_**next**_>{""sha"": ""662a028222a909f431f31c60bc421fa83d86d5b6"", ""filename"": ""src/tools/cryptoflex-tool.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/cryptoflex-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -21,6 +21,7 @@\n #include \""config.h\""\n \n #include \""libopensc/sc-ossl-compat.h\""\n+#include \""libopensc/internal.h\""\n #include <openssl/bn.h>\n #include <openssl/rsa.h>\n #include <openssl/x509.h>\n@@ -331,7 +332,7 @@ static int read_public_key(RSA *rsa)\n \t\tfprintf(stderr, \""Unable to select public key file: %s\\n\"", sc_strerror(r));\n \t\treturn 2;\n \t}\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {\n@@ -382,7 +383,7 @@ static int read_private_key(RSA *rsa)\n \te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n \tif (e == NULL || e->method == SC_AC_NEVER)\n \t\treturn 10;\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {""}<_**next**_>{""sha"": ""31360833b5284915ae8d93babeb3fdb1b279a0f3"", ""filename"": ""src/tools/egk-tool.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/egk-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -149,7 +149,7 @@ int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t\n \t\tgoto err;\n \t}\n \n-\tlen = file ? file->size : 4096;\n+\tlen = file && file->size > 0 ? file->size : 4096;\n \tp = realloc(*data, len);\n \tif (!p) {\n \t\tgoto err;""}<_**next**_>{""sha"": ""e49647a472e921663b2952ef5cf213c9fc974beb"", ""filename"": ""src/tools/util.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/util.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -339,10 +339,11 @@ const char * util_acl_to_str(const sc_acl_entry_t *e)\n \t\t\tstrcpy(buf, \""????\"");\n \t\t\tbreak;\n \t\t}\n-\t\tstrcat(line, buf);\n-\t\tstrcat(line, \"" \"");\n+\t\tstrncat(line, buf, sizeof line);\n+\t\tstrncat(line, \"" \"", sizeof line);\n \t\te = e->next;\n \t}\n+\tline[(sizeof line)-1] = '\\0'; /* make sure it's NUL terminated */\n \tline[strlen(line)-1] = 0; /* get rid of trailing space */\n \treturn line;\n }""}","sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)
{
	sc_card_t *card = p15card->card;
	unsigned char buff[128];
	int r, i;
	size_t field_length = 0, modulus_length = 0;
	sc_path_t tmppath;

	set_string (&p15card->tokeninfo->label, ""ID-kaart"");
	set_string (&p15card->tokeninfo->manufacturer_id, ""AS Sertifitseerimiskeskus"");

	/* Select application directory */
	sc_format_path (""3f00eeee5044"", &tmppath);
	r = sc_select_file (card, &tmppath, NULL);
	SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""select esteid PD failed"");

 	/* read the serial (document number) */
 	r = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);
 	SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""read document number failed"");
	buff[MIN((size_t) r, (sizeof buff)-1)] = '\0';
 	set_string (&p15card->tokeninfo->serial_number, (const char *) buff);
 
 	p15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION
				  | SC_PKCS15_TOKEN_EID_COMPLIANT
				  | SC_PKCS15_TOKEN_READONLY;

	/* add certificates */
	for (i = 0; i < 2; i++) {
		static const char *esteid_cert_names[2] = {
			""Isikutuvastus"",
			""Allkirjastamine""};
		static char const *esteid_cert_paths[2] = {
			""3f00eeeeaace"",
			""3f00eeeeddce""};
		static int esteid_cert_ids[2] = {1, 2};

		struct sc_pkcs15_cert_info cert_info;
		struct sc_pkcs15_object cert_obj;

		memset(&cert_info, 0, sizeof(cert_info));
		memset(&cert_obj, 0, sizeof(cert_obj));

		cert_info.id.value[0] = esteid_cert_ids[i];
		cert_info.id.len = 1;
		sc_format_path(esteid_cert_paths[i], &cert_info.path);
		strlcpy(cert_obj.label, esteid_cert_names[i], sizeof(cert_obj.label));
		r = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);
		if (r < 0)
			return SC_ERROR_INTERNAL;
		if (i == 0) {
			sc_pkcs15_cert_t *cert = NULL;
			r = sc_pkcs15_read_certificate(p15card, &cert_info, &cert);
			if (r < 0)
				return SC_ERROR_INTERNAL;
			if (cert->key->algorithm == SC_ALGORITHM_EC)
				field_length = cert->key->u.ec.params.field_length;
			else
				modulus_length = cert->key->u.rsa.modulus.len * 8;
			if (r == SC_SUCCESS) {
				static const struct sc_object_id cn_oid = {{ 2, 5, 4, 3, -1 }};
				u8 *cn_name = NULL;
				size_t cn_len = 0;
				sc_pkcs15_get_name_from_dn(card->ctx, cert->subject,
					cert->subject_len, &cn_oid, &cn_name, &cn_len);
				if (cn_len > 0) {
					char *token_name = malloc(cn_len+1);
					if (token_name) {
						memcpy(token_name, cn_name, cn_len);
						token_name[cn_len] = '\0';
						set_string(&p15card->tokeninfo->label, (const char*)token_name);
						free(token_name);
					}
				}
				free(cn_name);
				sc_pkcs15_free_certificate(cert);
			}
		}
	}

	/* the file with key pin info (tries left) */
	sc_format_path (""3f000016"", &tmppath);
	r = sc_select_file (card, &tmppath, NULL);
	if (r < 0)
		return SC_ERROR_INTERNAL;

	/* add pins */
	for (i = 0; i < 3; i++) {
		unsigned char tries_left;
		static const char *esteid_pin_names[3] = {
			""PIN1"",
			""PIN2"",
			""PUK"" };
			
		static const int esteid_pin_min[3] = {4, 5, 8};
		static const int esteid_pin_ref[3] = {1, 2, 0};
		static const int esteid_pin_authid[3] = {1, 2, 3};
		static const int esteid_pin_flags[3] = {0, 0, SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN};
		
		struct sc_pkcs15_auth_info pin_info;
		struct sc_pkcs15_object pin_obj;

		memset(&pin_info, 0, sizeof(pin_info));
		memset(&pin_obj, 0, sizeof(pin_obj));

		/* read the number of tries left for the PIN */
		r = sc_read_record (card, i + 1, buff, sizeof(buff), SC_RECORD_BY_REC_NR);
		if (r < 0)
			return SC_ERROR_INTERNAL;
		tries_left = buff[5];

		pin_info.auth_id.len = 1;
		pin_info.auth_id.value[0] = esteid_pin_authid[i];
		pin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;
		pin_info.attrs.pin.reference = esteid_pin_ref[i];
		pin_info.attrs.pin.flags = esteid_pin_flags[i];
		pin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;
		pin_info.attrs.pin.min_length = esteid_pin_min[i];
		pin_info.attrs.pin.stored_length = 12;
		pin_info.attrs.pin.max_length = 12;
		pin_info.attrs.pin.pad_char = '\0';
		pin_info.tries_left = (int)tries_left;
		pin_info.max_tries = 3;

		strlcpy(pin_obj.label, esteid_pin_names[i], sizeof(pin_obj.label));
		pin_obj.flags = esteid_pin_flags[i];

		/* Link normal PINs with PUK */
		if (i < 2) {
			pin_obj.auth_id.len = 1;
			pin_obj.auth_id.value[0] = 3;
		}

		r = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);
		if (r < 0)
			return SC_ERROR_INTERNAL;
	}

	/* add private keys */
	for (i = 0; i < 2; i++) {
		static int prkey_pin[2] = {1, 2};

		static const char *prkey_name[2] = {
			""Isikutuvastus"",
			""Allkirjastamine""};

		struct sc_pkcs15_prkey_info prkey_info;
		struct sc_pkcs15_object prkey_obj;

		memset(&prkey_info, 0, sizeof(prkey_info));
		memset(&prkey_obj, 0, sizeof(prkey_obj));

		prkey_info.id.len = 1;
		prkey_info.id.value[0] = prkey_pin[i];
		prkey_info.native = 1;
		prkey_info.key_reference = i + 1;
		prkey_info.field_length = field_length;
		prkey_info.modulus_length = modulus_length;
		if (i == 1)
			prkey_info.usage = SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;
		else if(field_length > 0) // ECC has sign and derive usage
			prkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE;
		else
			prkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT;

		strlcpy(prkey_obj.label, prkey_name[i], sizeof(prkey_obj.label));
		prkey_obj.auth_id.len = 1;
		prkey_obj.auth_id.value[0] = prkey_pin[i];
		prkey_obj.user_consent = 0;
		prkey_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;

		if(field_length > 0)
			r = sc_pkcs15emu_add_ec_prkey(p15card, &prkey_obj, &prkey_info);
		else
			r = sc_pkcs15emu_add_rsa_prkey(p15card, &prkey_obj, &prkey_info);
		if (r < 0)
			return SC_ERROR_INTERNAL;
	}

	return SC_SUCCESS;
}
","sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)
{
	sc_card_t *card = p15card->card;
	unsigned char buff[128];
	int r, i;
	size_t field_length = 0, modulus_length = 0;
	sc_path_t tmppath;

	set_string (&p15card->tokeninfo->label, ""ID-kaart"");
	set_string (&p15card->tokeninfo->manufacturer_id, ""AS Sertifitseerimiskeskus"");

	/* Select application directory */
	sc_format_path (""3f00eeee5044"", &tmppath);
	r = sc_select_file (card, &tmppath, NULL);
	SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""select esteid PD failed"");

 	/* read the serial (document number) */
 	r = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);
 	SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""read document number failed"");
	buff[r] = '\0';
 	set_string (&p15card->tokeninfo->serial_number, (const char *) buff);
 
 	p15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION
				  | SC_PKCS15_TOKEN_EID_COMPLIANT
				  | SC_PKCS15_TOKEN_READONLY;

	/* add certificates */
	for (i = 0; i < 2; i++) {
		static const char *esteid_cert_names[2] = {
			""Isikutuvastus"",
			""Allkirjastamine""};
		static char const *esteid_cert_paths[2] = {
			""3f00eeeeaace"",
			""3f00eeeeddce""};
		static int esteid_cert_ids[2] = {1, 2};

		struct sc_pkcs15_cert_info cert_info;
		struct sc_pkcs15_object cert_obj;

		memset(&cert_info, 0, sizeof(cert_info));
		memset(&cert_obj, 0, sizeof(cert_obj));

		cert_info.id.value[0] = esteid_cert_ids[i];
		cert_info.id.len = 1;
		sc_format_path(esteid_cert_paths[i], &cert_info.path);
		strlcpy(cert_obj.label, esteid_cert_names[i], sizeof(cert_obj.label));
		r = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);
		if (r < 0)
			return SC_ERROR_INTERNAL;
		if (i == 0) {
			sc_pkcs15_cert_t *cert = NULL;
			r = sc_pkcs15_read_certificate(p15card, &cert_info, &cert);
			if (r < 0)
				return SC_ERROR_INTERNAL;
			if (cert->key->algorithm == SC_ALGORITHM_EC)
				field_length = cert->key->u.ec.params.field_length;
			else
				modulus_length = cert->key->u.rsa.modulus.len * 8;
			if (r == SC_SUCCESS) {
				static const struct sc_object_id cn_oid = {{ 2, 5, 4, 3, -1 }};
				u8 *cn_name = NULL;
				size_t cn_len = 0;
				sc_pkcs15_get_name_from_dn(card->ctx, cert->subject,
					cert->subject_len, &cn_oid, &cn_name, &cn_len);
				if (cn_len > 0) {
					char *token_name = malloc(cn_len+1);
					if (token_name) {
						memcpy(token_name, cn_name, cn_len);
						token_name[cn_len] = '\0';
						set_string(&p15card->tokeninfo->label, (const char*)token_name);
						free(token_name);
					}
				}
				free(cn_name);
				sc_pkcs15_free_certificate(cert);
			}
		}
	}

	/* the file with key pin info (tries left) */
	sc_format_path (""3f000016"", &tmppath);
	r = sc_select_file (card, &tmppath, NULL);
	if (r < 0)
		return SC_ERROR_INTERNAL;

	/* add pins */
	for (i = 0; i < 3; i++) {
		unsigned char tries_left;
		static const char *esteid_pin_names[3] = {
			""PIN1"",
			""PIN2"",
			""PUK"" };
			
		static const int esteid_pin_min[3] = {4, 5, 8};
		static const int esteid_pin_ref[3] = {1, 2, 0};
		static const int esteid_pin_authid[3] = {1, 2, 3};
		static const int esteid_pin_flags[3] = {0, 0, SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN};
		
		struct sc_pkcs15_auth_info pin_info;
		struct sc_pkcs15_object pin_obj;

		memset(&pin_info, 0, sizeof(pin_info));
		memset(&pin_obj, 0, sizeof(pin_obj));

		/* read the number of tries left for the PIN */
		r = sc_read_record (card, i + 1, buff, sizeof(buff), SC_RECORD_BY_REC_NR);
		if (r < 0)
			return SC_ERROR_INTERNAL;
		tries_left = buff[5];

		pin_info.auth_id.len = 1;
		pin_info.auth_id.value[0] = esteid_pin_authid[i];
		pin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;
		pin_info.attrs.pin.reference = esteid_pin_ref[i];
		pin_info.attrs.pin.flags = esteid_pin_flags[i];
		pin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;
		pin_info.attrs.pin.min_length = esteid_pin_min[i];
		pin_info.attrs.pin.stored_length = 12;
		pin_info.attrs.pin.max_length = 12;
		pin_info.attrs.pin.pad_char = '\0';
		pin_info.tries_left = (int)tries_left;
		pin_info.max_tries = 3;

		strlcpy(pin_obj.label, esteid_pin_names[i], sizeof(pin_obj.label));
		pin_obj.flags = esteid_pin_flags[i];

		/* Link normal PINs with PUK */
		if (i < 2) {
			pin_obj.auth_id.len = 1;
			pin_obj.auth_id.value[0] = 3;
		}

		r = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);
		if (r < 0)
			return SC_ERROR_INTERNAL;
	}

	/* add private keys */
	for (i = 0; i < 2; i++) {
		static int prkey_pin[2] = {1, 2};

		static const char *prkey_name[2] = {
			""Isikutuvastus"",
			""Allkirjastamine""};

		struct sc_pkcs15_prkey_info prkey_info;
		struct sc_pkcs15_object prkey_obj;

		memset(&prkey_info, 0, sizeof(prkey_info));
		memset(&prkey_obj, 0, sizeof(prkey_obj));

		prkey_info.id.len = 1;
		prkey_info.id.value[0] = prkey_pin[i];
		prkey_info.native = 1;
		prkey_info.key_reference = i + 1;
		prkey_info.field_length = field_length;
		prkey_info.modulus_length = modulus_length;
		if (i == 1)
			prkey_info.usage = SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;
		else if(field_length > 0) // ECC has sign and derive usage
			prkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE;
		else
			prkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT;

		strlcpy(prkey_obj.label, prkey_name[i], sizeof(prkey_obj.label));
		prkey_obj.auth_id.len = 1;
		prkey_obj.auth_id.value[0] = prkey_pin[i];
		prkey_obj.user_consent = 0;
		prkey_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;

		if(field_length > 0)
			r = sc_pkcs15emu_add_ec_prkey(p15card, &prkey_obj, &prkey_info);
		else
			r = sc_pkcs15emu_add_rsa_prkey(p15card, &prkey_obj, &prkey_info);
		if (r < 0)
			return SC_ERROR_INTERNAL;
	}

	return SC_SUCCESS;
}
",C,"	buff[MIN((size_t) r, (sizeof buff)-1)] = '\0';
","	buff[r] = '\0';
",,"@@ -79,7 +79,7 @@ sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)
 	/* read the serial (document number) */
 	r = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);
 	SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""read document number failed"");
-	buff[r] = '\0';
+	buff[MIN((size_t) r, (sizeof buff)-1)] = '\0';
 	set_string (&p15card->tokeninfo->serial_number, (const char *) buff);
 
 	p15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION",OpenSC,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,8fe377e93b4b56060e5bbfb6f3142ceaeca744fa,1,"sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)
{
	sc_card_t *card = p15card->card;
	unsigned char buff[128];
	int r, i;
	size_t field_length = 0, modulus_length = 0;
	sc_path_t tmppath;

	set_string (&p15card->tokeninfo->label, ""ID-kaart"");
	set_string (&p15card->tokeninfo->manufacturer_id, ""AS Sertifitseerimiskeskus"");

	/* Select application directory */
	sc_format_path (""3f00eeee5044"", &tmppath);
	r = sc_select_file (card, &tmppath, NULL);
	SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""select esteid PD failed"");

 	/* read the serial (document number) */
 	r = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);
 	SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""read document number failed"");
//flaw_line_below:
	buff[r] = '\0';
//fix_flaw_line_below:
//	buff[MIN((size_t) r, (sizeof buff)-1)] = '\0';
 	set_string (&p15card->tokeninfo->serial_number, (const char *) buff);
 
 	p15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION
				  | SC_PKCS15_TOKEN_EID_COMPLIANT
				  | SC_PKCS15_TOKEN_READONLY;

	/* add certificates */
	for (i = 0; i < 2; i++) {
		static const char *esteid_cert_names[2] = {
			""Isikutuvastus"",
			""Allkirjastamine""};
		static char const *esteid_cert_paths[2] = {
			""3f00eeeeaace"",
			""3f00eeeeddce""};
		static int esteid_cert_ids[2] = {1, 2};

		struct sc_pkcs15_cert_info cert_info;
		struct sc_pkcs15_object cert_obj;

		memset(&cert_info, 0, sizeof(cert_info));
		memset(&cert_obj, 0, sizeof(cert_obj));

		cert_info.id.value[0] = esteid_cert_ids[i];
		cert_info.id.len = 1;
		sc_format_path(esteid_cert_paths[i], &cert_info.path);
		strlcpy(cert_obj.label, esteid_cert_names[i], sizeof(cert_obj.label));
		r = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);
		if (r < 0)
			return SC_ERROR_INTERNAL;
		if (i == 0) {
			sc_pkcs15_cert_t *cert = NULL;
			r = sc_pkcs15_read_certificate(p15card, &cert_info, &cert);
			if (r < 0)
				return SC_ERROR_INTERNAL;
			if (cert->key->algorithm == SC_ALGORITHM_EC)
				field_length = cert->key->u.ec.params.field_length;
			else
				modulus_length = cert->key->u.rsa.modulus.len * 8;
			if (r == SC_SUCCESS) {
				static const struct sc_object_id cn_oid = {{ 2, 5, 4, 3, -1 }};
				u8 *cn_name = NULL;
				size_t cn_len = 0;
				sc_pkcs15_get_name_from_dn(card->ctx, cert->subject,
					cert->subject_len, &cn_oid, &cn_name, &cn_len);
				if (cn_len > 0) {
					char *token_name = malloc(cn_len+1);
					if (token_name) {
						memcpy(token_name, cn_name, cn_len);
						token_name[cn_len] = '\0';
						set_string(&p15card->tokeninfo->label, (const char*)token_name);
						free(token_name);
					}
				}
				free(cn_name);
				sc_pkcs15_free_certificate(cert);
			}
		}
	}

	/* the file with key pin info (tries left) */
	sc_format_path (""3f000016"", &tmppath);
	r = sc_select_file (card, &tmppath, NULL);
	if (r < 0)
		return SC_ERROR_INTERNAL;

	/* add pins */
	for (i = 0; i < 3; i++) {
		unsigned char tries_left;
		static const char *esteid_pin_names[3] = {
			""PIN1"",
			""PIN2"",
			""PUK"" };
			
		static const int esteid_pin_min[3] = {4, 5, 8};
		static const int esteid_pin_ref[3] = {1, 2, 0};
		static const int esteid_pin_authid[3] = {1, 2, 3};
		static const int esteid_pin_flags[3] = {0, 0, SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN};
		
		struct sc_pkcs15_auth_info pin_info;
		struct sc_pkcs15_object pin_obj;

		memset(&pin_info, 0, sizeof(pin_info));
		memset(&pin_obj, 0, sizeof(pin_obj));

		/* read the number of tries left for the PIN */
		r = sc_read_record (card, i + 1, buff, sizeof(buff), SC_RECORD_BY_REC_NR);
		if (r < 0)
			return SC_ERROR_INTERNAL;
		tries_left = buff[5];

		pin_info.auth_id.len = 1;
		pin_info.auth_id.value[0] = esteid_pin_authid[i];
		pin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;
		pin_info.attrs.pin.reference = esteid_pin_ref[i];
		pin_info.attrs.pin.flags = esteid_pin_flags[i];
		pin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;
		pin_info.attrs.pin.min_length = esteid_pin_min[i];
		pin_info.attrs.pin.stored_length = 12;
		pin_info.attrs.pin.max_length = 12;
		pin_info.attrs.pin.pad_char = '\0';
		pin_info.tries_left = (int)tries_left;
		pin_info.max_tries = 3;

		strlcpy(pin_obj.label, esteid_pin_names[i], sizeof(pin_obj.label));
		pin_obj.flags = esteid_pin_flags[i];

		/* Link normal PINs with PUK */
		if (i < 2) {
			pin_obj.auth_id.len = 1;
			pin_obj.auth_id.value[0] = 3;
		}

		r = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);
		if (r < 0)
			return SC_ERROR_INTERNAL;
	}

	/* add private keys */
	for (i = 0; i < 2; i++) {
		static int prkey_pin[2] = {1, 2};

		static const char *prkey_name[2] = {
			""Isikutuvastus"",
			""Allkirjastamine""};

		struct sc_pkcs15_prkey_info prkey_info;
		struct sc_pkcs15_object prkey_obj;

		memset(&prkey_info, 0, sizeof(prkey_info));
		memset(&prkey_obj, 0, sizeof(prkey_obj));

		prkey_info.id.len = 1;
		prkey_info.id.value[0] = prkey_pin[i];
		prkey_info.native = 1;
		prkey_info.key_reference = i + 1;
		prkey_info.field_length = field_length;
		prkey_info.modulus_length = modulus_length;
		if (i == 1)
			prkey_info.usage = SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;
		else if(field_length > 0) // ECC has sign and derive usage
			prkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE;
		else
			prkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT;

		strlcpy(prkey_obj.label, prkey_name[i], sizeof(prkey_obj.label));
		prkey_obj.auth_id.len = 1;
		prkey_obj.auth_id.value[0] = prkey_pin[i];
		prkey_obj.user_consent = 0;
		prkey_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;

		if(field_length > 0)
			r = sc_pkcs15emu_add_ec_prkey(p15card, &prkey_obj, &prkey_info);
		else
			r = sc_pkcs15emu_add_rsa_prkey(p15card, &prkey_obj, &prkey_info);
		if (r < 0)
			return SC_ERROR_INTERNAL;
	}

	return SC_SUCCESS;
}
"
4513,182249,,Local,Not required,Partial,CVE-2018-16425,https://www.cvedetails.com/cve/CVE-2018-16425/,CWE-415,Low,Partial,Partial,,2018-09-03,4.6,A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,2019-09-11,DoS ,1,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,"fixed out of bounds writes

Thanks to Eric Sesterhenn from X41 D-SEC GmbH
for reporting the problems.",1,src/libopensc/pkcs15-gemsafeV1.c,"{""sha"": ""756788a0fbbbed8487e8cf33b6115bb4d4f58860"", ""filename"": ""src/libopensc/card-cac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-cac.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -794,7 +794,7 @@ static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri\n         }\n \tif (priv->cac_id_len) {\n \t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n-\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n+\t\tmemcpy(serial->value, priv->cac_id, serial->len);\n \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n \t}\n \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);""}<_**next**_>{""sha"": ""65a58f6740d38e6fd6204cbacb5015995067334f"", ""filename"": ""src/libopensc/card-epass2003.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-epass2003.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -951,7 +951,7 @@ decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned\n \twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n \t\tcipher_len--;\n \n-\tif (2 == cipher_len)\n+\tif (2 == cipher_len || *out_len < cipher_len - 2)\n \t\treturn -1;\n \n \tmemcpy(out, plaintext, cipher_len - 2);\n@@ -977,6 +977,7 @@ epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apd\n \tr = sc_check_sw(card, sm->sw1, sm->sw2);\n \tif (r == SC_SUCCESS) {\n \t\tif (exdata->sm) {\n+\t\t\tlen = plain->resplen;\n \t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n \t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n \t\t}""}<_**next**_>{""sha"": ""d247efabc9fd2d7978e4a24dc42bcaccd42f3bee"", ""filename"": ""src/libopensc/card-muscle.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-muscle.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -518,7 +518,9 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \tmscfs_check_cache(priv->fs);\n \n \tfor(x = 0; x < fs->cache.size; x++) {\n-\t\tu8* oid= fs->cache.array[x].objectId.id;\n+\t\tu8* oid = fs->cache.array[x].objectId.id;\n+\t\tif (bufLen < 2)\n+\t\t\tbreak;\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n \t\t\t\""FILE: %02X%02X%02X%02X\\n\"",\n \t\t\toid[0],oid[1],oid[2],oid[3]);\n@@ -527,7 +529,8 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \t\t\tbuf[1] = oid[3];\n \t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n \t\t\tbuf += 2;\n-\t\t\tcount+=2;\n+\t\t\tcount += 2;\n+\t\t\tbufLen -= 2;\n \t\t}\n \t}\n \treturn count;""}<_**next**_>{""sha"": ""3c86b1f4838a5837341ae9cfc9b7fdb5334fe138"", ""filename"": ""src/libopensc/card-tcos.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-tcos.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -408,7 +408,7 @@ static int tcos_select_file(sc_card_t *card,\n \tfile->path = *in_path;\n \n \tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n-\t\tint j, len=apdu.resp[i+1];\n+\t\tsize_t j, len=apdu.resp[i+1];\n \t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n \n \t\tswitch (type) {\n@@ -432,8 +432,8 @@ static int tcos_select_file(sc_card_t *card,\n \t\t\tfile->id = (d[0]<<8) | d[1];\n \t\t\tbreak;\n \t\tcase 0x84:\n-\t\t\tmemcpy(file->name, d, len);\n-\t\t\tfile->namelen = len;\n+\t\t\tfile->namelen = MIN(sizeof file->name, len);\n+\t\t\tmemcpy(file->name, d, file->namelen);\n \t\t\tbreak;\n \t\tcase 0x86:\n \t\t\tsc_file_set_sec_attr(file, d, len); ""}<_**next**_>{""sha"": ""2b8d66b913b0d3ce3c92c0578c43ae847f98d2c7"", ""filename"": ""src/libopensc/pkcs15-esteid.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-esteid.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -79,7 +79,7 @@ sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n \t/* read the serial (document number) */\n \tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \""read document number failed\"");\n-\tbuff[r] = '\\0';\n+\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n \tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n \n \tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION""}<_**next**_>{""sha"": ""3b220f7a5b37ea236b58ef543d01ca08c815b826"", ""filename"": ""src/libopensc/pkcs15-gemsafeV1.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-gemsafeV1.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -208,7 +208,7 @@ static int gemsafe_get_cert_len(sc_card_t *card)\n \t * the private key.\n \t */\n \tind = 2; /* skip length */\n-\twhile (ibuf[ind] == 0x01) {\n+\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n \t\tif (ibuf[ind+1] == 0xFE) {\n \t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n \t\t\tsc_log(card->ctx, \""Key container %d is allocated and uses key_ref %d\"",""}<_**next**_>{""sha"": ""1391bea15370cd020dfdf1cfb0d9c24db950a0c4"", ""filename"": ""src/libopensc/pkcs15-sc-hsm.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-sc-hsm.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -837,12 +837,14 @@ static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n \t\tr = read_file(p15card, (u8 *) \""\\x2F\\x02\"", efbin, &len, 1);\n \t\tLOG_TEST_RET(card->ctx, r, \""Skipping optional EF.C_DevAut\"");\n \n-\t\t/* save EF_C_DevAut for further use */\n-\t\tptr = realloc(priv->EF_C_DevAut, len);\n-\t\tif (ptr) {\n-\t\t\tmemcpy(ptr, efbin, len);\n-\t\t\tpriv->EF_C_DevAut = ptr;\n-\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\tif (len > 0) {\n+\t\t\t/* save EF_C_DevAut for further use */\n+\t\t\tptr = realloc(priv->EF_C_DevAut, len);\n+\t\t\tif (ptr) {\n+\t\t\t\tmemcpy(ptr, efbin, len);\n+\t\t\t\tpriv->EF_C_DevAut = ptr;\n+\t\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\t\t}\n \t\t}\n \n \t\tptr = efbin;""}<_**next**_>{""sha"": ""53fefb3e68eac554ed608a5a960cf3dd5f5b8dcb"", ""filename"": ""src/libopensc/sc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/sc.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -628,7 +628,7 @@ int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n \t\treturn SC_ERROR_INVALID_ARGUMENTS;\n \t}\n \n-\tif (sec_attr == NULL) {\n+\tif (sec_attr == NULL || sec_attr_len) {\n \t\tif (file->sec_attr != NULL)\n \t\t\tfree(file->sec_attr);\n \t\tfile->sec_attr = NULL;""}<_**next**_>{""sha"": ""662a028222a909f431f31c60bc421fa83d86d5b6"", ""filename"": ""src/tools/cryptoflex-tool.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/cryptoflex-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -21,6 +21,7 @@\n #include \""config.h\""\n \n #include \""libopensc/sc-ossl-compat.h\""\n+#include \""libopensc/internal.h\""\n #include <openssl/bn.h>\n #include <openssl/rsa.h>\n #include <openssl/x509.h>\n@@ -331,7 +332,7 @@ static int read_public_key(RSA *rsa)\n \t\tfprintf(stderr, \""Unable to select public key file: %s\\n\"", sc_strerror(r));\n \t\treturn 2;\n \t}\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {\n@@ -382,7 +383,7 @@ static int read_private_key(RSA *rsa)\n \te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n \tif (e == NULL || e->method == SC_AC_NEVER)\n \t\treturn 10;\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {""}<_**next**_>{""sha"": ""31360833b5284915ae8d93babeb3fdb1b279a0f3"", ""filename"": ""src/tools/egk-tool.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/egk-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -149,7 +149,7 @@ int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t\n \t\tgoto err;\n \t}\n \n-\tlen = file ? file->size : 4096;\n+\tlen = file && file->size > 0 ? file->size : 4096;\n \tp = realloc(*data, len);\n \tif (!p) {\n \t\tgoto err;""}<_**next**_>{""sha"": ""e49647a472e921663b2952ef5cf213c9fc974beb"", ""filename"": ""src/tools/util.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/util.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -339,10 +339,11 @@ const char * util_acl_to_str(const sc_acl_entry_t *e)\n \t\t\tstrcpy(buf, \""????\"");\n \t\t\tbreak;\n \t\t}\n-\t\tstrcat(line, buf);\n-\t\tstrcat(line, \"" \"");\n+\t\tstrncat(line, buf, sizeof line);\n+\t\tstrncat(line, \"" \"", sizeof line);\n \t\te = e->next;\n \t}\n+\tline[(sizeof line)-1] = '\\0'; /* make sure it's NUL terminated */\n \tline[strlen(line)-1] = 0; /* get rid of trailing space */\n \treturn line;\n }""}","static int gemsafe_get_cert_len(sc_card_t *card)
{
	int r;
	u8  ibuf[GEMSAFE_MAX_OBJLEN];
	u8 *iptr;
	struct sc_path path;
	struct sc_file *file;
	size_t objlen, certlen;
	unsigned int ind, i=0;

	sc_format_path(GEMSAFE_PATH, &path);
	r = sc_select_file(card, &path, &file);
	if (r != SC_SUCCESS || !file)
		return SC_ERROR_INTERNAL;

	/* Initial read */
	r = sc_read_binary(card, 0, ibuf, GEMSAFE_READ_QUANTUM, 0);
	if (r < 0)
		return SC_ERROR_INTERNAL;

	/* Actual stored object size is encoded in first 2 bytes
	 * (allocated EF space is much greater!)
	 */
	objlen = (((size_t) ibuf[0]) << 8) | ibuf[1];
	sc_log(card->ctx, ""Stored object is of size: %""SC_FORMAT_LEN_SIZE_T""u"",
	       objlen);
	if (objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN) {
	    sc_log(card->ctx, ""Invalid object size: %""SC_FORMAT_LEN_SIZE_T""u"",
		   objlen);
	    return SC_ERROR_INTERNAL;
	}

	/* It looks like the first thing in the block is a table of
	 * which keys are allocated. The table is small and is in the
	 * first 248 bytes. Example for a card with 10 key containers:
	 * 01 f0 00 03 03 b0 00 03     <=  1st key unallocated
	 * 01 f0 00 04 03 b0 00 04     <=  2nd key unallocated
	 * 01 fe 14 00 05 03 b0 00 05  <=  3rd key allocated
	 * 01 fe 14 01 06 03 b0 00 06  <=  4th key allocated
	 * 01 f0 00 07 03 b0 00 07     <=  5th key unallocated
	 * ...
	 * 01 f0 00 0c 03 b0 00 0c     <= 10th key unallocated
	 * For allocated keys, the fourth byte seems to indicate the
	 * default key and the fifth byte indicates the key_ref of
 	 * the private key.
 	 */
 	ind = 2; /* skip length */
	while (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {
 		if (ibuf[ind+1] == 0xFE) {
 			gemsafe_prkeys[i].ref = ibuf[ind+4];
 			sc_log(card->ctx, ""Key container %d is allocated and uses key_ref %d"",
					i+1, gemsafe_prkeys[i].ref);
			ind += 9;
		}
		else {
			gemsafe_prkeys[i].label = NULL;
			gemsafe_cert[i].label = NULL;
			sc_log(card->ctx, ""Key container %d is unallocated"", i+1);
			ind += 8;
		}
		i++;
	}

	/* Delete additional key containers from the data structures if
	 * this card can't accommodate them.
	 */
	for (; i < gemsafe_cert_max; i++) {
		gemsafe_prkeys[i].label = NULL;
		gemsafe_cert[i].label = NULL;
	}

	/* Read entire file, then dissect in memory.
	 * Gemalto ClassicClient seems to do it the same way.
	 */
	iptr = ibuf + GEMSAFE_READ_QUANTUM;
	while ((size_t)(iptr - ibuf) < objlen) {
		r = sc_read_binary(card, iptr - ibuf, iptr,
				   MIN(GEMSAFE_READ_QUANTUM, objlen - (iptr - ibuf)), 0);
		if (r < 0) {
			sc_log(card->ctx, ""Could not read cert object"");
			return SC_ERROR_INTERNAL;
		}
		iptr += GEMSAFE_READ_QUANTUM;
	}

	/* Search buffer for certificates, they start with 0x3082. */
	i = 0;
	while (ind < objlen - 1) {
		if (ibuf[ind] == 0x30 && ibuf[ind+1] == 0x82) {
			/* Find next allocated key container */
			while (i < gemsafe_cert_max && gemsafe_cert[i].label == NULL)
				i++;
			if (i == gemsafe_cert_max) {
				sc_log(card->ctx, ""Warning: Found orphaned certificate at offset %d"", ind);
				return SC_SUCCESS;
			}
			/* DER cert len is encoded this way */
			if (ind+3 >= sizeof ibuf)
				return SC_ERROR_INVALID_DATA;
			certlen = ((((size_t) ibuf[ind+2]) << 8) | ibuf[ind+3]) + 4;
			sc_log(card->ctx,
			       ""Found certificate of key container %d at offset %d, len %""SC_FORMAT_LEN_SIZE_T""u"",
			       i+1, ind, certlen);
			gemsafe_cert[i].index = ind;
			gemsafe_cert[i].count = certlen;
			ind += certlen;
			i++;
		} else
			ind++;
	}

	/* Delete additional key containers from the data structures if
	 * they're missing on the card.
	 */
	for (; i < gemsafe_cert_max; i++) {
		if (gemsafe_cert[i].label) {
			sc_log(card->ctx, ""Warning: Certificate of key container %d is missing"", i+1);
			gemsafe_prkeys[i].label = NULL;
			gemsafe_cert[i].label = NULL;
		}
	}

	return SC_SUCCESS;
}
","static int gemsafe_get_cert_len(sc_card_t *card)
{
	int r;
	u8  ibuf[GEMSAFE_MAX_OBJLEN];
	u8 *iptr;
	struct sc_path path;
	struct sc_file *file;
	size_t objlen, certlen;
	unsigned int ind, i=0;

	sc_format_path(GEMSAFE_PATH, &path);
	r = sc_select_file(card, &path, &file);
	if (r != SC_SUCCESS || !file)
		return SC_ERROR_INTERNAL;

	/* Initial read */
	r = sc_read_binary(card, 0, ibuf, GEMSAFE_READ_QUANTUM, 0);
	if (r < 0)
		return SC_ERROR_INTERNAL;

	/* Actual stored object size is encoded in first 2 bytes
	 * (allocated EF space is much greater!)
	 */
	objlen = (((size_t) ibuf[0]) << 8) | ibuf[1];
	sc_log(card->ctx, ""Stored object is of size: %""SC_FORMAT_LEN_SIZE_T""u"",
	       objlen);
	if (objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN) {
	    sc_log(card->ctx, ""Invalid object size: %""SC_FORMAT_LEN_SIZE_T""u"",
		   objlen);
	    return SC_ERROR_INTERNAL;
	}

	/* It looks like the first thing in the block is a table of
	 * which keys are allocated. The table is small and is in the
	 * first 248 bytes. Example for a card with 10 key containers:
	 * 01 f0 00 03 03 b0 00 03     <=  1st key unallocated
	 * 01 f0 00 04 03 b0 00 04     <=  2nd key unallocated
	 * 01 fe 14 00 05 03 b0 00 05  <=  3rd key allocated
	 * 01 fe 14 01 06 03 b0 00 06  <=  4th key allocated
	 * 01 f0 00 07 03 b0 00 07     <=  5th key unallocated
	 * ...
	 * 01 f0 00 0c 03 b0 00 0c     <= 10th key unallocated
	 * For allocated keys, the fourth byte seems to indicate the
	 * default key and the fifth byte indicates the key_ref of
 	 * the private key.
 	 */
 	ind = 2; /* skip length */
	while (ibuf[ind] == 0x01) {
 		if (ibuf[ind+1] == 0xFE) {
 			gemsafe_prkeys[i].ref = ibuf[ind+4];
 			sc_log(card->ctx, ""Key container %d is allocated and uses key_ref %d"",
					i+1, gemsafe_prkeys[i].ref);
			ind += 9;
		}
		else {
			gemsafe_prkeys[i].label = NULL;
			gemsafe_cert[i].label = NULL;
			sc_log(card->ctx, ""Key container %d is unallocated"", i+1);
			ind += 8;
		}
		i++;
	}

	/* Delete additional key containers from the data structures if
	 * this card can't accommodate them.
	 */
	for (; i < gemsafe_cert_max; i++) {
		gemsafe_prkeys[i].label = NULL;
		gemsafe_cert[i].label = NULL;
	}

	/* Read entire file, then dissect in memory.
	 * Gemalto ClassicClient seems to do it the same way.
	 */
	iptr = ibuf + GEMSAFE_READ_QUANTUM;
	while ((size_t)(iptr - ibuf) < objlen) {
		r = sc_read_binary(card, iptr - ibuf, iptr,
				   MIN(GEMSAFE_READ_QUANTUM, objlen - (iptr - ibuf)), 0);
		if (r < 0) {
			sc_log(card->ctx, ""Could not read cert object"");
			return SC_ERROR_INTERNAL;
		}
		iptr += GEMSAFE_READ_QUANTUM;
	}

	/* Search buffer for certificates, they start with 0x3082. */
	i = 0;
	while (ind < objlen - 1) {
		if (ibuf[ind] == 0x30 && ibuf[ind+1] == 0x82) {
			/* Find next allocated key container */
			while (i < gemsafe_cert_max && gemsafe_cert[i].label == NULL)
				i++;
			if (i == gemsafe_cert_max) {
				sc_log(card->ctx, ""Warning: Found orphaned certificate at offset %d"", ind);
				return SC_SUCCESS;
			}
			/* DER cert len is encoded this way */
			if (ind+3 >= sizeof ibuf)
				return SC_ERROR_INVALID_DATA;
			certlen = ((((size_t) ibuf[ind+2]) << 8) | ibuf[ind+3]) + 4;
			sc_log(card->ctx,
			       ""Found certificate of key container %d at offset %d, len %""SC_FORMAT_LEN_SIZE_T""u"",
			       i+1, ind, certlen);
			gemsafe_cert[i].index = ind;
			gemsafe_cert[i].count = certlen;
			ind += certlen;
			i++;
		} else
			ind++;
	}

	/* Delete additional key containers from the data structures if
	 * they're missing on the card.
	 */
	for (; i < gemsafe_cert_max; i++) {
		if (gemsafe_cert[i].label) {
			sc_log(card->ctx, ""Warning: Certificate of key container %d is missing"", i+1);
			gemsafe_prkeys[i].label = NULL;
			gemsafe_cert[i].label = NULL;
		}
	}

	return SC_SUCCESS;
}
",C,"	while (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {
","	while (ibuf[ind] == 0x01) {
",,"@@ -208,7 +208,7 @@ static int gemsafe_get_cert_len(sc_card_t *card)
 	 * the private key.
 	 */
 	ind = 2; /* skip length */
-	while (ibuf[ind] == 0x01) {
+	while (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {
 		if (ibuf[ind+1] == 0xFE) {
 			gemsafe_prkeys[i].ref = ibuf[ind+4];
 			sc_log(card->ctx, ""Key container %d is allocated and uses key_ref %d"",",OpenSC,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,8fe377e93b4b56060e5bbfb6f3142ceaeca744fa,1,"static int gemsafe_get_cert_len(sc_card_t *card)
{
	int r;
	u8  ibuf[GEMSAFE_MAX_OBJLEN];
	u8 *iptr;
	struct sc_path path;
	struct sc_file *file;
	size_t objlen, certlen;
	unsigned int ind, i=0;

	sc_format_path(GEMSAFE_PATH, &path);
	r = sc_select_file(card, &path, &file);
	if (r != SC_SUCCESS || !file)
		return SC_ERROR_INTERNAL;

	/* Initial read */
	r = sc_read_binary(card, 0, ibuf, GEMSAFE_READ_QUANTUM, 0);
	if (r < 0)
		return SC_ERROR_INTERNAL;

	/* Actual stored object size is encoded in first 2 bytes
	 * (allocated EF space is much greater!)
	 */
	objlen = (((size_t) ibuf[0]) << 8) | ibuf[1];
	sc_log(card->ctx, ""Stored object is of size: %""SC_FORMAT_LEN_SIZE_T""u"",
	       objlen);
	if (objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN) {
	    sc_log(card->ctx, ""Invalid object size: %""SC_FORMAT_LEN_SIZE_T""u"",
		   objlen);
	    return SC_ERROR_INTERNAL;
	}

	/* It looks like the first thing in the block is a table of
	 * which keys are allocated. The table is small and is in the
	 * first 248 bytes. Example for a card with 10 key containers:
	 * 01 f0 00 03 03 b0 00 03     <=  1st key unallocated
	 * 01 f0 00 04 03 b0 00 04     <=  2nd key unallocated
	 * 01 fe 14 00 05 03 b0 00 05  <=  3rd key allocated
	 * 01 fe 14 01 06 03 b0 00 06  <=  4th key allocated
	 * 01 f0 00 07 03 b0 00 07     <=  5th key unallocated
	 * ...
	 * 01 f0 00 0c 03 b0 00 0c     <= 10th key unallocated
	 * For allocated keys, the fourth byte seems to indicate the
	 * default key and the fifth byte indicates the key_ref of
 	 * the private key.
 	 */
 	ind = 2; /* skip length */
//flaw_line_below:
	while (ibuf[ind] == 0x01) {
//fix_flaw_line_below:
//	while (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {
 		if (ibuf[ind+1] == 0xFE) {
 			gemsafe_prkeys[i].ref = ibuf[ind+4];
 			sc_log(card->ctx, ""Key container %d is allocated and uses key_ref %d"",
					i+1, gemsafe_prkeys[i].ref);
			ind += 9;
		}
		else {
			gemsafe_prkeys[i].label = NULL;
			gemsafe_cert[i].label = NULL;
			sc_log(card->ctx, ""Key container %d is unallocated"", i+1);
			ind += 8;
		}
		i++;
	}

	/* Delete additional key containers from the data structures if
	 * this card can't accommodate them.
	 */
	for (; i < gemsafe_cert_max; i++) {
		gemsafe_prkeys[i].label = NULL;
		gemsafe_cert[i].label = NULL;
	}

	/* Read entire file, then dissect in memory.
	 * Gemalto ClassicClient seems to do it the same way.
	 */
	iptr = ibuf + GEMSAFE_READ_QUANTUM;
	while ((size_t)(iptr - ibuf) < objlen) {
		r = sc_read_binary(card, iptr - ibuf, iptr,
				   MIN(GEMSAFE_READ_QUANTUM, objlen - (iptr - ibuf)), 0);
		if (r < 0) {
			sc_log(card->ctx, ""Could not read cert object"");
			return SC_ERROR_INTERNAL;
		}
		iptr += GEMSAFE_READ_QUANTUM;
	}

	/* Search buffer for certificates, they start with 0x3082. */
	i = 0;
	while (ind < objlen - 1) {
		if (ibuf[ind] == 0x30 && ibuf[ind+1] == 0x82) {
			/* Find next allocated key container */
			while (i < gemsafe_cert_max && gemsafe_cert[i].label == NULL)
				i++;
			if (i == gemsafe_cert_max) {
				sc_log(card->ctx, ""Warning: Found orphaned certificate at offset %d"", ind);
				return SC_SUCCESS;
			}
			/* DER cert len is encoded this way */
			if (ind+3 >= sizeof ibuf)
				return SC_ERROR_INVALID_DATA;
			certlen = ((((size_t) ibuf[ind+2]) << 8) | ibuf[ind+3]) + 4;
			sc_log(card->ctx,
			       ""Found certificate of key container %d at offset %d, len %""SC_FORMAT_LEN_SIZE_T""u"",
			       i+1, ind, certlen);
			gemsafe_cert[i].index = ind;
			gemsafe_cert[i].count = certlen;
			ind += certlen;
			i++;
		} else
			ind++;
	}

	/* Delete additional key containers from the data structures if
	 * they're missing on the card.
	 */
	for (; i < gemsafe_cert_max; i++) {
		if (gemsafe_cert[i].label) {
			sc_log(card->ctx, ""Warning: Certificate of key container %d is missing"", i+1);
			gemsafe_prkeys[i].label = NULL;
			gemsafe_cert[i].label = NULL;
		}
	}

	return SC_SUCCESS;
}
"
4514,182250,,Local,Not required,Partial,CVE-2018-16425,https://www.cvedetails.com/cve/CVE-2018-16425/,CWE-415,Low,Partial,Partial,,2018-09-03,4.6,A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,2019-09-11,DoS ,8,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,"fixed out of bounds writes

Thanks to Eric Sesterhenn from X41 D-SEC GmbH
for reporting the problems.",6,src/libopensc/pkcs15-sc-hsm.c,"{""sha"": ""756788a0fbbbed8487e8cf33b6115bb4d4f58860"", ""filename"": ""src/libopensc/card-cac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-cac.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -794,7 +794,7 @@ static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri\n         }\n \tif (priv->cac_id_len) {\n \t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n-\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n+\t\tmemcpy(serial->value, priv->cac_id, serial->len);\n \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n \t}\n \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);""}<_**next**_>{""sha"": ""65a58f6740d38e6fd6204cbacb5015995067334f"", ""filename"": ""src/libopensc/card-epass2003.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-epass2003.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -951,7 +951,7 @@ decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned\n \twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n \t\tcipher_len--;\n \n-\tif (2 == cipher_len)\n+\tif (2 == cipher_len || *out_len < cipher_len - 2)\n \t\treturn -1;\n \n \tmemcpy(out, plaintext, cipher_len - 2);\n@@ -977,6 +977,7 @@ epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apd\n \tr = sc_check_sw(card, sm->sw1, sm->sw2);\n \tif (r == SC_SUCCESS) {\n \t\tif (exdata->sm) {\n+\t\t\tlen = plain->resplen;\n \t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n \t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n \t\t}""}<_**next**_>{""sha"": ""d247efabc9fd2d7978e4a24dc42bcaccd42f3bee"", ""filename"": ""src/libopensc/card-muscle.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-muscle.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -518,7 +518,9 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \tmscfs_check_cache(priv->fs);\n \n \tfor(x = 0; x < fs->cache.size; x++) {\n-\t\tu8* oid= fs->cache.array[x].objectId.id;\n+\t\tu8* oid = fs->cache.array[x].objectId.id;\n+\t\tif (bufLen < 2)\n+\t\t\tbreak;\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n \t\t\t\""FILE: %02X%02X%02X%02X\\n\"",\n \t\t\toid[0],oid[1],oid[2],oid[3]);\n@@ -527,7 +529,8 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \t\t\tbuf[1] = oid[3];\n \t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n \t\t\tbuf += 2;\n-\t\t\tcount+=2;\n+\t\t\tcount += 2;\n+\t\t\tbufLen -= 2;\n \t\t}\n \t}\n \treturn count;""}<_**next**_>{""sha"": ""3c86b1f4838a5837341ae9cfc9b7fdb5334fe138"", ""filename"": ""src/libopensc/card-tcos.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-tcos.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -408,7 +408,7 @@ static int tcos_select_file(sc_card_t *card,\n \tfile->path = *in_path;\n \n \tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n-\t\tint j, len=apdu.resp[i+1];\n+\t\tsize_t j, len=apdu.resp[i+1];\n \t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n \n \t\tswitch (type) {\n@@ -432,8 +432,8 @@ static int tcos_select_file(sc_card_t *card,\n \t\t\tfile->id = (d[0]<<8) | d[1];\n \t\t\tbreak;\n \t\tcase 0x84:\n-\t\t\tmemcpy(file->name, d, len);\n-\t\t\tfile->namelen = len;\n+\t\t\tfile->namelen = MIN(sizeof file->name, len);\n+\t\t\tmemcpy(file->name, d, file->namelen);\n \t\t\tbreak;\n \t\tcase 0x86:\n \t\t\tsc_file_set_sec_attr(file, d, len); ""}<_**next**_>{""sha"": ""2b8d66b913b0d3ce3c92c0578c43ae847f98d2c7"", ""filename"": ""src/libopensc/pkcs15-esteid.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-esteid.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -79,7 +79,7 @@ sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n \t/* read the serial (document number) */\n \tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \""read document number failed\"");\n-\tbuff[r] = '\\0';\n+\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n \tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n \n \tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION""}<_**next**_>{""sha"": ""3b220f7a5b37ea236b58ef543d01ca08c815b826"", ""filename"": ""src/libopensc/pkcs15-gemsafeV1.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-gemsafeV1.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -208,7 +208,7 @@ static int gemsafe_get_cert_len(sc_card_t *card)\n \t * the private key.\n \t */\n \tind = 2; /* skip length */\n-\twhile (ibuf[ind] == 0x01) {\n+\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n \t\tif (ibuf[ind+1] == 0xFE) {\n \t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n \t\t\tsc_log(card->ctx, \""Key container %d is allocated and uses key_ref %d\"",""}<_**next**_>{""sha"": ""1391bea15370cd020dfdf1cfb0d9c24db950a0c4"", ""filename"": ""src/libopensc/pkcs15-sc-hsm.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-sc-hsm.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -837,12 +837,14 @@ static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n \t\tr = read_file(p15card, (u8 *) \""\\x2F\\x02\"", efbin, &len, 1);\n \t\tLOG_TEST_RET(card->ctx, r, \""Skipping optional EF.C_DevAut\"");\n \n-\t\t/* save EF_C_DevAut for further use */\n-\t\tptr = realloc(priv->EF_C_DevAut, len);\n-\t\tif (ptr) {\n-\t\t\tmemcpy(ptr, efbin, len);\n-\t\t\tpriv->EF_C_DevAut = ptr;\n-\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\tif (len > 0) {\n+\t\t\t/* save EF_C_DevAut for further use */\n+\t\t\tptr = realloc(priv->EF_C_DevAut, len);\n+\t\t\tif (ptr) {\n+\t\t\t\tmemcpy(ptr, efbin, len);\n+\t\t\t\tpriv->EF_C_DevAut = ptr;\n+\t\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\t\t}\n \t\t}\n \n \t\tptr = efbin;""}<_**next**_>{""sha"": ""53fefb3e68eac554ed608a5a960cf3dd5f5b8dcb"", ""filename"": ""src/libopensc/sc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/sc.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -628,7 +628,7 @@ int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n \t\treturn SC_ERROR_INVALID_ARGUMENTS;\n \t}\n \n-\tif (sec_attr == NULL) {\n+\tif (sec_attr == NULL || sec_attr_len) {\n \t\tif (file->sec_attr != NULL)\n \t\t\tfree(file->sec_attr);\n \t\tfile->sec_attr = NULL;""}<_**next**_>{""sha"": ""662a028222a909f431f31c60bc421fa83d86d5b6"", ""filename"": ""src/tools/cryptoflex-tool.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/cryptoflex-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -21,6 +21,7 @@\n #include \""config.h\""\n \n #include \""libopensc/sc-ossl-compat.h\""\n+#include \""libopensc/internal.h\""\n #include <openssl/bn.h>\n #include <openssl/rsa.h>\n #include <openssl/x509.h>\n@@ -331,7 +332,7 @@ static int read_public_key(RSA *rsa)\n \t\tfprintf(stderr, \""Unable to select public key file: %s\\n\"", sc_strerror(r));\n \t\treturn 2;\n \t}\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {\n@@ -382,7 +383,7 @@ static int read_private_key(RSA *rsa)\n \te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n \tif (e == NULL || e->method == SC_AC_NEVER)\n \t\treturn 10;\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {""}<_**next**_>{""sha"": ""31360833b5284915ae8d93babeb3fdb1b279a0f3"", ""filename"": ""src/tools/egk-tool.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/egk-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -149,7 +149,7 @@ int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t\n \t\tgoto err;\n \t}\n \n-\tlen = file ? file->size : 4096;\n+\tlen = file && file->size > 0 ? file->size : 4096;\n \tp = realloc(*data, len);\n \tif (!p) {\n \t\tgoto err;""}<_**next**_>{""sha"": ""e49647a472e921663b2952ef5cf213c9fc974beb"", ""filename"": ""src/tools/util.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/util.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -339,10 +339,11 @@ const char * util_acl_to_str(const sc_acl_entry_t *e)\n \t\t\tstrcpy(buf, \""????\"");\n \t\t\tbreak;\n \t\t}\n-\t\tstrcat(line, buf);\n-\t\tstrcat(line, \"" \"");\n+\t\tstrncat(line, buf, sizeof line);\n+\t\tstrncat(line, \"" \"", sizeof line);\n \t\te = e->next;\n \t}\n+\tline[(sizeof line)-1] = '\\0'; /* make sure it's NUL terminated */\n \tline[strlen(line)-1] = 0; /* get rid of trailing space */\n \treturn line;\n }""}","static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)
{
	sc_card_t *card = p15card->card;
	sc_hsm_private_data_t *priv = (sc_hsm_private_data_t *) card->drv_data;
	sc_file_t *file = NULL;
	sc_path_t path;
	u8 filelist[MAX_EXT_APDU_LENGTH];
	int filelistlength;
	int r, i;
	sc_cvc_t devcert;
	struct sc_app_info *appinfo;
	struct sc_pkcs15_auth_info pin_info;
	struct sc_pkcs15_object pin_obj;
	struct sc_pin_cmd_data pindata;
	u8 efbin[1024];
	u8 *ptr;
	size_t len;

	LOG_FUNC_CALLED(card->ctx);

	appinfo = calloc(1, sizeof(struct sc_app_info));

	if (appinfo == NULL) {
		LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
	}

	appinfo->aid = sc_hsm_aid;

	appinfo->ddo.aid = sc_hsm_aid;
	p15card->app = appinfo;

	sc_path_set(&path, SC_PATH_TYPE_DF_NAME, sc_hsm_aid.value, sc_hsm_aid.len, 0, 0);
	r = sc_select_file(card, &path, &file);
	LOG_TEST_RET(card->ctx, r, ""Could not select SmartCard-HSM application"");

	p15card->card->version.hw_major = 24;	/* JCOP 2.4.1r3 */
	p15card->card->version.hw_minor = 13;
	if (file && file->prop_attr && file->prop_attr_len >= 2) {
		p15card->card->version.fw_major = file->prop_attr[file->prop_attr_len - 2];
		p15card->card->version.fw_minor = file->prop_attr[file->prop_attr_len - 1];
	}

	sc_file_free(file);

	/* Read device certificate to determine serial number */
	if (priv->EF_C_DevAut && priv->EF_C_DevAut_len) {
		ptr = priv->EF_C_DevAut;
		len = priv->EF_C_DevAut_len;
	} else {
		len = sizeof efbin;
 		r = read_file(p15card, (u8 *) ""\x2F\x02"", efbin, &len, 1);
 		LOG_TEST_RET(card->ctx, r, ""Skipping optional EF.C_DevAut"");
 
		if (len > 0) {
			/* save EF_C_DevAut for further use */
			ptr = realloc(priv->EF_C_DevAut, len);
			if (ptr) {
				memcpy(ptr, efbin, len);
				priv->EF_C_DevAut = ptr;
				priv->EF_C_DevAut_len = len;
			}
 		}
 
 		ptr = efbin;
	}

	memset(&devcert, 0 ,sizeof(devcert));
	r = sc_pkcs15emu_sc_hsm_decode_cvc(p15card, (const u8 **)&ptr, &len, &devcert);
	LOG_TEST_RET(card->ctx, r, ""Could not decode EF.C_DevAut"");

	sc_pkcs15emu_sc_hsm_read_tokeninfo(p15card);

	if (p15card->tokeninfo->label == NULL) {
		if (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID
				|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {
			p15card->tokeninfo->label = strdup(""GoID"");
		} else {
			p15card->tokeninfo->label = strdup(""SmartCard-HSM"");
		}
		if (p15card->tokeninfo->label == NULL)
			LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
	}

	if ((p15card->tokeninfo->manufacturer_id != NULL) && !strcmp(""(unknown)"", p15card->tokeninfo->manufacturer_id)) {
		free(p15card->tokeninfo->manufacturer_id);
		p15card->tokeninfo->manufacturer_id = NULL;
	}

	if (p15card->tokeninfo->manufacturer_id == NULL) {
		if (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID
				|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {
			p15card->tokeninfo->manufacturer_id = strdup(""Bundesdruckerei GmbH"");
		} else {
			p15card->tokeninfo->manufacturer_id = strdup(""www.CardContact.de"");
		}
		if (p15card->tokeninfo->manufacturer_id == NULL)
			LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
	}

	appinfo->label = strdup(p15card->tokeninfo->label);
	if (appinfo->label == NULL)
		LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);

	len = strnlen(devcert.chr, sizeof devcert.chr);		/* Strip last 5 digit sequence number from CHR */
	assert(len >= 8);
	len -= 5;

	p15card->tokeninfo->serial_number = calloc(len + 1, 1);
	if (p15card->tokeninfo->serial_number == NULL)
		LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);

	memcpy(p15card->tokeninfo->serial_number, devcert.chr, len);
	*(p15card->tokeninfo->serial_number + len) = 0;

	sc_hsm_set_serialnr(card, p15card->tokeninfo->serial_number);

	sc_pkcs15emu_sc_hsm_free_cvc(&devcert);

	memset(&pin_info, 0, sizeof(pin_info));
	memset(&pin_obj, 0, sizeof(pin_obj));

	pin_info.auth_id.len = 1;
	pin_info.auth_id.value[0] = 1;
	pin_info.path.aid = sc_hsm_aid;
	pin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;
	pin_info.attrs.pin.reference = 0x81;
	pin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_EXCHANGE_REF_DATA;
	pin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;
	pin_info.attrs.pin.min_length = 6;
	pin_info.attrs.pin.stored_length = 0;
	pin_info.attrs.pin.max_length = 15;
	pin_info.attrs.pin.pad_char = '\0';
	pin_info.tries_left = 3;
	pin_info.max_tries = 3;

	pin_obj.auth_id.len = 1;
	pin_obj.auth_id.value[0] = 2;
	strlcpy(pin_obj.label, ""UserPIN"", sizeof(pin_obj.label));
	pin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE|SC_PKCS15_CO_FLAG_MODIFIABLE;

	r = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);
	if (r < 0)
		LOG_FUNC_RETURN(card->ctx, r);

	memset(&pin_info, 0, sizeof(pin_info));
	memset(&pin_obj, 0, sizeof(pin_obj));

	pin_info.auth_id.len = 1;
	pin_info.auth_id.value[0] = 2;
	pin_info.path.aid = sc_hsm_aid;
	pin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;
	pin_info.attrs.pin.reference = 0x88;
	pin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_UNBLOCK_DISABLED|SC_PKCS15_PIN_FLAG_SO_PIN;
	pin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_BCD;
	pin_info.attrs.pin.min_length = 16;
	pin_info.attrs.pin.stored_length = 0;
	pin_info.attrs.pin.max_length = 16;
	pin_info.attrs.pin.pad_char = '\0';
	pin_info.tries_left = 15;
	pin_info.max_tries = 15;

	strlcpy(pin_obj.label, ""SOPIN"", sizeof(pin_obj.label));
	pin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;

	r = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);
	if (r < 0)
		LOG_FUNC_RETURN(card->ctx, r);


	if (card->type == SC_CARD_TYPE_SC_HSM_SOC
			|| card->type == SC_CARD_TYPE_SC_HSM_GOID) {
		/* SC-HSM of this type always has a PIN-Pad */
		r = SC_SUCCESS;
	} else {
		memset(&pindata, 0, sizeof(pindata));
		pindata.cmd = SC_PIN_CMD_GET_INFO;
		pindata.pin_type = SC_AC_CHV;
		pindata.pin_reference = 0x85;

		r = sc_pin_cmd(card, &pindata, NULL);
	}
	if (r == SC_ERROR_DATA_OBJECT_NOT_FOUND) {
		memset(&pindata, 0, sizeof(pindata));
		pindata.cmd = SC_PIN_CMD_GET_INFO;
		pindata.pin_type = SC_AC_CHV;
		pindata.pin_reference = 0x86;

		r = sc_pin_cmd(card, &pindata, NULL);
	}

	if ((r != SC_ERROR_DATA_OBJECT_NOT_FOUND) && (r != SC_ERROR_INCORRECT_PARAMETERS))
		card->caps |= SC_CARD_CAP_PROTECTED_AUTHENTICATION_PATH;


	filelistlength = sc_list_files(card, filelist, sizeof(filelist));
	LOG_TEST_RET(card->ctx, filelistlength, ""Could not enumerate file and key identifier"");

	for (i = 0; i < filelistlength; i += 2) {
		switch(filelist[i]) {
		case KEY_PREFIX:
			r = sc_pkcs15emu_sc_hsm_add_prkd(p15card, filelist[i + 1]);
			break;
		case DCOD_PREFIX:
			r = sc_pkcs15emu_sc_hsm_add_dcod(p15card, filelist[i + 1]);
			break;
		case CD_PREFIX:
			r = sc_pkcs15emu_sc_hsm_add_cd(p15card, filelist[i + 1]);
			break;
		}
		if (r != SC_SUCCESS) {
			sc_log(card->ctx, ""Error %d adding elements to framework"", r);
		}
	}

	LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);
}
","static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)
{
	sc_card_t *card = p15card->card;
	sc_hsm_private_data_t *priv = (sc_hsm_private_data_t *) card->drv_data;
	sc_file_t *file = NULL;
	sc_path_t path;
	u8 filelist[MAX_EXT_APDU_LENGTH];
	int filelistlength;
	int r, i;
	sc_cvc_t devcert;
	struct sc_app_info *appinfo;
	struct sc_pkcs15_auth_info pin_info;
	struct sc_pkcs15_object pin_obj;
	struct sc_pin_cmd_data pindata;
	u8 efbin[1024];
	u8 *ptr;
	size_t len;

	LOG_FUNC_CALLED(card->ctx);

	appinfo = calloc(1, sizeof(struct sc_app_info));

	if (appinfo == NULL) {
		LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
	}

	appinfo->aid = sc_hsm_aid;

	appinfo->ddo.aid = sc_hsm_aid;
	p15card->app = appinfo;

	sc_path_set(&path, SC_PATH_TYPE_DF_NAME, sc_hsm_aid.value, sc_hsm_aid.len, 0, 0);
	r = sc_select_file(card, &path, &file);
	LOG_TEST_RET(card->ctx, r, ""Could not select SmartCard-HSM application"");

	p15card->card->version.hw_major = 24;	/* JCOP 2.4.1r3 */
	p15card->card->version.hw_minor = 13;
	if (file && file->prop_attr && file->prop_attr_len >= 2) {
		p15card->card->version.fw_major = file->prop_attr[file->prop_attr_len - 2];
		p15card->card->version.fw_minor = file->prop_attr[file->prop_attr_len - 1];
	}

	sc_file_free(file);

	/* Read device certificate to determine serial number */
	if (priv->EF_C_DevAut && priv->EF_C_DevAut_len) {
		ptr = priv->EF_C_DevAut;
		len = priv->EF_C_DevAut_len;
	} else {
		len = sizeof efbin;
 		r = read_file(p15card, (u8 *) ""\x2F\x02"", efbin, &len, 1);
 		LOG_TEST_RET(card->ctx, r, ""Skipping optional EF.C_DevAut"");
 
		/* save EF_C_DevAut for further use */
		ptr = realloc(priv->EF_C_DevAut, len);
		if (ptr) {
			memcpy(ptr, efbin, len);
			priv->EF_C_DevAut = ptr;
			priv->EF_C_DevAut_len = len;
 		}
 
 		ptr = efbin;
	}

	memset(&devcert, 0 ,sizeof(devcert));
	r = sc_pkcs15emu_sc_hsm_decode_cvc(p15card, (const u8 **)&ptr, &len, &devcert);
	LOG_TEST_RET(card->ctx, r, ""Could not decode EF.C_DevAut"");

	sc_pkcs15emu_sc_hsm_read_tokeninfo(p15card);

	if (p15card->tokeninfo->label == NULL) {
		if (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID
				|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {
			p15card->tokeninfo->label = strdup(""GoID"");
		} else {
			p15card->tokeninfo->label = strdup(""SmartCard-HSM"");
		}
		if (p15card->tokeninfo->label == NULL)
			LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
	}

	if ((p15card->tokeninfo->manufacturer_id != NULL) && !strcmp(""(unknown)"", p15card->tokeninfo->manufacturer_id)) {
		free(p15card->tokeninfo->manufacturer_id);
		p15card->tokeninfo->manufacturer_id = NULL;
	}

	if (p15card->tokeninfo->manufacturer_id == NULL) {
		if (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID
				|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {
			p15card->tokeninfo->manufacturer_id = strdup(""Bundesdruckerei GmbH"");
		} else {
			p15card->tokeninfo->manufacturer_id = strdup(""www.CardContact.de"");
		}
		if (p15card->tokeninfo->manufacturer_id == NULL)
			LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
	}

	appinfo->label = strdup(p15card->tokeninfo->label);
	if (appinfo->label == NULL)
		LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);

	len = strnlen(devcert.chr, sizeof devcert.chr);		/* Strip last 5 digit sequence number from CHR */
	assert(len >= 8);
	len -= 5;

	p15card->tokeninfo->serial_number = calloc(len + 1, 1);
	if (p15card->tokeninfo->serial_number == NULL)
		LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);

	memcpy(p15card->tokeninfo->serial_number, devcert.chr, len);
	*(p15card->tokeninfo->serial_number + len) = 0;

	sc_hsm_set_serialnr(card, p15card->tokeninfo->serial_number);

	sc_pkcs15emu_sc_hsm_free_cvc(&devcert);

	memset(&pin_info, 0, sizeof(pin_info));
	memset(&pin_obj, 0, sizeof(pin_obj));

	pin_info.auth_id.len = 1;
	pin_info.auth_id.value[0] = 1;
	pin_info.path.aid = sc_hsm_aid;
	pin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;
	pin_info.attrs.pin.reference = 0x81;
	pin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_EXCHANGE_REF_DATA;
	pin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;
	pin_info.attrs.pin.min_length = 6;
	pin_info.attrs.pin.stored_length = 0;
	pin_info.attrs.pin.max_length = 15;
	pin_info.attrs.pin.pad_char = '\0';
	pin_info.tries_left = 3;
	pin_info.max_tries = 3;

	pin_obj.auth_id.len = 1;
	pin_obj.auth_id.value[0] = 2;
	strlcpy(pin_obj.label, ""UserPIN"", sizeof(pin_obj.label));
	pin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE|SC_PKCS15_CO_FLAG_MODIFIABLE;

	r = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);
	if (r < 0)
		LOG_FUNC_RETURN(card->ctx, r);

	memset(&pin_info, 0, sizeof(pin_info));
	memset(&pin_obj, 0, sizeof(pin_obj));

	pin_info.auth_id.len = 1;
	pin_info.auth_id.value[0] = 2;
	pin_info.path.aid = sc_hsm_aid;
	pin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;
	pin_info.attrs.pin.reference = 0x88;
	pin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_UNBLOCK_DISABLED|SC_PKCS15_PIN_FLAG_SO_PIN;
	pin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_BCD;
	pin_info.attrs.pin.min_length = 16;
	pin_info.attrs.pin.stored_length = 0;
	pin_info.attrs.pin.max_length = 16;
	pin_info.attrs.pin.pad_char = '\0';
	pin_info.tries_left = 15;
	pin_info.max_tries = 15;

	strlcpy(pin_obj.label, ""SOPIN"", sizeof(pin_obj.label));
	pin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;

	r = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);
	if (r < 0)
		LOG_FUNC_RETURN(card->ctx, r);


	if (card->type == SC_CARD_TYPE_SC_HSM_SOC
			|| card->type == SC_CARD_TYPE_SC_HSM_GOID) {
		/* SC-HSM of this type always has a PIN-Pad */
		r = SC_SUCCESS;
	} else {
		memset(&pindata, 0, sizeof(pindata));
		pindata.cmd = SC_PIN_CMD_GET_INFO;
		pindata.pin_type = SC_AC_CHV;
		pindata.pin_reference = 0x85;

		r = sc_pin_cmd(card, &pindata, NULL);
	}
	if (r == SC_ERROR_DATA_OBJECT_NOT_FOUND) {
		memset(&pindata, 0, sizeof(pindata));
		pindata.cmd = SC_PIN_CMD_GET_INFO;
		pindata.pin_type = SC_AC_CHV;
		pindata.pin_reference = 0x86;

		r = sc_pin_cmd(card, &pindata, NULL);
	}

	if ((r != SC_ERROR_DATA_OBJECT_NOT_FOUND) && (r != SC_ERROR_INCORRECT_PARAMETERS))
		card->caps |= SC_CARD_CAP_PROTECTED_AUTHENTICATION_PATH;


	filelistlength = sc_list_files(card, filelist, sizeof(filelist));
	LOG_TEST_RET(card->ctx, filelistlength, ""Could not enumerate file and key identifier"");

	for (i = 0; i < filelistlength; i += 2) {
		switch(filelist[i]) {
		case KEY_PREFIX:
			r = sc_pkcs15emu_sc_hsm_add_prkd(p15card, filelist[i + 1]);
			break;
		case DCOD_PREFIX:
			r = sc_pkcs15emu_sc_hsm_add_dcod(p15card, filelist[i + 1]);
			break;
		case CD_PREFIX:
			r = sc_pkcs15emu_sc_hsm_add_cd(p15card, filelist[i + 1]);
			break;
		}
		if (r != SC_SUCCESS) {
			sc_log(card->ctx, ""Error %d adding elements to framework"", r);
		}
	}

	LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);
}
",C,"		if (len > 0) {
			/* save EF_C_DevAut for further use */
			ptr = realloc(priv->EF_C_DevAut, len);
			if (ptr) {
				memcpy(ptr, efbin, len);
				priv->EF_C_DevAut = ptr;
				priv->EF_C_DevAut_len = len;
			}
","		/* save EF_C_DevAut for further use */
		ptr = realloc(priv->EF_C_DevAut, len);
		if (ptr) {
			memcpy(ptr, efbin, len);
			priv->EF_C_DevAut = ptr;
			priv->EF_C_DevAut_len = len;
",,"@@ -837,12 +837,14 @@ static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)
 		r = read_file(p15card, (u8 *) ""\x2F\x02"", efbin, &len, 1);
 		LOG_TEST_RET(card->ctx, r, ""Skipping optional EF.C_DevAut"");
 
-		/* save EF_C_DevAut for further use */
-		ptr = realloc(priv->EF_C_DevAut, len);
-		if (ptr) {
-			memcpy(ptr, efbin, len);
-			priv->EF_C_DevAut = ptr;
-			priv->EF_C_DevAut_len = len;
+		if (len > 0) {
+			/* save EF_C_DevAut for further use */
+			ptr = realloc(priv->EF_C_DevAut, len);
+			if (ptr) {
+				memcpy(ptr, efbin, len);
+				priv->EF_C_DevAut = ptr;
+				priv->EF_C_DevAut_len = len;
+			}
 		}
 
 		ptr = efbin;",OpenSC,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,8fe377e93b4b56060e5bbfb6f3142ceaeca744fa,1,"static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)
{
	sc_card_t *card = p15card->card;
	sc_hsm_private_data_t *priv = (sc_hsm_private_data_t *) card->drv_data;
	sc_file_t *file = NULL;
	sc_path_t path;
	u8 filelist[MAX_EXT_APDU_LENGTH];
	int filelistlength;
	int r, i;
	sc_cvc_t devcert;
	struct sc_app_info *appinfo;
	struct sc_pkcs15_auth_info pin_info;
	struct sc_pkcs15_object pin_obj;
	struct sc_pin_cmd_data pindata;
	u8 efbin[1024];
	u8 *ptr;
	size_t len;

	LOG_FUNC_CALLED(card->ctx);

	appinfo = calloc(1, sizeof(struct sc_app_info));

	if (appinfo == NULL) {
		LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
	}

	appinfo->aid = sc_hsm_aid;

	appinfo->ddo.aid = sc_hsm_aid;
	p15card->app = appinfo;

	sc_path_set(&path, SC_PATH_TYPE_DF_NAME, sc_hsm_aid.value, sc_hsm_aid.len, 0, 0);
	r = sc_select_file(card, &path, &file);
	LOG_TEST_RET(card->ctx, r, ""Could not select SmartCard-HSM application"");

	p15card->card->version.hw_major = 24;	/* JCOP 2.4.1r3 */
	p15card->card->version.hw_minor = 13;
	if (file && file->prop_attr && file->prop_attr_len >= 2) {
		p15card->card->version.fw_major = file->prop_attr[file->prop_attr_len - 2];
		p15card->card->version.fw_minor = file->prop_attr[file->prop_attr_len - 1];
	}

	sc_file_free(file);

	/* Read device certificate to determine serial number */
	if (priv->EF_C_DevAut && priv->EF_C_DevAut_len) {
		ptr = priv->EF_C_DevAut;
		len = priv->EF_C_DevAut_len;
	} else {
		len = sizeof efbin;
 		r = read_file(p15card, (u8 *) ""\x2F\x02"", efbin, &len, 1);
 		LOG_TEST_RET(card->ctx, r, ""Skipping optional EF.C_DevAut"");
 
//flaw_line_below:
		/* save EF_C_DevAut for further use */
//flaw_line_below:
		ptr = realloc(priv->EF_C_DevAut, len);
//flaw_line_below:
		if (ptr) {
//flaw_line_below:
			memcpy(ptr, efbin, len);
//flaw_line_below:
			priv->EF_C_DevAut = ptr;
//flaw_line_below:
			priv->EF_C_DevAut_len = len;
//fix_flaw_line_below:
//		if (len > 0) {
//fix_flaw_line_below:
//			/* save EF_C_DevAut for further use */
//fix_flaw_line_below:
//			ptr = realloc(priv->EF_C_DevAut, len);
//fix_flaw_line_below:
//			if (ptr) {
//fix_flaw_line_below:
//				memcpy(ptr, efbin, len);
//fix_flaw_line_below:
//				priv->EF_C_DevAut = ptr;
//fix_flaw_line_below:
//				priv->EF_C_DevAut_len = len;
//fix_flaw_line_below:
//			}
 		}
 
 		ptr = efbin;
	}

	memset(&devcert, 0 ,sizeof(devcert));
	r = sc_pkcs15emu_sc_hsm_decode_cvc(p15card, (const u8 **)&ptr, &len, &devcert);
	LOG_TEST_RET(card->ctx, r, ""Could not decode EF.C_DevAut"");

	sc_pkcs15emu_sc_hsm_read_tokeninfo(p15card);

	if (p15card->tokeninfo->label == NULL) {
		if (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID
				|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {
			p15card->tokeninfo->label = strdup(""GoID"");
		} else {
			p15card->tokeninfo->label = strdup(""SmartCard-HSM"");
		}
		if (p15card->tokeninfo->label == NULL)
			LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
	}

	if ((p15card->tokeninfo->manufacturer_id != NULL) && !strcmp(""(unknown)"", p15card->tokeninfo->manufacturer_id)) {
		free(p15card->tokeninfo->manufacturer_id);
		p15card->tokeninfo->manufacturer_id = NULL;
	}

	if (p15card->tokeninfo->manufacturer_id == NULL) {
		if (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID
				|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {
			p15card->tokeninfo->manufacturer_id = strdup(""Bundesdruckerei GmbH"");
		} else {
			p15card->tokeninfo->manufacturer_id = strdup(""www.CardContact.de"");
		}
		if (p15card->tokeninfo->manufacturer_id == NULL)
			LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
	}

	appinfo->label = strdup(p15card->tokeninfo->label);
	if (appinfo->label == NULL)
		LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);

	len = strnlen(devcert.chr, sizeof devcert.chr);		/* Strip last 5 digit sequence number from CHR */
	assert(len >= 8);
	len -= 5;

	p15card->tokeninfo->serial_number = calloc(len + 1, 1);
	if (p15card->tokeninfo->serial_number == NULL)
		LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);

	memcpy(p15card->tokeninfo->serial_number, devcert.chr, len);
	*(p15card->tokeninfo->serial_number + len) = 0;

	sc_hsm_set_serialnr(card, p15card->tokeninfo->serial_number);

	sc_pkcs15emu_sc_hsm_free_cvc(&devcert);

	memset(&pin_info, 0, sizeof(pin_info));
	memset(&pin_obj, 0, sizeof(pin_obj));

	pin_info.auth_id.len = 1;
	pin_info.auth_id.value[0] = 1;
	pin_info.path.aid = sc_hsm_aid;
	pin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;
	pin_info.attrs.pin.reference = 0x81;
	pin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_EXCHANGE_REF_DATA;
	pin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;
	pin_info.attrs.pin.min_length = 6;
	pin_info.attrs.pin.stored_length = 0;
	pin_info.attrs.pin.max_length = 15;
	pin_info.attrs.pin.pad_char = '\0';
	pin_info.tries_left = 3;
	pin_info.max_tries = 3;

	pin_obj.auth_id.len = 1;
	pin_obj.auth_id.value[0] = 2;
	strlcpy(pin_obj.label, ""UserPIN"", sizeof(pin_obj.label));
	pin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE|SC_PKCS15_CO_FLAG_MODIFIABLE;

	r = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);
	if (r < 0)
		LOG_FUNC_RETURN(card->ctx, r);

	memset(&pin_info, 0, sizeof(pin_info));
	memset(&pin_obj, 0, sizeof(pin_obj));

	pin_info.auth_id.len = 1;
	pin_info.auth_id.value[0] = 2;
	pin_info.path.aid = sc_hsm_aid;
	pin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;
	pin_info.attrs.pin.reference = 0x88;
	pin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_UNBLOCK_DISABLED|SC_PKCS15_PIN_FLAG_SO_PIN;
	pin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_BCD;
	pin_info.attrs.pin.min_length = 16;
	pin_info.attrs.pin.stored_length = 0;
	pin_info.attrs.pin.max_length = 16;
	pin_info.attrs.pin.pad_char = '\0';
	pin_info.tries_left = 15;
	pin_info.max_tries = 15;

	strlcpy(pin_obj.label, ""SOPIN"", sizeof(pin_obj.label));
	pin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;

	r = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);
	if (r < 0)
		LOG_FUNC_RETURN(card->ctx, r);


	if (card->type == SC_CARD_TYPE_SC_HSM_SOC
			|| card->type == SC_CARD_TYPE_SC_HSM_GOID) {
		/* SC-HSM of this type always has a PIN-Pad */
		r = SC_SUCCESS;
	} else {
		memset(&pindata, 0, sizeof(pindata));
		pindata.cmd = SC_PIN_CMD_GET_INFO;
		pindata.pin_type = SC_AC_CHV;
		pindata.pin_reference = 0x85;

		r = sc_pin_cmd(card, &pindata, NULL);
	}
	if (r == SC_ERROR_DATA_OBJECT_NOT_FOUND) {
		memset(&pindata, 0, sizeof(pindata));
		pindata.cmd = SC_PIN_CMD_GET_INFO;
		pindata.pin_type = SC_AC_CHV;
		pindata.pin_reference = 0x86;

		r = sc_pin_cmd(card, &pindata, NULL);
	}

	if ((r != SC_ERROR_DATA_OBJECT_NOT_FOUND) && (r != SC_ERROR_INCORRECT_PARAMETERS))
		card->caps |= SC_CARD_CAP_PROTECTED_AUTHENTICATION_PATH;


	filelistlength = sc_list_files(card, filelist, sizeof(filelist));
	LOG_TEST_RET(card->ctx, filelistlength, ""Could not enumerate file and key identifier"");

	for (i = 0; i < filelistlength; i += 2) {
		switch(filelist[i]) {
		case KEY_PREFIX:
			r = sc_pkcs15emu_sc_hsm_add_prkd(p15card, filelist[i + 1]);
			break;
		case DCOD_PREFIX:
			r = sc_pkcs15emu_sc_hsm_add_dcod(p15card, filelist[i + 1]);
			break;
		case CD_PREFIX:
			r = sc_pkcs15emu_sc_hsm_add_cd(p15card, filelist[i + 1]);
			break;
		}
		if (r != SC_SUCCESS) {
			sc_log(card->ctx, ""Error %d adding elements to framework"", r);
		}
	}

	LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);
}
"
4515,182251,,Local,Not required,Partial,CVE-2018-16425,https://www.cvedetails.com/cve/CVE-2018-16425/,CWE-415,Low,Partial,Partial,,2018-09-03,4.6,A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,2019-09-11,DoS ,1,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,"fixed out of bounds writes

Thanks to Eric Sesterhenn from X41 D-SEC GmbH
for reporting the problems.",1,src/libopensc/sc.c,"{""sha"": ""756788a0fbbbed8487e8cf33b6115bb4d4f58860"", ""filename"": ""src/libopensc/card-cac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-cac.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -794,7 +794,7 @@ static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri\n         }\n \tif (priv->cac_id_len) {\n \t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n-\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n+\t\tmemcpy(serial->value, priv->cac_id, serial->len);\n \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n \t}\n \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);""}<_**next**_>{""sha"": ""65a58f6740d38e6fd6204cbacb5015995067334f"", ""filename"": ""src/libopensc/card-epass2003.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-epass2003.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -951,7 +951,7 @@ decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned\n \twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n \t\tcipher_len--;\n \n-\tif (2 == cipher_len)\n+\tif (2 == cipher_len || *out_len < cipher_len - 2)\n \t\treturn -1;\n \n \tmemcpy(out, plaintext, cipher_len - 2);\n@@ -977,6 +977,7 @@ epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apd\n \tr = sc_check_sw(card, sm->sw1, sm->sw2);\n \tif (r == SC_SUCCESS) {\n \t\tif (exdata->sm) {\n+\t\t\tlen = plain->resplen;\n \t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n \t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n \t\t}""}<_**next**_>{""sha"": ""d247efabc9fd2d7978e4a24dc42bcaccd42f3bee"", ""filename"": ""src/libopensc/card-muscle.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-muscle.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -518,7 +518,9 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \tmscfs_check_cache(priv->fs);\n \n \tfor(x = 0; x < fs->cache.size; x++) {\n-\t\tu8* oid= fs->cache.array[x].objectId.id;\n+\t\tu8* oid = fs->cache.array[x].objectId.id;\n+\t\tif (bufLen < 2)\n+\t\t\tbreak;\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n \t\t\t\""FILE: %02X%02X%02X%02X\\n\"",\n \t\t\toid[0],oid[1],oid[2],oid[3]);\n@@ -527,7 +529,8 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \t\t\tbuf[1] = oid[3];\n \t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n \t\t\tbuf += 2;\n-\t\t\tcount+=2;\n+\t\t\tcount += 2;\n+\t\t\tbufLen -= 2;\n \t\t}\n \t}\n \treturn count;""}<_**next**_>{""sha"": ""3c86b1f4838a5837341ae9cfc9b7fdb5334fe138"", ""filename"": ""src/libopensc/card-tcos.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-tcos.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -408,7 +408,7 @@ static int tcos_select_file(sc_card_t *card,\n \tfile->path = *in_path;\n \n \tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n-\t\tint j, len=apdu.resp[i+1];\n+\t\tsize_t j, len=apdu.resp[i+1];\n \t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n \n \t\tswitch (type) {\n@@ -432,8 +432,8 @@ static int tcos_select_file(sc_card_t *card,\n \t\t\tfile->id = (d[0]<<8) | d[1];\n \t\t\tbreak;\n \t\tcase 0x84:\n-\t\t\tmemcpy(file->name, d, len);\n-\t\t\tfile->namelen = len;\n+\t\t\tfile->namelen = MIN(sizeof file->name, len);\n+\t\t\tmemcpy(file->name, d, file->namelen);\n \t\t\tbreak;\n \t\tcase 0x86:\n \t\t\tsc_file_set_sec_attr(file, d, len); ""}<_**next**_>{""sha"": ""2b8d66b913b0d3ce3c92c0578c43ae847f98d2c7"", ""filename"": ""src/libopensc/pkcs15-esteid.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-esteid.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -79,7 +79,7 @@ sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n \t/* read the serial (document number) */\n \tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \""read document number failed\"");\n-\tbuff[r] = '\\0';\n+\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n \tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n \n \tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION""}<_**next**_>{""sha"": ""3b220f7a5b37ea236b58ef543d01ca08c815b826"", ""filename"": ""src/libopensc/pkcs15-gemsafeV1.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-gemsafeV1.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -208,7 +208,7 @@ static int gemsafe_get_cert_len(sc_card_t *card)\n \t * the private key.\n \t */\n \tind = 2; /* skip length */\n-\twhile (ibuf[ind] == 0x01) {\n+\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n \t\tif (ibuf[ind+1] == 0xFE) {\n \t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n \t\t\tsc_log(card->ctx, \""Key container %d is allocated and uses key_ref %d\"",""}<_**next**_>{""sha"": ""1391bea15370cd020dfdf1cfb0d9c24db950a0c4"", ""filename"": ""src/libopensc/pkcs15-sc-hsm.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-sc-hsm.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -837,12 +837,14 @@ static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n \t\tr = read_file(p15card, (u8 *) \""\\x2F\\x02\"", efbin, &len, 1);\n \t\tLOG_TEST_RET(card->ctx, r, \""Skipping optional EF.C_DevAut\"");\n \n-\t\t/* save EF_C_DevAut for further use */\n-\t\tptr = realloc(priv->EF_C_DevAut, len);\n-\t\tif (ptr) {\n-\t\t\tmemcpy(ptr, efbin, len);\n-\t\t\tpriv->EF_C_DevAut = ptr;\n-\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\tif (len > 0) {\n+\t\t\t/* save EF_C_DevAut for further use */\n+\t\t\tptr = realloc(priv->EF_C_DevAut, len);\n+\t\t\tif (ptr) {\n+\t\t\t\tmemcpy(ptr, efbin, len);\n+\t\t\t\tpriv->EF_C_DevAut = ptr;\n+\t\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\t\t}\n \t\t}\n \n \t\tptr = efbin;""}<_**next**_>{""sha"": ""53fefb3e68eac554ed608a5a960cf3dd5f5b8dcb"", ""filename"": ""src/libopensc/sc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/sc.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -628,7 +628,7 @@ int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n \t\treturn SC_ERROR_INVALID_ARGUMENTS;\n \t}\n \n-\tif (sec_attr == NULL) {\n+\tif (sec_attr == NULL || sec_attr_len) {\n \t\tif (file->sec_attr != NULL)\n \t\t\tfree(file->sec_attr);\n \t\tfile->sec_attr = NULL;""}<_**next**_>{""sha"": ""662a028222a909f431f31c60bc421fa83d86d5b6"", ""filename"": ""src/tools/cryptoflex-tool.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/cryptoflex-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -21,6 +21,7 @@\n #include \""config.h\""\n \n #include \""libopensc/sc-ossl-compat.h\""\n+#include \""libopensc/internal.h\""\n #include <openssl/bn.h>\n #include <openssl/rsa.h>\n #include <openssl/x509.h>\n@@ -331,7 +332,7 @@ static int read_public_key(RSA *rsa)\n \t\tfprintf(stderr, \""Unable to select public key file: %s\\n\"", sc_strerror(r));\n \t\treturn 2;\n \t}\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {\n@@ -382,7 +383,7 @@ static int read_private_key(RSA *rsa)\n \te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n \tif (e == NULL || e->method == SC_AC_NEVER)\n \t\treturn 10;\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {""}<_**next**_>{""sha"": ""31360833b5284915ae8d93babeb3fdb1b279a0f3"", ""filename"": ""src/tools/egk-tool.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/egk-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -149,7 +149,7 @@ int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t\n \t\tgoto err;\n \t}\n \n-\tlen = file ? file->size : 4096;\n+\tlen = file && file->size > 0 ? file->size : 4096;\n \tp = realloc(*data, len);\n \tif (!p) {\n \t\tgoto err;""}<_**next**_>{""sha"": ""e49647a472e921663b2952ef5cf213c9fc974beb"", ""filename"": ""src/tools/util.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/util.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -339,10 +339,11 @@ const char * util_acl_to_str(const sc_acl_entry_t *e)\n \t\t\tstrcpy(buf, \""????\"");\n \t\t\tbreak;\n \t\t}\n-\t\tstrcat(line, buf);\n-\t\tstrcat(line, \"" \"");\n+\t\tstrncat(line, buf, sizeof line);\n+\t\tstrncat(line, \"" \"", sizeof line);\n \t\te = e->next;\n \t}\n+\tline[(sizeof line)-1] = '\\0'; /* make sure it's NUL terminated */\n \tline[strlen(line)-1] = 0; /* get rid of trailing space */\n \treturn line;\n }""}","int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,
			 size_t sec_attr_len)
{
	u8 *tmp;
	if (!sc_file_valid(file)) {
 		return SC_ERROR_INVALID_ARGUMENTS;
 	}
 
	if (sec_attr == NULL || sec_attr_len) {
 		if (file->sec_attr != NULL)
 			free(file->sec_attr);
 		file->sec_attr = NULL;
		file->sec_attr_len = 0;
		return 0;
	 }
	tmp = (u8 *) realloc(file->sec_attr, sec_attr_len);
	if (!tmp) {
		if (file->sec_attr)
			free(file->sec_attr);
		file->sec_attr     = NULL;
		file->sec_attr_len = 0;
		return SC_ERROR_OUT_OF_MEMORY;
	}
	file->sec_attr = tmp;
	memcpy(file->sec_attr, sec_attr, sec_attr_len);
	file->sec_attr_len = sec_attr_len;

	return 0;
}
","int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,
			 size_t sec_attr_len)
{
	u8 *tmp;
	if (!sc_file_valid(file)) {
 		return SC_ERROR_INVALID_ARGUMENTS;
 	}
 
	if (sec_attr == NULL) {
 		if (file->sec_attr != NULL)
 			free(file->sec_attr);
 		file->sec_attr = NULL;
		file->sec_attr_len = 0;
		return 0;
	 }
	tmp = (u8 *) realloc(file->sec_attr, sec_attr_len);
	if (!tmp) {
		if (file->sec_attr)
			free(file->sec_attr);
		file->sec_attr     = NULL;
		file->sec_attr_len = 0;
		return SC_ERROR_OUT_OF_MEMORY;
	}
	file->sec_attr = tmp;
	memcpy(file->sec_attr, sec_attr, sec_attr_len);
	file->sec_attr_len = sec_attr_len;

	return 0;
}
",C,"	if (sec_attr == NULL || sec_attr_len) {
","	if (sec_attr == NULL) {
",,"@@ -628,7 +628,7 @@ int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,
 		return SC_ERROR_INVALID_ARGUMENTS;
 	}
 
-	if (sec_attr == NULL) {
+	if (sec_attr == NULL || sec_attr_len) {
 		if (file->sec_attr != NULL)
 			free(file->sec_attr);
 		file->sec_attr = NULL;",OpenSC,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,8fe377e93b4b56060e5bbfb6f3142ceaeca744fa,1,"int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,
			 size_t sec_attr_len)
{
	u8 *tmp;
	if (!sc_file_valid(file)) {
 		return SC_ERROR_INVALID_ARGUMENTS;
 	}
 
//flaw_line_below:
	if (sec_attr == NULL) {
//fix_flaw_line_below:
//	if (sec_attr == NULL || sec_attr_len) {
 		if (file->sec_attr != NULL)
 			free(file->sec_attr);
 		file->sec_attr = NULL;
		file->sec_attr_len = 0;
		return 0;
	 }
	tmp = (u8 *) realloc(file->sec_attr, sec_attr_len);
	if (!tmp) {
		if (file->sec_attr)
			free(file->sec_attr);
		file->sec_attr     = NULL;
		file->sec_attr_len = 0;
		return SC_ERROR_OUT_OF_MEMORY;
	}
	file->sec_attr = tmp;
	memcpy(file->sec_attr, sec_attr, sec_attr_len);
	file->sec_attr_len = sec_attr_len;

	return 0;
}
"
4516,182252,,Local,Not required,Partial,CVE-2018-16425,https://www.cvedetails.com/cve/CVE-2018-16425/,CWE-415,Low,Partial,Partial,,2018-09-03,4.6,A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,2019-09-11,DoS ,1,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,"fixed out of bounds writes

Thanks to Eric Sesterhenn from X41 D-SEC GmbH
for reporting the problems.",1,src/tools/cryptoflex-tool.c,"{""sha"": ""756788a0fbbbed8487e8cf33b6115bb4d4f58860"", ""filename"": ""src/libopensc/card-cac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-cac.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -794,7 +794,7 @@ static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri\n         }\n \tif (priv->cac_id_len) {\n \t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n-\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n+\t\tmemcpy(serial->value, priv->cac_id, serial->len);\n \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n \t}\n \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);""}<_**next**_>{""sha"": ""65a58f6740d38e6fd6204cbacb5015995067334f"", ""filename"": ""src/libopensc/card-epass2003.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-epass2003.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -951,7 +951,7 @@ decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned\n \twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n \t\tcipher_len--;\n \n-\tif (2 == cipher_len)\n+\tif (2 == cipher_len || *out_len < cipher_len - 2)\n \t\treturn -1;\n \n \tmemcpy(out, plaintext, cipher_len - 2);\n@@ -977,6 +977,7 @@ epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apd\n \tr = sc_check_sw(card, sm->sw1, sm->sw2);\n \tif (r == SC_SUCCESS) {\n \t\tif (exdata->sm) {\n+\t\t\tlen = plain->resplen;\n \t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n \t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n \t\t}""}<_**next**_>{""sha"": ""d247efabc9fd2d7978e4a24dc42bcaccd42f3bee"", ""filename"": ""src/libopensc/card-muscle.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-muscle.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -518,7 +518,9 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \tmscfs_check_cache(priv->fs);\n \n \tfor(x = 0; x < fs->cache.size; x++) {\n-\t\tu8* oid= fs->cache.array[x].objectId.id;\n+\t\tu8* oid = fs->cache.array[x].objectId.id;\n+\t\tif (bufLen < 2)\n+\t\t\tbreak;\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n \t\t\t\""FILE: %02X%02X%02X%02X\\n\"",\n \t\t\toid[0],oid[1],oid[2],oid[3]);\n@@ -527,7 +529,8 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \t\t\tbuf[1] = oid[3];\n \t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n \t\t\tbuf += 2;\n-\t\t\tcount+=2;\n+\t\t\tcount += 2;\n+\t\t\tbufLen -= 2;\n \t\t}\n \t}\n \treturn count;""}<_**next**_>{""sha"": ""3c86b1f4838a5837341ae9cfc9b7fdb5334fe138"", ""filename"": ""src/libopensc/card-tcos.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-tcos.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -408,7 +408,7 @@ static int tcos_select_file(sc_card_t *card,\n \tfile->path = *in_path;\n \n \tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n-\t\tint j, len=apdu.resp[i+1];\n+\t\tsize_t j, len=apdu.resp[i+1];\n \t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n \n \t\tswitch (type) {\n@@ -432,8 +432,8 @@ static int tcos_select_file(sc_card_t *card,\n \t\t\tfile->id = (d[0]<<8) | d[1];\n \t\t\tbreak;\n \t\tcase 0x84:\n-\t\t\tmemcpy(file->name, d, len);\n-\t\t\tfile->namelen = len;\n+\t\t\tfile->namelen = MIN(sizeof file->name, len);\n+\t\t\tmemcpy(file->name, d, file->namelen);\n \t\t\tbreak;\n \t\tcase 0x86:\n \t\t\tsc_file_set_sec_attr(file, d, len); ""}<_**next**_>{""sha"": ""2b8d66b913b0d3ce3c92c0578c43ae847f98d2c7"", ""filename"": ""src/libopensc/pkcs15-esteid.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-esteid.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -79,7 +79,7 @@ sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n \t/* read the serial (document number) */\n \tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \""read document number failed\"");\n-\tbuff[r] = '\\0';\n+\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n \tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n \n \tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION""}<_**next**_>{""sha"": ""3b220f7a5b37ea236b58ef543d01ca08c815b826"", ""filename"": ""src/libopensc/pkcs15-gemsafeV1.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-gemsafeV1.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -208,7 +208,7 @@ static int gemsafe_get_cert_len(sc_card_t *card)\n \t * the private key.\n \t */\n \tind = 2; /* skip length */\n-\twhile (ibuf[ind] == 0x01) {\n+\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n \t\tif (ibuf[ind+1] == 0xFE) {\n \t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n \t\t\tsc_log(card->ctx, \""Key container %d is allocated and uses key_ref %d\"",""}<_**next**_>{""sha"": ""1391bea15370cd020dfdf1cfb0d9c24db950a0c4"", ""filename"": ""src/libopensc/pkcs15-sc-hsm.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-sc-hsm.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -837,12 +837,14 @@ static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n \t\tr = read_file(p15card, (u8 *) \""\\x2F\\x02\"", efbin, &len, 1);\n \t\tLOG_TEST_RET(card->ctx, r, \""Skipping optional EF.C_DevAut\"");\n \n-\t\t/* save EF_C_DevAut for further use */\n-\t\tptr = realloc(priv->EF_C_DevAut, len);\n-\t\tif (ptr) {\n-\t\t\tmemcpy(ptr, efbin, len);\n-\t\t\tpriv->EF_C_DevAut = ptr;\n-\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\tif (len > 0) {\n+\t\t\t/* save EF_C_DevAut for further use */\n+\t\t\tptr = realloc(priv->EF_C_DevAut, len);\n+\t\t\tif (ptr) {\n+\t\t\t\tmemcpy(ptr, efbin, len);\n+\t\t\t\tpriv->EF_C_DevAut = ptr;\n+\t\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\t\t}\n \t\t}\n \n \t\tptr = efbin;""}<_**next**_>{""sha"": ""53fefb3e68eac554ed608a5a960cf3dd5f5b8dcb"", ""filename"": ""src/libopensc/sc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/sc.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -628,7 +628,7 @@ int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n \t\treturn SC_ERROR_INVALID_ARGUMENTS;\n \t}\n \n-\tif (sec_attr == NULL) {\n+\tif (sec_attr == NULL || sec_attr_len) {\n \t\tif (file->sec_attr != NULL)\n \t\t\tfree(file->sec_attr);\n \t\tfile->sec_attr = NULL;""}<_**next**_>{""sha"": ""662a028222a909f431f31c60bc421fa83d86d5b6"", ""filename"": ""src/tools/cryptoflex-tool.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/cryptoflex-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -21,6 +21,7 @@\n #include \""config.h\""\n \n #include \""libopensc/sc-ossl-compat.h\""\n+#include \""libopensc/internal.h\""\n #include <openssl/bn.h>\n #include <openssl/rsa.h>\n #include <openssl/x509.h>\n@@ -331,7 +332,7 @@ static int read_public_key(RSA *rsa)\n \t\tfprintf(stderr, \""Unable to select public key file: %s\\n\"", sc_strerror(r));\n \t\treturn 2;\n \t}\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {\n@@ -382,7 +383,7 @@ static int read_private_key(RSA *rsa)\n \te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n \tif (e == NULL || e->method == SC_AC_NEVER)\n \t\treturn 10;\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {""}<_**next**_>{""sha"": ""31360833b5284915ae8d93babeb3fdb1b279a0f3"", ""filename"": ""src/tools/egk-tool.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/egk-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -149,7 +149,7 @@ int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t\n \t\tgoto err;\n \t}\n \n-\tlen = file ? file->size : 4096;\n+\tlen = file && file->size > 0 ? file->size : 4096;\n \tp = realloc(*data, len);\n \tif (!p) {\n \t\tgoto err;""}<_**next**_>{""sha"": ""e49647a472e921663b2952ef5cf213c9fc974beb"", ""filename"": ""src/tools/util.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/util.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -339,10 +339,11 @@ const char * util_acl_to_str(const sc_acl_entry_t *e)\n \t\t\tstrcpy(buf, \""????\"");\n \t\t\tbreak;\n \t\t}\n-\t\tstrcat(line, buf);\n-\t\tstrcat(line, \"" \"");\n+\t\tstrncat(line, buf, sizeof line);\n+\t\tstrncat(line, \"" \"", sizeof line);\n \t\te = e->next;\n \t}\n+\tline[(sizeof line)-1] = '\\0'; /* make sure it's NUL terminated */\n \tline[strlen(line)-1] = 0; /* get rid of trailing space */\n \treturn line;\n }""}","static int read_private_key(RSA *rsa)
{
	int r;
	sc_path_t path;
	sc_file_t *file;
	const sc_acl_entry_t *e;

	u8 buf[2048], *p = buf;
	size_t bufsize, keysize;

	r = select_app_df();
	if (r)
		return 1;
	sc_format_path(""I0012"", &path);
	r = sc_select_file(card, &path, &file);
	if (r) {
		fprintf(stderr, ""Unable to select private key file: %s\n"", sc_strerror(r));
		return 2;
	}
 	e = sc_file_get_acl_entry(file, SC_AC_OP_READ);
 	if (e == NULL || e->method == SC_AC_NEVER)
 		return 10;
	bufsize = MIN(file->size, sizeof buf);
 	sc_file_free(file);
 	r = sc_read_binary(card, 0, buf, bufsize, 0);
 	if (r < 0) {
		fprintf(stderr, ""Unable to read private key file: %s\n"", sc_strerror(r));
		return 2;
	}
	bufsize = r;
	do {
		if (bufsize < 4)
			return 3;
		keysize = (p[0] << 8) | p[1];
		if (keysize == 0)
			break;
		if (keysize < 3)
			return 3;
		if (p[2] == opt_key_num)
			break;
		p += keysize;
		bufsize -= keysize;
	} while (1);
	if (keysize == 0) {
		printf(""Key number %d not found.\n"", opt_key_num);
		return 2;
	}
	return parse_private_key(p, keysize, rsa);
}
","static int read_private_key(RSA *rsa)
{
	int r;
	sc_path_t path;
	sc_file_t *file;
	const sc_acl_entry_t *e;

	u8 buf[2048], *p = buf;
	size_t bufsize, keysize;

	r = select_app_df();
	if (r)
		return 1;
	sc_format_path(""I0012"", &path);
	r = sc_select_file(card, &path, &file);
	if (r) {
		fprintf(stderr, ""Unable to select private key file: %s\n"", sc_strerror(r));
		return 2;
	}
 	e = sc_file_get_acl_entry(file, SC_AC_OP_READ);
 	if (e == NULL || e->method == SC_AC_NEVER)
 		return 10;
	bufsize = file->size;
 	sc_file_free(file);
 	r = sc_read_binary(card, 0, buf, bufsize, 0);
 	if (r < 0) {
		fprintf(stderr, ""Unable to read private key file: %s\n"", sc_strerror(r));
		return 2;
	}
	bufsize = r;
	do {
		if (bufsize < 4)
			return 3;
		keysize = (p[0] << 8) | p[1];
		if (keysize == 0)
			break;
		if (keysize < 3)
			return 3;
		if (p[2] == opt_key_num)
			break;
		p += keysize;
		bufsize -= keysize;
	} while (1);
	if (keysize == 0) {
		printf(""Key number %d not found.\n"", opt_key_num);
		return 2;
	}
	return parse_private_key(p, keysize, rsa);
}
",C,"	bufsize = MIN(file->size, sizeof buf);
","	bufsize = file->size;
",,"@@ -21,6 +21,7 @@
 #include ""config.h""
 
 #include ""libopensc/sc-ossl-compat.h""
+#include ""libopensc/internal.h""
 #include <openssl/bn.h>
 #include <openssl/rsa.h>
 #include <openssl/x509.h>
@@ -331,7 +332,7 @@ static int read_public_key(RSA *rsa)
 		fprintf(stderr, ""Unable to select public key file: %s\n"", sc_strerror(r));
 		return 2;
 	}
-	bufsize = file->size;
+	bufsize = MIN(file->size, sizeof buf);
 	sc_file_free(file);
 	r = sc_read_binary(card, 0, buf, bufsize, 0);
 	if (r < 0) {
@@ -382,7 +383,7 @@ static int read_private_key(RSA *rsa)
 	e = sc_file_get_acl_entry(file, SC_AC_OP_READ);
 	if (e == NULL || e->method == SC_AC_NEVER)
 		return 10;
-	bufsize = file->size;
+	bufsize = MIN(file->size, sizeof buf);
 	sc_file_free(file);
 	r = sc_read_binary(card, 0, buf, bufsize, 0);
 	if (r < 0) {",OpenSC,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,8fe377e93b4b56060e5bbfb6f3142ceaeca744fa,1,"static int read_private_key(RSA *rsa)
{
	int r;
	sc_path_t path;
	sc_file_t *file;
	const sc_acl_entry_t *e;

	u8 buf[2048], *p = buf;
	size_t bufsize, keysize;

	r = select_app_df();
	if (r)
		return 1;
	sc_format_path(""I0012"", &path);
	r = sc_select_file(card, &path, &file);
	if (r) {
		fprintf(stderr, ""Unable to select private key file: %s\n"", sc_strerror(r));
		return 2;
	}
 	e = sc_file_get_acl_entry(file, SC_AC_OP_READ);
 	if (e == NULL || e->method == SC_AC_NEVER)
 		return 10;
//flaw_line_below:
	bufsize = file->size;
//fix_flaw_line_below:
//	bufsize = MIN(file->size, sizeof buf);
 	sc_file_free(file);
 	r = sc_read_binary(card, 0, buf, bufsize, 0);
 	if (r < 0) {
		fprintf(stderr, ""Unable to read private key file: %s\n"", sc_strerror(r));
		return 2;
	}
	bufsize = r;
	do {
		if (bufsize < 4)
			return 3;
		keysize = (p[0] << 8) | p[1];
		if (keysize == 0)
			break;
		if (keysize < 3)
			return 3;
		if (p[2] == opt_key_num)
			break;
		p += keysize;
		bufsize -= keysize;
	} while (1);
	if (keysize == 0) {
		printf(""Key number %d not found.\n"", opt_key_num);
		return 2;
	}
	return parse_private_key(p, keysize, rsa);
}
"
4517,182253,,Local,Not required,Partial,CVE-2018-16425,https://www.cvedetails.com/cve/CVE-2018-16425/,CWE-415,Low,Partial,Partial,,2018-09-03,4.6,A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,2019-09-11,DoS ,1,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,"fixed out of bounds writes

Thanks to Eric Sesterhenn from X41 D-SEC GmbH
for reporting the problems.",1,src/tools/cryptoflex-tool.c,"{""sha"": ""756788a0fbbbed8487e8cf33b6115bb4d4f58860"", ""filename"": ""src/libopensc/card-cac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-cac.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -794,7 +794,7 @@ static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri\n         }\n \tif (priv->cac_id_len) {\n \t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n-\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n+\t\tmemcpy(serial->value, priv->cac_id, serial->len);\n \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n \t}\n \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);""}<_**next**_>{""sha"": ""65a58f6740d38e6fd6204cbacb5015995067334f"", ""filename"": ""src/libopensc/card-epass2003.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-epass2003.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -951,7 +951,7 @@ decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned\n \twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n \t\tcipher_len--;\n \n-\tif (2 == cipher_len)\n+\tif (2 == cipher_len || *out_len < cipher_len - 2)\n \t\treturn -1;\n \n \tmemcpy(out, plaintext, cipher_len - 2);\n@@ -977,6 +977,7 @@ epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apd\n \tr = sc_check_sw(card, sm->sw1, sm->sw2);\n \tif (r == SC_SUCCESS) {\n \t\tif (exdata->sm) {\n+\t\t\tlen = plain->resplen;\n \t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n \t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n \t\t}""}<_**next**_>{""sha"": ""d247efabc9fd2d7978e4a24dc42bcaccd42f3bee"", ""filename"": ""src/libopensc/card-muscle.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-muscle.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -518,7 +518,9 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \tmscfs_check_cache(priv->fs);\n \n \tfor(x = 0; x < fs->cache.size; x++) {\n-\t\tu8* oid= fs->cache.array[x].objectId.id;\n+\t\tu8* oid = fs->cache.array[x].objectId.id;\n+\t\tif (bufLen < 2)\n+\t\t\tbreak;\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n \t\t\t\""FILE: %02X%02X%02X%02X\\n\"",\n \t\t\toid[0],oid[1],oid[2],oid[3]);\n@@ -527,7 +529,8 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \t\t\tbuf[1] = oid[3];\n \t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n \t\t\tbuf += 2;\n-\t\t\tcount+=2;\n+\t\t\tcount += 2;\n+\t\t\tbufLen -= 2;\n \t\t}\n \t}\n \treturn count;""}<_**next**_>{""sha"": ""3c86b1f4838a5837341ae9cfc9b7fdb5334fe138"", ""filename"": ""src/libopensc/card-tcos.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-tcos.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -408,7 +408,7 @@ static int tcos_select_file(sc_card_t *card,\n \tfile->path = *in_path;\n \n \tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n-\t\tint j, len=apdu.resp[i+1];\n+\t\tsize_t j, len=apdu.resp[i+1];\n \t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n \n \t\tswitch (type) {\n@@ -432,8 +432,8 @@ static int tcos_select_file(sc_card_t *card,\n \t\t\tfile->id = (d[0]<<8) | d[1];\n \t\t\tbreak;\n \t\tcase 0x84:\n-\t\t\tmemcpy(file->name, d, len);\n-\t\t\tfile->namelen = len;\n+\t\t\tfile->namelen = MIN(sizeof file->name, len);\n+\t\t\tmemcpy(file->name, d, file->namelen);\n \t\t\tbreak;\n \t\tcase 0x86:\n \t\t\tsc_file_set_sec_attr(file, d, len); ""}<_**next**_>{""sha"": ""2b8d66b913b0d3ce3c92c0578c43ae847f98d2c7"", ""filename"": ""src/libopensc/pkcs15-esteid.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-esteid.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -79,7 +79,7 @@ sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n \t/* read the serial (document number) */\n \tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \""read document number failed\"");\n-\tbuff[r] = '\\0';\n+\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n \tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n \n \tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION""}<_**next**_>{""sha"": ""3b220f7a5b37ea236b58ef543d01ca08c815b826"", ""filename"": ""src/libopensc/pkcs15-gemsafeV1.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-gemsafeV1.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -208,7 +208,7 @@ static int gemsafe_get_cert_len(sc_card_t *card)\n \t * the private key.\n \t */\n \tind = 2; /* skip length */\n-\twhile (ibuf[ind] == 0x01) {\n+\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n \t\tif (ibuf[ind+1] == 0xFE) {\n \t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n \t\t\tsc_log(card->ctx, \""Key container %d is allocated and uses key_ref %d\"",""}<_**next**_>{""sha"": ""1391bea15370cd020dfdf1cfb0d9c24db950a0c4"", ""filename"": ""src/libopensc/pkcs15-sc-hsm.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-sc-hsm.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -837,12 +837,14 @@ static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n \t\tr = read_file(p15card, (u8 *) \""\\x2F\\x02\"", efbin, &len, 1);\n \t\tLOG_TEST_RET(card->ctx, r, \""Skipping optional EF.C_DevAut\"");\n \n-\t\t/* save EF_C_DevAut for further use */\n-\t\tptr = realloc(priv->EF_C_DevAut, len);\n-\t\tif (ptr) {\n-\t\t\tmemcpy(ptr, efbin, len);\n-\t\t\tpriv->EF_C_DevAut = ptr;\n-\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\tif (len > 0) {\n+\t\t\t/* save EF_C_DevAut for further use */\n+\t\t\tptr = realloc(priv->EF_C_DevAut, len);\n+\t\t\tif (ptr) {\n+\t\t\t\tmemcpy(ptr, efbin, len);\n+\t\t\t\tpriv->EF_C_DevAut = ptr;\n+\t\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\t\t}\n \t\t}\n \n \t\tptr = efbin;""}<_**next**_>{""sha"": ""53fefb3e68eac554ed608a5a960cf3dd5f5b8dcb"", ""filename"": ""src/libopensc/sc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/sc.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -628,7 +628,7 @@ int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n \t\treturn SC_ERROR_INVALID_ARGUMENTS;\n \t}\n \n-\tif (sec_attr == NULL) {\n+\tif (sec_attr == NULL || sec_attr_len) {\n \t\tif (file->sec_attr != NULL)\n \t\t\tfree(file->sec_attr);\n \t\tfile->sec_attr = NULL;""}<_**next**_>{""sha"": ""662a028222a909f431f31c60bc421fa83d86d5b6"", ""filename"": ""src/tools/cryptoflex-tool.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/cryptoflex-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -21,6 +21,7 @@\n #include \""config.h\""\n \n #include \""libopensc/sc-ossl-compat.h\""\n+#include \""libopensc/internal.h\""\n #include <openssl/bn.h>\n #include <openssl/rsa.h>\n #include <openssl/x509.h>\n@@ -331,7 +332,7 @@ static int read_public_key(RSA *rsa)\n \t\tfprintf(stderr, \""Unable to select public key file: %s\\n\"", sc_strerror(r));\n \t\treturn 2;\n \t}\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {\n@@ -382,7 +383,7 @@ static int read_private_key(RSA *rsa)\n \te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n \tif (e == NULL || e->method == SC_AC_NEVER)\n \t\treturn 10;\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {""}<_**next**_>{""sha"": ""31360833b5284915ae8d93babeb3fdb1b279a0f3"", ""filename"": ""src/tools/egk-tool.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/egk-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -149,7 +149,7 @@ int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t\n \t\tgoto err;\n \t}\n \n-\tlen = file ? file->size : 4096;\n+\tlen = file && file->size > 0 ? file->size : 4096;\n \tp = realloc(*data, len);\n \tif (!p) {\n \t\tgoto err;""}<_**next**_>{""sha"": ""e49647a472e921663b2952ef5cf213c9fc974beb"", ""filename"": ""src/tools/util.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/util.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -339,10 +339,11 @@ const char * util_acl_to_str(const sc_acl_entry_t *e)\n \t\t\tstrcpy(buf, \""????\"");\n \t\t\tbreak;\n \t\t}\n-\t\tstrcat(line, buf);\n-\t\tstrcat(line, \"" \"");\n+\t\tstrncat(line, buf, sizeof line);\n+\t\tstrncat(line, \"" \"", sizeof line);\n \t\te = e->next;\n \t}\n+\tline[(sizeof line)-1] = '\\0'; /* make sure it's NUL terminated */\n \tline[strlen(line)-1] = 0; /* get rid of trailing space */\n \treturn line;\n }""}","static int read_public_key(RSA *rsa)
{
	int r;
	sc_path_t path;
	sc_file_t *file;
	u8 buf[2048], *p = buf;
	size_t bufsize, keysize;

	r = select_app_df();
	if (r)
		return 1;
	sc_format_path(""I1012"", &path);
	r = sc_select_file(card, &path, &file);
	if (r) {
 		fprintf(stderr, ""Unable to select public key file: %s\n"", sc_strerror(r));
 		return 2;
 	}
	bufsize = MIN(file->size, sizeof buf);
 	sc_file_free(file);
 	r = sc_read_binary(card, 0, buf, bufsize, 0);
 	if (r < 0) {
		fprintf(stderr, ""Unable to read public key file: %s\n"", sc_strerror(r));
		return 2;
	}
	bufsize = r;
	do {
		if (bufsize < 4)
			return 3;
		keysize = (p[0] << 8) | p[1];
		if (keysize == 0)
			break;
		if (keysize < 3)
			return 3;
		if (p[2] == opt_key_num)
			break;
		p += keysize;
		bufsize -= keysize;
	} while (1);
	if (keysize == 0) {
		printf(""Key number %d not found.\n"", opt_key_num);
		return 2;
	}
	return parse_public_key(p, keysize, rsa);
}
","static int read_public_key(RSA *rsa)
{
	int r;
	sc_path_t path;
	sc_file_t *file;
	u8 buf[2048], *p = buf;
	size_t bufsize, keysize;

	r = select_app_df();
	if (r)
		return 1;
	sc_format_path(""I1012"", &path);
	r = sc_select_file(card, &path, &file);
	if (r) {
 		fprintf(stderr, ""Unable to select public key file: %s\n"", sc_strerror(r));
 		return 2;
 	}
	bufsize = file->size;
 	sc_file_free(file);
 	r = sc_read_binary(card, 0, buf, bufsize, 0);
 	if (r < 0) {
		fprintf(stderr, ""Unable to read public key file: %s\n"", sc_strerror(r));
		return 2;
	}
	bufsize = r;
	do {
		if (bufsize < 4)
			return 3;
		keysize = (p[0] << 8) | p[1];
		if (keysize == 0)
			break;
		if (keysize < 3)
			return 3;
		if (p[2] == opt_key_num)
			break;
		p += keysize;
		bufsize -= keysize;
	} while (1);
	if (keysize == 0) {
		printf(""Key number %d not found.\n"", opt_key_num);
		return 2;
	}
	return parse_public_key(p, keysize, rsa);
}
",C,"	bufsize = MIN(file->size, sizeof buf);
","	bufsize = file->size;
",,"@@ -21,6 +21,7 @@
 #include ""config.h""
 
 #include ""libopensc/sc-ossl-compat.h""
+#include ""libopensc/internal.h""
 #include <openssl/bn.h>
 #include <openssl/rsa.h>
 #include <openssl/x509.h>
@@ -331,7 +332,7 @@ static int read_public_key(RSA *rsa)
 		fprintf(stderr, ""Unable to select public key file: %s\n"", sc_strerror(r));
 		return 2;
 	}
-	bufsize = file->size;
+	bufsize = MIN(file->size, sizeof buf);
 	sc_file_free(file);
 	r = sc_read_binary(card, 0, buf, bufsize, 0);
 	if (r < 0) {
@@ -382,7 +383,7 @@ static int read_private_key(RSA *rsa)
 	e = sc_file_get_acl_entry(file, SC_AC_OP_READ);
 	if (e == NULL || e->method == SC_AC_NEVER)
 		return 10;
-	bufsize = file->size;
+	bufsize = MIN(file->size, sizeof buf);
 	sc_file_free(file);
 	r = sc_read_binary(card, 0, buf, bufsize, 0);
 	if (r < 0) {",OpenSC,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,8fe377e93b4b56060e5bbfb6f3142ceaeca744fa,1,"static int read_public_key(RSA *rsa)
{
	int r;
	sc_path_t path;
	sc_file_t *file;
	u8 buf[2048], *p = buf;
	size_t bufsize, keysize;

	r = select_app_df();
	if (r)
		return 1;
	sc_format_path(""I1012"", &path);
	r = sc_select_file(card, &path, &file);
	if (r) {
 		fprintf(stderr, ""Unable to select public key file: %s\n"", sc_strerror(r));
 		return 2;
 	}
//flaw_line_below:
	bufsize = file->size;
//fix_flaw_line_below:
//	bufsize = MIN(file->size, sizeof buf);
 	sc_file_free(file);
 	r = sc_read_binary(card, 0, buf, bufsize, 0);
 	if (r < 0) {
		fprintf(stderr, ""Unable to read public key file: %s\n"", sc_strerror(r));
		return 2;
	}
	bufsize = r;
	do {
		if (bufsize < 4)
			return 3;
		keysize = (p[0] << 8) | p[1];
		if (keysize == 0)
			break;
		if (keysize < 3)
			return 3;
		if (p[2] == opt_key_num)
			break;
		p += keysize;
		bufsize -= keysize;
	} while (1);
	if (keysize == 0) {
		printf(""Key number %d not found.\n"", opt_key_num);
		return 2;
	}
	return parse_public_key(p, keysize, rsa);
}
"
4518,182254,,Local,Not required,Partial,CVE-2018-16425,https://www.cvedetails.com/cve/CVE-2018-16425/,CWE-415,Low,Partial,Partial,,2018-09-03,4.6,A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,2019-09-11,DoS ,1,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,"fixed out of bounds writes

Thanks to Eric Sesterhenn from X41 D-SEC GmbH
for reporting the problems.",1,src/tools/egk-tool.c,"{""sha"": ""756788a0fbbbed8487e8cf33b6115bb4d4f58860"", ""filename"": ""src/libopensc/card-cac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-cac.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -794,7 +794,7 @@ static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri\n         }\n \tif (priv->cac_id_len) {\n \t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n-\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n+\t\tmemcpy(serial->value, priv->cac_id, serial->len);\n \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n \t}\n \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);""}<_**next**_>{""sha"": ""65a58f6740d38e6fd6204cbacb5015995067334f"", ""filename"": ""src/libopensc/card-epass2003.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-epass2003.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -951,7 +951,7 @@ decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned\n \twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n \t\tcipher_len--;\n \n-\tif (2 == cipher_len)\n+\tif (2 == cipher_len || *out_len < cipher_len - 2)\n \t\treturn -1;\n \n \tmemcpy(out, plaintext, cipher_len - 2);\n@@ -977,6 +977,7 @@ epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apd\n \tr = sc_check_sw(card, sm->sw1, sm->sw2);\n \tif (r == SC_SUCCESS) {\n \t\tif (exdata->sm) {\n+\t\t\tlen = plain->resplen;\n \t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n \t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n \t\t}""}<_**next**_>{""sha"": ""d247efabc9fd2d7978e4a24dc42bcaccd42f3bee"", ""filename"": ""src/libopensc/card-muscle.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-muscle.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -518,7 +518,9 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \tmscfs_check_cache(priv->fs);\n \n \tfor(x = 0; x < fs->cache.size; x++) {\n-\t\tu8* oid= fs->cache.array[x].objectId.id;\n+\t\tu8* oid = fs->cache.array[x].objectId.id;\n+\t\tif (bufLen < 2)\n+\t\t\tbreak;\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n \t\t\t\""FILE: %02X%02X%02X%02X\\n\"",\n \t\t\toid[0],oid[1],oid[2],oid[3]);\n@@ -527,7 +529,8 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \t\t\tbuf[1] = oid[3];\n \t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n \t\t\tbuf += 2;\n-\t\t\tcount+=2;\n+\t\t\tcount += 2;\n+\t\t\tbufLen -= 2;\n \t\t}\n \t}\n \treturn count;""}<_**next**_>{""sha"": ""3c86b1f4838a5837341ae9cfc9b7fdb5334fe138"", ""filename"": ""src/libopensc/card-tcos.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-tcos.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -408,7 +408,7 @@ static int tcos_select_file(sc_card_t *card,\n \tfile->path = *in_path;\n \n \tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n-\t\tint j, len=apdu.resp[i+1];\n+\t\tsize_t j, len=apdu.resp[i+1];\n \t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n \n \t\tswitch (type) {\n@@ -432,8 +432,8 @@ static int tcos_select_file(sc_card_t *card,\n \t\t\tfile->id = (d[0]<<8) | d[1];\n \t\t\tbreak;\n \t\tcase 0x84:\n-\t\t\tmemcpy(file->name, d, len);\n-\t\t\tfile->namelen = len;\n+\t\t\tfile->namelen = MIN(sizeof file->name, len);\n+\t\t\tmemcpy(file->name, d, file->namelen);\n \t\t\tbreak;\n \t\tcase 0x86:\n \t\t\tsc_file_set_sec_attr(file, d, len); ""}<_**next**_>{""sha"": ""2b8d66b913b0d3ce3c92c0578c43ae847f98d2c7"", ""filename"": ""src/libopensc/pkcs15-esteid.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-esteid.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -79,7 +79,7 @@ sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n \t/* read the serial (document number) */\n \tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \""read document number failed\"");\n-\tbuff[r] = '\\0';\n+\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n \tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n \n \tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION""}<_**next**_>{""sha"": ""3b220f7a5b37ea236b58ef543d01ca08c815b826"", ""filename"": ""src/libopensc/pkcs15-gemsafeV1.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-gemsafeV1.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -208,7 +208,7 @@ static int gemsafe_get_cert_len(sc_card_t *card)\n \t * the private key.\n \t */\n \tind = 2; /* skip length */\n-\twhile (ibuf[ind] == 0x01) {\n+\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n \t\tif (ibuf[ind+1] == 0xFE) {\n \t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n \t\t\tsc_log(card->ctx, \""Key container %d is allocated and uses key_ref %d\"",""}<_**next**_>{""sha"": ""1391bea15370cd020dfdf1cfb0d9c24db950a0c4"", ""filename"": ""src/libopensc/pkcs15-sc-hsm.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-sc-hsm.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -837,12 +837,14 @@ static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n \t\tr = read_file(p15card, (u8 *) \""\\x2F\\x02\"", efbin, &len, 1);\n \t\tLOG_TEST_RET(card->ctx, r, \""Skipping optional EF.C_DevAut\"");\n \n-\t\t/* save EF_C_DevAut for further use */\n-\t\tptr = realloc(priv->EF_C_DevAut, len);\n-\t\tif (ptr) {\n-\t\t\tmemcpy(ptr, efbin, len);\n-\t\t\tpriv->EF_C_DevAut = ptr;\n-\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\tif (len > 0) {\n+\t\t\t/* save EF_C_DevAut for further use */\n+\t\t\tptr = realloc(priv->EF_C_DevAut, len);\n+\t\t\tif (ptr) {\n+\t\t\t\tmemcpy(ptr, efbin, len);\n+\t\t\t\tpriv->EF_C_DevAut = ptr;\n+\t\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\t\t}\n \t\t}\n \n \t\tptr = efbin;""}<_**next**_>{""sha"": ""53fefb3e68eac554ed608a5a960cf3dd5f5b8dcb"", ""filename"": ""src/libopensc/sc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/sc.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -628,7 +628,7 @@ int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n \t\treturn SC_ERROR_INVALID_ARGUMENTS;\n \t}\n \n-\tif (sec_attr == NULL) {\n+\tif (sec_attr == NULL || sec_attr_len) {\n \t\tif (file->sec_attr != NULL)\n \t\t\tfree(file->sec_attr);\n \t\tfile->sec_attr = NULL;""}<_**next**_>{""sha"": ""662a028222a909f431f31c60bc421fa83d86d5b6"", ""filename"": ""src/tools/cryptoflex-tool.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/cryptoflex-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -21,6 +21,7 @@\n #include \""config.h\""\n \n #include \""libopensc/sc-ossl-compat.h\""\n+#include \""libopensc/internal.h\""\n #include <openssl/bn.h>\n #include <openssl/rsa.h>\n #include <openssl/x509.h>\n@@ -331,7 +332,7 @@ static int read_public_key(RSA *rsa)\n \t\tfprintf(stderr, \""Unable to select public key file: %s\\n\"", sc_strerror(r));\n \t\treturn 2;\n \t}\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {\n@@ -382,7 +383,7 @@ static int read_private_key(RSA *rsa)\n \te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n \tif (e == NULL || e->method == SC_AC_NEVER)\n \t\treturn 10;\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {""}<_**next**_>{""sha"": ""31360833b5284915ae8d93babeb3fdb1b279a0f3"", ""filename"": ""src/tools/egk-tool.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/egk-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -149,7 +149,7 @@ int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t\n \t\tgoto err;\n \t}\n \n-\tlen = file ? file->size : 4096;\n+\tlen = file && file->size > 0 ? file->size : 4096;\n \tp = realloc(*data, len);\n \tif (!p) {\n \t\tgoto err;""}<_**next**_>{""sha"": ""e49647a472e921663b2952ef5cf213c9fc974beb"", ""filename"": ""src/tools/util.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/util.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -339,10 +339,11 @@ const char * util_acl_to_str(const sc_acl_entry_t *e)\n \t\t\tstrcpy(buf, \""????\"");\n \t\t\tbreak;\n \t\t}\n-\t\tstrcat(line, buf);\n-\t\tstrcat(line, \"" \"");\n+\t\tstrncat(line, buf, sizeof line);\n+\t\tstrncat(line, \"" \"", sizeof line);\n \t\te = e->next;\n \t}\n+\tline[(sizeof line)-1] = '\\0'; /* make sure it's NUL terminated */\n \tline[strlen(line)-1] = 0; /* get rid of trailing space */\n \treturn line;\n }""}","int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)
{
	struct sc_path path;
	struct sc_file *file;
	unsigned char *p;
	int ok = 0;
	int r;
	size_t len;

	sc_format_path(str_path, &path);
	if (SC_SUCCESS != sc_select_file(card, &path, &file)) {
 		goto err;
 	}
 
	len = file && file->size > 0 ? file->size : 4096;
 	p = realloc(*data, len);
 	if (!p) {
 		goto err;
	}
	*data = p;
	*data_len = len;

	r = sc_read_binary(card, 0, p, len, 0);
	if (r < 0)
		goto err;

	*data_len = r;
	ok = 1;

err:
	sc_file_free(file);

	return ok;
}
","int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)
{
	struct sc_path path;
	struct sc_file *file;
	unsigned char *p;
	int ok = 0;
	int r;
	size_t len;

	sc_format_path(str_path, &path);
	if (SC_SUCCESS != sc_select_file(card, &path, &file)) {
 		goto err;
 	}
 
	len = file ? file->size : 4096;
 	p = realloc(*data, len);
 	if (!p) {
 		goto err;
	}
	*data = p;
	*data_len = len;

	r = sc_read_binary(card, 0, p, len, 0);
	if (r < 0)
		goto err;

	*data_len = r;
	ok = 1;

err:
	sc_file_free(file);

	return ok;
}
",C,"	len = file && file->size > 0 ? file->size : 4096;
","	len = file ? file->size : 4096;
",,"@@ -149,7 +149,7 @@ int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t
 		goto err;
 	}
 
-	len = file ? file->size : 4096;
+	len = file && file->size > 0 ? file->size : 4096;
 	p = realloc(*data, len);
 	if (!p) {
 		goto err;",OpenSC,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,8fe377e93b4b56060e5bbfb6f3142ceaeca744fa,1,"int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)
{
	struct sc_path path;
	struct sc_file *file;
	unsigned char *p;
	int ok = 0;
	int r;
	size_t len;

	sc_format_path(str_path, &path);
	if (SC_SUCCESS != sc_select_file(card, &path, &file)) {
 		goto err;
 	}
 
//flaw_line_below:
	len = file ? file->size : 4096;
//fix_flaw_line_below:
//	len = file && file->size > 0 ? file->size : 4096;
 	p = realloc(*data, len);
 	if (!p) {
 		goto err;
	}
	*data = p;
	*data_len = len;

	r = sc_read_binary(card, 0, p, len, 0);
	if (r < 0)
		goto err;

	*data_len = r;
	ok = 1;

err:
	sc_file_free(file);

	return ok;
}
"
4519,182255,,Local,Not required,Partial,CVE-2018-16425,https://www.cvedetails.com/cve/CVE-2018-16425/,CWE-415,Low,Partial,Partial,,2018-09-03,4.6,A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,2019-09-11,DoS ,3,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,"fixed out of bounds writes

Thanks to Eric Sesterhenn from X41 D-SEC GmbH
for reporting the problems.",2,src/tools/util.c,"{""sha"": ""756788a0fbbbed8487e8cf33b6115bb4d4f58860"", ""filename"": ""src/libopensc/card-cac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-cac.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -794,7 +794,7 @@ static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri\n         }\n \tif (priv->cac_id_len) {\n \t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n-\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n+\t\tmemcpy(serial->value, priv->cac_id, serial->len);\n \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n \t}\n \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);""}<_**next**_>{""sha"": ""65a58f6740d38e6fd6204cbacb5015995067334f"", ""filename"": ""src/libopensc/card-epass2003.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-epass2003.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -951,7 +951,7 @@ decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned\n \twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n \t\tcipher_len--;\n \n-\tif (2 == cipher_len)\n+\tif (2 == cipher_len || *out_len < cipher_len - 2)\n \t\treturn -1;\n \n \tmemcpy(out, plaintext, cipher_len - 2);\n@@ -977,6 +977,7 @@ epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apd\n \tr = sc_check_sw(card, sm->sw1, sm->sw2);\n \tif (r == SC_SUCCESS) {\n \t\tif (exdata->sm) {\n+\t\t\tlen = plain->resplen;\n \t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n \t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n \t\t}""}<_**next**_>{""sha"": ""d247efabc9fd2d7978e4a24dc42bcaccd42f3bee"", ""filename"": ""src/libopensc/card-muscle.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-muscle.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -518,7 +518,9 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \tmscfs_check_cache(priv->fs);\n \n \tfor(x = 0; x < fs->cache.size; x++) {\n-\t\tu8* oid= fs->cache.array[x].objectId.id;\n+\t\tu8* oid = fs->cache.array[x].objectId.id;\n+\t\tif (bufLen < 2)\n+\t\t\tbreak;\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n \t\t\t\""FILE: %02X%02X%02X%02X\\n\"",\n \t\t\toid[0],oid[1],oid[2],oid[3]);\n@@ -527,7 +529,8 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \t\t\tbuf[1] = oid[3];\n \t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n \t\t\tbuf += 2;\n-\t\t\tcount+=2;\n+\t\t\tcount += 2;\n+\t\t\tbufLen -= 2;\n \t\t}\n \t}\n \treturn count;""}<_**next**_>{""sha"": ""3c86b1f4838a5837341ae9cfc9b7fdb5334fe138"", ""filename"": ""src/libopensc/card-tcos.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-tcos.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -408,7 +408,7 @@ static int tcos_select_file(sc_card_t *card,\n \tfile->path = *in_path;\n \n \tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n-\t\tint j, len=apdu.resp[i+1];\n+\t\tsize_t j, len=apdu.resp[i+1];\n \t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n \n \t\tswitch (type) {\n@@ -432,8 +432,8 @@ static int tcos_select_file(sc_card_t *card,\n \t\t\tfile->id = (d[0]<<8) | d[1];\n \t\t\tbreak;\n \t\tcase 0x84:\n-\t\t\tmemcpy(file->name, d, len);\n-\t\t\tfile->namelen = len;\n+\t\t\tfile->namelen = MIN(sizeof file->name, len);\n+\t\t\tmemcpy(file->name, d, file->namelen);\n \t\t\tbreak;\n \t\tcase 0x86:\n \t\t\tsc_file_set_sec_attr(file, d, len); ""}<_**next**_>{""sha"": ""2b8d66b913b0d3ce3c92c0578c43ae847f98d2c7"", ""filename"": ""src/libopensc/pkcs15-esteid.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-esteid.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -79,7 +79,7 @@ sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n \t/* read the serial (document number) */\n \tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \""read document number failed\"");\n-\tbuff[r] = '\\0';\n+\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n \tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n \n \tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION""}<_**next**_>{""sha"": ""3b220f7a5b37ea236b58ef543d01ca08c815b826"", ""filename"": ""src/libopensc/pkcs15-gemsafeV1.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-gemsafeV1.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -208,7 +208,7 @@ static int gemsafe_get_cert_len(sc_card_t *card)\n \t * the private key.\n \t */\n \tind = 2; /* skip length */\n-\twhile (ibuf[ind] == 0x01) {\n+\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n \t\tif (ibuf[ind+1] == 0xFE) {\n \t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n \t\t\tsc_log(card->ctx, \""Key container %d is allocated and uses key_ref %d\"",""}<_**next**_>{""sha"": ""1391bea15370cd020dfdf1cfb0d9c24db950a0c4"", ""filename"": ""src/libopensc/pkcs15-sc-hsm.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-sc-hsm.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -837,12 +837,14 @@ static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n \t\tr = read_file(p15card, (u8 *) \""\\x2F\\x02\"", efbin, &len, 1);\n \t\tLOG_TEST_RET(card->ctx, r, \""Skipping optional EF.C_DevAut\"");\n \n-\t\t/* save EF_C_DevAut for further use */\n-\t\tptr = realloc(priv->EF_C_DevAut, len);\n-\t\tif (ptr) {\n-\t\t\tmemcpy(ptr, efbin, len);\n-\t\t\tpriv->EF_C_DevAut = ptr;\n-\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\tif (len > 0) {\n+\t\t\t/* save EF_C_DevAut for further use */\n+\t\t\tptr = realloc(priv->EF_C_DevAut, len);\n+\t\t\tif (ptr) {\n+\t\t\t\tmemcpy(ptr, efbin, len);\n+\t\t\t\tpriv->EF_C_DevAut = ptr;\n+\t\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\t\t}\n \t\t}\n \n \t\tptr = efbin;""}<_**next**_>{""sha"": ""53fefb3e68eac554ed608a5a960cf3dd5f5b8dcb"", ""filename"": ""src/libopensc/sc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/sc.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -628,7 +628,7 @@ int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n \t\treturn SC_ERROR_INVALID_ARGUMENTS;\n \t}\n \n-\tif (sec_attr == NULL) {\n+\tif (sec_attr == NULL || sec_attr_len) {\n \t\tif (file->sec_attr != NULL)\n \t\t\tfree(file->sec_attr);\n \t\tfile->sec_attr = NULL;""}<_**next**_>{""sha"": ""662a028222a909f431f31c60bc421fa83d86d5b6"", ""filename"": ""src/tools/cryptoflex-tool.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/cryptoflex-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -21,6 +21,7 @@\n #include \""config.h\""\n \n #include \""libopensc/sc-ossl-compat.h\""\n+#include \""libopensc/internal.h\""\n #include <openssl/bn.h>\n #include <openssl/rsa.h>\n #include <openssl/x509.h>\n@@ -331,7 +332,7 @@ static int read_public_key(RSA *rsa)\n \t\tfprintf(stderr, \""Unable to select public key file: %s\\n\"", sc_strerror(r));\n \t\treturn 2;\n \t}\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {\n@@ -382,7 +383,7 @@ static int read_private_key(RSA *rsa)\n \te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n \tif (e == NULL || e->method == SC_AC_NEVER)\n \t\treturn 10;\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {""}<_**next**_>{""sha"": ""31360833b5284915ae8d93babeb3fdb1b279a0f3"", ""filename"": ""src/tools/egk-tool.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/egk-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -149,7 +149,7 @@ int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t\n \t\tgoto err;\n \t}\n \n-\tlen = file ? file->size : 4096;\n+\tlen = file && file->size > 0 ? file->size : 4096;\n \tp = realloc(*data, len);\n \tif (!p) {\n \t\tgoto err;""}<_**next**_>{""sha"": ""e49647a472e921663b2952ef5cf213c9fc974beb"", ""filename"": ""src/tools/util.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/util.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -339,10 +339,11 @@ const char * util_acl_to_str(const sc_acl_entry_t *e)\n \t\t\tstrcpy(buf, \""????\"");\n \t\t\tbreak;\n \t\t}\n-\t\tstrcat(line, buf);\n-\t\tstrcat(line, \"" \"");\n+\t\tstrncat(line, buf, sizeof line);\n+\t\tstrncat(line, \"" \"", sizeof line);\n \t\te = e->next;\n \t}\n+\tline[(sizeof line)-1] = '\\0'; /* make sure it's NUL terminated */\n \tline[strlen(line)-1] = 0; /* get rid of trailing space */\n \treturn line;\n }""}","const char * util_acl_to_str(const sc_acl_entry_t *e)
{
	static char line[80], buf[20];
	unsigned int acl;

	if (e == NULL)
		return ""N/A"";
	line[0] = 0;
	while (e != NULL) {
		acl = e->method;

		switch (acl) {
		case SC_AC_UNKNOWN:
			return ""N/A"";
		case SC_AC_NEVER:
			return ""NEVR"";
		case SC_AC_NONE:
			return ""NONE"";
		case SC_AC_CHV:
			strcpy(buf, ""CHV"");
			if (e->key_ref != SC_AC_KEY_REF_NONE)
				sprintf(buf + 3, ""%d"", e->key_ref);
			break;
		case SC_AC_TERM:
			strcpy(buf, ""TERM"");
			break;
		case SC_AC_PRO:
			strcpy(buf, ""PROT"");
			break;
		case SC_AC_AUT:
			strcpy(buf, ""AUTH"");
			if (e->key_ref != SC_AC_KEY_REF_NONE)
				sprintf(buf + 4, ""%d"", e->key_ref);
			break;
		case SC_AC_SEN:
			strcpy(buf, ""Sec.Env. "");
			if (e->key_ref != SC_AC_KEY_REF_NONE)
				sprintf(buf + 3, ""#%d"", e->key_ref);
			break;
		case SC_AC_SCB:
			strcpy(buf, ""Sec.ControlByte "");
			if (e->key_ref != SC_AC_KEY_REF_NONE)
				sprintf(buf + 3, ""Ox%X"", e->key_ref);
			break;
		case SC_AC_IDA:
			strcpy(buf, ""PKCS#15 AuthID "");
			if (e->key_ref != SC_AC_KEY_REF_NONE)
				sprintf(buf + 3, ""#%d"", e->key_ref);
			break;
		default:
 			strcpy(buf, ""????"");
 			break;
 		}
		strncat(line, buf, sizeof line);
		strncat(line, "" "", sizeof line);
 		e = e->next;
 	}
	line[(sizeof line)-1] = '\0'; /* make sure it's NUL terminated */
 	line[strlen(line)-1] = 0; /* get rid of trailing space */
 	return line;
 }
","const char * util_acl_to_str(const sc_acl_entry_t *e)
{
	static char line[80], buf[20];
	unsigned int acl;

	if (e == NULL)
		return ""N/A"";
	line[0] = 0;
	while (e != NULL) {
		acl = e->method;

		switch (acl) {
		case SC_AC_UNKNOWN:
			return ""N/A"";
		case SC_AC_NEVER:
			return ""NEVR"";
		case SC_AC_NONE:
			return ""NONE"";
		case SC_AC_CHV:
			strcpy(buf, ""CHV"");
			if (e->key_ref != SC_AC_KEY_REF_NONE)
				sprintf(buf + 3, ""%d"", e->key_ref);
			break;
		case SC_AC_TERM:
			strcpy(buf, ""TERM"");
			break;
		case SC_AC_PRO:
			strcpy(buf, ""PROT"");
			break;
		case SC_AC_AUT:
			strcpy(buf, ""AUTH"");
			if (e->key_ref != SC_AC_KEY_REF_NONE)
				sprintf(buf + 4, ""%d"", e->key_ref);
			break;
		case SC_AC_SEN:
			strcpy(buf, ""Sec.Env. "");
			if (e->key_ref != SC_AC_KEY_REF_NONE)
				sprintf(buf + 3, ""#%d"", e->key_ref);
			break;
		case SC_AC_SCB:
			strcpy(buf, ""Sec.ControlByte "");
			if (e->key_ref != SC_AC_KEY_REF_NONE)
				sprintf(buf + 3, ""Ox%X"", e->key_ref);
			break;
		case SC_AC_IDA:
			strcpy(buf, ""PKCS#15 AuthID "");
			if (e->key_ref != SC_AC_KEY_REF_NONE)
				sprintf(buf + 3, ""#%d"", e->key_ref);
			break;
		default:
 			strcpy(buf, ""????"");
 			break;
 		}
		strcat(line, buf);
		strcat(line, "" "");
 		e = e->next;
 	}
 	line[strlen(line)-1] = 0; /* get rid of trailing space */
 	return line;
 }
",C,"		strncat(line, buf, sizeof line);
		strncat(line, "" "", sizeof line);
	line[(sizeof line)-1] = '\0'; /* make sure it's NUL terminated */
","		strcat(line, buf);
		strcat(line, "" "");
",,"@@ -339,10 +339,11 @@ const char * util_acl_to_str(const sc_acl_entry_t *e)
 			strcpy(buf, ""????"");
 			break;
 		}
-		strcat(line, buf);
-		strcat(line, "" "");
+		strncat(line, buf, sizeof line);
+		strncat(line, "" "", sizeof line);
 		e = e->next;
 	}
+	line[(sizeof line)-1] = '\0'; /* make sure it's NUL terminated */
 	line[strlen(line)-1] = 0; /* get rid of trailing space */
 	return line;
 }",OpenSC,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,8fe377e93b4b56060e5bbfb6f3142ceaeca744fa,1,"const char * util_acl_to_str(const sc_acl_entry_t *e)
{
	static char line[80], buf[20];
	unsigned int acl;

	if (e == NULL)
		return ""N/A"";
	line[0] = 0;
	while (e != NULL) {
		acl = e->method;

		switch (acl) {
		case SC_AC_UNKNOWN:
			return ""N/A"";
		case SC_AC_NEVER:
			return ""NEVR"";
		case SC_AC_NONE:
			return ""NONE"";
		case SC_AC_CHV:
			strcpy(buf, ""CHV"");
			if (e->key_ref != SC_AC_KEY_REF_NONE)
				sprintf(buf + 3, ""%d"", e->key_ref);
			break;
		case SC_AC_TERM:
			strcpy(buf, ""TERM"");
			break;
		case SC_AC_PRO:
			strcpy(buf, ""PROT"");
			break;
		case SC_AC_AUT:
			strcpy(buf, ""AUTH"");
			if (e->key_ref != SC_AC_KEY_REF_NONE)
				sprintf(buf + 4, ""%d"", e->key_ref);
			break;
		case SC_AC_SEN:
			strcpy(buf, ""Sec.Env. "");
			if (e->key_ref != SC_AC_KEY_REF_NONE)
				sprintf(buf + 3, ""#%d"", e->key_ref);
			break;
		case SC_AC_SCB:
			strcpy(buf, ""Sec.ControlByte "");
			if (e->key_ref != SC_AC_KEY_REF_NONE)
				sprintf(buf + 3, ""Ox%X"", e->key_ref);
			break;
		case SC_AC_IDA:
			strcpy(buf, ""PKCS#15 AuthID "");
			if (e->key_ref != SC_AC_KEY_REF_NONE)
				sprintf(buf + 3, ""#%d"", e->key_ref);
			break;
		default:
 			strcpy(buf, ""????"");
 			break;
 		}
//flaw_line_below:
		strcat(line, buf);
//flaw_line_below:
		strcat(line, "" "");
//fix_flaw_line_below:
//		strncat(line, buf, sizeof line);
//fix_flaw_line_below:
//		strncat(line, "" "", sizeof line);
 		e = e->next;
 	}
//fix_flaw_line_below:
//	line[(sizeof line)-1] = '\0'; /* make sure it's NUL terminated */
 	line[strlen(line)-1] = 0; /* get rid of trailing space */
 	return line;
 }
"
4703,182439,,Local,Not required,Partial,CVE-2018-9336,https://www.cvedetails.com/cve/CVE-2018-9336/,CWE-415,Low,Partial,Partial,,2018-05-01,4.6,openvpnserv.exe (aka the interactive service helper) in OpenVPN 2.4.x before 2.4.6 allows a local attacker to cause a double-free of memory by sending a malformed request to the interactive service. This could cause a denial-of-service through memory corruption or possibly have unspecified other impact including privilege escalation.,2018-06-13,Mem. Corr. ,11,https://github.com/OpenVPN/openvpn/commit/1394192b210cb3c6624a7419bcf3ff966742e79b,1394192b210cb3c6624a7419bcf3ff966742e79b,"Fix potential double-free() in Interactive Service (CVE-2018-9336)

Malformed input data on the service pipe towards the OpenVPN interactive
service (normally used by the OpenVPN GUI to request openvpn instances
from the service) can result in a double free() in the error handling code.

This usually only leads to a process crash (DoS by an unprivileged local
account) but since it could possibly lead to memory corruption if
happening while multiple other threads are active at the same time,
CVE-2018-9336 has been assigned to acknowledge this risk.

Fix by ensuring that sud->directory is set to NULL in GetStartUpData()
for all error cases (thus not being free()ed in FreeStartupData()).

Rewrite control flow to use explicit error label for error exit.

Discovered and reported by Jacob Baines <jbaines@tenable.com>.

CVE: 2018-9336

Signed-off-by: Gert Doering <gert@greenie.muc.de>
Acked-by: Selva Nair <selva.nair@gmail.com>
Message-Id: <20180414072617.25075-1-gert@greenie.muc.de>
URL: https://www.mail-archive.com/search?l=mid&q=20180414072617.25075-1-gert@greenie.muc.de

Signed-off-by: Gert Doering <gert@greenie.muc.de>",12,src/openvpnserv/interactive.c,"{""sha"": ""861f5e705bc5836539506a7f0f2118a8a144154c"", ""filename"": ""src/openvpnserv/interactive.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 12, ""changes"": 23, ""blob_url"": ""https://github.com/OpenVPN/openvpn/blob/1394192b210cb3c6624a7419bcf3ff966742e79b/src/openvpnserv/interactive.c"", ""raw_url"": ""https://github.com/OpenVPN/openvpn/raw/1394192b210cb3c6624a7419bcf3ff966742e79b/src/openvpnserv/interactive.c"", ""contents_url"": ""https://api.github.com/repos/OpenVPN/openvpn/contents/src/openvpnserv/interactive.c?ref=1394192b210cb3c6624a7419bcf3ff966742e79b"", ""patch"": ""@@ -453,7 +453,6 @@ static BOOL\n GetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n {\n     size_t size, len;\n-    BOOL ret = FALSE;\n     WCHAR *data = NULL;\n     DWORD bytes, read;\n \n@@ -462,38 +461,38 @@ GetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\""PeekNamedPipeAsync failed\""));\n         ReturnLastError(pipe, L\""PeekNamedPipeAsync\"");\n-        goto out;\n+        goto err;\n     }\n \n     size = bytes / sizeof(*data);\n     if (size == 0)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\""malformed startup data: 1 byte received\""));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\""GetStartupData\"", 1, &exit_event);\n-        goto out;\n+        goto err;\n     }\n \n     data = malloc(bytes);\n     if (data == NULL)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\""malloc failed\""));\n         ReturnLastError(pipe, L\""malloc\"");\n-        goto out;\n+        goto err;\n     }\n \n     read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);\n     if (bytes != read)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\""ReadPipeAsync failed\""));\n         ReturnLastError(pipe, L\""ReadPipeAsync\"");\n-        goto out;\n+        goto err;\n     }\n \n     if (data[size - 1] != 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\""Startup data is not NULL terminated\""));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\""GetStartupData\"", 1, &exit_event);\n-        goto out;\n+        goto err;\n     }\n \n     sud->directory = data;\n@@ -503,7 +502,7 @@ GetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n     {\n         MsgToEventLog(M_ERR, TEXT(\""Startup data ends at working directory\""));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\""GetStartupData\"", 1, &exit_event);\n-        goto out;\n+        goto err;\n     }\n \n     sud->options = sud->directory + len;\n@@ -513,16 +512,16 @@ GetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n     {\n         MsgToEventLog(M_ERR, TEXT(\""Startup data ends at command line options\""));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\""GetStartupData\"", 1, &exit_event);\n-        goto out;\n+        goto err;\n     }\n \n     sud->std_input = sud->options + len;\n-    data = NULL; /* don't free data */\n-    ret = TRUE;\n+    return TRUE;\n \n-out:\n+err:\n+    sud->directory = NULL;\t\t/* caller must not free() */\n     free(data);\n-    return ret;\n+    return FALSE;\n }\n \n ""}"," GetStartupData(HANDLE pipe, STARTUP_DATA *sud)
 {
     size_t size, len;
     WCHAR *data = NULL;
     DWORD bytes, read;
 
    bytes = PeekNamedPipeAsync(pipe, 1, &exit_event);
    if (bytes == 0)
     {
         MsgToEventLog(M_SYSERR, TEXT(""PeekNamedPipeAsync failed""));
         ReturnLastError(pipe, L""PeekNamedPipeAsync"");
        goto err;
     }
 
     size = bytes / sizeof(*data);
     if (size == 0)
     {
         MsgToEventLog(M_SYSERR, TEXT(""malformed startup data: 1 byte received""));
         ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event);
        goto err;
     }
 
     data = malloc(bytes);
     if (data == NULL)
     {
         MsgToEventLog(M_SYSERR, TEXT(""malloc failed""));
         ReturnLastError(pipe, L""malloc"");
        goto err;
     }
 
     read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);
     if (bytes != read)
     {
         MsgToEventLog(M_SYSERR, TEXT(""ReadPipeAsync failed""));
         ReturnLastError(pipe, L""ReadPipeAsync"");
        goto err;
     }
 
     if (data[size - 1] != 0)
     {
         MsgToEventLog(M_ERR, TEXT(""Startup data is not NULL terminated""));
         ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event);
        goto err;
     }
 
     sud->directory = data;
    len = wcslen(sud->directory) + 1;
    size -= len;
    if (size <= 0)
     {
         MsgToEventLog(M_ERR, TEXT(""Startup data ends at working directory""));
         ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event);
        goto err;
     }
 
     sud->options = sud->directory + len;
    len = wcslen(sud->options) + 1;
    size -= len;
    if (size <= 0)
     {
         MsgToEventLog(M_ERR, TEXT(""Startup data ends at command line options""));
         ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event);
        goto err;
     }
 
     sud->std_input = sud->options + len;
    return TRUE;
 
err:
    sud->directory = NULL;		/* caller must not free() */
     free(data);
    return FALSE;
 }
"," GetStartupData(HANDLE pipe, STARTUP_DATA *sud)
 {
     size_t size, len;
    BOOL ret = FALSE;
     WCHAR *data = NULL;
     DWORD bytes, read;
 
    bytes = PeekNamedPipeAsync(pipe, 1, &exit_event);
    if (bytes == 0)
     {
         MsgToEventLog(M_SYSERR, TEXT(""PeekNamedPipeAsync failed""));
         ReturnLastError(pipe, L""PeekNamedPipeAsync"");
        goto out;
     }
 
     size = bytes / sizeof(*data);
     if (size == 0)
     {
         MsgToEventLog(M_SYSERR, TEXT(""malformed startup data: 1 byte received""));
         ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event);
        goto out;
     }
 
     data = malloc(bytes);
     if (data == NULL)
     {
         MsgToEventLog(M_SYSERR, TEXT(""malloc failed""));
         ReturnLastError(pipe, L""malloc"");
        goto out;
     }
 
     read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);
     if (bytes != read)
     {
         MsgToEventLog(M_SYSERR, TEXT(""ReadPipeAsync failed""));
         ReturnLastError(pipe, L""ReadPipeAsync"");
        goto out;
     }
 
     if (data[size - 1] != 0)
     {
         MsgToEventLog(M_ERR, TEXT(""Startup data is not NULL terminated""));
         ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event);
        goto out;
     }
 
     sud->directory = data;
    len = wcslen(sud->directory) + 1;
    size -= len;
    if (size <= 0)
     {
         MsgToEventLog(M_ERR, TEXT(""Startup data ends at working directory""));
         ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event);
        goto out;
     }
 
     sud->options = sud->directory + len;
    len = wcslen(sud->options) + 1;
    size -= len;
    if (size <= 0)
     {
         MsgToEventLog(M_ERR, TEXT(""Startup data ends at command line options""));
         ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event);
        goto out;
     }
 
     sud->std_input = sud->options + len;
    data = NULL; /* don't free data */
    ret = TRUE;
 
out:
     free(data);
    return ret;
 }
",C,"        goto err;
        goto err;
        goto err;
        goto err;
        goto err;
        goto err;
        goto err;
    return TRUE;
err:
    sud->directory = NULL;		/* caller must not free() */
    return FALSE;
","    BOOL ret = FALSE;
        goto out;
        goto out;
        goto out;
        goto out;
        goto out;
        goto out;
        goto out;
    data = NULL; /* don't free data */
    ret = TRUE;
out:
    return ret;
",,"@@ -453,7 +453,6 @@ static BOOL
 GetStartupData(HANDLE pipe, STARTUP_DATA *sud)
 {
     size_t size, len;
-    BOOL ret = FALSE;
     WCHAR *data = NULL;
     DWORD bytes, read;
 
@@ -462,38 +461,38 @@ GetStartupData(HANDLE pipe, STARTUP_DATA *sud)
     {
         MsgToEventLog(M_SYSERR, TEXT(""PeekNamedPipeAsync failed""));
         ReturnLastError(pipe, L""PeekNamedPipeAsync"");
-        goto out;
+        goto err;
     }
 
     size = bytes / sizeof(*data);
     if (size == 0)
     {
         MsgToEventLog(M_SYSERR, TEXT(""malformed startup data: 1 byte received""));
         ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event);
-        goto out;
+        goto err;
     }
 
     data = malloc(bytes);
     if (data == NULL)
     {
         MsgToEventLog(M_SYSERR, TEXT(""malloc failed""));
         ReturnLastError(pipe, L""malloc"");
-        goto out;
+        goto err;
     }
 
     read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);
     if (bytes != read)
     {
         MsgToEventLog(M_SYSERR, TEXT(""ReadPipeAsync failed""));
         ReturnLastError(pipe, L""ReadPipeAsync"");
-        goto out;
+        goto err;
     }
 
     if (data[size - 1] != 0)
     {
         MsgToEventLog(M_ERR, TEXT(""Startup data is not NULL terminated""));
         ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event);
-        goto out;
+        goto err;
     }
 
     sud->directory = data;
@@ -503,7 +502,7 @@ GetStartupData(HANDLE pipe, STARTUP_DATA *sud)
     {
         MsgToEventLog(M_ERR, TEXT(""Startup data ends at working directory""));
         ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event);
-        goto out;
+        goto err;
     }
 
     sud->options = sud->directory + len;
@@ -513,16 +512,16 @@ GetStartupData(HANDLE pipe, STARTUP_DATA *sud)
     {
         MsgToEventLog(M_ERR, TEXT(""Startup data ends at command line options""));
         ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event);
-        goto out;
+        goto err;
     }
 
     sud->std_input = sud->options + len;
-    data = NULL; /* don't free data */
-    ret = TRUE;
+    return TRUE;
 
-out:
+err:
+    sud->directory = NULL;		/* caller must not free() */
     free(data);
-    return ret;
+    return FALSE;
 }
 
 ",openvpn,1394192b210cb3c6624a7419bcf3ff966742e79b,8acc40b6a64451d9a17cf4fa12fac2450ca26095,1," GetStartupData(HANDLE pipe, STARTUP_DATA *sud)
 {
     size_t size, len;
//flaw_line_below:
    BOOL ret = FALSE;
     WCHAR *data = NULL;
     DWORD bytes, read;
 
    bytes = PeekNamedPipeAsync(pipe, 1, &exit_event);
    if (bytes == 0)
     {
         MsgToEventLog(M_SYSERR, TEXT(""PeekNamedPipeAsync failed""));
         ReturnLastError(pipe, L""PeekNamedPipeAsync"");
//flaw_line_below:
        goto out;
//fix_flaw_line_below:
//        goto err;
     }
 
     size = bytes / sizeof(*data);
     if (size == 0)
     {
         MsgToEventLog(M_SYSERR, TEXT(""malformed startup data: 1 byte received""));
         ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event);
//flaw_line_below:
        goto out;
//fix_flaw_line_below:
//        goto err;
     }
 
     data = malloc(bytes);
     if (data == NULL)
     {
         MsgToEventLog(M_SYSERR, TEXT(""malloc failed""));
         ReturnLastError(pipe, L""malloc"");
//flaw_line_below:
        goto out;
//fix_flaw_line_below:
//        goto err;
     }
 
     read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);
     if (bytes != read)
     {
         MsgToEventLog(M_SYSERR, TEXT(""ReadPipeAsync failed""));
         ReturnLastError(pipe, L""ReadPipeAsync"");
//flaw_line_below:
        goto out;
//fix_flaw_line_below:
//        goto err;
     }
 
     if (data[size - 1] != 0)
     {
         MsgToEventLog(M_ERR, TEXT(""Startup data is not NULL terminated""));
         ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event);
//flaw_line_below:
        goto out;
//fix_flaw_line_below:
//        goto err;
     }
 
     sud->directory = data;
    len = wcslen(sud->directory) + 1;
    size -= len;
    if (size <= 0)
     {
         MsgToEventLog(M_ERR, TEXT(""Startup data ends at working directory""));
         ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event);
//flaw_line_below:
        goto out;
//fix_flaw_line_below:
//        goto err;
     }
 
     sud->options = sud->directory + len;
    len = wcslen(sud->options) + 1;
    size -= len;
    if (size <= 0)
     {
         MsgToEventLog(M_ERR, TEXT(""Startup data ends at command line options""));
         ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event);
//flaw_line_below:
        goto out;
//fix_flaw_line_below:
//        goto err;
     }
 
     sud->std_input = sud->options + len;
//flaw_line_below:
    data = NULL; /* don't free data */
//flaw_line_below:
    ret = TRUE;
//fix_flaw_line_below:
//    return TRUE;
 
//flaw_line_below:
out:
//fix_flaw_line_below:
//err:
//fix_flaw_line_below:
//    sud->directory = NULL;		/* caller must not free() */
     free(data);
//flaw_line_below:
    return ret;
//fix_flaw_line_below:
//    return FALSE;
 }
"
4735,182471,,Remote,Not required,Partial,CVE-2018-8099,https://www.cvedetails.com/cve/CVE-2018-8099/,CWE-415,Medium,,,,2018-03-13,4.3,"Incorrect returning of an error code in the index.c:read_entry() function leads to a double free in libgit2 before v0.26.2, which allows an attacker to cause a denial of service via a crafted repository index file.",2018-04-13,DoS ,2,https://github.com/libgit2/libgit2/commit/58a6fe94cb851f71214dbefac3f9bffee437d6fe,58a6fe94cb851f71214dbefac3f9bffee437d6fe,"index: convert `read_entry` to return entry size via an out-param

The function `read_entry` does not conform to our usual coding style of
returning stuff via the out parameter and to use the return value for
reporting errors. Due to most of our code conforming to that pattern, it
has become quite natural for us to actually return `-1` in case there is
any error, which has also slipped in with commit 5625d86b9 (index:
support index v4, 2016-05-17). As the function returns an `size_t` only,
though, the return value is wrapped around, causing the caller of
`read_tree` to continue with an invalid index entry. Ultimately, this
can lead to a double-free.

Improve code and fix the bug by converting the function to return the
index entry size via an out parameter and only using the return value to
indicate errors.

Reported-by: Krishna Ram Prakash R <krp@gtux.in>
Reported-by: Vivek Parikh <viv0411.parikh@gmail.com>",3,src/index.c,"{""sha"": ""3ef892b7f170b1fdad356de32061652d7f97c48a"", ""filename"": ""src/index.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 9, ""changes"": 22, ""blob_url"": ""https://github.com/libgit2/libgit2/blob/58a6fe94cb851f71214dbefac3f9bffee437d6fe/src/index.c"", ""raw_url"": ""https://github.com/libgit2/libgit2/raw/58a6fe94cb851f71214dbefac3f9bffee437d6fe/src/index.c"", ""contents_url"": ""https://api.github.com/repos/libgit2/libgit2/contents/src/index.c?ref=58a6fe94cb851f71214dbefac3f9bffee437d6fe"", ""patch"": ""@@ -2299,8 +2299,9 @@ static size_t index_entry_size(size_t path_len, size_t varint_len, uint32_t flag\n \t}\n }\n \n-static size_t read_entry(\n+static int read_entry(\n \tgit_index_entry **out,\n+\tsize_t *out_size,\n \tgit_index *index,\n \tconst void *buffer,\n \tsize_t buffer_size,\n@@ -2314,7 +2315,7 @@ static size_t read_entry(\n \tchar *tmp_path = NULL;\n \n \tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n-\t\treturn 0;\n+\t\treturn -1;\n \n \t/* buffer is not guaranteed to be aligned */\n \tmemcpy(&source, buffer, sizeof(struct entry_short));\n@@ -2356,7 +2357,7 @@ static size_t read_entry(\n \n \t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n \t\t\tif (path_end == NULL)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn -1;\n \n \t\t\tpath_length = path_end - path_ptr;\n \t\t}\n@@ -2386,16 +2387,20 @@ static size_t read_entry(\n \t\tentry.path = tmp_path;\n \t}\n \n+\tif (entry_size == 0)\n+\t\treturn -1;\n+\n \tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n-\t\treturn 0;\n+\t\treturn -1;\n \n \tif (index_entry_dup(out, index, &entry) < 0) {\n \t\tgit__free(tmp_path);\n-\t\treturn 0;\n+\t\treturn -1;\n \t}\n \n \tgit__free(tmp_path);\n-\treturn entry_size;\n+\t*out_size = entry_size;\n+\treturn 0;\n }\n \n static int read_header(struct index_header *dest, const void *buffer)\n@@ -2499,10 +2504,9 @@ static int parse_index(git_index *index, const char *buffer, size_t buffer_size)\n \t/* Parse all the entries */\n \tfor (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {\n \t\tgit_index_entry *entry = NULL;\n-\t\tsize_t entry_size = read_entry(&entry, index, buffer, buffer_size, last);\n+\t\tsize_t entry_size;\n \n-\t\t/* 0 bytes read means an object corruption */\n-\t\tif (entry_size == 0) {\n+\t\tif ((error = read_entry(&entry, &entry_size, index, buffer, buffer_size, last)) < 0) {\n \t\t\terror = index_error_invalid(\""invalid entry\"");\n \t\t\tgoto done;\n \t\t}""}","static int parse_index(git_index *index, const char *buffer, size_t buffer_size)
{
	int error = 0;
	unsigned int i;
	struct index_header header = { 0 };
	git_oid checksum_calculated, checksum_expected;
	const char *last = NULL;
	const char *empty = """";

#define seek_forward(_increase) { \
	if (_increase >= buffer_size) { \
		error = index_error_invalid(""ran out of data while parsing""); \
		goto done; } \
	buffer += _increase; \
	buffer_size -= _increase;\
}

	if (buffer_size < INDEX_HEADER_SIZE + INDEX_FOOTER_SIZE)
		return index_error_invalid(""insufficient buffer space"");

	/* Precalculate the SHA1 of the files's contents -- we'll match it to
	 * the provided SHA1 in the footer */
	git_hash_buf(&checksum_calculated, buffer, buffer_size - INDEX_FOOTER_SIZE);

	/* Parse header */
	if ((error = read_header(&header, buffer)) < 0)
		return error;

	index->version = header.version;
	if (index->version >= INDEX_VERSION_NUMBER_COMP)
		last = empty;

	seek_forward(INDEX_HEADER_SIZE);

	assert(!index->entries.length);

	if (index->ignore_case)
		git_idxmap_icase_resize((khash_t(idxicase) *) index->entries_map, header.entry_count);
	else
		git_idxmap_resize(index->entries_map, header.entry_count);

 	/* Parse all the entries */
 	for (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {
 		git_index_entry *entry = NULL;
		size_t entry_size;
 
		if ((error = read_entry(&entry, &entry_size, index, buffer, buffer_size, last)) < 0) {
 			error = index_error_invalid(""invalid entry"");
 			goto done;
 		}

		if ((error = git_vector_insert(&index->entries, entry)) < 0) {
			index_entry_free(entry);
			goto done;
		}

		INSERT_IN_MAP(index, entry, &error);

		if (error < 0) {
			index_entry_free(entry);
			goto done;
		}
		error = 0;

		if (index->version >= INDEX_VERSION_NUMBER_COMP)
			last = entry->path;

		seek_forward(entry_size);
	}

	if (i != header.entry_count) {
		error = index_error_invalid(""header entries changed while parsing"");
		goto done;
	}

	/* There's still space for some extensions! */
	while (buffer_size > INDEX_FOOTER_SIZE) {
		size_t extension_size;

		extension_size = read_extension(index, buffer, buffer_size);

		/* see if we have read any bytes from the extension */
		if (extension_size == 0) {
			error = index_error_invalid(""extension is truncated"");
			goto done;
		}

		seek_forward(extension_size);
	}

	if (buffer_size != INDEX_FOOTER_SIZE) {
		error = index_error_invalid(
			""buffer size does not match index footer size"");
		goto done;
	}

	/* 160-bit SHA-1 over the content of the index file before this checksum. */
	git_oid_fromraw(&checksum_expected, (const unsigned char *)buffer);

	if (git_oid__cmp(&checksum_calculated, &checksum_expected) != 0) {
		error = index_error_invalid(
			""calculated checksum does not match expected"");
		goto done;
	}

	git_oid_cpy(&index->checksum, &checksum_calculated);

#undef seek_forward

	/* Entries are stored case-sensitively on disk, so re-sort now if
	 * in-memory index is supposed to be case-insensitive
	 */
	git_vector_set_sorted(&index->entries, !index->ignore_case);
	git_vector_sort(&index->entries);

done:
	return error;
}
","static int parse_index(git_index *index, const char *buffer, size_t buffer_size)
{
	int error = 0;
	unsigned int i;
	struct index_header header = { 0 };
	git_oid checksum_calculated, checksum_expected;
	const char *last = NULL;
	const char *empty = """";

#define seek_forward(_increase) { \
	if (_increase >= buffer_size) { \
		error = index_error_invalid(""ran out of data while parsing""); \
		goto done; } \
	buffer += _increase; \
	buffer_size -= _increase;\
}

	if (buffer_size < INDEX_HEADER_SIZE + INDEX_FOOTER_SIZE)
		return index_error_invalid(""insufficient buffer space"");

	/* Precalculate the SHA1 of the files's contents -- we'll match it to
	 * the provided SHA1 in the footer */
	git_hash_buf(&checksum_calculated, buffer, buffer_size - INDEX_FOOTER_SIZE);

	/* Parse header */
	if ((error = read_header(&header, buffer)) < 0)
		return error;

	index->version = header.version;
	if (index->version >= INDEX_VERSION_NUMBER_COMP)
		last = empty;

	seek_forward(INDEX_HEADER_SIZE);

	assert(!index->entries.length);

	if (index->ignore_case)
		git_idxmap_icase_resize((khash_t(idxicase) *) index->entries_map, header.entry_count);
	else
		git_idxmap_resize(index->entries_map, header.entry_count);

 	/* Parse all the entries */
 	for (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {
 		git_index_entry *entry = NULL;
		size_t entry_size = read_entry(&entry, index, buffer, buffer_size, last);
 
		/* 0 bytes read means an object corruption */
		if (entry_size == 0) {
 			error = index_error_invalid(""invalid entry"");
 			goto done;
 		}

		if ((error = git_vector_insert(&index->entries, entry)) < 0) {
			index_entry_free(entry);
			goto done;
		}

		INSERT_IN_MAP(index, entry, &error);

		if (error < 0) {
			index_entry_free(entry);
			goto done;
		}
		error = 0;

		if (index->version >= INDEX_VERSION_NUMBER_COMP)
			last = entry->path;

		seek_forward(entry_size);
	}

	if (i != header.entry_count) {
		error = index_error_invalid(""header entries changed while parsing"");
		goto done;
	}

	/* There's still space for some extensions! */
	while (buffer_size > INDEX_FOOTER_SIZE) {
		size_t extension_size;

		extension_size = read_extension(index, buffer, buffer_size);

		/* see if we have read any bytes from the extension */
		if (extension_size == 0) {
			error = index_error_invalid(""extension is truncated"");
			goto done;
		}

		seek_forward(extension_size);
	}

	if (buffer_size != INDEX_FOOTER_SIZE) {
		error = index_error_invalid(
			""buffer size does not match index footer size"");
		goto done;
	}

	/* 160-bit SHA-1 over the content of the index file before this checksum. */
	git_oid_fromraw(&checksum_expected, (const unsigned char *)buffer);

	if (git_oid__cmp(&checksum_calculated, &checksum_expected) != 0) {
		error = index_error_invalid(
			""calculated checksum does not match expected"");
		goto done;
	}

	git_oid_cpy(&index->checksum, &checksum_calculated);

#undef seek_forward

	/* Entries are stored case-sensitively on disk, so re-sort now if
	 * in-memory index is supposed to be case-insensitive
	 */
	git_vector_set_sorted(&index->entries, !index->ignore_case);
	git_vector_sort(&index->entries);

done:
	return error;
}
",C,"		size_t entry_size;
		if ((error = read_entry(&entry, &entry_size, index, buffer, buffer_size, last)) < 0) {
","		size_t entry_size = read_entry(&entry, index, buffer, buffer_size, last);
		/* 0 bytes read means an object corruption */
		if (entry_size == 0) {
",,"@@ -2299,8 +2299,9 @@ static size_t index_entry_size(size_t path_len, size_t varint_len, uint32_t flag
 	}
 }
 
-static size_t read_entry(
+static int read_entry(
 	git_index_entry **out,
+	size_t *out_size,
 	git_index *index,
 	const void *buffer,
 	size_t buffer_size,
@@ -2314,7 +2315,7 @@ static size_t read_entry(
 	char *tmp_path = NULL;
 
 	if (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)
-		return 0;
+		return -1;
 
 	/* buffer is not guaranteed to be aligned */
 	memcpy(&source, buffer, sizeof(struct entry_short));
@@ -2356,7 +2357,7 @@ static size_t read_entry(
 
 			path_end = memchr(path_ptr, '\0', buffer_size);
 			if (path_end == NULL)
-				return 0;
+				return -1;
 
 			path_length = path_end - path_ptr;
 		}
@@ -2386,16 +2387,20 @@ static size_t read_entry(
 		entry.path = tmp_path;
 	}
 
+	if (entry_size == 0)
+		return -1;
+
 	if (INDEX_FOOTER_SIZE + entry_size > buffer_size)
-		return 0;
+		return -1;
 
 	if (index_entry_dup(out, index, &entry) < 0) {
 		git__free(tmp_path);
-		return 0;
+		return -1;
 	}
 
 	git__free(tmp_path);
-	return entry_size;
+	*out_size = entry_size;
+	return 0;
 }
 
 static int read_header(struct index_header *dest, const void *buffer)
@@ -2499,10 +2504,9 @@ static int parse_index(git_index *index, const char *buffer, size_t buffer_size)
 	/* Parse all the entries */
 	for (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {
 		git_index_entry *entry = NULL;
-		size_t entry_size = read_entry(&entry, index, buffer, buffer_size, last);
+		size_t entry_size;
 
-		/* 0 bytes read means an object corruption */
-		if (entry_size == 0) {
+		if ((error = read_entry(&entry, &entry_size, index, buffer, buffer_size, last)) < 0) {
 			error = index_error_invalid(""invalid entry"");
 			goto done;
 		}",libgit2,58a6fe94cb851f71214dbefac3f9bffee437d6fe,d11c4a1a464f10c69d5cc58824e980ea5045d439,1,"static int parse_index(git_index *index, const char *buffer, size_t buffer_size)
{
	int error = 0;
	unsigned int i;
	struct index_header header = { 0 };
	git_oid checksum_calculated, checksum_expected;
	const char *last = NULL;
	const char *empty = """";

#define seek_forward(_increase) { \
	if (_increase >= buffer_size) { \
		error = index_error_invalid(""ran out of data while parsing""); \
		goto done; } \
	buffer += _increase; \
	buffer_size -= _increase;\
}

	if (buffer_size < INDEX_HEADER_SIZE + INDEX_FOOTER_SIZE)
		return index_error_invalid(""insufficient buffer space"");

	/* Precalculate the SHA1 of the files's contents -- we'll match it to
	 * the provided SHA1 in the footer */
	git_hash_buf(&checksum_calculated, buffer, buffer_size - INDEX_FOOTER_SIZE);

	/* Parse header */
	if ((error = read_header(&header, buffer)) < 0)
		return error;

	index->version = header.version;
	if (index->version >= INDEX_VERSION_NUMBER_COMP)
		last = empty;

	seek_forward(INDEX_HEADER_SIZE);

	assert(!index->entries.length);

	if (index->ignore_case)
		git_idxmap_icase_resize((khash_t(idxicase) *) index->entries_map, header.entry_count);
	else
		git_idxmap_resize(index->entries_map, header.entry_count);

 	/* Parse all the entries */
 	for (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {
 		git_index_entry *entry = NULL;
//flaw_line_below:
		size_t entry_size = read_entry(&entry, index, buffer, buffer_size, last);
//fix_flaw_line_below:
//		size_t entry_size;
 
//flaw_line_below:
		/* 0 bytes read means an object corruption */
//flaw_line_below:
		if (entry_size == 0) {
//fix_flaw_line_below:
//		if ((error = read_entry(&entry, &entry_size, index, buffer, buffer_size, last)) < 0) {
 			error = index_error_invalid(""invalid entry"");
 			goto done;
 		}

		if ((error = git_vector_insert(&index->entries, entry)) < 0) {
			index_entry_free(entry);
			goto done;
		}

		INSERT_IN_MAP(index, entry, &error);

		if (error < 0) {
			index_entry_free(entry);
			goto done;
		}
		error = 0;

		if (index->version >= INDEX_VERSION_NUMBER_COMP)
			last = entry->path;

		seek_forward(entry_size);
	}

	if (i != header.entry_count) {
		error = index_error_invalid(""header entries changed while parsing"");
		goto done;
	}

	/* There's still space for some extensions! */
	while (buffer_size > INDEX_FOOTER_SIZE) {
		size_t extension_size;

		extension_size = read_extension(index, buffer, buffer_size);

		/* see if we have read any bytes from the extension */
		if (extension_size == 0) {
			error = index_error_invalid(""extension is truncated"");
			goto done;
		}

		seek_forward(extension_size);
	}

	if (buffer_size != INDEX_FOOTER_SIZE) {
		error = index_error_invalid(
			""buffer size does not match index footer size"");
		goto done;
	}

	/* 160-bit SHA-1 over the content of the index file before this checksum. */
	git_oid_fromraw(&checksum_expected, (const unsigned char *)buffer);

	if (git_oid__cmp(&checksum_calculated, &checksum_expected) != 0) {
		error = index_error_invalid(
			""calculated checksum does not match expected"");
		goto done;
	}

	git_oid_cpy(&index->checksum, &checksum_calculated);

#undef seek_forward

	/* Entries are stored case-sensitively on disk, so re-sort now if
	 * in-memory index is supposed to be case-insensitive
	 */
	git_vector_set_sorted(&index->entries, !index->ignore_case);
	git_vector_sort(&index->entries);

done:
	return error;
}
"
4736,182472,,Remote,Not required,Partial,CVE-2018-8099,https://www.cvedetails.com/cve/CVE-2018-8099/,CWE-415,Medium,,,,2018-03-13,4.3,"Incorrect returning of an error code in the index.c:read_entry() function leads to a double free in libgit2 before v0.26.2, which allows an attacker to cause a denial of service via a crafted repository index file.",2018-04-13,DoS ,11,https://github.com/libgit2/libgit2/commit/58a6fe94cb851f71214dbefac3f9bffee437d6fe,58a6fe94cb851f71214dbefac3f9bffee437d6fe,"index: convert `read_entry` to return entry size via an out-param

The function `read_entry` does not conform to our usual coding style of
returning stuff via the out parameter and to use the return value for
reporting errors. Due to most of our code conforming to that pattern, it
has become quite natural for us to actually return `-1` in case there is
any error, which has also slipped in with commit 5625d86b9 (index:
support index v4, 2016-05-17). As the function returns an `size_t` only,
though, the return value is wrapped around, causing the caller of
`read_tree` to continue with an invalid index entry. Ultimately, this
can lead to a double-free.

Improve code and fix the bug by converting the function to return the
index entry size via an out parameter and only using the return value to
indicate errors.

Reported-by: Krishna Ram Prakash R <krp@gtux.in>
Reported-by: Vivek Parikh <viv0411.parikh@gmail.com>",5,src/index.c,"{""sha"": ""3ef892b7f170b1fdad356de32061652d7f97c48a"", ""filename"": ""src/index.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 9, ""changes"": 22, ""blob_url"": ""https://github.com/libgit2/libgit2/blob/58a6fe94cb851f71214dbefac3f9bffee437d6fe/src/index.c"", ""raw_url"": ""https://github.com/libgit2/libgit2/raw/58a6fe94cb851f71214dbefac3f9bffee437d6fe/src/index.c"", ""contents_url"": ""https://api.github.com/repos/libgit2/libgit2/contents/src/index.c?ref=58a6fe94cb851f71214dbefac3f9bffee437d6fe"", ""patch"": ""@@ -2299,8 +2299,9 @@ static size_t index_entry_size(size_t path_len, size_t varint_len, uint32_t flag\n \t}\n }\n \n-static size_t read_entry(\n+static int read_entry(\n \tgit_index_entry **out,\n+\tsize_t *out_size,\n \tgit_index *index,\n \tconst void *buffer,\n \tsize_t buffer_size,\n@@ -2314,7 +2315,7 @@ static size_t read_entry(\n \tchar *tmp_path = NULL;\n \n \tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n-\t\treturn 0;\n+\t\treturn -1;\n \n \t/* buffer is not guaranteed to be aligned */\n \tmemcpy(&source, buffer, sizeof(struct entry_short));\n@@ -2356,7 +2357,7 @@ static size_t read_entry(\n \n \t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n \t\t\tif (path_end == NULL)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn -1;\n \n \t\t\tpath_length = path_end - path_ptr;\n \t\t}\n@@ -2386,16 +2387,20 @@ static size_t read_entry(\n \t\tentry.path = tmp_path;\n \t}\n \n+\tif (entry_size == 0)\n+\t\treturn -1;\n+\n \tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n-\t\treturn 0;\n+\t\treturn -1;\n \n \tif (index_entry_dup(out, index, &entry) < 0) {\n \t\tgit__free(tmp_path);\n-\t\treturn 0;\n+\t\treturn -1;\n \t}\n \n \tgit__free(tmp_path);\n-\treturn entry_size;\n+\t*out_size = entry_size;\n+\treturn 0;\n }\n \n static int read_header(struct index_header *dest, const void *buffer)\n@@ -2499,10 +2504,9 @@ static int parse_index(git_index *index, const char *buffer, size_t buffer_size)\n \t/* Parse all the entries */\n \tfor (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {\n \t\tgit_index_entry *entry = NULL;\n-\t\tsize_t entry_size = read_entry(&entry, index, buffer, buffer_size, last);\n+\t\tsize_t entry_size;\n \n-\t\t/* 0 bytes read means an object corruption */\n-\t\tif (entry_size == 0) {\n+\t\tif ((error = read_entry(&entry, &entry_size, index, buffer, buffer_size, last)) < 0) {\n \t\t\terror = index_error_invalid(\""invalid entry\"");\n \t\t\tgoto done;\n \t\t}""}","static size_t read_entry(
static int read_entry(
 	git_index_entry **out,
	size_t *out_size,
 	git_index *index,
 	const void *buffer,
 	size_t buffer_size,
	const char *last)
{
	size_t path_length, entry_size;
	const char *path_ptr;
	struct entry_short source;
	git_index_entry entry = {{0}};
	bool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;
 	char *tmp_path = NULL;
 
 	if (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)
		return -1;
 
 	/* buffer is not guaranteed to be aligned */
 	memcpy(&source, buffer, sizeof(struct entry_short));

	entry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);
	entry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);
	entry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);
	entry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);
	entry.dev = ntohl(source.dev);
	entry.ino = ntohl(source.ino);
	entry.mode = ntohl(source.mode);
	entry.uid = ntohl(source.uid);
	entry.gid = ntohl(source.gid);
	entry.file_size = ntohl(source.file_size);
	git_oid_cpy(&entry.id, &source.oid);
	entry.flags = ntohs(source.flags);

	if (entry.flags & GIT_IDXENTRY_EXTENDED) {
		uint16_t flags_raw;
		size_t flags_offset;

		flags_offset = offsetof(struct entry_long, flags_extended);
		memcpy(&flags_raw, (const char *) buffer + flags_offset,
			sizeof(flags_raw));
		flags_raw = ntohs(flags_raw);

		memcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));
		path_ptr = (const char *) buffer + offsetof(struct entry_long, path);
	} else
		path_ptr = (const char *) buffer + offsetof(struct entry_short, path);

	if (!compressed) {
		path_length = entry.flags & GIT_IDXENTRY_NAMEMASK;

		/* if this is a very long string, we must find its
		 * real length without overflowing */
		if (path_length == 0xFFF) {
			const char *path_end;
 
 			path_end = memchr(path_ptr, '\0', buffer_size);
 			if (path_end == NULL)
				return -1;
 
 			path_length = path_end - path_ptr;
 		}

		entry_size = index_entry_size(path_length, 0, entry.flags);
		entry.path = (char *)path_ptr;
	} else {
		size_t varint_len;
		size_t strip_len = git_decode_varint((const unsigned char *)path_ptr,
						     &varint_len);
		size_t last_len = strlen(last);
		size_t prefix_len = last_len - strip_len;
		size_t suffix_len = strlen(path_ptr + varint_len);
		size_t path_len;

		if (varint_len == 0)
			return index_error_invalid(""incorrect prefix length"");

		GITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);
		GITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);
		tmp_path = git__malloc(path_len);
		GITERR_CHECK_ALLOC(tmp_path);

		memcpy(tmp_path, last, prefix_len);
		memcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);
		entry_size = index_entry_size(suffix_len, varint_len, entry.flags);
 		entry.path = tmp_path;
 	}
 
	if (entry_size == 0)
		return -1;

 	if (INDEX_FOOTER_SIZE + entry_size > buffer_size)
		return -1;
 
 	if (index_entry_dup(out, index, &entry) < 0) {
 		git__free(tmp_path);
		return -1;
 	}
 
 	git__free(tmp_path);
	*out_size = entry_size;
	return 0;
 }
","static size_t read_entry(
 	git_index_entry **out,
 	git_index *index,
 	const void *buffer,
 	size_t buffer_size,
	const char *last)
{
	size_t path_length, entry_size;
	const char *path_ptr;
	struct entry_short source;
	git_index_entry entry = {{0}};
	bool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;
 	char *tmp_path = NULL;
 
 	if (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)
		return 0;
 
 	/* buffer is not guaranteed to be aligned */
 	memcpy(&source, buffer, sizeof(struct entry_short));

	entry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);
	entry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);
	entry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);
	entry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);
	entry.dev = ntohl(source.dev);
	entry.ino = ntohl(source.ino);
	entry.mode = ntohl(source.mode);
	entry.uid = ntohl(source.uid);
	entry.gid = ntohl(source.gid);
	entry.file_size = ntohl(source.file_size);
	git_oid_cpy(&entry.id, &source.oid);
	entry.flags = ntohs(source.flags);

	if (entry.flags & GIT_IDXENTRY_EXTENDED) {
		uint16_t flags_raw;
		size_t flags_offset;

		flags_offset = offsetof(struct entry_long, flags_extended);
		memcpy(&flags_raw, (const char *) buffer + flags_offset,
			sizeof(flags_raw));
		flags_raw = ntohs(flags_raw);

		memcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));
		path_ptr = (const char *) buffer + offsetof(struct entry_long, path);
	} else
		path_ptr = (const char *) buffer + offsetof(struct entry_short, path);

	if (!compressed) {
		path_length = entry.flags & GIT_IDXENTRY_NAMEMASK;

		/* if this is a very long string, we must find its
		 * real length without overflowing */
		if (path_length == 0xFFF) {
			const char *path_end;
 
 			path_end = memchr(path_ptr, '\0', buffer_size);
 			if (path_end == NULL)
				return 0;
 
 			path_length = path_end - path_ptr;
 		}

		entry_size = index_entry_size(path_length, 0, entry.flags);
		entry.path = (char *)path_ptr;
	} else {
		size_t varint_len;
		size_t strip_len = git_decode_varint((const unsigned char *)path_ptr,
						     &varint_len);
		size_t last_len = strlen(last);
		size_t prefix_len = last_len - strip_len;
		size_t suffix_len = strlen(path_ptr + varint_len);
		size_t path_len;

		if (varint_len == 0)
			return index_error_invalid(""incorrect prefix length"");

		GITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);
		GITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);
		tmp_path = git__malloc(path_len);
		GITERR_CHECK_ALLOC(tmp_path);

		memcpy(tmp_path, last, prefix_len);
		memcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);
		entry_size = index_entry_size(suffix_len, varint_len, entry.flags);
 		entry.path = tmp_path;
 	}
 
 	if (INDEX_FOOTER_SIZE + entry_size > buffer_size)
		return 0;
 
 	if (index_entry_dup(out, index, &entry) < 0) {
 		git__free(tmp_path);
		return 0;
 	}
 
 	git__free(tmp_path);
	return entry_size;
 }
",C,"static int read_entry(
	size_t *out_size,
		return -1;
				return -1;
	if (entry_size == 0)
		return -1;

		return -1;
		return -1;
	*out_size = entry_size;
	return 0;
","		return 0;
				return 0;
		return 0;
		return 0;
	return entry_size;
",,"@@ -2299,8 +2299,9 @@ static size_t index_entry_size(size_t path_len, size_t varint_len, uint32_t flag
 	}
 }
 
-static size_t read_entry(
+static int read_entry(
 	git_index_entry **out,
+	size_t *out_size,
 	git_index *index,
 	const void *buffer,
 	size_t buffer_size,
@@ -2314,7 +2315,7 @@ static size_t read_entry(
 	char *tmp_path = NULL;
 
 	if (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)
-		return 0;
+		return -1;
 
 	/* buffer is not guaranteed to be aligned */
 	memcpy(&source, buffer, sizeof(struct entry_short));
@@ -2356,7 +2357,7 @@ static size_t read_entry(
 
 			path_end = memchr(path_ptr, '\0', buffer_size);
 			if (path_end == NULL)
-				return 0;
+				return -1;
 
 			path_length = path_end - path_ptr;
 		}
@@ -2386,16 +2387,20 @@ static size_t read_entry(
 		entry.path = tmp_path;
 	}
 
+	if (entry_size == 0)
+		return -1;
+
 	if (INDEX_FOOTER_SIZE + entry_size > buffer_size)
-		return 0;
+		return -1;
 
 	if (index_entry_dup(out, index, &entry) < 0) {
 		git__free(tmp_path);
-		return 0;
+		return -1;
 	}
 
 	git__free(tmp_path);
-	return entry_size;
+	*out_size = entry_size;
+	return 0;
 }
 
 static int read_header(struct index_header *dest, const void *buffer)
@@ -2499,10 +2504,9 @@ static int parse_index(git_index *index, const char *buffer, size_t buffer_size)
 	/* Parse all the entries */
 	for (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {
 		git_index_entry *entry = NULL;
-		size_t entry_size = read_entry(&entry, index, buffer, buffer_size, last);
+		size_t entry_size;
 
-		/* 0 bytes read means an object corruption */
-		if (entry_size == 0) {
+		if ((error = read_entry(&entry, &entry_size, index, buffer, buffer_size, last)) < 0) {
 			error = index_error_invalid(""invalid entry"");
 			goto done;
 		}",libgit2,58a6fe94cb851f71214dbefac3f9bffee437d6fe,d11c4a1a464f10c69d5cc58824e980ea5045d439,1,"static size_t read_entry(
//fix_flaw_line_below:
//static int read_entry(
 	git_index_entry **out,
//fix_flaw_line_below:
//	size_t *out_size,
 	git_index *index,
 	const void *buffer,
 	size_t buffer_size,
	const char *last)
{
	size_t path_length, entry_size;
	const char *path_ptr;
	struct entry_short source;
	git_index_entry entry = {{0}};
	bool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;
 	char *tmp_path = NULL;
 
 	if (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)
//flaw_line_below:
		return 0;
//fix_flaw_line_below:
//		return -1;
 
 	/* buffer is not guaranteed to be aligned */
 	memcpy(&source, buffer, sizeof(struct entry_short));

	entry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);
	entry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);
	entry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);
	entry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);
	entry.dev = ntohl(source.dev);
	entry.ino = ntohl(source.ino);
	entry.mode = ntohl(source.mode);
	entry.uid = ntohl(source.uid);
	entry.gid = ntohl(source.gid);
	entry.file_size = ntohl(source.file_size);
	git_oid_cpy(&entry.id, &source.oid);
	entry.flags = ntohs(source.flags);

	if (entry.flags & GIT_IDXENTRY_EXTENDED) {
		uint16_t flags_raw;
		size_t flags_offset;

		flags_offset = offsetof(struct entry_long, flags_extended);
		memcpy(&flags_raw, (const char *) buffer + flags_offset,
			sizeof(flags_raw));
		flags_raw = ntohs(flags_raw);

		memcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));
		path_ptr = (const char *) buffer + offsetof(struct entry_long, path);
	} else
		path_ptr = (const char *) buffer + offsetof(struct entry_short, path);

	if (!compressed) {
		path_length = entry.flags & GIT_IDXENTRY_NAMEMASK;

		/* if this is a very long string, we must find its
		 * real length without overflowing */
		if (path_length == 0xFFF) {
			const char *path_end;
 
 			path_end = memchr(path_ptr, '\0', buffer_size);
 			if (path_end == NULL)
//flaw_line_below:
				return 0;
//fix_flaw_line_below:
//				return -1;
 
 			path_length = path_end - path_ptr;
 		}

		entry_size = index_entry_size(path_length, 0, entry.flags);
		entry.path = (char *)path_ptr;
	} else {
		size_t varint_len;
		size_t strip_len = git_decode_varint((const unsigned char *)path_ptr,
						     &varint_len);
		size_t last_len = strlen(last);
		size_t prefix_len = last_len - strip_len;
		size_t suffix_len = strlen(path_ptr + varint_len);
		size_t path_len;

		if (varint_len == 0)
			return index_error_invalid(""incorrect prefix length"");

		GITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);
		GITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);
		tmp_path = git__malloc(path_len);
		GITERR_CHECK_ALLOC(tmp_path);

		memcpy(tmp_path, last, prefix_len);
		memcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);
		entry_size = index_entry_size(suffix_len, varint_len, entry.flags);
 		entry.path = tmp_path;
 	}
 
//fix_flaw_line_below:
//	if (entry_size == 0)
//fix_flaw_line_below:
//		return -1;
//fix_flaw_line_below:
//
 	if (INDEX_FOOTER_SIZE + entry_size > buffer_size)
//flaw_line_below:
		return 0;
//fix_flaw_line_below:
//		return -1;
 
 	if (index_entry_dup(out, index, &entry) < 0) {
 		git__free(tmp_path);
//flaw_line_below:
		return 0;
//fix_flaw_line_below:
//		return -1;
 	}
 
 	git__free(tmp_path);
//flaw_line_below:
	return entry_size;
//fix_flaw_line_below:
//	*out_size = entry_size;
//fix_flaw_line_below:
//	return 0;
 }
"
4754,182490,,Local,Not required,Complete,CVE-2018-7480,https://www.cvedetails.com/cve/CVE-2018-7480/,CWE-415,Low,Complete,Complete,,2018-02-25,7.2,The blkcg_init_queue function in block/blk-cgroup.c in the Linux kernel before 4.11 allows local users to cause a denial of service (double free) or possibly have unspecified other impact by triggering a creation failure.,2018-05-23,DoS ,1,https://github.com/torvalds/linux/commit/9b54d816e00425c3a517514e0d677bb3cec49258,9b54d816e00425c3a517514e0d677bb3cec49258,"blkcg: fix double free of new_blkg in blkcg_init_queue

If blkg_create fails, new_blkg passed as an argument will
be freed by blkg_create, so there is no need to free it again.

Signed-off-by: Hou Tao <houtao1@huawei.com>
Signed-off-by: Jens Axboe <axboe@fb.com>",3,block/blk-cgroup.c,"{""sha"": ""295e98c2c8ccdf7c86515306157d620c83052119"", ""filename"": ""block/blk-cgroup.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/9b54d816e00425c3a517514e0d677bb3cec49258/block/blk-cgroup.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9b54d816e00425c3a517514e0d677bb3cec49258/block/blk-cgroup.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/block/blk-cgroup.c?ref=9b54d816e00425c3a517514e0d677bb3cec49258"", ""patch"": ""@@ -1079,10 +1079,8 @@ int blkcg_init_queue(struct request_queue *q)\n \tif (preloaded)\n \t\tradix_tree_preload_end();\n \n-\tif (IS_ERR(blkg)) {\n-\t\tblkg_free(new_blkg);\n+\tif (IS_ERR(blkg))\n \t\treturn PTR_ERR(blkg);\n-\t}\n \n \tq->root_blkg = blkg;\n \tq->root_rl.blkg = blkg;""}","int blkcg_init_queue(struct request_queue *q)
{
	struct blkcg_gq *new_blkg, *blkg;
	bool preloaded;
	int ret;

	new_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);
	if (!new_blkg)
		return -ENOMEM;

	preloaded = !radix_tree_preload(GFP_KERNEL);

	/*
	 * Make sure the root blkg exists and count the existing blkgs.  As
	 * @q is bypassing at this point, blkg_lookup_create() can't be
	 * used.  Open code insertion.
	 */
	rcu_read_lock();
	spin_lock_irq(q->queue_lock);
	blkg = blkg_create(&blkcg_root, q, new_blkg);
	spin_unlock_irq(q->queue_lock);
	rcu_read_unlock();

 	if (preloaded)
 		radix_tree_preload_end();
 
	if (IS_ERR(blkg))
 		return PTR_ERR(blkg);
 
 	q->root_blkg = blkg;
 	q->root_rl.blkg = blkg;

	ret = blk_throtl_init(q);
	if (ret) {
		spin_lock_irq(q->queue_lock);
		blkg_destroy_all(q);
		spin_unlock_irq(q->queue_lock);
	}
	return ret;
}
","int blkcg_init_queue(struct request_queue *q)
{
	struct blkcg_gq *new_blkg, *blkg;
	bool preloaded;
	int ret;

	new_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);
	if (!new_blkg)
		return -ENOMEM;

	preloaded = !radix_tree_preload(GFP_KERNEL);

	/*
	 * Make sure the root blkg exists and count the existing blkgs.  As
	 * @q is bypassing at this point, blkg_lookup_create() can't be
	 * used.  Open code insertion.
	 */
	rcu_read_lock();
	spin_lock_irq(q->queue_lock);
	blkg = blkg_create(&blkcg_root, q, new_blkg);
	spin_unlock_irq(q->queue_lock);
	rcu_read_unlock();

 	if (preloaded)
 		radix_tree_preload_end();
 
	if (IS_ERR(blkg)) {
		blkg_free(new_blkg);
 		return PTR_ERR(blkg);
	}
 
 	q->root_blkg = blkg;
 	q->root_rl.blkg = blkg;

	ret = blk_throtl_init(q);
	if (ret) {
		spin_lock_irq(q->queue_lock);
		blkg_destroy_all(q);
		spin_unlock_irq(q->queue_lock);
	}
	return ret;
}
",C,"	if (IS_ERR(blkg))
","	if (IS_ERR(blkg)) {
		blkg_free(new_blkg);
	}
",,"@@ -1079,10 +1079,8 @@ int blkcg_init_queue(struct request_queue *q)
 	if (preloaded)
 		radix_tree_preload_end();
 
-	if (IS_ERR(blkg)) {
-		blkg_free(new_blkg);
+	if (IS_ERR(blkg))
 		return PTR_ERR(blkg);
-	}
 
 	q->root_blkg = blkg;
 	q->root_rl.blkg = blkg;",linux,9b54d816e00425c3a517514e0d677bb3cec49258,0cacba6cf8252438f8166bd3fa1c3370dd28a769,1,"int blkcg_init_queue(struct request_queue *q)
{
	struct blkcg_gq *new_blkg, *blkg;
	bool preloaded;
	int ret;

	new_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);
	if (!new_blkg)
		return -ENOMEM;

	preloaded = !radix_tree_preload(GFP_KERNEL);

	/*
	 * Make sure the root blkg exists and count the existing blkgs.  As
	 * @q is bypassing at this point, blkg_lookup_create() can't be
	 * used.  Open code insertion.
	 */
	rcu_read_lock();
	spin_lock_irq(q->queue_lock);
	blkg = blkg_create(&blkcg_root, q, new_blkg);
	spin_unlock_irq(q->queue_lock);
	rcu_read_unlock();

 	if (preloaded)
 		radix_tree_preload_end();
 
//flaw_line_below:
	if (IS_ERR(blkg)) {
//flaw_line_below:
		blkg_free(new_blkg);
//fix_flaw_line_below:
//	if (IS_ERR(blkg))
 		return PTR_ERR(blkg);
//flaw_line_below:
	}
 
 	q->root_blkg = blkg;
 	q->root_rl.blkg = blkg;

	ret = blk_throtl_init(q);
	if (ret) {
		spin_lock_irq(q->queue_lock);
		blkg_destroy_all(q);
		spin_unlock_irq(q->queue_lock);
	}
	return ret;
}
"
4855,182591,,Remote,Not required,Partial,CVE-2017-18174,https://www.cvedetails.com/cve/CVE-2017-18174/,CWE-415,Low,Partial,Partial,,2018-02-11,7.5,"In the Linux kernel before 4.7, the amd_gpio_remove function in drivers/pinctrl/pinctrl-amd.c calls the pinctrl_unregister function, leading to a double free.",2018-12-21,,0,https://github.com/torvalds/linux/commit/8dca4a41f1ad65043a78c2338d9725f859c8d2c3,8dca4a41f1ad65043a78c2338d9725f859c8d2c3,"pinctrl/amd: Drop pinctrl_unregister for devm_ registered device

It's not necessary to unregister pin controller device registered
with devm_pinctrl_register() and using pinctrl_unregister() leads
to a double free.

Fixes: 3bfd44306c65 (""pinctrl: amd: Add support for additional GPIO"")
Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
Signed-off-by: Linus Walleij <linus.walleij@linaro.org>",1,drivers/pinctrl/pinctrl-amd.c,"{""sha"": ""6b75bd2b71db38136fa80008817139c7250ea3a4"", ""filename"": ""drivers/pinctrl/pinctrl-amd.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/8dca4a41f1ad65043a78c2338d9725f859c8d2c3/drivers/pinctrl/pinctrl-amd.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8dca4a41f1ad65043a78c2338d9725f859c8d2c3/drivers/pinctrl/pinctrl-amd.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/pinctrl/pinctrl-amd.c?ref=8dca4a41f1ad65043a78c2338d9725f859c8d2c3"", ""patch"": ""@@ -836,7 +836,6 @@ static int amd_gpio_remove(struct platform_device *pdev)\n \tgpio_dev = platform_get_drvdata(pdev);\n \n \tgpiochip_remove(&gpio_dev->gc);\n-\tpinctrl_unregister(gpio_dev->pctrl);\n \n \treturn 0;\n }""}","static int amd_gpio_remove(struct platform_device *pdev)
{
	struct amd_gpio *gpio_dev;

 	gpio_dev = platform_get_drvdata(pdev);
 
 	gpiochip_remove(&gpio_dev->gc);
 
 	return 0;
 }
","static int amd_gpio_remove(struct platform_device *pdev)
{
	struct amd_gpio *gpio_dev;

 	gpio_dev = platform_get_drvdata(pdev);
 
 	gpiochip_remove(&gpio_dev->gc);
	pinctrl_unregister(gpio_dev->pctrl);
 
 	return 0;
 }
",C,,"	pinctrl_unregister(gpio_dev->pctrl);
",,"@@ -836,7 +836,6 @@ static int amd_gpio_remove(struct platform_device *pdev)
 	gpio_dev = platform_get_drvdata(pdev);
 
 	gpiochip_remove(&gpio_dev->gc);
-	pinctrl_unregister(gpio_dev->pctrl);
 
 	return 0;
 }",linux,8dca4a41f1ad65043a78c2338d9725f859c8d2c3,1fe8d6cbfb47deff69e6fad2a33c044ac745679c,1,"static int amd_gpio_remove(struct platform_device *pdev)
{
	struct amd_gpio *gpio_dev;

 	gpio_dev = platform_get_drvdata(pdev);
 
 	gpiochip_remove(&gpio_dev->gc);
//flaw_line_below:
	pinctrl_unregister(gpio_dev->pctrl);
 
 	return 0;
 }
"
4856,182592,,Remote,Not required,Partial,CVE-2017-18120,https://www.cvedetails.com/cve/CVE-2017-18120/,CWE-415,Medium,Partial,Partial,,2018-02-02,6.8,"A double-free bug in the read_gif function in gifread.c in gifsicle 1.90 allows a remote attacker to cause a denial-of-service attack or unspecified other impact via a maliciously crafted file, because last_name is mishandled, a different vulnerability than CVE-2017-1000421.",2018-02-14,,1,https://github.com/kohler/gifsicle/commit/118a46090c50829dc543179019e6140e1235f909,118a46090c50829dc543179019e6140e1235f909,"gif_read: Set last_name = NULL unconditionally.

With a non-malicious GIF, last_name is set to NULL when a name
extension is followed by an image. Reported in #117, via
Debian, via a KAIST fuzzing program.",0,src/gifread.c,"{""sha"": ""9c287dd58bddead5f9b844cf5e915855aa8654e0"", ""filename"": ""src/gifread.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/kohler/gifsicle/blob/118a46090c50829dc543179019e6140e1235f909/src/gifread.c"", ""raw_url"": ""https://github.com/kohler/gifsicle/raw/118a46090c50829dc543179019e6140e1235f909/src/gifread.c"", ""contents_url"": ""https://api.github.com/repos/kohler/gifsicle/contents/src/gifread.c?ref=118a46090c50829dc543179019e6140e1235f909"", ""patch"": ""@@ -900,6 +900,7 @@ read_gif(Gif_Reader *grr, int read_flags,\n   Gif_DeleteArray(gfc.suffix);\n   Gif_DeleteArray(gfc.length);\n   gfc.gfi = 0;\n+  last_name = 0;\n \n   if (gfs)\n     gfs->errors = gfc.errors[1];""}","read_gif(Gif_Reader *grr, int read_flags,
	 const char* landmark, Gif_ReadErrorHandler handler)
{
  Gif_Stream *gfs;
  Gif_Image *gfi;
  Gif_Context gfc;
  int unknown_block_type = 0;

  if (gifgetc(grr) != 'G' ||
      gifgetc(grr) != 'I' ||
      gifgetc(grr) != 'F')
    return 0;
  (void)gifgetc(grr);
  (void)gifgetc(grr);
  (void)gifgetc(grr);

  gfs = Gif_NewStream();
  gfi = Gif_NewImage();

  gfc.stream = gfs;
  gfc.prefix = Gif_NewArray(Gif_Code, GIF_MAX_CODE);
  gfc.suffix = Gif_NewArray(uint8_t, GIF_MAX_CODE);
  gfc.length = Gif_NewArray(uint16_t, GIF_MAX_CODE);
  gfc.handler = handler;
  gfc.gfi = gfi;
  gfc.errors[0] = gfc.errors[1] = 0;

  if (!gfs || !gfi || !gfc.prefix || !gfc.suffix || !gfc.length)
    goto done;
  gfs->landmark = landmark;

  GIF_DEBUG((""\nGIF ""));
  if (!read_logical_screen_descriptor(gfs, grr))
    goto done;
  GIF_DEBUG((""logscrdesc ""));

  while (!gifeof(grr)) {

    uint8_t block = gifgetbyte(grr);

    switch (block) {

     case ',': /* image block */
      GIF_DEBUG((""imageread %d "", gfs->nimages));

      gfi->identifier = last_name;
      last_name = 0;
      if (!Gif_AddImage(gfs, gfi))
          goto done;
      else if (!read_image(grr, &gfc, gfi, read_flags)) {
          Gif_RemoveImage(gfs, gfs->nimages - 1);
          gfi = 0;
          goto done;
      }

      gfc.gfi = gfi = Gif_NewImage();
      if (!gfi)
          goto done;
      break;

     case ';': /* terminator */
      GIF_DEBUG((""term\n""));
      goto done;

     case '!': /* extension */
      block = gifgetbyte(grr);
      GIF_DEBUG((""ext(0x%02X) "", block));
      switch (block) {

       case 0xF9:
	read_graphic_control_extension(&gfc, gfi, grr);
	break;

       case 0xCE:
	last_name = suck_data(last_name, 0, grr);
	break;

       case 0xFE:
	if (!read_comment_extension(gfi, grr)) goto done;
	break;

       case 0xFF:
	read_application_extension(&gfc, grr);
	break;

       default:
        read_unknown_extension(&gfc, grr, block, 0, 0);
	break;

      }
      break;

     default:
       if (!unknown_block_type) {
	 char buf[256];
	 sprintf(buf, ""unknown block type %d at file offset %u"", block, grr->pos - 1);
	 gif_read_error(&gfc, 1, buf);
	 unknown_block_type = 1;
       }
       break;

    }

  }

 done:

  /* Move comments and extensions after last image into stream. */
  if (gfs && gfi) {
      Gif_Extension* gfex;
      gfs->end_comment = gfi->comment;
      gfi->comment = 0;
      gfs->end_extension_list = gfi->extension_list;
      gfi->extension_list = 0;
      for (gfex = gfs->end_extension_list; gfex; gfex = gfex->next)
          gfex->image = NULL;
  }

  Gif_DeleteImage(gfi);
  Gif_DeleteArray(last_name);
  Gif_DeleteArray(gfc.prefix);
   Gif_DeleteArray(gfc.suffix);
   Gif_DeleteArray(gfc.length);
   gfc.gfi = 0;
  last_name = 0;
 
   if (gfs)
     gfs->errors = gfc.errors[1];
  if (gfs && gfc.errors[1] == 0
      && !(read_flags & GIF_READ_TRAILING_GARBAGE_OK)
      && !grr->eofer(grr))
      gif_read_error(&gfc, 0, ""trailing garbage after GIF ignored"");
  /* finally, export last message */
  gif_read_error(&gfc, -1, 0);

  return gfs;
}
","read_gif(Gif_Reader *grr, int read_flags,
	 const char* landmark, Gif_ReadErrorHandler handler)
{
  Gif_Stream *gfs;
  Gif_Image *gfi;
  Gif_Context gfc;
  int unknown_block_type = 0;

  if (gifgetc(grr) != 'G' ||
      gifgetc(grr) != 'I' ||
      gifgetc(grr) != 'F')
    return 0;
  (void)gifgetc(grr);
  (void)gifgetc(grr);
  (void)gifgetc(grr);

  gfs = Gif_NewStream();
  gfi = Gif_NewImage();

  gfc.stream = gfs;
  gfc.prefix = Gif_NewArray(Gif_Code, GIF_MAX_CODE);
  gfc.suffix = Gif_NewArray(uint8_t, GIF_MAX_CODE);
  gfc.length = Gif_NewArray(uint16_t, GIF_MAX_CODE);
  gfc.handler = handler;
  gfc.gfi = gfi;
  gfc.errors[0] = gfc.errors[1] = 0;

  if (!gfs || !gfi || !gfc.prefix || !gfc.suffix || !gfc.length)
    goto done;
  gfs->landmark = landmark;

  GIF_DEBUG((""\nGIF ""));
  if (!read_logical_screen_descriptor(gfs, grr))
    goto done;
  GIF_DEBUG((""logscrdesc ""));

  while (!gifeof(grr)) {

    uint8_t block = gifgetbyte(grr);

    switch (block) {

     case ',': /* image block */
      GIF_DEBUG((""imageread %d "", gfs->nimages));

      gfi->identifier = last_name;
      last_name = 0;
      if (!Gif_AddImage(gfs, gfi))
          goto done;
      else if (!read_image(grr, &gfc, gfi, read_flags)) {
          Gif_RemoveImage(gfs, gfs->nimages - 1);
          gfi = 0;
          goto done;
      }

      gfc.gfi = gfi = Gif_NewImage();
      if (!gfi)
          goto done;
      break;

     case ';': /* terminator */
      GIF_DEBUG((""term\n""));
      goto done;

     case '!': /* extension */
      block = gifgetbyte(grr);
      GIF_DEBUG((""ext(0x%02X) "", block));
      switch (block) {

       case 0xF9:
	read_graphic_control_extension(&gfc, gfi, grr);
	break;

       case 0xCE:
	last_name = suck_data(last_name, 0, grr);
	break;

       case 0xFE:
	if (!read_comment_extension(gfi, grr)) goto done;
	break;

       case 0xFF:
	read_application_extension(&gfc, grr);
	break;

       default:
        read_unknown_extension(&gfc, grr, block, 0, 0);
	break;

      }
      break;

     default:
       if (!unknown_block_type) {
	 char buf[256];
	 sprintf(buf, ""unknown block type %d at file offset %u"", block, grr->pos - 1);
	 gif_read_error(&gfc, 1, buf);
	 unknown_block_type = 1;
       }
       break;

    }

  }

 done:

  /* Move comments and extensions after last image into stream. */
  if (gfs && gfi) {
      Gif_Extension* gfex;
      gfs->end_comment = gfi->comment;
      gfi->comment = 0;
      gfs->end_extension_list = gfi->extension_list;
      gfi->extension_list = 0;
      for (gfex = gfs->end_extension_list; gfex; gfex = gfex->next)
          gfex->image = NULL;
  }

  Gif_DeleteImage(gfi);
  Gif_DeleteArray(last_name);
  Gif_DeleteArray(gfc.prefix);
   Gif_DeleteArray(gfc.suffix);
   Gif_DeleteArray(gfc.length);
   gfc.gfi = 0;
 
   if (gfs)
     gfs->errors = gfc.errors[1];
  if (gfs && gfc.errors[1] == 0
      && !(read_flags & GIF_READ_TRAILING_GARBAGE_OK)
      && !grr->eofer(grr))
      gif_read_error(&gfc, 0, ""trailing garbage after GIF ignored"");
  /* finally, export last message */
  gif_read_error(&gfc, -1, 0);

  return gfs;
}
",C,"  last_name = 0;
",,,"@@ -900,6 +900,7 @@ read_gif(Gif_Reader *grr, int read_flags,
   Gif_DeleteArray(gfc.suffix);
   Gif_DeleteArray(gfc.length);
   gfc.gfi = 0;
+  last_name = 0;
 
   if (gfs)
     gfs->errors = gfc.errors[1];",gifsicle,118a46090c50829dc543179019e6140e1235f909,f1b8e6323a8fdd029847b7efd400d5fc2ac9aecc,1,"read_gif(Gif_Reader *grr, int read_flags,
	 const char* landmark, Gif_ReadErrorHandler handler)
{
  Gif_Stream *gfs;
  Gif_Image *gfi;
  Gif_Context gfc;
  int unknown_block_type = 0;

  if (gifgetc(grr) != 'G' ||
      gifgetc(grr) != 'I' ||
      gifgetc(grr) != 'F')
    return 0;
  (void)gifgetc(grr);
  (void)gifgetc(grr);
  (void)gifgetc(grr);

  gfs = Gif_NewStream();
  gfi = Gif_NewImage();

  gfc.stream = gfs;
  gfc.prefix = Gif_NewArray(Gif_Code, GIF_MAX_CODE);
  gfc.suffix = Gif_NewArray(uint8_t, GIF_MAX_CODE);
  gfc.length = Gif_NewArray(uint16_t, GIF_MAX_CODE);
  gfc.handler = handler;
  gfc.gfi = gfi;
  gfc.errors[0] = gfc.errors[1] = 0;

  if (!gfs || !gfi || !gfc.prefix || !gfc.suffix || !gfc.length)
    goto done;
  gfs->landmark = landmark;

  GIF_DEBUG((""\nGIF ""));
  if (!read_logical_screen_descriptor(gfs, grr))
    goto done;
  GIF_DEBUG((""logscrdesc ""));

  while (!gifeof(grr)) {

    uint8_t block = gifgetbyte(grr);

    switch (block) {

     case ',': /* image block */
      GIF_DEBUG((""imageread %d "", gfs->nimages));

      gfi->identifier = last_name;
      last_name = 0;
      if (!Gif_AddImage(gfs, gfi))
          goto done;
      else if (!read_image(grr, &gfc, gfi, read_flags)) {
          Gif_RemoveImage(gfs, gfs->nimages - 1);
          gfi = 0;
          goto done;
      }

      gfc.gfi = gfi = Gif_NewImage();
      if (!gfi)
          goto done;
      break;

     case ';': /* terminator */
      GIF_DEBUG((""term\n""));
      goto done;

     case '!': /* extension */
      block = gifgetbyte(grr);
      GIF_DEBUG((""ext(0x%02X) "", block));
      switch (block) {

       case 0xF9:
	read_graphic_control_extension(&gfc, gfi, grr);
	break;

       case 0xCE:
	last_name = suck_data(last_name, 0, grr);
	break;

       case 0xFE:
	if (!read_comment_extension(gfi, grr)) goto done;
	break;

       case 0xFF:
	read_application_extension(&gfc, grr);
	break;

       default:
        read_unknown_extension(&gfc, grr, block, 0, 0);
	break;

      }
      break;

     default:
       if (!unknown_block_type) {
	 char buf[256];
	 sprintf(buf, ""unknown block type %d at file offset %u"", block, grr->pos - 1);
	 gif_read_error(&gfc, 1, buf);
	 unknown_block_type = 1;
       }
       break;

    }

  }

 done:

  /* Move comments and extensions after last image into stream. */
  if (gfs && gfi) {
      Gif_Extension* gfex;
      gfs->end_comment = gfi->comment;
      gfi->comment = 0;
      gfs->end_extension_list = gfi->extension_list;
      gfi->extension_list = 0;
      for (gfex = gfs->end_extension_list; gfex; gfex = gfex->next)
          gfex->image = NULL;
  }

  Gif_DeleteImage(gfi);
  Gif_DeleteArray(last_name);
  Gif_DeleteArray(gfc.prefix);
   Gif_DeleteArray(gfc.suffix);
   Gif_DeleteArray(gfc.length);
   gfc.gfi = 0;
//fix_flaw_line_below:
//  last_name = 0;
 
   if (gfs)
     gfs->errors = gfc.errors[1];
  if (gfs && gfc.errors[1] == 0
      && !(read_flags & GIF_READ_TRAILING_GARBAGE_OK)
      && !grr->eofer(grr))
      gif_read_error(&gfc, 0, ""trailing garbage after GIF ignored"");
  /* finally, export last message */
  gif_read_error(&gfc, -1, 0);

  return gfs;
}
"
5169,182905,,Remote,Not required,Partial,CVE-2019-6978,https://www.cvedetails.com/cve/CVE-2019-6978/,CWE-415,Low,Partial,Partial,,2019-01-28,7.5,"The GD Graphics Library (aka LibGD) 2.2.5 has a double free in the gdImage*Ptr() functions in gd_gif_out.c, gd_jpeg.c, and gd_wbmp.c. NOTE: PHP is unaffected.",2019-04-04,,9,https://github.com/php/php-src/commit/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,"Sync with upstream

Even though libgd/libgd#492 is not a relevant bug fix for PHP, since
the binding doesn't use the `gdImage*Ptr()` functions at all, we're
porting the fix to stay in sync here.",1,ext/gd/libgd/gd_gif_out.c,"{""sha"": ""2e1f38af70477f91277a55fcb7f955a5f3cc3cea"", ""filename"": ""ext/gd/libgd/gd_gif_out.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 3, ""changes"": 20, ""blob_url"": ""https://github.com/php/php-src/blob/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_gif_out.c"", ""raw_url"": ""https://github.com/php/php-src/raw/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_gif_out.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/libgd/gd_gif_out.c?ref=089f7c0bc28d399b0420aa6ef058e4c1c120b2ae"", ""patch"": ""@@ -97,12 +97,18 @@ static void cl_hash (register count_int chsize, GifCtx *ctx);\n static void char_init (GifCtx *ctx);\n static void char_out (int c, GifCtx *ctx);\n static void flush_char (GifCtx *ctx);\n+\n+static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out);\n+\n void * gdImageGifPtr (gdImagePtr im, int *size)\n {\n   void *rv;\n   gdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n-  gdImageGifCtx (im, out);\n-  rv = gdDPExtractData (out, size);\n+\tif (!_gdImageGifCtx(im, out)) {\n+\t\trv = gdDPExtractData(out, size);\n+\t} else {\n+\t\trv = NULL;\n+\t}\n   out->gd_free (out);\n   return rv;\n }\n@@ -115,6 +121,12 @@ void gdImageGif (gdImagePtr im, FILE * outFile)\n }\n \n void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n+{\n+\t_gdImageGifCtx(im, out);\n+}\n+\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n {\n \tgdImagePtr pim = 0, tim = im;\n \tint interlace, BitsPerPixel;\n@@ -125,7 +137,7 @@ void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n \t\t\tbased temporary image. */\n \t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n \t\tif (!pim) {\n-\t\t\treturn;\n+\t\t\treturn 1;\n \t\t}\n \t\ttim = pim;\n \t}\n@@ -138,6 +150,8 @@ void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n \t\t/* Destroy palette based temporary image. */\n \t\tgdImageDestroy(\tpim);\n \t}\n+\n+    return 0;\n }\n \n static int""}<_**next**_>{""sha"": ""ef46c4a22cf03e6583b90295b63b06405e4ae63e"", ""filename"": ""ext/gd/libgd/gd_jpeg.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 3, ""changes"": 17, ""blob_url"": ""https://github.com/php/php-src/blob/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_jpeg.c"", ""raw_url"": ""https://github.com/php/php-src/raw/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_jpeg.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/libgd/gd_jpeg.c?ref=089f7c0bc28d399b0420aa6ef058e4c1c120b2ae"", ""patch"": ""@@ -132,6 +132,7 @@ const char * gdJpegGetVersionString()\n \t}\n }\n \n+static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality);\n \n /*\n  * Write IM to OUTFILE as a JFIF-formatted JPEG image, using quality\n@@ -153,8 +154,11 @@ void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)\n {\n \tvoid *rv;\n \tgdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n-\tgdImageJpegCtx (im, out, quality);\n-\trv = gdDPExtractData (out, size);\n+\tif (!_gdImageJpegCtx(im, out, quality)) {\n+\t\trv = gdDPExtractData(out, size);\n+\t} else {\n+\t\trv = NULL;\n+\t}\n \tout->gd_free (out);\n \n \treturn rv;\n@@ -163,6 +167,12 @@ void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)\n void jpeg_gdIOCtx_dest (j_compress_ptr cinfo, gdIOCtx * outfile);\n \n void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n+{\n+\t_gdImageJpegCtx(im, outfile, quality);\n+}\n+\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality)\n {\n \tstruct jpeg_compress_struct cinfo;\n \tstruct jpeg_error_mgr jerr;\n@@ -184,7 +194,7 @@ void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n \t\tif (row) {\n \t\t\tgdFree (row);\n \t\t}\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \tcinfo.err->error_exit = fatal_jpeg_error;\n@@ -277,6 +287,7 @@ void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n \tjpeg_finish_compress (&cinfo);\n \tjpeg_destroy_compress (&cinfo);\n \tgdFree (row);\n+\treturn 0;\n }\n \n gdImagePtr gdImageCreateFromJpeg (FILE * inFile)""}<_**next**_>{""sha"": ""fd9edad2cafa85a2641d61c5e1b1ebc54f4c348f"", ""filename"": ""ext/gd/libgd/gd_wbmp.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 3, ""changes"": 18, ""blob_url"": ""https://github.com/php/php-src/blob/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_wbmp.c"", ""raw_url"": ""https://github.com/php/php-src/raw/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_wbmp.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/libgd/gd_wbmp.c?ref=089f7c0bc28d399b0420aa6ef058e4c1c120b2ae"", ""patch"": ""@@ -82,6 +82,7 @@ int gd_getin (void *in)\n \treturn (gdGetC((gdIOCtx *) in));\n }\n \n+static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out);\n \n /*      gdImageWBMPCtx\n    **  --------------\n@@ -93,14 +94,20 @@ int gd_getin (void *in)\n    **  out:    the stream where to write\n  */\n void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)\n+{\n+\t_gdImageWBMPCtx(image, fg, out);\n+}\n+\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)\n {\n \tint x, y, pos;\n \tWbmp *wbmp;\n \n \t/* create the WBMP */\n \tif ((wbmp = createwbmp (gdImageSX (image), gdImageSY (image), WBMP_WHITE)) == NULL) {\n \t\tgd_error(\""Could not create WBMP\"");\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \t/* fill up the WBMP structure */\n@@ -116,7 +123,9 @@ void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)\n \n \t/* write the WBMP to a gd file descriptor */\n \tif (writewbmp (wbmp, &gd_putout, out)) {\n+\t\tfreewbmp(wbmp);\n \t\tgd_error(\""Could not save WBMP\"");\n+\t\treturn 1;\n \t}\n \t/* des submitted this bugfix: gdFree the memory. */\n \tfreewbmp(wbmp);\n@@ -204,8 +213,11 @@ void * gdImageWBMPPtr (gdImagePtr im, int *size, int fg)\n {\n \tvoid *rv;\n \tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n-\tgdImageWBMPCtx(im, fg, out);\n-\trv = gdDPExtractData(out, size);\n+\tif (!_gdImageWBMPCtx(im, fg, out)) {\n+\t\trv = gdDPExtractData(out, size);\n+\t} else {\n+\t\trv = NULL;\n+\t}\n \tout->gd_free(out);\n \n \treturn rv;""}"," void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
{
	_gdImageGifCtx(im, out);
}

/* returns 0 on success, 1 on failure */
static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 {
 	gdImagePtr pim = 0, tim = im;
 	int interlace, BitsPerPixel;
	interlace = im->interlace;
	if (im->trueColor) {
		/* Expensive, but the only way that produces an
			acceptable result: mix down to a palette
 			based temporary image. */
 		pim = gdImageCreatePaletteFromTrueColor(im, 1, 256);
 		if (!pim) {
			return 1;
 		}
 		tim = pim;
 	}
	BitsPerPixel = colorstobpp(tim->colorsTotal);
	/* All set, let's do it. */
	GIFEncode(
		out, tim->sx, tim->sy, tim->interlace, 0, tim->transparent, BitsPerPixel,
		tim->red, tim->green, tim->blue, tim);
	if (pim) {
 		/* Destroy palette based temporary image. */
 		gdImageDestroy(	pim);
 	}

    return 0;
 }
"," void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 {
 	gdImagePtr pim = 0, tim = im;
 	int interlace, BitsPerPixel;
	interlace = im->interlace;
	if (im->trueColor) {
		/* Expensive, but the only way that produces an
			acceptable result: mix down to a palette
 			based temporary image. */
 		pim = gdImageCreatePaletteFromTrueColor(im, 1, 256);
 		if (!pim) {
			return;
 		}
 		tim = pim;
 	}
	BitsPerPixel = colorstobpp(tim->colorsTotal);
	/* All set, let's do it. */
	GIFEncode(
		out, tim->sx, tim->sy, tim->interlace, 0, tim->transparent, BitsPerPixel,
		tim->red, tim->green, tim->blue, tim);
	if (pim) {
 		/* Destroy palette based temporary image. */
 		gdImageDestroy(	pim);
 	}
 }
",C,"{
	_gdImageGifCtx(im, out);
}

/* returns 0 on success, 1 on failure */
static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
			return 1;

    return 0;
","			return;
",,"@@ -97,12 +97,18 @@ static void cl_hash (register count_int chsize, GifCtx *ctx);
 static void char_init (GifCtx *ctx);
 static void char_out (int c, GifCtx *ctx);
 static void flush_char (GifCtx *ctx);
+
+static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out);
+
 void * gdImageGifPtr (gdImagePtr im, int *size)
 {
   void *rv;
   gdIOCtx *out = gdNewDynamicCtx (2048, NULL);
-  gdImageGifCtx (im, out);
-  rv = gdDPExtractData (out, size);
+	if (!_gdImageGifCtx(im, out)) {
+		rv = gdDPExtractData(out, size);
+	} else {
+		rv = NULL;
+	}
   out->gd_free (out);
   return rv;
 }
@@ -115,6 +121,12 @@ void gdImageGif (gdImagePtr im, FILE * outFile)
 }
 
 void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
+{
+	_gdImageGifCtx(im, out);
+}
+
+/* returns 0 on success, 1 on failure */
+static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 {
 	gdImagePtr pim = 0, tim = im;
 	int interlace, BitsPerPixel;
@@ -125,7 +137,7 @@ void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 			based temporary image. */
 		pim = gdImageCreatePaletteFromTrueColor(im, 1, 256);
 		if (!pim) {
-			return;
+			return 1;
 		}
 		tim = pim;
 	}
@@ -138,6 +150,8 @@ void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 		/* Destroy palette based temporary image. */
 		gdImageDestroy(	pim);
 	}
+
+    return 0;
 }
 
 static int",php-src,089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,6aff4d01c71238413dc9b4e4dabb884ebeb3beca,1," void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
//fix_flaw_line_below:
//{
//fix_flaw_line_below:
//	_gdImageGifCtx(im, out);
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
///* returns 0 on success, 1 on failure */
//fix_flaw_line_below:
//static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 {
 	gdImagePtr pim = 0, tim = im;
 	int interlace, BitsPerPixel;
	interlace = im->interlace;
	if (im->trueColor) {
		/* Expensive, but the only way that produces an
			acceptable result: mix down to a palette
 			based temporary image. */
 		pim = gdImageCreatePaletteFromTrueColor(im, 1, 256);
 		if (!pim) {
//flaw_line_below:
			return;
//fix_flaw_line_below:
//			return 1;
 		}
 		tim = pim;
 	}
	BitsPerPixel = colorstobpp(tim->colorsTotal);
	/* All set, let's do it. */
	GIFEncode(
		out, tim->sx, tim->sy, tim->interlace, 0, tim->transparent, BitsPerPixel,
		tim->red, tim->green, tim->blue, tim);
	if (pim) {
 		/* Destroy palette based temporary image. */
 		gdImageDestroy(	pim);
 	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    return 0;
 }
"
5170,182906,,Remote,Not required,Partial,CVE-2019-6978,https://www.cvedetails.com/cve/CVE-2019-6978/,CWE-415,Low,Partial,Partial,,2019-01-28,7.5,"The GD Graphics Library (aka LibGD) 2.2.5 has a double free in the gdImage*Ptr() functions in gd_gif_out.c, gd_jpeg.c, and gd_wbmp.c. NOTE: PHP is unaffected.",2019-04-04,,5,https://github.com/php/php-src/commit/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,"Sync with upstream

Even though libgd/libgd#492 is not a relevant bug fix for PHP, since
the binding doesn't use the `gdImage*Ptr()` functions at all, we're
porting the fix to stay in sync here.",2,ext/gd/libgd/gd_gif_out.c,"{""sha"": ""2e1f38af70477f91277a55fcb7f955a5f3cc3cea"", ""filename"": ""ext/gd/libgd/gd_gif_out.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 3, ""changes"": 20, ""blob_url"": ""https://github.com/php/php-src/blob/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_gif_out.c"", ""raw_url"": ""https://github.com/php/php-src/raw/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_gif_out.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/libgd/gd_gif_out.c?ref=089f7c0bc28d399b0420aa6ef058e4c1c120b2ae"", ""patch"": ""@@ -97,12 +97,18 @@ static void cl_hash (register count_int chsize, GifCtx *ctx);\n static void char_init (GifCtx *ctx);\n static void char_out (int c, GifCtx *ctx);\n static void flush_char (GifCtx *ctx);\n+\n+static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out);\n+\n void * gdImageGifPtr (gdImagePtr im, int *size)\n {\n   void *rv;\n   gdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n-  gdImageGifCtx (im, out);\n-  rv = gdDPExtractData (out, size);\n+\tif (!_gdImageGifCtx(im, out)) {\n+\t\trv = gdDPExtractData(out, size);\n+\t} else {\n+\t\trv = NULL;\n+\t}\n   out->gd_free (out);\n   return rv;\n }\n@@ -115,6 +121,12 @@ void gdImageGif (gdImagePtr im, FILE * outFile)\n }\n \n void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n+{\n+\t_gdImageGifCtx(im, out);\n+}\n+\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n {\n \tgdImagePtr pim = 0, tim = im;\n \tint interlace, BitsPerPixel;\n@@ -125,7 +137,7 @@ void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n \t\t\tbased temporary image. */\n \t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n \t\tif (!pim) {\n-\t\t\treturn;\n+\t\t\treturn 1;\n \t\t}\n \t\ttim = pim;\n \t}\n@@ -138,6 +150,8 @@ void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n \t\t/* Destroy palette based temporary image. */\n \t\tgdImageDestroy(\tpim);\n \t}\n+\n+    return 0;\n }\n \n static int""}<_**next**_>{""sha"": ""ef46c4a22cf03e6583b90295b63b06405e4ae63e"", ""filename"": ""ext/gd/libgd/gd_jpeg.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 3, ""changes"": 17, ""blob_url"": ""https://github.com/php/php-src/blob/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_jpeg.c"", ""raw_url"": ""https://github.com/php/php-src/raw/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_jpeg.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/libgd/gd_jpeg.c?ref=089f7c0bc28d399b0420aa6ef058e4c1c120b2ae"", ""patch"": ""@@ -132,6 +132,7 @@ const char * gdJpegGetVersionString()\n \t}\n }\n \n+static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality);\n \n /*\n  * Write IM to OUTFILE as a JFIF-formatted JPEG image, using quality\n@@ -153,8 +154,11 @@ void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)\n {\n \tvoid *rv;\n \tgdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n-\tgdImageJpegCtx (im, out, quality);\n-\trv = gdDPExtractData (out, size);\n+\tif (!_gdImageJpegCtx(im, out, quality)) {\n+\t\trv = gdDPExtractData(out, size);\n+\t} else {\n+\t\trv = NULL;\n+\t}\n \tout->gd_free (out);\n \n \treturn rv;\n@@ -163,6 +167,12 @@ void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)\n void jpeg_gdIOCtx_dest (j_compress_ptr cinfo, gdIOCtx * outfile);\n \n void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n+{\n+\t_gdImageJpegCtx(im, outfile, quality);\n+}\n+\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality)\n {\n \tstruct jpeg_compress_struct cinfo;\n \tstruct jpeg_error_mgr jerr;\n@@ -184,7 +194,7 @@ void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n \t\tif (row) {\n \t\t\tgdFree (row);\n \t\t}\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \tcinfo.err->error_exit = fatal_jpeg_error;\n@@ -277,6 +287,7 @@ void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n \tjpeg_finish_compress (&cinfo);\n \tjpeg_destroy_compress (&cinfo);\n \tgdFree (row);\n+\treturn 0;\n }\n \n gdImagePtr gdImageCreateFromJpeg (FILE * inFile)""}<_**next**_>{""sha"": ""fd9edad2cafa85a2641d61c5e1b1ebc54f4c348f"", ""filename"": ""ext/gd/libgd/gd_wbmp.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 3, ""changes"": 18, ""blob_url"": ""https://github.com/php/php-src/blob/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_wbmp.c"", ""raw_url"": ""https://github.com/php/php-src/raw/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_wbmp.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/libgd/gd_wbmp.c?ref=089f7c0bc28d399b0420aa6ef058e4c1c120b2ae"", ""patch"": ""@@ -82,6 +82,7 @@ int gd_getin (void *in)\n \treturn (gdGetC((gdIOCtx *) in));\n }\n \n+static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out);\n \n /*      gdImageWBMPCtx\n    **  --------------\n@@ -93,14 +94,20 @@ int gd_getin (void *in)\n    **  out:    the stream where to write\n  */\n void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)\n+{\n+\t_gdImageWBMPCtx(image, fg, out);\n+}\n+\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)\n {\n \tint x, y, pos;\n \tWbmp *wbmp;\n \n \t/* create the WBMP */\n \tif ((wbmp = createwbmp (gdImageSX (image), gdImageSY (image), WBMP_WHITE)) == NULL) {\n \t\tgd_error(\""Could not create WBMP\"");\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \t/* fill up the WBMP structure */\n@@ -116,7 +123,9 @@ void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)\n \n \t/* write the WBMP to a gd file descriptor */\n \tif (writewbmp (wbmp, &gd_putout, out)) {\n+\t\tfreewbmp(wbmp);\n \t\tgd_error(\""Could not save WBMP\"");\n+\t\treturn 1;\n \t}\n \t/* des submitted this bugfix: gdFree the memory. */\n \tfreewbmp(wbmp);\n@@ -204,8 +213,11 @@ void * gdImageWBMPPtr (gdImagePtr im, int *size, int fg)\n {\n \tvoid *rv;\n \tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n-\tgdImageWBMPCtx(im, fg, out);\n-\trv = gdDPExtractData(out, size);\n+\tif (!_gdImageWBMPCtx(im, fg, out)) {\n+\t\trv = gdDPExtractData(out, size);\n+\t} else {\n+\t\trv = NULL;\n+\t}\n \tout->gd_free(out);\n \n \treturn rv;""}"," void * gdImageGifPtr (gdImagePtr im, int *size)
 {
   void *rv;
   gdIOCtx *out = gdNewDynamicCtx (2048, NULL);
	if (!_gdImageGifCtx(im, out)) {
		rv = gdDPExtractData(out, size);
	} else {
		rv = NULL;
	}
   out->gd_free (out);
   return rv;
 }
"," void * gdImageGifPtr (gdImagePtr im, int *size)
 {
   void *rv;
   gdIOCtx *out = gdNewDynamicCtx (2048, NULL);
  gdImageGifCtx (im, out);
  rv = gdDPExtractData (out, size);
   out->gd_free (out);
   return rv;
 }
",C,"	if (!_gdImageGifCtx(im, out)) {
		rv = gdDPExtractData(out, size);
	} else {
		rv = NULL;
	}
","  gdImageGifCtx (im, out);
  rv = gdDPExtractData (out, size);
",,"@@ -97,12 +97,18 @@ static void cl_hash (register count_int chsize, GifCtx *ctx);
 static void char_init (GifCtx *ctx);
 static void char_out (int c, GifCtx *ctx);
 static void flush_char (GifCtx *ctx);
+
+static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out);
+
 void * gdImageGifPtr (gdImagePtr im, int *size)
 {
   void *rv;
   gdIOCtx *out = gdNewDynamicCtx (2048, NULL);
-  gdImageGifCtx (im, out);
-  rv = gdDPExtractData (out, size);
+	if (!_gdImageGifCtx(im, out)) {
+		rv = gdDPExtractData(out, size);
+	} else {
+		rv = NULL;
+	}
   out->gd_free (out);
   return rv;
 }
@@ -115,6 +121,12 @@ void gdImageGif (gdImagePtr im, FILE * outFile)
 }
 
 void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
+{
+	_gdImageGifCtx(im, out);
+}
+
+/* returns 0 on success, 1 on failure */
+static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 {
 	gdImagePtr pim = 0, tim = im;
 	int interlace, BitsPerPixel;
@@ -125,7 +137,7 @@ void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 			based temporary image. */
 		pim = gdImageCreatePaletteFromTrueColor(im, 1, 256);
 		if (!pim) {
-			return;
+			return 1;
 		}
 		tim = pim;
 	}
@@ -138,6 +150,8 @@ void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 		/* Destroy palette based temporary image. */
 		gdImageDestroy(	pim);
 	}
+
+    return 0;
 }
 
 static int",php-src,089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,6aff4d01c71238413dc9b4e4dabb884ebeb3beca,1," void * gdImageGifPtr (gdImagePtr im, int *size)
 {
   void *rv;
   gdIOCtx *out = gdNewDynamicCtx (2048, NULL);
//flaw_line_below:
  gdImageGifCtx (im, out);
//flaw_line_below:
  rv = gdDPExtractData (out, size);
//fix_flaw_line_below:
//	if (!_gdImageGifCtx(im, out)) {
//fix_flaw_line_below:
//		rv = gdDPExtractData(out, size);
//fix_flaw_line_below:
//	} else {
//fix_flaw_line_below:
//		rv = NULL;
//fix_flaw_line_below:
//	}
   out->gd_free (out);
   return rv;
 }
"
5171,182907,,Remote,Not required,Partial,CVE-2019-6978,https://www.cvedetails.com/cve/CVE-2019-6978/,CWE-415,Low,Partial,Partial,,2019-01-28,7.5,"The GD Graphics Library (aka LibGD) 2.2.5 has a double free in the gdImage*Ptr() functions in gd_gif_out.c, gd_jpeg.c, and gd_wbmp.c. NOTE: PHP is unaffected.",2019-04-04,,8,https://github.com/php/php-src/commit/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,"Sync with upstream

Even though libgd/libgd#492 is not a relevant bug fix for PHP, since
the binding doesn't use the `gdImage*Ptr()` functions at all, we're
porting the fix to stay in sync here.",1,ext/gd/libgd/gd_jpeg.c,"{""sha"": ""2e1f38af70477f91277a55fcb7f955a5f3cc3cea"", ""filename"": ""ext/gd/libgd/gd_gif_out.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 3, ""changes"": 20, ""blob_url"": ""https://github.com/php/php-src/blob/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_gif_out.c"", ""raw_url"": ""https://github.com/php/php-src/raw/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_gif_out.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/libgd/gd_gif_out.c?ref=089f7c0bc28d399b0420aa6ef058e4c1c120b2ae"", ""patch"": ""@@ -97,12 +97,18 @@ static void cl_hash (register count_int chsize, GifCtx *ctx);\n static void char_init (GifCtx *ctx);\n static void char_out (int c, GifCtx *ctx);\n static void flush_char (GifCtx *ctx);\n+\n+static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out);\n+\n void * gdImageGifPtr (gdImagePtr im, int *size)\n {\n   void *rv;\n   gdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n-  gdImageGifCtx (im, out);\n-  rv = gdDPExtractData (out, size);\n+\tif (!_gdImageGifCtx(im, out)) {\n+\t\trv = gdDPExtractData(out, size);\n+\t} else {\n+\t\trv = NULL;\n+\t}\n   out->gd_free (out);\n   return rv;\n }\n@@ -115,6 +121,12 @@ void gdImageGif (gdImagePtr im, FILE * outFile)\n }\n \n void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n+{\n+\t_gdImageGifCtx(im, out);\n+}\n+\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n {\n \tgdImagePtr pim = 0, tim = im;\n \tint interlace, BitsPerPixel;\n@@ -125,7 +137,7 @@ void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n \t\t\tbased temporary image. */\n \t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n \t\tif (!pim) {\n-\t\t\treturn;\n+\t\t\treturn 1;\n \t\t}\n \t\ttim = pim;\n \t}\n@@ -138,6 +150,8 @@ void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n \t\t/* Destroy palette based temporary image. */\n \t\tgdImageDestroy(\tpim);\n \t}\n+\n+    return 0;\n }\n \n static int""}<_**next**_>{""sha"": ""ef46c4a22cf03e6583b90295b63b06405e4ae63e"", ""filename"": ""ext/gd/libgd/gd_jpeg.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 3, ""changes"": 17, ""blob_url"": ""https://github.com/php/php-src/blob/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_jpeg.c"", ""raw_url"": ""https://github.com/php/php-src/raw/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_jpeg.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/libgd/gd_jpeg.c?ref=089f7c0bc28d399b0420aa6ef058e4c1c120b2ae"", ""patch"": ""@@ -132,6 +132,7 @@ const char * gdJpegGetVersionString()\n \t}\n }\n \n+static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality);\n \n /*\n  * Write IM to OUTFILE as a JFIF-formatted JPEG image, using quality\n@@ -153,8 +154,11 @@ void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)\n {\n \tvoid *rv;\n \tgdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n-\tgdImageJpegCtx (im, out, quality);\n-\trv = gdDPExtractData (out, size);\n+\tif (!_gdImageJpegCtx(im, out, quality)) {\n+\t\trv = gdDPExtractData(out, size);\n+\t} else {\n+\t\trv = NULL;\n+\t}\n \tout->gd_free (out);\n \n \treturn rv;\n@@ -163,6 +167,12 @@ void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)\n void jpeg_gdIOCtx_dest (j_compress_ptr cinfo, gdIOCtx * outfile);\n \n void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n+{\n+\t_gdImageJpegCtx(im, outfile, quality);\n+}\n+\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality)\n {\n \tstruct jpeg_compress_struct cinfo;\n \tstruct jpeg_error_mgr jerr;\n@@ -184,7 +194,7 @@ void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n \t\tif (row) {\n \t\t\tgdFree (row);\n \t\t}\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \tcinfo.err->error_exit = fatal_jpeg_error;\n@@ -277,6 +287,7 @@ void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n \tjpeg_finish_compress (&cinfo);\n \tjpeg_destroy_compress (&cinfo);\n \tgdFree (row);\n+\treturn 0;\n }\n \n gdImagePtr gdImageCreateFromJpeg (FILE * inFile)""}<_**next**_>{""sha"": ""fd9edad2cafa85a2641d61c5e1b1ebc54f4c348f"", ""filename"": ""ext/gd/libgd/gd_wbmp.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 3, ""changes"": 18, ""blob_url"": ""https://github.com/php/php-src/blob/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_wbmp.c"", ""raw_url"": ""https://github.com/php/php-src/raw/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_wbmp.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/libgd/gd_wbmp.c?ref=089f7c0bc28d399b0420aa6ef058e4c1c120b2ae"", ""patch"": ""@@ -82,6 +82,7 @@ int gd_getin (void *in)\n \treturn (gdGetC((gdIOCtx *) in));\n }\n \n+static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out);\n \n /*      gdImageWBMPCtx\n    **  --------------\n@@ -93,14 +94,20 @@ int gd_getin (void *in)\n    **  out:    the stream where to write\n  */\n void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)\n+{\n+\t_gdImageWBMPCtx(image, fg, out);\n+}\n+\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)\n {\n \tint x, y, pos;\n \tWbmp *wbmp;\n \n \t/* create the WBMP */\n \tif ((wbmp = createwbmp (gdImageSX (image), gdImageSY (image), WBMP_WHITE)) == NULL) {\n \t\tgd_error(\""Could not create WBMP\"");\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \t/* fill up the WBMP structure */\n@@ -116,7 +123,9 @@ void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)\n \n \t/* write the WBMP to a gd file descriptor */\n \tif (writewbmp (wbmp, &gd_putout, out)) {\n+\t\tfreewbmp(wbmp);\n \t\tgd_error(\""Could not save WBMP\"");\n+\t\treturn 1;\n \t}\n \t/* des submitted this bugfix: gdFree the memory. */\n \tfreewbmp(wbmp);\n@@ -204,8 +213,11 @@ void * gdImageWBMPPtr (gdImagePtr im, int *size, int fg)\n {\n \tvoid *rv;\n \tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n-\tgdImageWBMPCtx(im, fg, out);\n-\trv = gdDPExtractData(out, size);\n+\tif (!_gdImageWBMPCtx(im, fg, out)) {\n+\t\trv = gdDPExtractData(out, size);\n+\t} else {\n+\t\trv = NULL;\n+\t}\n \tout->gd_free(out);\n \n \treturn rv;""}"," void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
{
	_gdImageJpegCtx(im, outfile, quality);
}

/* returns 0 on success, 1 on failure */
static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality)
 {
 	struct jpeg_compress_struct cinfo;
 	struct jpeg_error_mgr jerr;
	int i, j, jidx;
	/* volatile so we can gdFree it on return from longjmp */
	volatile JSAMPROW row = 0;
	JSAMPROW rowptr[1];
	jmpbuf_wrapper jmpbufw;
	JDIMENSION nlines;
	char comment[255];

	memset (&cinfo, 0, sizeof (cinfo));
	memset (&jerr, 0, sizeof (jerr));

	cinfo.err = jpeg_std_error (&jerr);
	cinfo.client_data = &jmpbufw;
	if (setjmp (jmpbufw.jmpbuf) != 0) {
		/* we're here courtesy of longjmp */
 		if (row) {
 			gdFree (row);
 		}
		return 1;
 	}
 
 	cinfo.err->error_exit = fatal_jpeg_error;

	jpeg_create_compress (&cinfo);

	cinfo.image_width = im->sx;
	cinfo.image_height = im->sy;
	cinfo.input_components = 3;	/* # of color components per pixel */
	cinfo.in_color_space = JCS_RGB;	/* colorspace of input image */
	jpeg_set_defaults (&cinfo);

	cinfo.density_unit = 1;
	cinfo.X_density = im->res_x;
	cinfo.Y_density = im->res_y;

	if (quality >= 0) {
		jpeg_set_quality (&cinfo, quality, TRUE);
	}

	/* If user requests interlace, translate that to progressive JPEG */
	if (gdImageGetInterlaced (im)) {
		jpeg_simple_progression (&cinfo);
	}

	jpeg_gdIOCtx_dest (&cinfo, outfile);

	row = (JSAMPROW) safe_emalloc(cinfo.image_width * cinfo.input_components, sizeof(JSAMPLE), 0);
	memset(row, 0, cinfo.image_width * cinfo.input_components * sizeof(JSAMPLE));
	rowptr[0] = row;

	jpeg_start_compress (&cinfo, TRUE);

	if (quality >= 0) {
		snprintf(comment, sizeof(comment)-1, ""CREATOR: gd-jpeg v%s (using IJG JPEG v%d), quality = %d\n"", GD_JPEG_VERSION, JPEG_LIB_VERSION, quality);
	} else {
		snprintf(comment, sizeof(comment)-1, ""CREATOR: gd-jpeg v%s (using IJG JPEG v%d), default quality\n"", GD_JPEG_VERSION, JPEG_LIB_VERSION);
	}
	jpeg_write_marker (&cinfo, JPEG_COM, (unsigned char *) comment, (unsigned int) strlen (comment));
	if (im->trueColor) {

#if BITS_IN_JSAMPLE == 12
		gd_error(""gd-jpeg: error: jpeg library was compiled for 12-bit precision. This is mostly useless, because JPEGs on the web are 8-bit and such versions of the jpeg library won't read or write them. GD doesn't support these unusual images. Edit your jmorecfg.h file to specify the correct precision and completely 'make clean' and 'make install' libjpeg again. Sorry"");
		goto error;
#endif /* BITS_IN_JSAMPLE == 12 */

		for (i = 0; i < im->sy; i++) {
			for (jidx = 0, j = 0; j < im->sx; j++) {
				int val = im->tpixels[i][j];

				row[jidx++] = gdTrueColorGetRed (val);
				row[jidx++] = gdTrueColorGetGreen (val);
				row[jidx++] = gdTrueColorGetBlue (val);
			}

			nlines = jpeg_write_scanlines (&cinfo, rowptr, 1);
			if (nlines != 1) {
				gd_error_ex(GD_WARNING, ""gd_jpeg: warning: jpeg_write_scanlines returns %u -- expected 1"", nlines);
			}
		}
	} else {
		for (i = 0; i < im->sy; i++) {
			for (jidx = 0, j = 0; j < im->sx; j++) {
				int idx = im->pixels[i][j];

				/* NB: Although gd RGB values are ints, their max value is
				 * 255 (see the documentation for gdImageColorAllocate())
				 * -- perfect for 8-bit JPEG encoding (which is the norm)
				 */
#if BITS_IN_JSAMPLE == 8
				row[jidx++] = im->red[idx];
				row[jidx++] = im->green[idx];
				row[jidx++] = im->blue[idx];
#elif BITS_IN_JSAMPLE == 12
				row[jidx++] = im->red[idx] << 4;
				row[jidx++] = im->green[idx] << 4;
				row[jidx++] = im->blue[idx] << 4;
#else
#error IJG JPEG library BITS_IN_JSAMPLE value must be 8 or 12
#endif
			}

			nlines = jpeg_write_scanlines (&cinfo, rowptr, 1);
			if (nlines != 1) {
				gd_error_ex(GD_WARNING, ""gd_jpeg: warning: jpeg_write_scanlines returns %u -- expected 1"", nlines);
			}
		}
	}

 	jpeg_finish_compress (&cinfo);
 	jpeg_destroy_compress (&cinfo);
 	gdFree (row);
	return 0;
 }
"," void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
 {
 	struct jpeg_compress_struct cinfo;
 	struct jpeg_error_mgr jerr;
	int i, j, jidx;
	/* volatile so we can gdFree it on return from longjmp */
	volatile JSAMPROW row = 0;
	JSAMPROW rowptr[1];
	jmpbuf_wrapper jmpbufw;
	JDIMENSION nlines;
	char comment[255];

	memset (&cinfo, 0, sizeof (cinfo));
	memset (&jerr, 0, sizeof (jerr));

	cinfo.err = jpeg_std_error (&jerr);
	cinfo.client_data = &jmpbufw;
	if (setjmp (jmpbufw.jmpbuf) != 0) {
		/* we're here courtesy of longjmp */
 		if (row) {
 			gdFree (row);
 		}
		return;
 	}
 
 	cinfo.err->error_exit = fatal_jpeg_error;

	jpeg_create_compress (&cinfo);

	cinfo.image_width = im->sx;
	cinfo.image_height = im->sy;
	cinfo.input_components = 3;	/* # of color components per pixel */
	cinfo.in_color_space = JCS_RGB;	/* colorspace of input image */
	jpeg_set_defaults (&cinfo);

	cinfo.density_unit = 1;
	cinfo.X_density = im->res_x;
	cinfo.Y_density = im->res_y;

	if (quality >= 0) {
		jpeg_set_quality (&cinfo, quality, TRUE);
	}

	/* If user requests interlace, translate that to progressive JPEG */
	if (gdImageGetInterlaced (im)) {
		jpeg_simple_progression (&cinfo);
	}

	jpeg_gdIOCtx_dest (&cinfo, outfile);

	row = (JSAMPROW) safe_emalloc(cinfo.image_width * cinfo.input_components, sizeof(JSAMPLE), 0);
	memset(row, 0, cinfo.image_width * cinfo.input_components * sizeof(JSAMPLE));
	rowptr[0] = row;

	jpeg_start_compress (&cinfo, TRUE);

	if (quality >= 0) {
		snprintf(comment, sizeof(comment)-1, ""CREATOR: gd-jpeg v%s (using IJG JPEG v%d), quality = %d\n"", GD_JPEG_VERSION, JPEG_LIB_VERSION, quality);
	} else {
		snprintf(comment, sizeof(comment)-1, ""CREATOR: gd-jpeg v%s (using IJG JPEG v%d), default quality\n"", GD_JPEG_VERSION, JPEG_LIB_VERSION);
	}
	jpeg_write_marker (&cinfo, JPEG_COM, (unsigned char *) comment, (unsigned int) strlen (comment));
	if (im->trueColor) {

#if BITS_IN_JSAMPLE == 12
		gd_error(""gd-jpeg: error: jpeg library was compiled for 12-bit precision. This is mostly useless, because JPEGs on the web are 8-bit and such versions of the jpeg library won't read or write them. GD doesn't support these unusual images. Edit your jmorecfg.h file to specify the correct precision and completely 'make clean' and 'make install' libjpeg again. Sorry"");
		goto error;
#endif /* BITS_IN_JSAMPLE == 12 */

		for (i = 0; i < im->sy; i++) {
			for (jidx = 0, j = 0; j < im->sx; j++) {
				int val = im->tpixels[i][j];

				row[jidx++] = gdTrueColorGetRed (val);
				row[jidx++] = gdTrueColorGetGreen (val);
				row[jidx++] = gdTrueColorGetBlue (val);
			}

			nlines = jpeg_write_scanlines (&cinfo, rowptr, 1);
			if (nlines != 1) {
				gd_error_ex(GD_WARNING, ""gd_jpeg: warning: jpeg_write_scanlines returns %u -- expected 1"", nlines);
			}
		}
	} else {
		for (i = 0; i < im->sy; i++) {
			for (jidx = 0, j = 0; j < im->sx; j++) {
				int idx = im->pixels[i][j];

				/* NB: Although gd RGB values are ints, their max value is
				 * 255 (see the documentation for gdImageColorAllocate())
				 * -- perfect for 8-bit JPEG encoding (which is the norm)
				 */
#if BITS_IN_JSAMPLE == 8
				row[jidx++] = im->red[idx];
				row[jidx++] = im->green[idx];
				row[jidx++] = im->blue[idx];
#elif BITS_IN_JSAMPLE == 12
				row[jidx++] = im->red[idx] << 4;
				row[jidx++] = im->green[idx] << 4;
				row[jidx++] = im->blue[idx] << 4;
#else
#error IJG JPEG library BITS_IN_JSAMPLE value must be 8 or 12
#endif
			}

			nlines = jpeg_write_scanlines (&cinfo, rowptr, 1);
			if (nlines != 1) {
				gd_error_ex(GD_WARNING, ""gd_jpeg: warning: jpeg_write_scanlines returns %u -- expected 1"", nlines);
			}
		}
	}

 	jpeg_finish_compress (&cinfo);
 	jpeg_destroy_compress (&cinfo);
 	gdFree (row);
 }
",C,"{
	_gdImageJpegCtx(im, outfile, quality);
}

/* returns 0 on success, 1 on failure */
static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality)
		return 1;
	return 0;
","		return;
",,"@@ -132,6 +132,7 @@ const char * gdJpegGetVersionString()
 	}
 }
 
+static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality);
 
 /*
  * Write IM to OUTFILE as a JFIF-formatted JPEG image, using quality
@@ -153,8 +154,11 @@ void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)
 {
 	void *rv;
 	gdIOCtx *out = gdNewDynamicCtx (2048, NULL);
-	gdImageJpegCtx (im, out, quality);
-	rv = gdDPExtractData (out, size);
+	if (!_gdImageJpegCtx(im, out, quality)) {
+		rv = gdDPExtractData(out, size);
+	} else {
+		rv = NULL;
+	}
 	out->gd_free (out);
 
 	return rv;
@@ -163,6 +167,12 @@ void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)
 void jpeg_gdIOCtx_dest (j_compress_ptr cinfo, gdIOCtx * outfile);
 
 void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
+{
+	_gdImageJpegCtx(im, outfile, quality);
+}
+
+/* returns 0 on success, 1 on failure */
+static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality)
 {
 	struct jpeg_compress_struct cinfo;
 	struct jpeg_error_mgr jerr;
@@ -184,7 +194,7 @@ void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
 		if (row) {
 			gdFree (row);
 		}
-		return;
+		return 1;
 	}
 
 	cinfo.err->error_exit = fatal_jpeg_error;
@@ -277,6 +287,7 @@ void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
 	jpeg_finish_compress (&cinfo);
 	jpeg_destroy_compress (&cinfo);
 	gdFree (row);
+	return 0;
 }
 
 gdImagePtr gdImageCreateFromJpeg (FILE * inFile)",php-src,089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,6aff4d01c71238413dc9b4e4dabb884ebeb3beca,1," void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
//fix_flaw_line_below:
//{
//fix_flaw_line_below:
//	_gdImageJpegCtx(im, outfile, quality);
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
///* returns 0 on success, 1 on failure */
//fix_flaw_line_below:
//static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality)
 {
 	struct jpeg_compress_struct cinfo;
 	struct jpeg_error_mgr jerr;
	int i, j, jidx;
	/* volatile so we can gdFree it on return from longjmp */
	volatile JSAMPROW row = 0;
	JSAMPROW rowptr[1];
	jmpbuf_wrapper jmpbufw;
	JDIMENSION nlines;
	char comment[255];

	memset (&cinfo, 0, sizeof (cinfo));
	memset (&jerr, 0, sizeof (jerr));

	cinfo.err = jpeg_std_error (&jerr);
	cinfo.client_data = &jmpbufw;
	if (setjmp (jmpbufw.jmpbuf) != 0) {
		/* we're here courtesy of longjmp */
 		if (row) {
 			gdFree (row);
 		}
//flaw_line_below:
		return;
//fix_flaw_line_below:
//		return 1;
 	}
 
 	cinfo.err->error_exit = fatal_jpeg_error;

	jpeg_create_compress (&cinfo);

	cinfo.image_width = im->sx;
	cinfo.image_height = im->sy;
	cinfo.input_components = 3;	/* # of color components per pixel */
	cinfo.in_color_space = JCS_RGB;	/* colorspace of input image */
	jpeg_set_defaults (&cinfo);

	cinfo.density_unit = 1;
	cinfo.X_density = im->res_x;
	cinfo.Y_density = im->res_y;

	if (quality >= 0) {
		jpeg_set_quality (&cinfo, quality, TRUE);
	}

	/* If user requests interlace, translate that to progressive JPEG */
	if (gdImageGetInterlaced (im)) {
		jpeg_simple_progression (&cinfo);
	}

	jpeg_gdIOCtx_dest (&cinfo, outfile);

	row = (JSAMPROW) safe_emalloc(cinfo.image_width * cinfo.input_components, sizeof(JSAMPLE), 0);
	memset(row, 0, cinfo.image_width * cinfo.input_components * sizeof(JSAMPLE));
	rowptr[0] = row;

	jpeg_start_compress (&cinfo, TRUE);

	if (quality >= 0) {
		snprintf(comment, sizeof(comment)-1, ""CREATOR: gd-jpeg v%s (using IJG JPEG v%d), quality = %d\n"", GD_JPEG_VERSION, JPEG_LIB_VERSION, quality);
	} else {
		snprintf(comment, sizeof(comment)-1, ""CREATOR: gd-jpeg v%s (using IJG JPEG v%d), default quality\n"", GD_JPEG_VERSION, JPEG_LIB_VERSION);
	}
	jpeg_write_marker (&cinfo, JPEG_COM, (unsigned char *) comment, (unsigned int) strlen (comment));
	if (im->trueColor) {

#if BITS_IN_JSAMPLE == 12
		gd_error(""gd-jpeg: error: jpeg library was compiled for 12-bit precision. This is mostly useless, because JPEGs on the web are 8-bit and such versions of the jpeg library won't read or write them. GD doesn't support these unusual images. Edit your jmorecfg.h file to specify the correct precision and completely 'make clean' and 'make install' libjpeg again. Sorry"");
		goto error;
#endif /* BITS_IN_JSAMPLE == 12 */

		for (i = 0; i < im->sy; i++) {
			for (jidx = 0, j = 0; j < im->sx; j++) {
				int val = im->tpixels[i][j];

				row[jidx++] = gdTrueColorGetRed (val);
				row[jidx++] = gdTrueColorGetGreen (val);
				row[jidx++] = gdTrueColorGetBlue (val);
			}

			nlines = jpeg_write_scanlines (&cinfo, rowptr, 1);
			if (nlines != 1) {
				gd_error_ex(GD_WARNING, ""gd_jpeg: warning: jpeg_write_scanlines returns %u -- expected 1"", nlines);
			}
		}
	} else {
		for (i = 0; i < im->sy; i++) {
			for (jidx = 0, j = 0; j < im->sx; j++) {
				int idx = im->pixels[i][j];

				/* NB: Although gd RGB values are ints, their max value is
				 * 255 (see the documentation for gdImageColorAllocate())
				 * -- perfect for 8-bit JPEG encoding (which is the norm)
				 */
#if BITS_IN_JSAMPLE == 8
				row[jidx++] = im->red[idx];
				row[jidx++] = im->green[idx];
				row[jidx++] = im->blue[idx];
#elif BITS_IN_JSAMPLE == 12
				row[jidx++] = im->red[idx] << 4;
				row[jidx++] = im->green[idx] << 4;
				row[jidx++] = im->blue[idx] << 4;
#else
#error IJG JPEG library BITS_IN_JSAMPLE value must be 8 or 12
#endif
			}

			nlines = jpeg_write_scanlines (&cinfo, rowptr, 1);
			if (nlines != 1) {
				gd_error_ex(GD_WARNING, ""gd_jpeg: warning: jpeg_write_scanlines returns %u -- expected 1"", nlines);
			}
		}
	}

 	jpeg_finish_compress (&cinfo);
 	jpeg_destroy_compress (&cinfo);
 	gdFree (row);
//fix_flaw_line_below:
//	return 0;
 }
"
5172,182908,,Remote,Not required,Partial,CVE-2019-6978,https://www.cvedetails.com/cve/CVE-2019-6978/,CWE-415,Low,Partial,Partial,,2019-01-28,7.5,"The GD Graphics Library (aka LibGD) 2.2.5 has a double free in the gdImage*Ptr() functions in gd_gif_out.c, gd_jpeg.c, and gd_wbmp.c. NOTE: PHP is unaffected.",2019-04-04,,5,https://github.com/php/php-src/commit/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,"Sync with upstream

Even though libgd/libgd#492 is not a relevant bug fix for PHP, since
the binding doesn't use the `gdImage*Ptr()` functions at all, we're
porting the fix to stay in sync here.",2,ext/gd/libgd/gd_jpeg.c,"{""sha"": ""2e1f38af70477f91277a55fcb7f955a5f3cc3cea"", ""filename"": ""ext/gd/libgd/gd_gif_out.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 3, ""changes"": 20, ""blob_url"": ""https://github.com/php/php-src/blob/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_gif_out.c"", ""raw_url"": ""https://github.com/php/php-src/raw/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_gif_out.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/libgd/gd_gif_out.c?ref=089f7c0bc28d399b0420aa6ef058e4c1c120b2ae"", ""patch"": ""@@ -97,12 +97,18 @@ static void cl_hash (register count_int chsize, GifCtx *ctx);\n static void char_init (GifCtx *ctx);\n static void char_out (int c, GifCtx *ctx);\n static void flush_char (GifCtx *ctx);\n+\n+static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out);\n+\n void * gdImageGifPtr (gdImagePtr im, int *size)\n {\n   void *rv;\n   gdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n-  gdImageGifCtx (im, out);\n-  rv = gdDPExtractData (out, size);\n+\tif (!_gdImageGifCtx(im, out)) {\n+\t\trv = gdDPExtractData(out, size);\n+\t} else {\n+\t\trv = NULL;\n+\t}\n   out->gd_free (out);\n   return rv;\n }\n@@ -115,6 +121,12 @@ void gdImageGif (gdImagePtr im, FILE * outFile)\n }\n \n void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n+{\n+\t_gdImageGifCtx(im, out);\n+}\n+\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n {\n \tgdImagePtr pim = 0, tim = im;\n \tint interlace, BitsPerPixel;\n@@ -125,7 +137,7 @@ void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n \t\t\tbased temporary image. */\n \t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n \t\tif (!pim) {\n-\t\t\treturn;\n+\t\t\treturn 1;\n \t\t}\n \t\ttim = pim;\n \t}\n@@ -138,6 +150,8 @@ void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n \t\t/* Destroy palette based temporary image. */\n \t\tgdImageDestroy(\tpim);\n \t}\n+\n+    return 0;\n }\n \n static int""}<_**next**_>{""sha"": ""ef46c4a22cf03e6583b90295b63b06405e4ae63e"", ""filename"": ""ext/gd/libgd/gd_jpeg.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 3, ""changes"": 17, ""blob_url"": ""https://github.com/php/php-src/blob/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_jpeg.c"", ""raw_url"": ""https://github.com/php/php-src/raw/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_jpeg.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/libgd/gd_jpeg.c?ref=089f7c0bc28d399b0420aa6ef058e4c1c120b2ae"", ""patch"": ""@@ -132,6 +132,7 @@ const char * gdJpegGetVersionString()\n \t}\n }\n \n+static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality);\n \n /*\n  * Write IM to OUTFILE as a JFIF-formatted JPEG image, using quality\n@@ -153,8 +154,11 @@ void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)\n {\n \tvoid *rv;\n \tgdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n-\tgdImageJpegCtx (im, out, quality);\n-\trv = gdDPExtractData (out, size);\n+\tif (!_gdImageJpegCtx(im, out, quality)) {\n+\t\trv = gdDPExtractData(out, size);\n+\t} else {\n+\t\trv = NULL;\n+\t}\n \tout->gd_free (out);\n \n \treturn rv;\n@@ -163,6 +167,12 @@ void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)\n void jpeg_gdIOCtx_dest (j_compress_ptr cinfo, gdIOCtx * outfile);\n \n void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n+{\n+\t_gdImageJpegCtx(im, outfile, quality);\n+}\n+\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality)\n {\n \tstruct jpeg_compress_struct cinfo;\n \tstruct jpeg_error_mgr jerr;\n@@ -184,7 +194,7 @@ void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n \t\tif (row) {\n \t\t\tgdFree (row);\n \t\t}\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \tcinfo.err->error_exit = fatal_jpeg_error;\n@@ -277,6 +287,7 @@ void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n \tjpeg_finish_compress (&cinfo);\n \tjpeg_destroy_compress (&cinfo);\n \tgdFree (row);\n+\treturn 0;\n }\n \n gdImagePtr gdImageCreateFromJpeg (FILE * inFile)""}<_**next**_>{""sha"": ""fd9edad2cafa85a2641d61c5e1b1ebc54f4c348f"", ""filename"": ""ext/gd/libgd/gd_wbmp.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 3, ""changes"": 18, ""blob_url"": ""https://github.com/php/php-src/blob/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_wbmp.c"", ""raw_url"": ""https://github.com/php/php-src/raw/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_wbmp.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/libgd/gd_wbmp.c?ref=089f7c0bc28d399b0420aa6ef058e4c1c120b2ae"", ""patch"": ""@@ -82,6 +82,7 @@ int gd_getin (void *in)\n \treturn (gdGetC((gdIOCtx *) in));\n }\n \n+static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out);\n \n /*      gdImageWBMPCtx\n    **  --------------\n@@ -93,14 +94,20 @@ int gd_getin (void *in)\n    **  out:    the stream where to write\n  */\n void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)\n+{\n+\t_gdImageWBMPCtx(image, fg, out);\n+}\n+\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)\n {\n \tint x, y, pos;\n \tWbmp *wbmp;\n \n \t/* create the WBMP */\n \tif ((wbmp = createwbmp (gdImageSX (image), gdImageSY (image), WBMP_WHITE)) == NULL) {\n \t\tgd_error(\""Could not create WBMP\"");\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \t/* fill up the WBMP structure */\n@@ -116,7 +123,9 @@ void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)\n \n \t/* write the WBMP to a gd file descriptor */\n \tif (writewbmp (wbmp, &gd_putout, out)) {\n+\t\tfreewbmp(wbmp);\n \t\tgd_error(\""Could not save WBMP\"");\n+\t\treturn 1;\n \t}\n \t/* des submitted this bugfix: gdFree the memory. */\n \tfreewbmp(wbmp);\n@@ -204,8 +213,11 @@ void * gdImageWBMPPtr (gdImagePtr im, int *size, int fg)\n {\n \tvoid *rv;\n \tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n-\tgdImageWBMPCtx(im, fg, out);\n-\trv = gdDPExtractData(out, size);\n+\tif (!_gdImageWBMPCtx(im, fg, out)) {\n+\t\trv = gdDPExtractData(out, size);\n+\t} else {\n+\t\trv = NULL;\n+\t}\n \tout->gd_free(out);\n \n \treturn rv;""}","void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)
 {
 	void *rv;
 	gdIOCtx *out = gdNewDynamicCtx (2048, NULL);
	if (!_gdImageJpegCtx(im, out, quality)) {
		rv = gdDPExtractData(out, size);
	} else {
		rv = NULL;
	}
 	out->gd_free (out);
 
 	return rv;
}
","void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)
 {
 	void *rv;
 	gdIOCtx *out = gdNewDynamicCtx (2048, NULL);
	gdImageJpegCtx (im, out, quality);
	rv = gdDPExtractData (out, size);
 	out->gd_free (out);
 
 	return rv;
}
",C,"	if (!_gdImageJpegCtx(im, out, quality)) {
		rv = gdDPExtractData(out, size);
	} else {
		rv = NULL;
	}
","	gdImageJpegCtx (im, out, quality);
	rv = gdDPExtractData (out, size);
",,"@@ -132,6 +132,7 @@ const char * gdJpegGetVersionString()
 	}
 }
 
+static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality);
 
 /*
  * Write IM to OUTFILE as a JFIF-formatted JPEG image, using quality
@@ -153,8 +154,11 @@ void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)
 {
 	void *rv;
 	gdIOCtx *out = gdNewDynamicCtx (2048, NULL);
-	gdImageJpegCtx (im, out, quality);
-	rv = gdDPExtractData (out, size);
+	if (!_gdImageJpegCtx(im, out, quality)) {
+		rv = gdDPExtractData(out, size);
+	} else {
+		rv = NULL;
+	}
 	out->gd_free (out);
 
 	return rv;
@@ -163,6 +167,12 @@ void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)
 void jpeg_gdIOCtx_dest (j_compress_ptr cinfo, gdIOCtx * outfile);
 
 void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
+{
+	_gdImageJpegCtx(im, outfile, quality);
+}
+
+/* returns 0 on success, 1 on failure */
+static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality)
 {
 	struct jpeg_compress_struct cinfo;
 	struct jpeg_error_mgr jerr;
@@ -184,7 +194,7 @@ void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
 		if (row) {
 			gdFree (row);
 		}
-		return;
+		return 1;
 	}
 
 	cinfo.err->error_exit = fatal_jpeg_error;
@@ -277,6 +287,7 @@ void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
 	jpeg_finish_compress (&cinfo);
 	jpeg_destroy_compress (&cinfo);
 	gdFree (row);
+	return 0;
 }
 
 gdImagePtr gdImageCreateFromJpeg (FILE * inFile)",php-src,089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,6aff4d01c71238413dc9b4e4dabb884ebeb3beca,1,"void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)
 {
 	void *rv;
 	gdIOCtx *out = gdNewDynamicCtx (2048, NULL);
//flaw_line_below:
	gdImageJpegCtx (im, out, quality);
//flaw_line_below:
	rv = gdDPExtractData (out, size);
//fix_flaw_line_below:
//	if (!_gdImageJpegCtx(im, out, quality)) {
//fix_flaw_line_below:
//		rv = gdDPExtractData(out, size);
//fix_flaw_line_below:
//	} else {
//fix_flaw_line_below:
//		rv = NULL;
//fix_flaw_line_below:
//	}
 	out->gd_free (out);
 
 	return rv;
}
"
5173,182909,,Remote,Not required,Partial,CVE-2019-6978,https://www.cvedetails.com/cve/CVE-2019-6978/,CWE-415,Low,Partial,Partial,,2019-01-28,7.5,"The GD Graphics Library (aka LibGD) 2.2.5 has a double free in the gdImage*Ptr() functions in gd_gif_out.c, gd_jpeg.c, and gd_wbmp.c. NOTE: PHP is unaffected.",2019-04-04,,9,https://github.com/php/php-src/commit/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,"Sync with upstream

Even though libgd/libgd#492 is not a relevant bug fix for PHP, since
the binding doesn't use the `gdImage*Ptr()` functions at all, we're
porting the fix to stay in sync here.",1,ext/gd/libgd/gd_wbmp.c,"{""sha"": ""2e1f38af70477f91277a55fcb7f955a5f3cc3cea"", ""filename"": ""ext/gd/libgd/gd_gif_out.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 3, ""changes"": 20, ""blob_url"": ""https://github.com/php/php-src/blob/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_gif_out.c"", ""raw_url"": ""https://github.com/php/php-src/raw/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_gif_out.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/libgd/gd_gif_out.c?ref=089f7c0bc28d399b0420aa6ef058e4c1c120b2ae"", ""patch"": ""@@ -97,12 +97,18 @@ static void cl_hash (register count_int chsize, GifCtx *ctx);\n static void char_init (GifCtx *ctx);\n static void char_out (int c, GifCtx *ctx);\n static void flush_char (GifCtx *ctx);\n+\n+static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out);\n+\n void * gdImageGifPtr (gdImagePtr im, int *size)\n {\n   void *rv;\n   gdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n-  gdImageGifCtx (im, out);\n-  rv = gdDPExtractData (out, size);\n+\tif (!_gdImageGifCtx(im, out)) {\n+\t\trv = gdDPExtractData(out, size);\n+\t} else {\n+\t\trv = NULL;\n+\t}\n   out->gd_free (out);\n   return rv;\n }\n@@ -115,6 +121,12 @@ void gdImageGif (gdImagePtr im, FILE * outFile)\n }\n \n void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n+{\n+\t_gdImageGifCtx(im, out);\n+}\n+\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n {\n \tgdImagePtr pim = 0, tim = im;\n \tint interlace, BitsPerPixel;\n@@ -125,7 +137,7 @@ void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n \t\t\tbased temporary image. */\n \t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n \t\tif (!pim) {\n-\t\t\treturn;\n+\t\t\treturn 1;\n \t\t}\n \t\ttim = pim;\n \t}\n@@ -138,6 +150,8 @@ void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n \t\t/* Destroy palette based temporary image. */\n \t\tgdImageDestroy(\tpim);\n \t}\n+\n+    return 0;\n }\n \n static int""}<_**next**_>{""sha"": ""ef46c4a22cf03e6583b90295b63b06405e4ae63e"", ""filename"": ""ext/gd/libgd/gd_jpeg.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 3, ""changes"": 17, ""blob_url"": ""https://github.com/php/php-src/blob/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_jpeg.c"", ""raw_url"": ""https://github.com/php/php-src/raw/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_jpeg.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/libgd/gd_jpeg.c?ref=089f7c0bc28d399b0420aa6ef058e4c1c120b2ae"", ""patch"": ""@@ -132,6 +132,7 @@ const char * gdJpegGetVersionString()\n \t}\n }\n \n+static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality);\n \n /*\n  * Write IM to OUTFILE as a JFIF-formatted JPEG image, using quality\n@@ -153,8 +154,11 @@ void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)\n {\n \tvoid *rv;\n \tgdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n-\tgdImageJpegCtx (im, out, quality);\n-\trv = gdDPExtractData (out, size);\n+\tif (!_gdImageJpegCtx(im, out, quality)) {\n+\t\trv = gdDPExtractData(out, size);\n+\t} else {\n+\t\trv = NULL;\n+\t}\n \tout->gd_free (out);\n \n \treturn rv;\n@@ -163,6 +167,12 @@ void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)\n void jpeg_gdIOCtx_dest (j_compress_ptr cinfo, gdIOCtx * outfile);\n \n void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n+{\n+\t_gdImageJpegCtx(im, outfile, quality);\n+}\n+\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality)\n {\n \tstruct jpeg_compress_struct cinfo;\n \tstruct jpeg_error_mgr jerr;\n@@ -184,7 +194,7 @@ void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n \t\tif (row) {\n \t\t\tgdFree (row);\n \t\t}\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \tcinfo.err->error_exit = fatal_jpeg_error;\n@@ -277,6 +287,7 @@ void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n \tjpeg_finish_compress (&cinfo);\n \tjpeg_destroy_compress (&cinfo);\n \tgdFree (row);\n+\treturn 0;\n }\n \n gdImagePtr gdImageCreateFromJpeg (FILE * inFile)""}<_**next**_>{""sha"": ""fd9edad2cafa85a2641d61c5e1b1ebc54f4c348f"", ""filename"": ""ext/gd/libgd/gd_wbmp.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 3, ""changes"": 18, ""blob_url"": ""https://github.com/php/php-src/blob/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_wbmp.c"", ""raw_url"": ""https://github.com/php/php-src/raw/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_wbmp.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/libgd/gd_wbmp.c?ref=089f7c0bc28d399b0420aa6ef058e4c1c120b2ae"", ""patch"": ""@@ -82,6 +82,7 @@ int gd_getin (void *in)\n \treturn (gdGetC((gdIOCtx *) in));\n }\n \n+static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out);\n \n /*      gdImageWBMPCtx\n    **  --------------\n@@ -93,14 +94,20 @@ int gd_getin (void *in)\n    **  out:    the stream where to write\n  */\n void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)\n+{\n+\t_gdImageWBMPCtx(image, fg, out);\n+}\n+\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)\n {\n \tint x, y, pos;\n \tWbmp *wbmp;\n \n \t/* create the WBMP */\n \tif ((wbmp = createwbmp (gdImageSX (image), gdImageSY (image), WBMP_WHITE)) == NULL) {\n \t\tgd_error(\""Could not create WBMP\"");\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \t/* fill up the WBMP structure */\n@@ -116,7 +123,9 @@ void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)\n \n \t/* write the WBMP to a gd file descriptor */\n \tif (writewbmp (wbmp, &gd_putout, out)) {\n+\t\tfreewbmp(wbmp);\n \t\tgd_error(\""Could not save WBMP\"");\n+\t\treturn 1;\n \t}\n \t/* des submitted this bugfix: gdFree the memory. */\n \tfreewbmp(wbmp);\n@@ -204,8 +213,11 @@ void * gdImageWBMPPtr (gdImagePtr im, int *size, int fg)\n {\n \tvoid *rv;\n \tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n-\tgdImageWBMPCtx(im, fg, out);\n-\trv = gdDPExtractData(out, size);\n+\tif (!_gdImageWBMPCtx(im, fg, out)) {\n+\t\trv = gdDPExtractData(out, size);\n+\t} else {\n+\t\trv = NULL;\n+\t}\n \tout->gd_free(out);\n \n \treturn rv;""}"," void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)
{
	_gdImageWBMPCtx(image, fg, out);
}

/* returns 0 on success, 1 on failure */
static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)
 {
 	int x, y, pos;
 	Wbmp *wbmp;
 
 	/* create the WBMP */
 	if ((wbmp = createwbmp (gdImageSX (image), gdImageSY (image), WBMP_WHITE)) == NULL) {
 		gd_error(""Could not create WBMP"");
		return 1;
 	}
 
 	/* fill up the WBMP structure */
	pos = 0;
	for (y = 0; y < gdImageSY(image); y++) {
		for (x = 0; x < gdImageSX(image); x++) {
			if (gdImageGetPixel (image, x, y) == fg) {
				wbmp->bitmap[pos] = WBMP_BLACK;
			}
			pos++;
		}
	}
 
 	/* write the WBMP to a gd file descriptor */
 	if (writewbmp (wbmp, &gd_putout, out)) {
		freewbmp(wbmp);
 		gd_error(""Could not save WBMP"");
		return 1;
 	}
 	/* des submitted this bugfix: gdFree the memory. */
 	freewbmp(wbmp);
}
"," void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)
 {
 	int x, y, pos;
 	Wbmp *wbmp;
 
 	/* create the WBMP */
 	if ((wbmp = createwbmp (gdImageSX (image), gdImageSY (image), WBMP_WHITE)) == NULL) {
 		gd_error(""Could not create WBMP"");
		return;
 	}
 
 	/* fill up the WBMP structure */
	pos = 0;
	for (y = 0; y < gdImageSY(image); y++) {
		for (x = 0; x < gdImageSX(image); x++) {
			if (gdImageGetPixel (image, x, y) == fg) {
				wbmp->bitmap[pos] = WBMP_BLACK;
			}
			pos++;
		}
	}
 
 	/* write the WBMP to a gd file descriptor */
 	if (writewbmp (wbmp, &gd_putout, out)) {
 		gd_error(""Could not save WBMP"");
 	}
 	/* des submitted this bugfix: gdFree the memory. */
 	freewbmp(wbmp);
}
",C,"{
	_gdImageWBMPCtx(image, fg, out);
}

/* returns 0 on success, 1 on failure */
static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)
		return 1;
		freewbmp(wbmp);
		return 1;
","		return;
",,"@@ -82,6 +82,7 @@ int gd_getin (void *in)
 	return (gdGetC((gdIOCtx *) in));
 }
 
+static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out);
 
 /*      gdImageWBMPCtx
    **  --------------
@@ -93,14 +94,20 @@ int gd_getin (void *in)
    **  out:    the stream where to write
  */
 void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)
+{
+	_gdImageWBMPCtx(image, fg, out);
+}
+
+/* returns 0 on success, 1 on failure */
+static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)
 {
 	int x, y, pos;
 	Wbmp *wbmp;
 
 	/* create the WBMP */
 	if ((wbmp = createwbmp (gdImageSX (image), gdImageSY (image), WBMP_WHITE)) == NULL) {
 		gd_error(""Could not create WBMP"");
-		return;
+		return 1;
 	}
 
 	/* fill up the WBMP structure */
@@ -116,7 +123,9 @@ void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)
 
 	/* write the WBMP to a gd file descriptor */
 	if (writewbmp (wbmp, &gd_putout, out)) {
+		freewbmp(wbmp);
 		gd_error(""Could not save WBMP"");
+		return 1;
 	}
 	/* des submitted this bugfix: gdFree the memory. */
 	freewbmp(wbmp);
@@ -204,8 +213,11 @@ void * gdImageWBMPPtr (gdImagePtr im, int *size, int fg)
 {
 	void *rv;
 	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
-	gdImageWBMPCtx(im, fg, out);
-	rv = gdDPExtractData(out, size);
+	if (!_gdImageWBMPCtx(im, fg, out)) {
+		rv = gdDPExtractData(out, size);
+	} else {
+		rv = NULL;
+	}
 	out->gd_free(out);
 
 	return rv;",php-src,089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,6aff4d01c71238413dc9b4e4dabb884ebeb3beca,1," void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)
//fix_flaw_line_below:
//{
//fix_flaw_line_below:
//	_gdImageWBMPCtx(image, fg, out);
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
///* returns 0 on success, 1 on failure */
//fix_flaw_line_below:
//static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)
 {
 	int x, y, pos;
 	Wbmp *wbmp;
 
 	/* create the WBMP */
 	if ((wbmp = createwbmp (gdImageSX (image), gdImageSY (image), WBMP_WHITE)) == NULL) {
 		gd_error(""Could not create WBMP"");
//flaw_line_below:
		return;
//fix_flaw_line_below:
//		return 1;
 	}
 
 	/* fill up the WBMP structure */
	pos = 0;
	for (y = 0; y < gdImageSY(image); y++) {
		for (x = 0; x < gdImageSX(image); x++) {
			if (gdImageGetPixel (image, x, y) == fg) {
				wbmp->bitmap[pos] = WBMP_BLACK;
			}
			pos++;
		}
	}
 
 	/* write the WBMP to a gd file descriptor */
 	if (writewbmp (wbmp, &gd_putout, out)) {
//fix_flaw_line_below:
//		freewbmp(wbmp);
 		gd_error(""Could not save WBMP"");
//fix_flaw_line_below:
//		return 1;
 	}
 	/* des submitted this bugfix: gdFree the memory. */
 	freewbmp(wbmp);
}
"
5174,182910,,Remote,Not required,Partial,CVE-2019-6978,https://www.cvedetails.com/cve/CVE-2019-6978/,CWE-415,Low,Partial,Partial,,2019-01-28,7.5,"The GD Graphics Library (aka LibGD) 2.2.5 has a double free in the gdImage*Ptr() functions in gd_gif_out.c, gd_jpeg.c, and gd_wbmp.c. NOTE: PHP is unaffected.",2019-04-04,,5,https://github.com/php/php-src/commit/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,"Sync with upstream

Even though libgd/libgd#492 is not a relevant bug fix for PHP, since
the binding doesn't use the `gdImage*Ptr()` functions at all, we're
porting the fix to stay in sync here.",2,ext/gd/libgd/gd_wbmp.c,"{""sha"": ""2e1f38af70477f91277a55fcb7f955a5f3cc3cea"", ""filename"": ""ext/gd/libgd/gd_gif_out.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 3, ""changes"": 20, ""blob_url"": ""https://github.com/php/php-src/blob/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_gif_out.c"", ""raw_url"": ""https://github.com/php/php-src/raw/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_gif_out.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/libgd/gd_gif_out.c?ref=089f7c0bc28d399b0420aa6ef058e4c1c120b2ae"", ""patch"": ""@@ -97,12 +97,18 @@ static void cl_hash (register count_int chsize, GifCtx *ctx);\n static void char_init (GifCtx *ctx);\n static void char_out (int c, GifCtx *ctx);\n static void flush_char (GifCtx *ctx);\n+\n+static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out);\n+\n void * gdImageGifPtr (gdImagePtr im, int *size)\n {\n   void *rv;\n   gdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n-  gdImageGifCtx (im, out);\n-  rv = gdDPExtractData (out, size);\n+\tif (!_gdImageGifCtx(im, out)) {\n+\t\trv = gdDPExtractData(out, size);\n+\t} else {\n+\t\trv = NULL;\n+\t}\n   out->gd_free (out);\n   return rv;\n }\n@@ -115,6 +121,12 @@ void gdImageGif (gdImagePtr im, FILE * outFile)\n }\n \n void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n+{\n+\t_gdImageGifCtx(im, out);\n+}\n+\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n {\n \tgdImagePtr pim = 0, tim = im;\n \tint interlace, BitsPerPixel;\n@@ -125,7 +137,7 @@ void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n \t\t\tbased temporary image. */\n \t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n \t\tif (!pim) {\n-\t\t\treturn;\n+\t\t\treturn 1;\n \t\t}\n \t\ttim = pim;\n \t}\n@@ -138,6 +150,8 @@ void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n \t\t/* Destroy palette based temporary image. */\n \t\tgdImageDestroy(\tpim);\n \t}\n+\n+    return 0;\n }\n \n static int""}<_**next**_>{""sha"": ""ef46c4a22cf03e6583b90295b63b06405e4ae63e"", ""filename"": ""ext/gd/libgd/gd_jpeg.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 3, ""changes"": 17, ""blob_url"": ""https://github.com/php/php-src/blob/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_jpeg.c"", ""raw_url"": ""https://github.com/php/php-src/raw/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_jpeg.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/libgd/gd_jpeg.c?ref=089f7c0bc28d399b0420aa6ef058e4c1c120b2ae"", ""patch"": ""@@ -132,6 +132,7 @@ const char * gdJpegGetVersionString()\n \t}\n }\n \n+static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality);\n \n /*\n  * Write IM to OUTFILE as a JFIF-formatted JPEG image, using quality\n@@ -153,8 +154,11 @@ void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)\n {\n \tvoid *rv;\n \tgdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n-\tgdImageJpegCtx (im, out, quality);\n-\trv = gdDPExtractData (out, size);\n+\tif (!_gdImageJpegCtx(im, out, quality)) {\n+\t\trv = gdDPExtractData(out, size);\n+\t} else {\n+\t\trv = NULL;\n+\t}\n \tout->gd_free (out);\n \n \treturn rv;\n@@ -163,6 +167,12 @@ void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)\n void jpeg_gdIOCtx_dest (j_compress_ptr cinfo, gdIOCtx * outfile);\n \n void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n+{\n+\t_gdImageJpegCtx(im, outfile, quality);\n+}\n+\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality)\n {\n \tstruct jpeg_compress_struct cinfo;\n \tstruct jpeg_error_mgr jerr;\n@@ -184,7 +194,7 @@ void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n \t\tif (row) {\n \t\t\tgdFree (row);\n \t\t}\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \tcinfo.err->error_exit = fatal_jpeg_error;\n@@ -277,6 +287,7 @@ void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n \tjpeg_finish_compress (&cinfo);\n \tjpeg_destroy_compress (&cinfo);\n \tgdFree (row);\n+\treturn 0;\n }\n \n gdImagePtr gdImageCreateFromJpeg (FILE * inFile)""}<_**next**_>{""sha"": ""fd9edad2cafa85a2641d61c5e1b1ebc54f4c348f"", ""filename"": ""ext/gd/libgd/gd_wbmp.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 3, ""changes"": 18, ""blob_url"": ""https://github.com/php/php-src/blob/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_wbmp.c"", ""raw_url"": ""https://github.com/php/php-src/raw/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae/ext/gd/libgd/gd_wbmp.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/gd/libgd/gd_wbmp.c?ref=089f7c0bc28d399b0420aa6ef058e4c1c120b2ae"", ""patch"": ""@@ -82,6 +82,7 @@ int gd_getin (void *in)\n \treturn (gdGetC((gdIOCtx *) in));\n }\n \n+static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out);\n \n /*      gdImageWBMPCtx\n    **  --------------\n@@ -93,14 +94,20 @@ int gd_getin (void *in)\n    **  out:    the stream where to write\n  */\n void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)\n+{\n+\t_gdImageWBMPCtx(image, fg, out);\n+}\n+\n+/* returns 0 on success, 1 on failure */\n+static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)\n {\n \tint x, y, pos;\n \tWbmp *wbmp;\n \n \t/* create the WBMP */\n \tif ((wbmp = createwbmp (gdImageSX (image), gdImageSY (image), WBMP_WHITE)) == NULL) {\n \t\tgd_error(\""Could not create WBMP\"");\n-\t\treturn;\n+\t\treturn 1;\n \t}\n \n \t/* fill up the WBMP structure */\n@@ -116,7 +123,9 @@ void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)\n \n \t/* write the WBMP to a gd file descriptor */\n \tif (writewbmp (wbmp, &gd_putout, out)) {\n+\t\tfreewbmp(wbmp);\n \t\tgd_error(\""Could not save WBMP\"");\n+\t\treturn 1;\n \t}\n \t/* des submitted this bugfix: gdFree the memory. */\n \tfreewbmp(wbmp);\n@@ -204,8 +213,11 @@ void * gdImageWBMPPtr (gdImagePtr im, int *size, int fg)\n {\n \tvoid *rv;\n \tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n-\tgdImageWBMPCtx(im, fg, out);\n-\trv = gdDPExtractData(out, size);\n+\tif (!_gdImageWBMPCtx(im, fg, out)) {\n+\t\trv = gdDPExtractData(out, size);\n+\t} else {\n+\t\trv = NULL;\n+\t}\n \tout->gd_free(out);\n \n \treturn rv;""}","void * gdImageWBMPPtr (gdImagePtr im, int *size, int fg)
 {
 	void *rv;
 	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
	if (!_gdImageWBMPCtx(im, fg, out)) {
		rv = gdDPExtractData(out, size);
	} else {
		rv = NULL;
	}
 	out->gd_free(out);
 
 	return rv;
}
","void * gdImageWBMPPtr (gdImagePtr im, int *size, int fg)
 {
 	void *rv;
 	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
	gdImageWBMPCtx(im, fg, out);
	rv = gdDPExtractData(out, size);
 	out->gd_free(out);
 
 	return rv;
}
",C,"	if (!_gdImageWBMPCtx(im, fg, out)) {
		rv = gdDPExtractData(out, size);
	} else {
		rv = NULL;
	}
","	gdImageWBMPCtx(im, fg, out);
	rv = gdDPExtractData(out, size);
",,"@@ -82,6 +82,7 @@ int gd_getin (void *in)
 	return (gdGetC((gdIOCtx *) in));
 }
 
+static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out);
 
 /*      gdImageWBMPCtx
    **  --------------
@@ -93,14 +94,20 @@ int gd_getin (void *in)
    **  out:    the stream where to write
  */
 void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)
+{
+	_gdImageWBMPCtx(image, fg, out);
+}
+
+/* returns 0 on success, 1 on failure */
+static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)
 {
 	int x, y, pos;
 	Wbmp *wbmp;
 
 	/* create the WBMP */
 	if ((wbmp = createwbmp (gdImageSX (image), gdImageSY (image), WBMP_WHITE)) == NULL) {
 		gd_error(""Could not create WBMP"");
-		return;
+		return 1;
 	}
 
 	/* fill up the WBMP structure */
@@ -116,7 +123,9 @@ void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)
 
 	/* write the WBMP to a gd file descriptor */
 	if (writewbmp (wbmp, &gd_putout, out)) {
+		freewbmp(wbmp);
 		gd_error(""Could not save WBMP"");
+		return 1;
 	}
 	/* des submitted this bugfix: gdFree the memory. */
 	freewbmp(wbmp);
@@ -204,8 +213,11 @@ void * gdImageWBMPPtr (gdImagePtr im, int *size, int fg)
 {
 	void *rv;
 	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
-	gdImageWBMPCtx(im, fg, out);
-	rv = gdDPExtractData(out, size);
+	if (!_gdImageWBMPCtx(im, fg, out)) {
+		rv = gdDPExtractData(out, size);
+	} else {
+		rv = NULL;
+	}
 	out->gd_free(out);
 
 	return rv;",php-src,089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,6aff4d01c71238413dc9b4e4dabb884ebeb3beca,1,"void * gdImageWBMPPtr (gdImagePtr im, int *size, int fg)
 {
 	void *rv;
 	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
//flaw_line_below:
	gdImageWBMPCtx(im, fg, out);
//flaw_line_below:
	rv = gdDPExtractData(out, size);
//fix_flaw_line_below:
//	if (!_gdImageWBMPCtx(im, fg, out)) {
//fix_flaw_line_below:
//		rv = gdDPExtractData(out, size);
//fix_flaw_line_below:
//	} else {
//fix_flaw_line_below:
//		rv = NULL;
//fix_flaw_line_below:
//	}
 	out->gd_free(out);
 
 	return rv;
}
"
5197,182933,,Remote,Not required,Complete,CVE-2018-20961,https://www.cvedetails.com/cve/CVE-2018-20961/,CWE-415,Low,Complete,Complete,,2019-08-07,10.0,"In the Linux kernel before 4.16.4, a double free vulnerability in the f_midi_set_alt function of drivers/usb/gadget/function/f_midi.c in the f_midi driver may allow attackers to cause a denial of service or possibly have unspecified other impact.",2019-08-27,DoS ,2,https://github.com/torvalds/linux/commit/7fafcfdf6377b18b2a726ea554d6e593ba44349f,7fafcfdf6377b18b2a726ea554d6e593ba44349f,"USB: gadget: f_midi: fixing a possible double-free in f_midi

It looks like there is a possibility of a double-free vulnerability on an
error path of the f_midi_set_alt function in the f_midi driver. If the
path is feasible then free_ep_req gets called twice:

         req->complete = f_midi_complete;
         err = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);
            => ...
             usb_gadget_giveback_request
               =>
                 f_midi_complete (CALLBACK)
                   (inside f_midi_complete, for various cases of status)
                   free_ep_req(ep, req); // first kfree
         if (err) {
                 ERROR(midi, ""%s: couldn't enqueue request: %d\n"",
                             midi->out_ep->name, err);
                 free_ep_req(midi->out_ep, req); // second kfree
                 return err;
         }

The double-free possibility was introduced with commit ad0d1a058eac
(""usb: gadget: f_midi: fix leak on failed to enqueue out requests"").

Found by MOXCAFE tool.

Signed-off-by: Tuba Yavuz <tuba@ece.ufl.edu>
Fixes: ad0d1a058eac (""usb: gadget: f_midi: fix leak on failed to enqueue out requests"")
Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
Cc: stable <stable@vger.kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",1,drivers/usb/gadget/function/f_midi.c,"{""sha"": ""e8f35db42394d03166ebc8a0ef3114325ae478df"", ""filename"": ""drivers/usb/gadget/function/f_midi.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/7fafcfdf6377b18b2a726ea554d6e593ba44349f/drivers/usb/gadget/function/f_midi.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/7fafcfdf6377b18b2a726ea554d6e593ba44349f/drivers/usb/gadget/function/f_midi.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/gadget/function/f_midi.c?ref=7fafcfdf6377b18b2a726ea554d6e593ba44349f"", ""patch"": ""@@ -404,7 +404,8 @@ static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n \t\tif (err) {\n \t\t\tERROR(midi, \""%s: couldn't enqueue request: %d\\n\"",\n \t\t\t\t    midi->out_ep->name, err);\n-\t\t\tfree_ep_req(midi->out_ep, req);\n+\t\t\tif (req->buf != NULL)\n+\t\t\t\tfree_ep_req(midi->out_ep, req);\n \t\t\treturn err;\n \t\t}\n \t}""}<_**next**_>{""sha"": ""09f90447fed5d4a998ac650de2d32db9245fb412"", ""filename"": ""drivers/usb/gadget/u_f.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/7fafcfdf6377b18b2a726ea554d6e593ba44349f/drivers/usb/gadget/u_f.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/7fafcfdf6377b18b2a726ea554d6e593ba44349f/drivers/usb/gadget/u_f.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/gadget/u_f.h?ref=7fafcfdf6377b18b2a726ea554d6e593ba44349f"", ""patch"": ""@@ -61,7 +61,9 @@ struct usb_request *alloc_ep_req(struct usb_ep *ep, size_t len);\n /* Frees a usb_request previously allocated by alloc_ep_req() */\n static inline void free_ep_req(struct usb_ep *ep, struct usb_request *req)\n {\n+\tWARN_ON(req->buf == NULL);\n \tkfree(req->buf);\n+\treq->buf = NULL;\n \tusb_ep_free_request(ep, req);\n }\n ""}","static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
{
	struct f_midi *midi = func_to_midi(f);
	unsigned i;
	int err;

	/* we only set alt for MIDIStreaming interface */
	if (intf != midi->ms_id)
		return 0;

	err = f_midi_start_ep(midi, f, midi->in_ep);
	if (err)
		return err;

	err = f_midi_start_ep(midi, f, midi->out_ep);
	if (err)
		return err;

	/* pre-allocate write usb requests to use on f_midi_transmit. */
	while (kfifo_avail(&midi->in_req_fifo)) {
		struct usb_request *req =
			midi_alloc_ep_req(midi->in_ep, midi->buflen);

		if (req == NULL)
			return -ENOMEM;

		req->length = 0;
		req->complete = f_midi_complete;

		kfifo_put(&midi->in_req_fifo, req);
	}

	/* allocate a bunch of read buffers and queue them all at once. */
	for (i = 0; i < midi->qlen && err == 0; i++) {
		struct usb_request *req =
			midi_alloc_ep_req(midi->out_ep, midi->buflen);

		if (req == NULL)
			return -ENOMEM;

		req->complete = f_midi_complete;
		err = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);
 		if (err) {
 			ERROR(midi, ""%s: couldn't enqueue request: %d\n"",
 				    midi->out_ep->name, err);
			if (req->buf != NULL)
				free_ep_req(midi->out_ep, req);
 			return err;
 		}
 	}

	return 0;
}
","static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
{
	struct f_midi *midi = func_to_midi(f);
	unsigned i;
	int err;

	/* we only set alt for MIDIStreaming interface */
	if (intf != midi->ms_id)
		return 0;

	err = f_midi_start_ep(midi, f, midi->in_ep);
	if (err)
		return err;

	err = f_midi_start_ep(midi, f, midi->out_ep);
	if (err)
		return err;

	/* pre-allocate write usb requests to use on f_midi_transmit. */
	while (kfifo_avail(&midi->in_req_fifo)) {
		struct usb_request *req =
			midi_alloc_ep_req(midi->in_ep, midi->buflen);

		if (req == NULL)
			return -ENOMEM;

		req->length = 0;
		req->complete = f_midi_complete;

		kfifo_put(&midi->in_req_fifo, req);
	}

	/* allocate a bunch of read buffers and queue them all at once. */
	for (i = 0; i < midi->qlen && err == 0; i++) {
		struct usb_request *req =
			midi_alloc_ep_req(midi->out_ep, midi->buflen);

		if (req == NULL)
			return -ENOMEM;

		req->complete = f_midi_complete;
		err = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);
 		if (err) {
 			ERROR(midi, ""%s: couldn't enqueue request: %d\n"",
 				    midi->out_ep->name, err);
			free_ep_req(midi->out_ep, req);
 			return err;
 		}
 	}

	return 0;
}
",C,"			if (req->buf != NULL)
				free_ep_req(midi->out_ep, req);
","			free_ep_req(midi->out_ep, req);
",,"@@ -404,7 +404,8 @@ static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 		if (err) {
 			ERROR(midi, ""%s: couldn't enqueue request: %d\n"",
 				    midi->out_ep->name, err);
-			free_ep_req(midi->out_ep, req);
+			if (req->buf != NULL)
+				free_ep_req(midi->out_ep, req);
 			return err;
 		}
 	}",linux,7fafcfdf6377b18b2a726ea554d6e593ba44349f,4d8d5a392ae110d9b5889afd2b4beef9a09e712d,1,"static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
{
	struct f_midi *midi = func_to_midi(f);
	unsigned i;
	int err;

	/* we only set alt for MIDIStreaming interface */
	if (intf != midi->ms_id)
		return 0;

	err = f_midi_start_ep(midi, f, midi->in_ep);
	if (err)
		return err;

	err = f_midi_start_ep(midi, f, midi->out_ep);
	if (err)
		return err;

	/* pre-allocate write usb requests to use on f_midi_transmit. */
	while (kfifo_avail(&midi->in_req_fifo)) {
		struct usb_request *req =
			midi_alloc_ep_req(midi->in_ep, midi->buflen);

		if (req == NULL)
			return -ENOMEM;

		req->length = 0;
		req->complete = f_midi_complete;

		kfifo_put(&midi->in_req_fifo, req);
	}

	/* allocate a bunch of read buffers and queue them all at once. */
	for (i = 0; i < midi->qlen && err == 0; i++) {
		struct usb_request *req =
			midi_alloc_ep_req(midi->out_ep, midi->buflen);

		if (req == NULL)
			return -ENOMEM;

		req->complete = f_midi_complete;
		err = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);
 		if (err) {
 			ERROR(midi, ""%s: couldn't enqueue request: %d\n"",
 				    midi->out_ep->name, err);
//flaw_line_below:
			free_ep_req(midi->out_ep, req);
//fix_flaw_line_below:
//			if (req->buf != NULL)
//fix_flaw_line_below:
//				free_ep_req(midi->out_ep, req);
 			return err;
 		}
 	}

	return 0;
}
"
5292,183028,,Remote,Not required,Partial,CVE-2017-18594,https://www.cvedetails.com/cve/CVE-2017-18594/,CWE-415,Low,,,,2019-08-28,5.0,"nse_libssh2.cc in Nmap 7.70 is subject to a denial of service condition due to a double free when an SSH connection fails, as demonstrated by a leading n character to ssh-brute.nse or ssh-auth-methods.nse.",2019-09-26,DoS ,1,https://github.com/nmap/nmap/commit/350bbe0597d37ad67abe5fef8fba984707b4e9ad,350bbe0597d37ad67abe5fef8fba984707b4e9ad,Avoid a crash (double-free) when SSH connection fails,0,nse_libssh2.cc,"{""sha"": ""983f83dbdba8b9ceaf127826b3c1d3f785e80635"", ""filename"": ""nse_libssh2.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/nmap/nmap/blob/350bbe0597d37ad67abe5fef8fba984707b4e9ad/nse_libssh2.cc"", ""raw_url"": ""https://github.com/nmap/nmap/raw/350bbe0597d37ad67abe5fef8fba984707b4e9ad/nse_libssh2.cc"", ""contents_url"": ""https://api.github.com/repos/nmap/nmap/contents/nse_libssh2.cc?ref=350bbe0597d37ad67abe5fef8fba984707b4e9ad"", ""patch"": ""@@ -12,7 +12,6 @@ extern \""C\"" {\n }\n #include \""nse_lua.h\""\n \n-#include \""nse_debug.h\""\n #include \""nse_nsock.h\""\n #include \""nse_utility.h\""\n \n@@ -295,6 +294,7 @@ static int do_session_handshake (lua_State *L, int status, lua_KContext ctx) {\n \n     if (rc) {\n         libssh2_session_free(sshu->session);\n+        sshu->session = NULL;\n         return luaL_error(L, \""Unable to complete libssh2 handshake.\"");\n     }\n \n@@ -478,7 +478,7 @@ static int userauth_list (lua_State *L, int status, lua_KContext ctx) {\n }\n \n /*\n-* Returns list of supported authenication methods\n+* Returns list of supported authentication methods\n */\n static int l_userauth_list (lua_State *L) {\n     return userauth_list(L, 0, 0);""}","static int do_session_handshake (lua_State *L, int status, lua_KContext ctx) {
    int rc;
    struct ssh_userdata *sshu = NULL;

    assert(lua_gettop(L) == 4);
    sshu = (struct ssh_userdata *) nseU_checkudata(L, 3, SSH2_UDATA, ""ssh2"");

    while ((rc = libssh2_session_handshake(sshu->session, sshu->sp[0])) == LIBSSH2_ERROR_EAGAIN) {
        luaL_getmetafield(L, 3, ""filter"");
        lua_pushvalue(L, 3);

        assert(lua_status(L) == LUA_OK);
        lua_callk(L, 1, 0, 0, do_session_handshake);
    }
 
     if (rc) {
         libssh2_session_free(sshu->session);
        sshu->session = NULL;
         return luaL_error(L, ""Unable to complete libssh2 handshake."");
     }
 
    lua_settop(L, 3);

    return 1;
}
","static int do_session_handshake (lua_State *L, int status, lua_KContext ctx) {
    int rc;
    struct ssh_userdata *sshu = NULL;

    assert(lua_gettop(L) == 4);
    sshu = (struct ssh_userdata *) nseU_checkudata(L, 3, SSH2_UDATA, ""ssh2"");

    while ((rc = libssh2_session_handshake(sshu->session, sshu->sp[0])) == LIBSSH2_ERROR_EAGAIN) {
        luaL_getmetafield(L, 3, ""filter"");
        lua_pushvalue(L, 3);

        assert(lua_status(L) == LUA_OK);
        lua_callk(L, 1, 0, 0, do_session_handshake);
    }
 
     if (rc) {
         libssh2_session_free(sshu->session);
         return luaL_error(L, ""Unable to complete libssh2 handshake."");
     }
 
    lua_settop(L, 3);

    return 1;
}
",C,"        sshu->session = NULL;
",,,"@@ -12,7 +12,6 @@ extern ""C"" {
 }
 #include ""nse_lua.h""
 
-#include ""nse_debug.h""
 #include ""nse_nsock.h""
 #include ""nse_utility.h""
 
@@ -295,6 +294,7 @@ static int do_session_handshake (lua_State *L, int status, lua_KContext ctx) {
 
     if (rc) {
         libssh2_session_free(sshu->session);
+        sshu->session = NULL;
         return luaL_error(L, ""Unable to complete libssh2 handshake."");
     }
 
@@ -478,7 +478,7 @@ static int userauth_list (lua_State *L, int status, lua_KContext ctx) {
 }
 
 /*
-* Returns list of supported authenication methods
+* Returns list of supported authentication methods
 */
 static int l_userauth_list (lua_State *L) {
     return userauth_list(L, 0, 0);",nmap,350bbe0597d37ad67abe5fef8fba984707b4e9ad,f893372ddd95c1a67e8e7a7cea462809ca638358,1,"static int do_session_handshake (lua_State *L, int status, lua_KContext ctx) {
    int rc;
    struct ssh_userdata *sshu = NULL;

    assert(lua_gettop(L) == 4);
    sshu = (struct ssh_userdata *) nseU_checkudata(L, 3, SSH2_UDATA, ""ssh2"");

    while ((rc = libssh2_session_handshake(sshu->session, sshu->sp[0])) == LIBSSH2_ERROR_EAGAIN) {
        luaL_getmetafield(L, 3, ""filter"");
        lua_pushvalue(L, 3);

        assert(lua_status(L) == LUA_OK);
        lua_callk(L, 1, 0, 0, do_session_handshake);
    }
 
     if (rc) {
         libssh2_session_free(sshu->session);
//fix_flaw_line_below:
//        sshu->session = NULL;
         return luaL_error(L, ""Unable to complete libssh2 handshake."");
     }
 
    // lua_pushvalue(L, 3);
    lua_settop(L, 3);

    return 1;
}
"
5608,183344,,Remote,Not required,Partial,CVE-2017-18174,https://www.cvedetails.com/cve/CVE-2017-18174/,CWE-415,Low,Partial,Partial,,2018-02-11,7.5,"In the Linux kernel before 4.7, the amd_gpio_remove function in drivers/pinctrl/pinctrl-amd.c calls the pinctrl_unregister function, leading to a double free.",2018-12-21,,3,https://github.com/torvalds/linux/commit/251e22abde21833b3d29577e4d8c7aaccd650eee,251e22abde21833b3d29577e4d8c7aaccd650eee,"pinctrl: amd: Use devm_pinctrl_register() for pinctrl registration

Use devm_pinctrl_register() for pin control registration and clean
error path.

Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Signed-off-by: Linus Walleij <linus.walleij@linaro.org>",5,drivers/pinctrl/pinctrl-amd.c,"{""sha"": ""634b4d30eefb1e3c14c4ed6243ca3382fc4f5b66"", ""filename"": ""drivers/pinctrl/pinctrl-amd.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 6, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/251e22abde21833b3d29577e4d8c7aaccd650eee/drivers/pinctrl/pinctrl-amd.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/251e22abde21833b3d29577e4d8c7aaccd650eee/drivers/pinctrl/pinctrl-amd.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/pinctrl/pinctrl-amd.c?ref=251e22abde21833b3d29577e4d8c7aaccd650eee"", ""patch"": ""@@ -783,16 +783,16 @@ static int amd_gpio_probe(struct platform_device *pdev)\n \tgpio_dev->ngroups = ARRAY_SIZE(kerncz_groups);\n \n \tamd_pinctrl_desc.name = dev_name(&pdev->dev);\n-\tgpio_dev->pctrl = pinctrl_register(&amd_pinctrl_desc,\n-\t\t\t\t\t&pdev->dev, gpio_dev);\n+\tgpio_dev->pctrl = devm_pinctrl_register(&pdev->dev, &amd_pinctrl_desc,\n+\t\t\t\t\t\tgpio_dev);\n \tif (IS_ERR(gpio_dev->pctrl)) {\n \t\tdev_err(&pdev->dev, \""Couldn't register pinctrl driver\\n\"");\n \t\treturn PTR_ERR(gpio_dev->pctrl);\n \t}\n \n \tret = gpiochip_add_data(&gpio_dev->gc, gpio_dev);\n \tif (ret)\n-\t\tgoto out1;\n+\t\treturn ret;\n \n \tret = gpiochip_add_pin_range(&gpio_dev->gc, dev_name(&pdev->dev),\n \t\t\t\t0, 0, TOTAL_NUMBER_OF_PINS);\n@@ -825,8 +825,6 @@ static int amd_gpio_probe(struct platform_device *pdev)\n out2:\n \tgpiochip_remove(&gpio_dev->gc);\n \n-out1:\n-\tpinctrl_unregister(gpio_dev->pctrl);\n \treturn ret;\n }\n \n@@ -837,7 +835,6 @@ static int amd_gpio_remove(struct platform_device *pdev)\n \tgpio_dev = platform_get_drvdata(pdev);\n \n \tgpiochip_remove(&gpio_dev->gc);\n-\tpinctrl_unregister(gpio_dev->pctrl);\n \n \treturn 0;\n }""}","static int amd_gpio_probe(struct platform_device *pdev)
{
	int ret = 0;
	int irq_base;
	struct resource *res;
	struct amd_gpio *gpio_dev;

	gpio_dev = devm_kzalloc(&pdev->dev,
				sizeof(struct amd_gpio), GFP_KERNEL);
	if (!gpio_dev)
		return -ENOMEM;

	spin_lock_init(&gpio_dev->lock);

	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	if (!res) {
		dev_err(&pdev->dev, ""Failed to get gpio io resource.\n"");
		return -EINVAL;
	}

	gpio_dev->base = devm_ioremap_nocache(&pdev->dev, res->start,
						resource_size(res));
	if (!gpio_dev->base)
		return -ENOMEM;

	irq_base = platform_get_irq(pdev, 0);
	if (irq_base < 0) {
		dev_err(&pdev->dev, ""Failed to get gpio IRQ.\n"");
		return -EINVAL;
	}

	gpio_dev->pdev = pdev;
	gpio_dev->gc.direction_input	= amd_gpio_direction_input;
	gpio_dev->gc.direction_output	= amd_gpio_direction_output;
	gpio_dev->gc.get			= amd_gpio_get_value;
	gpio_dev->gc.set			= amd_gpio_set_value;
	gpio_dev->gc.set_debounce	= amd_gpio_set_debounce;
	gpio_dev->gc.dbg_show		= amd_gpio_dbg_show;

	gpio_dev->gc.base			= 0;
	gpio_dev->gc.label			= pdev->name;
	gpio_dev->gc.owner			= THIS_MODULE;
	gpio_dev->gc.parent			= &pdev->dev;
	gpio_dev->gc.ngpio			= TOTAL_NUMBER_OF_PINS;
#if defined(CONFIG_OF_GPIO)
	gpio_dev->gc.of_node			= pdev->dev.of_node;
#endif

	gpio_dev->groups = kerncz_groups;
 	gpio_dev->ngroups = ARRAY_SIZE(kerncz_groups);
 
 	amd_pinctrl_desc.name = dev_name(&pdev->dev);
	gpio_dev->pctrl = devm_pinctrl_register(&pdev->dev, &amd_pinctrl_desc,
						gpio_dev);
 	if (IS_ERR(gpio_dev->pctrl)) {
 		dev_err(&pdev->dev, ""Couldn't register pinctrl driver\n"");
 		return PTR_ERR(gpio_dev->pctrl);
 	}
 
 	ret = gpiochip_add_data(&gpio_dev->gc, gpio_dev);
 	if (ret)
		return ret;
 
 	ret = gpiochip_add_pin_range(&gpio_dev->gc, dev_name(&pdev->dev),
 				0, 0, TOTAL_NUMBER_OF_PINS);
	if (ret) {
		dev_err(&pdev->dev, ""Failed to add pin range\n"");
		goto out2;
	}

	ret = gpiochip_irqchip_add(&gpio_dev->gc,
				&amd_gpio_irqchip,
				0,
				handle_simple_irq,
				IRQ_TYPE_NONE);
	if (ret) {
		dev_err(&pdev->dev, ""could not add irqchip\n"");
		ret = -ENODEV;
		goto out2;
	}

	gpiochip_set_chained_irqchip(&gpio_dev->gc,
				 &amd_gpio_irqchip,
				 irq_base,
				 amd_gpio_irq_handler);

	platform_set_drvdata(pdev, gpio_dev);

	dev_dbg(&pdev->dev, ""amd gpio driver loaded\n"");
	return ret;

 out2:
 	gpiochip_remove(&gpio_dev->gc);
 
 	return ret;
 }
","static int amd_gpio_probe(struct platform_device *pdev)
{
	int ret = 0;
	int irq_base;
	struct resource *res;
	struct amd_gpio *gpio_dev;

	gpio_dev = devm_kzalloc(&pdev->dev,
				sizeof(struct amd_gpio), GFP_KERNEL);
	if (!gpio_dev)
		return -ENOMEM;

	spin_lock_init(&gpio_dev->lock);

	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	if (!res) {
		dev_err(&pdev->dev, ""Failed to get gpio io resource.\n"");
		return -EINVAL;
	}

	gpio_dev->base = devm_ioremap_nocache(&pdev->dev, res->start,
						resource_size(res));
	if (!gpio_dev->base)
		return -ENOMEM;

	irq_base = platform_get_irq(pdev, 0);
	if (irq_base < 0) {
		dev_err(&pdev->dev, ""Failed to get gpio IRQ.\n"");
		return -EINVAL;
	}

	gpio_dev->pdev = pdev;
	gpio_dev->gc.direction_input	= amd_gpio_direction_input;
	gpio_dev->gc.direction_output	= amd_gpio_direction_output;
	gpio_dev->gc.get			= amd_gpio_get_value;
	gpio_dev->gc.set			= amd_gpio_set_value;
	gpio_dev->gc.set_debounce	= amd_gpio_set_debounce;
	gpio_dev->gc.dbg_show		= amd_gpio_dbg_show;

	gpio_dev->gc.base			= 0;
	gpio_dev->gc.label			= pdev->name;
	gpio_dev->gc.owner			= THIS_MODULE;
	gpio_dev->gc.parent			= &pdev->dev;
	gpio_dev->gc.ngpio			= TOTAL_NUMBER_OF_PINS;
#if defined(CONFIG_OF_GPIO)
	gpio_dev->gc.of_node			= pdev->dev.of_node;
#endif

	gpio_dev->groups = kerncz_groups;
 	gpio_dev->ngroups = ARRAY_SIZE(kerncz_groups);
 
 	amd_pinctrl_desc.name = dev_name(&pdev->dev);
	gpio_dev->pctrl = pinctrl_register(&amd_pinctrl_desc,
					&pdev->dev, gpio_dev);
 	if (IS_ERR(gpio_dev->pctrl)) {
 		dev_err(&pdev->dev, ""Couldn't register pinctrl driver\n"");
 		return PTR_ERR(gpio_dev->pctrl);
 	}
 
 	ret = gpiochip_add_data(&gpio_dev->gc, gpio_dev);
 	if (ret)
		goto out1;
 
 	ret = gpiochip_add_pin_range(&gpio_dev->gc, dev_name(&pdev->dev),
 				0, 0, TOTAL_NUMBER_OF_PINS);
	if (ret) {
		dev_err(&pdev->dev, ""Failed to add pin range\n"");
		goto out2;
	}

	ret = gpiochip_irqchip_add(&gpio_dev->gc,
				&amd_gpio_irqchip,
				0,
				handle_simple_irq,
				IRQ_TYPE_NONE);
	if (ret) {
		dev_err(&pdev->dev, ""could not add irqchip\n"");
		ret = -ENODEV;
		goto out2;
	}

	gpiochip_set_chained_irqchip(&gpio_dev->gc,
				 &amd_gpio_irqchip,
				 irq_base,
				 amd_gpio_irq_handler);

	platform_set_drvdata(pdev, gpio_dev);

	dev_dbg(&pdev->dev, ""amd gpio driver loaded\n"");
	return ret;

 out2:
 	gpiochip_remove(&gpio_dev->gc);
 
out1:
	pinctrl_unregister(gpio_dev->pctrl);
 	return ret;
 }
",C,"	gpio_dev->pctrl = devm_pinctrl_register(&pdev->dev, &amd_pinctrl_desc,
						gpio_dev);
		return ret;
","	gpio_dev->pctrl = pinctrl_register(&amd_pinctrl_desc,
					&pdev->dev, gpio_dev);
		goto out1;
out1:
	pinctrl_unregister(gpio_dev->pctrl);
",,"@@ -783,16 +783,16 @@ static int amd_gpio_probe(struct platform_device *pdev)
 	gpio_dev->ngroups = ARRAY_SIZE(kerncz_groups);
 
 	amd_pinctrl_desc.name = dev_name(&pdev->dev);
-	gpio_dev->pctrl = pinctrl_register(&amd_pinctrl_desc,
-					&pdev->dev, gpio_dev);
+	gpio_dev->pctrl = devm_pinctrl_register(&pdev->dev, &amd_pinctrl_desc,
+						gpio_dev);
 	if (IS_ERR(gpio_dev->pctrl)) {
 		dev_err(&pdev->dev, ""Couldn't register pinctrl driver\n"");
 		return PTR_ERR(gpio_dev->pctrl);
 	}
 
 	ret = gpiochip_add_data(&gpio_dev->gc, gpio_dev);
 	if (ret)
-		goto out1;
+		return ret;
 
 	ret = gpiochip_add_pin_range(&gpio_dev->gc, dev_name(&pdev->dev),
 				0, 0, TOTAL_NUMBER_OF_PINS);
@@ -825,8 +825,6 @@ static int amd_gpio_probe(struct platform_device *pdev)
 out2:
 	gpiochip_remove(&gpio_dev->gc);
 
-out1:
-	pinctrl_unregister(gpio_dev->pctrl);
 	return ret;
 }
 
@@ -837,7 +835,6 @@ static int amd_gpio_remove(struct platform_device *pdev)
 	gpio_dev = platform_get_drvdata(pdev);
 
 	gpiochip_remove(&gpio_dev->gc);
-	pinctrl_unregister(gpio_dev->pctrl);
 
 	return 0;
 }",linux,251e22abde21833b3d29577e4d8c7aaccd650eee,12ba40821ad0fd3c202efdb31b0be9b5872cef1c,1,"static int amd_gpio_probe(struct platform_device *pdev)
{
	int ret = 0;
	int irq_base;
	struct resource *res;
	struct amd_gpio *gpio_dev;

	gpio_dev = devm_kzalloc(&pdev->dev,
				sizeof(struct amd_gpio), GFP_KERNEL);
	if (!gpio_dev)
		return -ENOMEM;

	spin_lock_init(&gpio_dev->lock);

	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	if (!res) {
		dev_err(&pdev->dev, ""Failed to get gpio io resource.\n"");
		return -EINVAL;
	}

	gpio_dev->base = devm_ioremap_nocache(&pdev->dev, res->start,
						resource_size(res));
	if (!gpio_dev->base)
		return -ENOMEM;

	irq_base = platform_get_irq(pdev, 0);
	if (irq_base < 0) {
		dev_err(&pdev->dev, ""Failed to get gpio IRQ.\n"");
		return -EINVAL;
	}

	gpio_dev->pdev = pdev;
	gpio_dev->gc.direction_input	= amd_gpio_direction_input;
	gpio_dev->gc.direction_output	= amd_gpio_direction_output;
	gpio_dev->gc.get			= amd_gpio_get_value;
	gpio_dev->gc.set			= amd_gpio_set_value;
	gpio_dev->gc.set_debounce	= amd_gpio_set_debounce;
	gpio_dev->gc.dbg_show		= amd_gpio_dbg_show;

	gpio_dev->gc.base			= 0;
	gpio_dev->gc.label			= pdev->name;
	gpio_dev->gc.owner			= THIS_MODULE;
	gpio_dev->gc.parent			= &pdev->dev;
	gpio_dev->gc.ngpio			= TOTAL_NUMBER_OF_PINS;
#if defined(CONFIG_OF_GPIO)
	gpio_dev->gc.of_node			= pdev->dev.of_node;
#endif

	gpio_dev->groups = kerncz_groups;
 	gpio_dev->ngroups = ARRAY_SIZE(kerncz_groups);
 
 	amd_pinctrl_desc.name = dev_name(&pdev->dev);
//flaw_line_below:
	gpio_dev->pctrl = pinctrl_register(&amd_pinctrl_desc,
//flaw_line_below:
					&pdev->dev, gpio_dev);
//fix_flaw_line_below:
//	gpio_dev->pctrl = devm_pinctrl_register(&pdev->dev, &amd_pinctrl_desc,
//fix_flaw_line_below:
//						gpio_dev);
 	if (IS_ERR(gpio_dev->pctrl)) {
 		dev_err(&pdev->dev, ""Couldn't register pinctrl driver\n"");
 		return PTR_ERR(gpio_dev->pctrl);
 	}
 
 	ret = gpiochip_add_data(&gpio_dev->gc, gpio_dev);
 	if (ret)
//flaw_line_below:
		goto out1;
//fix_flaw_line_below:
//		return ret;
 
 	ret = gpiochip_add_pin_range(&gpio_dev->gc, dev_name(&pdev->dev),
 				0, 0, TOTAL_NUMBER_OF_PINS);
	if (ret) {
		dev_err(&pdev->dev, ""Failed to add pin range\n"");
		goto out2;
	}

	ret = gpiochip_irqchip_add(&gpio_dev->gc,
				&amd_gpio_irqchip,
				0,
				handle_simple_irq,
				IRQ_TYPE_NONE);
	if (ret) {
		dev_err(&pdev->dev, ""could not add irqchip\n"");
		ret = -ENODEV;
		goto out2;
	}

	gpiochip_set_chained_irqchip(&gpio_dev->gc,
				 &amd_gpio_irqchip,
				 irq_base,
				 amd_gpio_irq_handler);

	platform_set_drvdata(pdev, gpio_dev);

	dev_dbg(&pdev->dev, ""amd gpio driver loaded\n"");
	return ret;

 out2:
 	gpiochip_remove(&gpio_dev->gc);
 
//flaw_line_below:
out1:
//flaw_line_below:
	pinctrl_unregister(gpio_dev->pctrl);
 	return ret;
 }
"
