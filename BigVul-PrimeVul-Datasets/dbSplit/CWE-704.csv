,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
70,177806,,Remote,Not required,Partial,CVE-2018-19476,https://www.cvedetails.com/cve/CVE-2018-19476/,CWE-704,Medium,Partial,Partial,,2018-11-23,6.8,psi/zicc.c in Artifex Ghostscript before 9.26 allows remote attackers to bypass intended access restrictions because of a setcolorspace type confusion.,2019-04-25,Bypass,1,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=67d760ab775dae4efe803b5944b0439aa3c0b04a,67d760ab775dae4efe803b5944b0439aa3c0b04a,,1,,,"int seticc(i_ctx_t * i_ctx_p, int ncomps, ref *ICCdict, float *range_buff)
{
    int                     code, k;
    gs_color_space *        pcs;
    ref *                   pstrmval;
    stream *                s = 0L;
    cmm_profile_t           *picc_profile = NULL;
    int                     i, expected = 0;
    ref *                   pnameval;
    static const char *const icc_std_profile_names[] = {
            GSICC_STANDARD_PROFILES
        };
    static const char *const icc_std_profile_keys[] = {
            GSICC_STANDARD_PROFILES_KEYS
        };

    /* verify the DataSource entry */
    if (dict_find_string(ICCdict, ""DataSource"", &pstrmval) <= 0)
        return_error(gs_error_undefined);
    check_read_file(i_ctx_p, s, pstrmval);

    /* build the color space object */
    code = gs_cspace_build_ICC(&pcs, NULL, gs_gstate_memory(igs));
    if (code < 0)
        return gs_rethrow(code, ""building color space object"");
    /*  For now, dump the profile into a buffer
        and obtain handle from the buffer when we need it.
        We may want to change this later.
        This depends to some degree on what the CMS is capable of doing.
        I don't want to get bogged down on stream I/O at this point.
        Note also, if we are going to be putting these into the clist we will
         want to have this buffer. */
     /* Check if we have the /Name entry.  This is used to associate with
        specs that have enumerated types to indicate sRGB sGray etc */
    if (dict_find_string(ICCdict, ""Name"", &pnameval) > 0 && r_has_type(pnameval, t_string)){
         uint size = r_size(pnameval);
         char *str = (char *)gs_alloc_bytes(gs_gstate_memory(igs), size+1, ""seticc"");
         memcpy(str, (const char *)pnameval->value.bytes, size);
        str[size] = 0;

        /* Compare this to the standard profile names */
        for (k = 0; k < GSICC_NUMBER_STANDARD_PROFILES; k++) {
            if ( strcmp( str, icc_std_profile_keys[k] ) == 0 ) {
                picc_profile = gsicc_get_profile_handle_file(icc_std_profile_names[k],
                    strlen(icc_std_profile_names[k]), gs_gstate_memory(igs));
                break;
            }
        }
        gs_free_object(gs_gstate_memory(igs), str, ""seticc"");
    } else {
        picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0);
        if (picc_profile == NULL)
            return gs_throw(gs_error_VMerror, ""Creation of ICC profile failed"");
        /* We have to get the profile handle due to the fact that we need to know
           if it has a data space that is CIELAB */
        picc_profile->profile_handle =
            gsicc_get_profile_handle_buffer(picc_profile->buffer,
                                            picc_profile->buffer_size,
                                            gs_gstate_memory(igs));
    }
    if (picc_profile == NULL || picc_profile->profile_handle == NULL) {
        /* Free up everything, the profile is not valid. We will end up going
           ahead and using a default based upon the number of components */
        rc_decrement(picc_profile,""seticc"");
        rc_decrement(pcs,""seticc"");
        return -1;
    }
    code = gsicc_set_gscs_profile(pcs, picc_profile, gs_gstate_memory(igs));
    if (code < 0) {
        rc_decrement(picc_profile,""seticc"");
        rc_decrement(pcs,""seticc"");
        return code;
    }
    picc_profile->num_comps = ncomps;

    picc_profile->data_cs =
        gscms_get_profile_data_space(picc_profile->profile_handle,
            picc_profile->memory);
    switch (picc_profile->data_cs) {
        case gsCIEXYZ:
        case gsCIELAB:
        case gsRGB:
            expected = 3;
            break;
        case gsGRAY:
            expected = 1;
            break;
        case gsCMYK:
            expected = 4;
            break;
        case gsNCHANNEL:
        case gsNAMED:            /* Silence warnings */
        case gsUNDEFINED:        /* Silence warnings */
            break;
    }
    if (!expected || ncomps != expected) {
        rc_decrement(picc_profile,""seticc"");
        rc_decrement(pcs,""seticc"");
        return_error(gs_error_rangecheck);
    }

    /* Lets go ahead and get the hash code and check if we match one of the default spaces */
    /* Later we may want to delay this, but for now lets go ahead and do it */
    gsicc_init_hash_cs(picc_profile, igs);

    /* Set the range according to the data type that is associated with the
       ICC input color type.  Occasionally, we will run into CIELAB to CIELAB
       profiles for spot colors in PDF documents. These spot colors are typically described
       as separation colors with tint transforms that go from a tint value
       to a linear mapping between the CIELAB white point and the CIELAB tint
       color.  This results in a CIELAB value that we need to use to fill.  We
       need to detect this to make sure we do the proper scaling of the data.  For
       CIELAB images in PDF, the source is always normal 8 or 16 bit encoded data
       in the range from 0 to 255 or 0 to 65535.  In that case, there should not
       be any encoding and decoding to CIELAB.  The PDF content will not include
       an ICC profile but will set the color space to \Lab.  In this case, we use
       our seticc_lab operation to install the LAB to LAB profile, but we detect
       that we did that through the use of the is_lab flag in the profile descriptor.
       When then avoid the CIELAB encode and decode */
    if (picc_profile->data_cs == gsCIELAB) {
    /* If the input space to this profile is CIELAB, then we need to adjust the limits */
        /* See ICC spec ICC.1:2004-10 Section 6.3.4.2 and 6.4.  I don't believe we need to
           worry about CIEXYZ profiles or any of the other odds ones.  Need to check that though
           at some point. */
        picc_profile->Range.ranges[0].rmin = 0.0;
        picc_profile->Range.ranges[0].rmax = 100.0;
        picc_profile->Range.ranges[1].rmin = -128.0;
        picc_profile->Range.ranges[1].rmax = 127.0;
        picc_profile->Range.ranges[2].rmin = -128.0;
        picc_profile->Range.ranges[2].rmax = 127.0;
        picc_profile->islab = true;
    } else {
        for (i = 0; i < ncomps; i++) {
            picc_profile->Range.ranges[i].rmin = range_buff[2 * i];
            picc_profile->Range.ranges[i].rmax = range_buff[2 * i + 1];
        }
    }
    /* Now see if we are in an overide situation.  We have to wait until now
       in case this is an LAB profile which we will not overide */
    if (gs_currentoverrideicc(igs) && picc_profile->data_cs != gsCIELAB) {
        /* Free up the profile structure */
        switch( picc_profile->data_cs ) {
            case gsRGB:
                pcs->cmm_icc_profile_data = igs->icc_manager->default_rgb;
                break;
            case gsGRAY:
                pcs->cmm_icc_profile_data = igs->icc_manager->default_gray;
                break;
            case gsCMYK:
                pcs->cmm_icc_profile_data = igs->icc_manager->default_cmyk;
                break;
            default:
                break;
        }
        /* Have one increment from the color space.  Having these tied
           together is not really correct.  Need to fix that.  ToDo.  MJV */
        rc_adjust(picc_profile, -2, ""seticc"");
        rc_increment(pcs->cmm_icc_profile_data);
    }
    /* Set the color space.  We are done.  No joint cache here... */
    code = gs_setcolorspace(igs, pcs);
    /* The context has taken a reference to the colorspace. We no longer need
     * ours, so drop it. */
    rc_decrement_only(pcs, ""seticc"");
    /* In this case, we already have a ref count of 2 on the icc profile
       one for when it was created and one for when it was set.  We really
       only want one here so adjust */
    rc_decrement(picc_profile,""seticc"");
    /* Remove the ICC dict from the stack */
    pop(1);
    return code;
}
","int seticc(i_ctx_t * i_ctx_p, int ncomps, ref *ICCdict, float *range_buff)
{
    int                     code, k;
    gs_color_space *        pcs;
    ref *                   pstrmval;
    stream *                s = 0L;
    cmm_profile_t           *picc_profile = NULL;
    int                     i, expected = 0;
    ref *                   pnameval;
    static const char *const icc_std_profile_names[] = {
            GSICC_STANDARD_PROFILES
        };
    static const char *const icc_std_profile_keys[] = {
            GSICC_STANDARD_PROFILES_KEYS
        };

    /* verify the DataSource entry */
    if (dict_find_string(ICCdict, ""DataSource"", &pstrmval) <= 0)
        return_error(gs_error_undefined);
    check_read_file(i_ctx_p, s, pstrmval);

    /* build the color space object */
    code = gs_cspace_build_ICC(&pcs, NULL, gs_gstate_memory(igs));
    if (code < 0)
        return gs_rethrow(code, ""building color space object"");
    /*  For now, dump the profile into a buffer
        and obtain handle from the buffer when we need it.
        We may want to change this later.
        This depends to some degree on what the CMS is capable of doing.
        I don't want to get bogged down on stream I/O at this point.
        Note also, if we are going to be putting these into the clist we will
         want to have this buffer. */
     /* Check if we have the /Name entry.  This is used to associate with
        specs that have enumerated types to indicate sRGB sGray etc */
    if (dict_find_string(ICCdict, ""Name"", &pnameval) > 0){
         uint size = r_size(pnameval);
         char *str = (char *)gs_alloc_bytes(gs_gstate_memory(igs), size+1, ""seticc"");
         memcpy(str, (const char *)pnameval->value.bytes, size);
        str[size] = 0;

        /* Compare this to the standard profile names */
        for (k = 0; k < GSICC_NUMBER_STANDARD_PROFILES; k++) {
            if ( strcmp( str, icc_std_profile_keys[k] ) == 0 ) {
                picc_profile = gsicc_get_profile_handle_file(icc_std_profile_names[k],
                    strlen(icc_std_profile_names[k]), gs_gstate_memory(igs));
                break;
            }
        }
        gs_free_object(gs_gstate_memory(igs), str, ""seticc"");
    } else {
        picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0);
        if (picc_profile == NULL)
            return gs_throw(gs_error_VMerror, ""Creation of ICC profile failed"");
        /* We have to get the profile handle due to the fact that we need to know
           if it has a data space that is CIELAB */
        picc_profile->profile_handle =
            gsicc_get_profile_handle_buffer(picc_profile->buffer,
                                            picc_profile->buffer_size,
                                            gs_gstate_memory(igs));
    }
    if (picc_profile == NULL || picc_profile->profile_handle == NULL) {
        /* Free up everything, the profile is not valid. We will end up going
           ahead and using a default based upon the number of components */
        rc_decrement(picc_profile,""seticc"");
        rc_decrement(pcs,""seticc"");
        return -1;
    }
    code = gsicc_set_gscs_profile(pcs, picc_profile, gs_gstate_memory(igs));
    if (code < 0) {
        rc_decrement(picc_profile,""seticc"");
        rc_decrement(pcs,""seticc"");
        return code;
    }
    picc_profile->num_comps = ncomps;

    picc_profile->data_cs =
        gscms_get_profile_data_space(picc_profile->profile_handle,
            picc_profile->memory);
    switch (picc_profile->data_cs) {
        case gsCIEXYZ:
        case gsCIELAB:
        case gsRGB:
            expected = 3;
            break;
        case gsGRAY:
            expected = 1;
            break;
        case gsCMYK:
            expected = 4;
            break;
        case gsNCHANNEL:
        case gsNAMED:            /* Silence warnings */
        case gsUNDEFINED:        /* Silence warnings */
            break;
    }
    if (!expected || ncomps != expected) {
        rc_decrement(picc_profile,""seticc"");
        rc_decrement(pcs,""seticc"");
        return_error(gs_error_rangecheck);
    }

    /* Lets go ahead and get the hash code and check if we match one of the default spaces */
    /* Later we may want to delay this, but for now lets go ahead and do it */
    gsicc_init_hash_cs(picc_profile, igs);

    /* Set the range according to the data type that is associated with the
       ICC input color type.  Occasionally, we will run into CIELAB to CIELAB
       profiles for spot colors in PDF documents. These spot colors are typically described
       as separation colors with tint transforms that go from a tint value
       to a linear mapping between the CIELAB white point and the CIELAB tint
       color.  This results in a CIELAB value that we need to use to fill.  We
       need to detect this to make sure we do the proper scaling of the data.  For
       CIELAB images in PDF, the source is always normal 8 or 16 bit encoded data
       in the range from 0 to 255 or 0 to 65535.  In that case, there should not
       be any encoding and decoding to CIELAB.  The PDF content will not include
       an ICC profile but will set the color space to \Lab.  In this case, we use
       our seticc_lab operation to install the LAB to LAB profile, but we detect
       that we did that through the use of the is_lab flag in the profile descriptor.
       When then avoid the CIELAB encode and decode */
    if (picc_profile->data_cs == gsCIELAB) {
    /* If the input space to this profile is CIELAB, then we need to adjust the limits */
        /* See ICC spec ICC.1:2004-10 Section 6.3.4.2 and 6.4.  I don't believe we need to
           worry about CIEXYZ profiles or any of the other odds ones.  Need to check that though
           at some point. */
        picc_profile->Range.ranges[0].rmin = 0.0;
        picc_profile->Range.ranges[0].rmax = 100.0;
        picc_profile->Range.ranges[1].rmin = -128.0;
        picc_profile->Range.ranges[1].rmax = 127.0;
        picc_profile->Range.ranges[2].rmin = -128.0;
        picc_profile->Range.ranges[2].rmax = 127.0;
        picc_profile->islab = true;
    } else {
        for (i = 0; i < ncomps; i++) {
            picc_profile->Range.ranges[i].rmin = range_buff[2 * i];
            picc_profile->Range.ranges[i].rmax = range_buff[2 * i + 1];
        }
    }
    /* Now see if we are in an overide situation.  We have to wait until now
       in case this is an LAB profile which we will not overide */
    if (gs_currentoverrideicc(igs) && picc_profile->data_cs != gsCIELAB) {
        /* Free up the profile structure */
        switch( picc_profile->data_cs ) {
            case gsRGB:
                pcs->cmm_icc_profile_data = igs->icc_manager->default_rgb;
                break;
            case gsGRAY:
                pcs->cmm_icc_profile_data = igs->icc_manager->default_gray;
                break;
            case gsCMYK:
                pcs->cmm_icc_profile_data = igs->icc_manager->default_cmyk;
                break;
            default:
                break;
        }
        /* Have one increment from the color space.  Having these tied
           together is not really correct.  Need to fix that.  ToDo.  MJV */
        rc_adjust(picc_profile, -2, ""seticc"");
        rc_increment(pcs->cmm_icc_profile_data);
    }
    /* Set the color space.  We are done.  No joint cache here... */
    code = gs_setcolorspace(igs, pcs);
    /* The context has taken a reference to the colorspace. We no longer need
     * ours, so drop it. */
    rc_decrement_only(pcs, ""seticc"");
    /* In this case, we already have a ref count of 2 on the icc profile
       one for when it was created and one for when it was set.  We really
       only want one here so adjust */
    rc_decrement(picc_profile,""seticc"");
    /* Remove the ICC dict from the stack */
    pop(1);
    return code;
}
",C,"    if (dict_find_string(ICCdict, ""Name"", &pnameval) > 0 && r_has_type(pnameval, t_string)){
","    if (dict_find_string(ICCdict, ""Name"", &pnameval) > 0){
",3005fcb9bb160af199e761e03bc70a9f249a987e,"@@ -76,7 +76,7 @@ int seticc(i_ctx_t * i_ctx_p, int ncomps, ref *ICCdict, float *range_buff)
         want to have this buffer. */
     /* Check if we have the /Name entry.  This is used to associate with
        specs that have enumerated types to indicate sRGB sGray etc */
-    if (dict_find_string(ICCdict, ""Name"", &pnameval) > 0){
+    if (dict_find_string(ICCdict, ""Name"", &pnameval) > 0 && r_has_type(pnameval, t_string)){
         uint size = r_size(pnameval);
         char *str = (char *)gs_alloc_bytes(gs_gstate_memory(igs), size+1, ""seticc"");
         memcpy(str, (const char *)pnameval->value.bytes, size);
@@ -263,6 +263,8 @@ zset_outputintent(i_ctx_t * i_ctx_p)
         return code;
     if (code == 0)
         return_error(gs_error_undefined);
+    if (r_type(pnval) != t_integer)
+        return gs_note_error(gs_error_typecheck);
     ncomps = pnval->value.intval;
 
     /* verify the DataSource entry. Creat profile from stream */
@@ -495,6 +497,8 @@ znumicc_components(i_ctx_t * i_ctx_p)
         return code;
     if (code == 0)
         return_error(gs_error_undefined);
+    if (r_type(pnval) != t_integer)
+        return gs_note_error(gs_error_typecheck);
     ncomps = pnval->value.intval;
     /* verify the DataSource entry. Create profile from stream */
     if (dict_find_string(op, ""DataSource"", &pstrmval) <= 0)",ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/zicc.c;h=dbd2562c7b748955173e098463d23ec738ba363d;hb=dbd2562c7b748955173e098463d23ec738ba363d,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/zicc.c;h=53bdf340df0f2110c17d1c17e1d309d37b1c23df;hb=53bdf340df0f2110c17d1c17e1d309d37b1c23df,1,"int seticc(i_ctx_t * i_ctx_p, int ncomps, ref *ICCdict, float *range_buff)
{
    int                     code, k;
    gs_color_space *        pcs;
    ref *                   pstrmval;
    stream *                s = 0L;
    cmm_profile_t           *picc_profile = NULL;
    int                     i, expected = 0;
    ref *                   pnameval;
    static const char *const icc_std_profile_names[] = {
            GSICC_STANDARD_PROFILES
        };
    static const char *const icc_std_profile_keys[] = {
            GSICC_STANDARD_PROFILES_KEYS
        };

    /* verify the DataSource entry */
    if (dict_find_string(ICCdict, ""DataSource"", &pstrmval) <= 0)
        return_error(gs_error_undefined);
    check_read_file(i_ctx_p, s, pstrmval);

    /* build the color space object */
    code = gs_cspace_build_ICC(&pcs, NULL, gs_gstate_memory(igs));
    if (code < 0)
        return gs_rethrow(code, ""building color space object"");
    /*  For now, dump the profile into a buffer
        and obtain handle from the buffer when we need it.
        We may want to change this later.
        This depends to some degree on what the CMS is capable of doing.
        I don't want to get bogged down on stream I/O at this point.
        Note also, if we are going to be putting these into the clist we will
         want to have this buffer. */
     /* Check if we have the /Name entry.  This is used to associate with
        specs that have enumerated types to indicate sRGB sGray etc */
//flaw_line_below:
    if (dict_find_string(ICCdict, ""Name"", &pnameval) > 0){
//fix_flaw_line_below:
//    if (dict_find_string(ICCdict, ""Name"", &pnameval) > 0 && r_has_type(pnameval, t_string)){
         uint size = r_size(pnameval);
         char *str = (char *)gs_alloc_bytes(gs_gstate_memory(igs), size+1, ""seticc"");
         memcpy(str, (const char *)pnameval->value.bytes, size);
        str[size] = 0;

        /* Compare this to the standard profile names */
        for (k = 0; k < GSICC_NUMBER_STANDARD_PROFILES; k++) {
            if ( strcmp( str, icc_std_profile_keys[k] ) == 0 ) {
                picc_profile = gsicc_get_profile_handle_file(icc_std_profile_names[k],
                    strlen(icc_std_profile_names[k]), gs_gstate_memory(igs));
                break;
            }
        }
        gs_free_object(gs_gstate_memory(igs), str, ""seticc"");
    } else {
        picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0);
        if (picc_profile == NULL)
            return gs_throw(gs_error_VMerror, ""Creation of ICC profile failed"");
        /* We have to get the profile handle due to the fact that we need to know
           if it has a data space that is CIELAB */
        picc_profile->profile_handle =
            gsicc_get_profile_handle_buffer(picc_profile->buffer,
                                            picc_profile->buffer_size,
                                            gs_gstate_memory(igs));
    }
    if (picc_profile == NULL || picc_profile->profile_handle == NULL) {
        /* Free up everything, the profile is not valid. We will end up going
           ahead and using a default based upon the number of components */
        rc_decrement(picc_profile,""seticc"");
        rc_decrement(pcs,""seticc"");
        return -1;
    }
    code = gsicc_set_gscs_profile(pcs, picc_profile, gs_gstate_memory(igs));
    if (code < 0) {
        rc_decrement(picc_profile,""seticc"");
        rc_decrement(pcs,""seticc"");
        return code;
    }
    picc_profile->num_comps = ncomps;

    picc_profile->data_cs =
        gscms_get_profile_data_space(picc_profile->profile_handle,
            picc_profile->memory);
    switch (picc_profile->data_cs) {
        case gsCIEXYZ:
        case gsCIELAB:
        case gsRGB:
            expected = 3;
            break;
        case gsGRAY:
            expected = 1;
            break;
        case gsCMYK:
            expected = 4;
            break;
        case gsNCHANNEL:
        case gsNAMED:            /* Silence warnings */
        case gsUNDEFINED:        /* Silence warnings */
            break;
    }
    if (!expected || ncomps != expected) {
        rc_decrement(picc_profile,""seticc"");
        rc_decrement(pcs,""seticc"");
        return_error(gs_error_rangecheck);
    }

    /* Lets go ahead and get the hash code and check if we match one of the default spaces */
    /* Later we may want to delay this, but for now lets go ahead and do it */
    gsicc_init_hash_cs(picc_profile, igs);

    /* Set the range according to the data type that is associated with the
       ICC input color type.  Occasionally, we will run into CIELAB to CIELAB
       profiles for spot colors in PDF documents. These spot colors are typically described
       as separation colors with tint transforms that go from a tint value
       to a linear mapping between the CIELAB white point and the CIELAB tint
       color.  This results in a CIELAB value that we need to use to fill.  We
       need to detect this to make sure we do the proper scaling of the data.  For
       CIELAB images in PDF, the source is always normal 8 or 16 bit encoded data
       in the range from 0 to 255 or 0 to 65535.  In that case, there should not
       be any encoding and decoding to CIELAB.  The PDF content will not include
       an ICC profile but will set the color space to \Lab.  In this case, we use
       our seticc_lab operation to install the LAB to LAB profile, but we detect
       that we did that through the use of the is_lab flag in the profile descriptor.
       When then avoid the CIELAB encode and decode */
    if (picc_profile->data_cs == gsCIELAB) {
    /* If the input space to this profile is CIELAB, then we need to adjust the limits */
        /* See ICC spec ICC.1:2004-10 Section 6.3.4.2 and 6.4.  I don't believe we need to
           worry about CIEXYZ profiles or any of the other odds ones.  Need to check that though
           at some point. */
        picc_profile->Range.ranges[0].rmin = 0.0;
        picc_profile->Range.ranges[0].rmax = 100.0;
        picc_profile->Range.ranges[1].rmin = -128.0;
        picc_profile->Range.ranges[1].rmax = 127.0;
        picc_profile->Range.ranges[2].rmin = -128.0;
        picc_profile->Range.ranges[2].rmax = 127.0;
        picc_profile->islab = true;
    } else {
        for (i = 0; i < ncomps; i++) {
            picc_profile->Range.ranges[i].rmin = range_buff[2 * i];
            picc_profile->Range.ranges[i].rmax = range_buff[2 * i + 1];
        }
    }
    /* Now see if we are in an overide situation.  We have to wait until now
       in case this is an LAB profile which we will not overide */
    if (gs_currentoverrideicc(igs) && picc_profile->data_cs != gsCIELAB) {
        /* Free up the profile structure */
        switch( picc_profile->data_cs ) {
            case gsRGB:
                pcs->cmm_icc_profile_data = igs->icc_manager->default_rgb;
                break;
            case gsGRAY:
                pcs->cmm_icc_profile_data = igs->icc_manager->default_gray;
                break;
            case gsCMYK:
                pcs->cmm_icc_profile_data = igs->icc_manager->default_cmyk;
                break;
            default:
                break;
        }
        /* Have one increment from the color space.  Having these tied
           together is not really correct.  Need to fix that.  ToDo.  MJV */
        rc_adjust(picc_profile, -2, ""seticc"");
        rc_increment(pcs->cmm_icc_profile_data);
    }
    /* Set the color space.  We are done.  No joint cache here... */
    code = gs_setcolorspace(igs, pcs);
    /* The context has taken a reference to the colorspace. We no longer need
     * ours, so drop it. */
    rc_decrement_only(pcs, ""seticc"");
    /* In this case, we already have a ref count of 2 on the icc profile
       one for when it was created and one for when it was set.  We really
       only want one here so adjust */
    rc_decrement(picc_profile,""seticc"");
    /* Remove the ICC dict from the stack */
    pop(1);
    return code;
}
"
71,177807,,Remote,Not required,Partial,CVE-2018-19476,https://www.cvedetails.com/cve/CVE-2018-19476/,CWE-704,Medium,Partial,Partial,,2018-11-23,6.8,psi/zicc.c in Artifex Ghostscript before 9.26 allows remote attackers to bypass intended access restrictions because of a setcolorspace type confusion.,2019-04-25,Bypass,2,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=67d760ab775dae4efe803b5944b0439aa3c0b04a,67d760ab775dae4efe803b5944b0439aa3c0b04a,,0,,,"znumicc_components(i_ctx_t * i_ctx_p)
{
    ref *                   pnval;
    ref *                   pstrmval;
    stream *                s;
    int                     ncomps, expected = 0, code;
    cmm_profile_t           *picc_profile;
    os_ptr                  op = osp;

    check_type(*op, t_dictionary);
    check_dict_read(*op);

    code = dict_find_string(op, ""N"", &pnval);
    if (code < 0)
        return code;
    if (code == 0)
         return code;
     if (code == 0)
         return_error(gs_error_undefined);
    if (r_type(pnval) != t_integer)
        return gs_note_error(gs_error_typecheck);
     ncomps = pnval->value.intval;
     /* verify the DataSource entry. Create profile from stream */
     if (dict_find_string(op, ""DataSource"", &pstrmval) <= 0)
    if (picc_profile == NULL)
        return gs_throw(gs_error_VMerror, ""Creation of ICC profile failed"");

    picc_profile->num_comps = ncomps;
    picc_profile->profile_handle =
        gsicc_get_profile_handle_buffer(picc_profile->buffer,
                                        picc_profile->buffer_size,
                                        gs_gstate_memory(igs));
    if (picc_profile->profile_handle == NULL) {
        rc_decrement(picc_profile,""znumicc_components"");
        make_int(op, expected);
        return 0;
    }
    picc_profile->data_cs =
        gscms_get_profile_data_space(picc_profile->profile_handle,
            picc_profile->memory);

    switch (picc_profile->data_cs) {
        case gsCIEXYZ:
        case gsCIELAB:
        case gsRGB:
            expected = 3;
            break;
        case gsGRAY:
            expected = 1;
            break;
        case gsCMYK:
            expected = 4;
            break;
        case gsNCHANNEL:
            expected = 0;
            break;
        case gsNAMED:
        case gsUNDEFINED:
            expected = -1;
            break;
    }

    make_int(op, expected);

    rc_decrement(picc_profile,""zset_outputintent"");
    return 0;
}
","znumicc_components(i_ctx_t * i_ctx_p)
{
    ref *                   pnval;
    ref *                   pstrmval;
    stream *                s;
    int                     ncomps, expected = 0, code;
    cmm_profile_t           *picc_profile;
    os_ptr                  op = osp;

    check_type(*op, t_dictionary);
    check_dict_read(*op);

    code = dict_find_string(op, ""N"", &pnval);
    if (code < 0)
        return code;
    if (code == 0)
         return code;
     if (code == 0)
         return_error(gs_error_undefined);
     ncomps = pnval->value.intval;
     /* verify the DataSource entry. Create profile from stream */
     if (dict_find_string(op, ""DataSource"", &pstrmval) <= 0)
    if (picc_profile == NULL)
        return gs_throw(gs_error_VMerror, ""Creation of ICC profile failed"");

    picc_profile->num_comps = ncomps;
    picc_profile->profile_handle =
        gsicc_get_profile_handle_buffer(picc_profile->buffer,
                                        picc_profile->buffer_size,
                                        gs_gstate_memory(igs));
    if (picc_profile->profile_handle == NULL) {
        rc_decrement(picc_profile,""znumicc_components"");
        make_int(op, expected);
        return 0;
    }
    picc_profile->data_cs =
        gscms_get_profile_data_space(picc_profile->profile_handle,
            picc_profile->memory);

    switch (picc_profile->data_cs) {
        case gsCIEXYZ:
        case gsCIELAB:
        case gsRGB:
            expected = 3;
            break;
        case gsGRAY:
            expected = 1;
            break;
        case gsCMYK:
            expected = 4;
            break;
        case gsNCHANNEL:
            expected = 0;
            break;
        case gsNAMED:
        case gsUNDEFINED:
            expected = -1;
            break;
    }

    make_int(op, expected);

    rc_decrement(picc_profile,""zset_outputintent"");
    return 0;
}
",C,"    if (r_type(pnval) != t_integer)
        return gs_note_error(gs_error_typecheck);
",,3005fcb9bb160af199e761e03bc70a9f249a987e,"@@ -76,7 +76,7 @@ int seticc(i_ctx_t * i_ctx_p, int ncomps, ref *ICCdict, float *range_buff)
         want to have this buffer. */
     /* Check if we have the /Name entry.  This is used to associate with
        specs that have enumerated types to indicate sRGB sGray etc */
-    if (dict_find_string(ICCdict, ""Name"", &pnameval) > 0){
+    if (dict_find_string(ICCdict, ""Name"", &pnameval) > 0 && r_has_type(pnameval, t_string)){
         uint size = r_size(pnameval);
         char *str = (char *)gs_alloc_bytes(gs_gstate_memory(igs), size+1, ""seticc"");
         memcpy(str, (const char *)pnameval->value.bytes, size);
@@ -263,6 +263,8 @@ zset_outputintent(i_ctx_t * i_ctx_p)
         return code;
     if (code == 0)
         return_error(gs_error_undefined);
+    if (r_type(pnval) != t_integer)
+        return gs_note_error(gs_error_typecheck);
     ncomps = pnval->value.intval;
 
     /* verify the DataSource entry. Creat profile from stream */
@@ -495,6 +497,8 @@ znumicc_components(i_ctx_t * i_ctx_p)
         return code;
     if (code == 0)
         return_error(gs_error_undefined);
+    if (r_type(pnval) != t_integer)
+        return gs_note_error(gs_error_typecheck);
     ncomps = pnval->value.intval;
     /* verify the DataSource entry. Create profile from stream */
     if (dict_find_string(op, ""DataSource"", &pstrmval) <= 0)",ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/zicc.c;h=dbd2562c7b748955173e098463d23ec738ba363d;hb=dbd2562c7b748955173e098463d23ec738ba363d,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/zicc.c;h=53bdf340df0f2110c17d1c17e1d309d37b1c23df;hb=53bdf340df0f2110c17d1c17e1d309d37b1c23df,1,"znumicc_components(i_ctx_t * i_ctx_p)
{
    ref *                   pnval;
    ref *                   pstrmval;
    stream *                s;
    int                     ncomps, expected = 0, code;
    cmm_profile_t           *picc_profile;
    os_ptr                  op = osp;

    check_type(*op, t_dictionary);
    check_dict_read(*op);

    code = dict_find_string(op, ""N"", &pnval);
    if (code < 0)
        return code;
    if (code == 0)
         return code;
     if (code == 0)
         return_error(gs_error_undefined);
//fix_flaw_line_below:
//    if (r_type(pnval) != t_integer)
//fix_flaw_line_below:
//        return gs_note_error(gs_error_typecheck);
     ncomps = pnval->value.intval;
     /* verify the DataSource entry. Create profile from stream */
     if (dict_find_string(op, ""DataSource"", &pstrmval) <= 0)
    if (picc_profile == NULL)
        return gs_throw(gs_error_VMerror, ""Creation of ICC profile failed"");

    picc_profile->num_comps = ncomps;
    picc_profile->profile_handle =
        gsicc_get_profile_handle_buffer(picc_profile->buffer,
                                        picc_profile->buffer_size,
                                        gs_gstate_memory(igs));
    if (picc_profile->profile_handle == NULL) {
        rc_decrement(picc_profile,""znumicc_components"");
        make_int(op, expected);
        return 0;
    }
    picc_profile->data_cs =
        gscms_get_profile_data_space(picc_profile->profile_handle,
            picc_profile->memory);

    switch (picc_profile->data_cs) {
        case gsCIEXYZ:
        case gsCIELAB:
        case gsRGB:
            expected = 3;
            break;
        case gsGRAY:
            expected = 1;
            break;
        case gsCMYK:
            expected = 4;
            break;
        case gsNCHANNEL:
            expected = 0;
            break;
        case gsNAMED:
        case gsUNDEFINED:
            expected = -1;
            break;
    }

    make_int(op, expected);

    rc_decrement(picc_profile,""zset_outputintent"");
    return 0;
}
"
72,177808,,Remote,Not required,Partial,CVE-2018-19476,https://www.cvedetails.com/cve/CVE-2018-19476/,CWE-704,Medium,Partial,Partial,,2018-11-23,6.8,psi/zicc.c in Artifex Ghostscript before 9.26 allows remote attackers to bypass intended access restrictions because of a setcolorspace type confusion.,2019-04-25,Bypass,2,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=67d760ab775dae4efe803b5944b0439aa3c0b04a,67d760ab775dae4efe803b5944b0439aa3c0b04a,,0,,,"zset_outputintent(i_ctx_t * i_ctx_p)
{
    os_ptr                  op = osp;
    int                     code = 0;
    gx_device *dev = gs_currentdevice(igs);
    cmm_dev_profile_t       *dev_profile;
    stream *                s = 0L;
    ref *                   pnval;
    ref *                   pstrmval;
    int                     ncomps, dev_comps;
    cmm_profile_t           *picc_profile;
    int                     expected = 0;
    gs_color_space_index    index;
    gsicc_manager_t         *icc_manager = igs->icc_manager;
    cmm_profile_t           *source_profile = NULL;

    check_type(*op, t_dictionary);
    check_dict_read(*op);
    if_debug0m(gs_debug_flag_icc, imemory, ""[icc] Using OutputIntent\n"");

    /* Get the device structure */
    code = dev_proc(dev, get_profile)(dev,  &dev_profile);
    if (code < 0)
        return code;

    if (dev_profile == NULL) {
        code = gsicc_init_device_profile_struct(dev, NULL, 0);
        if (code < 0)
            return code;
        code = dev_proc(dev, get_profile)(dev,  &dev_profile);
        if (code < 0)
            return code;
    }
    if (dev_profile->oi_profile != NULL) {
        return 0;  /* Allow only one setting of this object */
    }
    code = dict_find_string(op, ""N"", &pnval);
    if (code < 0)
         return code;
     if (code == 0)
         return_error(gs_error_undefined);
    if (r_type(pnval) != t_integer)
        return gs_note_error(gs_error_typecheck);
     ncomps = pnval->value.intval;
 
     /* verify the DataSource entry. Creat profile from stream */
    check_read_file(i_ctx_p, s, pstrmval);

    picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0);
    if (picc_profile == NULL)
        return gs_throw(gs_error_VMerror, ""Creation of ICC profile failed"");
    picc_profile->num_comps = ncomps;
    picc_profile->profile_handle =
        gsicc_get_profile_handle_buffer(picc_profile->buffer,
                                        picc_profile->buffer_size,
                                        gs_gstate_memory(igs));
    if (picc_profile->profile_handle == NULL) {
        rc_decrement(picc_profile,""zset_outputintent"");
        return -1;
    }
    picc_profile->data_cs =
        gscms_get_profile_data_space(picc_profile->profile_handle,
            picc_profile->memory);
    switch (picc_profile->data_cs) {
        case gsCIEXYZ:
        case gsCIELAB:
        case gsRGB:
            expected = 3;
            source_profile = icc_manager->default_rgb;
            break;
        case gsGRAY:
            expected = 1;
            source_profile = icc_manager->default_gray;
            break;
        case gsCMYK:
            expected = 4;
            source_profile = icc_manager->default_cmyk;
            break;
        case gsNCHANNEL:
            expected = 0;
            break;
        case gsNAMED:
        case gsUNDEFINED:
            break;
    }
    if (expected && ncomps != expected) {
        rc_decrement(picc_profile,""zset_outputintent"");
        return_error(gs_error_rangecheck);
    }
    gsicc_init_hash_cs(picc_profile, igs);

    /* All is well with the profile.  Lets set the stuff that needs to be set */
    dev_profile->oi_profile = picc_profile;
    picc_profile->name = (char *) gs_alloc_bytes(picc_profile->memory,
                                                 MAX_DEFAULT_ICC_LENGTH,
                                                 ""zset_outputintent"");
    strncpy(picc_profile->name, OI_PROFILE, strlen(OI_PROFILE));
    picc_profile->name[strlen(OI_PROFILE)] = 0;
    picc_profile->name_length = strlen(OI_PROFILE);
    /* Set the range of the profile */
    gsicc_set_icc_range(&picc_profile);

    /* If the output device has a different number of componenets, then we are
       going to set the output intent as the proofing profile, unless the
       proofing profile has already been set.

       If the device has the same number of components (and color model) then as
       the profile we will use this as the output profile, unless someone has
       explicitly set the output profile.

       Finally, we will use the output intent profile for the default profile
       of the proper Device profile in the icc manager, again, unless someone
       has explicitly set this default profile. */

    dev_comps = dev_profile->device_profile[0]->num_comps;
    index = gsicc_get_default_type(dev_profile->device_profile[0]);
    if (ncomps == dev_comps && index < gs_color_space_index_DevicePixel) {
        /* The OI profile is the same type as the profile for the device and a
           ""default"" profile for the device was not externally set. So we go
           ahead and use the OI profile as the device profile.  Care needs to be
           taken here to keep from screwing up any device parameters.   We will
           use a keyword of OIProfile for the user/device parameter to indicate
           its usage.  Also, note conflicts if one is setting object dependent
           color management */
        rc_assign(dev_profile->device_profile[0], picc_profile,
                  ""zset_outputintent"");
        if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used for device profile\n"");
    } else {
        if (dev_profile->proof_profile == NULL) {
            /* This means that we should use the OI profile as the proofing
               profile.  Note that if someone already has specified a
               proofing profile it is unclear what they are trying to do
               with the output intent.  In this case, we will use it
               just for the source data below */
            dev_profile->proof_profile = picc_profile;
            rc_increment(picc_profile);
            if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used for proof profile\n"");
        }
    }
    /* Now the source colors.  See which source color space needs to use the
       output intent ICC profile */
    index = gsicc_get_default_type(source_profile);
    if (index < gs_color_space_index_DevicePixel) {
        /* source_profile is currently the default.  Set it to the OI profile */
        switch (picc_profile->data_cs) {
            case gsGRAY:
                if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used source Gray\n"");
                rc_assign(icc_manager->default_gray, picc_profile,
                          ""zset_outputintent"");
                break;
            case gsRGB:
                if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used source RGB\n"");
                rc_assign(icc_manager->default_rgb, picc_profile,
                          ""zset_outputintent"");
                break;
            case gsCMYK:
                if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used source CMYK\n"");
                rc_assign(icc_manager->default_cmyk, picc_profile,
                          ""zset_outputintent"");
                break;
            default:
                break;
        }
    }
    /* Remove the output intent dict from the stack */
    pop(1);
    return code;
}
","zset_outputintent(i_ctx_t * i_ctx_p)
{
    os_ptr                  op = osp;
    int                     code = 0;
    gx_device *dev = gs_currentdevice(igs);
    cmm_dev_profile_t       *dev_profile;
    stream *                s = 0L;
    ref *                   pnval;
    ref *                   pstrmval;
    int                     ncomps, dev_comps;
    cmm_profile_t           *picc_profile;
    int                     expected = 0;
    gs_color_space_index    index;
    gsicc_manager_t         *icc_manager = igs->icc_manager;
    cmm_profile_t           *source_profile = NULL;

    check_type(*op, t_dictionary);
    check_dict_read(*op);
    if_debug0m(gs_debug_flag_icc, imemory, ""[icc] Using OutputIntent\n"");

    /* Get the device structure */
    code = dev_proc(dev, get_profile)(dev,  &dev_profile);
    if (code < 0)
        return code;

    if (dev_profile == NULL) {
        code = gsicc_init_device_profile_struct(dev, NULL, 0);
        if (code < 0)
            return code;
        code = dev_proc(dev, get_profile)(dev,  &dev_profile);
        if (code < 0)
            return code;
    }
    if (dev_profile->oi_profile != NULL) {
        return 0;  /* Allow only one setting of this object */
    }
    code = dict_find_string(op, ""N"", &pnval);
    if (code < 0)
         return code;
     if (code == 0)
         return_error(gs_error_undefined);
     ncomps = pnval->value.intval;
 
     /* verify the DataSource entry. Creat profile from stream */
    check_read_file(i_ctx_p, s, pstrmval);

    picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0);
    if (picc_profile == NULL)
        return gs_throw(gs_error_VMerror, ""Creation of ICC profile failed"");
    picc_profile->num_comps = ncomps;
    picc_profile->profile_handle =
        gsicc_get_profile_handle_buffer(picc_profile->buffer,
                                        picc_profile->buffer_size,
                                        gs_gstate_memory(igs));
    if (picc_profile->profile_handle == NULL) {
        rc_decrement(picc_profile,""zset_outputintent"");
        return -1;
    }
    picc_profile->data_cs =
        gscms_get_profile_data_space(picc_profile->profile_handle,
            picc_profile->memory);
    switch (picc_profile->data_cs) {
        case gsCIEXYZ:
        case gsCIELAB:
        case gsRGB:
            expected = 3;
            source_profile = icc_manager->default_rgb;
            break;
        case gsGRAY:
            expected = 1;
            source_profile = icc_manager->default_gray;
            break;
        case gsCMYK:
            expected = 4;
            source_profile = icc_manager->default_cmyk;
            break;
        case gsNCHANNEL:
            expected = 0;
            break;
        case gsNAMED:
        case gsUNDEFINED:
            break;
    }
    if (expected && ncomps != expected) {
        rc_decrement(picc_profile,""zset_outputintent"");
        return_error(gs_error_rangecheck);
    }
    gsicc_init_hash_cs(picc_profile, igs);

    /* All is well with the profile.  Lets set the stuff that needs to be set */
    dev_profile->oi_profile = picc_profile;
    picc_profile->name = (char *) gs_alloc_bytes(picc_profile->memory,
                                                 MAX_DEFAULT_ICC_LENGTH,
                                                 ""zset_outputintent"");
    strncpy(picc_profile->name, OI_PROFILE, strlen(OI_PROFILE));
    picc_profile->name[strlen(OI_PROFILE)] = 0;
    picc_profile->name_length = strlen(OI_PROFILE);
    /* Set the range of the profile */
    gsicc_set_icc_range(&picc_profile);

    /* If the output device has a different number of componenets, then we are
       going to set the output intent as the proofing profile, unless the
       proofing profile has already been set.

       If the device has the same number of components (and color model) then as
       the profile we will use this as the output profile, unless someone has
       explicitly set the output profile.

       Finally, we will use the output intent profile for the default profile
       of the proper Device profile in the icc manager, again, unless someone
       has explicitly set this default profile. */

    dev_comps = dev_profile->device_profile[0]->num_comps;
    index = gsicc_get_default_type(dev_profile->device_profile[0]);
    if (ncomps == dev_comps && index < gs_color_space_index_DevicePixel) {
        /* The OI profile is the same type as the profile for the device and a
           ""default"" profile for the device was not externally set. So we go
           ahead and use the OI profile as the device profile.  Care needs to be
           taken here to keep from screwing up any device parameters.   We will
           use a keyword of OIProfile for the user/device parameter to indicate
           its usage.  Also, note conflicts if one is setting object dependent
           color management */
        rc_assign(dev_profile->device_profile[0], picc_profile,
                  ""zset_outputintent"");
        if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used for device profile\n"");
    } else {
        if (dev_profile->proof_profile == NULL) {
            /* This means that we should use the OI profile as the proofing
               profile.  Note that if someone already has specified a
               proofing profile it is unclear what they are trying to do
               with the output intent.  In this case, we will use it
               just for the source data below */
            dev_profile->proof_profile = picc_profile;
            rc_increment(picc_profile);
            if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used for proof profile\n"");
        }
    }
    /* Now the source colors.  See which source color space needs to use the
       output intent ICC profile */
    index = gsicc_get_default_type(source_profile);
    if (index < gs_color_space_index_DevicePixel) {
        /* source_profile is currently the default.  Set it to the OI profile */
        switch (picc_profile->data_cs) {
            case gsGRAY:
                if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used source Gray\n"");
                rc_assign(icc_manager->default_gray, picc_profile,
                          ""zset_outputintent"");
                break;
            case gsRGB:
                if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used source RGB\n"");
                rc_assign(icc_manager->default_rgb, picc_profile,
                          ""zset_outputintent"");
                break;
            case gsCMYK:
                if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used source CMYK\n"");
                rc_assign(icc_manager->default_cmyk, picc_profile,
                          ""zset_outputintent"");
                break;
            default:
                break;
        }
    }
    /* Remove the output intent dict from the stack */
    pop(1);
    return code;
}
",C,"    if (r_type(pnval) != t_integer)
        return gs_note_error(gs_error_typecheck);
",,3005fcb9bb160af199e761e03bc70a9f249a987e,"@@ -76,7 +76,7 @@ int seticc(i_ctx_t * i_ctx_p, int ncomps, ref *ICCdict, float *range_buff)
         want to have this buffer. */
     /* Check if we have the /Name entry.  This is used to associate with
        specs that have enumerated types to indicate sRGB sGray etc */
-    if (dict_find_string(ICCdict, ""Name"", &pnameval) > 0){
+    if (dict_find_string(ICCdict, ""Name"", &pnameval) > 0 && r_has_type(pnameval, t_string)){
         uint size = r_size(pnameval);
         char *str = (char *)gs_alloc_bytes(gs_gstate_memory(igs), size+1, ""seticc"");
         memcpy(str, (const char *)pnameval->value.bytes, size);
@@ -263,6 +263,8 @@ zset_outputintent(i_ctx_t * i_ctx_p)
         return code;
     if (code == 0)
         return_error(gs_error_undefined);
+    if (r_type(pnval) != t_integer)
+        return gs_note_error(gs_error_typecheck);
     ncomps = pnval->value.intval;
 
     /* verify the DataSource entry. Creat profile from stream */
@@ -495,6 +497,8 @@ znumicc_components(i_ctx_t * i_ctx_p)
         return code;
     if (code == 0)
         return_error(gs_error_undefined);
+    if (r_type(pnval) != t_integer)
+        return gs_note_error(gs_error_typecheck);
     ncomps = pnval->value.intval;
     /* verify the DataSource entry. Create profile from stream */
     if (dict_find_string(op, ""DataSource"", &pstrmval) <= 0)",ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/zicc.c;h=dbd2562c7b748955173e098463d23ec738ba363d;hb=dbd2562c7b748955173e098463d23ec738ba363d,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/zicc.c;h=53bdf340df0f2110c17d1c17e1d309d37b1c23df;hb=53bdf340df0f2110c17d1c17e1d309d37b1c23df,1,"zset_outputintent(i_ctx_t * i_ctx_p)
{
    os_ptr                  op = osp;
    int                     code = 0;
    gx_device *dev = gs_currentdevice(igs);
    cmm_dev_profile_t       *dev_profile;
    stream *                s = 0L;
    ref *                   pnval;
    ref *                   pstrmval;
    int                     ncomps, dev_comps;
    cmm_profile_t           *picc_profile;
    int                     expected = 0;
    gs_color_space_index    index;
    gsicc_manager_t         *icc_manager = igs->icc_manager;
    cmm_profile_t           *source_profile = NULL;

    check_type(*op, t_dictionary);
    check_dict_read(*op);
    if_debug0m(gs_debug_flag_icc, imemory, ""[icc] Using OutputIntent\n"");

    /* Get the device structure */
    code = dev_proc(dev, get_profile)(dev,  &dev_profile);
    if (code < 0)
        return code;

    if (dev_profile == NULL) {
        code = gsicc_init_device_profile_struct(dev, NULL, 0);
        if (code < 0)
            return code;
        code = dev_proc(dev, get_profile)(dev,  &dev_profile);
        if (code < 0)
            return code;
    }
    if (dev_profile->oi_profile != NULL) {
        return 0;  /* Allow only one setting of this object */
    }
    code = dict_find_string(op, ""N"", &pnval);
    if (code < 0)
         return code;
     if (code == 0)
         return_error(gs_error_undefined);
//fix_flaw_line_below:
//    if (r_type(pnval) != t_integer)
//fix_flaw_line_below:
//        return gs_note_error(gs_error_typecheck);
     ncomps = pnval->value.intval;
 
     /* verify the DataSource entry. Creat profile from stream */
    check_read_file(i_ctx_p, s, pstrmval);

    picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0);
    if (picc_profile == NULL)
        return gs_throw(gs_error_VMerror, ""Creation of ICC profile failed"");
    picc_profile->num_comps = ncomps;
    picc_profile->profile_handle =
        gsicc_get_profile_handle_buffer(picc_profile->buffer,
                                        picc_profile->buffer_size,
                                        gs_gstate_memory(igs));
    if (picc_profile->profile_handle == NULL) {
        rc_decrement(picc_profile,""zset_outputintent"");
        return -1;
    }
    picc_profile->data_cs =
        gscms_get_profile_data_space(picc_profile->profile_handle,
            picc_profile->memory);
    switch (picc_profile->data_cs) {
        case gsCIEXYZ:
        case gsCIELAB:
        case gsRGB:
            expected = 3;
            source_profile = icc_manager->default_rgb;
            break;
        case gsGRAY:
            expected = 1;
            source_profile = icc_manager->default_gray;
            break;
        case gsCMYK:
            expected = 4;
            source_profile = icc_manager->default_cmyk;
            break;
        case gsNCHANNEL:
            expected = 0;
            break;
        case gsNAMED:
        case gsUNDEFINED:
            break;
    }
    if (expected && ncomps != expected) {
        rc_decrement(picc_profile,""zset_outputintent"");
        return_error(gs_error_rangecheck);
    }
    gsicc_init_hash_cs(picc_profile, igs);

    /* All is well with the profile.  Lets set the stuff that needs to be set */
    dev_profile->oi_profile = picc_profile;
    picc_profile->name = (char *) gs_alloc_bytes(picc_profile->memory,
                                                 MAX_DEFAULT_ICC_LENGTH,
                                                 ""zset_outputintent"");
    strncpy(picc_profile->name, OI_PROFILE, strlen(OI_PROFILE));
    picc_profile->name[strlen(OI_PROFILE)] = 0;
    picc_profile->name_length = strlen(OI_PROFILE);
    /* Set the range of the profile */
    gsicc_set_icc_range(&picc_profile);

    /* If the output device has a different number of componenets, then we are
       going to set the output intent as the proofing profile, unless the
       proofing profile has already been set.

       If the device has the same number of components (and color model) then as
       the profile we will use this as the output profile, unless someone has
       explicitly set the output profile.

       Finally, we will use the output intent profile for the default profile
       of the proper Device profile in the icc manager, again, unless someone
       has explicitly set this default profile. */

    dev_comps = dev_profile->device_profile[0]->num_comps;
    index = gsicc_get_default_type(dev_profile->device_profile[0]);
    if (ncomps == dev_comps && index < gs_color_space_index_DevicePixel) {
        /* The OI profile is the same type as the profile for the device and a
           ""default"" profile for the device was not externally set. So we go
           ahead and use the OI profile as the device profile.  Care needs to be
           taken here to keep from screwing up any device parameters.   We will
           use a keyword of OIProfile for the user/device parameter to indicate
           its usage.  Also, note conflicts if one is setting object dependent
           color management */
        rc_assign(dev_profile->device_profile[0], picc_profile,
                  ""zset_outputintent"");
        if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used for device profile\n"");
    } else {
        if (dev_profile->proof_profile == NULL) {
            /* This means that we should use the OI profile as the proofing
               profile.  Note that if someone already has specified a
               proofing profile it is unclear what they are trying to do
               with the output intent.  In this case, we will use it
               just for the source data below */
            dev_profile->proof_profile = picc_profile;
            rc_increment(picc_profile);
            if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used for proof profile\n"");
        }
    }
    /* Now the source colors.  See which source color space needs to use the
       output intent ICC profile */
    index = gsicc_get_default_type(source_profile);
    if (index < gs_color_space_index_DevicePixel) {
        /* source_profile is currently the default.  Set it to the OI profile */
        switch (picc_profile->data_cs) {
            case gsGRAY:
                if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used source Gray\n"");
                rc_assign(icc_manager->default_gray, picc_profile,
                          ""zset_outputintent"");
                break;
            case gsRGB:
                if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used source RGB\n"");
                rc_assign(icc_manager->default_rgb, picc_profile,
                          ""zset_outputintent"");
                break;
            case gsCMYK:
                if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used source CMYK\n"");
                rc_assign(icc_manager->default_cmyk, picc_profile,
                          ""zset_outputintent"");
                break;
            default:
                break;
        }
    }
    /* Remove the output intent dict from the stack */
    pop(1);
    return code;
}
"
83,177819,,Remote,Not required,Partial,CVE-2018-19134,https://www.cvedetails.com/cve/CVE-2018-19134/,CWE-704,Medium,Partial,Partial,,2018-12-20,6.8,"In Artifex Ghostscript through 9.25, the setpattern operator did not properly validate certain types. A specially crafted PostScript document could exploit this to crash Ghostscript or, possibly, execute arbitrary code in the context of the Ghostscript process. This is a type confusion issue because of failure to check whether the Implementation of a pattern dictionary was a structure type.",2019-01-11,Exec Code,2,http://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=693baf02152119af6e6afd30bb8ec76d14f84bbf,693baf02152119af6e6afd30bb8ec76d14f84bbf,,1,,,"gs_pattern2_set_color(const gs_client_color * pcc, gs_gstate * pgs)
{
    gs_pattern2_instance_t * pinst = (gs_pattern2_instance_t *)pcc->pattern;
    gs_color_space * pcs = pinst->templat.Shading->params.ColorSpace;
    int code;
    uchar k, num_comps;
 
     pinst->saved->overprint_mode = pgs->overprint_mode;
     pinst->saved->overprint = pgs->overprint;

     num_comps = pgs->device->color_info.num_components;
     for (k = 0; k < num_comps; k++) {
        pgs->color_component_map.color_map[k] =
             pinst->saved->color_component_map.color_map[k];
     }
     code = pcs->type->set_overprint(pcs, pgs);
    return code;
}
","gs_pattern2_set_color(const gs_client_color * pcc, gs_gstate * pgs)
{
    gs_pattern2_instance_t * pinst = (gs_pattern2_instance_t *)pcc->pattern;
    gs_color_space * pcs = pinst->templat.Shading->params.ColorSpace;
    int code;
    uchar k, num_comps;
 
     pinst->saved->overprint_mode = pgs->overprint_mode;
     pinst->saved->overprint = pgs->overprint;
     num_comps = pgs->device->color_info.num_components;
     for (k = 0; k < num_comps; k++) {
        pgs->color_component_map.color_map[k] = 
             pinst->saved->color_component_map.color_map[k];
     }
     code = pcs->type->set_overprint(pcs, pgs);
    return code;
}
",C,"
        pgs->color_component_map.color_map[k] =
","        pgs->color_component_map.color_map[k] = 
",81f3d1e7247b9a8e29a388677b01959e612a28c7,"@@ -33,7 +33,7 @@
 
 /* GC descriptors */
 private_st_pattern2_template();
-private_st_pattern2_instance();
+public_st_pattern2_instance();
 
 /* GC procedures */
 static ENUM_PTRS_BEGIN(pattern2_instance_enum_ptrs) {
@@ -206,10 +206,10 @@ gs_pattern2_set_color(const gs_client_color * pcc, gs_gstate * pgs)
 
     pinst->saved->overprint_mode = pgs->overprint_mode;
     pinst->saved->overprint = pgs->overprint;
-    
+
     num_comps = pgs->device->color_info.num_components;
     for (k = 0; k < num_comps; k++) {
-        pgs->color_component_map.color_map[k] = 
+        pgs->color_component_map.color_map[k] =
             pinst->saved->color_component_map.color_map[k];
     }
     code = pcs->type->set_overprint(pcs, pgs);",ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=base/gsptype2.c;h=c53eb2e9f161c63a733ae2dcda932ef6f751b91b;hb=693baf02152119af6e6afd30bb8ec76d14f84bbf,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=base/gsptype2.c;h=791e538c07297d24b89fefaca9434f644c65a1c5,1,"gs_pattern2_set_color(const gs_client_color * pcc, gs_gstate * pgs)
{
    gs_pattern2_instance_t * pinst = (gs_pattern2_instance_t *)pcc->pattern;
    gs_color_space * pcs = pinst->templat.Shading->params.ColorSpace;
    int code;
    uchar k, num_comps;
 
     pinst->saved->overprint_mode = pgs->overprint_mode;
     pinst->saved->overprint = pgs->overprint;
//flaw_line_below:
    
//fix_flaw_line_below:
//
     num_comps = pgs->device->color_info.num_components;
     for (k = 0; k < num_comps; k++) {
//flaw_line_below:
        pgs->color_component_map.color_map[k] = 
//fix_flaw_line_below:
//        pgs->color_component_map.color_map[k] =
             pinst->saved->color_component_map.color_map[k];
     }
     code = pcs->type->set_overprint(pcs, pgs);
    return code;
}
"
133,177869,,Remote,Not required,Partial,CVE-2018-16513,https://www.cvedetails.com/cve/CVE-2018-16513/,CWE-704,Medium,Partial,Partial,,2018-09-05,6.8,"In Artifex Ghostscript before 9.24, attackers able to supply crafted PostScript files could use a type confusion in the setcolor function to crash the interpreter or possibly have unspecified other impact.",2019-04-25,,3,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=b326a71659b7837d3acde954b18bda1a6f5e9498,b326a71659b7837d3acde954b18bda1a6f5e9498,,2,,,"zsetcolor(i_ctx_t * i_ctx_p)
{
    os_ptr                  op = osp;
    es_ptr ep;
    const gs_color_space *  pcs = gs_currentcolorspace(igs);
    gs_client_color         cc;
    int                     n_comps, n_numeric_comps, num_offset = 0, code, depth;
    PS_colour_space_t *space;

    /* initialize the client color pattern pointer for GC */
    cc.pattern = 0;

    /* check for a pattern color space */
    if ((n_comps = cs_num_components(pcs)) < 0) {
        n_comps = -n_comps;
         if (r_has_type(op, t_dictionary)) {
             ref     *pImpl, pPatInst;
 
            if ((code = dict_find_string(op, ""Implementation"", &pImpl)) < 0)
                return code;
            if (code > 0) {
                 code = array_get(imemory, pImpl, 0, &pPatInst);
                 if (code < 0)
                     return code;
                n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern)
                      ? n_comps - 1
                      : 0 );
            } else
                n_numeric_comps = 0;
        } else
            n_numeric_comps = 0;
        num_offset = 1;
    } else
        n_numeric_comps = n_comps;

    /* gather the numeric operands */
    code = float_params(op - num_offset, n_numeric_comps, cc.paint.values);
    if (code < 0)
        return code;
    /* The values are copied to graphic state and compared with */
    /* other colors by memcmp() in gx_hld_saved_color_equal()   */
    /* This is the easiest way to avoid indeterminism */
    memset(cc.paint.values + n_numeric_comps, 0,
            sizeof(cc.paint.values) - sizeof(*cc.paint.values)*n_numeric_comps);

    code = get_space_object(i_ctx_p, &istate->colorspace[0].array, &space);
    if (code < 0)
        return code;
    if (space->validatecomponents) {
        code = space->validatecomponents(i_ctx_p,
                                         &istate->colorspace[0].array,
                                         cc.paint.values, n_numeric_comps);
        if (code < 0)
            return code;
    }

    /* pass the color to the graphic library */
    if ((code = gs_setcolor(igs, &cc)) >= 0) {

        if (n_comps > n_numeric_comps) {
            istate->pattern[0] = *op;      /* save pattern dict or null */
        }
    }

    /* Check the color spaces, to see if we need to run any tint transform
     * procedures. Some Adobe applications *eg Photoshop) expect that the
     * tint transform will be run and use this to set up duotone DeviceN
     * spaces.
     */
    code = validate_spaces(i_ctx_p, &istate->colorspace[0].array, &depth);
    if (code < 0)
        return code;
    /* Set up for the continuation procedure which will do the work */
    /* Make sure the exec stack has enough space */
    check_estack(5);
    /* A place holder for data potentially used by transform functions */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'depth' of the space returned during checking above */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'stage' of processing (initially 0) */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store a pointer to the color space stored on the operand stack
     * as the stack may grow unpredictably making further access
     * to the space difficult
     */
    ep = esp += 1;
    *ep = istate->colorspace[0].array;
    /* Finally, the actual continuation routine */
    push_op_estack(setcolor_cont);
    return o_push_estack;
}
","zsetcolor(i_ctx_t * i_ctx_p)
{
    os_ptr                  op = osp;
    es_ptr ep;
    const gs_color_space *  pcs = gs_currentcolorspace(igs);
    gs_client_color         cc;
    int                     n_comps, n_numeric_comps, num_offset = 0, code, depth;
    PS_colour_space_t *space;

    /* initialize the client color pattern pointer for GC */
    cc.pattern = 0;

    /* check for a pattern color space */
    if ((n_comps = cs_num_components(pcs)) < 0) {
        n_comps = -n_comps;
         if (r_has_type(op, t_dictionary)) {
             ref     *pImpl, pPatInst;
 
            code = dict_find_string(op, ""Implementation"", &pImpl);
            if (code != 0) {
                 code = array_get(imemory, pImpl, 0, &pPatInst);
                 if (code < 0)
                     return code;
                n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern)
                      ? n_comps - 1
                      : 0 );
            } else
                n_numeric_comps = 0;
        } else
            n_numeric_comps = 0;
        num_offset = 1;
    } else
        n_numeric_comps = n_comps;

    /* gather the numeric operands */
    code = float_params(op - num_offset, n_numeric_comps, cc.paint.values);
    if (code < 0)
        return code;
    /* The values are copied to graphic state and compared with */
    /* other colors by memcmp() in gx_hld_saved_color_equal()   */
    /* This is the easiest way to avoid indeterminism */
    memset(cc.paint.values + n_numeric_comps, 0,
            sizeof(cc.paint.values) - sizeof(*cc.paint.values)*n_numeric_comps);

    code = get_space_object(i_ctx_p, &istate->colorspace[0].array, &space);
    if (code < 0)
        return code;
    if (space->validatecomponents) {
        code = space->validatecomponents(i_ctx_p,
                                         &istate->colorspace[0].array,
                                         cc.paint.values, n_numeric_comps);
        if (code < 0)
            return code;
    }

    /* pass the color to the graphic library */
    if ((code = gs_setcolor(igs, &cc)) >= 0) {

        if (n_comps > n_numeric_comps) {
            istate->pattern[0] = *op;      /* save pattern dict or null */
        }
    }

    /* Check the color spaces, to see if we need to run any tint transform
     * procedures. Some Adobe applications *eg Photoshop) expect that the
     * tint transform will be run and use this to set up duotone DeviceN
     * spaces.
     */
    code = validate_spaces(i_ctx_p, &istate->colorspace[0].array, &depth);
    if (code < 0)
        return code;
    /* Set up for the continuation procedure which will do the work */
    /* Make sure the exec stack has enough space */
    check_estack(5);
    /* A place holder for data potentially used by transform functions */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'depth' of the space returned during checking above */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'stage' of processing (initially 0) */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store a pointer to the color space stored on the operand stack
     * as the stack may grow unpredictably making further access
     * to the space difficult
     */
    ep = esp += 1;
    *ep = istate->colorspace[0].array;
    /* Finally, the actual continuation routine */
    push_op_estack(setcolor_cont);
    return o_push_estack;
}
",C,"            if ((code = dict_find_string(op, ""Implementation"", &pImpl)) < 0)
                return code;
            if (code > 0) {
","            code = dict_find_string(op, ""Implementation"", &pImpl);
            if (code != 0) {
",f25045e88de674a1202c1239565ee99e9ddabe91,"@@ -283,8 +283,9 @@ zsetcolor(i_ctx_t * i_ctx_p)
         if (r_has_type(op, t_dictionary)) {
             ref     *pImpl, pPatInst;
 
-            code = dict_find_string(op, ""Implementation"", &pImpl);
-            if (code != 0) {
+            if ((code = dict_find_string(op, ""Implementation"", &pImpl)) < 0)
+                return code;
+            if (code > 0) {
                 code = array_get(imemory, pImpl, 0, &pPatInst);
                 if (code < 0)
                     return code;",ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/zcolor.c;h=e27baf98880bfb3a3b4ae82e96936ceefacdac78;hb=e27baf98880bfb3a3b4ae82e96936ceefacdac78,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/zcolor.c;h=4c0f25827e320ceaa9b510c98f9b1926532a26d5;hb=4c0f25827e320ceaa9b510c98f9b1926532a26d5,1,"zsetcolor(i_ctx_t * i_ctx_p)
{
    os_ptr                  op = osp;
    es_ptr ep;
    const gs_color_space *  pcs = gs_currentcolorspace(igs);
    gs_client_color         cc;
    int                     n_comps, n_numeric_comps, num_offset = 0, code, depth;
    PS_colour_space_t *space;

    /* initialize the client color pattern pointer for GC */
    cc.pattern = 0;

    /* check for a pattern color space */
    if ((n_comps = cs_num_components(pcs)) < 0) {
        n_comps = -n_comps;
         if (r_has_type(op, t_dictionary)) {
             ref     *pImpl, pPatInst;
 
//flaw_line_below:
            code = dict_find_string(op, ""Implementation"", &pImpl);
//flaw_line_below:
            if (code != 0) {
//fix_flaw_line_below:
//            if ((code = dict_find_string(op, ""Implementation"", &pImpl)) < 0)
//fix_flaw_line_below:
//                return code;
//fix_flaw_line_below:
//            if (code > 0) {
                 code = array_get(imemory, pImpl, 0, &pPatInst);
                 if (code < 0)
                     return code;
                n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern)
                      ? n_comps - 1
                      : 0 );
            } else
                n_numeric_comps = 0;
        } else
            n_numeric_comps = 0;
        num_offset = 1;
    } else
        n_numeric_comps = n_comps;

    /* gather the numeric operands */
    code = float_params(op - num_offset, n_numeric_comps, cc.paint.values);
    if (code < 0)
        return code;
    /* The values are copied to graphic state and compared with */
    /* other colors by memcmp() in gx_hld_saved_color_equal()   */
    /* This is the easiest way to avoid indeterminism */
    memset(cc.paint.values + n_numeric_comps, 0,
            sizeof(cc.paint.values) - sizeof(*cc.paint.values)*n_numeric_comps);

    code = get_space_object(i_ctx_p, &istate->colorspace[0].array, &space);
    if (code < 0)
        return code;
    if (space->validatecomponents) {
        code = space->validatecomponents(i_ctx_p,
                                         &istate->colorspace[0].array,
                                         cc.paint.values, n_numeric_comps);
        if (code < 0)
            return code;
    }

    /* pass the color to the graphic library */
    if ((code = gs_setcolor(igs, &cc)) >= 0) {

        if (n_comps > n_numeric_comps) {
            istate->pattern[0] = *op;      /* save pattern dict or null */
        }
    }

    /* Check the color spaces, to see if we need to run any tint transform
     * procedures. Some Adobe applications *eg Photoshop) expect that the
     * tint transform will be run and use this to set up duotone DeviceN
     * spaces.
     */
    code = validate_spaces(i_ctx_p, &istate->colorspace[0].array, &depth);
    if (code < 0)
        return code;
    /* Set up for the continuation procedure which will do the work */
    /* Make sure the exec stack has enough space */
    check_estack(5);
    /* A place holder for data potentially used by transform functions */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'depth' of the space returned during checking above */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'stage' of processing (initially 0) */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store a pointer to the color space stored on the operand stack
     * as the stack may grow unpredictably making further access
     * to the space difficult
     */
    ep = esp += 1;
    *ep = istate->colorspace[0].array;
    /* Finally, the actual continuation routine */
    push_op_estack(setcolor_cont);
    return o_push_estack;
}
"
134,177870,,Remote,Not required,Partial,CVE-2018-16511,https://www.cvedetails.com/cve/CVE-2018-16511/,CWE-704,Medium,Partial,Partial,,2018-09-05,6.8,"An issue was discovered in Artifex Ghostscript before 9.24. A type confusion in ""ztype"" could be used by remote attackers able to supply crafted PostScript to crash the interpreter or possibly have unspecified other impact.",2018-11-27,,1,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=0edd3d6c634a577db261615a9dc2719bca7f6e01,0edd3d6c634a577db261615a9dc2719bca7f6e01,,1,,,"ztype(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    ref tnref;
    int code = array_get(imemory, op, (long)r_btype(op - 1), &tnref);

    if (code < 0)
        return code;
    if (!r_has_type(&tnref, t_name)) {
         /* Must be either a stack underflow or a t_[a]struct. */
         check_op(2);
         {                       /* Get the type name from the structure. */
            if ((r_has_type(&op[-1], t_struct) || r_has_type(&op[-1], t_astruct)) && op[-1].value.pstruct != 0x00) {
             const char *sname =
                 gs_struct_type_name_string(gs_object_type(imemory,
                                                           op[-1].value.pstruct));
            int code = name_ref(imemory, (const byte *)sname, strlen(sname),
                                (ref *) (op - 1), 0);

            if (code < 0)
                return code;
            } else
                return_error(gs_error_stackunderflow);
        }
        r_set_attrs(op - 1, a_executable);
    } else {
        ref_assign(op - 1, &tnref);
    }
    pop(1);
    return 0;
}
","ztype(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    ref tnref;
    int code = array_get(imemory, op, (long)r_btype(op - 1), &tnref);

    if (code < 0)
        return code;
    if (!r_has_type(&tnref, t_name)) {
         /* Must be either a stack underflow or a t_[a]struct. */
         check_op(2);
         {                       /* Get the type name from the structure. */
            if (op[-1].value.pstruct != 0x00) {
             const char *sname =
                 gs_struct_type_name_string(gs_object_type(imemory,
                                                           op[-1].value.pstruct));
            int code = name_ref(imemory, (const byte *)sname, strlen(sname),
                                (ref *) (op - 1), 0);

            if (code < 0)
                return code;
            } else
                return_error(gs_error_stackunderflow);
        }
        r_set_attrs(op - 1, a_executable);
    } else {
        ref_assign(op - 1, &tnref);
    }
    pop(1);
    return 0;
}
",C,"            if ((r_has_type(&op[-1], t_struct) || r_has_type(&op[-1], t_astruct)) && op[-1].value.pstruct != 0x00) {
","            if (op[-1].value.pstruct != 0x00) {
",a054156d425b4dbdaaa9fda4b5f1182b27598c2b,"@@ -76,7 +76,7 @@ ztype(i_ctx_t *i_ctx_p)
         /* Must be either a stack underflow or a t_[a]struct. */
         check_op(2);
         {                       /* Get the type name from the structure. */
-            if (op[-1].value.pstruct != 0x00) {
+            if ((r_has_type(&op[-1], t_struct) || r_has_type(&op[-1], t_astruct)) && op[-1].value.pstruct != 0x00) {
             const char *sname =
                 gs_struct_type_name_string(gs_object_type(imemory,
                                                           op[-1].value.pstruct));",ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/ztype.c;h=830795631291a67df12511686cd074db8120d94b;hb=830795631291a67df12511686cd074db8120d94b,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/ztype.c;h=ad248d96c60ddbd99964c54387954e4a0c86ed64;hb=ad248d96c60ddbd99964c54387954e4a0c86ed64,1,"ztype(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    ref tnref;
    int code = array_get(imemory, op, (long)r_btype(op - 1), &tnref);

    if (code < 0)
        return code;
    if (!r_has_type(&tnref, t_name)) {
         /* Must be either a stack underflow or a t_[a]struct. */
         check_op(2);
         {                       /* Get the type name from the structure. */
//flaw_line_below:
            if (op[-1].value.pstruct != 0x00) {
//fix_flaw_line_below:
//            if ((r_has_type(&op[-1], t_struct) || r_has_type(&op[-1], t_astruct)) && op[-1].value.pstruct != 0x00) {
             const char *sname =
                 gs_struct_type_name_string(gs_object_type(imemory,
                                                           op[-1].value.pstruct));
            int code = name_ref(imemory, (const byte *)sname, strlen(sname),
                                (ref *) (op - 1), 0);

            if (code < 0)
                return code;
            } else
                return_error(gs_error_stackunderflow);
        }
        r_set_attrs(op - 1, a_executable);
    } else {
        ref_assign(op - 1, &tnref);
    }
    pop(1);
    return 0;
}
"
140,177876,,Remote,Not required,Partial,CVE-2018-15910,https://www.cvedetails.com/cve/CVE-2018-15910/,CWE-704,Medium,Partial,Partial,,2018-08-27,6.8,"In Artifex Ghostscript before 9.24, attackers able to supply crafted PostScript files could use a type confusion in the LockDistillerParams parameter to crash the interpreter or execute code.",2019-04-25,Exec Code,1,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=c3476dde7743761a4e1d39a631716199b696b880,c3476dde7743761a4e1d39a631716199b696b880,,1,,,"gdev_pdf_put_params_impl(gx_device * dev, const gx_device_pdf * save_dev, gs_param_list * plist)
{
    int ecode, code;
    gx_device_pdf *pdev = (gx_device_pdf *) dev;
    float cl = (float)pdev->CompatibilityLevel;
    bool locked = pdev->params.LockDistillerParams, ForOPDFRead;
    gs_param_name param_name;

    pdev->pdf_memory = gs_memory_stable(pdev->memory);
    /*
     * If this is a pseudo-parameter (pdfmark or DSC),
     * don't bother checking for any real ones.
     */

    {
        gs_param_string_array ppa;
        gs_param_string pps;

        code = param_read_string_array(plist, (param_name = ""pdfmark""), &ppa);
        switch (code) {
            case 0:
                code = pdfwrite_pdf_open_document(pdev);
                if (code < 0)
                    return code;
                code = pdfmark_process(pdev, &ppa);
                if (code >= 0)
                    return code;
                /* falls through for errors */
            default:
                param_signal_error(plist, param_name, code);
                return code;
            case 1:
                break;
        }

        code = param_read_string_array(plist, (param_name = ""DSC""), &ppa);
        switch (code) {
            case 0:
                code = pdfwrite_pdf_open_document(pdev);
                if (code < 0)
                    return code;
                code = pdf_dsc_process(pdev, &ppa);
                if (code >= 0)
                    return code;
                /* falls through for errors */
            default:
                param_signal_error(plist, param_name, code);
                return code;
            case 1:
                break;
        }

        code = param_read_string(plist, (param_name = ""pdfpagelabels""), &pps);
        switch (code) {
            case 0:
                {
                    if (!pdev->ForOPDFRead) {
                        cos_dict_t *const pcd = pdev->Catalog;
                        code = pdfwrite_pdf_open_document(pdev);
                        if (code < 0)
                            return code;
                        code = cos_dict_put_string(pcd, (const byte *)""/PageLabels"", 11,
                                   pps.data, pps.size);
                        if (code >= 0)
                            return code;
                    } else
                        return 0;
                 }
                /* falls through for errors */
            default:
                param_signal_error(plist, param_name, code);
                return code;
            case 1:
                break;
        }
    }

    /*
     * Check for LockDistillerParams before doing anything else.
     * If LockDistillerParams is true and is not being set to false,
     * ignore all resettings of PDF-specific parameters.  Note that
      * LockDistillerParams is read again, and reset if necessary, in
      * psdf_put_params.
      */
    ecode = param_read_bool(plist, (param_name = ""LockDistillerParams""), &locked);
     if (ecode < 0)
         param_signal_error(plist, param_name, ecode);
    /* General parameters. */

    {
        int efo = 1;

        ecode = param_put_int(plist, (param_name = "".EmbedFontObjects""), &efo, ecode);
        if (ecode < 0)
            param_signal_error(plist, param_name, ecode);
        if (efo != 1)
            param_signal_error(plist, param_name, ecode = gs_error_rangecheck);
    }
    {
        int cdv = CoreDistVersion;

        ecode = param_put_int(plist, (param_name = ""CoreDistVersion""), &cdv, ecode);
        if (ecode < 0)
            return gs_note_error(ecode);
        if (cdv != CoreDistVersion)
            param_signal_error(plist, param_name, ecode = gs_error_rangecheck);
    }

    switch (code = param_read_float(plist, (param_name = ""CompatibilityLevel""), &cl)) {
        default:
            ecode = code;
            param_signal_error(plist, param_name, ecode);
            break;
        case 0:
            if (!(locked && pdev->params.LockDistillerParams)) {
                /*
                 * Must be 1.2, 1.3, 1.4, or 1.5.  Per Adobe documentation, substitute
                 * the nearest achievable value.
                 */
                if (cl < (float)1.15)
                    cl = (float)1.1;
                else if (cl < (float)1.25)
                    cl = (float)1.2;
                else if (cl < (float)1.35)
                    cl = (float)1.3;
                else if (cl < (float)1.45)
                    cl = (float)1.4;
                else if (cl < (float)1.55)
                    cl = (float)1.5;
                else if (cl < (float)1.65)
                    cl = (float)1.6;
                else if (cl < (float)1.75)
                    cl = (float)1.7;
                else {
                    cl = (float)2.0;
                    if (pdev->params.TransferFunctionInfo == tfi_Preserve)
                        pdev->params.TransferFunctionInfo = tfi_Apply;
                }
            }
        case 1:
            break;
    }
    {   /* HACK : gs_param_list_s::memory is documented in gsparam.h as
           ""for allocating coerced arrays"". Not sure why zputdeviceparams
           sets it to the current memory space, while the device
           assumes to store them in the device's memory space.
           As a hackish workaround we temporary replace it here.
           Doing so because we don't want to change the global code now
           because we're unable to test it with all devices.
           Bug 688531 ""Segmentation fault running pdfwrite from 219-01.ps"".

           This solution to be reconsidered after fixing
           the bug 688533 ""zputdeviceparams specifies a wrong memory space."".
        */
        gs_memory_t *mem = plist->memory;

        plist->memory = pdev->pdf_memory;
        code = gs_param_read_items(plist, pdev, pdf_param_items);
        if (code < 0 || (code = param_read_bool(plist, ""ForOPDFRead"", &ForOPDFRead)) < 0)
        {
        }
        if (code == 0 && !pdev->is_ps2write && !(locked && pdev->params.LockDistillerParams))
            pdev->ForOPDFRead = ForOPDFRead;
        plist->memory = mem;
    }
    if (code < 0)
        ecode = code;
    {
        /*
         * Setting FirstObjectNumber is only legal if the file
         * has just been opened and nothing has been written,
         * or if we are setting it to the same value.
         */
        long fon = pdev->FirstObjectNumber;

        if (fon != save_dev->FirstObjectNumber) {
            if (fon <= 0 || fon > 0x7fff0000 ||
                (pdev->next_id != 0 &&
                 pdev->next_id !=
                 save_dev->FirstObjectNumber + pdf_num_initial_ids)
                ) {
                ecode = gs_error_rangecheck;
                param_signal_error(plist, ""FirstObjectNumber"", ecode);
            }
        }
    }
    {
        /*
         * Set ProcessColorModel now, because gx_default_put_params checks
         * it.
         */
        static const char *const pcm_names[] = {
            ""DeviceGray"", ""DeviceRGB"", ""DeviceCMYK"", ""DeviceN"", 0
        };
        int pcm = -1;

        ecode = param_put_enum(plist, ""ProcessColorModel"", &pcm,
                               pcm_names, ecode);
        if (pcm >= 0) {
            pdf_set_process_color_model(pdev, pcm);
            rc_decrement(pdev->icc_struct, ""gdev_pdf_put_params_impl, ProcessColorModel changed"");
            pdev->icc_struct = 0;
        }
    }
    if (ecode < 0)
        goto fail;

    if (pdev->is_ps2write && (code = param_read_bool(plist, ""ProduceDSC"", &pdev->ProduceDSC)) < 0) {
        param_signal_error(plist, param_name, code);
    }

    /* PDFA and PDFX are stored in the page device dictionary and therefore
     * set on every setpagedevice. However, if we have encountered a file which
     * can't be made this way, and the PDFACompatibilityPolicy is 1, we want to
     * continue producing the file, but not as a PDF/A or PDF/X file. Its more
     * or less impossible to alter the setting in the (potentially saved) page
     * device dictionary, so we use this rather clunky method.
     */
    if (pdev->PDFA < 0 || pdev->PDFA > 3){
        ecode = gs_note_error(gs_error_rangecheck);
        param_signal_error(plist, ""PDFA"", ecode);
        goto fail;
    }
    if(pdev->PDFA != 0 && pdev->AbortPDFAX)
        pdev->PDFA = 0;
    if(pdev->PDFX && pdev->AbortPDFAX)
        pdev->PDFX = 0;
    if (pdev->PDFX && pdev->PDFA != 0) {
        ecode = gs_note_error(gs_error_rangecheck);
        param_signal_error(plist, ""PDFA"", ecode);
        goto fail;
    }
    if (pdev->PDFX && pdev->ForOPDFRead) {
        ecode = gs_note_error(gs_error_rangecheck);
        param_signal_error(plist, ""PDFX"", ecode);
        goto fail;
    }
    if (pdev->PDFA != 0 && pdev->ForOPDFRead) {
        ecode = gs_note_error(gs_error_rangecheck);
        param_signal_error(plist, ""PDFA"", ecode);
        goto fail;
    }
    if (pdev->PDFA == 1 || pdev->PDFX || pdev->CompatibilityLevel < 1.4) {
         pdev->HaveTransparency = false;
         pdev->PreserveSMask = false;
    }

    /*
     * We have to set version to the new value, because the set of
     * legal parameter values for psdf_put_params varies according to
     * the version.
     */
    if (pdev->PDFX)
        cl = (float)1.3; /* Instead pdev->CompatibilityLevel = 1.2; - see below. */
    if (pdev->PDFA != 0 && cl < 1.4)
        cl = (float)1.4;
    pdev->version = (cl < 1.2 ? psdf_version_level2 : psdf_version_ll3);
    if (pdev->ForOPDFRead) {
        pdev->ResourcesBeforeUsage = true;
        pdev->HaveCFF = false;
        pdev->HavePDFWidths = false;
        pdev->HaveStrokeColor = false;
        cl = (float)1.2; /* Instead pdev->CompatibilityLevel = 1.2; - see below. */
        pdev->MaxInlineImageSize = max_long; /* Save printer's RAM from saving temporary image data.
                                                Immediate images doen't need buffering. */
        pdev->version = psdf_version_level2;
    } else {
        pdev->ResourcesBeforeUsage = false;
        pdev->HaveCFF = true;
        pdev->HavePDFWidths = true;
        pdev->HaveStrokeColor = true;
    }
    pdev->ParamCompatibilityLevel = cl;
    if (cl < 1.2) {
        pdev->HaveCFF = false;
    }
    ecode = gdev_psdf_put_params(dev, plist);
    if (ecode < 0)
        goto fail;

    if (pdev->CompatibilityLevel > 1.7 && pdev->params.TransferFunctionInfo == tfi_Preserve) {
        pdev->params.TransferFunctionInfo = tfi_Apply;
        emprintf(pdev->memory, ""\nIt is not possible to preserve transfer functions in PDF 2.0\ntransfer functions will be applied instead\n"");
    }

    if (pdev->params.ConvertCMYKImagesToRGB) {
        if (pdev->params.ColorConversionStrategy == ccs_CMYK) {
            emprintf(pdev->memory, ""ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of CMYK\n"");
        } else {
            if (pdev->params.ColorConversionStrategy == ccs_Gray) {
                emprintf(pdev->memory, ""ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of Gray\n"");
            } else {
                if (pdev->icc_struct)
                    rc_decrement(pdev->icc_struct,
                                 ""reset default profile\n"");
                pdf_set_process_color_model(pdev,1);
                ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);
                if (ecode < 0)
                    goto fail;
            }
        }
    }
    switch (pdev->params.ColorConversionStrategy) {
        case ccs_ByObjectType:
        case ccs_LeaveColorUnchanged:
            break;
        case ccs_UseDeviceDependentColor:
        case ccs_UseDeviceIndependentColor:
        case ccs_UseDeviceIndependentColorForImages:
            pdev->params.TransferFunctionInfo = tfi_Apply;
            break;
        case ccs_CMYK:
            pdev->params.TransferFunctionInfo = tfi_Apply;
            if (pdev->icc_struct)
                rc_decrement(pdev->icc_struct,
                             ""reset default profile\n"");
            pdf_set_process_color_model(pdev, 2);
            ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);
            if (ecode < 0)
                goto fail;
            break;
        case ccs_Gray:
            pdev->params.TransferFunctionInfo = tfi_Apply;
            if (pdev->icc_struct)
                rc_decrement(pdev->icc_struct,
                             ""reset default profile\n"");
            pdf_set_process_color_model(pdev,0);
            ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);
            if (ecode < 0)
                goto fail;
            break;
        case ccs_sRGB:
        case ccs_RGB:
            pdev->params.TransferFunctionInfo = tfi_Apply;
            /* Only bother to do this if we didn't handle it above */
            if (!pdev->params.ConvertCMYKImagesToRGB) {
                if (pdev->icc_struct)
                    rc_decrement(pdev->icc_struct,
                                 ""reset default profile\n"");
                pdf_set_process_color_model(pdev,1);
                ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);
                if (ecode < 0)
                    goto fail;
            }
            break;
        default:
            break;
    }
    if (cl < 1.5f && pdev->params.ColorImage.Filter != NULL &&
            !strcmp(pdev->params.ColorImage.Filter, ""JPXEncode"")) {
        emprintf(pdev->memory,
                 ""JPXEncode requires CompatibilityLevel >= 1.5 .\n"");
        ecode = gs_note_error(gs_error_rangecheck);
    }
    if (cl < 1.5f && pdev->params.GrayImage.Filter != NULL &&
            !strcmp(pdev->params.GrayImage.Filter, ""JPXEncode"")) {
        emprintf(pdev->memory,
                 ""JPXEncode requires CompatibilityLevel >= 1.5 .\n"");
        ecode = gs_note_error(gs_error_rangecheck);
    }
    if (cl < 1.4f && pdev->params.MonoImage.Filter != NULL &&
            !strcmp(pdev->params.MonoImage.Filter, ""JBIG2Encode"")) {
        emprintf(pdev->memory,
                 ""JBIG2Encode requires CompatibilityLevel >= 1.4 .\n"");
        ecode = gs_note_error(gs_error_rangecheck);
    }
    if (pdev->HaveTrueTypes && pdev->version == psdf_version_level2) {
        pdev->version = psdf_version_level2_with_TT ;
    }
    if (ecode < 0)
        goto fail;

    if (pdev->FirstObjectNumber != save_dev->FirstObjectNumber) {
        if (pdev->xref.file != 0) {
            if (gp_fseek_64(pdev->xref.file, 0L, SEEK_SET) != 0) {
                ecode = gs_error_ioerror;
                goto fail;
            }
            pdf_initialize_ids(pdev);
        }
    }
    /* Handle the float/double mismatch. */
    pdev->CompatibilityLevel = (int)(cl * 10 + 0.5) / 10.0;
    if(pdev->OwnerPassword.size != save_dev->OwnerPassword.size ||
        (pdev->OwnerPassword.size != 0 &&
         memcmp(pdev->OwnerPassword.data, save_dev->OwnerPassword.data,
         pdev->OwnerPassword.size) != 0)) {
        if (pdev->is_open) {
            if (pdev->PageCount == 0) {
                gs_closedevice((gx_device *)save_dev);
                return 0;
            }
            else
                emprintf(pdev->memory, ""Owner Password changed mid-job, ignoring.\n"");
        }
    }

    if (pdev->Linearise && pdev->is_ps2write) {
        emprintf(pdev->memory, ""Can't linearise PostScript output, ignoring\n"");
        pdev->Linearise = false;
    }

    if (pdev->Linearise && pdev->OwnerPassword.size != 0) {
        emprintf(pdev->memory, ""Can't linearise encrypted PDF, ignoring\n"");
        pdev->Linearise = false;
    }

    if (pdev->FlattenFonts)
        pdev->PreserveTrMode = false;
    return 0;
 fail:
    /* Restore all the parameters to their original state. */
    pdev->version = save_dev->version;
    pdf_set_process_color_model(pdev, save_dev->pcm_color_info_index);
    pdev->saved_fill_color = save_dev->saved_fill_color;
    pdev->saved_stroke_color = save_dev->saved_fill_color;
    {
        const gs_param_item_t *ppi = pdf_param_items;

        for (; ppi->key; ++ppi)
            memcpy((char *)pdev + ppi->offset,
                   (char *)save_dev + ppi->offset,
                   gs_param_type_sizes[ppi->type]);
        pdev->ForOPDFRead = save_dev->ForOPDFRead;
    }
    return ecode;
}
","gdev_pdf_put_params_impl(gx_device * dev, const gx_device_pdf * save_dev, gs_param_list * plist)
{
    int ecode, code;
    gx_device_pdf *pdev = (gx_device_pdf *) dev;
    float cl = (float)pdev->CompatibilityLevel;
    bool locked = pdev->params.LockDistillerParams, ForOPDFRead;
    gs_param_name param_name;

    pdev->pdf_memory = gs_memory_stable(pdev->memory);
    /*
     * If this is a pseudo-parameter (pdfmark or DSC),
     * don't bother checking for any real ones.
     */

    {
        gs_param_string_array ppa;
        gs_param_string pps;

        code = param_read_string_array(plist, (param_name = ""pdfmark""), &ppa);
        switch (code) {
            case 0:
                code = pdfwrite_pdf_open_document(pdev);
                if (code < 0)
                    return code;
                code = pdfmark_process(pdev, &ppa);
                if (code >= 0)
                    return code;
                /* falls through for errors */
            default:
                param_signal_error(plist, param_name, code);
                return code;
            case 1:
                break;
        }

        code = param_read_string_array(plist, (param_name = ""DSC""), &ppa);
        switch (code) {
            case 0:
                code = pdfwrite_pdf_open_document(pdev);
                if (code < 0)
                    return code;
                code = pdf_dsc_process(pdev, &ppa);
                if (code >= 0)
                    return code;
                /* falls through for errors */
            default:
                param_signal_error(plist, param_name, code);
                return code;
            case 1:
                break;
        }

        code = param_read_string(plist, (param_name = ""pdfpagelabels""), &pps);
        switch (code) {
            case 0:
                {
                    if (!pdev->ForOPDFRead) {
                        cos_dict_t *const pcd = pdev->Catalog;
                        code = pdfwrite_pdf_open_document(pdev);
                        if (code < 0)
                            return code;
                        code = cos_dict_put_string(pcd, (const byte *)""/PageLabels"", 11,
                                   pps.data, pps.size);
                        if (code >= 0)
                            return code;
                    } else
                        return 0;
                 }
                /* falls through for errors */
            default:
                param_signal_error(plist, param_name, code);
                return code;
            case 1:
                break;
        }
    }

    /*
     * Check for LockDistillerParams before doing anything else.
     * If LockDistillerParams is true and is not being set to false,
     * ignore all resettings of PDF-specific parameters.  Note that
      * LockDistillerParams is read again, and reset if necessary, in
      * psdf_put_params.
      */
    ecode = param_read_bool(plist, ""LockDistillerParams"", &locked);
     if (ecode < 0)
         param_signal_error(plist, param_name, ecode);
    /* General parameters. */

    {
        int efo = 1;

        ecode = param_put_int(plist, (param_name = "".EmbedFontObjects""), &efo, ecode);
        if (ecode < 0)
            param_signal_error(plist, param_name, ecode);
        if (efo != 1)
            param_signal_error(plist, param_name, ecode = gs_error_rangecheck);
    }
    {
        int cdv = CoreDistVersion;

        ecode = param_put_int(plist, (param_name = ""CoreDistVersion""), &cdv, ecode);
        if (ecode < 0)
            return gs_note_error(ecode);
        if (cdv != CoreDistVersion)
            param_signal_error(plist, param_name, ecode = gs_error_rangecheck);
    }

    switch (code = param_read_float(plist, (param_name = ""CompatibilityLevel""), &cl)) {
        default:
            ecode = code;
            param_signal_error(plist, param_name, ecode);
            break;
        case 0:
            if (!(locked && pdev->params.LockDistillerParams)) {
                /*
                 * Must be 1.2, 1.3, 1.4, or 1.5.  Per Adobe documentation, substitute
                 * the nearest achievable value.
                 */
                if (cl < (float)1.15)
                    cl = (float)1.1;
                else if (cl < (float)1.25)
                    cl = (float)1.2;
                else if (cl < (float)1.35)
                    cl = (float)1.3;
                else if (cl < (float)1.45)
                    cl = (float)1.4;
                else if (cl < (float)1.55)
                    cl = (float)1.5;
                else if (cl < (float)1.65)
                    cl = (float)1.6;
                else if (cl < (float)1.75)
                    cl = (float)1.7;
                else {
                    cl = (float)2.0;
                    if (pdev->params.TransferFunctionInfo == tfi_Preserve)
                        pdev->params.TransferFunctionInfo = tfi_Apply;
                }
            }
        case 1:
            break;
    }
    {   /* HACK : gs_param_list_s::memory is documented in gsparam.h as
           ""for allocating coerced arrays"". Not sure why zputdeviceparams
           sets it to the current memory space, while the device
           assumes to store them in the device's memory space.
           As a hackish workaround we temporary replace it here.
           Doing so because we don't want to change the global code now
           because we're unable to test it with all devices.
           Bug 688531 ""Segmentation fault running pdfwrite from 219-01.ps"".

           This solution to be reconsidered after fixing
           the bug 688533 ""zputdeviceparams specifies a wrong memory space."".
        */
        gs_memory_t *mem = plist->memory;

        plist->memory = pdev->pdf_memory;
        code = gs_param_read_items(plist, pdev, pdf_param_items);
        if (code < 0 || (code = param_read_bool(plist, ""ForOPDFRead"", &ForOPDFRead)) < 0)
        {
        }
        if (code == 0 && !pdev->is_ps2write && !(locked && pdev->params.LockDistillerParams))
            pdev->ForOPDFRead = ForOPDFRead;
        plist->memory = mem;
    }
    if (code < 0)
        ecode = code;
    {
        /*
         * Setting FirstObjectNumber is only legal if the file
         * has just been opened and nothing has been written,
         * or if we are setting it to the same value.
         */
        long fon = pdev->FirstObjectNumber;

        if (fon != save_dev->FirstObjectNumber) {
            if (fon <= 0 || fon > 0x7fff0000 ||
                (pdev->next_id != 0 &&
                 pdev->next_id !=
                 save_dev->FirstObjectNumber + pdf_num_initial_ids)
                ) {
                ecode = gs_error_rangecheck;
                param_signal_error(plist, ""FirstObjectNumber"", ecode);
            }
        }
    }
    {
        /*
         * Set ProcessColorModel now, because gx_default_put_params checks
         * it.
         */
        static const char *const pcm_names[] = {
            ""DeviceGray"", ""DeviceRGB"", ""DeviceCMYK"", ""DeviceN"", 0
        };
        int pcm = -1;

        ecode = param_put_enum(plist, ""ProcessColorModel"", &pcm,
                               pcm_names, ecode);
        if (pcm >= 0) {
            pdf_set_process_color_model(pdev, pcm);
            rc_decrement(pdev->icc_struct, ""gdev_pdf_put_params_impl, ProcessColorModel changed"");
            pdev->icc_struct = 0;
        }
    }
    if (ecode < 0)
        goto fail;

    if (pdev->is_ps2write && (code = param_read_bool(plist, ""ProduceDSC"", &pdev->ProduceDSC)) < 0) {
        param_signal_error(plist, param_name, code);
    }

    /* PDFA and PDFX are stored in the page device dictionary and therefore
     * set on every setpagedevice. However, if we have encountered a file which
     * can't be made this way, and the PDFACompatibilityPolicy is 1, we want to
     * continue producing the file, but not as a PDF/A or PDF/X file. Its more
     * or less impossible to alter the setting in the (potentially saved) page
     * device dictionary, so we use this rather clunky method.
     */
    if (pdev->PDFA < 0 || pdev->PDFA > 3){
        ecode = gs_note_error(gs_error_rangecheck);
        param_signal_error(plist, ""PDFA"", ecode);
        goto fail;
    }
    if(pdev->PDFA != 0 && pdev->AbortPDFAX)
        pdev->PDFA = 0;
    if(pdev->PDFX && pdev->AbortPDFAX)
        pdev->PDFX = 0;
    if (pdev->PDFX && pdev->PDFA != 0) {
        ecode = gs_note_error(gs_error_rangecheck);
        param_signal_error(plist, ""PDFA"", ecode);
        goto fail;
    }
    if (pdev->PDFX && pdev->ForOPDFRead) {
        ecode = gs_note_error(gs_error_rangecheck);
        param_signal_error(plist, ""PDFX"", ecode);
        goto fail;
    }
    if (pdev->PDFA != 0 && pdev->ForOPDFRead) {
        ecode = gs_note_error(gs_error_rangecheck);
        param_signal_error(plist, ""PDFA"", ecode);
        goto fail;
    }
    if (pdev->PDFA == 1 || pdev->PDFX || pdev->CompatibilityLevel < 1.4) {
         pdev->HaveTransparency = false;
         pdev->PreserveSMask = false;
    }

    /*
     * We have to set version to the new value, because the set of
     * legal parameter values for psdf_put_params varies according to
     * the version.
     */
    if (pdev->PDFX)
        cl = (float)1.3; /* Instead pdev->CompatibilityLevel = 1.2; - see below. */
    if (pdev->PDFA != 0 && cl < 1.4)
        cl = (float)1.4;
    pdev->version = (cl < 1.2 ? psdf_version_level2 : psdf_version_ll3);
    if (pdev->ForOPDFRead) {
        pdev->ResourcesBeforeUsage = true;
        pdev->HaveCFF = false;
        pdev->HavePDFWidths = false;
        pdev->HaveStrokeColor = false;
        cl = (float)1.2; /* Instead pdev->CompatibilityLevel = 1.2; - see below. */
        pdev->MaxInlineImageSize = max_long; /* Save printer's RAM from saving temporary image data.
                                                Immediate images doen't need buffering. */
        pdev->version = psdf_version_level2;
    } else {
        pdev->ResourcesBeforeUsage = false;
        pdev->HaveCFF = true;
        pdev->HavePDFWidths = true;
        pdev->HaveStrokeColor = true;
    }
    pdev->ParamCompatibilityLevel = cl;
    if (cl < 1.2) {
        pdev->HaveCFF = false;
    }
    ecode = gdev_psdf_put_params(dev, plist);
    if (ecode < 0)
        goto fail;

    if (pdev->CompatibilityLevel > 1.7 && pdev->params.TransferFunctionInfo == tfi_Preserve) {
        pdev->params.TransferFunctionInfo = tfi_Apply;
        emprintf(pdev->memory, ""\nIt is not possible to preserve transfer functions in PDF 2.0\ntransfer functions will be applied instead\n"");
    }

    if (pdev->params.ConvertCMYKImagesToRGB) {
        if (pdev->params.ColorConversionStrategy == ccs_CMYK) {
            emprintf(pdev->memory, ""ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of CMYK\n"");
        } else {
            if (pdev->params.ColorConversionStrategy == ccs_Gray) {
                emprintf(pdev->memory, ""ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of Gray\n"");
            } else {
                if (pdev->icc_struct)
                    rc_decrement(pdev->icc_struct,
                                 ""reset default profile\n"");
                pdf_set_process_color_model(pdev,1);
                ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);
                if (ecode < 0)
                    goto fail;
            }
        }
    }
    switch (pdev->params.ColorConversionStrategy) {
        case ccs_ByObjectType:
        case ccs_LeaveColorUnchanged:
            break;
        case ccs_UseDeviceDependentColor:
        case ccs_UseDeviceIndependentColor:
        case ccs_UseDeviceIndependentColorForImages:
            pdev->params.TransferFunctionInfo = tfi_Apply;
            break;
        case ccs_CMYK:
            pdev->params.TransferFunctionInfo = tfi_Apply;
            if (pdev->icc_struct)
                rc_decrement(pdev->icc_struct,
                             ""reset default profile\n"");
            pdf_set_process_color_model(pdev, 2);
            ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);
            if (ecode < 0)
                goto fail;
            break;
        case ccs_Gray:
            pdev->params.TransferFunctionInfo = tfi_Apply;
            if (pdev->icc_struct)
                rc_decrement(pdev->icc_struct,
                             ""reset default profile\n"");
            pdf_set_process_color_model(pdev,0);
            ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);
            if (ecode < 0)
                goto fail;
            break;
        case ccs_sRGB:
        case ccs_RGB:
            pdev->params.TransferFunctionInfo = tfi_Apply;
            /* Only bother to do this if we didn't handle it above */
            if (!pdev->params.ConvertCMYKImagesToRGB) {
                if (pdev->icc_struct)
                    rc_decrement(pdev->icc_struct,
                                 ""reset default profile\n"");
                pdf_set_process_color_model(pdev,1);
                ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);
                if (ecode < 0)
                    goto fail;
            }
            break;
        default:
            break;
    }
    if (cl < 1.5f && pdev->params.ColorImage.Filter != NULL &&
            !strcmp(pdev->params.ColorImage.Filter, ""JPXEncode"")) {
        emprintf(pdev->memory,
                 ""JPXEncode requires CompatibilityLevel >= 1.5 .\n"");
        ecode = gs_note_error(gs_error_rangecheck);
    }
    if (cl < 1.5f && pdev->params.GrayImage.Filter != NULL &&
            !strcmp(pdev->params.GrayImage.Filter, ""JPXEncode"")) {
        emprintf(pdev->memory,
                 ""JPXEncode requires CompatibilityLevel >= 1.5 .\n"");
        ecode = gs_note_error(gs_error_rangecheck);
    }
    if (cl < 1.4f && pdev->params.MonoImage.Filter != NULL &&
            !strcmp(pdev->params.MonoImage.Filter, ""JBIG2Encode"")) {
        emprintf(pdev->memory,
                 ""JBIG2Encode requires CompatibilityLevel >= 1.4 .\n"");
        ecode = gs_note_error(gs_error_rangecheck);
    }
    if (pdev->HaveTrueTypes && pdev->version == psdf_version_level2) {
        pdev->version = psdf_version_level2_with_TT ;
    }
    if (ecode < 0)
        goto fail;

    if (pdev->FirstObjectNumber != save_dev->FirstObjectNumber) {
        if (pdev->xref.file != 0) {
            if (gp_fseek_64(pdev->xref.file, 0L, SEEK_SET) != 0) {
                ecode = gs_error_ioerror;
                goto fail;
            }
            pdf_initialize_ids(pdev);
        }
    }
    /* Handle the float/double mismatch. */
    pdev->CompatibilityLevel = (int)(cl * 10 + 0.5) / 10.0;
    if(pdev->OwnerPassword.size != save_dev->OwnerPassword.size ||
        (pdev->OwnerPassword.size != 0 &&
         memcmp(pdev->OwnerPassword.data, save_dev->OwnerPassword.data,
         pdev->OwnerPassword.size) != 0)) {
        if (pdev->is_open) {
            if (pdev->PageCount == 0) {
                gs_closedevice((gx_device *)save_dev);
                return 0;
            }
            else
                emprintf(pdev->memory, ""Owner Password changed mid-job, ignoring.\n"");
        }
    }

    if (pdev->Linearise && pdev->is_ps2write) {
        emprintf(pdev->memory, ""Can't linearise PostScript output, ignoring\n"");
        pdev->Linearise = false;
    }

    if (pdev->Linearise && pdev->OwnerPassword.size != 0) {
        emprintf(pdev->memory, ""Can't linearise encrypted PDF, ignoring\n"");
        pdev->Linearise = false;
    }

    if (pdev->FlattenFonts)
        pdev->PreserveTrMode = false;
    return 0;
 fail:
    /* Restore all the parameters to their original state. */
    pdev->version = save_dev->version;
    pdf_set_process_color_model(pdev, save_dev->pcm_color_info_index);
    pdev->saved_fill_color = save_dev->saved_fill_color;
    pdev->saved_stroke_color = save_dev->saved_fill_color;
    {
        const gs_param_item_t *ppi = pdf_param_items;

        for (; ppi->key; ++ppi)
            memcpy((char *)pdev + ppi->offset,
                   (char *)save_dev + ppi->offset,
                   gs_param_type_sizes[ppi->type]);
        pdev->ForOPDFRead = save_dev->ForOPDFRead;
    }
    return ecode;
}
",C,"    ecode = param_read_bool(plist, (param_name = ""LockDistillerParams""), &locked);
","    ecode = param_read_bool(plist, ""LockDistillerParams"", &locked);
",b326a71659b7837d3acde954b18bda1a6f5e9498,"@@ -364,7 +364,7 @@ gdev_pdf_put_params_impl(gx_device * dev, const gx_device_pdf * save_dev, gs_par
      * LockDistillerParams is read again, and reset if necessary, in
      * psdf_put_params.
      */
-    ecode = param_read_bool(plist, ""LockDistillerParams"", &locked);
+    ecode = param_read_bool(plist, (param_name = ""LockDistillerParams""), &locked);
     if (ecode < 0)
         param_signal_error(plist, param_name, ecode);",ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=devices/vector/gdevpdfp.c;h=7c58af76797feeab26d722bf4031b040d9f2729f;hb=c3476dde7743761a4e1d39a631716199b696b880,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=devices/vector/gdevpdfp.c;h=e9426823024b82f579049c613cdcda26761d2277,1,"gdev_pdf_put_params_impl(gx_device * dev, const gx_device_pdf * save_dev, gs_param_list * plist)
{
    int ecode, code;
    gx_device_pdf *pdev = (gx_device_pdf *) dev;
    float cl = (float)pdev->CompatibilityLevel;
    bool locked = pdev->params.LockDistillerParams, ForOPDFRead;
    gs_param_name param_name;

    pdev->pdf_memory = gs_memory_stable(pdev->memory);
    /*
     * If this is a pseudo-parameter (pdfmark or DSC),
     * don't bother checking for any real ones.
     */

    {
        gs_param_string_array ppa;
        gs_param_string pps;

        code = param_read_string_array(plist, (param_name = ""pdfmark""), &ppa);
        switch (code) {
            case 0:
                code = pdfwrite_pdf_open_document(pdev);
                if (code < 0)
                    return code;
                code = pdfmark_process(pdev, &ppa);
                if (code >= 0)
                    return code;
                /* falls through for errors */
            default:
                param_signal_error(plist, param_name, code);
                return code;
            case 1:
                break;
        }

        code = param_read_string_array(plist, (param_name = ""DSC""), &ppa);
        switch (code) {
            case 0:
                code = pdfwrite_pdf_open_document(pdev);
                if (code < 0)
                    return code;
                code = pdf_dsc_process(pdev, &ppa);
                if (code >= 0)
                    return code;
                /* falls through for errors */
            default:
                param_signal_error(plist, param_name, code);
                return code;
            case 1:
                break;
        }

        code = param_read_string(plist, (param_name = ""pdfpagelabels""), &pps);
        switch (code) {
            case 0:
                {
                    if (!pdev->ForOPDFRead) {
                        cos_dict_t *const pcd = pdev->Catalog;
                        code = pdfwrite_pdf_open_document(pdev);
                        if (code < 0)
                            return code;
                        code = cos_dict_put_string(pcd, (const byte *)""/PageLabels"", 11,
                                   pps.data, pps.size);
                        if (code >= 0)
                            return code;
                    } else
                        return 0;
                 }
                /* falls through for errors */
            default:
                param_signal_error(plist, param_name, code);
                return code;
            case 1:
                break;
        }
    }

    /*
     * Check for LockDistillerParams before doing anything else.
     * If LockDistillerParams is true and is not being set to false,
     * ignore all resettings of PDF-specific parameters.  Note that
      * LockDistillerParams is read again, and reset if necessary, in
      * psdf_put_params.
      */
//flaw_line_below:
    ecode = param_read_bool(plist, ""LockDistillerParams"", &locked);
//fix_flaw_line_below:
//    ecode = param_read_bool(plist, (param_name = ""LockDistillerParams""), &locked);
     if (ecode < 0)
         param_signal_error(plist, param_name, ecode);
    /* General parameters. */

    {
        int efo = 1;

        ecode = param_put_int(plist, (param_name = "".EmbedFontObjects""), &efo, ecode);
        if (ecode < 0)
            param_signal_error(plist, param_name, ecode);
        if (efo != 1)
            param_signal_error(plist, param_name, ecode = gs_error_rangecheck);
    }
    {
        int cdv = CoreDistVersion;

        ecode = param_put_int(plist, (param_name = ""CoreDistVersion""), &cdv, ecode);
        if (ecode < 0)
            return gs_note_error(ecode);
        if (cdv != CoreDistVersion)
            param_signal_error(plist, param_name, ecode = gs_error_rangecheck);
    }

    switch (code = param_read_float(plist, (param_name = ""CompatibilityLevel""), &cl)) {
        default:
            ecode = code;
            param_signal_error(plist, param_name, ecode);
            break;
        case 0:
            if (!(locked && pdev->params.LockDistillerParams)) {
                /*
                 * Must be 1.2, 1.3, 1.4, or 1.5.  Per Adobe documentation, substitute
                 * the nearest achievable value.
                 */
                if (cl < (float)1.15)
                    cl = (float)1.1;
                else if (cl < (float)1.25)
                    cl = (float)1.2;
                else if (cl < (float)1.35)
                    cl = (float)1.3;
                else if (cl < (float)1.45)
                    cl = (float)1.4;
                else if (cl < (float)1.55)
                    cl = (float)1.5;
                else if (cl < (float)1.65)
                    cl = (float)1.6;
                else if (cl < (float)1.75)
                    cl = (float)1.7;
                else {
                    cl = (float)2.0;
                    if (pdev->params.TransferFunctionInfo == tfi_Preserve)
                        pdev->params.TransferFunctionInfo = tfi_Apply;
                }
            }
        case 1:
            break;
    }
    {   /* HACK : gs_param_list_s::memory is documented in gsparam.h as
           ""for allocating coerced arrays"". Not sure why zputdeviceparams
           sets it to the current memory space, while the device
           assumes to store them in the device's memory space.
           As a hackish workaround we temporary replace it here.
           Doing so because we don't want to change the global code now
           because we're unable to test it with all devices.
           Bug 688531 ""Segmentation fault running pdfwrite from 219-01.ps"".

           This solution to be reconsidered after fixing
           the bug 688533 ""zputdeviceparams specifies a wrong memory space."".
        */
        gs_memory_t *mem = plist->memory;

        plist->memory = pdev->pdf_memory;
        code = gs_param_read_items(plist, pdev, pdf_param_items);
        if (code < 0 || (code = param_read_bool(plist, ""ForOPDFRead"", &ForOPDFRead)) < 0)
        {
        }
        if (code == 0 && !pdev->is_ps2write && !(locked && pdev->params.LockDistillerParams))
            pdev->ForOPDFRead = ForOPDFRead;
        plist->memory = mem;
    }
    if (code < 0)
        ecode = code;
    {
        /*
         * Setting FirstObjectNumber is only legal if the file
         * has just been opened and nothing has been written,
         * or if we are setting it to the same value.
         */
        long fon = pdev->FirstObjectNumber;

        if (fon != save_dev->FirstObjectNumber) {
            if (fon <= 0 || fon > 0x7fff0000 ||
                (pdev->next_id != 0 &&
                 pdev->next_id !=
                 save_dev->FirstObjectNumber + pdf_num_initial_ids)
                ) {
                ecode = gs_error_rangecheck;
                param_signal_error(plist, ""FirstObjectNumber"", ecode);
            }
        }
    }
    {
        /*
         * Set ProcessColorModel now, because gx_default_put_params checks
         * it.
         */
        static const char *const pcm_names[] = {
            ""DeviceGray"", ""DeviceRGB"", ""DeviceCMYK"", ""DeviceN"", 0
        };
        int pcm = -1;

        ecode = param_put_enum(plist, ""ProcessColorModel"", &pcm,
                               pcm_names, ecode);
        if (pcm >= 0) {
            pdf_set_process_color_model(pdev, pcm);
            rc_decrement(pdev->icc_struct, ""gdev_pdf_put_params_impl, ProcessColorModel changed"");
            pdev->icc_struct = 0;
        }
    }
    if (ecode < 0)
        goto fail;

    if (pdev->is_ps2write && (code = param_read_bool(plist, ""ProduceDSC"", &pdev->ProduceDSC)) < 0) {
        param_signal_error(plist, param_name, code);
    }

    /* PDFA and PDFX are stored in the page device dictionary and therefore
     * set on every setpagedevice. However, if we have encountered a file which
     * can't be made this way, and the PDFACompatibilityPolicy is 1, we want to
     * continue producing the file, but not as a PDF/A or PDF/X file. Its more
     * or less impossible to alter the setting in the (potentially saved) page
     * device dictionary, so we use this rather clunky method.
     */
    if (pdev->PDFA < 0 || pdev->PDFA > 3){
        ecode = gs_note_error(gs_error_rangecheck);
        param_signal_error(plist, ""PDFA"", ecode);
        goto fail;
    }
    if(pdev->PDFA != 0 && pdev->AbortPDFAX)
        pdev->PDFA = 0;
    if(pdev->PDFX && pdev->AbortPDFAX)
        pdev->PDFX = 0;
    if (pdev->PDFX && pdev->PDFA != 0) {
        ecode = gs_note_error(gs_error_rangecheck);
        param_signal_error(plist, ""PDFA"", ecode);
        goto fail;
    }
    if (pdev->PDFX && pdev->ForOPDFRead) {
        ecode = gs_note_error(gs_error_rangecheck);
        param_signal_error(plist, ""PDFX"", ecode);
        goto fail;
    }
    if (pdev->PDFA != 0 && pdev->ForOPDFRead) {
        ecode = gs_note_error(gs_error_rangecheck);
        param_signal_error(plist, ""PDFA"", ecode);
        goto fail;
    }
    if (pdev->PDFA == 1 || pdev->PDFX || pdev->CompatibilityLevel < 1.4) {
         pdev->HaveTransparency = false;
         pdev->PreserveSMask = false;
    }

    /*
     * We have to set version to the new value, because the set of
     * legal parameter values for psdf_put_params varies according to
     * the version.
     */
    if (pdev->PDFX)
        cl = (float)1.3; /* Instead pdev->CompatibilityLevel = 1.2; - see below. */
    if (pdev->PDFA != 0 && cl < 1.4)
        cl = (float)1.4;
    pdev->version = (cl < 1.2 ? psdf_version_level2 : psdf_version_ll3);
    if (pdev->ForOPDFRead) {
        pdev->ResourcesBeforeUsage = true;
        pdev->HaveCFF = false;
        pdev->HavePDFWidths = false;
        pdev->HaveStrokeColor = false;
        cl = (float)1.2; /* Instead pdev->CompatibilityLevel = 1.2; - see below. */
        pdev->MaxInlineImageSize = max_long; /* Save printer's RAM from saving temporary image data.
                                                Immediate images doen't need buffering. */
        pdev->version = psdf_version_level2;
    } else {
        pdev->ResourcesBeforeUsage = false;
        pdev->HaveCFF = true;
        pdev->HavePDFWidths = true;
        pdev->HaveStrokeColor = true;
    }
    pdev->ParamCompatibilityLevel = cl;
    if (cl < 1.2) {
        pdev->HaveCFF = false;
    }
    ecode = gdev_psdf_put_params(dev, plist);
    if (ecode < 0)
        goto fail;

    if (pdev->CompatibilityLevel > 1.7 && pdev->params.TransferFunctionInfo == tfi_Preserve) {
        pdev->params.TransferFunctionInfo = tfi_Apply;
        emprintf(pdev->memory, ""\nIt is not possible to preserve transfer functions in PDF 2.0\ntransfer functions will be applied instead\n"");
    }

    if (pdev->params.ConvertCMYKImagesToRGB) {
        if (pdev->params.ColorConversionStrategy == ccs_CMYK) {
            emprintf(pdev->memory, ""ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of CMYK\n"");
        } else {
            if (pdev->params.ColorConversionStrategy == ccs_Gray) {
                emprintf(pdev->memory, ""ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of Gray\n"");
            } else {
                if (pdev->icc_struct)
                    rc_decrement(pdev->icc_struct,
                                 ""reset default profile\n"");
                pdf_set_process_color_model(pdev,1);
                ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);
                if (ecode < 0)
                    goto fail;
            }
        }
    }
    switch (pdev->params.ColorConversionStrategy) {
        case ccs_ByObjectType:
        case ccs_LeaveColorUnchanged:
            break;
        case ccs_UseDeviceDependentColor:
        case ccs_UseDeviceIndependentColor:
        case ccs_UseDeviceIndependentColorForImages:
            pdev->params.TransferFunctionInfo = tfi_Apply;
            break;
        case ccs_CMYK:
            pdev->params.TransferFunctionInfo = tfi_Apply;
            if (pdev->icc_struct)
                rc_decrement(pdev->icc_struct,
                             ""reset default profile\n"");
            pdf_set_process_color_model(pdev, 2);
            ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);
            if (ecode < 0)
                goto fail;
            break;
        case ccs_Gray:
            pdev->params.TransferFunctionInfo = tfi_Apply;
            if (pdev->icc_struct)
                rc_decrement(pdev->icc_struct,
                             ""reset default profile\n"");
            pdf_set_process_color_model(pdev,0);
            ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);
            if (ecode < 0)
                goto fail;
            break;
        case ccs_sRGB:
        case ccs_RGB:
            pdev->params.TransferFunctionInfo = tfi_Apply;
            /* Only bother to do this if we didn't handle it above */
            if (!pdev->params.ConvertCMYKImagesToRGB) {
                if (pdev->icc_struct)
                    rc_decrement(pdev->icc_struct,
                                 ""reset default profile\n"");
                pdf_set_process_color_model(pdev,1);
                ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);
                if (ecode < 0)
                    goto fail;
            }
            break;
        default:
            break;
    }
    if (cl < 1.5f && pdev->params.ColorImage.Filter != NULL &&
            !strcmp(pdev->params.ColorImage.Filter, ""JPXEncode"")) {
        emprintf(pdev->memory,
                 ""JPXEncode requires CompatibilityLevel >= 1.5 .\n"");
        ecode = gs_note_error(gs_error_rangecheck);
    }
    if (cl < 1.5f && pdev->params.GrayImage.Filter != NULL &&
            !strcmp(pdev->params.GrayImage.Filter, ""JPXEncode"")) {
        emprintf(pdev->memory,
                 ""JPXEncode requires CompatibilityLevel >= 1.5 .\n"");
        ecode = gs_note_error(gs_error_rangecheck);
    }
    if (cl < 1.4f && pdev->params.MonoImage.Filter != NULL &&
            !strcmp(pdev->params.MonoImage.Filter, ""JBIG2Encode"")) {
        emprintf(pdev->memory,
                 ""JBIG2Encode requires CompatibilityLevel >= 1.4 .\n"");
        ecode = gs_note_error(gs_error_rangecheck);
    }
    if (pdev->HaveTrueTypes && pdev->version == psdf_version_level2) {
        pdev->version = psdf_version_level2_with_TT ;
    }
    if (ecode < 0)
        goto fail;

    if (pdev->FirstObjectNumber != save_dev->FirstObjectNumber) {
        if (pdev->xref.file != 0) {
            if (gp_fseek_64(pdev->xref.file, 0L, SEEK_SET) != 0) {
                ecode = gs_error_ioerror;
                goto fail;
            }
            pdf_initialize_ids(pdev);
        }
    }
    /* Handle the float/double mismatch. */
    pdev->CompatibilityLevel = (int)(cl * 10 + 0.5) / 10.0;
    if(pdev->OwnerPassword.size != save_dev->OwnerPassword.size ||
        (pdev->OwnerPassword.size != 0 &&
         memcmp(pdev->OwnerPassword.data, save_dev->OwnerPassword.data,
         pdev->OwnerPassword.size) != 0)) {
        if (pdev->is_open) {
            if (pdev->PageCount == 0) {
                gs_closedevice((gx_device *)save_dev);
                return 0;
            }
            else
                emprintf(pdev->memory, ""Owner Password changed mid-job, ignoring.\n"");
        }
    }

    if (pdev->Linearise && pdev->is_ps2write) {
        emprintf(pdev->memory, ""Can't linearise PostScript output, ignoring\n"");
        pdev->Linearise = false;
    }

    if (pdev->Linearise && pdev->OwnerPassword.size != 0) {
        emprintf(pdev->memory, ""Can't linearise encrypted PDF, ignoring\n"");
        pdev->Linearise = false;
    }

    if (pdev->FlattenFonts)
        pdev->PreserveTrMode = false;
    return 0;
 fail:
    /* Restore all the parameters to their original state. */
    pdev->version = save_dev->version;
    pdf_set_process_color_model(pdev, save_dev->pcm_color_info_index);
    pdev->saved_fill_color = save_dev->saved_fill_color;
    pdev->saved_stroke_color = save_dev->saved_fill_color;
    {
        const gs_param_item_t *ppi = pdf_param_items;

        for (; ppi->key; ++ppi)
            memcpy((char *)pdev + ppi->offset,
                   (char *)save_dev + ppi->offset,
                   gs_param_type_sizes[ppi->type]);
        pdev->ForOPDFRead = save_dev->ForOPDFRead;
    }
    return ecode;
}
"
141,177877,,Remote,Not required,Partial,CVE-2018-15910,https://www.cvedetails.com/cve/CVE-2018-15910/,CWE-704,Medium,Partial,Partial,,2018-08-27,6.8,"In Artifex Ghostscript before 9.24, attackers able to supply crafted PostScript files could use a type confusion in the LockDistillerParams parameter to crash the interpreter or execute code.",2019-04-25,Exec Code,4,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=c3476dde7743761a4e1d39a631716199b696b880,c3476dde7743761a4e1d39a631716199b696b880,,3,,," ref_param_read_signal_error(gs_param_list * plist, gs_param_name pkey, int code)
 {
     iparam_list *const iplist = (iparam_list *) plist;
    iparam_loc loc = {0};
 
    ref_param_read(iplist, pkey, &loc, -1);
    if (loc.presult)
        *loc.presult = code;
     switch (ref_param_read_get_policy(plist, pkey)) {
         case gs_param_policy_ignore:
             return 0;
            return_error(gs_error_configurationerror);
        default:
            return code;
    }
}
"," ref_param_read_signal_error(gs_param_list * plist, gs_param_name pkey, int code)
 {
     iparam_list *const iplist = (iparam_list *) plist;
    iparam_loc loc;
 
    ref_param_read(iplist, pkey, &loc, -1);    /* can't fail */
    *loc.presult = code;
     switch (ref_param_read_get_policy(plist, pkey)) {
         case gs_param_policy_ignore:
             return 0;
            return_error(gs_error_configurationerror);
        default:
            return code;
    }
}
",C,"    iparam_loc loc = {0};
    ref_param_read(iplist, pkey, &loc, -1);
    if (loc.presult)
        *loc.presult = code;
","    iparam_loc loc;
    ref_param_read(iplist, pkey, &loc, -1);    /* can't fail */
    *loc.presult = code;
",b326a71659b7837d3acde954b18bda1a6f5e9498,"@@ -822,10 +822,11 @@ static int
 ref_param_read_signal_error(gs_param_list * plist, gs_param_name pkey, int code)
 {
     iparam_list *const iplist = (iparam_list *) plist;
-    iparam_loc loc;
+    iparam_loc loc = {0};
 
-    ref_param_read(iplist, pkey, &loc, -1);    /* can't fail */
-    *loc.presult = code;
+    ref_param_read(iplist, pkey, &loc, -1);
+    if (loc.presult)
+        *loc.presult = code;
     switch (ref_param_read_get_policy(plist, pkey)) {
         case gs_param_policy_ignore:
             return 0;",ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/iparam.c;h=0279455cf307e5fc54b3795d49fb28d8b526194f;hb=c3476dde7743761a4e1d39a631716199b696b880,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/iparam.c;h=68c20d4d2c2893eb9a41a25058d4f01d8a223b95,1," ref_param_read_signal_error(gs_param_list * plist, gs_param_name pkey, int code)
 {
     iparam_list *const iplist = (iparam_list *) plist;
//flaw_line_below:
    iparam_loc loc;
//fix_flaw_line_below:
//    iparam_loc loc = {0};
 
//flaw_line_below:
    ref_param_read(iplist, pkey, &loc, -1);    /* can't fail */
//flaw_line_below:
    *loc.presult = code;
//fix_flaw_line_below:
//    ref_param_read(iplist, pkey, &loc, -1);
//fix_flaw_line_below:
//    if (loc.presult)
//fix_flaw_line_below:
//        *loc.presult = code;
     switch (ref_param_read_get_policy(plist, pkey)) {
         case gs_param_policy_ignore:
             return 0;
            return_error(gs_error_configurationerror);
        default:
            return code;
    }
}
"
699,178435,,Remote,Not required,Partial,CVE-2016-8602,https://www.cvedetails.com/cve/CVE-2016-8602/,CWE-704,Medium,Partial,Partial,,2017-04-14,6.8,The .sethalftone5 function in psi/zht2.c in Ghostscript before 9.21 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted Postscript document that calls .sethalftone5 with an empty operand stack.,2018-01-04,DoS Exec Code,10,http://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=f5c7555c303,f5c7555c30393e64ec1f5ab0dfae5b55b3b3fc78,,2,,,"zsethalftone5(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    uint count;
    gs_halftone_component *phtc = 0;
    gs_halftone_component *pc;
    int code = 0;
    int j;
    bool have_default;
    gs_halftone *pht = 0;
    gx_device_halftone *pdht = 0;
    ref sprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
    ref tprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
     gs_memory_t *mem;
     uint edepth = ref_stack_count(&e_stack);
     int npop = 2;
    int dict_enum;
     ref rvalue[2];
     int cname, colorant_number;
     byte * pname;
     uint name_size;
     int halftonetype, type = 0;
     gs_gstate *pgs = igs;
    int space_index;

    if (ref_stack_count(&o_stack) < 2)
        return_error(gs_error_stackunderflow);
    check_type(*op, t_dictionary);
    check_type(*(op - 1), t_dictionary);

    dict_enum = dict_first(op);
    space_index = r_space_index(op - 1);
 
     mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];
     * the device color space, so we need to mark them
     * with a different internal halftone type.
     */
    code = dict_int_param(op - 1, ""HalftoneType"", 1, 100, 0, &type);
    if (code < 0)
          return code;
    halftonetype = (type == 2 || type == 4)
                        ? ht_type_multiple_colorscreen
                        : ht_type_multiple;

    /* Count how many components that we will actually use. */

    have_default = false;
    for (count = 0; ;) {

        /* Move to next element in the dictionary */
        if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
            break;
        /*
         * Verify that we have a valid component.  We may have a
         * /HalfToneType entry.
         */
        if (!r_has_type(&rvalue[0], t_name))
            continue;
        if (!r_has_type(&rvalue[1], t_dictionary))
            continue;

        /* Get the name of the component  verify that we will use it. */
        cname = name_index(mem, &rvalue[0]);
        code = gs_get_colorname_string(mem, cname, &pname, &name_size);
        if (code < 0)
            break;
        colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
        if (colorant_number < 0)
            continue;
        else if (colorant_number == GX_DEVICE_COLOR_MAX_COMPONENTS) {
            /* If here then we have the ""Default"" component */
            if (have_default)
                return_error(gs_error_rangecheck);
            have_default = true;
        }

        count++;
        /*
         * Check to see if we have already reached the legal number of
         * components.
         */
        if (count > GS_CLIENT_COLOR_MAX_COMPONENTS + 1) {
            code = gs_note_error(gs_error_rangecheck);
            break;
        }
    }
    if (count == 0 || (halftonetype == ht_type_multiple && ! have_default))
        code = gs_note_error(gs_error_rangecheck);

    if (code >= 0) {
        check_estack(5);		/* for sampling Type 1 screens */
        refset_null(sprocs, count);
        refset_null(tprocs, count);
        rc_alloc_struct_0(pht, gs_halftone, &st_halftone,
                          imemory, pht = 0, "".sethalftone5"");
        phtc = gs_alloc_struct_array(mem, count, gs_halftone_component,
                                     &st_ht_component_element,
                                     "".sethalftone5"");
        rc_alloc_struct_0(pdht, gx_device_halftone, &st_device_halftone,
                          imemory, pdht = 0, "".sethalftone5"");
        if (pht == 0 || phtc == 0 || pdht == 0) {
            j = 0; /* Quiet the compiler:
                      gs_note_error isn't necessarily identity,
                      so j could be left ununitialized. */
            code = gs_note_error(gs_error_VMerror);
        }
    }
    if (code >= 0) {
        dict_enum = dict_first(op);
        for (j = 0, pc = phtc; ;) {
            int type;

            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;
            /*
             * Verify that we have a valid component.  We may have a
             * /HalfToneType entry.
             */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;		/* Do not use this component */
            pc->cname = cname;
            pc->comp_number = colorant_number;

            /* Now process the component dictionary */
            check_dict_read(rvalue[1]);
            if (dict_int_param(&rvalue[1], ""HalftoneType"", 1, 7, 0, &type) < 0) {
                code = gs_note_error(gs_error_typecheck);
                break;
            }
            switch (type) {
                default:
                    code = gs_note_error(gs_error_rangecheck);
                    break;
                case 1:
                    code = dict_spot_params(&rvalue[1], &pc->params.spot,
                                                sprocs + j, tprocs + j, mem);
                    pc->params.spot.screen.spot_function = spot1_dummy;
                    pc->type = ht_type_spot;
                    break;
                case 3:
                    code = dict_threshold_params(&rvalue[1], &pc->params.threshold,
                                                        tprocs + j);
                    pc->type = ht_type_threshold;
                    break;
                case 7:
                    code = dict_threshold2_params(&rvalue[1], &pc->params.threshold2,
                                                        tprocs + j, imemory);
                    pc->type = ht_type_threshold2;
                    break;
            }
            if (code < 0)
                break;
            pc++;
            j++;
        }
    }
    if (code >= 0) {
        pht->type = halftonetype;
        pht->params.multiple.components = phtc;
        pht->params.multiple.num_comp = j;
        pht->params.multiple.get_colorname_string = gs_get_colorname_string;
        code = gs_sethalftone_prepare(igs, pht, pdht);
    }
    if (code >= 0) {
        /*
         * Put the actual frequency and angle in the spot function component dictionaries.
         */
        dict_enum = dict_first(op);
        for (pc = phtc; ; ) {
            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;

            /* Verify that we have a valid component */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component and verify that we will use it. */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;

            if (pc->type == ht_type_spot) {
                code = dict_spot_results(i_ctx_p, &rvalue[1], &pc->params.spot);
                if (code < 0)
                    break;
            }
            pc++;
        }
    }
    if (code >= 0) {
        /*
         * Schedule the sampling of any Type 1 screens,
         * and any (Type 1 or Type 3) TransferFunctions.
         * Save the stack depths in case we have to back out.
         */
        uint odepth = ref_stack_count(&o_stack);
        ref odict, odict5;

        odict = op[-1];
        odict5 = *op;
        pop(2);
        op = osp;
        esp += 5;
        make_mark_estack(esp - 4, es_other, sethalftone_cleanup);
        esp[-3] = odict;
        make_istruct(esp - 2, 0, pht);
        make_istruct(esp - 1, 0, pdht);
        make_op_estack(esp, sethalftone_finish);
        for (j = 0; j < count; j++) {
            gx_ht_order *porder = NULL;

            if (pdht->components == 0)
                porder = &pdht->order;
            else {
                /* Find the component in pdht that matches component j in
                   the pht; gs_sethalftone_prepare() may permute these. */
                int k;
                int comp_number = phtc[j].comp_number;
                for (k = 0; k < count; k++) {
                    if (pdht->components[k].comp_number == comp_number) {
                        porder = &pdht->components[k].corder;
                        break;
                    }
                }
            }
            switch (phtc[j].type) {
            case ht_type_spot:
                code = zscreen_enum_init(i_ctx_p, porder,
                                         &phtc[j].params.spot.screen,
                                         &sprocs[j], 0, 0, space_index);
                if (code < 0)
                    break;
                /* falls through */
            case ht_type_threshold:
                if (!r_has_type(tprocs + j, t__invalid)) {
                    /* Schedule TransferFunction sampling. */
                    /****** check_xstack IS WRONG ******/
                    check_ostack(zcolor_remap_one_ostack);
                    check_estack(zcolor_remap_one_estack);
                    code = zcolor_remap_one(i_ctx_p, tprocs + j,
                                            porder->transfer, igs,
                                            zcolor_remap_one_finish);
                    op = osp;
                }
                break;
            default:	/* not possible here, but to keep */
                                /* the compilers happy.... */
                ;
            }
            if (code < 0) {	/* Restore the stack. */
                ref_stack_pop_to(&o_stack, odepth);
                ref_stack_pop_to(&e_stack, edepth);
                op = osp;
                op[-1] = odict;
                *op = odict5;
                break;
            }
            npop = 0;
        }
    }
    if (code < 0) {
        gs_free_object(mem, pdht, "".sethalftone5"");
        gs_free_object(mem, phtc, "".sethalftone5"");
        gs_free_object(mem, pht, "".sethalftone5"");
        return code;
    }
    pop(npop);
    return (ref_stack_count(&e_stack) > edepth ? o_push_estack : 0);
}
","zsethalftone5(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    uint count;
    gs_halftone_component *phtc = 0;
    gs_halftone_component *pc;
    int code = 0;
    int j;
    bool have_default;
    gs_halftone *pht = 0;
    gx_device_halftone *pdht = 0;
    ref sprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
    ref tprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
     gs_memory_t *mem;
     uint edepth = ref_stack_count(&e_stack);
     int npop = 2;
    int dict_enum = dict_first(op);
     ref rvalue[2];
     int cname, colorant_number;
     byte * pname;
     uint name_size;
     int halftonetype, type = 0;
     gs_gstate *pgs = igs;
    int space_index = r_space_index(op - 1);
 
     mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];
     * the device color space, so we need to mark them
     * with a different internal halftone type.
     */
    code = dict_int_param(op - 1, ""HalftoneType"", 1, 100, 0, &type);
    if (code < 0)
          return code;
    halftonetype = (type == 2 || type == 4)
                        ? ht_type_multiple_colorscreen
                        : ht_type_multiple;

    /* Count how many components that we will actually use. */

    have_default = false;
    for (count = 0; ;) {

        /* Move to next element in the dictionary */
        if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
            break;
        /*
         * Verify that we have a valid component.  We may have a
         * /HalfToneType entry.
         */
        if (!r_has_type(&rvalue[0], t_name))
            continue;
        if (!r_has_type(&rvalue[1], t_dictionary))
            continue;

        /* Get the name of the component  verify that we will use it. */
        cname = name_index(mem, &rvalue[0]);
        code = gs_get_colorname_string(mem, cname, &pname, &name_size);
        if (code < 0)
            break;
        colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
        if (colorant_number < 0)
            continue;
        else if (colorant_number == GX_DEVICE_COLOR_MAX_COMPONENTS) {
            /* If here then we have the ""Default"" component */
            if (have_default)
                return_error(gs_error_rangecheck);
            have_default = true;
        }

        count++;
        /*
         * Check to see if we have already reached the legal number of
         * components.
         */
        if (count > GS_CLIENT_COLOR_MAX_COMPONENTS + 1) {
            code = gs_note_error(gs_error_rangecheck);
            break;
        }
    }
    if (count == 0 || (halftonetype == ht_type_multiple && ! have_default))
        code = gs_note_error(gs_error_rangecheck);

    if (code >= 0) {
        check_estack(5);		/* for sampling Type 1 screens */
        refset_null(sprocs, count);
        refset_null(tprocs, count);
        rc_alloc_struct_0(pht, gs_halftone, &st_halftone,
                          imemory, pht = 0, "".sethalftone5"");
        phtc = gs_alloc_struct_array(mem, count, gs_halftone_component,
                                     &st_ht_component_element,
                                     "".sethalftone5"");
        rc_alloc_struct_0(pdht, gx_device_halftone, &st_device_halftone,
                          imemory, pdht = 0, "".sethalftone5"");
        if (pht == 0 || phtc == 0 || pdht == 0) {
            j = 0; /* Quiet the compiler:
                      gs_note_error isn't necessarily identity,
                      so j could be left ununitialized. */
            code = gs_note_error(gs_error_VMerror);
        }
    }
    if (code >= 0) {
        dict_enum = dict_first(op);
        for (j = 0, pc = phtc; ;) {
            int type;

            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;
            /*
             * Verify that we have a valid component.  We may have a
             * /HalfToneType entry.
             */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;		/* Do not use this component */
            pc->cname = cname;
            pc->comp_number = colorant_number;

            /* Now process the component dictionary */
            check_dict_read(rvalue[1]);
            if (dict_int_param(&rvalue[1], ""HalftoneType"", 1, 7, 0, &type) < 0) {
                code = gs_note_error(gs_error_typecheck);
                break;
            }
            switch (type) {
                default:
                    code = gs_note_error(gs_error_rangecheck);
                    break;
                case 1:
                    code = dict_spot_params(&rvalue[1], &pc->params.spot,
                                                sprocs + j, tprocs + j, mem);
                    pc->params.spot.screen.spot_function = spot1_dummy;
                    pc->type = ht_type_spot;
                    break;
                case 3:
                    code = dict_threshold_params(&rvalue[1], &pc->params.threshold,
                                                        tprocs + j);
                    pc->type = ht_type_threshold;
                    break;
                case 7:
                    code = dict_threshold2_params(&rvalue[1], &pc->params.threshold2,
                                                        tprocs + j, imemory);
                    pc->type = ht_type_threshold2;
                    break;
            }
            if (code < 0)
                break;
            pc++;
            j++;
        }
    }
    if (code >= 0) {
        pht->type = halftonetype;
        pht->params.multiple.components = phtc;
        pht->params.multiple.num_comp = j;
        pht->params.multiple.get_colorname_string = gs_get_colorname_string;
        code = gs_sethalftone_prepare(igs, pht, pdht);
    }
    if (code >= 0) {
        /*
         * Put the actual frequency and angle in the spot function component dictionaries.
         */
        dict_enum = dict_first(op);
        for (pc = phtc; ; ) {
            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;

            /* Verify that we have a valid component */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component and verify that we will use it. */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;

            if (pc->type == ht_type_spot) {
                code = dict_spot_results(i_ctx_p, &rvalue[1], &pc->params.spot);
                if (code < 0)
                    break;
            }
            pc++;
        }
    }
    if (code >= 0) {
        /*
         * Schedule the sampling of any Type 1 screens,
         * and any (Type 1 or Type 3) TransferFunctions.
         * Save the stack depths in case we have to back out.
         */
        uint odepth = ref_stack_count(&o_stack);
        ref odict, odict5;

        odict = op[-1];
        odict5 = *op;
        pop(2);
        op = osp;
        esp += 5;
        make_mark_estack(esp - 4, es_other, sethalftone_cleanup);
        esp[-3] = odict;
        make_istruct(esp - 2, 0, pht);
        make_istruct(esp - 1, 0, pdht);
        make_op_estack(esp, sethalftone_finish);
        for (j = 0; j < count; j++) {
            gx_ht_order *porder = NULL;

            if (pdht->components == 0)
                porder = &pdht->order;
            else {
                /* Find the component in pdht that matches component j in
                   the pht; gs_sethalftone_prepare() may permute these. */
                int k;
                int comp_number = phtc[j].comp_number;
                for (k = 0; k < count; k++) {
                    if (pdht->components[k].comp_number == comp_number) {
                        porder = &pdht->components[k].corder;
                        break;
                    }
                }
            }
            switch (phtc[j].type) {
            case ht_type_spot:
                code = zscreen_enum_init(i_ctx_p, porder,
                                         &phtc[j].params.spot.screen,
                                         &sprocs[j], 0, 0, space_index);
                if (code < 0)
                    break;
                /* falls through */
            case ht_type_threshold:
                if (!r_has_type(tprocs + j, t__invalid)) {
                    /* Schedule TransferFunction sampling. */
                    /****** check_xstack IS WRONG ******/
                    check_ostack(zcolor_remap_one_ostack);
                    check_estack(zcolor_remap_one_estack);
                    code = zcolor_remap_one(i_ctx_p, tprocs + j,
                                            porder->transfer, igs,
                                            zcolor_remap_one_finish);
                    op = osp;
                }
                break;
            default:	/* not possible here, but to keep */
                                /* the compilers happy.... */
                ;
            }
            if (code < 0) {	/* Restore the stack. */
                ref_stack_pop_to(&o_stack, odepth);
                ref_stack_pop_to(&e_stack, edepth);
                op = osp;
                op[-1] = odict;
                *op = odict5;
                break;
            }
            npop = 0;
        }
    }
    if (code < 0) {
        gs_free_object(mem, pdht, "".sethalftone5"");
        gs_free_object(mem, phtc, "".sethalftone5"");
        gs_free_object(mem, pht, "".sethalftone5"");
        return code;
    }
    pop(npop);
    return (ref_stack_count(&e_stack) > edepth ? o_push_estack : 0);
}
",C,"    int dict_enum;
    int space_index;

    if (ref_stack_count(&o_stack) < 2)
        return_error(gs_error_stackunderflow);
    check_type(*op, t_dictionary);
    check_type(*(op - 1), t_dictionary);

    dict_enum = dict_first(op);
    space_index = r_space_index(op - 1);
","    int dict_enum = dict_first(op);
    int space_index = r_space_index(op - 1);
",a5360401495654e89301b2516703c1d2877fc5ba,"@@ -82,14 +82,22 @@ zsethalftone5(i_ctx_t *i_ctx_p)
     gs_memory_t *mem;
     uint edepth = ref_stack_count(&e_stack);
     int npop = 2;
-    int dict_enum = dict_first(op);
+    int dict_enum;
     ref rvalue[2];
     int cname, colorant_number;
     byte * pname;
     uint name_size;
     int halftonetype, type = 0;
     gs_gstate *pgs = igs;
-    int space_index = r_space_index(op - 1);
+    int space_index;
+
+    if (ref_stack_count(&o_stack) < 2)
+        return_error(gs_error_stackunderflow);
+    check_type(*op, t_dictionary);
+    check_type(*(op - 1), t_dictionary);
+
+    dict_enum = dict_first(op);
+    space_index = r_space_index(op - 1);
 
     mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];",ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/zht2.c;h=dfa27a40ff46f497c929e12053753023212fcb26;hb=f5c7555c303,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/zht2.c;h=fb4a2649d4de8879f7033256c66634b691fee691,1,"zsethalftone5(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    uint count;
    gs_halftone_component *phtc = 0;
    gs_halftone_component *pc;
    int code = 0;
    int j;
    bool have_default;
    gs_halftone *pht = 0;
    gx_device_halftone *pdht = 0;
    ref sprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
    ref tprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
     gs_memory_t *mem;
     uint edepth = ref_stack_count(&e_stack);
     int npop = 2;
//flaw_line_below:
    int dict_enum = dict_first(op);
//fix_flaw_line_below:
//    int dict_enum;
     ref rvalue[2];
     int cname, colorant_number;
     byte * pname;
     uint name_size;
     int halftonetype, type = 0;
     gs_gstate *pgs = igs;
//flaw_line_below:
    int space_index = r_space_index(op - 1);
//fix_flaw_line_below:
//    int space_index;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (ref_stack_count(&o_stack) < 2)
//fix_flaw_line_below:
//        return_error(gs_error_stackunderflow);
//fix_flaw_line_below:
//    check_type(*op, t_dictionary);
//fix_flaw_line_below:
//    check_type(*(op - 1), t_dictionary);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    dict_enum = dict_first(op);
//fix_flaw_line_below:
//    space_index = r_space_index(op - 1);
 
     mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];
     * the device color space, so we need to mark them
     * with a different internal halftone type.
     */
    code = dict_int_param(op - 1, ""HalftoneType"", 1, 100, 0, &type);
    if (code < 0)
          return code;
    halftonetype = (type == 2 || type == 4)
                        ? ht_type_multiple_colorscreen
                        : ht_type_multiple;

    /* Count how many components that we will actually use. */

    have_default = false;
    for (count = 0; ;) {

        /* Move to next element in the dictionary */
        if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
            break;
        /*
         * Verify that we have a valid component.  We may have a
         * /HalfToneType entry.
         */
        if (!r_has_type(&rvalue[0], t_name))
            continue;
        if (!r_has_type(&rvalue[1], t_dictionary))
            continue;

        /* Get the name of the component  verify that we will use it. */
        cname = name_index(mem, &rvalue[0]);
        code = gs_get_colorname_string(mem, cname, &pname, &name_size);
        if (code < 0)
            break;
        colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
        if (colorant_number < 0)
            continue;
        else if (colorant_number == GX_DEVICE_COLOR_MAX_COMPONENTS) {
            /* If here then we have the ""Default"" component */
            if (have_default)
                return_error(gs_error_rangecheck);
            have_default = true;
        }

        count++;
        /*
         * Check to see if we have already reached the legal number of
         * components.
         */
        if (count > GS_CLIENT_COLOR_MAX_COMPONENTS + 1) {
            code = gs_note_error(gs_error_rangecheck);
            break;
        }
    }
    if (count == 0 || (halftonetype == ht_type_multiple && ! have_default))
        code = gs_note_error(gs_error_rangecheck);

    if (code >= 0) {
        check_estack(5);		/* for sampling Type 1 screens */
        refset_null(sprocs, count);
        refset_null(tprocs, count);
        rc_alloc_struct_0(pht, gs_halftone, &st_halftone,
                          imemory, pht = 0, "".sethalftone5"");
        phtc = gs_alloc_struct_array(mem, count, gs_halftone_component,
                                     &st_ht_component_element,
                                     "".sethalftone5"");
        rc_alloc_struct_0(pdht, gx_device_halftone, &st_device_halftone,
                          imemory, pdht = 0, "".sethalftone5"");
        if (pht == 0 || phtc == 0 || pdht == 0) {
            j = 0; /* Quiet the compiler:
                      gs_note_error isn't necessarily identity,
                      so j could be left ununitialized. */
            code = gs_note_error(gs_error_VMerror);
        }
    }
    if (code >= 0) {
        dict_enum = dict_first(op);
        for (j = 0, pc = phtc; ;) {
            int type;

            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;
            /*
             * Verify that we have a valid component.  We may have a
             * /HalfToneType entry.
             */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;		/* Do not use this component */
            pc->cname = cname;
            pc->comp_number = colorant_number;

            /* Now process the component dictionary */
            check_dict_read(rvalue[1]);
            if (dict_int_param(&rvalue[1], ""HalftoneType"", 1, 7, 0, &type) < 0) {
                code = gs_note_error(gs_error_typecheck);
                break;
            }
            switch (type) {
                default:
                    code = gs_note_error(gs_error_rangecheck);
                    break;
                case 1:
                    code = dict_spot_params(&rvalue[1], &pc->params.spot,
                                                sprocs + j, tprocs + j, mem);
                    pc->params.spot.screen.spot_function = spot1_dummy;
                    pc->type = ht_type_spot;
                    break;
                case 3:
                    code = dict_threshold_params(&rvalue[1], &pc->params.threshold,
                                                        tprocs + j);
                    pc->type = ht_type_threshold;
                    break;
                case 7:
                    code = dict_threshold2_params(&rvalue[1], &pc->params.threshold2,
                                                        tprocs + j, imemory);
                    pc->type = ht_type_threshold2;
                    break;
            }
            if (code < 0)
                break;
            pc++;
            j++;
        }
    }
    if (code >= 0) {
        pht->type = halftonetype;
        pht->params.multiple.components = phtc;
        pht->params.multiple.num_comp = j;
        pht->params.multiple.get_colorname_string = gs_get_colorname_string;
        code = gs_sethalftone_prepare(igs, pht, pdht);
    }
    if (code >= 0) {
        /*
         * Put the actual frequency and angle in the spot function component dictionaries.
         */
        dict_enum = dict_first(op);
        for (pc = phtc; ; ) {
            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;

            /* Verify that we have a valid component */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component and verify that we will use it. */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;

            if (pc->type == ht_type_spot) {
                code = dict_spot_results(i_ctx_p, &rvalue[1], &pc->params.spot);
                if (code < 0)
                    break;
            }
            pc++;
        }
    }
    if (code >= 0) {
        /*
         * Schedule the sampling of any Type 1 screens,
         * and any (Type 1 or Type 3) TransferFunctions.
         * Save the stack depths in case we have to back out.
         */
        uint odepth = ref_stack_count(&o_stack);
        ref odict, odict5;

        odict = op[-1];
        odict5 = *op;
        pop(2);
        op = osp;
        esp += 5;
        make_mark_estack(esp - 4, es_other, sethalftone_cleanup);
        esp[-3] = odict;
        make_istruct(esp - 2, 0, pht);
        make_istruct(esp - 1, 0, pdht);
        make_op_estack(esp, sethalftone_finish);
        for (j = 0; j < count; j++) {
            gx_ht_order *porder = NULL;

            if (pdht->components == 0)
                porder = &pdht->order;
            else {
                /* Find the component in pdht that matches component j in
                   the pht; gs_sethalftone_prepare() may permute these. */
                int k;
                int comp_number = phtc[j].comp_number;
                for (k = 0; k < count; k++) {
                    if (pdht->components[k].comp_number == comp_number) {
                        porder = &pdht->components[k].corder;
                        break;
                    }
                }
            }
            switch (phtc[j].type) {
            case ht_type_spot:
                code = zscreen_enum_init(i_ctx_p, porder,
                                         &phtc[j].params.spot.screen,
                                         &sprocs[j], 0, 0, space_index);
                if (code < 0)
                    break;
                /* falls through */
            case ht_type_threshold:
                if (!r_has_type(tprocs + j, t__invalid)) {
                    /* Schedule TransferFunction sampling. */
                    /****** check_xstack IS WRONG ******/
                    check_ostack(zcolor_remap_one_ostack);
                    check_estack(zcolor_remap_one_estack);
                    code = zcolor_remap_one(i_ctx_p, tprocs + j,
                                            porder->transfer, igs,
                                            zcolor_remap_one_finish);
                    op = osp;
                }
                break;
            default:	/* not possible here, but to keep */
                                /* the compilers happy.... */
                ;
            }
            if (code < 0) {	/* Restore the stack. */
                ref_stack_pop_to(&o_stack, odepth);
                ref_stack_pop_to(&e_stack, edepth);
                op = osp;
                op[-1] = odict;
                *op = odict5;
                break;
            }
            npop = 0;
        }
    }
    if (code < 0) {
        gs_free_object(mem, pdht, "".sethalftone5"");
        gs_free_object(mem, phtc, "".sethalftone5"");
        gs_free_object(mem, pht, "".sethalftone5"");
        return code;
    }
    pop(npop);
    return (ref_stack_count(&e_stack) > edepth ? o_push_estack : 0);
}
"
4445,182181,,Local,Not required,Partial,CVE-2018-18386,https://www.cvedetails.com/cve/CVE-2018-18386/,CWE-704,Low,,,,2018-10-17,2.1,drivers/tty/n_tty.c in the Linux kernel before 4.14.11 allows local attackers (who are able to access pseudo terminals) to hang/block further usage of any pseudo terminal devices due to an EXTPROC versus ICANON confusion in TIOCINQ.,2019-04-23,,1,https://github.com/torvalds/linux/commit/966031f340185eddd05affcf72b740549f056348,966031f340185eddd05affcf72b740549f056348,"n_tty: fix EXTPROC vs ICANON interaction with TIOCINQ (aka FIONREAD)

We added support for EXTPROC back in 2010 in commit 26df6d13406d (""tty:
Add EXTPROC support for LINEMODE"") and the intent was to allow it to
override some (all?) ICANON behavior.  Quoting from that original commit
message:

         There is a new bit in the termios local flag word, EXTPROC.
         When this bit is set, several aspects of the terminal driver
         are disabled.  Input line editing, character echo, and mapping
         of signals are all disabled.  This allows the telnetd to turn
         off these functions when in linemode, but still keep track of
         what state the user wants the terminal to be in.

but the problem turns out that ""several aspects of the terminal driver
are disabled"" is a bit ambiguous, and you can really confuse the n_tty
layer by setting EXTPROC and then causing some of the ICANON invariants
to no longer be maintained.

This fixes at least one such case (TIOCINQ) becoming unhappy because of
the confusion over whether ICANON really means ICANON when EXTPROC is set.

This basically makes TIOCINQ match the case of read: if EXTPROC is set,
we ignore ICANON.  Also, make sure to reset the ICANON state ie EXTPROC
changes, not just if ICANON changes.

Fixes: 26df6d13406d (""tty: Add EXTPROC support for LINEMODE"")
Reported-by: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
Reported-by: syzkaller <syzkaller@googlegroups.com>
Cc: Jiri Slaby <jslaby@suse.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",1,drivers/tty/n_tty.c,"{""sha"": ""539b49adb6afd41190eee97f6eaf1950c8a1ac3f"", ""filename"": ""drivers/tty/n_tty.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/966031f340185eddd05affcf72b740549f056348/drivers/tty/n_tty.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/966031f340185eddd05affcf72b740549f056348/drivers/tty/n_tty.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/tty/n_tty.c?ref=966031f340185eddd05affcf72b740549f056348"", ""patch"": ""@@ -1762,7 +1762,7 @@ static void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)\n {\n \tstruct n_tty_data *ldata = tty->disc_data;\n \n-\tif (!old || (old->c_lflag ^ tty->termios.c_lflag) & ICANON) {\n+\tif (!old || (old->c_lflag ^ tty->termios.c_lflag) & (ICANON | EXTPROC)) {\n \t\tbitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);\n \t\tldata->line_start = ldata->read_tail;\n \t\tif (!L_ICANON(tty) || !read_cnt(ldata)) {\n@@ -2425,7 +2425,7 @@ static int n_tty_ioctl(struct tty_struct *tty, struct file *file,\n \t\treturn put_user(tty_chars_in_buffer(tty), (int __user *) arg);\n \tcase TIOCINQ:\n \t\tdown_write(&tty->termios_rwsem);\n-\t\tif (L_ICANON(tty))\n+\t\tif (L_ICANON(tty) && !L_EXTPROC(tty))\n \t\t\tretval = inq_canon(ldata);\n \t\telse\n \t\t\tretval = read_cnt(ldata);""}","static int n_tty_ioctl(struct tty_struct *tty, struct file *file,
		       unsigned int cmd, unsigned long arg)
{
	struct n_tty_data *ldata = tty->disc_data;
	int retval;

	switch (cmd) {
	case TIOCOUTQ:
 		return put_user(tty_chars_in_buffer(tty), (int __user *) arg);
 	case TIOCINQ:
 		down_write(&tty->termios_rwsem);
		if (L_ICANON(tty) && !L_EXTPROC(tty))
 			retval = inq_canon(ldata);
 		else
 			retval = read_cnt(ldata);
		up_write(&tty->termios_rwsem);
		return put_user(retval, (unsigned int __user *) arg);
	default:
		return n_tty_ioctl_helper(tty, file, cmd, arg);
	}
}
","static int n_tty_ioctl(struct tty_struct *tty, struct file *file,
		       unsigned int cmd, unsigned long arg)
{
	struct n_tty_data *ldata = tty->disc_data;
	int retval;

	switch (cmd) {
	case TIOCOUTQ:
 		return put_user(tty_chars_in_buffer(tty), (int __user *) arg);
 	case TIOCINQ:
 		down_write(&tty->termios_rwsem);
		if (L_ICANON(tty))
 			retval = inq_canon(ldata);
 		else
 			retval = read_cnt(ldata);
		up_write(&tty->termios_rwsem);
		return put_user(retval, (unsigned int __user *) arg);
	default:
		return n_tty_ioctl_helper(tty, file, cmd, arg);
	}
}
",C,"		if (L_ICANON(tty) && !L_EXTPROC(tty))
","		if (L_ICANON(tty))
",,"@@ -1762,7 +1762,7 @@ static void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)
 {
 	struct n_tty_data *ldata = tty->disc_data;
 
-	if (!old || (old->c_lflag ^ tty->termios.c_lflag) & ICANON) {
+	if (!old || (old->c_lflag ^ tty->termios.c_lflag) & (ICANON | EXTPROC)) {
 		bitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);
 		ldata->line_start = ldata->read_tail;
 		if (!L_ICANON(tty) || !read_cnt(ldata)) {
@@ -2425,7 +2425,7 @@ static int n_tty_ioctl(struct tty_struct *tty, struct file *file,
 		return put_user(tty_chars_in_buffer(tty), (int __user *) arg);
 	case TIOCINQ:
 		down_write(&tty->termios_rwsem);
-		if (L_ICANON(tty))
+		if (L_ICANON(tty) && !L_EXTPROC(tty))
 			retval = inq_canon(ldata);
 		else
 			retval = read_cnt(ldata);",linux,966031f340185eddd05affcf72b740549f056348,50c4c4e268a2d7a3e58ebb698ac74da0de40ae36,1,"static int n_tty_ioctl(struct tty_struct *tty, struct file *file,
		       unsigned int cmd, unsigned long arg)
{
	struct n_tty_data *ldata = tty->disc_data;
	int retval;

	switch (cmd) {
	case TIOCOUTQ:
 		return put_user(tty_chars_in_buffer(tty), (int __user *) arg);
 	case TIOCINQ:
 		down_write(&tty->termios_rwsem);
//flaw_line_below:
		if (L_ICANON(tty))
//fix_flaw_line_below:
//		if (L_ICANON(tty) && !L_EXTPROC(tty))
 			retval = inq_canon(ldata);
 		else
 			retval = read_cnt(ldata);
		up_write(&tty->termios_rwsem);
		return put_user(retval, (unsigned int __user *) arg);
	default:
		return n_tty_ioctl_helper(tty, file, cmd, arg);
	}
}
"
4446,182182,,Local,Not required,Partial,CVE-2018-18386,https://www.cvedetails.com/cve/CVE-2018-18386/,CWE-704,Low,,,,2018-10-17,2.1,drivers/tty/n_tty.c in the Linux kernel before 4.14.11 allows local attackers (who are able to access pseudo terminals) to hang/block further usage of any pseudo terminal devices due to an EXTPROC versus ICANON confusion in TIOCINQ.,2019-04-23,,1,https://github.com/torvalds/linux/commit/966031f340185eddd05affcf72b740549f056348,966031f340185eddd05affcf72b740549f056348,"n_tty: fix EXTPROC vs ICANON interaction with TIOCINQ (aka FIONREAD)

We added support for EXTPROC back in 2010 in commit 26df6d13406d (""tty:
Add EXTPROC support for LINEMODE"") and the intent was to allow it to
override some (all?) ICANON behavior.  Quoting from that original commit
message:

         There is a new bit in the termios local flag word, EXTPROC.
         When this bit is set, several aspects of the terminal driver
         are disabled.  Input line editing, character echo, and mapping
         of signals are all disabled.  This allows the telnetd to turn
         off these functions when in linemode, but still keep track of
         what state the user wants the terminal to be in.

but the problem turns out that ""several aspects of the terminal driver
are disabled"" is a bit ambiguous, and you can really confuse the n_tty
layer by setting EXTPROC and then causing some of the ICANON invariants
to no longer be maintained.

This fixes at least one such case (TIOCINQ) becoming unhappy because of
the confusion over whether ICANON really means ICANON when EXTPROC is set.

This basically makes TIOCINQ match the case of read: if EXTPROC is set,
we ignore ICANON.  Also, make sure to reset the ICANON state ie EXTPROC
changes, not just if ICANON changes.

Fixes: 26df6d13406d (""tty: Add EXTPROC support for LINEMODE"")
Reported-by: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
Reported-by: syzkaller <syzkaller@googlegroups.com>
Cc: Jiri Slaby <jslaby@suse.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",1,drivers/tty/n_tty.c,"{""sha"": ""539b49adb6afd41190eee97f6eaf1950c8a1ac3f"", ""filename"": ""drivers/tty/n_tty.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/966031f340185eddd05affcf72b740549f056348/drivers/tty/n_tty.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/966031f340185eddd05affcf72b740549f056348/drivers/tty/n_tty.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/tty/n_tty.c?ref=966031f340185eddd05affcf72b740549f056348"", ""patch"": ""@@ -1762,7 +1762,7 @@ static void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)\n {\n \tstruct n_tty_data *ldata = tty->disc_data;\n \n-\tif (!old || (old->c_lflag ^ tty->termios.c_lflag) & ICANON) {\n+\tif (!old || (old->c_lflag ^ tty->termios.c_lflag) & (ICANON | EXTPROC)) {\n \t\tbitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);\n \t\tldata->line_start = ldata->read_tail;\n \t\tif (!L_ICANON(tty) || !read_cnt(ldata)) {\n@@ -2425,7 +2425,7 @@ static int n_tty_ioctl(struct tty_struct *tty, struct file *file,\n \t\treturn put_user(tty_chars_in_buffer(tty), (int __user *) arg);\n \tcase TIOCINQ:\n \t\tdown_write(&tty->termios_rwsem);\n-\t\tif (L_ICANON(tty))\n+\t\tif (L_ICANON(tty) && !L_EXTPROC(tty))\n \t\t\tretval = inq_canon(ldata);\n \t\telse\n \t\t\tretval = read_cnt(ldata);""}","static void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)
 {
 	struct n_tty_data *ldata = tty->disc_data;
 
	if (!old || (old->c_lflag ^ tty->termios.c_lflag) & (ICANON | EXTPROC)) {
 		bitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);
 		ldata->line_start = ldata->read_tail;
 		if (!L_ICANON(tty) || !read_cnt(ldata)) {
			ldata->canon_head = ldata->read_tail;
			ldata->push = 0;
		} else {
			set_bit((ldata->read_head - 1) & (N_TTY_BUF_SIZE - 1),
				ldata->read_flags);
			ldata->canon_head = ldata->read_head;
			ldata->push = 1;
		}
		ldata->commit_head = ldata->read_head;
		ldata->erasing = 0;
		ldata->lnext = 0;
	}

	ldata->icanon = (L_ICANON(tty) != 0);

	if (I_ISTRIP(tty) || I_IUCLC(tty) || I_IGNCR(tty) ||
	    I_ICRNL(tty) || I_INLCR(tty) || L_ICANON(tty) ||
	    I_IXON(tty) || L_ISIG(tty) || L_ECHO(tty) ||
	    I_PARMRK(tty)) {
		bitmap_zero(ldata->char_map, 256);

		if (I_IGNCR(tty) || I_ICRNL(tty))
			set_bit('\r', ldata->char_map);
		if (I_INLCR(tty))
			set_bit('\n', ldata->char_map);

		if (L_ICANON(tty)) {
			set_bit(ERASE_CHAR(tty), ldata->char_map);
			set_bit(KILL_CHAR(tty), ldata->char_map);
			set_bit(EOF_CHAR(tty), ldata->char_map);
			set_bit('\n', ldata->char_map);
			set_bit(EOL_CHAR(tty), ldata->char_map);
			if (L_IEXTEN(tty)) {
				set_bit(WERASE_CHAR(tty), ldata->char_map);
				set_bit(LNEXT_CHAR(tty), ldata->char_map);
				set_bit(EOL2_CHAR(tty), ldata->char_map);
				if (L_ECHO(tty))
					set_bit(REPRINT_CHAR(tty),
						ldata->char_map);
			}
		}
		if (I_IXON(tty)) {
			set_bit(START_CHAR(tty), ldata->char_map);
			set_bit(STOP_CHAR(tty), ldata->char_map);
		}
		if (L_ISIG(tty)) {
			set_bit(INTR_CHAR(tty), ldata->char_map);
			set_bit(QUIT_CHAR(tty), ldata->char_map);
			set_bit(SUSP_CHAR(tty), ldata->char_map);
		}
		clear_bit(__DISABLED_CHAR, ldata->char_map);
		ldata->raw = 0;
		ldata->real_raw = 0;
	} else {
		ldata->raw = 1;
		if ((I_IGNBRK(tty) || (!I_BRKINT(tty) && !I_PARMRK(tty))) &&
		    (I_IGNPAR(tty) || !I_INPCK(tty)) &&
		    (tty->driver->flags & TTY_DRIVER_REAL_RAW))
			ldata->real_raw = 1;
		else
			ldata->real_raw = 0;
	}
	/*
	 * Fix tty hang when I_IXON(tty) is cleared, but the tty
	 * been stopped by STOP_CHAR(tty) before it.
	 */
	if (!I_IXON(tty) && old && (old->c_iflag & IXON) && !tty->flow_stopped) {
		start_tty(tty);
		process_echoes(tty);
	}

	/* The termios change make the tty ready for I/O */
	wake_up_interruptible(&tty->write_wait);
	wake_up_interruptible(&tty->read_wait);
}
","static void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)
 {
 	struct n_tty_data *ldata = tty->disc_data;
 
	if (!old || (old->c_lflag ^ tty->termios.c_lflag) & ICANON) {
 		bitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);
 		ldata->line_start = ldata->read_tail;
 		if (!L_ICANON(tty) || !read_cnt(ldata)) {
			ldata->canon_head = ldata->read_tail;
			ldata->push = 0;
		} else {
			set_bit((ldata->read_head - 1) & (N_TTY_BUF_SIZE - 1),
				ldata->read_flags);
			ldata->canon_head = ldata->read_head;
			ldata->push = 1;
		}
		ldata->commit_head = ldata->read_head;
		ldata->erasing = 0;
		ldata->lnext = 0;
	}

	ldata->icanon = (L_ICANON(tty) != 0);

	if (I_ISTRIP(tty) || I_IUCLC(tty) || I_IGNCR(tty) ||
	    I_ICRNL(tty) || I_INLCR(tty) || L_ICANON(tty) ||
	    I_IXON(tty) || L_ISIG(tty) || L_ECHO(tty) ||
	    I_PARMRK(tty)) {
		bitmap_zero(ldata->char_map, 256);

		if (I_IGNCR(tty) || I_ICRNL(tty))
			set_bit('\r', ldata->char_map);
		if (I_INLCR(tty))
			set_bit('\n', ldata->char_map);

		if (L_ICANON(tty)) {
			set_bit(ERASE_CHAR(tty), ldata->char_map);
			set_bit(KILL_CHAR(tty), ldata->char_map);
			set_bit(EOF_CHAR(tty), ldata->char_map);
			set_bit('\n', ldata->char_map);
			set_bit(EOL_CHAR(tty), ldata->char_map);
			if (L_IEXTEN(tty)) {
				set_bit(WERASE_CHAR(tty), ldata->char_map);
				set_bit(LNEXT_CHAR(tty), ldata->char_map);
				set_bit(EOL2_CHAR(tty), ldata->char_map);
				if (L_ECHO(tty))
					set_bit(REPRINT_CHAR(tty),
						ldata->char_map);
			}
		}
		if (I_IXON(tty)) {
			set_bit(START_CHAR(tty), ldata->char_map);
			set_bit(STOP_CHAR(tty), ldata->char_map);
		}
		if (L_ISIG(tty)) {
			set_bit(INTR_CHAR(tty), ldata->char_map);
			set_bit(QUIT_CHAR(tty), ldata->char_map);
			set_bit(SUSP_CHAR(tty), ldata->char_map);
		}
		clear_bit(__DISABLED_CHAR, ldata->char_map);
		ldata->raw = 0;
		ldata->real_raw = 0;
	} else {
		ldata->raw = 1;
		if ((I_IGNBRK(tty) || (!I_BRKINT(tty) && !I_PARMRK(tty))) &&
		    (I_IGNPAR(tty) || !I_INPCK(tty)) &&
		    (tty->driver->flags & TTY_DRIVER_REAL_RAW))
			ldata->real_raw = 1;
		else
			ldata->real_raw = 0;
	}
	/*
	 * Fix tty hang when I_IXON(tty) is cleared, but the tty
	 * been stopped by STOP_CHAR(tty) before it.
	 */
	if (!I_IXON(tty) && old && (old->c_iflag & IXON) && !tty->flow_stopped) {
		start_tty(tty);
		process_echoes(tty);
	}

	/* The termios change make the tty ready for I/O */
	wake_up_interruptible(&tty->write_wait);
	wake_up_interruptible(&tty->read_wait);
}
",C,"	if (!old || (old->c_lflag ^ tty->termios.c_lflag) & (ICANON | EXTPROC)) {
","	if (!old || (old->c_lflag ^ tty->termios.c_lflag) & ICANON) {
",,"@@ -1762,7 +1762,7 @@ static void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)
 {
 	struct n_tty_data *ldata = tty->disc_data;
 
-	if (!old || (old->c_lflag ^ tty->termios.c_lflag) & ICANON) {
+	if (!old || (old->c_lflag ^ tty->termios.c_lflag) & (ICANON | EXTPROC)) {
 		bitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);
 		ldata->line_start = ldata->read_tail;
 		if (!L_ICANON(tty) || !read_cnt(ldata)) {
@@ -2425,7 +2425,7 @@ static int n_tty_ioctl(struct tty_struct *tty, struct file *file,
 		return put_user(tty_chars_in_buffer(tty), (int __user *) arg);
 	case TIOCINQ:
 		down_write(&tty->termios_rwsem);
-		if (L_ICANON(tty))
+		if (L_ICANON(tty) && !L_EXTPROC(tty))
 			retval = inq_canon(ldata);
 		else
 			retval = read_cnt(ldata);",linux,966031f340185eddd05affcf72b740549f056348,50c4c4e268a2d7a3e58ebb698ac74da0de40ae36,1,"static void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)
 {
 	struct n_tty_data *ldata = tty->disc_data;
 
//flaw_line_below:
	if (!old || (old->c_lflag ^ tty->termios.c_lflag) & ICANON) {
//fix_flaw_line_below:
//	if (!old || (old->c_lflag ^ tty->termios.c_lflag) & (ICANON | EXTPROC)) {
 		bitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);
 		ldata->line_start = ldata->read_tail;
 		if (!L_ICANON(tty) || !read_cnt(ldata)) {
			ldata->canon_head = ldata->read_tail;
			ldata->push = 0;
		} else {
			set_bit((ldata->read_head - 1) & (N_TTY_BUF_SIZE - 1),
				ldata->read_flags);
			ldata->canon_head = ldata->read_head;
			ldata->push = 1;
		}
		ldata->commit_head = ldata->read_head;
		ldata->erasing = 0;
		ldata->lnext = 0;
	}

	ldata->icanon = (L_ICANON(tty) != 0);

	if (I_ISTRIP(tty) || I_IUCLC(tty) || I_IGNCR(tty) ||
	    I_ICRNL(tty) || I_INLCR(tty) || L_ICANON(tty) ||
	    I_IXON(tty) || L_ISIG(tty) || L_ECHO(tty) ||
	    I_PARMRK(tty)) {
		bitmap_zero(ldata->char_map, 256);

		if (I_IGNCR(tty) || I_ICRNL(tty))
			set_bit('\r', ldata->char_map);
		if (I_INLCR(tty))
			set_bit('\n', ldata->char_map);

		if (L_ICANON(tty)) {
			set_bit(ERASE_CHAR(tty), ldata->char_map);
			set_bit(KILL_CHAR(tty), ldata->char_map);
			set_bit(EOF_CHAR(tty), ldata->char_map);
			set_bit('\n', ldata->char_map);
			set_bit(EOL_CHAR(tty), ldata->char_map);
			if (L_IEXTEN(tty)) {
				set_bit(WERASE_CHAR(tty), ldata->char_map);
				set_bit(LNEXT_CHAR(tty), ldata->char_map);
				set_bit(EOL2_CHAR(tty), ldata->char_map);
				if (L_ECHO(tty))
					set_bit(REPRINT_CHAR(tty),
						ldata->char_map);
			}
		}
		if (I_IXON(tty)) {
			set_bit(START_CHAR(tty), ldata->char_map);
			set_bit(STOP_CHAR(tty), ldata->char_map);
		}
		if (L_ISIG(tty)) {
			set_bit(INTR_CHAR(tty), ldata->char_map);
			set_bit(QUIT_CHAR(tty), ldata->char_map);
			set_bit(SUSP_CHAR(tty), ldata->char_map);
		}
		clear_bit(__DISABLED_CHAR, ldata->char_map);
		ldata->raw = 0;
		ldata->real_raw = 0;
	} else {
		ldata->raw = 1;
		if ((I_IGNBRK(tty) || (!I_BRKINT(tty) && !I_PARMRK(tty))) &&
		    (I_IGNPAR(tty) || !I_INPCK(tty)) &&
		    (tty->driver->flags & TTY_DRIVER_REAL_RAW))
			ldata->real_raw = 1;
		else
			ldata->real_raw = 0;
	}
	/*
	 * Fix tty hang when I_IXON(tty) is cleared, but the tty
	 * been stopped by STOP_CHAR(tty) before it.
	 */
	if (!I_IXON(tty) && old && (old->c_iflag & IXON) && !tty->flow_stopped) {
		start_tty(tty);
		process_echoes(tty);
	}

	/* The termios change make the tty ready for I/O */
	wake_up_interruptible(&tty->write_wait);
	wake_up_interruptible(&tty->read_wait);
}
"
4629,182365,,Remote,Not required,Partial,CVE-2018-12453,https://www.cvedetails.com/cve/CVE-2018-12453/,CWE-704,Low,,,,2018-06-16,5.0,Type confusion in the xgroupCommand function in t_stream.c in redis-server in Redis before 5.0 allows remote attackers to cause denial-of-service via an XGROUP command in which the key is not a stream.,2018-08-14,,1,https://github.com/antirez/redis/commit/c04082cf138f1f51cedf05ee9ad36fb6763cafc6,c04082cf138f1f51cedf05ee9ad36fb6763cafc6,Abort in XGROUP if the key is not a stream,1,src/t_stream.c,"{""sha"": ""c48928018c04d68e68b0191e202144978fe327a4"", ""filename"": ""src/t_stream.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/antirez/redis/blob/c04082cf138f1f51cedf05ee9ad36fb6763cafc6/src/t_stream.c"", ""raw_url"": ""https://github.com/antirez/redis/raw/c04082cf138f1f51cedf05ee9ad36fb6763cafc6/src/t_stream.c"", ""contents_url"": ""https://api.github.com/repos/antirez/redis/contents/src/t_stream.c?ref=c04082cf138f1f51cedf05ee9ad36fb6763cafc6"", ""patch"": ""@@ -1576,7 +1576,7 @@ NULL\n     /* Lookup the key now, this is common for all the subcommands but HELP. */\n     if (c->argc >= 4) {\n         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);\n-        if (o == NULL) return;\n+        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;\n         s = o->ptr;\n         grpname = c->argv[3]->ptr;\n ""}","void xgroupCommand(client *c) {
    const char *help[] = {
""CREATE      <key> <groupname> <id or $>  -- Create a new consumer group."",
""SETID       <key> <groupname> <id or $>  -- Set the current group ID."",
""DELGROUP    <key> <groupname>            -- Remove the specified group."",
""DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer."",
""HELP                                     -- Prints this help."",
NULL
    };
    stream *s = NULL;
    sds grpname = NULL;
    streamCG *cg = NULL;
    char *opt = c->argv[1]->ptr; /* Subcommand name. */

     /* Lookup the key now, this is common for all the subcommands but HELP. */
     if (c->argc >= 4) {
         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);
        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
         s = o->ptr;
         grpname = c->argv[3]->ptr;
 
        /* Certain subcommands require the group to exist. */
        if ((cg = streamLookupCG(s,grpname)) == NULL &&
            (!strcasecmp(opt,""SETID"") ||
             !strcasecmp(opt,""DELCONSUMER"")))
        {
            addReplyErrorFormat(c, ""-NOGROUP No such consumer group '%s' ""
                                   ""for key name '%s'"",
                                   (char*)grpname, (char*)c->argv[2]->ptr);
            return;
        }
    }

    /* Dispatch the different subcommands. */
    if (!strcasecmp(opt,""CREATE"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);
        if (cg) {
            addReply(c,shared.ok);
            server.dirty++;
        } else {
            addReplySds(c,
                sdsnew(""-BUSYGROUP Consumer Group name already exists\r\n""));
        }
    } else if (!strcasecmp(opt,""SETID"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        cg->last_id = id;
        addReply(c,shared.ok);
    } else if (!strcasecmp(opt,""DESTROY"") && c->argc == 4) {
        if (cg) {
            raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);
            streamFreeCG(cg);
            addReply(c,shared.cone);
        } else {
            addReply(c,shared.czero);
        }
    } else if (!strcasecmp(opt,""DELCONSUMER"") && c->argc == 5) {
        /* Delete the consumer and returns the number of pending messages
         * that were yet associated with such a consumer. */
        long long pending = streamDelConsumer(cg,c->argv[4]->ptr);
        addReplyLongLong(c,pending);
        server.dirty++;
    } else if (!strcasecmp(opt,""HELP"")) {
        addReplyHelp(c, help);
    } else {
        addReply(c,shared.syntaxerr);
    }
}
","void xgroupCommand(client *c) {
    const char *help[] = {
""CREATE      <key> <groupname> <id or $>  -- Create a new consumer group."",
""SETID       <key> <groupname> <id or $>  -- Set the current group ID."",
""DELGROUP    <key> <groupname>            -- Remove the specified group."",
""DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer."",
""HELP                                     -- Prints this help."",
NULL
    };
    stream *s = NULL;
    sds grpname = NULL;
    streamCG *cg = NULL;
    char *opt = c->argv[1]->ptr; /* Subcommand name. */

     /* Lookup the key now, this is common for all the subcommands but HELP. */
     if (c->argc >= 4) {
         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);
        if (o == NULL) return;
         s = o->ptr;
         grpname = c->argv[3]->ptr;
 
        /* Certain subcommands require the group to exist. */
        if ((cg = streamLookupCG(s,grpname)) == NULL &&
            (!strcasecmp(opt,""SETID"") ||
             !strcasecmp(opt,""DELCONSUMER"")))
        {
            addReplyErrorFormat(c, ""-NOGROUP No such consumer group '%s' ""
                                   ""for key name '%s'"",
                                   (char*)grpname, (char*)c->argv[2]->ptr);
            return;
        }
    }

    /* Dispatch the different subcommands. */
    if (!strcasecmp(opt,""CREATE"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);
        if (cg) {
            addReply(c,shared.ok);
            server.dirty++;
        } else {
            addReplySds(c,
                sdsnew(""-BUSYGROUP Consumer Group name already exists\r\n""));
        }
    } else if (!strcasecmp(opt,""SETID"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        cg->last_id = id;
        addReply(c,shared.ok);
    } else if (!strcasecmp(opt,""DESTROY"") && c->argc == 4) {
        if (cg) {
            raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);
            streamFreeCG(cg);
            addReply(c,shared.cone);
        } else {
            addReply(c,shared.czero);
        }
    } else if (!strcasecmp(opt,""DELCONSUMER"") && c->argc == 5) {
        /* Delete the consumer and returns the number of pending messages
         * that were yet associated with such a consumer. */
        long long pending = streamDelConsumer(cg,c->argv[4]->ptr);
        addReplyLongLong(c,pending);
        server.dirty++;
    } else if (!strcasecmp(opt,""HELP"")) {
        addReplyHelp(c, help);
    } else {
        addReply(c,shared.syntaxerr);
    }
}
",C,"        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
","        if (o == NULL) return;
",,"@@ -1576,7 +1576,7 @@ NULL
     /* Lookup the key now, this is common for all the subcommands but HELP. */
     if (c->argc >= 4) {
         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);
-        if (o == NULL) return;
+        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
         s = o->ptr;
         grpname = c->argv[3]->ptr;
 ",redis,c04082cf138f1f51cedf05ee9ad36fb6763cafc6,be899b824edd312d4e3a1998c56626d66fae3b61,1,"void xgroupCommand(client *c) {
    const char *help[] = {
""CREATE      <key> <groupname> <id or $>  -- Create a new consumer group."",
""SETID       <key> <groupname> <id or $>  -- Set the current group ID."",
""DELGROUP    <key> <groupname>            -- Remove the specified group."",
""DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer."",
""HELP                                     -- Prints this help."",
NULL
    };
    stream *s = NULL;
    sds grpname = NULL;
    streamCG *cg = NULL;
    char *opt = c->argv[1]->ptr; /* Subcommand name. */

     /* Lookup the key now, this is common for all the subcommands but HELP. */
     if (c->argc >= 4) {
         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);
//flaw_line_below:
        if (o == NULL) return;
//fix_flaw_line_below:
//        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
         s = o->ptr;
         grpname = c->argv[3]->ptr;
 
        /* Certain subcommands require the group to exist. */
        if ((cg = streamLookupCG(s,grpname)) == NULL &&
            (!strcasecmp(opt,""SETID"") ||
             !strcasecmp(opt,""DELCONSUMER"")))
        {
            addReplyErrorFormat(c, ""-NOGROUP No such consumer group '%s' ""
                                   ""for key name '%s'"",
                                   (char*)grpname, (char*)c->argv[2]->ptr);
            return;
        }
    }

    /* Dispatch the different subcommands. */
    if (!strcasecmp(opt,""CREATE"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);
        if (cg) {
            addReply(c,shared.ok);
            server.dirty++;
        } else {
            addReplySds(c,
                sdsnew(""-BUSYGROUP Consumer Group name already exists\r\n""));
        }
    } else if (!strcasecmp(opt,""SETID"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        cg->last_id = id;
        addReply(c,shared.ok);
    } else if (!strcasecmp(opt,""DESTROY"") && c->argc == 4) {
        if (cg) {
            raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);
            streamFreeCG(cg);
            addReply(c,shared.cone);
        } else {
            addReply(c,shared.czero);
        }
    } else if (!strcasecmp(opt,""DELCONSUMER"") && c->argc == 5) {
        /* Delete the consumer and returns the number of pending messages
         * that were yet associated with such a consumer. */
        long long pending = streamDelConsumer(cg,c->argv[4]->ptr);
        addReplyLongLong(c,pending);
        server.dirty++;
    } else if (!strcasecmp(opt,""HELP"")) {
        addReplyHelp(c, help);
    } else {
        addReply(c,shared.syntaxerr);
    }
}
"
5301,183037,,Remote,Not required,Partial,CVE-2016-7398,https://www.cvedetails.com/cve/CVE-2016-7398/,CWE-704,Low,Partial,Partial,,2019-09-06,7.5,A type confusion vulnerability in the merge_param() function of php_http_params.c in PHP's pecl-http extension 3.1.0beta2 (PHP 7) and earlier as well as 2.6.0beta2 (PHP 5) and earlier allows attackers to crash PHP and possibly execute arbitrary code via crafted HTTP requests.,2019-09-20,Exec Code ,1,https://github.com/m6w6/ext-http/commit/17137d4ab1ce81a2cee0fae842340a344ef3da83,17137d4ab1ce81a2cee0fae842340a344ef3da83,fix bug #73055,1,src/php_http_params.c,"{""sha"": ""45ac1a5f203ae766bd3662ce1fe7a59e677ceb02"", ""filename"": "".gitignore"", ""status"": ""modified"", ""additions"": 33, ""deletions"": 0, ""changes"": 33, ""blob_url"": ""https://github.com/m6w6/ext-http/blob/17137d4ab1ce81a2cee0fae842340a344ef3da83/.gitignore"", ""raw_url"": ""https://github.com/m6w6/ext-http/raw/17137d4ab1ce81a2cee0fae842340a344ef3da83/.gitignore"", ""contents_url"": ""https://api.github.com/repos/m6w6/ext-http/contents/.gitignore?ref=17137d4ab1ce81a2cee0fae842340a344ef3da83"", ""patch"": ""@@ -42,3 +42,36 @@ lcov_data\n *.phar\n vendor/\n tests/helper/server.log\n+php_http_api.h\n+php_http_buffer.h\n+php_http_client.h\n+php_http_client_curl.h\n+php_http_client_curl_event.h\n+php_http_client_curl_user.h\n+php_http_client_request.h\n+php_http_client_response.h\n+php_http_cookie.h\n+php_http_curl.h\n+php_http_encoding.h\n+php_http_env.h\n+php_http_env_request.h\n+php_http_env_response.h\n+php_http_etag.h\n+php_http_exception.h\n+php_http_filter.h\n+php_http_header.h\n+php_http_header_parser.h\n+php_http_info.h\n+php_http_message.h\n+php_http_message_body.h\n+php_http_message_parser.h\n+php_http_misc.h\n+php_http_negotiate.h\n+php_http_object.h\n+php_http_options.h\n+php_http_params.h\n+php_http_querystring.h\n+php_http_response_codes.h\n+php_http_url.h\n+php_http_utf8.h\n+php_http_version.h""}<_**next**_>{""sha"": ""7191f314ad8cc64d1d99491e09010f271a89ae9c"", ""filename"": ""package.xml"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 2, ""changes"": 9, ""blob_url"": ""https://github.com/m6w6/ext-http/blob/17137d4ab1ce81a2cee0fae842340a344ef3da83/package.xml"", ""raw_url"": ""https://github.com/m6w6/ext-http/raw/17137d4ab1ce81a2cee0fae842340a344ef3da83/package.xml"", ""contents_url"": ""https://api.github.com/repos/m6w6/ext-http/contents/package.xml?ref=17137d4ab1ce81a2cee0fae842340a344ef3da83"", ""patch"": ""@@ -31,9 +31,9 @@ https://mdref.m6w6.name/http\n   <email>mike@php.net</email>\n   <active>yes</active>\n  </lead>\n- <date>2016-09-07</date>\n+ <date>2016-09-12</date>\n  <version>\n-  <release>2.6.0beta2</release>\n+  <release>2.6.0RC1</release>\n   <api>2.6.0</api>\n  </version>\n  <stability>\n@@ -69,6 +69,10 @@ https://mdref.m6w6.name/http\n Changes from beta1:\n * Fixed PHP-5.3 compatibility\n * Fixed recursive calls to the event loop dispatcher\n+\n+Changes from beta2:\n+* Fix bug #73055: crash in http\\QueryString (Mike, @rc0r)\n+* Fix HTTP/2 version parser for older libcurl versions (Mike)\n ]]></notes>\n  <contents>\n   <dir name=\""/\"">\n@@ -185,6 +189,7 @@ Changes from beta1:\n      <file role=\""test\"" name=\""bug69313.phpt\""/>\n      <file role=\""test\"" name=\""bug69357.phpt\""/>\n      <file role=\""test\"" name=\""bug71719.phpt\""/>\n+     <file role=\""test\"" name=\""bug73055.phpt\""/>\n      <file role=\""test\"" name=\""client001.phpt\""/>\n      <file role=\""test\"" name=\""client002.phpt\""/>\n      <file role=\""test\"" name=\""client003.phpt\""/>""}<_**next**_>{""sha"": ""90710684deabe6d08bd5e81d8e1563086f0095a6"", ""filename"": ""src/php_http_params.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/m6w6/ext-http/blob/17137d4ab1ce81a2cee0fae842340a344ef3da83/src/php_http_params.c"", ""raw_url"": ""https://github.com/m6w6/ext-http/raw/17137d4ab1ce81a2cee0fae842340a344ef3da83/src/php_http_params.c"", ""contents_url"": ""https://api.github.com/repos/m6w6/ext-http/contents/src/php_http_params.c?ref=17137d4ab1ce81a2cee0fae842340a344ef3da83"", ""patch"": ""@@ -470,7 +470,7 @@ static void merge_param(HashTable *params, zval *zdata, zval ***current_param, z\n \t\t\twhile (Z_TYPE_PP(zdata_ptr) == IS_ARRAY\n \t\t\t&&\tSUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)\n \t\t\t) {\n-\t\t\t\tif (Z_TYPE_PP(test_ptr) == IS_ARRAY) {\n+\t\t\t\tif (Z_TYPE_PP(test_ptr) == IS_ARRAY && Z_TYPE_PP(ptr) == IS_ARRAY) {\n \n \t\t\t\t\t/* now find key in ptr */\n \t\t\t\t\tif (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {""}","static void merge_param(HashTable *params, zval *zdata, zval ***current_param, zval ***current_args TSRMLS_DC)
{
	zval **ptr, **zdata_ptr;
	php_http_array_hashkey_t hkey = php_http_array_hashkey_init(0);

#if 0
	{
		zval tmp;
		INIT_PZVAL_ARRAY(&tmp, params);
		fprintf(stderr, ""params = "");
		zend_print_zval_r(&tmp, 1 TSRMLS_CC);
		fprintf(stderr, ""\n"");
	}
#endif

	hkey.type = zend_hash_get_current_key_ex(Z_ARRVAL_P(zdata), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL);

	if ((hkey.type == HASH_KEY_IS_STRING && !zend_hash_exists(params, hkey.str, hkey.len))
	||	(hkey.type == HASH_KEY_IS_LONG && !zend_hash_index_exists(params, hkey.num))
	) {
		zval *tmp, *arg, **args;

		/* create the entry if it doesn't exist */
		zend_hash_get_current_data(Z_ARRVAL_P(zdata), (void *) &ptr);
		Z_ADDREF_PP(ptr);
		MAKE_STD_ZVAL(tmp);
		array_init(tmp);
		add_assoc_zval_ex(tmp, ZEND_STRS(""value""), *ptr);

		MAKE_STD_ZVAL(arg);
		array_init(arg);
		zend_hash_update(Z_ARRVAL_P(tmp), ""arguments"", sizeof(""arguments""), (void *) &arg, sizeof(zval *), (void *) &args);
		*current_args = args;

		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_update(params, hkey.str, hkey.len, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		} else {
			zend_hash_index_update(params, hkey.num, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		}
	} else {
		/* merge */
		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_find(params, hkey.str, hkey.len, (void *) &ptr);
		} else {
			zend_hash_index_find(params, hkey.num, (void *) &ptr);
		}

		zdata_ptr = &zdata;

		if (Z_TYPE_PP(ptr) == IS_ARRAY
		&&	SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), ""value"", sizeof(""value""), (void *) &ptr)
		&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &zdata_ptr)
		) {
			/*
			 * params = [arr => [value => [0 => 1]]]
			 *                            ^- ptr
			 * zdata  = [arr => [0 => NULL]]
			 *                  ^- zdata_ptr
			 */
			zval **test_ptr;

 			while (Z_TYPE_PP(zdata_ptr) == IS_ARRAY
 			&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)
 			) {
				if (Z_TYPE_PP(test_ptr) == IS_ARRAY && Z_TYPE_PP(ptr) == IS_ARRAY) {
 
 					/* now find key in ptr */
 					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						if (SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					} else {
						if (SUCCESS == zend_hash_index_find(Z_ARRVAL_PP(ptr), hkey.num, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else if (hkey.num) {
							Z_ADDREF_PP(test_ptr);
							zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					}
				} else {
					/* this is the leaf */
					Z_ADDREF_PP(test_ptr);
					if (Z_TYPE_PP(ptr) != IS_ARRAY) {
						zval_dtor(*ptr);
						array_init(*ptr);
					}
					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else if (hkey.num) {
						zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else {
						zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					}
					break;
				}
			}

		}
	}

	/* bubble up */
	while (Z_TYPE_PP(ptr) == IS_ARRAY && SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(ptr), (void *) &ptr));
	*current_param = ptr;
}
","static void merge_param(HashTable *params, zval *zdata, zval ***current_param, zval ***current_args TSRMLS_DC)
{
	zval **ptr, **zdata_ptr;
	php_http_array_hashkey_t hkey = php_http_array_hashkey_init(0);

#if 0
	{
		zval tmp;
		INIT_PZVAL_ARRAY(&tmp, params);
		fprintf(stderr, ""params = "");
		zend_print_zval_r(&tmp, 1 TSRMLS_CC);
		fprintf(stderr, ""\n"");
	}
#endif

	hkey.type = zend_hash_get_current_key_ex(Z_ARRVAL_P(zdata), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL);

	if ((hkey.type == HASH_KEY_IS_STRING && !zend_hash_exists(params, hkey.str, hkey.len))
	||	(hkey.type == HASH_KEY_IS_LONG && !zend_hash_index_exists(params, hkey.num))
	) {
		zval *tmp, *arg, **args;

		/* create the entry if it doesn't exist */
		zend_hash_get_current_data(Z_ARRVAL_P(zdata), (void *) &ptr);
		Z_ADDREF_PP(ptr);
		MAKE_STD_ZVAL(tmp);
		array_init(tmp);
		add_assoc_zval_ex(tmp, ZEND_STRS(""value""), *ptr);

		MAKE_STD_ZVAL(arg);
		array_init(arg);
		zend_hash_update(Z_ARRVAL_P(tmp), ""arguments"", sizeof(""arguments""), (void *) &arg, sizeof(zval *), (void *) &args);
		*current_args = args;

		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_update(params, hkey.str, hkey.len, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		} else {
			zend_hash_index_update(params, hkey.num, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		}
	} else {
		/* merge */
		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_find(params, hkey.str, hkey.len, (void *) &ptr);
		} else {
			zend_hash_index_find(params, hkey.num, (void *) &ptr);
		}

		zdata_ptr = &zdata;

		if (Z_TYPE_PP(ptr) == IS_ARRAY
		&&	SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), ""value"", sizeof(""value""), (void *) &ptr)
		&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &zdata_ptr)
		) {
			/*
			 * params = [arr => [value => [0 => 1]]]
			 *                            ^- ptr
			 * zdata  = [arr => [0 => NULL]]
			 *                  ^- zdata_ptr
			 */
			zval **test_ptr;

 			while (Z_TYPE_PP(zdata_ptr) == IS_ARRAY
 			&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)
 			) {
				if (Z_TYPE_PP(test_ptr) == IS_ARRAY) {
 
 					/* now find key in ptr */
 					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						if (SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					} else {
						if (SUCCESS == zend_hash_index_find(Z_ARRVAL_PP(ptr), hkey.num, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else if (hkey.num) {
							Z_ADDREF_PP(test_ptr);
							zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					}
				} else {
					/* this is the leaf */
					Z_ADDREF_PP(test_ptr);
					if (Z_TYPE_PP(ptr) != IS_ARRAY) {
						zval_dtor(*ptr);
						array_init(*ptr);
					}
					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else if (hkey.num) {
						zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else {
						zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					}
					break;
				}
			}

		}
	}

	/* bubble up */
	while (Z_TYPE_PP(ptr) == IS_ARRAY && SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(ptr), (void *) &ptr));
	*current_param = ptr;
}
",C,"				if (Z_TYPE_PP(test_ptr) == IS_ARRAY && Z_TYPE_PP(ptr) == IS_ARRAY) {
","				if (Z_TYPE_PP(test_ptr) == IS_ARRAY) {
",,"@@ -470,7 +470,7 @@ static void merge_param(HashTable *params, zval *zdata, zval ***current_param, z
 			while (Z_TYPE_PP(zdata_ptr) == IS_ARRAY
 			&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)
 			) {
-				if (Z_TYPE_PP(test_ptr) == IS_ARRAY) {
+				if (Z_TYPE_PP(test_ptr) == IS_ARRAY && Z_TYPE_PP(ptr) == IS_ARRAY) {
 
 					/* now find key in ptr */
 					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {",ext-http,17137d4ab1ce81a2cee0fae842340a344ef3da83,3c7b514d38d844b855d430fcbaed6dea67c9c17b,1,"static void merge_param(HashTable *params, zval *zdata, zval ***current_param, zval ***current_args TSRMLS_DC)
{
	zval **ptr, **zdata_ptr;
	php_http_array_hashkey_t hkey = php_http_array_hashkey_init(0);

#if 0
	{
		zval tmp;
		INIT_PZVAL_ARRAY(&tmp, params);
		fprintf(stderr, ""params = "");
		zend_print_zval_r(&tmp, 1 TSRMLS_CC);
		fprintf(stderr, ""\n"");
	}
#endif

	hkey.type = zend_hash_get_current_key_ex(Z_ARRVAL_P(zdata), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL);

	if ((hkey.type == HASH_KEY_IS_STRING && !zend_hash_exists(params, hkey.str, hkey.len))
	||	(hkey.type == HASH_KEY_IS_LONG && !zend_hash_index_exists(params, hkey.num))
	) {
		zval *tmp, *arg, **args;

		/* create the entry if it doesn't exist */
		zend_hash_get_current_data(Z_ARRVAL_P(zdata), (void *) &ptr);
		Z_ADDREF_PP(ptr);
		MAKE_STD_ZVAL(tmp);
		array_init(tmp);
		add_assoc_zval_ex(tmp, ZEND_STRS(""value""), *ptr);

		MAKE_STD_ZVAL(arg);
		array_init(arg);
		zend_hash_update(Z_ARRVAL_P(tmp), ""arguments"", sizeof(""arguments""), (void *) &arg, sizeof(zval *), (void *) &args);
		*current_args = args;

		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_update(params, hkey.str, hkey.len, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		} else {
			zend_hash_index_update(params, hkey.num, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		}
	} else {
		/* merge */
		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_find(params, hkey.str, hkey.len, (void *) &ptr);
		} else {
			zend_hash_index_find(params, hkey.num, (void *) &ptr);
		}

		zdata_ptr = &zdata;

		if (Z_TYPE_PP(ptr) == IS_ARRAY
		&&	SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), ""value"", sizeof(""value""), (void *) &ptr)
		&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &zdata_ptr)
		) {
			/*
			 * params = [arr => [value => [0 => 1]]]
			 *                            ^- ptr
			 * zdata  = [arr => [0 => NULL]]
			 *                  ^- zdata_ptr
			 */
			zval **test_ptr;

 			while (Z_TYPE_PP(zdata_ptr) == IS_ARRAY
 			&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)
 			) {
//flaw_line_below:
				if (Z_TYPE_PP(test_ptr) == IS_ARRAY) {
//fix_flaw_line_below:
//				if (Z_TYPE_PP(test_ptr) == IS_ARRAY && Z_TYPE_PP(ptr) == IS_ARRAY) {
 
 					/* now find key in ptr */
 					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						if (SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					} else {
						if (SUCCESS == zend_hash_index_find(Z_ARRVAL_PP(ptr), hkey.num, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else if (hkey.num) {
							Z_ADDREF_PP(test_ptr);
							zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					}
				} else {
					/* this is the leaf */
					Z_ADDREF_PP(test_ptr);
					if (Z_TYPE_PP(ptr) != IS_ARRAY) {
						zval_dtor(*ptr);
						array_init(*ptr);
					}
					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else if (hkey.num) {
						zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else {
						zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					}
					break;
				}
			}

		}
	}

	/* bubble up */
	while (Z_TYPE_PP(ptr) == IS_ARRAY && SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(ptr), (void *) &ptr));
	*current_param = ptr;
}
"
8529,186265,,Remote,Not required,Partial,CVE-2017-5116,https://www.cvedetails.com/cve/CVE-2017-5116/,CWE-704,Medium,Partial,Partial,,2017-10-27,6.8,"Type confusion in V8 in Google Chrome prior to 61.0.3163.79 for Mac, Windows, and Linux, and 61.0.3163.81 for Android, allowed a remote attacker to execute arbitrary code inside a sandbox via a crafted HTML page.",2018-01-19,Exec Code ,0,https://github.com/chromium/chromium/commit/acf2f0799f6f732dd70f45ddd252d773be7afd11,acf2f0799f6f732dd70f45ddd252d773be7afd11,"Desktop Page Info/Harmony: Show close button for internal pages.

The Harmony version of Page Info for internal Chrome pages (chrome://,
chrome-extension:// and view-source:// pages) show a close button. Update the
code to match this.

This patch also adds TestBrowserDialog tests for the latter two cases described
above (internal extension and view source pages).

See screenshot -
https://drive.google.com/file/d/18RZnMiHCu-rCX9N6DLUpu4mkFWguh1xm/view?usp=sharing

Bug: 535074
Change-Id: I55e5f1aa682fd4ec85f7b65ac88f5a4f5906fe53
Reviewed-on: https://chromium-review.googlesource.com/759624
Commit-Queue: Patti <patricialor@chromium.org>
Reviewed-by: Trent Apted <tapted@chromium.org>
Cr-Commit-Position: refs/heads/master@{#516624}",2,chrome/browser/ui/views/page_info/page_info_bubble_view.cc,"{""sha"": ""65b0f7a0ac0151d52a400e16202c912901e1ee0c"", ""filename"": ""chrome/browser/ui/views/page_info/page_info_bubble_view.cc"", ""status"": ""modified"", ""additions"": 45, ""deletions"": 20, ""changes"": 65, ""blob_url"": ""https://github.com/chromium/chromium/blob/acf2f0799f6f732dd70f45ddd252d773be7afd11/chrome/browser/ui/views/page_info/page_info_bubble_view.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/acf2f0799f6f732dd70f45ddd252d773be7afd11/chrome/browser/ui/views/page_info/page_info_bubble_view.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/page_info/page_info_bubble_view.cc?ref=acf2f0799f6f732dd70f45ddd252d773be7afd11"", ""patch"": ""@@ -224,12 +224,16 @@ class InternalPageInfoBubbleView : public views::BubbleDialogDelegateView {\n   ~InternalPageInfoBubbleView() override;\n \n   // views::BubbleDialogDelegateView:\n-  void OnWidgetDestroying(views::Widget* widget) override;\n   int GetDialogButtons() const override;\n+  base::string16 GetWindowTitle() const override;\n+  bool ShouldShowCloseButton() const override;\n+  gfx::ImageSkia GetWindowIcon() override;\n+  bool ShouldShowWindowIcon() const override;\n+  void OnWidgetDestroying(views::Widget* widget) override;\n \n  private:\n-  // Used around icon and inside bubble border.\n-  static constexpr int kSpacing = 12;\n+  base::string16 title_text_;\n+  gfx::ImageSkia* bubble_icon_;\n \n   DISALLOW_COPY_AND_ASSIGN(InternalPageInfoBubbleView);\n };\n@@ -411,36 +415,57 @@ InternalPageInfoBubbleView::InternalPageInfoBubbleView(\n   set_anchor_view_insets(gfx::Insets(\n       GetLayoutConstant(LOCATION_BAR_BUBBLE_ANCHOR_VERTICAL_INSET), 0));\n \n-  SetLayoutManager(new views::BoxLayout(views::BoxLayout::kHorizontal,\n-                                        gfx::Insets(kSpacing), kSpacing));\n+  // Title insets assume there is content (and thus have no bottom padding). Use\n+  // dialog insets to get the bottom margin back.\n+  set_title_margins(\n+      ChromeLayoutProvider::Get()->GetInsetsMetric(views::INSETS_DIALOG));\n   set_margins(gfx::Insets());\n-  if (ChromeLayoutProvider::Get()->ShouldShowWindowIcon()) {\n-    views::ImageView* icon_view = new NonAccessibleImageView();\n-    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-    icon_view->SetImage(rb.GetImageSkiaNamed(icon));\n-    AddChildView(icon_view);\n-  }\n \n-  views::Label* label = new views::Label(l10n_util::GetStringUTF16(text));\n-  label->SetMultiLine(true);\n-  label->SetAllowCharacterBreak(true);\n-  label->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n-  AddChildView(label);\n+  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+  bubble_icon_ = rb.GetImageSkiaNamed(icon);\n+  title_text_ = l10n_util::GetStringUTF16(text);\n \n   views::BubbleDialogDelegateView::CreateBubble(this);\n+\n+  // Use a normal label's style for the title since there is no content.\n+  views::Label* title_label =\n+      static_cast<views::Label*>(GetBubbleFrameView()->title());\n+  title_label->SetFontList(views::Label::GetDefaultFontList());\n+  title_label->SetMultiLine(false);\n+  title_label->SetElideBehavior(gfx::NO_ELIDE);\n+\n+  SizeToContents();\n }\n \n InternalPageInfoBubbleView::~InternalPageInfoBubbleView() {}\n \n+int InternalPageInfoBubbleView::GetDialogButtons() const {\n+  return ui::DIALOG_BUTTON_NONE;\n+}\n+\n+base::string16 InternalPageInfoBubbleView::GetWindowTitle() const {\n+  return title_text_;\n+}\n+\n+bool InternalPageInfoBubbleView::ShouldShowCloseButton() const {\n+  // TODO(patricialor): When Harmony is default, also remove |bubble_icon_| and\n+  // supporting code.\n+  return ui::MaterialDesignController::IsSecondaryUiMaterial();\n+}\n+\n+gfx::ImageSkia InternalPageInfoBubbleView::GetWindowIcon() {\n+  return *bubble_icon_;\n+}\n+\n+bool InternalPageInfoBubbleView::ShouldShowWindowIcon() const {\n+  return ChromeLayoutProvider::Get()->ShouldShowWindowIcon();\n+}\n+\n void InternalPageInfoBubbleView::OnWidgetDestroying(views::Widget* widget) {\n   g_shown_bubble_type = PageInfoBubbleView::BUBBLE_NONE;\n   g_page_info_bubble = nullptr;\n }\n \n-int InternalPageInfoBubbleView::GetDialogButtons() const {\n-  return ui::DIALOG_BUTTON_NONE;\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // PageInfoBubbleView\n ////////////////////////////////////////////////////////////////////////////////""}<_**next**_>{""sha"": ""97f388f5c227315c6eb8459438dc8fd4d602f9c3"", ""filename"": ""chrome/browser/ui/views/page_info/page_info_bubble_view_browsertest.cc"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 2, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/acf2f0799f6f732dd70f45ddd252d773be7afd11/chrome/browser/ui/views/page_info/page_info_bubble_view_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/acf2f0799f6f732dd70f45ddd252d773be7afd11/chrome/browser/ui/views/page_info/page_info_bubble_view_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/page_info/page_info_bubble_view_browsertest.cc?ref=acf2f0799f6f732dd70f45ddd252d773be7afd11"", ""patch"": ""@@ -111,6 +111,8 @@ class PageInfoBubbleViewBrowserTest : public DialogBrowserTest {\n     // All the possible test names.\n     constexpr char kInsecure[] = \""Insecure\"";\n     constexpr char kInternal[] = \""Internal\"";\n+    constexpr char kInternalExtension[] = \""InternalExtension\"";\n+    constexpr char kInternalViewSource[] = \""InternalViewSource\"";\n     constexpr char kSecure[] = \""Secure\"";\n     constexpr char kMalware[] = \""Malware\"";\n     constexpr char kDeceptive[] = \""Deceptive\"";\n@@ -121,6 +123,7 @@ class PageInfoBubbleViewBrowserTest : public DialogBrowserTest {\n     constexpr char kMixedContent[] = \""MixedContent\"";\n \n     const GURL internal_url(\""chrome://settings\"");\n+    const GURL internal_extension_url(\""chrome-extension://example\"");\n     // Note the following two URLs are not really necessary to get the different\n     // versions of Page Info to appear, but are here to indicate the type of\n     // URL each IdentityInfo type would normally be associated with.\n@@ -130,8 +133,17 @@ class PageInfoBubbleViewBrowserTest : public DialogBrowserTest {\n     GURL url = http_url;\n     if (name == kSecure || name == kMixedContentForm || name == kMixedContent)\n       url = https_url;\n-    if (name == kInternal)\n+    if (name == kInternal) {\n       url = internal_url;\n+    } else if (name == kInternalExtension) {\n+      url = internal_extension_url;\n+    } else if (name == kInternalViewSource) {\n+      constexpr char kTestHtml[] = \""/viewsource/test.html\"";\n+      ASSERT_TRUE(embedded_test_server()->Start());\n+      url = GURL(content::kViewSourceScheme +\n+                 std::string(url::kStandardSchemeSeparator) +\n+                 embedded_test_server()->GetURL(kTestHtml).spec());\n+    }\n \n     ui_test_utils::NavigateToURL(browser(), url);\n     OpenPageInfoBubble(browser());\n@@ -175,7 +187,7 @@ class PageInfoBubbleViewBrowserTest : public DialogBrowserTest {\n           PageInfo::SITE_CONNECTION_STATUS_INSECURE_PASSIVE_SUBRESOURCE;\n     }\n \n-    if (name != kInsecure && name != kInternal) {\n+    if (name != kInsecure && name.find(kInternal) == std::string::npos) {\n       // The bubble may be PageInfoBubbleView or InternalPageInfoBubbleView. The\n       // latter is only used for |kInternal|, so it is safe to static_cast here.\n       static_cast<PageInfoBubbleView*>(PageInfoBubbleView::GetPageInfoBubble())\n@@ -351,6 +363,18 @@ IN_PROC_BROWSER_TEST_F(PageInfoBubbleViewBrowserTest, InvokeDialog_Internal) {\n   RunDialog();\n }\n \n+// Shows the Page Info bubble for an extensions page.\n+IN_PROC_BROWSER_TEST_F(PageInfoBubbleViewBrowserTest,\n+                       InvokeDialog_InternalExtension) {\n+  RunDialog();\n+}\n+\n+// Shows the Page Info bubble for a chrome page that displays the source HTML.\n+IN_PROC_BROWSER_TEST_F(PageInfoBubbleViewBrowserTest,\n+                       InvokeDialog_InternalViewSource) {\n+  RunDialog();\n+}\n+\n // Shows the Page Info bubble for a site flagged for malware by Safe Browsing.\n IN_PROC_BROWSER_TEST_F(PageInfoBubbleViewBrowserTest, InvokeDialog_Malware) {\n   RunDialog();""}","int InternalPageInfoBubbleView::GetDialogButtons() const {
","int InternalPageInfoBubbleView::GetDialogButtons() const {
  return ui::DIALOG_BUTTON_NONE;
}
",C,,"  return ui::DIALOG_BUTTON_NONE;
}
",,"@@ -224,12 +224,16 @@ class InternalPageInfoBubbleView : public views::BubbleDialogDelegateView {
   ~InternalPageInfoBubbleView() override;
 
   // views::BubbleDialogDelegateView:
-  void OnWidgetDestroying(views::Widget* widget) override;
   int GetDialogButtons() const override;
+  base::string16 GetWindowTitle() const override;
+  bool ShouldShowCloseButton() const override;
+  gfx::ImageSkia GetWindowIcon() override;
+  bool ShouldShowWindowIcon() const override;
+  void OnWidgetDestroying(views::Widget* widget) override;
 
  private:
-  // Used around icon and inside bubble border.
-  static constexpr int kSpacing = 12;
+  base::string16 title_text_;
+  gfx::ImageSkia* bubble_icon_;
 
   DISALLOW_COPY_AND_ASSIGN(InternalPageInfoBubbleView);
 };
@@ -411,36 +415,57 @@ InternalPageInfoBubbleView::InternalPageInfoBubbleView(
   set_anchor_view_insets(gfx::Insets(
       GetLayoutConstant(LOCATION_BAR_BUBBLE_ANCHOR_VERTICAL_INSET), 0));
 
-  SetLayoutManager(new views::BoxLayout(views::BoxLayout::kHorizontal,
-                                        gfx::Insets(kSpacing), kSpacing));
+  // Title insets assume there is content (and thus have no bottom padding). Use
+  // dialog insets to get the bottom margin back.
+  set_title_margins(
+      ChromeLayoutProvider::Get()->GetInsetsMetric(views::INSETS_DIALOG));
   set_margins(gfx::Insets());
-  if (ChromeLayoutProvider::Get()->ShouldShowWindowIcon()) {
-    views::ImageView* icon_view = new NonAccessibleImageView();
-    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-    icon_view->SetImage(rb.GetImageSkiaNamed(icon));
-    AddChildView(icon_view);
-  }
 
-  views::Label* label = new views::Label(l10n_util::GetStringUTF16(text));
-  label->SetMultiLine(true);
-  label->SetAllowCharacterBreak(true);
-  label->SetHorizontalAlignment(gfx::ALIGN_LEFT);
-  AddChildView(label);
+  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+  bubble_icon_ = rb.GetImageSkiaNamed(icon);
+  title_text_ = l10n_util::GetStringUTF16(text);
 
   views::BubbleDialogDelegateView::CreateBubble(this);
+
+  // Use a normal label's style for the title since there is no content.
+  views::Label* title_label =
+      static_cast<views::Label*>(GetBubbleFrameView()->title());
+  title_label->SetFontList(views::Label::GetDefaultFontList());
+  title_label->SetMultiLine(false);
+  title_label->SetElideBehavior(gfx::NO_ELIDE);
+
+  SizeToContents();
 }
 
 InternalPageInfoBubbleView::~InternalPageInfoBubbleView() {}
 
+int InternalPageInfoBubbleView::GetDialogButtons() const {
+  return ui::DIALOG_BUTTON_NONE;
+}
+
+base::string16 InternalPageInfoBubbleView::GetWindowTitle() const {
+  return title_text_;
+}
+
+bool InternalPageInfoBubbleView::ShouldShowCloseButton() const {
+  // TODO(patricialor): When Harmony is default, also remove |bubble_icon_| and
+  // supporting code.
+  return ui::MaterialDesignController::IsSecondaryUiMaterial();
+}
+
+gfx::ImageSkia InternalPageInfoBubbleView::GetWindowIcon() {
+  return *bubble_icon_;
+}
+
+bool InternalPageInfoBubbleView::ShouldShowWindowIcon() const {
+  return ChromeLayoutProvider::Get()->ShouldShowWindowIcon();
+}
+
 void InternalPageInfoBubbleView::OnWidgetDestroying(views::Widget* widget) {
   g_shown_bubble_type = PageInfoBubbleView::BUBBLE_NONE;
   g_page_info_bubble = nullptr;
 }
 
-int InternalPageInfoBubbleView::GetDialogButtons() const {
-  return ui::DIALOG_BUTTON_NONE;
-}
-
 ////////////////////////////////////////////////////////////////////////////////
 // PageInfoBubbleView
 ////////////////////////////////////////////////////////////////////////////////",Chrome,acf2f0799f6f732dd70f45ddd252d773be7afd11,d661b2e68b309656837ad7f65e68c673f4bb82ca,1,"int InternalPageInfoBubbleView::GetDialogButtons() const {
//flaw_line_below:
  return ui::DIALOG_BUTTON_NONE;
//flaw_line_below:
}
"
8530,186266,,Remote,Not required,Partial,CVE-2017-5116,https://www.cvedetails.com/cve/CVE-2017-5116/,CWE-704,Medium,Partial,Partial,,2017-10-27,6.8,"Type confusion in V8 in Google Chrome prior to 61.0.3163.79 for Mac, Windows, and Linux, and 61.0.3163.81 for Android, allowed a remote attacker to execute arbitrary code inside a sandbox via a crafted HTML page.",2018-01-19,Exec Code ,16,https://github.com/chromium/chromium/commit/acf2f0799f6f732dd70f45ddd252d773be7afd11,acf2f0799f6f732dd70f45ddd252d773be7afd11,"Desktop Page Info/Harmony: Show close button for internal pages.

The Harmony version of Page Info for internal Chrome pages (chrome://,
chrome-extension:// and view-source:// pages) show a close button. Update the
code to match this.

This patch also adds TestBrowserDialog tests for the latter two cases described
above (internal extension and view source pages).

See screenshot -
https://drive.google.com/file/d/18RZnMiHCu-rCX9N6DLUpu4mkFWguh1xm/view?usp=sharing

Bug: 535074
Change-Id: I55e5f1aa682fd4ec85f7b65ac88f5a4f5906fe53
Reviewed-on: https://chromium-review.googlesource.com/759624
Commit-Queue: Patti <patricialor@chromium.org>
Reviewed-by: Trent Apted <tapted@chromium.org>
Cr-Commit-Position: refs/heads/master@{#516624}",13,chrome/browser/ui/views/page_info/page_info_bubble_view.cc,"{""sha"": ""65b0f7a0ac0151d52a400e16202c912901e1ee0c"", ""filename"": ""chrome/browser/ui/views/page_info/page_info_bubble_view.cc"", ""status"": ""modified"", ""additions"": 45, ""deletions"": 20, ""changes"": 65, ""blob_url"": ""https://github.com/chromium/chromium/blob/acf2f0799f6f732dd70f45ddd252d773be7afd11/chrome/browser/ui/views/page_info/page_info_bubble_view.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/acf2f0799f6f732dd70f45ddd252d773be7afd11/chrome/browser/ui/views/page_info/page_info_bubble_view.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/page_info/page_info_bubble_view.cc?ref=acf2f0799f6f732dd70f45ddd252d773be7afd11"", ""patch"": ""@@ -224,12 +224,16 @@ class InternalPageInfoBubbleView : public views::BubbleDialogDelegateView {\n   ~InternalPageInfoBubbleView() override;\n \n   // views::BubbleDialogDelegateView:\n-  void OnWidgetDestroying(views::Widget* widget) override;\n   int GetDialogButtons() const override;\n+  base::string16 GetWindowTitle() const override;\n+  bool ShouldShowCloseButton() const override;\n+  gfx::ImageSkia GetWindowIcon() override;\n+  bool ShouldShowWindowIcon() const override;\n+  void OnWidgetDestroying(views::Widget* widget) override;\n \n  private:\n-  // Used around icon and inside bubble border.\n-  static constexpr int kSpacing = 12;\n+  base::string16 title_text_;\n+  gfx::ImageSkia* bubble_icon_;\n \n   DISALLOW_COPY_AND_ASSIGN(InternalPageInfoBubbleView);\n };\n@@ -411,36 +415,57 @@ InternalPageInfoBubbleView::InternalPageInfoBubbleView(\n   set_anchor_view_insets(gfx::Insets(\n       GetLayoutConstant(LOCATION_BAR_BUBBLE_ANCHOR_VERTICAL_INSET), 0));\n \n-  SetLayoutManager(new views::BoxLayout(views::BoxLayout::kHorizontal,\n-                                        gfx::Insets(kSpacing), kSpacing));\n+  // Title insets assume there is content (and thus have no bottom padding). Use\n+  // dialog insets to get the bottom margin back.\n+  set_title_margins(\n+      ChromeLayoutProvider::Get()->GetInsetsMetric(views::INSETS_DIALOG));\n   set_margins(gfx::Insets());\n-  if (ChromeLayoutProvider::Get()->ShouldShowWindowIcon()) {\n-    views::ImageView* icon_view = new NonAccessibleImageView();\n-    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-    icon_view->SetImage(rb.GetImageSkiaNamed(icon));\n-    AddChildView(icon_view);\n-  }\n \n-  views::Label* label = new views::Label(l10n_util::GetStringUTF16(text));\n-  label->SetMultiLine(true);\n-  label->SetAllowCharacterBreak(true);\n-  label->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n-  AddChildView(label);\n+  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+  bubble_icon_ = rb.GetImageSkiaNamed(icon);\n+  title_text_ = l10n_util::GetStringUTF16(text);\n \n   views::BubbleDialogDelegateView::CreateBubble(this);\n+\n+  // Use a normal label's style for the title since there is no content.\n+  views::Label* title_label =\n+      static_cast<views::Label*>(GetBubbleFrameView()->title());\n+  title_label->SetFontList(views::Label::GetDefaultFontList());\n+  title_label->SetMultiLine(false);\n+  title_label->SetElideBehavior(gfx::NO_ELIDE);\n+\n+  SizeToContents();\n }\n \n InternalPageInfoBubbleView::~InternalPageInfoBubbleView() {}\n \n+int InternalPageInfoBubbleView::GetDialogButtons() const {\n+  return ui::DIALOG_BUTTON_NONE;\n+}\n+\n+base::string16 InternalPageInfoBubbleView::GetWindowTitle() const {\n+  return title_text_;\n+}\n+\n+bool InternalPageInfoBubbleView::ShouldShowCloseButton() const {\n+  // TODO(patricialor): When Harmony is default, also remove |bubble_icon_| and\n+  // supporting code.\n+  return ui::MaterialDesignController::IsSecondaryUiMaterial();\n+}\n+\n+gfx::ImageSkia InternalPageInfoBubbleView::GetWindowIcon() {\n+  return *bubble_icon_;\n+}\n+\n+bool InternalPageInfoBubbleView::ShouldShowWindowIcon() const {\n+  return ChromeLayoutProvider::Get()->ShouldShowWindowIcon();\n+}\n+\n void InternalPageInfoBubbleView::OnWidgetDestroying(views::Widget* widget) {\n   g_shown_bubble_type = PageInfoBubbleView::BUBBLE_NONE;\n   g_page_info_bubble = nullptr;\n }\n \n-int InternalPageInfoBubbleView::GetDialogButtons() const {\n-  return ui::DIALOG_BUTTON_NONE;\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // PageInfoBubbleView\n ////////////////////////////////////////////////////////////////////////////////""}<_**next**_>{""sha"": ""97f388f5c227315c6eb8459438dc8fd4d602f9c3"", ""filename"": ""chrome/browser/ui/views/page_info/page_info_bubble_view_browsertest.cc"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 2, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/acf2f0799f6f732dd70f45ddd252d773be7afd11/chrome/browser/ui/views/page_info/page_info_bubble_view_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/acf2f0799f6f732dd70f45ddd252d773be7afd11/chrome/browser/ui/views/page_info/page_info_bubble_view_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/page_info/page_info_bubble_view_browsertest.cc?ref=acf2f0799f6f732dd70f45ddd252d773be7afd11"", ""patch"": ""@@ -111,6 +111,8 @@ class PageInfoBubbleViewBrowserTest : public DialogBrowserTest {\n     // All the possible test names.\n     constexpr char kInsecure[] = \""Insecure\"";\n     constexpr char kInternal[] = \""Internal\"";\n+    constexpr char kInternalExtension[] = \""InternalExtension\"";\n+    constexpr char kInternalViewSource[] = \""InternalViewSource\"";\n     constexpr char kSecure[] = \""Secure\"";\n     constexpr char kMalware[] = \""Malware\"";\n     constexpr char kDeceptive[] = \""Deceptive\"";\n@@ -121,6 +123,7 @@ class PageInfoBubbleViewBrowserTest : public DialogBrowserTest {\n     constexpr char kMixedContent[] = \""MixedContent\"";\n \n     const GURL internal_url(\""chrome://settings\"");\n+    const GURL internal_extension_url(\""chrome-extension://example\"");\n     // Note the following two URLs are not really necessary to get the different\n     // versions of Page Info to appear, but are here to indicate the type of\n     // URL each IdentityInfo type would normally be associated with.\n@@ -130,8 +133,17 @@ class PageInfoBubbleViewBrowserTest : public DialogBrowserTest {\n     GURL url = http_url;\n     if (name == kSecure || name == kMixedContentForm || name == kMixedContent)\n       url = https_url;\n-    if (name == kInternal)\n+    if (name == kInternal) {\n       url = internal_url;\n+    } else if (name == kInternalExtension) {\n+      url = internal_extension_url;\n+    } else if (name == kInternalViewSource) {\n+      constexpr char kTestHtml[] = \""/viewsource/test.html\"";\n+      ASSERT_TRUE(embedded_test_server()->Start());\n+      url = GURL(content::kViewSourceScheme +\n+                 std::string(url::kStandardSchemeSeparator) +\n+                 embedded_test_server()->GetURL(kTestHtml).spec());\n+    }\n \n     ui_test_utils::NavigateToURL(browser(), url);\n     OpenPageInfoBubble(browser());\n@@ -175,7 +187,7 @@ class PageInfoBubbleViewBrowserTest : public DialogBrowserTest {\n           PageInfo::SITE_CONNECTION_STATUS_INSECURE_PASSIVE_SUBRESOURCE;\n     }\n \n-    if (name != kInsecure && name != kInternal) {\n+    if (name != kInsecure && name.find(kInternal) == std::string::npos) {\n       // The bubble may be PageInfoBubbleView or InternalPageInfoBubbleView. The\n       // latter is only used for |kInternal|, so it is safe to static_cast here.\n       static_cast<PageInfoBubbleView*>(PageInfoBubbleView::GetPageInfoBubble())\n@@ -351,6 +363,18 @@ IN_PROC_BROWSER_TEST_F(PageInfoBubbleViewBrowserTest, InvokeDialog_Internal) {\n   RunDialog();\n }\n \n+// Shows the Page Info bubble for an extensions page.\n+IN_PROC_BROWSER_TEST_F(PageInfoBubbleViewBrowserTest,\n+                       InvokeDialog_InternalExtension) {\n+  RunDialog();\n+}\n+\n+// Shows the Page Info bubble for a chrome page that displays the source HTML.\n+IN_PROC_BROWSER_TEST_F(PageInfoBubbleViewBrowserTest,\n+                       InvokeDialog_InternalViewSource) {\n+  RunDialog();\n+}\n+\n // Shows the Page Info bubble for a site flagged for malware by Safe Browsing.\n IN_PROC_BROWSER_TEST_F(PageInfoBubbleViewBrowserTest, InvokeDialog_Malware) {\n   RunDialog();""}","InternalPageInfoBubbleView::InternalPageInfoBubbleView(
    views::View* anchor_view,
    const gfx::Rect& anchor_rect,
    gfx::NativeView parent_window,
    const GURL& url)
    : BubbleDialogDelegateView(anchor_view, views::BubbleBorder::TOP_LEFT) {
  g_shown_bubble_type = PageInfoBubbleView::BUBBLE_INTERNAL_PAGE;
  g_page_info_bubble = this;
  set_parent_window(parent_window);
  if (!anchor_view)
    SetAnchorRect(anchor_rect);

  int text = IDS_PAGE_INFO_INTERNAL_PAGE;
  int icon = IDR_PRODUCT_LOGO_16;
  if (url.SchemeIs(extensions::kExtensionScheme)) {
    text = IDS_PAGE_INFO_EXTENSION_PAGE;
    icon = IDR_PLUGINS_FAVICON;
  } else if (url.SchemeIs(content::kViewSourceScheme)) {
    text = IDS_PAGE_INFO_VIEW_SOURCE_PAGE;
    icon = IDR_PRODUCT_LOGO_16;
  } else if (!url.SchemeIs(content::kChromeUIScheme) &&
             !url.SchemeIs(content::kChromeDevToolsScheme)) {
    NOTREACHED();
  }

   set_anchor_view_insets(gfx::Insets(
       GetLayoutConstant(LOCATION_BAR_BUBBLE_ANCHOR_VERTICAL_INSET), 0));
 
  // Title insets assume there is content (and thus have no bottom padding). Use
  // dialog insets to get the bottom margin back.
  set_title_margins(
      ChromeLayoutProvider::Get()->GetInsetsMetric(views::INSETS_DIALOG));
   set_margins(gfx::Insets());
 
  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
  bubble_icon_ = rb.GetImageSkiaNamed(icon);
  title_text_ = l10n_util::GetStringUTF16(text);
 
   views::BubbleDialogDelegateView::CreateBubble(this);

  // Use a normal label's style for the title since there is no content.
  views::Label* title_label =
      static_cast<views::Label*>(GetBubbleFrameView()->title());
  title_label->SetFontList(views::Label::GetDefaultFontList());
  title_label->SetMultiLine(false);
  title_label->SetElideBehavior(gfx::NO_ELIDE);

  SizeToContents();
 }
","InternalPageInfoBubbleView::InternalPageInfoBubbleView(
    views::View* anchor_view,
    const gfx::Rect& anchor_rect,
    gfx::NativeView parent_window,
    const GURL& url)
    : BubbleDialogDelegateView(anchor_view, views::BubbleBorder::TOP_LEFT) {
  g_shown_bubble_type = PageInfoBubbleView::BUBBLE_INTERNAL_PAGE;
  g_page_info_bubble = this;
  set_parent_window(parent_window);
  if (!anchor_view)
    SetAnchorRect(anchor_rect);

  int text = IDS_PAGE_INFO_INTERNAL_PAGE;
  int icon = IDR_PRODUCT_LOGO_16;
  if (url.SchemeIs(extensions::kExtensionScheme)) {
    text = IDS_PAGE_INFO_EXTENSION_PAGE;
    icon = IDR_PLUGINS_FAVICON;
  } else if (url.SchemeIs(content::kViewSourceScheme)) {
    text = IDS_PAGE_INFO_VIEW_SOURCE_PAGE;
    icon = IDR_PRODUCT_LOGO_16;
  } else if (!url.SchemeIs(content::kChromeUIScheme) &&
             !url.SchemeIs(content::kChromeDevToolsScheme)) {
    NOTREACHED();
  }

   set_anchor_view_insets(gfx::Insets(
       GetLayoutConstant(LOCATION_BAR_BUBBLE_ANCHOR_VERTICAL_INSET), 0));
 
  SetLayoutManager(new views::BoxLayout(views::BoxLayout::kHorizontal,
                                        gfx::Insets(kSpacing), kSpacing));
   set_margins(gfx::Insets());
  if (ChromeLayoutProvider::Get()->ShouldShowWindowIcon()) {
    views::ImageView* icon_view = new NonAccessibleImageView();
    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
    icon_view->SetImage(rb.GetImageSkiaNamed(icon));
    AddChildView(icon_view);
  }
 
  views::Label* label = new views::Label(l10n_util::GetStringUTF16(text));
  label->SetMultiLine(true);
  label->SetAllowCharacterBreak(true);
  label->SetHorizontalAlignment(gfx::ALIGN_LEFT);
  AddChildView(label);
 
   views::BubbleDialogDelegateView::CreateBubble(this);
 }
",C,"  // Title insets assume there is content (and thus have no bottom padding). Use
  // dialog insets to get the bottom margin back.
  set_title_margins(
      ChromeLayoutProvider::Get()->GetInsetsMetric(views::INSETS_DIALOG));
  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
  bubble_icon_ = rb.GetImageSkiaNamed(icon);
  title_text_ = l10n_util::GetStringUTF16(text);

  // Use a normal label's style for the title since there is no content.
  views::Label* title_label =
      static_cast<views::Label*>(GetBubbleFrameView()->title());
  title_label->SetFontList(views::Label::GetDefaultFontList());
  title_label->SetMultiLine(false);
  title_label->SetElideBehavior(gfx::NO_ELIDE);

  SizeToContents();
","  SetLayoutManager(new views::BoxLayout(views::BoxLayout::kHorizontal,
                                        gfx::Insets(kSpacing), kSpacing));
  if (ChromeLayoutProvider::Get()->ShouldShowWindowIcon()) {
    views::ImageView* icon_view = new NonAccessibleImageView();
    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
    icon_view->SetImage(rb.GetImageSkiaNamed(icon));
    AddChildView(icon_view);
  }
  views::Label* label = new views::Label(l10n_util::GetStringUTF16(text));
  label->SetMultiLine(true);
  label->SetAllowCharacterBreak(true);
  label->SetHorizontalAlignment(gfx::ALIGN_LEFT);
  AddChildView(label);
",,"@@ -224,12 +224,16 @@ class InternalPageInfoBubbleView : public views::BubbleDialogDelegateView {
   ~InternalPageInfoBubbleView() override;
 
   // views::BubbleDialogDelegateView:
-  void OnWidgetDestroying(views::Widget* widget) override;
   int GetDialogButtons() const override;
+  base::string16 GetWindowTitle() const override;
+  bool ShouldShowCloseButton() const override;
+  gfx::ImageSkia GetWindowIcon() override;
+  bool ShouldShowWindowIcon() const override;
+  void OnWidgetDestroying(views::Widget* widget) override;
 
  private:
-  // Used around icon and inside bubble border.
-  static constexpr int kSpacing = 12;
+  base::string16 title_text_;
+  gfx::ImageSkia* bubble_icon_;
 
   DISALLOW_COPY_AND_ASSIGN(InternalPageInfoBubbleView);
 };
@@ -411,36 +415,57 @@ InternalPageInfoBubbleView::InternalPageInfoBubbleView(
   set_anchor_view_insets(gfx::Insets(
       GetLayoutConstant(LOCATION_BAR_BUBBLE_ANCHOR_VERTICAL_INSET), 0));
 
-  SetLayoutManager(new views::BoxLayout(views::BoxLayout::kHorizontal,
-                                        gfx::Insets(kSpacing), kSpacing));
+  // Title insets assume there is content (and thus have no bottom padding). Use
+  // dialog insets to get the bottom margin back.
+  set_title_margins(
+      ChromeLayoutProvider::Get()->GetInsetsMetric(views::INSETS_DIALOG));
   set_margins(gfx::Insets());
-  if (ChromeLayoutProvider::Get()->ShouldShowWindowIcon()) {
-    views::ImageView* icon_view = new NonAccessibleImageView();
-    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-    icon_view->SetImage(rb.GetImageSkiaNamed(icon));
-    AddChildView(icon_view);
-  }
 
-  views::Label* label = new views::Label(l10n_util::GetStringUTF16(text));
-  label->SetMultiLine(true);
-  label->SetAllowCharacterBreak(true);
-  label->SetHorizontalAlignment(gfx::ALIGN_LEFT);
-  AddChildView(label);
+  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+  bubble_icon_ = rb.GetImageSkiaNamed(icon);
+  title_text_ = l10n_util::GetStringUTF16(text);
 
   views::BubbleDialogDelegateView::CreateBubble(this);
+
+  // Use a normal label's style for the title since there is no content.
+  views::Label* title_label =
+      static_cast<views::Label*>(GetBubbleFrameView()->title());
+  title_label->SetFontList(views::Label::GetDefaultFontList());
+  title_label->SetMultiLine(false);
+  title_label->SetElideBehavior(gfx::NO_ELIDE);
+
+  SizeToContents();
 }
 
 InternalPageInfoBubbleView::~InternalPageInfoBubbleView() {}
 
+int InternalPageInfoBubbleView::GetDialogButtons() const {
+  return ui::DIALOG_BUTTON_NONE;
+}
+
+base::string16 InternalPageInfoBubbleView::GetWindowTitle() const {
+  return title_text_;
+}
+
+bool InternalPageInfoBubbleView::ShouldShowCloseButton() const {
+  // TODO(patricialor): When Harmony is default, also remove |bubble_icon_| and
+  // supporting code.
+  return ui::MaterialDesignController::IsSecondaryUiMaterial();
+}
+
+gfx::ImageSkia InternalPageInfoBubbleView::GetWindowIcon() {
+  return *bubble_icon_;
+}
+
+bool InternalPageInfoBubbleView::ShouldShowWindowIcon() const {
+  return ChromeLayoutProvider::Get()->ShouldShowWindowIcon();
+}
+
 void InternalPageInfoBubbleView::OnWidgetDestroying(views::Widget* widget) {
   g_shown_bubble_type = PageInfoBubbleView::BUBBLE_NONE;
   g_page_info_bubble = nullptr;
 }
 
-int InternalPageInfoBubbleView::GetDialogButtons() const {
-  return ui::DIALOG_BUTTON_NONE;
-}
-
 ////////////////////////////////////////////////////////////////////////////////
 // PageInfoBubbleView
 ////////////////////////////////////////////////////////////////////////////////",Chrome,acf2f0799f6f732dd70f45ddd252d773be7afd11,d661b2e68b309656837ad7f65e68c673f4bb82ca,1,"InternalPageInfoBubbleView::InternalPageInfoBubbleView(
    views::View* anchor_view,
    const gfx::Rect& anchor_rect,
    gfx::NativeView parent_window,
    const GURL& url)
    : BubbleDialogDelegateView(anchor_view, views::BubbleBorder::TOP_LEFT) {
  g_shown_bubble_type = PageInfoBubbleView::BUBBLE_INTERNAL_PAGE;
  g_page_info_bubble = this;
  set_parent_window(parent_window);
  if (!anchor_view)
    SetAnchorRect(anchor_rect);

  int text = IDS_PAGE_INFO_INTERNAL_PAGE;
  int icon = IDR_PRODUCT_LOGO_16;
  if (url.SchemeIs(extensions::kExtensionScheme)) {
    text = IDS_PAGE_INFO_EXTENSION_PAGE;
    icon = IDR_PLUGINS_FAVICON;
  } else if (url.SchemeIs(content::kViewSourceScheme)) {
    text = IDS_PAGE_INFO_VIEW_SOURCE_PAGE;
    // view-source scheme uses the same icon as chrome:// pages.
    icon = IDR_PRODUCT_LOGO_16;
  } else if (!url.SchemeIs(content::kChromeUIScheme) &&
             !url.SchemeIs(content::kChromeDevToolsScheme)) {
    NOTREACHED();
  }

  // Compensate for built-in vertical padding in the anchor view's image.
   set_anchor_view_insets(gfx::Insets(
       GetLayoutConstant(LOCATION_BAR_BUBBLE_ANCHOR_VERTICAL_INSET), 0));
 
//flaw_line_below:
  SetLayoutManager(new views::BoxLayout(views::BoxLayout::kHorizontal,
//flaw_line_below:
                                        gfx::Insets(kSpacing), kSpacing));
//fix_flaw_line_below:
//  // Title insets assume there is content (and thus have no bottom padding). Use
//fix_flaw_line_below:
//  // dialog insets to get the bottom margin back.
//fix_flaw_line_below:
//  set_title_margins(
//fix_flaw_line_below:
//      ChromeLayoutProvider::Get()->GetInsetsMetric(views::INSETS_DIALOG));
   set_margins(gfx::Insets());
//flaw_line_below:
  if (ChromeLayoutProvider::Get()->ShouldShowWindowIcon()) {
//flaw_line_below:
    views::ImageView* icon_view = new NonAccessibleImageView();
//flaw_line_below:
    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
//flaw_line_below:
    icon_view->SetImage(rb.GetImageSkiaNamed(icon));
//flaw_line_below:
    AddChildView(icon_view);
//flaw_line_below:
  }
 
//flaw_line_below:
  views::Label* label = new views::Label(l10n_util::GetStringUTF16(text));
//flaw_line_below:
  label->SetMultiLine(true);
//flaw_line_below:
  label->SetAllowCharacterBreak(true);
//flaw_line_below:
  label->SetHorizontalAlignment(gfx::ALIGN_LEFT);
//flaw_line_below:
  AddChildView(label);
//fix_flaw_line_below:
//  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
//fix_flaw_line_below:
//  bubble_icon_ = rb.GetImageSkiaNamed(icon);
//fix_flaw_line_below:
//  title_text_ = l10n_util::GetStringUTF16(text);
 
   views::BubbleDialogDelegateView::CreateBubble(this);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  // Use a normal label's style for the title since there is no content.
//fix_flaw_line_below:
//  views::Label* title_label =
//fix_flaw_line_below:
//      static_cast<views::Label*>(GetBubbleFrameView()->title());
//fix_flaw_line_below:
//  title_label->SetFontList(views::Label::GetDefaultFontList());
//fix_flaw_line_below:
//  title_label->SetMultiLine(false);
//fix_flaw_line_below:
//  title_label->SetElideBehavior(gfx::NO_ELIDE);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  SizeToContents();
 }
"
8549,186285,,Remote,Not required,,CVE-2017-5094,https://www.cvedetails.com/cve/CVE-2017-5094/,CWE-704,Medium,,Partial,,2017-10-27,4.3,"Type confusion in extensions JavaScript bindings in Google Chrome prior to 60.0.3112.78 for Mac, Windows, Linux, and Android allowed a remote attacker to potentially maliciously modify objects via a crafted HTML page.",2018-01-04,,18,https://github.com/chromium/chromium/commit/41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c,41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c,"SkiaRenderer: Support changing color space

SkiaOutputSurfaceImpl did not handle the color space changing after it
was created previously. The SkSurfaceCharacterization color space was
only set during the first time Reshape() ran when the charactization is
returned from the GPU thread. If the color space was changed later the
SkSurface and SkDDL color spaces no longer matched and draw failed.

Bug: 1009452
Change-Id: Ib6d2083efc7e7eb6f94782342e92a809b69d6fdc
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1841811
Reviewed-by: Peng Huang <penghuang@chromium.org>
Commit-Queue: kylechar <kylechar@chromium.org>
Cr-Commit-Position: refs/heads/master@{#702946}",9,components/viz/service/display_embedder/skia_output_surface_impl.cc,"{""sha"": ""2e06d978df84358e1db9b704d4bdf275fbfbfd60"", ""filename"": ""components/viz/service/display_embedder/skia_output_surface_impl.cc"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 10, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c/components/viz/service/display_embedder/skia_output_surface_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c/components/viz/service/display_embedder/skia_output_surface_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/viz/service/display_embedder/skia_output_surface_impl.cc?ref=41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c"", ""patch"": ""@@ -193,14 +193,22 @@ void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (initialize_waitable_event_) {\n     initialize_waitable_event_->Wait();\n-    initialize_waitable_event_ = nullptr;\n+    initialize_waitable_event_.reset();\n   }\n \n   SkSurfaceCharacterization* characterization = nullptr;\n   if (characterization_.isValid()) {\n-    // TODO(weiliang): support color space. https://crbug.com/795132\n-    characterization_ =\n-        characterization_.createResized(size.width(), size.height());\n+    sk_sp<SkColorSpace> sk_color_space = color_space.ToSkColorSpace();\n+    if (!SkColorSpace::Equals(characterization_.refColorSpace().get(),\n+                              sk_color_space.get())) {\n+      characterization_ = characterization_.createColorSpace(sk_color_space);\n+    }\n+    if (size.width() != characterization_.width() ||\n+        size.height() != characterization_.height()) {\n+      characterization_ =\n+          characterization_.createResized(size.width(), size.height());\n+    }\n+    // TODO(kylechar): Update |characterization_| if |use_alpha| changes.\n     RecreateRootRecorder();\n   } else {\n     characterization = &characterization_;\n@@ -211,12 +219,12 @@ void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,\n \n   // impl_on_gpu_ is released on the GPU thread by a posted task from\n   // SkiaOutputSurfaceImpl::dtor. So it is safe to use base::Unretained.\n-  auto callback = base::BindOnce(\n-      &SkiaOutputSurfaceImplOnGpu::Reshape,\n-      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,\n-      std::move(color_space), has_alpha, use_stencil, pre_transform_,\n-      characterization, initialize_waitable_event_.get());\n-  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());\n+  auto task = base::BindOnce(&SkiaOutputSurfaceImplOnGpu::Reshape,\n+                             base::Unretained(impl_on_gpu_.get()), size,\n+                             device_scale_factor, color_space, has_alpha,\n+                             use_stencil, pre_transform_, characterization,\n+                             initialize_waitable_event_.get());\n+  ScheduleGpuTask(std::move(task), {});\n }\n \n void SkiaOutputSurfaceImpl::SetUpdateVSyncParametersCallback(""}<_**next**_>{""sha"": ""df9015ce046774c45d6f45db1818fcfbeabbff88"", ""filename"": ""components/viz/service/display_embedder/skia_output_surface_impl_unittest.cc"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 4, ""changes"": 32, ""blob_url"": ""https://github.com/chromium/chromium/blob/41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c/components/viz/service/display_embedder/skia_output_surface_impl_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c/components/viz/service/display_embedder/skia_output_surface_impl_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/viz/service/display_embedder/skia_output_surface_impl_unittest.cc?ref=41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c"", ""patch"": ""@@ -11,13 +11,15 @@\n #include \""base/base64.h\""\n #include \""base/bind.h\""\n #include \""base/command_line.h\""\n+#include \""base/run_loop.h\""\n #include \""base/test/scoped_feature_list.h\""\n #include \""cc/test/fake_output_surface_client.h\""\n #include \""cc/test/pixel_test_utils.h\""\n #include \""components/viz/common/display/renderer_settings.h\""\n #include \""components/viz/common/frame_sinks/copy_output_request.h\""\n #include \""components/viz/common/frame_sinks/copy_output_result.h\""\n #include \""components/viz/common/frame_sinks/copy_output_util.h\""\n+#include \""components/viz/service/display/output_surface_frame.h\""\n #include \""components/viz/service/display_embedder/skia_output_surface_dependency_impl.h\""\n #include \""components/viz/service/gl/gpu_service_impl.h\""\n #include \""components/viz/test/test_gpu_service_holder.h\""\n@@ -197,12 +199,34 @@ TEST_P(SkiaOutputSurfaceImplTest, SubmitPaint) {\n       base::BindOnce(&SkiaOutputSurfaceImplTest::CheckSyncTokenOnGpuThread,\n                      base::Unretained(this), sync_token);\n \n-  std::vector<gpu::SyncToken> resource_sync_tokens;\n-  resource_sync_tokens.push_back(sync_token);\n-  output_surface_->ScheduleGpuTaskForTesting(std::move(closure),\n-                                             std::move(resource_sync_tokens));\n+  output_surface_->ScheduleGpuTaskForTesting(std::move(closure), {sync_token});\n   BlockMainThread();\n   EXPECT_TRUE(on_finished_called);\n }\n \n+// Draws two frames and calls Reshape() between the two frames changing the\n+// color space. Verifies draw after color space change is successful.\n+TEST_P(SkiaOutputSurfaceImplTest, SupportsColorSpaceChange) {\n+  for (auto& color_space : {gfx::ColorSpace(), gfx::ColorSpace::CreateSRGB()}) {\n+    output_surface_->Reshape(kSurfaceRect.size(), 1, color_space,\n+                             /*has_alpha=*/false, /*use_stencil=*/false);\n+\n+    // Draw something, it's not important what.\n+    SkCanvas* root_canvas = output_surface_->BeginPaintCurrentFrame();\n+    SkPaint paint;\n+    paint.setColor(SK_ColorRED);\n+    root_canvas->drawRect(SkRect::MakeWH(10, 10), paint);\n+\n+    base::RunLoop run_loop;\n+    output_surface_->SubmitPaint(run_loop.QuitClosure());\n+\n+    OutputSurfaceFrame frame;\n+    frame.size = kSurfaceRect.size();\n+    output_surface_->SkiaSwapBuffers(std::move(frame),\n+                                     /*wants_sync_token=*/false);\n+\n+    run_loop.Run();\n+  }\n+}\n+\n }  // namespace viz""}","void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
                                    float device_scale_factor,
                                    const gfx::ColorSpace& color_space,
                                    bool has_alpha,
                                    bool use_stencil) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (initialize_waitable_event_) {
     initialize_waitable_event_->Wait();
    initialize_waitable_event_.reset();
   }
 
   SkSurfaceCharacterization* characterization = nullptr;
   if (characterization_.isValid()) {
    sk_sp<SkColorSpace> sk_color_space = color_space.ToSkColorSpace();
    if (!SkColorSpace::Equals(characterization_.refColorSpace().get(),
                              sk_color_space.get())) {
      characterization_ = characterization_.createColorSpace(sk_color_space);
    }
    if (size.width() != characterization_.width() ||
        size.height() != characterization_.height()) {
      characterization_ =
          characterization_.createResized(size.width(), size.height());
    }
    // TODO(kylechar): Update |characterization_| if |use_alpha| changes.
     RecreateRootRecorder();
   } else {
     characterization = &characterization_;
    initialize_waitable_event_ = std::make_unique<base::WaitableEvent>(
        base::WaitableEvent::ResetPolicy::MANUAL,
        base::WaitableEvent::InitialState::NOT_SIGNALED);
  }
 
  auto task = base::BindOnce(&SkiaOutputSurfaceImplOnGpu::Reshape,
                             base::Unretained(impl_on_gpu_.get()), size,
                             device_scale_factor, color_space, has_alpha,
                             use_stencil, pre_transform_, characterization,
                             initialize_waitable_event_.get());
  ScheduleGpuTask(std::move(task), {});
 }
","void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
                                    float device_scale_factor,
                                    const gfx::ColorSpace& color_space,
                                    bool has_alpha,
                                    bool use_stencil) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (initialize_waitable_event_) {
     initialize_waitable_event_->Wait();
    initialize_waitable_event_ = nullptr;
   }
 
   SkSurfaceCharacterization* characterization = nullptr;
   if (characterization_.isValid()) {
    characterization_ =
        characterization_.createResized(size.width(), size.height());
     RecreateRootRecorder();
   } else {
     characterization = &characterization_;
    initialize_waitable_event_ = std::make_unique<base::WaitableEvent>(
        base::WaitableEvent::ResetPolicy::MANUAL,
        base::WaitableEvent::InitialState::NOT_SIGNALED);
  }
 
  auto callback = base::BindOnce(
      &SkiaOutputSurfaceImplOnGpu::Reshape,
      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,
      std::move(color_space), has_alpha, use_stencil, pre_transform_,
      characterization, initialize_waitable_event_.get());
  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());
 }
",C,"    initialize_waitable_event_.reset();
    sk_sp<SkColorSpace> sk_color_space = color_space.ToSkColorSpace();
    if (!SkColorSpace::Equals(characterization_.refColorSpace().get(),
                              sk_color_space.get())) {
      characterization_ = characterization_.createColorSpace(sk_color_space);
    }
    if (size.width() != characterization_.width() ||
        size.height() != characterization_.height()) {
      characterization_ =
          characterization_.createResized(size.width(), size.height());
    }
    // TODO(kylechar): Update |characterization_| if |use_alpha| changes.
  auto task = base::BindOnce(&SkiaOutputSurfaceImplOnGpu::Reshape,
                             base::Unretained(impl_on_gpu_.get()), size,
                             device_scale_factor, color_space, has_alpha,
                             use_stencil, pre_transform_, characterization,
                             initialize_waitable_event_.get());
  ScheduleGpuTask(std::move(task), {});
","    initialize_waitable_event_ = nullptr;
    characterization_ =
        characterization_.createResized(size.width(), size.height());
  auto callback = base::BindOnce(
      &SkiaOutputSurfaceImplOnGpu::Reshape,
      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,
      std::move(color_space), has_alpha, use_stencil, pre_transform_,
      characterization, initialize_waitable_event_.get());
  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());
",,"@@ -193,14 +193,22 @@ void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (initialize_waitable_event_) {
     initialize_waitable_event_->Wait();
-    initialize_waitable_event_ = nullptr;
+    initialize_waitable_event_.reset();
   }
 
   SkSurfaceCharacterization* characterization = nullptr;
   if (characterization_.isValid()) {
-    // TODO(weiliang): support color space. https://crbug.com/795132
-    characterization_ =
-        characterization_.createResized(size.width(), size.height());
+    sk_sp<SkColorSpace> sk_color_space = color_space.ToSkColorSpace();
+    if (!SkColorSpace::Equals(characterization_.refColorSpace().get(),
+                              sk_color_space.get())) {
+      characterization_ = characterization_.createColorSpace(sk_color_space);
+    }
+    if (size.width() != characterization_.width() ||
+        size.height() != characterization_.height()) {
+      characterization_ =
+          characterization_.createResized(size.width(), size.height());
+    }
+    // TODO(kylechar): Update |characterization_| if |use_alpha| changes.
     RecreateRootRecorder();
   } else {
     characterization = &characterization_;
@@ -211,12 +219,12 @@ void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
 
   // impl_on_gpu_ is released on the GPU thread by a posted task from
   // SkiaOutputSurfaceImpl::dtor. So it is safe to use base::Unretained.
-  auto callback = base::BindOnce(
-      &SkiaOutputSurfaceImplOnGpu::Reshape,
-      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,
-      std::move(color_space), has_alpha, use_stencil, pre_transform_,
-      characterization, initialize_waitable_event_.get());
-  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());
+  auto task = base::BindOnce(&SkiaOutputSurfaceImplOnGpu::Reshape,
+                             base::Unretained(impl_on_gpu_.get()), size,
+                             device_scale_factor, color_space, has_alpha,
+                             use_stencil, pre_transform_, characterization,
+                             initialize_waitable_event_.get());
+  ScheduleGpuTask(std::move(task), {});
 }
 
 void SkiaOutputSurfaceImpl::SetUpdateVSyncParametersCallback(",Chrome,41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c,f223cb069262bb1fab90e47669e71d376f9db789,1,"void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
                                    float device_scale_factor,
                                    const gfx::ColorSpace& color_space,
                                    bool has_alpha,
                                    bool use_stencil) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (initialize_waitable_event_) {
     initialize_waitable_event_->Wait();
//flaw_line_below:
    initialize_waitable_event_ = nullptr;
//fix_flaw_line_below:
//    initialize_waitable_event_.reset();
   }
 
   SkSurfaceCharacterization* characterization = nullptr;
   if (characterization_.isValid()) {
//flaw_line_below:
    // TODO(weiliang): support color space. https://crbug.com/795132
//flaw_line_below:
    characterization_ =
//flaw_line_below:
        characterization_.createResized(size.width(), size.height());
//fix_flaw_line_below:
//    sk_sp<SkColorSpace> sk_color_space = color_space.ToSkColorSpace();
//fix_flaw_line_below:
//    if (!SkColorSpace::Equals(characterization_.refColorSpace().get(),
//fix_flaw_line_below:
//                              sk_color_space.get())) {
//fix_flaw_line_below:
//      characterization_ = characterization_.createColorSpace(sk_color_space);
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//    if (size.width() != characterization_.width() ||
//fix_flaw_line_below:
//        size.height() != characterization_.height()) {
//fix_flaw_line_below:
//      characterization_ =
//fix_flaw_line_below:
//          characterization_.createResized(size.width(), size.height());
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//    // TODO(kylechar): Update |characterization_| if |use_alpha| changes.
     RecreateRootRecorder();
   } else {
     characterization = &characterization_;
    initialize_waitable_event_ = std::make_unique<base::WaitableEvent>(
        base::WaitableEvent::ResetPolicy::MANUAL,
        base::WaitableEvent::InitialState::NOT_SIGNALED);
  }
 
   // impl_on_gpu_ is released on the GPU thread by a posted task from
   // SkiaOutputSurfaceImpl::dtor. So it is safe to use base::Unretained.
//flaw_line_below:
  auto callback = base::BindOnce(
//flaw_line_below:
      &SkiaOutputSurfaceImplOnGpu::Reshape,
//flaw_line_below:
      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,
//flaw_line_below:
      std::move(color_space), has_alpha, use_stencil, pre_transform_,
//flaw_line_below:
      characterization, initialize_waitable_event_.get());
//flaw_line_below:
  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());
//fix_flaw_line_below:
//  auto task = base::BindOnce(&SkiaOutputSurfaceImplOnGpu::Reshape,
//fix_flaw_line_below:
//                             base::Unretained(impl_on_gpu_.get()), size,
//fix_flaw_line_below:
//                             device_scale_factor, color_space, has_alpha,
//fix_flaw_line_below:
//                             use_stencil, pre_transform_, characterization,
//fix_flaw_line_below:
//                             initialize_waitable_event_.get());
//fix_flaw_line_below:
//  ScheduleGpuTask(std::move(task), {});
 }
"
8581,186317,,Remote,Not required,Partial,CVE-2017-5108,https://www.cvedetails.com/cve/CVE-2017-5108/,CWE-704,Medium,Partial,Partial,,2017-10-27,6.8,"Type confusion in PDFium in Google Chrome prior to 60.0.3112.78 for Mac, Windows, Linux, and Android allowed a remote attacker to potentially maliciously modify objects via a crafted PDF file.",2018-01-04,,2,https://github.com/chromium/chromium/commit/5cb799a393ba9e732f89f687ff3a322b4514ebfb,5cb799a393ba9e732f89f687ff3a322b4514ebfb,"autofocus: Fix a crash with an autofocus element in a document without browsing context.

ShouldAutofocus() should check existence of the browsing context.
Otherwise, doc.TopFrameOrigin() returns null.

Before crrev.com/695830, ShouldAutofocus() was called only for
rendered elements. That is to say, the document always had
browsing context.

Bug: 1003228
Change-Id: I2a941c34e9707d44869a6d7585dc7fb9f06e3bf4
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1800902
Commit-Queue: Kent Tamura <tkent@chromium.org>
Reviewed-by: Keishi Hattori <keishi@chromium.org>
Cr-Commit-Position: refs/heads/master@{#696291}",0,third_party/blink/renderer/core/html/forms/html_form_control_element.cc,"{""sha"": ""c134f907b1b8df93bd079d25ac525224c83b24db"", ""filename"": ""third_party/blink/renderer/core/html/forms/html_form_control_element.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/5cb799a393ba9e732f89f687ff3a322b4514ebfb/third_party/blink/renderer/core/html/forms/html_form_control_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5cb799a393ba9e732f89f687ff3a322b4514ebfb/third_party/blink/renderer/core/html/forms/html_form_control_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/forms/html_form_control_element.cc?ref=5cb799a393ba9e732f89f687ff3a322b4514ebfb"", ""patch"": ""@@ -234,6 +234,8 @@ static bool ShouldAutofocus(const HTMLFormControlElement* element) {\n   Document& doc = element->GetDocument();\n \n   // 3. If target's browsing context is null, then return.\n+  if (!doc.GetFrame())\n+    return false;\n \n   // 4. If target's active sandboxing flag set has the sandboxed automatic\n   // features browsing context flag, then return.""}<_**next**_>{""sha"": ""104dd5a4a5e371bf5002c7435e718d8e032fff5a"", ""filename"": ""third_party/blink/web_tests/external/wpt/html/semantics/forms/autofocus/skip-not-fully-active.html"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 1, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/5cb799a393ba9e732f89f687ff3a322b4514ebfb/third_party/blink/web_tests/external/wpt/html/semantics/forms/autofocus/skip-not-fully-active.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5cb799a393ba9e732f89f687ff3a322b4514ebfb/third_party/blink/web_tests/external/wpt/html/semantics/forms/autofocus/skip-not-fully-active.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/web_tests/external/wpt/html/semantics/forms/autofocus/skip-not-fully-active.html?ref=5cb799a393ba9e732f89f687ff3a322b4514ebfb"", ""patch"": ""@@ -8,11 +8,19 @@\n <script>\n 'use strict';\n \n+promise_test(async () => {\n+  let doc = document.cloneNode(false);\n+  doc.appendChild(doc.createElement('html'))\n+  doc.firstChild.innerHTML = '<body><input autofocus/></body>';\n+  await waitUntilStableAutofocusState();\n+  assert_equals(doc.activeElement, doc.body);\n+}, 'Autofocus element in not-fully-active document should not be queued.');\n+\n promise_test(async () => {\n   let iframe = document.querySelector('iframe');\n   let iframeDocument = iframe.contentDocument;\n   await waitForLoad(window);\n   assert_not_equals(document.activeElement, iframe);\n   assert_equals(iframeDocument.activeElement, iframeDocument.body);\n-}, 'Autofocus element in not-fully-active document should be skipped.');\n+}, 'Autofocus element in not-fully-active document should be skipped while flusing.');\n </script>""}","static bool ShouldAutofocus(const HTMLFormControlElement* element) {
  if (!element->isConnected())
    return false;
  if (!element->IsAutofocusable())
    return false;



   Document& doc = element->GetDocument();
 
  if (!doc.GetFrame())
    return false;
 
  if (doc.IsSandboxed(WebSandboxFlags::kAutomaticFeatures)) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control because the form's frame is ""
        ""sandboxed and the 'allow-scripts' permission is not set.""));
    return false;
  }

  if (!doc.IsInMainFrame() &&
      !doc.TopFrameOrigin()->CanAccess(doc.GetSecurityOrigin())) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control in a cross-origin subframe.""));
    return false;
  }

  return true;
}
","static bool ShouldAutofocus(const HTMLFormControlElement* element) {
  if (!element->isConnected())
    return false;
  if (!element->IsAutofocusable())
    return false;



   Document& doc = element->GetDocument();
 
 
  if (doc.IsSandboxed(WebSandboxFlags::kAutomaticFeatures)) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control because the form's frame is ""
        ""sandboxed and the 'allow-scripts' permission is not set.""));
    return false;
  }

  if (!doc.IsInMainFrame() &&
      !doc.TopFrameOrigin()->CanAccess(doc.GetSecurityOrigin())) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control in a cross-origin subframe.""));
    return false;
  }

  return true;
}
",C,"  if (!doc.GetFrame())
    return false;
",,,"@@ -234,6 +234,8 @@ static bool ShouldAutofocus(const HTMLFormControlElement* element) {
   Document& doc = element->GetDocument();
 
   // 3. If target's browsing context is null, then return.
+  if (!doc.GetFrame())
+    return false;
 
   // 4. If target's active sandboxing flag set has the sandboxed automatic
   // features browsing context flag, then return.",Chrome,5cb799a393ba9e732f89f687ff3a322b4514ebfb,9c7cd1e691d850ca82244fccd97d91d68b29a1d0,1,"static bool ShouldAutofocus(const HTMLFormControlElement* element) {
  // When an element with the autofocus attribute specified is inserted into a
  // document, run the following steps:
  if (!element->isConnected())
    return false;
  if (!element->IsAutofocusable())
    return false;

  // 1. If the user has indicated (for example, by starting to type in a form
  // control) that they do not wish focus to be changed, then optionally return.

  // We don't implement this optional step. If other browsers have such
  // behavior, we should follow it or standardize it.

  // 2. Let target be the element's node document.
   Document& doc = element->GetDocument();
 
   // 3. If target's browsing context is null, then return.
//fix_flaw_line_below:
//  if (!doc.GetFrame())
//fix_flaw_line_below:
//    return false;
 
   // 4. If target's active sandboxing flag set has the sandboxed automatic
   // features browsing context flag, then return.
  if (doc.IsSandboxed(WebSandboxFlags::kAutomaticFeatures)) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control because the form's frame is ""
        ""sandboxed and the 'allow-scripts' permission is not set.""));
    return false;
  }

  // 5. Let topDocument be the active document of target's browsing context's
  // top-level browsing context.
  // 6. If target's origin is not the same as the origin of topDocument,
  // then return.
  if (!doc.IsInMainFrame() &&
      !doc.TopFrameOrigin()->CanAccess(doc.GetSecurityOrigin())) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control in a cross-origin subframe.""));
    return false;
  }

  // Will call Document::EnqueueAutofocusCandidate() with |element|.
  return true;
}
"
9313,187049,,Remote,Not required,Partial,CVE-2019-5757,https://www.cvedetails.com/cve/CVE-2019-5757/,CWE-704,Medium,Partial,Partial,,2019-02-19,6.8,An incorrect object type assumption in SVG in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to potentially exploit object corruption via a crafted HTML page.,2019-04-18,,2,https://github.com/chromium/chromium/commit/032c3339bfb454c65ce38e7eafe49a54bac83073,032c3339bfb454c65ce38e7eafe49a54bac83073,"Fix SVG crash for v0 distribution into foreignObject.

We require a parent element to be an SVG element for non-svg-root
elements in order to create a LayoutObject for them. However, we checked
the light tree parent element, not the flat tree one which is the parent
for the layout tree construction. Note that this is just an issue in
Shadow DOM v0 since v1 does not allow shadow roots on SVG elements.

Bug: 915469
Change-Id: Id81843abad08814fae747b5bc81c09666583f130
Reviewed-on: https://chromium-review.googlesource.com/c/1382494
Reviewed-by: Fredrik Sderquist <fs@opera.com>
Commit-Queue: Rune Lillesveen <futhark@chromium.org>
Cr-Commit-Position: refs/heads/master@{#617487}",2,third_party/blink/renderer/core/svg/svg_element.cc,"{""sha"": ""b39b8168ec7c68ea811ec1f6f2be9f01a4c76405"", ""filename"": ""third_party/blink/renderer/core/svg/svg_element.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/032c3339bfb454c65ce38e7eafe49a54bac83073/third_party/blink/renderer/core/svg/svg_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/032c3339bfb454c65ce38e7eafe49a54bac83073/third_party/blink/renderer/core/svg/svg_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/svg/svg_element.cc?ref=032c3339bfb454c65ce38e7eafe49a54bac83073"", ""patch"": ""@@ -37,6 +37,7 @@\n #include \""third_party/blink/renderer/core/dom/document.h\""\n #include \""third_party/blink/renderer/core/dom/element_traversal.h\""\n #include \""third_party/blink/renderer/core/dom/events/event.h\""\n+#include \""third_party/blink/renderer/core/dom/flat_tree_traversal.h\""\n #include \""third_party/blink/renderer/core/dom/node_computed_style.h\""\n #include \""third_party/blink/renderer/core/dom/shadow_root.h\""\n #include \""third_party/blink/renderer/core/frame/csp/content_security_policy.h\""\n@@ -1034,10 +1035,8 @@ bool SVGElement::LayoutObjectIsNeeded(const ComputedStyle& style) const {\n }\n \n bool SVGElement::HasSVGParent() const {\n-  // Should we use the flat tree parent instead? If so, we should probably fix a\n-  // few other checks.\n-  return ParentOrShadowHostElement() &&\n-         ParentOrShadowHostElement()->IsSVGElement();\n+  Element* parent = FlatTreeTraversal::ParentElement(*this);\n+  return parent && parent->IsSVGElement();\n }\n \n MutableCSSPropertyValueSet* SVGElement::AnimatedSMILStyleProperties() const {""}<_**next**_>{""sha"": ""44ac3b0540b8f5a816a67b5be382b179623bd0cd"", ""filename"": ""third_party/blink/web_tests/svg/foreignObject/shadow-dom-v0-crash.html"", ""status"": ""added"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/032c3339bfb454c65ce38e7eafe49a54bac83073/third_party/blink/web_tests/svg/foreignObject/shadow-dom-v0-crash.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/032c3339bfb454c65ce38e7eafe49a54bac83073/third_party/blink/web_tests/svg/foreignObject/shadow-dom-v0-crash.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/web_tests/svg/foreignObject/shadow-dom-v0-crash.html?ref=032c3339bfb454c65ce38e7eafe49a54bac83073"", ""patch"": ""@@ -0,0 +1,11 @@\n+<!DOCTYPE html>\n+<script src=\""../../resources/testharness.js\""></script>\n+<script src=\""../../resources/testharnessreport.js\""></script>\n+<p>PASS if no crash or DCHECK failure.</p>\n+<svg id=\""svg\""><g /></svg>\n+<script>\n+  test(() => {\n+    const root = svg.createShadowRoot();\n+    root.innerHTML = '<foreignObject><div><content></content></div></foreignObject>';\n+  }, \""Rendering an svg g element distributed into a foreignObject will crash.\"");\n+</script>""}"," bool SVGElement::HasSVGParent() const {
  Element* parent = FlatTreeTraversal::ParentElement(*this);
  return parent && parent->IsSVGElement();
 }
"," bool SVGElement::HasSVGParent() const {
  return ParentOrShadowHostElement() &&
         ParentOrShadowHostElement()->IsSVGElement();
 }
",C,"  Element* parent = FlatTreeTraversal::ParentElement(*this);
  return parent && parent->IsSVGElement();
","  return ParentOrShadowHostElement() &&
         ParentOrShadowHostElement()->IsSVGElement();
",,"@@ -37,6 +37,7 @@
 #include ""third_party/blink/renderer/core/dom/document.h""
 #include ""third_party/blink/renderer/core/dom/element_traversal.h""
 #include ""third_party/blink/renderer/core/dom/events/event.h""
+#include ""third_party/blink/renderer/core/dom/flat_tree_traversal.h""
 #include ""third_party/blink/renderer/core/dom/node_computed_style.h""
 #include ""third_party/blink/renderer/core/dom/shadow_root.h""
 #include ""third_party/blink/renderer/core/frame/csp/content_security_policy.h""
@@ -1034,10 +1035,8 @@ bool SVGElement::LayoutObjectIsNeeded(const ComputedStyle& style) const {
 }
 
 bool SVGElement::HasSVGParent() const {
-  // Should we use the flat tree parent instead? If so, we should probably fix a
-  // few other checks.
-  return ParentOrShadowHostElement() &&
-         ParentOrShadowHostElement()->IsSVGElement();
+  Element* parent = FlatTreeTraversal::ParentElement(*this);
+  return parent && parent->IsSVGElement();
 }
 
 MutableCSSPropertyValueSet* SVGElement::AnimatedSMILStyleProperties() const {",Chrome,032c3339bfb454c65ce38e7eafe49a54bac83073,7917a910e959b8e46a16cde1391d2b681e64d4a8,1," bool SVGElement::HasSVGParent() const {
//flaw_line_below:
  // Should we use the flat tree parent instead? If so, we should probably fix a
//flaw_line_below:
  // few other checks.
//flaw_line_below:
  return ParentOrShadowHostElement() &&
//flaw_line_below:
         ParentOrShadowHostElement()->IsSVGElement();
//fix_flaw_line_below:
//  Element* parent = FlatTreeTraversal::ParentElement(*this);
//fix_flaw_line_below:
//  return parent && parent->IsSVGElement();
 }
"
10380,188116,,Remote,Not required,Complete,CVE-2018-9490,https://www.cvedetails.com/cve/CVE-2018-9490/,CWE-704,Medium,Complete,Complete,,2018-10-02,9.3,"In CollectValuesOrEntriesImpl of elements.cc, there is possible remote code execution due to type confusion. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android. Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111274046",2018-12-28,Exec Code ,36,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb,a24543157ae2cdd25da43e20f4e48a07481e6ceb,"Backport: Fix Object.entries/values with changing elements

Bug: 111274046
Test: m -j proxy_resolver_v8_unittest && adb sync && adb shell \
/data/nativetest64/proxy_resolver_v8_unittest/proxy_resolver_v8_unittest
Change-Id: I705fc512cc5837e9364ed187559cc75d079aa5cb
(cherry picked from commit d8be9a10287afed07705ac8af027d6a46d4def99)
",5,src/elements.cc,"{""filename"": ""src/elements.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/src/elements.cc"", ""patch"": ""@@ -511,6 +511,21 @@\n\n   return Just<int64_t>(-1);\n }\n \n+// The InternalElementsAccessor is a helper class to expose otherwise protected\n+// methods to its subclasses. Namely, we don't want to publicly expose methods\n+// that take an entry (instead of an index) as an argument.\n+class InternalElementsAccessor : public ElementsAccessor {\n+ public:\n+  explicit InternalElementsAccessor(const char* name)\n+      : ElementsAccessor(name) {}\n+\n+  virtual uint32_t GetEntryForIndex(Isolate* isolate, JSObject* holder,\n+                                    FixedArrayBase* backing_store,\n+                                    uint32_t index) = 0;\n+\n+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n+};\n+\n // Base class for element handler implementations. Contains the\n // the common logic for objects with different ElementsKinds.\n // Subclasses must specialize method for which the element\n@@ -529,10 +544,10 @@\n\n // CRTP to guarantee aggressive compile time optimizations (i.e.  inlining and\n // specialization of SomeElementsAccessor methods).\n template <typename Subclass, typename ElementsTraitsParam>\n-class ElementsAccessorBase : public ElementsAccessor {\n+class ElementsAccessorBase : public InternalElementsAccessor {\n  public:\n   explicit ElementsAccessorBase(const char* name)\n-      : ElementsAccessor(name) { }\n+      : InternalElementsAccessor(name) {}\n \n   typedef ElementsTraitsParam ElementsTraits;\n   typedef typename ElementsTraitsParam::BackingStore BackingStore;\n@@ -1014,35 +1029,66 @@\n\n       Isolate* isolate, Handle<JSObject> object,\n       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,\n       PropertyFilter filter) {\n-    int count = 0;\n+    DCHECK_EQ(*nof_items, 0);\n     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,\n                                ALL_PROPERTIES);\n     Subclass::CollectElementIndicesImpl(\n         object, handle(object->elements(), isolate), &accumulator);\n     Handle<FixedArray> keys = accumulator.GetKeys();\n \n-    for (int i = 0; i < keys->length(); ++i) {\n+    int count = 0;\n+    int i = 0;\n+    Handle<Map> original_map(object->map(), isolate);\n+\n+    for (; i < keys->length(); ++i) {\n       Handle<Object> key(keys->get(i), isolate);\n-      Handle<Object> value;\n       uint32_t index;\n       if (!key->ToUint32(&index)) continue;\n \n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = Subclass::GetEntryForIndexImpl(\n           isolate, *object, object->elements(), index, filter);\n       if (entry == kMaxUInt32) continue;\n \n       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);\n \n+      Handle<Object> value;\n       if (details.kind() == kData) {\n         value = Subclass::GetImpl(isolate, object->elements(), entry);\n       } else {\n+        // This might modify the elements and/or change the elements kind.\n         LookupIterator it(isolate, object, index, LookupIterator::OWN);\n         ASSIGN_RETURN_ON_EXCEPTION_VALUE(\n             isolate, value, Object::GetProperty(&it), Nothing<bool>());\n       }\n-      if (get_entries) {\n-        value = MakeEntryPair(isolate, index, value);\n+      if (get_entries) value = MakeEntryPair(isolate, index, value);\n+      values_or_entries->set(count++, *value);\n+      if (object->map() != *original_map) break;\n+    }\n+\n+    // Slow path caused by changes in elements kind during iteration.\n+    for (; i < keys->length(); i++) {\n+      Handle<Object> key(keys->get(i), isolate);\n+      uint32_t index;\n+      if (!key->ToUint32(&index)) continue;\n+\n+      if (filter & ONLY_ENUMERABLE) {\n+        InternalElementsAccessor* accessor =\n+            reinterpret_cast<InternalElementsAccessor*>(\n+                object->GetElementsAccessor());\n+        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,\n+                                                    object->elements(), index);\n+        if (entry == kMaxUInt32) continue;\n+        PropertyDetails details = accessor->GetDetails(*object, entry);\n+        if (!details.IsEnumerable()) continue;\n       }\n+\n+      Handle<Object> value;\n+      LookupIterator it(isolate, object, index, LookupIterator::OWN);\n+      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),\n+                                       Nothing<bool>());\n+\n+      if (get_entries) value = MakeEntryPair(isolate, index, value);\n       values_or_entries->set(count++, *value);\n     }\n \n@@ -1623,12 +1669,13 @@\n\n         return result;\n       }\n     }\n-\n+    Handle<Map> original_map(receiver->map(), isolate);\n     Handle<SeededNumberDictionary> dictionary(\n         SeededNumberDictionary::cast(receiver->elements()), isolate);\n     // Iterate through entire range, as accessing elements out of order is\n     // observable\n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(receiver->map(), *original_map);\n       int entry = dictionary->FindEntry(isolate, k);\n       if (entry == SeededNumberDictionary::kNotFound) {\n         if (search_for_hole) return Just(true);\n@@ -1690,11 +1737,13 @@\n\n                                          uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));\n \n+    Handle<Map> original_map(receiver->map(), isolate);\n     Handle<SeededNumberDictionary> dictionary(\n         SeededNumberDictionary::cast(receiver->elements()), isolate);\n     // Iterate through entire range, as accessing elements out of order is\n     // observable.\n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(receiver->map(), *original_map);\n       int entry = dictionary->FindEntry(isolate, k);\n       if (entry == SeededNumberDictionary::kNotFound) {\n         continue;\n@@ -3170,12 +3219,13 @@\n\n                                        Handle<Object> value,\n                                        uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n-    Handle<Map> original_map = handle(object->map(), isolate);\n+    Handle<Map> original_map(object->map(), isolate);\n     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                      isolate);\n     bool search_for_hole = value->IsUndefined(isolate);\n \n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                             ALL_PROPERTIES);\n       if (entry == kMaxUInt32) {\n@@ -3212,11 +3262,12 @@\n\n                                          Handle<Object> value,\n                                          uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n-    Handle<Map> original_map = handle(object->map(), isolate);\n+    Handle<Map> original_map(object->map(), isolate);\n     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                      isolate);\n \n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                             ALL_PROPERTIES);\n       if (entry == kMaxUInt32) {\n""}<_**next**_>{""filename"": ""src/elements.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/src/elements.h"", ""patch"": ""@@ -54,7 +54,6 @@\n\n \n   virtual Handle<Object> Get(Handle<JSObject> holder, uint32_t entry) = 0;\n \n-  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n   virtual bool HasAccessors(JSObject* holder) = 0;\n   virtual uint32_t NumberOfElements(JSObject* holder) = 0;\n \n@@ -65,9 +64,6 @@\n\n   // element that is non-deletable.\n   virtual void SetLength(Handle<JSArray> holder, uint32_t new_length) = 0;\n \n-  // Deletes an element in an object.\n-  virtual void Delete(Handle<JSObject> holder, uint32_t entry) = 0;\n-\n   // If kCopyToEnd is specified as the copy_size to CopyElements, it copies all\n   // of elements from source after source_start to the destination array.\n   static const int kCopyToEnd = -1;\n@@ -124,11 +120,6 @@\n\n \n   virtual void Set(Handle<JSObject> holder, uint32_t entry, Object* value) = 0;\n \n-  virtual void Reconfigure(Handle<JSObject> object,\n-                           Handle<FixedArrayBase> backing_store, uint32_t entry,\n-                           Handle<Object> value,\n-                           PropertyAttributes attributes) = 0;\n-\n   virtual void Add(Handle<JSObject> object, uint32_t index,\n                    Handle<Object> value, PropertyAttributes attributes,\n                    uint32_t new_capacity) = 0;\n@@ -193,6 +184,15 @@\n\n                                     FixedArrayBase* backing_store,\n                                     uint32_t index) = 0;\n \n+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n+  virtual void Reconfigure(Handle<JSObject> object,\n+                           Handle<FixedArrayBase> backing_store, uint32_t entry,\n+                           Handle<Object> value,\n+                           PropertyAttributes attributes) = 0;\n+\n+  // Deletes an element in an object.\n+  virtual void Delete(Handle<JSObject> holder, uint32_t entry) = 0;\n+\n   // NOTE: this method violates the handlified function signature convention:\n   // raw pointer parameter |source_holder| in the function that allocates.\n   // This is done intentionally to avoid ArrayConcat() builtin performance\n""}"," static Maybe<bool> CollectValuesOrEntriesImpl(

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
    DCHECK_EQ(*nof_items, 0);
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
    int count = 0;
    int i = 0;
    Handle<Map> original_map(object->map(), isolate);

    for (; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
      Handle<Object> value;
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
        // This might modify the elements and/or change the elements kind.
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
      if (get_entries) value = MakeEntryPair(isolate, index, value);
      values_or_entries->set(count++, *value);
      if (object->map() != *original_map) break;
    }

    // Slow path caused by changes in elements kind during iteration.
    for (; i < keys->length(); i++) {
      Handle<Object> key(keys->get(i), isolate);
      uint32_t index;
      if (!key->ToUint32(&index)) continue;

      if (filter & ONLY_ENUMERABLE) {
        InternalElementsAccessor* accessor =
            reinterpret_cast<InternalElementsAccessor*>(
                object->GetElementsAccessor());
        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,
                                                    object->elements(), index);
        if (entry == kMaxUInt32) continue;
        PropertyDetails details = accessor->GetDetails(*object, entry);
        if (!details.IsEnumerable()) continue;
       }

      Handle<Object> value;
      LookupIterator it(isolate, object, index, LookupIterator::OWN);
      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
                                       Nothing<bool>());

      if (get_entries) value = MakeEntryPair(isolate, index, value);
       values_or_entries->set(count++, *value);
     }
 
 *nof_items = count;
 return Just(true);
 }
"," static Maybe<bool> CollectValuesOrEntriesImpl(

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
    int count = 0;
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
    for (int i = 0; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
      Handle<Object> value;
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
      if (get_entries) {
        value = MakeEntryPair(isolate, index, value);
       }
       values_or_entries->set(count++, *value);
     }
 
 *nof_items = count;
 return Just(true);
 }
",C,"    DCHECK_EQ(*nof_items, 0);
    int count = 0;
    int i = 0;
    Handle<Map> original_map(object->map(), isolate);

    for (; i < keys->length(); ++i) {
      DCHECK_EQ(object->map(), *original_map);
      Handle<Object> value;
        // This might modify the elements and/or change the elements kind.
      if (get_entries) value = MakeEntryPair(isolate, index, value);
      values_or_entries->set(count++, *value);
      if (object->map() != *original_map) break;
    }

    // Slow path caused by changes in elements kind during iteration.
    for (; i < keys->length(); i++) {
      Handle<Object> key(keys->get(i), isolate);
      uint32_t index;
      if (!key->ToUint32(&index)) continue;

      if (filter & ONLY_ENUMERABLE) {
        InternalElementsAccessor* accessor =
            reinterpret_cast<InternalElementsAccessor*>(
                object->GetElementsAccessor());
        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,
                                                    object->elements(), index);
        if (entry == kMaxUInt32) continue;
        PropertyDetails details = accessor->GetDetails(*object, entry);
        if (!details.IsEnumerable()) continue;

      Handle<Object> value;
      LookupIterator it(isolate, object, index, LookupIterator::OWN);
      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
                                       Nothing<bool>());

      if (get_entries) value = MakeEntryPair(isolate, index, value);
","    int count = 0;
    for (int i = 0; i < keys->length(); ++i) {
      Handle<Object> value;
      if (get_entries) {
        value = MakeEntryPair(isolate, index, value);
",,"@@ -511,6 +511,21 @@

   return Just<int64_t>(-1);
 }
 
+// The InternalElementsAccessor is a helper class to expose otherwise protected
+// methods to its subclasses. Namely, we don't want to publicly expose methods
+// that take an entry (instead of an index) as an argument.
+class InternalElementsAccessor : public ElementsAccessor {
+ public:
+  explicit InternalElementsAccessor(const char* name)
+      : ElementsAccessor(name) {}
+
+  virtual uint32_t GetEntryForIndex(Isolate* isolate, JSObject* holder,
+                                    FixedArrayBase* backing_store,
+                                    uint32_t index) = 0;
+
+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;
+};
+
 // Base class for element handler implementations. Contains the
 // the common logic for objects with different ElementsKinds.
 // Subclasses must specialize method for which the element
@@ -529,10 +544,10 @@

 // CRTP to guarantee aggressive compile time optimizations (i.e.  inlining and
 // specialization of SomeElementsAccessor methods).
 template <typename Subclass, typename ElementsTraitsParam>
-class ElementsAccessorBase : public ElementsAccessor {
+class ElementsAccessorBase : public InternalElementsAccessor {
  public:
   explicit ElementsAccessorBase(const char* name)
-      : ElementsAccessor(name) { }
+      : InternalElementsAccessor(name) {}
 
   typedef ElementsTraitsParam ElementsTraits;
   typedef typename ElementsTraitsParam::BackingStore BackingStore;
@@ -1014,35 +1029,66 @@

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
-    int count = 0;
+    DCHECK_EQ(*nof_items, 0);
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
-    for (int i = 0; i < keys->length(); ++i) {
+    int count = 0;
+    int i = 0;
+    Handle<Map> original_map(object->map(), isolate);
+
+    for (; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
-      Handle<Object> value;
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
+      Handle<Object> value;
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
+        // This might modify the elements and/or change the elements kind.
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
-      if (get_entries) {
-        value = MakeEntryPair(isolate, index, value);
+      if (get_entries) value = MakeEntryPair(isolate, index, value);
+      values_or_entries->set(count++, *value);
+      if (object->map() != *original_map) break;
+    }
+
+    // Slow path caused by changes in elements kind during iteration.
+    for (; i < keys->length(); i++) {
+      Handle<Object> key(keys->get(i), isolate);
+      uint32_t index;
+      if (!key->ToUint32(&index)) continue;
+
+      if (filter & ONLY_ENUMERABLE) {
+        InternalElementsAccessor* accessor =
+            reinterpret_cast<InternalElementsAccessor*>(
+                object->GetElementsAccessor());
+        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,
+                                                    object->elements(), index);
+        if (entry == kMaxUInt32) continue;
+        PropertyDetails details = accessor->GetDetails(*object, entry);
+        if (!details.IsEnumerable()) continue;
       }
+
+      Handle<Object> value;
+      LookupIterator it(isolate, object, index, LookupIterator::OWN);
+      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
+                                       Nothing<bool>());
+
+      if (get_entries) value = MakeEntryPair(isolate, index, value);
       values_or_entries->set(count++, *value);
     }
 
@@ -1623,12 +1669,13 @@

         return result;
       }
     }
-
+    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     // Iterate through entire range, as accessing elements out of order is
     // observable
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         if (search_for_hole) return Just(true);
@@ -1690,11 +1737,13 @@

                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
 
+    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     // Iterate through entire range, as accessing elements out of order is
     // observable.
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         continue;
@@ -3170,12 +3219,13 @@

                                        Handle<Object> value,
                                        uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
-    Handle<Map> original_map = handle(object->map(), isolate);
+    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
     bool search_for_hole = value->IsUndefined(isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
@@ -3212,11 +3262,12 @@

                                          Handle<Object> value,
                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
-    Handle<Map> original_map = handle(object->map(), isolate);
+    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
",Android,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb%5E/,1," static Maybe<bool> CollectValuesOrEntriesImpl(

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
//flaw_line_below:
    int count = 0;
//fix_flaw_line_below:
//    DCHECK_EQ(*nof_items, 0);
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
//flaw_line_below:
    for (int i = 0; i < keys->length(); ++i) {
//fix_flaw_line_below:
//    int count = 0;
//fix_flaw_line_below:
//    int i = 0;
//fix_flaw_line_below:
//    Handle<Map> original_map(object->map(), isolate);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    for (; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
//flaw_line_below:
      Handle<Object> value;
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
//fix_flaw_line_below:
//      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
//fix_flaw_line_below:
//      Handle<Object> value;
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
//fix_flaw_line_below:
//        // This might modify the elements and/or change the elements kind.
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
//flaw_line_below:
      if (get_entries) {
//flaw_line_below:
        value = MakeEntryPair(isolate, index, value);
//fix_flaw_line_below:
//      if (get_entries) value = MakeEntryPair(isolate, index, value);
//fix_flaw_line_below:
//      values_or_entries->set(count++, *value);
//fix_flaw_line_below:
//      if (object->map() != *original_map) break;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    // Slow path caused by changes in elements kind during iteration.
//fix_flaw_line_below:
//    for (; i < keys->length(); i++) {
//fix_flaw_line_below:
//      Handle<Object> key(keys->get(i), isolate);
//fix_flaw_line_below:
//      uint32_t index;
//fix_flaw_line_below:
//      if (!key->ToUint32(&index)) continue;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//      if (filter & ONLY_ENUMERABLE) {
//fix_flaw_line_below:
//        InternalElementsAccessor* accessor =
//fix_flaw_line_below:
//            reinterpret_cast<InternalElementsAccessor*>(
//fix_flaw_line_below:
//                object->GetElementsAccessor());
//fix_flaw_line_below:
//        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,
//fix_flaw_line_below:
//                                                    object->elements(), index);
//fix_flaw_line_below:
//        if (entry == kMaxUInt32) continue;
//fix_flaw_line_below:
//        PropertyDetails details = accessor->GetDetails(*object, entry);
//fix_flaw_line_below:
//        if (!details.IsEnumerable()) continue;
       }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//      Handle<Object> value;
//fix_flaw_line_below:
//      LookupIterator it(isolate, object, index, LookupIterator::OWN);
//fix_flaw_line_below:
//      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
//fix_flaw_line_below:
//                                       Nothing<bool>());
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//      if (get_entries) value = MakeEntryPair(isolate, index, value);
       values_or_entries->set(count++, *value);
     }
 
 *nof_items = count;
 return Just(true);
 }
"
10381,188117,,Remote,Not required,Complete,CVE-2018-9490,https://www.cvedetails.com/cve/CVE-2018-9490/,CWE-704,Medium,Complete,Complete,,2018-10-02,9.3,"In CollectValuesOrEntriesImpl of elements.cc, there is possible remote code execution due to type confusion. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android. Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111274046",2018-12-28,Exec Code ,0,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb,a24543157ae2cdd25da43e20f4e48a07481e6ceb,"Backport: Fix Object.entries/values with changing elements

Bug: 111274046
Test: m -j proxy_resolver_v8_unittest && adb sync && adb shell \
/data/nativetest64/proxy_resolver_v8_unittest/proxy_resolver_v8_unittest
Change-Id: I705fc512cc5837e9364ed187559cc75d079aa5cb
(cherry picked from commit d8be9a10287afed07705ac8af027d6a46d4def99)
",1,src/elements.cc,"{""filename"": ""src/elements.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/src/elements.cc"", ""patch"": ""@@ -511,6 +511,21 @@\n\n   return Just<int64_t>(-1);\n }\n \n+// The InternalElementsAccessor is a helper class to expose otherwise protected\n+// methods to its subclasses. Namely, we don't want to publicly expose methods\n+// that take an entry (instead of an index) as an argument.\n+class InternalElementsAccessor : public ElementsAccessor {\n+ public:\n+  explicit InternalElementsAccessor(const char* name)\n+      : ElementsAccessor(name) {}\n+\n+  virtual uint32_t GetEntryForIndex(Isolate* isolate, JSObject* holder,\n+                                    FixedArrayBase* backing_store,\n+                                    uint32_t index) = 0;\n+\n+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n+};\n+\n // Base class for element handler implementations. Contains the\n // the common logic for objects with different ElementsKinds.\n // Subclasses must specialize method for which the element\n@@ -529,10 +544,10 @@\n\n // CRTP to guarantee aggressive compile time optimizations (i.e.  inlining and\n // specialization of SomeElementsAccessor methods).\n template <typename Subclass, typename ElementsTraitsParam>\n-class ElementsAccessorBase : public ElementsAccessor {\n+class ElementsAccessorBase : public InternalElementsAccessor {\n  public:\n   explicit ElementsAccessorBase(const char* name)\n-      : ElementsAccessor(name) { }\n+      : InternalElementsAccessor(name) {}\n \n   typedef ElementsTraitsParam ElementsTraits;\n   typedef typename ElementsTraitsParam::BackingStore BackingStore;\n@@ -1014,35 +1029,66 @@\n\n       Isolate* isolate, Handle<JSObject> object,\n       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,\n       PropertyFilter filter) {\n-    int count = 0;\n+    DCHECK_EQ(*nof_items, 0);\n     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,\n                                ALL_PROPERTIES);\n     Subclass::CollectElementIndicesImpl(\n         object, handle(object->elements(), isolate), &accumulator);\n     Handle<FixedArray> keys = accumulator.GetKeys();\n \n-    for (int i = 0; i < keys->length(); ++i) {\n+    int count = 0;\n+    int i = 0;\n+    Handle<Map> original_map(object->map(), isolate);\n+\n+    for (; i < keys->length(); ++i) {\n       Handle<Object> key(keys->get(i), isolate);\n-      Handle<Object> value;\n       uint32_t index;\n       if (!key->ToUint32(&index)) continue;\n \n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = Subclass::GetEntryForIndexImpl(\n           isolate, *object, object->elements(), index, filter);\n       if (entry == kMaxUInt32) continue;\n \n       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);\n \n+      Handle<Object> value;\n       if (details.kind() == kData) {\n         value = Subclass::GetImpl(isolate, object->elements(), entry);\n       } else {\n+        // This might modify the elements and/or change the elements kind.\n         LookupIterator it(isolate, object, index, LookupIterator::OWN);\n         ASSIGN_RETURN_ON_EXCEPTION_VALUE(\n             isolate, value, Object::GetProperty(&it), Nothing<bool>());\n       }\n-      if (get_entries) {\n-        value = MakeEntryPair(isolate, index, value);\n+      if (get_entries) value = MakeEntryPair(isolate, index, value);\n+      values_or_entries->set(count++, *value);\n+      if (object->map() != *original_map) break;\n+    }\n+\n+    // Slow path caused by changes in elements kind during iteration.\n+    for (; i < keys->length(); i++) {\n+      Handle<Object> key(keys->get(i), isolate);\n+      uint32_t index;\n+      if (!key->ToUint32(&index)) continue;\n+\n+      if (filter & ONLY_ENUMERABLE) {\n+        InternalElementsAccessor* accessor =\n+            reinterpret_cast<InternalElementsAccessor*>(\n+                object->GetElementsAccessor());\n+        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,\n+                                                    object->elements(), index);\n+        if (entry == kMaxUInt32) continue;\n+        PropertyDetails details = accessor->GetDetails(*object, entry);\n+        if (!details.IsEnumerable()) continue;\n       }\n+\n+      Handle<Object> value;\n+      LookupIterator it(isolate, object, index, LookupIterator::OWN);\n+      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),\n+                                       Nothing<bool>());\n+\n+      if (get_entries) value = MakeEntryPair(isolate, index, value);\n       values_or_entries->set(count++, *value);\n     }\n \n@@ -1623,12 +1669,13 @@\n\n         return result;\n       }\n     }\n-\n+    Handle<Map> original_map(receiver->map(), isolate);\n     Handle<SeededNumberDictionary> dictionary(\n         SeededNumberDictionary::cast(receiver->elements()), isolate);\n     // Iterate through entire range, as accessing elements out of order is\n     // observable\n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(receiver->map(), *original_map);\n       int entry = dictionary->FindEntry(isolate, k);\n       if (entry == SeededNumberDictionary::kNotFound) {\n         if (search_for_hole) return Just(true);\n@@ -1690,11 +1737,13 @@\n\n                                          uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));\n \n+    Handle<Map> original_map(receiver->map(), isolate);\n     Handle<SeededNumberDictionary> dictionary(\n         SeededNumberDictionary::cast(receiver->elements()), isolate);\n     // Iterate through entire range, as accessing elements out of order is\n     // observable.\n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(receiver->map(), *original_map);\n       int entry = dictionary->FindEntry(isolate, k);\n       if (entry == SeededNumberDictionary::kNotFound) {\n         continue;\n@@ -3170,12 +3219,13 @@\n\n                                        Handle<Object> value,\n                                        uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n-    Handle<Map> original_map = handle(object->map(), isolate);\n+    Handle<Map> original_map(object->map(), isolate);\n     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                      isolate);\n     bool search_for_hole = value->IsUndefined(isolate);\n \n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                             ALL_PROPERTIES);\n       if (entry == kMaxUInt32) {\n@@ -3212,11 +3262,12 @@\n\n                                          Handle<Object> value,\n                                          uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n-    Handle<Map> original_map = handle(object->map(), isolate);\n+    Handle<Map> original_map(object->map(), isolate);\n     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                      isolate);\n \n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                             ALL_PROPERTIES);\n       if (entry == kMaxUInt32) {\n""}<_**next**_>{""filename"": ""src/elements.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/src/elements.h"", ""patch"": ""@@ -54,7 +54,6 @@\n\n \n   virtual Handle<Object> Get(Handle<JSObject> holder, uint32_t entry) = 0;\n \n-  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n   virtual bool HasAccessors(JSObject* holder) = 0;\n   virtual uint32_t NumberOfElements(JSObject* holder) = 0;\n \n@@ -65,9 +64,6 @@\n\n   // element that is non-deletable.\n   virtual void SetLength(Handle<JSArray> holder, uint32_t new_length) = 0;\n \n-  // Deletes an element in an object.\n-  virtual void Delete(Handle<JSObject> holder, uint32_t entry) = 0;\n-\n   // If kCopyToEnd is specified as the copy_size to CopyElements, it copies all\n   // of elements from source after source_start to the destination array.\n   static const int kCopyToEnd = -1;\n@@ -124,11 +120,6 @@\n\n \n   virtual void Set(Handle<JSObject> holder, uint32_t entry, Object* value) = 0;\n \n-  virtual void Reconfigure(Handle<JSObject> object,\n-                           Handle<FixedArrayBase> backing_store, uint32_t entry,\n-                           Handle<Object> value,\n-                           PropertyAttributes attributes) = 0;\n-\n   virtual void Add(Handle<JSObject> object, uint32_t index,\n                    Handle<Object> value, PropertyAttributes attributes,\n                    uint32_t new_capacity) = 0;\n@@ -193,6 +184,15 @@\n\n                                     FixedArrayBase* backing_store,\n                                     uint32_t index) = 0;\n \n+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n+  virtual void Reconfigure(Handle<JSObject> object,\n+                           Handle<FixedArrayBase> backing_store, uint32_t entry,\n+                           Handle<Object> value,\n+                           PropertyAttributes attributes) = 0;\n+\n+  // Deletes an element in an object.\n+  virtual void Delete(Handle<JSObject> holder, uint32_t entry) = 0;\n+\n   // NOTE: this method violates the handlified function signature convention:\n   // raw pointer parameter |source_holder| in the function that allocates.\n   // This is done intentionally to avoid ArrayConcat() builtin performance\n""}","   explicit ElementsAccessorBase(const char* name)
","   explicit ElementsAccessorBase(const char* name)
      : ElementsAccessor(name) { }
",C,,"      : ElementsAccessor(name) { }
",,"@@ -511,6 +511,21 @@

   return Just<int64_t>(-1);
 }
 
+// The InternalElementsAccessor is a helper class to expose otherwise protected
+// methods to its subclasses. Namely, we don't want to publicly expose methods
+// that take an entry (instead of an index) as an argument.
+class InternalElementsAccessor : public ElementsAccessor {
+ public:
+  explicit InternalElementsAccessor(const char* name)
+      : ElementsAccessor(name) {}
+
+  virtual uint32_t GetEntryForIndex(Isolate* isolate, JSObject* holder,
+                                    FixedArrayBase* backing_store,
+                                    uint32_t index) = 0;
+
+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;
+};
+
 // Base class for element handler implementations. Contains the
 // the common logic for objects with different ElementsKinds.
 // Subclasses must specialize method for which the element
@@ -529,10 +544,10 @@

 // CRTP to guarantee aggressive compile time optimizations (i.e.  inlining and
 // specialization of SomeElementsAccessor methods).
 template <typename Subclass, typename ElementsTraitsParam>
-class ElementsAccessorBase : public ElementsAccessor {
+class ElementsAccessorBase : public InternalElementsAccessor {
  public:
   explicit ElementsAccessorBase(const char* name)
-      : ElementsAccessor(name) { }
+      : InternalElementsAccessor(name) {}
 
   typedef ElementsTraitsParam ElementsTraits;
   typedef typename ElementsTraitsParam::BackingStore BackingStore;
@@ -1014,35 +1029,66 @@

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
-    int count = 0;
+    DCHECK_EQ(*nof_items, 0);
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
-    for (int i = 0; i < keys->length(); ++i) {
+    int count = 0;
+    int i = 0;
+    Handle<Map> original_map(object->map(), isolate);
+
+    for (; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
-      Handle<Object> value;
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
+      Handle<Object> value;
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
+        // This might modify the elements and/or change the elements kind.
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
-      if (get_entries) {
-        value = MakeEntryPair(isolate, index, value);
+      if (get_entries) value = MakeEntryPair(isolate, index, value);
+      values_or_entries->set(count++, *value);
+      if (object->map() != *original_map) break;
+    }
+
+    // Slow path caused by changes in elements kind during iteration.
+    for (; i < keys->length(); i++) {
+      Handle<Object> key(keys->get(i), isolate);
+      uint32_t index;
+      if (!key->ToUint32(&index)) continue;
+
+      if (filter & ONLY_ENUMERABLE) {
+        InternalElementsAccessor* accessor =
+            reinterpret_cast<InternalElementsAccessor*>(
+                object->GetElementsAccessor());
+        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,
+                                                    object->elements(), index);
+        if (entry == kMaxUInt32) continue;
+        PropertyDetails details = accessor->GetDetails(*object, entry);
+        if (!details.IsEnumerable()) continue;
       }
+
+      Handle<Object> value;
+      LookupIterator it(isolate, object, index, LookupIterator::OWN);
+      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
+                                       Nothing<bool>());
+
+      if (get_entries) value = MakeEntryPair(isolate, index, value);
       values_or_entries->set(count++, *value);
     }
 
@@ -1623,12 +1669,13 @@

         return result;
       }
     }
-
+    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     // Iterate through entire range, as accessing elements out of order is
     // observable
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         if (search_for_hole) return Just(true);
@@ -1690,11 +1737,13 @@

                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
 
+    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     // Iterate through entire range, as accessing elements out of order is
     // observable.
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         continue;
@@ -3170,12 +3219,13 @@

                                        Handle<Object> value,
                                        uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
-    Handle<Map> original_map = handle(object->map(), isolate);
+    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
     bool search_for_hole = value->IsUndefined(isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
@@ -3212,11 +3262,12 @@

                                          Handle<Object> value,
                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
-    Handle<Map> original_map = handle(object->map(), isolate);
+    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
",Android,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb%5E/,1,"   explicit ElementsAccessorBase(const char* name)
//flaw_line_below:
      : ElementsAccessor(name) { }
"
10382,188118,,Remote,Not required,Complete,CVE-2018-9490,https://www.cvedetails.com/cve/CVE-2018-9490/,CWE-704,Medium,Complete,Complete,,2018-10-02,9.3,"In CollectValuesOrEntriesImpl of elements.cc, there is possible remote code execution due to type confusion. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android. Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111274046",2018-12-28,Exec Code ,2,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb,a24543157ae2cdd25da43e20f4e48a07481e6ceb,"Backport: Fix Object.entries/values with changing elements

Bug: 111274046
Test: m -j proxy_resolver_v8_unittest && adb sync && adb shell \
/data/nativetest64/proxy_resolver_v8_unittest/proxy_resolver_v8_unittest
Change-Id: I705fc512cc5837e9364ed187559cc75d079aa5cb
(cherry picked from commit d8be9a10287afed07705ac8af027d6a46d4def99)
",0,src/elements.cc,"{""filename"": ""src/elements.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/src/elements.cc"", ""patch"": ""@@ -511,6 +511,21 @@\n\n   return Just<int64_t>(-1);\n }\n \n+// The InternalElementsAccessor is a helper class to expose otherwise protected\n+// methods to its subclasses. Namely, we don't want to publicly expose methods\n+// that take an entry (instead of an index) as an argument.\n+class InternalElementsAccessor : public ElementsAccessor {\n+ public:\n+  explicit InternalElementsAccessor(const char* name)\n+      : ElementsAccessor(name) {}\n+\n+  virtual uint32_t GetEntryForIndex(Isolate* isolate, JSObject* holder,\n+                                    FixedArrayBase* backing_store,\n+                                    uint32_t index) = 0;\n+\n+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n+};\n+\n // Base class for element handler implementations. Contains the\n // the common logic for objects with different ElementsKinds.\n // Subclasses must specialize method for which the element\n@@ -529,10 +544,10 @@\n\n // CRTP to guarantee aggressive compile time optimizations (i.e.  inlining and\n // specialization of SomeElementsAccessor methods).\n template <typename Subclass, typename ElementsTraitsParam>\n-class ElementsAccessorBase : public ElementsAccessor {\n+class ElementsAccessorBase : public InternalElementsAccessor {\n  public:\n   explicit ElementsAccessorBase(const char* name)\n-      : ElementsAccessor(name) { }\n+      : InternalElementsAccessor(name) {}\n \n   typedef ElementsTraitsParam ElementsTraits;\n   typedef typename ElementsTraitsParam::BackingStore BackingStore;\n@@ -1014,35 +1029,66 @@\n\n       Isolate* isolate, Handle<JSObject> object,\n       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,\n       PropertyFilter filter) {\n-    int count = 0;\n+    DCHECK_EQ(*nof_items, 0);\n     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,\n                                ALL_PROPERTIES);\n     Subclass::CollectElementIndicesImpl(\n         object, handle(object->elements(), isolate), &accumulator);\n     Handle<FixedArray> keys = accumulator.GetKeys();\n \n-    for (int i = 0; i < keys->length(); ++i) {\n+    int count = 0;\n+    int i = 0;\n+    Handle<Map> original_map(object->map(), isolate);\n+\n+    for (; i < keys->length(); ++i) {\n       Handle<Object> key(keys->get(i), isolate);\n-      Handle<Object> value;\n       uint32_t index;\n       if (!key->ToUint32(&index)) continue;\n \n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = Subclass::GetEntryForIndexImpl(\n           isolate, *object, object->elements(), index, filter);\n       if (entry == kMaxUInt32) continue;\n \n       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);\n \n+      Handle<Object> value;\n       if (details.kind() == kData) {\n         value = Subclass::GetImpl(isolate, object->elements(), entry);\n       } else {\n+        // This might modify the elements and/or change the elements kind.\n         LookupIterator it(isolate, object, index, LookupIterator::OWN);\n         ASSIGN_RETURN_ON_EXCEPTION_VALUE(\n             isolate, value, Object::GetProperty(&it), Nothing<bool>());\n       }\n-      if (get_entries) {\n-        value = MakeEntryPair(isolate, index, value);\n+      if (get_entries) value = MakeEntryPair(isolate, index, value);\n+      values_or_entries->set(count++, *value);\n+      if (object->map() != *original_map) break;\n+    }\n+\n+    // Slow path caused by changes in elements kind during iteration.\n+    for (; i < keys->length(); i++) {\n+      Handle<Object> key(keys->get(i), isolate);\n+      uint32_t index;\n+      if (!key->ToUint32(&index)) continue;\n+\n+      if (filter & ONLY_ENUMERABLE) {\n+        InternalElementsAccessor* accessor =\n+            reinterpret_cast<InternalElementsAccessor*>(\n+                object->GetElementsAccessor());\n+        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,\n+                                                    object->elements(), index);\n+        if (entry == kMaxUInt32) continue;\n+        PropertyDetails details = accessor->GetDetails(*object, entry);\n+        if (!details.IsEnumerable()) continue;\n       }\n+\n+      Handle<Object> value;\n+      LookupIterator it(isolate, object, index, LookupIterator::OWN);\n+      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),\n+                                       Nothing<bool>());\n+\n+      if (get_entries) value = MakeEntryPair(isolate, index, value);\n       values_or_entries->set(count++, *value);\n     }\n \n@@ -1623,12 +1669,13 @@\n\n         return result;\n       }\n     }\n-\n+    Handle<Map> original_map(receiver->map(), isolate);\n     Handle<SeededNumberDictionary> dictionary(\n         SeededNumberDictionary::cast(receiver->elements()), isolate);\n     // Iterate through entire range, as accessing elements out of order is\n     // observable\n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(receiver->map(), *original_map);\n       int entry = dictionary->FindEntry(isolate, k);\n       if (entry == SeededNumberDictionary::kNotFound) {\n         if (search_for_hole) return Just(true);\n@@ -1690,11 +1737,13 @@\n\n                                          uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));\n \n+    Handle<Map> original_map(receiver->map(), isolate);\n     Handle<SeededNumberDictionary> dictionary(\n         SeededNumberDictionary::cast(receiver->elements()), isolate);\n     // Iterate through entire range, as accessing elements out of order is\n     // observable.\n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(receiver->map(), *original_map);\n       int entry = dictionary->FindEntry(isolate, k);\n       if (entry == SeededNumberDictionary::kNotFound) {\n         continue;\n@@ -3170,12 +3219,13 @@\n\n                                        Handle<Object> value,\n                                        uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n-    Handle<Map> original_map = handle(object->map(), isolate);\n+    Handle<Map> original_map(object->map(), isolate);\n     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                      isolate);\n     bool search_for_hole = value->IsUndefined(isolate);\n \n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                             ALL_PROPERTIES);\n       if (entry == kMaxUInt32) {\n@@ -3212,11 +3262,12 @@\n\n                                          Handle<Object> value,\n                                          uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n-    Handle<Map> original_map = handle(object->map(), isolate);\n+    Handle<Map> original_map(object->map(), isolate);\n     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                      isolate);\n \n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                             ALL_PROPERTIES);\n       if (entry == kMaxUInt32) {\n""}<_**next**_>{""filename"": ""src/elements.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/src/elements.h"", ""patch"": ""@@ -54,7 +54,6 @@\n\n \n   virtual Handle<Object> Get(Handle<JSObject> holder, uint32_t entry) = 0;\n \n-  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n   virtual bool HasAccessors(JSObject* holder) = 0;\n   virtual uint32_t NumberOfElements(JSObject* holder) = 0;\n \n@@ -65,9 +64,6 @@\n\n   // element that is non-deletable.\n   virtual void SetLength(Handle<JSArray> holder, uint32_t new_length) = 0;\n \n-  // Deletes an element in an object.\n-  virtual void Delete(Handle<JSObject> holder, uint32_t entry) = 0;\n-\n   // If kCopyToEnd is specified as the copy_size to CopyElements, it copies all\n   // of elements from source after source_start to the destination array.\n   static const int kCopyToEnd = -1;\n@@ -124,11 +120,6 @@\n\n \n   virtual void Set(Handle<JSObject> holder, uint32_t entry, Object* value) = 0;\n \n-  virtual void Reconfigure(Handle<JSObject> object,\n-                           Handle<FixedArrayBase> backing_store, uint32_t entry,\n-                           Handle<Object> value,\n-                           PropertyAttributes attributes) = 0;\n-\n   virtual void Add(Handle<JSObject> object, uint32_t index,\n                    Handle<Object> value, PropertyAttributes attributes,\n                    uint32_t new_capacity) = 0;\n@@ -193,6 +184,15 @@\n\n                                     FixedArrayBase* backing_store,\n                                     uint32_t index) = 0;\n \n+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n+  virtual void Reconfigure(Handle<JSObject> object,\n+                           Handle<FixedArrayBase> backing_store, uint32_t entry,\n+                           Handle<Object> value,\n+                           PropertyAttributes attributes) = 0;\n+\n+  // Deletes an element in an object.\n+  virtual void Delete(Handle<JSObject> holder, uint32_t entry) = 0;\n+\n   // NOTE: this method violates the handlified function signature convention:\n   // raw pointer parameter |source_holder| in the function that allocates.\n   // This is done intentionally to avoid ArrayConcat() builtin performance\n""}"," static Maybe<bool> IncludesValueImpl(Isolate* isolate,
 Handle<JSObject> receiver,
 Handle<Object> value,
 uint32_t start_from, uint32_t length) {
    DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
 bool search_for_hole = value->IsUndefined(isolate);

 if (!search_for_hole) {
 Maybe<bool> result = Nothing<bool>();
 if (DictionaryElementsAccessor::IncludesValueFastPath(
              isolate, receiver, value, start_from, length, &result)) {

         return result;
       }
     }
    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     for (uint32_t k = start_from; k < length; ++k) {
      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         if (search_for_hole) return Just(true);
 continue;
 }

 PropertyDetails details = GetDetailsImpl(*dictionary, entry);
 switch (details.kind()) {
 case kData: {
 Object* element_k = dictionary->ValueAt(entry);
 if (value->SameValueZero(element_k)) return Just(true);
 break;
 }
 case kAccessor: {
 LookupIterator it(isolate, receiver, k,
 LookupIterator::OWN_SKIP_INTERCEPTOR);
          DCHECK(it.IsFound());
          DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);
 Handle<Object> element_k;

          ASSIGN_RETURN_ON_EXCEPTION_VALUE(
              isolate, element_k, JSObject::GetPropertyWithAccessor(&it),
 Nothing<bool>());

 if (value->SameValueZero(*element_k)) return Just(true);

 if (!JSObject::PrototypeHasNoElements(isolate, *receiver)) {
 return IncludesValueSlowPath(isolate, receiver, value, k + 1,
                                         length);
 }

 if (*dictionary == receiver->elements()) continue;

 if (receiver->GetElementsKind() != DICTIONARY_ELEMENTS) {
 if (receiver->map()->GetInitialElements() == receiver->elements()) {
 return Just(search_for_hole);
 }
 return IncludesValueSlowPath(isolate, receiver, value, k + 1,
                                         length);
 }
          dictionary = handle(
 SeededNumberDictionary::cast(receiver->elements()), isolate);
 break;
 }
 }
 }
 return Just(false);
 }
"," static Maybe<bool> IncludesValueImpl(Isolate* isolate,
 Handle<JSObject> receiver,
 Handle<Object> value,
 uint32_t start_from, uint32_t length) {
    DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
 bool search_for_hole = value->IsUndefined(isolate);

 if (!search_for_hole) {
 Maybe<bool> result = Nothing<bool>();
 if (DictionaryElementsAccessor::IncludesValueFastPath(
              isolate, receiver, value, start_from, length, &result)) {

         return result;
       }
     }
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     for (uint32_t k = start_from; k < length; ++k) {
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         if (search_for_hole) return Just(true);
 continue;
 }

 PropertyDetails details = GetDetailsImpl(*dictionary, entry);
 switch (details.kind()) {
 case kData: {
 Object* element_k = dictionary->ValueAt(entry);
 if (value->SameValueZero(element_k)) return Just(true);
 break;
 }
 case kAccessor: {
 LookupIterator it(isolate, receiver, k,
 LookupIterator::OWN_SKIP_INTERCEPTOR);
          DCHECK(it.IsFound());
          DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);
 Handle<Object> element_k;

          ASSIGN_RETURN_ON_EXCEPTION_VALUE(
              isolate, element_k, JSObject::GetPropertyWithAccessor(&it),
 Nothing<bool>());

 if (value->SameValueZero(*element_k)) return Just(true);

 if (!JSObject::PrototypeHasNoElements(isolate, *receiver)) {
 return IncludesValueSlowPath(isolate, receiver, value, k + 1,
                                         length);
 }

 if (*dictionary == receiver->elements()) continue;

 if (receiver->GetElementsKind() != DICTIONARY_ELEMENTS) {
 if (receiver->map()->GetInitialElements() == receiver->elements()) {
 return Just(search_for_hole);
 }
 return IncludesValueSlowPath(isolate, receiver, value, k + 1,
                                         length);
 }
          dictionary = handle(
 SeededNumberDictionary::cast(receiver->elements()), isolate);
 break;
 }
 }
 }
 return Just(false);
 }
",C,"    Handle<Map> original_map(receiver->map(), isolate);
      DCHECK_EQ(receiver->map(), *original_map);
",,,"@@ -511,6 +511,21 @@

   return Just<int64_t>(-1);
 }
 
+// The InternalElementsAccessor is a helper class to expose otherwise protected
+// methods to its subclasses. Namely, we don't want to publicly expose methods
+// that take an entry (instead of an index) as an argument.
+class InternalElementsAccessor : public ElementsAccessor {
+ public:
+  explicit InternalElementsAccessor(const char* name)
+      : ElementsAccessor(name) {}
+
+  virtual uint32_t GetEntryForIndex(Isolate* isolate, JSObject* holder,
+                                    FixedArrayBase* backing_store,
+                                    uint32_t index) = 0;
+
+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;
+};
+
 // Base class for element handler implementations. Contains the
 // the common logic for objects with different ElementsKinds.
 // Subclasses must specialize method for which the element
@@ -529,10 +544,10 @@

 // CRTP to guarantee aggressive compile time optimizations (i.e.  inlining and
 // specialization of SomeElementsAccessor methods).
 template <typename Subclass, typename ElementsTraitsParam>
-class ElementsAccessorBase : public ElementsAccessor {
+class ElementsAccessorBase : public InternalElementsAccessor {
  public:
   explicit ElementsAccessorBase(const char* name)
-      : ElementsAccessor(name) { }
+      : InternalElementsAccessor(name) {}
 
   typedef ElementsTraitsParam ElementsTraits;
   typedef typename ElementsTraitsParam::BackingStore BackingStore;
@@ -1014,35 +1029,66 @@

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
-    int count = 0;
+    DCHECK_EQ(*nof_items, 0);
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
-    for (int i = 0; i < keys->length(); ++i) {
+    int count = 0;
+    int i = 0;
+    Handle<Map> original_map(object->map(), isolate);
+
+    for (; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
-      Handle<Object> value;
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
+      Handle<Object> value;
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
+        // This might modify the elements and/or change the elements kind.
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
-      if (get_entries) {
-        value = MakeEntryPair(isolate, index, value);
+      if (get_entries) value = MakeEntryPair(isolate, index, value);
+      values_or_entries->set(count++, *value);
+      if (object->map() != *original_map) break;
+    }
+
+    // Slow path caused by changes in elements kind during iteration.
+    for (; i < keys->length(); i++) {
+      Handle<Object> key(keys->get(i), isolate);
+      uint32_t index;
+      if (!key->ToUint32(&index)) continue;
+
+      if (filter & ONLY_ENUMERABLE) {
+        InternalElementsAccessor* accessor =
+            reinterpret_cast<InternalElementsAccessor*>(
+                object->GetElementsAccessor());
+        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,
+                                                    object->elements(), index);
+        if (entry == kMaxUInt32) continue;
+        PropertyDetails details = accessor->GetDetails(*object, entry);
+        if (!details.IsEnumerable()) continue;
       }
+
+      Handle<Object> value;
+      LookupIterator it(isolate, object, index, LookupIterator::OWN);
+      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
+                                       Nothing<bool>());
+
+      if (get_entries) value = MakeEntryPair(isolate, index, value);
       values_or_entries->set(count++, *value);
     }
 
@@ -1623,12 +1669,13 @@

         return result;
       }
     }
-
+    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     // Iterate through entire range, as accessing elements out of order is
     // observable
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         if (search_for_hole) return Just(true);
@@ -1690,11 +1737,13 @@

                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
 
+    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     // Iterate through entire range, as accessing elements out of order is
     // observable.
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         continue;
@@ -3170,12 +3219,13 @@

                                        Handle<Object> value,
                                        uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
-    Handle<Map> original_map = handle(object->map(), isolate);
+    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
     bool search_for_hole = value->IsUndefined(isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
@@ -3212,11 +3262,12 @@

                                          Handle<Object> value,
                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
-    Handle<Map> original_map = handle(object->map(), isolate);
+    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
",Android,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb%5E/,1," static Maybe<bool> IncludesValueImpl(Isolate* isolate,
 Handle<JSObject> receiver,
 Handle<Object> value,
 uint32_t start_from, uint32_t length) {
    DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
 bool search_for_hole = value->IsUndefined(isolate);

 if (!search_for_hole) {
 Maybe<bool> result = Nothing<bool>();
 if (DictionaryElementsAccessor::IncludesValueFastPath(
              isolate, receiver, value, start_from, length, &result)) {

         return result;
       }
     }
//flaw_line_below:

//fix_flaw_line_below:
//    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     // Iterate through entire range, as accessing elements out of order is
     // observable
     for (uint32_t k = start_from; k < length; ++k) {
//fix_flaw_line_below:
//      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         if (search_for_hole) return Just(true);
 continue;
 }

 PropertyDetails details = GetDetailsImpl(*dictionary, entry);
 switch (details.kind()) {
 case kData: {
 Object* element_k = dictionary->ValueAt(entry);
 if (value->SameValueZero(element_k)) return Just(true);
 break;
 }
 case kAccessor: {
 LookupIterator it(isolate, receiver, k,
 LookupIterator::OWN_SKIP_INTERCEPTOR);
          DCHECK(it.IsFound());
          DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);
 Handle<Object> element_k;

          ASSIGN_RETURN_ON_EXCEPTION_VALUE(
              isolate, element_k, JSObject::GetPropertyWithAccessor(&it),
 Nothing<bool>());

 if (value->SameValueZero(*element_k)) return Just(true);

 // Bailout to slow path if elements on prototype changed
 if (!JSObject::PrototypeHasNoElements(isolate, *receiver)) {
 return IncludesValueSlowPath(isolate, receiver, value, k + 1,
                                         length);
 }

 // Continue if elements unchanged
 if (*dictionary == receiver->elements()) continue;

 // Otherwise, bailout or update elements
 if (receiver->GetElementsKind() != DICTIONARY_ELEMENTS) {
 if (receiver->map()->GetInitialElements() == receiver->elements()) {
 // If switched to initial elements, return true if searching for
 // undefined, and false otherwise.
 return Just(search_for_hole);
 }
 // Otherwise, switch to slow path.
 return IncludesValueSlowPath(isolate, receiver, value, k + 1,
                                         length);
 }
          dictionary = handle(
 SeededNumberDictionary::cast(receiver->elements()), isolate);
 break;
 }
 }
 }
 return Just(false);
 }
"
10383,188119,,Remote,Not required,Complete,CVE-2018-9490,https://www.cvedetails.com/cve/CVE-2018-9490/,CWE-704,Medium,Complete,Complete,,2018-10-02,9.3,"In CollectValuesOrEntriesImpl of elements.cc, there is possible remote code execution due to type confusion. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android. Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111274046",2018-12-28,Exec Code ,2,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb,a24543157ae2cdd25da43e20f4e48a07481e6ceb,"Backport: Fix Object.entries/values with changing elements

Bug: 111274046
Test: m -j proxy_resolver_v8_unittest && adb sync && adb shell \
/data/nativetest64/proxy_resolver_v8_unittest/proxy_resolver_v8_unittest
Change-Id: I705fc512cc5837e9364ed187559cc75d079aa5cb
(cherry picked from commit d8be9a10287afed07705ac8af027d6a46d4def99)
",1,src/elements.cc,"{""filename"": ""src/elements.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/src/elements.cc"", ""patch"": ""@@ -511,6 +511,21 @@\n\n   return Just<int64_t>(-1);\n }\n \n+// The InternalElementsAccessor is a helper class to expose otherwise protected\n+// methods to its subclasses. Namely, we don't want to publicly expose methods\n+// that take an entry (instead of an index) as an argument.\n+class InternalElementsAccessor : public ElementsAccessor {\n+ public:\n+  explicit InternalElementsAccessor(const char* name)\n+      : ElementsAccessor(name) {}\n+\n+  virtual uint32_t GetEntryForIndex(Isolate* isolate, JSObject* holder,\n+                                    FixedArrayBase* backing_store,\n+                                    uint32_t index) = 0;\n+\n+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n+};\n+\n // Base class for element handler implementations. Contains the\n // the common logic for objects with different ElementsKinds.\n // Subclasses must specialize method for which the element\n@@ -529,10 +544,10 @@\n\n // CRTP to guarantee aggressive compile time optimizations (i.e.  inlining and\n // specialization of SomeElementsAccessor methods).\n template <typename Subclass, typename ElementsTraitsParam>\n-class ElementsAccessorBase : public ElementsAccessor {\n+class ElementsAccessorBase : public InternalElementsAccessor {\n  public:\n   explicit ElementsAccessorBase(const char* name)\n-      : ElementsAccessor(name) { }\n+      : InternalElementsAccessor(name) {}\n \n   typedef ElementsTraitsParam ElementsTraits;\n   typedef typename ElementsTraitsParam::BackingStore BackingStore;\n@@ -1014,35 +1029,66 @@\n\n       Isolate* isolate, Handle<JSObject> object,\n       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,\n       PropertyFilter filter) {\n-    int count = 0;\n+    DCHECK_EQ(*nof_items, 0);\n     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,\n                                ALL_PROPERTIES);\n     Subclass::CollectElementIndicesImpl(\n         object, handle(object->elements(), isolate), &accumulator);\n     Handle<FixedArray> keys = accumulator.GetKeys();\n \n-    for (int i = 0; i < keys->length(); ++i) {\n+    int count = 0;\n+    int i = 0;\n+    Handle<Map> original_map(object->map(), isolate);\n+\n+    for (; i < keys->length(); ++i) {\n       Handle<Object> key(keys->get(i), isolate);\n-      Handle<Object> value;\n       uint32_t index;\n       if (!key->ToUint32(&index)) continue;\n \n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = Subclass::GetEntryForIndexImpl(\n           isolate, *object, object->elements(), index, filter);\n       if (entry == kMaxUInt32) continue;\n \n       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);\n \n+      Handle<Object> value;\n       if (details.kind() == kData) {\n         value = Subclass::GetImpl(isolate, object->elements(), entry);\n       } else {\n+        // This might modify the elements and/or change the elements kind.\n         LookupIterator it(isolate, object, index, LookupIterator::OWN);\n         ASSIGN_RETURN_ON_EXCEPTION_VALUE(\n             isolate, value, Object::GetProperty(&it), Nothing<bool>());\n       }\n-      if (get_entries) {\n-        value = MakeEntryPair(isolate, index, value);\n+      if (get_entries) value = MakeEntryPair(isolate, index, value);\n+      values_or_entries->set(count++, *value);\n+      if (object->map() != *original_map) break;\n+    }\n+\n+    // Slow path caused by changes in elements kind during iteration.\n+    for (; i < keys->length(); i++) {\n+      Handle<Object> key(keys->get(i), isolate);\n+      uint32_t index;\n+      if (!key->ToUint32(&index)) continue;\n+\n+      if (filter & ONLY_ENUMERABLE) {\n+        InternalElementsAccessor* accessor =\n+            reinterpret_cast<InternalElementsAccessor*>(\n+                object->GetElementsAccessor());\n+        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,\n+                                                    object->elements(), index);\n+        if (entry == kMaxUInt32) continue;\n+        PropertyDetails details = accessor->GetDetails(*object, entry);\n+        if (!details.IsEnumerable()) continue;\n       }\n+\n+      Handle<Object> value;\n+      LookupIterator it(isolate, object, index, LookupIterator::OWN);\n+      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),\n+                                       Nothing<bool>());\n+\n+      if (get_entries) value = MakeEntryPair(isolate, index, value);\n       values_or_entries->set(count++, *value);\n     }\n \n@@ -1623,12 +1669,13 @@\n\n         return result;\n       }\n     }\n-\n+    Handle<Map> original_map(receiver->map(), isolate);\n     Handle<SeededNumberDictionary> dictionary(\n         SeededNumberDictionary::cast(receiver->elements()), isolate);\n     // Iterate through entire range, as accessing elements out of order is\n     // observable\n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(receiver->map(), *original_map);\n       int entry = dictionary->FindEntry(isolate, k);\n       if (entry == SeededNumberDictionary::kNotFound) {\n         if (search_for_hole) return Just(true);\n@@ -1690,11 +1737,13 @@\n\n                                          uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));\n \n+    Handle<Map> original_map(receiver->map(), isolate);\n     Handle<SeededNumberDictionary> dictionary(\n         SeededNumberDictionary::cast(receiver->elements()), isolate);\n     // Iterate through entire range, as accessing elements out of order is\n     // observable.\n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(receiver->map(), *original_map);\n       int entry = dictionary->FindEntry(isolate, k);\n       if (entry == SeededNumberDictionary::kNotFound) {\n         continue;\n@@ -3170,12 +3219,13 @@\n\n                                        Handle<Object> value,\n                                        uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n-    Handle<Map> original_map = handle(object->map(), isolate);\n+    Handle<Map> original_map(object->map(), isolate);\n     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                      isolate);\n     bool search_for_hole = value->IsUndefined(isolate);\n \n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                             ALL_PROPERTIES);\n       if (entry == kMaxUInt32) {\n@@ -3212,11 +3262,12 @@\n\n                                          Handle<Object> value,\n                                          uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n-    Handle<Map> original_map = handle(object->map(), isolate);\n+    Handle<Map> original_map(object->map(), isolate);\n     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                      isolate);\n \n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                             ALL_PROPERTIES);\n       if (entry == kMaxUInt32) {\n""}<_**next**_>{""filename"": ""src/elements.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/src/elements.h"", ""patch"": ""@@ -54,7 +54,6 @@\n\n \n   virtual Handle<Object> Get(Handle<JSObject> holder, uint32_t entry) = 0;\n \n-  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n   virtual bool HasAccessors(JSObject* holder) = 0;\n   virtual uint32_t NumberOfElements(JSObject* holder) = 0;\n \n@@ -65,9 +64,6 @@\n\n   // element that is non-deletable.\n   virtual void SetLength(Handle<JSArray> holder, uint32_t new_length) = 0;\n \n-  // Deletes an element in an object.\n-  virtual void Delete(Handle<JSObject> holder, uint32_t entry) = 0;\n-\n   // If kCopyToEnd is specified as the copy_size to CopyElements, it copies all\n   // of elements from source after source_start to the destination array.\n   static const int kCopyToEnd = -1;\n@@ -124,11 +120,6 @@\n\n \n   virtual void Set(Handle<JSObject> holder, uint32_t entry, Object* value) = 0;\n \n-  virtual void Reconfigure(Handle<JSObject> object,\n-                           Handle<FixedArrayBase> backing_store, uint32_t entry,\n-                           Handle<Object> value,\n-                           PropertyAttributes attributes) = 0;\n-\n   virtual void Add(Handle<JSObject> object, uint32_t index,\n                    Handle<Object> value, PropertyAttributes attributes,\n                    uint32_t new_capacity) = 0;\n@@ -193,6 +184,15 @@\n\n                                     FixedArrayBase* backing_store,\n                                     uint32_t index) = 0;\n \n+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n+  virtual void Reconfigure(Handle<JSObject> object,\n+                           Handle<FixedArrayBase> backing_store, uint32_t entry,\n+                           Handle<Object> value,\n+                           PropertyAttributes attributes) = 0;\n+\n+  // Deletes an element in an object.\n+  virtual void Delete(Handle<JSObject> holder, uint32_t entry) = 0;\n+\n   // NOTE: this method violates the handlified function signature convention:\n   // raw pointer parameter |source_holder| in the function that allocates.\n   // This is done intentionally to avoid ArrayConcat() builtin performance\n""}"," static Maybe<bool> IncludesValueImpl(Isolate* isolate,
 Handle<JSObject> object,

                                        Handle<Object> value,
                                        uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
     bool search_for_hole = value->IsUndefined(isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
 if (search_for_hole) return Just(true);
 continue;
 }

 Handle<Object> element_k =
 Subclass::GetImpl(isolate, *parameter_map, entry);

 if (element_k->IsAccessorPair()) {
 LookupIterator it(isolate, object, k, LookupIterator::OWN);
        DCHECK(it.IsFound());
        DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);
        ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,
 Object::GetPropertyWithAccessor(&it),
 Nothing<bool>());

 if (value->SameValueZero(*element_k)) return Just(true);

 if (object->map() != *original_map) {
 return IncludesValueSlowPath(isolate, object, value, k + 1, length);
 }
 } else if (value->SameValueZero(*element_k)) {
 return Just(true);
 }
 }
 return Just(false);
 }
"," static Maybe<bool> IncludesValueImpl(Isolate* isolate,
 Handle<JSObject> object,

                                        Handle<Object> value,
                                        uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
    Handle<Map> original_map = handle(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
     bool search_for_hole = value->IsUndefined(isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
 if (search_for_hole) return Just(true);
 continue;
 }

 Handle<Object> element_k =
 Subclass::GetImpl(isolate, *parameter_map, entry);

 if (element_k->IsAccessorPair()) {
 LookupIterator it(isolate, object, k, LookupIterator::OWN);
        DCHECK(it.IsFound());
        DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);
        ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,
 Object::GetPropertyWithAccessor(&it),
 Nothing<bool>());

 if (value->SameValueZero(*element_k)) return Just(true);

 if (object->map() != *original_map) {
 return IncludesValueSlowPath(isolate, object, value, k + 1, length);
 }
 } else if (value->SameValueZero(*element_k)) {
 return Just(true);
 }
 }
 return Just(false);
 }
",C,"    Handle<Map> original_map(object->map(), isolate);
      DCHECK_EQ(object->map(), *original_map);
","    Handle<Map> original_map = handle(object->map(), isolate);
",,"@@ -511,6 +511,21 @@

   return Just<int64_t>(-1);
 }
 
+// The InternalElementsAccessor is a helper class to expose otherwise protected
+// methods to its subclasses. Namely, we don't want to publicly expose methods
+// that take an entry (instead of an index) as an argument.
+class InternalElementsAccessor : public ElementsAccessor {
+ public:
+  explicit InternalElementsAccessor(const char* name)
+      : ElementsAccessor(name) {}
+
+  virtual uint32_t GetEntryForIndex(Isolate* isolate, JSObject* holder,
+                                    FixedArrayBase* backing_store,
+                                    uint32_t index) = 0;
+
+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;
+};
+
 // Base class for element handler implementations. Contains the
 // the common logic for objects with different ElementsKinds.
 // Subclasses must specialize method for which the element
@@ -529,10 +544,10 @@

 // CRTP to guarantee aggressive compile time optimizations (i.e.  inlining and
 // specialization of SomeElementsAccessor methods).
 template <typename Subclass, typename ElementsTraitsParam>
-class ElementsAccessorBase : public ElementsAccessor {
+class ElementsAccessorBase : public InternalElementsAccessor {
  public:
   explicit ElementsAccessorBase(const char* name)
-      : ElementsAccessor(name) { }
+      : InternalElementsAccessor(name) {}
 
   typedef ElementsTraitsParam ElementsTraits;
   typedef typename ElementsTraitsParam::BackingStore BackingStore;
@@ -1014,35 +1029,66 @@

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
-    int count = 0;
+    DCHECK_EQ(*nof_items, 0);
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
-    for (int i = 0; i < keys->length(); ++i) {
+    int count = 0;
+    int i = 0;
+    Handle<Map> original_map(object->map(), isolate);
+
+    for (; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
-      Handle<Object> value;
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
+      Handle<Object> value;
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
+        // This might modify the elements and/or change the elements kind.
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
-      if (get_entries) {
-        value = MakeEntryPair(isolate, index, value);
+      if (get_entries) value = MakeEntryPair(isolate, index, value);
+      values_or_entries->set(count++, *value);
+      if (object->map() != *original_map) break;
+    }
+
+    // Slow path caused by changes in elements kind during iteration.
+    for (; i < keys->length(); i++) {
+      Handle<Object> key(keys->get(i), isolate);
+      uint32_t index;
+      if (!key->ToUint32(&index)) continue;
+
+      if (filter & ONLY_ENUMERABLE) {
+        InternalElementsAccessor* accessor =
+            reinterpret_cast<InternalElementsAccessor*>(
+                object->GetElementsAccessor());
+        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,
+                                                    object->elements(), index);
+        if (entry == kMaxUInt32) continue;
+        PropertyDetails details = accessor->GetDetails(*object, entry);
+        if (!details.IsEnumerable()) continue;
       }
+
+      Handle<Object> value;
+      LookupIterator it(isolate, object, index, LookupIterator::OWN);
+      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
+                                       Nothing<bool>());
+
+      if (get_entries) value = MakeEntryPair(isolate, index, value);
       values_or_entries->set(count++, *value);
     }
 
@@ -1623,12 +1669,13 @@

         return result;
       }
     }
-
+    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     // Iterate through entire range, as accessing elements out of order is
     // observable
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         if (search_for_hole) return Just(true);
@@ -1690,11 +1737,13 @@

                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
 
+    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     // Iterate through entire range, as accessing elements out of order is
     // observable.
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         continue;
@@ -3170,12 +3219,13 @@

                                        Handle<Object> value,
                                        uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
-    Handle<Map> original_map = handle(object->map(), isolate);
+    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
     bool search_for_hole = value->IsUndefined(isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
@@ -3212,11 +3262,12 @@

                                          Handle<Object> value,
                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
-    Handle<Map> original_map = handle(object->map(), isolate);
+    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
",Android,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb%5E/,1," static Maybe<bool> IncludesValueImpl(Isolate* isolate,
 Handle<JSObject> object,

                                        Handle<Object> value,
                                        uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
//flaw_line_below:
    Handle<Map> original_map = handle(object->map(), isolate);
//fix_flaw_line_below:
//    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
     bool search_for_hole = value->IsUndefined(isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
//fix_flaw_line_below:
//      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
 if (search_for_hole) return Just(true);
 continue;
 }

 Handle<Object> element_k =
 Subclass::GetImpl(isolate, *parameter_map, entry);

 if (element_k->IsAccessorPair()) {
 LookupIterator it(isolate, object, k, LookupIterator::OWN);
        DCHECK(it.IsFound());
        DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);
        ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,
 Object::GetPropertyWithAccessor(&it),
 Nothing<bool>());

 if (value->SameValueZero(*element_k)) return Just(true);

 if (object->map() != *original_map) {
 // Some mutation occurred in accessor. Abort ""fast"" path
 return IncludesValueSlowPath(isolate, object, value, k + 1, length);
 }
 } else if (value->SameValueZero(*element_k)) {
 return Just(true);
 }
 }
 return Just(false);
 }
"
10384,188120,,Remote,Not required,Complete,CVE-2018-9490,https://www.cvedetails.com/cve/CVE-2018-9490/,CWE-704,Medium,Complete,Complete,,2018-10-02,9.3,"In CollectValuesOrEntriesImpl of elements.cc, there is possible remote code execution due to type confusion. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android. Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111274046",2018-12-28,Exec Code ,2,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb,a24543157ae2cdd25da43e20f4e48a07481e6ceb,"Backport: Fix Object.entries/values with changing elements

Bug: 111274046
Test: m -j proxy_resolver_v8_unittest && adb sync && adb shell \
/data/nativetest64/proxy_resolver_v8_unittest/proxy_resolver_v8_unittest
Change-Id: I705fc512cc5837e9364ed187559cc75d079aa5cb
(cherry picked from commit d8be9a10287afed07705ac8af027d6a46d4def99)
",0,src/elements.cc,"{""filename"": ""src/elements.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/src/elements.cc"", ""patch"": ""@@ -511,6 +511,21 @@\n\n   return Just<int64_t>(-1);\n }\n \n+// The InternalElementsAccessor is a helper class to expose otherwise protected\n+// methods to its subclasses. Namely, we don't want to publicly expose methods\n+// that take an entry (instead of an index) as an argument.\n+class InternalElementsAccessor : public ElementsAccessor {\n+ public:\n+  explicit InternalElementsAccessor(const char* name)\n+      : ElementsAccessor(name) {}\n+\n+  virtual uint32_t GetEntryForIndex(Isolate* isolate, JSObject* holder,\n+                                    FixedArrayBase* backing_store,\n+                                    uint32_t index) = 0;\n+\n+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n+};\n+\n // Base class for element handler implementations. Contains the\n // the common logic for objects with different ElementsKinds.\n // Subclasses must specialize method for which the element\n@@ -529,10 +544,10 @@\n\n // CRTP to guarantee aggressive compile time optimizations (i.e.  inlining and\n // specialization of SomeElementsAccessor methods).\n template <typename Subclass, typename ElementsTraitsParam>\n-class ElementsAccessorBase : public ElementsAccessor {\n+class ElementsAccessorBase : public InternalElementsAccessor {\n  public:\n   explicit ElementsAccessorBase(const char* name)\n-      : ElementsAccessor(name) { }\n+      : InternalElementsAccessor(name) {}\n \n   typedef ElementsTraitsParam ElementsTraits;\n   typedef typename ElementsTraitsParam::BackingStore BackingStore;\n@@ -1014,35 +1029,66 @@\n\n       Isolate* isolate, Handle<JSObject> object,\n       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,\n       PropertyFilter filter) {\n-    int count = 0;\n+    DCHECK_EQ(*nof_items, 0);\n     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,\n                                ALL_PROPERTIES);\n     Subclass::CollectElementIndicesImpl(\n         object, handle(object->elements(), isolate), &accumulator);\n     Handle<FixedArray> keys = accumulator.GetKeys();\n \n-    for (int i = 0; i < keys->length(); ++i) {\n+    int count = 0;\n+    int i = 0;\n+    Handle<Map> original_map(object->map(), isolate);\n+\n+    for (; i < keys->length(); ++i) {\n       Handle<Object> key(keys->get(i), isolate);\n-      Handle<Object> value;\n       uint32_t index;\n       if (!key->ToUint32(&index)) continue;\n \n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = Subclass::GetEntryForIndexImpl(\n           isolate, *object, object->elements(), index, filter);\n       if (entry == kMaxUInt32) continue;\n \n       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);\n \n+      Handle<Object> value;\n       if (details.kind() == kData) {\n         value = Subclass::GetImpl(isolate, object->elements(), entry);\n       } else {\n+        // This might modify the elements and/or change the elements kind.\n         LookupIterator it(isolate, object, index, LookupIterator::OWN);\n         ASSIGN_RETURN_ON_EXCEPTION_VALUE(\n             isolate, value, Object::GetProperty(&it), Nothing<bool>());\n       }\n-      if (get_entries) {\n-        value = MakeEntryPair(isolate, index, value);\n+      if (get_entries) value = MakeEntryPair(isolate, index, value);\n+      values_or_entries->set(count++, *value);\n+      if (object->map() != *original_map) break;\n+    }\n+\n+    // Slow path caused by changes in elements kind during iteration.\n+    for (; i < keys->length(); i++) {\n+      Handle<Object> key(keys->get(i), isolate);\n+      uint32_t index;\n+      if (!key->ToUint32(&index)) continue;\n+\n+      if (filter & ONLY_ENUMERABLE) {\n+        InternalElementsAccessor* accessor =\n+            reinterpret_cast<InternalElementsAccessor*>(\n+                object->GetElementsAccessor());\n+        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,\n+                                                    object->elements(), index);\n+        if (entry == kMaxUInt32) continue;\n+        PropertyDetails details = accessor->GetDetails(*object, entry);\n+        if (!details.IsEnumerable()) continue;\n       }\n+\n+      Handle<Object> value;\n+      LookupIterator it(isolate, object, index, LookupIterator::OWN);\n+      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),\n+                                       Nothing<bool>());\n+\n+      if (get_entries) value = MakeEntryPair(isolate, index, value);\n       values_or_entries->set(count++, *value);\n     }\n \n@@ -1623,12 +1669,13 @@\n\n         return result;\n       }\n     }\n-\n+    Handle<Map> original_map(receiver->map(), isolate);\n     Handle<SeededNumberDictionary> dictionary(\n         SeededNumberDictionary::cast(receiver->elements()), isolate);\n     // Iterate through entire range, as accessing elements out of order is\n     // observable\n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(receiver->map(), *original_map);\n       int entry = dictionary->FindEntry(isolate, k);\n       if (entry == SeededNumberDictionary::kNotFound) {\n         if (search_for_hole) return Just(true);\n@@ -1690,11 +1737,13 @@\n\n                                          uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));\n \n+    Handle<Map> original_map(receiver->map(), isolate);\n     Handle<SeededNumberDictionary> dictionary(\n         SeededNumberDictionary::cast(receiver->elements()), isolate);\n     // Iterate through entire range, as accessing elements out of order is\n     // observable.\n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(receiver->map(), *original_map);\n       int entry = dictionary->FindEntry(isolate, k);\n       if (entry == SeededNumberDictionary::kNotFound) {\n         continue;\n@@ -3170,12 +3219,13 @@\n\n                                        Handle<Object> value,\n                                        uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n-    Handle<Map> original_map = handle(object->map(), isolate);\n+    Handle<Map> original_map(object->map(), isolate);\n     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                      isolate);\n     bool search_for_hole = value->IsUndefined(isolate);\n \n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                             ALL_PROPERTIES);\n       if (entry == kMaxUInt32) {\n@@ -3212,11 +3262,12 @@\n\n                                          Handle<Object> value,\n                                          uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n-    Handle<Map> original_map = handle(object->map(), isolate);\n+    Handle<Map> original_map(object->map(), isolate);\n     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                      isolate);\n \n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                             ALL_PROPERTIES);\n       if (entry == kMaxUInt32) {\n""}<_**next**_>{""filename"": ""src/elements.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/src/elements.h"", ""patch"": ""@@ -54,7 +54,6 @@\n\n \n   virtual Handle<Object> Get(Handle<JSObject> holder, uint32_t entry) = 0;\n \n-  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n   virtual bool HasAccessors(JSObject* holder) = 0;\n   virtual uint32_t NumberOfElements(JSObject* holder) = 0;\n \n@@ -65,9 +64,6 @@\n\n   // element that is non-deletable.\n   virtual void SetLength(Handle<JSArray> holder, uint32_t new_length) = 0;\n \n-  // Deletes an element in an object.\n-  virtual void Delete(Handle<JSObject> holder, uint32_t entry) = 0;\n-\n   // If kCopyToEnd is specified as the copy_size to CopyElements, it copies all\n   // of elements from source after source_start to the destination array.\n   static const int kCopyToEnd = -1;\n@@ -124,11 +120,6 @@\n\n \n   virtual void Set(Handle<JSObject> holder, uint32_t entry, Object* value) = 0;\n \n-  virtual void Reconfigure(Handle<JSObject> object,\n-                           Handle<FixedArrayBase> backing_store, uint32_t entry,\n-                           Handle<Object> value,\n-                           PropertyAttributes attributes) = 0;\n-\n   virtual void Add(Handle<JSObject> object, uint32_t index,\n                    Handle<Object> value, PropertyAttributes attributes,\n                    uint32_t new_capacity) = 0;\n@@ -193,6 +184,15 @@\n\n                                     FixedArrayBase* backing_store,\n                                     uint32_t index) = 0;\n \n+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n+  virtual void Reconfigure(Handle<JSObject> object,\n+                           Handle<FixedArrayBase> backing_store, uint32_t entry,\n+                           Handle<Object> value,\n+                           PropertyAttributes attributes) = 0;\n+\n+  // Deletes an element in an object.\n+  virtual void Delete(Handle<JSObject> holder, uint32_t entry) = 0;\n+\n   // NOTE: this method violates the handlified function signature convention:\n   // raw pointer parameter |source_holder| in the function that allocates.\n   // This is done intentionally to avoid ArrayConcat() builtin performance\n""}"," static Maybe<int64_t> IndexOfValueImpl(Isolate* isolate,
 Handle<JSObject> receiver,
 Handle<Object> value,

                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
 
    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     for (uint32_t k = start_from; k < length; ++k) {
      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         continue;
 }

 PropertyDetails details = GetDetailsImpl(*dictionary, entry);
 switch (details.kind()) {
 case kData: {
 Object* element_k = dictionary->ValueAt(entry);
 if (value->StrictEquals(element_k)) {
 return Just<int64_t>(k);
 }
 break;
 }
 case kAccessor: {
 LookupIterator it(isolate, receiver, k,
 LookupIterator::OWN_SKIP_INTERCEPTOR);
          DCHECK(it.IsFound());
          DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);
 Handle<Object> element_k;

          ASSIGN_RETURN_ON_EXCEPTION_VALUE(
              isolate, element_k, JSObject::GetPropertyWithAccessor(&it),
 Nothing<int64_t>());

 if (value->StrictEquals(*element_k)) return Just<int64_t>(k);

 if (!JSObject::PrototypeHasNoElements(isolate, *receiver)) {
 return IndexOfValueSlowPath(isolate, receiver, value, k + 1,
                                        length);
 }

 if (*dictionary == receiver->elements()) continue;

 if (receiver->GetElementsKind() != DICTIONARY_ELEMENTS) {
 return IndexOfValueSlowPath(isolate, receiver, value, k + 1,
                                        length);
 }
          dictionary = handle(
 SeededNumberDictionary::cast(receiver->elements()), isolate);
 break;
 }
 }
 }
 return Just<int64_t>(-1);
 }
"," static Maybe<int64_t> IndexOfValueImpl(Isolate* isolate,
 Handle<JSObject> receiver,
 Handle<Object> value,

                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
 
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     for (uint32_t k = start_from; k < length; ++k) {
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         continue;
 }

 PropertyDetails details = GetDetailsImpl(*dictionary, entry);
 switch (details.kind()) {
 case kData: {
 Object* element_k = dictionary->ValueAt(entry);
 if (value->StrictEquals(element_k)) {
 return Just<int64_t>(k);
 }
 break;
 }
 case kAccessor: {
 LookupIterator it(isolate, receiver, k,
 LookupIterator::OWN_SKIP_INTERCEPTOR);
          DCHECK(it.IsFound());
          DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);
 Handle<Object> element_k;

          ASSIGN_RETURN_ON_EXCEPTION_VALUE(
              isolate, element_k, JSObject::GetPropertyWithAccessor(&it),
 Nothing<int64_t>());

 if (value->StrictEquals(*element_k)) return Just<int64_t>(k);

 if (!JSObject::PrototypeHasNoElements(isolate, *receiver)) {
 return IndexOfValueSlowPath(isolate, receiver, value, k + 1,
                                        length);
 }

 if (*dictionary == receiver->elements()) continue;

 if (receiver->GetElementsKind() != DICTIONARY_ELEMENTS) {
 return IndexOfValueSlowPath(isolate, receiver, value, k + 1,
                                        length);
 }
          dictionary = handle(
 SeededNumberDictionary::cast(receiver->elements()), isolate);
 break;
 }
 }
 }
 return Just<int64_t>(-1);
 }
",C,"    Handle<Map> original_map(receiver->map(), isolate);
      DCHECK_EQ(receiver->map(), *original_map);
",,,"@@ -511,6 +511,21 @@

   return Just<int64_t>(-1);
 }
 
+// The InternalElementsAccessor is a helper class to expose otherwise protected
+// methods to its subclasses. Namely, we don't want to publicly expose methods
+// that take an entry (instead of an index) as an argument.
+class InternalElementsAccessor : public ElementsAccessor {
+ public:
+  explicit InternalElementsAccessor(const char* name)
+      : ElementsAccessor(name) {}
+
+  virtual uint32_t GetEntryForIndex(Isolate* isolate, JSObject* holder,
+                                    FixedArrayBase* backing_store,
+                                    uint32_t index) = 0;
+
+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;
+};
+
 // Base class for element handler implementations. Contains the
 // the common logic for objects with different ElementsKinds.
 // Subclasses must specialize method for which the element
@@ -529,10 +544,10 @@

 // CRTP to guarantee aggressive compile time optimizations (i.e.  inlining and
 // specialization of SomeElementsAccessor methods).
 template <typename Subclass, typename ElementsTraitsParam>
-class ElementsAccessorBase : public ElementsAccessor {
+class ElementsAccessorBase : public InternalElementsAccessor {
  public:
   explicit ElementsAccessorBase(const char* name)
-      : ElementsAccessor(name) { }
+      : InternalElementsAccessor(name) {}
 
   typedef ElementsTraitsParam ElementsTraits;
   typedef typename ElementsTraitsParam::BackingStore BackingStore;
@@ -1014,35 +1029,66 @@

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
-    int count = 0;
+    DCHECK_EQ(*nof_items, 0);
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
-    for (int i = 0; i < keys->length(); ++i) {
+    int count = 0;
+    int i = 0;
+    Handle<Map> original_map(object->map(), isolate);
+
+    for (; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
-      Handle<Object> value;
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
+      Handle<Object> value;
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
+        // This might modify the elements and/or change the elements kind.
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
-      if (get_entries) {
-        value = MakeEntryPair(isolate, index, value);
+      if (get_entries) value = MakeEntryPair(isolate, index, value);
+      values_or_entries->set(count++, *value);
+      if (object->map() != *original_map) break;
+    }
+
+    // Slow path caused by changes in elements kind during iteration.
+    for (; i < keys->length(); i++) {
+      Handle<Object> key(keys->get(i), isolate);
+      uint32_t index;
+      if (!key->ToUint32(&index)) continue;
+
+      if (filter & ONLY_ENUMERABLE) {
+        InternalElementsAccessor* accessor =
+            reinterpret_cast<InternalElementsAccessor*>(
+                object->GetElementsAccessor());
+        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,
+                                                    object->elements(), index);
+        if (entry == kMaxUInt32) continue;
+        PropertyDetails details = accessor->GetDetails(*object, entry);
+        if (!details.IsEnumerable()) continue;
       }
+
+      Handle<Object> value;
+      LookupIterator it(isolate, object, index, LookupIterator::OWN);
+      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
+                                       Nothing<bool>());
+
+      if (get_entries) value = MakeEntryPair(isolate, index, value);
       values_or_entries->set(count++, *value);
     }
 
@@ -1623,12 +1669,13 @@

         return result;
       }
     }
-
+    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     // Iterate through entire range, as accessing elements out of order is
     // observable
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         if (search_for_hole) return Just(true);
@@ -1690,11 +1737,13 @@

                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
 
+    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     // Iterate through entire range, as accessing elements out of order is
     // observable.
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         continue;
@@ -3170,12 +3219,13 @@

                                        Handle<Object> value,
                                        uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
-    Handle<Map> original_map = handle(object->map(), isolate);
+    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
     bool search_for_hole = value->IsUndefined(isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
@@ -3212,11 +3262,12 @@

                                          Handle<Object> value,
                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
-    Handle<Map> original_map = handle(object->map(), isolate);
+    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
",Android,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb%5E/,1," static Maybe<int64_t> IndexOfValueImpl(Isolate* isolate,
 Handle<JSObject> receiver,
 Handle<Object> value,

                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
 
//fix_flaw_line_below:
//    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     // Iterate through entire range, as accessing elements out of order is
     // observable.
     for (uint32_t k = start_from; k < length; ++k) {
//fix_flaw_line_below:
//      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         continue;
 }

 PropertyDetails details = GetDetailsImpl(*dictionary, entry);
 switch (details.kind()) {
 case kData: {
 Object* element_k = dictionary->ValueAt(entry);
 if (value->StrictEquals(element_k)) {
 return Just<int64_t>(k);
 }
 break;
 }
 case kAccessor: {
 LookupIterator it(isolate, receiver, k,
 LookupIterator::OWN_SKIP_INTERCEPTOR);
          DCHECK(it.IsFound());
          DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);
 Handle<Object> element_k;

          ASSIGN_RETURN_ON_EXCEPTION_VALUE(
              isolate, element_k, JSObject::GetPropertyWithAccessor(&it),
 Nothing<int64_t>());

 if (value->StrictEquals(*element_k)) return Just<int64_t>(k);

 // Bailout to slow path if elements on prototype changed.
 if (!JSObject::PrototypeHasNoElements(isolate, *receiver)) {
 return IndexOfValueSlowPath(isolate, receiver, value, k + 1,
                                        length);
 }

 // Continue if elements unchanged.
 if (*dictionary == receiver->elements()) continue;

 // Otherwise, bailout or update elements.
 if (receiver->GetElementsKind() != DICTIONARY_ELEMENTS) {
 // Otherwise, switch to slow path.
 return IndexOfValueSlowPath(isolate, receiver, value, k + 1,
                                        length);
 }
          dictionary = handle(
 SeededNumberDictionary::cast(receiver->elements()), isolate);
 break;
 }
 }
 }
 return Just<int64_t>(-1);
 }
"
10385,188121,,Remote,Not required,Complete,CVE-2018-9490,https://www.cvedetails.com/cve/CVE-2018-9490/,CWE-704,Medium,Complete,Complete,,2018-10-02,9.3,"In CollectValuesOrEntriesImpl of elements.cc, there is possible remote code execution due to type confusion. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android. Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111274046",2018-12-28,Exec Code ,2,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb,a24543157ae2cdd25da43e20f4e48a07481e6ceb,"Backport: Fix Object.entries/values with changing elements

Bug: 111274046
Test: m -j proxy_resolver_v8_unittest && adb sync && adb shell \
/data/nativetest64/proxy_resolver_v8_unittest/proxy_resolver_v8_unittest
Change-Id: I705fc512cc5837e9364ed187559cc75d079aa5cb
(cherry picked from commit d8be9a10287afed07705ac8af027d6a46d4def99)
",1,src/elements.cc,"{""filename"": ""src/elements.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/src/elements.cc"", ""patch"": ""@@ -511,6 +511,21 @@\n\n   return Just<int64_t>(-1);\n }\n \n+// The InternalElementsAccessor is a helper class to expose otherwise protected\n+// methods to its subclasses. Namely, we don't want to publicly expose methods\n+// that take an entry (instead of an index) as an argument.\n+class InternalElementsAccessor : public ElementsAccessor {\n+ public:\n+  explicit InternalElementsAccessor(const char* name)\n+      : ElementsAccessor(name) {}\n+\n+  virtual uint32_t GetEntryForIndex(Isolate* isolate, JSObject* holder,\n+                                    FixedArrayBase* backing_store,\n+                                    uint32_t index) = 0;\n+\n+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n+};\n+\n // Base class for element handler implementations. Contains the\n // the common logic for objects with different ElementsKinds.\n // Subclasses must specialize method for which the element\n@@ -529,10 +544,10 @@\n\n // CRTP to guarantee aggressive compile time optimizations (i.e.  inlining and\n // specialization of SomeElementsAccessor methods).\n template <typename Subclass, typename ElementsTraitsParam>\n-class ElementsAccessorBase : public ElementsAccessor {\n+class ElementsAccessorBase : public InternalElementsAccessor {\n  public:\n   explicit ElementsAccessorBase(const char* name)\n-      : ElementsAccessor(name) { }\n+      : InternalElementsAccessor(name) {}\n \n   typedef ElementsTraitsParam ElementsTraits;\n   typedef typename ElementsTraitsParam::BackingStore BackingStore;\n@@ -1014,35 +1029,66 @@\n\n       Isolate* isolate, Handle<JSObject> object,\n       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,\n       PropertyFilter filter) {\n-    int count = 0;\n+    DCHECK_EQ(*nof_items, 0);\n     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,\n                                ALL_PROPERTIES);\n     Subclass::CollectElementIndicesImpl(\n         object, handle(object->elements(), isolate), &accumulator);\n     Handle<FixedArray> keys = accumulator.GetKeys();\n \n-    for (int i = 0; i < keys->length(); ++i) {\n+    int count = 0;\n+    int i = 0;\n+    Handle<Map> original_map(object->map(), isolate);\n+\n+    for (; i < keys->length(); ++i) {\n       Handle<Object> key(keys->get(i), isolate);\n-      Handle<Object> value;\n       uint32_t index;\n       if (!key->ToUint32(&index)) continue;\n \n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = Subclass::GetEntryForIndexImpl(\n           isolate, *object, object->elements(), index, filter);\n       if (entry == kMaxUInt32) continue;\n \n       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);\n \n+      Handle<Object> value;\n       if (details.kind() == kData) {\n         value = Subclass::GetImpl(isolate, object->elements(), entry);\n       } else {\n+        // This might modify the elements and/or change the elements kind.\n         LookupIterator it(isolate, object, index, LookupIterator::OWN);\n         ASSIGN_RETURN_ON_EXCEPTION_VALUE(\n             isolate, value, Object::GetProperty(&it), Nothing<bool>());\n       }\n-      if (get_entries) {\n-        value = MakeEntryPair(isolate, index, value);\n+      if (get_entries) value = MakeEntryPair(isolate, index, value);\n+      values_or_entries->set(count++, *value);\n+      if (object->map() != *original_map) break;\n+    }\n+\n+    // Slow path caused by changes in elements kind during iteration.\n+    for (; i < keys->length(); i++) {\n+      Handle<Object> key(keys->get(i), isolate);\n+      uint32_t index;\n+      if (!key->ToUint32(&index)) continue;\n+\n+      if (filter & ONLY_ENUMERABLE) {\n+        InternalElementsAccessor* accessor =\n+            reinterpret_cast<InternalElementsAccessor*>(\n+                object->GetElementsAccessor());\n+        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,\n+                                                    object->elements(), index);\n+        if (entry == kMaxUInt32) continue;\n+        PropertyDetails details = accessor->GetDetails(*object, entry);\n+        if (!details.IsEnumerable()) continue;\n       }\n+\n+      Handle<Object> value;\n+      LookupIterator it(isolate, object, index, LookupIterator::OWN);\n+      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),\n+                                       Nothing<bool>());\n+\n+      if (get_entries) value = MakeEntryPair(isolate, index, value);\n       values_or_entries->set(count++, *value);\n     }\n \n@@ -1623,12 +1669,13 @@\n\n         return result;\n       }\n     }\n-\n+    Handle<Map> original_map(receiver->map(), isolate);\n     Handle<SeededNumberDictionary> dictionary(\n         SeededNumberDictionary::cast(receiver->elements()), isolate);\n     // Iterate through entire range, as accessing elements out of order is\n     // observable\n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(receiver->map(), *original_map);\n       int entry = dictionary->FindEntry(isolate, k);\n       if (entry == SeededNumberDictionary::kNotFound) {\n         if (search_for_hole) return Just(true);\n@@ -1690,11 +1737,13 @@\n\n                                          uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));\n \n+    Handle<Map> original_map(receiver->map(), isolate);\n     Handle<SeededNumberDictionary> dictionary(\n         SeededNumberDictionary::cast(receiver->elements()), isolate);\n     // Iterate through entire range, as accessing elements out of order is\n     // observable.\n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(receiver->map(), *original_map);\n       int entry = dictionary->FindEntry(isolate, k);\n       if (entry == SeededNumberDictionary::kNotFound) {\n         continue;\n@@ -3170,12 +3219,13 @@\n\n                                        Handle<Object> value,\n                                        uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n-    Handle<Map> original_map = handle(object->map(), isolate);\n+    Handle<Map> original_map(object->map(), isolate);\n     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                      isolate);\n     bool search_for_hole = value->IsUndefined(isolate);\n \n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                             ALL_PROPERTIES);\n       if (entry == kMaxUInt32) {\n@@ -3212,11 +3262,12 @@\n\n                                          Handle<Object> value,\n                                          uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n-    Handle<Map> original_map = handle(object->map(), isolate);\n+    Handle<Map> original_map(object->map(), isolate);\n     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                      isolate);\n \n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                             ALL_PROPERTIES);\n       if (entry == kMaxUInt32) {\n""}<_**next**_>{""filename"": ""src/elements.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/src/elements.h"", ""patch"": ""@@ -54,7 +54,6 @@\n\n \n   virtual Handle<Object> Get(Handle<JSObject> holder, uint32_t entry) = 0;\n \n-  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n   virtual bool HasAccessors(JSObject* holder) = 0;\n   virtual uint32_t NumberOfElements(JSObject* holder) = 0;\n \n@@ -65,9 +64,6 @@\n\n   // element that is non-deletable.\n   virtual void SetLength(Handle<JSArray> holder, uint32_t new_length) = 0;\n \n-  // Deletes an element in an object.\n-  virtual void Delete(Handle<JSObject> holder, uint32_t entry) = 0;\n-\n   // If kCopyToEnd is specified as the copy_size to CopyElements, it copies all\n   // of elements from source after source_start to the destination array.\n   static const int kCopyToEnd = -1;\n@@ -124,11 +120,6 @@\n\n \n   virtual void Set(Handle<JSObject> holder, uint32_t entry, Object* value) = 0;\n \n-  virtual void Reconfigure(Handle<JSObject> object,\n-                           Handle<FixedArrayBase> backing_store, uint32_t entry,\n-                           Handle<Object> value,\n-                           PropertyAttributes attributes) = 0;\n-\n   virtual void Add(Handle<JSObject> object, uint32_t index,\n                    Handle<Object> value, PropertyAttributes attributes,\n                    uint32_t new_capacity) = 0;\n@@ -193,6 +184,15 @@\n\n                                     FixedArrayBase* backing_store,\n                                     uint32_t index) = 0;\n \n+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n+  virtual void Reconfigure(Handle<JSObject> object,\n+                           Handle<FixedArrayBase> backing_store, uint32_t entry,\n+                           Handle<Object> value,\n+                           PropertyAttributes attributes) = 0;\n+\n+  // Deletes an element in an object.\n+  virtual void Delete(Handle<JSObject> holder, uint32_t entry) = 0;\n+\n   // NOTE: this method violates the handlified function signature convention:\n   // raw pointer parameter |source_holder| in the function that allocates.\n   // This is done intentionally to avoid ArrayConcat() builtin performance\n""}"," static Maybe<int64_t> IndexOfValueImpl(Isolate* isolate,
 Handle<JSObject> object,

                                          Handle<Object> value,
                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
 continue;
 }

 Handle<Object> element_k =
 Subclass::GetImpl(isolate, *parameter_map, entry);

 if (element_k->IsAccessorPair()) {
 LookupIterator it(isolate, object, k, LookupIterator::OWN);
        DCHECK(it.IsFound());
        DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);
        ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,
 Object::GetPropertyWithAccessor(&it),
 Nothing<int64_t>());

 if (value->StrictEquals(*element_k)) {
 return Just<int64_t>(k);
 }

 if (object->map() != *original_map) {
 return IndexOfValueSlowPath(isolate, object, value, k + 1, length);
 }
 } else if (value->StrictEquals(*element_k)) {
 return Just<int64_t>(k);
 }
 }
 return Just<int64_t>(-1);
 }
"," static Maybe<int64_t> IndexOfValueImpl(Isolate* isolate,
 Handle<JSObject> object,

                                          Handle<Object> value,
                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
    Handle<Map> original_map = handle(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
 continue;
 }

 Handle<Object> element_k =
 Subclass::GetImpl(isolate, *parameter_map, entry);

 if (element_k->IsAccessorPair()) {
 LookupIterator it(isolate, object, k, LookupIterator::OWN);
        DCHECK(it.IsFound());
        DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);
        ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,
 Object::GetPropertyWithAccessor(&it),
 Nothing<int64_t>());

 if (value->StrictEquals(*element_k)) {
 return Just<int64_t>(k);
 }

 if (object->map() != *original_map) {
 return IndexOfValueSlowPath(isolate, object, value, k + 1, length);
 }
 } else if (value->StrictEquals(*element_k)) {
 return Just<int64_t>(k);
 }
 }
 return Just<int64_t>(-1);
 }
",C,"    Handle<Map> original_map(object->map(), isolate);
      DCHECK_EQ(object->map(), *original_map);
","    Handle<Map> original_map = handle(object->map(), isolate);
",,"@@ -511,6 +511,21 @@

   return Just<int64_t>(-1);
 }
 
+// The InternalElementsAccessor is a helper class to expose otherwise protected
+// methods to its subclasses. Namely, we don't want to publicly expose methods
+// that take an entry (instead of an index) as an argument.
+class InternalElementsAccessor : public ElementsAccessor {
+ public:
+  explicit InternalElementsAccessor(const char* name)
+      : ElementsAccessor(name) {}
+
+  virtual uint32_t GetEntryForIndex(Isolate* isolate, JSObject* holder,
+                                    FixedArrayBase* backing_store,
+                                    uint32_t index) = 0;
+
+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;
+};
+
 // Base class for element handler implementations. Contains the
 // the common logic for objects with different ElementsKinds.
 // Subclasses must specialize method for which the element
@@ -529,10 +544,10 @@

 // CRTP to guarantee aggressive compile time optimizations (i.e.  inlining and
 // specialization of SomeElementsAccessor methods).
 template <typename Subclass, typename ElementsTraitsParam>
-class ElementsAccessorBase : public ElementsAccessor {
+class ElementsAccessorBase : public InternalElementsAccessor {
  public:
   explicit ElementsAccessorBase(const char* name)
-      : ElementsAccessor(name) { }
+      : InternalElementsAccessor(name) {}
 
   typedef ElementsTraitsParam ElementsTraits;
   typedef typename ElementsTraitsParam::BackingStore BackingStore;
@@ -1014,35 +1029,66 @@

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
-    int count = 0;
+    DCHECK_EQ(*nof_items, 0);
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
-    for (int i = 0; i < keys->length(); ++i) {
+    int count = 0;
+    int i = 0;
+    Handle<Map> original_map(object->map(), isolate);
+
+    for (; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
-      Handle<Object> value;
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
+      Handle<Object> value;
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
+        // This might modify the elements and/or change the elements kind.
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
-      if (get_entries) {
-        value = MakeEntryPair(isolate, index, value);
+      if (get_entries) value = MakeEntryPair(isolate, index, value);
+      values_or_entries->set(count++, *value);
+      if (object->map() != *original_map) break;
+    }
+
+    // Slow path caused by changes in elements kind during iteration.
+    for (; i < keys->length(); i++) {
+      Handle<Object> key(keys->get(i), isolate);
+      uint32_t index;
+      if (!key->ToUint32(&index)) continue;
+
+      if (filter & ONLY_ENUMERABLE) {
+        InternalElementsAccessor* accessor =
+            reinterpret_cast<InternalElementsAccessor*>(
+                object->GetElementsAccessor());
+        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,
+                                                    object->elements(), index);
+        if (entry == kMaxUInt32) continue;
+        PropertyDetails details = accessor->GetDetails(*object, entry);
+        if (!details.IsEnumerable()) continue;
       }
+
+      Handle<Object> value;
+      LookupIterator it(isolate, object, index, LookupIterator::OWN);
+      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
+                                       Nothing<bool>());
+
+      if (get_entries) value = MakeEntryPair(isolate, index, value);
       values_or_entries->set(count++, *value);
     }
 
@@ -1623,12 +1669,13 @@

         return result;
       }
     }
-
+    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     // Iterate through entire range, as accessing elements out of order is
     // observable
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         if (search_for_hole) return Just(true);
@@ -1690,11 +1737,13 @@

                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
 
+    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     // Iterate through entire range, as accessing elements out of order is
     // observable.
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         continue;
@@ -3170,12 +3219,13 @@

                                        Handle<Object> value,
                                        uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
-    Handle<Map> original_map = handle(object->map(), isolate);
+    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
     bool search_for_hole = value->IsUndefined(isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
@@ -3212,11 +3262,12 @@

                                          Handle<Object> value,
                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
-    Handle<Map> original_map = handle(object->map(), isolate);
+    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
",Android,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb%5E/,1," static Maybe<int64_t> IndexOfValueImpl(Isolate* isolate,
 Handle<JSObject> object,

                                          Handle<Object> value,
                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
//flaw_line_below:
    Handle<Map> original_map = handle(object->map(), isolate);
//fix_flaw_line_below:
//    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
//fix_flaw_line_below:
//      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
 continue;
 }

 Handle<Object> element_k =
 Subclass::GetImpl(isolate, *parameter_map, entry);

 if (element_k->IsAccessorPair()) {
 LookupIterator it(isolate, object, k, LookupIterator::OWN);
        DCHECK(it.IsFound());
        DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);
        ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,
 Object::GetPropertyWithAccessor(&it),
 Nothing<int64_t>());

 if (value->StrictEquals(*element_k)) {
 return Just<int64_t>(k);
 }

 if (object->map() != *original_map) {
 // Some mutation occurred in accessor. Abort ""fast"" path.
 return IndexOfValueSlowPath(isolate, object, value, k + 1, length);
 }
 } else if (value->StrictEquals(*element_k)) {
 return Just<int64_t>(k);
 }
 }
 return Just<int64_t>(-1);
 }
"
