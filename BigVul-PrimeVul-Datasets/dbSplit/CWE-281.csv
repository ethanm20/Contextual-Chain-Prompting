,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
8659,186395,,Remote,Not required,,CVE-2017-5033,https://www.cvedetails.com/cve/CVE-2017-5033/,CWE-281,Medium,,Partial,,2017-04-24,4.3,"Blink in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android failed to correctly propagate CSP restrictions to local scheme pages, which allowed a remote attacker to bypass content security policy via a crafted HTML page, related to the unsafe-inline keyword.",2019-10-02,Bypass ,1,https://github.com/chromium/chromium/commit/14f2111f9cec919a450115ce4914f228effca58e,14f2111f9cec919a450115ce4914f228effca58e,"Revert ""Add explicit flag for compositor scrollbar injected gestures""

This reverts commit d9a56afcbdf9850bc39bb3edb56d07d11a1eb2b2.

Reason for revert:

Findit (https://goo.gl/kROfz5) identified CL at revision 669086 as the
culprit for flakes in the build cycles as shown on:
https://analysis.chromium.org/p/chromium/flake-portal/analysis/culprit?key=ag9zfmZpbmRpdC1mb3ItbWVyQwsSDEZsYWtlQ3VscHJpdCIxY2hyb21pdW0vZDlhNTZhZmNiZGY5ODUwYmMzOWJiM2VkYjU2ZDA3ZDExYTFlYjJiMgw

Sample Failed Build: https://ci.chromium.org/buildbot/chromium.chromiumos/linux-chromeos-rel/25818

Sample Failed Step: content_browsertests on Ubuntu-16.04

Sample Flaky Test: ScrollLatencyScrollbarBrowserTest.ScrollbarThumbDragLatency

Original change's description:
> Add explicit flag for compositor scrollbar injected gestures
> 
> The original change to enable scrollbar latency for the composited
> scrollbars incorrectly used an existing member to try and determine
> whether a GestureScrollUpdate was the first one in an injected sequence
> or not. is_first_gesture_scroll_update_ was incorrect because it is only
> updated when input is actually dispatched to InputHandlerProxy, and the
> flag is cleared for all GSUs before the location where it was being
> read.
> 
> This bug was missed because of incorrect tests. The
> VerifyRecordedSamplesForHistogram method doesn't actually assert or
> expect anything - the return value must be inspected.
> 
> As part of fixing up the tests, I made a few other changes to get them
> passing consistently across all platforms:
> - turn on main thread scrollbar injection feature (in case it's ever
>   turned off we don't want the tests to start failing)
> - enable mock scrollbars
> - disable smooth scrolling
> - don't run scrollbar tests on Android
> 
> The composited scrollbar button test is disabled due to a bug in how
> the mock theme reports its button sizes, which throws off the region
> detection in ScrollbarLayerImplBase::IdentifyScrollbarPart (filed
> crbug.com/974063 for this issue).
> 
> Change-Id: Ie1a762a5f6ecc264d22f0256db68f141fc76b950
> 
> Bug: 954007
> Change-Id: Ib258e08e083e79da90ba2e4e4216e4879cf00cf7
> Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1652741
> Commit-Queue: Daniel Libby <dlibby@microsoft.com>
> Reviewed-by: David Bokan <bokan@chromium.org>
> Cr-Commit-Position: refs/heads/master@{#669086}


Change-Id: Icc743e48fa740fe27f0cb0cfa21b209a696f518c
No-Presubmit: true
No-Tree-Checks: true
No-Try: true
Bug: 954007
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1660114
Cr-Commit-Position: refs/heads/master@{#669150}",5,content/browser/renderer_host/input/scroll_latency_browsertest.cc,"{""sha"": ""1f98c08075cfc4dbc85a034e423ed241a3781df9"", ""filename"": ""content/browser/renderer_host/input/scroll_latency_browsertest.cc"", ""status"": ""modified"", ""additions"": 106, ""deletions"": 157, ""changes"": 263, ""blob_url"": ""https://github.com/chromium/chromium/blob/14f2111f9cec919a450115ce4914f228effca58e/content/browser/renderer_host/input/scroll_latency_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/14f2111f9cec919a450115ce4914f228effca58e/content/browser/renderer_host/input/scroll_latency_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/input/scroll_latency_browsertest.cc?ref=14f2111f9cec919a450115ce4914f228effca58e"", ""patch"": ""@@ -9,7 +9,6 @@\n #include \""base/run_loop.h\""\n #include \""base/test/metrics/histogram_tester.h\""\n #include \""base/test/scoped_feature_list.h\""\n-#include \""build/build_config.h\""\n #include \""cc/base/switches.h\""\n #include \""content/browser/renderer_host/input/synthetic_gesture.h\""\n #include \""content/browser/renderer_host/input/synthetic_gesture_controller.h\""\n@@ -27,9 +26,7 @@\n #include \""content/public/test/content_browser_test_utils.h\""\n #include \""content/public/test/hit_test_region_observer.h\""\n #include \""content/shell/browser/shell.h\""\n-#include \""third_party/blink/public/common/features.h\""\n #include \""ui/base/ui_base_features.h\""\n-#include \""ui/native_theme/native_theme_features.h\""\n \n namespace {\n \n@@ -104,15 +101,11 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {\n   }\n \n   void LoadURL() {\n-    WebContents* contents = shell()->web_contents();\n-    WebPreferences prefs =\n-        contents->GetRenderViewHost()->GetWebkitPreferences();\n-    prefs.mock_scrollbars_enabled = true;\n-    contents->GetRenderViewHost()->UpdateWebkitPreferences(prefs);\n     const GURL data_url(kDataURL);\n     NavigateToURL(shell(), data_url);\n \n     RenderWidgetHostImpl* host = GetWidgetHost();\n+    host->GetView()->SetSize(gfx::Size(400, 400));\n \n     HitTestRegionObserver observer(host->GetFrameSinkId());\n \n@@ -181,19 +174,117 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {\n     }\n   }\n \n+  void RunScrollbarButtonLatencyTest() {\n+    // Click on the forward scrollbar button to induce a compositor thread\n+    // scrollbar scroll.\n+    blink::WebFloatPoint scrollbar_forward_button(795, 595);\n+    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,\n+        scrollbar_forward_button.y, 0);\n+    mouse_event.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_event.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n+\n+    mouse_event.SetType(blink::WebInputEvent::kMouseUp);\n+    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n+\n+    RunUntilInputProcessed(GetWidgetHost());\n+\n+    FetchHistogramsFromChildProcesses();\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1,\n+        \""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1,\n+        \""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+    std::string thread_name =\n+        DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled_\"" + thread_name);\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_\"" +\n+               thread_name);\n+  }\n+\n+  void RunScrollbarThumbDragLatencyTest() {\n+    // Click on the scrollbar thumb and drag it twice to induce a compositor\n+    // thread scrollbar ScrollBegin and ScrollUpdate.\n+    blink::WebFloatPoint scrollbar_thumb(795, 30);\n+    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,\n+        0);\n+    mouse_down.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_down.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_down);\n+\n+    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,\n+        scrollbar_thumb.y + 10, 0);\n+    mouse_move.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_move.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n+    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n+    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n+    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n+\n+    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,\n+        scrollbar_thumb.y + 20, 0);\n+    mouse_up.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_up.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_up);\n+\n+    RunUntilInputProcessed(GetWidgetHost());\n+\n+    FetchHistogramsFromChildProcesses();\n+    const std::string scroll_types[] = {\""ScrollBegin\"", \""ScrollUpdate\""};\n+    for (const std::string& scroll_type : scroll_types) {\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.RendererSwapToBrowserNotified2\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.BrowserNotifiedToBeforeGpuSwap2\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type + \"".Scrollbar.GpuSwap2\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+      std::string thread_name =\n+          DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n+      VerifyRecordedSamplesForHistogram(1, \""Event.Latency.\"" + scroll_type +\n+                                               \"".Scrollbar.TimeToHandled_\"" +\n+                                               thread_name);\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.HandledToRendererSwap2_\"" + thread_name);\n+    }\n+  }\n+\n   // Returns true if the given histogram has recorded the expected number of\n   // samples.\n-  WARN_UNUSED_RESULT bool VerifyRecordedSamplesForHistogram(\n+  bool VerifyRecordedSamplesForHistogram(\n       const size_t num_samples,\n       const std::string& histogram_name) const {\n     return num_samples ==\n            histogram_tester_.GetAllSamples(histogram_name).size();\n   }\n \n+  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }\n+\n   std::unique_ptr<base::RunLoop> run_loop_;\n   bool disable_threaded_scrolling_ = false;\n \n- protected:\n+ private:\n   base::HistogramTester histogram_tester_;\n   uint32_t visual_state_callback_count_ = 0;\n \n@@ -264,166 +355,24 @@ IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest,\n       0, \""Event.Latency.ScrollBegin.Touch.TimeToScrollUpdateSwapBegin4\""));\n }\n \n-class ScrollLatencyScrollbarBrowserTest : public ScrollLatencyBrowserTest {\n- public:\n-  ScrollLatencyScrollbarBrowserTest() {}\n-\n-  void SetUpCommandLine(base::CommandLine* command_line) override {\n-    command_line->AppendSwitch(::switches::kDisableSmoothScrolling);\n-  }\n-\n-  void SetUp() override {\n-    // Enable |kScrollbarInjectScrollGestures|, as these tests depend on it\n-    // being on. Disable kOverlayScrollbar since overlay scrollbars are not\n-    // hit-testable (thus input is not routed to scrollbars).\n-    scoped_feature_list_.InitWithFeatures(\n-        {blink::features::kScrollbarInjectScrollGestures},\n-        {features::kOverlayScrollbar});\n-    ScrollLatencyBrowserTest::SetUp();\n-  }\n-  ~ScrollLatencyScrollbarBrowserTest() override {}\n-\n- protected:\n-  void RunScrollbarButtonLatencyTest() {\n-    // We don't run tests that click the scrollbar on Android for a few reasons:\n-    //  - Mobile browser uses scrollbars that are not hit-testable.\n-    //  - On Android, you cannot resize the RenderWidgetHostView (see\n-    //    |RenderWidgetHostViewAndroid::SetSize()|) and thus getting consistent\n-    //    coordinates to manipulate the scrollbar is different from other\n-    //    platforms.\n-    // We could overcome the first limitation, by toggling various features\n-    // and WebPreferences (e.g. kOverlayScrollbar feature, and\n-    // viewport_enabled and use_solid_color_scrollbars WebPreferences) but at\n-    // that point, we're not really testing a shipping configuration.\n-#if !defined(OS_ANDROID)\n-\n-    // Click on the forward scrollbar button to induce a compositor thread\n-    // scrollbar scroll.\n-    blink::WebFloatPoint scrollbar_forward_button(795, 595);\n-    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,\n-        scrollbar_forward_button.y, 0);\n-    mouse_event.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_event.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n-\n-    mouse_event.SetType(blink::WebInputEvent::kMouseUp);\n-    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n-\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    FetchHistogramsFromChildProcesses();\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\""));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1,\n-        \""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2\""));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1,\n-        \""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2\""));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1, \""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2\""));\n-    std::string thread_name =\n-        DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1,\n-        \""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled2_\"" + thread_name));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1, \""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_\"" +\n-               thread_name));\n-#endif  // !defined(OS_ANDROID)\n-  }\n-\n-  void RunScrollbarThumbDragLatencyTest() {\n-    // See above comment in RunScrollbarButtonLatencyTest for why this test\n-    // doesn't run on Android.\n-#if !defined(OS_ANDROID)\n-    // Click on the scrollbar thumb and drag it twice to induce a compositor\n-    // thread scrollbar ScrollBegin and ScrollUpdate.\n-    blink::WebFloatPoint scrollbar_thumb(795, 30);\n-    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,\n-        0);\n-    mouse_down.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_down.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_down);\n-\n-    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,\n-        scrollbar_thumb.y + 10, 0);\n-    mouse_move.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_move.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n-    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n-    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,\n-        scrollbar_thumb.y + 20, 0);\n-    mouse_up.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_up.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_up);\n-\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    FetchHistogramsFromChildProcesses();\n-    const std::string scroll_types[] = {\""ScrollBegin\"", \""ScrollUpdate\""};\n-    for (const std::string& scroll_type : scroll_types) {\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.TimeToScrollUpdateSwapBegin4\""));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.RendererSwapToBrowserNotified2\""));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.BrowserNotifiedToBeforeGpuSwap2\""));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type + \"".Scrollbar.GpuSwap2\""));\n-      std::string thread_name =\n-          DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type + \"".Scrollbar.TimeToHandled2_\"" +\n-                 thread_name));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.HandledToRendererSwap2_\"" + thread_name));\n-    }\n-#endif  // !defined(OS_ANDROID)\n-  }\n-\n-  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }\n-\n-  base::test::ScopedFeatureList scoped_feature_list_;\n-};\n-\n-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,\n-                       ScrollbarButtonLatency) {\n+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarButtonLatency) {\n   LoadURL();\n \n   RunScrollbarButtonLatencyTest();\n }\n \n-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,\n-                       ScrollbarThumbDragLatency) {\n+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarThumbDragLatency) {\n   LoadURL();\n \n   RunScrollbarThumbDragLatencyTest();\n }\n \n class ScrollLatencyCompositedScrollbarBrowserTest\n-    : public ScrollLatencyScrollbarBrowserTest {\n+    : public ScrollLatencyBrowserTest {\n  public:\n-  ScrollLatencyCompositedScrollbarBrowserTest() {}\n-\n-  void SetUp() override {\n+  ScrollLatencyCompositedScrollbarBrowserTest() {\n     scoped_feature_list_.InitAndEnableFeature(\n         features::kCompositorThreadedScrollbarScrolling);\n-    ScrollLatencyScrollbarBrowserTest::SetUp();\n   }\n   ~ScrollLatencyCompositedScrollbarBrowserTest() override {}\n \n@@ -434,7 +383,7 @@ class ScrollLatencyCompositedScrollbarBrowserTest\n };\n \n IN_PROC_BROWSER_TEST_F(ScrollLatencyCompositedScrollbarBrowserTest,\n-                       DISABLED_ScrollbarButtonLatency) {\n+                       ScrollbarButtonLatency) {\n   LoadURL();\n \n   RunScrollbarButtonLatencyTest();""}<_**next**_>{""sha"": ""053fa0d159e192dd8c6bbc001bf363dda3cb977d"", ""filename"": ""ui/events/blink/input_handler_proxy.cc"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 20, ""changes"": 52, ""blob_url"": ""https://github.com/chromium/chromium/blob/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/events/blink/input_handler_proxy.cc?ref=14f2111f9cec919a450115ce4914f228effca58e"", ""patch"": ""@@ -174,7 +174,6 @@ InputHandlerProxy::InputHandlerProxy(cc::InputHandler* input_handler,\n       current_overscroll_params_(nullptr),\n       has_ongoing_compositor_scroll_or_pinch_(false),\n       is_first_gesture_scroll_update_(false),\n-      last_injected_gesture_was_begin_(false),\n       tick_clock_(base::DefaultTickClock::GetInstance()),\n       snap_fling_controller_(std::make_unique<cc::SnapFlingController>(this)),\n       compositor_touch_action_enabled_(\n@@ -312,10 +311,15 @@ void InputHandlerProxy::DispatchSingleInputEvent(\n \n   current_overscroll_params_.reset();\n \n+  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();\n+  if (type == blink::WebGestureEvent::kGestureScrollUpdate) {\n+    EnsureScrollUpdateLatencyComponent(\n+        &monitored_latency_info, event_with_callback->event().TimeStamp());\n+  }\n+\n   InputHandlerProxy::EventDisposition disposition = RouteToTypeSpecificHandler(\n       event_with_callback->event(), original_latency_info);\n \n-  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();\n   switch (type) {\n     case blink::WebGestureEvent::kGestureScrollBegin:\n       is_first_gesture_scroll_update_ = true;\n@@ -361,6 +365,32 @@ void InputHandlerProxy::DispatchSingleInputEvent(\n                                     std::move(current_overscroll_params_));\n }\n \n+// Scroll updates injected from within the renderer process will not have a\n+// scroll update component, since those are added to the latency info\n+// in the browser process before being dispatched to the renderer.\n+void InputHandlerProxy::EnsureScrollUpdateLatencyComponent(\n+    LatencyInfo* monitored_latency_info,\n+    base::TimeTicks original_timestamp) {\n+  // Currently we only expect LatencyInfo's of type SCROLLBAR to get into\n+  // this state, but there are a few exceptions (i.e. GestureScrollUpdates\n+  // that are coalesced with GesturePinchUpdates via\n+  // CompositorThreadEventQueue::Queue/CoalesceScrollAndPinch).\n+  // TODO(dlibby): Update that codepath and turn this into a DCHECK when there\n+  // is a missing scroll update component.\n+  if (monitored_latency_info->source_event_type() !=\n+      ui::SourceEventType::SCROLLBAR)\n+    return;\n+\n+  // Add a scroll update component to the latency info if one doesn't exist,\n+  // based on whether or not this is the first scroll update we've seen in a\n+  // gesture sequence.\n+  monitored_latency_info->AddLatencyNumberWithTimestamp(\n+      (is_first_gesture_scroll_update_)\n+          ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT\n+          : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,\n+      original_timestamp, 1);\n+}\n+\n void InputHandlerProxy::DispatchQueuedInputEvents() {\n   // Calling |NowTicks()| is expensive so we only want to do it once.\n   base::TimeTicks now = tick_clock_->NowTicks();\n@@ -406,24 +436,6 @@ void InputHandlerProxy::InjectScrollbarGestureScroll(\n   DCHECK(!scrollbar_latency_info.FindLatency(\n       ui::INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL_COMPONENT, nullptr));\n \n-  if (type == WebInputEvent::Type::kGestureScrollBegin) {\n-    last_injected_gesture_was_begin_ = true;\n-  } else {\n-    if (type == WebInputEvent::Type::kGestureScrollUpdate) {\n-      // For injected GSUs, add a scroll update component to the latency info\n-      // so that it is properly classified as a scroll. If the last injected\n-      // gesture was a GSB, then this GSU is the first scroll update - mark\n-      // the LatencyInfo as such.\n-      scrollbar_latency_info.AddLatencyNumberWithTimestamp(\n-          (last_injected_gesture_was_begin_)\n-              ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT\n-              : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,\n-          original_timestamp, 1);\n-    }\n-\n-    last_injected_gesture_was_begin_ = false;\n-  }\n-\n   std::unique_ptr<EventWithCallback> gesture_event_with_callback_update =\n       std::make_unique<EventWithCallback>(\n           std::move(web_scoped_gesture_event), scrollbar_latency_info,""}<_**next**_>{""sha"": ""dd9f0d6a96f7e222b2d991a58df09571c09ef7a9"", ""filename"": ""ui/events/blink/input_handler_proxy.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/events/blink/input_handler_proxy.h?ref=14f2111f9cec919a450115ce4914f228effca58e"", ""patch"": ""@@ -187,6 +187,12 @@ class InputHandlerProxy : public cc::InputHandlerClient,\n       bool* is_touching_scrolling_layer,\n       cc::TouchAction* white_listed_touch_action);\n \n+  // Scroll updates injected from within the renderer process will not have a\n+  // scroll update component, since those are added to the latency info\n+  // in the browser process before being dispatched to the renderer.\n+  void EnsureScrollUpdateLatencyComponent(LatencyInfo* monitored_latency_info,\n+                                          base::TimeTicks original_timestamp);\n+\n   InputHandlerProxyClient* client_;\n   cc::InputHandler* input_handler_;\n \n@@ -229,13 +235,6 @@ class InputHandlerProxy : public cc::InputHandlerClient,\n   bool has_ongoing_compositor_scroll_or_pinch_;\n   bool is_first_gesture_scroll_update_;\n \n-  // Whether the last injected scroll gesture was a GestureScrollBegin. Used to\n-  // determine which GestureScrollUpdate is the first in a gesture sequence for\n-  // latency classification. This is separate from\n-  // |is_first_gesture_scroll_update_| and is used to determine which type of\n-  // latency component should be added for injected GestureScrollUpdates.\n-  bool last_injected_gesture_was_begin_;\n-\n   const base::TickClock* tick_clock_;\n \n   std::unique_ptr<cc::SnapFlingController> snap_fling_controller_;""}","   void LoadURL() {
     const GURL data_url(kDataURL);
     NavigateToURL(shell(), data_url);
 
     RenderWidgetHostImpl* host = GetWidgetHost();
    host->GetView()->SetSize(gfx::Size(400, 400));
 
     HitTestRegionObserver observer(host->GetFrameSinkId());
 
    observer.WaitForHitTestData();
  }
","   void LoadURL() {
    WebContents* contents = shell()->web_contents();
    WebPreferences prefs =
        contents->GetRenderViewHost()->GetWebkitPreferences();
    prefs.mock_scrollbars_enabled = true;
    contents->GetRenderViewHost()->UpdateWebkitPreferences(prefs);
     const GURL data_url(kDataURL);
     NavigateToURL(shell(), data_url);
 
     RenderWidgetHostImpl* host = GetWidgetHost();
 
     HitTestRegionObserver observer(host->GetFrameSinkId());
 
    observer.WaitForHitTestData();
  }
",C,"    host->GetView()->SetSize(gfx::Size(400, 400));
","    WebContents* contents = shell()->web_contents();
    WebPreferences prefs =
        contents->GetRenderViewHost()->GetWebkitPreferences();
    prefs.mock_scrollbars_enabled = true;
    contents->GetRenderViewHost()->UpdateWebkitPreferences(prefs);
",,"@@ -9,7 +9,6 @@
 #include ""base/run_loop.h""
 #include ""base/test/metrics/histogram_tester.h""
 #include ""base/test/scoped_feature_list.h""
-#include ""build/build_config.h""
 #include ""cc/base/switches.h""
 #include ""content/browser/renderer_host/input/synthetic_gesture.h""
 #include ""content/browser/renderer_host/input/synthetic_gesture_controller.h""
@@ -27,9 +26,7 @@
 #include ""content/public/test/content_browser_test_utils.h""
 #include ""content/public/test/hit_test_region_observer.h""
 #include ""content/shell/browser/shell.h""
-#include ""third_party/blink/public/common/features.h""
 #include ""ui/base/ui_base_features.h""
-#include ""ui/native_theme/native_theme_features.h""
 
 namespace {
 
@@ -104,15 +101,11 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {
   }
 
   void LoadURL() {
-    WebContents* contents = shell()->web_contents();
-    WebPreferences prefs =
-        contents->GetRenderViewHost()->GetWebkitPreferences();
-    prefs.mock_scrollbars_enabled = true;
-    contents->GetRenderViewHost()->UpdateWebkitPreferences(prefs);
     const GURL data_url(kDataURL);
     NavigateToURL(shell(), data_url);
 
     RenderWidgetHostImpl* host = GetWidgetHost();
+    host->GetView()->SetSize(gfx::Size(400, 400));
 
     HitTestRegionObserver observer(host->GetFrameSinkId());
 
@@ -181,19 +174,117 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {
     }
   }
 
+  void RunScrollbarButtonLatencyTest() {
+    // Click on the forward scrollbar button to induce a compositor thread
+    // scrollbar scroll.
+    blink::WebFloatPoint scrollbar_forward_button(795, 595);
+    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(
+        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,
+        scrollbar_forward_button.y, 0);
+    mouse_event.button = blink::WebMouseEvent::Button::kLeft;
+    mouse_event.SetTimeStamp(base::TimeTicks::Now());
+    GetWidgetHost()->ForwardMouseEvent(mouse_event);
+
+    mouse_event.SetType(blink::WebInputEvent::kMouseUp);
+    GetWidgetHost()->ForwardMouseEvent(mouse_event);
+
+    RunUntilInputProcessed(GetWidgetHost());
+
+    FetchHistogramsFromChildProcesses();
+    VerifyRecordedSamplesForHistogram(
+        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4"");
+    VerifyRecordedSamplesForHistogram(
+        1,
+        ""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2"");
+    VerifyRecordedSamplesForHistogram(
+        1,
+        ""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2"");
+    VerifyRecordedSamplesForHistogram(
+        1, ""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2"");
+    VerifyRecordedSamplesForHistogram(
+        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4"");
+    std::string thread_name =
+        DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
+    VerifyRecordedSamplesForHistogram(
+        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled_"" + thread_name);
+    VerifyRecordedSamplesForHistogram(
+        1, ""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_"" +
+               thread_name);
+  }
+
+  void RunScrollbarThumbDragLatencyTest() {
+    // Click on the scrollbar thumb and drag it twice to induce a compositor
+    // thread scrollbar ScrollBegin and ScrollUpdate.
+    blink::WebFloatPoint scrollbar_thumb(795, 30);
+    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(
+        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,
+        0);
+    mouse_down.button = blink::WebMouseEvent::Button::kLeft;
+    mouse_down.SetTimeStamp(base::TimeTicks::Now());
+    GetWidgetHost()->ForwardMouseEvent(mouse_down);
+
+    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(
+        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,
+        scrollbar_thumb.y + 10, 0);
+    mouse_move.button = blink::WebMouseEvent::Button::kLeft;
+    mouse_move.SetTimeStamp(base::TimeTicks::Now());
+    GetWidgetHost()->ForwardMouseEvent(mouse_move);
+    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);
+    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);
+    GetWidgetHost()->ForwardMouseEvent(mouse_move);
+
+    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(
+        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,
+        scrollbar_thumb.y + 20, 0);
+    mouse_up.button = blink::WebMouseEvent::Button::kLeft;
+    mouse_up.SetTimeStamp(base::TimeTicks::Now());
+    GetWidgetHost()->ForwardMouseEvent(mouse_up);
+
+    RunUntilInputProcessed(GetWidgetHost());
+
+    FetchHistogramsFromChildProcesses();
+    const std::string scroll_types[] = {""ScrollBegin"", ""ScrollUpdate""};
+    for (const std::string& scroll_type : scroll_types) {
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type +
+                 "".Scrollbar.TimeToScrollUpdateSwapBegin4"");
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type +
+                 "".Scrollbar.RendererSwapToBrowserNotified2"");
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type +
+                 "".Scrollbar.BrowserNotifiedToBeforeGpuSwap2"");
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type + "".Scrollbar.GpuSwap2"");
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type +
+                 "".Scrollbar.TimeToScrollUpdateSwapBegin4"");
+      std::string thread_name =
+          DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
+      VerifyRecordedSamplesForHistogram(1, ""Event.Latency."" + scroll_type +
+                                               "".Scrollbar.TimeToHandled_"" +
+                                               thread_name);
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type +
+                 "".Scrollbar.HandledToRendererSwap2_"" + thread_name);
+    }
+  }
+
   // Returns true if the given histogram has recorded the expected number of
   // samples.
-  WARN_UNUSED_RESULT bool VerifyRecordedSamplesForHistogram(
+  bool VerifyRecordedSamplesForHistogram(
       const size_t num_samples,
       const std::string& histogram_name) const {
     return num_samples ==
            histogram_tester_.GetAllSamples(histogram_name).size();
   }
 
+  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }
+
   std::unique_ptr<base::RunLoop> run_loop_;
   bool disable_threaded_scrolling_ = false;
 
- protected:
+ private:
   base::HistogramTester histogram_tester_;
   uint32_t visual_state_callback_count_ = 0;
 
@@ -264,166 +355,24 @@ IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest,
       0, ""Event.Latency.ScrollBegin.Touch.TimeToScrollUpdateSwapBegin4""));
 }
 
-class ScrollLatencyScrollbarBrowserTest : public ScrollLatencyBrowserTest {
- public:
-  ScrollLatencyScrollbarBrowserTest() {}
-
-  void SetUpCommandLine(base::CommandLine* command_line) override {
-    command_line->AppendSwitch(::switches::kDisableSmoothScrolling);
-  }
-
-  void SetUp() override {
-    // Enable |kScrollbarInjectScrollGestures|, as these tests depend on it
-    // being on. Disable kOverlayScrollbar since overlay scrollbars are not
-    // hit-testable (thus input is not routed to scrollbars).
-    scoped_feature_list_.InitWithFeatures(
-        {blink::features::kScrollbarInjectScrollGestures},
-        {features::kOverlayScrollbar});
-    ScrollLatencyBrowserTest::SetUp();
-  }
-  ~ScrollLatencyScrollbarBrowserTest() override {}
-
- protected:
-  void RunScrollbarButtonLatencyTest() {
-    // We don't run tests that click the scrollbar on Android for a few reasons:
-    //  - Mobile browser uses scrollbars that are not hit-testable.
-    //  - On Android, you cannot resize the RenderWidgetHostView (see
-    //    |RenderWidgetHostViewAndroid::SetSize()|) and thus getting consistent
-    //    coordinates to manipulate the scrollbar is different from other
-    //    platforms.
-    // We could overcome the first limitation, by toggling various features
-    // and WebPreferences (e.g. kOverlayScrollbar feature, and
-    // viewport_enabled and use_solid_color_scrollbars WebPreferences) but at
-    // that point, we're not really testing a shipping configuration.
-#if !defined(OS_ANDROID)
-
-    // Click on the forward scrollbar button to induce a compositor thread
-    // scrollbar scroll.
-    blink::WebFloatPoint scrollbar_forward_button(795, 595);
-    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(
-        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,
-        scrollbar_forward_button.y, 0);
-    mouse_event.button = blink::WebMouseEvent::Button::kLeft;
-    mouse_event.SetTimeStamp(base::TimeTicks::Now());
-    GetWidgetHost()->ForwardMouseEvent(mouse_event);
-
-    mouse_event.SetType(blink::WebInputEvent::kMouseUp);
-    GetWidgetHost()->ForwardMouseEvent(mouse_event);
-
-    RunUntilInputProcessed(GetWidgetHost());
-
-    FetchHistogramsFromChildProcesses();
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4""));
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1,
-        ""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2""));
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1,
-        ""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2""));
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1, ""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2""));
-    std::string thread_name =
-        DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1,
-        ""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled2_"" + thread_name));
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1, ""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_"" +
-               thread_name));
-#endif  // !defined(OS_ANDROID)
-  }
-
-  void RunScrollbarThumbDragLatencyTest() {
-    // See above comment in RunScrollbarButtonLatencyTest for why this test
-    // doesn't run on Android.
-#if !defined(OS_ANDROID)
-    // Click on the scrollbar thumb and drag it twice to induce a compositor
-    // thread scrollbar ScrollBegin and ScrollUpdate.
-    blink::WebFloatPoint scrollbar_thumb(795, 30);
-    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(
-        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,
-        0);
-    mouse_down.button = blink::WebMouseEvent::Button::kLeft;
-    mouse_down.SetTimeStamp(base::TimeTicks::Now());
-    GetWidgetHost()->ForwardMouseEvent(mouse_down);
-
-    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(
-        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,
-        scrollbar_thumb.y + 10, 0);
-    mouse_move.button = blink::WebMouseEvent::Button::kLeft;
-    mouse_move.SetTimeStamp(base::TimeTicks::Now());
-    GetWidgetHost()->ForwardMouseEvent(mouse_move);
-    RunUntilInputProcessed(GetWidgetHost());
-
-    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);
-    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);
-    GetWidgetHost()->ForwardMouseEvent(mouse_move);
-    RunUntilInputProcessed(GetWidgetHost());
-
-    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(
-        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,
-        scrollbar_thumb.y + 20, 0);
-    mouse_up.button = blink::WebMouseEvent::Button::kLeft;
-    mouse_up.SetTimeStamp(base::TimeTicks::Now());
-    GetWidgetHost()->ForwardMouseEvent(mouse_up);
-
-    RunUntilInputProcessed(GetWidgetHost());
-
-    FetchHistogramsFromChildProcesses();
-    const std::string scroll_types[] = {""ScrollBegin"", ""ScrollUpdate""};
-    for (const std::string& scroll_type : scroll_types) {
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type +
-                 "".Scrollbar.TimeToScrollUpdateSwapBegin4""));
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type +
-                 "".Scrollbar.RendererSwapToBrowserNotified2""));
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type +
-                 "".Scrollbar.BrowserNotifiedToBeforeGpuSwap2""));
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type + "".Scrollbar.GpuSwap2""));
-      std::string thread_name =
-          DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type + "".Scrollbar.TimeToHandled2_"" +
-                 thread_name));
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type +
-                 "".Scrollbar.HandledToRendererSwap2_"" + thread_name));
-    }
-#endif  // !defined(OS_ANDROID)
-  }
-
-  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }
-
-  base::test::ScopedFeatureList scoped_feature_list_;
-};
-
-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,
-                       ScrollbarButtonLatency) {
+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarButtonLatency) {
   LoadURL();
 
   RunScrollbarButtonLatencyTest();
 }
 
-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,
-                       ScrollbarThumbDragLatency) {
+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarThumbDragLatency) {
   LoadURL();
 
   RunScrollbarThumbDragLatencyTest();
 }
 
 class ScrollLatencyCompositedScrollbarBrowserTest
-    : public ScrollLatencyScrollbarBrowserTest {
+    : public ScrollLatencyBrowserTest {
  public:
-  ScrollLatencyCompositedScrollbarBrowserTest() {}
-
-  void SetUp() override {
+  ScrollLatencyCompositedScrollbarBrowserTest() {
     scoped_feature_list_.InitAndEnableFeature(
         features::kCompositorThreadedScrollbarScrolling);
-    ScrollLatencyScrollbarBrowserTest::SetUp();
   }
   ~ScrollLatencyCompositedScrollbarBrowserTest() override {}
 
@@ -434,7 +383,7 @@ class ScrollLatencyCompositedScrollbarBrowserTest
 };
 
 IN_PROC_BROWSER_TEST_F(ScrollLatencyCompositedScrollbarBrowserTest,
-                       DISABLED_ScrollbarButtonLatency) {
+                       ScrollbarButtonLatency) {
   LoadURL();
 
   RunScrollbarButtonLatencyTest();",Chrome,14f2111f9cec919a450115ce4914f228effca58e,a7237f2e9866ca6088cffbb38668728606120a17,1,"   void LoadURL() {
//flaw_line_below:
    WebContents* contents = shell()->web_contents();
//flaw_line_below:
    WebPreferences prefs =
//flaw_line_below:
        contents->GetRenderViewHost()->GetWebkitPreferences();
//flaw_line_below:
    prefs.mock_scrollbars_enabled = true;
//flaw_line_below:
    contents->GetRenderViewHost()->UpdateWebkitPreferences(prefs);
     const GURL data_url(kDataURL);
     NavigateToURL(shell(), data_url);
 
     RenderWidgetHostImpl* host = GetWidgetHost();
//fix_flaw_line_below:
//    host->GetView()->SetSize(gfx::Size(400, 400));
 
     HitTestRegionObserver observer(host->GetFrameSinkId());
 
    // Wait for the hit test data to be ready
    observer.WaitForHitTestData();
  }
"
8660,186396,,Remote,Not required,,CVE-2017-5033,https://www.cvedetails.com/cve/CVE-2017-5033/,CWE-281,Medium,,Partial,,2017-04-24,4.3,"Blink in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android failed to correctly propagate CSP restrictions to local scheme pages, which allowed a remote attacker to bypass content security policy via a crafted HTML page, related to the unsafe-inline keyword.",2019-10-02,Bypass ,0,https://github.com/chromium/chromium/commit/14f2111f9cec919a450115ce4914f228effca58e,14f2111f9cec919a450115ce4914f228effca58e,"Revert ""Add explicit flag for compositor scrollbar injected gestures""

This reverts commit d9a56afcbdf9850bc39bb3edb56d07d11a1eb2b2.

Reason for revert:

Findit (https://goo.gl/kROfz5) identified CL at revision 669086 as the
culprit for flakes in the build cycles as shown on:
https://analysis.chromium.org/p/chromium/flake-portal/analysis/culprit?key=ag9zfmZpbmRpdC1mb3ItbWVyQwsSDEZsYWtlQ3VscHJpdCIxY2hyb21pdW0vZDlhNTZhZmNiZGY5ODUwYmMzOWJiM2VkYjU2ZDA3ZDExYTFlYjJiMgw

Sample Failed Build: https://ci.chromium.org/buildbot/chromium.chromiumos/linux-chromeos-rel/25818

Sample Failed Step: content_browsertests on Ubuntu-16.04

Sample Flaky Test: ScrollLatencyScrollbarBrowserTest.ScrollbarThumbDragLatency

Original change's description:
> Add explicit flag for compositor scrollbar injected gestures
> 
> The original change to enable scrollbar latency for the composited
> scrollbars incorrectly used an existing member to try and determine
> whether a GestureScrollUpdate was the first one in an injected sequence
> or not. is_first_gesture_scroll_update_ was incorrect because it is only
> updated when input is actually dispatched to InputHandlerProxy, and the
> flag is cleared for all GSUs before the location where it was being
> read.
> 
> This bug was missed because of incorrect tests. The
> VerifyRecordedSamplesForHistogram method doesn't actually assert or
> expect anything - the return value must be inspected.
> 
> As part of fixing up the tests, I made a few other changes to get them
> passing consistently across all platforms:
> - turn on main thread scrollbar injection feature (in case it's ever
>   turned off we don't want the tests to start failing)
> - enable mock scrollbars
> - disable smooth scrolling
> - don't run scrollbar tests on Android
> 
> The composited scrollbar button test is disabled due to a bug in how
> the mock theme reports its button sizes, which throws off the region
> detection in ScrollbarLayerImplBase::IdentifyScrollbarPart (filed
> crbug.com/974063 for this issue).
> 
> Change-Id: Ie1a762a5f6ecc264d22f0256db68f141fc76b950
> 
> Bug: 954007
> Change-Id: Ib258e08e083e79da90ba2e4e4216e4879cf00cf7
> Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1652741
> Commit-Queue: Daniel Libby <dlibby@microsoft.com>
> Reviewed-by: David Bokan <bokan@chromium.org>
> Cr-Commit-Position: refs/heads/master@{#669086}


Change-Id: Icc743e48fa740fe27f0cb0cfa21b209a696f518c
No-Presubmit: true
No-Tree-Checks: true
No-Try: true
Bug: 954007
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1660114
Cr-Commit-Position: refs/heads/master@{#669150}",32,content/browser/renderer_host/input/scroll_latency_browsertest.cc,"{""sha"": ""1f98c08075cfc4dbc85a034e423ed241a3781df9"", ""filename"": ""content/browser/renderer_host/input/scroll_latency_browsertest.cc"", ""status"": ""modified"", ""additions"": 106, ""deletions"": 157, ""changes"": 263, ""blob_url"": ""https://github.com/chromium/chromium/blob/14f2111f9cec919a450115ce4914f228effca58e/content/browser/renderer_host/input/scroll_latency_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/14f2111f9cec919a450115ce4914f228effca58e/content/browser/renderer_host/input/scroll_latency_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/input/scroll_latency_browsertest.cc?ref=14f2111f9cec919a450115ce4914f228effca58e"", ""patch"": ""@@ -9,7 +9,6 @@\n #include \""base/run_loop.h\""\n #include \""base/test/metrics/histogram_tester.h\""\n #include \""base/test/scoped_feature_list.h\""\n-#include \""build/build_config.h\""\n #include \""cc/base/switches.h\""\n #include \""content/browser/renderer_host/input/synthetic_gesture.h\""\n #include \""content/browser/renderer_host/input/synthetic_gesture_controller.h\""\n@@ -27,9 +26,7 @@\n #include \""content/public/test/content_browser_test_utils.h\""\n #include \""content/public/test/hit_test_region_observer.h\""\n #include \""content/shell/browser/shell.h\""\n-#include \""third_party/blink/public/common/features.h\""\n #include \""ui/base/ui_base_features.h\""\n-#include \""ui/native_theme/native_theme_features.h\""\n \n namespace {\n \n@@ -104,15 +101,11 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {\n   }\n \n   void LoadURL() {\n-    WebContents* contents = shell()->web_contents();\n-    WebPreferences prefs =\n-        contents->GetRenderViewHost()->GetWebkitPreferences();\n-    prefs.mock_scrollbars_enabled = true;\n-    contents->GetRenderViewHost()->UpdateWebkitPreferences(prefs);\n     const GURL data_url(kDataURL);\n     NavigateToURL(shell(), data_url);\n \n     RenderWidgetHostImpl* host = GetWidgetHost();\n+    host->GetView()->SetSize(gfx::Size(400, 400));\n \n     HitTestRegionObserver observer(host->GetFrameSinkId());\n \n@@ -181,19 +174,117 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {\n     }\n   }\n \n+  void RunScrollbarButtonLatencyTest() {\n+    // Click on the forward scrollbar button to induce a compositor thread\n+    // scrollbar scroll.\n+    blink::WebFloatPoint scrollbar_forward_button(795, 595);\n+    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,\n+        scrollbar_forward_button.y, 0);\n+    mouse_event.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_event.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n+\n+    mouse_event.SetType(blink::WebInputEvent::kMouseUp);\n+    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n+\n+    RunUntilInputProcessed(GetWidgetHost());\n+\n+    FetchHistogramsFromChildProcesses();\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1,\n+        \""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1,\n+        \""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+    std::string thread_name =\n+        DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled_\"" + thread_name);\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_\"" +\n+               thread_name);\n+  }\n+\n+  void RunScrollbarThumbDragLatencyTest() {\n+    // Click on the scrollbar thumb and drag it twice to induce a compositor\n+    // thread scrollbar ScrollBegin and ScrollUpdate.\n+    blink::WebFloatPoint scrollbar_thumb(795, 30);\n+    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,\n+        0);\n+    mouse_down.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_down.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_down);\n+\n+    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,\n+        scrollbar_thumb.y + 10, 0);\n+    mouse_move.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_move.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n+    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n+    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n+    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n+\n+    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,\n+        scrollbar_thumb.y + 20, 0);\n+    mouse_up.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_up.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_up);\n+\n+    RunUntilInputProcessed(GetWidgetHost());\n+\n+    FetchHistogramsFromChildProcesses();\n+    const std::string scroll_types[] = {\""ScrollBegin\"", \""ScrollUpdate\""};\n+    for (const std::string& scroll_type : scroll_types) {\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.RendererSwapToBrowserNotified2\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.BrowserNotifiedToBeforeGpuSwap2\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type + \"".Scrollbar.GpuSwap2\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+      std::string thread_name =\n+          DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n+      VerifyRecordedSamplesForHistogram(1, \""Event.Latency.\"" + scroll_type +\n+                                               \"".Scrollbar.TimeToHandled_\"" +\n+                                               thread_name);\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.HandledToRendererSwap2_\"" + thread_name);\n+    }\n+  }\n+\n   // Returns true if the given histogram has recorded the expected number of\n   // samples.\n-  WARN_UNUSED_RESULT bool VerifyRecordedSamplesForHistogram(\n+  bool VerifyRecordedSamplesForHistogram(\n       const size_t num_samples,\n       const std::string& histogram_name) const {\n     return num_samples ==\n            histogram_tester_.GetAllSamples(histogram_name).size();\n   }\n \n+  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }\n+\n   std::unique_ptr<base::RunLoop> run_loop_;\n   bool disable_threaded_scrolling_ = false;\n \n- protected:\n+ private:\n   base::HistogramTester histogram_tester_;\n   uint32_t visual_state_callback_count_ = 0;\n \n@@ -264,166 +355,24 @@ IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest,\n       0, \""Event.Latency.ScrollBegin.Touch.TimeToScrollUpdateSwapBegin4\""));\n }\n \n-class ScrollLatencyScrollbarBrowserTest : public ScrollLatencyBrowserTest {\n- public:\n-  ScrollLatencyScrollbarBrowserTest() {}\n-\n-  void SetUpCommandLine(base::CommandLine* command_line) override {\n-    command_line->AppendSwitch(::switches::kDisableSmoothScrolling);\n-  }\n-\n-  void SetUp() override {\n-    // Enable |kScrollbarInjectScrollGestures|, as these tests depend on it\n-    // being on. Disable kOverlayScrollbar since overlay scrollbars are not\n-    // hit-testable (thus input is not routed to scrollbars).\n-    scoped_feature_list_.InitWithFeatures(\n-        {blink::features::kScrollbarInjectScrollGestures},\n-        {features::kOverlayScrollbar});\n-    ScrollLatencyBrowserTest::SetUp();\n-  }\n-  ~ScrollLatencyScrollbarBrowserTest() override {}\n-\n- protected:\n-  void RunScrollbarButtonLatencyTest() {\n-    // We don't run tests that click the scrollbar on Android for a few reasons:\n-    //  - Mobile browser uses scrollbars that are not hit-testable.\n-    //  - On Android, you cannot resize the RenderWidgetHostView (see\n-    //    |RenderWidgetHostViewAndroid::SetSize()|) and thus getting consistent\n-    //    coordinates to manipulate the scrollbar is different from other\n-    //    platforms.\n-    // We could overcome the first limitation, by toggling various features\n-    // and WebPreferences (e.g. kOverlayScrollbar feature, and\n-    // viewport_enabled and use_solid_color_scrollbars WebPreferences) but at\n-    // that point, we're not really testing a shipping configuration.\n-#if !defined(OS_ANDROID)\n-\n-    // Click on the forward scrollbar button to induce a compositor thread\n-    // scrollbar scroll.\n-    blink::WebFloatPoint scrollbar_forward_button(795, 595);\n-    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,\n-        scrollbar_forward_button.y, 0);\n-    mouse_event.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_event.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n-\n-    mouse_event.SetType(blink::WebInputEvent::kMouseUp);\n-    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n-\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    FetchHistogramsFromChildProcesses();\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\""));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1,\n-        \""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2\""));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1,\n-        \""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2\""));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1, \""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2\""));\n-    std::string thread_name =\n-        DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1,\n-        \""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled2_\"" + thread_name));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1, \""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_\"" +\n-               thread_name));\n-#endif  // !defined(OS_ANDROID)\n-  }\n-\n-  void RunScrollbarThumbDragLatencyTest() {\n-    // See above comment in RunScrollbarButtonLatencyTest for why this test\n-    // doesn't run on Android.\n-#if !defined(OS_ANDROID)\n-    // Click on the scrollbar thumb and drag it twice to induce a compositor\n-    // thread scrollbar ScrollBegin and ScrollUpdate.\n-    blink::WebFloatPoint scrollbar_thumb(795, 30);\n-    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,\n-        0);\n-    mouse_down.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_down.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_down);\n-\n-    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,\n-        scrollbar_thumb.y + 10, 0);\n-    mouse_move.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_move.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n-    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n-    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,\n-        scrollbar_thumb.y + 20, 0);\n-    mouse_up.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_up.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_up);\n-\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    FetchHistogramsFromChildProcesses();\n-    const std::string scroll_types[] = {\""ScrollBegin\"", \""ScrollUpdate\""};\n-    for (const std::string& scroll_type : scroll_types) {\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.TimeToScrollUpdateSwapBegin4\""));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.RendererSwapToBrowserNotified2\""));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.BrowserNotifiedToBeforeGpuSwap2\""));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type + \"".Scrollbar.GpuSwap2\""));\n-      std::string thread_name =\n-          DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type + \"".Scrollbar.TimeToHandled2_\"" +\n-                 thread_name));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.HandledToRendererSwap2_\"" + thread_name));\n-    }\n-#endif  // !defined(OS_ANDROID)\n-  }\n-\n-  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }\n-\n-  base::test::ScopedFeatureList scoped_feature_list_;\n-};\n-\n-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,\n-                       ScrollbarButtonLatency) {\n+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarButtonLatency) {\n   LoadURL();\n \n   RunScrollbarButtonLatencyTest();\n }\n \n-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,\n-                       ScrollbarThumbDragLatency) {\n+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarThumbDragLatency) {\n   LoadURL();\n \n   RunScrollbarThumbDragLatencyTest();\n }\n \n class ScrollLatencyCompositedScrollbarBrowserTest\n-    : public ScrollLatencyScrollbarBrowserTest {\n+    : public ScrollLatencyBrowserTest {\n  public:\n-  ScrollLatencyCompositedScrollbarBrowserTest() {}\n-\n-  void SetUp() override {\n+  ScrollLatencyCompositedScrollbarBrowserTest() {\n     scoped_feature_list_.InitAndEnableFeature(\n         features::kCompositorThreadedScrollbarScrolling);\n-    ScrollLatencyScrollbarBrowserTest::SetUp();\n   }\n   ~ScrollLatencyCompositedScrollbarBrowserTest() override {}\n \n@@ -434,7 +383,7 @@ class ScrollLatencyCompositedScrollbarBrowserTest\n };\n \n IN_PROC_BROWSER_TEST_F(ScrollLatencyCompositedScrollbarBrowserTest,\n-                       DISABLED_ScrollbarButtonLatency) {\n+                       ScrollbarButtonLatency) {\n   LoadURL();\n \n   RunScrollbarButtonLatencyTest();""}<_**next**_>{""sha"": ""053fa0d159e192dd8c6bbc001bf363dda3cb977d"", ""filename"": ""ui/events/blink/input_handler_proxy.cc"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 20, ""changes"": 52, ""blob_url"": ""https://github.com/chromium/chromium/blob/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/events/blink/input_handler_proxy.cc?ref=14f2111f9cec919a450115ce4914f228effca58e"", ""patch"": ""@@ -174,7 +174,6 @@ InputHandlerProxy::InputHandlerProxy(cc::InputHandler* input_handler,\n       current_overscroll_params_(nullptr),\n       has_ongoing_compositor_scroll_or_pinch_(false),\n       is_first_gesture_scroll_update_(false),\n-      last_injected_gesture_was_begin_(false),\n       tick_clock_(base::DefaultTickClock::GetInstance()),\n       snap_fling_controller_(std::make_unique<cc::SnapFlingController>(this)),\n       compositor_touch_action_enabled_(\n@@ -312,10 +311,15 @@ void InputHandlerProxy::DispatchSingleInputEvent(\n \n   current_overscroll_params_.reset();\n \n+  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();\n+  if (type == blink::WebGestureEvent::kGestureScrollUpdate) {\n+    EnsureScrollUpdateLatencyComponent(\n+        &monitored_latency_info, event_with_callback->event().TimeStamp());\n+  }\n+\n   InputHandlerProxy::EventDisposition disposition = RouteToTypeSpecificHandler(\n       event_with_callback->event(), original_latency_info);\n \n-  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();\n   switch (type) {\n     case blink::WebGestureEvent::kGestureScrollBegin:\n       is_first_gesture_scroll_update_ = true;\n@@ -361,6 +365,32 @@ void InputHandlerProxy::DispatchSingleInputEvent(\n                                     std::move(current_overscroll_params_));\n }\n \n+// Scroll updates injected from within the renderer process will not have a\n+// scroll update component, since those are added to the latency info\n+// in the browser process before being dispatched to the renderer.\n+void InputHandlerProxy::EnsureScrollUpdateLatencyComponent(\n+    LatencyInfo* monitored_latency_info,\n+    base::TimeTicks original_timestamp) {\n+  // Currently we only expect LatencyInfo's of type SCROLLBAR to get into\n+  // this state, but there are a few exceptions (i.e. GestureScrollUpdates\n+  // that are coalesced with GesturePinchUpdates via\n+  // CompositorThreadEventQueue::Queue/CoalesceScrollAndPinch).\n+  // TODO(dlibby): Update that codepath and turn this into a DCHECK when there\n+  // is a missing scroll update component.\n+  if (monitored_latency_info->source_event_type() !=\n+      ui::SourceEventType::SCROLLBAR)\n+    return;\n+\n+  // Add a scroll update component to the latency info if one doesn't exist,\n+  // based on whether or not this is the first scroll update we've seen in a\n+  // gesture sequence.\n+  monitored_latency_info->AddLatencyNumberWithTimestamp(\n+      (is_first_gesture_scroll_update_)\n+          ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT\n+          : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,\n+      original_timestamp, 1);\n+}\n+\n void InputHandlerProxy::DispatchQueuedInputEvents() {\n   // Calling |NowTicks()| is expensive so we only want to do it once.\n   base::TimeTicks now = tick_clock_->NowTicks();\n@@ -406,24 +436,6 @@ void InputHandlerProxy::InjectScrollbarGestureScroll(\n   DCHECK(!scrollbar_latency_info.FindLatency(\n       ui::INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL_COMPONENT, nullptr));\n \n-  if (type == WebInputEvent::Type::kGestureScrollBegin) {\n-    last_injected_gesture_was_begin_ = true;\n-  } else {\n-    if (type == WebInputEvent::Type::kGestureScrollUpdate) {\n-      // For injected GSUs, add a scroll update component to the latency info\n-      // so that it is properly classified as a scroll. If the last injected\n-      // gesture was a GSB, then this GSU is the first scroll update - mark\n-      // the LatencyInfo as such.\n-      scrollbar_latency_info.AddLatencyNumberWithTimestamp(\n-          (last_injected_gesture_was_begin_)\n-              ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT\n-              : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,\n-          original_timestamp, 1);\n-    }\n-\n-    last_injected_gesture_was_begin_ = false;\n-  }\n-\n   std::unique_ptr<EventWithCallback> gesture_event_with_callback_update =\n       std::make_unique<EventWithCallback>(\n           std::move(web_scoped_gesture_event), scrollbar_latency_info,""}<_**next**_>{""sha"": ""dd9f0d6a96f7e222b2d991a58df09571c09ef7a9"", ""filename"": ""ui/events/blink/input_handler_proxy.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/events/blink/input_handler_proxy.h?ref=14f2111f9cec919a450115ce4914f228effca58e"", ""patch"": ""@@ -187,6 +187,12 @@ class InputHandlerProxy : public cc::InputHandlerClient,\n       bool* is_touching_scrolling_layer,\n       cc::TouchAction* white_listed_touch_action);\n \n+  // Scroll updates injected from within the renderer process will not have a\n+  // scroll update component, since those are added to the latency info\n+  // in the browser process before being dispatched to the renderer.\n+  void EnsureScrollUpdateLatencyComponent(LatencyInfo* monitored_latency_info,\n+                                          base::TimeTicks original_timestamp);\n+\n   InputHandlerProxyClient* client_;\n   cc::InputHandler* input_handler_;\n \n@@ -229,13 +235,6 @@ class InputHandlerProxy : public cc::InputHandlerClient,\n   bool has_ongoing_compositor_scroll_or_pinch_;\n   bool is_first_gesture_scroll_update_;\n \n-  // Whether the last injected scroll gesture was a GestureScrollBegin. Used to\n-  // determine which GestureScrollUpdate is the first in a gesture sequence for\n-  // latency classification. This is separate from\n-  // |is_first_gesture_scroll_update_| and is used to determine which type of\n-  // latency component should be added for injected GestureScrollUpdates.\n-  bool last_injected_gesture_was_begin_;\n-\n   const base::TickClock* tick_clock_;\n \n   std::unique_ptr<cc::SnapFlingController> snap_fling_controller_;""}","  void RunScrollbarButtonLatencyTest() {
","  void RunScrollbarButtonLatencyTest() {
#if !defined(OS_ANDROID)
    blink::WebFloatPoint scrollbar_forward_button(795, 595);
    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(
        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,
        scrollbar_forward_button.y, 0);
    mouse_event.button = blink::WebMouseEvent::Button::kLeft;
    mouse_event.SetTimeStamp(base::TimeTicks::Now());
    GetWidgetHost()->ForwardMouseEvent(mouse_event);
    mouse_event.SetType(blink::WebInputEvent::kMouseUp);
    GetWidgetHost()->ForwardMouseEvent(mouse_event);
    RunUntilInputProcessed(GetWidgetHost());
    FetchHistogramsFromChildProcesses();
    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4""));
    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
        1,
        ""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2""));
    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
        1,
        ""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2""));
    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
        1, ""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2""));
    std::string thread_name =
        DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
        1,
        ""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled2_"" + thread_name));
    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
        1, ""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_"" +
               thread_name));
#endif  // !defined(OS_ANDROID)
  }
",C,,"#if !defined(OS_ANDROID)
    blink::WebFloatPoint scrollbar_forward_button(795, 595);
    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(
        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,
        scrollbar_forward_button.y, 0);
    mouse_event.button = blink::WebMouseEvent::Button::kLeft;
    mouse_event.SetTimeStamp(base::TimeTicks::Now());
    GetWidgetHost()->ForwardMouseEvent(mouse_event);
    mouse_event.SetType(blink::WebInputEvent::kMouseUp);
    GetWidgetHost()->ForwardMouseEvent(mouse_event);
    RunUntilInputProcessed(GetWidgetHost());
    FetchHistogramsFromChildProcesses();
    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4""));
    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
        1,
        ""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2""));
    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
        1,
        ""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2""));
    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
        1, ""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2""));
    std::string thread_name =
        DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
        1,
        ""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled2_"" + thread_name));
    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
        1, ""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_"" +
               thread_name));
#endif  // !defined(OS_ANDROID)
  }
",,"@@ -9,7 +9,6 @@
 #include ""base/run_loop.h""
 #include ""base/test/metrics/histogram_tester.h""
 #include ""base/test/scoped_feature_list.h""
-#include ""build/build_config.h""
 #include ""cc/base/switches.h""
 #include ""content/browser/renderer_host/input/synthetic_gesture.h""
 #include ""content/browser/renderer_host/input/synthetic_gesture_controller.h""
@@ -27,9 +26,7 @@
 #include ""content/public/test/content_browser_test_utils.h""
 #include ""content/public/test/hit_test_region_observer.h""
 #include ""content/shell/browser/shell.h""
-#include ""third_party/blink/public/common/features.h""
 #include ""ui/base/ui_base_features.h""
-#include ""ui/native_theme/native_theme_features.h""
 
 namespace {
 
@@ -104,15 +101,11 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {
   }
 
   void LoadURL() {
-    WebContents* contents = shell()->web_contents();
-    WebPreferences prefs =
-        contents->GetRenderViewHost()->GetWebkitPreferences();
-    prefs.mock_scrollbars_enabled = true;
-    contents->GetRenderViewHost()->UpdateWebkitPreferences(prefs);
     const GURL data_url(kDataURL);
     NavigateToURL(shell(), data_url);
 
     RenderWidgetHostImpl* host = GetWidgetHost();
+    host->GetView()->SetSize(gfx::Size(400, 400));
 
     HitTestRegionObserver observer(host->GetFrameSinkId());
 
@@ -181,19 +174,117 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {
     }
   }
 
+  void RunScrollbarButtonLatencyTest() {
+    // Click on the forward scrollbar button to induce a compositor thread
+    // scrollbar scroll.
+    blink::WebFloatPoint scrollbar_forward_button(795, 595);
+    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(
+        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,
+        scrollbar_forward_button.y, 0);
+    mouse_event.button = blink::WebMouseEvent::Button::kLeft;
+    mouse_event.SetTimeStamp(base::TimeTicks::Now());
+    GetWidgetHost()->ForwardMouseEvent(mouse_event);
+
+    mouse_event.SetType(blink::WebInputEvent::kMouseUp);
+    GetWidgetHost()->ForwardMouseEvent(mouse_event);
+
+    RunUntilInputProcessed(GetWidgetHost());
+
+    FetchHistogramsFromChildProcesses();
+    VerifyRecordedSamplesForHistogram(
+        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4"");
+    VerifyRecordedSamplesForHistogram(
+        1,
+        ""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2"");
+    VerifyRecordedSamplesForHistogram(
+        1,
+        ""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2"");
+    VerifyRecordedSamplesForHistogram(
+        1, ""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2"");
+    VerifyRecordedSamplesForHistogram(
+        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4"");
+    std::string thread_name =
+        DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
+    VerifyRecordedSamplesForHistogram(
+        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled_"" + thread_name);
+    VerifyRecordedSamplesForHistogram(
+        1, ""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_"" +
+               thread_name);
+  }
+
+  void RunScrollbarThumbDragLatencyTest() {
+    // Click on the scrollbar thumb and drag it twice to induce a compositor
+    // thread scrollbar ScrollBegin and ScrollUpdate.
+    blink::WebFloatPoint scrollbar_thumb(795, 30);
+    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(
+        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,
+        0);
+    mouse_down.button = blink::WebMouseEvent::Button::kLeft;
+    mouse_down.SetTimeStamp(base::TimeTicks::Now());
+    GetWidgetHost()->ForwardMouseEvent(mouse_down);
+
+    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(
+        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,
+        scrollbar_thumb.y + 10, 0);
+    mouse_move.button = blink::WebMouseEvent::Button::kLeft;
+    mouse_move.SetTimeStamp(base::TimeTicks::Now());
+    GetWidgetHost()->ForwardMouseEvent(mouse_move);
+    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);
+    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);
+    GetWidgetHost()->ForwardMouseEvent(mouse_move);
+
+    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(
+        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,
+        scrollbar_thumb.y + 20, 0);
+    mouse_up.button = blink::WebMouseEvent::Button::kLeft;
+    mouse_up.SetTimeStamp(base::TimeTicks::Now());
+    GetWidgetHost()->ForwardMouseEvent(mouse_up);
+
+    RunUntilInputProcessed(GetWidgetHost());
+
+    FetchHistogramsFromChildProcesses();
+    const std::string scroll_types[] = {""ScrollBegin"", ""ScrollUpdate""};
+    for (const std::string& scroll_type : scroll_types) {
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type +
+                 "".Scrollbar.TimeToScrollUpdateSwapBegin4"");
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type +
+                 "".Scrollbar.RendererSwapToBrowserNotified2"");
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type +
+                 "".Scrollbar.BrowserNotifiedToBeforeGpuSwap2"");
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type + "".Scrollbar.GpuSwap2"");
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type +
+                 "".Scrollbar.TimeToScrollUpdateSwapBegin4"");
+      std::string thread_name =
+          DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
+      VerifyRecordedSamplesForHistogram(1, ""Event.Latency."" + scroll_type +
+                                               "".Scrollbar.TimeToHandled_"" +
+                                               thread_name);
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type +
+                 "".Scrollbar.HandledToRendererSwap2_"" + thread_name);
+    }
+  }
+
   // Returns true if the given histogram has recorded the expected number of
   // samples.
-  WARN_UNUSED_RESULT bool VerifyRecordedSamplesForHistogram(
+  bool VerifyRecordedSamplesForHistogram(
       const size_t num_samples,
       const std::string& histogram_name) const {
     return num_samples ==
            histogram_tester_.GetAllSamples(histogram_name).size();
   }
 
+  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }
+
   std::unique_ptr<base::RunLoop> run_loop_;
   bool disable_threaded_scrolling_ = false;
 
- protected:
+ private:
   base::HistogramTester histogram_tester_;
   uint32_t visual_state_callback_count_ = 0;
 
@@ -264,166 +355,24 @@ IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest,
       0, ""Event.Latency.ScrollBegin.Touch.TimeToScrollUpdateSwapBegin4""));
 }
 
-class ScrollLatencyScrollbarBrowserTest : public ScrollLatencyBrowserTest {
- public:
-  ScrollLatencyScrollbarBrowserTest() {}
-
-  void SetUpCommandLine(base::CommandLine* command_line) override {
-    command_line->AppendSwitch(::switches::kDisableSmoothScrolling);
-  }
-
-  void SetUp() override {
-    // Enable |kScrollbarInjectScrollGestures|, as these tests depend on it
-    // being on. Disable kOverlayScrollbar since overlay scrollbars are not
-    // hit-testable (thus input is not routed to scrollbars).
-    scoped_feature_list_.InitWithFeatures(
-        {blink::features::kScrollbarInjectScrollGestures},
-        {features::kOverlayScrollbar});
-    ScrollLatencyBrowserTest::SetUp();
-  }
-  ~ScrollLatencyScrollbarBrowserTest() override {}
-
- protected:
-  void RunScrollbarButtonLatencyTest() {
-    // We don't run tests that click the scrollbar on Android for a few reasons:
-    //  - Mobile browser uses scrollbars that are not hit-testable.
-    //  - On Android, you cannot resize the RenderWidgetHostView (see
-    //    |RenderWidgetHostViewAndroid::SetSize()|) and thus getting consistent
-    //    coordinates to manipulate the scrollbar is different from other
-    //    platforms.
-    // We could overcome the first limitation, by toggling various features
-    // and WebPreferences (e.g. kOverlayScrollbar feature, and
-    // viewport_enabled and use_solid_color_scrollbars WebPreferences) but at
-    // that point, we're not really testing a shipping configuration.
-#if !defined(OS_ANDROID)
-
-    // Click on the forward scrollbar button to induce a compositor thread
-    // scrollbar scroll.
-    blink::WebFloatPoint scrollbar_forward_button(795, 595);
-    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(
-        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,
-        scrollbar_forward_button.y, 0);
-    mouse_event.button = blink::WebMouseEvent::Button::kLeft;
-    mouse_event.SetTimeStamp(base::TimeTicks::Now());
-    GetWidgetHost()->ForwardMouseEvent(mouse_event);
-
-    mouse_event.SetType(blink::WebInputEvent::kMouseUp);
-    GetWidgetHost()->ForwardMouseEvent(mouse_event);
-
-    RunUntilInputProcessed(GetWidgetHost());
-
-    FetchHistogramsFromChildProcesses();
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4""));
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1,
-        ""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2""));
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1,
-        ""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2""));
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1, ""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2""));
-    std::string thread_name =
-        DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1,
-        ""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled2_"" + thread_name));
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1, ""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_"" +
-               thread_name));
-#endif  // !defined(OS_ANDROID)
-  }
-
-  void RunScrollbarThumbDragLatencyTest() {
-    // See above comment in RunScrollbarButtonLatencyTest for why this test
-    // doesn't run on Android.
-#if !defined(OS_ANDROID)
-    // Click on the scrollbar thumb and drag it twice to induce a compositor
-    // thread scrollbar ScrollBegin and ScrollUpdate.
-    blink::WebFloatPoint scrollbar_thumb(795, 30);
-    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(
-        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,
-        0);
-    mouse_down.button = blink::WebMouseEvent::Button::kLeft;
-    mouse_down.SetTimeStamp(base::TimeTicks::Now());
-    GetWidgetHost()->ForwardMouseEvent(mouse_down);
-
-    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(
-        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,
-        scrollbar_thumb.y + 10, 0);
-    mouse_move.button = blink::WebMouseEvent::Button::kLeft;
-    mouse_move.SetTimeStamp(base::TimeTicks::Now());
-    GetWidgetHost()->ForwardMouseEvent(mouse_move);
-    RunUntilInputProcessed(GetWidgetHost());
-
-    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);
-    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);
-    GetWidgetHost()->ForwardMouseEvent(mouse_move);
-    RunUntilInputProcessed(GetWidgetHost());
-
-    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(
-        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,
-        scrollbar_thumb.y + 20, 0);
-    mouse_up.button = blink::WebMouseEvent::Button::kLeft;
-    mouse_up.SetTimeStamp(base::TimeTicks::Now());
-    GetWidgetHost()->ForwardMouseEvent(mouse_up);
-
-    RunUntilInputProcessed(GetWidgetHost());
-
-    FetchHistogramsFromChildProcesses();
-    const std::string scroll_types[] = {""ScrollBegin"", ""ScrollUpdate""};
-    for (const std::string& scroll_type : scroll_types) {
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type +
-                 "".Scrollbar.TimeToScrollUpdateSwapBegin4""));
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type +
-                 "".Scrollbar.RendererSwapToBrowserNotified2""));
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type +
-                 "".Scrollbar.BrowserNotifiedToBeforeGpuSwap2""));
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type + "".Scrollbar.GpuSwap2""));
-      std::string thread_name =
-          DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type + "".Scrollbar.TimeToHandled2_"" +
-                 thread_name));
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type +
-                 "".Scrollbar.HandledToRendererSwap2_"" + thread_name));
-    }
-#endif  // !defined(OS_ANDROID)
-  }
-
-  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }
-
-  base::test::ScopedFeatureList scoped_feature_list_;
-};
-
-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,
-                       ScrollbarButtonLatency) {
+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarButtonLatency) {
   LoadURL();
 
   RunScrollbarButtonLatencyTest();
 }
 
-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,
-                       ScrollbarThumbDragLatency) {
+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarThumbDragLatency) {
   LoadURL();
 
   RunScrollbarThumbDragLatencyTest();
 }
 
 class ScrollLatencyCompositedScrollbarBrowserTest
-    : public ScrollLatencyScrollbarBrowserTest {
+    : public ScrollLatencyBrowserTest {
  public:
-  ScrollLatencyCompositedScrollbarBrowserTest() {}
-
-  void SetUp() override {
+  ScrollLatencyCompositedScrollbarBrowserTest() {
     scoped_feature_list_.InitAndEnableFeature(
         features::kCompositorThreadedScrollbarScrolling);
-    ScrollLatencyScrollbarBrowserTest::SetUp();
   }
   ~ScrollLatencyCompositedScrollbarBrowserTest() override {}
 
@@ -434,7 +383,7 @@ class ScrollLatencyCompositedScrollbarBrowserTest
 };
 
 IN_PROC_BROWSER_TEST_F(ScrollLatencyCompositedScrollbarBrowserTest,
-                       DISABLED_ScrollbarButtonLatency) {
+                       ScrollbarButtonLatency) {
   LoadURL();
 
   RunScrollbarButtonLatencyTest();",Chrome,14f2111f9cec919a450115ce4914f228effca58e,a7237f2e9866ca6088cffbb38668728606120a17,1,"  void RunScrollbarButtonLatencyTest() {
//flaw_line_below:
    // We don't run tests that click the scrollbar on Android for a few reasons:
//flaw_line_below:
    //  - Mobile browser uses scrollbars that are not hit-testable.
//flaw_line_below:
    //  - On Android, you cannot resize the RenderWidgetHostView (see
//flaw_line_below:
    //    |RenderWidgetHostViewAndroid::SetSize()|) and thus getting consistent
//flaw_line_below:
    //    coordinates to manipulate the scrollbar is different from other
//flaw_line_below:
    //    platforms.
//flaw_line_below:
    // We could overcome the first limitation, by toggling various features
//flaw_line_below:
    // and WebPreferences (e.g. kOverlayScrollbar feature, and
//flaw_line_below:
    // viewport_enabled and use_solid_color_scrollbars WebPreferences) but at
//flaw_line_below:
    // that point, we're not really testing a shipping configuration.
//flaw_line_below:
#if !defined(OS_ANDROID)
//flaw_line_below:

//flaw_line_below:
    // Click on the forward scrollbar button to induce a compositor thread
//flaw_line_below:
    // scrollbar scroll.
//flaw_line_below:
    blink::WebFloatPoint scrollbar_forward_button(795, 595);
//flaw_line_below:
    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(
//flaw_line_below:
        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,
//flaw_line_below:
        scrollbar_forward_button.y, 0);
//flaw_line_below:
    mouse_event.button = blink::WebMouseEvent::Button::kLeft;
//flaw_line_below:
    mouse_event.SetTimeStamp(base::TimeTicks::Now());
//flaw_line_below:
    GetWidgetHost()->ForwardMouseEvent(mouse_event);
//flaw_line_below:

//flaw_line_below:
    mouse_event.SetType(blink::WebInputEvent::kMouseUp);
//flaw_line_below:
    GetWidgetHost()->ForwardMouseEvent(mouse_event);
//flaw_line_below:

//flaw_line_below:
    RunUntilInputProcessed(GetWidgetHost());
//flaw_line_below:

//flaw_line_below:
    FetchHistogramsFromChildProcesses();
//flaw_line_below:
    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
//flaw_line_below:
        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4""));
//flaw_line_below:
    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
//flaw_line_below:
        1,
//flaw_line_below:
        ""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2""));
//flaw_line_below:
    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
//flaw_line_below:
        1,
//flaw_line_below:
        ""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2""));
//flaw_line_below:
    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
//flaw_line_below:
        1, ""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2""));
//flaw_line_below:
    std::string thread_name =
//flaw_line_below:
        DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
//flaw_line_below:
    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
//flaw_line_below:
        1,
//flaw_line_below:
        ""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled2_"" + thread_name));
//flaw_line_below:
    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
//flaw_line_below:
        1, ""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_"" +
//flaw_line_below:
               thread_name));
//flaw_line_below:
#endif  // !defined(OS_ANDROID)
//flaw_line_below:
  }
"
8661,186397,,Remote,Not required,,CVE-2017-5033,https://www.cvedetails.com/cve/CVE-2017-5033/,CWE-281,Medium,,Partial,,2017-04-24,4.3,"Blink in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android failed to correctly propagate CSP restrictions to local scheme pages, which allowed a remote attacker to bypass content security policy via a crafted HTML page, related to the unsafe-inline keyword.",2019-10-02,Bypass ,0,https://github.com/chromium/chromium/commit/14f2111f9cec919a450115ce4914f228effca58e,14f2111f9cec919a450115ce4914f228effca58e,"Revert ""Add explicit flag for compositor scrollbar injected gestures""

This reverts commit d9a56afcbdf9850bc39bb3edb56d07d11a1eb2b2.

Reason for revert:

Findit (https://goo.gl/kROfz5) identified CL at revision 669086 as the
culprit for flakes in the build cycles as shown on:
https://analysis.chromium.org/p/chromium/flake-portal/analysis/culprit?key=ag9zfmZpbmRpdC1mb3ItbWVyQwsSDEZsYWtlQ3VscHJpdCIxY2hyb21pdW0vZDlhNTZhZmNiZGY5ODUwYmMzOWJiM2VkYjU2ZDA3ZDExYTFlYjJiMgw

Sample Failed Build: https://ci.chromium.org/buildbot/chromium.chromiumos/linux-chromeos-rel/25818

Sample Failed Step: content_browsertests on Ubuntu-16.04

Sample Flaky Test: ScrollLatencyScrollbarBrowserTest.ScrollbarThumbDragLatency

Original change's description:
> Add explicit flag for compositor scrollbar injected gestures
> 
> The original change to enable scrollbar latency for the composited
> scrollbars incorrectly used an existing member to try and determine
> whether a GestureScrollUpdate was the first one in an injected sequence
> or not. is_first_gesture_scroll_update_ was incorrect because it is only
> updated when input is actually dispatched to InputHandlerProxy, and the
> flag is cleared for all GSUs before the location where it was being
> read.
> 
> This bug was missed because of incorrect tests. The
> VerifyRecordedSamplesForHistogram method doesn't actually assert or
> expect anything - the return value must be inspected.
> 
> As part of fixing up the tests, I made a few other changes to get them
> passing consistently across all platforms:
> - turn on main thread scrollbar injection feature (in case it's ever
>   turned off we don't want the tests to start failing)
> - enable mock scrollbars
> - disable smooth scrolling
> - don't run scrollbar tests on Android
> 
> The composited scrollbar button test is disabled due to a bug in how
> the mock theme reports its button sizes, which throws off the region
> detection in ScrollbarLayerImplBase::IdentifyScrollbarPart (filed
> crbug.com/974063 for this issue).
> 
> Change-Id: Ie1a762a5f6ecc264d22f0256db68f141fc76b950
> 
> Bug: 954007
> Change-Id: Ib258e08e083e79da90ba2e4e4216e4879cf00cf7
> Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1652741
> Commit-Queue: Daniel Libby <dlibby@microsoft.com>
> Reviewed-by: David Bokan <bokan@chromium.org>
> Cr-Commit-Position: refs/heads/master@{#669086}


Change-Id: Icc743e48fa740fe27f0cb0cfa21b209a696f518c
No-Presubmit: true
No-Tree-Checks: true
No-Try: true
Bug: 954007
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1660114
Cr-Commit-Position: refs/heads/master@{#669150}",51,content/browser/renderer_host/input/scroll_latency_browsertest.cc,"{""sha"": ""1f98c08075cfc4dbc85a034e423ed241a3781df9"", ""filename"": ""content/browser/renderer_host/input/scroll_latency_browsertest.cc"", ""status"": ""modified"", ""additions"": 106, ""deletions"": 157, ""changes"": 263, ""blob_url"": ""https://github.com/chromium/chromium/blob/14f2111f9cec919a450115ce4914f228effca58e/content/browser/renderer_host/input/scroll_latency_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/14f2111f9cec919a450115ce4914f228effca58e/content/browser/renderer_host/input/scroll_latency_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/input/scroll_latency_browsertest.cc?ref=14f2111f9cec919a450115ce4914f228effca58e"", ""patch"": ""@@ -9,7 +9,6 @@\n #include \""base/run_loop.h\""\n #include \""base/test/metrics/histogram_tester.h\""\n #include \""base/test/scoped_feature_list.h\""\n-#include \""build/build_config.h\""\n #include \""cc/base/switches.h\""\n #include \""content/browser/renderer_host/input/synthetic_gesture.h\""\n #include \""content/browser/renderer_host/input/synthetic_gesture_controller.h\""\n@@ -27,9 +26,7 @@\n #include \""content/public/test/content_browser_test_utils.h\""\n #include \""content/public/test/hit_test_region_observer.h\""\n #include \""content/shell/browser/shell.h\""\n-#include \""third_party/blink/public/common/features.h\""\n #include \""ui/base/ui_base_features.h\""\n-#include \""ui/native_theme/native_theme_features.h\""\n \n namespace {\n \n@@ -104,15 +101,11 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {\n   }\n \n   void LoadURL() {\n-    WebContents* contents = shell()->web_contents();\n-    WebPreferences prefs =\n-        contents->GetRenderViewHost()->GetWebkitPreferences();\n-    prefs.mock_scrollbars_enabled = true;\n-    contents->GetRenderViewHost()->UpdateWebkitPreferences(prefs);\n     const GURL data_url(kDataURL);\n     NavigateToURL(shell(), data_url);\n \n     RenderWidgetHostImpl* host = GetWidgetHost();\n+    host->GetView()->SetSize(gfx::Size(400, 400));\n \n     HitTestRegionObserver observer(host->GetFrameSinkId());\n \n@@ -181,19 +174,117 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {\n     }\n   }\n \n+  void RunScrollbarButtonLatencyTest() {\n+    // Click on the forward scrollbar button to induce a compositor thread\n+    // scrollbar scroll.\n+    blink::WebFloatPoint scrollbar_forward_button(795, 595);\n+    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,\n+        scrollbar_forward_button.y, 0);\n+    mouse_event.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_event.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n+\n+    mouse_event.SetType(blink::WebInputEvent::kMouseUp);\n+    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n+\n+    RunUntilInputProcessed(GetWidgetHost());\n+\n+    FetchHistogramsFromChildProcesses();\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1,\n+        \""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1,\n+        \""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+    std::string thread_name =\n+        DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled_\"" + thread_name);\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_\"" +\n+               thread_name);\n+  }\n+\n+  void RunScrollbarThumbDragLatencyTest() {\n+    // Click on the scrollbar thumb and drag it twice to induce a compositor\n+    // thread scrollbar ScrollBegin and ScrollUpdate.\n+    blink::WebFloatPoint scrollbar_thumb(795, 30);\n+    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,\n+        0);\n+    mouse_down.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_down.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_down);\n+\n+    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,\n+        scrollbar_thumb.y + 10, 0);\n+    mouse_move.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_move.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n+    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n+    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n+    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n+\n+    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,\n+        scrollbar_thumb.y + 20, 0);\n+    mouse_up.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_up.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_up);\n+\n+    RunUntilInputProcessed(GetWidgetHost());\n+\n+    FetchHistogramsFromChildProcesses();\n+    const std::string scroll_types[] = {\""ScrollBegin\"", \""ScrollUpdate\""};\n+    for (const std::string& scroll_type : scroll_types) {\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.RendererSwapToBrowserNotified2\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.BrowserNotifiedToBeforeGpuSwap2\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type + \"".Scrollbar.GpuSwap2\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+      std::string thread_name =\n+          DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n+      VerifyRecordedSamplesForHistogram(1, \""Event.Latency.\"" + scroll_type +\n+                                               \"".Scrollbar.TimeToHandled_\"" +\n+                                               thread_name);\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.HandledToRendererSwap2_\"" + thread_name);\n+    }\n+  }\n+\n   // Returns true if the given histogram has recorded the expected number of\n   // samples.\n-  WARN_UNUSED_RESULT bool VerifyRecordedSamplesForHistogram(\n+  bool VerifyRecordedSamplesForHistogram(\n       const size_t num_samples,\n       const std::string& histogram_name) const {\n     return num_samples ==\n            histogram_tester_.GetAllSamples(histogram_name).size();\n   }\n \n+  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }\n+\n   std::unique_ptr<base::RunLoop> run_loop_;\n   bool disable_threaded_scrolling_ = false;\n \n- protected:\n+ private:\n   base::HistogramTester histogram_tester_;\n   uint32_t visual_state_callback_count_ = 0;\n \n@@ -264,166 +355,24 @@ IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest,\n       0, \""Event.Latency.ScrollBegin.Touch.TimeToScrollUpdateSwapBegin4\""));\n }\n \n-class ScrollLatencyScrollbarBrowserTest : public ScrollLatencyBrowserTest {\n- public:\n-  ScrollLatencyScrollbarBrowserTest() {}\n-\n-  void SetUpCommandLine(base::CommandLine* command_line) override {\n-    command_line->AppendSwitch(::switches::kDisableSmoothScrolling);\n-  }\n-\n-  void SetUp() override {\n-    // Enable |kScrollbarInjectScrollGestures|, as these tests depend on it\n-    // being on. Disable kOverlayScrollbar since overlay scrollbars are not\n-    // hit-testable (thus input is not routed to scrollbars).\n-    scoped_feature_list_.InitWithFeatures(\n-        {blink::features::kScrollbarInjectScrollGestures},\n-        {features::kOverlayScrollbar});\n-    ScrollLatencyBrowserTest::SetUp();\n-  }\n-  ~ScrollLatencyScrollbarBrowserTest() override {}\n-\n- protected:\n-  void RunScrollbarButtonLatencyTest() {\n-    // We don't run tests that click the scrollbar on Android for a few reasons:\n-    //  - Mobile browser uses scrollbars that are not hit-testable.\n-    //  - On Android, you cannot resize the RenderWidgetHostView (see\n-    //    |RenderWidgetHostViewAndroid::SetSize()|) and thus getting consistent\n-    //    coordinates to manipulate the scrollbar is different from other\n-    //    platforms.\n-    // We could overcome the first limitation, by toggling various features\n-    // and WebPreferences (e.g. kOverlayScrollbar feature, and\n-    // viewport_enabled and use_solid_color_scrollbars WebPreferences) but at\n-    // that point, we're not really testing a shipping configuration.\n-#if !defined(OS_ANDROID)\n-\n-    // Click on the forward scrollbar button to induce a compositor thread\n-    // scrollbar scroll.\n-    blink::WebFloatPoint scrollbar_forward_button(795, 595);\n-    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,\n-        scrollbar_forward_button.y, 0);\n-    mouse_event.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_event.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n-\n-    mouse_event.SetType(blink::WebInputEvent::kMouseUp);\n-    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n-\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    FetchHistogramsFromChildProcesses();\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\""));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1,\n-        \""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2\""));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1,\n-        \""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2\""));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1, \""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2\""));\n-    std::string thread_name =\n-        DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1,\n-        \""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled2_\"" + thread_name));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1, \""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_\"" +\n-               thread_name));\n-#endif  // !defined(OS_ANDROID)\n-  }\n-\n-  void RunScrollbarThumbDragLatencyTest() {\n-    // See above comment in RunScrollbarButtonLatencyTest for why this test\n-    // doesn't run on Android.\n-#if !defined(OS_ANDROID)\n-    // Click on the scrollbar thumb and drag it twice to induce a compositor\n-    // thread scrollbar ScrollBegin and ScrollUpdate.\n-    blink::WebFloatPoint scrollbar_thumb(795, 30);\n-    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,\n-        0);\n-    mouse_down.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_down.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_down);\n-\n-    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,\n-        scrollbar_thumb.y + 10, 0);\n-    mouse_move.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_move.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n-    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n-    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,\n-        scrollbar_thumb.y + 20, 0);\n-    mouse_up.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_up.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_up);\n-\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    FetchHistogramsFromChildProcesses();\n-    const std::string scroll_types[] = {\""ScrollBegin\"", \""ScrollUpdate\""};\n-    for (const std::string& scroll_type : scroll_types) {\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.TimeToScrollUpdateSwapBegin4\""));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.RendererSwapToBrowserNotified2\""));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.BrowserNotifiedToBeforeGpuSwap2\""));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type + \"".Scrollbar.GpuSwap2\""));\n-      std::string thread_name =\n-          DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type + \"".Scrollbar.TimeToHandled2_\"" +\n-                 thread_name));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.HandledToRendererSwap2_\"" + thread_name));\n-    }\n-#endif  // !defined(OS_ANDROID)\n-  }\n-\n-  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }\n-\n-  base::test::ScopedFeatureList scoped_feature_list_;\n-};\n-\n-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,\n-                       ScrollbarButtonLatency) {\n+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarButtonLatency) {\n   LoadURL();\n \n   RunScrollbarButtonLatencyTest();\n }\n \n-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,\n-                       ScrollbarThumbDragLatency) {\n+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarThumbDragLatency) {\n   LoadURL();\n \n   RunScrollbarThumbDragLatencyTest();\n }\n \n class ScrollLatencyCompositedScrollbarBrowserTest\n-    : public ScrollLatencyScrollbarBrowserTest {\n+    : public ScrollLatencyBrowserTest {\n  public:\n-  ScrollLatencyCompositedScrollbarBrowserTest() {}\n-\n-  void SetUp() override {\n+  ScrollLatencyCompositedScrollbarBrowserTest() {\n     scoped_feature_list_.InitAndEnableFeature(\n         features::kCompositorThreadedScrollbarScrolling);\n-    ScrollLatencyScrollbarBrowserTest::SetUp();\n   }\n   ~ScrollLatencyCompositedScrollbarBrowserTest() override {}\n \n@@ -434,7 +383,7 @@ class ScrollLatencyCompositedScrollbarBrowserTest\n };\n \n IN_PROC_BROWSER_TEST_F(ScrollLatencyCompositedScrollbarBrowserTest,\n-                       DISABLED_ScrollbarButtonLatency) {\n+                       ScrollbarButtonLatency) {\n   LoadURL();\n \n   RunScrollbarButtonLatencyTest();""}<_**next**_>{""sha"": ""053fa0d159e192dd8c6bbc001bf363dda3cb977d"", ""filename"": ""ui/events/blink/input_handler_proxy.cc"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 20, ""changes"": 52, ""blob_url"": ""https://github.com/chromium/chromium/blob/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/events/blink/input_handler_proxy.cc?ref=14f2111f9cec919a450115ce4914f228effca58e"", ""patch"": ""@@ -174,7 +174,6 @@ InputHandlerProxy::InputHandlerProxy(cc::InputHandler* input_handler,\n       current_overscroll_params_(nullptr),\n       has_ongoing_compositor_scroll_or_pinch_(false),\n       is_first_gesture_scroll_update_(false),\n-      last_injected_gesture_was_begin_(false),\n       tick_clock_(base::DefaultTickClock::GetInstance()),\n       snap_fling_controller_(std::make_unique<cc::SnapFlingController>(this)),\n       compositor_touch_action_enabled_(\n@@ -312,10 +311,15 @@ void InputHandlerProxy::DispatchSingleInputEvent(\n \n   current_overscroll_params_.reset();\n \n+  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();\n+  if (type == blink::WebGestureEvent::kGestureScrollUpdate) {\n+    EnsureScrollUpdateLatencyComponent(\n+        &monitored_latency_info, event_with_callback->event().TimeStamp());\n+  }\n+\n   InputHandlerProxy::EventDisposition disposition = RouteToTypeSpecificHandler(\n       event_with_callback->event(), original_latency_info);\n \n-  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();\n   switch (type) {\n     case blink::WebGestureEvent::kGestureScrollBegin:\n       is_first_gesture_scroll_update_ = true;\n@@ -361,6 +365,32 @@ void InputHandlerProxy::DispatchSingleInputEvent(\n                                     std::move(current_overscroll_params_));\n }\n \n+// Scroll updates injected from within the renderer process will not have a\n+// scroll update component, since those are added to the latency info\n+// in the browser process before being dispatched to the renderer.\n+void InputHandlerProxy::EnsureScrollUpdateLatencyComponent(\n+    LatencyInfo* monitored_latency_info,\n+    base::TimeTicks original_timestamp) {\n+  // Currently we only expect LatencyInfo's of type SCROLLBAR to get into\n+  // this state, but there are a few exceptions (i.e. GestureScrollUpdates\n+  // that are coalesced with GesturePinchUpdates via\n+  // CompositorThreadEventQueue::Queue/CoalesceScrollAndPinch).\n+  // TODO(dlibby): Update that codepath and turn this into a DCHECK when there\n+  // is a missing scroll update component.\n+  if (monitored_latency_info->source_event_type() !=\n+      ui::SourceEventType::SCROLLBAR)\n+    return;\n+\n+  // Add a scroll update component to the latency info if one doesn't exist,\n+  // based on whether or not this is the first scroll update we've seen in a\n+  // gesture sequence.\n+  monitored_latency_info->AddLatencyNumberWithTimestamp(\n+      (is_first_gesture_scroll_update_)\n+          ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT\n+          : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,\n+      original_timestamp, 1);\n+}\n+\n void InputHandlerProxy::DispatchQueuedInputEvents() {\n   // Calling |NowTicks()| is expensive so we only want to do it once.\n   base::TimeTicks now = tick_clock_->NowTicks();\n@@ -406,24 +436,6 @@ void InputHandlerProxy::InjectScrollbarGestureScroll(\n   DCHECK(!scrollbar_latency_info.FindLatency(\n       ui::INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL_COMPONENT, nullptr));\n \n-  if (type == WebInputEvent::Type::kGestureScrollBegin) {\n-    last_injected_gesture_was_begin_ = true;\n-  } else {\n-    if (type == WebInputEvent::Type::kGestureScrollUpdate) {\n-      // For injected GSUs, add a scroll update component to the latency info\n-      // so that it is properly classified as a scroll. If the last injected\n-      // gesture was a GSB, then this GSU is the first scroll update - mark\n-      // the LatencyInfo as such.\n-      scrollbar_latency_info.AddLatencyNumberWithTimestamp(\n-          (last_injected_gesture_was_begin_)\n-              ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT\n-              : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,\n-          original_timestamp, 1);\n-    }\n-\n-    last_injected_gesture_was_begin_ = false;\n-  }\n-\n   std::unique_ptr<EventWithCallback> gesture_event_with_callback_update =\n       std::make_unique<EventWithCallback>(\n           std::move(web_scoped_gesture_event), scrollbar_latency_info,""}<_**next**_>{""sha"": ""dd9f0d6a96f7e222b2d991a58df09571c09ef7a9"", ""filename"": ""ui/events/blink/input_handler_proxy.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/events/blink/input_handler_proxy.h?ref=14f2111f9cec919a450115ce4914f228effca58e"", ""patch"": ""@@ -187,6 +187,12 @@ class InputHandlerProxy : public cc::InputHandlerClient,\n       bool* is_touching_scrolling_layer,\n       cc::TouchAction* white_listed_touch_action);\n \n+  // Scroll updates injected from within the renderer process will not have a\n+  // scroll update component, since those are added to the latency info\n+  // in the browser process before being dispatched to the renderer.\n+  void EnsureScrollUpdateLatencyComponent(LatencyInfo* monitored_latency_info,\n+                                          base::TimeTicks original_timestamp);\n+\n   InputHandlerProxyClient* client_;\n   cc::InputHandler* input_handler_;\n \n@@ -229,13 +235,6 @@ class InputHandlerProxy : public cc::InputHandlerClient,\n   bool has_ongoing_compositor_scroll_or_pinch_;\n   bool is_first_gesture_scroll_update_;\n \n-  // Whether the last injected scroll gesture was a GestureScrollBegin. Used to\n-  // determine which GestureScrollUpdate is the first in a gesture sequence for\n-  // latency classification. This is separate from\n-  // |is_first_gesture_scroll_update_| and is used to determine which type of\n-  // latency component should be added for injected GestureScrollUpdates.\n-  bool last_injected_gesture_was_begin_;\n-\n   const base::TickClock* tick_clock_;\n \n   std::unique_ptr<cc::SnapFlingController> snap_fling_controller_;""}","  void RunScrollbarThumbDragLatencyTest() {
","  void RunScrollbarThumbDragLatencyTest() {
#if !defined(OS_ANDROID)
    blink::WebFloatPoint scrollbar_thumb(795, 30);
    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(
        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,
        0);
    mouse_down.button = blink::WebMouseEvent::Button::kLeft;
    mouse_down.SetTimeStamp(base::TimeTicks::Now());
    GetWidgetHost()->ForwardMouseEvent(mouse_down);
    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(
        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,
        scrollbar_thumb.y + 10, 0);
    mouse_move.button = blink::WebMouseEvent::Button::kLeft;
    mouse_move.SetTimeStamp(base::TimeTicks::Now());
    GetWidgetHost()->ForwardMouseEvent(mouse_move);
    RunUntilInputProcessed(GetWidgetHost());
    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);
    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);
    GetWidgetHost()->ForwardMouseEvent(mouse_move);
    RunUntilInputProcessed(GetWidgetHost());
    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(
        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,
        scrollbar_thumb.y + 20, 0);
    mouse_up.button = blink::WebMouseEvent::Button::kLeft;
    mouse_up.SetTimeStamp(base::TimeTicks::Now());
    GetWidgetHost()->ForwardMouseEvent(mouse_up);
    RunUntilInputProcessed(GetWidgetHost());
    FetchHistogramsFromChildProcesses();
    const std::string scroll_types[] = {""ScrollBegin"", ""ScrollUpdate""};
    for (const std::string& scroll_type : scroll_types) {
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type +
                 "".Scrollbar.TimeToScrollUpdateSwapBegin4""));
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type +
                 "".Scrollbar.RendererSwapToBrowserNotified2""));
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type +
                 "".Scrollbar.BrowserNotifiedToBeforeGpuSwap2""));
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type + "".Scrollbar.GpuSwap2""));
      std::string thread_name =
          DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type + "".Scrollbar.TimeToHandled2_"" +
                 thread_name));
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type +
                 "".Scrollbar.HandledToRendererSwap2_"" + thread_name));
    }
#endif  // !defined(OS_ANDROID)
  }
",C,,"#if !defined(OS_ANDROID)
    blink::WebFloatPoint scrollbar_thumb(795, 30);
    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(
        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,
        0);
    mouse_down.button = blink::WebMouseEvent::Button::kLeft;
    mouse_down.SetTimeStamp(base::TimeTicks::Now());
    GetWidgetHost()->ForwardMouseEvent(mouse_down);
    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(
        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,
        scrollbar_thumb.y + 10, 0);
    mouse_move.button = blink::WebMouseEvent::Button::kLeft;
    mouse_move.SetTimeStamp(base::TimeTicks::Now());
    GetWidgetHost()->ForwardMouseEvent(mouse_move);
    RunUntilInputProcessed(GetWidgetHost());
    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);
    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);
    GetWidgetHost()->ForwardMouseEvent(mouse_move);
    RunUntilInputProcessed(GetWidgetHost());
    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(
        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,
        scrollbar_thumb.y + 20, 0);
    mouse_up.button = blink::WebMouseEvent::Button::kLeft;
    mouse_up.SetTimeStamp(base::TimeTicks::Now());
    GetWidgetHost()->ForwardMouseEvent(mouse_up);
    RunUntilInputProcessed(GetWidgetHost());
    FetchHistogramsFromChildProcesses();
    const std::string scroll_types[] = {""ScrollBegin"", ""ScrollUpdate""};
    for (const std::string& scroll_type : scroll_types) {
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type +
                 "".Scrollbar.TimeToScrollUpdateSwapBegin4""));
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type +
                 "".Scrollbar.RendererSwapToBrowserNotified2""));
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type +
                 "".Scrollbar.BrowserNotifiedToBeforeGpuSwap2""));
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type + "".Scrollbar.GpuSwap2""));
      std::string thread_name =
          DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type + "".Scrollbar.TimeToHandled2_"" +
                 thread_name));
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type +
                 "".Scrollbar.HandledToRendererSwap2_"" + thread_name));
    }
#endif  // !defined(OS_ANDROID)
  }
",,"@@ -9,7 +9,6 @@
 #include ""base/run_loop.h""
 #include ""base/test/metrics/histogram_tester.h""
 #include ""base/test/scoped_feature_list.h""
-#include ""build/build_config.h""
 #include ""cc/base/switches.h""
 #include ""content/browser/renderer_host/input/synthetic_gesture.h""
 #include ""content/browser/renderer_host/input/synthetic_gesture_controller.h""
@@ -27,9 +26,7 @@
 #include ""content/public/test/content_browser_test_utils.h""
 #include ""content/public/test/hit_test_region_observer.h""
 #include ""content/shell/browser/shell.h""
-#include ""third_party/blink/public/common/features.h""
 #include ""ui/base/ui_base_features.h""
-#include ""ui/native_theme/native_theme_features.h""
 
 namespace {
 
@@ -104,15 +101,11 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {
   }
 
   void LoadURL() {
-    WebContents* contents = shell()->web_contents();
-    WebPreferences prefs =
-        contents->GetRenderViewHost()->GetWebkitPreferences();
-    prefs.mock_scrollbars_enabled = true;
-    contents->GetRenderViewHost()->UpdateWebkitPreferences(prefs);
     const GURL data_url(kDataURL);
     NavigateToURL(shell(), data_url);
 
     RenderWidgetHostImpl* host = GetWidgetHost();
+    host->GetView()->SetSize(gfx::Size(400, 400));
 
     HitTestRegionObserver observer(host->GetFrameSinkId());
 
@@ -181,19 +174,117 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {
     }
   }
 
+  void RunScrollbarButtonLatencyTest() {
+    // Click on the forward scrollbar button to induce a compositor thread
+    // scrollbar scroll.
+    blink::WebFloatPoint scrollbar_forward_button(795, 595);
+    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(
+        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,
+        scrollbar_forward_button.y, 0);
+    mouse_event.button = blink::WebMouseEvent::Button::kLeft;
+    mouse_event.SetTimeStamp(base::TimeTicks::Now());
+    GetWidgetHost()->ForwardMouseEvent(mouse_event);
+
+    mouse_event.SetType(blink::WebInputEvent::kMouseUp);
+    GetWidgetHost()->ForwardMouseEvent(mouse_event);
+
+    RunUntilInputProcessed(GetWidgetHost());
+
+    FetchHistogramsFromChildProcesses();
+    VerifyRecordedSamplesForHistogram(
+        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4"");
+    VerifyRecordedSamplesForHistogram(
+        1,
+        ""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2"");
+    VerifyRecordedSamplesForHistogram(
+        1,
+        ""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2"");
+    VerifyRecordedSamplesForHistogram(
+        1, ""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2"");
+    VerifyRecordedSamplesForHistogram(
+        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4"");
+    std::string thread_name =
+        DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
+    VerifyRecordedSamplesForHistogram(
+        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled_"" + thread_name);
+    VerifyRecordedSamplesForHistogram(
+        1, ""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_"" +
+               thread_name);
+  }
+
+  void RunScrollbarThumbDragLatencyTest() {
+    // Click on the scrollbar thumb and drag it twice to induce a compositor
+    // thread scrollbar ScrollBegin and ScrollUpdate.
+    blink::WebFloatPoint scrollbar_thumb(795, 30);
+    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(
+        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,
+        0);
+    mouse_down.button = blink::WebMouseEvent::Button::kLeft;
+    mouse_down.SetTimeStamp(base::TimeTicks::Now());
+    GetWidgetHost()->ForwardMouseEvent(mouse_down);
+
+    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(
+        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,
+        scrollbar_thumb.y + 10, 0);
+    mouse_move.button = blink::WebMouseEvent::Button::kLeft;
+    mouse_move.SetTimeStamp(base::TimeTicks::Now());
+    GetWidgetHost()->ForwardMouseEvent(mouse_move);
+    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);
+    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);
+    GetWidgetHost()->ForwardMouseEvent(mouse_move);
+
+    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(
+        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,
+        scrollbar_thumb.y + 20, 0);
+    mouse_up.button = blink::WebMouseEvent::Button::kLeft;
+    mouse_up.SetTimeStamp(base::TimeTicks::Now());
+    GetWidgetHost()->ForwardMouseEvent(mouse_up);
+
+    RunUntilInputProcessed(GetWidgetHost());
+
+    FetchHistogramsFromChildProcesses();
+    const std::string scroll_types[] = {""ScrollBegin"", ""ScrollUpdate""};
+    for (const std::string& scroll_type : scroll_types) {
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type +
+                 "".Scrollbar.TimeToScrollUpdateSwapBegin4"");
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type +
+                 "".Scrollbar.RendererSwapToBrowserNotified2"");
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type +
+                 "".Scrollbar.BrowserNotifiedToBeforeGpuSwap2"");
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type + "".Scrollbar.GpuSwap2"");
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type +
+                 "".Scrollbar.TimeToScrollUpdateSwapBegin4"");
+      std::string thread_name =
+          DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
+      VerifyRecordedSamplesForHistogram(1, ""Event.Latency."" + scroll_type +
+                                               "".Scrollbar.TimeToHandled_"" +
+                                               thread_name);
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type +
+                 "".Scrollbar.HandledToRendererSwap2_"" + thread_name);
+    }
+  }
+
   // Returns true if the given histogram has recorded the expected number of
   // samples.
-  WARN_UNUSED_RESULT bool VerifyRecordedSamplesForHistogram(
+  bool VerifyRecordedSamplesForHistogram(
       const size_t num_samples,
       const std::string& histogram_name) const {
     return num_samples ==
            histogram_tester_.GetAllSamples(histogram_name).size();
   }
 
+  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }
+
   std::unique_ptr<base::RunLoop> run_loop_;
   bool disable_threaded_scrolling_ = false;
 
- protected:
+ private:
   base::HistogramTester histogram_tester_;
   uint32_t visual_state_callback_count_ = 0;
 
@@ -264,166 +355,24 @@ IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest,
       0, ""Event.Latency.ScrollBegin.Touch.TimeToScrollUpdateSwapBegin4""));
 }
 
-class ScrollLatencyScrollbarBrowserTest : public ScrollLatencyBrowserTest {
- public:
-  ScrollLatencyScrollbarBrowserTest() {}
-
-  void SetUpCommandLine(base::CommandLine* command_line) override {
-    command_line->AppendSwitch(::switches::kDisableSmoothScrolling);
-  }
-
-  void SetUp() override {
-    // Enable |kScrollbarInjectScrollGestures|, as these tests depend on it
-    // being on. Disable kOverlayScrollbar since overlay scrollbars are not
-    // hit-testable (thus input is not routed to scrollbars).
-    scoped_feature_list_.InitWithFeatures(
-        {blink::features::kScrollbarInjectScrollGestures},
-        {features::kOverlayScrollbar});
-    ScrollLatencyBrowserTest::SetUp();
-  }
-  ~ScrollLatencyScrollbarBrowserTest() override {}
-
- protected:
-  void RunScrollbarButtonLatencyTest() {
-    // We don't run tests that click the scrollbar on Android for a few reasons:
-    //  - Mobile browser uses scrollbars that are not hit-testable.
-    //  - On Android, you cannot resize the RenderWidgetHostView (see
-    //    |RenderWidgetHostViewAndroid::SetSize()|) and thus getting consistent
-    //    coordinates to manipulate the scrollbar is different from other
-    //    platforms.
-    // We could overcome the first limitation, by toggling various features
-    // and WebPreferences (e.g. kOverlayScrollbar feature, and
-    // viewport_enabled and use_solid_color_scrollbars WebPreferences) but at
-    // that point, we're not really testing a shipping configuration.
-#if !defined(OS_ANDROID)
-
-    // Click on the forward scrollbar button to induce a compositor thread
-    // scrollbar scroll.
-    blink::WebFloatPoint scrollbar_forward_button(795, 595);
-    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(
-        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,
-        scrollbar_forward_button.y, 0);
-    mouse_event.button = blink::WebMouseEvent::Button::kLeft;
-    mouse_event.SetTimeStamp(base::TimeTicks::Now());
-    GetWidgetHost()->ForwardMouseEvent(mouse_event);
-
-    mouse_event.SetType(blink::WebInputEvent::kMouseUp);
-    GetWidgetHost()->ForwardMouseEvent(mouse_event);
-
-    RunUntilInputProcessed(GetWidgetHost());
-
-    FetchHistogramsFromChildProcesses();
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4""));
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1,
-        ""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2""));
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1,
-        ""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2""));
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1, ""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2""));
-    std::string thread_name =
-        DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1,
-        ""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled2_"" + thread_name));
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1, ""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_"" +
-               thread_name));
-#endif  // !defined(OS_ANDROID)
-  }
-
-  void RunScrollbarThumbDragLatencyTest() {
-    // See above comment in RunScrollbarButtonLatencyTest for why this test
-    // doesn't run on Android.
-#if !defined(OS_ANDROID)
-    // Click on the scrollbar thumb and drag it twice to induce a compositor
-    // thread scrollbar ScrollBegin and ScrollUpdate.
-    blink::WebFloatPoint scrollbar_thumb(795, 30);
-    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(
-        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,
-        0);
-    mouse_down.button = blink::WebMouseEvent::Button::kLeft;
-    mouse_down.SetTimeStamp(base::TimeTicks::Now());
-    GetWidgetHost()->ForwardMouseEvent(mouse_down);
-
-    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(
-        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,
-        scrollbar_thumb.y + 10, 0);
-    mouse_move.button = blink::WebMouseEvent::Button::kLeft;
-    mouse_move.SetTimeStamp(base::TimeTicks::Now());
-    GetWidgetHost()->ForwardMouseEvent(mouse_move);
-    RunUntilInputProcessed(GetWidgetHost());
-
-    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);
-    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);
-    GetWidgetHost()->ForwardMouseEvent(mouse_move);
-    RunUntilInputProcessed(GetWidgetHost());
-
-    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(
-        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,
-        scrollbar_thumb.y + 20, 0);
-    mouse_up.button = blink::WebMouseEvent::Button::kLeft;
-    mouse_up.SetTimeStamp(base::TimeTicks::Now());
-    GetWidgetHost()->ForwardMouseEvent(mouse_up);
-
-    RunUntilInputProcessed(GetWidgetHost());
-
-    FetchHistogramsFromChildProcesses();
-    const std::string scroll_types[] = {""ScrollBegin"", ""ScrollUpdate""};
-    for (const std::string& scroll_type : scroll_types) {
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type +
-                 "".Scrollbar.TimeToScrollUpdateSwapBegin4""));
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type +
-                 "".Scrollbar.RendererSwapToBrowserNotified2""));
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type +
-                 "".Scrollbar.BrowserNotifiedToBeforeGpuSwap2""));
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type + "".Scrollbar.GpuSwap2""));
-      std::string thread_name =
-          DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type + "".Scrollbar.TimeToHandled2_"" +
-                 thread_name));
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type +
-                 "".Scrollbar.HandledToRendererSwap2_"" + thread_name));
-    }
-#endif  // !defined(OS_ANDROID)
-  }
-
-  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }
-
-  base::test::ScopedFeatureList scoped_feature_list_;
-};
-
-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,
-                       ScrollbarButtonLatency) {
+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarButtonLatency) {
   LoadURL();
 
   RunScrollbarButtonLatencyTest();
 }
 
-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,
-                       ScrollbarThumbDragLatency) {
+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarThumbDragLatency) {
   LoadURL();
 
   RunScrollbarThumbDragLatencyTest();
 }
 
 class ScrollLatencyCompositedScrollbarBrowserTest
-    : public ScrollLatencyScrollbarBrowserTest {
+    : public ScrollLatencyBrowserTest {
  public:
-  ScrollLatencyCompositedScrollbarBrowserTest() {}
-
-  void SetUp() override {
+  ScrollLatencyCompositedScrollbarBrowserTest() {
     scoped_feature_list_.InitAndEnableFeature(
         features::kCompositorThreadedScrollbarScrolling);
-    ScrollLatencyScrollbarBrowserTest::SetUp();
   }
   ~ScrollLatencyCompositedScrollbarBrowserTest() override {}
 
@@ -434,7 +383,7 @@ class ScrollLatencyCompositedScrollbarBrowserTest
 };
 
 IN_PROC_BROWSER_TEST_F(ScrollLatencyCompositedScrollbarBrowserTest,
-                       DISABLED_ScrollbarButtonLatency) {
+                       ScrollbarButtonLatency) {
   LoadURL();
 
   RunScrollbarButtonLatencyTest();",Chrome,14f2111f9cec919a450115ce4914f228effca58e,a7237f2e9866ca6088cffbb38668728606120a17,1,"  void RunScrollbarThumbDragLatencyTest() {
//flaw_line_below:
    // See above comment in RunScrollbarButtonLatencyTest for why this test
//flaw_line_below:
    // doesn't run on Android.
//flaw_line_below:
#if !defined(OS_ANDROID)
//flaw_line_below:
    // Click on the scrollbar thumb and drag it twice to induce a compositor
//flaw_line_below:
    // thread scrollbar ScrollBegin and ScrollUpdate.
//flaw_line_below:
    blink::WebFloatPoint scrollbar_thumb(795, 30);
//flaw_line_below:
    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(
//flaw_line_below:
        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,
//flaw_line_below:
        0);
//flaw_line_below:
    mouse_down.button = blink::WebMouseEvent::Button::kLeft;
//flaw_line_below:
    mouse_down.SetTimeStamp(base::TimeTicks::Now());
//flaw_line_below:
    GetWidgetHost()->ForwardMouseEvent(mouse_down);
//flaw_line_below:

//flaw_line_below:
    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(
//flaw_line_below:
        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,
//flaw_line_below:
        scrollbar_thumb.y + 10, 0);
//flaw_line_below:
    mouse_move.button = blink::WebMouseEvent::Button::kLeft;
//flaw_line_below:
    mouse_move.SetTimeStamp(base::TimeTicks::Now());
//flaw_line_below:
    GetWidgetHost()->ForwardMouseEvent(mouse_move);
//flaw_line_below:
    RunUntilInputProcessed(GetWidgetHost());
//flaw_line_below:

//flaw_line_below:
    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);
//flaw_line_below:
    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);
//flaw_line_below:
    GetWidgetHost()->ForwardMouseEvent(mouse_move);
//flaw_line_below:
    RunUntilInputProcessed(GetWidgetHost());
//flaw_line_below:

//flaw_line_below:
    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(
//flaw_line_below:
        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,
//flaw_line_below:
        scrollbar_thumb.y + 20, 0);
//flaw_line_below:
    mouse_up.button = blink::WebMouseEvent::Button::kLeft;
//flaw_line_below:
    mouse_up.SetTimeStamp(base::TimeTicks::Now());
//flaw_line_below:
    GetWidgetHost()->ForwardMouseEvent(mouse_up);
//flaw_line_below:

//flaw_line_below:
    RunUntilInputProcessed(GetWidgetHost());
//flaw_line_below:

//flaw_line_below:
    FetchHistogramsFromChildProcesses();
//flaw_line_below:
    const std::string scroll_types[] = {""ScrollBegin"", ""ScrollUpdate""};
//flaw_line_below:
    for (const std::string& scroll_type : scroll_types) {
//flaw_line_below:
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
//flaw_line_below:
          1, ""Event.Latency."" + scroll_type +
//flaw_line_below:
                 "".Scrollbar.TimeToScrollUpdateSwapBegin4""));
//flaw_line_below:
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
//flaw_line_below:
          1, ""Event.Latency."" + scroll_type +
//flaw_line_below:
                 "".Scrollbar.RendererSwapToBrowserNotified2""));
//flaw_line_below:
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
//flaw_line_below:
          1, ""Event.Latency."" + scroll_type +
//flaw_line_below:
                 "".Scrollbar.BrowserNotifiedToBeforeGpuSwap2""));
//flaw_line_below:
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
//flaw_line_below:
          1, ""Event.Latency."" + scroll_type + "".Scrollbar.GpuSwap2""));
//flaw_line_below:
      std::string thread_name =
//flaw_line_below:
          DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
//flaw_line_below:
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
//flaw_line_below:
          1, ""Event.Latency."" + scroll_type + "".Scrollbar.TimeToHandled2_"" +
//flaw_line_below:
                 thread_name));
//flaw_line_below:
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
//flaw_line_below:
          1, ""Event.Latency."" + scroll_type +
//flaw_line_below:
                 "".Scrollbar.HandledToRendererSwap2_"" + thread_name));
//flaw_line_below:
    }
//flaw_line_below:
#endif  // !defined(OS_ANDROID)
//flaw_line_below:
  }
"
8662,186398,,Remote,Not required,,CVE-2017-5033,https://www.cvedetails.com/cve/CVE-2017-5033/,CWE-281,Medium,,Partial,,2017-04-24,4.3,"Blink in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android failed to correctly propagate CSP restrictions to local scheme pages, which allowed a remote attacker to bypass content security policy via a crafted HTML page, related to the unsafe-inline keyword.",2019-10-02,Bypass ,1,https://github.com/chromium/chromium/commit/14f2111f9cec919a450115ce4914f228effca58e,14f2111f9cec919a450115ce4914f228effca58e,"Revert ""Add explicit flag for compositor scrollbar injected gestures""

This reverts commit d9a56afcbdf9850bc39bb3edb56d07d11a1eb2b2.

Reason for revert:

Findit (https://goo.gl/kROfz5) identified CL at revision 669086 as the
culprit for flakes in the build cycles as shown on:
https://analysis.chromium.org/p/chromium/flake-portal/analysis/culprit?key=ag9zfmZpbmRpdC1mb3ItbWVyQwsSDEZsYWtlQ3VscHJpdCIxY2hyb21pdW0vZDlhNTZhZmNiZGY5ODUwYmMzOWJiM2VkYjU2ZDA3ZDExYTFlYjJiMgw

Sample Failed Build: https://ci.chromium.org/buildbot/chromium.chromiumos/linux-chromeos-rel/25818

Sample Failed Step: content_browsertests on Ubuntu-16.04

Sample Flaky Test: ScrollLatencyScrollbarBrowserTest.ScrollbarThumbDragLatency

Original change's description:
> Add explicit flag for compositor scrollbar injected gestures
> 
> The original change to enable scrollbar latency for the composited
> scrollbars incorrectly used an existing member to try and determine
> whether a GestureScrollUpdate was the first one in an injected sequence
> or not. is_first_gesture_scroll_update_ was incorrect because it is only
> updated when input is actually dispatched to InputHandlerProxy, and the
> flag is cleared for all GSUs before the location where it was being
> read.
> 
> This bug was missed because of incorrect tests. The
> VerifyRecordedSamplesForHistogram method doesn't actually assert or
> expect anything - the return value must be inspected.
> 
> As part of fixing up the tests, I made a few other changes to get them
> passing consistently across all platforms:
> - turn on main thread scrollbar injection feature (in case it's ever
>   turned off we don't want the tests to start failing)
> - enable mock scrollbars
> - disable smooth scrolling
> - don't run scrollbar tests on Android
> 
> The composited scrollbar button test is disabled due to a bug in how
> the mock theme reports its button sizes, which throws off the region
> detection in ScrollbarLayerImplBase::IdentifyScrollbarPart (filed
> crbug.com/974063 for this issue).
> 
> Change-Id: Ie1a762a5f6ecc264d22f0256db68f141fc76b950
> 
> Bug: 954007
> Change-Id: Ib258e08e083e79da90ba2e4e4216e4879cf00cf7
> Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1652741
> Commit-Queue: Daniel Libby <dlibby@microsoft.com>
> Reviewed-by: David Bokan <bokan@chromium.org>
> Cr-Commit-Position: refs/heads/master@{#669086}


Change-Id: Icc743e48fa740fe27f0cb0cfa21b209a696f518c
No-Presubmit: true
No-Tree-Checks: true
No-Try: true
Bug: 954007
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1660114
Cr-Commit-Position: refs/heads/master@{#669150}",0,content/browser/renderer_host/input/scroll_latency_browsertest.cc,"{""sha"": ""1f98c08075cfc4dbc85a034e423ed241a3781df9"", ""filename"": ""content/browser/renderer_host/input/scroll_latency_browsertest.cc"", ""status"": ""modified"", ""additions"": 106, ""deletions"": 157, ""changes"": 263, ""blob_url"": ""https://github.com/chromium/chromium/blob/14f2111f9cec919a450115ce4914f228effca58e/content/browser/renderer_host/input/scroll_latency_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/14f2111f9cec919a450115ce4914f228effca58e/content/browser/renderer_host/input/scroll_latency_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/input/scroll_latency_browsertest.cc?ref=14f2111f9cec919a450115ce4914f228effca58e"", ""patch"": ""@@ -9,7 +9,6 @@\n #include \""base/run_loop.h\""\n #include \""base/test/metrics/histogram_tester.h\""\n #include \""base/test/scoped_feature_list.h\""\n-#include \""build/build_config.h\""\n #include \""cc/base/switches.h\""\n #include \""content/browser/renderer_host/input/synthetic_gesture.h\""\n #include \""content/browser/renderer_host/input/synthetic_gesture_controller.h\""\n@@ -27,9 +26,7 @@\n #include \""content/public/test/content_browser_test_utils.h\""\n #include \""content/public/test/hit_test_region_observer.h\""\n #include \""content/shell/browser/shell.h\""\n-#include \""third_party/blink/public/common/features.h\""\n #include \""ui/base/ui_base_features.h\""\n-#include \""ui/native_theme/native_theme_features.h\""\n \n namespace {\n \n@@ -104,15 +101,11 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {\n   }\n \n   void LoadURL() {\n-    WebContents* contents = shell()->web_contents();\n-    WebPreferences prefs =\n-        contents->GetRenderViewHost()->GetWebkitPreferences();\n-    prefs.mock_scrollbars_enabled = true;\n-    contents->GetRenderViewHost()->UpdateWebkitPreferences(prefs);\n     const GURL data_url(kDataURL);\n     NavigateToURL(shell(), data_url);\n \n     RenderWidgetHostImpl* host = GetWidgetHost();\n+    host->GetView()->SetSize(gfx::Size(400, 400));\n \n     HitTestRegionObserver observer(host->GetFrameSinkId());\n \n@@ -181,19 +174,117 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {\n     }\n   }\n \n+  void RunScrollbarButtonLatencyTest() {\n+    // Click on the forward scrollbar button to induce a compositor thread\n+    // scrollbar scroll.\n+    blink::WebFloatPoint scrollbar_forward_button(795, 595);\n+    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,\n+        scrollbar_forward_button.y, 0);\n+    mouse_event.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_event.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n+\n+    mouse_event.SetType(blink::WebInputEvent::kMouseUp);\n+    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n+\n+    RunUntilInputProcessed(GetWidgetHost());\n+\n+    FetchHistogramsFromChildProcesses();\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1,\n+        \""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1,\n+        \""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+    std::string thread_name =\n+        DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled_\"" + thread_name);\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_\"" +\n+               thread_name);\n+  }\n+\n+  void RunScrollbarThumbDragLatencyTest() {\n+    // Click on the scrollbar thumb and drag it twice to induce a compositor\n+    // thread scrollbar ScrollBegin and ScrollUpdate.\n+    blink::WebFloatPoint scrollbar_thumb(795, 30);\n+    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,\n+        0);\n+    mouse_down.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_down.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_down);\n+\n+    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,\n+        scrollbar_thumb.y + 10, 0);\n+    mouse_move.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_move.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n+    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n+    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n+    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n+\n+    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,\n+        scrollbar_thumb.y + 20, 0);\n+    mouse_up.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_up.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_up);\n+\n+    RunUntilInputProcessed(GetWidgetHost());\n+\n+    FetchHistogramsFromChildProcesses();\n+    const std::string scroll_types[] = {\""ScrollBegin\"", \""ScrollUpdate\""};\n+    for (const std::string& scroll_type : scroll_types) {\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.RendererSwapToBrowserNotified2\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.BrowserNotifiedToBeforeGpuSwap2\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type + \"".Scrollbar.GpuSwap2\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+      std::string thread_name =\n+          DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n+      VerifyRecordedSamplesForHistogram(1, \""Event.Latency.\"" + scroll_type +\n+                                               \"".Scrollbar.TimeToHandled_\"" +\n+                                               thread_name);\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.HandledToRendererSwap2_\"" + thread_name);\n+    }\n+  }\n+\n   // Returns true if the given histogram has recorded the expected number of\n   // samples.\n-  WARN_UNUSED_RESULT bool VerifyRecordedSamplesForHistogram(\n+  bool VerifyRecordedSamplesForHistogram(\n       const size_t num_samples,\n       const std::string& histogram_name) const {\n     return num_samples ==\n            histogram_tester_.GetAllSamples(histogram_name).size();\n   }\n \n+  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }\n+\n   std::unique_ptr<base::RunLoop> run_loop_;\n   bool disable_threaded_scrolling_ = false;\n \n- protected:\n+ private:\n   base::HistogramTester histogram_tester_;\n   uint32_t visual_state_callback_count_ = 0;\n \n@@ -264,166 +355,24 @@ IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest,\n       0, \""Event.Latency.ScrollBegin.Touch.TimeToScrollUpdateSwapBegin4\""));\n }\n \n-class ScrollLatencyScrollbarBrowserTest : public ScrollLatencyBrowserTest {\n- public:\n-  ScrollLatencyScrollbarBrowserTest() {}\n-\n-  void SetUpCommandLine(base::CommandLine* command_line) override {\n-    command_line->AppendSwitch(::switches::kDisableSmoothScrolling);\n-  }\n-\n-  void SetUp() override {\n-    // Enable |kScrollbarInjectScrollGestures|, as these tests depend on it\n-    // being on. Disable kOverlayScrollbar since overlay scrollbars are not\n-    // hit-testable (thus input is not routed to scrollbars).\n-    scoped_feature_list_.InitWithFeatures(\n-        {blink::features::kScrollbarInjectScrollGestures},\n-        {features::kOverlayScrollbar});\n-    ScrollLatencyBrowserTest::SetUp();\n-  }\n-  ~ScrollLatencyScrollbarBrowserTest() override {}\n-\n- protected:\n-  void RunScrollbarButtonLatencyTest() {\n-    // We don't run tests that click the scrollbar on Android for a few reasons:\n-    //  - Mobile browser uses scrollbars that are not hit-testable.\n-    //  - On Android, you cannot resize the RenderWidgetHostView (see\n-    //    |RenderWidgetHostViewAndroid::SetSize()|) and thus getting consistent\n-    //    coordinates to manipulate the scrollbar is different from other\n-    //    platforms.\n-    // We could overcome the first limitation, by toggling various features\n-    // and WebPreferences (e.g. kOverlayScrollbar feature, and\n-    // viewport_enabled and use_solid_color_scrollbars WebPreferences) but at\n-    // that point, we're not really testing a shipping configuration.\n-#if !defined(OS_ANDROID)\n-\n-    // Click on the forward scrollbar button to induce a compositor thread\n-    // scrollbar scroll.\n-    blink::WebFloatPoint scrollbar_forward_button(795, 595);\n-    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,\n-        scrollbar_forward_button.y, 0);\n-    mouse_event.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_event.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n-\n-    mouse_event.SetType(blink::WebInputEvent::kMouseUp);\n-    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n-\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    FetchHistogramsFromChildProcesses();\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\""));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1,\n-        \""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2\""));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1,\n-        \""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2\""));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1, \""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2\""));\n-    std::string thread_name =\n-        DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1,\n-        \""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled2_\"" + thread_name));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1, \""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_\"" +\n-               thread_name));\n-#endif  // !defined(OS_ANDROID)\n-  }\n-\n-  void RunScrollbarThumbDragLatencyTest() {\n-    // See above comment in RunScrollbarButtonLatencyTest for why this test\n-    // doesn't run on Android.\n-#if !defined(OS_ANDROID)\n-    // Click on the scrollbar thumb and drag it twice to induce a compositor\n-    // thread scrollbar ScrollBegin and ScrollUpdate.\n-    blink::WebFloatPoint scrollbar_thumb(795, 30);\n-    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,\n-        0);\n-    mouse_down.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_down.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_down);\n-\n-    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,\n-        scrollbar_thumb.y + 10, 0);\n-    mouse_move.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_move.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n-    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n-    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,\n-        scrollbar_thumb.y + 20, 0);\n-    mouse_up.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_up.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_up);\n-\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    FetchHistogramsFromChildProcesses();\n-    const std::string scroll_types[] = {\""ScrollBegin\"", \""ScrollUpdate\""};\n-    for (const std::string& scroll_type : scroll_types) {\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.TimeToScrollUpdateSwapBegin4\""));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.RendererSwapToBrowserNotified2\""));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.BrowserNotifiedToBeforeGpuSwap2\""));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type + \"".Scrollbar.GpuSwap2\""));\n-      std::string thread_name =\n-          DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type + \"".Scrollbar.TimeToHandled2_\"" +\n-                 thread_name));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.HandledToRendererSwap2_\"" + thread_name));\n-    }\n-#endif  // !defined(OS_ANDROID)\n-  }\n-\n-  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }\n-\n-  base::test::ScopedFeatureList scoped_feature_list_;\n-};\n-\n-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,\n-                       ScrollbarButtonLatency) {\n+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarButtonLatency) {\n   LoadURL();\n \n   RunScrollbarButtonLatencyTest();\n }\n \n-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,\n-                       ScrollbarThumbDragLatency) {\n+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarThumbDragLatency) {\n   LoadURL();\n \n   RunScrollbarThumbDragLatencyTest();\n }\n \n class ScrollLatencyCompositedScrollbarBrowserTest\n-    : public ScrollLatencyScrollbarBrowserTest {\n+    : public ScrollLatencyBrowserTest {\n  public:\n-  ScrollLatencyCompositedScrollbarBrowserTest() {}\n-\n-  void SetUp() override {\n+  ScrollLatencyCompositedScrollbarBrowserTest() {\n     scoped_feature_list_.InitAndEnableFeature(\n         features::kCompositorThreadedScrollbarScrolling);\n-    ScrollLatencyScrollbarBrowserTest::SetUp();\n   }\n   ~ScrollLatencyCompositedScrollbarBrowserTest() override {}\n \n@@ -434,7 +383,7 @@ class ScrollLatencyCompositedScrollbarBrowserTest\n };\n \n IN_PROC_BROWSER_TEST_F(ScrollLatencyCompositedScrollbarBrowserTest,\n-                       DISABLED_ScrollbarButtonLatency) {\n+                       ScrollbarButtonLatency) {\n   LoadURL();\n \n   RunScrollbarButtonLatencyTest();""}<_**next**_>{""sha"": ""053fa0d159e192dd8c6bbc001bf363dda3cb977d"", ""filename"": ""ui/events/blink/input_handler_proxy.cc"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 20, ""changes"": 52, ""blob_url"": ""https://github.com/chromium/chromium/blob/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/events/blink/input_handler_proxy.cc?ref=14f2111f9cec919a450115ce4914f228effca58e"", ""patch"": ""@@ -174,7 +174,6 @@ InputHandlerProxy::InputHandlerProxy(cc::InputHandler* input_handler,\n       current_overscroll_params_(nullptr),\n       has_ongoing_compositor_scroll_or_pinch_(false),\n       is_first_gesture_scroll_update_(false),\n-      last_injected_gesture_was_begin_(false),\n       tick_clock_(base::DefaultTickClock::GetInstance()),\n       snap_fling_controller_(std::make_unique<cc::SnapFlingController>(this)),\n       compositor_touch_action_enabled_(\n@@ -312,10 +311,15 @@ void InputHandlerProxy::DispatchSingleInputEvent(\n \n   current_overscroll_params_.reset();\n \n+  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();\n+  if (type == blink::WebGestureEvent::kGestureScrollUpdate) {\n+    EnsureScrollUpdateLatencyComponent(\n+        &monitored_latency_info, event_with_callback->event().TimeStamp());\n+  }\n+\n   InputHandlerProxy::EventDisposition disposition = RouteToTypeSpecificHandler(\n       event_with_callback->event(), original_latency_info);\n \n-  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();\n   switch (type) {\n     case blink::WebGestureEvent::kGestureScrollBegin:\n       is_first_gesture_scroll_update_ = true;\n@@ -361,6 +365,32 @@ void InputHandlerProxy::DispatchSingleInputEvent(\n                                     std::move(current_overscroll_params_));\n }\n \n+// Scroll updates injected from within the renderer process will not have a\n+// scroll update component, since those are added to the latency info\n+// in the browser process before being dispatched to the renderer.\n+void InputHandlerProxy::EnsureScrollUpdateLatencyComponent(\n+    LatencyInfo* monitored_latency_info,\n+    base::TimeTicks original_timestamp) {\n+  // Currently we only expect LatencyInfo's of type SCROLLBAR to get into\n+  // this state, but there are a few exceptions (i.e. GestureScrollUpdates\n+  // that are coalesced with GesturePinchUpdates via\n+  // CompositorThreadEventQueue::Queue/CoalesceScrollAndPinch).\n+  // TODO(dlibby): Update that codepath and turn this into a DCHECK when there\n+  // is a missing scroll update component.\n+  if (monitored_latency_info->source_event_type() !=\n+      ui::SourceEventType::SCROLLBAR)\n+    return;\n+\n+  // Add a scroll update component to the latency info if one doesn't exist,\n+  // based on whether or not this is the first scroll update we've seen in a\n+  // gesture sequence.\n+  monitored_latency_info->AddLatencyNumberWithTimestamp(\n+      (is_first_gesture_scroll_update_)\n+          ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT\n+          : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,\n+      original_timestamp, 1);\n+}\n+\n void InputHandlerProxy::DispatchQueuedInputEvents() {\n   // Calling |NowTicks()| is expensive so we only want to do it once.\n   base::TimeTicks now = tick_clock_->NowTicks();\n@@ -406,24 +436,6 @@ void InputHandlerProxy::InjectScrollbarGestureScroll(\n   DCHECK(!scrollbar_latency_info.FindLatency(\n       ui::INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL_COMPONENT, nullptr));\n \n-  if (type == WebInputEvent::Type::kGestureScrollBegin) {\n-    last_injected_gesture_was_begin_ = true;\n-  } else {\n-    if (type == WebInputEvent::Type::kGestureScrollUpdate) {\n-      // For injected GSUs, add a scroll update component to the latency info\n-      // so that it is properly classified as a scroll. If the last injected\n-      // gesture was a GSB, then this GSU is the first scroll update - mark\n-      // the LatencyInfo as such.\n-      scrollbar_latency_info.AddLatencyNumberWithTimestamp(\n-          (last_injected_gesture_was_begin_)\n-              ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT\n-              : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,\n-          original_timestamp, 1);\n-    }\n-\n-    last_injected_gesture_was_begin_ = false;\n-  }\n-\n   std::unique_ptr<EventWithCallback> gesture_event_with_callback_update =\n       std::make_unique<EventWithCallback>(\n           std::move(web_scoped_gesture_event), scrollbar_latency_info,""}<_**next**_>{""sha"": ""dd9f0d6a96f7e222b2d991a58df09571c09ef7a9"", ""filename"": ""ui/events/blink/input_handler_proxy.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/events/blink/input_handler_proxy.h?ref=14f2111f9cec919a450115ce4914f228effca58e"", ""patch"": ""@@ -187,6 +187,12 @@ class InputHandlerProxy : public cc::InputHandlerClient,\n       bool* is_touching_scrolling_layer,\n       cc::TouchAction* white_listed_touch_action);\n \n+  // Scroll updates injected from within the renderer process will not have a\n+  // scroll update component, since those are added to the latency info\n+  // in the browser process before being dispatched to the renderer.\n+  void EnsureScrollUpdateLatencyComponent(LatencyInfo* monitored_latency_info,\n+                                          base::TimeTicks original_timestamp);\n+\n   InputHandlerProxyClient* client_;\n   cc::InputHandler* input_handler_;\n \n@@ -229,13 +235,6 @@ class InputHandlerProxy : public cc::InputHandlerClient,\n   bool has_ongoing_compositor_scroll_or_pinch_;\n   bool is_first_gesture_scroll_update_;\n \n-  // Whether the last injected scroll gesture was a GestureScrollBegin. Used to\n-  // determine which GestureScrollUpdate is the first in a gesture sequence for\n-  // latency classification. This is separate from\n-  // |is_first_gesture_scroll_update_| and is used to determine which type of\n-  // latency component should be added for injected GestureScrollUpdates.\n-  bool last_injected_gesture_was_begin_;\n-\n   const base::TickClock* tick_clock_;\n \n   std::unique_ptr<cc::SnapFlingController> snap_fling_controller_;""}","  WARN_UNUSED_RESULT bool VerifyRecordedSamplesForHistogram(
  bool VerifyRecordedSamplesForHistogram(
       const size_t num_samples,
       const std::string& histogram_name) const {
     return num_samples ==
            histogram_tester_.GetAllSamples(histogram_name).size();
   }
","  WARN_UNUSED_RESULT bool VerifyRecordedSamplesForHistogram(
       const size_t num_samples,
       const std::string& histogram_name) const {
     return num_samples ==
            histogram_tester_.GetAllSamples(histogram_name).size();
   }
",C,"  bool VerifyRecordedSamplesForHistogram(
",,,"@@ -9,7 +9,6 @@
 #include ""base/run_loop.h""
 #include ""base/test/metrics/histogram_tester.h""
 #include ""base/test/scoped_feature_list.h""
-#include ""build/build_config.h""
 #include ""cc/base/switches.h""
 #include ""content/browser/renderer_host/input/synthetic_gesture.h""
 #include ""content/browser/renderer_host/input/synthetic_gesture_controller.h""
@@ -27,9 +26,7 @@
 #include ""content/public/test/content_browser_test_utils.h""
 #include ""content/public/test/hit_test_region_observer.h""
 #include ""content/shell/browser/shell.h""
-#include ""third_party/blink/public/common/features.h""
 #include ""ui/base/ui_base_features.h""
-#include ""ui/native_theme/native_theme_features.h""
 
 namespace {
 
@@ -104,15 +101,11 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {
   }
 
   void LoadURL() {
-    WebContents* contents = shell()->web_contents();
-    WebPreferences prefs =
-        contents->GetRenderViewHost()->GetWebkitPreferences();
-    prefs.mock_scrollbars_enabled = true;
-    contents->GetRenderViewHost()->UpdateWebkitPreferences(prefs);
     const GURL data_url(kDataURL);
     NavigateToURL(shell(), data_url);
 
     RenderWidgetHostImpl* host = GetWidgetHost();
+    host->GetView()->SetSize(gfx::Size(400, 400));
 
     HitTestRegionObserver observer(host->GetFrameSinkId());
 
@@ -181,19 +174,117 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {
     }
   }
 
+  void RunScrollbarButtonLatencyTest() {
+    // Click on the forward scrollbar button to induce a compositor thread
+    // scrollbar scroll.
+    blink::WebFloatPoint scrollbar_forward_button(795, 595);
+    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(
+        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,
+        scrollbar_forward_button.y, 0);
+    mouse_event.button = blink::WebMouseEvent::Button::kLeft;
+    mouse_event.SetTimeStamp(base::TimeTicks::Now());
+    GetWidgetHost()->ForwardMouseEvent(mouse_event);
+
+    mouse_event.SetType(blink::WebInputEvent::kMouseUp);
+    GetWidgetHost()->ForwardMouseEvent(mouse_event);
+
+    RunUntilInputProcessed(GetWidgetHost());
+
+    FetchHistogramsFromChildProcesses();
+    VerifyRecordedSamplesForHistogram(
+        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4"");
+    VerifyRecordedSamplesForHistogram(
+        1,
+        ""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2"");
+    VerifyRecordedSamplesForHistogram(
+        1,
+        ""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2"");
+    VerifyRecordedSamplesForHistogram(
+        1, ""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2"");
+    VerifyRecordedSamplesForHistogram(
+        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4"");
+    std::string thread_name =
+        DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
+    VerifyRecordedSamplesForHistogram(
+        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled_"" + thread_name);
+    VerifyRecordedSamplesForHistogram(
+        1, ""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_"" +
+               thread_name);
+  }
+
+  void RunScrollbarThumbDragLatencyTest() {
+    // Click on the scrollbar thumb and drag it twice to induce a compositor
+    // thread scrollbar ScrollBegin and ScrollUpdate.
+    blink::WebFloatPoint scrollbar_thumb(795, 30);
+    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(
+        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,
+        0);
+    mouse_down.button = blink::WebMouseEvent::Button::kLeft;
+    mouse_down.SetTimeStamp(base::TimeTicks::Now());
+    GetWidgetHost()->ForwardMouseEvent(mouse_down);
+
+    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(
+        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,
+        scrollbar_thumb.y + 10, 0);
+    mouse_move.button = blink::WebMouseEvent::Button::kLeft;
+    mouse_move.SetTimeStamp(base::TimeTicks::Now());
+    GetWidgetHost()->ForwardMouseEvent(mouse_move);
+    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);
+    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);
+    GetWidgetHost()->ForwardMouseEvent(mouse_move);
+
+    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(
+        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,
+        scrollbar_thumb.y + 20, 0);
+    mouse_up.button = blink::WebMouseEvent::Button::kLeft;
+    mouse_up.SetTimeStamp(base::TimeTicks::Now());
+    GetWidgetHost()->ForwardMouseEvent(mouse_up);
+
+    RunUntilInputProcessed(GetWidgetHost());
+
+    FetchHistogramsFromChildProcesses();
+    const std::string scroll_types[] = {""ScrollBegin"", ""ScrollUpdate""};
+    for (const std::string& scroll_type : scroll_types) {
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type +
+                 "".Scrollbar.TimeToScrollUpdateSwapBegin4"");
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type +
+                 "".Scrollbar.RendererSwapToBrowserNotified2"");
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type +
+                 "".Scrollbar.BrowserNotifiedToBeforeGpuSwap2"");
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type + "".Scrollbar.GpuSwap2"");
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type +
+                 "".Scrollbar.TimeToScrollUpdateSwapBegin4"");
+      std::string thread_name =
+          DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
+      VerifyRecordedSamplesForHistogram(1, ""Event.Latency."" + scroll_type +
+                                               "".Scrollbar.TimeToHandled_"" +
+                                               thread_name);
+      VerifyRecordedSamplesForHistogram(
+          1, ""Event.Latency."" + scroll_type +
+                 "".Scrollbar.HandledToRendererSwap2_"" + thread_name);
+    }
+  }
+
   // Returns true if the given histogram has recorded the expected number of
   // samples.
-  WARN_UNUSED_RESULT bool VerifyRecordedSamplesForHistogram(
+  bool VerifyRecordedSamplesForHistogram(
       const size_t num_samples,
       const std::string& histogram_name) const {
     return num_samples ==
            histogram_tester_.GetAllSamples(histogram_name).size();
   }
 
+  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }
+
   std::unique_ptr<base::RunLoop> run_loop_;
   bool disable_threaded_scrolling_ = false;
 
- protected:
+ private:
   base::HistogramTester histogram_tester_;
   uint32_t visual_state_callback_count_ = 0;
 
@@ -264,166 +355,24 @@ IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest,
       0, ""Event.Latency.ScrollBegin.Touch.TimeToScrollUpdateSwapBegin4""));
 }
 
-class ScrollLatencyScrollbarBrowserTest : public ScrollLatencyBrowserTest {
- public:
-  ScrollLatencyScrollbarBrowserTest() {}
-
-  void SetUpCommandLine(base::CommandLine* command_line) override {
-    command_line->AppendSwitch(::switches::kDisableSmoothScrolling);
-  }
-
-  void SetUp() override {
-    // Enable |kScrollbarInjectScrollGestures|, as these tests depend on it
-    // being on. Disable kOverlayScrollbar since overlay scrollbars are not
-    // hit-testable (thus input is not routed to scrollbars).
-    scoped_feature_list_.InitWithFeatures(
-        {blink::features::kScrollbarInjectScrollGestures},
-        {features::kOverlayScrollbar});
-    ScrollLatencyBrowserTest::SetUp();
-  }
-  ~ScrollLatencyScrollbarBrowserTest() override {}
-
- protected:
-  void RunScrollbarButtonLatencyTest() {
-    // We don't run tests that click the scrollbar on Android for a few reasons:
-    //  - Mobile browser uses scrollbars that are not hit-testable.
-    //  - On Android, you cannot resize the RenderWidgetHostView (see
-    //    |RenderWidgetHostViewAndroid::SetSize()|) and thus getting consistent
-    //    coordinates to manipulate the scrollbar is different from other
-    //    platforms.
-    // We could overcome the first limitation, by toggling various features
-    // and WebPreferences (e.g. kOverlayScrollbar feature, and
-    // viewport_enabled and use_solid_color_scrollbars WebPreferences) but at
-    // that point, we're not really testing a shipping configuration.
-#if !defined(OS_ANDROID)
-
-    // Click on the forward scrollbar button to induce a compositor thread
-    // scrollbar scroll.
-    blink::WebFloatPoint scrollbar_forward_button(795, 595);
-    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(
-        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,
-        scrollbar_forward_button.y, 0);
-    mouse_event.button = blink::WebMouseEvent::Button::kLeft;
-    mouse_event.SetTimeStamp(base::TimeTicks::Now());
-    GetWidgetHost()->ForwardMouseEvent(mouse_event);
-
-    mouse_event.SetType(blink::WebInputEvent::kMouseUp);
-    GetWidgetHost()->ForwardMouseEvent(mouse_event);
-
-    RunUntilInputProcessed(GetWidgetHost());
-
-    FetchHistogramsFromChildProcesses();
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4""));
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1,
-        ""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2""));
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1,
-        ""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2""));
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1, ""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2""));
-    std::string thread_name =
-        DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1,
-        ""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled2_"" + thread_name));
-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-        1, ""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_"" +
-               thread_name));
-#endif  // !defined(OS_ANDROID)
-  }
-
-  void RunScrollbarThumbDragLatencyTest() {
-    // See above comment in RunScrollbarButtonLatencyTest for why this test
-    // doesn't run on Android.
-#if !defined(OS_ANDROID)
-    // Click on the scrollbar thumb and drag it twice to induce a compositor
-    // thread scrollbar ScrollBegin and ScrollUpdate.
-    blink::WebFloatPoint scrollbar_thumb(795, 30);
-    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(
-        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,
-        0);
-    mouse_down.button = blink::WebMouseEvent::Button::kLeft;
-    mouse_down.SetTimeStamp(base::TimeTicks::Now());
-    GetWidgetHost()->ForwardMouseEvent(mouse_down);
-
-    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(
-        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,
-        scrollbar_thumb.y + 10, 0);
-    mouse_move.button = blink::WebMouseEvent::Button::kLeft;
-    mouse_move.SetTimeStamp(base::TimeTicks::Now());
-    GetWidgetHost()->ForwardMouseEvent(mouse_move);
-    RunUntilInputProcessed(GetWidgetHost());
-
-    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);
-    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);
-    GetWidgetHost()->ForwardMouseEvent(mouse_move);
-    RunUntilInputProcessed(GetWidgetHost());
-
-    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(
-        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,
-        scrollbar_thumb.y + 20, 0);
-    mouse_up.button = blink::WebMouseEvent::Button::kLeft;
-    mouse_up.SetTimeStamp(base::TimeTicks::Now());
-    GetWidgetHost()->ForwardMouseEvent(mouse_up);
-
-    RunUntilInputProcessed(GetWidgetHost());
-
-    FetchHistogramsFromChildProcesses();
-    const std::string scroll_types[] = {""ScrollBegin"", ""ScrollUpdate""};
-    for (const std::string& scroll_type : scroll_types) {
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type +
-                 "".Scrollbar.TimeToScrollUpdateSwapBegin4""));
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type +
-                 "".Scrollbar.RendererSwapToBrowserNotified2""));
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type +
-                 "".Scrollbar.BrowserNotifiedToBeforeGpuSwap2""));
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type + "".Scrollbar.GpuSwap2""));
-      std::string thread_name =
-          DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type + "".Scrollbar.TimeToHandled2_"" +
-                 thread_name));
-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
-          1, ""Event.Latency."" + scroll_type +
-                 "".Scrollbar.HandledToRendererSwap2_"" + thread_name));
-    }
-#endif  // !defined(OS_ANDROID)
-  }
-
-  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }
-
-  base::test::ScopedFeatureList scoped_feature_list_;
-};
-
-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,
-                       ScrollbarButtonLatency) {
+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarButtonLatency) {
   LoadURL();
 
   RunScrollbarButtonLatencyTest();
 }
 
-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,
-                       ScrollbarThumbDragLatency) {
+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarThumbDragLatency) {
   LoadURL();
 
   RunScrollbarThumbDragLatencyTest();
 }
 
 class ScrollLatencyCompositedScrollbarBrowserTest
-    : public ScrollLatencyScrollbarBrowserTest {
+    : public ScrollLatencyBrowserTest {
  public:
-  ScrollLatencyCompositedScrollbarBrowserTest() {}
-
-  void SetUp() override {
+  ScrollLatencyCompositedScrollbarBrowserTest() {
     scoped_feature_list_.InitAndEnableFeature(
         features::kCompositorThreadedScrollbarScrolling);
-    ScrollLatencyScrollbarBrowserTest::SetUp();
   }
   ~ScrollLatencyCompositedScrollbarBrowserTest() override {}
 
@@ -434,7 +383,7 @@ class ScrollLatencyCompositedScrollbarBrowserTest
 };
 
 IN_PROC_BROWSER_TEST_F(ScrollLatencyCompositedScrollbarBrowserTest,
-                       DISABLED_ScrollbarButtonLatency) {
+                       ScrollbarButtonLatency) {
   LoadURL();
 
   RunScrollbarButtonLatencyTest();",Chrome,14f2111f9cec919a450115ce4914f228effca58e,a7237f2e9866ca6088cffbb38668728606120a17,1,"  WARN_UNUSED_RESULT bool VerifyRecordedSamplesForHistogram(
//fix_flaw_line_below:
//  bool VerifyRecordedSamplesForHistogram(
       const size_t num_samples,
       const std::string& histogram_name) const {
     return num_samples ==
            histogram_tester_.GetAllSamples(histogram_name).size();
   }
"
8663,186399,,Remote,Not required,,CVE-2017-5033,https://www.cvedetails.com/cve/CVE-2017-5033/,CWE-281,Medium,,Partial,,2017-04-24,4.3,"Blink in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android failed to correctly propagate CSP restrictions to local scheme pages, which allowed a remote attacker to bypass content security policy via a crafted HTML page, related to the unsafe-inline keyword.",2019-10-02,Bypass ,6,https://github.com/chromium/chromium/commit/14f2111f9cec919a450115ce4914f228effca58e,14f2111f9cec919a450115ce4914f228effca58e,"Revert ""Add explicit flag for compositor scrollbar injected gestures""

This reverts commit d9a56afcbdf9850bc39bb3edb56d07d11a1eb2b2.

Reason for revert:

Findit (https://goo.gl/kROfz5) identified CL at revision 669086 as the
culprit for flakes in the build cycles as shown on:
https://analysis.chromium.org/p/chromium/flake-portal/analysis/culprit?key=ag9zfmZpbmRpdC1mb3ItbWVyQwsSDEZsYWtlQ3VscHJpdCIxY2hyb21pdW0vZDlhNTZhZmNiZGY5ODUwYmMzOWJiM2VkYjU2ZDA3ZDExYTFlYjJiMgw

Sample Failed Build: https://ci.chromium.org/buildbot/chromium.chromiumos/linux-chromeos-rel/25818

Sample Failed Step: content_browsertests on Ubuntu-16.04

Sample Flaky Test: ScrollLatencyScrollbarBrowserTest.ScrollbarThumbDragLatency

Original change's description:
> Add explicit flag for compositor scrollbar injected gestures
> 
> The original change to enable scrollbar latency for the composited
> scrollbars incorrectly used an existing member to try and determine
> whether a GestureScrollUpdate was the first one in an injected sequence
> or not. is_first_gesture_scroll_update_ was incorrect because it is only
> updated when input is actually dispatched to InputHandlerProxy, and the
> flag is cleared for all GSUs before the location where it was being
> read.
> 
> This bug was missed because of incorrect tests. The
> VerifyRecordedSamplesForHistogram method doesn't actually assert or
> expect anything - the return value must be inspected.
> 
> As part of fixing up the tests, I made a few other changes to get them
> passing consistently across all platforms:
> - turn on main thread scrollbar injection feature (in case it's ever
>   turned off we don't want the tests to start failing)
> - enable mock scrollbars
> - disable smooth scrolling
> - don't run scrollbar tests on Android
> 
> The composited scrollbar button test is disabled due to a bug in how
> the mock theme reports its button sizes, which throws off the region
> detection in ScrollbarLayerImplBase::IdentifyScrollbarPart (filed
> crbug.com/974063 for this issue).
> 
> Change-Id: Ie1a762a5f6ecc264d22f0256db68f141fc76b950
> 
> Bug: 954007
> Change-Id: Ib258e08e083e79da90ba2e4e4216e4879cf00cf7
> Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1652741
> Commit-Queue: Daniel Libby <dlibby@microsoft.com>
> Reviewed-by: David Bokan <bokan@chromium.org>
> Cr-Commit-Position: refs/heads/master@{#669086}


Change-Id: Icc743e48fa740fe27f0cb0cfa21b209a696f518c
No-Presubmit: true
No-Tree-Checks: true
No-Try: true
Bug: 954007
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1660114
Cr-Commit-Position: refs/heads/master@{#669150}",1,ui/events/blink/input_handler_proxy.cc,"{""sha"": ""1f98c08075cfc4dbc85a034e423ed241a3781df9"", ""filename"": ""content/browser/renderer_host/input/scroll_latency_browsertest.cc"", ""status"": ""modified"", ""additions"": 106, ""deletions"": 157, ""changes"": 263, ""blob_url"": ""https://github.com/chromium/chromium/blob/14f2111f9cec919a450115ce4914f228effca58e/content/browser/renderer_host/input/scroll_latency_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/14f2111f9cec919a450115ce4914f228effca58e/content/browser/renderer_host/input/scroll_latency_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/input/scroll_latency_browsertest.cc?ref=14f2111f9cec919a450115ce4914f228effca58e"", ""patch"": ""@@ -9,7 +9,6 @@\n #include \""base/run_loop.h\""\n #include \""base/test/metrics/histogram_tester.h\""\n #include \""base/test/scoped_feature_list.h\""\n-#include \""build/build_config.h\""\n #include \""cc/base/switches.h\""\n #include \""content/browser/renderer_host/input/synthetic_gesture.h\""\n #include \""content/browser/renderer_host/input/synthetic_gesture_controller.h\""\n@@ -27,9 +26,7 @@\n #include \""content/public/test/content_browser_test_utils.h\""\n #include \""content/public/test/hit_test_region_observer.h\""\n #include \""content/shell/browser/shell.h\""\n-#include \""third_party/blink/public/common/features.h\""\n #include \""ui/base/ui_base_features.h\""\n-#include \""ui/native_theme/native_theme_features.h\""\n \n namespace {\n \n@@ -104,15 +101,11 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {\n   }\n \n   void LoadURL() {\n-    WebContents* contents = shell()->web_contents();\n-    WebPreferences prefs =\n-        contents->GetRenderViewHost()->GetWebkitPreferences();\n-    prefs.mock_scrollbars_enabled = true;\n-    contents->GetRenderViewHost()->UpdateWebkitPreferences(prefs);\n     const GURL data_url(kDataURL);\n     NavigateToURL(shell(), data_url);\n \n     RenderWidgetHostImpl* host = GetWidgetHost();\n+    host->GetView()->SetSize(gfx::Size(400, 400));\n \n     HitTestRegionObserver observer(host->GetFrameSinkId());\n \n@@ -181,19 +174,117 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {\n     }\n   }\n \n+  void RunScrollbarButtonLatencyTest() {\n+    // Click on the forward scrollbar button to induce a compositor thread\n+    // scrollbar scroll.\n+    blink::WebFloatPoint scrollbar_forward_button(795, 595);\n+    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,\n+        scrollbar_forward_button.y, 0);\n+    mouse_event.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_event.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n+\n+    mouse_event.SetType(blink::WebInputEvent::kMouseUp);\n+    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n+\n+    RunUntilInputProcessed(GetWidgetHost());\n+\n+    FetchHistogramsFromChildProcesses();\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1,\n+        \""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1,\n+        \""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+    std::string thread_name =\n+        DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled_\"" + thread_name);\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_\"" +\n+               thread_name);\n+  }\n+\n+  void RunScrollbarThumbDragLatencyTest() {\n+    // Click on the scrollbar thumb and drag it twice to induce a compositor\n+    // thread scrollbar ScrollBegin and ScrollUpdate.\n+    blink::WebFloatPoint scrollbar_thumb(795, 30);\n+    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,\n+        0);\n+    mouse_down.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_down.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_down);\n+\n+    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,\n+        scrollbar_thumb.y + 10, 0);\n+    mouse_move.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_move.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n+    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n+    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n+    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n+\n+    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,\n+        scrollbar_thumb.y + 20, 0);\n+    mouse_up.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_up.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_up);\n+\n+    RunUntilInputProcessed(GetWidgetHost());\n+\n+    FetchHistogramsFromChildProcesses();\n+    const std::string scroll_types[] = {\""ScrollBegin\"", \""ScrollUpdate\""};\n+    for (const std::string& scroll_type : scroll_types) {\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.RendererSwapToBrowserNotified2\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.BrowserNotifiedToBeforeGpuSwap2\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type + \"".Scrollbar.GpuSwap2\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+      std::string thread_name =\n+          DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n+      VerifyRecordedSamplesForHistogram(1, \""Event.Latency.\"" + scroll_type +\n+                                               \"".Scrollbar.TimeToHandled_\"" +\n+                                               thread_name);\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.HandledToRendererSwap2_\"" + thread_name);\n+    }\n+  }\n+\n   // Returns true if the given histogram has recorded the expected number of\n   // samples.\n-  WARN_UNUSED_RESULT bool VerifyRecordedSamplesForHistogram(\n+  bool VerifyRecordedSamplesForHistogram(\n       const size_t num_samples,\n       const std::string& histogram_name) const {\n     return num_samples ==\n            histogram_tester_.GetAllSamples(histogram_name).size();\n   }\n \n+  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }\n+\n   std::unique_ptr<base::RunLoop> run_loop_;\n   bool disable_threaded_scrolling_ = false;\n \n- protected:\n+ private:\n   base::HistogramTester histogram_tester_;\n   uint32_t visual_state_callback_count_ = 0;\n \n@@ -264,166 +355,24 @@ IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest,\n       0, \""Event.Latency.ScrollBegin.Touch.TimeToScrollUpdateSwapBegin4\""));\n }\n \n-class ScrollLatencyScrollbarBrowserTest : public ScrollLatencyBrowserTest {\n- public:\n-  ScrollLatencyScrollbarBrowserTest() {}\n-\n-  void SetUpCommandLine(base::CommandLine* command_line) override {\n-    command_line->AppendSwitch(::switches::kDisableSmoothScrolling);\n-  }\n-\n-  void SetUp() override {\n-    // Enable |kScrollbarInjectScrollGestures|, as these tests depend on it\n-    // being on. Disable kOverlayScrollbar since overlay scrollbars are not\n-    // hit-testable (thus input is not routed to scrollbars).\n-    scoped_feature_list_.InitWithFeatures(\n-        {blink::features::kScrollbarInjectScrollGestures},\n-        {features::kOverlayScrollbar});\n-    ScrollLatencyBrowserTest::SetUp();\n-  }\n-  ~ScrollLatencyScrollbarBrowserTest() override {}\n-\n- protected:\n-  void RunScrollbarButtonLatencyTest() {\n-    // We don't run tests that click the scrollbar on Android for a few reasons:\n-    //  - Mobile browser uses scrollbars that are not hit-testable.\n-    //  - On Android, you cannot resize the RenderWidgetHostView (see\n-    //    |RenderWidgetHostViewAndroid::SetSize()|) and thus getting consistent\n-    //    coordinates to manipulate the scrollbar is different from other\n-    //    platforms.\n-    // We could overcome the first limitation, by toggling various features\n-    // and WebPreferences (e.g. kOverlayScrollbar feature, and\n-    // viewport_enabled and use_solid_color_scrollbars WebPreferences) but at\n-    // that point, we're not really testing a shipping configuration.\n-#if !defined(OS_ANDROID)\n-\n-    // Click on the forward scrollbar button to induce a compositor thread\n-    // scrollbar scroll.\n-    blink::WebFloatPoint scrollbar_forward_button(795, 595);\n-    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,\n-        scrollbar_forward_button.y, 0);\n-    mouse_event.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_event.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n-\n-    mouse_event.SetType(blink::WebInputEvent::kMouseUp);\n-    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n-\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    FetchHistogramsFromChildProcesses();\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\""));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1,\n-        \""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2\""));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1,\n-        \""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2\""));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1, \""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2\""));\n-    std::string thread_name =\n-        DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1,\n-        \""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled2_\"" + thread_name));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1, \""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_\"" +\n-               thread_name));\n-#endif  // !defined(OS_ANDROID)\n-  }\n-\n-  void RunScrollbarThumbDragLatencyTest() {\n-    // See above comment in RunScrollbarButtonLatencyTest for why this test\n-    // doesn't run on Android.\n-#if !defined(OS_ANDROID)\n-    // Click on the scrollbar thumb and drag it twice to induce a compositor\n-    // thread scrollbar ScrollBegin and ScrollUpdate.\n-    blink::WebFloatPoint scrollbar_thumb(795, 30);\n-    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,\n-        0);\n-    mouse_down.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_down.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_down);\n-\n-    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,\n-        scrollbar_thumb.y + 10, 0);\n-    mouse_move.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_move.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n-    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n-    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,\n-        scrollbar_thumb.y + 20, 0);\n-    mouse_up.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_up.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_up);\n-\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    FetchHistogramsFromChildProcesses();\n-    const std::string scroll_types[] = {\""ScrollBegin\"", \""ScrollUpdate\""};\n-    for (const std::string& scroll_type : scroll_types) {\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.TimeToScrollUpdateSwapBegin4\""));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.RendererSwapToBrowserNotified2\""));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.BrowserNotifiedToBeforeGpuSwap2\""));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type + \"".Scrollbar.GpuSwap2\""));\n-      std::string thread_name =\n-          DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type + \"".Scrollbar.TimeToHandled2_\"" +\n-                 thread_name));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.HandledToRendererSwap2_\"" + thread_name));\n-    }\n-#endif  // !defined(OS_ANDROID)\n-  }\n-\n-  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }\n-\n-  base::test::ScopedFeatureList scoped_feature_list_;\n-};\n-\n-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,\n-                       ScrollbarButtonLatency) {\n+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarButtonLatency) {\n   LoadURL();\n \n   RunScrollbarButtonLatencyTest();\n }\n \n-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,\n-                       ScrollbarThumbDragLatency) {\n+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarThumbDragLatency) {\n   LoadURL();\n \n   RunScrollbarThumbDragLatencyTest();\n }\n \n class ScrollLatencyCompositedScrollbarBrowserTest\n-    : public ScrollLatencyScrollbarBrowserTest {\n+    : public ScrollLatencyBrowserTest {\n  public:\n-  ScrollLatencyCompositedScrollbarBrowserTest() {}\n-\n-  void SetUp() override {\n+  ScrollLatencyCompositedScrollbarBrowserTest() {\n     scoped_feature_list_.InitAndEnableFeature(\n         features::kCompositorThreadedScrollbarScrolling);\n-    ScrollLatencyScrollbarBrowserTest::SetUp();\n   }\n   ~ScrollLatencyCompositedScrollbarBrowserTest() override {}\n \n@@ -434,7 +383,7 @@ class ScrollLatencyCompositedScrollbarBrowserTest\n };\n \n IN_PROC_BROWSER_TEST_F(ScrollLatencyCompositedScrollbarBrowserTest,\n-                       DISABLED_ScrollbarButtonLatency) {\n+                       ScrollbarButtonLatency) {\n   LoadURL();\n \n   RunScrollbarButtonLatencyTest();""}<_**next**_>{""sha"": ""053fa0d159e192dd8c6bbc001bf363dda3cb977d"", ""filename"": ""ui/events/blink/input_handler_proxy.cc"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 20, ""changes"": 52, ""blob_url"": ""https://github.com/chromium/chromium/blob/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/events/blink/input_handler_proxy.cc?ref=14f2111f9cec919a450115ce4914f228effca58e"", ""patch"": ""@@ -174,7 +174,6 @@ InputHandlerProxy::InputHandlerProxy(cc::InputHandler* input_handler,\n       current_overscroll_params_(nullptr),\n       has_ongoing_compositor_scroll_or_pinch_(false),\n       is_first_gesture_scroll_update_(false),\n-      last_injected_gesture_was_begin_(false),\n       tick_clock_(base::DefaultTickClock::GetInstance()),\n       snap_fling_controller_(std::make_unique<cc::SnapFlingController>(this)),\n       compositor_touch_action_enabled_(\n@@ -312,10 +311,15 @@ void InputHandlerProxy::DispatchSingleInputEvent(\n \n   current_overscroll_params_.reset();\n \n+  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();\n+  if (type == blink::WebGestureEvent::kGestureScrollUpdate) {\n+    EnsureScrollUpdateLatencyComponent(\n+        &monitored_latency_info, event_with_callback->event().TimeStamp());\n+  }\n+\n   InputHandlerProxy::EventDisposition disposition = RouteToTypeSpecificHandler(\n       event_with_callback->event(), original_latency_info);\n \n-  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();\n   switch (type) {\n     case blink::WebGestureEvent::kGestureScrollBegin:\n       is_first_gesture_scroll_update_ = true;\n@@ -361,6 +365,32 @@ void InputHandlerProxy::DispatchSingleInputEvent(\n                                     std::move(current_overscroll_params_));\n }\n \n+// Scroll updates injected from within the renderer process will not have a\n+// scroll update component, since those are added to the latency info\n+// in the browser process before being dispatched to the renderer.\n+void InputHandlerProxy::EnsureScrollUpdateLatencyComponent(\n+    LatencyInfo* monitored_latency_info,\n+    base::TimeTicks original_timestamp) {\n+  // Currently we only expect LatencyInfo's of type SCROLLBAR to get into\n+  // this state, but there are a few exceptions (i.e. GestureScrollUpdates\n+  // that are coalesced with GesturePinchUpdates via\n+  // CompositorThreadEventQueue::Queue/CoalesceScrollAndPinch).\n+  // TODO(dlibby): Update that codepath and turn this into a DCHECK when there\n+  // is a missing scroll update component.\n+  if (monitored_latency_info->source_event_type() !=\n+      ui::SourceEventType::SCROLLBAR)\n+    return;\n+\n+  // Add a scroll update component to the latency info if one doesn't exist,\n+  // based on whether or not this is the first scroll update we've seen in a\n+  // gesture sequence.\n+  monitored_latency_info->AddLatencyNumberWithTimestamp(\n+      (is_first_gesture_scroll_update_)\n+          ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT\n+          : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,\n+      original_timestamp, 1);\n+}\n+\n void InputHandlerProxy::DispatchQueuedInputEvents() {\n   // Calling |NowTicks()| is expensive so we only want to do it once.\n   base::TimeTicks now = tick_clock_->NowTicks();\n@@ -406,24 +436,6 @@ void InputHandlerProxy::InjectScrollbarGestureScroll(\n   DCHECK(!scrollbar_latency_info.FindLatency(\n       ui::INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL_COMPONENT, nullptr));\n \n-  if (type == WebInputEvent::Type::kGestureScrollBegin) {\n-    last_injected_gesture_was_begin_ = true;\n-  } else {\n-    if (type == WebInputEvent::Type::kGestureScrollUpdate) {\n-      // For injected GSUs, add a scroll update component to the latency info\n-      // so that it is properly classified as a scroll. If the last injected\n-      // gesture was a GSB, then this GSU is the first scroll update - mark\n-      // the LatencyInfo as such.\n-      scrollbar_latency_info.AddLatencyNumberWithTimestamp(\n-          (last_injected_gesture_was_begin_)\n-              ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT\n-              : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,\n-          original_timestamp, 1);\n-    }\n-\n-    last_injected_gesture_was_begin_ = false;\n-  }\n-\n   std::unique_ptr<EventWithCallback> gesture_event_with_callback_update =\n       std::make_unique<EventWithCallback>(\n           std::move(web_scoped_gesture_event), scrollbar_latency_info,""}<_**next**_>{""sha"": ""dd9f0d6a96f7e222b2d991a58df09571c09ef7a9"", ""filename"": ""ui/events/blink/input_handler_proxy.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/events/blink/input_handler_proxy.h?ref=14f2111f9cec919a450115ce4914f228effca58e"", ""patch"": ""@@ -187,6 +187,12 @@ class InputHandlerProxy : public cc::InputHandlerClient,\n       bool* is_touching_scrolling_layer,\n       cc::TouchAction* white_listed_touch_action);\n \n+  // Scroll updates injected from within the renderer process will not have a\n+  // scroll update component, since those are added to the latency info\n+  // in the browser process before being dispatched to the renderer.\n+  void EnsureScrollUpdateLatencyComponent(LatencyInfo* monitored_latency_info,\n+                                          base::TimeTicks original_timestamp);\n+\n   InputHandlerProxyClient* client_;\n   cc::InputHandler* input_handler_;\n \n@@ -229,13 +235,6 @@ class InputHandlerProxy : public cc::InputHandlerClient,\n   bool has_ongoing_compositor_scroll_or_pinch_;\n   bool is_first_gesture_scroll_update_;\n \n-  // Whether the last injected scroll gesture was a GestureScrollBegin. Used to\n-  // determine which GestureScrollUpdate is the first in a gesture sequence for\n-  // latency classification. This is separate from\n-  // |is_first_gesture_scroll_update_| and is used to determine which type of\n-  // latency component should be added for injected GestureScrollUpdates.\n-  bool last_injected_gesture_was_begin_;\n-\n   const base::TickClock* tick_clock_;\n \n   std::unique_ptr<cc::SnapFlingController> snap_fling_controller_;""}","void InputHandlerProxy::DispatchSingleInputEvent(
    std::unique_ptr<EventWithCallback> event_with_callback,
    const base::TimeTicks now) {
  const ui::LatencyInfo& original_latency_info =
      event_with_callback->latency_info();
  ui::LatencyInfo monitored_latency_info = original_latency_info;
  std::unique_ptr<cc::SwapPromiseMonitor> latency_info_swap_promise_monitor =
      input_handler_->CreateLatencyInfoSwapPromiseMonitor(
          &monitored_latency_info);
 
   current_overscroll_params_.reset();
 
  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();
  if (type == blink::WebGestureEvent::kGestureScrollUpdate) {
    EnsureScrollUpdateLatencyComponent(
        &monitored_latency_info, event_with_callback->event().TimeStamp());
  }

   InputHandlerProxy::EventDisposition disposition = RouteToTypeSpecificHandler(
       event_with_callback->event(), original_latency_info);
 
   switch (type) {
     case blink::WebGestureEvent::kGestureScrollBegin:
       is_first_gesture_scroll_update_ = true;
      FALLTHROUGH;
    case blink::WebGestureEvent::kGesturePinchBegin:
    case blink::WebGestureEvent::kGestureScrollUpdate:
    case blink::WebGestureEvent::kGesturePinchUpdate:
      has_ongoing_compositor_scroll_or_pinch_ = disposition == DID_HANDLE;
      break;

    case blink::WebGestureEvent::kGestureScrollEnd:
    case blink::WebGestureEvent::kGesturePinchEnd:
      has_ongoing_compositor_scroll_or_pinch_ = false;
      break;
    default:
      break;
  }

  switch (type) {
    case blink::WebGestureEvent::kGestureScrollBegin:
      momentum_scroll_jank_tracker_ =
          std::make_unique<MomentumScrollJankTracker>();
      break;
    case blink::WebGestureEvent::kGestureScrollUpdate:
      if (momentum_scroll_jank_tracker_) {
        momentum_scroll_jank_tracker_->OnDispatchedInputEvent(
            event_with_callback.get(), now);
      }
      break;
    case blink::WebGestureEvent::kGestureScrollEnd:
      momentum_scroll_jank_tracker_.reset();
      break;
    default:
      break;
  }

  event_with_callback->RunCallbacks(disposition, monitored_latency_info,
                                     std::move(current_overscroll_params_));
 }
","void InputHandlerProxy::DispatchSingleInputEvent(
    std::unique_ptr<EventWithCallback> event_with_callback,
    const base::TimeTicks now) {
  const ui::LatencyInfo& original_latency_info =
      event_with_callback->latency_info();
  ui::LatencyInfo monitored_latency_info = original_latency_info;
  std::unique_ptr<cc::SwapPromiseMonitor> latency_info_swap_promise_monitor =
      input_handler_->CreateLatencyInfoSwapPromiseMonitor(
          &monitored_latency_info);
 
   current_overscroll_params_.reset();
 
   InputHandlerProxy::EventDisposition disposition = RouteToTypeSpecificHandler(
       event_with_callback->event(), original_latency_info);
 
  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();
   switch (type) {
     case blink::WebGestureEvent::kGestureScrollBegin:
       is_first_gesture_scroll_update_ = true;
      FALLTHROUGH;
    case blink::WebGestureEvent::kGesturePinchBegin:
    case blink::WebGestureEvent::kGestureScrollUpdate:
    case blink::WebGestureEvent::kGesturePinchUpdate:
      has_ongoing_compositor_scroll_or_pinch_ = disposition == DID_HANDLE;
      break;

    case blink::WebGestureEvent::kGestureScrollEnd:
    case blink::WebGestureEvent::kGesturePinchEnd:
      has_ongoing_compositor_scroll_or_pinch_ = false;
      break;
    default:
      break;
  }

  switch (type) {
    case blink::WebGestureEvent::kGestureScrollBegin:
      momentum_scroll_jank_tracker_ =
          std::make_unique<MomentumScrollJankTracker>();
      break;
    case blink::WebGestureEvent::kGestureScrollUpdate:
      if (momentum_scroll_jank_tracker_) {
        momentum_scroll_jank_tracker_->OnDispatchedInputEvent(
            event_with_callback.get(), now);
      }
      break;
    case blink::WebGestureEvent::kGestureScrollEnd:
      momentum_scroll_jank_tracker_.reset();
      break;
    default:
      break;
  }

  event_with_callback->RunCallbacks(disposition, monitored_latency_info,
                                     std::move(current_overscroll_params_));
 }
",C,"  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();
  if (type == blink::WebGestureEvent::kGestureScrollUpdate) {
    EnsureScrollUpdateLatencyComponent(
        &monitored_latency_info, event_with_callback->event().TimeStamp());
  }

","  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();
",,"@@ -174,7 +174,6 @@ InputHandlerProxy::InputHandlerProxy(cc::InputHandler* input_handler,
       current_overscroll_params_(nullptr),
       has_ongoing_compositor_scroll_or_pinch_(false),
       is_first_gesture_scroll_update_(false),
-      last_injected_gesture_was_begin_(false),
       tick_clock_(base::DefaultTickClock::GetInstance()),
       snap_fling_controller_(std::make_unique<cc::SnapFlingController>(this)),
       compositor_touch_action_enabled_(
@@ -312,10 +311,15 @@ void InputHandlerProxy::DispatchSingleInputEvent(
 
   current_overscroll_params_.reset();
 
+  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();
+  if (type == blink::WebGestureEvent::kGestureScrollUpdate) {
+    EnsureScrollUpdateLatencyComponent(
+        &monitored_latency_info, event_with_callback->event().TimeStamp());
+  }
+
   InputHandlerProxy::EventDisposition disposition = RouteToTypeSpecificHandler(
       event_with_callback->event(), original_latency_info);
 
-  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();
   switch (type) {
     case blink::WebGestureEvent::kGestureScrollBegin:
       is_first_gesture_scroll_update_ = true;
@@ -361,6 +365,32 @@ void InputHandlerProxy::DispatchSingleInputEvent(
                                     std::move(current_overscroll_params_));
 }
 
+// Scroll updates injected from within the renderer process will not have a
+// scroll update component, since those are added to the latency info
+// in the browser process before being dispatched to the renderer.
+void InputHandlerProxy::EnsureScrollUpdateLatencyComponent(
+    LatencyInfo* monitored_latency_info,
+    base::TimeTicks original_timestamp) {
+  // Currently we only expect LatencyInfo's of type SCROLLBAR to get into
+  // this state, but there are a few exceptions (i.e. GestureScrollUpdates
+  // that are coalesced with GesturePinchUpdates via
+  // CompositorThreadEventQueue::Queue/CoalesceScrollAndPinch).
+  // TODO(dlibby): Update that codepath and turn this into a DCHECK when there
+  // is a missing scroll update component.
+  if (monitored_latency_info->source_event_type() !=
+      ui::SourceEventType::SCROLLBAR)
+    return;
+
+  // Add a scroll update component to the latency info if one doesn't exist,
+  // based on whether or not this is the first scroll update we've seen in a
+  // gesture sequence.
+  monitored_latency_info->AddLatencyNumberWithTimestamp(
+      (is_first_gesture_scroll_update_)
+          ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT
+          : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,
+      original_timestamp, 1);
+}
+
 void InputHandlerProxy::DispatchQueuedInputEvents() {
   // Calling |NowTicks()| is expensive so we only want to do it once.
   base::TimeTicks now = tick_clock_->NowTicks();
@@ -406,24 +436,6 @@ void InputHandlerProxy::InjectScrollbarGestureScroll(
   DCHECK(!scrollbar_latency_info.FindLatency(
       ui::INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL_COMPONENT, nullptr));
 
-  if (type == WebInputEvent::Type::kGestureScrollBegin) {
-    last_injected_gesture_was_begin_ = true;
-  } else {
-    if (type == WebInputEvent::Type::kGestureScrollUpdate) {
-      // For injected GSUs, add a scroll update component to the latency info
-      // so that it is properly classified as a scroll. If the last injected
-      // gesture was a GSB, then this GSU is the first scroll update - mark
-      // the LatencyInfo as such.
-      scrollbar_latency_info.AddLatencyNumberWithTimestamp(
-          (last_injected_gesture_was_begin_)
-              ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT
-              : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,
-          original_timestamp, 1);
-    }
-
-    last_injected_gesture_was_begin_ = false;
-  }
-
   std::unique_ptr<EventWithCallback> gesture_event_with_callback_update =
       std::make_unique<EventWithCallback>(
           std::move(web_scoped_gesture_event), scrollbar_latency_info,",Chrome,14f2111f9cec919a450115ce4914f228effca58e,a7237f2e9866ca6088cffbb38668728606120a17,1,"void InputHandlerProxy::DispatchSingleInputEvent(
    std::unique_ptr<EventWithCallback> event_with_callback,
    const base::TimeTicks now) {
  const ui::LatencyInfo& original_latency_info =
      event_with_callback->latency_info();
  ui::LatencyInfo monitored_latency_info = original_latency_info;
  std::unique_ptr<cc::SwapPromiseMonitor> latency_info_swap_promise_monitor =
      input_handler_->CreateLatencyInfoSwapPromiseMonitor(
          &monitored_latency_info);
 
   current_overscroll_params_.reset();
 
//fix_flaw_line_below:
//  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();
//fix_flaw_line_below:
//  if (type == blink::WebGestureEvent::kGestureScrollUpdate) {
//fix_flaw_line_below:
//    EnsureScrollUpdateLatencyComponent(
//fix_flaw_line_below:
//        &monitored_latency_info, event_with_callback->event().TimeStamp());
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
   InputHandlerProxy::EventDisposition disposition = RouteToTypeSpecificHandler(
       event_with_callback->event(), original_latency_info);
 
//flaw_line_below:
  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();
   switch (type) {
     case blink::WebGestureEvent::kGestureScrollBegin:
       is_first_gesture_scroll_update_ = true;
      FALLTHROUGH;
    case blink::WebGestureEvent::kGesturePinchBegin:
    case blink::WebGestureEvent::kGestureScrollUpdate:
    case blink::WebGestureEvent::kGesturePinchUpdate:
      has_ongoing_compositor_scroll_or_pinch_ = disposition == DID_HANDLE;
      break;

    case blink::WebGestureEvent::kGestureScrollEnd:
    case blink::WebGestureEvent::kGesturePinchEnd:
      has_ongoing_compositor_scroll_or_pinch_ = false;
      break;
    default:
      break;
  }

  // Handle jank tracking during the momentum phase of a scroll gesture. The
  // class filters non-momentum events internally.
  switch (type) {
    case blink::WebGestureEvent::kGestureScrollBegin:
      momentum_scroll_jank_tracker_ =
          std::make_unique<MomentumScrollJankTracker>();
      break;
    case blink::WebGestureEvent::kGestureScrollUpdate:
      // It's possible to get a scroll update without a begin. Ignore these
      // cases.
      if (momentum_scroll_jank_tracker_) {
        momentum_scroll_jank_tracker_->OnDispatchedInputEvent(
            event_with_callback.get(), now);
      }
      break;
    case blink::WebGestureEvent::kGestureScrollEnd:
      momentum_scroll_jank_tracker_.reset();
      break;
    default:
      break;
  }

  // Will run callback for every original events.
  event_with_callback->RunCallbacks(disposition, monitored_latency_info,
                                     std::move(current_overscroll_params_));
 }
"
8664,186400,,Remote,Not required,,CVE-2017-5033,https://www.cvedetails.com/cve/CVE-2017-5033/,CWE-281,Medium,,Partial,,2017-04-24,4.3,"Blink in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android failed to correctly propagate CSP restrictions to local scheme pages, which allowed a remote attacker to bypass content security policy via a crafted HTML page, related to the unsafe-inline keyword.",2019-10-02,Bypass ,0,https://github.com/chromium/chromium/commit/14f2111f9cec919a450115ce4914f228effca58e,14f2111f9cec919a450115ce4914f228effca58e,"Revert ""Add explicit flag for compositor scrollbar injected gestures""

This reverts commit d9a56afcbdf9850bc39bb3edb56d07d11a1eb2b2.

Reason for revert:

Findit (https://goo.gl/kROfz5) identified CL at revision 669086 as the
culprit for flakes in the build cycles as shown on:
https://analysis.chromium.org/p/chromium/flake-portal/analysis/culprit?key=ag9zfmZpbmRpdC1mb3ItbWVyQwsSDEZsYWtlQ3VscHJpdCIxY2hyb21pdW0vZDlhNTZhZmNiZGY5ODUwYmMzOWJiM2VkYjU2ZDA3ZDExYTFlYjJiMgw

Sample Failed Build: https://ci.chromium.org/buildbot/chromium.chromiumos/linux-chromeos-rel/25818

Sample Failed Step: content_browsertests on Ubuntu-16.04

Sample Flaky Test: ScrollLatencyScrollbarBrowserTest.ScrollbarThumbDragLatency

Original change's description:
> Add explicit flag for compositor scrollbar injected gestures
> 
> The original change to enable scrollbar latency for the composited
> scrollbars incorrectly used an existing member to try and determine
> whether a GestureScrollUpdate was the first one in an injected sequence
> or not. is_first_gesture_scroll_update_ was incorrect because it is only
> updated when input is actually dispatched to InputHandlerProxy, and the
> flag is cleared for all GSUs before the location where it was being
> read.
> 
> This bug was missed because of incorrect tests. The
> VerifyRecordedSamplesForHistogram method doesn't actually assert or
> expect anything - the return value must be inspected.
> 
> As part of fixing up the tests, I made a few other changes to get them
> passing consistently across all platforms:
> - turn on main thread scrollbar injection feature (in case it's ever
>   turned off we don't want the tests to start failing)
> - enable mock scrollbars
> - disable smooth scrolling
> - don't run scrollbar tests on Android
> 
> The composited scrollbar button test is disabled due to a bug in how
> the mock theme reports its button sizes, which throws off the region
> detection in ScrollbarLayerImplBase::IdentifyScrollbarPart (filed
> crbug.com/974063 for this issue).
> 
> Change-Id: Ie1a762a5f6ecc264d22f0256db68f141fc76b950
> 
> Bug: 954007
> Change-Id: Ib258e08e083e79da90ba2e4e4216e4879cf00cf7
> Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1652741
> Commit-Queue: Daniel Libby <dlibby@microsoft.com>
> Reviewed-by: David Bokan <bokan@chromium.org>
> Cr-Commit-Position: refs/heads/master@{#669086}


Change-Id: Icc743e48fa740fe27f0cb0cfa21b209a696f518c
No-Presubmit: true
No-Tree-Checks: true
No-Try: true
Bug: 954007
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1660114
Cr-Commit-Position: refs/heads/master@{#669150}",12,ui/events/blink/input_handler_proxy.cc,"{""sha"": ""1f98c08075cfc4dbc85a034e423ed241a3781df9"", ""filename"": ""content/browser/renderer_host/input/scroll_latency_browsertest.cc"", ""status"": ""modified"", ""additions"": 106, ""deletions"": 157, ""changes"": 263, ""blob_url"": ""https://github.com/chromium/chromium/blob/14f2111f9cec919a450115ce4914f228effca58e/content/browser/renderer_host/input/scroll_latency_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/14f2111f9cec919a450115ce4914f228effca58e/content/browser/renderer_host/input/scroll_latency_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/input/scroll_latency_browsertest.cc?ref=14f2111f9cec919a450115ce4914f228effca58e"", ""patch"": ""@@ -9,7 +9,6 @@\n #include \""base/run_loop.h\""\n #include \""base/test/metrics/histogram_tester.h\""\n #include \""base/test/scoped_feature_list.h\""\n-#include \""build/build_config.h\""\n #include \""cc/base/switches.h\""\n #include \""content/browser/renderer_host/input/synthetic_gesture.h\""\n #include \""content/browser/renderer_host/input/synthetic_gesture_controller.h\""\n@@ -27,9 +26,7 @@\n #include \""content/public/test/content_browser_test_utils.h\""\n #include \""content/public/test/hit_test_region_observer.h\""\n #include \""content/shell/browser/shell.h\""\n-#include \""third_party/blink/public/common/features.h\""\n #include \""ui/base/ui_base_features.h\""\n-#include \""ui/native_theme/native_theme_features.h\""\n \n namespace {\n \n@@ -104,15 +101,11 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {\n   }\n \n   void LoadURL() {\n-    WebContents* contents = shell()->web_contents();\n-    WebPreferences prefs =\n-        contents->GetRenderViewHost()->GetWebkitPreferences();\n-    prefs.mock_scrollbars_enabled = true;\n-    contents->GetRenderViewHost()->UpdateWebkitPreferences(prefs);\n     const GURL data_url(kDataURL);\n     NavigateToURL(shell(), data_url);\n \n     RenderWidgetHostImpl* host = GetWidgetHost();\n+    host->GetView()->SetSize(gfx::Size(400, 400));\n \n     HitTestRegionObserver observer(host->GetFrameSinkId());\n \n@@ -181,19 +174,117 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {\n     }\n   }\n \n+  void RunScrollbarButtonLatencyTest() {\n+    // Click on the forward scrollbar button to induce a compositor thread\n+    // scrollbar scroll.\n+    blink::WebFloatPoint scrollbar_forward_button(795, 595);\n+    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,\n+        scrollbar_forward_button.y, 0);\n+    mouse_event.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_event.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n+\n+    mouse_event.SetType(blink::WebInputEvent::kMouseUp);\n+    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n+\n+    RunUntilInputProcessed(GetWidgetHost());\n+\n+    FetchHistogramsFromChildProcesses();\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1,\n+        \""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1,\n+        \""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+    std::string thread_name =\n+        DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled_\"" + thread_name);\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_\"" +\n+               thread_name);\n+  }\n+\n+  void RunScrollbarThumbDragLatencyTest() {\n+    // Click on the scrollbar thumb and drag it twice to induce a compositor\n+    // thread scrollbar ScrollBegin and ScrollUpdate.\n+    blink::WebFloatPoint scrollbar_thumb(795, 30);\n+    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,\n+        0);\n+    mouse_down.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_down.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_down);\n+\n+    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,\n+        scrollbar_thumb.y + 10, 0);\n+    mouse_move.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_move.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n+    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n+    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n+    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n+\n+    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,\n+        scrollbar_thumb.y + 20, 0);\n+    mouse_up.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_up.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_up);\n+\n+    RunUntilInputProcessed(GetWidgetHost());\n+\n+    FetchHistogramsFromChildProcesses();\n+    const std::string scroll_types[] = {\""ScrollBegin\"", \""ScrollUpdate\""};\n+    for (const std::string& scroll_type : scroll_types) {\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.RendererSwapToBrowserNotified2\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.BrowserNotifiedToBeforeGpuSwap2\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type + \"".Scrollbar.GpuSwap2\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+      std::string thread_name =\n+          DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n+      VerifyRecordedSamplesForHistogram(1, \""Event.Latency.\"" + scroll_type +\n+                                               \"".Scrollbar.TimeToHandled_\"" +\n+                                               thread_name);\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.HandledToRendererSwap2_\"" + thread_name);\n+    }\n+  }\n+\n   // Returns true if the given histogram has recorded the expected number of\n   // samples.\n-  WARN_UNUSED_RESULT bool VerifyRecordedSamplesForHistogram(\n+  bool VerifyRecordedSamplesForHistogram(\n       const size_t num_samples,\n       const std::string& histogram_name) const {\n     return num_samples ==\n            histogram_tester_.GetAllSamples(histogram_name).size();\n   }\n \n+  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }\n+\n   std::unique_ptr<base::RunLoop> run_loop_;\n   bool disable_threaded_scrolling_ = false;\n \n- protected:\n+ private:\n   base::HistogramTester histogram_tester_;\n   uint32_t visual_state_callback_count_ = 0;\n \n@@ -264,166 +355,24 @@ IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest,\n       0, \""Event.Latency.ScrollBegin.Touch.TimeToScrollUpdateSwapBegin4\""));\n }\n \n-class ScrollLatencyScrollbarBrowserTest : public ScrollLatencyBrowserTest {\n- public:\n-  ScrollLatencyScrollbarBrowserTest() {}\n-\n-  void SetUpCommandLine(base::CommandLine* command_line) override {\n-    command_line->AppendSwitch(::switches::kDisableSmoothScrolling);\n-  }\n-\n-  void SetUp() override {\n-    // Enable |kScrollbarInjectScrollGestures|, as these tests depend on it\n-    // being on. Disable kOverlayScrollbar since overlay scrollbars are not\n-    // hit-testable (thus input is not routed to scrollbars).\n-    scoped_feature_list_.InitWithFeatures(\n-        {blink::features::kScrollbarInjectScrollGestures},\n-        {features::kOverlayScrollbar});\n-    ScrollLatencyBrowserTest::SetUp();\n-  }\n-  ~ScrollLatencyScrollbarBrowserTest() override {}\n-\n- protected:\n-  void RunScrollbarButtonLatencyTest() {\n-    // We don't run tests that click the scrollbar on Android for a few reasons:\n-    //  - Mobile browser uses scrollbars that are not hit-testable.\n-    //  - On Android, you cannot resize the RenderWidgetHostView (see\n-    //    |RenderWidgetHostViewAndroid::SetSize()|) and thus getting consistent\n-    //    coordinates to manipulate the scrollbar is different from other\n-    //    platforms.\n-    // We could overcome the first limitation, by toggling various features\n-    // and WebPreferences (e.g. kOverlayScrollbar feature, and\n-    // viewport_enabled and use_solid_color_scrollbars WebPreferences) but at\n-    // that point, we're not really testing a shipping configuration.\n-#if !defined(OS_ANDROID)\n-\n-    // Click on the forward scrollbar button to induce a compositor thread\n-    // scrollbar scroll.\n-    blink::WebFloatPoint scrollbar_forward_button(795, 595);\n-    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,\n-        scrollbar_forward_button.y, 0);\n-    mouse_event.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_event.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n-\n-    mouse_event.SetType(blink::WebInputEvent::kMouseUp);\n-    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n-\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    FetchHistogramsFromChildProcesses();\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\""));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1,\n-        \""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2\""));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1,\n-        \""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2\""));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1, \""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2\""));\n-    std::string thread_name =\n-        DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1,\n-        \""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled2_\"" + thread_name));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1, \""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_\"" +\n-               thread_name));\n-#endif  // !defined(OS_ANDROID)\n-  }\n-\n-  void RunScrollbarThumbDragLatencyTest() {\n-    // See above comment in RunScrollbarButtonLatencyTest for why this test\n-    // doesn't run on Android.\n-#if !defined(OS_ANDROID)\n-    // Click on the scrollbar thumb and drag it twice to induce a compositor\n-    // thread scrollbar ScrollBegin and ScrollUpdate.\n-    blink::WebFloatPoint scrollbar_thumb(795, 30);\n-    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,\n-        0);\n-    mouse_down.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_down.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_down);\n-\n-    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,\n-        scrollbar_thumb.y + 10, 0);\n-    mouse_move.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_move.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n-    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n-    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,\n-        scrollbar_thumb.y + 20, 0);\n-    mouse_up.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_up.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_up);\n-\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    FetchHistogramsFromChildProcesses();\n-    const std::string scroll_types[] = {\""ScrollBegin\"", \""ScrollUpdate\""};\n-    for (const std::string& scroll_type : scroll_types) {\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.TimeToScrollUpdateSwapBegin4\""));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.RendererSwapToBrowserNotified2\""));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.BrowserNotifiedToBeforeGpuSwap2\""));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type + \"".Scrollbar.GpuSwap2\""));\n-      std::string thread_name =\n-          DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type + \"".Scrollbar.TimeToHandled2_\"" +\n-                 thread_name));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.HandledToRendererSwap2_\"" + thread_name));\n-    }\n-#endif  // !defined(OS_ANDROID)\n-  }\n-\n-  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }\n-\n-  base::test::ScopedFeatureList scoped_feature_list_;\n-};\n-\n-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,\n-                       ScrollbarButtonLatency) {\n+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarButtonLatency) {\n   LoadURL();\n \n   RunScrollbarButtonLatencyTest();\n }\n \n-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,\n-                       ScrollbarThumbDragLatency) {\n+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarThumbDragLatency) {\n   LoadURL();\n \n   RunScrollbarThumbDragLatencyTest();\n }\n \n class ScrollLatencyCompositedScrollbarBrowserTest\n-    : public ScrollLatencyScrollbarBrowserTest {\n+    : public ScrollLatencyBrowserTest {\n  public:\n-  ScrollLatencyCompositedScrollbarBrowserTest() {}\n-\n-  void SetUp() override {\n+  ScrollLatencyCompositedScrollbarBrowserTest() {\n     scoped_feature_list_.InitAndEnableFeature(\n         features::kCompositorThreadedScrollbarScrolling);\n-    ScrollLatencyScrollbarBrowserTest::SetUp();\n   }\n   ~ScrollLatencyCompositedScrollbarBrowserTest() override {}\n \n@@ -434,7 +383,7 @@ class ScrollLatencyCompositedScrollbarBrowserTest\n };\n \n IN_PROC_BROWSER_TEST_F(ScrollLatencyCompositedScrollbarBrowserTest,\n-                       DISABLED_ScrollbarButtonLatency) {\n+                       ScrollbarButtonLatency) {\n   LoadURL();\n \n   RunScrollbarButtonLatencyTest();""}<_**next**_>{""sha"": ""053fa0d159e192dd8c6bbc001bf363dda3cb977d"", ""filename"": ""ui/events/blink/input_handler_proxy.cc"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 20, ""changes"": 52, ""blob_url"": ""https://github.com/chromium/chromium/blob/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/events/blink/input_handler_proxy.cc?ref=14f2111f9cec919a450115ce4914f228effca58e"", ""patch"": ""@@ -174,7 +174,6 @@ InputHandlerProxy::InputHandlerProxy(cc::InputHandler* input_handler,\n       current_overscroll_params_(nullptr),\n       has_ongoing_compositor_scroll_or_pinch_(false),\n       is_first_gesture_scroll_update_(false),\n-      last_injected_gesture_was_begin_(false),\n       tick_clock_(base::DefaultTickClock::GetInstance()),\n       snap_fling_controller_(std::make_unique<cc::SnapFlingController>(this)),\n       compositor_touch_action_enabled_(\n@@ -312,10 +311,15 @@ void InputHandlerProxy::DispatchSingleInputEvent(\n \n   current_overscroll_params_.reset();\n \n+  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();\n+  if (type == blink::WebGestureEvent::kGestureScrollUpdate) {\n+    EnsureScrollUpdateLatencyComponent(\n+        &monitored_latency_info, event_with_callback->event().TimeStamp());\n+  }\n+\n   InputHandlerProxy::EventDisposition disposition = RouteToTypeSpecificHandler(\n       event_with_callback->event(), original_latency_info);\n \n-  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();\n   switch (type) {\n     case blink::WebGestureEvent::kGestureScrollBegin:\n       is_first_gesture_scroll_update_ = true;\n@@ -361,6 +365,32 @@ void InputHandlerProxy::DispatchSingleInputEvent(\n                                     std::move(current_overscroll_params_));\n }\n \n+// Scroll updates injected from within the renderer process will not have a\n+// scroll update component, since those are added to the latency info\n+// in the browser process before being dispatched to the renderer.\n+void InputHandlerProxy::EnsureScrollUpdateLatencyComponent(\n+    LatencyInfo* monitored_latency_info,\n+    base::TimeTicks original_timestamp) {\n+  // Currently we only expect LatencyInfo's of type SCROLLBAR to get into\n+  // this state, but there are a few exceptions (i.e. GestureScrollUpdates\n+  // that are coalesced with GesturePinchUpdates via\n+  // CompositorThreadEventQueue::Queue/CoalesceScrollAndPinch).\n+  // TODO(dlibby): Update that codepath and turn this into a DCHECK when there\n+  // is a missing scroll update component.\n+  if (monitored_latency_info->source_event_type() !=\n+      ui::SourceEventType::SCROLLBAR)\n+    return;\n+\n+  // Add a scroll update component to the latency info if one doesn't exist,\n+  // based on whether or not this is the first scroll update we've seen in a\n+  // gesture sequence.\n+  monitored_latency_info->AddLatencyNumberWithTimestamp(\n+      (is_first_gesture_scroll_update_)\n+          ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT\n+          : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,\n+      original_timestamp, 1);\n+}\n+\n void InputHandlerProxy::DispatchQueuedInputEvents() {\n   // Calling |NowTicks()| is expensive so we only want to do it once.\n   base::TimeTicks now = tick_clock_->NowTicks();\n@@ -406,24 +436,6 @@ void InputHandlerProxy::InjectScrollbarGestureScroll(\n   DCHECK(!scrollbar_latency_info.FindLatency(\n       ui::INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL_COMPONENT, nullptr));\n \n-  if (type == WebInputEvent::Type::kGestureScrollBegin) {\n-    last_injected_gesture_was_begin_ = true;\n-  } else {\n-    if (type == WebInputEvent::Type::kGestureScrollUpdate) {\n-      // For injected GSUs, add a scroll update component to the latency info\n-      // so that it is properly classified as a scroll. If the last injected\n-      // gesture was a GSB, then this GSU is the first scroll update - mark\n-      // the LatencyInfo as such.\n-      scrollbar_latency_info.AddLatencyNumberWithTimestamp(\n-          (last_injected_gesture_was_begin_)\n-              ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT\n-              : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,\n-          original_timestamp, 1);\n-    }\n-\n-    last_injected_gesture_was_begin_ = false;\n-  }\n-\n   std::unique_ptr<EventWithCallback> gesture_event_with_callback_update =\n       std::make_unique<EventWithCallback>(\n           std::move(web_scoped_gesture_event), scrollbar_latency_info,""}<_**next**_>{""sha"": ""dd9f0d6a96f7e222b2d991a58df09571c09ef7a9"", ""filename"": ""ui/events/blink/input_handler_proxy.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/events/blink/input_handler_proxy.h?ref=14f2111f9cec919a450115ce4914f228effca58e"", ""patch"": ""@@ -187,6 +187,12 @@ class InputHandlerProxy : public cc::InputHandlerClient,\n       bool* is_touching_scrolling_layer,\n       cc::TouchAction* white_listed_touch_action);\n \n+  // Scroll updates injected from within the renderer process will not have a\n+  // scroll update component, since those are added to the latency info\n+  // in the browser process before being dispatched to the renderer.\n+  void EnsureScrollUpdateLatencyComponent(LatencyInfo* monitored_latency_info,\n+                                          base::TimeTicks original_timestamp);\n+\n   InputHandlerProxyClient* client_;\n   cc::InputHandler* input_handler_;\n \n@@ -229,13 +235,6 @@ class InputHandlerProxy : public cc::InputHandlerClient,\n   bool has_ongoing_compositor_scroll_or_pinch_;\n   bool is_first_gesture_scroll_update_;\n \n-  // Whether the last injected scroll gesture was a GestureScrollBegin. Used to\n-  // determine which GestureScrollUpdate is the first in a gesture sequence for\n-  // latency classification. This is separate from\n-  // |is_first_gesture_scroll_update_| and is used to determine which type of\n-  // latency component should be added for injected GestureScrollUpdates.\n-  bool last_injected_gesture_was_begin_;\n-\n   const base::TickClock* tick_clock_;\n \n   std::unique_ptr<cc::SnapFlingController> snap_fling_controller_;""}","void InputHandlerProxy::InjectScrollbarGestureScroll(
    const WebInputEvent::Type type,
    const blink::WebFloatPoint& position_in_widget,
    const cc::InputHandlerPointerResult& pointer_result,
    const LatencyInfo& latency_info,
    const base::TimeTicks original_timestamp) {
  gfx::Vector2dF scroll_delta(pointer_result.scroll_offset.x(),
                              pointer_result.scroll_offset.y());
  std::unique_ptr<WebGestureEvent> synthetic_gesture_event =
      GenerateInjectedScrollGesture(
          type, original_timestamp, blink::WebGestureDevice::kScrollbar,
          position_in_widget, scroll_delta,
          pointer_result.scroll_units);

  WebScopedInputEvent web_scoped_gesture_event(
      synthetic_gesture_event.release());

  LatencyInfo scrollbar_latency_info(latency_info);
  scrollbar_latency_info.set_source_event_type(ui::SourceEventType::SCROLLBAR);

   DCHECK(!scrollbar_latency_info.FindLatency(
       ui::INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL_COMPONENT, nullptr));
 
   std::unique_ptr<EventWithCallback> gesture_event_with_callback_update =
       std::make_unique<EventWithCallback>(
           std::move(web_scoped_gesture_event), scrollbar_latency_info,
          original_timestamp, original_timestamp, nullptr);

  bool needs_animate_input = compositor_event_queue_->empty();
  compositor_event_queue_->Queue(std::move(gesture_event_with_callback_update),
                                 original_timestamp);

  if (needs_animate_input)
    input_handler_->SetNeedsAnimateInput();
}
","void InputHandlerProxy::InjectScrollbarGestureScroll(
    const WebInputEvent::Type type,
    const blink::WebFloatPoint& position_in_widget,
    const cc::InputHandlerPointerResult& pointer_result,
    const LatencyInfo& latency_info,
    const base::TimeTicks original_timestamp) {
  gfx::Vector2dF scroll_delta(pointer_result.scroll_offset.x(),
                              pointer_result.scroll_offset.y());
  std::unique_ptr<WebGestureEvent> synthetic_gesture_event =
      GenerateInjectedScrollGesture(
          type, original_timestamp, blink::WebGestureDevice::kScrollbar,
          position_in_widget, scroll_delta,
          pointer_result.scroll_units);

  WebScopedInputEvent web_scoped_gesture_event(
      synthetic_gesture_event.release());

  LatencyInfo scrollbar_latency_info(latency_info);
  scrollbar_latency_info.set_source_event_type(ui::SourceEventType::SCROLLBAR);

   DCHECK(!scrollbar_latency_info.FindLatency(
       ui::INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL_COMPONENT, nullptr));
 
  if (type == WebInputEvent::Type::kGestureScrollBegin) {
    last_injected_gesture_was_begin_ = true;
  } else {
    if (type == WebInputEvent::Type::kGestureScrollUpdate) {
      scrollbar_latency_info.AddLatencyNumberWithTimestamp(
          (last_injected_gesture_was_begin_)
              ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT
              : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,
          original_timestamp, 1);
    }
    last_injected_gesture_was_begin_ = false;
  }
   std::unique_ptr<EventWithCallback> gesture_event_with_callback_update =
       std::make_unique<EventWithCallback>(
           std::move(web_scoped_gesture_event), scrollbar_latency_info,
          original_timestamp, original_timestamp, nullptr);

  bool needs_animate_input = compositor_event_queue_->empty();
  compositor_event_queue_->Queue(std::move(gesture_event_with_callback_update),
                                 original_timestamp);

  if (needs_animate_input)
    input_handler_->SetNeedsAnimateInput();
}
",C,,"  if (type == WebInputEvent::Type::kGestureScrollBegin) {
    last_injected_gesture_was_begin_ = true;
  } else {
    if (type == WebInputEvent::Type::kGestureScrollUpdate) {
      scrollbar_latency_info.AddLatencyNumberWithTimestamp(
          (last_injected_gesture_was_begin_)
              ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT
              : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,
          original_timestamp, 1);
    }
    last_injected_gesture_was_begin_ = false;
  }
",,"@@ -174,7 +174,6 @@ InputHandlerProxy::InputHandlerProxy(cc::InputHandler* input_handler,
       current_overscroll_params_(nullptr),
       has_ongoing_compositor_scroll_or_pinch_(false),
       is_first_gesture_scroll_update_(false),
-      last_injected_gesture_was_begin_(false),
       tick_clock_(base::DefaultTickClock::GetInstance()),
       snap_fling_controller_(std::make_unique<cc::SnapFlingController>(this)),
       compositor_touch_action_enabled_(
@@ -312,10 +311,15 @@ void InputHandlerProxy::DispatchSingleInputEvent(
 
   current_overscroll_params_.reset();
 
+  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();
+  if (type == blink::WebGestureEvent::kGestureScrollUpdate) {
+    EnsureScrollUpdateLatencyComponent(
+        &monitored_latency_info, event_with_callback->event().TimeStamp());
+  }
+
   InputHandlerProxy::EventDisposition disposition = RouteToTypeSpecificHandler(
       event_with_callback->event(), original_latency_info);
 
-  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();
   switch (type) {
     case blink::WebGestureEvent::kGestureScrollBegin:
       is_first_gesture_scroll_update_ = true;
@@ -361,6 +365,32 @@ void InputHandlerProxy::DispatchSingleInputEvent(
                                     std::move(current_overscroll_params_));
 }
 
+// Scroll updates injected from within the renderer process will not have a
+// scroll update component, since those are added to the latency info
+// in the browser process before being dispatched to the renderer.
+void InputHandlerProxy::EnsureScrollUpdateLatencyComponent(
+    LatencyInfo* monitored_latency_info,
+    base::TimeTicks original_timestamp) {
+  // Currently we only expect LatencyInfo's of type SCROLLBAR to get into
+  // this state, but there are a few exceptions (i.e. GestureScrollUpdates
+  // that are coalesced with GesturePinchUpdates via
+  // CompositorThreadEventQueue::Queue/CoalesceScrollAndPinch).
+  // TODO(dlibby): Update that codepath and turn this into a DCHECK when there
+  // is a missing scroll update component.
+  if (monitored_latency_info->source_event_type() !=
+      ui::SourceEventType::SCROLLBAR)
+    return;
+
+  // Add a scroll update component to the latency info if one doesn't exist,
+  // based on whether or not this is the first scroll update we've seen in a
+  // gesture sequence.
+  monitored_latency_info->AddLatencyNumberWithTimestamp(
+      (is_first_gesture_scroll_update_)
+          ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT
+          : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,
+      original_timestamp, 1);
+}
+
 void InputHandlerProxy::DispatchQueuedInputEvents() {
   // Calling |NowTicks()| is expensive so we only want to do it once.
   base::TimeTicks now = tick_clock_->NowTicks();
@@ -406,24 +436,6 @@ void InputHandlerProxy::InjectScrollbarGestureScroll(
   DCHECK(!scrollbar_latency_info.FindLatency(
       ui::INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL_COMPONENT, nullptr));
 
-  if (type == WebInputEvent::Type::kGestureScrollBegin) {
-    last_injected_gesture_was_begin_ = true;
-  } else {
-    if (type == WebInputEvent::Type::kGestureScrollUpdate) {
-      // For injected GSUs, add a scroll update component to the latency info
-      // so that it is properly classified as a scroll. If the last injected
-      // gesture was a GSB, then this GSU is the first scroll update - mark
-      // the LatencyInfo as such.
-      scrollbar_latency_info.AddLatencyNumberWithTimestamp(
-          (last_injected_gesture_was_begin_)
-              ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT
-              : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,
-          original_timestamp, 1);
-    }
-
-    last_injected_gesture_was_begin_ = false;
-  }
-
   std::unique_ptr<EventWithCallback> gesture_event_with_callback_update =
       std::make_unique<EventWithCallback>(
           std::move(web_scoped_gesture_event), scrollbar_latency_info,",Chrome,14f2111f9cec919a450115ce4914f228effca58e,a7237f2e9866ca6088cffbb38668728606120a17,1,"void InputHandlerProxy::InjectScrollbarGestureScroll(
    const WebInputEvent::Type type,
    const blink::WebFloatPoint& position_in_widget,
    const cc::InputHandlerPointerResult& pointer_result,
    const LatencyInfo& latency_info,
    const base::TimeTicks original_timestamp) {
  gfx::Vector2dF scroll_delta(pointer_result.scroll_offset.x(),
                              pointer_result.scroll_offset.y());
  std::unique_ptr<WebGestureEvent> synthetic_gesture_event =
      GenerateInjectedScrollGesture(
          type, original_timestamp, blink::WebGestureDevice::kScrollbar,
          position_in_widget, scroll_delta,
          pointer_result.scroll_units);

  WebScopedInputEvent web_scoped_gesture_event(
      synthetic_gesture_event.release());

  // Send in a LatencyInfo with SCROLLBAR type so that the end to end latency
  // is calculated specifically for scrollbars.
  LatencyInfo scrollbar_latency_info(latency_info);
  scrollbar_latency_info.set_source_event_type(ui::SourceEventType::SCROLLBAR);

  // This latency_info should not have already been scheduled for rendering -
  // i.e. it should be the original latency_info that was associated with the
  // input event that caused this scroll injection. If it has already been
  // scheduled it won't get queued to be shipped off with the CompositorFrame
  // when the gesture is handled.
   DCHECK(!scrollbar_latency_info.FindLatency(
       ui::INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL_COMPONENT, nullptr));
 
//flaw_line_below:
  if (type == WebInputEvent::Type::kGestureScrollBegin) {
//flaw_line_below:
    last_injected_gesture_was_begin_ = true;
//flaw_line_below:
  } else {
//flaw_line_below:
    if (type == WebInputEvent::Type::kGestureScrollUpdate) {
//flaw_line_below:
      // For injected GSUs, add a scroll update component to the latency info
//flaw_line_below:
      // so that it is properly classified as a scroll. If the last injected
//flaw_line_below:
      // gesture was a GSB, then this GSU is the first scroll update - mark
//flaw_line_below:
      // the LatencyInfo as such.
//flaw_line_below:
      scrollbar_latency_info.AddLatencyNumberWithTimestamp(
//flaw_line_below:
          (last_injected_gesture_was_begin_)
//flaw_line_below:
              ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT
//flaw_line_below:
              : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,
//flaw_line_below:
          original_timestamp, 1);
//flaw_line_below:
    }
//flaw_line_below:

//flaw_line_below:
    last_injected_gesture_was_begin_ = false;
//flaw_line_below:
  }
//flaw_line_below:

   std::unique_ptr<EventWithCallback> gesture_event_with_callback_update =
       std::make_unique<EventWithCallback>(
           std::move(web_scoped_gesture_event), scrollbar_latency_info,
          original_timestamp, original_timestamp, nullptr);

  bool needs_animate_input = compositor_event_queue_->empty();
  compositor_event_queue_->Queue(std::move(gesture_event_with_callback_update),
                                 original_timestamp);

  if (needs_animate_input)
    input_handler_->SetNeedsAnimateInput();
}
"
8665,186401,,Remote,Not required,,CVE-2017-5033,https://www.cvedetails.com/cve/CVE-2017-5033/,CWE-281,Medium,,Partial,,2017-04-24,4.3,"Blink in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android failed to correctly propagate CSP restrictions to local scheme pages, which allowed a remote attacker to bypass content security policy via a crafted HTML page, related to the unsafe-inline keyword.",2019-10-02,Bypass ,0,https://github.com/chromium/chromium/commit/14f2111f9cec919a450115ce4914f228effca58e,14f2111f9cec919a450115ce4914f228effca58e,"Revert ""Add explicit flag for compositor scrollbar injected gestures""

This reverts commit d9a56afcbdf9850bc39bb3edb56d07d11a1eb2b2.

Reason for revert:

Findit (https://goo.gl/kROfz5) identified CL at revision 669086 as the
culprit for flakes in the build cycles as shown on:
https://analysis.chromium.org/p/chromium/flake-portal/analysis/culprit?key=ag9zfmZpbmRpdC1mb3ItbWVyQwsSDEZsYWtlQ3VscHJpdCIxY2hyb21pdW0vZDlhNTZhZmNiZGY5ODUwYmMzOWJiM2VkYjU2ZDA3ZDExYTFlYjJiMgw

Sample Failed Build: https://ci.chromium.org/buildbot/chromium.chromiumos/linux-chromeos-rel/25818

Sample Failed Step: content_browsertests on Ubuntu-16.04

Sample Flaky Test: ScrollLatencyScrollbarBrowserTest.ScrollbarThumbDragLatency

Original change's description:
> Add explicit flag for compositor scrollbar injected gestures
> 
> The original change to enable scrollbar latency for the composited
> scrollbars incorrectly used an existing member to try and determine
> whether a GestureScrollUpdate was the first one in an injected sequence
> or not. is_first_gesture_scroll_update_ was incorrect because it is only
> updated when input is actually dispatched to InputHandlerProxy, and the
> flag is cleared for all GSUs before the location where it was being
> read.
> 
> This bug was missed because of incorrect tests. The
> VerifyRecordedSamplesForHistogram method doesn't actually assert or
> expect anything - the return value must be inspected.
> 
> As part of fixing up the tests, I made a few other changes to get them
> passing consistently across all platforms:
> - turn on main thread scrollbar injection feature (in case it's ever
>   turned off we don't want the tests to start failing)
> - enable mock scrollbars
> - disable smooth scrolling
> - don't run scrollbar tests on Android
> 
> The composited scrollbar button test is disabled due to a bug in how
> the mock theme reports its button sizes, which throws off the region
> detection in ScrollbarLayerImplBase::IdentifyScrollbarPart (filed
> crbug.com/974063 for this issue).
> 
> Change-Id: Ie1a762a5f6ecc264d22f0256db68f141fc76b950
> 
> Bug: 954007
> Change-Id: Ib258e08e083e79da90ba2e4e4216e4879cf00cf7
> Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1652741
> Commit-Queue: Daniel Libby <dlibby@microsoft.com>
> Reviewed-by: David Bokan <bokan@chromium.org>
> Cr-Commit-Position: refs/heads/master@{#669086}


Change-Id: Icc743e48fa740fe27f0cb0cfa21b209a696f518c
No-Presubmit: true
No-Tree-Checks: true
No-Try: true
Bug: 954007
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1660114
Cr-Commit-Position: refs/heads/master@{#669150}",1,ui/events/blink/input_handler_proxy.cc,"{""sha"": ""1f98c08075cfc4dbc85a034e423ed241a3781df9"", ""filename"": ""content/browser/renderer_host/input/scroll_latency_browsertest.cc"", ""status"": ""modified"", ""additions"": 106, ""deletions"": 157, ""changes"": 263, ""blob_url"": ""https://github.com/chromium/chromium/blob/14f2111f9cec919a450115ce4914f228effca58e/content/browser/renderer_host/input/scroll_latency_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/14f2111f9cec919a450115ce4914f228effca58e/content/browser/renderer_host/input/scroll_latency_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/input/scroll_latency_browsertest.cc?ref=14f2111f9cec919a450115ce4914f228effca58e"", ""patch"": ""@@ -9,7 +9,6 @@\n #include \""base/run_loop.h\""\n #include \""base/test/metrics/histogram_tester.h\""\n #include \""base/test/scoped_feature_list.h\""\n-#include \""build/build_config.h\""\n #include \""cc/base/switches.h\""\n #include \""content/browser/renderer_host/input/synthetic_gesture.h\""\n #include \""content/browser/renderer_host/input/synthetic_gesture_controller.h\""\n@@ -27,9 +26,7 @@\n #include \""content/public/test/content_browser_test_utils.h\""\n #include \""content/public/test/hit_test_region_observer.h\""\n #include \""content/shell/browser/shell.h\""\n-#include \""third_party/blink/public/common/features.h\""\n #include \""ui/base/ui_base_features.h\""\n-#include \""ui/native_theme/native_theme_features.h\""\n \n namespace {\n \n@@ -104,15 +101,11 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {\n   }\n \n   void LoadURL() {\n-    WebContents* contents = shell()->web_contents();\n-    WebPreferences prefs =\n-        contents->GetRenderViewHost()->GetWebkitPreferences();\n-    prefs.mock_scrollbars_enabled = true;\n-    contents->GetRenderViewHost()->UpdateWebkitPreferences(prefs);\n     const GURL data_url(kDataURL);\n     NavigateToURL(shell(), data_url);\n \n     RenderWidgetHostImpl* host = GetWidgetHost();\n+    host->GetView()->SetSize(gfx::Size(400, 400));\n \n     HitTestRegionObserver observer(host->GetFrameSinkId());\n \n@@ -181,19 +174,117 @@ class ScrollLatencyBrowserTest : public ContentBrowserTest {\n     }\n   }\n \n+  void RunScrollbarButtonLatencyTest() {\n+    // Click on the forward scrollbar button to induce a compositor thread\n+    // scrollbar scroll.\n+    blink::WebFloatPoint scrollbar_forward_button(795, 595);\n+    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,\n+        scrollbar_forward_button.y, 0);\n+    mouse_event.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_event.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n+\n+    mouse_event.SetType(blink::WebInputEvent::kMouseUp);\n+    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n+\n+    RunUntilInputProcessed(GetWidgetHost());\n+\n+    FetchHistogramsFromChildProcesses();\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1,\n+        \""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1,\n+        \""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2\"");\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+    std::string thread_name =\n+        DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled_\"" + thread_name);\n+    VerifyRecordedSamplesForHistogram(\n+        1, \""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_\"" +\n+               thread_name);\n+  }\n+\n+  void RunScrollbarThumbDragLatencyTest() {\n+    // Click on the scrollbar thumb and drag it twice to induce a compositor\n+    // thread scrollbar ScrollBegin and ScrollUpdate.\n+    blink::WebFloatPoint scrollbar_thumb(795, 30);\n+    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,\n+        0);\n+    mouse_down.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_down.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_down);\n+\n+    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,\n+        scrollbar_thumb.y + 10, 0);\n+    mouse_move.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_move.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n+    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n+    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n+    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n+\n+    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(\n+        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,\n+        scrollbar_thumb.y + 20, 0);\n+    mouse_up.button = blink::WebMouseEvent::Button::kLeft;\n+    mouse_up.SetTimeStamp(base::TimeTicks::Now());\n+    GetWidgetHost()->ForwardMouseEvent(mouse_up);\n+\n+    RunUntilInputProcessed(GetWidgetHost());\n+\n+    FetchHistogramsFromChildProcesses();\n+    const std::string scroll_types[] = {\""ScrollBegin\"", \""ScrollUpdate\""};\n+    for (const std::string& scroll_type : scroll_types) {\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.RendererSwapToBrowserNotified2\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.BrowserNotifiedToBeforeGpuSwap2\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type + \"".Scrollbar.GpuSwap2\"");\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.TimeToScrollUpdateSwapBegin4\"");\n+      std::string thread_name =\n+          DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n+      VerifyRecordedSamplesForHistogram(1, \""Event.Latency.\"" + scroll_type +\n+                                               \"".Scrollbar.TimeToHandled_\"" +\n+                                               thread_name);\n+      VerifyRecordedSamplesForHistogram(\n+          1, \""Event.Latency.\"" + scroll_type +\n+                 \"".Scrollbar.HandledToRendererSwap2_\"" + thread_name);\n+    }\n+  }\n+\n   // Returns true if the given histogram has recorded the expected number of\n   // samples.\n-  WARN_UNUSED_RESULT bool VerifyRecordedSamplesForHistogram(\n+  bool VerifyRecordedSamplesForHistogram(\n       const size_t num_samples,\n       const std::string& histogram_name) const {\n     return num_samples ==\n            histogram_tester_.GetAllSamples(histogram_name).size();\n   }\n \n+  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }\n+\n   std::unique_ptr<base::RunLoop> run_loop_;\n   bool disable_threaded_scrolling_ = false;\n \n- protected:\n+ private:\n   base::HistogramTester histogram_tester_;\n   uint32_t visual_state_callback_count_ = 0;\n \n@@ -264,166 +355,24 @@ IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest,\n       0, \""Event.Latency.ScrollBegin.Touch.TimeToScrollUpdateSwapBegin4\""));\n }\n \n-class ScrollLatencyScrollbarBrowserTest : public ScrollLatencyBrowserTest {\n- public:\n-  ScrollLatencyScrollbarBrowserTest() {}\n-\n-  void SetUpCommandLine(base::CommandLine* command_line) override {\n-    command_line->AppendSwitch(::switches::kDisableSmoothScrolling);\n-  }\n-\n-  void SetUp() override {\n-    // Enable |kScrollbarInjectScrollGestures|, as these tests depend on it\n-    // being on. Disable kOverlayScrollbar since overlay scrollbars are not\n-    // hit-testable (thus input is not routed to scrollbars).\n-    scoped_feature_list_.InitWithFeatures(\n-        {blink::features::kScrollbarInjectScrollGestures},\n-        {features::kOverlayScrollbar});\n-    ScrollLatencyBrowserTest::SetUp();\n-  }\n-  ~ScrollLatencyScrollbarBrowserTest() override {}\n-\n- protected:\n-  void RunScrollbarButtonLatencyTest() {\n-    // We don't run tests that click the scrollbar on Android for a few reasons:\n-    //  - Mobile browser uses scrollbars that are not hit-testable.\n-    //  - On Android, you cannot resize the RenderWidgetHostView (see\n-    //    |RenderWidgetHostViewAndroid::SetSize()|) and thus getting consistent\n-    //    coordinates to manipulate the scrollbar is different from other\n-    //    platforms.\n-    // We could overcome the first limitation, by toggling various features\n-    // and WebPreferences (e.g. kOverlayScrollbar feature, and\n-    // viewport_enabled and use_solid_color_scrollbars WebPreferences) but at\n-    // that point, we're not really testing a shipping configuration.\n-#if !defined(OS_ANDROID)\n-\n-    // Click on the forward scrollbar button to induce a compositor thread\n-    // scrollbar scroll.\n-    blink::WebFloatPoint scrollbar_forward_button(795, 595);\n-    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,\n-        scrollbar_forward_button.y, 0);\n-    mouse_event.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_event.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n-\n-    mouse_event.SetType(blink::WebInputEvent::kMouseUp);\n-    GetWidgetHost()->ForwardMouseEvent(mouse_event);\n-\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    FetchHistogramsFromChildProcesses();\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1, \""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4\""));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1,\n-        \""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2\""));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1,\n-        \""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2\""));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1, \""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2\""));\n-    std::string thread_name =\n-        DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1,\n-        \""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled2_\"" + thread_name));\n-    EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-        1, \""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_\"" +\n-               thread_name));\n-#endif  // !defined(OS_ANDROID)\n-  }\n-\n-  void RunScrollbarThumbDragLatencyTest() {\n-    // See above comment in RunScrollbarButtonLatencyTest for why this test\n-    // doesn't run on Android.\n-#if !defined(OS_ANDROID)\n-    // Click on the scrollbar thumb and drag it twice to induce a compositor\n-    // thread scrollbar ScrollBegin and ScrollUpdate.\n-    blink::WebFloatPoint scrollbar_thumb(795, 30);\n-    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,\n-        0);\n-    mouse_down.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_down.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_down);\n-\n-    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,\n-        scrollbar_thumb.y + 10, 0);\n-    mouse_move.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_move.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n-    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n-    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(\n-        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,\n-        scrollbar_thumb.y + 20, 0);\n-    mouse_up.button = blink::WebMouseEvent::Button::kLeft;\n-    mouse_up.SetTimeStamp(base::TimeTicks::Now());\n-    GetWidgetHost()->ForwardMouseEvent(mouse_up);\n-\n-    RunUntilInputProcessed(GetWidgetHost());\n-\n-    FetchHistogramsFromChildProcesses();\n-    const std::string scroll_types[] = {\""ScrollBegin\"", \""ScrollUpdate\""};\n-    for (const std::string& scroll_type : scroll_types) {\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.TimeToScrollUpdateSwapBegin4\""));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.RendererSwapToBrowserNotified2\""));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.BrowserNotifiedToBeforeGpuSwap2\""));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type + \"".Scrollbar.GpuSwap2\""));\n-      std::string thread_name =\n-          DoesScrollbarScrollOnMainThread() ? \""Main\"" : \""Impl\"";\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type + \"".Scrollbar.TimeToHandled2_\"" +\n-                 thread_name));\n-      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n-          1, \""Event.Latency.\"" + scroll_type +\n-                 \"".Scrollbar.HandledToRendererSwap2_\"" + thread_name));\n-    }\n-#endif  // !defined(OS_ANDROID)\n-  }\n-\n-  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }\n-\n-  base::test::ScopedFeatureList scoped_feature_list_;\n-};\n-\n-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,\n-                       ScrollbarButtonLatency) {\n+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarButtonLatency) {\n   LoadURL();\n \n   RunScrollbarButtonLatencyTest();\n }\n \n-IN_PROC_BROWSER_TEST_F(ScrollLatencyScrollbarBrowserTest,\n-                       ScrollbarThumbDragLatency) {\n+IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarThumbDragLatency) {\n   LoadURL();\n \n   RunScrollbarThumbDragLatencyTest();\n }\n \n class ScrollLatencyCompositedScrollbarBrowserTest\n-    : public ScrollLatencyScrollbarBrowserTest {\n+    : public ScrollLatencyBrowserTest {\n  public:\n-  ScrollLatencyCompositedScrollbarBrowserTest() {}\n-\n-  void SetUp() override {\n+  ScrollLatencyCompositedScrollbarBrowserTest() {\n     scoped_feature_list_.InitAndEnableFeature(\n         features::kCompositorThreadedScrollbarScrolling);\n-    ScrollLatencyScrollbarBrowserTest::SetUp();\n   }\n   ~ScrollLatencyCompositedScrollbarBrowserTest() override {}\n \n@@ -434,7 +383,7 @@ class ScrollLatencyCompositedScrollbarBrowserTest\n };\n \n IN_PROC_BROWSER_TEST_F(ScrollLatencyCompositedScrollbarBrowserTest,\n-                       DISABLED_ScrollbarButtonLatency) {\n+                       ScrollbarButtonLatency) {\n   LoadURL();\n \n   RunScrollbarButtonLatencyTest();""}<_**next**_>{""sha"": ""053fa0d159e192dd8c6bbc001bf363dda3cb977d"", ""filename"": ""ui/events/blink/input_handler_proxy.cc"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 20, ""changes"": 52, ""blob_url"": ""https://github.com/chromium/chromium/blob/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/events/blink/input_handler_proxy.cc?ref=14f2111f9cec919a450115ce4914f228effca58e"", ""patch"": ""@@ -174,7 +174,6 @@ InputHandlerProxy::InputHandlerProxy(cc::InputHandler* input_handler,\n       current_overscroll_params_(nullptr),\n       has_ongoing_compositor_scroll_or_pinch_(false),\n       is_first_gesture_scroll_update_(false),\n-      last_injected_gesture_was_begin_(false),\n       tick_clock_(base::DefaultTickClock::GetInstance()),\n       snap_fling_controller_(std::make_unique<cc::SnapFlingController>(this)),\n       compositor_touch_action_enabled_(\n@@ -312,10 +311,15 @@ void InputHandlerProxy::DispatchSingleInputEvent(\n \n   current_overscroll_params_.reset();\n \n+  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();\n+  if (type == blink::WebGestureEvent::kGestureScrollUpdate) {\n+    EnsureScrollUpdateLatencyComponent(\n+        &monitored_latency_info, event_with_callback->event().TimeStamp());\n+  }\n+\n   InputHandlerProxy::EventDisposition disposition = RouteToTypeSpecificHandler(\n       event_with_callback->event(), original_latency_info);\n \n-  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();\n   switch (type) {\n     case blink::WebGestureEvent::kGestureScrollBegin:\n       is_first_gesture_scroll_update_ = true;\n@@ -361,6 +365,32 @@ void InputHandlerProxy::DispatchSingleInputEvent(\n                                     std::move(current_overscroll_params_));\n }\n \n+// Scroll updates injected from within the renderer process will not have a\n+// scroll update component, since those are added to the latency info\n+// in the browser process before being dispatched to the renderer.\n+void InputHandlerProxy::EnsureScrollUpdateLatencyComponent(\n+    LatencyInfo* monitored_latency_info,\n+    base::TimeTicks original_timestamp) {\n+  // Currently we only expect LatencyInfo's of type SCROLLBAR to get into\n+  // this state, but there are a few exceptions (i.e. GestureScrollUpdates\n+  // that are coalesced with GesturePinchUpdates via\n+  // CompositorThreadEventQueue::Queue/CoalesceScrollAndPinch).\n+  // TODO(dlibby): Update that codepath and turn this into a DCHECK when there\n+  // is a missing scroll update component.\n+  if (monitored_latency_info->source_event_type() !=\n+      ui::SourceEventType::SCROLLBAR)\n+    return;\n+\n+  // Add a scroll update component to the latency info if one doesn't exist,\n+  // based on whether or not this is the first scroll update we've seen in a\n+  // gesture sequence.\n+  monitored_latency_info->AddLatencyNumberWithTimestamp(\n+      (is_first_gesture_scroll_update_)\n+          ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT\n+          : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,\n+      original_timestamp, 1);\n+}\n+\n void InputHandlerProxy::DispatchQueuedInputEvents() {\n   // Calling |NowTicks()| is expensive so we only want to do it once.\n   base::TimeTicks now = tick_clock_->NowTicks();\n@@ -406,24 +436,6 @@ void InputHandlerProxy::InjectScrollbarGestureScroll(\n   DCHECK(!scrollbar_latency_info.FindLatency(\n       ui::INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL_COMPONENT, nullptr));\n \n-  if (type == WebInputEvent::Type::kGestureScrollBegin) {\n-    last_injected_gesture_was_begin_ = true;\n-  } else {\n-    if (type == WebInputEvent::Type::kGestureScrollUpdate) {\n-      // For injected GSUs, add a scroll update component to the latency info\n-      // so that it is properly classified as a scroll. If the last injected\n-      // gesture was a GSB, then this GSU is the first scroll update - mark\n-      // the LatencyInfo as such.\n-      scrollbar_latency_info.AddLatencyNumberWithTimestamp(\n-          (last_injected_gesture_was_begin_)\n-              ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT\n-              : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,\n-          original_timestamp, 1);\n-    }\n-\n-    last_injected_gesture_was_begin_ = false;\n-  }\n-\n   std::unique_ptr<EventWithCallback> gesture_event_with_callback_update =\n       std::make_unique<EventWithCallback>(\n           std::move(web_scoped_gesture_event), scrollbar_latency_info,""}<_**next**_>{""sha"": ""dd9f0d6a96f7e222b2d991a58df09571c09ef7a9"", ""filename"": ""ui/events/blink/input_handler_proxy.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/14f2111f9cec919a450115ce4914f228effca58e/ui/events/blink/input_handler_proxy.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/events/blink/input_handler_proxy.h?ref=14f2111f9cec919a450115ce4914f228effca58e"", ""patch"": ""@@ -187,6 +187,12 @@ class InputHandlerProxy : public cc::InputHandlerClient,\n       bool* is_touching_scrolling_layer,\n       cc::TouchAction* white_listed_touch_action);\n \n+  // Scroll updates injected from within the renderer process will not have a\n+  // scroll update component, since those are added to the latency info\n+  // in the browser process before being dispatched to the renderer.\n+  void EnsureScrollUpdateLatencyComponent(LatencyInfo* monitored_latency_info,\n+                                          base::TimeTicks original_timestamp);\n+\n   InputHandlerProxyClient* client_;\n   cc::InputHandler* input_handler_;\n \n@@ -229,13 +235,6 @@ class InputHandlerProxy : public cc::InputHandlerClient,\n   bool has_ongoing_compositor_scroll_or_pinch_;\n   bool is_first_gesture_scroll_update_;\n \n-  // Whether the last injected scroll gesture was a GestureScrollBegin. Used to\n-  // determine which GestureScrollUpdate is the first in a gesture sequence for\n-  // latency classification. This is separate from\n-  // |is_first_gesture_scroll_update_| and is used to determine which type of\n-  // latency component should be added for injected GestureScrollUpdates.\n-  bool last_injected_gesture_was_begin_;\n-\n   const base::TickClock* tick_clock_;\n \n   std::unique_ptr<cc::SnapFlingController> snap_fling_controller_;""}","InputHandlerProxy::InputHandlerProxy(cc::InputHandler* input_handler,
                                     InputHandlerProxyClient* client,
                                     bool force_input_to_main_thread)
    : client_(client),
      input_handler_(input_handler),
      synchronous_input_handler_(nullptr),
      allow_root_animate_(true),
#if DCHECK_IS_ON()
      expect_scroll_update_end_(false),
#endif
      gesture_scroll_on_impl_thread_(false),
      scroll_sequence_ignored_(false),
      smooth_scroll_enabled_(false),
      touch_result_(kEventDispositionUndefined),
      mouse_wheel_result_(kEventDispositionUndefined),
       current_overscroll_params_(nullptr),
       has_ongoing_compositor_scroll_or_pinch_(false),
       is_first_gesture_scroll_update_(false),
       tick_clock_(base::DefaultTickClock::GetInstance()),
       snap_fling_controller_(std::make_unique<cc::SnapFlingController>(this)),
       compositor_touch_action_enabled_(
          base::FeatureList::IsEnabled(features::kCompositorTouchAction)),
      force_input_to_main_thread_(force_input_to_main_thread) {
  DCHECK(client);
  input_handler_->BindToClient(this);
  cc::ScrollElasticityHelper* scroll_elasticity_helper =
      input_handler_->CreateScrollElasticityHelper();
  if (scroll_elasticity_helper) {
    scroll_elasticity_controller_.reset(
        new InputScrollElasticityController(scroll_elasticity_helper));
  }
  compositor_event_queue_ = std::make_unique<CompositorThreadEventQueue>();
  scroll_predictor_ = std::make_unique<ScrollPredictor>(
      base::FeatureList::IsEnabled(features::kResamplingScrollEvents));

  if (base::FeatureList::IsEnabled(features::kSkipTouchEventFilter) &&
      GetFieldTrialParamValueByFeature(
          features::kSkipTouchEventFilter,
          features::kSkipTouchEventFilterFilteringProcessParamName) ==
          features::
              kSkipTouchEventFilterFilteringProcessParamValueBrowserAndRenderer) {
    skip_touch_filter_discrete_ = true;
    if (GetFieldTrialParamValueByFeature(
            features::kSkipTouchEventFilter,
            features::kSkipTouchEventFilterTypeParamName) ==
        features::kSkipTouchEventFilterTypeParamValueAll) {
      skip_touch_filter_all_ = true;
    }
  }
}
","InputHandlerProxy::InputHandlerProxy(cc::InputHandler* input_handler,
                                     InputHandlerProxyClient* client,
                                     bool force_input_to_main_thread)
    : client_(client),
      input_handler_(input_handler),
      synchronous_input_handler_(nullptr),
      allow_root_animate_(true),
#if DCHECK_IS_ON()
      expect_scroll_update_end_(false),
#endif
      gesture_scroll_on_impl_thread_(false),
      scroll_sequence_ignored_(false),
      smooth_scroll_enabled_(false),
      touch_result_(kEventDispositionUndefined),
      mouse_wheel_result_(kEventDispositionUndefined),
       current_overscroll_params_(nullptr),
       has_ongoing_compositor_scroll_or_pinch_(false),
       is_first_gesture_scroll_update_(false),
      last_injected_gesture_was_begin_(false),
       tick_clock_(base::DefaultTickClock::GetInstance()),
       snap_fling_controller_(std::make_unique<cc::SnapFlingController>(this)),
       compositor_touch_action_enabled_(
          base::FeatureList::IsEnabled(features::kCompositorTouchAction)),
      force_input_to_main_thread_(force_input_to_main_thread) {
  DCHECK(client);
  input_handler_->BindToClient(this);
  cc::ScrollElasticityHelper* scroll_elasticity_helper =
      input_handler_->CreateScrollElasticityHelper();
  if (scroll_elasticity_helper) {
    scroll_elasticity_controller_.reset(
        new InputScrollElasticityController(scroll_elasticity_helper));
  }
  compositor_event_queue_ = std::make_unique<CompositorThreadEventQueue>();
  scroll_predictor_ = std::make_unique<ScrollPredictor>(
      base::FeatureList::IsEnabled(features::kResamplingScrollEvents));

  if (base::FeatureList::IsEnabled(features::kSkipTouchEventFilter) &&
      GetFieldTrialParamValueByFeature(
          features::kSkipTouchEventFilter,
          features::kSkipTouchEventFilterFilteringProcessParamName) ==
          features::
              kSkipTouchEventFilterFilteringProcessParamValueBrowserAndRenderer) {
    skip_touch_filter_discrete_ = true;
    if (GetFieldTrialParamValueByFeature(
            features::kSkipTouchEventFilter,
            features::kSkipTouchEventFilterTypeParamName) ==
        features::kSkipTouchEventFilterTypeParamValueAll) {
      skip_touch_filter_all_ = true;
    }
  }
}
",C,,"      last_injected_gesture_was_begin_(false),
",,"@@ -174,7 +174,6 @@ InputHandlerProxy::InputHandlerProxy(cc::InputHandler* input_handler,
       current_overscroll_params_(nullptr),
       has_ongoing_compositor_scroll_or_pinch_(false),
       is_first_gesture_scroll_update_(false),
-      last_injected_gesture_was_begin_(false),
       tick_clock_(base::DefaultTickClock::GetInstance()),
       snap_fling_controller_(std::make_unique<cc::SnapFlingController>(this)),
       compositor_touch_action_enabled_(
@@ -312,10 +311,15 @@ void InputHandlerProxy::DispatchSingleInputEvent(
 
   current_overscroll_params_.reset();
 
+  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();
+  if (type == blink::WebGestureEvent::kGestureScrollUpdate) {
+    EnsureScrollUpdateLatencyComponent(
+        &monitored_latency_info, event_with_callback->event().TimeStamp());
+  }
+
   InputHandlerProxy::EventDisposition disposition = RouteToTypeSpecificHandler(
       event_with_callback->event(), original_latency_info);
 
-  blink::WebGestureEvent::Type type = event_with_callback->event().GetType();
   switch (type) {
     case blink::WebGestureEvent::kGestureScrollBegin:
       is_first_gesture_scroll_update_ = true;
@@ -361,6 +365,32 @@ void InputHandlerProxy::DispatchSingleInputEvent(
                                     std::move(current_overscroll_params_));
 }
 
+// Scroll updates injected from within the renderer process will not have a
+// scroll update component, since those are added to the latency info
+// in the browser process before being dispatched to the renderer.
+void InputHandlerProxy::EnsureScrollUpdateLatencyComponent(
+    LatencyInfo* monitored_latency_info,
+    base::TimeTicks original_timestamp) {
+  // Currently we only expect LatencyInfo's of type SCROLLBAR to get into
+  // this state, but there are a few exceptions (i.e. GestureScrollUpdates
+  // that are coalesced with GesturePinchUpdates via
+  // CompositorThreadEventQueue::Queue/CoalesceScrollAndPinch).
+  // TODO(dlibby): Update that codepath and turn this into a DCHECK when there
+  // is a missing scroll update component.
+  if (monitored_latency_info->source_event_type() !=
+      ui::SourceEventType::SCROLLBAR)
+    return;
+
+  // Add a scroll update component to the latency info if one doesn't exist,
+  // based on whether or not this is the first scroll update we've seen in a
+  // gesture sequence.
+  monitored_latency_info->AddLatencyNumberWithTimestamp(
+      (is_first_gesture_scroll_update_)
+          ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT
+          : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,
+      original_timestamp, 1);
+}
+
 void InputHandlerProxy::DispatchQueuedInputEvents() {
   // Calling |NowTicks()| is expensive so we only want to do it once.
   base::TimeTicks now = tick_clock_->NowTicks();
@@ -406,24 +436,6 @@ void InputHandlerProxy::InjectScrollbarGestureScroll(
   DCHECK(!scrollbar_latency_info.FindLatency(
       ui::INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL_COMPONENT, nullptr));
 
-  if (type == WebInputEvent::Type::kGestureScrollBegin) {
-    last_injected_gesture_was_begin_ = true;
-  } else {
-    if (type == WebInputEvent::Type::kGestureScrollUpdate) {
-      // For injected GSUs, add a scroll update component to the latency info
-      // so that it is properly classified as a scroll. If the last injected
-      // gesture was a GSB, then this GSU is the first scroll update - mark
-      // the LatencyInfo as such.
-      scrollbar_latency_info.AddLatencyNumberWithTimestamp(
-          (last_injected_gesture_was_begin_)
-              ? ui::INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL_COMPONENT
-              : ui::INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL_COMPONENT,
-          original_timestamp, 1);
-    }
-
-    last_injected_gesture_was_begin_ = false;
-  }
-
   std::unique_ptr<EventWithCallback> gesture_event_with_callback_update =
       std::make_unique<EventWithCallback>(
           std::move(web_scoped_gesture_event), scrollbar_latency_info,",Chrome,14f2111f9cec919a450115ce4914f228effca58e,a7237f2e9866ca6088cffbb38668728606120a17,1,"InputHandlerProxy::InputHandlerProxy(cc::InputHandler* input_handler,
                                     InputHandlerProxyClient* client,
                                     bool force_input_to_main_thread)
    : client_(client),
      input_handler_(input_handler),
      synchronous_input_handler_(nullptr),
      allow_root_animate_(true),
#if DCHECK_IS_ON()
      expect_scroll_update_end_(false),
#endif
      gesture_scroll_on_impl_thread_(false),
      scroll_sequence_ignored_(false),
      smooth_scroll_enabled_(false),
      touch_result_(kEventDispositionUndefined),
      mouse_wheel_result_(kEventDispositionUndefined),
       current_overscroll_params_(nullptr),
       has_ongoing_compositor_scroll_or_pinch_(false),
       is_first_gesture_scroll_update_(false),
//flaw_line_below:
      last_injected_gesture_was_begin_(false),
       tick_clock_(base::DefaultTickClock::GetInstance()),
       snap_fling_controller_(std::make_unique<cc::SnapFlingController>(this)),
       compositor_touch_action_enabled_(
          base::FeatureList::IsEnabled(features::kCompositorTouchAction)),
      force_input_to_main_thread_(force_input_to_main_thread) {
  DCHECK(client);
  input_handler_->BindToClient(this);
  cc::ScrollElasticityHelper* scroll_elasticity_helper =
      input_handler_->CreateScrollElasticityHelper();
  if (scroll_elasticity_helper) {
    scroll_elasticity_controller_.reset(
        new InputScrollElasticityController(scroll_elasticity_helper));
  }
  compositor_event_queue_ = std::make_unique<CompositorThreadEventQueue>();
  scroll_predictor_ = std::make_unique<ScrollPredictor>(
      base::FeatureList::IsEnabled(features::kResamplingScrollEvents));

  if (base::FeatureList::IsEnabled(features::kSkipTouchEventFilter) &&
      GetFieldTrialParamValueByFeature(
          features::kSkipTouchEventFilter,
          features::kSkipTouchEventFilterFilteringProcessParamName) ==
          features::
              kSkipTouchEventFilterFilteringProcessParamValueBrowserAndRenderer) {
    // Skipping filtering for touch events on renderer process is enabled.
    // Always skip filtering discrete events.
    skip_touch_filter_discrete_ = true;
    if (GetFieldTrialParamValueByFeature(
            features::kSkipTouchEventFilter,
            features::kSkipTouchEventFilterTypeParamName) ==
        features::kSkipTouchEventFilterTypeParamValueAll) {
      // The experiment config also specifies to skip touchmove events.
      skip_touch_filter_all_ = true;
    }
  }
}
"
