,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
1014,178750,,Local,Not required,,CVE-2012-3520,https://www.cvedetails.com/cve/CVE-2012-3520/,CWE-287,Medium,,Partial,,2012-10-03,1.9,"The Netlink implementation in the Linux kernel before 3.2.30 does not properly handle messages that lack SCM_CREDENTIALS data, which might allow local users to spoof Netlink communication via a crafted message, as demonstrated by a message to (1) Avahi or (2) NetworkManager.",2016-10-11,,1,https://github.com/torvalds/linux/commit/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea,e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea,"af_netlink: force credentials passing [CVE-2012-3520]

Pablo Neira Ayuso discovered that avahi and
potentially NetworkManager accept spoofed Netlink messages because of a
kernel bug.  The kernel passes all-zero SCM_CREDENTIALS ancillary data
to the receiver if the sender did not provide such data, instead of not
including any such data at all or including the correct data from the
peer (as it is the case with AF_UNIX).

This bug was introduced in commit 16e572626961
(af_unix: dont send SCM_CREDENTIALS by default)

This patch forces passing credentials for netlink, as
before the regression.

Another fix would be to not add SCM_CREDENTIALS in
netlink messages if not provided by the sender, but it
might break some programs.

With help from Florian Weimer & Petr Matousek

This issue is designated as CVE-2012-3520

Signed-off-by: Eric Dumazet <edumazet@google.com>
Cc: Petr Matousek <pmatouse@redhat.com>
Cc: Florian Weimer <fweimer@redhat.com>
Cc: Pablo Neira Ayuso <pablo@netfilter.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/netlink/af_netlink.c,"{""sha"": ""7dc0854f0b3891992696002b7f75edf7a01233ab"", ""filename"": ""include/net/scm.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea/include/net/scm.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea/include/net/scm.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/net/scm.h?ref=e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea"", ""patch"": ""@@ -70,9 +70,11 @@ static __inline__ void scm_destroy(struct scm_cookie *scm)\n }\n \n static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,\n-\t\t\t       struct scm_cookie *scm)\n+\t\t\t       struct scm_cookie *scm, bool forcecreds)\n {\n \tmemset(scm, 0, sizeof(*scm));\n+\tif (forcecreds)\n+\t\tscm_set_cred(scm, task_tgid(current), current_cred());\n \tunix_get_peersec_dgram(sock, scm);\n \tif (msg->msg_controllen <= 0)\n \t\treturn 0;""}<_**next**_>{""sha"": ""1445d73533ed13ac9aa43dd85d6f58b4a006c130"", ""filename"": ""net/netlink/af_netlink.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea/net/netlink/af_netlink.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea/net/netlink/af_netlink.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/netlink/af_netlink.c?ref=e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea"", ""patch"": ""@@ -1362,7 +1362,7 @@ static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,\n \tif (NULL == siocb->scm)\n \t\tsiocb->scm = &scm;\n \n-\terr = scm_send(sock, msg, siocb->scm);\n+\terr = scm_send(sock, msg, siocb->scm, true);\n \tif (err < 0)\n \t\treturn err;\n ""}<_**next**_>{""sha"": ""c5ee4ff613641b3f8439f1c9cb6b22d55a1ff7f2"", ""filename"": ""net/unix/af_unix.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea/net/unix/af_unix.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea/net/unix/af_unix.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/unix/af_unix.c?ref=e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea"", ""patch"": ""@@ -1450,7 +1450,7 @@ static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,\n \tif (NULL == siocb->scm)\n \t\tsiocb->scm = &tmp_scm;\n \twait_for_unix_gc();\n-\terr = scm_send(sock, msg, siocb->scm);\n+\terr = scm_send(sock, msg, siocb->scm, false);\n \tif (err < 0)\n \t\treturn err;\n \n@@ -1619,7 +1619,7 @@ static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,\n \tif (NULL == siocb->scm)\n \t\tsiocb->scm = &tmp_scm;\n \twait_for_unix_gc();\n-\terr = scm_send(sock, msg, siocb->scm);\n+\terr = scm_send(sock, msg, siocb->scm, false);\n \tif (err < 0)\n \t\treturn err;\n ""}","static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
			   struct msghdr *msg, size_t len)
{
	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
	struct sock *sk = sock->sk;
	struct netlink_sock *nlk = nlk_sk(sk);
	struct sockaddr_nl *addr = msg->msg_name;
	u32 dst_pid;
	u32 dst_group;
	struct sk_buff *skb;
	int err;
	struct scm_cookie scm;

	if (msg->msg_flags&MSG_OOB)
		return -EOPNOTSUPP;

 	if (NULL == siocb->scm)
 		siocb->scm = &scm;
 
	err = scm_send(sock, msg, siocb->scm, true);
 	if (err < 0)
 		return err;
 
	if (msg->msg_namelen) {
		err = -EINVAL;
		if (addr->nl_family != AF_NETLINK)
			goto out;
		dst_pid = addr->nl_pid;
		dst_group = ffs(addr->nl_groups);
		err =  -EPERM;
		if (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))
			goto out;
	} else {
		dst_pid = nlk->dst_pid;
		dst_group = nlk->dst_group;
	}

	if (!nlk->pid) {
		err = netlink_autobind(sock);
		if (err)
			goto out;
	}

	err = -EMSGSIZE;
	if (len > sk->sk_sndbuf - 32)
		goto out;
	err = -ENOBUFS;
	skb = alloc_skb(len, GFP_KERNEL);
	if (skb == NULL)
		goto out;

	NETLINK_CB(skb).pid	= nlk->pid;
	NETLINK_CB(skb).dst_group = dst_group;
	memcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));

	err = -EFAULT;
	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
		kfree_skb(skb);
		goto out;
	}

	err = security_netlink_send(sk, skb);
	if (err) {
		kfree_skb(skb);
		goto out;
	}

	if (dst_group) {
		atomic_inc(&skb->users);
		netlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);
	}
	err = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);

out:
	scm_destroy(siocb->scm);
	return err;
}
","static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
			   struct msghdr *msg, size_t len)
{
	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
	struct sock *sk = sock->sk;
	struct netlink_sock *nlk = nlk_sk(sk);
	struct sockaddr_nl *addr = msg->msg_name;
	u32 dst_pid;
	u32 dst_group;
	struct sk_buff *skb;
	int err;
	struct scm_cookie scm;

	if (msg->msg_flags&MSG_OOB)
		return -EOPNOTSUPP;

 	if (NULL == siocb->scm)
 		siocb->scm = &scm;
 
	err = scm_send(sock, msg, siocb->scm);
 	if (err < 0)
 		return err;
 
	if (msg->msg_namelen) {
		err = -EINVAL;
		if (addr->nl_family != AF_NETLINK)
			goto out;
		dst_pid = addr->nl_pid;
		dst_group = ffs(addr->nl_groups);
		err =  -EPERM;
		if (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))
			goto out;
	} else {
		dst_pid = nlk->dst_pid;
		dst_group = nlk->dst_group;
	}

	if (!nlk->pid) {
		err = netlink_autobind(sock);
		if (err)
			goto out;
	}

	err = -EMSGSIZE;
	if (len > sk->sk_sndbuf - 32)
		goto out;
	err = -ENOBUFS;
	skb = alloc_skb(len, GFP_KERNEL);
	if (skb == NULL)
		goto out;

	NETLINK_CB(skb).pid	= nlk->pid;
	NETLINK_CB(skb).dst_group = dst_group;
	memcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));

	err = -EFAULT;
	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
		kfree_skb(skb);
		goto out;
	}

	err = security_netlink_send(sk, skb);
	if (err) {
		kfree_skb(skb);
		goto out;
	}

	if (dst_group) {
		atomic_inc(&skb->users);
		netlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);
	}
	err = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);

out:
	scm_destroy(siocb->scm);
	return err;
}
",C,"	err = scm_send(sock, msg, siocb->scm, true);
","	err = scm_send(sock, msg, siocb->scm);
",,"@@ -1362,7 +1362,7 @@ static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
 	if (NULL == siocb->scm)
 		siocb->scm = &scm;
 
-	err = scm_send(sock, msg, siocb->scm);
+	err = scm_send(sock, msg, siocb->scm, true);
 	if (err < 0)
 		return err;
 ",linux,e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea,a9915a1b52df52ad87f3b33422da95cf25372f09,1,"static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
			   struct msghdr *msg, size_t len)
{
	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
	struct sock *sk = sock->sk;
	struct netlink_sock *nlk = nlk_sk(sk);
	struct sockaddr_nl *addr = msg->msg_name;
	u32 dst_pid;
	u32 dst_group;
	struct sk_buff *skb;
	int err;
	struct scm_cookie scm;

	if (msg->msg_flags&MSG_OOB)
		return -EOPNOTSUPP;

 	if (NULL == siocb->scm)
 		siocb->scm = &scm;
 
//flaw_line_below:
	err = scm_send(sock, msg, siocb->scm);
//fix_flaw_line_below:
//	err = scm_send(sock, msg, siocb->scm, true);
 	if (err < 0)
 		return err;
 
	if (msg->msg_namelen) {
		err = -EINVAL;
		if (addr->nl_family != AF_NETLINK)
			goto out;
		dst_pid = addr->nl_pid;
		dst_group = ffs(addr->nl_groups);
		err =  -EPERM;
		if (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))
			goto out;
	} else {
		dst_pid = nlk->dst_pid;
		dst_group = nlk->dst_group;
	}

	if (!nlk->pid) {
		err = netlink_autobind(sock);
		if (err)
			goto out;
	}

	err = -EMSGSIZE;
	if (len > sk->sk_sndbuf - 32)
		goto out;
	err = -ENOBUFS;
	skb = alloc_skb(len, GFP_KERNEL);
	if (skb == NULL)
		goto out;

	NETLINK_CB(skb).pid	= nlk->pid;
	NETLINK_CB(skb).dst_group = dst_group;
	memcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));

	err = -EFAULT;
	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
		kfree_skb(skb);
		goto out;
	}

	err = security_netlink_send(sk, skb);
	if (err) {
		kfree_skb(skb);
		goto out;
	}

	if (dst_group) {
		atomic_inc(&skb->users);
		netlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);
	}
	err = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);

out:
	scm_destroy(siocb->scm);
	return err;
}
"
1015,178751,,Local,Not required,,CVE-2012-3520,https://www.cvedetails.com/cve/CVE-2012-3520/,CWE-287,Medium,,Partial,,2012-10-03,1.9,"The Netlink implementation in the Linux kernel before 3.2.30 does not properly handle messages that lack SCM_CREDENTIALS data, which might allow local users to spoof Netlink communication via a crafted message, as demonstrated by a message to (1) Avahi or (2) NetworkManager.",2016-10-11,,1,https://github.com/torvalds/linux/commit/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea,e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea,"af_netlink: force credentials passing [CVE-2012-3520]

Pablo Neira Ayuso discovered that avahi and
potentially NetworkManager accept spoofed Netlink messages because of a
kernel bug.  The kernel passes all-zero SCM_CREDENTIALS ancillary data
to the receiver if the sender did not provide such data, instead of not
including any such data at all or including the correct data from the
peer (as it is the case with AF_UNIX).

This bug was introduced in commit 16e572626961
(af_unix: dont send SCM_CREDENTIALS by default)

This patch forces passing credentials for netlink, as
before the regression.

Another fix would be to not add SCM_CREDENTIALS in
netlink messages if not provided by the sender, but it
might break some programs.

With help from Florian Weimer & Petr Matousek

This issue is designated as CVE-2012-3520

Signed-off-by: Eric Dumazet <edumazet@google.com>
Cc: Petr Matousek <pmatouse@redhat.com>
Cc: Florian Weimer <fweimer@redhat.com>
Cc: Pablo Neira Ayuso <pablo@netfilter.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/unix/af_unix.c,"{""sha"": ""7dc0854f0b3891992696002b7f75edf7a01233ab"", ""filename"": ""include/net/scm.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea/include/net/scm.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea/include/net/scm.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/net/scm.h?ref=e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea"", ""patch"": ""@@ -70,9 +70,11 @@ static __inline__ void scm_destroy(struct scm_cookie *scm)\n }\n \n static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,\n-\t\t\t       struct scm_cookie *scm)\n+\t\t\t       struct scm_cookie *scm, bool forcecreds)\n {\n \tmemset(scm, 0, sizeof(*scm));\n+\tif (forcecreds)\n+\t\tscm_set_cred(scm, task_tgid(current), current_cred());\n \tunix_get_peersec_dgram(sock, scm);\n \tif (msg->msg_controllen <= 0)\n \t\treturn 0;""}<_**next**_>{""sha"": ""1445d73533ed13ac9aa43dd85d6f58b4a006c130"", ""filename"": ""net/netlink/af_netlink.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea/net/netlink/af_netlink.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea/net/netlink/af_netlink.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/netlink/af_netlink.c?ref=e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea"", ""patch"": ""@@ -1362,7 +1362,7 @@ static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,\n \tif (NULL == siocb->scm)\n \t\tsiocb->scm = &scm;\n \n-\terr = scm_send(sock, msg, siocb->scm);\n+\terr = scm_send(sock, msg, siocb->scm, true);\n \tif (err < 0)\n \t\treturn err;\n ""}<_**next**_>{""sha"": ""c5ee4ff613641b3f8439f1c9cb6b22d55a1ff7f2"", ""filename"": ""net/unix/af_unix.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea/net/unix/af_unix.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea/net/unix/af_unix.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/unix/af_unix.c?ref=e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea"", ""patch"": ""@@ -1450,7 +1450,7 @@ static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,\n \tif (NULL == siocb->scm)\n \t\tsiocb->scm = &tmp_scm;\n \twait_for_unix_gc();\n-\terr = scm_send(sock, msg, siocb->scm);\n+\terr = scm_send(sock, msg, siocb->scm, false);\n \tif (err < 0)\n \t\treturn err;\n \n@@ -1619,7 +1619,7 @@ static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,\n \tif (NULL == siocb->scm)\n \t\tsiocb->scm = &tmp_scm;\n \twait_for_unix_gc();\n-\terr = scm_send(sock, msg, siocb->scm);\n+\terr = scm_send(sock, msg, siocb->scm, false);\n \tif (err < 0)\n \t\treturn err;\n ""}","static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,
			      struct msghdr *msg, size_t len)
{
	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
	struct sock *sk = sock->sk;
	struct net *net = sock_net(sk);
	struct unix_sock *u = unix_sk(sk);
	struct sockaddr_un *sunaddr = msg->msg_name;
	struct sock *other = NULL;
	int namelen = 0; /* fake GCC */
	int err;
	unsigned int hash;
	struct sk_buff *skb;
	long timeo;
	struct scm_cookie tmp_scm;
	int max_level;
	int data_len = 0;

 	if (NULL == siocb->scm)
 		siocb->scm = &tmp_scm;
 	wait_for_unix_gc();
	err = scm_send(sock, msg, siocb->scm, false);
 	if (err < 0)
 		return err;
 
	err = -EOPNOTSUPP;
	if (msg->msg_flags&MSG_OOB)
		goto out;

	if (msg->msg_namelen) {
		err = unix_mkname(sunaddr, msg->msg_namelen, &hash);
		if (err < 0)
			goto out;
		namelen = err;
	} else {
		sunaddr = NULL;
		err = -ENOTCONN;
		other = unix_peer_get(sk);
		if (!other)
			goto out;
	}

	if (test_bit(SOCK_PASSCRED, &sock->flags) && !u->addr
	    && (err = unix_autobind(sock)) != 0)
		goto out;

	err = -EMSGSIZE;
	if (len > sk->sk_sndbuf - 32)
		goto out;

	if (len > SKB_MAX_ALLOC)
		data_len = min_t(size_t,
				 len - SKB_MAX_ALLOC,
				 MAX_SKB_FRAGS * PAGE_SIZE);

	skb = sock_alloc_send_pskb(sk, len - data_len, data_len,
				   msg->msg_flags & MSG_DONTWAIT, &err);
	if (skb == NULL)
		goto out;

	err = unix_scm_to_skb(siocb->scm, skb, true);
	if (err < 0)
		goto out_free;
	max_level = err + 1;
	unix_get_secdata(siocb->scm, skb);

	skb_put(skb, len - data_len);
	skb->data_len = data_len;
	skb->len = len;
	err = skb_copy_datagram_from_iovec(skb, 0, msg->msg_iov, 0, len);
	if (err)
		goto out_free;

	timeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);

restart:
	if (!other) {
		err = -ECONNRESET;
		if (sunaddr == NULL)
			goto out_free;

		other = unix_find_other(net, sunaddr, namelen, sk->sk_type,
					hash, &err);
		if (other == NULL)
			goto out_free;
	}

	if (sk_filter(other, skb) < 0) {
		/* Toss the packet but do not return any error to the sender */
		err = len;
		goto out_free;
	}

	unix_state_lock(other);
	err = -EPERM;
	if (!unix_may_send(sk, other))
		goto out_unlock;

	if (sock_flag(other, SOCK_DEAD)) {
		/*
		 *	Check with 1003.1g - what should
		 *	datagram error
		 */
		unix_state_unlock(other);
		sock_put(other);

		err = 0;
		unix_state_lock(sk);
		if (unix_peer(sk) == other) {
			unix_peer(sk) = NULL;
			unix_state_unlock(sk);

			unix_dgram_disconnected(sk, other);
			sock_put(other);
			err = -ECONNREFUSED;
		} else {
			unix_state_unlock(sk);
		}

		other = NULL;
		if (err)
			goto out_free;
		goto restart;
	}

	err = -EPIPE;
	if (other->sk_shutdown & RCV_SHUTDOWN)
		goto out_unlock;

	if (sk->sk_type != SOCK_SEQPACKET) {
		err = security_unix_may_send(sk->sk_socket, other->sk_socket);
		if (err)
			goto out_unlock;
	}

	if (unix_peer(other) != sk && unix_recvq_full(other)) {
		if (!timeo) {
			err = -EAGAIN;
			goto out_unlock;
		}

		timeo = unix_wait_for_peer(other, timeo);

		err = sock_intr_errno(timeo);
		if (signal_pending(current))
			goto out_free;

		goto restart;
	}

	if (sock_flag(other, SOCK_RCVTSTAMP))
		__net_timestamp(skb);
	maybe_add_creds(skb, sock, other);
	skb_queue_tail(&other->sk_receive_queue, skb);
	if (max_level > unix_sk(other)->recursion_level)
		unix_sk(other)->recursion_level = max_level;
	unix_state_unlock(other);
	other->sk_data_ready(other, len);
	sock_put(other);
	scm_destroy(siocb->scm);
	return len;

out_unlock:
	unix_state_unlock(other);
out_free:
	kfree_skb(skb);
out:
	if (other)
		sock_put(other);
	scm_destroy(siocb->scm);
	return err;
}
","static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,
			      struct msghdr *msg, size_t len)
{
	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
	struct sock *sk = sock->sk;
	struct net *net = sock_net(sk);
	struct unix_sock *u = unix_sk(sk);
	struct sockaddr_un *sunaddr = msg->msg_name;
	struct sock *other = NULL;
	int namelen = 0; /* fake GCC */
	int err;
	unsigned int hash;
	struct sk_buff *skb;
	long timeo;
	struct scm_cookie tmp_scm;
	int max_level;
	int data_len = 0;

 	if (NULL == siocb->scm)
 		siocb->scm = &tmp_scm;
 	wait_for_unix_gc();
	err = scm_send(sock, msg, siocb->scm);
 	if (err < 0)
 		return err;
 
	err = -EOPNOTSUPP;
	if (msg->msg_flags&MSG_OOB)
		goto out;

	if (msg->msg_namelen) {
		err = unix_mkname(sunaddr, msg->msg_namelen, &hash);
		if (err < 0)
			goto out;
		namelen = err;
	} else {
		sunaddr = NULL;
		err = -ENOTCONN;
		other = unix_peer_get(sk);
		if (!other)
			goto out;
	}

	if (test_bit(SOCK_PASSCRED, &sock->flags) && !u->addr
	    && (err = unix_autobind(sock)) != 0)
		goto out;

	err = -EMSGSIZE;
	if (len > sk->sk_sndbuf - 32)
		goto out;

	if (len > SKB_MAX_ALLOC)
		data_len = min_t(size_t,
				 len - SKB_MAX_ALLOC,
				 MAX_SKB_FRAGS * PAGE_SIZE);

	skb = sock_alloc_send_pskb(sk, len - data_len, data_len,
				   msg->msg_flags & MSG_DONTWAIT, &err);
	if (skb == NULL)
		goto out;

	err = unix_scm_to_skb(siocb->scm, skb, true);
	if (err < 0)
		goto out_free;
	max_level = err + 1;
	unix_get_secdata(siocb->scm, skb);

	skb_put(skb, len - data_len);
	skb->data_len = data_len;
	skb->len = len;
	err = skb_copy_datagram_from_iovec(skb, 0, msg->msg_iov, 0, len);
	if (err)
		goto out_free;

	timeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);

restart:
	if (!other) {
		err = -ECONNRESET;
		if (sunaddr == NULL)
			goto out_free;

		other = unix_find_other(net, sunaddr, namelen, sk->sk_type,
					hash, &err);
		if (other == NULL)
			goto out_free;
	}

	if (sk_filter(other, skb) < 0) {
		/* Toss the packet but do not return any error to the sender */
		err = len;
		goto out_free;
	}

	unix_state_lock(other);
	err = -EPERM;
	if (!unix_may_send(sk, other))
		goto out_unlock;

	if (sock_flag(other, SOCK_DEAD)) {
		/*
		 *	Check with 1003.1g - what should
		 *	datagram error
		 */
		unix_state_unlock(other);
		sock_put(other);

		err = 0;
		unix_state_lock(sk);
		if (unix_peer(sk) == other) {
			unix_peer(sk) = NULL;
			unix_state_unlock(sk);

			unix_dgram_disconnected(sk, other);
			sock_put(other);
			err = -ECONNREFUSED;
		} else {
			unix_state_unlock(sk);
		}

		other = NULL;
		if (err)
			goto out_free;
		goto restart;
	}

	err = -EPIPE;
	if (other->sk_shutdown & RCV_SHUTDOWN)
		goto out_unlock;

	if (sk->sk_type != SOCK_SEQPACKET) {
		err = security_unix_may_send(sk->sk_socket, other->sk_socket);
		if (err)
			goto out_unlock;
	}

	if (unix_peer(other) != sk && unix_recvq_full(other)) {
		if (!timeo) {
			err = -EAGAIN;
			goto out_unlock;
		}

		timeo = unix_wait_for_peer(other, timeo);

		err = sock_intr_errno(timeo);
		if (signal_pending(current))
			goto out_free;

		goto restart;
	}

	if (sock_flag(other, SOCK_RCVTSTAMP))
		__net_timestamp(skb);
	maybe_add_creds(skb, sock, other);
	skb_queue_tail(&other->sk_receive_queue, skb);
	if (max_level > unix_sk(other)->recursion_level)
		unix_sk(other)->recursion_level = max_level;
	unix_state_unlock(other);
	other->sk_data_ready(other, len);
	sock_put(other);
	scm_destroy(siocb->scm);
	return len;

out_unlock:
	unix_state_unlock(other);
out_free:
	kfree_skb(skb);
out:
	if (other)
		sock_put(other);
	scm_destroy(siocb->scm);
	return err;
}
",C,"	err = scm_send(sock, msg, siocb->scm, false);
","	err = scm_send(sock, msg, siocb->scm);
",,"@@ -1450,7 +1450,7 @@ static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,
 	if (NULL == siocb->scm)
 		siocb->scm = &tmp_scm;
 	wait_for_unix_gc();
-	err = scm_send(sock, msg, siocb->scm);
+	err = scm_send(sock, msg, siocb->scm, false);
 	if (err < 0)
 		return err;
 
@@ -1619,7 +1619,7 @@ static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,
 	if (NULL == siocb->scm)
 		siocb->scm = &tmp_scm;
 	wait_for_unix_gc();
-	err = scm_send(sock, msg, siocb->scm);
+	err = scm_send(sock, msg, siocb->scm, false);
 	if (err < 0)
 		return err;
 ",linux,e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea,a9915a1b52df52ad87f3b33422da95cf25372f09,1,"static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,
			      struct msghdr *msg, size_t len)
{
	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
	struct sock *sk = sock->sk;
	struct net *net = sock_net(sk);
	struct unix_sock *u = unix_sk(sk);
	struct sockaddr_un *sunaddr = msg->msg_name;
	struct sock *other = NULL;
	int namelen = 0; /* fake GCC */
	int err;
	unsigned int hash;
	struct sk_buff *skb;
	long timeo;
	struct scm_cookie tmp_scm;
	int max_level;
	int data_len = 0;

 	if (NULL == siocb->scm)
 		siocb->scm = &tmp_scm;
 	wait_for_unix_gc();
//flaw_line_below:
	err = scm_send(sock, msg, siocb->scm);
//fix_flaw_line_below:
//	err = scm_send(sock, msg, siocb->scm, false);
 	if (err < 0)
 		return err;
 
	err = -EOPNOTSUPP;
	if (msg->msg_flags&MSG_OOB)
		goto out;

	if (msg->msg_namelen) {
		err = unix_mkname(sunaddr, msg->msg_namelen, &hash);
		if (err < 0)
			goto out;
		namelen = err;
	} else {
		sunaddr = NULL;
		err = -ENOTCONN;
		other = unix_peer_get(sk);
		if (!other)
			goto out;
	}

	if (test_bit(SOCK_PASSCRED, &sock->flags) && !u->addr
	    && (err = unix_autobind(sock)) != 0)
		goto out;

	err = -EMSGSIZE;
	if (len > sk->sk_sndbuf - 32)
		goto out;

	if (len > SKB_MAX_ALLOC)
		data_len = min_t(size_t,
				 len - SKB_MAX_ALLOC,
				 MAX_SKB_FRAGS * PAGE_SIZE);

	skb = sock_alloc_send_pskb(sk, len - data_len, data_len,
				   msg->msg_flags & MSG_DONTWAIT, &err);
	if (skb == NULL)
		goto out;

	err = unix_scm_to_skb(siocb->scm, skb, true);
	if (err < 0)
		goto out_free;
	max_level = err + 1;
	unix_get_secdata(siocb->scm, skb);

	skb_put(skb, len - data_len);
	skb->data_len = data_len;
	skb->len = len;
	err = skb_copy_datagram_from_iovec(skb, 0, msg->msg_iov, 0, len);
	if (err)
		goto out_free;

	timeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);

restart:
	if (!other) {
		err = -ECONNRESET;
		if (sunaddr == NULL)
			goto out_free;

		other = unix_find_other(net, sunaddr, namelen, sk->sk_type,
					hash, &err);
		if (other == NULL)
			goto out_free;
	}

	if (sk_filter(other, skb) < 0) {
		/* Toss the packet but do not return any error to the sender */
		err = len;
		goto out_free;
	}

	unix_state_lock(other);
	err = -EPERM;
	if (!unix_may_send(sk, other))
		goto out_unlock;

	if (sock_flag(other, SOCK_DEAD)) {
		/*
		 *	Check with 1003.1g - what should
		 *	datagram error
		 */
		unix_state_unlock(other);
		sock_put(other);

		err = 0;
		unix_state_lock(sk);
		if (unix_peer(sk) == other) {
			unix_peer(sk) = NULL;
			unix_state_unlock(sk);

			unix_dgram_disconnected(sk, other);
			sock_put(other);
			err = -ECONNREFUSED;
		} else {
			unix_state_unlock(sk);
		}

		other = NULL;
		if (err)
			goto out_free;
		goto restart;
	}

	err = -EPIPE;
	if (other->sk_shutdown & RCV_SHUTDOWN)
		goto out_unlock;

	if (sk->sk_type != SOCK_SEQPACKET) {
		err = security_unix_may_send(sk->sk_socket, other->sk_socket);
		if (err)
			goto out_unlock;
	}

	if (unix_peer(other) != sk && unix_recvq_full(other)) {
		if (!timeo) {
			err = -EAGAIN;
			goto out_unlock;
		}

		timeo = unix_wait_for_peer(other, timeo);

		err = sock_intr_errno(timeo);
		if (signal_pending(current))
			goto out_free;

		goto restart;
	}

	if (sock_flag(other, SOCK_RCVTSTAMP))
		__net_timestamp(skb);
	maybe_add_creds(skb, sock, other);
	skb_queue_tail(&other->sk_receive_queue, skb);
	if (max_level > unix_sk(other)->recursion_level)
		unix_sk(other)->recursion_level = max_level;
	unix_state_unlock(other);
	other->sk_data_ready(other, len);
	sock_put(other);
	scm_destroy(siocb->scm);
	return len;

out_unlock:
	unix_state_unlock(other);
out_free:
	kfree_skb(skb);
out:
	if (other)
		sock_put(other);
	scm_destroy(siocb->scm);
	return err;
}
"
1016,178752,,Local,Not required,,CVE-2012-3520,https://www.cvedetails.com/cve/CVE-2012-3520/,CWE-287,Medium,,Partial,,2012-10-03,1.9,"The Netlink implementation in the Linux kernel before 3.2.30 does not properly handle messages that lack SCM_CREDENTIALS data, which might allow local users to spoof Netlink communication via a crafted message, as demonstrated by a message to (1) Avahi or (2) NetworkManager.",2016-10-11,,1,https://github.com/torvalds/linux/commit/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea,e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea,"af_netlink: force credentials passing [CVE-2012-3520]

Pablo Neira Ayuso discovered that avahi and
potentially NetworkManager accept spoofed Netlink messages because of a
kernel bug.  The kernel passes all-zero SCM_CREDENTIALS ancillary data
to the receiver if the sender did not provide such data, instead of not
including any such data at all or including the correct data from the
peer (as it is the case with AF_UNIX).

This bug was introduced in commit 16e572626961
(af_unix: dont send SCM_CREDENTIALS by default)

This patch forces passing credentials for netlink, as
before the regression.

Another fix would be to not add SCM_CREDENTIALS in
netlink messages if not provided by the sender, but it
might break some programs.

With help from Florian Weimer & Petr Matousek

This issue is designated as CVE-2012-3520

Signed-off-by: Eric Dumazet <edumazet@google.com>
Cc: Petr Matousek <pmatouse@redhat.com>
Cc: Florian Weimer <fweimer@redhat.com>
Cc: Pablo Neira Ayuso <pablo@netfilter.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/unix/af_unix.c,"{""sha"": ""7dc0854f0b3891992696002b7f75edf7a01233ab"", ""filename"": ""include/net/scm.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea/include/net/scm.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea/include/net/scm.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/net/scm.h?ref=e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea"", ""patch"": ""@@ -70,9 +70,11 @@ static __inline__ void scm_destroy(struct scm_cookie *scm)\n }\n \n static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,\n-\t\t\t       struct scm_cookie *scm)\n+\t\t\t       struct scm_cookie *scm, bool forcecreds)\n {\n \tmemset(scm, 0, sizeof(*scm));\n+\tif (forcecreds)\n+\t\tscm_set_cred(scm, task_tgid(current), current_cred());\n \tunix_get_peersec_dgram(sock, scm);\n \tif (msg->msg_controllen <= 0)\n \t\treturn 0;""}<_**next**_>{""sha"": ""1445d73533ed13ac9aa43dd85d6f58b4a006c130"", ""filename"": ""net/netlink/af_netlink.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea/net/netlink/af_netlink.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea/net/netlink/af_netlink.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/netlink/af_netlink.c?ref=e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea"", ""patch"": ""@@ -1362,7 +1362,7 @@ static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,\n \tif (NULL == siocb->scm)\n \t\tsiocb->scm = &scm;\n \n-\terr = scm_send(sock, msg, siocb->scm);\n+\terr = scm_send(sock, msg, siocb->scm, true);\n \tif (err < 0)\n \t\treturn err;\n ""}<_**next**_>{""sha"": ""c5ee4ff613641b3f8439f1c9cb6b22d55a1ff7f2"", ""filename"": ""net/unix/af_unix.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea/net/unix/af_unix.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea/net/unix/af_unix.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/unix/af_unix.c?ref=e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea"", ""patch"": ""@@ -1450,7 +1450,7 @@ static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,\n \tif (NULL == siocb->scm)\n \t\tsiocb->scm = &tmp_scm;\n \twait_for_unix_gc();\n-\terr = scm_send(sock, msg, siocb->scm);\n+\terr = scm_send(sock, msg, siocb->scm, false);\n \tif (err < 0)\n \t\treturn err;\n \n@@ -1619,7 +1619,7 @@ static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,\n \tif (NULL == siocb->scm)\n \t\tsiocb->scm = &tmp_scm;\n \twait_for_unix_gc();\n-\terr = scm_send(sock, msg, siocb->scm);\n+\terr = scm_send(sock, msg, siocb->scm, false);\n \tif (err < 0)\n \t\treturn err;\n ""}","static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,
			       struct msghdr *msg, size_t len)
{
	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
	struct sock *sk = sock->sk;
	struct sock *other = NULL;
	int err, size;
	struct sk_buff *skb;
	int sent = 0;
	struct scm_cookie tmp_scm;
	bool fds_sent = false;
	int max_level;

 	if (NULL == siocb->scm)
 		siocb->scm = &tmp_scm;
 	wait_for_unix_gc();
	err = scm_send(sock, msg, siocb->scm, false);
 	if (err < 0)
 		return err;
 
	err = -EOPNOTSUPP;
	if (msg->msg_flags&MSG_OOB)
		goto out_err;

	if (msg->msg_namelen) {
		err = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;
		goto out_err;
	} else {
		err = -ENOTCONN;
		other = unix_peer(sk);
		if (!other)
			goto out_err;
	}

	if (sk->sk_shutdown & SEND_SHUTDOWN)
		goto pipe_err;

	while (sent < len) {
		/*
		 *	Optimisation for the fact that under 0.01% of X
		 *	messages typically need breaking up.
		 */

		size = len-sent;

		/* Keep two messages in the pipe so it schedules better */
		if (size > ((sk->sk_sndbuf >> 1) - 64))
			size = (sk->sk_sndbuf >> 1) - 64;

		if (size > SKB_MAX_ALLOC)
			size = SKB_MAX_ALLOC;

		/*
		 *	Grab a buffer
		 */

		skb = sock_alloc_send_skb(sk, size, msg->msg_flags&MSG_DONTWAIT,
					  &err);

		if (skb == NULL)
			goto out_err;

		/*
		 *	If you pass two values to the sock_alloc_send_skb
		 *	it tries to grab the large buffer with GFP_NOFS
		 *	(which can fail easily), and if it fails grab the
		 *	fallback size buffer which is under a page and will
		 *	succeed. [Alan]
		 */
		size = min_t(int, size, skb_tailroom(skb));


		/* Only send the fds in the first buffer */
		err = unix_scm_to_skb(siocb->scm, skb, !fds_sent);
		if (err < 0) {
			kfree_skb(skb);
			goto out_err;
		}
		max_level = err + 1;
		fds_sent = true;

		err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);
		if (err) {
			kfree_skb(skb);
			goto out_err;
		}

		unix_state_lock(other);

		if (sock_flag(other, SOCK_DEAD) ||
		    (other->sk_shutdown & RCV_SHUTDOWN))
			goto pipe_err_free;

		maybe_add_creds(skb, sock, other);
		skb_queue_tail(&other->sk_receive_queue, skb);
		if (max_level > unix_sk(other)->recursion_level)
			unix_sk(other)->recursion_level = max_level;
		unix_state_unlock(other);
		other->sk_data_ready(other, size);
		sent += size;
	}

	scm_destroy(siocb->scm);
	siocb->scm = NULL;

	return sent;

pipe_err_free:
	unix_state_unlock(other);
	kfree_skb(skb);
pipe_err:
	if (sent == 0 && !(msg->msg_flags&MSG_NOSIGNAL))
		send_sig(SIGPIPE, current, 0);
	err = -EPIPE;
out_err:
	scm_destroy(siocb->scm);
	siocb->scm = NULL;
	return sent ? : err;
}
","static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,
			       struct msghdr *msg, size_t len)
{
	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
	struct sock *sk = sock->sk;
	struct sock *other = NULL;
	int err, size;
	struct sk_buff *skb;
	int sent = 0;
	struct scm_cookie tmp_scm;
	bool fds_sent = false;
	int max_level;

 	if (NULL == siocb->scm)
 		siocb->scm = &tmp_scm;
 	wait_for_unix_gc();
	err = scm_send(sock, msg, siocb->scm);
 	if (err < 0)
 		return err;
 
	err = -EOPNOTSUPP;
	if (msg->msg_flags&MSG_OOB)
		goto out_err;

	if (msg->msg_namelen) {
		err = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;
		goto out_err;
	} else {
		err = -ENOTCONN;
		other = unix_peer(sk);
		if (!other)
			goto out_err;
	}

	if (sk->sk_shutdown & SEND_SHUTDOWN)
		goto pipe_err;

	while (sent < len) {
		/*
		 *	Optimisation for the fact that under 0.01% of X
		 *	messages typically need breaking up.
		 */

		size = len-sent;

		/* Keep two messages in the pipe so it schedules better */
		if (size > ((sk->sk_sndbuf >> 1) - 64))
			size = (sk->sk_sndbuf >> 1) - 64;

		if (size > SKB_MAX_ALLOC)
			size = SKB_MAX_ALLOC;

		/*
		 *	Grab a buffer
		 */

		skb = sock_alloc_send_skb(sk, size, msg->msg_flags&MSG_DONTWAIT,
					  &err);

		if (skb == NULL)
			goto out_err;

		/*
		 *	If you pass two values to the sock_alloc_send_skb
		 *	it tries to grab the large buffer with GFP_NOFS
		 *	(which can fail easily), and if it fails grab the
		 *	fallback size buffer which is under a page and will
		 *	succeed. [Alan]
		 */
		size = min_t(int, size, skb_tailroom(skb));


		/* Only send the fds in the first buffer */
		err = unix_scm_to_skb(siocb->scm, skb, !fds_sent);
		if (err < 0) {
			kfree_skb(skb);
			goto out_err;
		}
		max_level = err + 1;
		fds_sent = true;

		err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);
		if (err) {
			kfree_skb(skb);
			goto out_err;
		}

		unix_state_lock(other);

		if (sock_flag(other, SOCK_DEAD) ||
		    (other->sk_shutdown & RCV_SHUTDOWN))
			goto pipe_err_free;

		maybe_add_creds(skb, sock, other);
		skb_queue_tail(&other->sk_receive_queue, skb);
		if (max_level > unix_sk(other)->recursion_level)
			unix_sk(other)->recursion_level = max_level;
		unix_state_unlock(other);
		other->sk_data_ready(other, size);
		sent += size;
	}

	scm_destroy(siocb->scm);
	siocb->scm = NULL;

	return sent;

pipe_err_free:
	unix_state_unlock(other);
	kfree_skb(skb);
pipe_err:
	if (sent == 0 && !(msg->msg_flags&MSG_NOSIGNAL))
		send_sig(SIGPIPE, current, 0);
	err = -EPIPE;
out_err:
	scm_destroy(siocb->scm);
	siocb->scm = NULL;
	return sent ? : err;
}
",C,"	err = scm_send(sock, msg, siocb->scm, false);
","	err = scm_send(sock, msg, siocb->scm);
",,"@@ -1450,7 +1450,7 @@ static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,
 	if (NULL == siocb->scm)
 		siocb->scm = &tmp_scm;
 	wait_for_unix_gc();
-	err = scm_send(sock, msg, siocb->scm);
+	err = scm_send(sock, msg, siocb->scm, false);
 	if (err < 0)
 		return err;
 
@@ -1619,7 +1619,7 @@ static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,
 	if (NULL == siocb->scm)
 		siocb->scm = &tmp_scm;
 	wait_for_unix_gc();
-	err = scm_send(sock, msg, siocb->scm);
+	err = scm_send(sock, msg, siocb->scm, false);
 	if (err < 0)
 		return err;
 ",linux,e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea,a9915a1b52df52ad87f3b33422da95cf25372f09,1,"static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,
			       struct msghdr *msg, size_t len)
{
	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
	struct sock *sk = sock->sk;
	struct sock *other = NULL;
	int err, size;
	struct sk_buff *skb;
	int sent = 0;
	struct scm_cookie tmp_scm;
	bool fds_sent = false;
	int max_level;

 	if (NULL == siocb->scm)
 		siocb->scm = &tmp_scm;
 	wait_for_unix_gc();
//flaw_line_below:
	err = scm_send(sock, msg, siocb->scm);
//fix_flaw_line_below:
//	err = scm_send(sock, msg, siocb->scm, false);
 	if (err < 0)
 		return err;
 
	err = -EOPNOTSUPP;
	if (msg->msg_flags&MSG_OOB)
		goto out_err;

	if (msg->msg_namelen) {
		err = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;
		goto out_err;
	} else {
		err = -ENOTCONN;
		other = unix_peer(sk);
		if (!other)
			goto out_err;
	}

	if (sk->sk_shutdown & SEND_SHUTDOWN)
		goto pipe_err;

	while (sent < len) {
		/*
		 *	Optimisation for the fact that under 0.01% of X
		 *	messages typically need breaking up.
		 */

		size = len-sent;

		/* Keep two messages in the pipe so it schedules better */
		if (size > ((sk->sk_sndbuf >> 1) - 64))
			size = (sk->sk_sndbuf >> 1) - 64;

		if (size > SKB_MAX_ALLOC)
			size = SKB_MAX_ALLOC;

		/*
		 *	Grab a buffer
		 */

		skb = sock_alloc_send_skb(sk, size, msg->msg_flags&MSG_DONTWAIT,
					  &err);

		if (skb == NULL)
			goto out_err;

		/*
		 *	If you pass two values to the sock_alloc_send_skb
		 *	it tries to grab the large buffer with GFP_NOFS
		 *	(which can fail easily), and if it fails grab the
		 *	fallback size buffer which is under a page and will
		 *	succeed. [Alan]
		 */
		size = min_t(int, size, skb_tailroom(skb));


		/* Only send the fds in the first buffer */
		err = unix_scm_to_skb(siocb->scm, skb, !fds_sent);
		if (err < 0) {
			kfree_skb(skb);
			goto out_err;
		}
		max_level = err + 1;
		fds_sent = true;

		err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);
		if (err) {
			kfree_skb(skb);
			goto out_err;
		}

		unix_state_lock(other);

		if (sock_flag(other, SOCK_DEAD) ||
		    (other->sk_shutdown & RCV_SHUTDOWN))
			goto pipe_err_free;

		maybe_add_creds(skb, sock, other);
		skb_queue_tail(&other->sk_receive_queue, skb);
		if (max_level > unix_sk(other)->recursion_level)
			unix_sk(other)->recursion_level = max_level;
		unix_state_unlock(other);
		other->sk_data_ready(other, size);
		sent += size;
	}

	scm_destroy(siocb->scm);
	siocb->scm = NULL;

	return sent;

pipe_err_free:
	unix_state_unlock(other);
	kfree_skb(skb);
pipe_err:
	if (sent == 0 && !(msg->msg_flags&MSG_NOSIGNAL))
		send_sig(SIGPIPE, current, 0);
	err = -EPIPE;
out_err:
	scm_destroy(siocb->scm);
	siocb->scm = NULL;
	return sent ? : err;
}
"
1724,179460,,Remote,Not required,Partial,CVE-2014-4668,https://www.cvedetails.com/cve/CVE-2014-4668/,CWE-287,Medium,Partial,Partial,,2014-07-02,6.8,"The cherokee_validator_ldap_check function in validator_ldap.c in Cherokee 1.2.103 and earlier, when LDAP is used, does not properly consider unauthenticated-bind semantics, which allows remote attackers to bypass authentication via an empty password.",2017-01-02,Bypass ,2,https://github.com/cherokee/webserver/commit/fbda667221c51f0aa476a02366e0cf66cb012f88,fbda667221c51f0aa476a02366e0cf66cb012f88,Prevent the LDAP validator from accepting an empty password.,1,cherokee/validator_ldap.c,"{""sha"": ""417fd9e4bc44b50c98e90e1aeeaa0022cf56b960"", ""filename"": ""cherokee/validator_ldap.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/cherokee/webserver/blob/fbda667221c51f0aa476a02366e0cf66cb012f88/cherokee/validator_ldap.c"", ""raw_url"": ""https://github.com/cherokee/webserver/raw/fbda667221c51f0aa476a02366e0cf66cb012f88/cherokee/validator_ldap.c"", ""contents_url"": ""https://api.github.com/repos/cherokee/webserver/contents/cherokee/validator_ldap.c?ref=fbda667221c51f0aa476a02366e0cf66cb012f88"", ""patch"": ""@@ -335,7 +335,8 @@ cherokee_validator_ldap_check (cherokee_validator_ldap_t *ldap,\n \t/* Sanity checks\n \t */\n \tif ((conn->validator == NULL) ||\n-\t    cherokee_buffer_is_empty (&conn->validator->user))\n+\t    cherokee_buffer_is_empty (&conn->validator->user) ||\n+\t    cherokee_buffer_is_empty (&conn->validator->passwd))\n \t\treturn ret_error;\n \n \tsize = cherokee_buffer_cnt_cspn (&conn->validator->user, 0, \""*()\"");""}","cherokee_validator_ldap_check (cherokee_validator_ldap_t *ldap,
                               cherokee_connection_t     *conn)
{
	int                              re;
	ret_t                            ret;
	size_t                           size;
	char                            *dn;
	LDAPMessage                     *message;
	LDAPMessage                     *first;
	char                            *attrs[] = { LDAP_NO_ATTRS, NULL };
	cherokee_validator_ldap_props_t *props   = VAL_LDAP_PROP(ldap);

 	/* Sanity checks
 	 */
 	if ((conn->validator == NULL) ||
	    cherokee_buffer_is_empty (&conn->validator->user) ||
	    cherokee_buffer_is_empty (&conn->validator->passwd))
 		return ret_error;
 
 	size = cherokee_buffer_cnt_cspn (&conn->validator->user, 0, ""*()"");
	if (size != conn->validator->user.len)
		return ret_error;

	/* Build filter
	 */
	ret = init_filter (ldap, props, conn);
	if (ret != ret_ok)
		return ret;

	/* Search
	 */
	re = ldap_search_s (ldap->conn, props->basedn.buf, LDAP_SCOPE_SUBTREE, ldap->filter.buf, attrs, 0, &message);
	if (re != LDAP_SUCCESS) {
		LOG_ERROR (CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH,
		           props->filter.buf ? props->filter.buf : """");
		return ret_error;
	}

	TRACE (ENTRIES, ""subtree search (%s): done\n"", ldap->filter.buf ? ldap->filter.buf : """");

	/* Check that there a single entry
	 */
	re = ldap_count_entries (ldap->conn, message);
	if (re != 1) {
		ldap_msgfree (message);
		return ret_not_found;
	}

	/* Pick up the first one
	 */
	first = ldap_first_entry (ldap->conn, message);
	if (first == NULL) {
		ldap_msgfree (message);
		return ret_not_found;
	}

	/* Get DN
	 */
	dn = ldap_get_dn (ldap->conn, first);
	if (dn == NULL) {
		ldap_msgfree (message);
		return ret_error;
	}

	ldap_msgfree (message);

	/* Check that it's right
	 */
	ret = validate_dn (props, dn, conn->validator->passwd.buf);
	if (ret != ret_ok)
		return ret;

	/* Disconnect from the LDAP server
	 */
	re = ldap_unbind_s (ldap->conn);
	if (re != LDAP_SUCCESS)
		return ret_error;

	/* Validated!
	 */
	TRACE (ENTRIES, ""Access to use %s has been granted\n"", conn->validator->user.buf);

	return ret_ok;
}
","cherokee_validator_ldap_check (cherokee_validator_ldap_t *ldap,
                               cherokee_connection_t     *conn)
{
	int                              re;
	ret_t                            ret;
	size_t                           size;
	char                            *dn;
	LDAPMessage                     *message;
	LDAPMessage                     *first;
	char                            *attrs[] = { LDAP_NO_ATTRS, NULL };
	cherokee_validator_ldap_props_t *props   = VAL_LDAP_PROP(ldap);

 	/* Sanity checks
 	 */
 	if ((conn->validator == NULL) ||
	    cherokee_buffer_is_empty (&conn->validator->user))
 		return ret_error;
 
 	size = cherokee_buffer_cnt_cspn (&conn->validator->user, 0, ""*()"");
	if (size != conn->validator->user.len)
		return ret_error;

	/* Build filter
	 */
	ret = init_filter (ldap, props, conn);
	if (ret != ret_ok)
		return ret;

	/* Search
	 */
	re = ldap_search_s (ldap->conn, props->basedn.buf, LDAP_SCOPE_SUBTREE, ldap->filter.buf, attrs, 0, &message);
	if (re != LDAP_SUCCESS) {
		LOG_ERROR (CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH,
		           props->filter.buf ? props->filter.buf : """");
		return ret_error;
	}

	TRACE (ENTRIES, ""subtree search (%s): done\n"", ldap->filter.buf ? ldap->filter.buf : """");

	/* Check that there a single entry
	 */
	re = ldap_count_entries (ldap->conn, message);
	if (re != 1) {
		ldap_msgfree (message);
		return ret_not_found;
	}

	/* Pick up the first one
	 */
	first = ldap_first_entry (ldap->conn, message);
	if (first == NULL) {
		ldap_msgfree (message);
		return ret_not_found;
	}

	/* Get DN
	 */
	dn = ldap_get_dn (ldap->conn, first);
	if (dn == NULL) {
		ldap_msgfree (message);
		return ret_error;
	}

	ldap_msgfree (message);

	/* Check that it's right
	 */
	ret = validate_dn (props, dn, conn->validator->passwd.buf);
	if (ret != ret_ok)
		return ret;

	/* Disconnect from the LDAP server
	 */
	re = ldap_unbind_s (ldap->conn);
	if (re != LDAP_SUCCESS)
		return ret_error;

	/* Validated!
	 */
	TRACE (ENTRIES, ""Access to use %s has been granted\n"", conn->validator->user.buf);

	return ret_ok;
}
",C,"	    cherokee_buffer_is_empty (&conn->validator->user) ||
	    cherokee_buffer_is_empty (&conn->validator->passwd))
","	    cherokee_buffer_is_empty (&conn->validator->user))
",,"@@ -335,7 +335,8 @@ cherokee_validator_ldap_check (cherokee_validator_ldap_t *ldap,
 	/* Sanity checks
 	 */
 	if ((conn->validator == NULL) ||
-	    cherokee_buffer_is_empty (&conn->validator->user))
+	    cherokee_buffer_is_empty (&conn->validator->user) ||
+	    cherokee_buffer_is_empty (&conn->validator->passwd))
 		return ret_error;
 
 	size = cherokee_buffer_cnt_cspn (&conn->validator->user, 0, ""*()"");",webserver,fbda667221c51f0aa476a02366e0cf66cb012f88,dc1f76f32ef6a9b982a27ca4748ee9b030913323,1,"cherokee_validator_ldap_check (cherokee_validator_ldap_t *ldap,
                               cherokee_connection_t     *conn)
{
	int                              re;
	ret_t                            ret;
	size_t                           size;
	char                            *dn;
	LDAPMessage                     *message;
	LDAPMessage                     *first;
	char                            *attrs[] = { LDAP_NO_ATTRS, NULL };
	cherokee_validator_ldap_props_t *props   = VAL_LDAP_PROP(ldap);

 	/* Sanity checks
 	 */
 	if ((conn->validator == NULL) ||
//flaw_line_below:
	    cherokee_buffer_is_empty (&conn->validator->user))
//fix_flaw_line_below:
//	    cherokee_buffer_is_empty (&conn->validator->user) ||
//fix_flaw_line_below:
//	    cherokee_buffer_is_empty (&conn->validator->passwd))
 		return ret_error;
 
 	size = cherokee_buffer_cnt_cspn (&conn->validator->user, 0, ""*()"");
	if (size != conn->validator->user.len)
		return ret_error;

	/* Build filter
	 */
	ret = init_filter (ldap, props, conn);
	if (ret != ret_ok)
		return ret;

	/* Search
	 */
	re = ldap_search_s (ldap->conn, props->basedn.buf, LDAP_SCOPE_SUBTREE, ldap->filter.buf, attrs, 0, &message);
	if (re != LDAP_SUCCESS) {
		LOG_ERROR (CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH,
		           props->filter.buf ? props->filter.buf : """");
		return ret_error;
	}

	TRACE (ENTRIES, ""subtree search (%s): done\n"", ldap->filter.buf ? ldap->filter.buf : """");

	/* Check that there a single entry
	 */
	re = ldap_count_entries (ldap->conn, message);
	if (re != 1) {
		ldap_msgfree (message);
		return ret_not_found;
	}

	/* Pick up the first one
	 */
	first = ldap_first_entry (ldap->conn, message);
	if (first == NULL) {
		ldap_msgfree (message);
		return ret_not_found;
	}

	/* Get DN
	 */
	dn = ldap_get_dn (ldap->conn, first);
	if (dn == NULL) {
		ldap_msgfree (message);
		return ret_error;
	}

	ldap_msgfree (message);

	/* Check that it's right
	 */
	ret = validate_dn (props, dn, conn->validator->passwd.buf);
	if (ret != ret_ok)
		return ret;

	/* Disconnect from the LDAP server
	 */
	re = ldap_unbind_s (ldap->conn);
	if (re != LDAP_SUCCESS)
		return ret_error;

	/* Validated!
	 */
	TRACE (ENTRIES, ""Access to use %s has been granted\n"", conn->validator->user.buf);

	return ret_ok;
}
"
2381,180117,,Remote,Not required,,CVE-2016-7141,https://www.cvedetails.com/cve/CVE-2016-7141/,CWE-287,Low,,Partial,,2016-10-03,5.0,"curl and libcurl before 7.50.2, when built with NSS and the libnsspem.so library is available at runtime, allow remote attackers to hijack the authentication of a TLS connection by leveraging reuse of a previously loaded client certificate from file for a connection for which no certificate has been set, a different vulnerability than CVE-2016-5420.",2018-11-13,,7,https://github.com/curl/curl/commit/curl-7_50_2~32,curl-7_50_2~32,"nss: refuse previously loaded certificate from file

... when we are not asked to use a certificate from file",1,lib/vtls/nss.c,"{""sha"": ""b8a98a99e746696a458c82019e78c447d49cd491"", ""filename"": ""RELEASE-NOTES"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/curl/curl/blob/7700fcba64bf5806de28f6c1c7da3b4f0b38567d/RELEASE-NOTES"", ""raw_url"": ""https://github.com/curl/curl/raw/7700fcba64bf5806de28f6c1c7da3b4f0b38567d/RELEASE-NOTES"", ""contents_url"": ""https://api.github.com/repos/curl/curl/contents/RELEASE-NOTES?ref=7700fcba64bf5806de28f6c1c7da3b4f0b38567d"", ""patch"": ""@@ -37,6 +37,7 @@ This release includes the following bugfixes:\n  o SOCKS: display the hostname returned by the SOCKS5 proxy server\n  o sasl: Don't use GSSAPI authentication when domain name not specified [16]\n  o win: Basic support for Universal Windows Platform apps [17]\n+ o nss: fix incorrect use of a previously loaded certificate from file\n \n This release includes the following known bugs:\n ""}<_**next**_>{""sha"": ""cfb226328f71e943b7c8f1d3631c2b55da595c10"", ""filename"": ""lib/vtls/nss.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/curl/curl/blob/7700fcba64bf5806de28f6c1c7da3b4f0b38567d/lib/vtls/nss.c"", ""raw_url"": ""https://github.com/curl/curl/raw/7700fcba64bf5806de28f6c1c7da3b4f0b38567d/lib/vtls/nss.c"", ""contents_url"": ""https://api.github.com/repos/curl/curl/contents/lib/vtls/nss.c?ref=7700fcba64bf5806de28f6c1c7da3b4f0b38567d"", ""patch"": ""@@ -1002,10 +1002,10 @@ static SECStatus SelectClientCert(void *arg, PRFileDesc *sock,\n   struct ssl_connect_data *connssl = (struct ssl_connect_data *)arg;\n   struct Curl_easy *data = connssl->data;\n   const char *nickname = connssl->client_nickname;\n+  static const char pem_slotname[] = \""PEM Token #1\"";\n \n   if(connssl->obj_clicert) {\n     /* use the cert/key provided by PEM reader */\n-    static const char pem_slotname[] = \""PEM Token #1\"";\n     SECItem cert_der = { 0, NULL, 0 };\n     void *proto_win = SSL_RevealPinArg(sock);\n     struct CERTCertificateStr *cert;\n@@ -1067,6 +1067,12 @@ static SECStatus SelectClientCert(void *arg, PRFileDesc *sock,\n   if(NULL == nickname)\n     nickname = \""[unknown]\"";\n \n+  if(!strncmp(nickname, pem_slotname, sizeof(pem_slotname) - 1U)) {\n+    failf(data, \""NSS: refusing previously loaded certificate from file: %s\"",\n+          nickname);\n+    return SECFailure;\n+  }\n+\n   if(NULL == *pRetKey) {\n     failf(data, \""NSS: private key not found for certificate: %s\"", nickname);\n     return SECFailure;""}","static SECStatus SelectClientCert(void *arg, PRFileDesc *sock,
                                  struct CERTDistNamesStr *caNames,
                                  struct CERTCertificateStr **pRetCert,
                                  struct SECKEYPrivateKeyStr **pRetKey)
{
   struct ssl_connect_data *connssl = (struct ssl_connect_data *)arg;
   struct Curl_easy *data = connssl->data;
   const char *nickname = connssl->client_nickname;
  static const char pem_slotname[] = ""PEM Token #1"";
 
   if(connssl->obj_clicert) {
     /* use the cert/key provided by PEM reader */
     SECItem cert_der = { 0, NULL, 0 };
     void *proto_win = SSL_RevealPinArg(sock);
     struct CERTCertificateStr *cert;
    struct SECKEYPrivateKeyStr *key;

    PK11SlotInfo *slot = PK11_FindSlotByName(pem_slotname);
    if(NULL == slot) {
      failf(data, ""NSS: PK11 slot not found: %s"", pem_slotname);
      return SECFailure;
    }

    if(PK11_ReadRawAttribute(PK11_TypeGeneric, connssl->obj_clicert, CKA_VALUE,
                             &cert_der) != SECSuccess) {
      failf(data, ""NSS: CKA_VALUE not found in PK11 generic object"");
      PK11_FreeSlot(slot);
      return SECFailure;
    }

    cert = PK11_FindCertFromDERCertItem(slot, &cert_der, proto_win);
    SECITEM_FreeItem(&cert_der, PR_FALSE);
    if(NULL == cert) {
      failf(data, ""NSS: client certificate from file not found"");
      PK11_FreeSlot(slot);
      return SECFailure;
    }

    key = PK11_FindPrivateKeyFromCert(slot, cert, NULL);
    PK11_FreeSlot(slot);
    if(NULL == key) {
      failf(data, ""NSS: private key from file not found"");
      CERT_DestroyCertificate(cert);
      return SECFailure;
    }

    infof(data, ""NSS: client certificate from file\n"");
    display_cert_info(data, cert);

    *pRetCert = cert;
    *pRetKey = key;
    return SECSuccess;
  }

  /* use the default NSS hook */
  if(SECSuccess != NSS_GetClientAuthData((void *)nickname, sock, caNames,
                                          pRetCert, pRetKey)
      || NULL == *pRetCert) {

    if(NULL == nickname)
      failf(data, ""NSS: client certificate not found (nickname not ""
            ""specified)"");
    else
      failf(data, ""NSS: client certificate not found: %s"", nickname);

    return SECFailure;
  }

  /* get certificate nickname if any */
  nickname = (*pRetCert)->nickname;
   if(NULL == nickname)
     nickname = ""[unknown]"";
 
  if(!strncmp(nickname, pem_slotname, sizeof(pem_slotname) - 1U)) {
    failf(data, ""NSS: refusing previously loaded certificate from file: %s"",
          nickname);
    return SECFailure;
  }

   if(NULL == *pRetKey) {
     failf(data, ""NSS: private key not found for certificate: %s"", nickname);
     return SECFailure;
  }

  infof(data, ""NSS: using client certificate: %s\n"", nickname);
  display_cert_info(data, *pRetCert);
  return SECSuccess;
}
","static SECStatus SelectClientCert(void *arg, PRFileDesc *sock,
                                  struct CERTDistNamesStr *caNames,
                                  struct CERTCertificateStr **pRetCert,
                                  struct SECKEYPrivateKeyStr **pRetKey)
{
   struct ssl_connect_data *connssl = (struct ssl_connect_data *)arg;
   struct Curl_easy *data = connssl->data;
   const char *nickname = connssl->client_nickname;
 
   if(connssl->obj_clicert) {
     /* use the cert/key provided by PEM reader */
    static const char pem_slotname[] = ""PEM Token #1"";
     SECItem cert_der = { 0, NULL, 0 };
     void *proto_win = SSL_RevealPinArg(sock);
     struct CERTCertificateStr *cert;
    struct SECKEYPrivateKeyStr *key;

    PK11SlotInfo *slot = PK11_FindSlotByName(pem_slotname);
    if(NULL == slot) {
      failf(data, ""NSS: PK11 slot not found: %s"", pem_slotname);
      return SECFailure;
    }

    if(PK11_ReadRawAttribute(PK11_TypeGeneric, connssl->obj_clicert, CKA_VALUE,
                             &cert_der) != SECSuccess) {
      failf(data, ""NSS: CKA_VALUE not found in PK11 generic object"");
      PK11_FreeSlot(slot);
      return SECFailure;
    }

    cert = PK11_FindCertFromDERCertItem(slot, &cert_der, proto_win);
    SECITEM_FreeItem(&cert_der, PR_FALSE);
    if(NULL == cert) {
      failf(data, ""NSS: client certificate from file not found"");
      PK11_FreeSlot(slot);
      return SECFailure;
    }

    key = PK11_FindPrivateKeyFromCert(slot, cert, NULL);
    PK11_FreeSlot(slot);
    if(NULL == key) {
      failf(data, ""NSS: private key from file not found"");
      CERT_DestroyCertificate(cert);
      return SECFailure;
    }

    infof(data, ""NSS: client certificate from file\n"");
    display_cert_info(data, cert);

    *pRetCert = cert;
    *pRetKey = key;
    return SECSuccess;
  }

  /* use the default NSS hook */
  if(SECSuccess != NSS_GetClientAuthData((void *)nickname, sock, caNames,
                                          pRetCert, pRetKey)
      || NULL == *pRetCert) {

    if(NULL == nickname)
      failf(data, ""NSS: client certificate not found (nickname not ""
            ""specified)"");
    else
      failf(data, ""NSS: client certificate not found: %s"", nickname);

    return SECFailure;
  }

  /* get certificate nickname if any */
  nickname = (*pRetCert)->nickname;
   if(NULL == nickname)
     nickname = ""[unknown]"";
 
   if(NULL == *pRetKey) {
     failf(data, ""NSS: private key not found for certificate: %s"", nickname);
     return SECFailure;
  }

  infof(data, ""NSS: using client certificate: %s\n"", nickname);
  display_cert_info(data, *pRetCert);
  return SECSuccess;
}
",C,"  static const char pem_slotname[] = ""PEM Token #1"";
  if(!strncmp(nickname, pem_slotname, sizeof(pem_slotname) - 1U)) {
    failf(data, ""NSS: refusing previously loaded certificate from file: %s"",
          nickname);
    return SECFailure;
  }

","    static const char pem_slotname[] = ""PEM Token #1"";
",,"@@ -1002,10 +1002,10 @@ static SECStatus SelectClientCert(void *arg, PRFileDesc *sock,
   struct ssl_connect_data *connssl = (struct ssl_connect_data *)arg;
   struct Curl_easy *data = connssl->data;
   const char *nickname = connssl->client_nickname;
+  static const char pem_slotname[] = ""PEM Token #1"";
 
   if(connssl->obj_clicert) {
     /* use the cert/key provided by PEM reader */
-    static const char pem_slotname[] = ""PEM Token #1"";
     SECItem cert_der = { 0, NULL, 0 };
     void *proto_win = SSL_RevealPinArg(sock);
     struct CERTCertificateStr *cert;
@@ -1067,6 +1067,12 @@ static SECStatus SelectClientCert(void *arg, PRFileDesc *sock,
   if(NULL == nickname)
     nickname = ""[unknown]"";
 
+  if(!strncmp(nickname, pem_slotname, sizeof(pem_slotname) - 1U)) {
+    failf(data, ""NSS: refusing previously loaded certificate from file: %s"",
+          nickname);
+    return SECFailure;
+  }
+
   if(NULL == *pRetKey) {
     failf(data, ""NSS: private key not found for certificate: %s"", nickname);
     return SECFailure;",curl,curl-7_50_2~32,822082d8327a41aafa4c6b7696bfcb8b56037cbf,1,"static SECStatus SelectClientCert(void *arg, PRFileDesc *sock,
                                  struct CERTDistNamesStr *caNames,
                                  struct CERTCertificateStr **pRetCert,
                                  struct SECKEYPrivateKeyStr **pRetKey)
{
   struct ssl_connect_data *connssl = (struct ssl_connect_data *)arg;
   struct Curl_easy *data = connssl->data;
   const char *nickname = connssl->client_nickname;
//fix_flaw_line_below:
//  static const char pem_slotname[] = ""PEM Token #1"";
 
   if(connssl->obj_clicert) {
     /* use the cert/key provided by PEM reader */
//flaw_line_below:
    static const char pem_slotname[] = ""PEM Token #1"";
     SECItem cert_der = { 0, NULL, 0 };
     void *proto_win = SSL_RevealPinArg(sock);
     struct CERTCertificateStr *cert;
    struct SECKEYPrivateKeyStr *key;

    PK11SlotInfo *slot = PK11_FindSlotByName(pem_slotname);
    if(NULL == slot) {
      failf(data, ""NSS: PK11 slot not found: %s"", pem_slotname);
      return SECFailure;
    }

    if(PK11_ReadRawAttribute(PK11_TypeGeneric, connssl->obj_clicert, CKA_VALUE,
                             &cert_der) != SECSuccess) {
      failf(data, ""NSS: CKA_VALUE not found in PK11 generic object"");
      PK11_FreeSlot(slot);
      return SECFailure;
    }

    cert = PK11_FindCertFromDERCertItem(slot, &cert_der, proto_win);
    SECITEM_FreeItem(&cert_der, PR_FALSE);
    if(NULL == cert) {
      failf(data, ""NSS: client certificate from file not found"");
      PK11_FreeSlot(slot);
      return SECFailure;
    }

    key = PK11_FindPrivateKeyFromCert(slot, cert, NULL);
    PK11_FreeSlot(slot);
    if(NULL == key) {
      failf(data, ""NSS: private key from file not found"");
      CERT_DestroyCertificate(cert);
      return SECFailure;
    }

    infof(data, ""NSS: client certificate from file\n"");
    display_cert_info(data, cert);

    *pRetCert = cert;
    *pRetKey = key;
    return SECSuccess;
  }

  /* use the default NSS hook */
  if(SECSuccess != NSS_GetClientAuthData((void *)nickname, sock, caNames,
                                          pRetCert, pRetKey)
      || NULL == *pRetCert) {

    if(NULL == nickname)
      failf(data, ""NSS: client certificate not found (nickname not ""
            ""specified)"");
    else
      failf(data, ""NSS: client certificate not found: %s"", nickname);

    return SECFailure;
  }

  /* get certificate nickname if any */
  nickname = (*pRetCert)->nickname;
   if(NULL == nickname)
     nickname = ""[unknown]"";
 
//fix_flaw_line_below:
//  if(!strncmp(nickname, pem_slotname, sizeof(pem_slotname) - 1U)) {
//fix_flaw_line_below:
//    failf(data, ""NSS: refusing previously loaded certificate from file: %s"",
//fix_flaw_line_below:
//          nickname);
//fix_flaw_line_below:
//    return SECFailure;
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
   if(NULL == *pRetKey) {
     failf(data, ""NSS: private key not found for certificate: %s"", nickname);
     return SECFailure;
  }

  infof(data, ""NSS: using client certificate: %s\n"", nickname);
  display_cert_info(data, *pRetCert);
  return SECSuccess;
}
"
3219,180955,,Remote,Not required,Partial,CVE-2017-14032,https://www.cvedetails.com/cve/CVE-2017-14032/,CWE-287,Medium,Partial,Partial,,2017-08-30,6.8,"ARM mbed TLS before 1.3.21 and 2.x before 2.1.9, if optional authentication is configured, allows remote attackers to bypass peer authentication via an X.509 certificate chain with many intermediates. NOTE: although mbed TLS was formerly known as PolarSSL, the releases shipped with the PolarSSL name are not affected.",2017-11-07,Bypass ,16,https://github.com/ARMmbed/mbedtls/commit/d15795acd5074e0b44e71f7ede8bdfe1b48591fc,d15795acd5074e0b44e71f7ede8bdfe1b48591fc,"Improve behaviour on fatal errors

If we didn't walk the whole chain, then there may be any kind of errors in the
part of the chain we didn't check, so setting all flags looks like the safe
thing to do.",5,library/x509_crt.c,"{""sha"": ""9bf6a1719d7be833e32a7ecac96079d8869c523c"", ""filename"": ""ChangeLog"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/d15795acd5074e0b44e71f7ede8bdfe1b48591fc/ChangeLog"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/d15795acd5074e0b44e71f7ede8bdfe1b48591fc/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/ChangeLog?ref=d15795acd5074e0b44e71f7ede8bdfe1b48591fc"", ""patch"": ""@@ -1,5 +1,12 @@\n mbed TLS ChangeLog (Sorted per branch, date)\n \n+= mbed TLS 2.y.z released YYYY-MM-DD\n+\n+Changes\n+   * Certificate verification functions now set flags to -1 in case the full\n+     chain was not verified due to an internal error (including in the verify\n+     callback) or chain length limitations.\n+\n = mbed TLS 2.5.1 released 2017-06-21\n \n Security""}<_**next**_>{""sha"": ""ee5f27e465b9e0cc63b0f8b1b252a456a0068c86"", ""filename"": ""library/x509_crt.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 6, ""changes"": 22, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/d15795acd5074e0b44e71f7ede8bdfe1b48591fc/library/x509_crt.c"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/d15795acd5074e0b44e71f7ede8bdfe1b48591fc/library/x509_crt.c"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/library/x509_crt.c?ref=d15795acd5074e0b44e71f7ede8bdfe1b48591fc"", ""patch"": ""@@ -2202,11 +2202,14 @@ int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,\n     mbedtls_x509_sequence *cur = NULL;\n     mbedtls_pk_type_t pk_type;\n \n-    if( profile == NULL )\n-        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n-\n     *flags = 0;\n \n+    if( profile == NULL )\n+    {\n+        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;\n+        goto exit;\n+    }\n+\n     if( cn != NULL )\n     {\n         name = &crt->subject;\n@@ -2280,7 +2283,7 @@ int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,\n         ret = x509_crt_verify_top( crt, parent, ca_crl, profile,\n                                    pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n         if( ret != 0 )\n-            return( ret );\n+            goto exit;\n     }\n     else\n     {\n@@ -2295,17 +2298,24 @@ int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,\n             ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,\n                                          pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n             if( ret != 0 )\n-                return( ret );\n+                goto exit;\n         }\n         else\n         {\n             ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,\n                                        pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n             if( ret != 0 )\n-                return( ret );\n+                goto exit;\n         }\n     }\n \n+exit:\n+    if( ret != 0 )\n+    {\n+        *flags = (uint32_t) -1;\n+        return( ret );\n+    }\n+\n     if( *flags != 0 )\n         return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n ""}<_**next**_>{""sha"": ""6df52987505d5f7000eb7587e4e0d373ea844ace"", ""filename"": ""tests/suites/test_suite_x509parse.data"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/d15795acd5074e0b44e71f7ede8bdfe1b48591fc/tests/suites/test_suite_x509parse.data"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/d15795acd5074e0b44e71f7ede8bdfe1b48591fc/tests/suites/test_suite_x509parse.data"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/tests/suites/test_suite_x509parse.data?ref=d15795acd5074e0b44e71f7ede8bdfe1b48591fc"", ""patch"": ""@@ -1204,7 +1204,7 @@ mbedtls_x509_crt_verify_max:\""data_files/test-ca2.crt\"":\""data_files/dir-maxpath\"":M\n \n X509 CRT verify long chain (max intermediate CA + 1)\n depends_on:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\n-mbedtls_x509_crt_verify_max:\""data_files/dir-maxpath/00.crt\"":\""data_files/dir-maxpath\"":MBEDTLS_X509_MAX_INTERMEDIATE_CA+1:MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:0\n+mbedtls_x509_crt_verify_max:\""data_files/dir-maxpath/00.crt\"":\""data_files/dir-maxpath\"":MBEDTLS_X509_MAX_INTERMEDIATE_CA+1:MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:-1\n \n X509 CRT verify chain #1 (zero pathlen intermediate)\n depends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C""}","int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,
                     mbedtls_x509_crt *trust_ca,
                     mbedtls_x509_crl *ca_crl,
                     const mbedtls_x509_crt_profile *profile,
                     const char *cn, uint32_t *flags,
                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
                     void *p_vrfy )
{
    size_t cn_len;
    int ret;
    int pathlen = 0, selfsigned = 0;
    mbedtls_x509_crt *parent;
    mbedtls_x509_name *name;
     mbedtls_x509_sequence *cur = NULL;
     mbedtls_pk_type_t pk_type;
 
     *flags = 0;
 
    if( profile == NULL )
    {
        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;
        goto exit;
    }

     if( cn != NULL )
     {
         name = &crt->subject;
        cn_len = strlen( cn );

        if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )
        {
            cur = &crt->subject_alt_names;

            while( cur != NULL )
            {
                if( cur->buf.len == cn_len &&
                    x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )
                    break;

                if( cur->buf.len > 2 &&
                    memcmp( cur->buf.p, ""*."", 2 ) == 0 &&
                    x509_check_wildcard( cn, &cur->buf ) == 0 )
                {
                    break;
                }

                cur = cur->next;
            }

            if( cur == NULL )
                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
        }
        else
        {
            while( name != NULL )
            {
                if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )
                {
                    if( name->val.len == cn_len &&
                        x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )
                        break;

                    if( name->val.len > 2 &&
                        memcmp( name->val.p, ""*."", 2 ) == 0 &&
                        x509_check_wildcard( cn, &name->val ) == 0 )
                        break;
                }

                name = name->next;
            }

            if( name == NULL )
                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
        }
    }

    /* Check the type and size of the key */
    pk_type = mbedtls_pk_get_type( &crt->pk );

    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;

    if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;

    /* Look for a parent in trusted CAs */
    for( parent = trust_ca; parent != NULL; parent = parent->next )
    {
        if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
            break;
    }

    if( parent != NULL )
    {
         ret = x509_crt_verify_top( crt, parent, ca_crl, profile,
                                    pathlen, selfsigned, flags, f_vrfy, p_vrfy );
         if( ret != 0 )
            goto exit;
     }
     else
     {
        /* Look for a parent upwards the chain */
        for( parent = crt->next; parent != NULL; parent = parent->next )
            if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
                break;

        /* Are we part of the chain or at the top? */
        if( parent != NULL )
        {
             ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,
                                          pathlen, selfsigned, flags, f_vrfy, p_vrfy );
             if( ret != 0 )
                goto exit;
         }
         else
         {
             ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,
                                        pathlen, selfsigned, flags, f_vrfy, p_vrfy );
             if( ret != 0 )
                goto exit;
         }
     }
 
exit:
    if( ret != 0 )
    {
        *flags = (uint32_t) -1;
        return( ret );
    }

     if( *flags != 0 )
         return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );
 
    return( 0 );
}
","int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,
                     mbedtls_x509_crt *trust_ca,
                     mbedtls_x509_crl *ca_crl,
                     const mbedtls_x509_crt_profile *profile,
                     const char *cn, uint32_t *flags,
                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
                     void *p_vrfy )
{
    size_t cn_len;
    int ret;
    int pathlen = 0, selfsigned = 0;
    mbedtls_x509_crt *parent;
    mbedtls_x509_name *name;
     mbedtls_x509_sequence *cur = NULL;
     mbedtls_pk_type_t pk_type;
 
    if( profile == NULL )
        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
     *flags = 0;
 
     if( cn != NULL )
     {
         name = &crt->subject;
        cn_len = strlen( cn );

        if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )
        {
            cur = &crt->subject_alt_names;

            while( cur != NULL )
            {
                if( cur->buf.len == cn_len &&
                    x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )
                    break;

                if( cur->buf.len > 2 &&
                    memcmp( cur->buf.p, ""*."", 2 ) == 0 &&
                    x509_check_wildcard( cn, &cur->buf ) == 0 )
                {
                    break;
                }

                cur = cur->next;
            }

            if( cur == NULL )
                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
        }
        else
        {
            while( name != NULL )
            {
                if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )
                {
                    if( name->val.len == cn_len &&
                        x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )
                        break;

                    if( name->val.len > 2 &&
                        memcmp( name->val.p, ""*."", 2 ) == 0 &&
                        x509_check_wildcard( cn, &name->val ) == 0 )
                        break;
                }

                name = name->next;
            }

            if( name == NULL )
                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
        }
    }

    /* Check the type and size of the key */
    pk_type = mbedtls_pk_get_type( &crt->pk );

    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;

    if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;

    /* Look for a parent in trusted CAs */
    for( parent = trust_ca; parent != NULL; parent = parent->next )
    {
        if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
            break;
    }

    if( parent != NULL )
    {
         ret = x509_crt_verify_top( crt, parent, ca_crl, profile,
                                    pathlen, selfsigned, flags, f_vrfy, p_vrfy );
         if( ret != 0 )
            return( ret );
     }
     else
     {
        /* Look for a parent upwards the chain */
        for( parent = crt->next; parent != NULL; parent = parent->next )
            if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
                break;

        /* Are we part of the chain or at the top? */
        if( parent != NULL )
        {
             ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,
                                          pathlen, selfsigned, flags, f_vrfy, p_vrfy );
             if( ret != 0 )
                return( ret );
         }
         else
         {
             ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,
                                        pathlen, selfsigned, flags, f_vrfy, p_vrfy );
             if( ret != 0 )
                return( ret );
         }
     }
 
     if( *flags != 0 )
         return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );
 
    return( 0 );
}
",C,"    if( profile == NULL )
    {
        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;
        goto exit;
    }

            goto exit;
                goto exit;
                goto exit;
exit:
    if( ret != 0 )
    {
        *flags = (uint32_t) -1;
        return( ret );
    }

","    if( profile == NULL )
        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
            return( ret );
                return( ret );
                return( ret );
",,"@@ -2202,11 +2202,14 @@ int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,
     mbedtls_x509_sequence *cur = NULL;
     mbedtls_pk_type_t pk_type;
 
-    if( profile == NULL )
-        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
-
     *flags = 0;
 
+    if( profile == NULL )
+    {
+        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;
+        goto exit;
+    }
+
     if( cn != NULL )
     {
         name = &crt->subject;
@@ -2280,7 +2283,7 @@ int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,
         ret = x509_crt_verify_top( crt, parent, ca_crl, profile,
                                    pathlen, selfsigned, flags, f_vrfy, p_vrfy );
         if( ret != 0 )
-            return( ret );
+            goto exit;
     }
     else
     {
@@ -2295,17 +2298,24 @@ int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,
             ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,
                                          pathlen, selfsigned, flags, f_vrfy, p_vrfy );
             if( ret != 0 )
-                return( ret );
+                goto exit;
         }
         else
         {
             ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,
                                        pathlen, selfsigned, flags, f_vrfy, p_vrfy );
             if( ret != 0 )
-                return( ret );
+                goto exit;
         }
     }
 
+exit:
+    if( ret != 0 )
+    {
+        *flags = (uint32_t) -1;
+        return( ret );
+    }
+
     if( *flags != 0 )
         return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );
 ",mbedtls,d15795acd5074e0b44e71f7ede8bdfe1b48591fc,1beb048316d50a0e7ed7d1c0e9a07b9ac7fe8bba,1,"int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,
                     mbedtls_x509_crt *trust_ca,
                     mbedtls_x509_crl *ca_crl,
                     const mbedtls_x509_crt_profile *profile,
                     const char *cn, uint32_t *flags,
                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
                     void *p_vrfy )
{
    size_t cn_len;
    int ret;
    int pathlen = 0, selfsigned = 0;
    mbedtls_x509_crt *parent;
    mbedtls_x509_name *name;
     mbedtls_x509_sequence *cur = NULL;
     mbedtls_pk_type_t pk_type;
 
//flaw_line_below:
    if( profile == NULL )
//flaw_line_below:
        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
//flaw_line_below:

     *flags = 0;
 
//fix_flaw_line_below:
//    if( profile == NULL )
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;
//fix_flaw_line_below:
//        goto exit;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     if( cn != NULL )
     {
         name = &crt->subject;
        cn_len = strlen( cn );

        if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )
        {
            cur = &crt->subject_alt_names;

            while( cur != NULL )
            {
                if( cur->buf.len == cn_len &&
                    x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )
                    break;

                if( cur->buf.len > 2 &&
                    memcmp( cur->buf.p, ""*."", 2 ) == 0 &&
                    x509_check_wildcard( cn, &cur->buf ) == 0 )
                {
                    break;
                }

                cur = cur->next;
            }

            if( cur == NULL )
                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
        }
        else
        {
            while( name != NULL )
            {
                if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )
                {
                    if( name->val.len == cn_len &&
                        x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )
                        break;

                    if( name->val.len > 2 &&
                        memcmp( name->val.p, ""*."", 2 ) == 0 &&
                        x509_check_wildcard( cn, &name->val ) == 0 )
                        break;
                }

                name = name->next;
            }

            if( name == NULL )
                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
        }
    }

    /* Check the type and size of the key */
    pk_type = mbedtls_pk_get_type( &crt->pk );

    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;

    if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;

    /* Look for a parent in trusted CAs */
    for( parent = trust_ca; parent != NULL; parent = parent->next )
    {
        if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
            break;
    }

    if( parent != NULL )
    {
         ret = x509_crt_verify_top( crt, parent, ca_crl, profile,
                                    pathlen, selfsigned, flags, f_vrfy, p_vrfy );
         if( ret != 0 )
//flaw_line_below:
            return( ret );
//fix_flaw_line_below:
//            goto exit;
     }
     else
     {
        /* Look for a parent upwards the chain */
        for( parent = crt->next; parent != NULL; parent = parent->next )
            if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
                break;

        /* Are we part of the chain or at the top? */
        if( parent != NULL )
        {
             ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,
                                          pathlen, selfsigned, flags, f_vrfy, p_vrfy );
             if( ret != 0 )
//flaw_line_below:
                return( ret );
//fix_flaw_line_below:
//                goto exit;
         }
         else
         {
             ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,
                                        pathlen, selfsigned, flags, f_vrfy, p_vrfy );
             if( ret != 0 )
//flaw_line_below:
                return( ret );
//fix_flaw_line_below:
//                goto exit;
         }
     }
 
//fix_flaw_line_below:
//exit:
//fix_flaw_line_below:
//    if( ret != 0 )
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//        *flags = (uint32_t) -1;
//fix_flaw_line_below:
//        return( ret );
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     if( *flags != 0 )
         return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );
 
    return( 0 );
}
"
3497,181233,,Remote,Not required,Partial,CVE-2017-10807,https://www.cvedetails.com/cve/CVE-2017-10807/,CWE-287,Low,Partial,Partial,,2017-07-04,7.5,"JabberD 2.x (aka jabberd2) before 2.6.1 allows anyone to authenticate using SASL ANONYMOUS, even when the sasl.anonymous c2s.xml option is not enabled.",2017-11-03,,2,https://github.com/jabberd2/jabberd2/commit/8416ae54ecefa670534f27a31db71d048b9c7f16,8416ae54ecefa670534f27a31db71d048b9c7f16,Fixed offered SASL mechanism check,0,c2s/main.c,"{""sha"": ""7972c5474f8eed00a529fb2c94d025a0cc1ab43b"", ""filename"": ""c2s/main.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/jabberd2/jabberd2/blob/8416ae54ecefa670534f27a31db71d048b9c7f16/c2s/main.c"", ""raw_url"": ""https://github.com/jabberd2/jabberd2/raw/8416ae54ecefa670534f27a31db71d048b9c7f16/c2s/main.c"", ""contents_url"": ""https://api.github.com/repos/jabberd2/jabberd2/contents/c2s/main.c?ref=8416ae54ecefa670534f27a31db71d048b9c7f16"", ""patch"": ""@@ -562,6 +562,8 @@ static int _c2s_sx_sasl_callback(int cb, void *arg, void **res, sx_t s, void *cb\n             mechbuf[sizeof(mechbuf)-1]='\\0';\n             for(i = 0; mechbuf[i]; i++) mechbuf[i] = tolower(mechbuf[i]);\n \n+            log_debug(ZONE, \""sx sasl callback: check mech (mech=%s)\"", mechbuf);\n+\n             /* get host for request */\n             host = xhash_get(c2s->hosts, s->req_to);\n             if(host == NULL) {""}<_**next**_>{""sha"": ""d52f6afabe971ee62363869e88d1e5569b4ab57d"", ""filename"": ""sx/sasl.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/jabberd2/jabberd2/blob/8416ae54ecefa670534f27a31db71d048b9c7f16/sx/sasl.c"", ""raw_url"": ""https://github.com/jabberd2/jabberd2/raw/8416ae54ecefa670534f27a31db71d048b9c7f16/sx/sasl.c"", ""contents_url"": ""https://api.github.com/repos/jabberd2/jabberd2/contents/sx/sasl.c?ref=8416ae54ecefa670534f27a31db71d048b9c7f16"", ""patch"": ""@@ -332,7 +332,7 @@ static void _sx_sasl_client_process(sx_t s, sx_plugin_t p, Gsasl_session *sd, co\n     if(mech != NULL) {\n         _sx_debug(ZONE, \""auth request from client (mechanism=%s)\"", mech);\n \n-        if(!gsasl_server_support_p(ctx->gsasl_ctx, mech)) {\n+        if(!gsasl_server_support_p(ctx->gsasl_ctx, mech) || (ctx->cb)(sx_sasl_cb_CHECK_MECH, (void*)mech, NULL, s, ctx->cbarg) != sx_sasl_ret_OK) {\n              _sx_debug(ZONE, \""client requested mechanism (%s) that we didn't offer\"", mech);\n              _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INVALID_MECHANISM, NULL), 0);\n              return;""}","static int _c2s_sx_sasl_callback(int cb, void *arg, void **res, sx_t s, void *cbarg) {
    c2s_t c2s = (c2s_t) cbarg;
    const char *my_realm, *mech;
    sx_sasl_creds_t creds;
    static char buf[3072];
    char mechbuf[256];
    struct jid_st jid;
    jid_static_buf jid_buf;
    int i, r;
    sess_t sess;
    char skey[44];
    host_t host;

    /* init static jid */
    jid_static(&jid,&jid_buf);

    /* retrieve our session */
    assert(s != NULL);
    sprintf(skey, ""%d"", s->tag);

    /*
     * Retrieve the session, note that depending on the operation,
     * session may be null.
     */
    sess = xhash_get(c2s->sessions, skey);

    switch(cb) {
        case sx_sasl_cb_GET_REALM:

            if(s->req_to == NULL)   /* this shouldn't happen */
                my_realm = """";

            else {
                /* get host for request */
                host = xhash_get(c2s->hosts, s->req_to);
                if(host == NULL) {
                    log_write(c2s->log, LOG_ERR, ""SASL callback for non-existing host: %s"", s->req_to);
                    *res = (void *)NULL;
                    return sx_sasl_ret_FAIL;
                }

                my_realm = host->realm;
                if(my_realm == NULL)
                    my_realm = s->req_to;
            }

            strncpy(buf, my_realm, 256);
            *res = (void *)buf;

            log_debug(ZONE, ""sx sasl callback: get realm: realm is '%s'"", buf);
            return sx_sasl_ret_OK;
            break;

        case sx_sasl_cb_GET_PASS:
            assert(sess != NULL);
            creds = (sx_sasl_creds_t) arg;

            log_debug(ZONE, ""sx sasl callback: get pass (authnid=%s, realm=%s)"", creds->authnid, creds->realm);

            if(sess->host->ar->get_password && (sess->host->ar->get_password)(
                        sess->host->ar, sess, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm: """", buf) == 0) {
                *res = buf;
                return sx_sasl_ret_OK;
            }

            return sx_sasl_ret_FAIL;

        case sx_sasl_cb_CHECK_PASS:
            assert(sess != NULL);
            creds = (sx_sasl_creds_t) arg;

            log_debug(ZONE, ""sx sasl callback: check pass (authnid=%s, realm=%s)"", creds->authnid, creds->realm);

            if(sess->host->ar->check_password != NULL) {
                if ((sess->host->ar->check_password)(
                            sess->host->ar, sess, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm : """", (char *)creds->pass) == 0)
                    return sx_sasl_ret_OK;
                else
                    return sx_sasl_ret_FAIL;
            }

            if(sess->host->ar->get_password != NULL) {
                if ((sess->host->ar->get_password)(sess->host->ar, sess, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm : """", buf) != 0)
                    return sx_sasl_ret_FAIL;

                if (strcmp(creds->pass, buf)==0)
                    return sx_sasl_ret_OK;
            }

            return sx_sasl_ret_FAIL;
            break;

        case sx_sasl_cb_CHECK_AUTHZID:
            assert(sess != NULL);
            creds = (sx_sasl_creds_t) arg;

            /* we need authzid to validate */
            if(creds->authzid == NULL || creds->authzid[0] == '\0')
                return sx_sasl_ret_FAIL;

            /* authzid must be a valid jid */
            if(jid_reset(&jid, creds->authzid, -1) == NULL)
                return sx_sasl_ret_FAIL;

            /* and have domain == stream to addr */
            if(!s->req_to || (strcmp(jid.domain, s->req_to) != 0))
                return sx_sasl_ret_FAIL;

            /* and have no resource */
            if(jid.resource[0] != '\0')
                return sx_sasl_ret_FAIL;

            /* and user has right to authorize as */
            if (sess->host->ar->user_authz_allowed) {
                if (sess->host->ar->user_authz_allowed(sess->host->ar, sess, (char *)creds->authnid, (char *)creds->realm, (char *)creds->authzid))
                        return sx_sasl_ret_OK;
            } else {
                if (strcmp(creds->authnid, jid.node) == 0 &&
                    (sess->host->ar->user_exists)(sess->host->ar, sess, jid.node, jid.domain))
                    return sx_sasl_ret_OK;
            }

            return sx_sasl_ret_FAIL;

        case sx_sasl_cb_GEN_AUTHZID:
            /* generate a jid for SASL ANONYMOUS */
            jid_reset(&jid, s->req_to, -1);

            /* make node a random string */
            jid_random_part(&jid, jid_NODE);

            strcpy(buf, jid.node);

            *res = (void *)buf;

            return sx_sasl_ret_OK;
            break;

        case sx_sasl_cb_CHECK_MECH:
            mech = (char *)arg;

            strncpy(mechbuf, mech, sizeof(mechbuf));
             mechbuf[sizeof(mechbuf)-1]='\0';
             for(i = 0; mechbuf[i]; i++) mechbuf[i] = tolower(mechbuf[i]);
 
            log_debug(ZONE, ""sx sasl callback: check mech (mech=%s)"", mechbuf);

             /* get host for request */
             host = xhash_get(c2s->hosts, s->req_to);
             if(host == NULL) {
                log_write(c2s->log, LOG_WARNING, ""SASL callback for non-existing host: %s"", s->req_to);
                return sx_sasl_ret_FAIL;
            }

            /* Determine if our configuration will let us use this mechanism.
             * We support different mechanisms for both SSL and normal use */
            if (strcmp(mechbuf, ""digest-md5"") == 0) {
                /* digest-md5 requires that our authreg support get_password */
                if (host->ar->get_password == NULL)
                    return sx_sasl_ret_FAIL;
            } else if (strcmp(mechbuf, ""plain"") == 0) {
                /* plain requires either get_password or check_password */
                if (host->ar->get_password == NULL && host->ar->check_password == NULL)
                    return sx_sasl_ret_FAIL;
            }

            /* Using SSF is potentially dangerous, as SASL can also set the
             * SSF of the connection. However, SASL shouldn't do so until after
             * we've finished mechanism establishment
             */
            if (s->ssf>0) {
                r = snprintf(buf, sizeof(buf), ""authreg.ssl-mechanisms.sasl.%s"",mechbuf);
                if (r < -1 || r > sizeof(buf))
                    return sx_sasl_ret_FAIL;
                if(config_get(c2s->config,buf) != NULL)
                    return sx_sasl_ret_OK;
            }

            r = snprintf(buf, sizeof(buf), ""authreg.mechanisms.sasl.%s"",mechbuf);
            if (r < -1 || r > sizeof(buf))
                return sx_sasl_ret_FAIL;

            /* Work out if our configuration will let us use this mechanism */
            if(config_get(c2s->config,buf) != NULL)
                return sx_sasl_ret_OK;
            else
                return sx_sasl_ret_FAIL;
        default:
            break;
    }

    return sx_sasl_ret_FAIL;
}
","static int _c2s_sx_sasl_callback(int cb, void *arg, void **res, sx_t s, void *cbarg) {
    c2s_t c2s = (c2s_t) cbarg;
    const char *my_realm, *mech;
    sx_sasl_creds_t creds;
    static char buf[3072];
    char mechbuf[256];
    struct jid_st jid;
    jid_static_buf jid_buf;
    int i, r;
    sess_t sess;
    char skey[44];
    host_t host;

    /* init static jid */
    jid_static(&jid,&jid_buf);

    /* retrieve our session */
    assert(s != NULL);
    sprintf(skey, ""%d"", s->tag);

    /*
     * Retrieve the session, note that depending on the operation,
     * session may be null.
     */
    sess = xhash_get(c2s->sessions, skey);

    switch(cb) {
        case sx_sasl_cb_GET_REALM:

            if(s->req_to == NULL)   /* this shouldn't happen */
                my_realm = """";

            else {
                /* get host for request */
                host = xhash_get(c2s->hosts, s->req_to);
                if(host == NULL) {
                    log_write(c2s->log, LOG_ERR, ""SASL callback for non-existing host: %s"", s->req_to);
                    *res = (void *)NULL;
                    return sx_sasl_ret_FAIL;
                }

                my_realm = host->realm;
                if(my_realm == NULL)
                    my_realm = s->req_to;
            }

            strncpy(buf, my_realm, 256);
            *res = (void *)buf;

            log_debug(ZONE, ""sx sasl callback: get realm: realm is '%s'"", buf);
            return sx_sasl_ret_OK;
            break;

        case sx_sasl_cb_GET_PASS:
            assert(sess != NULL);
            creds = (sx_sasl_creds_t) arg;

            log_debug(ZONE, ""sx sasl callback: get pass (authnid=%s, realm=%s)"", creds->authnid, creds->realm);

            if(sess->host->ar->get_password && (sess->host->ar->get_password)(
                        sess->host->ar, sess, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm: """", buf) == 0) {
                *res = buf;
                return sx_sasl_ret_OK;
            }

            return sx_sasl_ret_FAIL;

        case sx_sasl_cb_CHECK_PASS:
            assert(sess != NULL);
            creds = (sx_sasl_creds_t) arg;

            log_debug(ZONE, ""sx sasl callback: check pass (authnid=%s, realm=%s)"", creds->authnid, creds->realm);

            if(sess->host->ar->check_password != NULL) {
                if ((sess->host->ar->check_password)(
                            sess->host->ar, sess, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm : """", (char *)creds->pass) == 0)
                    return sx_sasl_ret_OK;
                else
                    return sx_sasl_ret_FAIL;
            }

            if(sess->host->ar->get_password != NULL) {
                if ((sess->host->ar->get_password)(sess->host->ar, sess, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm : """", buf) != 0)
                    return sx_sasl_ret_FAIL;

                if (strcmp(creds->pass, buf)==0)
                    return sx_sasl_ret_OK;
            }

            return sx_sasl_ret_FAIL;
            break;

        case sx_sasl_cb_CHECK_AUTHZID:
            assert(sess != NULL);
            creds = (sx_sasl_creds_t) arg;

            /* we need authzid to validate */
            if(creds->authzid == NULL || creds->authzid[0] == '\0')
                return sx_sasl_ret_FAIL;

            /* authzid must be a valid jid */
            if(jid_reset(&jid, creds->authzid, -1) == NULL)
                return sx_sasl_ret_FAIL;

            /* and have domain == stream to addr */
            if(!s->req_to || (strcmp(jid.domain, s->req_to) != 0))
                return sx_sasl_ret_FAIL;

            /* and have no resource */
            if(jid.resource[0] != '\0')
                return sx_sasl_ret_FAIL;

            /* and user has right to authorize as */
            if (sess->host->ar->user_authz_allowed) {
                if (sess->host->ar->user_authz_allowed(sess->host->ar, sess, (char *)creds->authnid, (char *)creds->realm, (char *)creds->authzid))
                        return sx_sasl_ret_OK;
            } else {
                if (strcmp(creds->authnid, jid.node) == 0 &&
                    (sess->host->ar->user_exists)(sess->host->ar, sess, jid.node, jid.domain))
                    return sx_sasl_ret_OK;
            }

            return sx_sasl_ret_FAIL;

        case sx_sasl_cb_GEN_AUTHZID:
            /* generate a jid for SASL ANONYMOUS */
            jid_reset(&jid, s->req_to, -1);

            /* make node a random string */
            jid_random_part(&jid, jid_NODE);

            strcpy(buf, jid.node);

            *res = (void *)buf;

            return sx_sasl_ret_OK;
            break;

        case sx_sasl_cb_CHECK_MECH:
            mech = (char *)arg;

            strncpy(mechbuf, mech, sizeof(mechbuf));
             mechbuf[sizeof(mechbuf)-1]='\0';
             for(i = 0; mechbuf[i]; i++) mechbuf[i] = tolower(mechbuf[i]);
 
             /* get host for request */
             host = xhash_get(c2s->hosts, s->req_to);
             if(host == NULL) {
                log_write(c2s->log, LOG_WARNING, ""SASL callback for non-existing host: %s"", s->req_to);
                return sx_sasl_ret_FAIL;
            }

            /* Determine if our configuration will let us use this mechanism.
             * We support different mechanisms for both SSL and normal use */
            if (strcmp(mechbuf, ""digest-md5"") == 0) {
                /* digest-md5 requires that our authreg support get_password */
                if (host->ar->get_password == NULL)
                    return sx_sasl_ret_FAIL;
            } else if (strcmp(mechbuf, ""plain"") == 0) {
                /* plain requires either get_password or check_password */
                if (host->ar->get_password == NULL && host->ar->check_password == NULL)
                    return sx_sasl_ret_FAIL;
            }

            /* Using SSF is potentially dangerous, as SASL can also set the
             * SSF of the connection. However, SASL shouldn't do so until after
             * we've finished mechanism establishment
             */
            if (s->ssf>0) {
                r = snprintf(buf, sizeof(buf), ""authreg.ssl-mechanisms.sasl.%s"",mechbuf);
                if (r < -1 || r > sizeof(buf))
                    return sx_sasl_ret_FAIL;
                if(config_get(c2s->config,buf) != NULL)
                    return sx_sasl_ret_OK;
            }

            r = snprintf(buf, sizeof(buf), ""authreg.mechanisms.sasl.%s"",mechbuf);
            if (r < -1 || r > sizeof(buf))
                return sx_sasl_ret_FAIL;

            /* Work out if our configuration will let us use this mechanism */
            if(config_get(c2s->config,buf) != NULL)
                return sx_sasl_ret_OK;
            else
                return sx_sasl_ret_FAIL;
        default:
            break;
    }

    return sx_sasl_ret_FAIL;
}
",C,"            log_debug(ZONE, ""sx sasl callback: check mech (mech=%s)"", mechbuf);

",,,"@@ -562,6 +562,8 @@ static int _c2s_sx_sasl_callback(int cb, void *arg, void **res, sx_t s, void *cb
             mechbuf[sizeof(mechbuf)-1]='\0';
             for(i = 0; mechbuf[i]; i++) mechbuf[i] = tolower(mechbuf[i]);
 
+            log_debug(ZONE, ""sx sasl callback: check mech (mech=%s)"", mechbuf);
+
             /* get host for request */
             host = xhash_get(c2s->hosts, s->req_to);
             if(host == NULL) {",jabberd2,8416ae54ecefa670534f27a31db71d048b9c7f16,e5c5518701e270070f974e5a9f5dc72ad9679e2e,1,"static int _c2s_sx_sasl_callback(int cb, void *arg, void **res, sx_t s, void *cbarg) {
    c2s_t c2s = (c2s_t) cbarg;
    const char *my_realm, *mech;
    sx_sasl_creds_t creds;
    static char buf[3072];
    char mechbuf[256];
    struct jid_st jid;
    jid_static_buf jid_buf;
    int i, r;
    sess_t sess;
    char skey[44];
    host_t host;

    /* init static jid */
    jid_static(&jid,&jid_buf);

    /* retrieve our session */
    assert(s != NULL);
    sprintf(skey, ""%d"", s->tag);

    /*
     * Retrieve the session, note that depending on the operation,
     * session may be null.
     */
    sess = xhash_get(c2s->sessions, skey);

    switch(cb) {
        case sx_sasl_cb_GET_REALM:

            if(s->req_to == NULL)   /* this shouldn't happen */
                my_realm = """";

            else {
                /* get host for request */
                host = xhash_get(c2s->hosts, s->req_to);
                if(host == NULL) {
                    log_write(c2s->log, LOG_ERR, ""SASL callback for non-existing host: %s"", s->req_to);
                    *res = (void *)NULL;
                    return sx_sasl_ret_FAIL;
                }

                my_realm = host->realm;
                if(my_realm == NULL)
                    my_realm = s->req_to;
            }

            strncpy(buf, my_realm, 256);
            *res = (void *)buf;

            log_debug(ZONE, ""sx sasl callback: get realm: realm is '%s'"", buf);
            return sx_sasl_ret_OK;
            break;

        case sx_sasl_cb_GET_PASS:
            assert(sess != NULL);
            creds = (sx_sasl_creds_t) arg;

            log_debug(ZONE, ""sx sasl callback: get pass (authnid=%s, realm=%s)"", creds->authnid, creds->realm);

            if(sess->host->ar->get_password && (sess->host->ar->get_password)(
                        sess->host->ar, sess, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm: """", buf) == 0) {
                *res = buf;
                return sx_sasl_ret_OK;
            }

            return sx_sasl_ret_FAIL;

        case sx_sasl_cb_CHECK_PASS:
            assert(sess != NULL);
            creds = (sx_sasl_creds_t) arg;

            log_debug(ZONE, ""sx sasl callback: check pass (authnid=%s, realm=%s)"", creds->authnid, creds->realm);

            if(sess->host->ar->check_password != NULL) {
                if ((sess->host->ar->check_password)(
                            sess->host->ar, sess, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm : """", (char *)creds->pass) == 0)
                    return sx_sasl_ret_OK;
                else
                    return sx_sasl_ret_FAIL;
            }

            if(sess->host->ar->get_password != NULL) {
                if ((sess->host->ar->get_password)(sess->host->ar, sess, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm : """", buf) != 0)
                    return sx_sasl_ret_FAIL;

                if (strcmp(creds->pass, buf)==0)
                    return sx_sasl_ret_OK;
            }

            return sx_sasl_ret_FAIL;
            break;

        case sx_sasl_cb_CHECK_AUTHZID:
            assert(sess != NULL);
            creds = (sx_sasl_creds_t) arg;

            /* we need authzid to validate */
            if(creds->authzid == NULL || creds->authzid[0] == '\0')
                return sx_sasl_ret_FAIL;

            /* authzid must be a valid jid */
            if(jid_reset(&jid, creds->authzid, -1) == NULL)
                return sx_sasl_ret_FAIL;

            /* and have domain == stream to addr */
            if(!s->req_to || (strcmp(jid.domain, s->req_to) != 0))
                return sx_sasl_ret_FAIL;

            /* and have no resource */
            if(jid.resource[0] != '\0')
                return sx_sasl_ret_FAIL;

            /* and user has right to authorize as */
            if (sess->host->ar->user_authz_allowed) {
                if (sess->host->ar->user_authz_allowed(sess->host->ar, sess, (char *)creds->authnid, (char *)creds->realm, (char *)creds->authzid))
                        return sx_sasl_ret_OK;
            } else {
                if (strcmp(creds->authnid, jid.node) == 0 &&
                    (sess->host->ar->user_exists)(sess->host->ar, sess, jid.node, jid.domain))
                    return sx_sasl_ret_OK;
            }

            return sx_sasl_ret_FAIL;

        case sx_sasl_cb_GEN_AUTHZID:
            /* generate a jid for SASL ANONYMOUS */
            jid_reset(&jid, s->req_to, -1);

            /* make node a random string */
            jid_random_part(&jid, jid_NODE);

            strcpy(buf, jid.node);

            *res = (void *)buf;

            return sx_sasl_ret_OK;
            break;

        case sx_sasl_cb_CHECK_MECH:
            mech = (char *)arg;

            strncpy(mechbuf, mech, sizeof(mechbuf));
             mechbuf[sizeof(mechbuf)-1]='\0';
             for(i = 0; mechbuf[i]; i++) mechbuf[i] = tolower(mechbuf[i]);
 
//fix_flaw_line_below:
//            log_debug(ZONE, ""sx sasl callback: check mech (mech=%s)"", mechbuf);
//fix_flaw_line_below:
//
             /* get host for request */
             host = xhash_get(c2s->hosts, s->req_to);
             if(host == NULL) {
                log_write(c2s->log, LOG_WARNING, ""SASL callback for non-existing host: %s"", s->req_to);
                return sx_sasl_ret_FAIL;
            }

            /* Determine if our configuration will let us use this mechanism.
             * We support different mechanisms for both SSL and normal use */
            if (strcmp(mechbuf, ""digest-md5"") == 0) {
                /* digest-md5 requires that our authreg support get_password */
                if (host->ar->get_password == NULL)
                    return sx_sasl_ret_FAIL;
            } else if (strcmp(mechbuf, ""plain"") == 0) {
                /* plain requires either get_password or check_password */
                if (host->ar->get_password == NULL && host->ar->check_password == NULL)
                    return sx_sasl_ret_FAIL;
            }

            /* Using SSF is potentially dangerous, as SASL can also set the
             * SSF of the connection. However, SASL shouldn't do so until after
             * we've finished mechanism establishment
             */
            if (s->ssf>0) {
                r = snprintf(buf, sizeof(buf), ""authreg.ssl-mechanisms.sasl.%s"",mechbuf);
                if (r < -1 || r > sizeof(buf))
                    return sx_sasl_ret_FAIL;
                if(config_get(c2s->config,buf) != NULL)
                    return sx_sasl_ret_OK;
            }

            r = snprintf(buf, sizeof(buf), ""authreg.mechanisms.sasl.%s"",mechbuf);
            if (r < -1 || r > sizeof(buf))
                return sx_sasl_ret_FAIL;

            /* Work out if our configuration will let us use this mechanism */
            if(config_get(c2s->config,buf) != NULL)
                return sx_sasl_ret_OK;
            else
                return sx_sasl_ret_FAIL;
        default:
            break;
    }

    return sx_sasl_ret_FAIL;
}
"
3498,181234,,Remote,Not required,Partial,CVE-2017-10807,https://www.cvedetails.com/cve/CVE-2017-10807/,CWE-287,Low,Partial,Partial,,2017-07-04,7.5,"JabberD 2.x (aka jabberd2) before 2.6.1 allows anyone to authenticate using SASL ANONYMOUS, even when the sasl.anonymous c2s.xml option is not enabled.",2017-11-03,,1,https://github.com/jabberd2/jabberd2/commit/8416ae54ecefa670534f27a31db71d048b9c7f16,8416ae54ecefa670534f27a31db71d048b9c7f16,Fixed offered SASL mechanism check,1,sx/sasl.c,"{""sha"": ""7972c5474f8eed00a529fb2c94d025a0cc1ab43b"", ""filename"": ""c2s/main.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/jabberd2/jabberd2/blob/8416ae54ecefa670534f27a31db71d048b9c7f16/c2s/main.c"", ""raw_url"": ""https://github.com/jabberd2/jabberd2/raw/8416ae54ecefa670534f27a31db71d048b9c7f16/c2s/main.c"", ""contents_url"": ""https://api.github.com/repos/jabberd2/jabberd2/contents/c2s/main.c?ref=8416ae54ecefa670534f27a31db71d048b9c7f16"", ""patch"": ""@@ -562,6 +562,8 @@ static int _c2s_sx_sasl_callback(int cb, void *arg, void **res, sx_t s, void *cb\n             mechbuf[sizeof(mechbuf)-1]='\\0';\n             for(i = 0; mechbuf[i]; i++) mechbuf[i] = tolower(mechbuf[i]);\n \n+            log_debug(ZONE, \""sx sasl callback: check mech (mech=%s)\"", mechbuf);\n+\n             /* get host for request */\n             host = xhash_get(c2s->hosts, s->req_to);\n             if(host == NULL) {""}<_**next**_>{""sha"": ""d52f6afabe971ee62363869e88d1e5569b4ab57d"", ""filename"": ""sx/sasl.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/jabberd2/jabberd2/blob/8416ae54ecefa670534f27a31db71d048b9c7f16/sx/sasl.c"", ""raw_url"": ""https://github.com/jabberd2/jabberd2/raw/8416ae54ecefa670534f27a31db71d048b9c7f16/sx/sasl.c"", ""contents_url"": ""https://api.github.com/repos/jabberd2/jabberd2/contents/sx/sasl.c?ref=8416ae54ecefa670534f27a31db71d048b9c7f16"", ""patch"": ""@@ -332,7 +332,7 @@ static void _sx_sasl_client_process(sx_t s, sx_plugin_t p, Gsasl_session *sd, co\n     if(mech != NULL) {\n         _sx_debug(ZONE, \""auth request from client (mechanism=%s)\"", mech);\n \n-        if(!gsasl_server_support_p(ctx->gsasl_ctx, mech)) {\n+        if(!gsasl_server_support_p(ctx->gsasl_ctx, mech) || (ctx->cb)(sx_sasl_cb_CHECK_MECH, (void*)mech, NULL, s, ctx->cbarg) != sx_sasl_ret_OK) {\n              _sx_debug(ZONE, \""client requested mechanism (%s) that we didn't offer\"", mech);\n              _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INVALID_MECHANISM, NULL), 0);\n              return;""}","static void _sx_sasl_client_process(sx_t s, sx_plugin_t p, Gsasl_session *sd, const char *mech, const char *in, int inlen) {
    _sx_sasl_t ctx = (_sx_sasl_t) p->private;
    _sx_sasl_sess_t sctx = NULL;
    char *buf = NULL, *out = NULL, *realm = NULL, **ext_id;
    char hostname[256];
    int ret;
#ifdef HAVE_SSL
    int i;
#endif
    size_t buflen, outlen;

    assert(ctx);
    assert(ctx->cb);

     if(mech != NULL) {
         _sx_debug(ZONE, ""auth request from client (mechanism=%s)"", mech);
 
        if(!gsasl_server_support_p(ctx->gsasl_ctx, mech) || (ctx->cb)(sx_sasl_cb_CHECK_MECH, (void*)mech, NULL, s, ctx->cbarg) != sx_sasl_ret_OK) {
              _sx_debug(ZONE, ""client requested mechanism (%s) that we didn't offer"", mech);
              _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INVALID_MECHANISM, NULL), 0);
              return;
        }

        /* startup */
        ret = gsasl_server_start(ctx->gsasl_ctx, mech, &sd);
        if(ret != GSASL_OK) {
            _sx_debug(ZONE, ""gsasl_server_start failed, no sasl for this conn; (%d): %s"", ret, gsasl_strerror(ret));
            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_TEMPORARY_FAILURE, gsasl_strerror(ret)), 0);
            return;
        }

        /* get the realm */
        (ctx->cb)(sx_sasl_cb_GET_REALM, NULL, (void **) &realm, s, ctx->cbarg);

        /* cleanup any existing session context */
        sctx = gsasl_session_hook_get(sd);
        if (sctx != NULL) free(sctx);

        /* allocate and initialize our per session context */
        sctx = (_sx_sasl_sess_t) calloc(1, sizeof(struct _sx_sasl_sess_st));
        sctx->s = s;
        sctx->ctx = ctx;
        gsasl_session_hook_set(sd, (void *) sctx);
        gsasl_property_set(sd, GSASL_SERVICE, ctx->appname);
        gsasl_property_set(sd, GSASL_REALM, realm);

        /* get hostname */
        hostname[0] = '\0';
        gethostname(hostname, 256);
        hostname[255] = '\0';
        gsasl_property_set(sd, GSASL_HOSTNAME, hostname);

        /* get EXTERNAL data from the ssl plugin */
        ext_id = NULL;
#ifdef HAVE_SSL
        for(i = 0; i < s->env->nplugins; i++)
            if(s->env->plugins[i]->magic == SX_SSL_MAGIC && s->plugin_data[s->env->plugins[i]->index] != NULL)
                ext_id = ((_sx_ssl_conn_t) s->plugin_data[s->env->plugins[i]->index])->external_id;
        if (ext_id != NULL) {
            /* if there is, store it for later */
            for (i = 0; i < SX_CONN_EXTERNAL_ID_MAX_COUNT; i++)
                if (ext_id[i] != NULL) {
                    ctx->ext_id[i] = strdup(ext_id[i]);
                } else {
                    ctx->ext_id[i] = NULL;
                    break;
                }
        }
#endif

        _sx_debug(ZONE, ""sasl context initialised for %d"", s->tag);

        s->plugin_data[p->index] = (void *) sd;

        if(strcmp(mech, ""ANONYMOUS"") == 0) {
            /*
             * special case for SASL ANONYMOUS: ignore the initial
             * response provided by the client and generate a random
             * authid to use as the jid node for the user, as
             * specified in XEP-0175
             */
            (ctx->cb)(sx_sasl_cb_GEN_AUTHZID, NULL, (void **)&out, s, ctx->cbarg);
            buf = strdup(out);
            buflen = strlen(buf);
        } else if (strstr(in, ""<"") != NULL && strncmp(in, ""="", strstr(in, ""<"") - in ) == 0) {
            /* XXX The above check is hackish, but `in` is just weird */
            /* This is a special case for SASL External c2s. See XEP-0178 */
            _sx_debug(ZONE, ""gsasl auth string is empty"");
            buf = strdup("""");
            buflen = strlen(buf);
        } else {
            /* decode and process */
            ret = gsasl_base64_from(in, inlen, &buf, &buflen);
            if (ret != GSASL_OK) {
                _sx_debug(ZONE, ""gsasl_base64_from failed, no sasl for this conn; (%d): %s"", ret, gsasl_strerror(ret));
                _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);
                if(buf != NULL) free(buf);
                return;
            }
        }

        ret = gsasl_step(sd, buf, buflen, &out, &outlen);
    }

    else {
        /* decode and process */
        ret = gsasl_base64_from(in, inlen, &buf, &buflen);
        if (ret != GSASL_OK) {
            _sx_debug(ZONE, ""gsasl_base64_from failed, no sasl for this conn; (%d): %s"", ret, gsasl_strerror(ret));
            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);
            return;
        }

        if(!sd) {
            _sx_debug(ZONE, ""response send before auth request enabling mechanism (decoded: %.*s)"", buflen, buf);
            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_MECH_TOO_WEAK, ""response send before auth request enabling mechanism""), 0);
            if(buf != NULL) free(buf);
            return;
        }
        _sx_debug(ZONE, ""response from client (decoded: %.*s)"", buflen, buf);
        ret = gsasl_step(sd, buf, buflen, &out, &outlen);
    }

    if(buf != NULL) free(buf);

    /* auth completed */
    if(ret == GSASL_OK) {
        _sx_debug(ZONE, ""sasl handshake completed"");

        /* encode the leftover response */
        ret = gsasl_base64_to(out, outlen, &buf, &buflen);
        if (ret == GSASL_OK) {
            /* send success */
            _sx_nad_write(s, _sx_sasl_success(s, buf, buflen), 0);
            free(buf);

            /* set a notify on the success nad buffer */
            ((sx_buf_t) s->wbufq->front->data)->notify = _sx_sasl_notify_success;
            ((sx_buf_t) s->wbufq->front->data)->notify_arg = (void *) p;
        }
        else {
            _sx_debug(ZONE, ""gsasl_base64_to failed, no sasl for this conn; (%d): %s"", ret, gsasl_strerror(ret));
            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);
            if(buf != NULL) free(buf);
        }

        if(out != NULL) free(out);

        return;
    }

    /* in progress */
    if(ret == GSASL_NEEDS_MORE) {
        _sx_debug(ZONE, ""sasl handshake in progress (challenge: %.*s)"", outlen, out);

        /* encode the challenge */
        ret = gsasl_base64_to(out, outlen, &buf, &buflen);
        if (ret == GSASL_OK) {
            _sx_nad_write(s, _sx_sasl_challenge(s, buf, buflen), 0);
            free(buf);
        }
        else {
            _sx_debug(ZONE, ""gsasl_base64_to failed, no sasl for this conn; (%d): %s"", ret, gsasl_strerror(ret));
            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);
            if(buf != NULL) free(buf);
        }

        if(out != NULL) free(out);

        return;
    }

    if(out != NULL) free(out);

    /* its over */
    _sx_debug(ZONE, ""sasl handshake failed; (%d): %s"", ret, gsasl_strerror(ret));

    switch (ret) {
        case GSASL_AUTHENTICATION_ERROR:
	case GSASL_NO_ANONYMOUS_TOKEN:
	case GSASL_NO_AUTHID:
	case GSASL_NO_AUTHZID:
	case GSASL_NO_PASSWORD:
	case GSASL_NO_PASSCODE:
	case GSASL_NO_PIN:
	case GSASL_NO_SERVICE:
	case GSASL_NO_HOSTNAME:
            out = _sasl_err_NOT_AUTHORIZED;
            break;
	case GSASL_UNKNOWN_MECHANISM:
	case GSASL_MECHANISM_PARSE_ERROR:
            out = _sasl_err_INVALID_MECHANISM;
            break;
	case GSASL_BASE64_ERROR:
            out = _sasl_err_INCORRECT_ENCODING;
            break;
        default:
            out = _sasl_err_MALFORMED_REQUEST;
    }
    _sx_nad_write(s, _sx_sasl_failure(s, out, gsasl_strerror(ret)), 0);
}
","static void _sx_sasl_client_process(sx_t s, sx_plugin_t p, Gsasl_session *sd, const char *mech, const char *in, int inlen) {
    _sx_sasl_t ctx = (_sx_sasl_t) p->private;
    _sx_sasl_sess_t sctx = NULL;
    char *buf = NULL, *out = NULL, *realm = NULL, **ext_id;
    char hostname[256];
    int ret;
#ifdef HAVE_SSL
    int i;
#endif
    size_t buflen, outlen;

    assert(ctx);
    assert(ctx->cb);

     if(mech != NULL) {
         _sx_debug(ZONE, ""auth request from client (mechanism=%s)"", mech);
 
        if(!gsasl_server_support_p(ctx->gsasl_ctx, mech)) {
              _sx_debug(ZONE, ""client requested mechanism (%s) that we didn't offer"", mech);
              _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INVALID_MECHANISM, NULL), 0);
              return;
        }

        /* startup */
        ret = gsasl_server_start(ctx->gsasl_ctx, mech, &sd);
        if(ret != GSASL_OK) {
            _sx_debug(ZONE, ""gsasl_server_start failed, no sasl for this conn; (%d): %s"", ret, gsasl_strerror(ret));
            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_TEMPORARY_FAILURE, gsasl_strerror(ret)), 0);
            return;
        }

        /* get the realm */
        (ctx->cb)(sx_sasl_cb_GET_REALM, NULL, (void **) &realm, s, ctx->cbarg);

        /* cleanup any existing session context */
        sctx = gsasl_session_hook_get(sd);
        if (sctx != NULL) free(sctx);

        /* allocate and initialize our per session context */
        sctx = (_sx_sasl_sess_t) calloc(1, sizeof(struct _sx_sasl_sess_st));
        sctx->s = s;
        sctx->ctx = ctx;
        gsasl_session_hook_set(sd, (void *) sctx);
        gsasl_property_set(sd, GSASL_SERVICE, ctx->appname);
        gsasl_property_set(sd, GSASL_REALM, realm);

        /* get hostname */
        hostname[0] = '\0';
        gethostname(hostname, 256);
        hostname[255] = '\0';
        gsasl_property_set(sd, GSASL_HOSTNAME, hostname);

        /* get EXTERNAL data from the ssl plugin */
        ext_id = NULL;
#ifdef HAVE_SSL
        for(i = 0; i < s->env->nplugins; i++)
            if(s->env->plugins[i]->magic == SX_SSL_MAGIC && s->plugin_data[s->env->plugins[i]->index] != NULL)
                ext_id = ((_sx_ssl_conn_t) s->plugin_data[s->env->plugins[i]->index])->external_id;
        if (ext_id != NULL) {
            /* if there is, store it for later */
            for (i = 0; i < SX_CONN_EXTERNAL_ID_MAX_COUNT; i++)
                if (ext_id[i] != NULL) {
                    ctx->ext_id[i] = strdup(ext_id[i]);
                } else {
                    ctx->ext_id[i] = NULL;
                    break;
                }
        }
#endif

        _sx_debug(ZONE, ""sasl context initialised for %d"", s->tag);

        s->plugin_data[p->index] = (void *) sd;

        if(strcmp(mech, ""ANONYMOUS"") == 0) {
            /*
             * special case for SASL ANONYMOUS: ignore the initial
             * response provided by the client and generate a random
             * authid to use as the jid node for the user, as
             * specified in XEP-0175
             */
            (ctx->cb)(sx_sasl_cb_GEN_AUTHZID, NULL, (void **)&out, s, ctx->cbarg);
            buf = strdup(out);
            buflen = strlen(buf);
        } else if (strstr(in, ""<"") != NULL && strncmp(in, ""="", strstr(in, ""<"") - in ) == 0) {
            /* XXX The above check is hackish, but `in` is just weird */
            /* This is a special case for SASL External c2s. See XEP-0178 */
            _sx_debug(ZONE, ""gsasl auth string is empty"");
            buf = strdup("""");
            buflen = strlen(buf);
        } else {
            /* decode and process */
            ret = gsasl_base64_from(in, inlen, &buf, &buflen);
            if (ret != GSASL_OK) {
                _sx_debug(ZONE, ""gsasl_base64_from failed, no sasl for this conn; (%d): %s"", ret, gsasl_strerror(ret));
                _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);
                if(buf != NULL) free(buf);
                return;
            }
        }

        ret = gsasl_step(sd, buf, buflen, &out, &outlen);
    }

    else {
        /* decode and process */
        ret = gsasl_base64_from(in, inlen, &buf, &buflen);
        if (ret != GSASL_OK) {
            _sx_debug(ZONE, ""gsasl_base64_from failed, no sasl for this conn; (%d): %s"", ret, gsasl_strerror(ret));
            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);
            return;
        }

        if(!sd) {
            _sx_debug(ZONE, ""response send before auth request enabling mechanism (decoded: %.*s)"", buflen, buf);
            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_MECH_TOO_WEAK, ""response send before auth request enabling mechanism""), 0);
            if(buf != NULL) free(buf);
            return;
        }
        _sx_debug(ZONE, ""response from client (decoded: %.*s)"", buflen, buf);
        ret = gsasl_step(sd, buf, buflen, &out, &outlen);
    }

    if(buf != NULL) free(buf);

    /* auth completed */
    if(ret == GSASL_OK) {
        _sx_debug(ZONE, ""sasl handshake completed"");

        /* encode the leftover response */
        ret = gsasl_base64_to(out, outlen, &buf, &buflen);
        if (ret == GSASL_OK) {
            /* send success */
            _sx_nad_write(s, _sx_sasl_success(s, buf, buflen), 0);
            free(buf);

            /* set a notify on the success nad buffer */
            ((sx_buf_t) s->wbufq->front->data)->notify = _sx_sasl_notify_success;
            ((sx_buf_t) s->wbufq->front->data)->notify_arg = (void *) p;
        }
        else {
            _sx_debug(ZONE, ""gsasl_base64_to failed, no sasl for this conn; (%d): %s"", ret, gsasl_strerror(ret));
            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);
            if(buf != NULL) free(buf);
        }

        if(out != NULL) free(out);

        return;
    }

    /* in progress */
    if(ret == GSASL_NEEDS_MORE) {
        _sx_debug(ZONE, ""sasl handshake in progress (challenge: %.*s)"", outlen, out);

        /* encode the challenge */
        ret = gsasl_base64_to(out, outlen, &buf, &buflen);
        if (ret == GSASL_OK) {
            _sx_nad_write(s, _sx_sasl_challenge(s, buf, buflen), 0);
            free(buf);
        }
        else {
            _sx_debug(ZONE, ""gsasl_base64_to failed, no sasl for this conn; (%d): %s"", ret, gsasl_strerror(ret));
            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);
            if(buf != NULL) free(buf);
        }

        if(out != NULL) free(out);

        return;
    }

    if(out != NULL) free(out);

    /* its over */
    _sx_debug(ZONE, ""sasl handshake failed; (%d): %s"", ret, gsasl_strerror(ret));

    switch (ret) {
        case GSASL_AUTHENTICATION_ERROR:
	case GSASL_NO_ANONYMOUS_TOKEN:
	case GSASL_NO_AUTHID:
	case GSASL_NO_AUTHZID:
	case GSASL_NO_PASSWORD:
	case GSASL_NO_PASSCODE:
	case GSASL_NO_PIN:
	case GSASL_NO_SERVICE:
	case GSASL_NO_HOSTNAME:
            out = _sasl_err_NOT_AUTHORIZED;
            break;
	case GSASL_UNKNOWN_MECHANISM:
	case GSASL_MECHANISM_PARSE_ERROR:
            out = _sasl_err_INVALID_MECHANISM;
            break;
	case GSASL_BASE64_ERROR:
            out = _sasl_err_INCORRECT_ENCODING;
            break;
        default:
            out = _sasl_err_MALFORMED_REQUEST;
    }
    _sx_nad_write(s, _sx_sasl_failure(s, out, gsasl_strerror(ret)), 0);
}
",C,"        if(!gsasl_server_support_p(ctx->gsasl_ctx, mech) || (ctx->cb)(sx_sasl_cb_CHECK_MECH, (void*)mech, NULL, s, ctx->cbarg) != sx_sasl_ret_OK) {
","        if(!gsasl_server_support_p(ctx->gsasl_ctx, mech)) {
",,"@@ -332,7 +332,7 @@ static void _sx_sasl_client_process(sx_t s, sx_plugin_t p, Gsasl_session *sd, co
     if(mech != NULL) {
         _sx_debug(ZONE, ""auth request from client (mechanism=%s)"", mech);
 
-        if(!gsasl_server_support_p(ctx->gsasl_ctx, mech)) {
+        if(!gsasl_server_support_p(ctx->gsasl_ctx, mech) || (ctx->cb)(sx_sasl_cb_CHECK_MECH, (void*)mech, NULL, s, ctx->cbarg) != sx_sasl_ret_OK) {
              _sx_debug(ZONE, ""client requested mechanism (%s) that we didn't offer"", mech);
              _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INVALID_MECHANISM, NULL), 0);
              return;",jabberd2,8416ae54ecefa670534f27a31db71d048b9c7f16,e5c5518701e270070f974e5a9f5dc72ad9679e2e,1,"static void _sx_sasl_client_process(sx_t s, sx_plugin_t p, Gsasl_session *sd, const char *mech, const char *in, int inlen) {
    _sx_sasl_t ctx = (_sx_sasl_t) p->private;
    _sx_sasl_sess_t sctx = NULL;
    char *buf = NULL, *out = NULL, *realm = NULL, **ext_id;
    char hostname[256];
    int ret;
#ifdef HAVE_SSL
    int i;
#endif
    size_t buflen, outlen;

    assert(ctx);
    assert(ctx->cb);

     if(mech != NULL) {
         _sx_debug(ZONE, ""auth request from client (mechanism=%s)"", mech);
 
//flaw_line_below:
        if(!gsasl_server_support_p(ctx->gsasl_ctx, mech)) {
//fix_flaw_line_below:
//        if(!gsasl_server_support_p(ctx->gsasl_ctx, mech) || (ctx->cb)(sx_sasl_cb_CHECK_MECH, (void*)mech, NULL, s, ctx->cbarg) != sx_sasl_ret_OK) {
              _sx_debug(ZONE, ""client requested mechanism (%s) that we didn't offer"", mech);
              _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INVALID_MECHANISM, NULL), 0);
              return;
        }

        /* startup */
        ret = gsasl_server_start(ctx->gsasl_ctx, mech, &sd);
        if(ret != GSASL_OK) {
            _sx_debug(ZONE, ""gsasl_server_start failed, no sasl for this conn; (%d): %s"", ret, gsasl_strerror(ret));
            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_TEMPORARY_FAILURE, gsasl_strerror(ret)), 0);
            return;
        }

        /* get the realm */
        (ctx->cb)(sx_sasl_cb_GET_REALM, NULL, (void **) &realm, s, ctx->cbarg);

        /* cleanup any existing session context */
        sctx = gsasl_session_hook_get(sd);
        if (sctx != NULL) free(sctx);

        /* allocate and initialize our per session context */
        sctx = (_sx_sasl_sess_t) calloc(1, sizeof(struct _sx_sasl_sess_st));
        sctx->s = s;
        sctx->ctx = ctx;
        gsasl_session_hook_set(sd, (void *) sctx);
        gsasl_property_set(sd, GSASL_SERVICE, ctx->appname);
        gsasl_property_set(sd, GSASL_REALM, realm);

        /* get hostname */
        hostname[0] = '\0';
        gethostname(hostname, 256);
        hostname[255] = '\0';
        gsasl_property_set(sd, GSASL_HOSTNAME, hostname);

        /* get EXTERNAL data from the ssl plugin */
        ext_id = NULL;
#ifdef HAVE_SSL
        for(i = 0; i < s->env->nplugins; i++)
            if(s->env->plugins[i]->magic == SX_SSL_MAGIC && s->plugin_data[s->env->plugins[i]->index] != NULL)
                ext_id = ((_sx_ssl_conn_t) s->plugin_data[s->env->plugins[i]->index])->external_id;
        if (ext_id != NULL) {
            //_sx_debug(ZONE, ""sasl context ext id '%s'"", ext_id);
            /* if there is, store it for later */
            for (i = 0; i < SX_CONN_EXTERNAL_ID_MAX_COUNT; i++)
                if (ext_id[i] != NULL) {
                    ctx->ext_id[i] = strdup(ext_id[i]);
                } else {
                    ctx->ext_id[i] = NULL;
                    break;
                }
        }
#endif

        _sx_debug(ZONE, ""sasl context initialised for %d"", s->tag);

        s->plugin_data[p->index] = (void *) sd;

        if(strcmp(mech, ""ANONYMOUS"") == 0) {
            /*
             * special case for SASL ANONYMOUS: ignore the initial
             * response provided by the client and generate a random
             * authid to use as the jid node for the user, as
             * specified in XEP-0175
             */
            (ctx->cb)(sx_sasl_cb_GEN_AUTHZID, NULL, (void **)&out, s, ctx->cbarg);
            buf = strdup(out);
            buflen = strlen(buf);
        } else if (strstr(in, ""<"") != NULL && strncmp(in, ""="", strstr(in, ""<"") - in ) == 0) {
            /* XXX The above check is hackish, but `in` is just weird */
            /* This is a special case for SASL External c2s. See XEP-0178 */
            _sx_debug(ZONE, ""gsasl auth string is empty"");
            buf = strdup("""");
            buflen = strlen(buf);
        } else {
            /* decode and process */
            ret = gsasl_base64_from(in, inlen, &buf, &buflen);
            if (ret != GSASL_OK) {
                _sx_debug(ZONE, ""gsasl_base64_from failed, no sasl for this conn; (%d): %s"", ret, gsasl_strerror(ret));
                _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);
                if(buf != NULL) free(buf);
                return;
            }
        }

        ret = gsasl_step(sd, buf, buflen, &out, &outlen);
    }

    else {
        /* decode and process */
        ret = gsasl_base64_from(in, inlen, &buf, &buflen);
        if (ret != GSASL_OK) {
            _sx_debug(ZONE, ""gsasl_base64_from failed, no sasl for this conn; (%d): %s"", ret, gsasl_strerror(ret));
            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);
            return;
        }

        if(!sd) {
            _sx_debug(ZONE, ""response send before auth request enabling mechanism (decoded: %.*s)"", buflen, buf);
            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_MECH_TOO_WEAK, ""response send before auth request enabling mechanism""), 0);
            if(buf != NULL) free(buf);
            return;
        }
        _sx_debug(ZONE, ""response from client (decoded: %.*s)"", buflen, buf);
        ret = gsasl_step(sd, buf, buflen, &out, &outlen);
    }

    if(buf != NULL) free(buf);

    /* auth completed */
    if(ret == GSASL_OK) {
        _sx_debug(ZONE, ""sasl handshake completed"");

        /* encode the leftover response */
        ret = gsasl_base64_to(out, outlen, &buf, &buflen);
        if (ret == GSASL_OK) {
            /* send success */
            _sx_nad_write(s, _sx_sasl_success(s, buf, buflen), 0);
            free(buf);

            /* set a notify on the success nad buffer */
            ((sx_buf_t) s->wbufq->front->data)->notify = _sx_sasl_notify_success;
            ((sx_buf_t) s->wbufq->front->data)->notify_arg = (void *) p;
        }
        else {
            _sx_debug(ZONE, ""gsasl_base64_to failed, no sasl for this conn; (%d): %s"", ret, gsasl_strerror(ret));
            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);
            if(buf != NULL) free(buf);
        }

        if(out != NULL) free(out);

        return;
    }

    /* in progress */
    if(ret == GSASL_NEEDS_MORE) {
        _sx_debug(ZONE, ""sasl handshake in progress (challenge: %.*s)"", outlen, out);

        /* encode the challenge */
        ret = gsasl_base64_to(out, outlen, &buf, &buflen);
        if (ret == GSASL_OK) {
            _sx_nad_write(s, _sx_sasl_challenge(s, buf, buflen), 0);
            free(buf);
        }
        else {
            _sx_debug(ZONE, ""gsasl_base64_to failed, no sasl for this conn; (%d): %s"", ret, gsasl_strerror(ret));
            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);
            if(buf != NULL) free(buf);
        }

        if(out != NULL) free(out);

        return;
    }

    if(out != NULL) free(out);

    /* its over */
    _sx_debug(ZONE, ""sasl handshake failed; (%d): %s"", ret, gsasl_strerror(ret));

    switch (ret) {
        case GSASL_AUTHENTICATION_ERROR:
	case GSASL_NO_ANONYMOUS_TOKEN:
	case GSASL_NO_AUTHID:
	case GSASL_NO_AUTHZID:
	case GSASL_NO_PASSWORD:
	case GSASL_NO_PASSCODE:
	case GSASL_NO_PIN:
	case GSASL_NO_SERVICE:
	case GSASL_NO_HOSTNAME:
            out = _sasl_err_NOT_AUTHORIZED;
            break;
	case GSASL_UNKNOWN_MECHANISM:
	case GSASL_MECHANISM_PARSE_ERROR:
            out = _sasl_err_INVALID_MECHANISM;
            break;
	case GSASL_BASE64_ERROR:
            out = _sasl_err_INCORRECT_ENCODING;
            break;
        default:
            out = _sasl_err_MALFORMED_REQUEST;
    }
    _sx_nad_write(s, _sx_sasl_failure(s, out, gsasl_strerror(ret)), 0);
}
"
4249,181985,,Remote,Not required,Partial,CVE-2016-7145,https://www.cvedetails.com/cve/CVE-2016-7145/,CWE-287,Low,Partial,Partial,,2017-03-07,7.5,The m_authenticate function in ircd/m_authenticate.c in nefarious2 allows remote attackers to spoof certificate fingerprints and consequently log in as another user via a crafted AUTHENTICATE parameter.,2017-03-08,,4,https://github.com/evilnet/nefarious2/commit/f50a84bad996d438e7b31b9e74c32a41e43f8be5,f50a84bad996d438e7b31b9e74c32a41e43f8be5,Fix to prevent SASL security vulnerability,0,ircd/m_authenticate.c,"{""sha"": ""f8960bd54da617d368a6e9d634d72f613780db6c"", ""filename"": ""ircd/m_authenticate.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/evilnet/nefarious2/blob/f50a84bad996d438e7b31b9e74c32a41e43f8be5/ircd/m_authenticate.c"", ""raw_url"": ""https://github.com/evilnet/nefarious2/raw/f50a84bad996d438e7b31b9e74c32a41e43f8be5/ircd/m_authenticate.c"", ""contents_url"": ""https://api.github.com/repos/evilnet/nefarious2/contents/ircd/m_authenticate.c?ref=f50a84bad996d438e7b31b9e74c32a41e43f8be5"", ""patch"": ""@@ -150,6 +150,8 @@ int m_authenticate(struct Client* cptr, struct Client* sptr, int parc, char* par\n \n   if (acptr) {\n     if (first) {\n+      if (*parv[1] == ':' || strchr(parv[1], ' '))\n+\t\treturn exit_client(cptr, sptr, sptr, \""Malformed AUTHENTICATE\"");\n       if (!EmptyString(cli_sslclifp(cptr)))\n         sendcmdto_one(&me, CMD_SASL, acptr, \""%C %C!%u.%u S %s :%s\"", acptr, &me,\n                       cli_fd(cptr), cli_saslcookie(cptr),\n@@ -167,6 +169,8 @@ int m_authenticate(struct Client* cptr, struct Client* sptr, int parc, char* par\n     }\n   } else {\n     if (first) {\n+      if (*parv[1] == ':' || strchr(parv[1], ' '))\n+        return exit_client(cptr, sptr, sptr, \""Malformed AUTHENTICATE\"");\n       if (!EmptyString(cli_sslclifp(cptr)))\n         sendcmdto_serv_butone(&me, CMD_SASL, cptr, \""* %C!%u.%u S %s :%s\"", &me,\n                               cli_fd(cptr), cli_saslcookie(cptr),""}","int m_authenticate(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
{
  struct Client* acptr;
  int first = 0;
  char realhost[HOSTLEN + 3];
  char *hoststr = (cli_sockhost(cptr) ? cli_sockhost(cptr) : cli_sock_ip(cptr));

  if (!CapActive(cptr, CAP_SASL))
    return 0;

  if (parc < 2) /* have enough parameters? */
    return need_more_params(cptr, ""AUTHENTICATE"");

  if (strlen(parv[1]) > 400)
    return send_reply(cptr, ERR_SASLTOOLONG);

  if (IsSASLComplete(cptr))
    return send_reply(cptr, ERR_SASLALREADY);

  /* Look up the target server */
  if (!(acptr = cli_saslagent(cptr))) {
    if (strcmp(feature_str(FEAT_SASL_SERVER), ""*""))
      acptr = find_match_server((char *)feature_str(FEAT_SASL_SERVER));
    else
      acptr = NULL;
  }

  if (!acptr && strcmp(feature_str(FEAT_SASL_SERVER), ""*""))
    return send_reply(cptr, ERR_SASLFAIL, "": service unavailable"");

  /* If it's to us, do nothing; otherwise, forward the query */
  if (acptr && IsMe(acptr))
    return 0;

  /* Generate an SASL session cookie if not already generated */
  if (!cli_saslcookie(cptr)) {
    do {
      cli_saslcookie(cptr) = ircrandom() & 0x7fffffff;
    } while (!cli_saslcookie(cptr));
    first = 1;
  }

  if (strchr(hoststr, ':') != NULL)
    ircd_snprintf(0, realhost, sizeof(realhost), ""[%s]"", hoststr);
  else
    ircd_strncpy(realhost, hoststr, sizeof(realhost));
 
   if (acptr) {
     if (first) {
      if (*parv[1] == ':' || strchr(parv[1], ' '))
		return exit_client(cptr, sptr, sptr, ""Malformed AUTHENTICATE"");
       if (!EmptyString(cli_sslclifp(cptr)))
         sendcmdto_one(&me, CMD_SASL, acptr, ""%C %C!%u.%u S %s :%s"", acptr, &me,
                       cli_fd(cptr), cli_saslcookie(cptr),
                      parv[1], cli_sslclifp(cptr));
      else
        sendcmdto_one(&me, CMD_SASL, acptr, ""%C %C!%u.%u S :%s"", acptr, &me,
                      cli_fd(cptr), cli_saslcookie(cptr), parv[1]);
      if (feature_bool(FEAT_SASL_SENDHOST))
        sendcmdto_one(&me, CMD_SASL, acptr, ""%C %C!%u.%u H :%s@%s:%s"", acptr, &me,
                      cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),
                      realhost, cli_sock_ip(cptr));
    } else {
      sendcmdto_one(&me, CMD_SASL, acptr, ""%C %C!%u.%u C :%s"", acptr, &me,
                    cli_fd(cptr), cli_saslcookie(cptr), parv[1]);
     }
   } else {
     if (first) {
      if (*parv[1] == ':' || strchr(parv[1], ' '))
        return exit_client(cptr, sptr, sptr, ""Malformed AUTHENTICATE"");
       if (!EmptyString(cli_sslclifp(cptr)))
         sendcmdto_serv_butone(&me, CMD_SASL, cptr, ""* %C!%u.%u S %s :%s"", &me,
                               cli_fd(cptr), cli_saslcookie(cptr),
                              parv[1], cli_sslclifp(cptr));
      else
        sendcmdto_serv_butone(&me, CMD_SASL, cptr, ""* %C!%u.%u S :%s"", &me,
                              cli_fd(cptr), cli_saslcookie(cptr), parv[1]);
      if (feature_bool(FEAT_SASL_SENDHOST))
        sendcmdto_serv_butone(&me, CMD_SASL, cptr, ""* %C!%u.%u H :%s@%s:%s"", &me,
                              cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),
                              realhost, cli_sock_ip(cptr));
    } else {
      sendcmdto_serv_butone(&me, CMD_SASL, cptr, ""* %C!%u.%u C :%s"", &me,
                            cli_fd(cptr), cli_saslcookie(cptr), parv[1]);
    }
  }

  if (!t_active(&cli_sasltimeout(cptr)))
    timer_add(timer_init(&cli_sasltimeout(cptr)), sasl_timeout_callback, (void*) cptr,
              TT_RELATIVE, feature_int(FEAT_SASL_TIMEOUT));

  return 0;
}
","int m_authenticate(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
{
  struct Client* acptr;
  int first = 0;
  char realhost[HOSTLEN + 3];
  char *hoststr = (cli_sockhost(cptr) ? cli_sockhost(cptr) : cli_sock_ip(cptr));

  if (!CapActive(cptr, CAP_SASL))
    return 0;

  if (parc < 2) /* have enough parameters? */
    return need_more_params(cptr, ""AUTHENTICATE"");

  if (strlen(parv[1]) > 400)
    return send_reply(cptr, ERR_SASLTOOLONG);

  if (IsSASLComplete(cptr))
    return send_reply(cptr, ERR_SASLALREADY);

  /* Look up the target server */
  if (!(acptr = cli_saslagent(cptr))) {
    if (strcmp(feature_str(FEAT_SASL_SERVER), ""*""))
      acptr = find_match_server((char *)feature_str(FEAT_SASL_SERVER));
    else
      acptr = NULL;
  }

  if (!acptr && strcmp(feature_str(FEAT_SASL_SERVER), ""*""))
    return send_reply(cptr, ERR_SASLFAIL, "": service unavailable"");

  /* If it's to us, do nothing; otherwise, forward the query */
  if (acptr && IsMe(acptr))
    return 0;

  /* Generate an SASL session cookie if not already generated */
  if (!cli_saslcookie(cptr)) {
    do {
      cli_saslcookie(cptr) = ircrandom() & 0x7fffffff;
    } while (!cli_saslcookie(cptr));
    first = 1;
  }

  if (strchr(hoststr, ':') != NULL)
    ircd_snprintf(0, realhost, sizeof(realhost), ""[%s]"", hoststr);
  else
    ircd_strncpy(realhost, hoststr, sizeof(realhost));
 
   if (acptr) {
     if (first) {
       if (!EmptyString(cli_sslclifp(cptr)))
         sendcmdto_one(&me, CMD_SASL, acptr, ""%C %C!%u.%u S %s :%s"", acptr, &me,
                       cli_fd(cptr), cli_saslcookie(cptr),
                      parv[1], cli_sslclifp(cptr));
      else
        sendcmdto_one(&me, CMD_SASL, acptr, ""%C %C!%u.%u S :%s"", acptr, &me,
                      cli_fd(cptr), cli_saslcookie(cptr), parv[1]);
      if (feature_bool(FEAT_SASL_SENDHOST))
        sendcmdto_one(&me, CMD_SASL, acptr, ""%C %C!%u.%u H :%s@%s:%s"", acptr, &me,
                      cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),
                      realhost, cli_sock_ip(cptr));
    } else {
      sendcmdto_one(&me, CMD_SASL, acptr, ""%C %C!%u.%u C :%s"", acptr, &me,
                    cli_fd(cptr), cli_saslcookie(cptr), parv[1]);
     }
   } else {
     if (first) {
       if (!EmptyString(cli_sslclifp(cptr)))
         sendcmdto_serv_butone(&me, CMD_SASL, cptr, ""* %C!%u.%u S %s :%s"", &me,
                               cli_fd(cptr), cli_saslcookie(cptr),
                              parv[1], cli_sslclifp(cptr));
      else
        sendcmdto_serv_butone(&me, CMD_SASL, cptr, ""* %C!%u.%u S :%s"", &me,
                              cli_fd(cptr), cli_saslcookie(cptr), parv[1]);
      if (feature_bool(FEAT_SASL_SENDHOST))
        sendcmdto_serv_butone(&me, CMD_SASL, cptr, ""* %C!%u.%u H :%s@%s:%s"", &me,
                              cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),
                              realhost, cli_sock_ip(cptr));
    } else {
      sendcmdto_serv_butone(&me, CMD_SASL, cptr, ""* %C!%u.%u C :%s"", &me,
                            cli_fd(cptr), cli_saslcookie(cptr), parv[1]);
    }
  }

  if (!t_active(&cli_sasltimeout(cptr)))
    timer_add(timer_init(&cli_sasltimeout(cptr)), sasl_timeout_callback, (void*) cptr,
              TT_RELATIVE, feature_int(FEAT_SASL_TIMEOUT));

  return 0;
}
",C,"      if (*parv[1] == ':' || strchr(parv[1], ' '))
		return exit_client(cptr, sptr, sptr, ""Malformed AUTHENTICATE"");
      if (*parv[1] == ':' || strchr(parv[1], ' '))
        return exit_client(cptr, sptr, sptr, ""Malformed AUTHENTICATE"");
",,,"@@ -150,6 +150,8 @@ int m_authenticate(struct Client* cptr, struct Client* sptr, int parc, char* par
 
   if (acptr) {
     if (first) {
+      if (*parv[1] == ':' || strchr(parv[1], ' '))
+		return exit_client(cptr, sptr, sptr, ""Malformed AUTHENTICATE"");
       if (!EmptyString(cli_sslclifp(cptr)))
         sendcmdto_one(&me, CMD_SASL, acptr, ""%C %C!%u.%u S %s :%s"", acptr, &me,
                       cli_fd(cptr), cli_saslcookie(cptr),
@@ -167,6 +169,8 @@ int m_authenticate(struct Client* cptr, struct Client* sptr, int parc, char* par
     }
   } else {
     if (first) {
+      if (*parv[1] == ':' || strchr(parv[1], ' '))
+        return exit_client(cptr, sptr, sptr, ""Malformed AUTHENTICATE"");
       if (!EmptyString(cli_sslclifp(cptr)))
         sendcmdto_serv_butone(&me, CMD_SASL, cptr, ""* %C!%u.%u S %s :%s"", &me,
                               cli_fd(cptr), cli_saslcookie(cptr),",nefarious2,f50a84bad996d438e7b31b9e74c32a41e43f8be5,656d86a61249fa4411d73c8d2d7cf9deccc97cec,1,"int m_authenticate(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
{
  struct Client* acptr;
  int first = 0;
  char realhost[HOSTLEN + 3];
  char *hoststr = (cli_sockhost(cptr) ? cli_sockhost(cptr) : cli_sock_ip(cptr));

  if (!CapActive(cptr, CAP_SASL))
    return 0;

  if (parc < 2) /* have enough parameters? */
    return need_more_params(cptr, ""AUTHENTICATE"");

  if (strlen(parv[1]) > 400)
    return send_reply(cptr, ERR_SASLTOOLONG);

  if (IsSASLComplete(cptr))
    return send_reply(cptr, ERR_SASLALREADY);

  /* Look up the target server */
  if (!(acptr = cli_saslagent(cptr))) {
    if (strcmp(feature_str(FEAT_SASL_SERVER), ""*""))
      acptr = find_match_server((char *)feature_str(FEAT_SASL_SERVER));
    else
      acptr = NULL;
  }

  if (!acptr && strcmp(feature_str(FEAT_SASL_SERVER), ""*""))
    return send_reply(cptr, ERR_SASLFAIL, "": service unavailable"");

  /* If it's to us, do nothing; otherwise, forward the query */
  if (acptr && IsMe(acptr))
    return 0;

  /* Generate an SASL session cookie if not already generated */
  if (!cli_saslcookie(cptr)) {
    do {
      cli_saslcookie(cptr) = ircrandom() & 0x7fffffff;
    } while (!cli_saslcookie(cptr));
    first = 1;
  }

  if (strchr(hoststr, ':') != NULL)
    ircd_snprintf(0, realhost, sizeof(realhost), ""[%s]"", hoststr);
  else
    ircd_strncpy(realhost, hoststr, sizeof(realhost));
 
   if (acptr) {
     if (first) {
//fix_flaw_line_below:
//      if (*parv[1] == ':' || strchr(parv[1], ' '))
//fix_flaw_line_below:
//		return exit_client(cptr, sptr, sptr, ""Malformed AUTHENTICATE"");
       if (!EmptyString(cli_sslclifp(cptr)))
         sendcmdto_one(&me, CMD_SASL, acptr, ""%C %C!%u.%u S %s :%s"", acptr, &me,
                       cli_fd(cptr), cli_saslcookie(cptr),
                      parv[1], cli_sslclifp(cptr));
      else
        sendcmdto_one(&me, CMD_SASL, acptr, ""%C %C!%u.%u S :%s"", acptr, &me,
                      cli_fd(cptr), cli_saslcookie(cptr), parv[1]);
      if (feature_bool(FEAT_SASL_SENDHOST))
        sendcmdto_one(&me, CMD_SASL, acptr, ""%C %C!%u.%u H :%s@%s:%s"", acptr, &me,
                      cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),
                      realhost, cli_sock_ip(cptr));
    } else {
      sendcmdto_one(&me, CMD_SASL, acptr, ""%C %C!%u.%u C :%s"", acptr, &me,
                    cli_fd(cptr), cli_saslcookie(cptr), parv[1]);
     }
   } else {
     if (first) {
//fix_flaw_line_below:
//      if (*parv[1] == ':' || strchr(parv[1], ' '))
//fix_flaw_line_below:
//        return exit_client(cptr, sptr, sptr, ""Malformed AUTHENTICATE"");
       if (!EmptyString(cli_sslclifp(cptr)))
         sendcmdto_serv_butone(&me, CMD_SASL, cptr, ""* %C!%u.%u S %s :%s"", &me,
                               cli_fd(cptr), cli_saslcookie(cptr),
                              parv[1], cli_sslclifp(cptr));
      else
        sendcmdto_serv_butone(&me, CMD_SASL, cptr, ""* %C!%u.%u S :%s"", &me,
                              cli_fd(cptr), cli_saslcookie(cptr), parv[1]);
      if (feature_bool(FEAT_SASL_SENDHOST))
        sendcmdto_serv_butone(&me, CMD_SASL, cptr, ""* %C!%u.%u H :%s@%s:%s"", &me,
                              cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),
                              realhost, cli_sock_ip(cptr));
    } else {
      sendcmdto_serv_butone(&me, CMD_SASL, cptr, ""* %C!%u.%u C :%s"", &me,
                            cli_fd(cptr), cli_saslcookie(cptr), parv[1]);
    }
  }

  if (!t_active(&cli_sasltimeout(cptr)))
    timer_add(timer_init(&cli_sasltimeout(cptr)), sasl_timeout_callback, (void*) cptr,
              TT_RELATIVE, feature_int(FEAT_SASL_TIMEOUT));

  return 0;
}
"
4250,181986,,Remote,Not required,Partial,CVE-2016-7144,https://www.cvedetails.com/cve/CVE-2016-7144/,CWE-287,Medium,Partial,Partial,,2017-01-18,6.8,The m_authenticate function in modules/m_sasl.c in UnrealIRCd before 3.2.10.7 and 4.x before 4.0.6 allows remote attackers to spoof certificate fingerprints and consequently log in as another user via a crafted AUTHENTICATE parameter.,2017-01-20,,6,https://github.com/unrealircd/unrealircd/commit/f473e355e1dc422c4f019dbf86bc50ba1a34a766,f473e355e1dc422c4f019dbf86bc50ba1a34a766,Fix AUTHENTICATE bug,0,src/modules/m_sasl.c,"{""sha"": ""b53818a96ff59c082a777cb43a316c9dc350930a"", ""filename"": ""src/modules/m_sasl.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/unrealircd/unrealircd/blob/f473e355e1dc422c4f019dbf86bc50ba1a34a766/src/modules/m_sasl.c"", ""raw_url"": ""https://github.com/unrealircd/unrealircd/raw/f473e355e1dc422c4f019dbf86bc50ba1a34a766/src/modules/m_sasl.c"", ""contents_url"": ""https://api.github.com/repos/unrealircd/unrealircd/contents/src/modules/m_sasl.c?ref=f473e355e1dc422c4f019dbf86bc50ba1a34a766"", ""patch"": ""@@ -230,6 +230,12 @@ CMD_FUNC(m_authenticate)\n \t\treturn 0;\n \t}\n \n+\tif ((parv[1][0] == ':') || strchr(parv[1], ' '))\n+\t{\n+\t\tsendto_one(sptr, err_str(ERR_CANNOTDOCOMMAND), me.name, \""*\"", \""AUTHENTICATE\"", \""Invalid parameter\"");\n+\t\treturn 0;\n+\t}\n+\n \tif (strlen(parv[1]) > 400)\n \t{\n \t\tsendto_one(sptr, err_str(ERR_SASLTOOLONG), me.name, BadPtr(sptr->name) ? \""*\"" : sptr->name);""}","CMD_FUNC(m_authenticate)
{
	aClient *agent_p = NULL;

	/* Failing to use CAP REQ for sasl is a protocol violation. */
	if (!SASL_SERVER || !MyConnect(sptr) || BadPtr(parv[1]) || !CHECKPROTO(sptr, PROTO_SASL))
		return 0;

	if (sptr->local->sasl_complete)
	{
		sendto_one(sptr, err_str(ERR_SASLALREADY), me.name, BadPtr(sptr->name) ? ""*"" : sptr->name);
 		return 0;
 	}
 
	if ((parv[1][0] == ':') || strchr(parv[1], ' '))
	{
		sendto_one(sptr, err_str(ERR_CANNOTDOCOMMAND), me.name, ""*"", ""AUTHENTICATE"", ""Invalid parameter"");
		return 0;
	}

 	if (strlen(parv[1]) > 400)
 	{
 		sendto_one(sptr, err_str(ERR_SASLTOOLONG), me.name, BadPtr(sptr->name) ? ""*"" : sptr->name);
		return 0;
	}

	if (*sptr->local->sasl_agent)
		agent_p = find_client(sptr->local->sasl_agent, NULL);

	if (agent_p == NULL)
	{
		char *addr = BadPtr(sptr->ip) ? ""0"" : sptr->ip;
		char *certfp = moddata_client_get(sptr, ""certfp"");

		sendto_server(NULL, 0, 0, "":%s SASL %s %s H %s %s"",
		    me.name, SASL_SERVER, encode_puid(sptr), addr, addr);

		if (certfp)
			sendto_server(NULL, 0, 0, "":%s SASL %s %s S %s %s"",
			    me.name, SASL_SERVER, encode_puid(sptr), parv[1], certfp);
		else
			sendto_server(NULL, 0, 0, "":%s SASL %s %s S %s"",
			    me.name, SASL_SERVER, encode_puid(sptr), parv[1]);
	}
	else
		sendto_server(NULL, 0, 0, "":%s SASL %s %s C %s"",
		    me.name, AGENT_SID(agent_p), encode_puid(sptr), parv[1]);

	sptr->local->sasl_out++;

	return 0;
}
","CMD_FUNC(m_authenticate)
{
	aClient *agent_p = NULL;

	/* Failing to use CAP REQ for sasl is a protocol violation. */
	if (!SASL_SERVER || !MyConnect(sptr) || BadPtr(parv[1]) || !CHECKPROTO(sptr, PROTO_SASL))
		return 0;

	if (sptr->local->sasl_complete)
	{
		sendto_one(sptr, err_str(ERR_SASLALREADY), me.name, BadPtr(sptr->name) ? ""*"" : sptr->name);
 		return 0;
 	}
 
 	if (strlen(parv[1]) > 400)
 	{
 		sendto_one(sptr, err_str(ERR_SASLTOOLONG), me.name, BadPtr(sptr->name) ? ""*"" : sptr->name);
		return 0;
	}

	if (*sptr->local->sasl_agent)
		agent_p = find_client(sptr->local->sasl_agent, NULL);

	if (agent_p == NULL)
	{
		char *addr = BadPtr(sptr->ip) ? ""0"" : sptr->ip;
		char *certfp = moddata_client_get(sptr, ""certfp"");

		sendto_server(NULL, 0, 0, "":%s SASL %s %s H %s %s"",
		    me.name, SASL_SERVER, encode_puid(sptr), addr, addr);

		if (certfp)
			sendto_server(NULL, 0, 0, "":%s SASL %s %s S %s %s"",
			    me.name, SASL_SERVER, encode_puid(sptr), parv[1], certfp);
		else
			sendto_server(NULL, 0, 0, "":%s SASL %s %s S %s"",
			    me.name, SASL_SERVER, encode_puid(sptr), parv[1]);
	}
	else
		sendto_server(NULL, 0, 0, "":%s SASL %s %s C %s"",
		    me.name, AGENT_SID(agent_p), encode_puid(sptr), parv[1]);

	sptr->local->sasl_out++;

	return 0;
}
",C,"	if ((parv[1][0] == ':') || strchr(parv[1], ' '))
	{
		sendto_one(sptr, err_str(ERR_CANNOTDOCOMMAND), me.name, ""*"", ""AUTHENTICATE"", ""Invalid parameter"");
		return 0;
	}

",,,"@@ -230,6 +230,12 @@ CMD_FUNC(m_authenticate)
 		return 0;
 	}
 
+	if ((parv[1][0] == ':') || strchr(parv[1], ' '))
+	{
+		sendto_one(sptr, err_str(ERR_CANNOTDOCOMMAND), me.name, ""*"", ""AUTHENTICATE"", ""Invalid parameter"");
+		return 0;
+	}
+
 	if (strlen(parv[1]) > 400)
 	{
 		sendto_one(sptr, err_str(ERR_SASLTOOLONG), me.name, BadPtr(sptr->name) ? ""*"" : sptr->name);",unrealircd,f473e355e1dc422c4f019dbf86bc50ba1a34a766,ae0fc98a04fce80e5b940617b9b3f5e43daa2dba,1,"CMD_FUNC(m_authenticate)
{
	aClient *agent_p = NULL;

	/* Failing to use CAP REQ for sasl is a protocol violation. */
	if (!SASL_SERVER || !MyConnect(sptr) || BadPtr(parv[1]) || !CHECKPROTO(sptr, PROTO_SASL))
		return 0;

	if (sptr->local->sasl_complete)
	{
		sendto_one(sptr, err_str(ERR_SASLALREADY), me.name, BadPtr(sptr->name) ? ""*"" : sptr->name);
 		return 0;
 	}
 
//fix_flaw_line_below:
//	if ((parv[1][0] == ':') || strchr(parv[1], ' '))
//fix_flaw_line_below:
//	{
//fix_flaw_line_below:
//		sendto_one(sptr, err_str(ERR_CANNOTDOCOMMAND), me.name, ""*"", ""AUTHENTICATE"", ""Invalid parameter"");
//fix_flaw_line_below:
//		return 0;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	if (strlen(parv[1]) > 400)
 	{
 		sendto_one(sptr, err_str(ERR_SASLTOOLONG), me.name, BadPtr(sptr->name) ? ""*"" : sptr->name);
		return 0;
	}

	if (*sptr->local->sasl_agent)
		agent_p = find_client(sptr->local->sasl_agent, NULL);

	if (agent_p == NULL)
	{
		char *addr = BadPtr(sptr->ip) ? ""0"" : sptr->ip;
		char *certfp = moddata_client_get(sptr, ""certfp"");

		sendto_server(NULL, 0, 0, "":%s SASL %s %s H %s %s"",
		    me.name, SASL_SERVER, encode_puid(sptr), addr, addr);

		if (certfp)
			sendto_server(NULL, 0, 0, "":%s SASL %s %s S %s %s"",
			    me.name, SASL_SERVER, encode_puid(sptr), parv[1], certfp);
		else
			sendto_server(NULL, 0, 0, "":%s SASL %s %s S %s"",
			    me.name, SASL_SERVER, encode_puid(sptr), parv[1]);
	}
	else
		sendto_server(NULL, 0, 0, "":%s SASL %s %s C %s"",
		    me.name, AGENT_SID(agent_p), encode_puid(sptr), parv[1]);

	sptr->local->sasl_out++;

	return 0;
}
"
4307,182043,,Remote,Not required,Partial,CVE-2015-6817,https://www.cvedetails.com/cve/CVE-2015-6817/,CWE-287,Medium,Partial,Partial,,2017-05-23,6.8,"PgBouncer 1.6.x before 1.6.1, when configured with auth_user, allows remote attackers to gain login access as auth_user via an unknown username.",2017-06-06,,0,https://github.com/pgbouncer/pgbouncer/commit/7ca3e5279d05fceb1e8a043c6f5b6f58dea3ed38,7ca3e5279d05fceb1e8a043c6f5b6f58dea3ed38,"Remove too early set of auth_user

When query returns 0 rows (user not found),
this user stays as login user...

Should fix #69.",1,src/client.c,"{""sha"": ""2b01ff2ccdb45089055fa35d22f79ffa17f4761e"", ""filename"": ""src/client.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/pgbouncer/pgbouncer/blob/7ca3e5279d05fceb1e8a043c6f5b6f58dea3ed38/src/client.c"", ""raw_url"": ""https://github.com/pgbouncer/pgbouncer/raw/7ca3e5279d05fceb1e8a043c6f5b6f58dea3ed38/src/client.c"", ""contents_url"": ""https://api.github.com/repos/pgbouncer/pgbouncer/contents/src/client.c?ref=7ca3e5279d05fceb1e8a043c6f5b6f58dea3ed38"", ""patch"": ""@@ -83,7 +83,6 @@ static void start_auth_request(PgSocket *client, const char *username)\n \tint res;\n \tPktBuf *buf;\n \n-\tclient->auth_user = client->db->auth_user;\n \t/* have to fetch user info from db */\n \tclient->pool = get_pool(client->db, client->db->auth_user);\n \tif (!find_server(client)) {""}","static void start_auth_request(PgSocket *client, const char *username)
{
 	int res;
 	PktBuf *buf;
 
 	/* have to fetch user info from db */
 	client->pool = get_pool(client->db, client->db->auth_user);
 	if (!find_server(client)) {
		client->wait_for_user_conn = true;
		return;
	}
	slog_noise(client, ""Doing auth_conn query"");
	client->wait_for_user_conn = false;
	client->wait_for_user = true;
	if (!sbuf_pause(&client->sbuf)) {
		release_server(client->link);
		disconnect_client(client, true, ""pause failed"");
		return;
	}
	client->link->ready = 0;

	res = 0;
	buf = pktbuf_dynamic(512);
	if (buf) {
		pktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);
		res = pktbuf_send_immediate(buf, client->link);
		pktbuf_free(buf);
		/*
		 * Should do instead:
		 *   res = pktbuf_send_queued(buf, client->link);
		 * but that needs better integration with SBuf.
		 */
	}
	if (!res)
		disconnect_server(client->link, false, ""unable to send login query"");
}
","static void start_auth_request(PgSocket *client, const char *username)
{
 	int res;
 	PktBuf *buf;
 
	client->auth_user = client->db->auth_user;
 	/* have to fetch user info from db */
 	client->pool = get_pool(client->db, client->db->auth_user);
 	if (!find_server(client)) {
		client->wait_for_user_conn = true;
		return;
	}
	slog_noise(client, ""Doing auth_conn query"");
	client->wait_for_user_conn = false;
	client->wait_for_user = true;
	if (!sbuf_pause(&client->sbuf)) {
		release_server(client->link);
		disconnect_client(client, true, ""pause failed"");
		return;
	}
	client->link->ready = 0;

	res = 0;
	buf = pktbuf_dynamic(512);
	if (buf) {
		pktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);
		res = pktbuf_send_immediate(buf, client->link);
		pktbuf_free(buf);
		/*
		 * Should do instead:
		 *   res = pktbuf_send_queued(buf, client->link);
		 * but that needs better integration with SBuf.
		 */
	}
	if (!res)
		disconnect_server(client->link, false, ""unable to send login query"");
}
",C,,"	client->auth_user = client->db->auth_user;
",,"@@ -83,7 +83,6 @@ static void start_auth_request(PgSocket *client, const char *username)
 	int res;
 	PktBuf *buf;
 
-	client->auth_user = client->db->auth_user;
 	/* have to fetch user info from db */
 	client->pool = get_pool(client->db, client->db->auth_user);
 	if (!find_server(client)) {",pgbouncer,7ca3e5279d05fceb1e8a043c6f5b6f58dea3ed38,86db13075cd60ee59719137e67a9ab3a88cfad1a,1,"static void start_auth_request(PgSocket *client, const char *username)
{
 	int res;
 	PktBuf *buf;
 
//flaw_line_below:
	client->auth_user = client->db->auth_user;
 	/* have to fetch user info from db */
 	client->pool = get_pool(client->db, client->db->auth_user);
 	if (!find_server(client)) {
		client->wait_for_user_conn = true;
		return;
	}
	slog_noise(client, ""Doing auth_conn query"");
	client->wait_for_user_conn = false;
	client->wait_for_user = true;
	if (!sbuf_pause(&client->sbuf)) {
		release_server(client->link);
		disconnect_client(client, true, ""pause failed"");
		return;
	}
	client->link->ready = 0;

	res = 0;
	buf = pktbuf_dynamic(512);
	if (buf) {
		pktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);
		res = pktbuf_send_immediate(buf, client->link);
		pktbuf_free(buf);
		/*
		 * Should do instead:
		 *   res = pktbuf_send_queued(buf, client->link);
		 * but that needs better integration with SBuf.
		 */
	}
	if (!res)
		disconnect_server(client->link, false, ""unable to send login query"");
}
"
5454,183190,,Remote,Not required,Partial,CVE-2017-14032,https://www.cvedetails.com/cve/CVE-2017-14032/,CWE-287,Medium,Partial,Partial,,2017-08-30,6.8,"ARM mbed TLS before 1.3.21 and 2.x before 2.1.9, if optional authentication is configured, allows remote attackers to bypass peer authentication via an X.509 certificate chain with many intermediates. NOTE: although mbed TLS was formerly known as PolarSSL, the releases shipped with the PolarSSL name are not affected.",2017-11-07,Bypass ,2,https://github.com/ARMmbed/mbedtls/commit/31458a18788b0cf0b722acda9bb2f2fe13a3fb32,31458a18788b0cf0b722acda9bb2f2fe13a3fb32,"Only return VERIFY_FAILED from a single point

Everything else is a fatal error. Also improve documentation about that for
the vrfy callback.",0,library/error.c,"{""sha"": ""d35457b962a4b9916fa9e4768d566c61eaa37bbe"", ""filename"": ""ChangeLog"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/ChangeLog"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/ChangeLog?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -6,6 +6,9 @@ Changes\n    * Certificate verification functions now set flags to -1 in case the full\n      chain was not verified due to an internal error (including in the verify\n      callback) or chain length limitations.\n+   * With authmode set to optional, handshake is now aborted if the\n+     verification of the peer's certificate failed due to an overlong chain or\n+     a fatal error in the vrfy callback.\n \n = mbed TLS 2.5.1 released 2017-06-21\n ""}<_**next**_>{""sha"": ""31591e2d6439baef544ec687a834ff322adafeff"", ""filename"": ""include/mbedtls/error.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/error.h"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/error.h"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/include/mbedtls/error.h?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -71,7 +71,7 @@\n  * Name      ID  Nr of Errors\n  * PEM       1   9\n  * PKCS#12   1   4 (Started from top)\n- * X509      2   19\n+ * X509      2   20\n  * PKCS5     2   4 (Started from top)\n  * DHM       3   9\n  * PK        3   14 (Started from top)""}<_**next**_>{""sha"": ""cc0007006280b4e382b90809484b76bd62c6035b"", ""filename"": ""include/mbedtls/ssl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/ssl.h"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/ssl.h"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/include/mbedtls/ssl.h?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -1052,7 +1052,7 @@ void mbedtls_ssl_conf_authmode( mbedtls_ssl_config *conf, int authmode );\n  *\n  *                 If set, the verify callback is called for each\n  *                 certificate in the chain. For implementation\n- *                 information, please see \\c x509parse_verify()\n+ *                 information, please see \\c mbedtls_x509_crt_verify()\n  *\n  * \\param conf     SSL configuration\n  * \\param f_vrfy   verification function""}<_**next**_>{""sha"": ""128eaded6fb7b2b17dda917fb024d8dd1421eecf"", ""filename"": ""include/mbedtls/x509.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/x509.h"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/x509.h"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/include/mbedtls/x509.h?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -76,6 +76,7 @@\n #define MBEDTLS_ERR_X509_ALLOC_FAILED                     -0x2880  /**< Allocation of memory failed. */\n #define MBEDTLS_ERR_X509_FILE_IO_ERROR                    -0x2900  /**< Read/write of file failed. */\n #define MBEDTLS_ERR_X509_BUFFER_TOO_SMALL                 -0x2980  /**< Destination buffer is too small. */\n+#define MBEDTLS_ERR_X509_FATAL_ERROR                      -0x3000  /**< A fatal error occured, eg the chain is too long or the vrfy callback failed. */\n /* \\} name */\n \n /**""}<_**next**_>{""sha"": ""fd203360c631cea5667abe09b6e6084380a613c6"", ""filename"": ""include/mbedtls/x509_crt.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/x509_crt.h"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/x509_crt.h"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/include/mbedtls/x509_crt.h?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -267,7 +267,13 @@ int mbedtls_x509_crt_verify_info( char *buf, size_t size, const char *prefix,\n  *\n  *                 All flags left after returning from the callback\n  *                 are also returned to the application. The function should\n- *                 return 0 for anything but a fatal error.\n+ *                 return 0 for anything (including invalid certificates)\n+ *                 other than fatal error, as a non-zero return code\n+ *                 immediately aborts the verification process. For fatal\n+ *                 errors, a specific error code should be used (different\n+ *                 from MBEDTLS_ERR_X509_CERT_VERIFY_FAILED which should not\n+ *                 be returned at this point), or MBEDTLS_ERR_X509_FATAL_ERROR\n+ *                 can be used if no better code is available.\n  *\n  * \\note           In case verification failed, the results can be displayed\n  *                 using \\c mbedtls_x509_crt_verify_info()""}<_**next**_>{""sha"": ""db42381c427c4d3e38cbb981bee9757edcc69001"", ""filename"": ""library/error.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/library/error.c"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/library/error.c"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/library/error.c?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -480,6 +480,8 @@ void mbedtls_strerror( int ret, char *buf, size_t buflen )\n             mbedtls_snprintf( buf, buflen, \""X509 - Read/write of file failed\"" );\n         if( use_ret == -(MBEDTLS_ERR_X509_BUFFER_TOO_SMALL) )\n             mbedtls_snprintf( buf, buflen, \""X509 - Destination buffer is too small\"" );\n+        if( use_ret == -(MBEDTLS_ERR_X509_FATAL_ERROR) )\n+            mbedtls_snprintf( buf, buflen, \""X509 - A fatal error occured, eg the chain is too long or the vrfy callback failed\"" );\n #endif /* MBEDTLS_X509_USE_C || MBEDTLS_X509_CREATE_C */\n         // END generated code\n ""}<_**next**_>{""sha"": ""ec5f77268db943a51a4eda88c27a37124b15c63c"", ""filename"": ""library/x509_crt.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 2, ""changes"": 8, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/library/x509_crt.c"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/library/x509_crt.c"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/library/x509_crt.c?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -2057,8 +2057,8 @@ static int x509_crt_verify_child(\n     /* path_cnt is 0 for the first intermediate CA */\n     if( 1 + path_cnt > MBEDTLS_X509_MAX_INTERMEDIATE_CA )\n     {\n-        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n-        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n+        /* return immediately as the goal is to avoid unbounded recursion */\n+        return( MBEDTLS_ERR_X509_FATAL_ERROR );\n     }\n \n     if( mbedtls_x509_time_is_past( &child->valid_to ) )\n@@ -2310,6 +2310,10 @@ int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,\n     }\n \n exit:\n+    /* prevent misuse of the vrfy callback */\n+    if( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED )\n+        ret = MBEDTLS_ERR_X509_FATAL_ERROR;\n+\n     if( ret != 0 )\n     {\n         *flags = (uint32_t) -1;""}<_**next**_>{""sha"": ""ea56f3fbc76312734f4eb41fa3da1cbb5ca7bc14"", ""filename"": ""tests/suites/test_suite_x509parse.data"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/tests/suites/test_suite_x509parse.data"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/tests/suites/test_suite_x509parse.data"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/tests/suites/test_suite_x509parse.data?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -1204,7 +1204,7 @@ mbedtls_x509_crt_verify_max:\""data_files/test-ca2.crt\"":\""data_files/dir-maxpath\"":M\n \n X509 CRT verify long chain (max intermediate CA + 1)\n depends_on:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\n-mbedtls_x509_crt_verify_max:\""data_files/dir-maxpath/00.crt\"":\""data_files/dir-maxpath\"":MBEDTLS_X509_MAX_INTERMEDIATE_CA+1:MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:-1\n+mbedtls_x509_crt_verify_max:\""data_files/dir-maxpath/00.crt\"":\""data_files/dir-maxpath\"":MBEDTLS_X509_MAX_INTERMEDIATE_CA+1:MBEDTLS_ERR_X509_FATAL_ERROR:-1\n \n X509 CRT verify chain #1 (zero pathlen intermediate)\n depends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C""}","void mbedtls_strerror( int ret, char *buf, size_t buflen )
{
    size_t len;
    int use_ret;

    if( buflen == 0 )
        return;

    memset( buf, 0x00, buflen );

    if( ret < 0 )
        ret = -ret;

    if( ret & 0xFF80 )
    {
        use_ret = ret & 0xFF80;

#if defined(MBEDTLS_CIPHER_C)
        if( use_ret == -(MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""CIPHER - The selected feature is not available"" );
        if( use_ret == -(MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""CIPHER - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_CIPHER_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""CIPHER - Failed to allocate memory"" );
        if( use_ret == -(MBEDTLS_ERR_CIPHER_INVALID_PADDING) )
            mbedtls_snprintf( buf, buflen, ""CIPHER - Input data contains invalid padding and is rejected"" );
        if( use_ret == -(MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED) )
            mbedtls_snprintf( buf, buflen, ""CIPHER - Decryption of block requires a full block"" );
        if( use_ret == -(MBEDTLS_ERR_CIPHER_AUTH_FAILED) )
            mbedtls_snprintf( buf, buflen, ""CIPHER - Authentication failed (for AEAD modes)"" );
        if( use_ret == -(MBEDTLS_ERR_CIPHER_INVALID_CONTEXT) )
            mbedtls_snprintf( buf, buflen, ""CIPHER - The context is invalid, eg because it was free()ed"" );
#endif /* MBEDTLS_CIPHER_C */

#if defined(MBEDTLS_DHM_C)
        if( use_ret == -(MBEDTLS_ERR_DHM_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""DHM - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_READ_PARAMS_FAILED) )
            mbedtls_snprintf( buf, buflen, ""DHM - Reading of the DHM parameters failed"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_MAKE_PARAMS_FAILED) )
            mbedtls_snprintf( buf, buflen, ""DHM - Making of the DHM parameters failed"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_READ_PUBLIC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""DHM - Reading of the public values failed"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_MAKE_PUBLIC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""DHM - Making of the public value failed"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_CALC_SECRET_FAILED) )
            mbedtls_snprintf( buf, buflen, ""DHM - Calculation of the DHM secret failed"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_INVALID_FORMAT) )
            mbedtls_snprintf( buf, buflen, ""DHM - The ASN.1 data is not formatted correctly"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""DHM - Allocation of memory failed"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_FILE_IO_ERROR) )
            mbedtls_snprintf( buf, buflen, ""DHM - Read/write of file failed"" );
#endif /* MBEDTLS_DHM_C */

#if defined(MBEDTLS_ECP_C)
        if( use_ret == -(MBEDTLS_ERR_ECP_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""ECP - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL) )
            mbedtls_snprintf( buf, buflen, ""ECP - The buffer is too small to write to"" );
        if( use_ret == -(MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""ECP - Requested curve not available"" );
        if( use_ret == -(MBEDTLS_ERR_ECP_VERIFY_FAILED) )
            mbedtls_snprintf( buf, buflen, ""ECP - The signature is not valid"" );
        if( use_ret == -(MBEDTLS_ERR_ECP_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""ECP - Memory allocation failed"" );
        if( use_ret == -(MBEDTLS_ERR_ECP_RANDOM_FAILED) )
            mbedtls_snprintf( buf, buflen, ""ECP - Generation of random value, such as (ephemeral) key, failed"" );
        if( use_ret == -(MBEDTLS_ERR_ECP_INVALID_KEY) )
            mbedtls_snprintf( buf, buflen, ""ECP - Invalid private or public key"" );
        if( use_ret == -(MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""ECP - Signature is valid but shorter than the user-supplied length"" );
#endif /* MBEDTLS_ECP_C */

#if defined(MBEDTLS_MD_C)
        if( use_ret == -(MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""MD - The selected feature is not available"" );
        if( use_ret == -(MBEDTLS_ERR_MD_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""MD - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_MD_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""MD - Failed to allocate memory"" );
        if( use_ret == -(MBEDTLS_ERR_MD_FILE_IO_ERROR) )
            mbedtls_snprintf( buf, buflen, ""MD - Opening or reading of file failed"" );
#endif /* MBEDTLS_MD_C */

#if defined(MBEDTLS_PEM_PARSE_C) || defined(MBEDTLS_PEM_WRITE_C)
        if( use_ret == -(MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT) )
            mbedtls_snprintf( buf, buflen, ""PEM - No PEM header or footer found"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_INVALID_DATA) )
            mbedtls_snprintf( buf, buflen, ""PEM - PEM string is not as expected"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""PEM - Failed to allocate memory"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_INVALID_ENC_IV) )
            mbedtls_snprintf( buf, buflen, ""PEM - RSA IV is not in hex-format"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_UNKNOWN_ENC_ALG) )
            mbedtls_snprintf( buf, buflen, ""PEM - Unsupported key encryption algorithm"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_PASSWORD_REQUIRED) )
            mbedtls_snprintf( buf, buflen, ""PEM - Private key password can't be empty"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_PASSWORD_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""PEM - Given private key password does not allow for correct decryption"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""PEM - Unavailable feature, e.g. hashing/encryption combination"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""PEM - Bad input parameters to function"" );
#endif /* MBEDTLS_PEM_PARSE_C || MBEDTLS_PEM_WRITE_C */

#if defined(MBEDTLS_PK_C)
        if( use_ret == -(MBEDTLS_ERR_PK_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""PK - Memory allocation failed"" );
        if( use_ret == -(MBEDTLS_ERR_PK_TYPE_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""PK - Type mismatch, eg attempt to encrypt with an ECDSA key"" );
        if( use_ret == -(MBEDTLS_ERR_PK_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""PK - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_PK_FILE_IO_ERROR) )
            mbedtls_snprintf( buf, buflen, ""PK - Read/write of file failed"" );
        if( use_ret == -(MBEDTLS_ERR_PK_KEY_INVALID_VERSION) )
            mbedtls_snprintf( buf, buflen, ""PK - Unsupported key version"" );
        if( use_ret == -(MBEDTLS_ERR_PK_KEY_INVALID_FORMAT) )
            mbedtls_snprintf( buf, buflen, ""PK - Invalid key tag or value"" );
        if( use_ret == -(MBEDTLS_ERR_PK_UNKNOWN_PK_ALG) )
            mbedtls_snprintf( buf, buflen, ""PK - Key algorithm is unsupported (only RSA and EC are supported)"" );
        if( use_ret == -(MBEDTLS_ERR_PK_PASSWORD_REQUIRED) )
            mbedtls_snprintf( buf, buflen, ""PK - Private key password can't be empty"" );
        if( use_ret == -(MBEDTLS_ERR_PK_PASSWORD_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""PK - Given private key password does not allow for correct decryption"" );
        if( use_ret == -(MBEDTLS_ERR_PK_INVALID_PUBKEY) )
            mbedtls_snprintf( buf, buflen, ""PK - The pubkey tag or value is invalid (only RSA and EC are supported)"" );
        if( use_ret == -(MBEDTLS_ERR_PK_INVALID_ALG) )
            mbedtls_snprintf( buf, buflen, ""PK - The algorithm tag or value is invalid"" );
        if( use_ret == -(MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE) )
            mbedtls_snprintf( buf, buflen, ""PK - Elliptic curve is unsupported (only NIST curves are supported)"" );
        if( use_ret == -(MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""PK - Unavailable feature, e.g. RSA disabled for RSA key"" );
        if( use_ret == -(MBEDTLS_ERR_PK_SIG_LEN_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""PK - The signature is valid but its length is less than expected"" );
#endif /* MBEDTLS_PK_C */

#if defined(MBEDTLS_PKCS12_C)
        if( use_ret == -(MBEDTLS_ERR_PKCS12_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""PKCS12 - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_PKCS12_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""PKCS12 - Feature not available, e.g. unsupported encryption scheme"" );
        if( use_ret == -(MBEDTLS_ERR_PKCS12_PBE_INVALID_FORMAT) )
            mbedtls_snprintf( buf, buflen, ""PKCS12 - PBE ASN.1 data not as expected"" );
        if( use_ret == -(MBEDTLS_ERR_PKCS12_PASSWORD_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""PKCS12 - Given private key password does not allow for correct decryption"" );
#endif /* MBEDTLS_PKCS12_C */

#if defined(MBEDTLS_PKCS5_C)
        if( use_ret == -(MBEDTLS_ERR_PKCS5_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""PKCS5 - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_PKCS5_INVALID_FORMAT) )
            mbedtls_snprintf( buf, buflen, ""PKCS5 - Unexpected ASN.1 data"" );
        if( use_ret == -(MBEDTLS_ERR_PKCS5_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""PKCS5 - Requested encryption or digest alg not available"" );
        if( use_ret == -(MBEDTLS_ERR_PKCS5_PASSWORD_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""PKCS5 - Given private key password does not allow for correct decryption"" );
#endif /* MBEDTLS_PKCS5_C */

#if defined(MBEDTLS_RSA_C)
        if( use_ret == -(MBEDTLS_ERR_RSA_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""RSA - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_INVALID_PADDING) )
            mbedtls_snprintf( buf, buflen, ""RSA - Input data contains invalid padding and is rejected"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_KEY_GEN_FAILED) )
            mbedtls_snprintf( buf, buflen, ""RSA - Something failed during generation of a key"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_KEY_CHECK_FAILED) )
            mbedtls_snprintf( buf, buflen, ""RSA - Key failed to pass the library's validity check"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_PUBLIC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""RSA - The public key operation failed"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_PRIVATE_FAILED) )
            mbedtls_snprintf( buf, buflen, ""RSA - The private key operation failed"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_VERIFY_FAILED) )
            mbedtls_snprintf( buf, buflen, ""RSA - The PKCS#1 verification failed"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE) )
            mbedtls_snprintf( buf, buflen, ""RSA - The output buffer for decryption is not large enough"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_RNG_FAILED) )
            mbedtls_snprintf( buf, buflen, ""RSA - The random generator failed to generate non-zeros"" );
#endif /* MBEDTLS_RSA_C */

#if defined(MBEDTLS_SSL_TLS_C)
        if( use_ret == -(MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""SSL - The requested feature is not available"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""SSL - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_INVALID_MAC) )
            mbedtls_snprintf( buf, buflen, ""SSL - Verification of the message MAC failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_INVALID_RECORD) )
            mbedtls_snprintf( buf, buflen, ""SSL - An invalid SSL record was received"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_CONN_EOF) )
            mbedtls_snprintf( buf, buflen, ""SSL - The connection indicated an EOF"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_UNKNOWN_CIPHER) )
            mbedtls_snprintf( buf, buflen, ""SSL - An unknown cipher was received"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN) )
            mbedtls_snprintf( buf, buflen, ""SSL - The server has no ciphersuites in common with the client"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_NO_RNG) )
            mbedtls_snprintf( buf, buflen, ""SSL - No RNG was provided to the SSL module"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE) )
            mbedtls_snprintf( buf, buflen, ""SSL - No client certification received from the client, but required by the authentication mode"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_CERTIFICATE_TOO_LARGE) )
            mbedtls_snprintf( buf, buflen, ""SSL - Our own certificate(s) is/are too large to send in an SSL message"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_CERTIFICATE_REQUIRED) )
            mbedtls_snprintf( buf, buflen, ""SSL - The own certificate is not set, but needed by the server"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED) )
            mbedtls_snprintf( buf, buflen, ""SSL - The own private key or pre-shared key is not set, but needed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_CA_CHAIN_REQUIRED) )
            mbedtls_snprintf( buf, buflen, ""SSL - No CA Chain is set, but required to operate"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE) )
            mbedtls_snprintf( buf, buflen, ""SSL - An unexpected message was received from our peer"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE) )
        {
            mbedtls_snprintf( buf, buflen, ""SSL - A fatal alert message was received from our peer"" );
            return;
        }
        if( use_ret == -(MBEDTLS_ERR_SSL_PEER_VERIFY_FAILED) )
            mbedtls_snprintf( buf, buflen, ""SSL - Verification of our peer failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY) )
            mbedtls_snprintf( buf, buflen, ""SSL - The peer notified us that the connection is going to be closed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ClientHello handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ServerHello handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the Certificate handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the CertificateRequest handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ServerKeyExchange handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO_DONE) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ServerHelloDone handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ClientKeyExchange handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ClientKeyExchange handshake message failed in DHM / ECDH Read Public"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ClientKeyExchange handshake message failed in DHM / ECDH Calculate Secret"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the CertificateVerify handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CHANGE_CIPHER_SPEC) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ChangeCipherSpec handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_FINISHED) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the Finished handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""SSL - Memory allocation failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_HW_ACCEL_FAILED) )
            mbedtls_snprintf( buf, buflen, ""SSL - Hardware acceleration function returned with error"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH) )
            mbedtls_snprintf( buf, buflen, ""SSL - Hardware acceleration function skipped / left alone data"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_COMPRESSION_FAILED) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the compression / decompression failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION) )
            mbedtls_snprintf( buf, buflen, ""SSL - Handshake protocol not within min/max boundaries"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_NEW_SESSION_TICKET) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the NewSessionTicket handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED) )
            mbedtls_snprintf( buf, buflen, ""SSL - Session ticket has expired"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""SSL - Public key type mismatch (eg, asked for RSA key exchange and presented EC key)"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY) )
            mbedtls_snprintf( buf, buflen, ""SSL - Unknown identity received (eg, PSK identity)"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_INTERNAL_ERROR) )
            mbedtls_snprintf( buf, buflen, ""SSL - Internal error (eg, unexpected failure in lower-level module)"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_COUNTER_WRAPPING) )
            mbedtls_snprintf( buf, buflen, ""SSL - A counter would wrap (eg, too many messages exchanged)"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO) )
            mbedtls_snprintf( buf, buflen, ""SSL - Unexpected message at ServerHello in renegotiation"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED) )
            mbedtls_snprintf( buf, buflen, ""SSL - DTLS client must retry for hello verification"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL) )
            mbedtls_snprintf( buf, buflen, ""SSL - A buffer is too small to receive or write a message"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE) )
            mbedtls_snprintf( buf, buflen, ""SSL - None of the common ciphersuites is usable (eg, no suitable certificate, see debug messages)"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_WANT_READ) )
            mbedtls_snprintf( buf, buflen, ""SSL - Connection requires a read call"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_WANT_WRITE) )
            mbedtls_snprintf( buf, buflen, ""SSL - Connection requires a write call"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_TIMEOUT) )
            mbedtls_snprintf( buf, buflen, ""SSL - The operation timed out"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_CLIENT_RECONNECT) )
            mbedtls_snprintf( buf, buflen, ""SSL - The client initiated a reconnect from the same port"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_UNEXPECTED_RECORD) )
            mbedtls_snprintf( buf, buflen, ""SSL - Record header looks valid but is not expected"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_NON_FATAL) )
            mbedtls_snprintf( buf, buflen, ""SSL - The alert message received indicates a non-fatal error"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH) )
            mbedtls_snprintf( buf, buflen, ""SSL - Couldn't set the hash for verifying CertificateVerify"" );
#endif /* MBEDTLS_SSL_TLS_C */

#if defined(MBEDTLS_X509_USE_C) || defined(MBEDTLS_X509_CREATE_C)
        if( use_ret == -(MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""X509 - Unavailable feature, e.g. RSA hashing/encryption combination"" );
        if( use_ret == -(MBEDTLS_ERR_X509_UNKNOWN_OID) )
            mbedtls_snprintf( buf, buflen, ""X509 - Requested OID is unknown"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_FORMAT) )
            mbedtls_snprintf( buf, buflen, ""X509 - The CRT/CRL/CSR format is invalid, e.g. different type expected"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_VERSION) )
            mbedtls_snprintf( buf, buflen, ""X509 - The CRT/CRL/CSR version element is invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_SERIAL) )
            mbedtls_snprintf( buf, buflen, ""X509 - The serial tag or value is invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_ALG) )
            mbedtls_snprintf( buf, buflen, ""X509 - The algorithm tag or value is invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_NAME) )
            mbedtls_snprintf( buf, buflen, ""X509 - The name tag or value is invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_DATE) )
            mbedtls_snprintf( buf, buflen, ""X509 - The date tag or value is invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_SIGNATURE) )
            mbedtls_snprintf( buf, buflen, ""X509 - The signature tag or value invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_EXTENSIONS) )
            mbedtls_snprintf( buf, buflen, ""X509 - The extension tag or value is invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_UNKNOWN_VERSION) )
            mbedtls_snprintf( buf, buflen, ""X509 - CRT/CRL/CSR has an unsupported version number"" );
        if( use_ret == -(MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG) )
            mbedtls_snprintf( buf, buflen, ""X509 - Signature algorithm (oid) is unsupported"" );
        if( use_ret == -(MBEDTLS_ERR_X509_SIG_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""X509 - Signature algorithms do not match. (see \\c ::mbedtls_x509_crt sig_oid)"" );
        if( use_ret == -(MBEDTLS_ERR_X509_CERT_VERIFY_FAILED) )
            mbedtls_snprintf( buf, buflen, ""X509 - Certificate verification failed, e.g. CRL, CA or signature check failed"" );
        if( use_ret == -(MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT) )
            mbedtls_snprintf( buf, buflen, ""X509 - Format not recognized as DER or PEM"" );
        if( use_ret == -(MBEDTLS_ERR_X509_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""X509 - Input invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""X509 - Allocation of memory failed"" );
        if( use_ret == -(MBEDTLS_ERR_X509_FILE_IO_ERROR) )
             mbedtls_snprintf( buf, buflen, ""X509 - Read/write of file failed"" );
         if( use_ret == -(MBEDTLS_ERR_X509_BUFFER_TOO_SMALL) )
             mbedtls_snprintf( buf, buflen, ""X509 - Destination buffer is too small"" );
        if( use_ret == -(MBEDTLS_ERR_X509_FATAL_ERROR) )
            mbedtls_snprintf( buf, buflen, ""X509 - A fatal error occured, eg the chain is too long or the vrfy callback failed"" );
 #endif /* MBEDTLS_X509_USE_C || MBEDTLS_X509_CREATE_C */
 
        if( strlen( buf ) == 0 )
            mbedtls_snprintf( buf, buflen, ""UNKNOWN ERROR CODE (%04X)"", use_ret );
    }

    use_ret = ret & ~0xFF80;

    if( use_ret == 0 )
        return;

    len = strlen( buf );

    if( len > 0 )
    {
        if( buflen - len < 5 )
            return;

        mbedtls_snprintf( buf + len, buflen - len, "" : "" );

        buf += len + 3;
        buflen -= len + 3;
    }

#if defined(MBEDTLS_AES_C)
    if( use_ret == -(MBEDTLS_ERR_AES_INVALID_KEY_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""AES - Invalid key length"" );
    if( use_ret == -(MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""AES - Invalid data input length"" );
#endif /* MBEDTLS_AES_C */

#if defined(MBEDTLS_ASN1_PARSE_C)
    if( use_ret == -(MBEDTLS_ERR_ASN1_OUT_OF_DATA) )
        mbedtls_snprintf( buf, buflen, ""ASN1 - Out of data when parsing an ASN1 data structure"" );
    if( use_ret == -(MBEDTLS_ERR_ASN1_UNEXPECTED_TAG) )
        mbedtls_snprintf( buf, buflen, ""ASN1 - ASN1 tag was of an unexpected value"" );
    if( use_ret == -(MBEDTLS_ERR_ASN1_INVALID_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""ASN1 - Error when trying to determine the length or invalid length"" );
    if( use_ret == -(MBEDTLS_ERR_ASN1_LENGTH_MISMATCH) )
        mbedtls_snprintf( buf, buflen, ""ASN1 - Actual length differs from expected length"" );
    if( use_ret == -(MBEDTLS_ERR_ASN1_INVALID_DATA) )
        mbedtls_snprintf( buf, buflen, ""ASN1 - Data is invalid. (not used)"" );
    if( use_ret == -(MBEDTLS_ERR_ASN1_ALLOC_FAILED) )
        mbedtls_snprintf( buf, buflen, ""ASN1 - Memory allocation failed"" );
    if( use_ret == -(MBEDTLS_ERR_ASN1_BUF_TOO_SMALL) )
        mbedtls_snprintf( buf, buflen, ""ASN1 - Buffer too small when writing ASN.1 data structure"" );
#endif /* MBEDTLS_ASN1_PARSE_C */

#if defined(MBEDTLS_BASE64_C)
    if( use_ret == -(MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL) )
        mbedtls_snprintf( buf, buflen, ""BASE64 - Output buffer too small"" );
    if( use_ret == -(MBEDTLS_ERR_BASE64_INVALID_CHARACTER) )
        mbedtls_snprintf( buf, buflen, ""BASE64 - Invalid character in input"" );
#endif /* MBEDTLS_BASE64_C */

#if defined(MBEDTLS_BIGNUM_C)
    if( use_ret == -(MBEDTLS_ERR_MPI_FILE_IO_ERROR) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - An error occurred while reading from or writing to a file"" );
    if( use_ret == -(MBEDTLS_ERR_MPI_BAD_INPUT_DATA) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - Bad input parameters to function"" );
    if( use_ret == -(MBEDTLS_ERR_MPI_INVALID_CHARACTER) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - There is an invalid character in the digit string"" );
    if( use_ret == -(MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - The buffer is too small to write to"" );
    if( use_ret == -(MBEDTLS_ERR_MPI_NEGATIVE_VALUE) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - The input arguments are negative or result in illegal output"" );
    if( use_ret == -(MBEDTLS_ERR_MPI_DIVISION_BY_ZERO) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - The input argument for division is zero, which is not allowed"" );
    if( use_ret == -(MBEDTLS_ERR_MPI_NOT_ACCEPTABLE) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - The input arguments are not acceptable"" );
    if( use_ret == -(MBEDTLS_ERR_MPI_ALLOC_FAILED) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - Memory allocation failed"" );
#endif /* MBEDTLS_BIGNUM_C */

#if defined(MBEDTLS_BLOWFISH_C)
    if( use_ret == -(MBEDTLS_ERR_BLOWFISH_INVALID_KEY_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""BLOWFISH - Invalid key length"" );
    if( use_ret == -(MBEDTLS_ERR_BLOWFISH_INVALID_INPUT_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""BLOWFISH - Invalid data input length"" );
#endif /* MBEDTLS_BLOWFISH_C */

#if defined(MBEDTLS_CAMELLIA_C)
    if( use_ret == -(MBEDTLS_ERR_CAMELLIA_INVALID_KEY_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""CAMELLIA - Invalid key length"" );
    if( use_ret == -(MBEDTLS_ERR_CAMELLIA_INVALID_INPUT_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""CAMELLIA - Invalid data input length"" );
#endif /* MBEDTLS_CAMELLIA_C */

#if defined(MBEDTLS_CCM_C)
    if( use_ret == -(MBEDTLS_ERR_CCM_BAD_INPUT) )
        mbedtls_snprintf( buf, buflen, ""CCM - Bad input parameters to function"" );
    if( use_ret == -(MBEDTLS_ERR_CCM_AUTH_FAILED) )
        mbedtls_snprintf( buf, buflen, ""CCM - Authenticated decryption failed"" );
#endif /* MBEDTLS_CCM_C */

#if defined(MBEDTLS_CTR_DRBG_C)
    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED) )
        mbedtls_snprintf( buf, buflen, ""CTR_DRBG - The entropy source failed"" );
    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG) )
        mbedtls_snprintf( buf, buflen, ""CTR_DRBG - Too many random requested in single call"" );
    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG) )
        mbedtls_snprintf( buf, buflen, ""CTR_DRBG - Input too large (Entropy + additional)"" );
    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR) )
        mbedtls_snprintf( buf, buflen, ""CTR_DRBG - Read/write error in file"" );
#endif /* MBEDTLS_CTR_DRBG_C */

#if defined(MBEDTLS_DES_C)
    if( use_ret == -(MBEDTLS_ERR_DES_INVALID_INPUT_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""DES - The data input has an invalid length"" );
#endif /* MBEDTLS_DES_C */

#if defined(MBEDTLS_ENTROPY_C)
    if( use_ret == -(MBEDTLS_ERR_ENTROPY_SOURCE_FAILED) )
        mbedtls_snprintf( buf, buflen, ""ENTROPY - Critical entropy source failure"" );
    if( use_ret == -(MBEDTLS_ERR_ENTROPY_MAX_SOURCES) )
        mbedtls_snprintf( buf, buflen, ""ENTROPY - No more sources can be added"" );
    if( use_ret == -(MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED) )
        mbedtls_snprintf( buf, buflen, ""ENTROPY - No sources have been added to poll"" );
    if( use_ret == -(MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE) )
        mbedtls_snprintf( buf, buflen, ""ENTROPY - No strong sources have been added to poll"" );
    if( use_ret == -(MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR) )
        mbedtls_snprintf( buf, buflen, ""ENTROPY - Read/write error in file"" );
#endif /* MBEDTLS_ENTROPY_C */

#if defined(MBEDTLS_GCM_C)
    if( use_ret == -(MBEDTLS_ERR_GCM_AUTH_FAILED) )
        mbedtls_snprintf( buf, buflen, ""GCM - Authenticated decryption failed"" );
    if( use_ret == -(MBEDTLS_ERR_GCM_BAD_INPUT) )
        mbedtls_snprintf( buf, buflen, ""GCM - Bad input parameters to function"" );
#endif /* MBEDTLS_GCM_C */

#if defined(MBEDTLS_HMAC_DRBG_C)
    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_REQUEST_TOO_BIG) )
        mbedtls_snprintf( buf, buflen, ""HMAC_DRBG - Too many random requested in single call"" );
    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG) )
        mbedtls_snprintf( buf, buflen, ""HMAC_DRBG - Input too large (Entropy + additional)"" );
    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_FILE_IO_ERROR) )
        mbedtls_snprintf( buf, buflen, ""HMAC_DRBG - Read/write error in file"" );
    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED) )
        mbedtls_snprintf( buf, buflen, ""HMAC_DRBG - The entropy source failed"" );
#endif /* MBEDTLS_HMAC_DRBG_C */

#if defined(MBEDTLS_NET_C)
    if( use_ret == -(MBEDTLS_ERR_NET_SOCKET_FAILED) )
        mbedtls_snprintf( buf, buflen, ""NET - Failed to open a socket"" );
    if( use_ret == -(MBEDTLS_ERR_NET_CONNECT_FAILED) )
        mbedtls_snprintf( buf, buflen, ""NET - The connection to the given server / port failed"" );
    if( use_ret == -(MBEDTLS_ERR_NET_BIND_FAILED) )
        mbedtls_snprintf( buf, buflen, ""NET - Binding of the socket failed"" );
    if( use_ret == -(MBEDTLS_ERR_NET_LISTEN_FAILED) )
        mbedtls_snprintf( buf, buflen, ""NET - Could not listen on the socket"" );
    if( use_ret == -(MBEDTLS_ERR_NET_ACCEPT_FAILED) )
        mbedtls_snprintf( buf, buflen, ""NET - Could not accept the incoming connection"" );
    if( use_ret == -(MBEDTLS_ERR_NET_RECV_FAILED) )
        mbedtls_snprintf( buf, buflen, ""NET - Reading information from the socket failed"" );
    if( use_ret == -(MBEDTLS_ERR_NET_SEND_FAILED) )
        mbedtls_snprintf( buf, buflen, ""NET - Sending information through the socket failed"" );
    if( use_ret == -(MBEDTLS_ERR_NET_CONN_RESET) )
        mbedtls_snprintf( buf, buflen, ""NET - Connection was reset by peer"" );
    if( use_ret == -(MBEDTLS_ERR_NET_UNKNOWN_HOST) )
        mbedtls_snprintf( buf, buflen, ""NET - Failed to get an IP address for the given hostname"" );
    if( use_ret == -(MBEDTLS_ERR_NET_BUFFER_TOO_SMALL) )
        mbedtls_snprintf( buf, buflen, ""NET - Buffer is too small to hold the data"" );
    if( use_ret == -(MBEDTLS_ERR_NET_INVALID_CONTEXT) )
        mbedtls_snprintf( buf, buflen, ""NET - The context is invalid, eg because it was free()ed"" );
#endif /* MBEDTLS_NET_C */

#if defined(MBEDTLS_OID_C)
    if( use_ret == -(MBEDTLS_ERR_OID_NOT_FOUND) )
        mbedtls_snprintf( buf, buflen, ""OID - OID is not found"" );
    if( use_ret == -(MBEDTLS_ERR_OID_BUF_TOO_SMALL) )
        mbedtls_snprintf( buf, buflen, ""OID - output buffer is too small"" );
#endif /* MBEDTLS_OID_C */

#if defined(MBEDTLS_PADLOCK_C)
    if( use_ret == -(MBEDTLS_ERR_PADLOCK_DATA_MISALIGNED) )
        mbedtls_snprintf( buf, buflen, ""PADLOCK - Input data should be aligned"" );
#endif /* MBEDTLS_PADLOCK_C */

#if defined(MBEDTLS_THREADING_C)
    if( use_ret == -(MBEDTLS_ERR_THREADING_FEATURE_UNAVAILABLE) )
        mbedtls_snprintf( buf, buflen, ""THREADING - The selected feature is not available"" );
    if( use_ret == -(MBEDTLS_ERR_THREADING_BAD_INPUT_DATA) )
        mbedtls_snprintf( buf, buflen, ""THREADING - Bad input parameters to function"" );
    if( use_ret == -(MBEDTLS_ERR_THREADING_MUTEX_ERROR) )
        mbedtls_snprintf( buf, buflen, ""THREADING - Locking / unlocking / free failed with error code"" );
#endif /* MBEDTLS_THREADING_C */

#if defined(MBEDTLS_XTEA_C)
    if( use_ret == -(MBEDTLS_ERR_XTEA_INVALID_INPUT_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""XTEA - The data input has an invalid length"" );
#endif /* MBEDTLS_XTEA_C */

    if( strlen( buf ) != 0 )
        return;

    mbedtls_snprintf( buf, buflen, ""UNKNOWN ERROR CODE (%04X)"", use_ret );
}
","void mbedtls_strerror( int ret, char *buf, size_t buflen )
{
    size_t len;
    int use_ret;

    if( buflen == 0 )
        return;

    memset( buf, 0x00, buflen );

    if( ret < 0 )
        ret = -ret;

    if( ret & 0xFF80 )
    {
        use_ret = ret & 0xFF80;

#if defined(MBEDTLS_CIPHER_C)
        if( use_ret == -(MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""CIPHER - The selected feature is not available"" );
        if( use_ret == -(MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""CIPHER - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_CIPHER_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""CIPHER - Failed to allocate memory"" );
        if( use_ret == -(MBEDTLS_ERR_CIPHER_INVALID_PADDING) )
            mbedtls_snprintf( buf, buflen, ""CIPHER - Input data contains invalid padding and is rejected"" );
        if( use_ret == -(MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED) )
            mbedtls_snprintf( buf, buflen, ""CIPHER - Decryption of block requires a full block"" );
        if( use_ret == -(MBEDTLS_ERR_CIPHER_AUTH_FAILED) )
            mbedtls_snprintf( buf, buflen, ""CIPHER - Authentication failed (for AEAD modes)"" );
        if( use_ret == -(MBEDTLS_ERR_CIPHER_INVALID_CONTEXT) )
            mbedtls_snprintf( buf, buflen, ""CIPHER - The context is invalid, eg because it was free()ed"" );
#endif /* MBEDTLS_CIPHER_C */

#if defined(MBEDTLS_DHM_C)
        if( use_ret == -(MBEDTLS_ERR_DHM_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""DHM - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_READ_PARAMS_FAILED) )
            mbedtls_snprintf( buf, buflen, ""DHM - Reading of the DHM parameters failed"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_MAKE_PARAMS_FAILED) )
            mbedtls_snprintf( buf, buflen, ""DHM - Making of the DHM parameters failed"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_READ_PUBLIC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""DHM - Reading of the public values failed"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_MAKE_PUBLIC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""DHM - Making of the public value failed"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_CALC_SECRET_FAILED) )
            mbedtls_snprintf( buf, buflen, ""DHM - Calculation of the DHM secret failed"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_INVALID_FORMAT) )
            mbedtls_snprintf( buf, buflen, ""DHM - The ASN.1 data is not formatted correctly"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""DHM - Allocation of memory failed"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_FILE_IO_ERROR) )
            mbedtls_snprintf( buf, buflen, ""DHM - Read/write of file failed"" );
#endif /* MBEDTLS_DHM_C */

#if defined(MBEDTLS_ECP_C)
        if( use_ret == -(MBEDTLS_ERR_ECP_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""ECP - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL) )
            mbedtls_snprintf( buf, buflen, ""ECP - The buffer is too small to write to"" );
        if( use_ret == -(MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""ECP - Requested curve not available"" );
        if( use_ret == -(MBEDTLS_ERR_ECP_VERIFY_FAILED) )
            mbedtls_snprintf( buf, buflen, ""ECP - The signature is not valid"" );
        if( use_ret == -(MBEDTLS_ERR_ECP_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""ECP - Memory allocation failed"" );
        if( use_ret == -(MBEDTLS_ERR_ECP_RANDOM_FAILED) )
            mbedtls_snprintf( buf, buflen, ""ECP - Generation of random value, such as (ephemeral) key, failed"" );
        if( use_ret == -(MBEDTLS_ERR_ECP_INVALID_KEY) )
            mbedtls_snprintf( buf, buflen, ""ECP - Invalid private or public key"" );
        if( use_ret == -(MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""ECP - Signature is valid but shorter than the user-supplied length"" );
#endif /* MBEDTLS_ECP_C */

#if defined(MBEDTLS_MD_C)
        if( use_ret == -(MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""MD - The selected feature is not available"" );
        if( use_ret == -(MBEDTLS_ERR_MD_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""MD - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_MD_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""MD - Failed to allocate memory"" );
        if( use_ret == -(MBEDTLS_ERR_MD_FILE_IO_ERROR) )
            mbedtls_snprintf( buf, buflen, ""MD - Opening or reading of file failed"" );
#endif /* MBEDTLS_MD_C */

#if defined(MBEDTLS_PEM_PARSE_C) || defined(MBEDTLS_PEM_WRITE_C)
        if( use_ret == -(MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT) )
            mbedtls_snprintf( buf, buflen, ""PEM - No PEM header or footer found"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_INVALID_DATA) )
            mbedtls_snprintf( buf, buflen, ""PEM - PEM string is not as expected"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""PEM - Failed to allocate memory"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_INVALID_ENC_IV) )
            mbedtls_snprintf( buf, buflen, ""PEM - RSA IV is not in hex-format"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_UNKNOWN_ENC_ALG) )
            mbedtls_snprintf( buf, buflen, ""PEM - Unsupported key encryption algorithm"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_PASSWORD_REQUIRED) )
            mbedtls_snprintf( buf, buflen, ""PEM - Private key password can't be empty"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_PASSWORD_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""PEM - Given private key password does not allow for correct decryption"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""PEM - Unavailable feature, e.g. hashing/encryption combination"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""PEM - Bad input parameters to function"" );
#endif /* MBEDTLS_PEM_PARSE_C || MBEDTLS_PEM_WRITE_C */

#if defined(MBEDTLS_PK_C)
        if( use_ret == -(MBEDTLS_ERR_PK_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""PK - Memory allocation failed"" );
        if( use_ret == -(MBEDTLS_ERR_PK_TYPE_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""PK - Type mismatch, eg attempt to encrypt with an ECDSA key"" );
        if( use_ret == -(MBEDTLS_ERR_PK_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""PK - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_PK_FILE_IO_ERROR) )
            mbedtls_snprintf( buf, buflen, ""PK - Read/write of file failed"" );
        if( use_ret == -(MBEDTLS_ERR_PK_KEY_INVALID_VERSION) )
            mbedtls_snprintf( buf, buflen, ""PK - Unsupported key version"" );
        if( use_ret == -(MBEDTLS_ERR_PK_KEY_INVALID_FORMAT) )
            mbedtls_snprintf( buf, buflen, ""PK - Invalid key tag or value"" );
        if( use_ret == -(MBEDTLS_ERR_PK_UNKNOWN_PK_ALG) )
            mbedtls_snprintf( buf, buflen, ""PK - Key algorithm is unsupported (only RSA and EC are supported)"" );
        if( use_ret == -(MBEDTLS_ERR_PK_PASSWORD_REQUIRED) )
            mbedtls_snprintf( buf, buflen, ""PK - Private key password can't be empty"" );
        if( use_ret == -(MBEDTLS_ERR_PK_PASSWORD_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""PK - Given private key password does not allow for correct decryption"" );
        if( use_ret == -(MBEDTLS_ERR_PK_INVALID_PUBKEY) )
            mbedtls_snprintf( buf, buflen, ""PK - The pubkey tag or value is invalid (only RSA and EC are supported)"" );
        if( use_ret == -(MBEDTLS_ERR_PK_INVALID_ALG) )
            mbedtls_snprintf( buf, buflen, ""PK - The algorithm tag or value is invalid"" );
        if( use_ret == -(MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE) )
            mbedtls_snprintf( buf, buflen, ""PK - Elliptic curve is unsupported (only NIST curves are supported)"" );
        if( use_ret == -(MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""PK - Unavailable feature, e.g. RSA disabled for RSA key"" );
        if( use_ret == -(MBEDTLS_ERR_PK_SIG_LEN_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""PK - The signature is valid but its length is less than expected"" );
#endif /* MBEDTLS_PK_C */

#if defined(MBEDTLS_PKCS12_C)
        if( use_ret == -(MBEDTLS_ERR_PKCS12_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""PKCS12 - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_PKCS12_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""PKCS12 - Feature not available, e.g. unsupported encryption scheme"" );
        if( use_ret == -(MBEDTLS_ERR_PKCS12_PBE_INVALID_FORMAT) )
            mbedtls_snprintf( buf, buflen, ""PKCS12 - PBE ASN.1 data not as expected"" );
        if( use_ret == -(MBEDTLS_ERR_PKCS12_PASSWORD_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""PKCS12 - Given private key password does not allow for correct decryption"" );
#endif /* MBEDTLS_PKCS12_C */

#if defined(MBEDTLS_PKCS5_C)
        if( use_ret == -(MBEDTLS_ERR_PKCS5_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""PKCS5 - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_PKCS5_INVALID_FORMAT) )
            mbedtls_snprintf( buf, buflen, ""PKCS5 - Unexpected ASN.1 data"" );
        if( use_ret == -(MBEDTLS_ERR_PKCS5_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""PKCS5 - Requested encryption or digest alg not available"" );
        if( use_ret == -(MBEDTLS_ERR_PKCS5_PASSWORD_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""PKCS5 - Given private key password does not allow for correct decryption"" );
#endif /* MBEDTLS_PKCS5_C */

#if defined(MBEDTLS_RSA_C)
        if( use_ret == -(MBEDTLS_ERR_RSA_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""RSA - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_INVALID_PADDING) )
            mbedtls_snprintf( buf, buflen, ""RSA - Input data contains invalid padding and is rejected"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_KEY_GEN_FAILED) )
            mbedtls_snprintf( buf, buflen, ""RSA - Something failed during generation of a key"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_KEY_CHECK_FAILED) )
            mbedtls_snprintf( buf, buflen, ""RSA - Key failed to pass the library's validity check"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_PUBLIC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""RSA - The public key operation failed"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_PRIVATE_FAILED) )
            mbedtls_snprintf( buf, buflen, ""RSA - The private key operation failed"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_VERIFY_FAILED) )
            mbedtls_snprintf( buf, buflen, ""RSA - The PKCS#1 verification failed"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE) )
            mbedtls_snprintf( buf, buflen, ""RSA - The output buffer for decryption is not large enough"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_RNG_FAILED) )
            mbedtls_snprintf( buf, buflen, ""RSA - The random generator failed to generate non-zeros"" );
#endif /* MBEDTLS_RSA_C */

#if defined(MBEDTLS_SSL_TLS_C)
        if( use_ret == -(MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""SSL - The requested feature is not available"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""SSL - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_INVALID_MAC) )
            mbedtls_snprintf( buf, buflen, ""SSL - Verification of the message MAC failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_INVALID_RECORD) )
            mbedtls_snprintf( buf, buflen, ""SSL - An invalid SSL record was received"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_CONN_EOF) )
            mbedtls_snprintf( buf, buflen, ""SSL - The connection indicated an EOF"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_UNKNOWN_CIPHER) )
            mbedtls_snprintf( buf, buflen, ""SSL - An unknown cipher was received"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN) )
            mbedtls_snprintf( buf, buflen, ""SSL - The server has no ciphersuites in common with the client"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_NO_RNG) )
            mbedtls_snprintf( buf, buflen, ""SSL - No RNG was provided to the SSL module"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE) )
            mbedtls_snprintf( buf, buflen, ""SSL - No client certification received from the client, but required by the authentication mode"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_CERTIFICATE_TOO_LARGE) )
            mbedtls_snprintf( buf, buflen, ""SSL - Our own certificate(s) is/are too large to send in an SSL message"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_CERTIFICATE_REQUIRED) )
            mbedtls_snprintf( buf, buflen, ""SSL - The own certificate is not set, but needed by the server"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED) )
            mbedtls_snprintf( buf, buflen, ""SSL - The own private key or pre-shared key is not set, but needed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_CA_CHAIN_REQUIRED) )
            mbedtls_snprintf( buf, buflen, ""SSL - No CA Chain is set, but required to operate"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE) )
            mbedtls_snprintf( buf, buflen, ""SSL - An unexpected message was received from our peer"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE) )
        {
            mbedtls_snprintf( buf, buflen, ""SSL - A fatal alert message was received from our peer"" );
            return;
        }
        if( use_ret == -(MBEDTLS_ERR_SSL_PEER_VERIFY_FAILED) )
            mbedtls_snprintf( buf, buflen, ""SSL - Verification of our peer failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY) )
            mbedtls_snprintf( buf, buflen, ""SSL - The peer notified us that the connection is going to be closed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ClientHello handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ServerHello handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the Certificate handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the CertificateRequest handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ServerKeyExchange handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO_DONE) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ServerHelloDone handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ClientKeyExchange handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ClientKeyExchange handshake message failed in DHM / ECDH Read Public"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ClientKeyExchange handshake message failed in DHM / ECDH Calculate Secret"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the CertificateVerify handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CHANGE_CIPHER_SPEC) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ChangeCipherSpec handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_FINISHED) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the Finished handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""SSL - Memory allocation failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_HW_ACCEL_FAILED) )
            mbedtls_snprintf( buf, buflen, ""SSL - Hardware acceleration function returned with error"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH) )
            mbedtls_snprintf( buf, buflen, ""SSL - Hardware acceleration function skipped / left alone data"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_COMPRESSION_FAILED) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the compression / decompression failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION) )
            mbedtls_snprintf( buf, buflen, ""SSL - Handshake protocol not within min/max boundaries"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_NEW_SESSION_TICKET) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the NewSessionTicket handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED) )
            mbedtls_snprintf( buf, buflen, ""SSL - Session ticket has expired"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""SSL - Public key type mismatch (eg, asked for RSA key exchange and presented EC key)"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY) )
            mbedtls_snprintf( buf, buflen, ""SSL - Unknown identity received (eg, PSK identity)"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_INTERNAL_ERROR) )
            mbedtls_snprintf( buf, buflen, ""SSL - Internal error (eg, unexpected failure in lower-level module)"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_COUNTER_WRAPPING) )
            mbedtls_snprintf( buf, buflen, ""SSL - A counter would wrap (eg, too many messages exchanged)"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO) )
            mbedtls_snprintf( buf, buflen, ""SSL - Unexpected message at ServerHello in renegotiation"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED) )
            mbedtls_snprintf( buf, buflen, ""SSL - DTLS client must retry for hello verification"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL) )
            mbedtls_snprintf( buf, buflen, ""SSL - A buffer is too small to receive or write a message"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE) )
            mbedtls_snprintf( buf, buflen, ""SSL - None of the common ciphersuites is usable (eg, no suitable certificate, see debug messages)"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_WANT_READ) )
            mbedtls_snprintf( buf, buflen, ""SSL - Connection requires a read call"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_WANT_WRITE) )
            mbedtls_snprintf( buf, buflen, ""SSL - Connection requires a write call"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_TIMEOUT) )
            mbedtls_snprintf( buf, buflen, ""SSL - The operation timed out"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_CLIENT_RECONNECT) )
            mbedtls_snprintf( buf, buflen, ""SSL - The client initiated a reconnect from the same port"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_UNEXPECTED_RECORD) )
            mbedtls_snprintf( buf, buflen, ""SSL - Record header looks valid but is not expected"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_NON_FATAL) )
            mbedtls_snprintf( buf, buflen, ""SSL - The alert message received indicates a non-fatal error"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH) )
            mbedtls_snprintf( buf, buflen, ""SSL - Couldn't set the hash for verifying CertificateVerify"" );
#endif /* MBEDTLS_SSL_TLS_C */

#if defined(MBEDTLS_X509_USE_C) || defined(MBEDTLS_X509_CREATE_C)
        if( use_ret == -(MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""X509 - Unavailable feature, e.g. RSA hashing/encryption combination"" );
        if( use_ret == -(MBEDTLS_ERR_X509_UNKNOWN_OID) )
            mbedtls_snprintf( buf, buflen, ""X509 - Requested OID is unknown"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_FORMAT) )
            mbedtls_snprintf( buf, buflen, ""X509 - The CRT/CRL/CSR format is invalid, e.g. different type expected"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_VERSION) )
            mbedtls_snprintf( buf, buflen, ""X509 - The CRT/CRL/CSR version element is invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_SERIAL) )
            mbedtls_snprintf( buf, buflen, ""X509 - The serial tag or value is invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_ALG) )
            mbedtls_snprintf( buf, buflen, ""X509 - The algorithm tag or value is invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_NAME) )
            mbedtls_snprintf( buf, buflen, ""X509 - The name tag or value is invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_DATE) )
            mbedtls_snprintf( buf, buflen, ""X509 - The date tag or value is invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_SIGNATURE) )
            mbedtls_snprintf( buf, buflen, ""X509 - The signature tag or value invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_EXTENSIONS) )
            mbedtls_snprintf( buf, buflen, ""X509 - The extension tag or value is invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_UNKNOWN_VERSION) )
            mbedtls_snprintf( buf, buflen, ""X509 - CRT/CRL/CSR has an unsupported version number"" );
        if( use_ret == -(MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG) )
            mbedtls_snprintf( buf, buflen, ""X509 - Signature algorithm (oid) is unsupported"" );
        if( use_ret == -(MBEDTLS_ERR_X509_SIG_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""X509 - Signature algorithms do not match. (see \\c ::mbedtls_x509_crt sig_oid)"" );
        if( use_ret == -(MBEDTLS_ERR_X509_CERT_VERIFY_FAILED) )
            mbedtls_snprintf( buf, buflen, ""X509 - Certificate verification failed, e.g. CRL, CA or signature check failed"" );
        if( use_ret == -(MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT) )
            mbedtls_snprintf( buf, buflen, ""X509 - Format not recognized as DER or PEM"" );
        if( use_ret == -(MBEDTLS_ERR_X509_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""X509 - Input invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""X509 - Allocation of memory failed"" );
        if( use_ret == -(MBEDTLS_ERR_X509_FILE_IO_ERROR) )
             mbedtls_snprintf( buf, buflen, ""X509 - Read/write of file failed"" );
         if( use_ret == -(MBEDTLS_ERR_X509_BUFFER_TOO_SMALL) )
             mbedtls_snprintf( buf, buflen, ""X509 - Destination buffer is too small"" );
 #endif /* MBEDTLS_X509_USE_C || MBEDTLS_X509_CREATE_C */
 
        if( strlen( buf ) == 0 )
            mbedtls_snprintf( buf, buflen, ""UNKNOWN ERROR CODE (%04X)"", use_ret );
    }

    use_ret = ret & ~0xFF80;

    if( use_ret == 0 )
        return;

    len = strlen( buf );

    if( len > 0 )
    {
        if( buflen - len < 5 )
            return;

        mbedtls_snprintf( buf + len, buflen - len, "" : "" );

        buf += len + 3;
        buflen -= len + 3;
    }

#if defined(MBEDTLS_AES_C)
    if( use_ret == -(MBEDTLS_ERR_AES_INVALID_KEY_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""AES - Invalid key length"" );
    if( use_ret == -(MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""AES - Invalid data input length"" );
#endif /* MBEDTLS_AES_C */

#if defined(MBEDTLS_ASN1_PARSE_C)
    if( use_ret == -(MBEDTLS_ERR_ASN1_OUT_OF_DATA) )
        mbedtls_snprintf( buf, buflen, ""ASN1 - Out of data when parsing an ASN1 data structure"" );
    if( use_ret == -(MBEDTLS_ERR_ASN1_UNEXPECTED_TAG) )
        mbedtls_snprintf( buf, buflen, ""ASN1 - ASN1 tag was of an unexpected value"" );
    if( use_ret == -(MBEDTLS_ERR_ASN1_INVALID_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""ASN1 - Error when trying to determine the length or invalid length"" );
    if( use_ret == -(MBEDTLS_ERR_ASN1_LENGTH_MISMATCH) )
        mbedtls_snprintf( buf, buflen, ""ASN1 - Actual length differs from expected length"" );
    if( use_ret == -(MBEDTLS_ERR_ASN1_INVALID_DATA) )
        mbedtls_snprintf( buf, buflen, ""ASN1 - Data is invalid. (not used)"" );
    if( use_ret == -(MBEDTLS_ERR_ASN1_ALLOC_FAILED) )
        mbedtls_snprintf( buf, buflen, ""ASN1 - Memory allocation failed"" );
    if( use_ret == -(MBEDTLS_ERR_ASN1_BUF_TOO_SMALL) )
        mbedtls_snprintf( buf, buflen, ""ASN1 - Buffer too small when writing ASN.1 data structure"" );
#endif /* MBEDTLS_ASN1_PARSE_C */

#if defined(MBEDTLS_BASE64_C)
    if( use_ret == -(MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL) )
        mbedtls_snprintf( buf, buflen, ""BASE64 - Output buffer too small"" );
    if( use_ret == -(MBEDTLS_ERR_BASE64_INVALID_CHARACTER) )
        mbedtls_snprintf( buf, buflen, ""BASE64 - Invalid character in input"" );
#endif /* MBEDTLS_BASE64_C */

#if defined(MBEDTLS_BIGNUM_C)
    if( use_ret == -(MBEDTLS_ERR_MPI_FILE_IO_ERROR) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - An error occurred while reading from or writing to a file"" );
    if( use_ret == -(MBEDTLS_ERR_MPI_BAD_INPUT_DATA) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - Bad input parameters to function"" );
    if( use_ret == -(MBEDTLS_ERR_MPI_INVALID_CHARACTER) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - There is an invalid character in the digit string"" );
    if( use_ret == -(MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - The buffer is too small to write to"" );
    if( use_ret == -(MBEDTLS_ERR_MPI_NEGATIVE_VALUE) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - The input arguments are negative or result in illegal output"" );
    if( use_ret == -(MBEDTLS_ERR_MPI_DIVISION_BY_ZERO) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - The input argument for division is zero, which is not allowed"" );
    if( use_ret == -(MBEDTLS_ERR_MPI_NOT_ACCEPTABLE) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - The input arguments are not acceptable"" );
    if( use_ret == -(MBEDTLS_ERR_MPI_ALLOC_FAILED) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - Memory allocation failed"" );
#endif /* MBEDTLS_BIGNUM_C */

#if defined(MBEDTLS_BLOWFISH_C)
    if( use_ret == -(MBEDTLS_ERR_BLOWFISH_INVALID_KEY_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""BLOWFISH - Invalid key length"" );
    if( use_ret == -(MBEDTLS_ERR_BLOWFISH_INVALID_INPUT_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""BLOWFISH - Invalid data input length"" );
#endif /* MBEDTLS_BLOWFISH_C */

#if defined(MBEDTLS_CAMELLIA_C)
    if( use_ret == -(MBEDTLS_ERR_CAMELLIA_INVALID_KEY_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""CAMELLIA - Invalid key length"" );
    if( use_ret == -(MBEDTLS_ERR_CAMELLIA_INVALID_INPUT_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""CAMELLIA - Invalid data input length"" );
#endif /* MBEDTLS_CAMELLIA_C */

#if defined(MBEDTLS_CCM_C)
    if( use_ret == -(MBEDTLS_ERR_CCM_BAD_INPUT) )
        mbedtls_snprintf( buf, buflen, ""CCM - Bad input parameters to function"" );
    if( use_ret == -(MBEDTLS_ERR_CCM_AUTH_FAILED) )
        mbedtls_snprintf( buf, buflen, ""CCM - Authenticated decryption failed"" );
#endif /* MBEDTLS_CCM_C */

#if defined(MBEDTLS_CTR_DRBG_C)
    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED) )
        mbedtls_snprintf( buf, buflen, ""CTR_DRBG - The entropy source failed"" );
    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG) )
        mbedtls_snprintf( buf, buflen, ""CTR_DRBG - Too many random requested in single call"" );
    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG) )
        mbedtls_snprintf( buf, buflen, ""CTR_DRBG - Input too large (Entropy + additional)"" );
    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR) )
        mbedtls_snprintf( buf, buflen, ""CTR_DRBG - Read/write error in file"" );
#endif /* MBEDTLS_CTR_DRBG_C */

#if defined(MBEDTLS_DES_C)
    if( use_ret == -(MBEDTLS_ERR_DES_INVALID_INPUT_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""DES - The data input has an invalid length"" );
#endif /* MBEDTLS_DES_C */

#if defined(MBEDTLS_ENTROPY_C)
    if( use_ret == -(MBEDTLS_ERR_ENTROPY_SOURCE_FAILED) )
        mbedtls_snprintf( buf, buflen, ""ENTROPY - Critical entropy source failure"" );
    if( use_ret == -(MBEDTLS_ERR_ENTROPY_MAX_SOURCES) )
        mbedtls_snprintf( buf, buflen, ""ENTROPY - No more sources can be added"" );
    if( use_ret == -(MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED) )
        mbedtls_snprintf( buf, buflen, ""ENTROPY - No sources have been added to poll"" );
    if( use_ret == -(MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE) )
        mbedtls_snprintf( buf, buflen, ""ENTROPY - No strong sources have been added to poll"" );
    if( use_ret == -(MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR) )
        mbedtls_snprintf( buf, buflen, ""ENTROPY - Read/write error in file"" );
#endif /* MBEDTLS_ENTROPY_C */

#if defined(MBEDTLS_GCM_C)
    if( use_ret == -(MBEDTLS_ERR_GCM_AUTH_FAILED) )
        mbedtls_snprintf( buf, buflen, ""GCM - Authenticated decryption failed"" );
    if( use_ret == -(MBEDTLS_ERR_GCM_BAD_INPUT) )
        mbedtls_snprintf( buf, buflen, ""GCM - Bad input parameters to function"" );
#endif /* MBEDTLS_GCM_C */

#if defined(MBEDTLS_HMAC_DRBG_C)
    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_REQUEST_TOO_BIG) )
        mbedtls_snprintf( buf, buflen, ""HMAC_DRBG - Too many random requested in single call"" );
    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG) )
        mbedtls_snprintf( buf, buflen, ""HMAC_DRBG - Input too large (Entropy + additional)"" );
    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_FILE_IO_ERROR) )
        mbedtls_snprintf( buf, buflen, ""HMAC_DRBG - Read/write error in file"" );
    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED) )
        mbedtls_snprintf( buf, buflen, ""HMAC_DRBG - The entropy source failed"" );
#endif /* MBEDTLS_HMAC_DRBG_C */

#if defined(MBEDTLS_NET_C)
    if( use_ret == -(MBEDTLS_ERR_NET_SOCKET_FAILED) )
        mbedtls_snprintf( buf, buflen, ""NET - Failed to open a socket"" );
    if( use_ret == -(MBEDTLS_ERR_NET_CONNECT_FAILED) )
        mbedtls_snprintf( buf, buflen, ""NET - The connection to the given server / port failed"" );
    if( use_ret == -(MBEDTLS_ERR_NET_BIND_FAILED) )
        mbedtls_snprintf( buf, buflen, ""NET - Binding of the socket failed"" );
    if( use_ret == -(MBEDTLS_ERR_NET_LISTEN_FAILED) )
        mbedtls_snprintf( buf, buflen, ""NET - Could not listen on the socket"" );
    if( use_ret == -(MBEDTLS_ERR_NET_ACCEPT_FAILED) )
        mbedtls_snprintf( buf, buflen, ""NET - Could not accept the incoming connection"" );
    if( use_ret == -(MBEDTLS_ERR_NET_RECV_FAILED) )
        mbedtls_snprintf( buf, buflen, ""NET - Reading information from the socket failed"" );
    if( use_ret == -(MBEDTLS_ERR_NET_SEND_FAILED) )
        mbedtls_snprintf( buf, buflen, ""NET - Sending information through the socket failed"" );
    if( use_ret == -(MBEDTLS_ERR_NET_CONN_RESET) )
        mbedtls_snprintf( buf, buflen, ""NET - Connection was reset by peer"" );
    if( use_ret == -(MBEDTLS_ERR_NET_UNKNOWN_HOST) )
        mbedtls_snprintf( buf, buflen, ""NET - Failed to get an IP address for the given hostname"" );
    if( use_ret == -(MBEDTLS_ERR_NET_BUFFER_TOO_SMALL) )
        mbedtls_snprintf( buf, buflen, ""NET - Buffer is too small to hold the data"" );
    if( use_ret == -(MBEDTLS_ERR_NET_INVALID_CONTEXT) )
        mbedtls_snprintf( buf, buflen, ""NET - The context is invalid, eg because it was free()ed"" );
#endif /* MBEDTLS_NET_C */

#if defined(MBEDTLS_OID_C)
    if( use_ret == -(MBEDTLS_ERR_OID_NOT_FOUND) )
        mbedtls_snprintf( buf, buflen, ""OID - OID is not found"" );
    if( use_ret == -(MBEDTLS_ERR_OID_BUF_TOO_SMALL) )
        mbedtls_snprintf( buf, buflen, ""OID - output buffer is too small"" );
#endif /* MBEDTLS_OID_C */

#if defined(MBEDTLS_PADLOCK_C)
    if( use_ret == -(MBEDTLS_ERR_PADLOCK_DATA_MISALIGNED) )
        mbedtls_snprintf( buf, buflen, ""PADLOCK - Input data should be aligned"" );
#endif /* MBEDTLS_PADLOCK_C */

#if defined(MBEDTLS_THREADING_C)
    if( use_ret == -(MBEDTLS_ERR_THREADING_FEATURE_UNAVAILABLE) )
        mbedtls_snprintf( buf, buflen, ""THREADING - The selected feature is not available"" );
    if( use_ret == -(MBEDTLS_ERR_THREADING_BAD_INPUT_DATA) )
        mbedtls_snprintf( buf, buflen, ""THREADING - Bad input parameters to function"" );
    if( use_ret == -(MBEDTLS_ERR_THREADING_MUTEX_ERROR) )
        mbedtls_snprintf( buf, buflen, ""THREADING - Locking / unlocking / free failed with error code"" );
#endif /* MBEDTLS_THREADING_C */

#if defined(MBEDTLS_XTEA_C)
    if( use_ret == -(MBEDTLS_ERR_XTEA_INVALID_INPUT_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""XTEA - The data input has an invalid length"" );
#endif /* MBEDTLS_XTEA_C */

    if( strlen( buf ) != 0 )
        return;

    mbedtls_snprintf( buf, buflen, ""UNKNOWN ERROR CODE (%04X)"", use_ret );
}
",C,"        if( use_ret == -(MBEDTLS_ERR_X509_FATAL_ERROR) )
            mbedtls_snprintf( buf, buflen, ""X509 - A fatal error occured, eg the chain is too long or the vrfy callback failed"" );
",,,"@@ -480,6 +480,8 @@ void mbedtls_strerror( int ret, char *buf, size_t buflen )
             mbedtls_snprintf( buf, buflen, ""X509 - Read/write of file failed"" );
         if( use_ret == -(MBEDTLS_ERR_X509_BUFFER_TOO_SMALL) )
             mbedtls_snprintf( buf, buflen, ""X509 - Destination buffer is too small"" );
+        if( use_ret == -(MBEDTLS_ERR_X509_FATAL_ERROR) )
+            mbedtls_snprintf( buf, buflen, ""X509 - A fatal error occured, eg the chain is too long or the vrfy callback failed"" );
 #endif /* MBEDTLS_X509_USE_C || MBEDTLS_X509_CREATE_C */
         // END generated code
 ",mbedtls,31458a18788b0cf0b722acda9bb2f2fe13a3fb32,d15795acd5074e0b44e71f7ede8bdfe1b48591fc,1,"void mbedtls_strerror( int ret, char *buf, size_t buflen )
{
    size_t len;
    int use_ret;

    if( buflen == 0 )
        return;

    memset( buf, 0x00, buflen );

    if( ret < 0 )
        ret = -ret;

    if( ret & 0xFF80 )
    {
        use_ret = ret & 0xFF80;

        // High level error codes
        //
        // BEGIN generated code
#if defined(MBEDTLS_CIPHER_C)
        if( use_ret == -(MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""CIPHER - The selected feature is not available"" );
        if( use_ret == -(MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""CIPHER - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_CIPHER_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""CIPHER - Failed to allocate memory"" );
        if( use_ret == -(MBEDTLS_ERR_CIPHER_INVALID_PADDING) )
            mbedtls_snprintf( buf, buflen, ""CIPHER - Input data contains invalid padding and is rejected"" );
        if( use_ret == -(MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED) )
            mbedtls_snprintf( buf, buflen, ""CIPHER - Decryption of block requires a full block"" );
        if( use_ret == -(MBEDTLS_ERR_CIPHER_AUTH_FAILED) )
            mbedtls_snprintf( buf, buflen, ""CIPHER - Authentication failed (for AEAD modes)"" );
        if( use_ret == -(MBEDTLS_ERR_CIPHER_INVALID_CONTEXT) )
            mbedtls_snprintf( buf, buflen, ""CIPHER - The context is invalid, eg because it was free()ed"" );
#endif /* MBEDTLS_CIPHER_C */

#if defined(MBEDTLS_DHM_C)
        if( use_ret == -(MBEDTLS_ERR_DHM_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""DHM - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_READ_PARAMS_FAILED) )
            mbedtls_snprintf( buf, buflen, ""DHM - Reading of the DHM parameters failed"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_MAKE_PARAMS_FAILED) )
            mbedtls_snprintf( buf, buflen, ""DHM - Making of the DHM parameters failed"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_READ_PUBLIC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""DHM - Reading of the public values failed"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_MAKE_PUBLIC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""DHM - Making of the public value failed"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_CALC_SECRET_FAILED) )
            mbedtls_snprintf( buf, buflen, ""DHM - Calculation of the DHM secret failed"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_INVALID_FORMAT) )
            mbedtls_snprintf( buf, buflen, ""DHM - The ASN.1 data is not formatted correctly"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""DHM - Allocation of memory failed"" );
        if( use_ret == -(MBEDTLS_ERR_DHM_FILE_IO_ERROR) )
            mbedtls_snprintf( buf, buflen, ""DHM - Read/write of file failed"" );
#endif /* MBEDTLS_DHM_C */

#if defined(MBEDTLS_ECP_C)
        if( use_ret == -(MBEDTLS_ERR_ECP_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""ECP - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL) )
            mbedtls_snprintf( buf, buflen, ""ECP - The buffer is too small to write to"" );
        if( use_ret == -(MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""ECP - Requested curve not available"" );
        if( use_ret == -(MBEDTLS_ERR_ECP_VERIFY_FAILED) )
            mbedtls_snprintf( buf, buflen, ""ECP - The signature is not valid"" );
        if( use_ret == -(MBEDTLS_ERR_ECP_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""ECP - Memory allocation failed"" );
        if( use_ret == -(MBEDTLS_ERR_ECP_RANDOM_FAILED) )
            mbedtls_snprintf( buf, buflen, ""ECP - Generation of random value, such as (ephemeral) key, failed"" );
        if( use_ret == -(MBEDTLS_ERR_ECP_INVALID_KEY) )
            mbedtls_snprintf( buf, buflen, ""ECP - Invalid private or public key"" );
        if( use_ret == -(MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""ECP - Signature is valid but shorter than the user-supplied length"" );
#endif /* MBEDTLS_ECP_C */

#if defined(MBEDTLS_MD_C)
        if( use_ret == -(MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""MD - The selected feature is not available"" );
        if( use_ret == -(MBEDTLS_ERR_MD_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""MD - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_MD_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""MD - Failed to allocate memory"" );
        if( use_ret == -(MBEDTLS_ERR_MD_FILE_IO_ERROR) )
            mbedtls_snprintf( buf, buflen, ""MD - Opening or reading of file failed"" );
#endif /* MBEDTLS_MD_C */

#if defined(MBEDTLS_PEM_PARSE_C) || defined(MBEDTLS_PEM_WRITE_C)
        if( use_ret == -(MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT) )
            mbedtls_snprintf( buf, buflen, ""PEM - No PEM header or footer found"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_INVALID_DATA) )
            mbedtls_snprintf( buf, buflen, ""PEM - PEM string is not as expected"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""PEM - Failed to allocate memory"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_INVALID_ENC_IV) )
            mbedtls_snprintf( buf, buflen, ""PEM - RSA IV is not in hex-format"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_UNKNOWN_ENC_ALG) )
            mbedtls_snprintf( buf, buflen, ""PEM - Unsupported key encryption algorithm"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_PASSWORD_REQUIRED) )
            mbedtls_snprintf( buf, buflen, ""PEM - Private key password can't be empty"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_PASSWORD_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""PEM - Given private key password does not allow for correct decryption"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""PEM - Unavailable feature, e.g. hashing/encryption combination"" );
        if( use_ret == -(MBEDTLS_ERR_PEM_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""PEM - Bad input parameters to function"" );
#endif /* MBEDTLS_PEM_PARSE_C || MBEDTLS_PEM_WRITE_C */

#if defined(MBEDTLS_PK_C)
        if( use_ret == -(MBEDTLS_ERR_PK_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""PK - Memory allocation failed"" );
        if( use_ret == -(MBEDTLS_ERR_PK_TYPE_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""PK - Type mismatch, eg attempt to encrypt with an ECDSA key"" );
        if( use_ret == -(MBEDTLS_ERR_PK_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""PK - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_PK_FILE_IO_ERROR) )
            mbedtls_snprintf( buf, buflen, ""PK - Read/write of file failed"" );
        if( use_ret == -(MBEDTLS_ERR_PK_KEY_INVALID_VERSION) )
            mbedtls_snprintf( buf, buflen, ""PK - Unsupported key version"" );
        if( use_ret == -(MBEDTLS_ERR_PK_KEY_INVALID_FORMAT) )
            mbedtls_snprintf( buf, buflen, ""PK - Invalid key tag or value"" );
        if( use_ret == -(MBEDTLS_ERR_PK_UNKNOWN_PK_ALG) )
            mbedtls_snprintf( buf, buflen, ""PK - Key algorithm is unsupported (only RSA and EC are supported)"" );
        if( use_ret == -(MBEDTLS_ERR_PK_PASSWORD_REQUIRED) )
            mbedtls_snprintf( buf, buflen, ""PK - Private key password can't be empty"" );
        if( use_ret == -(MBEDTLS_ERR_PK_PASSWORD_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""PK - Given private key password does not allow for correct decryption"" );
        if( use_ret == -(MBEDTLS_ERR_PK_INVALID_PUBKEY) )
            mbedtls_snprintf( buf, buflen, ""PK - The pubkey tag or value is invalid (only RSA and EC are supported)"" );
        if( use_ret == -(MBEDTLS_ERR_PK_INVALID_ALG) )
            mbedtls_snprintf( buf, buflen, ""PK - The algorithm tag or value is invalid"" );
        if( use_ret == -(MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE) )
            mbedtls_snprintf( buf, buflen, ""PK - Elliptic curve is unsupported (only NIST curves are supported)"" );
        if( use_ret == -(MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""PK - Unavailable feature, e.g. RSA disabled for RSA key"" );
        if( use_ret == -(MBEDTLS_ERR_PK_SIG_LEN_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""PK - The signature is valid but its length is less than expected"" );
#endif /* MBEDTLS_PK_C */

#if defined(MBEDTLS_PKCS12_C)
        if( use_ret == -(MBEDTLS_ERR_PKCS12_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""PKCS12 - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_PKCS12_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""PKCS12 - Feature not available, e.g. unsupported encryption scheme"" );
        if( use_ret == -(MBEDTLS_ERR_PKCS12_PBE_INVALID_FORMAT) )
            mbedtls_snprintf( buf, buflen, ""PKCS12 - PBE ASN.1 data not as expected"" );
        if( use_ret == -(MBEDTLS_ERR_PKCS12_PASSWORD_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""PKCS12 - Given private key password does not allow for correct decryption"" );
#endif /* MBEDTLS_PKCS12_C */

#if defined(MBEDTLS_PKCS5_C)
        if( use_ret == -(MBEDTLS_ERR_PKCS5_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""PKCS5 - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_PKCS5_INVALID_FORMAT) )
            mbedtls_snprintf( buf, buflen, ""PKCS5 - Unexpected ASN.1 data"" );
        if( use_ret == -(MBEDTLS_ERR_PKCS5_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""PKCS5 - Requested encryption or digest alg not available"" );
        if( use_ret == -(MBEDTLS_ERR_PKCS5_PASSWORD_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""PKCS5 - Given private key password does not allow for correct decryption"" );
#endif /* MBEDTLS_PKCS5_C */

#if defined(MBEDTLS_RSA_C)
        if( use_ret == -(MBEDTLS_ERR_RSA_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""RSA - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_INVALID_PADDING) )
            mbedtls_snprintf( buf, buflen, ""RSA - Input data contains invalid padding and is rejected"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_KEY_GEN_FAILED) )
            mbedtls_snprintf( buf, buflen, ""RSA - Something failed during generation of a key"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_KEY_CHECK_FAILED) )
            mbedtls_snprintf( buf, buflen, ""RSA - Key failed to pass the library's validity check"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_PUBLIC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""RSA - The public key operation failed"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_PRIVATE_FAILED) )
            mbedtls_snprintf( buf, buflen, ""RSA - The private key operation failed"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_VERIFY_FAILED) )
            mbedtls_snprintf( buf, buflen, ""RSA - The PKCS#1 verification failed"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE) )
            mbedtls_snprintf( buf, buflen, ""RSA - The output buffer for decryption is not large enough"" );
        if( use_ret == -(MBEDTLS_ERR_RSA_RNG_FAILED) )
            mbedtls_snprintf( buf, buflen, ""RSA - The random generator failed to generate non-zeros"" );
#endif /* MBEDTLS_RSA_C */

#if defined(MBEDTLS_SSL_TLS_C)
        if( use_ret == -(MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""SSL - The requested feature is not available"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""SSL - Bad input parameters to function"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_INVALID_MAC) )
            mbedtls_snprintf( buf, buflen, ""SSL - Verification of the message MAC failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_INVALID_RECORD) )
            mbedtls_snprintf( buf, buflen, ""SSL - An invalid SSL record was received"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_CONN_EOF) )
            mbedtls_snprintf( buf, buflen, ""SSL - The connection indicated an EOF"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_UNKNOWN_CIPHER) )
            mbedtls_snprintf( buf, buflen, ""SSL - An unknown cipher was received"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN) )
            mbedtls_snprintf( buf, buflen, ""SSL - The server has no ciphersuites in common with the client"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_NO_RNG) )
            mbedtls_snprintf( buf, buflen, ""SSL - No RNG was provided to the SSL module"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE) )
            mbedtls_snprintf( buf, buflen, ""SSL - No client certification received from the client, but required by the authentication mode"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_CERTIFICATE_TOO_LARGE) )
            mbedtls_snprintf( buf, buflen, ""SSL - Our own certificate(s) is/are too large to send in an SSL message"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_CERTIFICATE_REQUIRED) )
            mbedtls_snprintf( buf, buflen, ""SSL - The own certificate is not set, but needed by the server"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED) )
            mbedtls_snprintf( buf, buflen, ""SSL - The own private key or pre-shared key is not set, but needed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_CA_CHAIN_REQUIRED) )
            mbedtls_snprintf( buf, buflen, ""SSL - No CA Chain is set, but required to operate"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE) )
            mbedtls_snprintf( buf, buflen, ""SSL - An unexpected message was received from our peer"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE) )
        {
            mbedtls_snprintf( buf, buflen, ""SSL - A fatal alert message was received from our peer"" );
            return;
        }
        if( use_ret == -(MBEDTLS_ERR_SSL_PEER_VERIFY_FAILED) )
            mbedtls_snprintf( buf, buflen, ""SSL - Verification of our peer failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY) )
            mbedtls_snprintf( buf, buflen, ""SSL - The peer notified us that the connection is going to be closed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ClientHello handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ServerHello handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the Certificate handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the CertificateRequest handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ServerKeyExchange handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO_DONE) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ServerHelloDone handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ClientKeyExchange handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ClientKeyExchange handshake message failed in DHM / ECDH Read Public"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ClientKeyExchange handshake message failed in DHM / ECDH Calculate Secret"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the CertificateVerify handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CHANGE_CIPHER_SPEC) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the ChangeCipherSpec handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_FINISHED) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the Finished handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""SSL - Memory allocation failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_HW_ACCEL_FAILED) )
            mbedtls_snprintf( buf, buflen, ""SSL - Hardware acceleration function returned with error"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH) )
            mbedtls_snprintf( buf, buflen, ""SSL - Hardware acceleration function skipped / left alone data"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_COMPRESSION_FAILED) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the compression / decompression failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION) )
            mbedtls_snprintf( buf, buflen, ""SSL - Handshake protocol not within min/max boundaries"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_NEW_SESSION_TICKET) )
            mbedtls_snprintf( buf, buflen, ""SSL - Processing of the NewSessionTicket handshake message failed"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED) )
            mbedtls_snprintf( buf, buflen, ""SSL - Session ticket has expired"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""SSL - Public key type mismatch (eg, asked for RSA key exchange and presented EC key)"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY) )
            mbedtls_snprintf( buf, buflen, ""SSL - Unknown identity received (eg, PSK identity)"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_INTERNAL_ERROR) )
            mbedtls_snprintf( buf, buflen, ""SSL - Internal error (eg, unexpected failure in lower-level module)"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_COUNTER_WRAPPING) )
            mbedtls_snprintf( buf, buflen, ""SSL - A counter would wrap (eg, too many messages exchanged)"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO) )
            mbedtls_snprintf( buf, buflen, ""SSL - Unexpected message at ServerHello in renegotiation"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED) )
            mbedtls_snprintf( buf, buflen, ""SSL - DTLS client must retry for hello verification"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL) )
            mbedtls_snprintf( buf, buflen, ""SSL - A buffer is too small to receive or write a message"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE) )
            mbedtls_snprintf( buf, buflen, ""SSL - None of the common ciphersuites is usable (eg, no suitable certificate, see debug messages)"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_WANT_READ) )
            mbedtls_snprintf( buf, buflen, ""SSL - Connection requires a read call"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_WANT_WRITE) )
            mbedtls_snprintf( buf, buflen, ""SSL - Connection requires a write call"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_TIMEOUT) )
            mbedtls_snprintf( buf, buflen, ""SSL - The operation timed out"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_CLIENT_RECONNECT) )
            mbedtls_snprintf( buf, buflen, ""SSL - The client initiated a reconnect from the same port"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_UNEXPECTED_RECORD) )
            mbedtls_snprintf( buf, buflen, ""SSL - Record header looks valid but is not expected"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_NON_FATAL) )
            mbedtls_snprintf( buf, buflen, ""SSL - The alert message received indicates a non-fatal error"" );
        if( use_ret == -(MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH) )
            mbedtls_snprintf( buf, buflen, ""SSL - Couldn't set the hash for verifying CertificateVerify"" );
#endif /* MBEDTLS_SSL_TLS_C */

#if defined(MBEDTLS_X509_USE_C) || defined(MBEDTLS_X509_CREATE_C)
        if( use_ret == -(MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE) )
            mbedtls_snprintf( buf, buflen, ""X509 - Unavailable feature, e.g. RSA hashing/encryption combination"" );
        if( use_ret == -(MBEDTLS_ERR_X509_UNKNOWN_OID) )
            mbedtls_snprintf( buf, buflen, ""X509 - Requested OID is unknown"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_FORMAT) )
            mbedtls_snprintf( buf, buflen, ""X509 - The CRT/CRL/CSR format is invalid, e.g. different type expected"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_VERSION) )
            mbedtls_snprintf( buf, buflen, ""X509 - The CRT/CRL/CSR version element is invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_SERIAL) )
            mbedtls_snprintf( buf, buflen, ""X509 - The serial tag or value is invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_ALG) )
            mbedtls_snprintf( buf, buflen, ""X509 - The algorithm tag or value is invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_NAME) )
            mbedtls_snprintf( buf, buflen, ""X509 - The name tag or value is invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_DATE) )
            mbedtls_snprintf( buf, buflen, ""X509 - The date tag or value is invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_SIGNATURE) )
            mbedtls_snprintf( buf, buflen, ""X509 - The signature tag or value invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_EXTENSIONS) )
            mbedtls_snprintf( buf, buflen, ""X509 - The extension tag or value is invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_UNKNOWN_VERSION) )
            mbedtls_snprintf( buf, buflen, ""X509 - CRT/CRL/CSR has an unsupported version number"" );
        if( use_ret == -(MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG) )
            mbedtls_snprintf( buf, buflen, ""X509 - Signature algorithm (oid) is unsupported"" );
        if( use_ret == -(MBEDTLS_ERR_X509_SIG_MISMATCH) )
            mbedtls_snprintf( buf, buflen, ""X509 - Signature algorithms do not match. (see \\c ::mbedtls_x509_crt sig_oid)"" );
        if( use_ret == -(MBEDTLS_ERR_X509_CERT_VERIFY_FAILED) )
            mbedtls_snprintf( buf, buflen, ""X509 - Certificate verification failed, e.g. CRL, CA or signature check failed"" );
        if( use_ret == -(MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT) )
            mbedtls_snprintf( buf, buflen, ""X509 - Format not recognized as DER or PEM"" );
        if( use_ret == -(MBEDTLS_ERR_X509_BAD_INPUT_DATA) )
            mbedtls_snprintf( buf, buflen, ""X509 - Input invalid"" );
        if( use_ret == -(MBEDTLS_ERR_X509_ALLOC_FAILED) )
            mbedtls_snprintf( buf, buflen, ""X509 - Allocation of memory failed"" );
        if( use_ret == -(MBEDTLS_ERR_X509_FILE_IO_ERROR) )
             mbedtls_snprintf( buf, buflen, ""X509 - Read/write of file failed"" );
         if( use_ret == -(MBEDTLS_ERR_X509_BUFFER_TOO_SMALL) )
             mbedtls_snprintf( buf, buflen, ""X509 - Destination buffer is too small"" );
//fix_flaw_line_below:
//        if( use_ret == -(MBEDTLS_ERR_X509_FATAL_ERROR) )
//fix_flaw_line_below:
//            mbedtls_snprintf( buf, buflen, ""X509 - A fatal error occured, eg the chain is too long or the vrfy callback failed"" );
 #endif /* MBEDTLS_X509_USE_C || MBEDTLS_X509_CREATE_C */
         // END generated code
 
        if( strlen( buf ) == 0 )
            mbedtls_snprintf( buf, buflen, ""UNKNOWN ERROR CODE (%04X)"", use_ret );
    }

    use_ret = ret & ~0xFF80;

    if( use_ret == 0 )
        return;

    // If high level code is present, make a concatenation between both
    // error strings.
    //
    len = strlen( buf );

    if( len > 0 )
    {
        if( buflen - len < 5 )
            return;

        mbedtls_snprintf( buf + len, buflen - len, "" : "" );

        buf += len + 3;
        buflen -= len + 3;
    }

    // Low level error codes
    //
    // BEGIN generated code
#if defined(MBEDTLS_AES_C)
    if( use_ret == -(MBEDTLS_ERR_AES_INVALID_KEY_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""AES - Invalid key length"" );
    if( use_ret == -(MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""AES - Invalid data input length"" );
#endif /* MBEDTLS_AES_C */

#if defined(MBEDTLS_ASN1_PARSE_C)
    if( use_ret == -(MBEDTLS_ERR_ASN1_OUT_OF_DATA) )
        mbedtls_snprintf( buf, buflen, ""ASN1 - Out of data when parsing an ASN1 data structure"" );
    if( use_ret == -(MBEDTLS_ERR_ASN1_UNEXPECTED_TAG) )
        mbedtls_snprintf( buf, buflen, ""ASN1 - ASN1 tag was of an unexpected value"" );
    if( use_ret == -(MBEDTLS_ERR_ASN1_INVALID_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""ASN1 - Error when trying to determine the length or invalid length"" );
    if( use_ret == -(MBEDTLS_ERR_ASN1_LENGTH_MISMATCH) )
        mbedtls_snprintf( buf, buflen, ""ASN1 - Actual length differs from expected length"" );
    if( use_ret == -(MBEDTLS_ERR_ASN1_INVALID_DATA) )
        mbedtls_snprintf( buf, buflen, ""ASN1 - Data is invalid. (not used)"" );
    if( use_ret == -(MBEDTLS_ERR_ASN1_ALLOC_FAILED) )
        mbedtls_snprintf( buf, buflen, ""ASN1 - Memory allocation failed"" );
    if( use_ret == -(MBEDTLS_ERR_ASN1_BUF_TOO_SMALL) )
        mbedtls_snprintf( buf, buflen, ""ASN1 - Buffer too small when writing ASN.1 data structure"" );
#endif /* MBEDTLS_ASN1_PARSE_C */

#if defined(MBEDTLS_BASE64_C)
    if( use_ret == -(MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL) )
        mbedtls_snprintf( buf, buflen, ""BASE64 - Output buffer too small"" );
    if( use_ret == -(MBEDTLS_ERR_BASE64_INVALID_CHARACTER) )
        mbedtls_snprintf( buf, buflen, ""BASE64 - Invalid character in input"" );
#endif /* MBEDTLS_BASE64_C */

#if defined(MBEDTLS_BIGNUM_C)
    if( use_ret == -(MBEDTLS_ERR_MPI_FILE_IO_ERROR) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - An error occurred while reading from or writing to a file"" );
    if( use_ret == -(MBEDTLS_ERR_MPI_BAD_INPUT_DATA) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - Bad input parameters to function"" );
    if( use_ret == -(MBEDTLS_ERR_MPI_INVALID_CHARACTER) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - There is an invalid character in the digit string"" );
    if( use_ret == -(MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - The buffer is too small to write to"" );
    if( use_ret == -(MBEDTLS_ERR_MPI_NEGATIVE_VALUE) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - The input arguments are negative or result in illegal output"" );
    if( use_ret == -(MBEDTLS_ERR_MPI_DIVISION_BY_ZERO) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - The input argument for division is zero, which is not allowed"" );
    if( use_ret == -(MBEDTLS_ERR_MPI_NOT_ACCEPTABLE) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - The input arguments are not acceptable"" );
    if( use_ret == -(MBEDTLS_ERR_MPI_ALLOC_FAILED) )
        mbedtls_snprintf( buf, buflen, ""BIGNUM - Memory allocation failed"" );
#endif /* MBEDTLS_BIGNUM_C */

#if defined(MBEDTLS_BLOWFISH_C)
    if( use_ret == -(MBEDTLS_ERR_BLOWFISH_INVALID_KEY_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""BLOWFISH - Invalid key length"" );
    if( use_ret == -(MBEDTLS_ERR_BLOWFISH_INVALID_INPUT_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""BLOWFISH - Invalid data input length"" );
#endif /* MBEDTLS_BLOWFISH_C */

#if defined(MBEDTLS_CAMELLIA_C)
    if( use_ret == -(MBEDTLS_ERR_CAMELLIA_INVALID_KEY_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""CAMELLIA - Invalid key length"" );
    if( use_ret == -(MBEDTLS_ERR_CAMELLIA_INVALID_INPUT_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""CAMELLIA - Invalid data input length"" );
#endif /* MBEDTLS_CAMELLIA_C */

#if defined(MBEDTLS_CCM_C)
    if( use_ret == -(MBEDTLS_ERR_CCM_BAD_INPUT) )
        mbedtls_snprintf( buf, buflen, ""CCM - Bad input parameters to function"" );
    if( use_ret == -(MBEDTLS_ERR_CCM_AUTH_FAILED) )
        mbedtls_snprintf( buf, buflen, ""CCM - Authenticated decryption failed"" );
#endif /* MBEDTLS_CCM_C */

#if defined(MBEDTLS_CTR_DRBG_C)
    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED) )
        mbedtls_snprintf( buf, buflen, ""CTR_DRBG - The entropy source failed"" );
    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG) )
        mbedtls_snprintf( buf, buflen, ""CTR_DRBG - Too many random requested in single call"" );
    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG) )
        mbedtls_snprintf( buf, buflen, ""CTR_DRBG - Input too large (Entropy + additional)"" );
    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR) )
        mbedtls_snprintf( buf, buflen, ""CTR_DRBG - Read/write error in file"" );
#endif /* MBEDTLS_CTR_DRBG_C */

#if defined(MBEDTLS_DES_C)
    if( use_ret == -(MBEDTLS_ERR_DES_INVALID_INPUT_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""DES - The data input has an invalid length"" );
#endif /* MBEDTLS_DES_C */

#if defined(MBEDTLS_ENTROPY_C)
    if( use_ret == -(MBEDTLS_ERR_ENTROPY_SOURCE_FAILED) )
        mbedtls_snprintf( buf, buflen, ""ENTROPY - Critical entropy source failure"" );
    if( use_ret == -(MBEDTLS_ERR_ENTROPY_MAX_SOURCES) )
        mbedtls_snprintf( buf, buflen, ""ENTROPY - No more sources can be added"" );
    if( use_ret == -(MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED) )
        mbedtls_snprintf( buf, buflen, ""ENTROPY - No sources have been added to poll"" );
    if( use_ret == -(MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE) )
        mbedtls_snprintf( buf, buflen, ""ENTROPY - No strong sources have been added to poll"" );
    if( use_ret == -(MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR) )
        mbedtls_snprintf( buf, buflen, ""ENTROPY - Read/write error in file"" );
#endif /* MBEDTLS_ENTROPY_C */

#if defined(MBEDTLS_GCM_C)
    if( use_ret == -(MBEDTLS_ERR_GCM_AUTH_FAILED) )
        mbedtls_snprintf( buf, buflen, ""GCM - Authenticated decryption failed"" );
    if( use_ret == -(MBEDTLS_ERR_GCM_BAD_INPUT) )
        mbedtls_snprintf( buf, buflen, ""GCM - Bad input parameters to function"" );
#endif /* MBEDTLS_GCM_C */

#if defined(MBEDTLS_HMAC_DRBG_C)
    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_REQUEST_TOO_BIG) )
        mbedtls_snprintf( buf, buflen, ""HMAC_DRBG - Too many random requested in single call"" );
    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG) )
        mbedtls_snprintf( buf, buflen, ""HMAC_DRBG - Input too large (Entropy + additional)"" );
    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_FILE_IO_ERROR) )
        mbedtls_snprintf( buf, buflen, ""HMAC_DRBG - Read/write error in file"" );
    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED) )
        mbedtls_snprintf( buf, buflen, ""HMAC_DRBG - The entropy source failed"" );
#endif /* MBEDTLS_HMAC_DRBG_C */

#if defined(MBEDTLS_NET_C)
    if( use_ret == -(MBEDTLS_ERR_NET_SOCKET_FAILED) )
        mbedtls_snprintf( buf, buflen, ""NET - Failed to open a socket"" );
    if( use_ret == -(MBEDTLS_ERR_NET_CONNECT_FAILED) )
        mbedtls_snprintf( buf, buflen, ""NET - The connection to the given server / port failed"" );
    if( use_ret == -(MBEDTLS_ERR_NET_BIND_FAILED) )
        mbedtls_snprintf( buf, buflen, ""NET - Binding of the socket failed"" );
    if( use_ret == -(MBEDTLS_ERR_NET_LISTEN_FAILED) )
        mbedtls_snprintf( buf, buflen, ""NET - Could not listen on the socket"" );
    if( use_ret == -(MBEDTLS_ERR_NET_ACCEPT_FAILED) )
        mbedtls_snprintf( buf, buflen, ""NET - Could not accept the incoming connection"" );
    if( use_ret == -(MBEDTLS_ERR_NET_RECV_FAILED) )
        mbedtls_snprintf( buf, buflen, ""NET - Reading information from the socket failed"" );
    if( use_ret == -(MBEDTLS_ERR_NET_SEND_FAILED) )
        mbedtls_snprintf( buf, buflen, ""NET - Sending information through the socket failed"" );
    if( use_ret == -(MBEDTLS_ERR_NET_CONN_RESET) )
        mbedtls_snprintf( buf, buflen, ""NET - Connection was reset by peer"" );
    if( use_ret == -(MBEDTLS_ERR_NET_UNKNOWN_HOST) )
        mbedtls_snprintf( buf, buflen, ""NET - Failed to get an IP address for the given hostname"" );
    if( use_ret == -(MBEDTLS_ERR_NET_BUFFER_TOO_SMALL) )
        mbedtls_snprintf( buf, buflen, ""NET - Buffer is too small to hold the data"" );
    if( use_ret == -(MBEDTLS_ERR_NET_INVALID_CONTEXT) )
        mbedtls_snprintf( buf, buflen, ""NET - The context is invalid, eg because it was free()ed"" );
#endif /* MBEDTLS_NET_C */

#if defined(MBEDTLS_OID_C)
    if( use_ret == -(MBEDTLS_ERR_OID_NOT_FOUND) )
        mbedtls_snprintf( buf, buflen, ""OID - OID is not found"" );
    if( use_ret == -(MBEDTLS_ERR_OID_BUF_TOO_SMALL) )
        mbedtls_snprintf( buf, buflen, ""OID - output buffer is too small"" );
#endif /* MBEDTLS_OID_C */

#if defined(MBEDTLS_PADLOCK_C)
    if( use_ret == -(MBEDTLS_ERR_PADLOCK_DATA_MISALIGNED) )
        mbedtls_snprintf( buf, buflen, ""PADLOCK - Input data should be aligned"" );
#endif /* MBEDTLS_PADLOCK_C */

#if defined(MBEDTLS_THREADING_C)
    if( use_ret == -(MBEDTLS_ERR_THREADING_FEATURE_UNAVAILABLE) )
        mbedtls_snprintf( buf, buflen, ""THREADING - The selected feature is not available"" );
    if( use_ret == -(MBEDTLS_ERR_THREADING_BAD_INPUT_DATA) )
        mbedtls_snprintf( buf, buflen, ""THREADING - Bad input parameters to function"" );
    if( use_ret == -(MBEDTLS_ERR_THREADING_MUTEX_ERROR) )
        mbedtls_snprintf( buf, buflen, ""THREADING - Locking / unlocking / free failed with error code"" );
#endif /* MBEDTLS_THREADING_C */

#if defined(MBEDTLS_XTEA_C)
    if( use_ret == -(MBEDTLS_ERR_XTEA_INVALID_INPUT_LENGTH) )
        mbedtls_snprintf( buf, buflen, ""XTEA - The data input has an invalid length"" );
#endif /* MBEDTLS_XTEA_C */
    // END generated code

    if( strlen( buf ) != 0 )
        return;

    mbedtls_snprintf( buf, buflen, ""UNKNOWN ERROR CODE (%04X)"", use_ret );
}
"
5455,183191,,Remote,Not required,Partial,CVE-2017-14032,https://www.cvedetails.com/cve/CVE-2017-14032/,CWE-287,Medium,Partial,Partial,,2017-08-30,6.8,"ARM mbed TLS before 1.3.21 and 2.x before 2.1.9, if optional authentication is configured, allows remote attackers to bypass peer authentication via an X.509 certificate chain with many intermediates. NOTE: although mbed TLS was formerly known as PolarSSL, the releases shipped with the PolarSSL name are not affected.",2017-11-07,Bypass ,4,https://github.com/ARMmbed/mbedtls/commit/31458a18788b0cf0b722acda9bb2f2fe13a3fb32,31458a18788b0cf0b722acda9bb2f2fe13a3fb32,"Only return VERIFY_FAILED from a single point

Everything else is a fatal error. Also improve documentation about that for
the vrfy callback.",0,library/x509_crt.c,"{""sha"": ""d35457b962a4b9916fa9e4768d566c61eaa37bbe"", ""filename"": ""ChangeLog"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/ChangeLog"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/ChangeLog?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -6,6 +6,9 @@ Changes\n    * Certificate verification functions now set flags to -1 in case the full\n      chain was not verified due to an internal error (including in the verify\n      callback) or chain length limitations.\n+   * With authmode set to optional, handshake is now aborted if the\n+     verification of the peer's certificate failed due to an overlong chain or\n+     a fatal error in the vrfy callback.\n \n = mbed TLS 2.5.1 released 2017-06-21\n ""}<_**next**_>{""sha"": ""31591e2d6439baef544ec687a834ff322adafeff"", ""filename"": ""include/mbedtls/error.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/error.h"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/error.h"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/include/mbedtls/error.h?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -71,7 +71,7 @@\n  * Name      ID  Nr of Errors\n  * PEM       1   9\n  * PKCS#12   1   4 (Started from top)\n- * X509      2   19\n+ * X509      2   20\n  * PKCS5     2   4 (Started from top)\n  * DHM       3   9\n  * PK        3   14 (Started from top)""}<_**next**_>{""sha"": ""cc0007006280b4e382b90809484b76bd62c6035b"", ""filename"": ""include/mbedtls/ssl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/ssl.h"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/ssl.h"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/include/mbedtls/ssl.h?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -1052,7 +1052,7 @@ void mbedtls_ssl_conf_authmode( mbedtls_ssl_config *conf, int authmode );\n  *\n  *                 If set, the verify callback is called for each\n  *                 certificate in the chain. For implementation\n- *                 information, please see \\c x509parse_verify()\n+ *                 information, please see \\c mbedtls_x509_crt_verify()\n  *\n  * \\param conf     SSL configuration\n  * \\param f_vrfy   verification function""}<_**next**_>{""sha"": ""128eaded6fb7b2b17dda917fb024d8dd1421eecf"", ""filename"": ""include/mbedtls/x509.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/x509.h"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/x509.h"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/include/mbedtls/x509.h?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -76,6 +76,7 @@\n #define MBEDTLS_ERR_X509_ALLOC_FAILED                     -0x2880  /**< Allocation of memory failed. */\n #define MBEDTLS_ERR_X509_FILE_IO_ERROR                    -0x2900  /**< Read/write of file failed. */\n #define MBEDTLS_ERR_X509_BUFFER_TOO_SMALL                 -0x2980  /**< Destination buffer is too small. */\n+#define MBEDTLS_ERR_X509_FATAL_ERROR                      -0x3000  /**< A fatal error occured, eg the chain is too long or the vrfy callback failed. */\n /* \\} name */\n \n /**""}<_**next**_>{""sha"": ""fd203360c631cea5667abe09b6e6084380a613c6"", ""filename"": ""include/mbedtls/x509_crt.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/x509_crt.h"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/x509_crt.h"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/include/mbedtls/x509_crt.h?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -267,7 +267,13 @@ int mbedtls_x509_crt_verify_info( char *buf, size_t size, const char *prefix,\n  *\n  *                 All flags left after returning from the callback\n  *                 are also returned to the application. The function should\n- *                 return 0 for anything but a fatal error.\n+ *                 return 0 for anything (including invalid certificates)\n+ *                 other than fatal error, as a non-zero return code\n+ *                 immediately aborts the verification process. For fatal\n+ *                 errors, a specific error code should be used (different\n+ *                 from MBEDTLS_ERR_X509_CERT_VERIFY_FAILED which should not\n+ *                 be returned at this point), or MBEDTLS_ERR_X509_FATAL_ERROR\n+ *                 can be used if no better code is available.\n  *\n  * \\note           In case verification failed, the results can be displayed\n  *                 using \\c mbedtls_x509_crt_verify_info()""}<_**next**_>{""sha"": ""db42381c427c4d3e38cbb981bee9757edcc69001"", ""filename"": ""library/error.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/library/error.c"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/library/error.c"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/library/error.c?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -480,6 +480,8 @@ void mbedtls_strerror( int ret, char *buf, size_t buflen )\n             mbedtls_snprintf( buf, buflen, \""X509 - Read/write of file failed\"" );\n         if( use_ret == -(MBEDTLS_ERR_X509_BUFFER_TOO_SMALL) )\n             mbedtls_snprintf( buf, buflen, \""X509 - Destination buffer is too small\"" );\n+        if( use_ret == -(MBEDTLS_ERR_X509_FATAL_ERROR) )\n+            mbedtls_snprintf( buf, buflen, \""X509 - A fatal error occured, eg the chain is too long or the vrfy callback failed\"" );\n #endif /* MBEDTLS_X509_USE_C || MBEDTLS_X509_CREATE_C */\n         // END generated code\n ""}<_**next**_>{""sha"": ""ec5f77268db943a51a4eda88c27a37124b15c63c"", ""filename"": ""library/x509_crt.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 2, ""changes"": 8, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/library/x509_crt.c"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/library/x509_crt.c"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/library/x509_crt.c?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -2057,8 +2057,8 @@ static int x509_crt_verify_child(\n     /* path_cnt is 0 for the first intermediate CA */\n     if( 1 + path_cnt > MBEDTLS_X509_MAX_INTERMEDIATE_CA )\n     {\n-        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n-        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n+        /* return immediately as the goal is to avoid unbounded recursion */\n+        return( MBEDTLS_ERR_X509_FATAL_ERROR );\n     }\n \n     if( mbedtls_x509_time_is_past( &child->valid_to ) )\n@@ -2310,6 +2310,10 @@ int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,\n     }\n \n exit:\n+    /* prevent misuse of the vrfy callback */\n+    if( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED )\n+        ret = MBEDTLS_ERR_X509_FATAL_ERROR;\n+\n     if( ret != 0 )\n     {\n         *flags = (uint32_t) -1;""}<_**next**_>{""sha"": ""ea56f3fbc76312734f4eb41fa3da1cbb5ca7bc14"", ""filename"": ""tests/suites/test_suite_x509parse.data"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/tests/suites/test_suite_x509parse.data"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/tests/suites/test_suite_x509parse.data"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/tests/suites/test_suite_x509parse.data?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -1204,7 +1204,7 @@ mbedtls_x509_crt_verify_max:\""data_files/test-ca2.crt\"":\""data_files/dir-maxpath\"":M\n \n X509 CRT verify long chain (max intermediate CA + 1)\n depends_on:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\n-mbedtls_x509_crt_verify_max:\""data_files/dir-maxpath/00.crt\"":\""data_files/dir-maxpath\"":MBEDTLS_X509_MAX_INTERMEDIATE_CA+1:MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:-1\n+mbedtls_x509_crt_verify_max:\""data_files/dir-maxpath/00.crt\"":\""data_files/dir-maxpath\"":MBEDTLS_X509_MAX_INTERMEDIATE_CA+1:MBEDTLS_ERR_X509_FATAL_ERROR:-1\n \n X509 CRT verify chain #1 (zero pathlen intermediate)\n depends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C""}","int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,
                     mbedtls_x509_crt *trust_ca,
                     mbedtls_x509_crl *ca_crl,
                     const mbedtls_x509_crt_profile *profile,
                     const char *cn, uint32_t *flags,
                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
                     void *p_vrfy )
{
    size_t cn_len;
    int ret;
    int pathlen = 0, selfsigned = 0;
    mbedtls_x509_crt *parent;
    mbedtls_x509_name *name;
    mbedtls_x509_sequence *cur = NULL;
    mbedtls_pk_type_t pk_type;

    *flags = 0;

    if( profile == NULL )
    {
        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;
        goto exit;
    }

    if( cn != NULL )
    {
        name = &crt->subject;
        cn_len = strlen( cn );

        if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )
        {
            cur = &crt->subject_alt_names;

            while( cur != NULL )
            {
                if( cur->buf.len == cn_len &&
                    x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )
                    break;

                if( cur->buf.len > 2 &&
                    memcmp( cur->buf.p, ""*."", 2 ) == 0 &&
                    x509_check_wildcard( cn, &cur->buf ) == 0 )
                {
                    break;
                }

                cur = cur->next;
            }

            if( cur == NULL )
                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
        }
        else
        {
            while( name != NULL )
            {
                if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )
                {
                    if( name->val.len == cn_len &&
                        x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )
                        break;

                    if( name->val.len > 2 &&
                        memcmp( name->val.p, ""*."", 2 ) == 0 &&
                        x509_check_wildcard( cn, &name->val ) == 0 )
                        break;
                }

                name = name->next;
            }

            if( name == NULL )
                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
        }
    }

    /* Check the type and size of the key */
    pk_type = mbedtls_pk_get_type( &crt->pk );

    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;

    if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;

    /* Look for a parent in trusted CAs */
    for( parent = trust_ca; parent != NULL; parent = parent->next )
    {
        if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
            break;
    }

    if( parent != NULL )
    {
        ret = x509_crt_verify_top( crt, parent, ca_crl, profile,
                                   pathlen, selfsigned, flags, f_vrfy, p_vrfy );
        if( ret != 0 )
            goto exit;
    }
    else
    {
        /* Look for a parent upwards the chain */
        for( parent = crt->next; parent != NULL; parent = parent->next )
            if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
                break;

        /* Are we part of the chain or at the top? */
        if( parent != NULL )
        {
            ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,
                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );
            if( ret != 0 )
                goto exit;
        }
        else
        {
            ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,
                                       pathlen, selfsigned, flags, f_vrfy, p_vrfy );
            if( ret != 0 )
                goto exit;
        }
     }
 
 exit:
    /* prevent misuse of the vrfy callback */
    if( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED )
        ret = MBEDTLS_ERR_X509_FATAL_ERROR;

     if( ret != 0 )
     {
         *flags = (uint32_t) -1;
        return( ret );
    }

    if( *flags != 0 )
        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );

    return( 0 );
}
","int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,
                     mbedtls_x509_crt *trust_ca,
                     mbedtls_x509_crl *ca_crl,
                     const mbedtls_x509_crt_profile *profile,
                     const char *cn, uint32_t *flags,
                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
                     void *p_vrfy )
{
    size_t cn_len;
    int ret;
    int pathlen = 0, selfsigned = 0;
    mbedtls_x509_crt *parent;
    mbedtls_x509_name *name;
    mbedtls_x509_sequence *cur = NULL;
    mbedtls_pk_type_t pk_type;

    *flags = 0;

    if( profile == NULL )
    {
        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;
        goto exit;
    }

    if( cn != NULL )
    {
        name = &crt->subject;
        cn_len = strlen( cn );

        if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )
        {
            cur = &crt->subject_alt_names;

            while( cur != NULL )
            {
                if( cur->buf.len == cn_len &&
                    x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )
                    break;

                if( cur->buf.len > 2 &&
                    memcmp( cur->buf.p, ""*."", 2 ) == 0 &&
                    x509_check_wildcard( cn, &cur->buf ) == 0 )
                {
                    break;
                }

                cur = cur->next;
            }

            if( cur == NULL )
                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
        }
        else
        {
            while( name != NULL )
            {
                if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )
                {
                    if( name->val.len == cn_len &&
                        x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )
                        break;

                    if( name->val.len > 2 &&
                        memcmp( name->val.p, ""*."", 2 ) == 0 &&
                        x509_check_wildcard( cn, &name->val ) == 0 )
                        break;
                }

                name = name->next;
            }

            if( name == NULL )
                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
        }
    }

    /* Check the type and size of the key */
    pk_type = mbedtls_pk_get_type( &crt->pk );

    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;

    if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;

    /* Look for a parent in trusted CAs */
    for( parent = trust_ca; parent != NULL; parent = parent->next )
    {
        if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
            break;
    }

    if( parent != NULL )
    {
        ret = x509_crt_verify_top( crt, parent, ca_crl, profile,
                                   pathlen, selfsigned, flags, f_vrfy, p_vrfy );
        if( ret != 0 )
            goto exit;
    }
    else
    {
        /* Look for a parent upwards the chain */
        for( parent = crt->next; parent != NULL; parent = parent->next )
            if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
                break;

        /* Are we part of the chain or at the top? */
        if( parent != NULL )
        {
            ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,
                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );
            if( ret != 0 )
                goto exit;
        }
        else
        {
            ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,
                                       pathlen, selfsigned, flags, f_vrfy, p_vrfy );
            if( ret != 0 )
                goto exit;
        }
     }
 
 exit:
     if( ret != 0 )
     {
         *flags = (uint32_t) -1;
        return( ret );
    }

    if( *flags != 0 )
        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );

    return( 0 );
}
",C,"    /* prevent misuse of the vrfy callback */
    if( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED )
        ret = MBEDTLS_ERR_X509_FATAL_ERROR;

",,,"@@ -2057,8 +2057,8 @@ static int x509_crt_verify_child(
     /* path_cnt is 0 for the first intermediate CA */
     if( 1 + path_cnt > MBEDTLS_X509_MAX_INTERMEDIATE_CA )
     {
-        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
-        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );
+        /* return immediately as the goal is to avoid unbounded recursion */
+        return( MBEDTLS_ERR_X509_FATAL_ERROR );
     }
 
     if( mbedtls_x509_time_is_past( &child->valid_to ) )
@@ -2310,6 +2310,10 @@ int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,
     }
 
 exit:
+    /* prevent misuse of the vrfy callback */
+    if( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED )
+        ret = MBEDTLS_ERR_X509_FATAL_ERROR;
+
     if( ret != 0 )
     {
         *flags = (uint32_t) -1;",mbedtls,31458a18788b0cf0b722acda9bb2f2fe13a3fb32,d15795acd5074e0b44e71f7ede8bdfe1b48591fc,1,"int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,
                     mbedtls_x509_crt *trust_ca,
                     mbedtls_x509_crl *ca_crl,
                     const mbedtls_x509_crt_profile *profile,
                     const char *cn, uint32_t *flags,
                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
                     void *p_vrfy )
{
    size_t cn_len;
    int ret;
    int pathlen = 0, selfsigned = 0;
    mbedtls_x509_crt *parent;
    mbedtls_x509_name *name;
    mbedtls_x509_sequence *cur = NULL;
    mbedtls_pk_type_t pk_type;

    *flags = 0;

    if( profile == NULL )
    {
        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;
        goto exit;
    }

    if( cn != NULL )
    {
        name = &crt->subject;
        cn_len = strlen( cn );

        if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )
        {
            cur = &crt->subject_alt_names;

            while( cur != NULL )
            {
                if( cur->buf.len == cn_len &&
                    x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )
                    break;

                if( cur->buf.len > 2 &&
                    memcmp( cur->buf.p, ""*."", 2 ) == 0 &&
                    x509_check_wildcard( cn, &cur->buf ) == 0 )
                {
                    break;
                }

                cur = cur->next;
            }

            if( cur == NULL )
                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
        }
        else
        {
            while( name != NULL )
            {
                if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )
                {
                    if( name->val.len == cn_len &&
                        x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )
                        break;

                    if( name->val.len > 2 &&
                        memcmp( name->val.p, ""*."", 2 ) == 0 &&
                        x509_check_wildcard( cn, &name->val ) == 0 )
                        break;
                }

                name = name->next;
            }

            if( name == NULL )
                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
        }
    }

    /* Check the type and size of the key */
    pk_type = mbedtls_pk_get_type( &crt->pk );

    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;

    if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;

    /* Look for a parent in trusted CAs */
    for( parent = trust_ca; parent != NULL; parent = parent->next )
    {
        if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
            break;
    }

    if( parent != NULL )
    {
        ret = x509_crt_verify_top( crt, parent, ca_crl, profile,
                                   pathlen, selfsigned, flags, f_vrfy, p_vrfy );
        if( ret != 0 )
            goto exit;
    }
    else
    {
        /* Look for a parent upwards the chain */
        for( parent = crt->next; parent != NULL; parent = parent->next )
            if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
                break;

        /* Are we part of the chain or at the top? */
        if( parent != NULL )
        {
            ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,
                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );
            if( ret != 0 )
                goto exit;
        }
        else
        {
            ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,
                                       pathlen, selfsigned, flags, f_vrfy, p_vrfy );
            if( ret != 0 )
                goto exit;
        }
     }
 
 exit:
//fix_flaw_line_below:
//    /* prevent misuse of the vrfy callback */
//fix_flaw_line_below:
//    if( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED )
//fix_flaw_line_below:
//        ret = MBEDTLS_ERR_X509_FATAL_ERROR;
//fix_flaw_line_below:
//
     if( ret != 0 )
     {
         *flags = (uint32_t) -1;
        return( ret );
    }

    if( *flags != 0 )
        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );

    return( 0 );
}
"
5456,183192,,Remote,Not required,Partial,CVE-2017-14032,https://www.cvedetails.com/cve/CVE-2017-14032/,CWE-287,Medium,Partial,Partial,,2017-08-30,6.8,"ARM mbed TLS before 1.3.21 and 2.x before 2.1.9, if optional authentication is configured, allows remote attackers to bypass peer authentication via an X.509 certificate chain with many intermediates. NOTE: although mbed TLS was formerly known as PolarSSL, the releases shipped with the PolarSSL name are not affected.",2017-11-07,Bypass ,2,https://github.com/ARMmbed/mbedtls/commit/31458a18788b0cf0b722acda9bb2f2fe13a3fb32,31458a18788b0cf0b722acda9bb2f2fe13a3fb32,"Only return VERIFY_FAILED from a single point

Everything else is a fatal error. Also improve documentation about that for
the vrfy callback.",2,library/x509_crt.c,"{""sha"": ""d35457b962a4b9916fa9e4768d566c61eaa37bbe"", ""filename"": ""ChangeLog"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/ChangeLog"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/ChangeLog?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -6,6 +6,9 @@ Changes\n    * Certificate verification functions now set flags to -1 in case the full\n      chain was not verified due to an internal error (including in the verify\n      callback) or chain length limitations.\n+   * With authmode set to optional, handshake is now aborted if the\n+     verification of the peer's certificate failed due to an overlong chain or\n+     a fatal error in the vrfy callback.\n \n = mbed TLS 2.5.1 released 2017-06-21\n ""}<_**next**_>{""sha"": ""31591e2d6439baef544ec687a834ff322adafeff"", ""filename"": ""include/mbedtls/error.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/error.h"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/error.h"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/include/mbedtls/error.h?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -71,7 +71,7 @@\n  * Name      ID  Nr of Errors\n  * PEM       1   9\n  * PKCS#12   1   4 (Started from top)\n- * X509      2   19\n+ * X509      2   20\n  * PKCS5     2   4 (Started from top)\n  * DHM       3   9\n  * PK        3   14 (Started from top)""}<_**next**_>{""sha"": ""cc0007006280b4e382b90809484b76bd62c6035b"", ""filename"": ""include/mbedtls/ssl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/ssl.h"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/ssl.h"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/include/mbedtls/ssl.h?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -1052,7 +1052,7 @@ void mbedtls_ssl_conf_authmode( mbedtls_ssl_config *conf, int authmode );\n  *\n  *                 If set, the verify callback is called for each\n  *                 certificate in the chain. For implementation\n- *                 information, please see \\c x509parse_verify()\n+ *                 information, please see \\c mbedtls_x509_crt_verify()\n  *\n  * \\param conf     SSL configuration\n  * \\param f_vrfy   verification function""}<_**next**_>{""sha"": ""128eaded6fb7b2b17dda917fb024d8dd1421eecf"", ""filename"": ""include/mbedtls/x509.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/x509.h"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/x509.h"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/include/mbedtls/x509.h?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -76,6 +76,7 @@\n #define MBEDTLS_ERR_X509_ALLOC_FAILED                     -0x2880  /**< Allocation of memory failed. */\n #define MBEDTLS_ERR_X509_FILE_IO_ERROR                    -0x2900  /**< Read/write of file failed. */\n #define MBEDTLS_ERR_X509_BUFFER_TOO_SMALL                 -0x2980  /**< Destination buffer is too small. */\n+#define MBEDTLS_ERR_X509_FATAL_ERROR                      -0x3000  /**< A fatal error occured, eg the chain is too long or the vrfy callback failed. */\n /* \\} name */\n \n /**""}<_**next**_>{""sha"": ""fd203360c631cea5667abe09b6e6084380a613c6"", ""filename"": ""include/mbedtls/x509_crt.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/x509_crt.h"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/include/mbedtls/x509_crt.h"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/include/mbedtls/x509_crt.h?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -267,7 +267,13 @@ int mbedtls_x509_crt_verify_info( char *buf, size_t size, const char *prefix,\n  *\n  *                 All flags left after returning from the callback\n  *                 are also returned to the application. The function should\n- *                 return 0 for anything but a fatal error.\n+ *                 return 0 for anything (including invalid certificates)\n+ *                 other than fatal error, as a non-zero return code\n+ *                 immediately aborts the verification process. For fatal\n+ *                 errors, a specific error code should be used (different\n+ *                 from MBEDTLS_ERR_X509_CERT_VERIFY_FAILED which should not\n+ *                 be returned at this point), or MBEDTLS_ERR_X509_FATAL_ERROR\n+ *                 can be used if no better code is available.\n  *\n  * \\note           In case verification failed, the results can be displayed\n  *                 using \\c mbedtls_x509_crt_verify_info()""}<_**next**_>{""sha"": ""db42381c427c4d3e38cbb981bee9757edcc69001"", ""filename"": ""library/error.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/library/error.c"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/library/error.c"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/library/error.c?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -480,6 +480,8 @@ void mbedtls_strerror( int ret, char *buf, size_t buflen )\n             mbedtls_snprintf( buf, buflen, \""X509 - Read/write of file failed\"" );\n         if( use_ret == -(MBEDTLS_ERR_X509_BUFFER_TOO_SMALL) )\n             mbedtls_snprintf( buf, buflen, \""X509 - Destination buffer is too small\"" );\n+        if( use_ret == -(MBEDTLS_ERR_X509_FATAL_ERROR) )\n+            mbedtls_snprintf( buf, buflen, \""X509 - A fatal error occured, eg the chain is too long or the vrfy callback failed\"" );\n #endif /* MBEDTLS_X509_USE_C || MBEDTLS_X509_CREATE_C */\n         // END generated code\n ""}<_**next**_>{""sha"": ""ec5f77268db943a51a4eda88c27a37124b15c63c"", ""filename"": ""library/x509_crt.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 2, ""changes"": 8, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/library/x509_crt.c"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/library/x509_crt.c"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/library/x509_crt.c?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -2057,8 +2057,8 @@ static int x509_crt_verify_child(\n     /* path_cnt is 0 for the first intermediate CA */\n     if( 1 + path_cnt > MBEDTLS_X509_MAX_INTERMEDIATE_CA )\n     {\n-        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n-        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n+        /* return immediately as the goal is to avoid unbounded recursion */\n+        return( MBEDTLS_ERR_X509_FATAL_ERROR );\n     }\n \n     if( mbedtls_x509_time_is_past( &child->valid_to ) )\n@@ -2310,6 +2310,10 @@ int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,\n     }\n \n exit:\n+    /* prevent misuse of the vrfy callback */\n+    if( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED )\n+        ret = MBEDTLS_ERR_X509_FATAL_ERROR;\n+\n     if( ret != 0 )\n     {\n         *flags = (uint32_t) -1;""}<_**next**_>{""sha"": ""ea56f3fbc76312734f4eb41fa3da1cbb5ca7bc14"", ""filename"": ""tests/suites/test_suite_x509parse.data"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/ARMmbed/mbedtls/blob/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/tests/suites/test_suite_x509parse.data"", ""raw_url"": ""https://github.com/ARMmbed/mbedtls/raw/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/tests/suites/test_suite_x509parse.data"", ""contents_url"": ""https://api.github.com/repos/ARMmbed/mbedtls/contents/tests/suites/test_suite_x509parse.data?ref=31458a18788b0cf0b722acda9bb2f2fe13a3fb32"", ""patch"": ""@@ -1204,7 +1204,7 @@ mbedtls_x509_crt_verify_max:\""data_files/test-ca2.crt\"":\""data_files/dir-maxpath\"":M\n \n X509 CRT verify long chain (max intermediate CA + 1)\n depends_on:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\n-mbedtls_x509_crt_verify_max:\""data_files/dir-maxpath/00.crt\"":\""data_files/dir-maxpath\"":MBEDTLS_X509_MAX_INTERMEDIATE_CA+1:MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:-1\n+mbedtls_x509_crt_verify_max:\""data_files/dir-maxpath/00.crt\"":\""data_files/dir-maxpath\"":MBEDTLS_X509_MAX_INTERMEDIATE_CA+1:MBEDTLS_ERR_X509_FATAL_ERROR:-1\n \n X509 CRT verify chain #1 (zero pathlen intermediate)\n depends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C""}","static int x509_crt_verify_child(
                mbedtls_x509_crt *child, mbedtls_x509_crt *parent,
                mbedtls_x509_crt *trust_ca, mbedtls_x509_crl *ca_crl,
                const mbedtls_x509_crt_profile *profile,
                int path_cnt, int self_cnt, uint32_t *flags,
                int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
                void *p_vrfy )
{
    int ret;
    uint32_t parent_flags = 0;
    unsigned char hash[MBEDTLS_MD_MAX_SIZE];
    mbedtls_x509_crt *grandparent;
    const mbedtls_md_info_t *md_info;

    /* Counting intermediate self signed certificates */
    if( ( path_cnt != 0 ) && x509_name_cmp( &child->issuer, &child->subject ) == 0 )
        self_cnt++;

     /* path_cnt is 0 for the first intermediate CA */
     if( 1 + path_cnt > MBEDTLS_X509_MAX_INTERMEDIATE_CA )
     {
        /* return immediately as the goal is to avoid unbounded recursion */
        return( MBEDTLS_ERR_X509_FATAL_ERROR );
     }
 
     if( mbedtls_x509_time_is_past( &child->valid_to ) )
        *flags |= MBEDTLS_X509_BADCERT_EXPIRED;

    if( mbedtls_x509_time_is_future( &child->valid_from ) )
        *flags |= MBEDTLS_X509_BADCERT_FUTURE;

    if( x509_profile_check_md_alg( profile, child->sig_md ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_MD;

    if( x509_profile_check_pk_alg( profile, child->sig_pk ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;

    md_info = mbedtls_md_info_from_type( child->sig_md );
    if( md_info == NULL )
    {
        /*
         * Cannot check 'unknown' hash
         */
        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
    }
    else
    {
        mbedtls_md( md_info, child->tbs.p, child->tbs.len, hash );

        if( x509_profile_check_key( profile, child->sig_pk, &parent->pk ) != 0 )
            *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;

        if( mbedtls_pk_verify_ext( child->sig_pk, child->sig_opts, &parent->pk,
                           child->sig_md, hash, mbedtls_md_get_size( md_info ),
                           child->sig.p, child->sig.len ) != 0 )
        {
            *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
        }
    }

#if defined(MBEDTLS_X509_CRL_PARSE_C)
    /* Check trusted CA's CRL for the given crt */
    *flags |= x509_crt_verifycrl(child, parent, ca_crl, profile );
#endif

    /* Look for a grandparent in trusted CAs */
    for( grandparent = trust_ca;
         grandparent != NULL;
         grandparent = grandparent->next )
    {
        if( x509_crt_check_parent( parent, grandparent,
                                   0, path_cnt == 0 ) == 0 )
            break;
    }

    if( grandparent != NULL )
    {
        ret = x509_crt_verify_top( parent, grandparent, ca_crl, profile,
                                path_cnt + 1, self_cnt, &parent_flags, f_vrfy, p_vrfy );
        if( ret != 0 )
            return( ret );
    }
    else
    {
        /* Look for a grandparent upwards the chain */
        for( grandparent = parent->next;
             grandparent != NULL;
             grandparent = grandparent->next )
        {
            /* +2 because the current step is not yet accounted for
             * and because max_pathlen is one higher than it should be.
             * Also self signed certificates do not count to the limit. */
            if( grandparent->max_pathlen > 0 &&
                grandparent->max_pathlen < 2 + path_cnt - self_cnt )
            {
                continue;
            }

            if( x509_crt_check_parent( parent, grandparent,
                                       0, path_cnt == 0 ) == 0 )
                break;
        }

        /* Is our parent part of the chain or at the top? */
        if( grandparent != NULL )
        {
            ret = x509_crt_verify_child( parent, grandparent, trust_ca, ca_crl,
                                         profile, path_cnt + 1, self_cnt, &parent_flags,
                                         f_vrfy, p_vrfy );
            if( ret != 0 )
                return( ret );
        }
        else
        {
            ret = x509_crt_verify_top( parent, trust_ca, ca_crl, profile,
                                       path_cnt + 1, self_cnt, &parent_flags,
                                       f_vrfy, p_vrfy );
            if( ret != 0 )
                return( ret );
        }
    }

    /* child is verified to be a child of the parent, call verify callback */
    if( NULL != f_vrfy )
        if( ( ret = f_vrfy( p_vrfy, child, path_cnt, flags ) ) != 0 )
            return( ret );

    *flags |= parent_flags;

    return( 0 );
}
","static int x509_crt_verify_child(
                mbedtls_x509_crt *child, mbedtls_x509_crt *parent,
                mbedtls_x509_crt *trust_ca, mbedtls_x509_crl *ca_crl,
                const mbedtls_x509_crt_profile *profile,
                int path_cnt, int self_cnt, uint32_t *flags,
                int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
                void *p_vrfy )
{
    int ret;
    uint32_t parent_flags = 0;
    unsigned char hash[MBEDTLS_MD_MAX_SIZE];
    mbedtls_x509_crt *grandparent;
    const mbedtls_md_info_t *md_info;

    /* Counting intermediate self signed certificates */
    if( ( path_cnt != 0 ) && x509_name_cmp( &child->issuer, &child->subject ) == 0 )
        self_cnt++;

     /* path_cnt is 0 for the first intermediate CA */
     if( 1 + path_cnt > MBEDTLS_X509_MAX_INTERMEDIATE_CA )
     {
        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );
     }
 
     if( mbedtls_x509_time_is_past( &child->valid_to ) )
        *flags |= MBEDTLS_X509_BADCERT_EXPIRED;

    if( mbedtls_x509_time_is_future( &child->valid_from ) )
        *flags |= MBEDTLS_X509_BADCERT_FUTURE;

    if( x509_profile_check_md_alg( profile, child->sig_md ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_MD;

    if( x509_profile_check_pk_alg( profile, child->sig_pk ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;

    md_info = mbedtls_md_info_from_type( child->sig_md );
    if( md_info == NULL )
    {
        /*
         * Cannot check 'unknown' hash
         */
        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
    }
    else
    {
        mbedtls_md( md_info, child->tbs.p, child->tbs.len, hash );

        if( x509_profile_check_key( profile, child->sig_pk, &parent->pk ) != 0 )
            *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;

        if( mbedtls_pk_verify_ext( child->sig_pk, child->sig_opts, &parent->pk,
                           child->sig_md, hash, mbedtls_md_get_size( md_info ),
                           child->sig.p, child->sig.len ) != 0 )
        {
            *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
        }
    }

#if defined(MBEDTLS_X509_CRL_PARSE_C)
    /* Check trusted CA's CRL for the given crt */
    *flags |= x509_crt_verifycrl(child, parent, ca_crl, profile );
#endif

    /* Look for a grandparent in trusted CAs */
    for( grandparent = trust_ca;
         grandparent != NULL;
         grandparent = grandparent->next )
    {
        if( x509_crt_check_parent( parent, grandparent,
                                   0, path_cnt == 0 ) == 0 )
            break;
    }

    if( grandparent != NULL )
    {
        ret = x509_crt_verify_top( parent, grandparent, ca_crl, profile,
                                path_cnt + 1, self_cnt, &parent_flags, f_vrfy, p_vrfy );
        if( ret != 0 )
            return( ret );
    }
    else
    {
        /* Look for a grandparent upwards the chain */
        for( grandparent = parent->next;
             grandparent != NULL;
             grandparent = grandparent->next )
        {
            /* +2 because the current step is not yet accounted for
             * and because max_pathlen is one higher than it should be.
             * Also self signed certificates do not count to the limit. */
            if( grandparent->max_pathlen > 0 &&
                grandparent->max_pathlen < 2 + path_cnt - self_cnt )
            {
                continue;
            }

            if( x509_crt_check_parent( parent, grandparent,
                                       0, path_cnt == 0 ) == 0 )
                break;
        }

        /* Is our parent part of the chain or at the top? */
        if( grandparent != NULL )
        {
            ret = x509_crt_verify_child( parent, grandparent, trust_ca, ca_crl,
                                         profile, path_cnt + 1, self_cnt, &parent_flags,
                                         f_vrfy, p_vrfy );
            if( ret != 0 )
                return( ret );
        }
        else
        {
            ret = x509_crt_verify_top( parent, trust_ca, ca_crl, profile,
                                       path_cnt + 1, self_cnt, &parent_flags,
                                       f_vrfy, p_vrfy );
            if( ret != 0 )
                return( ret );
        }
    }

    /* child is verified to be a child of the parent, call verify callback */
    if( NULL != f_vrfy )
        if( ( ret = f_vrfy( p_vrfy, child, path_cnt, flags ) ) != 0 )
            return( ret );

    *flags |= parent_flags;

    return( 0 );
}
",C,"        /* return immediately as the goal is to avoid unbounded recursion */
        return( MBEDTLS_ERR_X509_FATAL_ERROR );
","        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );
",,"@@ -2057,8 +2057,8 @@ static int x509_crt_verify_child(
     /* path_cnt is 0 for the first intermediate CA */
     if( 1 + path_cnt > MBEDTLS_X509_MAX_INTERMEDIATE_CA )
     {
-        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
-        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );
+        /* return immediately as the goal is to avoid unbounded recursion */
+        return( MBEDTLS_ERR_X509_FATAL_ERROR );
     }
 
     if( mbedtls_x509_time_is_past( &child->valid_to ) )
@@ -2310,6 +2310,10 @@ int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,
     }
 
 exit:
+    /* prevent misuse of the vrfy callback */
+    if( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED )
+        ret = MBEDTLS_ERR_X509_FATAL_ERROR;
+
     if( ret != 0 )
     {
         *flags = (uint32_t) -1;",mbedtls,31458a18788b0cf0b722acda9bb2f2fe13a3fb32,d15795acd5074e0b44e71f7ede8bdfe1b48591fc,1,"static int x509_crt_verify_child(
                mbedtls_x509_crt *child, mbedtls_x509_crt *parent,
                mbedtls_x509_crt *trust_ca, mbedtls_x509_crl *ca_crl,
                const mbedtls_x509_crt_profile *profile,
                int path_cnt, int self_cnt, uint32_t *flags,
                int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
                void *p_vrfy )
{
    int ret;
    uint32_t parent_flags = 0;
    unsigned char hash[MBEDTLS_MD_MAX_SIZE];
    mbedtls_x509_crt *grandparent;
    const mbedtls_md_info_t *md_info;

    /* Counting intermediate self signed certificates */
    if( ( path_cnt != 0 ) && x509_name_cmp( &child->issuer, &child->subject ) == 0 )
        self_cnt++;

     /* path_cnt is 0 for the first intermediate CA */
     if( 1 + path_cnt > MBEDTLS_X509_MAX_INTERMEDIATE_CA )
     {
//flaw_line_below:
        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
//flaw_line_below:
        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );
//fix_flaw_line_below:
//        /* return immediately as the goal is to avoid unbounded recursion */
//fix_flaw_line_below:
//        return( MBEDTLS_ERR_X509_FATAL_ERROR );
     }
 
     if( mbedtls_x509_time_is_past( &child->valid_to ) )
        *flags |= MBEDTLS_X509_BADCERT_EXPIRED;

    if( mbedtls_x509_time_is_future( &child->valid_from ) )
        *flags |= MBEDTLS_X509_BADCERT_FUTURE;

    if( x509_profile_check_md_alg( profile, child->sig_md ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_MD;

    if( x509_profile_check_pk_alg( profile, child->sig_pk ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;

    md_info = mbedtls_md_info_from_type( child->sig_md );
    if( md_info == NULL )
    {
        /*
         * Cannot check 'unknown' hash
         */
        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
    }
    else
    {
        mbedtls_md( md_info, child->tbs.p, child->tbs.len, hash );

        if( x509_profile_check_key( profile, child->sig_pk, &parent->pk ) != 0 )
            *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;

        if( mbedtls_pk_verify_ext( child->sig_pk, child->sig_opts, &parent->pk,
                           child->sig_md, hash, mbedtls_md_get_size( md_info ),
                           child->sig.p, child->sig.len ) != 0 )
        {
            *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
        }
    }

#if defined(MBEDTLS_X509_CRL_PARSE_C)
    /* Check trusted CA's CRL for the given crt */
    *flags |= x509_crt_verifycrl(child, parent, ca_crl, profile );
#endif

    /* Look for a grandparent in trusted CAs */
    for( grandparent = trust_ca;
         grandparent != NULL;
         grandparent = grandparent->next )
    {
        if( x509_crt_check_parent( parent, grandparent,
                                   0, path_cnt == 0 ) == 0 )
            break;
    }

    if( grandparent != NULL )
    {
        ret = x509_crt_verify_top( parent, grandparent, ca_crl, profile,
                                path_cnt + 1, self_cnt, &parent_flags, f_vrfy, p_vrfy );
        if( ret != 0 )
            return( ret );
    }
    else
    {
        /* Look for a grandparent upwards the chain */
        for( grandparent = parent->next;
             grandparent != NULL;
             grandparent = grandparent->next )
        {
            /* +2 because the current step is not yet accounted for
             * and because max_pathlen is one higher than it should be.
             * Also self signed certificates do not count to the limit. */
            if( grandparent->max_pathlen > 0 &&
                grandparent->max_pathlen < 2 + path_cnt - self_cnt )
            {
                continue;
            }

            if( x509_crt_check_parent( parent, grandparent,
                                       0, path_cnt == 0 ) == 0 )
                break;
        }

        /* Is our parent part of the chain or at the top? */
        if( grandparent != NULL )
        {
            ret = x509_crt_verify_child( parent, grandparent, trust_ca, ca_crl,
                                         profile, path_cnt + 1, self_cnt, &parent_flags,
                                         f_vrfy, p_vrfy );
            if( ret != 0 )
                return( ret );
        }
        else
        {
            ret = x509_crt_verify_top( parent, trust_ca, ca_crl, profile,
                                       path_cnt + 1, self_cnt, &parent_flags,
                                       f_vrfy, p_vrfy );
            if( ret != 0 )
                return( ret );
        }
    }

    /* child is verified to be a child of the parent, call verify callback */
    if( NULL != f_vrfy )
        if( ( ret = f_vrfy( p_vrfy, child, path_cnt, flags ) ) != 0 )
            return( ret );

    *flags |= parent_flags;

    return( 0 );
}
"
5609,183345,,Remote,Single system,,CVE-2017-7562,https://www.cvedetails.com/cve/CVE-2017-7562/,CWE-287,Low,,Partial,,2018-07-26,4.0,An authentication bypass flaw was found in the way krb5's certauth interface before 1.16.1 handled the validation of client certificates. A remote attacker able to communicate with the KDC could potentially use this flaw to impersonate arbitrary principals under rare and erroneous circumstances.,2019-10-09,Bypass ,18,https://github.com/krb5/krb5/pull/694/commits/50fe4074f188c2d4da0c421e96553acea8378db2,50fe4074f188c2d4da0c421e96553acea8378db2,"Fix certauth built-in module returns

The PKINIT certauth eku module should never authoritatively authorize
a certificate, because an extended key usage does not establish a
relationship between the certificate and any specific user; it only
establishes that the certificate was created for PKINIT client
authentication.  Therefore, pkinit_eku_authorize() should return
KRB5_PLUGIN_NO_HANDLE on success, not 0.

The certauth san module should pass if it does not find any SANs of
the types it can match against; the presence of other types of SANs
should not cause it to explicitly deny a certificate.  Check for an
empty result from crypto_retrieve_cert_sans() in verify_client_san(),
instead of returning ENOENT from crypto_retrieve_cert_sans() when
there are no SANs at all.

ticket: 8561",21,src/plugins/preauth/pkinit/pkinit_crypto_openssl.c,"{""sha"": ""f7640baf14ccd00af9df09cb91559d01412f41bb"", ""filename"": ""src/plugins/preauth/pkinit/pkinit_crypto_openssl.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 21, ""changes"": 39, ""blob_url"": ""https://github.com/krb5/krb5/blob/50fe4074f188c2d4da0c421e96553acea8378db2/src/plugins/preauth/pkinit/pkinit_crypto_openssl.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/50fe4074f188c2d4da0c421e96553acea8378db2/src/plugins/preauth/pkinit/pkinit_crypto_openssl.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/plugins/preauth/pkinit/pkinit_crypto_openssl.c?ref=50fe4074f188c2d4da0c421e96553acea8378db2"", ""patch"": ""@@ -2125,7 +2125,6 @@ crypto_retrieve_X509_sans(krb5_context context,\n \n     if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {\n         pkiDebug(\""%s: found no subject alt name extensions\\n\"", __FUNCTION__);\n-        retval = ENOENT;\n         goto cleanup;\n     }\n     num_sans = sk_GENERAL_NAME_num(ialt);\n@@ -2228,31 +2227,29 @@ crypto_retrieve_X509_sans(krb5_context context,\n     sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);\n \n     retval = 0;\n-    if (princs)\n+    if (princs != NULL && *princs != NULL) {\n         *princs_ret = princs;\n-    if (upns)\n+        princs = NULL;\n+    }\n+    if (upns != NULL && *upns != NULL) {\n         *upn_ret = upns;\n-    if (dnss)\n+        upns = NULL;\n+    }\n+    if (dnss != NULL && *dnss != NULL) {\n         *dns_ret = dnss;\n+        dnss = NULL;\n+    }\n \n cleanup:\n-    if (retval) {\n-        if (princs != NULL) {\n-            for (i = 0; princs[i] != NULL; i++)\n-                krb5_free_principal(context, princs[i]);\n-            free(princs);\n-        }\n-        if (upns != NULL) {\n-            for (i = 0; upns[i] != NULL; i++)\n-                krb5_free_principal(context, upns[i]);\n-            free(upns);\n-        }\n-        if (dnss != NULL) {\n-            for (i = 0; dnss[i] != NULL; i++)\n-                free(dnss[i]);\n-            free(dnss);\n-        }\n-    }\n+    for (i = 0; princs != NULL && princs[i] != NULL; i++)\n+        krb5_free_principal(context, princs[i]);\n+    free(princs);\n+    for (i = 0; upns != NULL && upns[i] != NULL; i++)\n+        krb5_free_principal(context, upns[i]);\n+    free(upns);\n+    for (i = 0; dnss != NULL && dnss[i] != NULL; i++)\n+        free(dnss[i]);\n+    free(dnss);\n     return retval;\n }\n ""}<_**next**_>{""sha"": ""7210fc14cbbf61ebec6a7de9bbbc8ee98c63ce80"", ""filename"": ""src/plugins/preauth/pkinit/pkinit_srv.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 5, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/50fe4074f188c2d4da0c421e96553acea8378db2/src/plugins/preauth/pkinit/pkinit_srv.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/50fe4074f188c2d4da0c421e96553acea8378db2/src/plugins/preauth/pkinit/pkinit_srv.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/plugins/preauth/pkinit/pkinit_srv.c?ref=50fe4074f188c2d4da0c421e96553acea8378db2"", ""patch"": ""@@ -187,14 +187,18 @@ verify_client_san(krb5_context context,\n                                        &princs,\n                                        plgctx->opts->allow_upn ? &upns : NULL,\n                                        NULL);\n-    if (retval == ENOENT) {\n-        TRACE_PKINIT_SERVER_NO_SAN(context);\n-        goto out;\n-    } else if (retval) {\n+    if (retval) {\n         pkiDebug(\""%s: error from retrieve_certificate_sans()\\n\"", __FUNCTION__);\n         retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n         goto out;\n     }\n+\n+    if (princs == NULL && upns == NULL) {\n+        TRACE_PKINIT_SERVER_NO_SAN(context);\n+        retval = ENOENT;\n+        goto out;\n+    }\n+\n     /* XXX Verify this is consistent with client side XXX */\n #if 0\n     retval = call_san_checking_plugins(context, plgctx, reqctx, princs,\n@@ -1497,7 +1501,7 @@ pkinit_eku_authorize(krb5_context context, krb5_certauth_moddata moddata,\n         return KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;\n     }\n \n-    return 0;\n+    return KRB5_PLUGIN_NO_HANDLE;\n }\n \n static krb5_error_code""}","crypto_retrieve_X509_sans(krb5_context context,
                          pkinit_plg_crypto_context plgctx,
                          pkinit_req_crypto_context reqctx,
                          X509 *cert,
                          krb5_principal **princs_ret,
                          krb5_principal **upn_ret,
                          unsigned char ***dns_ret)
{
    krb5_error_code retval = EINVAL;
    char buf[DN_BUF_LEN];
    int p = 0, u = 0, d = 0, ret = 0, l;
    krb5_principal *princs = NULL;
    krb5_principal *upns = NULL;
    unsigned char **dnss = NULL;
    unsigned int i, num_found = 0, num_sans = 0;
    X509_EXTENSION *ext = NULL;
    GENERAL_NAMES *ialt = NULL;
    GENERAL_NAME *gen = NULL;

    if (princs_ret != NULL)
        *princs_ret = NULL;
    if (upn_ret != NULL)
        *upn_ret = NULL;
    if (dns_ret != NULL)
        *dns_ret = NULL;

    if (princs_ret == NULL && upn_ret == NULL && dns_ret == NULL) {
        pkiDebug(""%s: nowhere to return any values!\n"", __FUNCTION__);
        return retval;
    }

    if (cert == NULL) {
        pkiDebug(""%s: no certificate!\n"", __FUNCTION__);
        return retval;
    }

    X509_NAME_oneline(X509_get_subject_name(cert),
                      buf, sizeof(buf));
    pkiDebug(""%s: looking for SANs in cert = %s\n"", __FUNCTION__, buf);

    l = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);
    if (l < 0)
        return 0;
 
     if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {
         pkiDebug(""%s: found no subject alt name extensions\n"", __FUNCTION__);
         goto cleanup;
     }
     num_sans = sk_GENERAL_NAME_num(ialt);

    pkiDebug(""%s: found %d subject alt name extension(s)\n"", __FUNCTION__,
             num_sans);

    /* OK, we're likely returning something. Allocate return values */
    if (princs_ret != NULL) {
        princs = calloc(num_sans + 1, sizeof(krb5_principal));
        if (princs == NULL) {
            retval = ENOMEM;
            goto cleanup;
        }
    }
    if (upn_ret != NULL) {
        upns = calloc(num_sans + 1, sizeof(krb5_principal));
        if (upns == NULL) {
            retval = ENOMEM;
            goto cleanup;
        }
    }
    if (dns_ret != NULL) {
        dnss = calloc(num_sans + 1, sizeof(*dnss));
        if (dnss == NULL) {
            retval = ENOMEM;
            goto cleanup;
        }
    }

    for (i = 0; i < num_sans; i++) {
        krb5_data name = { 0, 0, NULL };

        gen = sk_GENERAL_NAME_value(ialt, i);
        switch (gen->type) {
        case GEN_OTHERNAME:
            name.length = gen->d.otherName->value->value.sequence->length;
            name.data = (char *)gen->d.otherName->value->value.sequence->data;
            if (princs != NULL &&
                OBJ_cmp(plgctx->id_pkinit_san,
                        gen->d.otherName->type_id) == 0) {
#ifdef DEBUG_ASN1
                print_buffer_bin((unsigned char *)name.data, name.length,
                                 ""/tmp/pkinit_san"");
#endif
                ret = k5int_decode_krb5_principal_name(&name, &princs[p]);
                if (ret) {
                    pkiDebug(""%s: failed decoding pkinit san value\n"",
                             __FUNCTION__);
                } else {
                    p++;
                    num_found++;
                }
            } else if (upns != NULL &&
                       OBJ_cmp(plgctx->id_ms_san_upn,
                               gen->d.otherName->type_id) == 0) {
                /* Prevent abuse of embedded null characters. */
                if (memchr(name.data, '\0', name.length))
                    break;
                ret = krb5_parse_name_flags(context, name.data,
                                            KRB5_PRINCIPAL_PARSE_ENTERPRISE,
                                            &upns[u]);
                if (ret) {
                    pkiDebug(""%s: failed parsing ms-upn san value\n"",
                             __FUNCTION__);
                } else {
                    u++;
                    num_found++;
                }
            } else {
                pkiDebug(""%s: unrecognized othername oid in SAN\n"",
                         __FUNCTION__);
                continue;
            }

            break;
        case GEN_DNS:
            if (dnss != NULL) {
                /* Prevent abuse of embedded null characters. */
                if (memchr(gen->d.dNSName->data, '\0', gen->d.dNSName->length))
                    break;
                pkiDebug(""%s: found dns name = %s\n"", __FUNCTION__,
                         gen->d.dNSName->data);
                dnss[d] = (unsigned char *)
                    strdup((char *)gen->d.dNSName->data);
                if (dnss[d] == NULL) {
                    pkiDebug(""%s: failed to duplicate dns name\n"",
                             __FUNCTION__);
                } else {
                    d++;
                    num_found++;
                }
            }
            break;
        default:
            pkiDebug(""%s: SAN type = %d expecting %d\n"", __FUNCTION__,
                     gen->type, GEN_OTHERNAME);
        }
    }
     sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);
 
     retval = 0;
    if (princs != NULL && *princs != NULL) {
         *princs_ret = princs;
        princs = NULL;
    }
    if (upns != NULL && *upns != NULL) {
         *upn_ret = upns;
        upns = NULL;
    }
    if (dnss != NULL && *dnss != NULL) {
         *dns_ret = dnss;
        dnss = NULL;
    }
 
 cleanup:
    for (i = 0; princs != NULL && princs[i] != NULL; i++)
        krb5_free_principal(context, princs[i]);
    free(princs);
    for (i = 0; upns != NULL && upns[i] != NULL; i++)
        krb5_free_principal(context, upns[i]);
    free(upns);
    for (i = 0; dnss != NULL && dnss[i] != NULL; i++)
        free(dnss[i]);
    free(dnss);
     return retval;
 }
","crypto_retrieve_X509_sans(krb5_context context,
                          pkinit_plg_crypto_context plgctx,
                          pkinit_req_crypto_context reqctx,
                          X509 *cert,
                          krb5_principal **princs_ret,
                          krb5_principal **upn_ret,
                          unsigned char ***dns_ret)
{
    krb5_error_code retval = EINVAL;
    char buf[DN_BUF_LEN];
    int p = 0, u = 0, d = 0, ret = 0, l;
    krb5_principal *princs = NULL;
    krb5_principal *upns = NULL;
    unsigned char **dnss = NULL;
    unsigned int i, num_found = 0, num_sans = 0;
    X509_EXTENSION *ext = NULL;
    GENERAL_NAMES *ialt = NULL;
    GENERAL_NAME *gen = NULL;

    if (princs_ret != NULL)
        *princs_ret = NULL;
    if (upn_ret != NULL)
        *upn_ret = NULL;
    if (dns_ret != NULL)
        *dns_ret = NULL;

    if (princs_ret == NULL && upn_ret == NULL && dns_ret == NULL) {
        pkiDebug(""%s: nowhere to return any values!\n"", __FUNCTION__);
        return retval;
    }

    if (cert == NULL) {
        pkiDebug(""%s: no certificate!\n"", __FUNCTION__);
        return retval;
    }

    X509_NAME_oneline(X509_get_subject_name(cert),
                      buf, sizeof(buf));
    pkiDebug(""%s: looking for SANs in cert = %s\n"", __FUNCTION__, buf);

    l = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);
    if (l < 0)
        return 0;
 
     if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {
         pkiDebug(""%s: found no subject alt name extensions\n"", __FUNCTION__);
        retval = ENOENT;
         goto cleanup;
     }
     num_sans = sk_GENERAL_NAME_num(ialt);

    pkiDebug(""%s: found %d subject alt name extension(s)\n"", __FUNCTION__,
             num_sans);

    /* OK, we're likely returning something. Allocate return values */
    if (princs_ret != NULL) {
        princs = calloc(num_sans + 1, sizeof(krb5_principal));
        if (princs == NULL) {
            retval = ENOMEM;
            goto cleanup;
        }
    }
    if (upn_ret != NULL) {
        upns = calloc(num_sans + 1, sizeof(krb5_principal));
        if (upns == NULL) {
            retval = ENOMEM;
            goto cleanup;
        }
    }
    if (dns_ret != NULL) {
        dnss = calloc(num_sans + 1, sizeof(*dnss));
        if (dnss == NULL) {
            retval = ENOMEM;
            goto cleanup;
        }
    }

    for (i = 0; i < num_sans; i++) {
        krb5_data name = { 0, 0, NULL };

        gen = sk_GENERAL_NAME_value(ialt, i);
        switch (gen->type) {
        case GEN_OTHERNAME:
            name.length = gen->d.otherName->value->value.sequence->length;
            name.data = (char *)gen->d.otherName->value->value.sequence->data;
            if (princs != NULL &&
                OBJ_cmp(plgctx->id_pkinit_san,
                        gen->d.otherName->type_id) == 0) {
#ifdef DEBUG_ASN1
                print_buffer_bin((unsigned char *)name.data, name.length,
                                 ""/tmp/pkinit_san"");
#endif
                ret = k5int_decode_krb5_principal_name(&name, &princs[p]);
                if (ret) {
                    pkiDebug(""%s: failed decoding pkinit san value\n"",
                             __FUNCTION__);
                } else {
                    p++;
                    num_found++;
                }
            } else if (upns != NULL &&
                       OBJ_cmp(plgctx->id_ms_san_upn,
                               gen->d.otherName->type_id) == 0) {
                /* Prevent abuse of embedded null characters. */
                if (memchr(name.data, '\0', name.length))
                    break;
                ret = krb5_parse_name_flags(context, name.data,
                                            KRB5_PRINCIPAL_PARSE_ENTERPRISE,
                                            &upns[u]);
                if (ret) {
                    pkiDebug(""%s: failed parsing ms-upn san value\n"",
                             __FUNCTION__);
                } else {
                    u++;
                    num_found++;
                }
            } else {
                pkiDebug(""%s: unrecognized othername oid in SAN\n"",
                         __FUNCTION__);
                continue;
            }

            break;
        case GEN_DNS:
            if (dnss != NULL) {
                /* Prevent abuse of embedded null characters. */
                if (memchr(gen->d.dNSName->data, '\0', gen->d.dNSName->length))
                    break;
                pkiDebug(""%s: found dns name = %s\n"", __FUNCTION__,
                         gen->d.dNSName->data);
                dnss[d] = (unsigned char *)
                    strdup((char *)gen->d.dNSName->data);
                if (dnss[d] == NULL) {
                    pkiDebug(""%s: failed to duplicate dns name\n"",
                             __FUNCTION__);
                } else {
                    d++;
                    num_found++;
                }
            }
            break;
        default:
            pkiDebug(""%s: SAN type = %d expecting %d\n"", __FUNCTION__,
                     gen->type, GEN_OTHERNAME);
        }
    }
     sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);
 
     retval = 0;
    if (princs)
         *princs_ret = princs;
    if (upns)
         *upn_ret = upns;
    if (dnss)
         *dns_ret = dnss;
 
 cleanup:
    if (retval) {
        if (princs != NULL) {
            for (i = 0; princs[i] != NULL; i++)
                krb5_free_principal(context, princs[i]);
            free(princs);
        }
        if (upns != NULL) {
            for (i = 0; upns[i] != NULL; i++)
                krb5_free_principal(context, upns[i]);
            free(upns);
        }
        if (dnss != NULL) {
            for (i = 0; dnss[i] != NULL; i++)
                free(dnss[i]);
            free(dnss);
        }
    }
     return retval;
 }
",C,"    if (princs != NULL && *princs != NULL) {
        princs = NULL;
    }
    if (upns != NULL && *upns != NULL) {
        upns = NULL;
    }
    if (dnss != NULL && *dnss != NULL) {
        dnss = NULL;
    }
    for (i = 0; princs != NULL && princs[i] != NULL; i++)
        krb5_free_principal(context, princs[i]);
    free(princs);
    for (i = 0; upns != NULL && upns[i] != NULL; i++)
        krb5_free_principal(context, upns[i]);
    free(upns);
    for (i = 0; dnss != NULL && dnss[i] != NULL; i++)
        free(dnss[i]);
    free(dnss);
","        retval = ENOENT;
    if (princs)
    if (upns)
    if (dnss)
    if (retval) {
        if (princs != NULL) {
            for (i = 0; princs[i] != NULL; i++)
                krb5_free_principal(context, princs[i]);
            free(princs);
        }
        if (upns != NULL) {
            for (i = 0; upns[i] != NULL; i++)
                krb5_free_principal(context, upns[i]);
            free(upns);
        }
        if (dnss != NULL) {
            for (i = 0; dnss[i] != NULL; i++)
                free(dnss[i]);
            free(dnss);
        }
    }
",,"@@ -2125,7 +2125,6 @@ crypto_retrieve_X509_sans(krb5_context context,
 
     if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {
         pkiDebug(""%s: found no subject alt name extensions\n"", __FUNCTION__);
-        retval = ENOENT;
         goto cleanup;
     }
     num_sans = sk_GENERAL_NAME_num(ialt);
@@ -2228,31 +2227,29 @@ crypto_retrieve_X509_sans(krb5_context context,
     sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);
 
     retval = 0;
-    if (princs)
+    if (princs != NULL && *princs != NULL) {
         *princs_ret = princs;
-    if (upns)
+        princs = NULL;
+    }
+    if (upns != NULL && *upns != NULL) {
         *upn_ret = upns;
-    if (dnss)
+        upns = NULL;
+    }
+    if (dnss != NULL && *dnss != NULL) {
         *dns_ret = dnss;
+        dnss = NULL;
+    }
 
 cleanup:
-    if (retval) {
-        if (princs != NULL) {
-            for (i = 0; princs[i] != NULL; i++)
-                krb5_free_principal(context, princs[i]);
-            free(princs);
-        }
-        if (upns != NULL) {
-            for (i = 0; upns[i] != NULL; i++)
-                krb5_free_principal(context, upns[i]);
-            free(upns);
-        }
-        if (dnss != NULL) {
-            for (i = 0; dnss[i] != NULL; i++)
-                free(dnss[i]);
-            free(dnss);
-        }
-    }
+    for (i = 0; princs != NULL && princs[i] != NULL; i++)
+        krb5_free_principal(context, princs[i]);
+    free(princs);
+    for (i = 0; upns != NULL && upns[i] != NULL; i++)
+        krb5_free_principal(context, upns[i]);
+    free(upns);
+    for (i = 0; dnss != NULL && dnss[i] != NULL; i++)
+        free(dnss[i]);
+    free(dnss);
     return retval;
 }
 ",krb5,50fe4074f188c2d4da0c421e96553acea8378db2,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"crypto_retrieve_X509_sans(krb5_context context,
                          pkinit_plg_crypto_context plgctx,
                          pkinit_req_crypto_context reqctx,
                          X509 *cert,
                          krb5_principal **princs_ret,
                          krb5_principal **upn_ret,
                          unsigned char ***dns_ret)
{
    krb5_error_code retval = EINVAL;
    char buf[DN_BUF_LEN];
    int p = 0, u = 0, d = 0, ret = 0, l;
    krb5_principal *princs = NULL;
    krb5_principal *upns = NULL;
    unsigned char **dnss = NULL;
    unsigned int i, num_found = 0, num_sans = 0;
    X509_EXTENSION *ext = NULL;
    GENERAL_NAMES *ialt = NULL;
    GENERAL_NAME *gen = NULL;

    if (princs_ret != NULL)
        *princs_ret = NULL;
    if (upn_ret != NULL)
        *upn_ret = NULL;
    if (dns_ret != NULL)
        *dns_ret = NULL;

    if (princs_ret == NULL && upn_ret == NULL && dns_ret == NULL) {
        pkiDebug(""%s: nowhere to return any values!\n"", __FUNCTION__);
        return retval;
    }

    if (cert == NULL) {
        pkiDebug(""%s: no certificate!\n"", __FUNCTION__);
        return retval;
    }

    X509_NAME_oneline(X509_get_subject_name(cert),
                      buf, sizeof(buf));
    pkiDebug(""%s: looking for SANs in cert = %s\n"", __FUNCTION__, buf);

    l = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);
    if (l < 0)
        return 0;
 
     if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {
         pkiDebug(""%s: found no subject alt name extensions\n"", __FUNCTION__);
//flaw_line_below:
        retval = ENOENT;
         goto cleanup;
     }
     num_sans = sk_GENERAL_NAME_num(ialt);

    pkiDebug(""%s: found %d subject alt name extension(s)\n"", __FUNCTION__,
             num_sans);

    /* OK, we're likely returning something. Allocate return values */
    if (princs_ret != NULL) {
        princs = calloc(num_sans + 1, sizeof(krb5_principal));
        if (princs == NULL) {
            retval = ENOMEM;
            goto cleanup;
        }
    }
    if (upn_ret != NULL) {
        upns = calloc(num_sans + 1, sizeof(krb5_principal));
        if (upns == NULL) {
            retval = ENOMEM;
            goto cleanup;
        }
    }
    if (dns_ret != NULL) {
        dnss = calloc(num_sans + 1, sizeof(*dnss));
        if (dnss == NULL) {
            retval = ENOMEM;
            goto cleanup;
        }
    }

    for (i = 0; i < num_sans; i++) {
        krb5_data name = { 0, 0, NULL };

        gen = sk_GENERAL_NAME_value(ialt, i);
        switch (gen->type) {
        case GEN_OTHERNAME:
            name.length = gen->d.otherName->value->value.sequence->length;
            name.data = (char *)gen->d.otherName->value->value.sequence->data;
            if (princs != NULL &&
                OBJ_cmp(plgctx->id_pkinit_san,
                        gen->d.otherName->type_id) == 0) {
#ifdef DEBUG_ASN1
                print_buffer_bin((unsigned char *)name.data, name.length,
                                 ""/tmp/pkinit_san"");
#endif
                ret = k5int_decode_krb5_principal_name(&name, &princs[p]);
                if (ret) {
                    pkiDebug(""%s: failed decoding pkinit san value\n"",
                             __FUNCTION__);
                } else {
                    p++;
                    num_found++;
                }
            } else if (upns != NULL &&
                       OBJ_cmp(plgctx->id_ms_san_upn,
                               gen->d.otherName->type_id) == 0) {
                /* Prevent abuse of embedded null characters. */
                if (memchr(name.data, '\0', name.length))
                    break;
                ret = krb5_parse_name_flags(context, name.data,
                                            KRB5_PRINCIPAL_PARSE_ENTERPRISE,
                                            &upns[u]);
                if (ret) {
                    pkiDebug(""%s: failed parsing ms-upn san value\n"",
                             __FUNCTION__);
                } else {
                    u++;
                    num_found++;
                }
            } else {
                pkiDebug(""%s: unrecognized othername oid in SAN\n"",
                         __FUNCTION__);
                continue;
            }

            break;
        case GEN_DNS:
            if (dnss != NULL) {
                /* Prevent abuse of embedded null characters. */
                if (memchr(gen->d.dNSName->data, '\0', gen->d.dNSName->length))
                    break;
                pkiDebug(""%s: found dns name = %s\n"", __FUNCTION__,
                         gen->d.dNSName->data);
                dnss[d] = (unsigned char *)
                    strdup((char *)gen->d.dNSName->data);
                if (dnss[d] == NULL) {
                    pkiDebug(""%s: failed to duplicate dns name\n"",
                             __FUNCTION__);
                } else {
                    d++;
                    num_found++;
                }
            }
            break;
        default:
            pkiDebug(""%s: SAN type = %d expecting %d\n"", __FUNCTION__,
                     gen->type, GEN_OTHERNAME);
        }
    }
     sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);
 
     retval = 0;
//flaw_line_below:
    if (princs)
//fix_flaw_line_below:
//    if (princs != NULL && *princs != NULL) {
         *princs_ret = princs;
//flaw_line_below:
    if (upns)
//fix_flaw_line_below:
//        princs = NULL;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//    if (upns != NULL && *upns != NULL) {
         *upn_ret = upns;
//flaw_line_below:
    if (dnss)
//fix_flaw_line_below:
//        upns = NULL;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//    if (dnss != NULL && *dnss != NULL) {
         *dns_ret = dnss;
//fix_flaw_line_below:
//        dnss = NULL;
//fix_flaw_line_below:
//    }
 
 cleanup:
//flaw_line_below:
    if (retval) {
//flaw_line_below:
        if (princs != NULL) {
//flaw_line_below:
            for (i = 0; princs[i] != NULL; i++)
//flaw_line_below:
                krb5_free_principal(context, princs[i]);
//flaw_line_below:
            free(princs);
//flaw_line_below:
        }
//flaw_line_below:
        if (upns != NULL) {
//flaw_line_below:
            for (i = 0; upns[i] != NULL; i++)
//flaw_line_below:
                krb5_free_principal(context, upns[i]);
//flaw_line_below:
            free(upns);
//flaw_line_below:
        }
//flaw_line_below:
        if (dnss != NULL) {
//flaw_line_below:
            for (i = 0; dnss[i] != NULL; i++)
//flaw_line_below:
                free(dnss[i]);
//flaw_line_below:
            free(dnss);
//flaw_line_below:
        }
//flaw_line_below:
    }
//fix_flaw_line_below:
//    for (i = 0; princs != NULL && princs[i] != NULL; i++)
//fix_flaw_line_below:
//        krb5_free_principal(context, princs[i]);
//fix_flaw_line_below:
//    free(princs);
//fix_flaw_line_below:
//    for (i = 0; upns != NULL && upns[i] != NULL; i++)
//fix_flaw_line_below:
//        krb5_free_principal(context, upns[i]);
//fix_flaw_line_below:
//    free(upns);
//fix_flaw_line_below:
//    for (i = 0; dnss != NULL && dnss[i] != NULL; i++)
//fix_flaw_line_below:
//        free(dnss[i]);
//fix_flaw_line_below:
//    free(dnss);
     return retval;
 }
"
5610,183346,,Remote,Single system,,CVE-2017-7562,https://www.cvedetails.com/cve/CVE-2017-7562/,CWE-287,Low,,Partial,,2018-07-26,4.0,An authentication bypass flaw was found in the way krb5's certauth interface before 1.16.1 handled the validation of client certificates. A remote attacker able to communicate with the KDC could potentially use this flaw to impersonate arbitrary principals under rare and erroneous circumstances.,2019-10-09,Bypass ,1,https://github.com/krb5/krb5/pull/694/commits/50fe4074f188c2d4da0c421e96553acea8378db2,50fe4074f188c2d4da0c421e96553acea8378db2,"Fix certauth built-in module returns

The PKINIT certauth eku module should never authoritatively authorize
a certificate, because an extended key usage does not establish a
relationship between the certificate and any specific user; it only
establishes that the certificate was created for PKINIT client
authentication.  Therefore, pkinit_eku_authorize() should return
KRB5_PLUGIN_NO_HANDLE on success, not 0.

The certauth san module should pass if it does not find any SANs of
the types it can match against; the presence of other types of SANs
should not cause it to explicitly deny a certificate.  Check for an
empty result from crypto_retrieve_cert_sans() in verify_client_san(),
instead of returning ENOENT from crypto_retrieve_cert_sans() when
there are no SANs at all.

ticket: 8561",1,src/plugins/preauth/pkinit/pkinit_srv.c,"{""sha"": ""f7640baf14ccd00af9df09cb91559d01412f41bb"", ""filename"": ""src/plugins/preauth/pkinit/pkinit_crypto_openssl.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 21, ""changes"": 39, ""blob_url"": ""https://github.com/krb5/krb5/blob/50fe4074f188c2d4da0c421e96553acea8378db2/src/plugins/preauth/pkinit/pkinit_crypto_openssl.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/50fe4074f188c2d4da0c421e96553acea8378db2/src/plugins/preauth/pkinit/pkinit_crypto_openssl.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/plugins/preauth/pkinit/pkinit_crypto_openssl.c?ref=50fe4074f188c2d4da0c421e96553acea8378db2"", ""patch"": ""@@ -2125,7 +2125,6 @@ crypto_retrieve_X509_sans(krb5_context context,\n \n     if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {\n         pkiDebug(\""%s: found no subject alt name extensions\\n\"", __FUNCTION__);\n-        retval = ENOENT;\n         goto cleanup;\n     }\n     num_sans = sk_GENERAL_NAME_num(ialt);\n@@ -2228,31 +2227,29 @@ crypto_retrieve_X509_sans(krb5_context context,\n     sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);\n \n     retval = 0;\n-    if (princs)\n+    if (princs != NULL && *princs != NULL) {\n         *princs_ret = princs;\n-    if (upns)\n+        princs = NULL;\n+    }\n+    if (upns != NULL && *upns != NULL) {\n         *upn_ret = upns;\n-    if (dnss)\n+        upns = NULL;\n+    }\n+    if (dnss != NULL && *dnss != NULL) {\n         *dns_ret = dnss;\n+        dnss = NULL;\n+    }\n \n cleanup:\n-    if (retval) {\n-        if (princs != NULL) {\n-            for (i = 0; princs[i] != NULL; i++)\n-                krb5_free_principal(context, princs[i]);\n-            free(princs);\n-        }\n-        if (upns != NULL) {\n-            for (i = 0; upns[i] != NULL; i++)\n-                krb5_free_principal(context, upns[i]);\n-            free(upns);\n-        }\n-        if (dnss != NULL) {\n-            for (i = 0; dnss[i] != NULL; i++)\n-                free(dnss[i]);\n-            free(dnss);\n-        }\n-    }\n+    for (i = 0; princs != NULL && princs[i] != NULL; i++)\n+        krb5_free_principal(context, princs[i]);\n+    free(princs);\n+    for (i = 0; upns != NULL && upns[i] != NULL; i++)\n+        krb5_free_principal(context, upns[i]);\n+    free(upns);\n+    for (i = 0; dnss != NULL && dnss[i] != NULL; i++)\n+        free(dnss[i]);\n+    free(dnss);\n     return retval;\n }\n ""}<_**next**_>{""sha"": ""7210fc14cbbf61ebec6a7de9bbbc8ee98c63ce80"", ""filename"": ""src/plugins/preauth/pkinit/pkinit_srv.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 5, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/50fe4074f188c2d4da0c421e96553acea8378db2/src/plugins/preauth/pkinit/pkinit_srv.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/50fe4074f188c2d4da0c421e96553acea8378db2/src/plugins/preauth/pkinit/pkinit_srv.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/plugins/preauth/pkinit/pkinit_srv.c?ref=50fe4074f188c2d4da0c421e96553acea8378db2"", ""patch"": ""@@ -187,14 +187,18 @@ verify_client_san(krb5_context context,\n                                        &princs,\n                                        plgctx->opts->allow_upn ? &upns : NULL,\n                                        NULL);\n-    if (retval == ENOENT) {\n-        TRACE_PKINIT_SERVER_NO_SAN(context);\n-        goto out;\n-    } else if (retval) {\n+    if (retval) {\n         pkiDebug(\""%s: error from retrieve_certificate_sans()\\n\"", __FUNCTION__);\n         retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n         goto out;\n     }\n+\n+    if (princs == NULL && upns == NULL) {\n+        TRACE_PKINIT_SERVER_NO_SAN(context);\n+        retval = ENOENT;\n+        goto out;\n+    }\n+\n     /* XXX Verify this is consistent with client side XXX */\n #if 0\n     retval = call_san_checking_plugins(context, plgctx, reqctx, princs,\n@@ -1497,7 +1501,7 @@ pkinit_eku_authorize(krb5_context context, krb5_certauth_moddata moddata,\n         return KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;\n     }\n \n-    return 0;\n+    return KRB5_PLUGIN_NO_HANDLE;\n }\n \n static krb5_error_code""}","pkinit_eku_authorize(krb5_context context, krb5_certauth_moddata moddata,
                     const uint8_t *cert, size_t cert_len,
                     krb5_const_principal princ, const void *opts,
                     const struct _krb5_db_entry_new *db_entry,
                     char ***authinds_out)
{
    krb5_error_code ret;
    int valid_eku;
    const struct certauth_req_opts *req_opts = opts;

    *authinds_out = NULL;

    /* Verify the client EKU. */
    ret = verify_client_eku(context, req_opts->plgctx, req_opts->reqctx,
                            &valid_eku);
    if (ret)
        return ret;

    if (!valid_eku) {
        TRACE_PKINIT_SERVER_EKU_REJECT(context);
         return KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
     }
 
    return KRB5_PLUGIN_NO_HANDLE;
 }
","pkinit_eku_authorize(krb5_context context, krb5_certauth_moddata moddata,
                     const uint8_t *cert, size_t cert_len,
                     krb5_const_principal princ, const void *opts,
                     const struct _krb5_db_entry_new *db_entry,
                     char ***authinds_out)
{
    krb5_error_code ret;
    int valid_eku;
    const struct certauth_req_opts *req_opts = opts;

    *authinds_out = NULL;

    /* Verify the client EKU. */
    ret = verify_client_eku(context, req_opts->plgctx, req_opts->reqctx,
                            &valid_eku);
    if (ret)
        return ret;

    if (!valid_eku) {
        TRACE_PKINIT_SERVER_EKU_REJECT(context);
         return KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
     }
 
    return 0;
 }
",C,"    return KRB5_PLUGIN_NO_HANDLE;
","    return 0;
",,"@@ -187,14 +187,18 @@ verify_client_san(krb5_context context,
                                        &princs,
                                        plgctx->opts->allow_upn ? &upns : NULL,
                                        NULL);
-    if (retval == ENOENT) {
-        TRACE_PKINIT_SERVER_NO_SAN(context);
-        goto out;
-    } else if (retval) {
+    if (retval) {
         pkiDebug(""%s: error from retrieve_certificate_sans()\n"", __FUNCTION__);
         retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
         goto out;
     }
+
+    if (princs == NULL && upns == NULL) {
+        TRACE_PKINIT_SERVER_NO_SAN(context);
+        retval = ENOENT;
+        goto out;
+    }
+
     /* XXX Verify this is consistent with client side XXX */
 #if 0
     retval = call_san_checking_plugins(context, plgctx, reqctx, princs,
@@ -1497,7 +1501,7 @@ pkinit_eku_authorize(krb5_context context, krb5_certauth_moddata moddata,
         return KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
     }
 
-    return 0;
+    return KRB5_PLUGIN_NO_HANDLE;
 }
 
 static krb5_error_code",krb5,50fe4074f188c2d4da0c421e96553acea8378db2,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"pkinit_eku_authorize(krb5_context context, krb5_certauth_moddata moddata,
                     const uint8_t *cert, size_t cert_len,
                     krb5_const_principal princ, const void *opts,
                     const struct _krb5_db_entry_new *db_entry,
                     char ***authinds_out)
{
    krb5_error_code ret;
    int valid_eku;
    const struct certauth_req_opts *req_opts = opts;

    *authinds_out = NULL;

    /* Verify the client EKU. */
    ret = verify_client_eku(context, req_opts->plgctx, req_opts->reqctx,
                            &valid_eku);
    if (ret)
        return ret;

    if (!valid_eku) {
        TRACE_PKINIT_SERVER_EKU_REJECT(context);
         return KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
     }
 
//flaw_line_below:
    return 0;
//fix_flaw_line_below:
//    return KRB5_PLUGIN_NO_HANDLE;
 }
"
5611,183347,,Remote,Single system,,CVE-2017-7562,https://www.cvedetails.com/cve/CVE-2017-7562/,CWE-287,Low,,Partial,,2018-07-26,4.0,An authentication bypass flaw was found in the way krb5's certauth interface before 1.16.1 handled the validation of client certificates. A remote attacker able to communicate with the KDC could potentially use this flaw to impersonate arbitrary principals under rare and erroneous circumstances.,2019-10-09,Bypass ,8,https://github.com/krb5/krb5/pull/694/commits/50fe4074f188c2d4da0c421e96553acea8378db2,50fe4074f188c2d4da0c421e96553acea8378db2,"Fix certauth built-in module returns

The PKINIT certauth eku module should never authoritatively authorize
a certificate, because an extended key usage does not establish a
relationship between the certificate and any specific user; it only
establishes that the certificate was created for PKINIT client
authentication.  Therefore, pkinit_eku_authorize() should return
KRB5_PLUGIN_NO_HANDLE on success, not 0.

The certauth san module should pass if it does not find any SANs of
the types it can match against; the presence of other types of SANs
should not cause it to explicitly deny a certificate.  Check for an
empty result from crypto_retrieve_cert_sans() in verify_client_san(),
instead of returning ENOENT from crypto_retrieve_cert_sans() when
there are no SANs at all.

ticket: 8561",4,src/plugins/preauth/pkinit/pkinit_srv.c,"{""sha"": ""f7640baf14ccd00af9df09cb91559d01412f41bb"", ""filename"": ""src/plugins/preauth/pkinit/pkinit_crypto_openssl.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 21, ""changes"": 39, ""blob_url"": ""https://github.com/krb5/krb5/blob/50fe4074f188c2d4da0c421e96553acea8378db2/src/plugins/preauth/pkinit/pkinit_crypto_openssl.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/50fe4074f188c2d4da0c421e96553acea8378db2/src/plugins/preauth/pkinit/pkinit_crypto_openssl.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/plugins/preauth/pkinit/pkinit_crypto_openssl.c?ref=50fe4074f188c2d4da0c421e96553acea8378db2"", ""patch"": ""@@ -2125,7 +2125,6 @@ crypto_retrieve_X509_sans(krb5_context context,\n \n     if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {\n         pkiDebug(\""%s: found no subject alt name extensions\\n\"", __FUNCTION__);\n-        retval = ENOENT;\n         goto cleanup;\n     }\n     num_sans = sk_GENERAL_NAME_num(ialt);\n@@ -2228,31 +2227,29 @@ crypto_retrieve_X509_sans(krb5_context context,\n     sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);\n \n     retval = 0;\n-    if (princs)\n+    if (princs != NULL && *princs != NULL) {\n         *princs_ret = princs;\n-    if (upns)\n+        princs = NULL;\n+    }\n+    if (upns != NULL && *upns != NULL) {\n         *upn_ret = upns;\n-    if (dnss)\n+        upns = NULL;\n+    }\n+    if (dnss != NULL && *dnss != NULL) {\n         *dns_ret = dnss;\n+        dnss = NULL;\n+    }\n \n cleanup:\n-    if (retval) {\n-        if (princs != NULL) {\n-            for (i = 0; princs[i] != NULL; i++)\n-                krb5_free_principal(context, princs[i]);\n-            free(princs);\n-        }\n-        if (upns != NULL) {\n-            for (i = 0; upns[i] != NULL; i++)\n-                krb5_free_principal(context, upns[i]);\n-            free(upns);\n-        }\n-        if (dnss != NULL) {\n-            for (i = 0; dnss[i] != NULL; i++)\n-                free(dnss[i]);\n-            free(dnss);\n-        }\n-    }\n+    for (i = 0; princs != NULL && princs[i] != NULL; i++)\n+        krb5_free_principal(context, princs[i]);\n+    free(princs);\n+    for (i = 0; upns != NULL && upns[i] != NULL; i++)\n+        krb5_free_principal(context, upns[i]);\n+    free(upns);\n+    for (i = 0; dnss != NULL && dnss[i] != NULL; i++)\n+        free(dnss[i]);\n+    free(dnss);\n     return retval;\n }\n ""}<_**next**_>{""sha"": ""7210fc14cbbf61ebec6a7de9bbbc8ee98c63ce80"", ""filename"": ""src/plugins/preauth/pkinit/pkinit_srv.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 5, ""changes"": 14, ""blob_url"": ""https://github.com/krb5/krb5/blob/50fe4074f188c2d4da0c421e96553acea8378db2/src/plugins/preauth/pkinit/pkinit_srv.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/50fe4074f188c2d4da0c421e96553acea8378db2/src/plugins/preauth/pkinit/pkinit_srv.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/plugins/preauth/pkinit/pkinit_srv.c?ref=50fe4074f188c2d4da0c421e96553acea8378db2"", ""patch"": ""@@ -187,14 +187,18 @@ verify_client_san(krb5_context context,\n                                        &princs,\n                                        plgctx->opts->allow_upn ? &upns : NULL,\n                                        NULL);\n-    if (retval == ENOENT) {\n-        TRACE_PKINIT_SERVER_NO_SAN(context);\n-        goto out;\n-    } else if (retval) {\n+    if (retval) {\n         pkiDebug(\""%s: error from retrieve_certificate_sans()\\n\"", __FUNCTION__);\n         retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n         goto out;\n     }\n+\n+    if (princs == NULL && upns == NULL) {\n+        TRACE_PKINIT_SERVER_NO_SAN(context);\n+        retval = ENOENT;\n+        goto out;\n+    }\n+\n     /* XXX Verify this is consistent with client side XXX */\n #if 0\n     retval = call_san_checking_plugins(context, plgctx, reqctx, princs,\n@@ -1497,7 +1501,7 @@ pkinit_eku_authorize(krb5_context context, krb5_certauth_moddata moddata,\n         return KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;\n     }\n \n-    return 0;\n+    return KRB5_PLUGIN_NO_HANDLE;\n }\n \n static krb5_error_code""}","verify_client_san(krb5_context context,
                  pkinit_kdc_context plgctx,
                  pkinit_kdc_req_context reqctx,
                  krb5_kdcpreauth_callbacks cb,
                  krb5_kdcpreauth_rock rock,
                  krb5_const_principal client,
                  int *valid_san)
{
    krb5_error_code retval;
    krb5_principal *princs = NULL;
    krb5_principal *upns = NULL;
    int i;
#ifdef DEBUG_SAN_INFO
    char *client_string = NULL, *san_string;
#endif

    *valid_san = 0;
    retval = crypto_retrieve_cert_sans(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx,
                                        &princs,
                                        plgctx->opts->allow_upn ? &upns : NULL,
                                        NULL);
    if (retval) {
         pkiDebug(""%s: error from retrieve_certificate_sans()\n"", __FUNCTION__);
         retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
         goto out;
     }

    if (princs == NULL && upns == NULL) {
        TRACE_PKINIT_SERVER_NO_SAN(context);
        retval = ENOENT;
        goto out;
    }

     /* XXX Verify this is consistent with client side XXX */
 #if 0
     retval = call_san_checking_plugins(context, plgctx, reqctx, princs,
                                       upns, NULL, &plugin_decision, &ignore);
    pkiDebug(""%s: call_san_checking_plugins() returned retval %d\n"",
             __FUNCTION__);
    if (retval) {
        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
        goto cleanup;
    }
    pkiDebug(""%s: call_san_checking_plugins() returned decision %d\n"",
             __FUNCTION__, plugin_decision);
    if (plugin_decision != NO_DECISION) {
        retval = plugin_decision;
        goto out;
    }
#endif

#ifdef DEBUG_SAN_INFO
    krb5_unparse_name(context, client, &client_string);
#endif
    pkiDebug(""%s: Checking pkinit sans\n"", __FUNCTION__);
    for (i = 0; princs != NULL && princs[i] != NULL; i++) {
#ifdef DEBUG_SAN_INFO
        krb5_unparse_name(context, princs[i], &san_string);
        pkiDebug(""%s: Comparing client '%s' to pkinit san value '%s'\n"",
                 __FUNCTION__, client_string, san_string);
        krb5_free_unparsed_name(context, san_string);
#endif
        if (cb->match_client(context, rock, princs[i])) {
            TRACE_PKINIT_SERVER_MATCHING_SAN_FOUND(context);
            *valid_san = 1;
            retval = 0;
            goto out;
        }
    }
    pkiDebug(""%s: no pkinit san match found\n"", __FUNCTION__);
    /*
     * XXX if cert has names but none match, should we
     * be returning KRB5KDC_ERR_CLIENT_NAME_MISMATCH here?
     */

    if (upns == NULL) {
        pkiDebug(""%s: no upn sans (or we wouldn't accept them anyway)\n"",
                 __FUNCTION__);
        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
        goto out;
    }

    pkiDebug(""%s: Checking upn sans\n"", __FUNCTION__);
    for (i = 0; upns[i] != NULL; i++) {
#ifdef DEBUG_SAN_INFO
        krb5_unparse_name(context, upns[i], &san_string);
        pkiDebug(""%s: Comparing client '%s' to upn san value '%s'\n"",
                 __FUNCTION__, client_string, san_string);
        krb5_free_unparsed_name(context, san_string);
#endif
        if (cb->match_client(context, rock, upns[i])) {
            TRACE_PKINIT_SERVER_MATCHING_UPN_FOUND(context);
            *valid_san = 1;
            retval = 0;
            goto out;
        }
    }
    pkiDebug(""%s: no upn san match found\n"", __FUNCTION__);

    /* We found no match */
    if (princs != NULL || upns != NULL) {
        *valid_san = 0;
        /* XXX ??? If there was one or more name in the cert, but
         * none matched the client name, then return mismatch? */
        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
    }
    retval = 0;

out:
    if (princs != NULL) {
        for (i = 0; princs[i] != NULL; i++)
            krb5_free_principal(context, princs[i]);
        free(princs);
    }
    if (upns != NULL) {
        for (i = 0; upns[i] != NULL; i++)
            krb5_free_principal(context, upns[i]);
        free(upns);
    }
#ifdef DEBUG_SAN_INFO
    if (client_string != NULL)
        krb5_free_unparsed_name(context, client_string);
#endif
    pkiDebug(""%s: returning retval %d, valid_san %d\n"",
             __FUNCTION__, retval, *valid_san);
    return retval;
}
","verify_client_san(krb5_context context,
                  pkinit_kdc_context plgctx,
                  pkinit_kdc_req_context reqctx,
                  krb5_kdcpreauth_callbacks cb,
                  krb5_kdcpreauth_rock rock,
                  krb5_const_principal client,
                  int *valid_san)
{
    krb5_error_code retval;
    krb5_principal *princs = NULL;
    krb5_principal *upns = NULL;
    int i;
#ifdef DEBUG_SAN_INFO
    char *client_string = NULL, *san_string;
#endif

    *valid_san = 0;
    retval = crypto_retrieve_cert_sans(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx,
                                        &princs,
                                        plgctx->opts->allow_upn ? &upns : NULL,
                                        NULL);
    if (retval == ENOENT) {
        TRACE_PKINIT_SERVER_NO_SAN(context);
        goto out;
    } else if (retval) {
         pkiDebug(""%s: error from retrieve_certificate_sans()\n"", __FUNCTION__);
         retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
         goto out;
     }
     /* XXX Verify this is consistent with client side XXX */
 #if 0
     retval = call_san_checking_plugins(context, plgctx, reqctx, princs,
                                       upns, NULL, &plugin_decision, &ignore);
    pkiDebug(""%s: call_san_checking_plugins() returned retval %d\n"",
             __FUNCTION__);
    if (retval) {
        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
        goto cleanup;
    }
    pkiDebug(""%s: call_san_checking_plugins() returned decision %d\n"",
             __FUNCTION__, plugin_decision);
    if (plugin_decision != NO_DECISION) {
        retval = plugin_decision;
        goto out;
    }
#endif

#ifdef DEBUG_SAN_INFO
    krb5_unparse_name(context, client, &client_string);
#endif
    pkiDebug(""%s: Checking pkinit sans\n"", __FUNCTION__);
    for (i = 0; princs != NULL && princs[i] != NULL; i++) {
#ifdef DEBUG_SAN_INFO
        krb5_unparse_name(context, princs[i], &san_string);
        pkiDebug(""%s: Comparing client '%s' to pkinit san value '%s'\n"",
                 __FUNCTION__, client_string, san_string);
        krb5_free_unparsed_name(context, san_string);
#endif
        if (cb->match_client(context, rock, princs[i])) {
            TRACE_PKINIT_SERVER_MATCHING_SAN_FOUND(context);
            *valid_san = 1;
            retval = 0;
            goto out;
        }
    }
    pkiDebug(""%s: no pkinit san match found\n"", __FUNCTION__);
    /*
     * XXX if cert has names but none match, should we
     * be returning KRB5KDC_ERR_CLIENT_NAME_MISMATCH here?
     */

    if (upns == NULL) {
        pkiDebug(""%s: no upn sans (or we wouldn't accept them anyway)\n"",
                 __FUNCTION__);
        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
        goto out;
    }

    pkiDebug(""%s: Checking upn sans\n"", __FUNCTION__);
    for (i = 0; upns[i] != NULL; i++) {
#ifdef DEBUG_SAN_INFO
        krb5_unparse_name(context, upns[i], &san_string);
        pkiDebug(""%s: Comparing client '%s' to upn san value '%s'\n"",
                 __FUNCTION__, client_string, san_string);
        krb5_free_unparsed_name(context, san_string);
#endif
        if (cb->match_client(context, rock, upns[i])) {
            TRACE_PKINIT_SERVER_MATCHING_UPN_FOUND(context);
            *valid_san = 1;
            retval = 0;
            goto out;
        }
    }
    pkiDebug(""%s: no upn san match found\n"", __FUNCTION__);

    /* We found no match */
    if (princs != NULL || upns != NULL) {
        *valid_san = 0;
        /* XXX ??? If there was one or more name in the cert, but
         * none matched the client name, then return mismatch? */
        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
    }
    retval = 0;

out:
    if (princs != NULL) {
        for (i = 0; princs[i] != NULL; i++)
            krb5_free_principal(context, princs[i]);
        free(princs);
    }
    if (upns != NULL) {
        for (i = 0; upns[i] != NULL; i++)
            krb5_free_principal(context, upns[i]);
        free(upns);
    }
#ifdef DEBUG_SAN_INFO
    if (client_string != NULL)
        krb5_free_unparsed_name(context, client_string);
#endif
    pkiDebug(""%s: returning retval %d, valid_san %d\n"",
             __FUNCTION__, retval, *valid_san);
    return retval;
}
",C,"    if (retval) {

    if (princs == NULL && upns == NULL) {
        TRACE_PKINIT_SERVER_NO_SAN(context);
        retval = ENOENT;
        goto out;
    }

","    if (retval == ENOENT) {
        TRACE_PKINIT_SERVER_NO_SAN(context);
        goto out;
    } else if (retval) {
",,"@@ -187,14 +187,18 @@ verify_client_san(krb5_context context,
                                        &princs,
                                        plgctx->opts->allow_upn ? &upns : NULL,
                                        NULL);
-    if (retval == ENOENT) {
-        TRACE_PKINIT_SERVER_NO_SAN(context);
-        goto out;
-    } else if (retval) {
+    if (retval) {
         pkiDebug(""%s: error from retrieve_certificate_sans()\n"", __FUNCTION__);
         retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
         goto out;
     }
+
+    if (princs == NULL && upns == NULL) {
+        TRACE_PKINIT_SERVER_NO_SAN(context);
+        retval = ENOENT;
+        goto out;
+    }
+
     /* XXX Verify this is consistent with client side XXX */
 #if 0
     retval = call_san_checking_plugins(context, plgctx, reqctx, princs,
@@ -1497,7 +1501,7 @@ pkinit_eku_authorize(krb5_context context, krb5_certauth_moddata moddata,
         return KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
     }
 
-    return 0;
+    return KRB5_PLUGIN_NO_HANDLE;
 }
 
 static krb5_error_code",krb5,50fe4074f188c2d4da0c421e96553acea8378db2,a96ac7f73b5804a9c34033539a933ec0b64cce11,1,"verify_client_san(krb5_context context,
                  pkinit_kdc_context plgctx,
                  pkinit_kdc_req_context reqctx,
                  krb5_kdcpreauth_callbacks cb,
                  krb5_kdcpreauth_rock rock,
                  krb5_const_principal client,
                  int *valid_san)
{
    krb5_error_code retval;
    krb5_principal *princs = NULL;
    krb5_principal *upns = NULL;
    int i;
#ifdef DEBUG_SAN_INFO
    char *client_string = NULL, *san_string;
#endif

    *valid_san = 0;
    retval = crypto_retrieve_cert_sans(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx,
                                        &princs,
                                        plgctx->opts->allow_upn ? &upns : NULL,
                                        NULL);
//flaw_line_below:
    if (retval == ENOENT) {
//flaw_line_below:
        TRACE_PKINIT_SERVER_NO_SAN(context);
//flaw_line_below:
        goto out;
//flaw_line_below:
    } else if (retval) {
//fix_flaw_line_below:
//    if (retval) {
         pkiDebug(""%s: error from retrieve_certificate_sans()\n"", __FUNCTION__);
         retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
         goto out;
     }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (princs == NULL && upns == NULL) {
//fix_flaw_line_below:
//        TRACE_PKINIT_SERVER_NO_SAN(context);
//fix_flaw_line_below:
//        retval = ENOENT;
//fix_flaw_line_below:
//        goto out;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     /* XXX Verify this is consistent with client side XXX */
 #if 0
     retval = call_san_checking_plugins(context, plgctx, reqctx, princs,
                                       upns, NULL, &plugin_decision, &ignore);
    pkiDebug(""%s: call_san_checking_plugins() returned retval %d\n"",
             __FUNCTION__);
    if (retval) {
        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
        goto cleanup;
    }
    pkiDebug(""%s: call_san_checking_plugins() returned decision %d\n"",
             __FUNCTION__, plugin_decision);
    if (plugin_decision != NO_DECISION) {
        retval = plugin_decision;
        goto out;
    }
#endif

#ifdef DEBUG_SAN_INFO
    krb5_unparse_name(context, client, &client_string);
#endif
    pkiDebug(""%s: Checking pkinit sans\n"", __FUNCTION__);
    for (i = 0; princs != NULL && princs[i] != NULL; i++) {
#ifdef DEBUG_SAN_INFO
        krb5_unparse_name(context, princs[i], &san_string);
        pkiDebug(""%s: Comparing client '%s' to pkinit san value '%s'\n"",
                 __FUNCTION__, client_string, san_string);
        krb5_free_unparsed_name(context, san_string);
#endif
        if (cb->match_client(context, rock, princs[i])) {
            TRACE_PKINIT_SERVER_MATCHING_SAN_FOUND(context);
            *valid_san = 1;
            retval = 0;
            goto out;
        }
    }
    pkiDebug(""%s: no pkinit san match found\n"", __FUNCTION__);
    /*
     * XXX if cert has names but none match, should we
     * be returning KRB5KDC_ERR_CLIENT_NAME_MISMATCH here?
     */

    if (upns == NULL) {
        pkiDebug(""%s: no upn sans (or we wouldn't accept them anyway)\n"",
                 __FUNCTION__);
        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
        goto out;
    }

    pkiDebug(""%s: Checking upn sans\n"", __FUNCTION__);
    for (i = 0; upns[i] != NULL; i++) {
#ifdef DEBUG_SAN_INFO
        krb5_unparse_name(context, upns[i], &san_string);
        pkiDebug(""%s: Comparing client '%s' to upn san value '%s'\n"",
                 __FUNCTION__, client_string, san_string);
        krb5_free_unparsed_name(context, san_string);
#endif
        if (cb->match_client(context, rock, upns[i])) {
            TRACE_PKINIT_SERVER_MATCHING_UPN_FOUND(context);
            *valid_san = 1;
            retval = 0;
            goto out;
        }
    }
    pkiDebug(""%s: no upn san match found\n"", __FUNCTION__);

    /* We found no match */
    if (princs != NULL || upns != NULL) {
        *valid_san = 0;
        /* XXX ??? If there was one or more name in the cert, but
         * none matched the client name, then return mismatch? */
        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
    }
    retval = 0;

out:
    if (princs != NULL) {
        for (i = 0; princs[i] != NULL; i++)
            krb5_free_principal(context, princs[i]);
        free(princs);
    }
    if (upns != NULL) {
        for (i = 0; upns[i] != NULL; i++)
            krb5_free_principal(context, upns[i]);
        free(upns);
    }
#ifdef DEBUG_SAN_INFO
    if (client_string != NULL)
        krb5_free_unparsed_name(context, client_string);
#endif
    pkiDebug(""%s: returning retval %d, valid_san %d\n"",
             __FUNCTION__, retval, *valid_san);
    return retval;
}
"
7092,184828,,Remote,Not required,Partial,CVE-2013-6634,https://www.cvedetails.com/cve/CVE-2013-6634/,CWE-287,Medium,Partial,Partial,,2013-12-06,6.8,"The OneClickSigninHelper::ShowInfoBarIfPossible function in browser/ui/sync/one_click_signin_helper.cc in Google Chrome before 31.0.1650.63 uses an incorrect URL during realm validation, which allows remote attackers to conduct session fixation attacks and hijack web sessions by triggering improper sync after a 302 (aka Found) HTTP status code.",2014-03-05,,1,https://github.com/chromium/chromium/commit/50370b3c98047bdc80184ff87a502edc5c597d3a,50370b3c98047bdc80184ff87a502edc5c597d3a,"During redirects in the one click sign in flow, check the current URL
instead of original URL to validate gaia http headers.

BUG=307159

Review URL: https://codereview.chromium.org/77343002

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@236563 0039d316-1c4b-4281-b951-d872f2087c98",1,chrome/browser/ui/sync/one_click_signin_helper.cc,"{""sha"": ""eecf03c35892b74e9a6141efdde5ef4ffa3a1466"", ""filename"": ""chrome/browser/ui/sync/one_click_signin_helper.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/50370b3c98047bdc80184ff87a502edc5c597d3a/chrome/browser/ui/sync/one_click_signin_helper.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50370b3c98047bdc80184ff87a502edc5c597d3a/chrome/browser/ui/sync/one_click_signin_helper.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/sync/one_click_signin_helper.cc?ref=50370b3c98047bdc80184ff87a502edc5c597d3a"", ""patch"": ""@@ -855,7 +855,7 @@ void OneClickSigninHelper::ShowInfoBarIfPossible(net::URLRequest* request,\n             << \"" g-c-s='\"" << google_chrome_signin_value << \""'\"";\n   }\n \n-  if (!gaia::IsGaiaSignonRealm(request->original_url().GetOrigin()))\n+  if (!gaia::IsGaiaSignonRealm(request->url().GetOrigin()))\n     return;\n \n   // Parse Google-Accounts-SignIn.""}","void OneClickSigninHelper::ShowInfoBarIfPossible(net::URLRequest* request,
                                                 ProfileIOData* io_data,
                                                 int child_id,
                                                 int route_id) {
  std::string google_chrome_signin_value;
  std::string google_accounts_signin_value;
  request->GetResponseHeaderByName(""Google-Chrome-SignIn"",
                                   &google_chrome_signin_value);
  request->GetResponseHeaderByName(""Google-Accounts-SignIn"",
                                   &google_accounts_signin_value);

  if (!google_accounts_signin_value.empty() ||
      !google_chrome_signin_value.empty()) {
    VLOG(1) << ""OneClickSigninHelper::ShowInfoBarIfPossible:""
            << "" g-a-s='"" << google_accounts_signin_value << ""'""
             << "" g-c-s='"" << google_chrome_signin_value << ""'"";
   }
 
  if (!gaia::IsGaiaSignonRealm(request->url().GetOrigin()))
     return;
 
  std::vector<std::pair<std::string, std::string> > pairs;
  base::SplitStringIntoKeyValuePairs(google_accounts_signin_value, '=', ',',
                                     &pairs);
  std::string session_index;
  std::string email;
  for (size_t i = 0; i < pairs.size(); ++i) {
    const std::pair<std::string, std::string>& pair = pairs[i];
    const std::string& key = pair.first;
    const std::string& value = pair.second;
    if (key == ""email"") {
      TrimString(value, ""\"""", &email);
    } else if (key == ""sessionindex"") {
      session_index = value;
    }
  }

  if (!email.empty())
    io_data->set_reverse_autologin_pending_email(email);

  if (!email.empty() || !session_index.empty()) {
    VLOG(1) << ""OneClickSigninHelper::ShowInfoBarIfPossible:""
            << "" email="" << email
            << "" sessionindex="" << session_index;
  }

  AutoAccept auto_accept = AUTO_ACCEPT_NONE;
  signin::Source source = signin::SOURCE_UNKNOWN;
  GURL continue_url;
  std::vector<std::string> tokens;
  base::SplitString(google_chrome_signin_value, ',', &tokens);
  for (size_t i = 0; i < tokens.size(); ++i) {
    const std::string& token = tokens[i];
    if (token == ""accepted"") {
      auto_accept = AUTO_ACCEPT_ACCEPTED;
    } else if (token == ""configure"") {
      auto_accept = AUTO_ACCEPT_CONFIGURE;
    } else if (token == ""rejected-for-profile"") {
      auto_accept = AUTO_ACCEPT_REJECTED_FOR_PROFILE;
    }
  }

  source = GetSigninSource(request->url(), &continue_url);
  if (source != signin::SOURCE_UNKNOWN)
    auto_accept = AUTO_ACCEPT_EXPLICIT;

  if (auto_accept != AUTO_ACCEPT_NONE) {
    VLOG(1) << ""OneClickSigninHelper::ShowInfoBarIfPossible:""
            << "" auto_accept="" << auto_accept;
  }

  if (session_index.empty() && email.empty() &&
      auto_accept == AUTO_ACCEPT_NONE && !continue_url.is_valid()) {
    return;
  }

  content::BrowserThread::PostTask(
      content::BrowserThread::UI, FROM_HERE,
      base::Bind(&OneClickSigninHelper::ShowInfoBarUIThread, session_index,
                 email, auto_accept, source, continue_url, child_id, route_id));
}
","void OneClickSigninHelper::ShowInfoBarIfPossible(net::URLRequest* request,
                                                 ProfileIOData* io_data,
                                                 int child_id,
                                                 int route_id) {
  std::string google_chrome_signin_value;
  std::string google_accounts_signin_value;
  request->GetResponseHeaderByName(""Google-Chrome-SignIn"",
                                   &google_chrome_signin_value);
  request->GetResponseHeaderByName(""Google-Accounts-SignIn"",
                                   &google_accounts_signin_value);

  if (!google_accounts_signin_value.empty() ||
      !google_chrome_signin_value.empty()) {
    VLOG(1) << ""OneClickSigninHelper::ShowInfoBarIfPossible:""
            << "" g-a-s='"" << google_accounts_signin_value << ""'""
             << "" g-c-s='"" << google_chrome_signin_value << ""'"";
   }
 
  if (!gaia::IsGaiaSignonRealm(request->original_url().GetOrigin()))
     return;
 
  std::vector<std::pair<std::string, std::string> > pairs;
  base::SplitStringIntoKeyValuePairs(google_accounts_signin_value, '=', ',',
                                     &pairs);
  std::string session_index;
  std::string email;
  for (size_t i = 0; i < pairs.size(); ++i) {
    const std::pair<std::string, std::string>& pair = pairs[i];
    const std::string& key = pair.first;
    const std::string& value = pair.second;
    if (key == ""email"") {
      TrimString(value, ""\"""", &email);
    } else if (key == ""sessionindex"") {
      session_index = value;
    }
  }

  if (!email.empty())
    io_data->set_reverse_autologin_pending_email(email);

  if (!email.empty() || !session_index.empty()) {
    VLOG(1) << ""OneClickSigninHelper::ShowInfoBarIfPossible:""
            << "" email="" << email
            << "" sessionindex="" << session_index;
  }

  AutoAccept auto_accept = AUTO_ACCEPT_NONE;
  signin::Source source = signin::SOURCE_UNKNOWN;
  GURL continue_url;
  std::vector<std::string> tokens;
  base::SplitString(google_chrome_signin_value, ',', &tokens);
  for (size_t i = 0; i < tokens.size(); ++i) {
    const std::string& token = tokens[i];
    if (token == ""accepted"") {
      auto_accept = AUTO_ACCEPT_ACCEPTED;
    } else if (token == ""configure"") {
      auto_accept = AUTO_ACCEPT_CONFIGURE;
    } else if (token == ""rejected-for-profile"") {
      auto_accept = AUTO_ACCEPT_REJECTED_FOR_PROFILE;
    }
  }

  source = GetSigninSource(request->url(), &continue_url);
  if (source != signin::SOURCE_UNKNOWN)
    auto_accept = AUTO_ACCEPT_EXPLICIT;

  if (auto_accept != AUTO_ACCEPT_NONE) {
    VLOG(1) << ""OneClickSigninHelper::ShowInfoBarIfPossible:""
            << "" auto_accept="" << auto_accept;
  }

  if (session_index.empty() && email.empty() &&
      auto_accept == AUTO_ACCEPT_NONE && !continue_url.is_valid()) {
    return;
  }

  content::BrowserThread::PostTask(
      content::BrowserThread::UI, FROM_HERE,
      base::Bind(&OneClickSigninHelper::ShowInfoBarUIThread, session_index,
                 email, auto_accept, source, continue_url, child_id, route_id));
}
",C,"  if (!gaia::IsGaiaSignonRealm(request->url().GetOrigin()))
","  if (!gaia::IsGaiaSignonRealm(request->original_url().GetOrigin()))
",,"@@ -855,7 +855,7 @@ void OneClickSigninHelper::ShowInfoBarIfPossible(net::URLRequest* request,
             << "" g-c-s='"" << google_chrome_signin_value << ""'"";
   }
 
-  if (!gaia::IsGaiaSignonRealm(request->original_url().GetOrigin()))
+  if (!gaia::IsGaiaSignonRealm(request->url().GetOrigin()))
     return;
 
   // Parse Google-Accounts-SignIn.",Chrome,50370b3c98047bdc80184ff87a502edc5c597d3a,8b23a96ea48a39ce96f329cc4a46ada1f8958524,1,"void OneClickSigninHelper::ShowInfoBarIfPossible(net::URLRequest* request,
                                                 ProfileIOData* io_data,
                                                 int child_id,
                                                 int route_id) {
  std::string google_chrome_signin_value;
  std::string google_accounts_signin_value;
  request->GetResponseHeaderByName(""Google-Chrome-SignIn"",
                                   &google_chrome_signin_value);
  request->GetResponseHeaderByName(""Google-Accounts-SignIn"",
                                   &google_accounts_signin_value);

  if (!google_accounts_signin_value.empty() ||
      !google_chrome_signin_value.empty()) {
    VLOG(1) << ""OneClickSigninHelper::ShowInfoBarIfPossible:""
            << "" g-a-s='"" << google_accounts_signin_value << ""'""
             << "" g-c-s='"" << google_chrome_signin_value << ""'"";
   }
 
//flaw_line_below:
  if (!gaia::IsGaiaSignonRealm(request->original_url().GetOrigin()))
//fix_flaw_line_below:
//  if (!gaia::IsGaiaSignonRealm(request->url().GetOrigin()))
     return;
 
   // Parse Google-Accounts-SignIn.
  std::vector<std::pair<std::string, std::string> > pairs;
  base::SplitStringIntoKeyValuePairs(google_accounts_signin_value, '=', ',',
                                     &pairs);
  std::string session_index;
  std::string email;
  for (size_t i = 0; i < pairs.size(); ++i) {
    const std::pair<std::string, std::string>& pair = pairs[i];
    const std::string& key = pair.first;
    const std::string& value = pair.second;
    if (key == ""email"") {
      TrimString(value, ""\"""", &email);
    } else if (key == ""sessionindex"") {
      session_index = value;
    }
  }

  // Later in the chain of this request, we'll need to check the email address
  // in the IO thread (see CanOfferOnIOThread).  So save the email address as
  // user data on the request (only for web-based flow).
  if (!email.empty())
    io_data->set_reverse_autologin_pending_email(email);

  if (!email.empty() || !session_index.empty()) {
    VLOG(1) << ""OneClickSigninHelper::ShowInfoBarIfPossible:""
            << "" email="" << email
            << "" sessionindex="" << session_index;
  }

  // Parse Google-Chrome-SignIn.
  AutoAccept auto_accept = AUTO_ACCEPT_NONE;
  signin::Source source = signin::SOURCE_UNKNOWN;
  GURL continue_url;
  std::vector<std::string> tokens;
  base::SplitString(google_chrome_signin_value, ',', &tokens);
  for (size_t i = 0; i < tokens.size(); ++i) {
    const std::string& token = tokens[i];
    if (token == ""accepted"") {
      auto_accept = AUTO_ACCEPT_ACCEPTED;
    } else if (token == ""configure"") {
      auto_accept = AUTO_ACCEPT_CONFIGURE;
    } else if (token == ""rejected-for-profile"") {
      auto_accept = AUTO_ACCEPT_REJECTED_FOR_PROFILE;
    }
  }

  // If this is an explicit sign in (i.e., first run, NTP, Apps page, menu,
  // settings) then force the auto accept type to explicit.
  source = GetSigninSource(request->url(), &continue_url);
  if (source != signin::SOURCE_UNKNOWN)
    auto_accept = AUTO_ACCEPT_EXPLICIT;

  if (auto_accept != AUTO_ACCEPT_NONE) {
    VLOG(1) << ""OneClickSigninHelper::ShowInfoBarIfPossible:""
            << "" auto_accept="" << auto_accept;
  }

  // If |session_index|, |email|, |auto_accept|, and |continue_url| all have
  // their default value, don't bother posting a task to the UI thread.
  // It will be a noop anyway.
  //
  // The two headers above may (but not always) come in different http requests
  // so a post to the UI thread is still needed if |auto_accept| is not its
  // default value, but |email| and |session_index| are.
  if (session_index.empty() && email.empty() &&
      auto_accept == AUTO_ACCEPT_NONE && !continue_url.is_valid()) {
    return;
  }

  content::BrowserThread::PostTask(
      content::BrowserThread::UI, FROM_HERE,
      base::Bind(&OneClickSigninHelper::ShowInfoBarUIThread, session_index,
                 email, auto_accept, source, continue_url, child_id, route_id));
}
"
7432,185168,,Remote,Not required,Partial,CVE-2013-0910,https://www.cvedetails.com/cve/CVE-2013-0910/,CWE-287,Low,Partial,Partial,,2013-03-05,7.5,"Google Chrome before 25.0.1364.152 does not properly manage the interaction between the browser process and renderer processes during authorization of the loading of a plug-in, which makes it easier for remote attackers to bypass intended access restrictions via vectors involving a blocked plug-in.",2017-09-18,Bypass ,4,https://github.com/chromium/chromium/commit/ac8bd041b81e46e4e4fcd5021aaa5499703952e6,ac8bd041b81e46e4e4fcd5021aaa5499703952e6,"Follow-on fixes and naming changes for https://codereview.chromium.org/12086077/

BUG=172573
Review URL: https://codereview.chromium.org/12177018

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@180600 0039d316-1c4b-4281-b951-d872f2087c98",4,chrome/browser/plugins/chrome_plugin_service_filter.cc,"{""sha"": ""072269f723daf87a86251f9f4a4fae5574f5be8b"", ""filename"": ""chrome/browser/plugins/chrome_plugin_service_filter.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/chrome_plugin_service_filter.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -69,7 +69,7 @@ void ChromePluginServiceFilter::UnrestrictPlugin(\n   restricted_plugins_.erase(plugin_path);\n }\n \n-bool ChromePluginServiceFilter::IsPluginEnabled(\n+bool ChromePluginServiceFilter::IsPluginAvailable(\n     int render_process_id,\n     int render_view_id,\n     const void* context,\n@@ -87,10 +87,9 @@ bool ChromePluginServiceFilter::IsPluginEnabled(\n            details->overridden_plugins[i].url.is_empty())) {\n \n         bool use = details->overridden_plugins[i].plugin.path == plugin->path;\n-        if (!use)\n-          return false;\n-        *plugin = details->overridden_plugins[i].plugin;\n-        break;\n+        if (use)\n+          *plugin = details->overridden_plugins[i].plugin;\n+        return use;\n       }\n     }\n   }""}<_**next**_>{""sha"": ""6c69b9b6d8c3c7ab81156a117bed86d42240cbda"", ""filename"": ""chrome/browser/plugins/chrome_plugin_service_filter.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/chrome_plugin_service_filter.h?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -58,7 +58,7 @@ class ChromePluginServiceFilter : public content::PluginServiceFilter,\n   void AuthorizeAllPlugins(int render_process_id);\n \n   // PluginServiceFilter implementation:\n-  virtual bool IsPluginEnabled(\n+  virtual bool IsPluginAvailable(\n       int render_process_id,\n       int render_view_id,\n       const void* context,""}<_**next**_>{""sha"": ""6b77bc2b7451e3c7540f599bfba4c093a26df85b"", ""filename"": ""chrome/browser/plugins/plugin_info_message_filter.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/plugin_info_message_filter.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -133,7 +133,7 @@ void PluginInfoMessageFilter::PluginsLoaded(\n     output.group_name = plugin_metadata->name();\n   }\n \n-  context_.GrantAccess(output.status, output.plugin.path);\n+  context_.MaybeGrantAccess(output.status, output.plugin.path);\n \n   ChromeViewHostMsg_GetPluginInfo::WriteReplyParams(reply_msg, output);\n   Send(reply_msg);\n@@ -228,12 +228,12 @@ bool PluginInfoMessageFilter::Context::FindEnabledPlugin(\n       PluginService::GetInstance()->GetFilter();\n   size_t i = 0;\n   for (; i < matching_plugins.size(); ++i) {\n-    if (!filter || filter->IsPluginEnabled(render_process_id_,\n-                                           render_view_id,\n-                                           resource_context_,\n-                                           url,\n-                                           top_origin_url,\n-                                           &matching_plugins[i])) {\n+    if (!filter || filter->IsPluginAvailable(render_process_id_,\n+                                             render_view_id,\n+                                             resource_context_,\n+                                             url,\n+                                             top_origin_url,\n+                                             &matching_plugins[i])) {\n       break;\n     }\n   }\n@@ -293,7 +293,7 @@ void PluginInfoMessageFilter::Context::GetPluginContentSetting(\n       info.secondary_pattern == ContentSettingsPattern::Wildcard();\n }\n \n-void PluginInfoMessageFilter::Context::GrantAccess(\n+void PluginInfoMessageFilter::Context::MaybeGrantAccess(\n     const ChromeViewHostMsg_GetPluginInfo_Status& status,\n     const FilePath& path) const {\n   if (status.value == ChromeViewHostMsg_GetPluginInfo_Status::kAllowed ||""}<_**next**_>{""sha"": ""7e5d8663d14cc7c72009480df996e2e9b33c7baa"", ""filename"": ""chrome/browser/plugins/plugin_info_message_filter.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/plugin_info_message_filter.h?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -63,8 +63,8 @@ class PluginInfoMessageFilter : public content::BrowserMessageFilter {\n                                  const std::string& resource,\n                                  ContentSetting* setting,\n                                  bool* is_default) const;\n-    void GrantAccess(const ChromeViewHostMsg_GetPluginInfo_Status& status,\n-                     const FilePath& path) const;\n+    void MaybeGrantAccess(const ChromeViewHostMsg_GetPluginInfo_Status& status,\n+                          const FilePath& path) const;\n \n    private:\n     int render_process_id_;""}<_**next**_>{""sha"": ""50c0aa82b791c6918f384452ca78e4a489dfe183"", ""filename"": ""chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -27,12 +27,12 @@ class FakePluginServiceFilter : public content::PluginServiceFilter {\n   FakePluginServiceFilter() {}\n   virtual ~FakePluginServiceFilter() {}\n \n-  virtual bool IsPluginEnabled(int render_process_id,\n-                               int render_view_id,\n-                               const void* context,\n-                               const GURL& url,\n-                               const GURL& policy_url,\n-                               webkit::WebPluginInfo* plugin) OVERRIDE;\n+  virtual bool IsPluginAvailable(int render_process_id,\n+                                 int render_view_id,\n+                                 const void* context,\n+                                 const GURL& url,\n+                                 const GURL& policy_url,\n+                                 webkit::WebPluginInfo* plugin) OVERRIDE;\n \n   virtual bool CanLoadPlugin(int render_process_id,\n                              const FilePath& path) OVERRIDE;\n@@ -45,12 +45,12 @@ class FakePluginServiceFilter : public content::PluginServiceFilter {\n   std::map<FilePath, bool> plugin_state_;\n };\n \n-bool FakePluginServiceFilter::IsPluginEnabled(int render_process_id,\n-                                              int render_view_id,\n-                                              const void* context,\n-                                              const GURL& url,\n-                                              const GURL& policy_url,\n-                                              webkit::WebPluginInfo* plugin) {\n+bool FakePluginServiceFilter::IsPluginAvailable(int render_process_id,\n+                                                int render_view_id,\n+                                                const void* context,\n+                                                const GURL& url,\n+                                                const GURL& policy_url,\n+                                                webkit::WebPluginInfo* plugin) {\n   std::map<FilePath, bool>::iterator it = plugin_state_.find(plugin->path);\n   if (it == plugin_state_.end()) {\n     ADD_FAILURE() << \""No plug-in state for '\"" << plugin->path.value() << \""'\"";""}<_**next**_>{""sha"": ""7079828f897928a21ba382fb2fca39406ccd985e"", ""filename"": ""content/browser/plugin_service_impl.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/plugin_service_impl.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -489,12 +489,12 @@ bool PluginServiceImpl::GetPluginInfo(int render_process_id,\n     *is_stale = stale;\n \n   for (size_t i = 0; i < plugins.size(); ++i) {\n-    if (!filter_ || filter_->IsPluginEnabled(render_process_id,\n-                                             render_view_id,\n-                                             context,\n-                                             url,\n-                                             page_url,\n-                                             &plugins[i])) {\n+    if (!filter_ || filter_->IsPluginAvailable(render_process_id,\n+                                               render_view_id,\n+                                               context,\n+                                               url,\n+                                               page_url,\n+                                               &plugins[i])) {\n       *info = plugins[i];\n       if (actual_mime_type)\n         *actual_mime_type = mime_types[i];""}<_**next**_>{""sha"": ""94b929ae26fcd7767d40791168f2b134bbe2ce36"", ""filename"": ""content/browser/plugin_service_impl_browsertest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/plugin_service_impl_browsertest.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -121,7 +121,7 @@ class MockPluginServiceFilter : public content::PluginServiceFilter {\n  public:\n   MockPluginServiceFilter() {}\n \n-  virtual bool IsPluginEnabled(\n+  virtual bool IsPluginAvailable(\n       int render_process_id,\n       int render_view_id,\n       const void* context,""}<_**next**_>{""sha"": ""9bd597b7101c694dfcdbef41adaa96fcb935cd91"", ""filename"": ""content/browser/renderer_host/render_message_filter.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/renderer_host/render_message_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/renderer_host/render_message_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/render_message_filter.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -673,12 +673,12 @@ void RenderMessageFilter::GetPluginsCallback(\n   for (size_t i = 0; i < all_plugins.size(); ++i) {\n     // Copy because the filter can mutate.\n     webkit::WebPluginInfo plugin(all_plugins[i]);\n-    if (!filter || filter->IsPluginEnabled(child_process_id,\n-                                           routing_id,\n-                                           resource_context_,\n-                                           GURL(),\n-                                           GURL(),\n-                                           &plugin)) {\n+    if (!filter || filter->IsPluginAvailable(child_process_id,\n+                                             routing_id,\n+                                             resource_context_,\n+                                             GURL(),\n+                                             GURL(),\n+                                             &plugin)) {\n       plugins.push_back(plugin);\n     }\n   }""}<_**next**_>{""sha"": ""f0b8bbc875736a13047ce51c65d14bd1db2d3e2b"", ""filename"": ""content/public/browser/plugin_service_filter.h"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/public/browser/plugin_service_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/public/browser/plugin_service_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/public/browser/plugin_service_filter.h?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -20,16 +20,16 @@ class PluginServiceFilter {\n  public:\n   virtual ~PluginServiceFilter() {}\n \n-  // Whether |plugin| is enabled. The client can return false to hide the\n+  // Whether |plugin| is available. The client can return false to hide the\n   // plugin, or return true and optionally change the passed in plugin.\n-  virtual bool IsPluginEnabled(int render_process_id,\n-                               int render_view_id,\n-                               const void* context,\n-                               const GURL& url,\n-                               const GURL& policy_url,\n-                               webkit::WebPluginInfo* plugin) = 0;\n-\n-  // Whether the renderer has permission to load enabled |plugin|.\n+  virtual bool IsPluginAvailable(int render_process_id,\n+                                 int render_view_id,\n+                                 const void* context,\n+                                 const GURL& url,\n+                                 const GURL& policy_url,\n+                                 webkit::WebPluginInfo* plugin) = 0;\n+\n+  // Whether the renderer has permission to load available |plugin|.\n   virtual bool CanLoadPlugin(int render_process_id,\n                              const FilePath& path) = 0;\n };""}","bool ChromePluginServiceFilter::IsPluginEnabled(
bool ChromePluginServiceFilter::IsPluginAvailable(
     int render_process_id,
     int render_view_id,
     const void* context,
    const GURL& url,
    const GURL& policy_url,
    webkit::WebPluginInfo* plugin) {
  base::AutoLock auto_lock(lock_);
  const ProcessDetails* details = GetProcess(render_process_id);

  if (details) {
    for (size_t i = 0; i < details->overridden_plugins.size(); ++i) {
      if (details->overridden_plugins[i].render_view_id == render_view_id &&
          (details->overridden_plugins[i].url == url ||
            details->overridden_plugins[i].url.is_empty())) {
 
         bool use = details->overridden_plugins[i].plugin.path == plugin->path;
        if (use)
          *plugin = details->overridden_plugins[i].plugin;
        return use;
       }
     }
   }

  ResourceContextMap::iterator prefs_it =
      resource_context_map_.find(context);
  if (prefs_it == resource_context_map_.end())
    return false;

  PluginPrefs* plugin_prefs = prefs_it->second.get();
  if (!plugin_prefs->IsPluginEnabled(*plugin))
    return false;

  RestrictedPluginMap::const_iterator it =
      restricted_plugins_.find(plugin->path);
  if (it != restricted_plugins_.end()) {
    if (it->second.first != plugin_prefs)
      return false;
    const GURL& origin = it->second.second;
    if (!origin.is_empty() &&
        (policy_url.scheme() != origin.scheme() ||
         policy_url.host() != origin.host() ||
         policy_url.port() != origin.port())) {
      return false;
    }
  }

  return true;
}
","bool ChromePluginServiceFilter::IsPluginEnabled(
     int render_process_id,
     int render_view_id,
     const void* context,
    const GURL& url,
    const GURL& policy_url,
    webkit::WebPluginInfo* plugin) {
  base::AutoLock auto_lock(lock_);
  const ProcessDetails* details = GetProcess(render_process_id);

  if (details) {
    for (size_t i = 0; i < details->overridden_plugins.size(); ++i) {
      if (details->overridden_plugins[i].render_view_id == render_view_id &&
          (details->overridden_plugins[i].url == url ||
            details->overridden_plugins[i].url.is_empty())) {
 
         bool use = details->overridden_plugins[i].plugin.path == plugin->path;
        if (!use)
          return false;
        *plugin = details->overridden_plugins[i].plugin;
        break;
       }
     }
   }

  ResourceContextMap::iterator prefs_it =
      resource_context_map_.find(context);
  if (prefs_it == resource_context_map_.end())
    return false;

  PluginPrefs* plugin_prefs = prefs_it->second.get();
  if (!plugin_prefs->IsPluginEnabled(*plugin))
    return false;

  RestrictedPluginMap::const_iterator it =
      restricted_plugins_.find(plugin->path);
  if (it != restricted_plugins_.end()) {
    if (it->second.first != plugin_prefs)
      return false;
    const GURL& origin = it->second.second;
    if (!origin.is_empty() &&
        (policy_url.scheme() != origin.scheme() ||
         policy_url.host() != origin.host() ||
         policy_url.port() != origin.port())) {
      return false;
    }
  }

  return true;
}
",C,"bool ChromePluginServiceFilter::IsPluginAvailable(
        if (use)
          *plugin = details->overridden_plugins[i].plugin;
        return use;
","        if (!use)
          return false;
        *plugin = details->overridden_plugins[i].plugin;
        break;
",,"@@ -69,7 +69,7 @@ void ChromePluginServiceFilter::UnrestrictPlugin(
   restricted_plugins_.erase(plugin_path);
 }
 
-bool ChromePluginServiceFilter::IsPluginEnabled(
+bool ChromePluginServiceFilter::IsPluginAvailable(
     int render_process_id,
     int render_view_id,
     const void* context,
@@ -87,10 +87,9 @@ bool ChromePluginServiceFilter::IsPluginEnabled(
            details->overridden_plugins[i].url.is_empty())) {
 
         bool use = details->overridden_plugins[i].plugin.path == plugin->path;
-        if (!use)
-          return false;
-        *plugin = details->overridden_plugins[i].plugin;
-        break;
+        if (use)
+          *plugin = details->overridden_plugins[i].plugin;
+        return use;
       }
     }
   }",Chrome,ac8bd041b81e46e4e4fcd5021aaa5499703952e6,a0461055bead3cb4904fec723e4145b629db4360,1,"bool ChromePluginServiceFilter::IsPluginEnabled(
//fix_flaw_line_below:
//bool ChromePluginServiceFilter::IsPluginAvailable(
     int render_process_id,
     int render_view_id,
     const void* context,
    const GURL& url,
    const GURL& policy_url,
    webkit::WebPluginInfo* plugin) {
  base::AutoLock auto_lock(lock_);
  const ProcessDetails* details = GetProcess(render_process_id);

  // Check whether the plugin is overridden.
  if (details) {
    for (size_t i = 0; i < details->overridden_plugins.size(); ++i) {
      if (details->overridden_plugins[i].render_view_id == render_view_id &&
          (details->overridden_plugins[i].url == url ||
            details->overridden_plugins[i].url.is_empty())) {
 
         bool use = details->overridden_plugins[i].plugin.path == plugin->path;
//flaw_line_below:
        if (!use)
//flaw_line_below:
          return false;
//flaw_line_below:
        *plugin = details->overridden_plugins[i].plugin;
//flaw_line_below:
        break;
//fix_flaw_line_below:
//        if (use)
//fix_flaw_line_below:
//          *plugin = details->overridden_plugins[i].plugin;
//fix_flaw_line_below:
//        return use;
       }
     }
   }

  // Check whether the plugin is disabled.
  ResourceContextMap::iterator prefs_it =
      resource_context_map_.find(context);
  if (prefs_it == resource_context_map_.end())
    return false;

  PluginPrefs* plugin_prefs = prefs_it->second.get();
  if (!plugin_prefs->IsPluginEnabled(*plugin))
    return false;

  // Check whether the plugin is restricted to a URL.
  RestrictedPluginMap::const_iterator it =
      restricted_plugins_.find(plugin->path);
  if (it != restricted_plugins_.end()) {
    if (it->second.first != plugin_prefs)
      return false;
    const GURL& origin = it->second.second;
    if (!origin.is_empty() &&
        (policy_url.scheme() != origin.scheme() ||
         policy_url.host() != origin.host() ||
         policy_url.port() != origin.port())) {
      return false;
    }
  }

  return true;
}
"
7433,185169,,Remote,Not required,Partial,CVE-2013-0910,https://www.cvedetails.com/cve/CVE-2013-0910/,CWE-287,Low,Partial,Partial,,2013-03-05,7.5,"Google Chrome before 25.0.1364.152 does not properly manage the interaction between the browser process and renderer processes during authorization of the loading of a plug-in, which makes it easier for remote attackers to bypass intended access restrictions via vectors involving a blocked plug-in.",2017-09-18,Bypass ,6,https://github.com/chromium/chromium/commit/ac8bd041b81e46e4e4fcd5021aaa5499703952e6,ac8bd041b81e46e4e4fcd5021aaa5499703952e6,"Follow-on fixes and naming changes for https://codereview.chromium.org/12086077/

BUG=172573
Review URL: https://codereview.chromium.org/12177018

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@180600 0039d316-1c4b-4281-b951-d872f2087c98",6,chrome/browser/plugins/plugin_info_message_filter.cc,"{""sha"": ""072269f723daf87a86251f9f4a4fae5574f5be8b"", ""filename"": ""chrome/browser/plugins/chrome_plugin_service_filter.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/chrome_plugin_service_filter.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -69,7 +69,7 @@ void ChromePluginServiceFilter::UnrestrictPlugin(\n   restricted_plugins_.erase(plugin_path);\n }\n \n-bool ChromePluginServiceFilter::IsPluginEnabled(\n+bool ChromePluginServiceFilter::IsPluginAvailable(\n     int render_process_id,\n     int render_view_id,\n     const void* context,\n@@ -87,10 +87,9 @@ bool ChromePluginServiceFilter::IsPluginEnabled(\n            details->overridden_plugins[i].url.is_empty())) {\n \n         bool use = details->overridden_plugins[i].plugin.path == plugin->path;\n-        if (!use)\n-          return false;\n-        *plugin = details->overridden_plugins[i].plugin;\n-        break;\n+        if (use)\n+          *plugin = details->overridden_plugins[i].plugin;\n+        return use;\n       }\n     }\n   }""}<_**next**_>{""sha"": ""6c69b9b6d8c3c7ab81156a117bed86d42240cbda"", ""filename"": ""chrome/browser/plugins/chrome_plugin_service_filter.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/chrome_plugin_service_filter.h?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -58,7 +58,7 @@ class ChromePluginServiceFilter : public content::PluginServiceFilter,\n   void AuthorizeAllPlugins(int render_process_id);\n \n   // PluginServiceFilter implementation:\n-  virtual bool IsPluginEnabled(\n+  virtual bool IsPluginAvailable(\n       int render_process_id,\n       int render_view_id,\n       const void* context,""}<_**next**_>{""sha"": ""6b77bc2b7451e3c7540f599bfba4c093a26df85b"", ""filename"": ""chrome/browser/plugins/plugin_info_message_filter.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/plugin_info_message_filter.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -133,7 +133,7 @@ void PluginInfoMessageFilter::PluginsLoaded(\n     output.group_name = plugin_metadata->name();\n   }\n \n-  context_.GrantAccess(output.status, output.plugin.path);\n+  context_.MaybeGrantAccess(output.status, output.plugin.path);\n \n   ChromeViewHostMsg_GetPluginInfo::WriteReplyParams(reply_msg, output);\n   Send(reply_msg);\n@@ -228,12 +228,12 @@ bool PluginInfoMessageFilter::Context::FindEnabledPlugin(\n       PluginService::GetInstance()->GetFilter();\n   size_t i = 0;\n   for (; i < matching_plugins.size(); ++i) {\n-    if (!filter || filter->IsPluginEnabled(render_process_id_,\n-                                           render_view_id,\n-                                           resource_context_,\n-                                           url,\n-                                           top_origin_url,\n-                                           &matching_plugins[i])) {\n+    if (!filter || filter->IsPluginAvailable(render_process_id_,\n+                                             render_view_id,\n+                                             resource_context_,\n+                                             url,\n+                                             top_origin_url,\n+                                             &matching_plugins[i])) {\n       break;\n     }\n   }\n@@ -293,7 +293,7 @@ void PluginInfoMessageFilter::Context::GetPluginContentSetting(\n       info.secondary_pattern == ContentSettingsPattern::Wildcard();\n }\n \n-void PluginInfoMessageFilter::Context::GrantAccess(\n+void PluginInfoMessageFilter::Context::MaybeGrantAccess(\n     const ChromeViewHostMsg_GetPluginInfo_Status& status,\n     const FilePath& path) const {\n   if (status.value == ChromeViewHostMsg_GetPluginInfo_Status::kAllowed ||""}<_**next**_>{""sha"": ""7e5d8663d14cc7c72009480df996e2e9b33c7baa"", ""filename"": ""chrome/browser/plugins/plugin_info_message_filter.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/plugin_info_message_filter.h?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -63,8 +63,8 @@ class PluginInfoMessageFilter : public content::BrowserMessageFilter {\n                                  const std::string& resource,\n                                  ContentSetting* setting,\n                                  bool* is_default) const;\n-    void GrantAccess(const ChromeViewHostMsg_GetPluginInfo_Status& status,\n-                     const FilePath& path) const;\n+    void MaybeGrantAccess(const ChromeViewHostMsg_GetPluginInfo_Status& status,\n+                          const FilePath& path) const;\n \n    private:\n     int render_process_id_;""}<_**next**_>{""sha"": ""50c0aa82b791c6918f384452ca78e4a489dfe183"", ""filename"": ""chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -27,12 +27,12 @@ class FakePluginServiceFilter : public content::PluginServiceFilter {\n   FakePluginServiceFilter() {}\n   virtual ~FakePluginServiceFilter() {}\n \n-  virtual bool IsPluginEnabled(int render_process_id,\n-                               int render_view_id,\n-                               const void* context,\n-                               const GURL& url,\n-                               const GURL& policy_url,\n-                               webkit::WebPluginInfo* plugin) OVERRIDE;\n+  virtual bool IsPluginAvailable(int render_process_id,\n+                                 int render_view_id,\n+                                 const void* context,\n+                                 const GURL& url,\n+                                 const GURL& policy_url,\n+                                 webkit::WebPluginInfo* plugin) OVERRIDE;\n \n   virtual bool CanLoadPlugin(int render_process_id,\n                              const FilePath& path) OVERRIDE;\n@@ -45,12 +45,12 @@ class FakePluginServiceFilter : public content::PluginServiceFilter {\n   std::map<FilePath, bool> plugin_state_;\n };\n \n-bool FakePluginServiceFilter::IsPluginEnabled(int render_process_id,\n-                                              int render_view_id,\n-                                              const void* context,\n-                                              const GURL& url,\n-                                              const GURL& policy_url,\n-                                              webkit::WebPluginInfo* plugin) {\n+bool FakePluginServiceFilter::IsPluginAvailable(int render_process_id,\n+                                                int render_view_id,\n+                                                const void* context,\n+                                                const GURL& url,\n+                                                const GURL& policy_url,\n+                                                webkit::WebPluginInfo* plugin) {\n   std::map<FilePath, bool>::iterator it = plugin_state_.find(plugin->path);\n   if (it == plugin_state_.end()) {\n     ADD_FAILURE() << \""No plug-in state for '\"" << plugin->path.value() << \""'\"";""}<_**next**_>{""sha"": ""7079828f897928a21ba382fb2fca39406ccd985e"", ""filename"": ""content/browser/plugin_service_impl.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/plugin_service_impl.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -489,12 +489,12 @@ bool PluginServiceImpl::GetPluginInfo(int render_process_id,\n     *is_stale = stale;\n \n   for (size_t i = 0; i < plugins.size(); ++i) {\n-    if (!filter_ || filter_->IsPluginEnabled(render_process_id,\n-                                             render_view_id,\n-                                             context,\n-                                             url,\n-                                             page_url,\n-                                             &plugins[i])) {\n+    if (!filter_ || filter_->IsPluginAvailable(render_process_id,\n+                                               render_view_id,\n+                                               context,\n+                                               url,\n+                                               page_url,\n+                                               &plugins[i])) {\n       *info = plugins[i];\n       if (actual_mime_type)\n         *actual_mime_type = mime_types[i];""}<_**next**_>{""sha"": ""94b929ae26fcd7767d40791168f2b134bbe2ce36"", ""filename"": ""content/browser/plugin_service_impl_browsertest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/plugin_service_impl_browsertest.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -121,7 +121,7 @@ class MockPluginServiceFilter : public content::PluginServiceFilter {\n  public:\n   MockPluginServiceFilter() {}\n \n-  virtual bool IsPluginEnabled(\n+  virtual bool IsPluginAvailable(\n       int render_process_id,\n       int render_view_id,\n       const void* context,""}<_**next**_>{""sha"": ""9bd597b7101c694dfcdbef41adaa96fcb935cd91"", ""filename"": ""content/browser/renderer_host/render_message_filter.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/renderer_host/render_message_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/renderer_host/render_message_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/render_message_filter.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -673,12 +673,12 @@ void RenderMessageFilter::GetPluginsCallback(\n   for (size_t i = 0; i < all_plugins.size(); ++i) {\n     // Copy because the filter can mutate.\n     webkit::WebPluginInfo plugin(all_plugins[i]);\n-    if (!filter || filter->IsPluginEnabled(child_process_id,\n-                                           routing_id,\n-                                           resource_context_,\n-                                           GURL(),\n-                                           GURL(),\n-                                           &plugin)) {\n+    if (!filter || filter->IsPluginAvailable(child_process_id,\n+                                             routing_id,\n+                                             resource_context_,\n+                                             GURL(),\n+                                             GURL(),\n+                                             &plugin)) {\n       plugins.push_back(plugin);\n     }\n   }""}<_**next**_>{""sha"": ""f0b8bbc875736a13047ce51c65d14bd1db2d3e2b"", ""filename"": ""content/public/browser/plugin_service_filter.h"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/public/browser/plugin_service_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/public/browser/plugin_service_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/public/browser/plugin_service_filter.h?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -20,16 +20,16 @@ class PluginServiceFilter {\n  public:\n   virtual ~PluginServiceFilter() {}\n \n-  // Whether |plugin| is enabled. The client can return false to hide the\n+  // Whether |plugin| is available. The client can return false to hide the\n   // plugin, or return true and optionally change the passed in plugin.\n-  virtual bool IsPluginEnabled(int render_process_id,\n-                               int render_view_id,\n-                               const void* context,\n-                               const GURL& url,\n-                               const GURL& policy_url,\n-                               webkit::WebPluginInfo* plugin) = 0;\n-\n-  // Whether the renderer has permission to load enabled |plugin|.\n+  virtual bool IsPluginAvailable(int render_process_id,\n+                                 int render_view_id,\n+                                 const void* context,\n+                                 const GURL& url,\n+                                 const GURL& policy_url,\n+                                 webkit::WebPluginInfo* plugin) = 0;\n+\n+  // Whether the renderer has permission to load available |plugin|.\n   virtual bool CanLoadPlugin(int render_process_id,\n                              const FilePath& path) = 0;\n };""}","bool PluginInfoMessageFilter::Context::FindEnabledPlugin(
    int render_view_id,
    const GURL& url,
    const GURL& top_origin_url,
    const std::string& mime_type,
    ChromeViewHostMsg_GetPluginInfo_Status* status,
    WebPluginInfo* plugin,
    std::string* actual_mime_type,
    scoped_ptr<PluginMetadata>* plugin_metadata) const {
  bool allow_wildcard = true;
  std::vector<WebPluginInfo> matching_plugins;
  std::vector<std::string> mime_types;
  PluginService::GetInstance()->GetPluginInfoArray(
      url, mime_type, allow_wildcard, &matching_plugins, &mime_types);
  if (matching_plugins.empty()) {
    status->value = ChromeViewHostMsg_GetPluginInfo_Status::kNotFound;
    return false;
  }

  content::PluginServiceFilter* filter =
       PluginService::GetInstance()->GetFilter();
   size_t i = 0;
   for (; i < matching_plugins.size(); ++i) {
    if (!filter || filter->IsPluginAvailable(render_process_id_,
                                             render_view_id,
                                             resource_context_,
                                             url,
                                             top_origin_url,
                                             &matching_plugins[i])) {
       break;
     }
   }

  bool enabled = i < matching_plugins.size();
  if (!enabled) {
    i = 0;
    status->value = ChromeViewHostMsg_GetPluginInfo_Status::kDisabled;
  }

  *plugin = matching_plugins[i];
  *actual_mime_type = mime_types[i];
  if (plugin_metadata)
    *plugin_metadata = PluginFinder::GetInstance()->GetPluginMetadata(*plugin);

  return enabled;
}
","bool PluginInfoMessageFilter::Context::FindEnabledPlugin(
    int render_view_id,
    const GURL& url,
    const GURL& top_origin_url,
    const std::string& mime_type,
    ChromeViewHostMsg_GetPluginInfo_Status* status,
    WebPluginInfo* plugin,
    std::string* actual_mime_type,
    scoped_ptr<PluginMetadata>* plugin_metadata) const {
  bool allow_wildcard = true;
  std::vector<WebPluginInfo> matching_plugins;
  std::vector<std::string> mime_types;
  PluginService::GetInstance()->GetPluginInfoArray(
      url, mime_type, allow_wildcard, &matching_plugins, &mime_types);
  if (matching_plugins.empty()) {
    status->value = ChromeViewHostMsg_GetPluginInfo_Status::kNotFound;
    return false;
  }

  content::PluginServiceFilter* filter =
       PluginService::GetInstance()->GetFilter();
   size_t i = 0;
   for (; i < matching_plugins.size(); ++i) {
    if (!filter || filter->IsPluginEnabled(render_process_id_,
                                           render_view_id,
                                           resource_context_,
                                           url,
                                           top_origin_url,
                                           &matching_plugins[i])) {
       break;
     }
   }

  bool enabled = i < matching_plugins.size();
  if (!enabled) {
    i = 0;
    status->value = ChromeViewHostMsg_GetPluginInfo_Status::kDisabled;
  }

  *plugin = matching_plugins[i];
  *actual_mime_type = mime_types[i];
  if (plugin_metadata)
    *plugin_metadata = PluginFinder::GetInstance()->GetPluginMetadata(*plugin);

  return enabled;
}
",C,"    if (!filter || filter->IsPluginAvailable(render_process_id_,
                                             render_view_id,
                                             resource_context_,
                                             url,
                                             top_origin_url,
                                             &matching_plugins[i])) {
","    if (!filter || filter->IsPluginEnabled(render_process_id_,
                                           render_view_id,
                                           resource_context_,
                                           url,
                                           top_origin_url,
                                           &matching_plugins[i])) {
",,"@@ -133,7 +133,7 @@ void PluginInfoMessageFilter::PluginsLoaded(
     output.group_name = plugin_metadata->name();
   }
 
-  context_.GrantAccess(output.status, output.plugin.path);
+  context_.MaybeGrantAccess(output.status, output.plugin.path);
 
   ChromeViewHostMsg_GetPluginInfo::WriteReplyParams(reply_msg, output);
   Send(reply_msg);
@@ -228,12 +228,12 @@ bool PluginInfoMessageFilter::Context::FindEnabledPlugin(
       PluginService::GetInstance()->GetFilter();
   size_t i = 0;
   for (; i < matching_plugins.size(); ++i) {
-    if (!filter || filter->IsPluginEnabled(render_process_id_,
-                                           render_view_id,
-                                           resource_context_,
-                                           url,
-                                           top_origin_url,
-                                           &matching_plugins[i])) {
+    if (!filter || filter->IsPluginAvailable(render_process_id_,
+                                             render_view_id,
+                                             resource_context_,
+                                             url,
+                                             top_origin_url,
+                                             &matching_plugins[i])) {
       break;
     }
   }
@@ -293,7 +293,7 @@ void PluginInfoMessageFilter::Context::GetPluginContentSetting(
       info.secondary_pattern == ContentSettingsPattern::Wildcard();
 }
 
-void PluginInfoMessageFilter::Context::GrantAccess(
+void PluginInfoMessageFilter::Context::MaybeGrantAccess(
     const ChromeViewHostMsg_GetPluginInfo_Status& status,
     const FilePath& path) const {
   if (status.value == ChromeViewHostMsg_GetPluginInfo_Status::kAllowed ||",Chrome,ac8bd041b81e46e4e4fcd5021aaa5499703952e6,a0461055bead3cb4904fec723e4145b629db4360,1,"bool PluginInfoMessageFilter::Context::FindEnabledPlugin(
    int render_view_id,
    const GURL& url,
    const GURL& top_origin_url,
    const std::string& mime_type,
    ChromeViewHostMsg_GetPluginInfo_Status* status,
    WebPluginInfo* plugin,
    std::string* actual_mime_type,
    scoped_ptr<PluginMetadata>* plugin_metadata) const {
  bool allow_wildcard = true;
  std::vector<WebPluginInfo> matching_plugins;
  std::vector<std::string> mime_types;
  PluginService::GetInstance()->GetPluginInfoArray(
      url, mime_type, allow_wildcard, &matching_plugins, &mime_types);
  if (matching_plugins.empty()) {
    status->value = ChromeViewHostMsg_GetPluginInfo_Status::kNotFound;
    return false;
  }

  content::PluginServiceFilter* filter =
       PluginService::GetInstance()->GetFilter();
   size_t i = 0;
   for (; i < matching_plugins.size(); ++i) {
//flaw_line_below:
    if (!filter || filter->IsPluginEnabled(render_process_id_,
//flaw_line_below:
                                           render_view_id,
//flaw_line_below:
                                           resource_context_,
//flaw_line_below:
                                           url,
//flaw_line_below:
                                           top_origin_url,
//flaw_line_below:
                                           &matching_plugins[i])) {
//fix_flaw_line_below:
//    if (!filter || filter->IsPluginAvailable(render_process_id_,
//fix_flaw_line_below:
//                                             render_view_id,
//fix_flaw_line_below:
//                                             resource_context_,
//fix_flaw_line_below:
//                                             url,
//fix_flaw_line_below:
//                                             top_origin_url,
//fix_flaw_line_below:
//                                             &matching_plugins[i])) {
       break;
     }
   }

  // If we broke out of the loop, we have found an enabled plug-in.
  bool enabled = i < matching_plugins.size();
  if (!enabled) {
    // Otherwise, we only found disabled plug-ins, so we take the first one.
    i = 0;
    status->value = ChromeViewHostMsg_GetPluginInfo_Status::kDisabled;
  }

  *plugin = matching_plugins[i];
  *actual_mime_type = mime_types[i];
  if (plugin_metadata)
    *plugin_metadata = PluginFinder::GetInstance()->GetPluginMetadata(*plugin);

  return enabled;
}
"
7434,185170,,Remote,Not required,Partial,CVE-2013-0910,https://www.cvedetails.com/cve/CVE-2013-0910/,CWE-287,Low,Partial,Partial,,2013-03-05,7.5,"Google Chrome before 25.0.1364.152 does not properly manage the interaction between the browser process and renderer processes during authorization of the loading of a plug-in, which makes it easier for remote attackers to bypass intended access restrictions via vectors involving a blocked plug-in.",2017-09-18,Bypass ,1,https://github.com/chromium/chromium/commit/ac8bd041b81e46e4e4fcd5021aaa5499703952e6,ac8bd041b81e46e4e4fcd5021aaa5499703952e6,"Follow-on fixes and naming changes for https://codereview.chromium.org/12086077/

BUG=172573
Review URL: https://codereview.chromium.org/12177018

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@180600 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/browser/plugins/plugin_info_message_filter.cc,"{""sha"": ""072269f723daf87a86251f9f4a4fae5574f5be8b"", ""filename"": ""chrome/browser/plugins/chrome_plugin_service_filter.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/chrome_plugin_service_filter.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -69,7 +69,7 @@ void ChromePluginServiceFilter::UnrestrictPlugin(\n   restricted_plugins_.erase(plugin_path);\n }\n \n-bool ChromePluginServiceFilter::IsPluginEnabled(\n+bool ChromePluginServiceFilter::IsPluginAvailable(\n     int render_process_id,\n     int render_view_id,\n     const void* context,\n@@ -87,10 +87,9 @@ bool ChromePluginServiceFilter::IsPluginEnabled(\n            details->overridden_plugins[i].url.is_empty())) {\n \n         bool use = details->overridden_plugins[i].plugin.path == plugin->path;\n-        if (!use)\n-          return false;\n-        *plugin = details->overridden_plugins[i].plugin;\n-        break;\n+        if (use)\n+          *plugin = details->overridden_plugins[i].plugin;\n+        return use;\n       }\n     }\n   }""}<_**next**_>{""sha"": ""6c69b9b6d8c3c7ab81156a117bed86d42240cbda"", ""filename"": ""chrome/browser/plugins/chrome_plugin_service_filter.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/chrome_plugin_service_filter.h?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -58,7 +58,7 @@ class ChromePluginServiceFilter : public content::PluginServiceFilter,\n   void AuthorizeAllPlugins(int render_process_id);\n \n   // PluginServiceFilter implementation:\n-  virtual bool IsPluginEnabled(\n+  virtual bool IsPluginAvailable(\n       int render_process_id,\n       int render_view_id,\n       const void* context,""}<_**next**_>{""sha"": ""6b77bc2b7451e3c7540f599bfba4c093a26df85b"", ""filename"": ""chrome/browser/plugins/plugin_info_message_filter.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/plugin_info_message_filter.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -133,7 +133,7 @@ void PluginInfoMessageFilter::PluginsLoaded(\n     output.group_name = plugin_metadata->name();\n   }\n \n-  context_.GrantAccess(output.status, output.plugin.path);\n+  context_.MaybeGrantAccess(output.status, output.plugin.path);\n \n   ChromeViewHostMsg_GetPluginInfo::WriteReplyParams(reply_msg, output);\n   Send(reply_msg);\n@@ -228,12 +228,12 @@ bool PluginInfoMessageFilter::Context::FindEnabledPlugin(\n       PluginService::GetInstance()->GetFilter();\n   size_t i = 0;\n   for (; i < matching_plugins.size(); ++i) {\n-    if (!filter || filter->IsPluginEnabled(render_process_id_,\n-                                           render_view_id,\n-                                           resource_context_,\n-                                           url,\n-                                           top_origin_url,\n-                                           &matching_plugins[i])) {\n+    if (!filter || filter->IsPluginAvailable(render_process_id_,\n+                                             render_view_id,\n+                                             resource_context_,\n+                                             url,\n+                                             top_origin_url,\n+                                             &matching_plugins[i])) {\n       break;\n     }\n   }\n@@ -293,7 +293,7 @@ void PluginInfoMessageFilter::Context::GetPluginContentSetting(\n       info.secondary_pattern == ContentSettingsPattern::Wildcard();\n }\n \n-void PluginInfoMessageFilter::Context::GrantAccess(\n+void PluginInfoMessageFilter::Context::MaybeGrantAccess(\n     const ChromeViewHostMsg_GetPluginInfo_Status& status,\n     const FilePath& path) const {\n   if (status.value == ChromeViewHostMsg_GetPluginInfo_Status::kAllowed ||""}<_**next**_>{""sha"": ""7e5d8663d14cc7c72009480df996e2e9b33c7baa"", ""filename"": ""chrome/browser/plugins/plugin_info_message_filter.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/plugin_info_message_filter.h?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -63,8 +63,8 @@ class PluginInfoMessageFilter : public content::BrowserMessageFilter {\n                                  const std::string& resource,\n                                  ContentSetting* setting,\n                                  bool* is_default) const;\n-    void GrantAccess(const ChromeViewHostMsg_GetPluginInfo_Status& status,\n-                     const FilePath& path) const;\n+    void MaybeGrantAccess(const ChromeViewHostMsg_GetPluginInfo_Status& status,\n+                          const FilePath& path) const;\n \n    private:\n     int render_process_id_;""}<_**next**_>{""sha"": ""50c0aa82b791c6918f384452ca78e4a489dfe183"", ""filename"": ""chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -27,12 +27,12 @@ class FakePluginServiceFilter : public content::PluginServiceFilter {\n   FakePluginServiceFilter() {}\n   virtual ~FakePluginServiceFilter() {}\n \n-  virtual bool IsPluginEnabled(int render_process_id,\n-                               int render_view_id,\n-                               const void* context,\n-                               const GURL& url,\n-                               const GURL& policy_url,\n-                               webkit::WebPluginInfo* plugin) OVERRIDE;\n+  virtual bool IsPluginAvailable(int render_process_id,\n+                                 int render_view_id,\n+                                 const void* context,\n+                                 const GURL& url,\n+                                 const GURL& policy_url,\n+                                 webkit::WebPluginInfo* plugin) OVERRIDE;\n \n   virtual bool CanLoadPlugin(int render_process_id,\n                              const FilePath& path) OVERRIDE;\n@@ -45,12 +45,12 @@ class FakePluginServiceFilter : public content::PluginServiceFilter {\n   std::map<FilePath, bool> plugin_state_;\n };\n \n-bool FakePluginServiceFilter::IsPluginEnabled(int render_process_id,\n-                                              int render_view_id,\n-                                              const void* context,\n-                                              const GURL& url,\n-                                              const GURL& policy_url,\n-                                              webkit::WebPluginInfo* plugin) {\n+bool FakePluginServiceFilter::IsPluginAvailable(int render_process_id,\n+                                                int render_view_id,\n+                                                const void* context,\n+                                                const GURL& url,\n+                                                const GURL& policy_url,\n+                                                webkit::WebPluginInfo* plugin) {\n   std::map<FilePath, bool>::iterator it = plugin_state_.find(plugin->path);\n   if (it == plugin_state_.end()) {\n     ADD_FAILURE() << \""No plug-in state for '\"" << plugin->path.value() << \""'\"";""}<_**next**_>{""sha"": ""7079828f897928a21ba382fb2fca39406ccd985e"", ""filename"": ""content/browser/plugin_service_impl.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/plugin_service_impl.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -489,12 +489,12 @@ bool PluginServiceImpl::GetPluginInfo(int render_process_id,\n     *is_stale = stale;\n \n   for (size_t i = 0; i < plugins.size(); ++i) {\n-    if (!filter_ || filter_->IsPluginEnabled(render_process_id,\n-                                             render_view_id,\n-                                             context,\n-                                             url,\n-                                             page_url,\n-                                             &plugins[i])) {\n+    if (!filter_ || filter_->IsPluginAvailable(render_process_id,\n+                                               render_view_id,\n+                                               context,\n+                                               url,\n+                                               page_url,\n+                                               &plugins[i])) {\n       *info = plugins[i];\n       if (actual_mime_type)\n         *actual_mime_type = mime_types[i];""}<_**next**_>{""sha"": ""94b929ae26fcd7767d40791168f2b134bbe2ce36"", ""filename"": ""content/browser/plugin_service_impl_browsertest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/plugin_service_impl_browsertest.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -121,7 +121,7 @@ class MockPluginServiceFilter : public content::PluginServiceFilter {\n  public:\n   MockPluginServiceFilter() {}\n \n-  virtual bool IsPluginEnabled(\n+  virtual bool IsPluginAvailable(\n       int render_process_id,\n       int render_view_id,\n       const void* context,""}<_**next**_>{""sha"": ""9bd597b7101c694dfcdbef41adaa96fcb935cd91"", ""filename"": ""content/browser/renderer_host/render_message_filter.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/renderer_host/render_message_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/renderer_host/render_message_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/render_message_filter.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -673,12 +673,12 @@ void RenderMessageFilter::GetPluginsCallback(\n   for (size_t i = 0; i < all_plugins.size(); ++i) {\n     // Copy because the filter can mutate.\n     webkit::WebPluginInfo plugin(all_plugins[i]);\n-    if (!filter || filter->IsPluginEnabled(child_process_id,\n-                                           routing_id,\n-                                           resource_context_,\n-                                           GURL(),\n-                                           GURL(),\n-                                           &plugin)) {\n+    if (!filter || filter->IsPluginAvailable(child_process_id,\n+                                             routing_id,\n+                                             resource_context_,\n+                                             GURL(),\n+                                             GURL(),\n+                                             &plugin)) {\n       plugins.push_back(plugin);\n     }\n   }""}<_**next**_>{""sha"": ""f0b8bbc875736a13047ce51c65d14bd1db2d3e2b"", ""filename"": ""content/public/browser/plugin_service_filter.h"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/public/browser/plugin_service_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/public/browser/plugin_service_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/public/browser/plugin_service_filter.h?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -20,16 +20,16 @@ class PluginServiceFilter {\n  public:\n   virtual ~PluginServiceFilter() {}\n \n-  // Whether |plugin| is enabled. The client can return false to hide the\n+  // Whether |plugin| is available. The client can return false to hide the\n   // plugin, or return true and optionally change the passed in plugin.\n-  virtual bool IsPluginEnabled(int render_process_id,\n-                               int render_view_id,\n-                               const void* context,\n-                               const GURL& url,\n-                               const GURL& policy_url,\n-                               webkit::WebPluginInfo* plugin) = 0;\n-\n-  // Whether the renderer has permission to load enabled |plugin|.\n+  virtual bool IsPluginAvailable(int render_process_id,\n+                                 int render_view_id,\n+                                 const void* context,\n+                                 const GURL& url,\n+                                 const GURL& policy_url,\n+                                 webkit::WebPluginInfo* plugin) = 0;\n+\n+  // Whether the renderer has permission to load available |plugin|.\n   virtual bool CanLoadPlugin(int render_process_id,\n                              const FilePath& path) = 0;\n };""}","void PluginInfoMessageFilter::Context::GrantAccess(
void PluginInfoMessageFilter::Context::MaybeGrantAccess(
     const ChromeViewHostMsg_GetPluginInfo_Status& status,
     const FilePath& path) const {
   if (status.value == ChromeViewHostMsg_GetPluginInfo_Status::kAllowed ||
      status.value == ChromeViewHostMsg_GetPluginInfo_Status::kClickToPlay) {
    ChromePluginServiceFilter::GetInstance()->AuthorizePlugin(
        render_process_id_, path);
  }
}
","void PluginInfoMessageFilter::Context::GrantAccess(
     const ChromeViewHostMsg_GetPluginInfo_Status& status,
     const FilePath& path) const {
   if (status.value == ChromeViewHostMsg_GetPluginInfo_Status::kAllowed ||
      status.value == ChromeViewHostMsg_GetPluginInfo_Status::kClickToPlay) {
    ChromePluginServiceFilter::GetInstance()->AuthorizePlugin(
        render_process_id_, path);
  }
}
",C,"void PluginInfoMessageFilter::Context::MaybeGrantAccess(
",,,"@@ -133,7 +133,7 @@ void PluginInfoMessageFilter::PluginsLoaded(
     output.group_name = plugin_metadata->name();
   }
 
-  context_.GrantAccess(output.status, output.plugin.path);
+  context_.MaybeGrantAccess(output.status, output.plugin.path);
 
   ChromeViewHostMsg_GetPluginInfo::WriteReplyParams(reply_msg, output);
   Send(reply_msg);
@@ -228,12 +228,12 @@ bool PluginInfoMessageFilter::Context::FindEnabledPlugin(
       PluginService::GetInstance()->GetFilter();
   size_t i = 0;
   for (; i < matching_plugins.size(); ++i) {
-    if (!filter || filter->IsPluginEnabled(render_process_id_,
-                                           render_view_id,
-                                           resource_context_,
-                                           url,
-                                           top_origin_url,
-                                           &matching_plugins[i])) {
+    if (!filter || filter->IsPluginAvailable(render_process_id_,
+                                             render_view_id,
+                                             resource_context_,
+                                             url,
+                                             top_origin_url,
+                                             &matching_plugins[i])) {
       break;
     }
   }
@@ -293,7 +293,7 @@ void PluginInfoMessageFilter::Context::GetPluginContentSetting(
       info.secondary_pattern == ContentSettingsPattern::Wildcard();
 }
 
-void PluginInfoMessageFilter::Context::GrantAccess(
+void PluginInfoMessageFilter::Context::MaybeGrantAccess(
     const ChromeViewHostMsg_GetPluginInfo_Status& status,
     const FilePath& path) const {
   if (status.value == ChromeViewHostMsg_GetPluginInfo_Status::kAllowed ||",Chrome,ac8bd041b81e46e4e4fcd5021aaa5499703952e6,a0461055bead3cb4904fec723e4145b629db4360,1,"void PluginInfoMessageFilter::Context::GrantAccess(
//fix_flaw_line_below:
//void PluginInfoMessageFilter::Context::MaybeGrantAccess(
     const ChromeViewHostMsg_GetPluginInfo_Status& status,
     const FilePath& path) const {
   if (status.value == ChromeViewHostMsg_GetPluginInfo_Status::kAllowed ||
      status.value == ChromeViewHostMsg_GetPluginInfo_Status::kClickToPlay) {
    ChromePluginServiceFilter::GetInstance()->AuthorizePlugin(
        render_process_id_, path);
  }
}
"
7435,185171,,Remote,Not required,Partial,CVE-2013-0910,https://www.cvedetails.com/cve/CVE-2013-0910/,CWE-287,Low,Partial,Partial,,2013-03-05,7.5,"Google Chrome before 25.0.1364.152 does not properly manage the interaction between the browser process and renderer processes during authorization of the loading of a plug-in, which makes it easier for remote attackers to bypass intended access restrictions via vectors involving a blocked plug-in.",2017-09-18,Bypass ,1,https://github.com/chromium/chromium/commit/ac8bd041b81e46e4e4fcd5021aaa5499703952e6,ac8bd041b81e46e4e4fcd5021aaa5499703952e6,"Follow-on fixes and naming changes for https://codereview.chromium.org/12086077/

BUG=172573
Review URL: https://codereview.chromium.org/12177018

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@180600 0039d316-1c4b-4281-b951-d872f2087c98",1,chrome/browser/plugins/plugin_info_message_filter.cc,"{""sha"": ""072269f723daf87a86251f9f4a4fae5574f5be8b"", ""filename"": ""chrome/browser/plugins/chrome_plugin_service_filter.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/chrome_plugin_service_filter.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -69,7 +69,7 @@ void ChromePluginServiceFilter::UnrestrictPlugin(\n   restricted_plugins_.erase(plugin_path);\n }\n \n-bool ChromePluginServiceFilter::IsPluginEnabled(\n+bool ChromePluginServiceFilter::IsPluginAvailable(\n     int render_process_id,\n     int render_view_id,\n     const void* context,\n@@ -87,10 +87,9 @@ bool ChromePluginServiceFilter::IsPluginEnabled(\n            details->overridden_plugins[i].url.is_empty())) {\n \n         bool use = details->overridden_plugins[i].plugin.path == plugin->path;\n-        if (!use)\n-          return false;\n-        *plugin = details->overridden_plugins[i].plugin;\n-        break;\n+        if (use)\n+          *plugin = details->overridden_plugins[i].plugin;\n+        return use;\n       }\n     }\n   }""}<_**next**_>{""sha"": ""6c69b9b6d8c3c7ab81156a117bed86d42240cbda"", ""filename"": ""chrome/browser/plugins/chrome_plugin_service_filter.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/chrome_plugin_service_filter.h?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -58,7 +58,7 @@ class ChromePluginServiceFilter : public content::PluginServiceFilter,\n   void AuthorizeAllPlugins(int render_process_id);\n \n   // PluginServiceFilter implementation:\n-  virtual bool IsPluginEnabled(\n+  virtual bool IsPluginAvailable(\n       int render_process_id,\n       int render_view_id,\n       const void* context,""}<_**next**_>{""sha"": ""6b77bc2b7451e3c7540f599bfba4c093a26df85b"", ""filename"": ""chrome/browser/plugins/plugin_info_message_filter.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/plugin_info_message_filter.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -133,7 +133,7 @@ void PluginInfoMessageFilter::PluginsLoaded(\n     output.group_name = plugin_metadata->name();\n   }\n \n-  context_.GrantAccess(output.status, output.plugin.path);\n+  context_.MaybeGrantAccess(output.status, output.plugin.path);\n \n   ChromeViewHostMsg_GetPluginInfo::WriteReplyParams(reply_msg, output);\n   Send(reply_msg);\n@@ -228,12 +228,12 @@ bool PluginInfoMessageFilter::Context::FindEnabledPlugin(\n       PluginService::GetInstance()->GetFilter();\n   size_t i = 0;\n   for (; i < matching_plugins.size(); ++i) {\n-    if (!filter || filter->IsPluginEnabled(render_process_id_,\n-                                           render_view_id,\n-                                           resource_context_,\n-                                           url,\n-                                           top_origin_url,\n-                                           &matching_plugins[i])) {\n+    if (!filter || filter->IsPluginAvailable(render_process_id_,\n+                                             render_view_id,\n+                                             resource_context_,\n+                                             url,\n+                                             top_origin_url,\n+                                             &matching_plugins[i])) {\n       break;\n     }\n   }\n@@ -293,7 +293,7 @@ void PluginInfoMessageFilter::Context::GetPluginContentSetting(\n       info.secondary_pattern == ContentSettingsPattern::Wildcard();\n }\n \n-void PluginInfoMessageFilter::Context::GrantAccess(\n+void PluginInfoMessageFilter::Context::MaybeGrantAccess(\n     const ChromeViewHostMsg_GetPluginInfo_Status& status,\n     const FilePath& path) const {\n   if (status.value == ChromeViewHostMsg_GetPluginInfo_Status::kAllowed ||""}<_**next**_>{""sha"": ""7e5d8663d14cc7c72009480df996e2e9b33c7baa"", ""filename"": ""chrome/browser/plugins/plugin_info_message_filter.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/plugin_info_message_filter.h?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -63,8 +63,8 @@ class PluginInfoMessageFilter : public content::BrowserMessageFilter {\n                                  const std::string& resource,\n                                  ContentSetting* setting,\n                                  bool* is_default) const;\n-    void GrantAccess(const ChromeViewHostMsg_GetPluginInfo_Status& status,\n-                     const FilePath& path) const;\n+    void MaybeGrantAccess(const ChromeViewHostMsg_GetPluginInfo_Status& status,\n+                          const FilePath& path) const;\n \n    private:\n     int render_process_id_;""}<_**next**_>{""sha"": ""50c0aa82b791c6918f384452ca78e4a489dfe183"", ""filename"": ""chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -27,12 +27,12 @@ class FakePluginServiceFilter : public content::PluginServiceFilter {\n   FakePluginServiceFilter() {}\n   virtual ~FakePluginServiceFilter() {}\n \n-  virtual bool IsPluginEnabled(int render_process_id,\n-                               int render_view_id,\n-                               const void* context,\n-                               const GURL& url,\n-                               const GURL& policy_url,\n-                               webkit::WebPluginInfo* plugin) OVERRIDE;\n+  virtual bool IsPluginAvailable(int render_process_id,\n+                                 int render_view_id,\n+                                 const void* context,\n+                                 const GURL& url,\n+                                 const GURL& policy_url,\n+                                 webkit::WebPluginInfo* plugin) OVERRIDE;\n \n   virtual bool CanLoadPlugin(int render_process_id,\n                              const FilePath& path) OVERRIDE;\n@@ -45,12 +45,12 @@ class FakePluginServiceFilter : public content::PluginServiceFilter {\n   std::map<FilePath, bool> plugin_state_;\n };\n \n-bool FakePluginServiceFilter::IsPluginEnabled(int render_process_id,\n-                                              int render_view_id,\n-                                              const void* context,\n-                                              const GURL& url,\n-                                              const GURL& policy_url,\n-                                              webkit::WebPluginInfo* plugin) {\n+bool FakePluginServiceFilter::IsPluginAvailable(int render_process_id,\n+                                                int render_view_id,\n+                                                const void* context,\n+                                                const GURL& url,\n+                                                const GURL& policy_url,\n+                                                webkit::WebPluginInfo* plugin) {\n   std::map<FilePath, bool>::iterator it = plugin_state_.find(plugin->path);\n   if (it == plugin_state_.end()) {\n     ADD_FAILURE() << \""No plug-in state for '\"" << plugin->path.value() << \""'\"";""}<_**next**_>{""sha"": ""7079828f897928a21ba382fb2fca39406ccd985e"", ""filename"": ""content/browser/plugin_service_impl.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/plugin_service_impl.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -489,12 +489,12 @@ bool PluginServiceImpl::GetPluginInfo(int render_process_id,\n     *is_stale = stale;\n \n   for (size_t i = 0; i < plugins.size(); ++i) {\n-    if (!filter_ || filter_->IsPluginEnabled(render_process_id,\n-                                             render_view_id,\n-                                             context,\n-                                             url,\n-                                             page_url,\n-                                             &plugins[i])) {\n+    if (!filter_ || filter_->IsPluginAvailable(render_process_id,\n+                                               render_view_id,\n+                                               context,\n+                                               url,\n+                                               page_url,\n+                                               &plugins[i])) {\n       *info = plugins[i];\n       if (actual_mime_type)\n         *actual_mime_type = mime_types[i];""}<_**next**_>{""sha"": ""94b929ae26fcd7767d40791168f2b134bbe2ce36"", ""filename"": ""content/browser/plugin_service_impl_browsertest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/plugin_service_impl_browsertest.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -121,7 +121,7 @@ class MockPluginServiceFilter : public content::PluginServiceFilter {\n  public:\n   MockPluginServiceFilter() {}\n \n-  virtual bool IsPluginEnabled(\n+  virtual bool IsPluginAvailable(\n       int render_process_id,\n       int render_view_id,\n       const void* context,""}<_**next**_>{""sha"": ""9bd597b7101c694dfcdbef41adaa96fcb935cd91"", ""filename"": ""content/browser/renderer_host/render_message_filter.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/renderer_host/render_message_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/renderer_host/render_message_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/render_message_filter.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -673,12 +673,12 @@ void RenderMessageFilter::GetPluginsCallback(\n   for (size_t i = 0; i < all_plugins.size(); ++i) {\n     // Copy because the filter can mutate.\n     webkit::WebPluginInfo plugin(all_plugins[i]);\n-    if (!filter || filter->IsPluginEnabled(child_process_id,\n-                                           routing_id,\n-                                           resource_context_,\n-                                           GURL(),\n-                                           GURL(),\n-                                           &plugin)) {\n+    if (!filter || filter->IsPluginAvailable(child_process_id,\n+                                             routing_id,\n+                                             resource_context_,\n+                                             GURL(),\n+                                             GURL(),\n+                                             &plugin)) {\n       plugins.push_back(plugin);\n     }\n   }""}<_**next**_>{""sha"": ""f0b8bbc875736a13047ce51c65d14bd1db2d3e2b"", ""filename"": ""content/public/browser/plugin_service_filter.h"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/public/browser/plugin_service_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/public/browser/plugin_service_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/public/browser/plugin_service_filter.h?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -20,16 +20,16 @@ class PluginServiceFilter {\n  public:\n   virtual ~PluginServiceFilter() {}\n \n-  // Whether |plugin| is enabled. The client can return false to hide the\n+  // Whether |plugin| is available. The client can return false to hide the\n   // plugin, or return true and optionally change the passed in plugin.\n-  virtual bool IsPluginEnabled(int render_process_id,\n-                               int render_view_id,\n-                               const void* context,\n-                               const GURL& url,\n-                               const GURL& policy_url,\n-                               webkit::WebPluginInfo* plugin) = 0;\n-\n-  // Whether the renderer has permission to load enabled |plugin|.\n+  virtual bool IsPluginAvailable(int render_process_id,\n+                                 int render_view_id,\n+                                 const void* context,\n+                                 const GURL& url,\n+                                 const GURL& policy_url,\n+                                 webkit::WebPluginInfo* plugin) = 0;\n+\n+  // Whether the renderer has permission to load available |plugin|.\n   virtual bool CanLoadPlugin(int render_process_id,\n                              const FilePath& path) = 0;\n };""}","void PluginInfoMessageFilter::PluginsLoaded(
    const GetPluginInfo_Params& params,
    IPC::Message* reply_msg,
    const std::vector<WebPluginInfo>& plugins) {
  ChromeViewHostMsg_GetPluginInfo_Output output;
  scoped_ptr<PluginMetadata> plugin_metadata;
  if (context_.FindEnabledPlugin(params.render_view_id, params.url,
                                 params.top_origin_url, params.mime_type,
                                 &output.status, &output.plugin,
                                 &output.actual_mime_type,
                                 &plugin_metadata)) {
    context_.DecidePluginStatus(params, output.plugin, plugin_metadata.get(),
                                &output.status);
  }

  if (plugin_metadata) {
    output.group_identifier = plugin_metadata->identifier();
     output.group_name = plugin_metadata->name();
   }
 
  context_.MaybeGrantAccess(output.status, output.plugin.path);
 
   ChromeViewHostMsg_GetPluginInfo::WriteReplyParams(reply_msg, output);
   Send(reply_msg);
}
","void PluginInfoMessageFilter::PluginsLoaded(
    const GetPluginInfo_Params& params,
    IPC::Message* reply_msg,
    const std::vector<WebPluginInfo>& plugins) {
  ChromeViewHostMsg_GetPluginInfo_Output output;
  scoped_ptr<PluginMetadata> plugin_metadata;
  if (context_.FindEnabledPlugin(params.render_view_id, params.url,
                                 params.top_origin_url, params.mime_type,
                                 &output.status, &output.plugin,
                                 &output.actual_mime_type,
                                 &plugin_metadata)) {
    context_.DecidePluginStatus(params, output.plugin, plugin_metadata.get(),
                                &output.status);
  }

  if (plugin_metadata) {
    output.group_identifier = plugin_metadata->identifier();
     output.group_name = plugin_metadata->name();
   }
 
  context_.GrantAccess(output.status, output.plugin.path);
 
   ChromeViewHostMsg_GetPluginInfo::WriteReplyParams(reply_msg, output);
   Send(reply_msg);
}
",C,"  context_.MaybeGrantAccess(output.status, output.plugin.path);
","  context_.GrantAccess(output.status, output.plugin.path);
",,"@@ -133,7 +133,7 @@ void PluginInfoMessageFilter::PluginsLoaded(
     output.group_name = plugin_metadata->name();
   }
 
-  context_.GrantAccess(output.status, output.plugin.path);
+  context_.MaybeGrantAccess(output.status, output.plugin.path);
 
   ChromeViewHostMsg_GetPluginInfo::WriteReplyParams(reply_msg, output);
   Send(reply_msg);
@@ -228,12 +228,12 @@ bool PluginInfoMessageFilter::Context::FindEnabledPlugin(
       PluginService::GetInstance()->GetFilter();
   size_t i = 0;
   for (; i < matching_plugins.size(); ++i) {
-    if (!filter || filter->IsPluginEnabled(render_process_id_,
-                                           render_view_id,
-                                           resource_context_,
-                                           url,
-                                           top_origin_url,
-                                           &matching_plugins[i])) {
+    if (!filter || filter->IsPluginAvailable(render_process_id_,
+                                             render_view_id,
+                                             resource_context_,
+                                             url,
+                                             top_origin_url,
+                                             &matching_plugins[i])) {
       break;
     }
   }
@@ -293,7 +293,7 @@ void PluginInfoMessageFilter::Context::GetPluginContentSetting(
       info.secondary_pattern == ContentSettingsPattern::Wildcard();
 }
 
-void PluginInfoMessageFilter::Context::GrantAccess(
+void PluginInfoMessageFilter::Context::MaybeGrantAccess(
     const ChromeViewHostMsg_GetPluginInfo_Status& status,
     const FilePath& path) const {
   if (status.value == ChromeViewHostMsg_GetPluginInfo_Status::kAllowed ||",Chrome,ac8bd041b81e46e4e4fcd5021aaa5499703952e6,a0461055bead3cb4904fec723e4145b629db4360,1,"void PluginInfoMessageFilter::PluginsLoaded(
    const GetPluginInfo_Params& params,
    IPC::Message* reply_msg,
    const std::vector<WebPluginInfo>& plugins) {
  ChromeViewHostMsg_GetPluginInfo_Output output;
  // This also fills in |actual_mime_type|.
  scoped_ptr<PluginMetadata> plugin_metadata;
  if (context_.FindEnabledPlugin(params.render_view_id, params.url,
                                 params.top_origin_url, params.mime_type,
                                 &output.status, &output.plugin,
                                 &output.actual_mime_type,
                                 &plugin_metadata)) {
    context_.DecidePluginStatus(params, output.plugin, plugin_metadata.get(),
                                &output.status);
  }

  if (plugin_metadata) {
    output.group_identifier = plugin_metadata->identifier();
     output.group_name = plugin_metadata->name();
   }
 
//flaw_line_below:
  context_.GrantAccess(output.status, output.plugin.path);
//fix_flaw_line_below:
//  context_.MaybeGrantAccess(output.status, output.plugin.path);
 
   ChromeViewHostMsg_GetPluginInfo::WriteReplyParams(reply_msg, output);
   Send(reply_msg);
}
"
7436,185172,,Remote,Not required,Partial,CVE-2013-0910,https://www.cvedetails.com/cve/CVE-2013-0910/,CWE-287,Low,Partial,Partial,,2013-03-05,7.5,"Google Chrome before 25.0.1364.152 does not properly manage the interaction between the browser process and renderer processes during authorization of the loading of a plug-in, which makes it easier for remote attackers to bypass intended access restrictions via vectors involving a blocked plug-in.",2017-09-18,Bypass ,6,https://github.com/chromium/chromium/commit/ac8bd041b81e46e4e4fcd5021aaa5499703952e6,ac8bd041b81e46e4e4fcd5021aaa5499703952e6,"Follow-on fixes and naming changes for https://codereview.chromium.org/12086077/

BUG=172573
Review URL: https://codereview.chromium.org/12177018

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@180600 0039d316-1c4b-4281-b951-d872f2087c98",5,chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc,"{""sha"": ""072269f723daf87a86251f9f4a4fae5574f5be8b"", ""filename"": ""chrome/browser/plugins/chrome_plugin_service_filter.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/chrome_plugin_service_filter.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -69,7 +69,7 @@ void ChromePluginServiceFilter::UnrestrictPlugin(\n   restricted_plugins_.erase(plugin_path);\n }\n \n-bool ChromePluginServiceFilter::IsPluginEnabled(\n+bool ChromePluginServiceFilter::IsPluginAvailable(\n     int render_process_id,\n     int render_view_id,\n     const void* context,\n@@ -87,10 +87,9 @@ bool ChromePluginServiceFilter::IsPluginEnabled(\n            details->overridden_plugins[i].url.is_empty())) {\n \n         bool use = details->overridden_plugins[i].plugin.path == plugin->path;\n-        if (!use)\n-          return false;\n-        *plugin = details->overridden_plugins[i].plugin;\n-        break;\n+        if (use)\n+          *plugin = details->overridden_plugins[i].plugin;\n+        return use;\n       }\n     }\n   }""}<_**next**_>{""sha"": ""6c69b9b6d8c3c7ab81156a117bed86d42240cbda"", ""filename"": ""chrome/browser/plugins/chrome_plugin_service_filter.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/chrome_plugin_service_filter.h?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -58,7 +58,7 @@ class ChromePluginServiceFilter : public content::PluginServiceFilter,\n   void AuthorizeAllPlugins(int render_process_id);\n \n   // PluginServiceFilter implementation:\n-  virtual bool IsPluginEnabled(\n+  virtual bool IsPluginAvailable(\n       int render_process_id,\n       int render_view_id,\n       const void* context,""}<_**next**_>{""sha"": ""6b77bc2b7451e3c7540f599bfba4c093a26df85b"", ""filename"": ""chrome/browser/plugins/plugin_info_message_filter.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/plugin_info_message_filter.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -133,7 +133,7 @@ void PluginInfoMessageFilter::PluginsLoaded(\n     output.group_name = plugin_metadata->name();\n   }\n \n-  context_.GrantAccess(output.status, output.plugin.path);\n+  context_.MaybeGrantAccess(output.status, output.plugin.path);\n \n   ChromeViewHostMsg_GetPluginInfo::WriteReplyParams(reply_msg, output);\n   Send(reply_msg);\n@@ -228,12 +228,12 @@ bool PluginInfoMessageFilter::Context::FindEnabledPlugin(\n       PluginService::GetInstance()->GetFilter();\n   size_t i = 0;\n   for (; i < matching_plugins.size(); ++i) {\n-    if (!filter || filter->IsPluginEnabled(render_process_id_,\n-                                           render_view_id,\n-                                           resource_context_,\n-                                           url,\n-                                           top_origin_url,\n-                                           &matching_plugins[i])) {\n+    if (!filter || filter->IsPluginAvailable(render_process_id_,\n+                                             render_view_id,\n+                                             resource_context_,\n+                                             url,\n+                                             top_origin_url,\n+                                             &matching_plugins[i])) {\n       break;\n     }\n   }\n@@ -293,7 +293,7 @@ void PluginInfoMessageFilter::Context::GetPluginContentSetting(\n       info.secondary_pattern == ContentSettingsPattern::Wildcard();\n }\n \n-void PluginInfoMessageFilter::Context::GrantAccess(\n+void PluginInfoMessageFilter::Context::MaybeGrantAccess(\n     const ChromeViewHostMsg_GetPluginInfo_Status& status,\n     const FilePath& path) const {\n   if (status.value == ChromeViewHostMsg_GetPluginInfo_Status::kAllowed ||""}<_**next**_>{""sha"": ""7e5d8663d14cc7c72009480df996e2e9b33c7baa"", ""filename"": ""chrome/browser/plugins/plugin_info_message_filter.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/plugin_info_message_filter.h?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -63,8 +63,8 @@ class PluginInfoMessageFilter : public content::BrowserMessageFilter {\n                                  const std::string& resource,\n                                  ContentSetting* setting,\n                                  bool* is_default) const;\n-    void GrantAccess(const ChromeViewHostMsg_GetPluginInfo_Status& status,\n-                     const FilePath& path) const;\n+    void MaybeGrantAccess(const ChromeViewHostMsg_GetPluginInfo_Status& status,\n+                          const FilePath& path) const;\n \n    private:\n     int render_process_id_;""}<_**next**_>{""sha"": ""50c0aa82b791c6918f384452ca78e4a489dfe183"", ""filename"": ""chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -27,12 +27,12 @@ class FakePluginServiceFilter : public content::PluginServiceFilter {\n   FakePluginServiceFilter() {}\n   virtual ~FakePluginServiceFilter() {}\n \n-  virtual bool IsPluginEnabled(int render_process_id,\n-                               int render_view_id,\n-                               const void* context,\n-                               const GURL& url,\n-                               const GURL& policy_url,\n-                               webkit::WebPluginInfo* plugin) OVERRIDE;\n+  virtual bool IsPluginAvailable(int render_process_id,\n+                                 int render_view_id,\n+                                 const void* context,\n+                                 const GURL& url,\n+                                 const GURL& policy_url,\n+                                 webkit::WebPluginInfo* plugin) OVERRIDE;\n \n   virtual bool CanLoadPlugin(int render_process_id,\n                              const FilePath& path) OVERRIDE;\n@@ -45,12 +45,12 @@ class FakePluginServiceFilter : public content::PluginServiceFilter {\n   std::map<FilePath, bool> plugin_state_;\n };\n \n-bool FakePluginServiceFilter::IsPluginEnabled(int render_process_id,\n-                                              int render_view_id,\n-                                              const void* context,\n-                                              const GURL& url,\n-                                              const GURL& policy_url,\n-                                              webkit::WebPluginInfo* plugin) {\n+bool FakePluginServiceFilter::IsPluginAvailable(int render_process_id,\n+                                                int render_view_id,\n+                                                const void* context,\n+                                                const GURL& url,\n+                                                const GURL& policy_url,\n+                                                webkit::WebPluginInfo* plugin) {\n   std::map<FilePath, bool>::iterator it = plugin_state_.find(plugin->path);\n   if (it == plugin_state_.end()) {\n     ADD_FAILURE() << \""No plug-in state for '\"" << plugin->path.value() << \""'\"";""}<_**next**_>{""sha"": ""7079828f897928a21ba382fb2fca39406ccd985e"", ""filename"": ""content/browser/plugin_service_impl.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/plugin_service_impl.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -489,12 +489,12 @@ bool PluginServiceImpl::GetPluginInfo(int render_process_id,\n     *is_stale = stale;\n \n   for (size_t i = 0; i < plugins.size(); ++i) {\n-    if (!filter_ || filter_->IsPluginEnabled(render_process_id,\n-                                             render_view_id,\n-                                             context,\n-                                             url,\n-                                             page_url,\n-                                             &plugins[i])) {\n+    if (!filter_ || filter_->IsPluginAvailable(render_process_id,\n+                                               render_view_id,\n+                                               context,\n+                                               url,\n+                                               page_url,\n+                                               &plugins[i])) {\n       *info = plugins[i];\n       if (actual_mime_type)\n         *actual_mime_type = mime_types[i];""}<_**next**_>{""sha"": ""94b929ae26fcd7767d40791168f2b134bbe2ce36"", ""filename"": ""content/browser/plugin_service_impl_browsertest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/plugin_service_impl_browsertest.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -121,7 +121,7 @@ class MockPluginServiceFilter : public content::PluginServiceFilter {\n  public:\n   MockPluginServiceFilter() {}\n \n-  virtual bool IsPluginEnabled(\n+  virtual bool IsPluginAvailable(\n       int render_process_id,\n       int render_view_id,\n       const void* context,""}<_**next**_>{""sha"": ""9bd597b7101c694dfcdbef41adaa96fcb935cd91"", ""filename"": ""content/browser/renderer_host/render_message_filter.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/renderer_host/render_message_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/renderer_host/render_message_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/render_message_filter.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -673,12 +673,12 @@ void RenderMessageFilter::GetPluginsCallback(\n   for (size_t i = 0; i < all_plugins.size(); ++i) {\n     // Copy because the filter can mutate.\n     webkit::WebPluginInfo plugin(all_plugins[i]);\n-    if (!filter || filter->IsPluginEnabled(child_process_id,\n-                                           routing_id,\n-                                           resource_context_,\n-                                           GURL(),\n-                                           GURL(),\n-                                           &plugin)) {\n+    if (!filter || filter->IsPluginAvailable(child_process_id,\n+                                             routing_id,\n+                                             resource_context_,\n+                                             GURL(),\n+                                             GURL(),\n+                                             &plugin)) {\n       plugins.push_back(plugin);\n     }\n   }""}<_**next**_>{""sha"": ""f0b8bbc875736a13047ce51c65d14bd1db2d3e2b"", ""filename"": ""content/public/browser/plugin_service_filter.h"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/public/browser/plugin_service_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/public/browser/plugin_service_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/public/browser/plugin_service_filter.h?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -20,16 +20,16 @@ class PluginServiceFilter {\n  public:\n   virtual ~PluginServiceFilter() {}\n \n-  // Whether |plugin| is enabled. The client can return false to hide the\n+  // Whether |plugin| is available. The client can return false to hide the\n   // plugin, or return true and optionally change the passed in plugin.\n-  virtual bool IsPluginEnabled(int render_process_id,\n-                               int render_view_id,\n-                               const void* context,\n-                               const GURL& url,\n-                               const GURL& policy_url,\n-                               webkit::WebPluginInfo* plugin) = 0;\n-\n-  // Whether the renderer has permission to load enabled |plugin|.\n+  virtual bool IsPluginAvailable(int render_process_id,\n+                                 int render_view_id,\n+                                 const void* context,\n+                                 const GURL& url,\n+                                 const GURL& policy_url,\n+                                 webkit::WebPluginInfo* plugin) = 0;\n+\n+  // Whether the renderer has permission to load available |plugin|.\n   virtual bool CanLoadPlugin(int render_process_id,\n                              const FilePath& path) = 0;\n };""}","bool FakePluginServiceFilter::IsPluginEnabled(int render_process_id,
bool FakePluginServiceFilter::IsPluginAvailable(int render_process_id,
                                                int render_view_id,
                                                const void* context,
                                                const GURL& url,
                                                const GURL& policy_url,
                                                webkit::WebPluginInfo* plugin) {
   std::map<FilePath, bool>::iterator it = plugin_state_.find(plugin->path);
   if (it == plugin_state_.end()) {
     ADD_FAILURE() << ""No plug-in state for '"" << plugin->path.value() << ""'"";
    return false;
  }
  return it->second;
}
","bool FakePluginServiceFilter::IsPluginEnabled(int render_process_id,
                                              int render_view_id,
                                              const void* context,
                                              const GURL& url,
                                              const GURL& policy_url,
                                              webkit::WebPluginInfo* plugin) {
   std::map<FilePath, bool>::iterator it = plugin_state_.find(plugin->path);
   if (it == plugin_state_.end()) {
     ADD_FAILURE() << ""No plug-in state for '"" << plugin->path.value() << ""'"";
    return false;
  }
  return it->second;
}
",C,"bool FakePluginServiceFilter::IsPluginAvailable(int render_process_id,
                                                int render_view_id,
                                                const void* context,
                                                const GURL& url,
                                                const GURL& policy_url,
                                                webkit::WebPluginInfo* plugin) {
","                                              int render_view_id,
                                              const void* context,
                                              const GURL& url,
                                              const GURL& policy_url,
                                              webkit::WebPluginInfo* plugin) {
",,"@@ -27,12 +27,12 @@ class FakePluginServiceFilter : public content::PluginServiceFilter {
   FakePluginServiceFilter() {}
   virtual ~FakePluginServiceFilter() {}
 
-  virtual bool IsPluginEnabled(int render_process_id,
-                               int render_view_id,
-                               const void* context,
-                               const GURL& url,
-                               const GURL& policy_url,
-                               webkit::WebPluginInfo* plugin) OVERRIDE;
+  virtual bool IsPluginAvailable(int render_process_id,
+                                 int render_view_id,
+                                 const void* context,
+                                 const GURL& url,
+                                 const GURL& policy_url,
+                                 webkit::WebPluginInfo* plugin) OVERRIDE;
 
   virtual bool CanLoadPlugin(int render_process_id,
                              const FilePath& path) OVERRIDE;
@@ -45,12 +45,12 @@ class FakePluginServiceFilter : public content::PluginServiceFilter {
   std::map<FilePath, bool> plugin_state_;
 };
 
-bool FakePluginServiceFilter::IsPluginEnabled(int render_process_id,
-                                              int render_view_id,
-                                              const void* context,
-                                              const GURL& url,
-                                              const GURL& policy_url,
-                                              webkit::WebPluginInfo* plugin) {
+bool FakePluginServiceFilter::IsPluginAvailable(int render_process_id,
+                                                int render_view_id,
+                                                const void* context,
+                                                const GURL& url,
+                                                const GURL& policy_url,
+                                                webkit::WebPluginInfo* plugin) {
   std::map<FilePath, bool>::iterator it = plugin_state_.find(plugin->path);
   if (it == plugin_state_.end()) {
     ADD_FAILURE() << ""No plug-in state for '"" << plugin->path.value() << ""'"";",Chrome,ac8bd041b81e46e4e4fcd5021aaa5499703952e6,a0461055bead3cb4904fec723e4145b629db4360,1,"bool FakePluginServiceFilter::IsPluginEnabled(int render_process_id,
//flaw_line_below:
                                              int render_view_id,
//flaw_line_below:
                                              const void* context,
//flaw_line_below:
                                              const GURL& url,
//flaw_line_below:
                                              const GURL& policy_url,
//flaw_line_below:
                                              webkit::WebPluginInfo* plugin) {
//fix_flaw_line_below:
//bool FakePluginServiceFilter::IsPluginAvailable(int render_process_id,
//fix_flaw_line_below:
//                                                int render_view_id,
//fix_flaw_line_below:
//                                                const void* context,
//fix_flaw_line_below:
//                                                const GURL& url,
//fix_flaw_line_below:
//                                                const GURL& policy_url,
//fix_flaw_line_below:
//                                                webkit::WebPluginInfo* plugin) {
   std::map<FilePath, bool>::iterator it = plugin_state_.find(plugin->path);
   if (it == plugin_state_.end()) {
     ADD_FAILURE() << ""No plug-in state for '"" << plugin->path.value() << ""'"";
    return false;
  }
  return it->second;
}
"
7437,185173,,Remote,Not required,Partial,CVE-2013-0910,https://www.cvedetails.com/cve/CVE-2013-0910/,CWE-287,Low,Partial,Partial,,2013-03-05,7.5,"Google Chrome before 25.0.1364.152 does not properly manage the interaction between the browser process and renderer processes during authorization of the loading of a plug-in, which makes it easier for remote attackers to bypass intended access restrictions via vectors involving a blocked plug-in.",2017-09-18,Bypass ,6,https://github.com/chromium/chromium/commit/ac8bd041b81e46e4e4fcd5021aaa5499703952e6,ac8bd041b81e46e4e4fcd5021aaa5499703952e6,"Follow-on fixes and naming changes for https://codereview.chromium.org/12086077/

BUG=172573
Review URL: https://codereview.chromium.org/12177018

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@180600 0039d316-1c4b-4281-b951-d872f2087c98",6,content/browser/plugin_service_impl.cc,"{""sha"": ""072269f723daf87a86251f9f4a4fae5574f5be8b"", ""filename"": ""chrome/browser/plugins/chrome_plugin_service_filter.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/chrome_plugin_service_filter.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -69,7 +69,7 @@ void ChromePluginServiceFilter::UnrestrictPlugin(\n   restricted_plugins_.erase(plugin_path);\n }\n \n-bool ChromePluginServiceFilter::IsPluginEnabled(\n+bool ChromePluginServiceFilter::IsPluginAvailable(\n     int render_process_id,\n     int render_view_id,\n     const void* context,\n@@ -87,10 +87,9 @@ bool ChromePluginServiceFilter::IsPluginEnabled(\n            details->overridden_plugins[i].url.is_empty())) {\n \n         bool use = details->overridden_plugins[i].plugin.path == plugin->path;\n-        if (!use)\n-          return false;\n-        *plugin = details->overridden_plugins[i].plugin;\n-        break;\n+        if (use)\n+          *plugin = details->overridden_plugins[i].plugin;\n+        return use;\n       }\n     }\n   }""}<_**next**_>{""sha"": ""6c69b9b6d8c3c7ab81156a117bed86d42240cbda"", ""filename"": ""chrome/browser/plugins/chrome_plugin_service_filter.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/chrome_plugin_service_filter.h?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -58,7 +58,7 @@ class ChromePluginServiceFilter : public content::PluginServiceFilter,\n   void AuthorizeAllPlugins(int render_process_id);\n \n   // PluginServiceFilter implementation:\n-  virtual bool IsPluginEnabled(\n+  virtual bool IsPluginAvailable(\n       int render_process_id,\n       int render_view_id,\n       const void* context,""}<_**next**_>{""sha"": ""6b77bc2b7451e3c7540f599bfba4c093a26df85b"", ""filename"": ""chrome/browser/plugins/plugin_info_message_filter.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/plugin_info_message_filter.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -133,7 +133,7 @@ void PluginInfoMessageFilter::PluginsLoaded(\n     output.group_name = plugin_metadata->name();\n   }\n \n-  context_.GrantAccess(output.status, output.plugin.path);\n+  context_.MaybeGrantAccess(output.status, output.plugin.path);\n \n   ChromeViewHostMsg_GetPluginInfo::WriteReplyParams(reply_msg, output);\n   Send(reply_msg);\n@@ -228,12 +228,12 @@ bool PluginInfoMessageFilter::Context::FindEnabledPlugin(\n       PluginService::GetInstance()->GetFilter();\n   size_t i = 0;\n   for (; i < matching_plugins.size(); ++i) {\n-    if (!filter || filter->IsPluginEnabled(render_process_id_,\n-                                           render_view_id,\n-                                           resource_context_,\n-                                           url,\n-                                           top_origin_url,\n-                                           &matching_plugins[i])) {\n+    if (!filter || filter->IsPluginAvailable(render_process_id_,\n+                                             render_view_id,\n+                                             resource_context_,\n+                                             url,\n+                                             top_origin_url,\n+                                             &matching_plugins[i])) {\n       break;\n     }\n   }\n@@ -293,7 +293,7 @@ void PluginInfoMessageFilter::Context::GetPluginContentSetting(\n       info.secondary_pattern == ContentSettingsPattern::Wildcard();\n }\n \n-void PluginInfoMessageFilter::Context::GrantAccess(\n+void PluginInfoMessageFilter::Context::MaybeGrantAccess(\n     const ChromeViewHostMsg_GetPluginInfo_Status& status,\n     const FilePath& path) const {\n   if (status.value == ChromeViewHostMsg_GetPluginInfo_Status::kAllowed ||""}<_**next**_>{""sha"": ""7e5d8663d14cc7c72009480df996e2e9b33c7baa"", ""filename"": ""chrome/browser/plugins/plugin_info_message_filter.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/plugin_info_message_filter.h?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -63,8 +63,8 @@ class PluginInfoMessageFilter : public content::BrowserMessageFilter {\n                                  const std::string& resource,\n                                  ContentSetting* setting,\n                                  bool* is_default) const;\n-    void GrantAccess(const ChromeViewHostMsg_GetPluginInfo_Status& status,\n-                     const FilePath& path) const;\n+    void MaybeGrantAccess(const ChromeViewHostMsg_GetPluginInfo_Status& status,\n+                          const FilePath& path) const;\n \n    private:\n     int render_process_id_;""}<_**next**_>{""sha"": ""50c0aa82b791c6918f384452ca78e4a489dfe183"", ""filename"": ""chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -27,12 +27,12 @@ class FakePluginServiceFilter : public content::PluginServiceFilter {\n   FakePluginServiceFilter() {}\n   virtual ~FakePluginServiceFilter() {}\n \n-  virtual bool IsPluginEnabled(int render_process_id,\n-                               int render_view_id,\n-                               const void* context,\n-                               const GURL& url,\n-                               const GURL& policy_url,\n-                               webkit::WebPluginInfo* plugin) OVERRIDE;\n+  virtual bool IsPluginAvailable(int render_process_id,\n+                                 int render_view_id,\n+                                 const void* context,\n+                                 const GURL& url,\n+                                 const GURL& policy_url,\n+                                 webkit::WebPluginInfo* plugin) OVERRIDE;\n \n   virtual bool CanLoadPlugin(int render_process_id,\n                              const FilePath& path) OVERRIDE;\n@@ -45,12 +45,12 @@ class FakePluginServiceFilter : public content::PluginServiceFilter {\n   std::map<FilePath, bool> plugin_state_;\n };\n \n-bool FakePluginServiceFilter::IsPluginEnabled(int render_process_id,\n-                                              int render_view_id,\n-                                              const void* context,\n-                                              const GURL& url,\n-                                              const GURL& policy_url,\n-                                              webkit::WebPluginInfo* plugin) {\n+bool FakePluginServiceFilter::IsPluginAvailable(int render_process_id,\n+                                                int render_view_id,\n+                                                const void* context,\n+                                                const GURL& url,\n+                                                const GURL& policy_url,\n+                                                webkit::WebPluginInfo* plugin) {\n   std::map<FilePath, bool>::iterator it = plugin_state_.find(plugin->path);\n   if (it == plugin_state_.end()) {\n     ADD_FAILURE() << \""No plug-in state for '\"" << plugin->path.value() << \""'\"";""}<_**next**_>{""sha"": ""7079828f897928a21ba382fb2fca39406ccd985e"", ""filename"": ""content/browser/plugin_service_impl.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/plugin_service_impl.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -489,12 +489,12 @@ bool PluginServiceImpl::GetPluginInfo(int render_process_id,\n     *is_stale = stale;\n \n   for (size_t i = 0; i < plugins.size(); ++i) {\n-    if (!filter_ || filter_->IsPluginEnabled(render_process_id,\n-                                             render_view_id,\n-                                             context,\n-                                             url,\n-                                             page_url,\n-                                             &plugins[i])) {\n+    if (!filter_ || filter_->IsPluginAvailable(render_process_id,\n+                                               render_view_id,\n+                                               context,\n+                                               url,\n+                                               page_url,\n+                                               &plugins[i])) {\n       *info = plugins[i];\n       if (actual_mime_type)\n         *actual_mime_type = mime_types[i];""}<_**next**_>{""sha"": ""94b929ae26fcd7767d40791168f2b134bbe2ce36"", ""filename"": ""content/browser/plugin_service_impl_browsertest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/plugin_service_impl_browsertest.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -121,7 +121,7 @@ class MockPluginServiceFilter : public content::PluginServiceFilter {\n  public:\n   MockPluginServiceFilter() {}\n \n-  virtual bool IsPluginEnabled(\n+  virtual bool IsPluginAvailable(\n       int render_process_id,\n       int render_view_id,\n       const void* context,""}<_**next**_>{""sha"": ""9bd597b7101c694dfcdbef41adaa96fcb935cd91"", ""filename"": ""content/browser/renderer_host/render_message_filter.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/renderer_host/render_message_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/renderer_host/render_message_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/render_message_filter.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -673,12 +673,12 @@ void RenderMessageFilter::GetPluginsCallback(\n   for (size_t i = 0; i < all_plugins.size(); ++i) {\n     // Copy because the filter can mutate.\n     webkit::WebPluginInfo plugin(all_plugins[i]);\n-    if (!filter || filter->IsPluginEnabled(child_process_id,\n-                                           routing_id,\n-                                           resource_context_,\n-                                           GURL(),\n-                                           GURL(),\n-                                           &plugin)) {\n+    if (!filter || filter->IsPluginAvailable(child_process_id,\n+                                             routing_id,\n+                                             resource_context_,\n+                                             GURL(),\n+                                             GURL(),\n+                                             &plugin)) {\n       plugins.push_back(plugin);\n     }\n   }""}<_**next**_>{""sha"": ""f0b8bbc875736a13047ce51c65d14bd1db2d3e2b"", ""filename"": ""content/public/browser/plugin_service_filter.h"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/public/browser/plugin_service_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/public/browser/plugin_service_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/public/browser/plugin_service_filter.h?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -20,16 +20,16 @@ class PluginServiceFilter {\n  public:\n   virtual ~PluginServiceFilter() {}\n \n-  // Whether |plugin| is enabled. The client can return false to hide the\n+  // Whether |plugin| is available. The client can return false to hide the\n   // plugin, or return true and optionally change the passed in plugin.\n-  virtual bool IsPluginEnabled(int render_process_id,\n-                               int render_view_id,\n-                               const void* context,\n-                               const GURL& url,\n-                               const GURL& policy_url,\n-                               webkit::WebPluginInfo* plugin) = 0;\n-\n-  // Whether the renderer has permission to load enabled |plugin|.\n+  virtual bool IsPluginAvailable(int render_process_id,\n+                                 int render_view_id,\n+                                 const void* context,\n+                                 const GURL& url,\n+                                 const GURL& policy_url,\n+                                 webkit::WebPluginInfo* plugin) = 0;\n+\n+  // Whether the renderer has permission to load available |plugin|.\n   virtual bool CanLoadPlugin(int render_process_id,\n                              const FilePath& path) = 0;\n };""}","bool PluginServiceImpl::GetPluginInfo(int render_process_id,
                                      int render_view_id,
                                      ResourceContext* context,
                                      const GURL& url,
                                      const GURL& page_url,
                                      const std::string& mime_type,
                                      bool allow_wildcard,
                                      bool* is_stale,
                                      webkit::WebPluginInfo* info,
                                      std::string* actual_mime_type) {
  std::vector<webkit::WebPluginInfo> plugins;
  std::vector<std::string> mime_types;
  bool stale = GetPluginInfoArray(
      url, mime_type, allow_wildcard, &plugins, &mime_types);
  if (is_stale)
     *is_stale = stale;
 
   for (size_t i = 0; i < plugins.size(); ++i) {
    if (!filter_ || filter_->IsPluginAvailable(render_process_id,
                                               render_view_id,
                                               context,
                                               url,
                                               page_url,
                                               &plugins[i])) {
       *info = plugins[i];
       if (actual_mime_type)
         *actual_mime_type = mime_types[i];
      return true;
    }
  }
  return false;
}
","bool PluginServiceImpl::GetPluginInfo(int render_process_id,
                                      int render_view_id,
                                      ResourceContext* context,
                                      const GURL& url,
                                      const GURL& page_url,
                                      const std::string& mime_type,
                                      bool allow_wildcard,
                                      bool* is_stale,
                                      webkit::WebPluginInfo* info,
                                      std::string* actual_mime_type) {
  std::vector<webkit::WebPluginInfo> plugins;
  std::vector<std::string> mime_types;
  bool stale = GetPluginInfoArray(
      url, mime_type, allow_wildcard, &plugins, &mime_types);
  if (is_stale)
     *is_stale = stale;
 
   for (size_t i = 0; i < plugins.size(); ++i) {
    if (!filter_ || filter_->IsPluginEnabled(render_process_id,
                                             render_view_id,
                                             context,
                                             url,
                                             page_url,
                                             &plugins[i])) {
       *info = plugins[i];
       if (actual_mime_type)
         *actual_mime_type = mime_types[i];
      return true;
    }
  }
  return false;
}
",C,"    if (!filter_ || filter_->IsPluginAvailable(render_process_id,
                                               render_view_id,
                                               context,
                                               url,
                                               page_url,
                                               &plugins[i])) {
","    if (!filter_ || filter_->IsPluginEnabled(render_process_id,
                                             render_view_id,
                                             context,
                                             url,
                                             page_url,
                                             &plugins[i])) {
",,"@@ -489,12 +489,12 @@ bool PluginServiceImpl::GetPluginInfo(int render_process_id,
     *is_stale = stale;
 
   for (size_t i = 0; i < plugins.size(); ++i) {
-    if (!filter_ || filter_->IsPluginEnabled(render_process_id,
-                                             render_view_id,
-                                             context,
-                                             url,
-                                             page_url,
-                                             &plugins[i])) {
+    if (!filter_ || filter_->IsPluginAvailable(render_process_id,
+                                               render_view_id,
+                                               context,
+                                               url,
+                                               page_url,
+                                               &plugins[i])) {
       *info = plugins[i];
       if (actual_mime_type)
         *actual_mime_type = mime_types[i];",Chrome,ac8bd041b81e46e4e4fcd5021aaa5499703952e6,a0461055bead3cb4904fec723e4145b629db4360,1,"bool PluginServiceImpl::GetPluginInfo(int render_process_id,
                                      int render_view_id,
                                      ResourceContext* context,
                                      const GURL& url,
                                      const GURL& page_url,
                                      const std::string& mime_type,
                                      bool allow_wildcard,
                                      bool* is_stale,
                                      webkit::WebPluginInfo* info,
                                      std::string* actual_mime_type) {
  std::vector<webkit::WebPluginInfo> plugins;
  std::vector<std::string> mime_types;
  bool stale = GetPluginInfoArray(
      url, mime_type, allow_wildcard, &plugins, &mime_types);
  if (is_stale)
     *is_stale = stale;
 
   for (size_t i = 0; i < plugins.size(); ++i) {
//flaw_line_below:
    if (!filter_ || filter_->IsPluginEnabled(render_process_id,
//flaw_line_below:
                                             render_view_id,
//flaw_line_below:
                                             context,
//flaw_line_below:
                                             url,
//flaw_line_below:
                                             page_url,
//flaw_line_below:
                                             &plugins[i])) {
//fix_flaw_line_below:
//    if (!filter_ || filter_->IsPluginAvailable(render_process_id,
//fix_flaw_line_below:
//                                               render_view_id,
//fix_flaw_line_below:
//                                               context,
//fix_flaw_line_below:
//                                               url,
//fix_flaw_line_below:
//                                               page_url,
//fix_flaw_line_below:
//                                               &plugins[i])) {
       *info = plugins[i];
       if (actual_mime_type)
         *actual_mime_type = mime_types[i];
      return true;
    }
  }
  return false;
}
"
7438,185174,,Remote,Not required,Partial,CVE-2013-0910,https://www.cvedetails.com/cve/CVE-2013-0910/,CWE-287,Low,Partial,Partial,,2013-03-05,7.5,"Google Chrome before 25.0.1364.152 does not properly manage the interaction between the browser process and renderer processes during authorization of the loading of a plug-in, which makes it easier for remote attackers to bypass intended access restrictions via vectors involving a blocked plug-in.",2017-09-18,Bypass ,6,https://github.com/chromium/chromium/commit/ac8bd041b81e46e4e4fcd5021aaa5499703952e6,ac8bd041b81e46e4e4fcd5021aaa5499703952e6,"Follow-on fixes and naming changes for https://codereview.chromium.org/12086077/

BUG=172573
Review URL: https://codereview.chromium.org/12177018

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@180600 0039d316-1c4b-4281-b951-d872f2087c98",6,content/browser/renderer_host/render_message_filter.cc,"{""sha"": ""072269f723daf87a86251f9f4a4fae5574f5be8b"", ""filename"": ""chrome/browser/plugins/chrome_plugin_service_filter.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/chrome_plugin_service_filter.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -69,7 +69,7 @@ void ChromePluginServiceFilter::UnrestrictPlugin(\n   restricted_plugins_.erase(plugin_path);\n }\n \n-bool ChromePluginServiceFilter::IsPluginEnabled(\n+bool ChromePluginServiceFilter::IsPluginAvailable(\n     int render_process_id,\n     int render_view_id,\n     const void* context,\n@@ -87,10 +87,9 @@ bool ChromePluginServiceFilter::IsPluginEnabled(\n            details->overridden_plugins[i].url.is_empty())) {\n \n         bool use = details->overridden_plugins[i].plugin.path == plugin->path;\n-        if (!use)\n-          return false;\n-        *plugin = details->overridden_plugins[i].plugin;\n-        break;\n+        if (use)\n+          *plugin = details->overridden_plugins[i].plugin;\n+        return use;\n       }\n     }\n   }""}<_**next**_>{""sha"": ""6c69b9b6d8c3c7ab81156a117bed86d42240cbda"", ""filename"": ""chrome/browser/plugins/chrome_plugin_service_filter.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/chrome_plugin_service_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/chrome_plugin_service_filter.h?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -58,7 +58,7 @@ class ChromePluginServiceFilter : public content::PluginServiceFilter,\n   void AuthorizeAllPlugins(int render_process_id);\n \n   // PluginServiceFilter implementation:\n-  virtual bool IsPluginEnabled(\n+  virtual bool IsPluginAvailable(\n       int render_process_id,\n       int render_view_id,\n       const void* context,""}<_**next**_>{""sha"": ""6b77bc2b7451e3c7540f599bfba4c093a26df85b"", ""filename"": ""chrome/browser/plugins/plugin_info_message_filter.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/plugin_info_message_filter.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -133,7 +133,7 @@ void PluginInfoMessageFilter::PluginsLoaded(\n     output.group_name = plugin_metadata->name();\n   }\n \n-  context_.GrantAccess(output.status, output.plugin.path);\n+  context_.MaybeGrantAccess(output.status, output.plugin.path);\n \n   ChromeViewHostMsg_GetPluginInfo::WriteReplyParams(reply_msg, output);\n   Send(reply_msg);\n@@ -228,12 +228,12 @@ bool PluginInfoMessageFilter::Context::FindEnabledPlugin(\n       PluginService::GetInstance()->GetFilter();\n   size_t i = 0;\n   for (; i < matching_plugins.size(); ++i) {\n-    if (!filter || filter->IsPluginEnabled(render_process_id_,\n-                                           render_view_id,\n-                                           resource_context_,\n-                                           url,\n-                                           top_origin_url,\n-                                           &matching_plugins[i])) {\n+    if (!filter || filter->IsPluginAvailable(render_process_id_,\n+                                             render_view_id,\n+                                             resource_context_,\n+                                             url,\n+                                             top_origin_url,\n+                                             &matching_plugins[i])) {\n       break;\n     }\n   }\n@@ -293,7 +293,7 @@ void PluginInfoMessageFilter::Context::GetPluginContentSetting(\n       info.secondary_pattern == ContentSettingsPattern::Wildcard();\n }\n \n-void PluginInfoMessageFilter::Context::GrantAccess(\n+void PluginInfoMessageFilter::Context::MaybeGrantAccess(\n     const ChromeViewHostMsg_GetPluginInfo_Status& status,\n     const FilePath& path) const {\n   if (status.value == ChromeViewHostMsg_GetPluginInfo_Status::kAllowed ||""}<_**next**_>{""sha"": ""7e5d8663d14cc7c72009480df996e2e9b33c7baa"", ""filename"": ""chrome/browser/plugins/plugin_info_message_filter.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/plugins/plugin_info_message_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugins/plugin_info_message_filter.h?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -63,8 +63,8 @@ class PluginInfoMessageFilter : public content::BrowserMessageFilter {\n                                  const std::string& resource,\n                                  ContentSetting* setting,\n                                  bool* is_default) const;\n-    void GrantAccess(const ChromeViewHostMsg_GetPluginInfo_Status& status,\n-                     const FilePath& path) const;\n+    void MaybeGrantAccess(const ChromeViewHostMsg_GetPluginInfo_Status& status,\n+                          const FilePath& path) const;\n \n    private:\n     int render_process_id_;""}<_**next**_>{""sha"": ""50c0aa82b791c6918f384452ca78e4a489dfe183"", ""filename"": ""chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/renderer_host/plugin_info_message_filter_unittest.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -27,12 +27,12 @@ class FakePluginServiceFilter : public content::PluginServiceFilter {\n   FakePluginServiceFilter() {}\n   virtual ~FakePluginServiceFilter() {}\n \n-  virtual bool IsPluginEnabled(int render_process_id,\n-                               int render_view_id,\n-                               const void* context,\n-                               const GURL& url,\n-                               const GURL& policy_url,\n-                               webkit::WebPluginInfo* plugin) OVERRIDE;\n+  virtual bool IsPluginAvailable(int render_process_id,\n+                                 int render_view_id,\n+                                 const void* context,\n+                                 const GURL& url,\n+                                 const GURL& policy_url,\n+                                 webkit::WebPluginInfo* plugin) OVERRIDE;\n \n   virtual bool CanLoadPlugin(int render_process_id,\n                              const FilePath& path) OVERRIDE;\n@@ -45,12 +45,12 @@ class FakePluginServiceFilter : public content::PluginServiceFilter {\n   std::map<FilePath, bool> plugin_state_;\n };\n \n-bool FakePluginServiceFilter::IsPluginEnabled(int render_process_id,\n-                                              int render_view_id,\n-                                              const void* context,\n-                                              const GURL& url,\n-                                              const GURL& policy_url,\n-                                              webkit::WebPluginInfo* plugin) {\n+bool FakePluginServiceFilter::IsPluginAvailable(int render_process_id,\n+                                                int render_view_id,\n+                                                const void* context,\n+                                                const GURL& url,\n+                                                const GURL& policy_url,\n+                                                webkit::WebPluginInfo* plugin) {\n   std::map<FilePath, bool>::iterator it = plugin_state_.find(plugin->path);\n   if (it == plugin_state_.end()) {\n     ADD_FAILURE() << \""No plug-in state for '\"" << plugin->path.value() << \""'\"";""}<_**next**_>{""sha"": ""7079828f897928a21ba382fb2fca39406ccd985e"", ""filename"": ""content/browser/plugin_service_impl.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/plugin_service_impl.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -489,12 +489,12 @@ bool PluginServiceImpl::GetPluginInfo(int render_process_id,\n     *is_stale = stale;\n \n   for (size_t i = 0; i < plugins.size(); ++i) {\n-    if (!filter_ || filter_->IsPluginEnabled(render_process_id,\n-                                             render_view_id,\n-                                             context,\n-                                             url,\n-                                             page_url,\n-                                             &plugins[i])) {\n+    if (!filter_ || filter_->IsPluginAvailable(render_process_id,\n+                                               render_view_id,\n+                                               context,\n+                                               url,\n+                                               page_url,\n+                                               &plugins[i])) {\n       *info = plugins[i];\n       if (actual_mime_type)\n         *actual_mime_type = mime_types[i];""}<_**next**_>{""sha"": ""94b929ae26fcd7767d40791168f2b134bbe2ce36"", ""filename"": ""content/browser/plugin_service_impl_browsertest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/plugin_service_impl_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/plugin_service_impl_browsertest.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -121,7 +121,7 @@ class MockPluginServiceFilter : public content::PluginServiceFilter {\n  public:\n   MockPluginServiceFilter() {}\n \n-  virtual bool IsPluginEnabled(\n+  virtual bool IsPluginAvailable(\n       int render_process_id,\n       int render_view_id,\n       const void* context,""}<_**next**_>{""sha"": ""9bd597b7101c694dfcdbef41adaa96fcb935cd91"", ""filename"": ""content/browser/renderer_host/render_message_filter.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/renderer_host/render_message_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/browser/renderer_host/render_message_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/render_message_filter.cc?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -673,12 +673,12 @@ void RenderMessageFilter::GetPluginsCallback(\n   for (size_t i = 0; i < all_plugins.size(); ++i) {\n     // Copy because the filter can mutate.\n     webkit::WebPluginInfo plugin(all_plugins[i]);\n-    if (!filter || filter->IsPluginEnabled(child_process_id,\n-                                           routing_id,\n-                                           resource_context_,\n-                                           GURL(),\n-                                           GURL(),\n-                                           &plugin)) {\n+    if (!filter || filter->IsPluginAvailable(child_process_id,\n+                                             routing_id,\n+                                             resource_context_,\n+                                             GURL(),\n+                                             GURL(),\n+                                             &plugin)) {\n       plugins.push_back(plugin);\n     }\n   }""}<_**next**_>{""sha"": ""f0b8bbc875736a13047ce51c65d14bd1db2d3e2b"", ""filename"": ""content/public/browser/plugin_service_filter.h"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 9, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/public/browser/plugin_service_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ac8bd041b81e46e4e4fcd5021aaa5499703952e6/content/public/browser/plugin_service_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/public/browser/plugin_service_filter.h?ref=ac8bd041b81e46e4e4fcd5021aaa5499703952e6"", ""patch"": ""@@ -20,16 +20,16 @@ class PluginServiceFilter {\n  public:\n   virtual ~PluginServiceFilter() {}\n \n-  // Whether |plugin| is enabled. The client can return false to hide the\n+  // Whether |plugin| is available. The client can return false to hide the\n   // plugin, or return true and optionally change the passed in plugin.\n-  virtual bool IsPluginEnabled(int render_process_id,\n-                               int render_view_id,\n-                               const void* context,\n-                               const GURL& url,\n-                               const GURL& policy_url,\n-                               webkit::WebPluginInfo* plugin) = 0;\n-\n-  // Whether the renderer has permission to load enabled |plugin|.\n+  virtual bool IsPluginAvailable(int render_process_id,\n+                                 int render_view_id,\n+                                 const void* context,\n+                                 const GURL& url,\n+                                 const GURL& policy_url,\n+                                 webkit::WebPluginInfo* plugin) = 0;\n+\n+  // Whether the renderer has permission to load available |plugin|.\n   virtual bool CanLoadPlugin(int render_process_id,\n                              const FilePath& path) = 0;\n };""}","void RenderMessageFilter::GetPluginsCallback(
    IPC::Message* reply_msg,
    const std::vector<webkit::WebPluginInfo>& all_plugins) {
  PluginServiceFilter* filter = PluginServiceImpl::GetInstance()->GetFilter();
  std::vector<webkit::WebPluginInfo> plugins;

  int child_process_id = -1;
  int routing_id = MSG_ROUTING_NONE;
   for (size_t i = 0; i < all_plugins.size(); ++i) {
     webkit::WebPluginInfo plugin(all_plugins[i]);
    if (!filter || filter->IsPluginAvailable(child_process_id,
                                             routing_id,
                                             resource_context_,
                                             GURL(),
                                             GURL(),
                                             &plugin)) {
       plugins.push_back(plugin);
     }
   }

  ViewHostMsg_GetPlugins::WriteReplyParams(reply_msg, plugins);
  Send(reply_msg);
}
","void RenderMessageFilter::GetPluginsCallback(
    IPC::Message* reply_msg,
    const std::vector<webkit::WebPluginInfo>& all_plugins) {
  PluginServiceFilter* filter = PluginServiceImpl::GetInstance()->GetFilter();
  std::vector<webkit::WebPluginInfo> plugins;

  int child_process_id = -1;
  int routing_id = MSG_ROUTING_NONE;
   for (size_t i = 0; i < all_plugins.size(); ++i) {
     webkit::WebPluginInfo plugin(all_plugins[i]);
    if (!filter || filter->IsPluginEnabled(child_process_id,
                                           routing_id,
                                           resource_context_,
                                           GURL(),
                                           GURL(),
                                           &plugin)) {
       plugins.push_back(plugin);
     }
   }

  ViewHostMsg_GetPlugins::WriteReplyParams(reply_msg, plugins);
  Send(reply_msg);
}
",C,"    if (!filter || filter->IsPluginAvailable(child_process_id,
                                             routing_id,
                                             resource_context_,
                                             GURL(),
                                             GURL(),
                                             &plugin)) {
","    if (!filter || filter->IsPluginEnabled(child_process_id,
                                           routing_id,
                                           resource_context_,
                                           GURL(),
                                           GURL(),
                                           &plugin)) {
",,"@@ -673,12 +673,12 @@ void RenderMessageFilter::GetPluginsCallback(
   for (size_t i = 0; i < all_plugins.size(); ++i) {
     // Copy because the filter can mutate.
     webkit::WebPluginInfo plugin(all_plugins[i]);
-    if (!filter || filter->IsPluginEnabled(child_process_id,
-                                           routing_id,
-                                           resource_context_,
-                                           GURL(),
-                                           GURL(),
-                                           &plugin)) {
+    if (!filter || filter->IsPluginAvailable(child_process_id,
+                                             routing_id,
+                                             resource_context_,
+                                             GURL(),
+                                             GURL(),
+                                             &plugin)) {
       plugins.push_back(plugin);
     }
   }",Chrome,ac8bd041b81e46e4e4fcd5021aaa5499703952e6,a0461055bead3cb4904fec723e4145b629db4360,1,"void RenderMessageFilter::GetPluginsCallback(
    IPC::Message* reply_msg,
    const std::vector<webkit::WebPluginInfo>& all_plugins) {
  // Filter the plugin list.
  PluginServiceFilter* filter = PluginServiceImpl::GetInstance()->GetFilter();
  std::vector<webkit::WebPluginInfo> plugins;

  int child_process_id = -1;
  int routing_id = MSG_ROUTING_NONE;
   for (size_t i = 0; i < all_plugins.size(); ++i) {
     // Copy because the filter can mutate.
     webkit::WebPluginInfo plugin(all_plugins[i]);
//flaw_line_below:
    if (!filter || filter->IsPluginEnabled(child_process_id,
//flaw_line_below:
                                           routing_id,
//flaw_line_below:
                                           resource_context_,
//flaw_line_below:
                                           GURL(),
//flaw_line_below:
                                           GURL(),
//flaw_line_below:
                                           &plugin)) {
//fix_flaw_line_below:
//    if (!filter || filter->IsPluginAvailable(child_process_id,
//fix_flaw_line_below:
//                                             routing_id,
//fix_flaw_line_below:
//                                             resource_context_,
//fix_flaw_line_below:
//                                             GURL(),
//fix_flaw_line_below:
//                                             GURL(),
//fix_flaw_line_below:
//                                             &plugin)) {
       plugins.push_back(plugin);
     }
   }

  ViewHostMsg_GetPlugins::WriteReplyParams(reply_msg, plugins);
  Send(reply_msg);
}
"
7812,185548,,Remote,Not required,Partial,CVE-2013-6643,https://www.cvedetails.com/cve/CVE-2013-6643/,CWE-287,Low,Partial,Partial,,2014-01-16,7.5,The OneClickSigninBubbleView::WindowClosing function in browser/ui/views/sync/one_click_signin_bubble_view.cc in Google Chrome before 32.0.1700.76 on Windows and before 32.0.1700.77 on Mac OS X and Linux allows attackers to trigger a sync with an arbitrary Google account by leveraging improper handling of the closing of an untrusted signin confirm dialog.,2018-10-30,,4,https://github.com/chromium/chromium/commit/fc343fd48badc0158dc2bb763e9a8b9342f3cb6f,fc343fd48badc0158dc2bb763e9a8b9342f3cb6f,"Fix a crash when a form control is in a past naems map of a demoted form element.

Note that we wanted to add the protector in FormAssociatedElement::setForm(),
but we couldn't do it because it is called from the constructor.

BUG=326854
TEST=automated.

Review URL: https://codereview.chromium.org/105693013

git-svn-id: svn://svn.chromium.org/blink/trunk@163680 bbb929c8-8fbe-4397-9dbb-9b2b20218538",2,third_party/WebKit/Source/core/html/FormAssociatedElement.cpp,"{""sha"": ""86cf193fa7e59bb94da19f240133200407470bcd"", ""filename"": ""third_party/WebKit/LayoutTests/fast/forms/past-names-crash-expected.txt"", ""status"": ""added"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/fc343fd48badc0158dc2bb763e9a8b9342f3cb6f/third_party/WebKit/LayoutTests/fast/forms/past-names-crash-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fc343fd48badc0158dc2bb763e9a8b9342f3cb6f/third_party/WebKit/LayoutTests/fast/forms/past-names-crash-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/forms/past-names-crash-expected.txt?ref=fc343fd48badc0158dc2bb763e9a8b9342f3cb6f"", ""patch"": ""@@ -0,0 +1,4 @@\n+PASS successfullyParsed is true\n+\n+TEST COMPLETE\n+PASS if not crashed.""}<_**next**_>{""sha"": ""1e9fd1746b81cba3d9d9b646ce5e8a8b2a9bd544"", ""filename"": ""third_party/WebKit/LayoutTests/fast/forms/past-names-crash.html"", ""status"": ""added"", ""additions"": 28, ""deletions"": 0, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/fc343fd48badc0158dc2bb763e9a8b9342f3cb6f/third_party/WebKit/LayoutTests/fast/forms/past-names-crash.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fc343fd48badc0158dc2bb763e9a8b9342f3cb6f/third_party/WebKit/LayoutTests/fast/forms/past-names-crash.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/forms/past-names-crash.html?ref=fc343fd48badc0158dc2bb763e9a8b9342f3cb6f"", ""patch"": ""@@ -0,0 +1,28 @@\n+<!DOCTYPE html>\n+<html>\n+<body>\n+<script src=\""../../resources/js-test.js\""></script>\n+<div id=\""container\"">\n+<table>\n+<form id=\""form1\"">\n+<td>\n+<input name=\""q\""/>\n+<script>\n+jsTestIsAsync = true;\n+var form1 = document.getElementById(\""form1\"");\n+var container = document.getElementById(\""container\"");\n+form1['q'];\n+container.innerHTML = '';\n+setTimeout(function() {\n+    container.insertBefore(form1, null);\n+    gc();\n+    container.innerHTML = 'PASS if not crashed.';\n+    finishJSTest();\n+}, 0);\n+</script>\n+</td>\n+</form>\n+</table>\n+</div>\n+</body>\n+</html>""}<_**next**_>{""sha"": ""f0d92cbe55a030cc3301fb6307301e89e32d0a3e"", ""filename"": ""third_party/WebKit/Source/core/html/FormAssociatedElement.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/fc343fd48badc0158dc2bb763e9a8b9342f3cb6f/third_party/WebKit/Source/core/html/FormAssociatedElement.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fc343fd48badc0158dc2bb763e9a8b9342f3cb6f/third_party/WebKit/Source/core/html/FormAssociatedElement.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/html/FormAssociatedElement.cpp?ref=fc343fd48badc0158dc2bb763e9a8b9342f3cb6f"", ""patch"": ""@@ -122,8 +122,10 @@ HTMLFormElement* FormAssociatedElement::findAssociatedForm(const HTMLElement* el\n void FormAssociatedElement::formRemovedFromTree(const Node* formRoot)\n {\n     ASSERT(m_form);\n-    if (toHTMLElement(this)->highestAncestor() != formRoot)\n-        setForm(0);\n+    if (toHTMLElement(this)->highestAncestor() == formRoot)\n+        return;\n+    RefPtr<HTMLElement> protector(toHTMLElement(this));\n+    setForm(0);\n }\n \n void FormAssociatedElement::setForm(HTMLFormElement* newForm)""}"," void FormAssociatedElement::formRemovedFromTree(const Node* formRoot)
 {
     ASSERT(m_form);
    if (toHTMLElement(this)->highestAncestor() == formRoot)
        return;
    RefPtr<HTMLElement> protector(toHTMLElement(this));
    setForm(0);
 }
"," void FormAssociatedElement::formRemovedFromTree(const Node* formRoot)
 {
     ASSERT(m_form);
    if (toHTMLElement(this)->highestAncestor() != formRoot)
        setForm(0);
 }
",C,"    if (toHTMLElement(this)->highestAncestor() == formRoot)
        return;
    RefPtr<HTMLElement> protector(toHTMLElement(this));
    setForm(0);
","    if (toHTMLElement(this)->highestAncestor() != formRoot)
        setForm(0);
",,"@@ -122,8 +122,10 @@ HTMLFormElement* FormAssociatedElement::findAssociatedForm(const HTMLElement* el
 void FormAssociatedElement::formRemovedFromTree(const Node* formRoot)
 {
     ASSERT(m_form);
-    if (toHTMLElement(this)->highestAncestor() != formRoot)
-        setForm(0);
+    if (toHTMLElement(this)->highestAncestor() == formRoot)
+        return;
+    RefPtr<HTMLElement> protector(toHTMLElement(this));
+    setForm(0);
 }
 
 void FormAssociatedElement::setForm(HTMLFormElement* newForm)",Chrome,fc343fd48badc0158dc2bb763e9a8b9342f3cb6f,9449b7d5c213cfb9fa2352e83dec607a057d6367,1," void FormAssociatedElement::formRemovedFromTree(const Node* formRoot)
 {
     ASSERT(m_form);
//flaw_line_below:
    if (toHTMLElement(this)->highestAncestor() != formRoot)
//flaw_line_below:
        setForm(0);
//fix_flaw_line_below:
//    if (toHTMLElement(this)->highestAncestor() == formRoot)
//fix_flaw_line_below:
//        return;
//fix_flaw_line_below:
//    RefPtr<HTMLElement> protector(toHTMLElement(this));
//fix_flaw_line_below:
//    setForm(0);
 }
"
