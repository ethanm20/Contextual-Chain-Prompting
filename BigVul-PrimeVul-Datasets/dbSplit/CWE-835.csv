,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
32,177768,,Local,Not required,Partial,CVE-2018-20482,https://www.cvedetails.com/cve/CVE-2018-20482/,CWE-835,Medium,,,,2018-12-26,1.9,"GNU Tar through 1.30, when --sparse is used, mishandles file shrinkage during read access, which allows local users to cause a denial of service (infinite read loop in sparse_dump_region in sparse.c) by modifying a file that is supposed to be archived by a different user's process (e.g., a system backup running as root).",2019-10-02,DoS,25,https://git.savannah.gnu.org/cgit/tar.git/commit/?id=c15c42ccd1e2377945fd0414eca1a49294bff454,c15c42ccd1e2377945fd0414eca1a49294bff454,,1,,,"sparse_dump_region (struct tar_sparse_file *file, size_t i)
{
  union block *blk;
  off_t bytes_left = file->stat_info->sparse_map[i].numbytes;

  if (!lseek_or_error (file, file->stat_info->sparse_map[i].offset))
    return false;

  while (bytes_left > 0)
    {
      size_t bufsize = (bytes_left > BLOCKSIZE) ? BLOCKSIZE : bytes_left;
      size_t bytes_read;

      blk = find_next_block ();
      bytes_read = safe_read (file->fd, blk->buffer, bufsize);
      if (bytes_read == SAFE_READ_ERROR)
	{
          read_diag_details (file->stat_info->orig_file_name,
	                     (file->stat_info->sparse_map[i].offset
			      + file->stat_info->sparse_map[i].numbytes
			      - bytes_left),
 			     bufsize);
 	  return false;
 	}
      else if (bytes_read == 0)
	{
	  char buf[UINTMAX_STRSIZE_BOUND];
	  struct stat st;
	  size_t n;
	  if (fstat (file->fd, &st) == 0)
	    n = file->stat_info->stat.st_size - st.st_size;
	  else
	    n = file->stat_info->stat.st_size
	      - (file->stat_info->sparse_map[i].offset
		 + file->stat_info->sparse_map[i].numbytes
		 - bytes_left);
	  
	  WARNOPT (WARN_FILE_SHRANK,
		   (0, 0,
		    ngettext (""%s: File shrank by %s byte; padding with zeros"",
			      ""%s: File shrank by %s bytes; padding with zeros"",
			      n),
		    quotearg_colon (file->stat_info->orig_file_name),
		    STRINGIFY_BIGINT (n, buf)));
	  if (! ignore_failed_read_option)
	    set_exit_status (TAREXIT_DIFFERS);
	  return false;
	}
 
       memset (blk->buffer + bytes_read, 0, BLOCKSIZE - bytes_read);
       bytes_left -= bytes_read;
    {
      size_t count;
      size_t wrbytes = (write_size > BLOCKSIZE) ? BLOCKSIZE : write_size;
      union block *blk = find_next_block ();
      if (!blk)
	{
	  ERROR ((0, 0, _(""Unexpected EOF in archive"")));
	  return false;
	}
      set_next_block_after (blk);
      count = blocking_write (file->fd, blk->buffer, wrbytes);
      write_size -= count;
      file->dumped_size += count;
      mv_size_left (file->stat_info->archive_file_size - file->dumped_size);
      file->offset += count;
      if (count != wrbytes)
	{
	  write_error_details (file->stat_info->orig_file_name,
			       count, wrbytes);
	  return false;
	}
    }
  return true;
}



/* Interface functions */
enum dump_status
sparse_dump_file (int fd, struct tar_stat_info *st)
{
 	  return false;
 	}
       set_next_block_after (blk);
      file->dumped_size += BLOCKSIZE;
       count = blocking_write (file->fd, blk->buffer, wrbytes);
       write_size -= count;
       mv_size_left (file->stat_info->archive_file_size - file->dumped_size);
       file->offset += count;
       if (count != wrbytes)

  rc = sparse_scan_file (&file);
  if (rc && file.optab->dump_region)
    {
      tar_sparse_dump_header (&file);

      if (fd >= 0)
	{
	  size_t i;

	  mv_begin_write (file.stat_info->file_name,
		          file.stat_info->stat.st_size,
		          file.stat_info->archive_file_size - file.dumped_size);
	  for (i = 0; rc && i < file.stat_info->sparse_map_avail; i++)
	    rc = tar_sparse_dump_region (&file, i);
	}
    }

  pad_archive (file.stat_info->archive_file_size - file.dumped_size);
  return (tar_sparse_done (&file) && rc) ? dump_status_ok : dump_status_short;
}
","sparse_dump_region (struct tar_sparse_file *file, size_t i)
{
  union block *blk;
  off_t bytes_left = file->stat_info->sparse_map[i].numbytes;

  if (!lseek_or_error (file, file->stat_info->sparse_map[i].offset))
    return false;

  while (bytes_left > 0)
    {
      size_t bufsize = (bytes_left > BLOCKSIZE) ? BLOCKSIZE : bytes_left;
      size_t bytes_read;

      blk = find_next_block ();
      bytes_read = safe_read (file->fd, blk->buffer, bufsize);
      if (bytes_read == SAFE_READ_ERROR)
	{
          read_diag_details (file->stat_info->orig_file_name,
	                     (file->stat_info->sparse_map[i].offset
			      + file->stat_info->sparse_map[i].numbytes
			      - bytes_left),
 			     bufsize);
 	  return false;
 	}
 
       memset (blk->buffer + bytes_read, 0, BLOCKSIZE - bytes_read);
       bytes_left -= bytes_read;
    {
      size_t count;
      size_t wrbytes = (write_size > BLOCKSIZE) ? BLOCKSIZE : write_size;
      union block *blk = find_next_block ();
      if (!blk)
	{
	  ERROR ((0, 0, _(""Unexpected EOF in archive"")));
	  return false;
	}
      set_next_block_after (blk);
      count = blocking_write (file->fd, blk->buffer, wrbytes);
      write_size -= count;
      file->dumped_size += count;
      mv_size_left (file->stat_info->archive_file_size - file->dumped_size);
      file->offset += count;
      if (count != wrbytes)
	{
	  write_error_details (file->stat_info->orig_file_name,
			       count, wrbytes);
	  return false;
	}
    }
  return true;
}



/* Interface functions */
enum dump_status
sparse_dump_file (int fd, struct tar_stat_info *st)
{
 	  return false;
 	}
       set_next_block_after (blk);
       count = blocking_write (file->fd, blk->buffer, wrbytes);
       write_size -= count;
      file->dumped_size += count;
       mv_size_left (file->stat_info->archive_file_size - file->dumped_size);
       file->offset += count;
       if (count != wrbytes)

  rc = sparse_scan_file (&file);
  if (rc && file.optab->dump_region)
    {
      tar_sparse_dump_header (&file);

      if (fd >= 0)
	{
	  size_t i;

	  mv_begin_write (file.stat_info->file_name,
		          file.stat_info->stat.st_size,
		          file.stat_info->archive_file_size - file.dumped_size);
	  for (i = 0; rc && i < file.stat_info->sparse_map_avail; i++)
	    rc = tar_sparse_dump_region (&file, i);
	}
    }

  pad_archive (file.stat_info->archive_file_size - file.dumped_size);
  return (tar_sparse_done (&file) && rc) ? dump_status_ok : dump_status_short;
}
",C,"      else if (bytes_read == 0)
	{
	  char buf[UINTMAX_STRSIZE_BOUND];
	  struct stat st;
	  size_t n;
	  if (fstat (file->fd, &st) == 0)
	    n = file->stat_info->stat.st_size - st.st_size;
	  else
	    n = file->stat_info->stat.st_size
	      - (file->stat_info->sparse_map[i].offset
		 + file->stat_info->sparse_map[i].numbytes
		 - bytes_left);
	  
	  WARNOPT (WARN_FILE_SHRANK,
		   (0, 0,
		    ngettext (""%s: File shrank by %s byte; padding with zeros"",
			      ""%s: File shrank by %s bytes; padding with zeros"",
			      n),
		    quotearg_colon (file->stat_info->orig_file_name),
		    STRINGIFY_BIGINT (n, buf)));
	  if (! ignore_failed_read_option)
	    set_exit_status (TAREXIT_DIFFERS);
	  return false;
	}
      file->dumped_size += BLOCKSIZE;
","      file->dumped_size += count;
",3c2a2cd94d3b062aa5bf850b82364039ec9c6029,"@@ -1,6 +1,6 @@
 /* Functions for dealing with sparse files
 
-   Copyright 2003-2007, 2010, 2013-2017 Free Software Foundation, Inc.
+   Copyright 2003-2007, 2010, 2013-2018 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
@@ -427,6 +427,30 @@ sparse_dump_region (struct tar_sparse_file *file, size_t i)
 			     bufsize);
 	  return false;
 	}
+      else if (bytes_read == 0)
+	{
+	  char buf[UINTMAX_STRSIZE_BOUND];
+	  struct stat st;
+	  size_t n;
+	  if (fstat (file->fd, &st) == 0)
+	    n = file->stat_info->stat.st_size - st.st_size;
+	  else
+	    n = file->stat_info->stat.st_size
+	      - (file->stat_info->sparse_map[i].offset
+		 + file->stat_info->sparse_map[i].numbytes
+		 - bytes_left);
+	  
+	  WARNOPT (WARN_FILE_SHRANK,
+		   (0, 0,
+		    ngettext (""%s: File shrank by %s byte; padding with zeros"",
+			      ""%s: File shrank by %s bytes; padding with zeros"",
+			      n),
+		    quotearg_colon (file->stat_info->orig_file_name),
+		    STRINGIFY_BIGINT (n, buf)));
+	  if (! ignore_failed_read_option)
+	    set_exit_status (TAREXIT_DIFFERS);
+	  return false;
+	}
 
       memset (blk->buffer + bytes_read, 0, BLOCKSIZE - bytes_read);
       bytes_left -= bytes_read;
@@ -464,9 +488,9 @@ sparse_extract_region (struct tar_sparse_file *file, size_t i)
 	  return false;
 	}
       set_next_block_after (blk);
+      file->dumped_size += BLOCKSIZE;
       count = blocking_write (file->fd, blk->buffer, wrbytes);
       write_size -= count;
-      file->dumped_size += count;
       mv_size_left (file->stat_info->archive_file_size - file->dumped_size);
       file->offset += count;
       if (count != wrbytes)
@@ -598,6 +622,12 @@ check_sparse_region (struct tar_sparse_file *file, off_t beg, off_t end)
 			     rdsize);
 	  return false;
 	}
+      else if (bytes_read == 0)
+	{
+	  report_difference (file->stat_info, _(""Size differs""));
+	  return false;
+	}
+      
       if (!zero_block_p (diff_buffer, bytes_read))
 	{
 	  char begbuf[INT_BUFSIZE_BOUND (off_t)];
@@ -609,6 +639,7 @@ check_sparse_region (struct tar_sparse_file *file, off_t beg, off_t end)
 
       beg += bytes_read;
     }
+
   return true;
 }
 
@@ -635,6 +666,7 @@ check_data_region (struct tar_sparse_file *file, size_t i)
 	  return false;
 	}
       set_next_block_after (blk);
+      file->dumped_size += BLOCKSIZE;      
       bytes_read = safe_read (file->fd, diff_buffer, rdsize);
       if (bytes_read == SAFE_READ_ERROR)
 	{
@@ -645,7 +677,11 @@ check_data_region (struct tar_sparse_file *file, size_t i)
 			     rdsize);
 	  return false;
 	}
-      file->dumped_size += bytes_read;
+      else if (bytes_read == 0)
+	{
+	  report_difference (&current_stat_info, _(""Size differs""));
+	  return false;
+	}
       size_left -= bytes_read;
       mv_size_left (file->stat_info->archive_file_size - file->dumped_size);
       if (memcmp (blk->buffer, diff_buffer, rdsize))
@@ -1213,7 +1249,8 @@ pax_decode_header (struct tar_sparse_file *file)
       union block *blk;
       char *p;
       size_t i;
-
+      off_t start;
+      
 #define COPY_BUF(b,buf,src) do                                     \
  {                                                                 \
    char *endp = b->buffer + BLOCKSIZE;                             \
@@ -1229,7 +1266,6 @@ pax_decode_header (struct tar_sparse_file *file)
        if (src == endp)                                            \
 	 {                                                         \
 	   set_next_block_after (b);                               \
-           file->dumped_size += BLOCKSIZE;                         \
            b = find_next_block ();                                 \
            src = b->buffer;                                        \
 	   endp = b->buffer + BLOCKSIZE;                           \
@@ -1240,8 +1276,8 @@ pax_decode_header (struct tar_sparse_file *file)
    dst[-1] = 0;                                                    \
  } while (0)
 
+      start = current_block_ordinal ();
       set_next_block_after (current_header);
-      file->dumped_size += BLOCKSIZE;
       blk = find_next_block ();
       p = blk->buffer;
       COPY_BUF (blk,nbuf,p);
@@ -1278,6 +1314,8 @@ pax_decode_header (struct tar_sparse_file *file)
 	  sparse_add_map (file->stat_info, &sp);
 	}
       set_next_block_after (blk);
+
+      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);
     }
 
   return true;",savannah,https://git.savannah.gnu.org/cgit/tar.git/tree/src/sparse.c?id=c15c42ccd1e2377945fd0414eca1a49294bff454,https://git.savannah.gnu.org/cgit/tar.git/tree/src/sparse.c?id=3c2a2cd94d3b062aa5bf850b82364039ec9c6029,1,"sparse_dump_region (struct tar_sparse_file *file, size_t i)
{
  union block *blk;
  off_t bytes_left = file->stat_info->sparse_map[i].numbytes;

  if (!lseek_or_error (file, file->stat_info->sparse_map[i].offset))
    return false;

  while (bytes_left > 0)
    {
      size_t bufsize = (bytes_left > BLOCKSIZE) ? BLOCKSIZE : bytes_left;
      size_t bytes_read;

      blk = find_next_block ();
      bytes_read = safe_read (file->fd, blk->buffer, bufsize);
      if (bytes_read == SAFE_READ_ERROR)
	{
          read_diag_details (file->stat_info->orig_file_name,
	                     (file->stat_info->sparse_map[i].offset
			      + file->stat_info->sparse_map[i].numbytes
			      - bytes_left),
 			     bufsize);
 	  return false;
 	}
//fix_flaw_line_below:
//      else if (bytes_read == 0)
//fix_flaw_line_below:
//	{
//fix_flaw_line_below:
//	  char buf[UINTMAX_STRSIZE_BOUND];
//fix_flaw_line_below:
//	  struct stat st;
//fix_flaw_line_below:
//	  size_t n;
//fix_flaw_line_below:
//	  if (fstat (file->fd, &st) == 0)
//fix_flaw_line_below:
//	    n = file->stat_info->stat.st_size - st.st_size;
//fix_flaw_line_below:
//	  else
//fix_flaw_line_below:
//	    n = file->stat_info->stat.st_size
//fix_flaw_line_below:
//	      - (file->stat_info->sparse_map[i].offset
//fix_flaw_line_below:
//		 + file->stat_info->sparse_map[i].numbytes
//fix_flaw_line_below:
//		 - bytes_left);
//fix_flaw_line_below:
//	  
//fix_flaw_line_below:
//	  WARNOPT (WARN_FILE_SHRANK,
//fix_flaw_line_below:
//		   (0, 0,
//fix_flaw_line_below:
//		    ngettext (""%s: File shrank by %s byte; padding with zeros"",
//fix_flaw_line_below:
//			      ""%s: File shrank by %s bytes; padding with zeros"",
//fix_flaw_line_below:
//			      n),
//fix_flaw_line_below:
//		    quotearg_colon (file->stat_info->orig_file_name),
//fix_flaw_line_below:
//		    STRINGIFY_BIGINT (n, buf)));
//fix_flaw_line_below:
//	  if (! ignore_failed_read_option)
//fix_flaw_line_below:
//	    set_exit_status (TAREXIT_DIFFERS);
//fix_flaw_line_below:
//	  return false;
//fix_flaw_line_below:
//	}
 
       memset (blk->buffer + bytes_read, 0, BLOCKSIZE - bytes_read);
       bytes_left -= bytes_read;
    {
      size_t count;
      size_t wrbytes = (write_size > BLOCKSIZE) ? BLOCKSIZE : write_size;
      union block *blk = find_next_block ();
      if (!blk)
	{
	  ERROR ((0, 0, _(""Unexpected EOF in archive"")));
	  return false;
	}
      set_next_block_after (blk);
      count = blocking_write (file->fd, blk->buffer, wrbytes);
      write_size -= count;
      file->dumped_size += count;
      mv_size_left (file->stat_info->archive_file_size - file->dumped_size);
      file->offset += count;
      if (count != wrbytes)
	{
	  write_error_details (file->stat_info->orig_file_name,
			       count, wrbytes);
	  return false;
	}
    }
  return true;
}



/* Interface functions */
enum dump_status
sparse_dump_file (int fd, struct tar_stat_info *st)
{
 	  return false;
 	}
       set_next_block_after (blk);
//fix_flaw_line_below:
//      file->dumped_size += BLOCKSIZE;
       count = blocking_write (file->fd, blk->buffer, wrbytes);
       write_size -= count;
//flaw_line_below:
      file->dumped_size += count;
       mv_size_left (file->stat_info->archive_file_size - file->dumped_size);
       file->offset += count;
       if (count != wrbytes)

  rc = sparse_scan_file (&file);
  if (rc && file.optab->dump_region)
    {
      tar_sparse_dump_header (&file);

      if (fd >= 0)
	{
	  size_t i;

	  mv_begin_write (file.stat_info->file_name,
		          file.stat_info->stat.st_size,
		          file.stat_info->archive_file_size - file.dumped_size);
	  for (i = 0; rc && i < file.stat_info->sparse_map_avail; i++)
	    rc = tar_sparse_dump_region (&file, i);
	}
    }

  pad_archive (file.stat_info->archive_file_size - file.dumped_size);
  return (tar_sparse_done (&file) && rc) ? dump_status_ok : dump_status_short;
}
"
35,177771,,Remote,Not required,Partial,CVE-2018-20103,https://www.cvedetails.com/cve/CVE-2018-20103/,CWE-835,Low,,,,2018-12-12,5.0,"An issue was discovered in dns.c in HAProxy through 1.8.14. In the case of a compressed pointer, a crafted packet can trigger infinite recursion by making the pointer point to itself, or create a long chain of valid pointers resulting in stack exhaustion.",2019-10-02,,5,https://git.haproxy.org/?p=haproxy.git;a=commit;h=58df5aea0a0c926b2238f65908f5e9f83d1cca25,58df5aea0a0c926b2238f65908f5e9f83d1cca25,,2,,," int dns_read_name(unsigned char *buffer, unsigned char *bufend,
                  unsigned char *name, char *destination, int dest_len,
                 int *offset, unsigned int depth)
 {
        int nb_bytes = 0, n = 0;
        int label_len;
	unsigned char *reader = name;
	char *dest = destination;

	while (1) {
		/* Name compression is in use */
		if ((*reader & 0xc0) == 0xc0) {
			/* Must point BEFORE current position */
                        if ((buffer + reader[1]) > reader)
                                goto err;
 
                       if (depth++ > 100)
                               goto err;

                        n = dns_read_name(buffer, bufend, buffer + reader[1],
                                         dest, dest_len - nb_bytes, offset, depth);
                        if (n == 0)
                                goto err;
 
		}

		label_len = *reader;
		if (label_len == 0)
			goto out;

		/* Check if:
		 *  - we won't read outside the buffer
		 *  - there is enough place in the destination
		 */
		if ((reader + label_len >= bufend) || (nb_bytes + label_len >= dest_len))
			goto err;

		/* +1 to take label len + label string */
		label_len++;

		memcpy(dest, reader, label_len);

		dest     += label_len;
		nb_bytes += label_len;
		reader   += label_len;
	}

  out:
	/* offset computation:
	 * parse from <name> until finding either NULL or a pointer ""c0xx""
	 */
	reader  = name;
	*offset = 0;
	while (reader < bufend) {
		if ((reader[0] & 0xc0) == 0xc0) {
			*offset += 2;
			break;
		}
		else if (*reader == 0) {
			*offset += 1;
			break;
		}
		*offset += 1;
		++reader;
	}
	return nb_bytes;

  err:
	return 0;
}
"," int dns_read_name(unsigned char *buffer, unsigned char *bufend,
                  unsigned char *name, char *destination, int dest_len,
                 int *offset)
 {
        int nb_bytes = 0, n = 0;
        int label_len;
	unsigned char *reader = name;
	char *dest = destination;

	while (1) {
		/* Name compression is in use */
		if ((*reader & 0xc0) == 0xc0) {
			/* Must point BEFORE current position */
                        if ((buffer + reader[1]) > reader)
                                goto err;
 
                        n = dns_read_name(buffer, bufend, buffer + reader[1],
                                         dest, dest_len - nb_bytes, offset);
                        if (n == 0)
                                goto err;
 
		}

		label_len = *reader;
		if (label_len == 0)
			goto out;

		/* Check if:
		 *  - we won't read outside the buffer
		 *  - there is enough place in the destination
		 */
		if ((reader + label_len >= bufend) || (nb_bytes + label_len >= dest_len))
			goto err;

		/* +1 to take label len + label string */
		label_len++;

		memcpy(dest, reader, label_len);

		dest     += label_len;
		nb_bytes += label_len;
		reader   += label_len;
	}

  out:
	/* offset computation:
	 * parse from <name> until finding either NULL or a pointer ""c0xx""
	 */
	reader  = name;
	*offset = 0;
	while (reader < bufend) {
		if ((reader[0] & 0xc0) == 0xc0) {
			*offset += 2;
			break;
		}
		else if (*reader == 0) {
			*offset += 1;
			break;
		}
		*offset += 1;
		++reader;
	}
	return nb_bytes;

  err:
	return 0;
}
",C,"                 int *offset, unsigned int depth)
                       if (depth++ > 100)
                               goto err;

                                         dest, dest_len - nb_bytes, offset, depth);
","                 int *offset)
                                         dest, dest_len - nb_bytes, offset);
",adb222004120a3ab242d04469e08e44d8ae9c35b,"@@ -394,7 +394,7 @@ static inline unsigned short dns_response_get_query_id(unsigned char *resp)
  */
 int dns_read_name(unsigned char *buffer, unsigned char *bufend,
                  unsigned char *name, char *destination, int dest_len,
-                 int *offset)
+                 int *offset, unsigned int depth)
 {
        int nb_bytes = 0, n = 0;
        int label_len;
@@ -408,8 +408,11 @@ int dns_read_name(unsigned char *buffer, unsigned char *bufend,
                        if ((buffer + reader[1]) > reader)
                                goto err;
 
+                       if (depth++ > 100)
+                               goto err;
+
                        n = dns_read_name(buffer, bufend, buffer + reader[1],
-                                         dest, dest_len - nb_bytes, offset);
+                                         dest, dest_len - nb_bytes, offset, depth);
                        if (n == 0)
                                goto err;
 
@@ -695,7 +698,7 @@ static int dns_validate_dns_response(unsigned char *resp, unsigned char *bufend,
                 * one query per response and the first one can't be compressed
                 * (using the 0x0c format) */
                offset = 0;
-               len = dns_read_name(resp, bufend, reader, dns_query->name, DNS_MAX_NAME_SIZE, &offset);
+               len = dns_read_name(resp, bufend, reader, dns_query->name, DNS_MAX_NAME_SIZE, &offset, 0);
 
                if (len == 0)
                        return DNS_RESP_INVALID;
@@ -732,7 +735,7 @@ static int dns_validate_dns_response(unsigned char *resp, unsigned char *bufend,
                        return (DNS_RESP_INVALID);
 
                offset = 0;
-               len = dns_read_name(resp, bufend, reader, tmpname, DNS_MAX_NAME_SIZE, &offset);
+               len = dns_read_name(resp, bufend, reader, tmpname, DNS_MAX_NAME_SIZE, &offset, 0);
 
                if (len == 0) {
                        pool_free(dns_answer_item_pool, dns_answer_record);
@@ -829,7 +832,7 @@ static int dns_validate_dns_response(unsigned char *resp, unsigned char *bufend,
                                }
 
                                offset = 0;
-                               len = dns_read_name(resp, bufend, reader, tmpname, DNS_MAX_NAME_SIZE, &offset);
+                               len = dns_read_name(resp, bufend, reader, tmpname, DNS_MAX_NAME_SIZE, &offset, 0);
                                if (len == 0) {
                                        pool_free(dns_answer_item_pool, dns_answer_record);
                                        return DNS_RESP_INVALID;
@@ -859,7 +862,7 @@ static int dns_validate_dns_response(unsigned char *resp, unsigned char *bufend,
                                dns_answer_record->port = read_n16(reader);
                                reader += sizeof(uint16_t);
                                offset = 0;
-                               len = dns_read_name(resp, bufend, reader, tmpname, DNS_MAX_NAME_SIZE, &offset);
+                               len = dns_read_name(resp, bufend, reader, tmpname, DNS_MAX_NAME_SIZE, &offset, 0);
                                if (len == 0) {
                                        pool_free(dns_answer_item_pool, dns_answer_record);
                                        return DNS_RESP_INVALID;",haproxy,https://git.haproxy.org/?p=haproxy.git;a=blob;f=src/dns.c;h=50fc16e09f8dc915a70a7c24075d0ec8496af1d2;hb=50fc16e09f8dc915a70a7c24075d0ec8496af1d2,https://git.haproxy.org/?p=haproxy.git;a=blob;f=src/dns.c;h=2a53c038c377d394371f7f7b535c2a0b236232c4;hb=2a53c038c377d394371f7f7b535c2a0b236232c4,1," int dns_read_name(unsigned char *buffer, unsigned char *bufend,
                  unsigned char *name, char *destination, int dest_len,
//flaw_line_below:
                 int *offset)
//fix_flaw_line_below:
//                 int *offset, unsigned int depth)
 {
        int nb_bytes = 0, n = 0;
        int label_len;
	unsigned char *reader = name;
	char *dest = destination;

	while (1) {
		/* Name compression is in use */
		if ((*reader & 0xc0) == 0xc0) {
			/* Must point BEFORE current position */
                        if ((buffer + reader[1]) > reader)
                                goto err;
 
//fix_flaw_line_below:
//                       if (depth++ > 100)
//fix_flaw_line_below:
//                               goto err;
//fix_flaw_line_below:
//
                        n = dns_read_name(buffer, bufend, buffer + reader[1],
//flaw_line_below:
                                         dest, dest_len - nb_bytes, offset);
//fix_flaw_line_below:
//                                         dest, dest_len - nb_bytes, offset, depth);
                        if (n == 0)
                                goto err;
 
		}

		label_len = *reader;
		if (label_len == 0)
			goto out;

		/* Check if:
		 *  - we won't read outside the buffer
		 *  - there is enough place in the destination
		 */
		if ((reader + label_len >= bufend) || (nb_bytes + label_len >= dest_len))
			goto err;

		/* +1 to take label len + label string */
		label_len++;

		memcpy(dest, reader, label_len);

		dest     += label_len;
		nb_bytes += label_len;
		reader   += label_len;
	}

  out:
	/* offset computation:
	 * parse from <name> until finding either NULL or a pointer ""c0xx""
	 */
	reader  = name;
	*offset = 0;
	while (reader < bufend) {
		if ((reader[0] & 0xc0) == 0xc0) {
			*offset += 2;
			break;
		}
		else if (*reader == 0) {
			*offset += 1;
			break;
		}
		*offset += 1;
		++reader;
	}
	return nb_bytes;

  err:
	return 0;
}
"
158,177894,,Remote,Not required,Partial,CVE-2019-12068,https://www.cvedetails.com/cve/CVE-2019-12068/,CWE-835,Low,,,,2019-09-24,5.0,"In QEMU 1:4.1-1, 1:2.1+dfsg-12+deb8u6, 1:2.8+dfsg-6+deb9u8, 1:3.1+dfsg-8~deb10u1, 1:3.1+dfsg-8+deb10u2, and 1:2.1+dfsg-12+deb8u12 (fixed), when executing script in lsi_execute_script(), the LSI scsi adapter emulator advances 's->dsp' index to read next opcode. This can lead to an infinite loop if the next opcode is empty. Move the existing loop exit after 10k iterations so that it covers no-op opcodes as well.",2019-09-26,Exec Code,15,https://git.qemu.org/?p=qemu.git;a=commit;h=de594e47659029316bbf9391efb79da0a1a08e08,de594e47659029316bbf9391efb79da0a1a08e08,,1,,,"static void lsi_execute_script(LSIState *s)
{
    PCIDevice *pci_dev = PCI_DEVICE(s);
    uint32_t insn;
    uint32_t addr, addr_high;
    int opcode;
    int insn_processed = 0;

    s->istat1 |= LSI_ISTAT1_SRUN;
again:
 
     s->istat1 |= LSI_ISTAT1_SRUN;
 again:
    if (++insn_processed > LSI_MAX_INSN) {
        /* Some windows drivers make the device spin waiting for a memory
           location to change.  If we have been executed a lot of code then
           assume this is the case and force an unexpected device disconnect.
           This is apparently sufficient to beat the drivers into submission.
         */
        if (!(s->sien0 & LSI_SIST0_UDC)) {
            qemu_log_mask(LOG_GUEST_ERROR,
                          ""lsi_scsi: inf. loop with UDC masked"");
        }
        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);
        lsi_disconnect(s);
        trace_lsi_execute_script_stop();
        return;
    }
     insn = read_dword(s, s->dsp);
     if (!insn) {
         /* If we receive an empty opcode increment the DSP by 4 bytes
        s->dbc = insn & 0xffffff;
        s->rbc = s->dbc;
        /* ??? Set ESA.  */
        s->ia = s->dsp - 8;
        if (insn & (1 << 29)) {
            /* Indirect addressing.  */
            addr = read_dword(s, addr);
        } else if (insn & (1 << 28)) {
            uint32_t buf[2];
            int32_t offset;
            /* Table indirect addressing.  */

            /* 32-bit Table indirect */
            offset = sextract32(addr, 0, 24);
            pci_dma_read(pci_dev, s->dsa + offset, buf, 8);
            /* byte count is stored in bits 0:23 only */
            s->dbc = cpu_to_le32(buf[0]) & 0xffffff;
            s->rbc = s->dbc;
            addr = cpu_to_le32(buf[1]);

            /* 40-bit DMA, upper addr bits [39:32] stored in first DWORD of
             * table, bits [31:24] */
            if (lsi_dma_40bit(s))
                addr_high = cpu_to_le32(buf[0]) >> 24;
            else if (lsi_dma_ti64bit(s)) {
                int selector = (cpu_to_le32(buf[0]) >> 24) & 0x1f;
                switch (selector) {
                case 0 ... 0x0f:
                    /* offset index into scratch registers since
                     * TI64 mode can use registers C to R */
                    addr_high = s->scratch[2 + selector];
                    break;
                case 0x10:
                    addr_high = s->mmrs;
                    break;
                case 0x11:
                    addr_high = s->mmws;
                    break;
                case 0x12:
                    addr_high = s->sfs;
                    break;
                case 0x13:
                    addr_high = s->drs;
                    break;
                case 0x14:
                    addr_high = s->sbms;
                    break;
                case 0x15:
                    addr_high = s->dbms;
                    break;
                default:
                    qemu_log_mask(LOG_GUEST_ERROR,
                          ""lsi_scsi: Illegal selector specified (0x%x > 0x15) ""
                          ""for 64-bit DMA block move"", selector);
                    break;
                }
            }
        } else if (lsi_dma_64bit(s)) {
            /* fetch a 3rd dword if 64-bit direct move is enabled and
               only if we're not doing table indirect or indirect addressing */
            s->dbms = read_dword(s, s->dsp);
            s->dsp += 4;
            s->ia = s->dsp - 12;
        }
        if ((s->sstat1 & PHASE_MASK) != ((insn >> 24) & 7)) {
            trace_lsi_execute_script_blockmove_badphase(
                    scsi_phase_name(s->sstat1),
                    scsi_phase_name(insn >> 24));
            lsi_script_scsi_interrupt(s, LSI_SIST0_MA, 0);
            break;
        }
        s->dnad = addr;
        s->dnad64 = addr_high;
        switch (s->sstat1 & 0x7) {
        case PHASE_DO:
            s->waiting = LSI_DMA_SCRIPTS;
            lsi_do_dma(s, 1);
            if (s->waiting)
                s->waiting = LSI_DMA_IN_PROGRESS;
            break;
        case PHASE_DI:
            s->waiting = LSI_DMA_SCRIPTS;
            lsi_do_dma(s, 0);
            if (s->waiting)
                s->waiting = LSI_DMA_IN_PROGRESS;
            break;
        case PHASE_CMD:
            lsi_do_command(s);
            break;
        case PHASE_ST:
            lsi_do_status(s);
            break;
        case PHASE_MO:
            lsi_do_msgout(s);
            break;
        case PHASE_MI:
            lsi_do_msgin(s);
            break;
        default:
            qemu_log_mask(LOG_UNIMP, ""lsi_scsi: Unimplemented phase %s\n"",
                          scsi_phase_name(s->sstat1));
        }
        s->dfifo = s->dbc & 0xff;
        s->ctest5 = (s->ctest5 & 0xfc) | ((s->dbc >> 8) & 3);
        s->sbc = s->dbc;
        s->rbc -= s->dbc;
        s->ua = addr + s->dbc;
        break;

    case 1: /* IO or Read/Write instruction.  */
        opcode = (insn >> 27) & 7;
        if (opcode < 5) {
            uint32_t id;

            if (insn & (1 << 25)) {
                id = read_dword(s, s->dsa + sextract32(insn, 0, 24));
            } else {
                id = insn;
            }
            id = (id >> 16) & 0xf;
            if (insn & (1 << 26)) {
                addr = s->dsp + sextract32(addr, 0, 24);
            }
            s->dnad = addr;
            switch (opcode) {
            case 0: /* Select */
                s->sdid = id;
                if (s->scntl1 & LSI_SCNTL1_CON) {
                    trace_lsi_execute_script_io_alreadyreselected();
                    s->dsp = s->dnad;
                    break;
                }
                s->sstat0 |= LSI_SSTAT0_WOA;
                s->scntl1 &= ~LSI_SCNTL1_IARB;
                if (!scsi_device_find(&s->bus, 0, id, 0)) {
                    lsi_bad_selection(s, id);
                    break;
                }
                trace_lsi_execute_script_io_selected(id,
                                             insn & (1 << 3) ? "" ATN"" : """");
                /* ??? Linux drivers compain when this is set.  Maybe
                   it only applies in low-level mode (unimplemented).
                lsi_script_scsi_interrupt(s, LSI_SIST0_CMP, 0); */
                s->select_tag = id << 8;
                s->scntl1 |= LSI_SCNTL1_CON;
                if (insn & (1 << 3)) {
                    s->socl |= LSI_SOCL_ATN;
                    s->sbcl |= LSI_SBCL_ATN;
                }
                s->sbcl |= LSI_SBCL_BSY;
                lsi_set_phase(s, PHASE_MO);
                s->waiting = LSI_NOWAIT;
                break;
            case 1: /* Disconnect */
                trace_lsi_execute_script_io_disconnect();
                s->scntl1 &= ~LSI_SCNTL1_CON;
                /* FIXME: this is not entirely correct; the target need not ask
                 * for reselection until it has to send data, while here we force a
                 * reselection as soon as the bus is free.  The correct flow would
                 * reselect before lsi_transfer_data and disconnect as soon as
                 * DMA ends.
                 */
                if (!s->current) {
                    lsi_request *p = get_pending_req(s);
                    if (p) {
                        lsi_reselect(s, p);
                    }
                }
                break;
            case 2: /* Wait Reselect */
                if (s->istat0 & LSI_ISTAT0_SIGP) {
                    s->dsp = s->dnad;
                } else if (!lsi_irq_on_rsl(s)) {
                        lsi_wait_reselect(s);
                }
                break;
            case 3: /* Set */
                trace_lsi_execute_script_io_set(
                        insn & (1 << 3) ? "" ATN"" : """",
                        insn & (1 << 6) ? "" ACK"" : """",
                        insn & (1 << 9) ? "" TM"" : """",
                        insn & (1 << 10) ? "" CC"" : """");
                if (insn & (1 << 3)) {
                    s->socl |= LSI_SOCL_ATN;
                    s->sbcl |= LSI_SBCL_ATN;
                    lsi_set_phase(s, PHASE_MO);
                }

                if (insn & (1 << 6)) {
                    s->sbcl |= LSI_SBCL_ACK;
                }

                if (insn & (1 << 9)) {
                    qemu_log_mask(LOG_UNIMP,
                        ""lsi_scsi: Target mode not implemented\n"");
                }
                if (insn & (1 << 10))
                    s->carry = 1;
                break;
            case 4: /* Clear */
                trace_lsi_execute_script_io_clear(
                        insn & (1 << 3) ? "" ATN"" : """",
                        insn & (1 << 6) ? "" ACK"" : """",
                        insn & (1 << 9) ? "" TM"" : """",
                        insn & (1 << 10) ? "" CC"" : """");
                if (insn & (1 << 3)) {
                    s->socl &= ~LSI_SOCL_ATN;
                    s->sbcl &= ~LSI_SBCL_ATN;
                }

                if (insn & (1 << 6)) {
                    s->sbcl &= ~LSI_SBCL_ACK;
                }

                if (insn & (1 << 10))
                    s->carry = 0;
                break;
            }
        } else {
            uint8_t op0;
            uint8_t op1;
            uint8_t data8;
            int reg;
            int operator;

            static const char *opcode_names[3] =
                {""Write"", ""Read"", ""Read-Modify-Write""};
            static const char *operator_names[8] =
                {""MOV"", ""SHL"", ""OR"", ""XOR"", ""AND"", ""SHR"", ""ADD"", ""ADC""};

            reg = ((insn >> 16) & 0x7f) | (insn & 0x80);
            data8 = (insn >> 8) & 0xff;
            opcode = (insn >> 27) & 7;
            operator = (insn >> 24) & 7;
            trace_lsi_execute_script_io_opcode(
                    opcode_names[opcode - 5], reg,
                    operator_names[operator], data8, s->sfbr,
                    (insn & (1 << 23)) ? "" SFBR"" : """");
            op0 = op1 = 0;
            switch (opcode) {
            case 5: /* From SFBR */
                op0 = s->sfbr;
                op1 = data8;
                break;
            case 6: /* To SFBR */
                if (operator)
                    op0 = lsi_reg_readb(s, reg);
                op1 = data8;
                break;
            case 7: /* Read-modify-write */
                if (operator)
                    op0 = lsi_reg_readb(s, reg);
                if (insn & (1 << 23)) {
                    op1 = s->sfbr;
                } else {
                    op1 = data8;
                }
                break;
            }

            switch (operator) {
            case 0: /* move */
                op0 = op1;
                break;
            case 1: /* Shift left */
                op1 = op0 >> 7;
                op0 = (op0 << 1) | s->carry;
                s->carry = op1;
                break;
            case 2: /* OR */
                op0 |= op1;
                break;
            case 3: /* XOR */
                op0 ^= op1;
                break;
            case 4: /* AND */
                op0 &= op1;
                break;
            case 5: /* SHR */
                op1 = op0 & 1;
                op0 = (op0 >> 1) | (s->carry << 7);
                s->carry = op1;
                break;
            case 6: /* ADD */
                op0 += op1;
                s->carry = op0 < op1;
                break;
            case 7: /* ADC */
                op0 += op1 + s->carry;
                if (s->carry)
                    s->carry = op0 <= op1;
                else
                    s->carry = op0 < op1;
                break;
            }

            switch (opcode) {
            case 5: /* From SFBR */
            case 7: /* Read-modify-write */
                lsi_reg_writeb(s, reg, op0);
                break;
            case 6: /* To SFBR */
                s->sfbr = op0;
                break;
            }
        }
        break;

    case 2: /* Transfer Control.  */
        {
            int cond;
            int jmp;

            if ((insn & 0x002e0000) == 0) {
                trace_lsi_execute_script_tc_nop();
                break;
            }
            if (s->sist1 & LSI_SIST1_STO) {
                trace_lsi_execute_script_tc_delayedselect_timeout();
                lsi_stop_script(s);
                break;
            }
            cond = jmp = (insn & (1 << 19)) != 0;
            if (cond == jmp && (insn & (1 << 21))) {
                trace_lsi_execute_script_tc_compc(s->carry == jmp);
                cond = s->carry != 0;
            }
            if (cond == jmp && (insn & (1 << 17))) {
                trace_lsi_execute_script_tc_compp(scsi_phase_name(s->sstat1),
                        jmp ? '=' : '!', scsi_phase_name(insn >> 24));
                cond = (s->sstat1 & PHASE_MASK) == ((insn >> 24) & 7);
            }
            if (cond == jmp && (insn & (1 << 18))) {
                uint8_t mask;

                mask = (~insn >> 8) & 0xff;
                trace_lsi_execute_script_tc_compd(
                        s->sfbr, mask, jmp ? '=' : '!', insn & mask);
                cond = (s->sfbr & mask) == (insn & mask);
            }
            if (cond == jmp) {
                if (insn & (1 << 23)) {
                    /* Relative address.  */
                    addr = s->dsp + sextract32(addr, 0, 24);
                }
                switch ((insn >> 27) & 7) {
                case 0: /* Jump */
                    trace_lsi_execute_script_tc_jump(addr);
                    s->adder = addr;
                    s->dsp = addr;
                    break;
                case 1: /* Call */
                    trace_lsi_execute_script_tc_call(addr);
                    s->temp = s->dsp;
                    s->dsp = addr;
                    break;
                case 2: /* Return */
                    trace_lsi_execute_script_tc_return(s->temp);
                    s->dsp = s->temp;
                    break;
                case 3: /* Interrupt */
                    trace_lsi_execute_script_tc_interrupt(s->dsps);
                    if ((insn & (1 << 20)) != 0) {
                        s->istat0 |= LSI_ISTAT0_INTF;
                        lsi_update_irq(s);
                    } else {
                        lsi_script_dma_interrupt(s, LSI_DSTAT_SIR);
                    }
                    break;
                default:
                    trace_lsi_execute_script_tc_illegal();
                    lsi_script_dma_interrupt(s, LSI_DSTAT_IID);
                    break;
                }
            } else {
                trace_lsi_execute_script_tc_cc_failed();
            }
        }
        break;

    case 3:
        if ((insn & (1 << 29)) == 0) {
            /* Memory move.  */
            uint32_t dest;
            /* ??? The docs imply the destination address is loaded into
               the TEMP register.  However the Linux drivers rely on
               the value being presrved.  */
            dest = read_dword(s, s->dsp);
            s->dsp += 4;
            lsi_memcpy(s, dest, addr, insn & 0xffffff);
        } else {
            uint8_t data[7];
            int reg;
            int n;
            int i;

            if (insn & (1 << 28)) {
                addr = s->dsa + sextract32(addr, 0, 24);
            }
            n = (insn & 7);
            reg = (insn >> 16) & 0xff;
            if (insn & (1 << 24)) {
                pci_dma_read(pci_dev, addr, data, n);
                trace_lsi_execute_script_mm_load(reg, n, addr, *(int *)data);
                for (i = 0; i < n; i++) {
                    lsi_reg_writeb(s, reg + i, data[i]);
                }
            } else {
                trace_lsi_execute_script_mm_store(reg, n, addr);
                for (i = 0; i < n; i++) {
                    data[i] = lsi_reg_readb(s, reg + i);
                }
                pci_dma_write(pci_dev, addr, data, n);
            }
        }
    }
    if (insn_processed > 10000 && s->waiting == LSI_NOWAIT) {
        /* Some windows drivers make the device spin waiting for a memory
           location to change.  If we have been executed a lot of code then
           assume this is the case and force an unexpected device disconnect.
           This is apparently sufficient to beat the drivers into submission.
         */
        if (!(s->sien0 & LSI_SIST0_UDC)) {
            qemu_log_mask(LOG_GUEST_ERROR,
                          ""lsi_scsi: inf. loop with UDC masked"");
        }
        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);
        lsi_disconnect(s);
    } else if (s->istat1 & LSI_ISTAT1_SRUN && s->waiting == LSI_NOWAIT) {
        if (s->dcntl & LSI_DCNTL_SSM) {
             }
         }
     }
","static void lsi_execute_script(LSIState *s)
{
    PCIDevice *pci_dev = PCI_DEVICE(s);
    uint32_t insn;
    uint32_t addr, addr_high;
    int opcode;
    int insn_processed = 0;

    s->istat1 |= LSI_ISTAT1_SRUN;
again:
 
     s->istat1 |= LSI_ISTAT1_SRUN;
 again:
    insn_processed++;
     insn = read_dword(s, s->dsp);
     if (!insn) {
         /* If we receive an empty opcode increment the DSP by 4 bytes
        s->dbc = insn & 0xffffff;
        s->rbc = s->dbc;
        /* ??? Set ESA.  */
        s->ia = s->dsp - 8;
        if (insn & (1 << 29)) {
            /* Indirect addressing.  */
            addr = read_dword(s, addr);
        } else if (insn & (1 << 28)) {
            uint32_t buf[2];
            int32_t offset;
            /* Table indirect addressing.  */

            /* 32-bit Table indirect */
            offset = sextract32(addr, 0, 24);
            pci_dma_read(pci_dev, s->dsa + offset, buf, 8);
            /* byte count is stored in bits 0:23 only */
            s->dbc = cpu_to_le32(buf[0]) & 0xffffff;
            s->rbc = s->dbc;
            addr = cpu_to_le32(buf[1]);

            /* 40-bit DMA, upper addr bits [39:32] stored in first DWORD of
             * table, bits [31:24] */
            if (lsi_dma_40bit(s))
                addr_high = cpu_to_le32(buf[0]) >> 24;
            else if (lsi_dma_ti64bit(s)) {
                int selector = (cpu_to_le32(buf[0]) >> 24) & 0x1f;
                switch (selector) {
                case 0 ... 0x0f:
                    /* offset index into scratch registers since
                     * TI64 mode can use registers C to R */
                    addr_high = s->scratch[2 + selector];
                    break;
                case 0x10:
                    addr_high = s->mmrs;
                    break;
                case 0x11:
                    addr_high = s->mmws;
                    break;
                case 0x12:
                    addr_high = s->sfs;
                    break;
                case 0x13:
                    addr_high = s->drs;
                    break;
                case 0x14:
                    addr_high = s->sbms;
                    break;
                case 0x15:
                    addr_high = s->dbms;
                    break;
                default:
                    qemu_log_mask(LOG_GUEST_ERROR,
                          ""lsi_scsi: Illegal selector specified (0x%x > 0x15) ""
                          ""for 64-bit DMA block move"", selector);
                    break;
                }
            }
        } else if (lsi_dma_64bit(s)) {
            /* fetch a 3rd dword if 64-bit direct move is enabled and
               only if we're not doing table indirect or indirect addressing */
            s->dbms = read_dword(s, s->dsp);
            s->dsp += 4;
            s->ia = s->dsp - 12;
        }
        if ((s->sstat1 & PHASE_MASK) != ((insn >> 24) & 7)) {
            trace_lsi_execute_script_blockmove_badphase(
                    scsi_phase_name(s->sstat1),
                    scsi_phase_name(insn >> 24));
            lsi_script_scsi_interrupt(s, LSI_SIST0_MA, 0);
            break;
        }
        s->dnad = addr;
        s->dnad64 = addr_high;
        switch (s->sstat1 & 0x7) {
        case PHASE_DO:
            s->waiting = LSI_DMA_SCRIPTS;
            lsi_do_dma(s, 1);
            if (s->waiting)
                s->waiting = LSI_DMA_IN_PROGRESS;
            break;
        case PHASE_DI:
            s->waiting = LSI_DMA_SCRIPTS;
            lsi_do_dma(s, 0);
            if (s->waiting)
                s->waiting = LSI_DMA_IN_PROGRESS;
            break;
        case PHASE_CMD:
            lsi_do_command(s);
            break;
        case PHASE_ST:
            lsi_do_status(s);
            break;
        case PHASE_MO:
            lsi_do_msgout(s);
            break;
        case PHASE_MI:
            lsi_do_msgin(s);
            break;
        default:
            qemu_log_mask(LOG_UNIMP, ""lsi_scsi: Unimplemented phase %s\n"",
                          scsi_phase_name(s->sstat1));
        }
        s->dfifo = s->dbc & 0xff;
        s->ctest5 = (s->ctest5 & 0xfc) | ((s->dbc >> 8) & 3);
        s->sbc = s->dbc;
        s->rbc -= s->dbc;
        s->ua = addr + s->dbc;
        break;

    case 1: /* IO or Read/Write instruction.  */
        opcode = (insn >> 27) & 7;
        if (opcode < 5) {
            uint32_t id;

            if (insn & (1 << 25)) {
                id = read_dword(s, s->dsa + sextract32(insn, 0, 24));
            } else {
                id = insn;
            }
            id = (id >> 16) & 0xf;
            if (insn & (1 << 26)) {
                addr = s->dsp + sextract32(addr, 0, 24);
            }
            s->dnad = addr;
            switch (opcode) {
            case 0: /* Select */
                s->sdid = id;
                if (s->scntl1 & LSI_SCNTL1_CON) {
                    trace_lsi_execute_script_io_alreadyreselected();
                    s->dsp = s->dnad;
                    break;
                }
                s->sstat0 |= LSI_SSTAT0_WOA;
                s->scntl1 &= ~LSI_SCNTL1_IARB;
                if (!scsi_device_find(&s->bus, 0, id, 0)) {
                    lsi_bad_selection(s, id);
                    break;
                }
                trace_lsi_execute_script_io_selected(id,
                                             insn & (1 << 3) ? "" ATN"" : """");
                /* ??? Linux drivers compain when this is set.  Maybe
                   it only applies in low-level mode (unimplemented).
                lsi_script_scsi_interrupt(s, LSI_SIST0_CMP, 0); */
                s->select_tag = id << 8;
                s->scntl1 |= LSI_SCNTL1_CON;
                if (insn & (1 << 3)) {
                    s->socl |= LSI_SOCL_ATN;
                    s->sbcl |= LSI_SBCL_ATN;
                }
                s->sbcl |= LSI_SBCL_BSY;
                lsi_set_phase(s, PHASE_MO);
                s->waiting = LSI_NOWAIT;
                break;
            case 1: /* Disconnect */
                trace_lsi_execute_script_io_disconnect();
                s->scntl1 &= ~LSI_SCNTL1_CON;
                /* FIXME: this is not entirely correct; the target need not ask
                 * for reselection until it has to send data, while here we force a
                 * reselection as soon as the bus is free.  The correct flow would
                 * reselect before lsi_transfer_data and disconnect as soon as
                 * DMA ends.
                 */
                if (!s->current) {
                    lsi_request *p = get_pending_req(s);
                    if (p) {
                        lsi_reselect(s, p);
                    }
                }
                break;
            case 2: /* Wait Reselect */
                if (s->istat0 & LSI_ISTAT0_SIGP) {
                    s->dsp = s->dnad;
                } else if (!lsi_irq_on_rsl(s)) {
                        lsi_wait_reselect(s);
                }
                break;
            case 3: /* Set */
                trace_lsi_execute_script_io_set(
                        insn & (1 << 3) ? "" ATN"" : """",
                        insn & (1 << 6) ? "" ACK"" : """",
                        insn & (1 << 9) ? "" TM"" : """",
                        insn & (1 << 10) ? "" CC"" : """");
                if (insn & (1 << 3)) {
                    s->socl |= LSI_SOCL_ATN;
                    s->sbcl |= LSI_SBCL_ATN;
                    lsi_set_phase(s, PHASE_MO);
                }

                if (insn & (1 << 6)) {
                    s->sbcl |= LSI_SBCL_ACK;
                }

                if (insn & (1 << 9)) {
                    qemu_log_mask(LOG_UNIMP,
                        ""lsi_scsi: Target mode not implemented\n"");
                }
                if (insn & (1 << 10))
                    s->carry = 1;
                break;
            case 4: /* Clear */
                trace_lsi_execute_script_io_clear(
                        insn & (1 << 3) ? "" ATN"" : """",
                        insn & (1 << 6) ? "" ACK"" : """",
                        insn & (1 << 9) ? "" TM"" : """",
                        insn & (1 << 10) ? "" CC"" : """");
                if (insn & (1 << 3)) {
                    s->socl &= ~LSI_SOCL_ATN;
                    s->sbcl &= ~LSI_SBCL_ATN;
                }

                if (insn & (1 << 6)) {
                    s->sbcl &= ~LSI_SBCL_ACK;
                }

                if (insn & (1 << 10))
                    s->carry = 0;
                break;
            }
        } else {
            uint8_t op0;
            uint8_t op1;
            uint8_t data8;
            int reg;
            int operator;

            static const char *opcode_names[3] =
                {""Write"", ""Read"", ""Read-Modify-Write""};
            static const char *operator_names[8] =
                {""MOV"", ""SHL"", ""OR"", ""XOR"", ""AND"", ""SHR"", ""ADD"", ""ADC""};

            reg = ((insn >> 16) & 0x7f) | (insn & 0x80);
            data8 = (insn >> 8) & 0xff;
            opcode = (insn >> 27) & 7;
            operator = (insn >> 24) & 7;
            trace_lsi_execute_script_io_opcode(
                    opcode_names[opcode - 5], reg,
                    operator_names[operator], data8, s->sfbr,
                    (insn & (1 << 23)) ? "" SFBR"" : """");
            op0 = op1 = 0;
            switch (opcode) {
            case 5: /* From SFBR */
                op0 = s->sfbr;
                op1 = data8;
                break;
            case 6: /* To SFBR */
                if (operator)
                    op0 = lsi_reg_readb(s, reg);
                op1 = data8;
                break;
            case 7: /* Read-modify-write */
                if (operator)
                    op0 = lsi_reg_readb(s, reg);
                if (insn & (1 << 23)) {
                    op1 = s->sfbr;
                } else {
                    op1 = data8;
                }
                break;
            }

            switch (operator) {
            case 0: /* move */
                op0 = op1;
                break;
            case 1: /* Shift left */
                op1 = op0 >> 7;
                op0 = (op0 << 1) | s->carry;
                s->carry = op1;
                break;
            case 2: /* OR */
                op0 |= op1;
                break;
            case 3: /* XOR */
                op0 ^= op1;
                break;
            case 4: /* AND */
                op0 &= op1;
                break;
            case 5: /* SHR */
                op1 = op0 & 1;
                op0 = (op0 >> 1) | (s->carry << 7);
                s->carry = op1;
                break;
            case 6: /* ADD */
                op0 += op1;
                s->carry = op0 < op1;
                break;
            case 7: /* ADC */
                op0 += op1 + s->carry;
                if (s->carry)
                    s->carry = op0 <= op1;
                else
                    s->carry = op0 < op1;
                break;
            }

            switch (opcode) {
            case 5: /* From SFBR */
            case 7: /* Read-modify-write */
                lsi_reg_writeb(s, reg, op0);
                break;
            case 6: /* To SFBR */
                s->sfbr = op0;
                break;
            }
        }
        break;

    case 2: /* Transfer Control.  */
        {
            int cond;
            int jmp;

            if ((insn & 0x002e0000) == 0) {
                trace_lsi_execute_script_tc_nop();
                break;
            }
            if (s->sist1 & LSI_SIST1_STO) {
                trace_lsi_execute_script_tc_delayedselect_timeout();
                lsi_stop_script(s);
                break;
            }
            cond = jmp = (insn & (1 << 19)) != 0;
            if (cond == jmp && (insn & (1 << 21))) {
                trace_lsi_execute_script_tc_compc(s->carry == jmp);
                cond = s->carry != 0;
            }
            if (cond == jmp && (insn & (1 << 17))) {
                trace_lsi_execute_script_tc_compp(scsi_phase_name(s->sstat1),
                        jmp ? '=' : '!', scsi_phase_name(insn >> 24));
                cond = (s->sstat1 & PHASE_MASK) == ((insn >> 24) & 7);
            }
            if (cond == jmp && (insn & (1 << 18))) {
                uint8_t mask;

                mask = (~insn >> 8) & 0xff;
                trace_lsi_execute_script_tc_compd(
                        s->sfbr, mask, jmp ? '=' : '!', insn & mask);
                cond = (s->sfbr & mask) == (insn & mask);
            }
            if (cond == jmp) {
                if (insn & (1 << 23)) {
                    /* Relative address.  */
                    addr = s->dsp + sextract32(addr, 0, 24);
                }
                switch ((insn >> 27) & 7) {
                case 0: /* Jump */
                    trace_lsi_execute_script_tc_jump(addr);
                    s->adder = addr;
                    s->dsp = addr;
                    break;
                case 1: /* Call */
                    trace_lsi_execute_script_tc_call(addr);
                    s->temp = s->dsp;
                    s->dsp = addr;
                    break;
                case 2: /* Return */
                    trace_lsi_execute_script_tc_return(s->temp);
                    s->dsp = s->temp;
                    break;
                case 3: /* Interrupt */
                    trace_lsi_execute_script_tc_interrupt(s->dsps);
                    if ((insn & (1 << 20)) != 0) {
                        s->istat0 |= LSI_ISTAT0_INTF;
                        lsi_update_irq(s);
                    } else {
                        lsi_script_dma_interrupt(s, LSI_DSTAT_SIR);
                    }
                    break;
                default:
                    trace_lsi_execute_script_tc_illegal();
                    lsi_script_dma_interrupt(s, LSI_DSTAT_IID);
                    break;
                }
            } else {
                trace_lsi_execute_script_tc_cc_failed();
            }
        }
        break;

    case 3:
        if ((insn & (1 << 29)) == 0) {
            /* Memory move.  */
            uint32_t dest;
            /* ??? The docs imply the destination address is loaded into
               the TEMP register.  However the Linux drivers rely on
               the value being presrved.  */
            dest = read_dword(s, s->dsp);
            s->dsp += 4;
            lsi_memcpy(s, dest, addr, insn & 0xffffff);
        } else {
            uint8_t data[7];
            int reg;
            int n;
            int i;

            if (insn & (1 << 28)) {
                addr = s->dsa + sextract32(addr, 0, 24);
            }
            n = (insn & 7);
            reg = (insn >> 16) & 0xff;
            if (insn & (1 << 24)) {
                pci_dma_read(pci_dev, addr, data, n);
                trace_lsi_execute_script_mm_load(reg, n, addr, *(int *)data);
                for (i = 0; i < n; i++) {
                    lsi_reg_writeb(s, reg + i, data[i]);
                }
            } else {
                trace_lsi_execute_script_mm_store(reg, n, addr);
                for (i = 0; i < n; i++) {
                    data[i] = lsi_reg_readb(s, reg + i);
                }
                pci_dma_write(pci_dev, addr, data, n);
            }
        }
    }
    if (insn_processed > 10000 && s->waiting == LSI_NOWAIT) {
        /* Some windows drivers make the device spin waiting for a memory
           location to change.  If we have been executed a lot of code then
           assume this is the case and force an unexpected device disconnect.
           This is apparently sufficient to beat the drivers into submission.
         */
        if (!(s->sien0 & LSI_SIST0_UDC)) {
            qemu_log_mask(LOG_GUEST_ERROR,
                          ""lsi_scsi: inf. loop with UDC masked"");
        }
        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);
        lsi_disconnect(s);
    } else if (s->istat1 & LSI_ISTAT1_SRUN && s->waiting == LSI_NOWAIT) {
        if (s->dcntl & LSI_DCNTL_SSM) {
             }
         }
     }
",C,"    if (++insn_processed > LSI_MAX_INSN) {
        /* Some windows drivers make the device spin waiting for a memory
           location to change.  If we have been executed a lot of code then
           assume this is the case and force an unexpected device disconnect.
           This is apparently sufficient to beat the drivers into submission.
         */
        if (!(s->sien0 & LSI_SIST0_UDC)) {
            qemu_log_mask(LOG_GUEST_ERROR,
                          ""lsi_scsi: inf. loop with UDC masked"");
        }
        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);
        lsi_disconnect(s);
        trace_lsi_execute_script_stop();
        return;
    }
","    insn_processed++;
",a060297822ea6b4194bf36654e58c802448a3eea,"@@ -186,6 +186,9 @@ static const char *names[] = {
 /* Flag set if this is a tagged command.  */
 #define LSI_TAG_VALID     (1 << 16)
 
+/* Maximum instructions to process. */
+#define LSI_MAX_INSN    10000
+
 typedef struct lsi_request {
     SCSIRequest *req;
     uint32_t tag;
@@ -1133,7 +1136,21 @@ static void lsi_execute_script(LSIState *s)
 
     s->istat1 |= LSI_ISTAT1_SRUN;
 again:
-    insn_processed++;
+    if (++insn_processed > LSI_MAX_INSN) {
+        /* Some windows drivers make the device spin waiting for a memory
+           location to change.  If we have been executed a lot of code then
+           assume this is the case and force an unexpected device disconnect.
+           This is apparently sufficient to beat the drivers into submission.
+         */
+        if (!(s->sien0 & LSI_SIST0_UDC)) {
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          ""lsi_scsi: inf. loop with UDC masked"");
+        }
+        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);
+        lsi_disconnect(s);
+        trace_lsi_execute_script_stop();
+        return;
+    }
     insn = read_dword(s, s->dsp);
     if (!insn) {
         /* If we receive an empty opcode increment the DSP by 4 bytes
@@ -1570,19 +1587,7 @@ again:
             }
         }
     }
-    if (insn_processed > 10000 && s->waiting == LSI_NOWAIT) {
-        /* Some windows drivers make the device spin waiting for a memory
-           location to change.  If we have been executed a lot of code then
-           assume this is the case and force an unexpected device disconnect.
-           This is apparently sufficient to beat the drivers into submission.
-         */
-        if (!(s->sien0 & LSI_SIST0_UDC)) {
-            qemu_log_mask(LOG_GUEST_ERROR,
-                          ""lsi_scsi: inf. loop with UDC masked"");
-        }
-        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);
-        lsi_disconnect(s);
-    } else if (s->istat1 & LSI_ISTAT1_SRUN && s->waiting == LSI_NOWAIT) {
+    if (s->istat1 & LSI_ISTAT1_SRUN && s->waiting == LSI_NOWAIT) {
         if (s->dcntl & LSI_DCNTL_SSM) {
             lsi_script_dma_interrupt(s, LSI_DSTAT_SSI);
         } else {
@@ -1970,6 +1975,10 @@ static void lsi_reg_writeb(LSIState *s, int offset, uint8_t val)
     case 0x2f: /* DSP[24:31] */
         s->dsp &= 0x00ffffff;
         s->dsp |= val << 24;
+        /*
+         * FIXME: if s->waiting != LSI_NOWAIT, this will only execute one
+         * instruction.  Is this correct?
+         */
         if ((s->dmode & LSI_DMODE_MAN) == 0
             && (s->istat1 & LSI_ISTAT1_SRUN) == 0)
             lsi_execute_script(s);
@@ -1988,6 +1997,10 @@ static void lsi_reg_writeb(LSIState *s, int offset, uint8_t val)
         break;
     case 0x3b: /* DCNTL */
         s->dcntl = val & ~(LSI_DCNTL_PFF | LSI_DCNTL_STD);
+        /*
+         * FIXME: if s->waiting != LSI_NOWAIT, this will only execute one
+         * instruction.  Is this correct?
+         */
         if ((val & LSI_DCNTL_STD) && (s->istat1 & LSI_ISTAT1_SRUN) == 0)
             lsi_execute_script(s);
         break;",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/scsi/lsi53c895a.c;h=ec53b14f7fbfe0f033088ad85a674cb111f566e0;hb=ec53b14f7fbfe0f033088ad85a674cb111f566e0,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/scsi/lsi53c895a.c;h=222a286d44098390e13704d5c8b8cd6d5c11f226;hb=222a286d44098390e13704d5c8b8cd6d5c11f226,1,"static void lsi_execute_script(LSIState *s)
{
    PCIDevice *pci_dev = PCI_DEVICE(s);
    uint32_t insn;
    uint32_t addr, addr_high;
    int opcode;
    int insn_processed = 0;

    s->istat1 |= LSI_ISTAT1_SRUN;
again:
 
     s->istat1 |= LSI_ISTAT1_SRUN;
 again:
//flaw_line_below:
    insn_processed++;
//fix_flaw_line_below:
//    if (++insn_processed > LSI_MAX_INSN) {
//fix_flaw_line_below:
//        /* Some windows drivers make the device spin waiting for a memory
//fix_flaw_line_below:
//           location to change.  If we have been executed a lot of code then
//fix_flaw_line_below:
//           assume this is the case and force an unexpected device disconnect.
//fix_flaw_line_below:
//           This is apparently sufficient to beat the drivers into submission.
//fix_flaw_line_below:
//         */
//fix_flaw_line_below:
//        if (!(s->sien0 & LSI_SIST0_UDC)) {
//fix_flaw_line_below:
//            qemu_log_mask(LOG_GUEST_ERROR,
//fix_flaw_line_below:
//                          ""lsi_scsi: inf. loop with UDC masked"");
//fix_flaw_line_below:
//        }
//fix_flaw_line_below:
//        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);
//fix_flaw_line_below:
//        lsi_disconnect(s);
//fix_flaw_line_below:
//        trace_lsi_execute_script_stop();
//fix_flaw_line_below:
//        return;
//fix_flaw_line_below:
//    }
     insn = read_dword(s, s->dsp);
     if (!insn) {
         /* If we receive an empty opcode increment the DSP by 4 bytes
        s->dbc = insn & 0xffffff;
        s->rbc = s->dbc;
        /* ??? Set ESA.  */
        s->ia = s->dsp - 8;
        if (insn & (1 << 29)) {
            /* Indirect addressing.  */
            addr = read_dword(s, addr);
        } else if (insn & (1 << 28)) {
            uint32_t buf[2];
            int32_t offset;
            /* Table indirect addressing.  */

            /* 32-bit Table indirect */
            offset = sextract32(addr, 0, 24);
            pci_dma_read(pci_dev, s->dsa + offset, buf, 8);
            /* byte count is stored in bits 0:23 only */
            s->dbc = cpu_to_le32(buf[0]) & 0xffffff;
            s->rbc = s->dbc;
            addr = cpu_to_le32(buf[1]);

            /* 40-bit DMA, upper addr bits [39:32] stored in first DWORD of
             * table, bits [31:24] */
            if (lsi_dma_40bit(s))
                addr_high = cpu_to_le32(buf[0]) >> 24;
            else if (lsi_dma_ti64bit(s)) {
                int selector = (cpu_to_le32(buf[0]) >> 24) & 0x1f;
                switch (selector) {
                case 0 ... 0x0f:
                    /* offset index into scratch registers since
                     * TI64 mode can use registers C to R */
                    addr_high = s->scratch[2 + selector];
                    break;
                case 0x10:
                    addr_high = s->mmrs;
                    break;
                case 0x11:
                    addr_high = s->mmws;
                    break;
                case 0x12:
                    addr_high = s->sfs;
                    break;
                case 0x13:
                    addr_high = s->drs;
                    break;
                case 0x14:
                    addr_high = s->sbms;
                    break;
                case 0x15:
                    addr_high = s->dbms;
                    break;
                default:
                    qemu_log_mask(LOG_GUEST_ERROR,
                          ""lsi_scsi: Illegal selector specified (0x%x > 0x15) ""
                          ""for 64-bit DMA block move"", selector);
                    break;
                }
            }
        } else if (lsi_dma_64bit(s)) {
            /* fetch a 3rd dword if 64-bit direct move is enabled and
               only if we're not doing table indirect or indirect addressing */
            s->dbms = read_dword(s, s->dsp);
            s->dsp += 4;
            s->ia = s->dsp - 12;
        }
        if ((s->sstat1 & PHASE_MASK) != ((insn >> 24) & 7)) {
            trace_lsi_execute_script_blockmove_badphase(
                    scsi_phase_name(s->sstat1),
                    scsi_phase_name(insn >> 24));
            lsi_script_scsi_interrupt(s, LSI_SIST0_MA, 0);
            break;
        }
        s->dnad = addr;
        s->dnad64 = addr_high;
        switch (s->sstat1 & 0x7) {
        case PHASE_DO:
            s->waiting = LSI_DMA_SCRIPTS;
            lsi_do_dma(s, 1);
            if (s->waiting)
                s->waiting = LSI_DMA_IN_PROGRESS;
            break;
        case PHASE_DI:
            s->waiting = LSI_DMA_SCRIPTS;
            lsi_do_dma(s, 0);
            if (s->waiting)
                s->waiting = LSI_DMA_IN_PROGRESS;
            break;
        case PHASE_CMD:
            lsi_do_command(s);
            break;
        case PHASE_ST:
            lsi_do_status(s);
            break;
        case PHASE_MO:
            lsi_do_msgout(s);
            break;
        case PHASE_MI:
            lsi_do_msgin(s);
            break;
        default:
            qemu_log_mask(LOG_UNIMP, ""lsi_scsi: Unimplemented phase %s\n"",
                          scsi_phase_name(s->sstat1));
        }
        s->dfifo = s->dbc & 0xff;
        s->ctest5 = (s->ctest5 & 0xfc) | ((s->dbc >> 8) & 3);
        s->sbc = s->dbc;
        s->rbc -= s->dbc;
        s->ua = addr + s->dbc;
        break;

    case 1: /* IO or Read/Write instruction.  */
        opcode = (insn >> 27) & 7;
        if (opcode < 5) {
            uint32_t id;

            if (insn & (1 << 25)) {
                id = read_dword(s, s->dsa + sextract32(insn, 0, 24));
            } else {
                id = insn;
            }
            id = (id >> 16) & 0xf;
            if (insn & (1 << 26)) {
                addr = s->dsp + sextract32(addr, 0, 24);
            }
            s->dnad = addr;
            switch (opcode) {
            case 0: /* Select */
                s->sdid = id;
                if (s->scntl1 & LSI_SCNTL1_CON) {
                    trace_lsi_execute_script_io_alreadyreselected();
                    s->dsp = s->dnad;
                    break;
                }
                s->sstat0 |= LSI_SSTAT0_WOA;
                s->scntl1 &= ~LSI_SCNTL1_IARB;
                if (!scsi_device_find(&s->bus, 0, id, 0)) {
                    lsi_bad_selection(s, id);
                    break;
                }
                trace_lsi_execute_script_io_selected(id,
                                             insn & (1 << 3) ? "" ATN"" : """");
                /* ??? Linux drivers compain when this is set.  Maybe
                   it only applies in low-level mode (unimplemented).
                lsi_script_scsi_interrupt(s, LSI_SIST0_CMP, 0); */
                s->select_tag = id << 8;
                s->scntl1 |= LSI_SCNTL1_CON;
                if (insn & (1 << 3)) {
                    s->socl |= LSI_SOCL_ATN;
                    s->sbcl |= LSI_SBCL_ATN;
                }
                s->sbcl |= LSI_SBCL_BSY;
                lsi_set_phase(s, PHASE_MO);
                s->waiting = LSI_NOWAIT;
                break;
            case 1: /* Disconnect */
                trace_lsi_execute_script_io_disconnect();
                s->scntl1 &= ~LSI_SCNTL1_CON;
                /* FIXME: this is not entirely correct; the target need not ask
                 * for reselection until it has to send data, while here we force a
                 * reselection as soon as the bus is free.  The correct flow would
                 * reselect before lsi_transfer_data and disconnect as soon as
                 * DMA ends.
                 */
                if (!s->current) {
                    lsi_request *p = get_pending_req(s);
                    if (p) {
                        lsi_reselect(s, p);
                    }
                }
                break;
            case 2: /* Wait Reselect */
                if (s->istat0 & LSI_ISTAT0_SIGP) {
                    s->dsp = s->dnad;
                } else if (!lsi_irq_on_rsl(s)) {
                        lsi_wait_reselect(s);
                }
                break;
            case 3: /* Set */
                trace_lsi_execute_script_io_set(
                        insn & (1 << 3) ? "" ATN"" : """",
                        insn & (1 << 6) ? "" ACK"" : """",
                        insn & (1 << 9) ? "" TM"" : """",
                        insn & (1 << 10) ? "" CC"" : """");
                if (insn & (1 << 3)) {
                    s->socl |= LSI_SOCL_ATN;
                    s->sbcl |= LSI_SBCL_ATN;
                    lsi_set_phase(s, PHASE_MO);
                }

                if (insn & (1 << 6)) {
                    s->sbcl |= LSI_SBCL_ACK;
                }

                if (insn & (1 << 9)) {
                    qemu_log_mask(LOG_UNIMP,
                        ""lsi_scsi: Target mode not implemented\n"");
                }
                if (insn & (1 << 10))
                    s->carry = 1;
                break;
            case 4: /* Clear */
                trace_lsi_execute_script_io_clear(
                        insn & (1 << 3) ? "" ATN"" : """",
                        insn & (1 << 6) ? "" ACK"" : """",
                        insn & (1 << 9) ? "" TM"" : """",
                        insn & (1 << 10) ? "" CC"" : """");
                if (insn & (1 << 3)) {
                    s->socl &= ~LSI_SOCL_ATN;
                    s->sbcl &= ~LSI_SBCL_ATN;
                }

                if (insn & (1 << 6)) {
                    s->sbcl &= ~LSI_SBCL_ACK;
                }

                if (insn & (1 << 10))
                    s->carry = 0;
                break;
            }
        } else {
            uint8_t op0;
            uint8_t op1;
            uint8_t data8;
            int reg;
            int operator;

            static const char *opcode_names[3] =
                {""Write"", ""Read"", ""Read-Modify-Write""};
            static const char *operator_names[8] =
                {""MOV"", ""SHL"", ""OR"", ""XOR"", ""AND"", ""SHR"", ""ADD"", ""ADC""};

            reg = ((insn >> 16) & 0x7f) | (insn & 0x80);
            data8 = (insn >> 8) & 0xff;
            opcode = (insn >> 27) & 7;
            operator = (insn >> 24) & 7;
            trace_lsi_execute_script_io_opcode(
                    opcode_names[opcode - 5], reg,
                    operator_names[operator], data8, s->sfbr,
                    (insn & (1 << 23)) ? "" SFBR"" : """");
            op0 = op1 = 0;
            switch (opcode) {
            case 5: /* From SFBR */
                op0 = s->sfbr;
                op1 = data8;
                break;
            case 6: /* To SFBR */
                if (operator)
                    op0 = lsi_reg_readb(s, reg);
                op1 = data8;
                break;
            case 7: /* Read-modify-write */
                if (operator)
                    op0 = lsi_reg_readb(s, reg);
                if (insn & (1 << 23)) {
                    op1 = s->sfbr;
                } else {
                    op1 = data8;
                }
                break;
            }

            switch (operator) {
            case 0: /* move */
                op0 = op1;
                break;
            case 1: /* Shift left */
                op1 = op0 >> 7;
                op0 = (op0 << 1) | s->carry;
                s->carry = op1;
                break;
            case 2: /* OR */
                op0 |= op1;
                break;
            case 3: /* XOR */
                op0 ^= op1;
                break;
            case 4: /* AND */
                op0 &= op1;
                break;
            case 5: /* SHR */
                op1 = op0 & 1;
                op0 = (op0 >> 1) | (s->carry << 7);
                s->carry = op1;
                break;
            case 6: /* ADD */
                op0 += op1;
                s->carry = op0 < op1;
                break;
            case 7: /* ADC */
                op0 += op1 + s->carry;
                if (s->carry)
                    s->carry = op0 <= op1;
                else
                    s->carry = op0 < op1;
                break;
            }

            switch (opcode) {
            case 5: /* From SFBR */
            case 7: /* Read-modify-write */
                lsi_reg_writeb(s, reg, op0);
                break;
            case 6: /* To SFBR */
                s->sfbr = op0;
                break;
            }
        }
        break;

    case 2: /* Transfer Control.  */
        {
            int cond;
            int jmp;

            if ((insn & 0x002e0000) == 0) {
                trace_lsi_execute_script_tc_nop();
                break;
            }
            if (s->sist1 & LSI_SIST1_STO) {
                trace_lsi_execute_script_tc_delayedselect_timeout();
                lsi_stop_script(s);
                break;
            }
            cond = jmp = (insn & (1 << 19)) != 0;
            if (cond == jmp && (insn & (1 << 21))) {
                trace_lsi_execute_script_tc_compc(s->carry == jmp);
                cond = s->carry != 0;
            }
            if (cond == jmp && (insn & (1 << 17))) {
                trace_lsi_execute_script_tc_compp(scsi_phase_name(s->sstat1),
                        jmp ? '=' : '!', scsi_phase_name(insn >> 24));
                cond = (s->sstat1 & PHASE_MASK) == ((insn >> 24) & 7);
            }
            if (cond == jmp && (insn & (1 << 18))) {
                uint8_t mask;

                mask = (~insn >> 8) & 0xff;
                trace_lsi_execute_script_tc_compd(
                        s->sfbr, mask, jmp ? '=' : '!', insn & mask);
                cond = (s->sfbr & mask) == (insn & mask);
            }
            if (cond == jmp) {
                if (insn & (1 << 23)) {
                    /* Relative address.  */
                    addr = s->dsp + sextract32(addr, 0, 24);
                }
                switch ((insn >> 27) & 7) {
                case 0: /* Jump */
                    trace_lsi_execute_script_tc_jump(addr);
                    s->adder = addr;
                    s->dsp = addr;
                    break;
                case 1: /* Call */
                    trace_lsi_execute_script_tc_call(addr);
                    s->temp = s->dsp;
                    s->dsp = addr;
                    break;
                case 2: /* Return */
                    trace_lsi_execute_script_tc_return(s->temp);
                    s->dsp = s->temp;
                    break;
                case 3: /* Interrupt */
                    trace_lsi_execute_script_tc_interrupt(s->dsps);
                    if ((insn & (1 << 20)) != 0) {
                        s->istat0 |= LSI_ISTAT0_INTF;
                        lsi_update_irq(s);
                    } else {
                        lsi_script_dma_interrupt(s, LSI_DSTAT_SIR);
                    }
                    break;
                default:
                    trace_lsi_execute_script_tc_illegal();
                    lsi_script_dma_interrupt(s, LSI_DSTAT_IID);
                    break;
                }
            } else {
                trace_lsi_execute_script_tc_cc_failed();
            }
        }
        break;

    case 3:
        if ((insn & (1 << 29)) == 0) {
            /* Memory move.  */
            uint32_t dest;
            /* ??? The docs imply the destination address is loaded into
               the TEMP register.  However the Linux drivers rely on
               the value being presrved.  */
            dest = read_dword(s, s->dsp);
            s->dsp += 4;
            lsi_memcpy(s, dest, addr, insn & 0xffffff);
        } else {
            uint8_t data[7];
            int reg;
            int n;
            int i;

            if (insn & (1 << 28)) {
                addr = s->dsa + sextract32(addr, 0, 24);
            }
            n = (insn & 7);
            reg = (insn >> 16) & 0xff;
            if (insn & (1 << 24)) {
                pci_dma_read(pci_dev, addr, data, n);
                trace_lsi_execute_script_mm_load(reg, n, addr, *(int *)data);
                for (i = 0; i < n; i++) {
                    lsi_reg_writeb(s, reg + i, data[i]);
                }
            } else {
                trace_lsi_execute_script_mm_store(reg, n, addr);
                for (i = 0; i < n; i++) {
                    data[i] = lsi_reg_readb(s, reg + i);
                }
                pci_dma_write(pci_dev, addr, data, n);
            }
        }
    }
    if (insn_processed > 10000 && s->waiting == LSI_NOWAIT) {
        /* Some windows drivers make the device spin waiting for a memory
           location to change.  If we have been executed a lot of code then
           assume this is the case and force an unexpected device disconnect.
           This is apparently sufficient to beat the drivers into submission.
         */
        if (!(s->sien0 & LSI_SIST0_UDC)) {
            qemu_log_mask(LOG_GUEST_ERROR,
                          ""lsi_scsi: inf. loop with UDC masked"");
        }
        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);
        lsi_disconnect(s);
    } else if (s->istat1 & LSI_ISTAT1_SRUN && s->waiting == LSI_NOWAIT) {
        if (s->dcntl & LSI_DCNTL_SSM) {
             }
         }
     }
"
230,177966,,Remote,Single system,Complete,CVE-2017-9461,https://www.cvedetails.com/cve/CVE-2017-9461/,CWE-835,Low,,,,2017-06-06,6.8,smbd in Samba before 4.4.10 and 4.5.x before 4.5.6 has a denial of service vulnerability (fd_open_atomic infinite loop with high CPU usage and memory consumption) due to wrongly handling dangling symlinks.,2019-10-02,DoS,2,https://git.samba.org/?p=samba.git;a=commit;h=10c3e3923022485c720f322ca4f0aca5d7501310,10c3e3923022485c720f322ca4f0aca5d7501310,,0,,,"static NTSTATUS fd_open_atomic(struct connection_struct *conn,
			files_struct *fsp,
			int flags,
			mode_t mode,
                        bool *file_created)
 {
        NTSTATUS status = NT_STATUS_UNSUCCESSFUL;
       NTSTATUS retry_status;
        bool file_existed = VALID_STAT(fsp->fsp_name->st);
       int curr_flags;
 
        *file_created = false;
 
		 * We're not creating the file, just pass through.
		 */
		return fd_open(conn, fsp, flags, mode);
	}
","static NTSTATUS fd_open_atomic(struct connection_struct *conn,
			files_struct *fsp,
			int flags,
			mode_t mode,
                        bool *file_created)
 {
        NTSTATUS status = NT_STATUS_UNSUCCESSFUL;
        bool file_existed = VALID_STAT(fsp->fsp_name->st);
 
        *file_created = false;
 
		 * We're not creating the file, just pass through.
		 */
		return fd_open(conn, fsp, flags, mode);
	}
",C,"       NTSTATUS retry_status;
       int curr_flags;
",,295f757fe16d508368095936a8d3cba096bceb5d,"@@ -640,7 +640,9 @@ static NTSTATUS fd_open_atomic(struct connection_struct *conn,
                        bool *file_created)
 {
        NTSTATUS status = NT_STATUS_UNSUCCESSFUL;
+       NTSTATUS retry_status;
        bool file_existed = VALID_STAT(fsp->fsp_name->st);
+       int curr_flags;
 
        *file_created = false;
 
@@ -672,59 +674,65 @@ static NTSTATUS fd_open_atomic(struct connection_struct *conn,
         * we can never call O_CREAT without O_EXCL. So if
         * we think the file existed, try without O_CREAT|O_EXCL.
         * If we think the file didn't exist, try with
-        * O_CREAT|O_EXCL. Keep bouncing between these two
-        * requests until either the file is created, or
-        * opened. Either way, we keep going until we get
-        * a returnable result (error, or open/create).
+        * O_CREAT|O_EXCL.
+        *
+        * The big problem here is dangling symlinks. Opening
+        * without O_NOFOLLOW means both bad symlink
+        * and missing path return -1, ENOENT from open(). As POSIX
+        * is pathname based it's not possible to tell
+        * the difference between these two cases in a
+        * non-racy way, so change to try only two attempts before
+        * giving up.
+        *
+        * We don't have this problem for the O_NOFOLLOW
+        * case as it just returns NT_STATUS_OBJECT_PATH_NOT_FOUND
+        * mapped from the ELOOP POSIX error.
         */
 
-       while(1) {
-               int curr_flags = flags;
+       curr_flags = flags;
 
-               if (file_existed) {
-                       /* Just try open, do not create. */
-                       curr_flags &= ~(O_CREAT);
-                       status = fd_open(conn, fsp, curr_flags, mode);
-                       if (NT_STATUS_EQUAL(status,
-                                       NT_STATUS_OBJECT_NAME_NOT_FOUND)) {
-                               /*
-                                * Someone deleted it in the meantime.
-                                * Retry with O_EXCL.
-                                */
-                               file_existed = false;
-                               DEBUG(10,(""fd_open_atomic: file %s existed. ""
-                                       ""Retry.\n"",
-                                       smb_fname_str_dbg(fsp->fsp_name)));
-                                       continue;
-                       }
-               } else {
-                       /* Try create exclusively, fail if it exists. */
-                       curr_flags |= O_EXCL;
-                       status = fd_open(conn, fsp, curr_flags, mode);
-                       if (NT_STATUS_EQUAL(status,
-                                       NT_STATUS_OBJECT_NAME_COLLISION)) {
-                               /*
-                                * Someone created it in the meantime.
-                                * Retry without O_CREAT.
-                                */
-                               file_existed = true;
-                               DEBUG(10,(""fd_open_atomic: file %s ""
-                                       ""did not exist. Retry.\n"",
-                                       smb_fname_str_dbg(fsp->fsp_name)));
-                               continue;
-                       }
-                       if (NT_STATUS_IS_OK(status)) {
-                               /*
-                                * Here we've opened with O_CREAT|O_EXCL
-                                * and got success. We *know* we created
-                                * this file.
-                                */
-                               *file_created = true;
-                       }
+       if (file_existed) {
+               curr_flags &= ~(O_CREAT);
+               retry_status = NT_STATUS_OBJECT_NAME_NOT_FOUND;
+       } else {
+               curr_flags |= O_EXCL;
+               retry_status = NT_STATUS_OBJECT_NAME_COLLISION;
+       }
+
+       status = fd_open(conn, fsp, curr_flags, mode);
+       if (NT_STATUS_IS_OK(status)) {
+               if (!file_existed) {
+                       *file_created = true;
                }
-               /* Create is done, or failed. */
-               break;
+               return NT_STATUS_OK;
        }
+       if (!NT_STATUS_EQUAL(status, retry_status)) {
+               return status;
+       }
+
+       curr_flags = flags;
+
+       /*
+        * Keep file_existed up to date for clarity.
+        */
+       if (NT_STATUS_EQUAL(status, NT_STATUS_OBJECT_NAME_NOT_FOUND)) {
+               file_existed = false;
+               curr_flags |= O_EXCL;
+               DBG_DEBUG(""file %s did not exist. Retry.\n"",
+                       smb_fname_str_dbg(fsp->fsp_name));
+       } else {
+               file_existed = true;
+               curr_flags &= ~(O_CREAT);
+               DBG_DEBUG(""file %s existed. Retry.\n"",
+                       smb_fname_str_dbg(fsp->fsp_name));
+       }
+
+       status = fd_open(conn, fsp, curr_flags, mode);
+
+       if (NT_STATUS_IS_OK(status) && (!file_existed)) {
+               *file_created = true;
+       }
+
        return status;
 }",samba,https://git.samba.org/?p=samba.git;a=blob;f=source3/smbd/open.c;h=37c630b7e5abe4ae6b0a25a210583c73aadbc96a;hb=37c630b7e5abe4ae6b0a25a210583c73aadbc96a,https://git.samba.org/?p=samba.git;a=blob;f=source3/smbd/open.c;h=931d76df44f22d35cb6b1e0feb5bd73b04c436e3;hb=931d76df44f22d35cb6b1e0feb5bd73b04c436e3,1,"static NTSTATUS fd_open_atomic(struct connection_struct *conn,
			files_struct *fsp,
			int flags,
			mode_t mode,
                        bool *file_created)
 {
        NTSTATUS status = NT_STATUS_UNSUCCESSFUL;
//fix_flaw_line_below:
//       NTSTATUS retry_status;
        bool file_existed = VALID_STAT(fsp->fsp_name->st);
//fix_flaw_line_below:
//       int curr_flags;
 
        *file_created = false;
 
		 * We're not creating the file, just pass through.
		 */
		return fd_open(conn, fsp, flags, mode);
	}
"
231,177967,,Local,Not required,Partial,CVE-2017-9375,https://www.cvedetails.com/cve/CVE-2017-9375/,CWE-835,Medium,,,,2017-06-16,1.9,"QEMU (aka Quick Emulator), when built with USB xHCI controller emulator support, allows local guest OS privileged users to cause a denial of service (infinite recursive call) via vectors involving control transfer descriptors sequencing.",2019-10-02,DoS,3,https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c,96d87bdda3919bb16f754b3d3fd1227e1f38f13c,,0,,,"static void xhci_kick_ep(XHCIState *xhci, unsigned int slotid,
                         unsigned int epid, unsigned int streamid)
{
    XHCIEPContext *epctx;

    assert(slotid >= 1 && slotid <= xhci->numslots);
    assert(epid >= 1 && epid <= 31);

    if (!xhci->slots[slotid-1].enabled) {
        DPRINTF(""xhci: xhci_kick_ep for disabled slot %d\n"", slotid);
        return;
    }
    epctx = xhci->slots[slotid-1].eps[epid-1];
    if (!epctx) {
        DPRINTF(""xhci: xhci_kick_ep for disabled endpoint %d,%d\n"",
                epid, slotid);
        return;
         return;
     }
 
    if (epctx->kick_active) {
        return;
    }
     xhci_kick_epctx(epctx, streamid);
 }
","static void xhci_kick_ep(XHCIState *xhci, unsigned int slotid,
                         unsigned int epid, unsigned int streamid)
{
    XHCIEPContext *epctx;

    assert(slotid >= 1 && slotid <= xhci->numslots);
    assert(epid >= 1 && epid <= 31);

    if (!xhci->slots[slotid-1].enabled) {
        DPRINTF(""xhci: xhci_kick_ep for disabled slot %d\n"", slotid);
        return;
    }
    epctx = xhci->slots[slotid-1].eps[epid-1];
    if (!epctx) {
        DPRINTF(""xhci: xhci_kick_ep for disabled endpoint %d,%d\n"",
                epid, slotid);
        return;
         return;
     }
 
     xhci_kick_epctx(epctx, streamid);
 }
",C,"    if (epctx->kick_active) {
        return;
    }
",,ddb603ab6c981c1d67cb42266fc700c33e5b2d8f,"@@ -390,6 +390,7 @@ struct XHCIEPContext {
     dma_addr_t pctx;
     unsigned int max_psize;
     uint32_t state;
+    uint32_t kick_active;
 
     /* streams */
     unsigned int max_pstreams;
@@ -2131,6 +2132,9 @@ static void xhci_kick_ep(XHCIState *xhci, unsigned int slotid,
         return;
     }
 
+    if (epctx->kick_active) {
+        return;
+    }
     xhci_kick_epctx(epctx, streamid);
 }
 
@@ -2146,6 +2150,7 @@ static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid)
     int i;
 
     trace_usb_xhci_ep_kick(epctx->slotid, epctx->epid, streamid);
+    assert(!epctx->kick_active);
 
     /* If the device has been detached, but the guest has not noticed this
        yet the 2 above checks will succeed, but we must NOT continue */
@@ -2217,6 +2222,7 @@ static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid)
     }
     assert(ring->dequeue != 0);
 
+    epctx->kick_active++;
     while (1) {
         length = xhci_ring_chain_length(xhci, ring);
         if (length <= 0) {
@@ -2253,6 +2259,7 @@ static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid)
             break;
         }
     }
+    epctx->kick_active--;
 
     ep = xhci_epid_to_usbep(epctx);
     if (ep) {",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/usb/hcd-xhci.c;h=1878dad2cea6f6c3f5b386fea98f5cfa0551ec7e;hb=1878dad2cea6f6c3f5b386fea98f5cfa0551ec7e,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/usb/hcd-xhci.c;h=f89d8dafba6a99dd333093cab4de90a1b4134e63;hb=f89d8dafba6a99dd333093cab4de90a1b4134e63,1,"static void xhci_kick_ep(XHCIState *xhci, unsigned int slotid,
                         unsigned int epid, unsigned int streamid)
{
    XHCIEPContext *epctx;

    assert(slotid >= 1 && slotid <= xhci->numslots);
    assert(epid >= 1 && epid <= 31);

    if (!xhci->slots[slotid-1].enabled) {
        DPRINTF(""xhci: xhci_kick_ep for disabled slot %d\n"", slotid);
        return;
    }
    epctx = xhci->slots[slotid-1].eps[epid-1];
    if (!epctx) {
        DPRINTF(""xhci: xhci_kick_ep for disabled endpoint %d,%d\n"",
                epid, slotid);
        return;
         return;
     }
 
//fix_flaw_line_below:
//    if (epctx->kick_active) {
//fix_flaw_line_below:
//        return;
//fix_flaw_line_below:
//    }
     xhci_kick_epctx(epctx, streamid);
 }
"
234,177970,,Local,Not required,Partial,CVE-2017-9330,https://www.cvedetails.com/cve/CVE-2017-9330/,CWE-835,Medium,,,,2017-06-08,1.9,"QEMU (aka Quick Emulator) before 2.9.0, when built with the USB OHCI Emulation support, allows local guest OS users to cause a denial of service (infinite loop) by leveraging an incorrect return value, a different vulnerability than CVE-2017-6505.",2019-10-02,DoS,1,https://git.qemu.org/?p=qemu.git;a=commit;h=26f670a244982335cc08943fb1ec099a2c81e42d,26f670a244982335cc08943fb1ec099a2c81e42d,,1,,,"static int ohci_service_iso_td(OHCIState *ohci, struct ohci_ed *ed,
                               int completion)
{
    int dir;
    size_t len = 0;
    const char *str = NULL;
    int pid;
    int ret;
    int i;
    USBDevice *dev;
    USBEndpoint *ep;
    struct ohci_iso_td iso_td;
    uint32_t addr;
    uint16_t starting_frame;
    int16_t relative_frame_number;
    int frame_count;
    uint32_t start_offset, next_offset, end_offset = 0;
    uint32_t start_addr, end_addr;

    addr = ed->head & OHCI_DPTR_MASK;

     if (ohci_read_iso_td(ohci, addr, &iso_td)) {
         trace_usb_ohci_iso_td_read_failed(addr);
         ohci_die(ohci);
        return 1;
     }
 
     starting_frame = OHCI_BM(iso_td.flags, TD_SF);
    frame_count = OHCI_BM(iso_td.flags, TD_FC);
    relative_frame_number = USUB(ohci->frame_number, starting_frame); 

    trace_usb_ohci_iso_td_head(
           ed->head & OHCI_DPTR_MASK, ed->tail & OHCI_DPTR_MASK,
           iso_td.flags, iso_td.bp, iso_td.next, iso_td.be,
           ohci->frame_number, starting_frame,
           frame_count, relative_frame_number);
    trace_usb_ohci_iso_td_head_offset(
           iso_td.offset[0], iso_td.offset[1],
           iso_td.offset[2], iso_td.offset[3],
           iso_td.offset[4], iso_td.offset[5],
           iso_td.offset[6], iso_td.offset[7]);

    if (relative_frame_number < 0) {
        trace_usb_ohci_iso_td_relative_frame_number_neg(relative_frame_number);
        return 1;
    } else if (relative_frame_number > frame_count) {
        /* ISO TD expired - retire the TD to the Done Queue and continue with
           the next ISO TD of the same ED */
        trace_usb_ohci_iso_td_relative_frame_number_big(relative_frame_number,
                                                        frame_count);
        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_DATAOVERRUN);
        ed->head &= ~OHCI_DPTR_MASK;
        ed->head |= (iso_td.next & OHCI_DPTR_MASK);
        iso_td.next = ohci->done;
        ohci->done = addr;
        i = OHCI_BM(iso_td.flags, TD_DI);
        if (i < ohci->done_count)
            ohci->done_count = i;
        if (ohci_put_iso_td(ohci, addr, &iso_td)) {
            ohci_die(ohci);
            return 1;
        }
        return 0;
    }

    dir = OHCI_BM(ed->flags, ED_D);
    switch (dir) {
    case OHCI_TD_DIR_IN:
        str = ""in"";
        pid = USB_TOKEN_IN;
        break;
    case OHCI_TD_DIR_OUT:
        str = ""out"";
        pid = USB_TOKEN_OUT;
        break;
    case OHCI_TD_DIR_SETUP:
        str = ""setup"";
        pid = USB_TOKEN_SETUP;
        break;
    default:
        trace_usb_ohci_iso_td_bad_direction(dir);
        return 1;
    }

    if (!iso_td.bp || !iso_td.be) {
        trace_usb_ohci_iso_td_bad_bp_be(iso_td.bp, iso_td.be);
        return 1;
    }

    start_offset = iso_td.offset[relative_frame_number];
    next_offset = iso_td.offset[relative_frame_number + 1];

    if (!(OHCI_BM(start_offset, TD_PSW_CC) & 0xe) || 
        ((relative_frame_number < frame_count) && 
         !(OHCI_BM(next_offset, TD_PSW_CC) & 0xe))) {
        trace_usb_ohci_iso_td_bad_cc_not_accessed(start_offset, next_offset);
        return 1;
    }

    if ((relative_frame_number < frame_count) && (start_offset > next_offset)) {
        trace_usb_ohci_iso_td_bad_cc_overrun(start_offset, next_offset);
        return 1;
    }

    if ((start_offset & 0x1000) == 0) {
        start_addr = (iso_td.bp & OHCI_PAGE_MASK) |
            (start_offset & OHCI_OFFSET_MASK);
    } else {
        start_addr = (iso_td.be & OHCI_PAGE_MASK) |
            (start_offset & OHCI_OFFSET_MASK);
    }

    if (relative_frame_number < frame_count) {
        end_offset = next_offset - 1;
        if ((end_offset & 0x1000) == 0) {
            end_addr = (iso_td.bp & OHCI_PAGE_MASK) |
                (end_offset & OHCI_OFFSET_MASK);
        } else {
            end_addr = (iso_td.be & OHCI_PAGE_MASK) |
                (end_offset & OHCI_OFFSET_MASK);
        }
    } else {
        /* Last packet in the ISO TD */
        end_addr = iso_td.be;
    }

    if ((start_addr & OHCI_PAGE_MASK) != (end_addr & OHCI_PAGE_MASK)) {
        len = (end_addr & OHCI_OFFSET_MASK) + 0x1001
            - (start_addr & OHCI_OFFSET_MASK);
    } else {
        len = end_addr - start_addr + 1;
    }

    if (len && dir != OHCI_TD_DIR_IN) {
        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, len,
                             DMA_DIRECTION_TO_DEVICE)) {
            ohci_die(ohci);
            return 1;
        }
    }

    if (!completion) {
        bool int_req = relative_frame_number == frame_count &&
                       OHCI_BM(iso_td.flags, TD_DI) == 0;
        dev = ohci_find_device(ohci, OHCI_BM(ed->flags, ED_FA));
        ep = usb_ep_get(dev, pid, OHCI_BM(ed->flags, ED_EN));
        usb_packet_setup(&ohci->usb_packet, pid, ep, 0, addr, false, int_req);
        usb_packet_addbuf(&ohci->usb_packet, ohci->usb_buf, len);
        usb_handle_packet(dev, &ohci->usb_packet);
        if (ohci->usb_packet.status == USB_RET_ASYNC) {
            usb_device_flush_ep_queue(dev, ep);
            return 1;
        }
    }
    if (ohci->usb_packet.status == USB_RET_SUCCESS) {
        ret = ohci->usb_packet.actual_length;
    } else {
        ret = ohci->usb_packet.status;
    }

    trace_usb_ohci_iso_td_so(start_offset, end_offset, start_addr, end_addr,
                             str, len, ret);

    /* Writeback */
    if (dir == OHCI_TD_DIR_IN && ret >= 0 && ret <= len) {
        /* IN transfer succeeded */
        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, ret,
                             DMA_DIRECTION_FROM_DEVICE)) {
            ohci_die(ohci);
            return 1;
        }
        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,
                    OHCI_CC_NOERROR);
        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, ret);
    } else if (dir == OHCI_TD_DIR_OUT && ret == len) {
        /* OUT transfer succeeded */
        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,
                    OHCI_CC_NOERROR);
        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, 0);
    } else {
        if (ret > (ssize_t) len) {
            trace_usb_ohci_iso_td_data_overrun(ret, len);
            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,
                        OHCI_CC_DATAOVERRUN);
            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,
                        len);
        } else if (ret >= 0) {
            trace_usb_ohci_iso_td_data_underrun(ret);
            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,
                        OHCI_CC_DATAUNDERRUN);
        } else {
            switch (ret) {
            case USB_RET_IOERROR:
            case USB_RET_NODEV:
                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,
                            OHCI_CC_DEVICENOTRESPONDING);
                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,
                            0);
                break;
            case USB_RET_NAK:
            case USB_RET_STALL:
                trace_usb_ohci_iso_td_nak(ret);
                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,
                            OHCI_CC_STALL);
                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,
                            0);
                break;
            default:
                trace_usb_ohci_iso_td_bad_response(ret);
                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,
                            OHCI_CC_UNDEXPETEDPID);
                break;
            }
        }
    }

    if (relative_frame_number == frame_count) {
        /* Last data packet of ISO TD - retire the TD to the Done Queue */
        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_NOERROR);
        ed->head &= ~OHCI_DPTR_MASK;
        ed->head |= (iso_td.next & OHCI_DPTR_MASK);
        iso_td.next = ohci->done;
        ohci->done = addr;
        i = OHCI_BM(iso_td.flags, TD_DI);
        if (i < ohci->done_count)
            ohci->done_count = i;
    }
    if (ohci_put_iso_td(ohci, addr, &iso_td)) {
        ohci_die(ohci);
    }
    return 1;
}
","static int ohci_service_iso_td(OHCIState *ohci, struct ohci_ed *ed,
                               int completion)
{
    int dir;
    size_t len = 0;
    const char *str = NULL;
    int pid;
    int ret;
    int i;
    USBDevice *dev;
    USBEndpoint *ep;
    struct ohci_iso_td iso_td;
    uint32_t addr;
    uint16_t starting_frame;
    int16_t relative_frame_number;
    int frame_count;
    uint32_t start_offset, next_offset, end_offset = 0;
    uint32_t start_addr, end_addr;

    addr = ed->head & OHCI_DPTR_MASK;

     if (ohci_read_iso_td(ohci, addr, &iso_td)) {
         trace_usb_ohci_iso_td_read_failed(addr);
         ohci_die(ohci);
        return 0;
     }
 
     starting_frame = OHCI_BM(iso_td.flags, TD_SF);
    frame_count = OHCI_BM(iso_td.flags, TD_FC);
    relative_frame_number = USUB(ohci->frame_number, starting_frame); 

    trace_usb_ohci_iso_td_head(
           ed->head & OHCI_DPTR_MASK, ed->tail & OHCI_DPTR_MASK,
           iso_td.flags, iso_td.bp, iso_td.next, iso_td.be,
           ohci->frame_number, starting_frame,
           frame_count, relative_frame_number);
    trace_usb_ohci_iso_td_head_offset(
           iso_td.offset[0], iso_td.offset[1],
           iso_td.offset[2], iso_td.offset[3],
           iso_td.offset[4], iso_td.offset[5],
           iso_td.offset[6], iso_td.offset[7]);

    if (relative_frame_number < 0) {
        trace_usb_ohci_iso_td_relative_frame_number_neg(relative_frame_number);
        return 1;
    } else if (relative_frame_number > frame_count) {
        /* ISO TD expired - retire the TD to the Done Queue and continue with
           the next ISO TD of the same ED */
        trace_usb_ohci_iso_td_relative_frame_number_big(relative_frame_number,
                                                        frame_count);
        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_DATAOVERRUN);
        ed->head &= ~OHCI_DPTR_MASK;
        ed->head |= (iso_td.next & OHCI_DPTR_MASK);
        iso_td.next = ohci->done;
        ohci->done = addr;
        i = OHCI_BM(iso_td.flags, TD_DI);
        if (i < ohci->done_count)
            ohci->done_count = i;
        if (ohci_put_iso_td(ohci, addr, &iso_td)) {
            ohci_die(ohci);
            return 1;
        }
        return 0;
    }

    dir = OHCI_BM(ed->flags, ED_D);
    switch (dir) {
    case OHCI_TD_DIR_IN:
        str = ""in"";
        pid = USB_TOKEN_IN;
        break;
    case OHCI_TD_DIR_OUT:
        str = ""out"";
        pid = USB_TOKEN_OUT;
        break;
    case OHCI_TD_DIR_SETUP:
        str = ""setup"";
        pid = USB_TOKEN_SETUP;
        break;
    default:
        trace_usb_ohci_iso_td_bad_direction(dir);
        return 1;
    }

    if (!iso_td.bp || !iso_td.be) {
        trace_usb_ohci_iso_td_bad_bp_be(iso_td.bp, iso_td.be);
        return 1;
    }

    start_offset = iso_td.offset[relative_frame_number];
    next_offset = iso_td.offset[relative_frame_number + 1];

    if (!(OHCI_BM(start_offset, TD_PSW_CC) & 0xe) || 
        ((relative_frame_number < frame_count) && 
         !(OHCI_BM(next_offset, TD_PSW_CC) & 0xe))) {
        trace_usb_ohci_iso_td_bad_cc_not_accessed(start_offset, next_offset);
        return 1;
    }

    if ((relative_frame_number < frame_count) && (start_offset > next_offset)) {
        trace_usb_ohci_iso_td_bad_cc_overrun(start_offset, next_offset);
        return 1;
    }

    if ((start_offset & 0x1000) == 0) {
        start_addr = (iso_td.bp & OHCI_PAGE_MASK) |
            (start_offset & OHCI_OFFSET_MASK);
    } else {
        start_addr = (iso_td.be & OHCI_PAGE_MASK) |
            (start_offset & OHCI_OFFSET_MASK);
    }

    if (relative_frame_number < frame_count) {
        end_offset = next_offset - 1;
        if ((end_offset & 0x1000) == 0) {
            end_addr = (iso_td.bp & OHCI_PAGE_MASK) |
                (end_offset & OHCI_OFFSET_MASK);
        } else {
            end_addr = (iso_td.be & OHCI_PAGE_MASK) |
                (end_offset & OHCI_OFFSET_MASK);
        }
    } else {
        /* Last packet in the ISO TD */
        end_addr = iso_td.be;
    }

    if ((start_addr & OHCI_PAGE_MASK) != (end_addr & OHCI_PAGE_MASK)) {
        len = (end_addr & OHCI_OFFSET_MASK) + 0x1001
            - (start_addr & OHCI_OFFSET_MASK);
    } else {
        len = end_addr - start_addr + 1;
    }

    if (len && dir != OHCI_TD_DIR_IN) {
        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, len,
                             DMA_DIRECTION_TO_DEVICE)) {
            ohci_die(ohci);
            return 1;
        }
    }

    if (!completion) {
        bool int_req = relative_frame_number == frame_count &&
                       OHCI_BM(iso_td.flags, TD_DI) == 0;
        dev = ohci_find_device(ohci, OHCI_BM(ed->flags, ED_FA));
        ep = usb_ep_get(dev, pid, OHCI_BM(ed->flags, ED_EN));
        usb_packet_setup(&ohci->usb_packet, pid, ep, 0, addr, false, int_req);
        usb_packet_addbuf(&ohci->usb_packet, ohci->usb_buf, len);
        usb_handle_packet(dev, &ohci->usb_packet);
        if (ohci->usb_packet.status == USB_RET_ASYNC) {
            usb_device_flush_ep_queue(dev, ep);
            return 1;
        }
    }
    if (ohci->usb_packet.status == USB_RET_SUCCESS) {
        ret = ohci->usb_packet.actual_length;
    } else {
        ret = ohci->usb_packet.status;
    }

    trace_usb_ohci_iso_td_so(start_offset, end_offset, start_addr, end_addr,
                             str, len, ret);

    /* Writeback */
    if (dir == OHCI_TD_DIR_IN && ret >= 0 && ret <= len) {
        /* IN transfer succeeded */
        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, ret,
                             DMA_DIRECTION_FROM_DEVICE)) {
            ohci_die(ohci);
            return 1;
        }
        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,
                    OHCI_CC_NOERROR);
        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, ret);
    } else if (dir == OHCI_TD_DIR_OUT && ret == len) {
        /* OUT transfer succeeded */
        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,
                    OHCI_CC_NOERROR);
        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, 0);
    } else {
        if (ret > (ssize_t) len) {
            trace_usb_ohci_iso_td_data_overrun(ret, len);
            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,
                        OHCI_CC_DATAOVERRUN);
            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,
                        len);
        } else if (ret >= 0) {
            trace_usb_ohci_iso_td_data_underrun(ret);
            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,
                        OHCI_CC_DATAUNDERRUN);
        } else {
            switch (ret) {
            case USB_RET_IOERROR:
            case USB_RET_NODEV:
                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,
                            OHCI_CC_DEVICENOTRESPONDING);
                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,
                            0);
                break;
            case USB_RET_NAK:
            case USB_RET_STALL:
                trace_usb_ohci_iso_td_nak(ret);
                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,
                            OHCI_CC_STALL);
                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,
                            0);
                break;
            default:
                trace_usb_ohci_iso_td_bad_response(ret);
                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,
                            OHCI_CC_UNDEXPETEDPID);
                break;
            }
        }
    }

    if (relative_frame_number == frame_count) {
        /* Last data packet of ISO TD - retire the TD to the Done Queue */
        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_NOERROR);
        ed->head &= ~OHCI_DPTR_MASK;
        ed->head |= (iso_td.next & OHCI_DPTR_MASK);
        iso_td.next = ohci->done;
        ohci->done = addr;
        i = OHCI_BM(iso_td.flags, TD_DI);
        if (i < ohci->done_count)
            ohci->done_count = i;
    }
    if (ohci_put_iso_td(ohci, addr, &iso_td)) {
        ohci_die(ohci);
    }
    return 1;
}
",C,"        return 1;
","        return 0;
",d710e1e7bd3d5bfc26b631f02ae87901ebe646b0,"@@ -725,7 +725,7 @@ static int ohci_service_iso_td(OHCIState *ohci, struct ohci_ed *ed,
     if (ohci_read_iso_td(ohci, addr, &iso_td)) {
         trace_usb_ohci_iso_td_read_failed(addr);
         ohci_die(ohci);
-        return 0;
+        return 1;
     }
 
     starting_frame = OHCI_BM(iso_td.flags, TD_SF);",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/usb/hcd-ohci.c;h=2cba3e3b5b484711fe9977e781057e6905cffb2c;hb=2cba3e3b5b484711fe9977e781057e6905cffb2c,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/usb/hcd-ohci.c;h=c82a92fff73eb3e605496c8b8008a691fac83435;hb=c82a92fff73eb3e605496c8b8008a691fac83435,1,"static int ohci_service_iso_td(OHCIState *ohci, struct ohci_ed *ed,
                               int completion)
{
    int dir;
    size_t len = 0;
    const char *str = NULL;
    int pid;
    int ret;
    int i;
    USBDevice *dev;
    USBEndpoint *ep;
    struct ohci_iso_td iso_td;
    uint32_t addr;
    uint16_t starting_frame;
    int16_t relative_frame_number;
    int frame_count;
    uint32_t start_offset, next_offset, end_offset = 0;
    uint32_t start_addr, end_addr;

    addr = ed->head & OHCI_DPTR_MASK;

     if (ohci_read_iso_td(ohci, addr, &iso_td)) {
         trace_usb_ohci_iso_td_read_failed(addr);
         ohci_die(ohci);
//flaw_line_below:
        return 0;
//fix_flaw_line_below:
//        return 1;
     }
 
     starting_frame = OHCI_BM(iso_td.flags, TD_SF);
    frame_count = OHCI_BM(iso_td.flags, TD_FC);
    relative_frame_number = USUB(ohci->frame_number, starting_frame); 

    trace_usb_ohci_iso_td_head(
           ed->head & OHCI_DPTR_MASK, ed->tail & OHCI_DPTR_MASK,
           iso_td.flags, iso_td.bp, iso_td.next, iso_td.be,
           ohci->frame_number, starting_frame,
           frame_count, relative_frame_number);
    trace_usb_ohci_iso_td_head_offset(
           iso_td.offset[0], iso_td.offset[1],
           iso_td.offset[2], iso_td.offset[3],
           iso_td.offset[4], iso_td.offset[5],
           iso_td.offset[6], iso_td.offset[7]);

    if (relative_frame_number < 0) {
        trace_usb_ohci_iso_td_relative_frame_number_neg(relative_frame_number);
        return 1;
    } else if (relative_frame_number > frame_count) {
        /* ISO TD expired - retire the TD to the Done Queue and continue with
           the next ISO TD of the same ED */
        trace_usb_ohci_iso_td_relative_frame_number_big(relative_frame_number,
                                                        frame_count);
        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_DATAOVERRUN);
        ed->head &= ~OHCI_DPTR_MASK;
        ed->head |= (iso_td.next & OHCI_DPTR_MASK);
        iso_td.next = ohci->done;
        ohci->done = addr;
        i = OHCI_BM(iso_td.flags, TD_DI);
        if (i < ohci->done_count)
            ohci->done_count = i;
        if (ohci_put_iso_td(ohci, addr, &iso_td)) {
            ohci_die(ohci);
            return 1;
        }
        return 0;
    }

    dir = OHCI_BM(ed->flags, ED_D);
    switch (dir) {
    case OHCI_TD_DIR_IN:
        str = ""in"";
        pid = USB_TOKEN_IN;
        break;
    case OHCI_TD_DIR_OUT:
        str = ""out"";
        pid = USB_TOKEN_OUT;
        break;
    case OHCI_TD_DIR_SETUP:
        str = ""setup"";
        pid = USB_TOKEN_SETUP;
        break;
    default:
        trace_usb_ohci_iso_td_bad_direction(dir);
        return 1;
    }

    if (!iso_td.bp || !iso_td.be) {
        trace_usb_ohci_iso_td_bad_bp_be(iso_td.bp, iso_td.be);
        return 1;
    }

    start_offset = iso_td.offset[relative_frame_number];
    next_offset = iso_td.offset[relative_frame_number + 1];

    if (!(OHCI_BM(start_offset, TD_PSW_CC) & 0xe) || 
        ((relative_frame_number < frame_count) && 
         !(OHCI_BM(next_offset, TD_PSW_CC) & 0xe))) {
        trace_usb_ohci_iso_td_bad_cc_not_accessed(start_offset, next_offset);
        return 1;
    }

    if ((relative_frame_number < frame_count) && (start_offset > next_offset)) {
        trace_usb_ohci_iso_td_bad_cc_overrun(start_offset, next_offset);
        return 1;
    }

    if ((start_offset & 0x1000) == 0) {
        start_addr = (iso_td.bp & OHCI_PAGE_MASK) |
            (start_offset & OHCI_OFFSET_MASK);
    } else {
        start_addr = (iso_td.be & OHCI_PAGE_MASK) |
            (start_offset & OHCI_OFFSET_MASK);
    }

    if (relative_frame_number < frame_count) {
        end_offset = next_offset - 1;
        if ((end_offset & 0x1000) == 0) {
            end_addr = (iso_td.bp & OHCI_PAGE_MASK) |
                (end_offset & OHCI_OFFSET_MASK);
        } else {
            end_addr = (iso_td.be & OHCI_PAGE_MASK) |
                (end_offset & OHCI_OFFSET_MASK);
        }
    } else {
        /* Last packet in the ISO TD */
        end_addr = iso_td.be;
    }

    if ((start_addr & OHCI_PAGE_MASK) != (end_addr & OHCI_PAGE_MASK)) {
        len = (end_addr & OHCI_OFFSET_MASK) + 0x1001
            - (start_addr & OHCI_OFFSET_MASK);
    } else {
        len = end_addr - start_addr + 1;
    }

    if (len && dir != OHCI_TD_DIR_IN) {
        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, len,
                             DMA_DIRECTION_TO_DEVICE)) {
            ohci_die(ohci);
            return 1;
        }
    }

    if (!completion) {
        bool int_req = relative_frame_number == frame_count &&
                       OHCI_BM(iso_td.flags, TD_DI) == 0;
        dev = ohci_find_device(ohci, OHCI_BM(ed->flags, ED_FA));
        ep = usb_ep_get(dev, pid, OHCI_BM(ed->flags, ED_EN));
        usb_packet_setup(&ohci->usb_packet, pid, ep, 0, addr, false, int_req);
        usb_packet_addbuf(&ohci->usb_packet, ohci->usb_buf, len);
        usb_handle_packet(dev, &ohci->usb_packet);
        if (ohci->usb_packet.status == USB_RET_ASYNC) {
            usb_device_flush_ep_queue(dev, ep);
            return 1;
        }
    }
    if (ohci->usb_packet.status == USB_RET_SUCCESS) {
        ret = ohci->usb_packet.actual_length;
    } else {
        ret = ohci->usb_packet.status;
    }

    trace_usb_ohci_iso_td_so(start_offset, end_offset, start_addr, end_addr,
                             str, len, ret);

    /* Writeback */
    if (dir == OHCI_TD_DIR_IN && ret >= 0 && ret <= len) {
        /* IN transfer succeeded */
        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, ret,
                             DMA_DIRECTION_FROM_DEVICE)) {
            ohci_die(ohci);
            return 1;
        }
        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,
                    OHCI_CC_NOERROR);
        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, ret);
    } else if (dir == OHCI_TD_DIR_OUT && ret == len) {
        /* OUT transfer succeeded */
        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,
                    OHCI_CC_NOERROR);
        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, 0);
    } else {
        if (ret > (ssize_t) len) {
            trace_usb_ohci_iso_td_data_overrun(ret, len);
            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,
                        OHCI_CC_DATAOVERRUN);
            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,
                        len);
        } else if (ret >= 0) {
            trace_usb_ohci_iso_td_data_underrun(ret);
            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,
                        OHCI_CC_DATAUNDERRUN);
        } else {
            switch (ret) {
            case USB_RET_IOERROR:
            case USB_RET_NODEV:
                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,
                            OHCI_CC_DEVICENOTRESPONDING);
                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,
                            0);
                break;
            case USB_RET_NAK:
            case USB_RET_STALL:
                trace_usb_ohci_iso_td_nak(ret);
                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,
                            OHCI_CC_STALL);
                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,
                            0);
                break;
            default:
                trace_usb_ohci_iso_td_bad_response(ret);
                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,
                            OHCI_CC_UNDEXPETEDPID);
                break;
            }
        }
    }

    if (relative_frame_number == frame_count) {
        /* Last data packet of ISO TD - retire the TD to the Done Queue */
        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_NOERROR);
        ed->head &= ~OHCI_DPTR_MASK;
        ed->head |= (iso_td.next & OHCI_DPTR_MASK);
        iso_td.next = ohci->done;
        ohci->done = addr;
        i = OHCI_BM(iso_td.flags, TD_DI);
        if (i < ohci->done_count)
            ohci->done_count = i;
    }
    if (ohci_put_iso_td(ohci, addr, &iso_td)) {
        ohci_die(ohci);
    }
    return 1;
}
"
235,177971,,Local,Not required,Partial,CVE-2017-9310,https://www.cvedetails.com/cve/CVE-2017-9310/,CWE-835,Medium,,,,2017-06-08,1.9,"QEMU (aka Quick Emulator), when built with the e1000e NIC emulation support, allows local guest OS privileged users to cause a denial of service (infinite loop) via vectors related to setting the initial receive / transmit descriptor head (TDH/RDH) outside the allocated descriptor buffer.",2019-10-02,DoS,2,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7,4154c7e03fa55b4cf52509a83d50d6c09d743b77,,1,,," e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)
 {
    return core->mac[r->dh] == core->mac[r->dt] ||
                core->mac[r->dt] >= core->mac[r->dlen] / E1000_RING_DESC_LEN;
 }
"," e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)
 {
    return core->mac[r->dh] == core->mac[r->dt];
 }
",C,"    return core->mac[r->dh] == core->mac[r->dt] ||
                core->mac[r->dt] >= core->mac[r->dlen] / E1000_RING_DESC_LEN;
","    return core->mac[r->dh] == core->mac[r->dt];
",81f17e0d435c3db3a3e67e0d32ebf9c98973211f,"@@ -806,7 +806,8 @@ typedef struct E1000E_RingInfo_st {
 static inline bool
 e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)
 {
-    return core->mac[r->dh] == core->mac[r->dt];
+    return core->mac[r->dh] == core->mac[r->dt] ||
+                core->mac[r->dt] >= core->mac[r->dlen] / E1000_RING_DESC_LEN;
 }
 
 static inline uint64_t
@@ -1522,6 +1523,10 @@ e1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt,
             desc_size = core->rx_desc_buf_size;
         }
 
+        if (e1000e_ring_empty(core, rxi)) {
+            return;
+        }
+
         base = e1000e_ring_head_descr(core, rxi);
 
         pci_dma_read(d, base, &desc, core->rx_desc_len);",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/net/e1000e_core.c;h=28c5be1506563d62f0afa7608bfcd854c76e9269;hb=4154c7e03fa55b4cf52509a83d50d6c09d743b7,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/net/e1000e_core.c;h=c99e2fbd625d29aeba04796890fe4c44fcf85021,1," e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)
 {
//flaw_line_below:
    return core->mac[r->dh] == core->mac[r->dt];
//fix_flaw_line_below:
//    return core->mac[r->dh] == core->mac[r->dt] ||
//fix_flaw_line_below:
//                core->mac[r->dt] >= core->mac[r->dlen] / E1000_RING_DESC_LEN;
 }
"
236,177972,,Local,Not required,Partial,CVE-2017-9310,https://www.cvedetails.com/cve/CVE-2017-9310/,CWE-835,Medium,,,,2017-06-08,1.9,"QEMU (aka Quick Emulator), when built with the e1000e NIC emulation support, allows local guest OS privileged users to cause a denial of service (infinite loop) via vectors related to setting the initial receive / transmit descriptor head (TDH/RDH) outside the allocated descriptor buffer.",2019-10-02,DoS,4,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7,4154c7e03fa55b4cf52509a83d50d6c09d743b77,,0,,,"e1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt,
                             const E1000E_RxRing *rxr,
                             const E1000E_RSSInfo *rss_info)
{
    PCIDevice *d = core->owner;
    dma_addr_t base;
    uint8_t desc[E1000_MAX_RX_DESC_LEN];
    size_t desc_size;
    size_t desc_offset = 0;
    size_t iov_ofs = 0;

    struct iovec *iov = net_rx_pkt_get_iovec(pkt);
    size_t size = net_rx_pkt_get_total_len(pkt);
    size_t total_size = size + e1000x_fcs_len(core->mac);
    const E1000E_RingInfo *rxi;
    size_t ps_hdr_len = 0;
    bool do_ps = e1000e_do_ps(core, pkt, &ps_hdr_len);
    bool is_first = true;

    rxi = rxr->i;

    do {
        hwaddr ba[MAX_PS_BUFFERS];
        e1000e_ba_state bastate = { { 0 } };
        bool is_last = false;

        desc_size = total_size - desc_offset;

        if (desc_size > core->rx_desc_buf_size) {
            desc_size = core->rx_desc_buf_size;
             desc_size = core->rx_desc_buf_size;
         }
 
        if (e1000e_ring_empty(core, rxi)) {
            return;
        }

         base = e1000e_ring_head_descr(core, rxi);
 
         pci_dma_read(d, base, &desc, core->rx_desc_len);
        if (ba[0]) {
            if (desc_offset < size) {
                static const uint32_t fcs_pad;
                size_t iov_copy;
                size_t copy_size = size - desc_offset;
                if (copy_size > core->rx_desc_buf_size) {
                    copy_size = core->rx_desc_buf_size;
                }

                /* For PS mode copy the packet header first */
                if (do_ps) {
                    if (is_first) {
                        size_t ps_hdr_copied = 0;
                        do {
                            iov_copy = MIN(ps_hdr_len - ps_hdr_copied,
                                           iov->iov_len - iov_ofs);

                            e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,
                                                      iov->iov_base, iov_copy);

                            copy_size -= iov_copy;
                            ps_hdr_copied += iov_copy;

                            iov_ofs += iov_copy;
                            if (iov_ofs == iov->iov_len) {
                                iov++;
                                iov_ofs = 0;
                            }
                        } while (ps_hdr_copied < ps_hdr_len);

                        is_first = false;
                    } else {
                        /* Leave buffer 0 of each descriptor except first */
                        /* empty as per spec 7.1.5.1                      */
                        e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,
                                                       NULL, 0);
                    }
                }

                /* Copy packet payload */
                while (copy_size) {
                    iov_copy = MIN(copy_size, iov->iov_len - iov_ofs);

                    e1000e_write_to_rx_buffers(core, &ba, &bastate,
                                            iov->iov_base + iov_ofs, iov_copy);

                    copy_size -= iov_copy;
                    iov_ofs += iov_copy;
                    if (iov_ofs == iov->iov_len) {
                        iov++;
                        iov_ofs = 0;
                    }
                }

                if (desc_offset + desc_size >= total_size) {
                    /* Simulate FCS checksum presence in the last descriptor */
                    e1000e_write_to_rx_buffers(core, &ba, &bastate,
                          (const char *) &fcs_pad, e1000x_fcs_len(core->mac));
                }
            }
            desc_offset += desc_size;
            if (desc_offset >= total_size) {
                is_last = true;
            }
        } else { /* as per intel docs; skip descriptors with null buf addr */
            trace_e1000e_rx_null_descriptor();
        }

        e1000e_write_rx_descr(core, desc, is_last ? core->rx_pkt : NULL,
                           rss_info, do_ps ? ps_hdr_len : 0, &bastate.written);
        pci_dma_write(d, base, &desc, core->rx_desc_len);

        e1000e_ring_advance(core, rxi,
                            core->rx_desc_len / E1000_MIN_RX_DESC_LEN);

    } while (desc_offset < total_size);

    e1000e_update_rx_stats(core, size, total_size);
}
","e1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt,
                             const E1000E_RxRing *rxr,
                             const E1000E_RSSInfo *rss_info)
{
    PCIDevice *d = core->owner;
    dma_addr_t base;
    uint8_t desc[E1000_MAX_RX_DESC_LEN];
    size_t desc_size;
    size_t desc_offset = 0;
    size_t iov_ofs = 0;

    struct iovec *iov = net_rx_pkt_get_iovec(pkt);
    size_t size = net_rx_pkt_get_total_len(pkt);
    size_t total_size = size + e1000x_fcs_len(core->mac);
    const E1000E_RingInfo *rxi;
    size_t ps_hdr_len = 0;
    bool do_ps = e1000e_do_ps(core, pkt, &ps_hdr_len);
    bool is_first = true;

    rxi = rxr->i;

    do {
        hwaddr ba[MAX_PS_BUFFERS];
        e1000e_ba_state bastate = { { 0 } };
        bool is_last = false;

        desc_size = total_size - desc_offset;

        if (desc_size > core->rx_desc_buf_size) {
            desc_size = core->rx_desc_buf_size;
             desc_size = core->rx_desc_buf_size;
         }
 
         base = e1000e_ring_head_descr(core, rxi);
 
         pci_dma_read(d, base, &desc, core->rx_desc_len);
        if (ba[0]) {
            if (desc_offset < size) {
                static const uint32_t fcs_pad;
                size_t iov_copy;
                size_t copy_size = size - desc_offset;
                if (copy_size > core->rx_desc_buf_size) {
                    copy_size = core->rx_desc_buf_size;
                }

                /* For PS mode copy the packet header first */
                if (do_ps) {
                    if (is_first) {
                        size_t ps_hdr_copied = 0;
                        do {
                            iov_copy = MIN(ps_hdr_len - ps_hdr_copied,
                                           iov->iov_len - iov_ofs);

                            e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,
                                                      iov->iov_base, iov_copy);

                            copy_size -= iov_copy;
                            ps_hdr_copied += iov_copy;

                            iov_ofs += iov_copy;
                            if (iov_ofs == iov->iov_len) {
                                iov++;
                                iov_ofs = 0;
                            }
                        } while (ps_hdr_copied < ps_hdr_len);

                        is_first = false;
                    } else {
                        /* Leave buffer 0 of each descriptor except first */
                        /* empty as per spec 7.1.5.1                      */
                        e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,
                                                       NULL, 0);
                    }
                }

                /* Copy packet payload */
                while (copy_size) {
                    iov_copy = MIN(copy_size, iov->iov_len - iov_ofs);

                    e1000e_write_to_rx_buffers(core, &ba, &bastate,
                                            iov->iov_base + iov_ofs, iov_copy);

                    copy_size -= iov_copy;
                    iov_ofs += iov_copy;
                    if (iov_ofs == iov->iov_len) {
                        iov++;
                        iov_ofs = 0;
                    }
                }

                if (desc_offset + desc_size >= total_size) {
                    /* Simulate FCS checksum presence in the last descriptor */
                    e1000e_write_to_rx_buffers(core, &ba, &bastate,
                          (const char *) &fcs_pad, e1000x_fcs_len(core->mac));
                }
            }
            desc_offset += desc_size;
            if (desc_offset >= total_size) {
                is_last = true;
            }
        } else { /* as per intel docs; skip descriptors with null buf addr */
            trace_e1000e_rx_null_descriptor();
        }

        e1000e_write_rx_descr(core, desc, is_last ? core->rx_pkt : NULL,
                           rss_info, do_ps ? ps_hdr_len : 0, &bastate.written);
        pci_dma_write(d, base, &desc, core->rx_desc_len);

        e1000e_ring_advance(core, rxi,
                            core->rx_desc_len / E1000_MIN_RX_DESC_LEN);

    } while (desc_offset < total_size);

    e1000e_update_rx_stats(core, size, total_size);
}
",C,"        if (e1000e_ring_empty(core, rxi)) {
            return;
        }

",,81f17e0d435c3db3a3e67e0d32ebf9c98973211f,"@@ -806,7 +806,8 @@ typedef struct E1000E_RingInfo_st {
 static inline bool
 e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)
 {
-    return core->mac[r->dh] == core->mac[r->dt];
+    return core->mac[r->dh] == core->mac[r->dt] ||
+                core->mac[r->dt] >= core->mac[r->dlen] / E1000_RING_DESC_LEN;
 }
 
 static inline uint64_t
@@ -1522,6 +1523,10 @@ e1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt,
             desc_size = core->rx_desc_buf_size;
         }
 
+        if (e1000e_ring_empty(core, rxi)) {
+            return;
+        }
+
         base = e1000e_ring_head_descr(core, rxi);
 
         pci_dma_read(d, base, &desc, core->rx_desc_len);",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/net/e1000e_core.c;h=28c5be1506563d62f0afa7608bfcd854c76e9269;hb=4154c7e03fa55b4cf52509a83d50d6c09d743b7,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/net/e1000e_core.c;h=c99e2fbd625d29aeba04796890fe4c44fcf85021,1,"e1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt,
                             const E1000E_RxRing *rxr,
                             const E1000E_RSSInfo *rss_info)
{
    PCIDevice *d = core->owner;
    dma_addr_t base;
    uint8_t desc[E1000_MAX_RX_DESC_LEN];
    size_t desc_size;
    size_t desc_offset = 0;
    size_t iov_ofs = 0;

    struct iovec *iov = net_rx_pkt_get_iovec(pkt);
    size_t size = net_rx_pkt_get_total_len(pkt);
    size_t total_size = size + e1000x_fcs_len(core->mac);
    const E1000E_RingInfo *rxi;
    size_t ps_hdr_len = 0;
    bool do_ps = e1000e_do_ps(core, pkt, &ps_hdr_len);
    bool is_first = true;

    rxi = rxr->i;

    do {
        hwaddr ba[MAX_PS_BUFFERS];
        e1000e_ba_state bastate = { { 0 } };
        bool is_last = false;

        desc_size = total_size - desc_offset;

        if (desc_size > core->rx_desc_buf_size) {
            desc_size = core->rx_desc_buf_size;
             desc_size = core->rx_desc_buf_size;
         }
 
//fix_flaw_line_below:
//        if (e1000e_ring_empty(core, rxi)) {
//fix_flaw_line_below:
//            return;
//fix_flaw_line_below:
//        }
//fix_flaw_line_below:
//
         base = e1000e_ring_head_descr(core, rxi);
 
         pci_dma_read(d, base, &desc, core->rx_desc_len);
        if (ba[0]) {
            if (desc_offset < size) {
                static const uint32_t fcs_pad;
                size_t iov_copy;
                size_t copy_size = size - desc_offset;
                if (copy_size > core->rx_desc_buf_size) {
                    copy_size = core->rx_desc_buf_size;
                }

                /* For PS mode copy the packet header first */
                if (do_ps) {
                    if (is_first) {
                        size_t ps_hdr_copied = 0;
                        do {
                            iov_copy = MIN(ps_hdr_len - ps_hdr_copied,
                                           iov->iov_len - iov_ofs);

                            e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,
                                                      iov->iov_base, iov_copy);

                            copy_size -= iov_copy;
                            ps_hdr_copied += iov_copy;

                            iov_ofs += iov_copy;
                            if (iov_ofs == iov->iov_len) {
                                iov++;
                                iov_ofs = 0;
                            }
                        } while (ps_hdr_copied < ps_hdr_len);

                        is_first = false;
                    } else {
                        /* Leave buffer 0 of each descriptor except first */
                        /* empty as per spec 7.1.5.1                      */
                        e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,
                                                       NULL, 0);
                    }
                }

                /* Copy packet payload */
                while (copy_size) {
                    iov_copy = MIN(copy_size, iov->iov_len - iov_ofs);

                    e1000e_write_to_rx_buffers(core, &ba, &bastate,
                                            iov->iov_base + iov_ofs, iov_copy);

                    copy_size -= iov_copy;
                    iov_ofs += iov_copy;
                    if (iov_ofs == iov->iov_len) {
                        iov++;
                        iov_ofs = 0;
                    }
                }

                if (desc_offset + desc_size >= total_size) {
                    /* Simulate FCS checksum presence in the last descriptor */
                    e1000e_write_to_rx_buffers(core, &ba, &bastate,
                          (const char *) &fcs_pad, e1000x_fcs_len(core->mac));
                }
            }
            desc_offset += desc_size;
            if (desc_offset >= total_size) {
                is_last = true;
            }
        } else { /* as per intel docs; skip descriptors with null buf addr */
            trace_e1000e_rx_null_descriptor();
        }

        e1000e_write_rx_descr(core, desc, is_last ? core->rx_pkt : NULL,
                           rss_info, do_ps ? ps_hdr_len : 0, &bastate.written);
        pci_dma_write(d, base, &desc, core->rx_desc_len);

        e1000e_ring_advance(core, rxi,
                            core->rx_desc_len / E1000_MIN_RX_DESC_LEN);

    } while (desc_offset < total_size);

    e1000e_update_rx_stats(core, size, total_size);
}
"
800,178536,,Remote,Not required,Partial,CVE-2017-18238,https://www.cvedetails.com/cve/CVE-2017-18238/,CWE-835,Medium,,,,2018-03-15,4.3,An issue was discovered in Exempi before 2.4.4. The TradQT_Manager::ParseCachedBoxes function in XMPFiles/source/FormatSupport/QuickTime_Support.cpp allows remote attackers to cause a denial of service (infinite loop) via crafted XMP data in a .qt file.,2019-10-02,DoS,2,https://cgit.freedesktop.org/exempi/commit/?id=886cd1d2314755adb1f4cdb99c16ff00830f0331,886cd1d2314755adb1f4cdb99c16ff00830f0331,,1,,,"bool TradQT_Manager::ParseCachedBoxes ( const MOOV_Manager & moovMgr )
{
	MOOV_Manager::BoxInfo udtaInfo;
	MOOV_Manager::BoxRef  udtaRef = moovMgr.GetBox ( ""moov/udta"", &udtaInfo );
	if ( udtaRef == 0 ) return false;

	for ( XMP_Uns32 i = 0; i < udtaInfo.childCount; ++i ) {

		MOOV_Manager::BoxInfo currInfo;
		MOOV_Manager::BoxRef  currRef = moovMgr.GetNthChild ( udtaRef, i, &currInfo );
		if ( currRef == 0 ) break;	// Sanity check, should not happen.
		if ( (currInfo.boxType >> 24) != 0xA9 ) continue;
		if ( currInfo.contentSize < 2+2+1 ) continue;	// Want enough for a non-empty value.
		
		InfoMapPos newInfo = this->parsedBoxes.insert ( this->parsedBoxes.end(),
														InfoMap::value_type ( currInfo.boxType, ParsedBoxInfo ( currInfo.boxType ) ) );
		std::vector<ValueInfo> * newValues = &newInfo->second.values;
		
		XMP_Uns8 * boxPtr = (XMP_Uns8*) currInfo.content;
		XMP_Uns8 * boxEnd = boxPtr + currInfo.contentSize;
		XMP_Uns16 miniLen, macLang;

		for ( ; boxPtr < boxEnd-4; boxPtr += miniLen ) {
 
 			miniLen = 4 + GetUns16BE ( boxPtr );	// ! Include header in local miniLen.
 			macLang  = GetUns16BE ( boxPtr+2);
			if ( (miniLen <= 4) || (miniLen > (boxEnd - boxPtr)) )
				break;	// Ignore bad or empty values.
 			
 			XMP_StringPtr valuePtr = (char*)(boxPtr+4);
 			size_t valueLen = miniLen - 4;
			newValues->push_back ( ValueInfo() );
			ValueInfo * newValue = &newValues->back();
			
			
			newValue->macLang = macLang;
			if ( IsMacLangKnown ( macLang ) ) newValue->xmpLang = GetXMPLang ( macLang );
			newValue->macValue.assign ( valuePtr, valueLen );

		}

	}
	
	return (! this->parsedBoxes.empty());

}	// TradQT_Manager::ParseCachedBoxes
","bool TradQT_Manager::ParseCachedBoxes ( const MOOV_Manager & moovMgr )
{
	MOOV_Manager::BoxInfo udtaInfo;
	MOOV_Manager::BoxRef  udtaRef = moovMgr.GetBox ( ""moov/udta"", &udtaInfo );
	if ( udtaRef == 0 ) return false;

	for ( XMP_Uns32 i = 0; i < udtaInfo.childCount; ++i ) {

		MOOV_Manager::BoxInfo currInfo;
		MOOV_Manager::BoxRef  currRef = moovMgr.GetNthChild ( udtaRef, i, &currInfo );
		if ( currRef == 0 ) break;	// Sanity check, should not happen.
		if ( (currInfo.boxType >> 24) != 0xA9 ) continue;
		if ( currInfo.contentSize < 2+2+1 ) continue;	// Want enough for a non-empty value.
		
		InfoMapPos newInfo = this->parsedBoxes.insert ( this->parsedBoxes.end(),
														InfoMap::value_type ( currInfo.boxType, ParsedBoxInfo ( currInfo.boxType ) ) );
		std::vector<ValueInfo> * newValues = &newInfo->second.values;
		
		XMP_Uns8 * boxPtr = (XMP_Uns8*) currInfo.content;
		XMP_Uns8 * boxEnd = boxPtr + currInfo.contentSize;
		XMP_Uns16 miniLen, macLang;

		for ( ; boxPtr < boxEnd-4; boxPtr += miniLen ) {
 
 			miniLen = 4 + GetUns16BE ( boxPtr );	// ! Include header in local miniLen.
 			macLang  = GetUns16BE ( boxPtr+2);
			if ( (miniLen <= 4) || (miniLen > (boxEnd - boxPtr)) ) continue;	// Ignore bad or empty values.
 			
 			XMP_StringPtr valuePtr = (char*)(boxPtr+4);
 			size_t valueLen = miniLen - 4;
			newValues->push_back ( ValueInfo() );
			ValueInfo * newValue = &newValues->back();
			
			
			newValue->macLang = macLang;
			if ( IsMacLangKnown ( macLang ) ) newValue->xmpLang = GetXMPLang ( macLang );
			newValue->macValue.assign ( valuePtr, valueLen );

		}

	}
	
	return (! this->parsedBoxes.empty());

}	// TradQT_Manager::ParseCachedBoxes
",CPP,"			if ( (miniLen <= 4) || (miniLen > (boxEnd - boxPtr)) )
				break;	// Ignore bad or empty values.
","			if ( (miniLen <= 4) || (miniLen > (boxEnd - boxPtr)) ) continue;	// Ignore bad or empty values.
",fc190643f3d75a97c0408c750340c3500727c9ea,"@@ -920,7 +920,8 @@ bool TradQT_Manager::ParseCachedBoxes ( const MOOV_Manager & moovMgr )
 
 			miniLen = 4 + GetUns16BE ( boxPtr );	// ! Include header in local miniLen.
 			macLang  = GetUns16BE ( boxPtr+2);
-			if ( (miniLen <= 4) || (miniLen > (boxEnd - boxPtr)) ) continue;	// Ignore bad or empty values.
+			if ( (miniLen <= 4) || (miniLen > (boxEnd - boxPtr)) )
+				break;	// Ignore bad or empty values.
 			
 			XMP_StringPtr valuePtr = (char*)(boxPtr+4);
 			size_t valueLen = miniLen - 4;",exempi,https://cgit.freedesktop.org/exempi/tree/XMPFiles/source/FormatSupport/QuickTime_Support.cpp?id=886cd1d2314755adb1f4cdb99c16ff00830f0331,https://cgit.freedesktop.org/exempi/tree/XMPFiles/source/FormatSupport/QuickTime_Support.cpp?id=fc190643f3d75a97c0408c750340c3500727c9ea,1,"bool TradQT_Manager::ParseCachedBoxes ( const MOOV_Manager & moovMgr )
{
	MOOV_Manager::BoxInfo udtaInfo;
	MOOV_Manager::BoxRef  udtaRef = moovMgr.GetBox ( ""moov/udta"", &udtaInfo );
	if ( udtaRef == 0 ) return false;

	for ( XMP_Uns32 i = 0; i < udtaInfo.childCount; ++i ) {

		MOOV_Manager::BoxInfo currInfo;
		MOOV_Manager::BoxRef  currRef = moovMgr.GetNthChild ( udtaRef, i, &currInfo );
		if ( currRef == 0 ) break;	// Sanity check, should not happen.
		if ( (currInfo.boxType >> 24) != 0xA9 ) continue;
		if ( currInfo.contentSize < 2+2+1 ) continue;	// Want enough for a non-empty value.
		
		InfoMapPos newInfo = this->parsedBoxes.insert ( this->parsedBoxes.end(),
														InfoMap::value_type ( currInfo.boxType, ParsedBoxInfo ( currInfo.boxType ) ) );
		std::vector<ValueInfo> * newValues = &newInfo->second.values;
		
		XMP_Uns8 * boxPtr = (XMP_Uns8*) currInfo.content;
		XMP_Uns8 * boxEnd = boxPtr + currInfo.contentSize;
		XMP_Uns16 miniLen, macLang;

		for ( ; boxPtr < boxEnd-4; boxPtr += miniLen ) {
 
 			miniLen = 4 + GetUns16BE ( boxPtr );	// ! Include header in local miniLen.
 			macLang  = GetUns16BE ( boxPtr+2);
//flaw_line_below:
			if ( (miniLen <= 4) || (miniLen > (boxEnd - boxPtr)) ) continue;	// Ignore bad or empty values.
//fix_flaw_line_below:
//			if ( (miniLen <= 4) || (miniLen > (boxEnd - boxPtr)) )
//fix_flaw_line_below:
//				break;	// Ignore bad or empty values.
 			
 			XMP_StringPtr valuePtr = (char*)(boxPtr+4);
 			size_t valueLen = miniLen - 4;
			newValues->push_back ( ValueInfo() );
			ValueInfo * newValue = &newValues->back();
			
			// Only set the XMP language if the Mac script is known, i.e. the value can be converted.
			
			newValue->macLang = macLang;
			if ( IsMacLangKnown ( macLang ) ) newValue->xmpLang = GetXMPLang ( macLang );
			newValue->macValue.assign ( valuePtr, valueLen );

		}

	}
	
	return (! this->parsedBoxes.empty());

}	// TradQT_Manager::ParseCachedBoxes
"
3101,180837,,Remote,Not required,Partial,CVE-2017-16932,https://www.cvedetails.com/cve/CVE-2017-16932/,CWE-835,Low,,,,2017-11-23,5.0,parser.c in libxml2 before 2.9.5 does not prevent infinite recursion in parameter entities.,2019-10-02,,3,https://github.com/GNOME/libxml2/commit/899a5d9f0ed13b8e32449a08a361e0de127dd961,899a5d9f0ed13b8e32449a08a361e0de127dd961,"Detect infinite recursion in parameter entities

When expanding a parameter entity in a DTD, infinite recursion could
lead to an infinite loop or memory exhaustion.

Thanks to Wei Lei for the first of many reports.

Fixes bug 759579.",1,parser.c,"{""sha"": ""51452a257732e82338a4d0ee20b800e32c6f0a41"", ""filename"": ""parser.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 1, ""changes"": 11, ""blob_url"": ""https://github.com/GNOME/libxml2/blob/899a5d9f0ed13b8e32449a08a361e0de127dd961/parser.c"", ""raw_url"": ""https://github.com/GNOME/libxml2/raw/899a5d9f0ed13b8e32449a08a361e0de127dd961/parser.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/libxml2/contents/parser.c?ref=899a5d9f0ed13b8e32449a08a361e0de127dd961"", ""patch"": ""@@ -2250,6 +2250,13 @@ xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {\n \txmlGenericError(xmlGenericErrorContext,\n \t\t\""Pushing input %d : %.30s\\n\"", ctxt->inputNr+1, input->cur);\n     }\n+    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||\n+        (ctxt->inputNr > 1024)) {\n+        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n+        while (ctxt->inputNr > 1)\n+            xmlFreeInputStream(inputPop(ctxt));\n+\treturn(-1);\n+    }\n     ret = inputPush(ctxt, input);\n     if (ctxt->instate == XML_PARSER_EOF)\n         return(-1);\n@@ -7916,8 +7923,10 @@ xmlParsePEReference(xmlParserCtxtPtr ctxt)\n \t\treturn;\n \n \t    input = xmlNewEntityInputStream(ctxt, entity);\n-\t    if (xmlPushInput(ctxt, input) < 0)\n+\t    if (xmlPushInput(ctxt, input) < 0) {\n+                xmlFreeInputStream(input);\n \t\treturn;\n+            }\n \n \t    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {\n                 /*""}<_**next**_>{""sha"": ""e69de29bb2d1d6434b8b29ae775ad8c2e48c5391"", ""filename"": ""result/errors/759579.xml"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/GNOME/libxml2/blob/899a5d9f0ed13b8e32449a08a361e0de127dd961/result/errors/759579.xml"", ""raw_url"": ""https://github.com/GNOME/libxml2/raw/899a5d9f0ed13b8e32449a08a361e0de127dd961/result/errors/759579.xml"", ""contents_url"": ""https://api.github.com/repos/GNOME/libxml2/contents/result/errors/759579.xml?ref=899a5d9f0ed13b8e32449a08a361e0de127dd961""}<_**next**_>{""sha"": ""288026e69aae8f4ec2745d020ea9965435104edd"", ""filename"": ""result/errors/759579.xml.err"", ""status"": ""added"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/GNOME/libxml2/blob/899a5d9f0ed13b8e32449a08a361e0de127dd961/result/errors/759579.xml.err"", ""raw_url"": ""https://github.com/GNOME/libxml2/raw/899a5d9f0ed13b8e32449a08a361e0de127dd961/result/errors/759579.xml.err"", ""contents_url"": ""https://api.github.com/repos/GNOME/libxml2/contents/result/errors/759579.xml.err?ref=899a5d9f0ed13b8e32449a08a361e0de127dd961"", ""patch"": ""@@ -0,0 +1,6 @@\n+Entity: line 2: parser error : Detected an entity reference loop\n+        %z; %z; %z; %z; %z;\n+           ^\n+Entity: line 2: \n+        %z; %z; %z; %z; %z;\n+           ^""}<_**next**_>{""sha"": ""09408f5205ac27af5dbb283830ba34543c35bc38"", ""filename"": ""result/errors/759579.xml.str"", ""status"": ""added"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/GNOME/libxml2/blob/899a5d9f0ed13b8e32449a08a361e0de127dd961/result/errors/759579.xml.str"", ""raw_url"": ""https://github.com/GNOME/libxml2/raw/899a5d9f0ed13b8e32449a08a361e0de127dd961/result/errors/759579.xml.str"", ""contents_url"": ""https://api.github.com/repos/GNOME/libxml2/contents/result/errors/759579.xml.str?ref=899a5d9f0ed13b8e32449a08a361e0de127dd961"", ""patch"": ""@@ -0,0 +1,7 @@\n+Entity: line 2: parser error : Detected an entity reference loop\n+        %z; %z; %z; %z; %z;\n+           ^\n+Entity: line 2: \n+        %z; %z; %z; %z; %z;\n+           ^\n+./test/errors/759579.xml : failed to parse""}<_**next**_>{""sha"": ""7fadd702413a6e6fbf83522768214f9823f82f03"", ""filename"": ""test/errors/759579.xml"", ""status"": ""added"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/GNOME/libxml2/blob/899a5d9f0ed13b8e32449a08a361e0de127dd961/test/errors/759579.xml"", ""raw_url"": ""https://github.com/GNOME/libxml2/raw/899a5d9f0ed13b8e32449a08a361e0de127dd961/test/errors/759579.xml"", ""contents_url"": ""https://api.github.com/repos/GNOME/libxml2/contents/test/errors/759579.xml?ref=899a5d9f0ed13b8e32449a08a361e0de127dd961"", ""patch"": ""@@ -0,0 +1,11 @@\n+<!DOCTYPE doc [\n+    <!ENTITY % z '\n+        &#37;z; &#37;z; &#37;z; &#37;z; &#37;z;\n+        &#37;z; &#37;z; &#37;z; &#37;z; &#37;z;\n+        &#37;z; &#37;z; &#37;z; &#37;z; &#37;z;\n+        &#37;z; &#37;z; &#37;z; &#37;z; &#37;z;\n+        &#37;z; &#37;z; &#37;z; &#37;z; &#37;z;\n+    '>\n+    %z;\n+]>\n+<doc/>""}","xmlParsePEReference(xmlParserCtxtPtr ctxt)
{
    const xmlChar *name;
    xmlEntityPtr entity = NULL;
    xmlParserInputPtr input;

    if (RAW != '%')
        return;
    NEXT;
    name = xmlParseName(ctxt);
    if (name == NULL) {
	xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, ""PEReference: no name\n"");
	return;
    }
    if (xmlParserDebugEntities)
	xmlGenericError(xmlGenericErrorContext,
		""PEReference: %s\n"", name);
    if (RAW != ';') {
	xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);
        return;
    }

    NEXT;

    /*
     * Increate the number of entity references parsed
     */
    ctxt->nbentities++;

    /*
     * Request the entity from SAX
     */
    if ((ctxt->sax != NULL) &&
	(ctxt->sax->getParameterEntity != NULL))
	entity = ctxt->sax->getParameterEntity(ctxt->userData, name);
    if (ctxt->instate == XML_PARSER_EOF)
	return;
    if (entity == NULL) {
	/*
	 * [ WFC: Entity Declared ]
	 * In a document without any DTD, a document with only an
	 * internal DTD subset which contains no parameter entity
	 * references, or a document with ""standalone='yes'"", ...
	 * ... The declaration of a parameter entity must precede
	 * any reference to it...
	 */
	if ((ctxt->standalone == 1) ||
	    ((ctxt->hasExternalSubset == 0) &&
	     (ctxt->hasPErefs == 0))) {
	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
			      ""PEReference: %%%s; not found\n"",
			      name);
	} else {
	    /*
	     * [ VC: Entity Declared ]
	     * In a document with an external subset or external
	     * parameter entities with ""standalone='no'"", ...
	     * ... The declaration of a parameter entity must
	     * precede any reference to it...
	     */
            if ((ctxt->validate) && (ctxt->vctxt.error != NULL)) {
                xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY,
                                 ""PEReference: %%%s; not found\n"",
                                 name, NULL);
            } else
                xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
                              ""PEReference: %%%s; not found\n"",
                              name, NULL);
            ctxt->valid = 0;
	}
	xmlParserEntityCheck(ctxt, 0, NULL, 0);
    } else {
	/*
	 * Internal checking in case the entity quest barfed
	 */
	if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&
	    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
		  ""Internal: %%%s; is not a parameter entity\n"",
			  name, NULL);
	} else {
            xmlChar start[4];
            xmlCharEncoding enc;

	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
	        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
		((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
		((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
		((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
		(ctxt->replaceEntities == 0) &&
		(ctxt->validate == 0))
 		return;
 
 	    input = xmlNewEntityInputStream(ctxt, entity);
	    if (xmlPushInput(ctxt, input) < 0) {
                xmlFreeInputStream(input);
 		return;
            }
 
 	    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {
                 /*
                 * Get the 4 first bytes and decode the charset
                 * if enc != XML_CHAR_ENCODING_NONE
                 * plug some encoding conversion routines.
                 * Note that, since we may have some non-UTF8
                 * encoding (like UTF16, bug 135229), the 'length'
                 * is not known, but we can calculate based upon
                 * the amount of data in the buffer.
                 */
                GROW
                if (ctxt->instate == XML_PARSER_EOF)
                    return;
                if ((ctxt->input->end - ctxt->input->cur)>=4) {
                    start[0] = RAW;
                    start[1] = NXT(1);
                    start[2] = NXT(2);
                    start[3] = NXT(3);
                    enc = xmlDetectCharEncoding(start, 4);
                    if (enc != XML_CHAR_ENCODING_NONE) {
                        xmlSwitchEncoding(ctxt, enc);
                    }
                }

                if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&
                    (IS_BLANK_CH(NXT(5)))) {
                    xmlParseTextDecl(ctxt);
                }
            }
	}
    }
    ctxt->hasPErefs = 1;
}
","xmlParsePEReference(xmlParserCtxtPtr ctxt)
{
    const xmlChar *name;
    xmlEntityPtr entity = NULL;
    xmlParserInputPtr input;

    if (RAW != '%')
        return;
    NEXT;
    name = xmlParseName(ctxt);
    if (name == NULL) {
	xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, ""PEReference: no name\n"");
	return;
    }
    if (xmlParserDebugEntities)
	xmlGenericError(xmlGenericErrorContext,
		""PEReference: %s\n"", name);
    if (RAW != ';') {
	xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);
        return;
    }

    NEXT;

    /*
     * Increate the number of entity references parsed
     */
    ctxt->nbentities++;

    /*
     * Request the entity from SAX
     */
    if ((ctxt->sax != NULL) &&
	(ctxt->sax->getParameterEntity != NULL))
	entity = ctxt->sax->getParameterEntity(ctxt->userData, name);
    if (ctxt->instate == XML_PARSER_EOF)
	return;
    if (entity == NULL) {
	/*
	 * [ WFC: Entity Declared ]
	 * In a document without any DTD, a document with only an
	 * internal DTD subset which contains no parameter entity
	 * references, or a document with ""standalone='yes'"", ...
	 * ... The declaration of a parameter entity must precede
	 * any reference to it...
	 */
	if ((ctxt->standalone == 1) ||
	    ((ctxt->hasExternalSubset == 0) &&
	     (ctxt->hasPErefs == 0))) {
	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
			      ""PEReference: %%%s; not found\n"",
			      name);
	} else {
	    /*
	     * [ VC: Entity Declared ]
	     * In a document with an external subset or external
	     * parameter entities with ""standalone='no'"", ...
	     * ... The declaration of a parameter entity must
	     * precede any reference to it...
	     */
            if ((ctxt->validate) && (ctxt->vctxt.error != NULL)) {
                xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY,
                                 ""PEReference: %%%s; not found\n"",
                                 name, NULL);
            } else
                xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
                              ""PEReference: %%%s; not found\n"",
                              name, NULL);
            ctxt->valid = 0;
	}
	xmlParserEntityCheck(ctxt, 0, NULL, 0);
    } else {
	/*
	 * Internal checking in case the entity quest barfed
	 */
	if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&
	    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
		  ""Internal: %%%s; is not a parameter entity\n"",
			  name, NULL);
	} else {
            xmlChar start[4];
            xmlCharEncoding enc;

	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
	        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
		((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
		((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
		((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
		(ctxt->replaceEntities == 0) &&
		(ctxt->validate == 0))
 		return;
 
 	    input = xmlNewEntityInputStream(ctxt, entity);
	    if (xmlPushInput(ctxt, input) < 0)
 		return;
 
 	    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {
                 /*
                 * Get the 4 first bytes and decode the charset
                 * if enc != XML_CHAR_ENCODING_NONE
                 * plug some encoding conversion routines.
                 * Note that, since we may have some non-UTF8
                 * encoding (like UTF16, bug 135229), the 'length'
                 * is not known, but we can calculate based upon
                 * the amount of data in the buffer.
                 */
                GROW
                if (ctxt->instate == XML_PARSER_EOF)
                    return;
                if ((ctxt->input->end - ctxt->input->cur)>=4) {
                    start[0] = RAW;
                    start[1] = NXT(1);
                    start[2] = NXT(2);
                    start[3] = NXT(3);
                    enc = xmlDetectCharEncoding(start, 4);
                    if (enc != XML_CHAR_ENCODING_NONE) {
                        xmlSwitchEncoding(ctxt, enc);
                    }
                }

                if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&
                    (IS_BLANK_CH(NXT(5)))) {
                    xmlParseTextDecl(ctxt);
                }
            }
	}
    }
    ctxt->hasPErefs = 1;
}
",C,"	    if (xmlPushInput(ctxt, input) < 0) {
                xmlFreeInputStream(input);
            }
","	    if (xmlPushInput(ctxt, input) < 0)
",,"@@ -2250,6 +2250,13 @@ xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {
 	xmlGenericError(xmlGenericErrorContext,
 		""Pushing input %d : %.30s\n"", ctxt->inputNr+1, input->cur);
     }
+    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
+        (ctxt->inputNr > 1024)) {
+        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
+        while (ctxt->inputNr > 1)
+            xmlFreeInputStream(inputPop(ctxt));
+	return(-1);
+    }
     ret = inputPush(ctxt, input);
     if (ctxt->instate == XML_PARSER_EOF)
         return(-1);
@@ -7916,8 +7923,10 @@ xmlParsePEReference(xmlParserCtxtPtr ctxt)
 		return;
 
 	    input = xmlNewEntityInputStream(ctxt, entity);
-	    if (xmlPushInput(ctxt, input) < 0)
+	    if (xmlPushInput(ctxt, input) < 0) {
+                xmlFreeInputStream(input);
 		return;
+            }
 
 	    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {
                 /*",libxml2,899a5d9f0ed13b8e32449a08a361e0de127dd961,fb56f80eeffde4b79a49667c3f0727181d57aeb3,1,"xmlParsePEReference(xmlParserCtxtPtr ctxt)
{
    const xmlChar *name;
    xmlEntityPtr entity = NULL;
    xmlParserInputPtr input;

    if (RAW != '%')
        return;
    NEXT;
    name = xmlParseName(ctxt);
    if (name == NULL) {
	xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, ""PEReference: no name\n"");
	return;
    }
    if (xmlParserDebugEntities)
	xmlGenericError(xmlGenericErrorContext,
		""PEReference: %s\n"", name);
    if (RAW != ';') {
	xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);
        return;
    }

    NEXT;

    /*
     * Increate the number of entity references parsed
     */
    ctxt->nbentities++;

    /*
     * Request the entity from SAX
     */
    if ((ctxt->sax != NULL) &&
	(ctxt->sax->getParameterEntity != NULL))
	entity = ctxt->sax->getParameterEntity(ctxt->userData, name);
    if (ctxt->instate == XML_PARSER_EOF)
	return;
    if (entity == NULL) {
	/*
	 * [ WFC: Entity Declared ]
	 * In a document without any DTD, a document with only an
	 * internal DTD subset which contains no parameter entity
	 * references, or a document with ""standalone='yes'"", ...
	 * ... The declaration of a parameter entity must precede
	 * any reference to it...
	 */
	if ((ctxt->standalone == 1) ||
	    ((ctxt->hasExternalSubset == 0) &&
	     (ctxt->hasPErefs == 0))) {
	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
			      ""PEReference: %%%s; not found\n"",
			      name);
	} else {
	    /*
	     * [ VC: Entity Declared ]
	     * In a document with an external subset or external
	     * parameter entities with ""standalone='no'"", ...
	     * ... The declaration of a parameter entity must
	     * precede any reference to it...
	     */
            if ((ctxt->validate) && (ctxt->vctxt.error != NULL)) {
                xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY,
                                 ""PEReference: %%%s; not found\n"",
                                 name, NULL);
            } else
                xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
                              ""PEReference: %%%s; not found\n"",
                              name, NULL);
            ctxt->valid = 0;
	}
	xmlParserEntityCheck(ctxt, 0, NULL, 0);
    } else {
	/*
	 * Internal checking in case the entity quest barfed
	 */
	if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&
	    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
		  ""Internal: %%%s; is not a parameter entity\n"",
			  name, NULL);
	} else {
            xmlChar start[4];
            xmlCharEncoding enc;

	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
	        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
		((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
		((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
		((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
		(ctxt->replaceEntities == 0) &&
		(ctxt->validate == 0))
 		return;
 
 	    input = xmlNewEntityInputStream(ctxt, entity);
//flaw_line_below:
	    if (xmlPushInput(ctxt, input) < 0)
//fix_flaw_line_below:
//	    if (xmlPushInput(ctxt, input) < 0) {
//fix_flaw_line_below:
//                xmlFreeInputStream(input);
 		return;
//fix_flaw_line_below:
//            }
 
 	    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {
                 /*
                 * Get the 4 first bytes and decode the charset
                 * if enc != XML_CHAR_ENCODING_NONE
                 * plug some encoding conversion routines.
                 * Note that, since we may have some non-UTF8
                 * encoding (like UTF16, bug 135229), the 'length'
                 * is not known, but we can calculate based upon
                 * the amount of data in the buffer.
                 */
                GROW
                if (ctxt->instate == XML_PARSER_EOF)
                    return;
                if ((ctxt->input->end - ctxt->input->cur)>=4) {
                    start[0] = RAW;
                    start[1] = NXT(1);
                    start[2] = NXT(2);
                    start[3] = NXT(3);
                    enc = xmlDetectCharEncoding(start, 4);
                    if (enc != XML_CHAR_ENCODING_NONE) {
                        xmlSwitchEncoding(ctxt, enc);
                    }
                }

                if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&
                    (IS_BLANK_CH(NXT(5)))) {
                    xmlParseTextDecl(ctxt);
                }
            }
	}
    }
    ctxt->hasPErefs = 1;
}
"
3102,180838,,Remote,Not required,Partial,CVE-2017-16932,https://www.cvedetails.com/cve/CVE-2017-16932/,CWE-835,Low,,,,2017-11-23,5.0,parser.c in libxml2 before 2.9.5 does not prevent infinite recursion in parameter entities.,2019-10-02,,7,https://github.com/GNOME/libxml2/commit/899a5d9f0ed13b8e32449a08a361e0de127dd961,899a5d9f0ed13b8e32449a08a361e0de127dd961,"Detect infinite recursion in parameter entities

When expanding a parameter entity in a DTD, infinite recursion could
lead to an infinite loop or memory exhaustion.

Thanks to Wei Lei for the first of many reports.

Fixes bug 759579.",0,parser.c,"{""sha"": ""51452a257732e82338a4d0ee20b800e32c6f0a41"", ""filename"": ""parser.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 1, ""changes"": 11, ""blob_url"": ""https://github.com/GNOME/libxml2/blob/899a5d9f0ed13b8e32449a08a361e0de127dd961/parser.c"", ""raw_url"": ""https://github.com/GNOME/libxml2/raw/899a5d9f0ed13b8e32449a08a361e0de127dd961/parser.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/libxml2/contents/parser.c?ref=899a5d9f0ed13b8e32449a08a361e0de127dd961"", ""patch"": ""@@ -2250,6 +2250,13 @@ xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {\n \txmlGenericError(xmlGenericErrorContext,\n \t\t\""Pushing input %d : %.30s\\n\"", ctxt->inputNr+1, input->cur);\n     }\n+    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||\n+        (ctxt->inputNr > 1024)) {\n+        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n+        while (ctxt->inputNr > 1)\n+            xmlFreeInputStream(inputPop(ctxt));\n+\treturn(-1);\n+    }\n     ret = inputPush(ctxt, input);\n     if (ctxt->instate == XML_PARSER_EOF)\n         return(-1);\n@@ -7916,8 +7923,10 @@ xmlParsePEReference(xmlParserCtxtPtr ctxt)\n \t\treturn;\n \n \t    input = xmlNewEntityInputStream(ctxt, entity);\n-\t    if (xmlPushInput(ctxt, input) < 0)\n+\t    if (xmlPushInput(ctxt, input) < 0) {\n+                xmlFreeInputStream(input);\n \t\treturn;\n+            }\n \n \t    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {\n                 /*""}<_**next**_>{""sha"": ""e69de29bb2d1d6434b8b29ae775ad8c2e48c5391"", ""filename"": ""result/errors/759579.xml"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/GNOME/libxml2/blob/899a5d9f0ed13b8e32449a08a361e0de127dd961/result/errors/759579.xml"", ""raw_url"": ""https://github.com/GNOME/libxml2/raw/899a5d9f0ed13b8e32449a08a361e0de127dd961/result/errors/759579.xml"", ""contents_url"": ""https://api.github.com/repos/GNOME/libxml2/contents/result/errors/759579.xml?ref=899a5d9f0ed13b8e32449a08a361e0de127dd961""}<_**next**_>{""sha"": ""288026e69aae8f4ec2745d020ea9965435104edd"", ""filename"": ""result/errors/759579.xml.err"", ""status"": ""added"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/GNOME/libxml2/blob/899a5d9f0ed13b8e32449a08a361e0de127dd961/result/errors/759579.xml.err"", ""raw_url"": ""https://github.com/GNOME/libxml2/raw/899a5d9f0ed13b8e32449a08a361e0de127dd961/result/errors/759579.xml.err"", ""contents_url"": ""https://api.github.com/repos/GNOME/libxml2/contents/result/errors/759579.xml.err?ref=899a5d9f0ed13b8e32449a08a361e0de127dd961"", ""patch"": ""@@ -0,0 +1,6 @@\n+Entity: line 2: parser error : Detected an entity reference loop\n+        %z; %z; %z; %z; %z;\n+           ^\n+Entity: line 2: \n+        %z; %z; %z; %z; %z;\n+           ^""}<_**next**_>{""sha"": ""09408f5205ac27af5dbb283830ba34543c35bc38"", ""filename"": ""result/errors/759579.xml.str"", ""status"": ""added"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/GNOME/libxml2/blob/899a5d9f0ed13b8e32449a08a361e0de127dd961/result/errors/759579.xml.str"", ""raw_url"": ""https://github.com/GNOME/libxml2/raw/899a5d9f0ed13b8e32449a08a361e0de127dd961/result/errors/759579.xml.str"", ""contents_url"": ""https://api.github.com/repos/GNOME/libxml2/contents/result/errors/759579.xml.str?ref=899a5d9f0ed13b8e32449a08a361e0de127dd961"", ""patch"": ""@@ -0,0 +1,7 @@\n+Entity: line 2: parser error : Detected an entity reference loop\n+        %z; %z; %z; %z; %z;\n+           ^\n+Entity: line 2: \n+        %z; %z; %z; %z; %z;\n+           ^\n+./test/errors/759579.xml : failed to parse""}<_**next**_>{""sha"": ""7fadd702413a6e6fbf83522768214f9823f82f03"", ""filename"": ""test/errors/759579.xml"", ""status"": ""added"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/GNOME/libxml2/blob/899a5d9f0ed13b8e32449a08a361e0de127dd961/test/errors/759579.xml"", ""raw_url"": ""https://github.com/GNOME/libxml2/raw/899a5d9f0ed13b8e32449a08a361e0de127dd961/test/errors/759579.xml"", ""contents_url"": ""https://api.github.com/repos/GNOME/libxml2/contents/test/errors/759579.xml?ref=899a5d9f0ed13b8e32449a08a361e0de127dd961"", ""patch"": ""@@ -0,0 +1,11 @@\n+<!DOCTYPE doc [\n+    <!ENTITY % z '\n+        &#37;z; &#37;z; &#37;z; &#37;z; &#37;z;\n+        &#37;z; &#37;z; &#37;z; &#37;z; &#37;z;\n+        &#37;z; &#37;z; &#37;z; &#37;z; &#37;z;\n+        &#37;z; &#37;z; &#37;z; &#37;z; &#37;z;\n+        &#37;z; &#37;z; &#37;z; &#37;z; &#37;z;\n+    '>\n+    %z;\n+]>\n+<doc/>""}","xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {
    int ret;
    if (input == NULL) return(-1);

    if (xmlParserDebugEntities) {
	if ((ctxt->input != NULL) && (ctxt->input->filename))
	    xmlGenericError(xmlGenericErrorContext,
		    ""%s(%d): "", ctxt->input->filename,
		    ctxt->input->line);
 	xmlGenericError(xmlGenericErrorContext,
 		""Pushing input %d : %.30s\n"", ctxt->inputNr+1, input->cur);
     }
    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
        (ctxt->inputNr > 1024)) {
        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
        while (ctxt->inputNr > 1)
            xmlFreeInputStream(inputPop(ctxt));
	return(-1);
    }
     ret = inputPush(ctxt, input);
     if (ctxt->instate == XML_PARSER_EOF)
         return(-1);
    GROW;
    return(ret);
}
","xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {
    int ret;
    if (input == NULL) return(-1);

    if (xmlParserDebugEntities) {
	if ((ctxt->input != NULL) && (ctxt->input->filename))
	    xmlGenericError(xmlGenericErrorContext,
		    ""%s(%d): "", ctxt->input->filename,
		    ctxt->input->line);
 	xmlGenericError(xmlGenericErrorContext,
 		""Pushing input %d : %.30s\n"", ctxt->inputNr+1, input->cur);
     }
     ret = inputPush(ctxt, input);
     if (ctxt->instate == XML_PARSER_EOF)
         return(-1);
    GROW;
    return(ret);
}
",C,"    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
        (ctxt->inputNr > 1024)) {
        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
        while (ctxt->inputNr > 1)
            xmlFreeInputStream(inputPop(ctxt));
	return(-1);
    }
",,,"@@ -2250,6 +2250,13 @@ xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {
 	xmlGenericError(xmlGenericErrorContext,
 		""Pushing input %d : %.30s\n"", ctxt->inputNr+1, input->cur);
     }
+    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
+        (ctxt->inputNr > 1024)) {
+        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
+        while (ctxt->inputNr > 1)
+            xmlFreeInputStream(inputPop(ctxt));
+	return(-1);
+    }
     ret = inputPush(ctxt, input);
     if (ctxt->instate == XML_PARSER_EOF)
         return(-1);
@@ -7916,8 +7923,10 @@ xmlParsePEReference(xmlParserCtxtPtr ctxt)
 		return;
 
 	    input = xmlNewEntityInputStream(ctxt, entity);
-	    if (xmlPushInput(ctxt, input) < 0)
+	    if (xmlPushInput(ctxt, input) < 0) {
+                xmlFreeInputStream(input);
 		return;
+            }
 
 	    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {
                 /*",libxml2,899a5d9f0ed13b8e32449a08a361e0de127dd961,fb56f80eeffde4b79a49667c3f0727181d57aeb3,1,"xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {
    int ret;
    if (input == NULL) return(-1);

    if (xmlParserDebugEntities) {
	if ((ctxt->input != NULL) && (ctxt->input->filename))
	    xmlGenericError(xmlGenericErrorContext,
		    ""%s(%d): "", ctxt->input->filename,
		    ctxt->input->line);
 	xmlGenericError(xmlGenericErrorContext,
 		""Pushing input %d : %.30s\n"", ctxt->inputNr+1, input->cur);
     }
//fix_flaw_line_below:
//    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
//fix_flaw_line_below:
//        (ctxt->inputNr > 1024)) {
//fix_flaw_line_below:
//        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
//fix_flaw_line_below:
//        while (ctxt->inputNr > 1)
//fix_flaw_line_below:
//            xmlFreeInputStream(inputPop(ctxt));
//fix_flaw_line_below:
//	return(-1);
//fix_flaw_line_below:
//    }
     ret = inputPush(ctxt, input);
     if (ctxt->instate == XML_PARSER_EOF)
         return(-1);
    GROW;
    return(ret);
}
"
3210,180946,,Remote,Not required,Partial,CVE-2017-14058,https://www.cvedetails.com/cve/CVE-2017-14058/,CWE-835,Medium,,,,2017-08-31,4.3,"In FFmpeg 3.3.3, the read_data function in libavformat/hls.c does not restrict reload attempts for an insufficient list, which allows remote attackers to cause a denial of service (infinite loop).",2019-10-02,DoS ,4,https://github.com/FFmpeg/FFmpeg/commit/7ec414892ddcad88313848494b6fc5f437c9ca4a,7ec414892ddcad88313848494b6fc5f437c9ca4a,"avformat/hls: Fix DoS due to infinite loop

Fixes: loop.m3u

The default max iteration count of 1000 is arbitrary and ideas for a better solution are welcome

Found-by: Xiaohei and Wangchu from Alibaba Security Team

Previous version reviewed-by: Steven Liu <lingjiujianke@gmail.com>
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",0,libavformat/hls.c,"{""sha"": ""73dc0feec194a085ff6e3ccaab2a184433f7ac37"", ""filename"": ""doc/demuxers.texi"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 0, ""changes"": 18, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/7ec414892ddcad88313848494b6fc5f437c9ca4a/doc/demuxers.texi"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/7ec414892ddcad88313848494b6fc5f437c9ca4a/doc/demuxers.texi"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/doc/demuxers.texi?ref=7ec414892ddcad88313848494b6fc5f437c9ca4a"", ""patch"": ""@@ -300,6 +300,24 @@ used to end the output video at the length of the shortest input file,\n which in this case is @file{input.mp4} as the GIF in this example loops\n infinitely.\n \n+@section hls\n+\n+HLS demuxer\n+\n+It accepts the following options:\n+\n+@table @option\n+@item live_start_index\n+segment index to start live streams at (negative values are from the end).\n+\n+@item allowed_extensions\n+',' separated list of file extensions that hls is allowed to access.\n+\n+@item max_reload\n+Maximum number of times a insufficient list is attempted to be reloaded.\n+Default value is 1000.\n+@end table\n+\n @section image2\n \n Image file demuxer.""}<_**next**_>{""sha"": ""0995345bbf2c4bf5327245405b7ee40ab181be85"", ""filename"": ""libavformat/hls.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/7ec414892ddcad88313848494b6fc5f437c9ca4a/libavformat/hls.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/7ec414892ddcad88313848494b6fc5f437c9ca4a/libavformat/hls.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavformat/hls.c?ref=7ec414892ddcad88313848494b6fc5f437c9ca4a"", ""patch"": ""@@ -205,6 +205,7 @@ typedef struct HLSContext {\n     AVDictionary *avio_opts;\n     int strict_std_compliance;\n     char *allowed_extensions;\n+    int max_reload;\n } HLSContext;\n \n static int read_chomp_line(AVIOContext *s, char *buf, int maxlen)\n@@ -1263,6 +1264,7 @@ static int read_data(void *opaque, uint8_t *buf, int buf_size)\n     HLSContext *c = v->parent->priv_data;\n     int ret, i;\n     int just_opened = 0;\n+    int reload_count = 0;\n \n restart:\n     if (!v->needed)\n@@ -1294,6 +1296,9 @@ static int read_data(void *opaque, uint8_t *buf, int buf_size)\n         reload_interval = default_reload_interval(v);\n \n reload:\n+        reload_count++;\n+        if (reload_count > c->max_reload)\n+            return AVERROR_EOF;\n         if (!v->finished &&\n             av_gettime_relative() - v->last_load_time >= reload_interval) {\n             if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {\n@@ -2150,6 +2155,8 @@ static const AVOption hls_options[] = {\n         OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,\n         {.str = \""3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav\""},\n         INT_MIN, INT_MAX, FLAGS},\n+    {\""max_reload\"", \""Maximum number of times a insufficient list is attempted to be reloaded\"",\n+        OFFSET(max_reload), AV_OPT_TYPE_INT, {.i64 = 1000}, 0, INT_MAX, FLAGS},\n     {NULL}\n };\n ""}","static int read_data(void *opaque, uint8_t *buf, int buf_size)
{
    struct playlist *v = opaque;
     HLSContext *c = v->parent->priv_data;
     int ret, i;
     int just_opened = 0;
    int reload_count = 0;
 
 restart:
     if (!v->needed)
        return AVERROR_EOF;

    if (!v->input) {
        int64_t reload_interval;
        struct segment *seg;

        /* Check that the playlist is still needed before opening a new
         * segment. */
        if (v->ctx && v->ctx->nb_streams) {
            v->needed = 0;
            for (i = 0; i < v->n_main_streams; i++) {
                if (v->main_streams[i]->discard < AVDISCARD_ALL) {
                    v->needed = 1;
                    break;
                }
            }
        }
        if (!v->needed) {
            av_log(v->parent, AV_LOG_INFO, ""No longer receiving playlist %d\n"",
                v->index);
            return AVERROR_EOF;
        }

        /* If this is a live stream and the reload interval has elapsed since
         * the last playlist reload, reload the playlists now. */
         reload_interval = default_reload_interval(v);
 
 reload:
        reload_count++;
        if (reload_count > c->max_reload)
            return AVERROR_EOF;
         if (!v->finished &&
             av_gettime_relative() - v->last_load_time >= reload_interval) {
             if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {
                av_log(v->parent, AV_LOG_WARNING, ""Failed to reload playlist %d\n"",
                       v->index);
                return ret;
            }
            /* If we need to reload the playlist again below (if
             * there's still no more segments), switch to a reload
             * interval of half the target duration. */
            reload_interval = v->target_duration / 2;
        }
        if (v->cur_seq_no < v->start_seq_no) {
            av_log(NULL, AV_LOG_WARNING,
                   ""skipping %d segments ahead, expired from playlists\n"",
                   v->start_seq_no - v->cur_seq_no);
            v->cur_seq_no = v->start_seq_no;
        }
        if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {
            if (v->finished)
                return AVERROR_EOF;
            while (av_gettime_relative() - v->last_load_time < reload_interval) {
                if (ff_check_interrupt(c->interrupt_callback))
                    return AVERROR_EXIT;
                av_usleep(100*1000);
            }
            /* Enough time has elapsed since the last reload */
            goto reload;
        }

        seg = current_segment(v);

        /* load/update Media Initialization Section, if any */
        ret = update_init_section(v, seg);
        if (ret)
            return ret;

        ret = open_input(c, v, seg);
        if (ret < 0) {
            if (ff_check_interrupt(c->interrupt_callback))
                return AVERROR_EXIT;
            av_log(v->parent, AV_LOG_WARNING, ""Failed to open segment of playlist %d\n"",
                   v->index);
            v->cur_seq_no += 1;
            goto reload;
        }
        just_opened = 1;
    }

    if (v->init_sec_buf_read_offset < v->init_sec_data_len) {
        /* Push init section out first before first actual segment */
        int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);
        memcpy(buf, v->init_sec_buf, copy_size);
        v->init_sec_buf_read_offset += copy_size;
        return copy_size;
    }

    ret = read_from_url(v, current_segment(v), buf, buf_size, READ_NORMAL);
    if (ret > 0) {
        if (just_opened && v->is_id3_timestamped != 0) {
            /* Intercept ID3 tags here, elementary audio streams are required
             * to convey timestamps using them in the beginning of each segment. */
            intercept_id3(v, buf, buf_size, &ret);
        }

        return ret;
    }
    ff_format_io_close(v->parent, &v->input);
    v->cur_seq_no++;

    c->cur_seq_no = v->cur_seq_no;

    goto restart;
}
","static int read_data(void *opaque, uint8_t *buf, int buf_size)
{
    struct playlist *v = opaque;
     HLSContext *c = v->parent->priv_data;
     int ret, i;
     int just_opened = 0;
 
 restart:
     if (!v->needed)
        return AVERROR_EOF;

    if (!v->input) {
        int64_t reload_interval;
        struct segment *seg;

        /* Check that the playlist is still needed before opening a new
         * segment. */
        if (v->ctx && v->ctx->nb_streams) {
            v->needed = 0;
            for (i = 0; i < v->n_main_streams; i++) {
                if (v->main_streams[i]->discard < AVDISCARD_ALL) {
                    v->needed = 1;
                    break;
                }
            }
        }
        if (!v->needed) {
            av_log(v->parent, AV_LOG_INFO, ""No longer receiving playlist %d\n"",
                v->index);
            return AVERROR_EOF;
        }

        /* If this is a live stream and the reload interval has elapsed since
         * the last playlist reload, reload the playlists now. */
         reload_interval = default_reload_interval(v);
 
 reload:
         if (!v->finished &&
             av_gettime_relative() - v->last_load_time >= reload_interval) {
             if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {
                av_log(v->parent, AV_LOG_WARNING, ""Failed to reload playlist %d\n"",
                       v->index);
                return ret;
            }
            /* If we need to reload the playlist again below (if
             * there's still no more segments), switch to a reload
             * interval of half the target duration. */
            reload_interval = v->target_duration / 2;
        }
        if (v->cur_seq_no < v->start_seq_no) {
            av_log(NULL, AV_LOG_WARNING,
                   ""skipping %d segments ahead, expired from playlists\n"",
                   v->start_seq_no - v->cur_seq_no);
            v->cur_seq_no = v->start_seq_no;
        }
        if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {
            if (v->finished)
                return AVERROR_EOF;
            while (av_gettime_relative() - v->last_load_time < reload_interval) {
                if (ff_check_interrupt(c->interrupt_callback))
                    return AVERROR_EXIT;
                av_usleep(100*1000);
            }
            /* Enough time has elapsed since the last reload */
            goto reload;
        }

        seg = current_segment(v);

        /* load/update Media Initialization Section, if any */
        ret = update_init_section(v, seg);
        if (ret)
            return ret;

        ret = open_input(c, v, seg);
        if (ret < 0) {
            if (ff_check_interrupt(c->interrupt_callback))
                return AVERROR_EXIT;
            av_log(v->parent, AV_LOG_WARNING, ""Failed to open segment of playlist %d\n"",
                   v->index);
            v->cur_seq_no += 1;
            goto reload;
        }
        just_opened = 1;
    }

    if (v->init_sec_buf_read_offset < v->init_sec_data_len) {
        /* Push init section out first before first actual segment */
        int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);
        memcpy(buf, v->init_sec_buf, copy_size);
        v->init_sec_buf_read_offset += copy_size;
        return copy_size;
    }

    ret = read_from_url(v, current_segment(v), buf, buf_size, READ_NORMAL);
    if (ret > 0) {
        if (just_opened && v->is_id3_timestamped != 0) {
            /* Intercept ID3 tags here, elementary audio streams are required
             * to convey timestamps using them in the beginning of each segment. */
            intercept_id3(v, buf, buf_size, &ret);
        }

        return ret;
    }
    ff_format_io_close(v->parent, &v->input);
    v->cur_seq_no++;

    c->cur_seq_no = v->cur_seq_no;

    goto restart;
}
",C,"    int reload_count = 0;
        reload_count++;
        if (reload_count > c->max_reload)
            return AVERROR_EOF;
",,,"@@ -205,6 +205,7 @@ typedef struct HLSContext {
     AVDictionary *avio_opts;
     int strict_std_compliance;
     char *allowed_extensions;
+    int max_reload;
 } HLSContext;
 
 static int read_chomp_line(AVIOContext *s, char *buf, int maxlen)
@@ -1263,6 +1264,7 @@ static int read_data(void *opaque, uint8_t *buf, int buf_size)
     HLSContext *c = v->parent->priv_data;
     int ret, i;
     int just_opened = 0;
+    int reload_count = 0;
 
 restart:
     if (!v->needed)
@@ -1294,6 +1296,9 @@ static int read_data(void *opaque, uint8_t *buf, int buf_size)
         reload_interval = default_reload_interval(v);
 
 reload:
+        reload_count++;
+        if (reload_count > c->max_reload)
+            return AVERROR_EOF;
         if (!v->finished &&
             av_gettime_relative() - v->last_load_time >= reload_interval) {
             if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {
@@ -2150,6 +2155,8 @@ static const AVOption hls_options[] = {
         OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,
         {.str = ""3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav""},
         INT_MIN, INT_MAX, FLAGS},
+    {""max_reload"", ""Maximum number of times a insufficient list is attempted to be reloaded"",
+        OFFSET(max_reload), AV_OPT_TYPE_INT, {.i64 = 1000}, 0, INT_MAX, FLAGS},
     {NULL}
 };
 ",FFmpeg,7ec414892ddcad88313848494b6fc5f437c9ca4a,2634927fe30ea4a821db515c6b7f77458f5c4bc5,1,"static int read_data(void *opaque, uint8_t *buf, int buf_size)
{
    struct playlist *v = opaque;
     HLSContext *c = v->parent->priv_data;
     int ret, i;
     int just_opened = 0;
//fix_flaw_line_below:
//    int reload_count = 0;
 
 restart:
     if (!v->needed)
        return AVERROR_EOF;

    if (!v->input) {
        int64_t reload_interval;
        struct segment *seg;

        /* Check that the playlist is still needed before opening a new
         * segment. */
        if (v->ctx && v->ctx->nb_streams) {
            v->needed = 0;
            for (i = 0; i < v->n_main_streams; i++) {
                if (v->main_streams[i]->discard < AVDISCARD_ALL) {
                    v->needed = 1;
                    break;
                }
            }
        }
        if (!v->needed) {
            av_log(v->parent, AV_LOG_INFO, ""No longer receiving playlist %d\n"",
                v->index);
            return AVERROR_EOF;
        }

        /* If this is a live stream and the reload interval has elapsed since
         * the last playlist reload, reload the playlists now. */
         reload_interval = default_reload_interval(v);
 
 reload:
//fix_flaw_line_below:
//        reload_count++;
//fix_flaw_line_below:
//        if (reload_count > c->max_reload)
//fix_flaw_line_below:
//            return AVERROR_EOF;
         if (!v->finished &&
             av_gettime_relative() - v->last_load_time >= reload_interval) {
             if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {
                av_log(v->parent, AV_LOG_WARNING, ""Failed to reload playlist %d\n"",
                       v->index);
                return ret;
            }
            /* If we need to reload the playlist again below (if
             * there's still no more segments), switch to a reload
             * interval of half the target duration. */
            reload_interval = v->target_duration / 2;
        }
        if (v->cur_seq_no < v->start_seq_no) {
            av_log(NULL, AV_LOG_WARNING,
                   ""skipping %d segments ahead, expired from playlists\n"",
                   v->start_seq_no - v->cur_seq_no);
            v->cur_seq_no = v->start_seq_no;
        }
        if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {
            if (v->finished)
                return AVERROR_EOF;
            while (av_gettime_relative() - v->last_load_time < reload_interval) {
                if (ff_check_interrupt(c->interrupt_callback))
                    return AVERROR_EXIT;
                av_usleep(100*1000);
            }
            /* Enough time has elapsed since the last reload */
            goto reload;
        }

        seg = current_segment(v);

        /* load/update Media Initialization Section, if any */
        ret = update_init_section(v, seg);
        if (ret)
            return ret;

        ret = open_input(c, v, seg);
        if (ret < 0) {
            if (ff_check_interrupt(c->interrupt_callback))
                return AVERROR_EXIT;
            av_log(v->parent, AV_LOG_WARNING, ""Failed to open segment of playlist %d\n"",
                   v->index);
            v->cur_seq_no += 1;
            goto reload;
        }
        just_opened = 1;
    }

    if (v->init_sec_buf_read_offset < v->init_sec_data_len) {
        /* Push init section out first before first actual segment */
        int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);
        memcpy(buf, v->init_sec_buf, copy_size);
        v->init_sec_buf_read_offset += copy_size;
        return copy_size;
    }

    ret = read_from_url(v, current_segment(v), buf, buf_size, READ_NORMAL);
    if (ret > 0) {
        if (just_opened && v->is_id3_timestamped != 0) {
            /* Intercept ID3 tags here, elementary audio streams are required
             * to convey timestamps using them in the beginning of each segment. */
            intercept_id3(v, buf, buf_size, &ret);
        }

        return ret;
    }
    ff_format_io_close(v->parent, &v->input);
    v->cur_seq_no++;

    c->cur_seq_no = v->cur_seq_no;

    goto restart;
}
"
3346,181082,,Remote,Not required,Partial,CVE-2017-12997,https://www.cvedetails.com/cve/CVE-2017-12997/,CWE-835,Low,,,,2017-09-14,5.0,The LLDP parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-lldp.c:lldp_private_8021_print().,2019-10-02,,4,https://github.com/the-tcpdump-group/tcpdump/commit/34cec721d39c76be1e0a600829a7b17bdfb832b6,34cec721d39c76be1e0a600829a7b17bdfb832b6,"CVE-2017-12997/LLDP: Don't use an 8-bit loop counter.

If you have a

	for (i = 0; i < N; i++)

loop, you'd better make sure that i is big enough to hold N - not N-1,
N.

The TLV length here is 9 bits long, not 8 bits long, so an 8-bit loop
counter will overflow and you can loop infinitely.

This fixes an infinite loop discovered by Forcepoint's security
researchers Otto Airamo & Antti Levomki.

Add tests using the capture files supplied by the reporter(s).

Clean up the output a bit while we're at it.",4,print-lldp.c,"{""sha"": ""dfdf1b94aa541c23d3e6d7a49d3afd89f6c347e0"", ""filename"": ""print-lldp.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/34cec721d39c76be1e0a600829a7b17bdfb832b6/print-lldp.c"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/34cec721d39c76be1e0a600829a7b17bdfb832b6/print-lldp.c"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/print-lldp.c?ref=34cec721d39c76be1e0a600829a7b17bdfb832b6"", ""patch"": ""@@ -651,7 +651,7 @@ lldp_private_8021_print(netdissect_options *ndo,\n     int subtype, hexdump = FALSE;\n     u_int sublen;\n     u_int tval;\n-    uint8_t i;\n+    u_int i;\n \n     if (tlv_len < 4) {\n         return hexdump;\n@@ -787,9 +787,9 @@ lldp_private_8021_print(netdissect_options *ndo,\n         ND_PRINT((ndo, \""\\n\\t    Application Priority Table\""));\n         while(i<sublen) {\n         \ttval=*(tptr+i+5);\n-        \tND_PRINT((ndo, \""\\n\\t      Priority: %d, RES: %d, Sel: %d\"",\n-        \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07)));\n-        \tND_PRINT((ndo, \""Protocol ID: %d\"", EXTRACT_16BITS(tptr + i + 5)));\n+        \tND_PRINT((ndo, \""\\n\\t      Priority: %u, RES: %u, Sel: %u, Protocol ID: %u\"",\n+        \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07),\n+        \t\t EXTRACT_16BITS(tptr + i + 5)));\n         \ti=i+3;\n         }\n         break;""}<_**next**_>{""sha"": ""ef8bffc74dc42592b64ae99f0694556960eb0bb3"", ""filename"": ""tests/TESTLIST"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/34cec721d39c76be1e0a600829a7b17bdfb832b6/tests/TESTLIST"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/34cec721d39c76be1e0a600829a7b17bdfb832b6/tests/TESTLIST"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/TESTLIST?ref=34cec721d39c76be1e0a600829a7b17bdfb832b6"", ""patch"": ""@@ -479,6 +479,8 @@ dns_fwdptr\t\tdns_fwdptr.pcap\t\t\tdns_fwdptr.out\t\t-vvv -e\n isis-areaaddr-oobr-1\tisis-areaaddr-oobr-1.pcap\tisis-areaaddr-oobr-1.out\t\t-vvv -e\n isis-areaaddr-oobr-2\tisis-areaaddr-oobr-2.pcap\tisis-areaaddr-oobr-2.out\t\t-vvv -e\n isis-extd-ipreach-oobr\tisis-extd-ipreach-oobr.pcap\tisis-extd-ipreach-oobr.out\t\t-vvv -e\n+lldp-infinite-loop-1\tlldp-infinite-loop-1.pcap\tlldp-infinite-loop-1.out\t\t-vvv -e\n+lldp-infinite-loop-2\tlldp-infinite-loop-2.pcap\tlldp-infinite-loop-2.out\t\t-vvv -e\n \n # RTP tests\n # fuzzed pcap""}<_**next**_>{""sha"": ""31ba710074e0273c5f92a3f5ff9cd9876657cfef"", ""filename"": ""tests/lldp-infinite-loop-1.out"", ""status"": ""added"", ""additions"": 134, ""deletions"": 0, ""changes"": 134, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/34cec721d39c76be1e0a600829a7b17bdfb832b6/tests/lldp-infinite-loop-1.out"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/34cec721d39c76be1e0a600829a7b17bdfb832b6/tests/lldp-infinite-loop-1.out"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/lldp-infinite-loop-1.out?ref=34cec721d39c76be1e0a600829a7b17bdfb832b6"", ""patch"": ""@@ -0,0 +1,134 @@\n+08:00:27:42:ba:59 > 01:80:c2:00:00:0e, ethertype LLDP (0x88cc), length 1755: LLDP, length 1741\n+\tChassis ID TLV (1), length 7\n+\t  Subtype MAC address (4): 08:00:27:42:ba:59\n+\t  0x0000:  0408 0027 42ba 59\n+\tPort ID TLV (2), length 7\n+\t  Subtype MAC address (3): 08:00:27:42:ba:59\n+\t  0x0000:  0308 0027 42ba 59\n+\tTime to Live TLV (3), length 2: TTL 120s\n+\t  0x0000:  0078\n+\tOrganization specific TLV (127), length 6: OUI Ethernet bridged (0x0080c2)\n+\t  Port VLAN Id Subtype (1)\n+\t    port vlan id (PVID): 0\n+\t  0x0000:  0080 c201 0000\n+\tOrganization specific TLV (127), length 7: OUI Ethernet bridged (0x0080c2)\n+\t  Port and Protocol VLAN ID Subtype (2)\n+\t    port and protocol vlan id (PPVID): 0, flags [supported] (0x02)\n+\t  0x0000:  0080 c202 0200 00\n+\tOrganization specific TLV (127), length 14: OUI Ethernet bridged (0x0080c2)\n+\t  VLAN name Subtype (3)\n+\t    vlan id (VID): 1\n+\t    vlan name: default\n+\t  0x0000:  0080 c203 0001 0764 6566 6175 6c74\n+\tOrganization specific TLV (127), length 13: OUI Ethernet bridged (0x0080c2)\n+\t  Protocol Identity Subtype (4)\n+\t    protocol identity: \n+\t  0x0000:  0080 c204 0800 0042 4203 0080 08\n+\tOrganization specific TLV (127), length 263: OUI Ethernet bridged (0x0080c2)\n+\t  Application Priority Subtype (12)\n+\t    RES: 0\n+\t    Application Priority Table\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 6, RES: 0, Sel: 2, Protocol ID: 49676\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 6, RES: 0, Sel: 2, Protocol ID: 49676\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 6, RES: 0, Sel: 2, Protocol ID: 49676\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 6, RES: 0, Sel: 2, Protocol ID: 49676\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 6, RES: 0, Sel: 2, Protocol ID: 49676\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 6, RES: 0, Sel: 2, Protocol ID: 49676\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 6, RES: 0, Sel: 2, Protocol ID: 49676\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t  0x0000:  0080 c20c 0000 0000 0000 0000 80c2 0c00\n+\t  0x0010:  0000 0000 0000 0080 c20c 0000 0000 0000\n+\t  0x0020:  0000 80c2 0c00 0000 0000 0000 0080 c20c\n+\t  0x0030:  0000 0000 0000 0000 80c2 0c00 0000 0000\n+\t  0x0040:  0000 0080 c20c 0000 0000 0000 0000 80c2\n+\t  0x0050:  0c00 0000 0000 0000 0080 c20c 0000 0000\n+\t  0x0060:  0000 0000 80c2 0c00 0000 0000 0000 0080\n+\t  0x0070:  c20c 0000 0000 0000 0000 80c2 0c00 0000\n+\t  0x0080:  0000 0000 0080 c20c 0000 0000 0000 0000\n+\t  0x0090:  80c2 0c00 0000 0000 0000 0080 c20c 0000\n+\t  0x00a0:  0000 0000 0000 80c2 0c00 0000 0000 0000\n+\t  0x00b0:  0080 c20c 0000 0000 0000 0000 80c2 0c00\n+\t  0x00c0:  0000 0000 0000 0080 c20c 0000 0000 0000\n+\t  0x00d0:  0000 80c2 0c00 0000 0000 0000 0080 c20c\n+\t  0x00e0:  0000 0000 0000 0000 80c2 0c00 0000 0000\n+\t  0x00f0:  0000 0080 c20c 0000 0000 0000 0000 80c2\n+\t  0x0100:  0c00 0000 0000 00\n+\tEnd TLV (0), length 0""}<_**next**_>{""sha"": ""232dbbd25dba417ffb46f90c1172d81a87626ec9"", ""filename"": ""tests/lldp-infinite-loop-1.pcap"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/34cec721d39c76be1e0a600829a7b17bdfb832b6/tests/lldp-infinite-loop-1.pcap"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/34cec721d39c76be1e0a600829a7b17bdfb832b6/tests/lldp-infinite-loop-1.pcap"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/lldp-infinite-loop-1.pcap?ref=34cec721d39c76be1e0a600829a7b17bdfb832b6""}<_**next**_>{""sha"": ""4016681300a8bf16c2f1dc0f12970d6481915fcb"", ""filename"": ""tests/lldp-infinite-loop-2.out"", ""status"": ""added"", ""additions"": 161, ""deletions"": 0, ""changes"": 161, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/34cec721d39c76be1e0a600829a7b17bdfb832b6/tests/lldp-infinite-loop-2.out"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/34cec721d39c76be1e0a600829a7b17bdfb832b6/tests/lldp-infinite-loop-2.out"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/lldp-infinite-loop-2.out?ref=34cec721d39c76be1e0a600829a7b17bdfb832b6"", ""patch"": ""@@ -0,0 +1,161 @@\n+08:00:27:0d:f1:3c > 01:80:c2:00:00:0e, ethertype LLDP (0x88cc), length 2130: LLDP, length 2116\n+\tChassis ID TLV (1), length 7\n+\t  Subtype MAC address (4): 08:00:27:0d:f1:3c\n+\t  0x0000:  0408 0027 0df1 3c\n+\tPort ID TLV (2), length 7\n+\t  Subtype MAC address (3): 08:00:27:0d:f1:3c\n+\t  0x0000:  0308 0027 0df1 3c\n+\tTime to Live TLV (3), length 2: TTL 120s\n+\t  0x0000:  0078\n+\tOrganization specific TLV (127), length 6: OUI Ethernet bridged (0x0080c2)\n+\t  Port VLAN Id Subtype (1)\n+\t    port vlan id (PVID): 1\n+\t  0x0000:  0080 c201 0001\n+\tOrganization specific TLV (127), length 7: OUI Ethernet bridged (0x0080c2)\n+\t  Port and Protocol VLAN ID Subtype (2)\n+\t    port and protocol vlan id (PPVID): 0, flags [supported] (0x02)\n+\t  0x0000:  0080 c202 0200 00\n+\tOrganization specific TLV (127), length 14: OUI Ethernet bridged (0x0080c2)\n+\t  VLAN name Subtype (3)\n+\t    vlan id (VID): 1\n+\t    vlan name: default\n+\t  0x0000:  0080 c203 0001 0764 6566 6175 6c74\n+\tOrganization specific TLV (127), length 13: OUI Ethernet bridged (0x0080c2)\n+\t  Protocol Identity Subtype (4)\n+\t    protocol identity: \n+\t  0x0000:  0080 c204 0800 0042 4203 0000 03\n+\tOrganization specific TLV (127), length 9: OUI Ethernet bridged (0x0080c2)\n+\t  EVB Subtype (13)\n+\t    EVB Bridge Status\n+\t      RES: 0, BGID: 0, RRCAP: 1, RRCTR: 0\n+\t    EVB Station Status\n+\t      RES: 0, SGID: 0, RRREQ: 0,RRSTAT: 0\n+\t    R: 7, RTE: 21, EVB Mode: EVB Bridge [1]\n+\t    ROL: 0, RWD: 30, RES: 0, ROL: 0, RKA: 15\n+\t  0x0000:  0080 c20d 0200 f55e 0f\n+\tOrganization specific TLV (127), length 266: OUI Ethernet bridged (0x0080c2)\n+\t  CDCP Subtype (14)\n+\t    Role: 0, RES: 0, Scomp: 0 ChnCap: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t    SCID: 3104, SVID: 3584\n+\t    SCID: 0, SVID: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t    SCID: 3104, SVID: 3584\n+\t    SCID: 0, SVID: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t    SCID: 3104, SVID: 3584\n+\t    SCID: 0, SVID: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t    SCID: 3104, SVID: 3584\n+\t    SCID: 0, SVID: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t    SCID: 3104, SVID: 3584\n+\t    SCID: 0, SVID: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t    SCID: 3104, SVID: 3584\n+\t    SCID: 0, SVID: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t    SCID: 3104, SVID: 3584\n+\t    SCID: 0, SVID: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t  0x0000:  0080 c20e 0000 00a7 0010 0100 00c2 0e00\n+\t  0x0010:  0000 a700 1001 0000 c20e 0000 00a7 0010\n+\t  0x0020:  0100 00c2 0e00 0000 a700 1001 0000 c20e\n+\t  0x0030:  0000 00a7 0010 0100 00c2 0e00 0000 a700\n+\t  0x0040:  1001 0000 c20e 0000 00a7 0010 0100 00c2\n+\t  0x0050:  0e00 0000 a700 1001 0000 c20e 0000 00a7\n+\t  0x0060:  0010 0100 00c2 0e00 0000 a700 1001 0000\n+\t  0x0070:  c20e 0000 00a7 0010 0100 00c2 0e00 0000\n+\t  0x0080:  a700 1001 0000 c20e 0000 00a7 0010 0100\n+\t  0x0090:  00c2 0e00 0000 a700 1001 0000 c20e 0000\n+\t  0x00a0:  00a7 0010 0100 00c2 0e00 0000 a700 1001\n+\t  0x00b0:  0000 c20e 0000 00a7 0010 0100 00c2 0e00\n+\t  0x00c0:  0000 a700 1001 0000 c20e 0000 00a7 0010\n+\t  0x00d0:  0100 00c2 0e00 0000 a700 1001 0000 c20e\n+\t  0x00e0:  0000 00a7 0010 0100 00c2 0e00 0000 a700\n+\t  0x00f0:  1001 0000 c20e 0000 00a7 0010 0100 00c2\n+\t  0x0100:  0e00 0000 a700 1001 0000\n+\tUnknown TLV (97), length 14\n+\t  0x0000:  0000 00a7 0010 0100 00c2 0e00 0000\n+\tUnknown TLV (83), length 256\n+\t  0x0000:  1001 0000 c20e 0000 00a7 0010 0100 00c2\n+\t  0x0010:  0e00 0000 a700 1001 0000 c20e 0000 00a7\n+\t  0x0020:  0010 0100 00c2 0e00 0000 a700 1001 0000\n+\t  0x0030:  c20e 0000 00a7 0010 0100 00c2 0e00 0000\n+\t  0x0040:  a700 1001 0000 c20e 0000 00a7 0010 0100\n+\t  0x0050:  00c2 0e00 0000 a700 1001 0000 c20e 0000\n+\t  0x0060:  00a7 0010 0100 00c2 0e00 0000 a700 1001\n+\t  0x0070:  0000 c20e 0000 00a7 0010 0100 00c2 0e00\n+\t  0x0080:  0000 a700 1001 0000 c20e 0000 00a7 0010\n+\t  0x0090:  0100 00c2 0e00 0000 a700 1001 0000 c20e\n+\t  0x00a0:  0000 00a7 0010 0100 00c2 0e00 0000 a700\n+\t  0x00b0:  1001 0000 c20e 0000 00a7 0010 0100 00c2\n+\t  0x00c0:  0e00 0000 a700 1001 0000 c20e 0000 00a7\n+\t  0x00d0:  0010 0100 00c2 0e00 0000 a700 1001 0000\n+\t  0x00e0:  c20e 0000 00a7 0010 0100 00c2 0e00 0000\n+\t  0x00f0:  a700 1001 0000 c20e 0000 00a7 0010 0100\n+\tEnd TLV (0), length 194""}<_**next**_>{""sha"": ""e8599831820017b9d2fdbff74db8c38eefc908a3"", ""filename"": ""tests/lldp-infinite-loop-2.pcap"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/34cec721d39c76be1e0a600829a7b17bdfb832b6/tests/lldp-infinite-loop-2.pcap"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/34cec721d39c76be1e0a600829a7b17bdfb832b6/tests/lldp-infinite-loop-2.pcap"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/lldp-infinite-loop-2.pcap?ref=34cec721d39c76be1e0a600829a7b17bdfb832b6""}","lldp_private_8021_print(netdissect_options *ndo,
                        const u_char *tptr, u_int tlv_len)
{
     int subtype, hexdump = FALSE;
     u_int sublen;
     u_int tval;
    u_int i;
 
     if (tlv_len < 4) {
         return hexdump;
    }
    subtype = *(tptr+3);

    ND_PRINT((ndo, ""\n\t  %s Subtype (%u)"",
           tok2str(lldp_8021_subtype_values, ""unknown"", subtype),
           subtype));

    switch (subtype) {
    case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID:
        if (tlv_len < 6) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    port vlan id (PVID): %u"",
               EXTRACT_16BITS(tptr + 4)));
        break;
    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID:
        if (tlv_len < 7) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    port and protocol vlan id (PPVID): %u, flags [%s] (0x%02x)"",
               EXTRACT_16BITS(tptr+5),
	       bittok2str(lldp_8021_port_protocol_id_values, ""none"", *(tptr+4)),
	       *(tptr + 4)));
        break;
    case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME:
        if (tlv_len < 6) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    vlan id (VID): %u"", EXTRACT_16BITS(tptr + 4)));
        if (tlv_len < 7) {
            return hexdump;
        }
        sublen = *(tptr+6);
        if (tlv_len < 7+sublen) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    vlan name: ""));
        safeputs(ndo, tptr + 7, sublen);
        break;
    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY:
        if (tlv_len < 5) {
            return hexdump;
        }
        sublen = *(tptr+4);
        if (tlv_len < 5+sublen) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    protocol identity: ""));
        safeputs(ndo, tptr + 5, sublen);
        break;
    case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH){
        	return hexdump;
        }
        tval=*(tptr+4);
        ND_PRINT((ndo, ""\n\t    Pre-Priority CNPV Indicator""));
        ND_PRINT((ndo, ""\n\t     Priority : 0  1  2  3  4  5  6  7""));
        ND_PRINT((ndo, ""\n\t     Value    : ""));
        for(i=0;i<NO_OF_BITS;i++)
            ND_PRINT((ndo, ""%-2d "", (tval >> i) & 0x01));
        tval=*(tptr+5);
        ND_PRINT((ndo, ""\n\t    Pre-Priority Ready Indicator""));
        ND_PRINT((ndo, ""\n\t     Priority : 0  1  2  3  4  5  6  7""));
        ND_PRINT((ndo, ""\n\t     Value    : ""));
        for(i=0;i<NO_OF_BITS;i++)
            ND_PRINT((ndo, ""%-2d "", (tval >> i) & 0x01));
        break;

    case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH) {
            return hexdump;
        }
        tval=*(tptr+4);
        ND_PRINT((ndo, ""\n\t    Willing:%d, CBS:%d, RES:%d, Max TCs:%d"",
        	tval >> 7, (tval >> 6) & 0x02, (tval >> 3) & 0x07, tval & 0x07));

        /*Print Priority Assignment Table*/
        print_ets_priority_assignment_table(ndo, tptr + 5);

        /*Print TC Bandwidth Table*/
        print_tc_bandwidth_table(ndo, tptr + 9);

        /* Print TSA Assignment Table */
        print_tsa_assignment_table(ndo, tptr + 17);

        break;

    case LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION_LENGTH) {
        	return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    RES: %d"", *(tptr + 4)));
        /*Print Priority Assignment Table */
        print_ets_priority_assignment_table(ndo, tptr + 5);
        /*Print TC Bandwidth Table */
        print_tc_bandwidth_table(ndo, tptr + 9);
        /* Print TSA Assignment Table */
        print_tsa_assignment_table(ndo, tptr + 17);
        break;

    case LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION_LENGTH) {
            return hexdump;
        }
        tval=*(tptr+4);
        ND_PRINT((ndo, ""\n\t    Willing: %d, MBC: %d, RES: %d, PFC cap:%d "",
        	tval >> 7, (tval >> 6) & 0x01, (tval >> 4) & 0x03, (tval & 0x0f)));
        ND_PRINT((ndo, ""\n\t    PFC Enable""));
        tval=*(tptr+5);
        ND_PRINT((ndo, ""\n\t     Priority : 0  1  2  3  4  5  6  7""));
        ND_PRINT((ndo, ""\n\t     Value    : ""));
        for(i=0;i<NO_OF_BITS;i++)
            ND_PRINT((ndo, ""%-2d "", (tval >> i) & 0x01));
        break;

    case LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    RES: %d"", *(tptr + 4)));
        if(tlv_len<=LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH){
        	return hexdump;
        }
        /*  Length of Application Priority Table */
        sublen=tlv_len-5;
        if(sublen%3!=0){
        	return hexdump;
        }
        i=0;
         ND_PRINT((ndo, ""\n\t    Application Priority Table""));
         while(i<sublen) {
         	tval=*(tptr+i+5);
        	ND_PRINT((ndo, ""\n\t      Priority: %u, RES: %u, Sel: %u, Protocol ID: %u"",
        		 tval >> 5, (tval >> 3) & 0x03, (tval & 0x07),
        		 EXTRACT_16BITS(tptr + i + 5)));
         	i=i+3;
         }
         break;
    case LLDP_PRIVATE_8021_SUBTYPE_EVB:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH){
        	return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    EVB Bridge Status""));
        tval=*(tptr+4);
        ND_PRINT((ndo, ""\n\t      RES: %d, BGID: %d, RRCAP: %d, RRCTR: %d"",
        	tval >> 3, (tval >> 2) & 0x01, (tval >> 1) & 0x01, tval & 0x01));
        ND_PRINT((ndo, ""\n\t    EVB Station Status""));
        tval=*(tptr+5);
        ND_PRINT((ndo, ""\n\t      RES: %d, SGID: %d, RRREQ: %d,RRSTAT: %d"",
        	tval >> 4, (tval >> 3) & 0x01, (tval >> 2) & 0x01, tval & 0x03));
        tval=*(tptr+6);
        ND_PRINT((ndo, ""\n\t    R: %d, RTE: %d, "",tval >> 5, tval & 0x1f));
        tval=*(tptr+7);
        ND_PRINT((ndo, ""EVB Mode: %s [%d]"",
        	tok2str(lldp_evb_mode_values, ""unknown"", tval >> 6), tval >> 6));
        ND_PRINT((ndo, ""\n\t    ROL: %d, RWD: %d, "", (tval >> 5) & 0x01, tval & 0x1f));
        tval=*(tptr+8);
        ND_PRINT((ndo, ""RES: %d, ROL: %d, RKA: %d"", tval >> 6, (tval >> 5) & 0x01, tval & 0x1f));
        break;

    case LLDP_PRIVATE_8021_SUBTYPE_CDCP:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CDCP_MIN_LENGTH){
        	return hexdump;
        }
        tval=*(tptr+4);
        ND_PRINT((ndo, ""\n\t    Role: %d, RES: %d, Scomp: %d "",
        	tval >> 7, (tval >> 4) & 0x07, (tval >> 3) & 0x01));
        ND_PRINT((ndo, ""ChnCap: %d"", EXTRACT_16BITS(tptr + 6) & 0x0fff));
        sublen=tlv_len-8;
        if(sublen%3!=0) {
        	return hexdump;
        }
        i=0;
        while(i<sublen) {
        	tval=EXTRACT_24BITS(tptr+i+8);
        	ND_PRINT((ndo, ""\n\t    SCID: %d, SVID: %d"",
        		tval >> 12, tval & 0x000fff));
        	i=i+3;
        }
        break;

    default:
        hexdump = TRUE;
        break;
    }

    return hexdump;
}
","lldp_private_8021_print(netdissect_options *ndo,
                        const u_char *tptr, u_int tlv_len)
{
     int subtype, hexdump = FALSE;
     u_int sublen;
     u_int tval;
    uint8_t i;
 
     if (tlv_len < 4) {
         return hexdump;
    }
    subtype = *(tptr+3);

    ND_PRINT((ndo, ""\n\t  %s Subtype (%u)"",
           tok2str(lldp_8021_subtype_values, ""unknown"", subtype),
           subtype));

    switch (subtype) {
    case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID:
        if (tlv_len < 6) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    port vlan id (PVID): %u"",
               EXTRACT_16BITS(tptr + 4)));
        break;
    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID:
        if (tlv_len < 7) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    port and protocol vlan id (PPVID): %u, flags [%s] (0x%02x)"",
               EXTRACT_16BITS(tptr+5),
	       bittok2str(lldp_8021_port_protocol_id_values, ""none"", *(tptr+4)),
	       *(tptr + 4)));
        break;
    case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME:
        if (tlv_len < 6) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    vlan id (VID): %u"", EXTRACT_16BITS(tptr + 4)));
        if (tlv_len < 7) {
            return hexdump;
        }
        sublen = *(tptr+6);
        if (tlv_len < 7+sublen) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    vlan name: ""));
        safeputs(ndo, tptr + 7, sublen);
        break;
    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY:
        if (tlv_len < 5) {
            return hexdump;
        }
        sublen = *(tptr+4);
        if (tlv_len < 5+sublen) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    protocol identity: ""));
        safeputs(ndo, tptr + 5, sublen);
        break;
    case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH){
        	return hexdump;
        }
        tval=*(tptr+4);
        ND_PRINT((ndo, ""\n\t    Pre-Priority CNPV Indicator""));
        ND_PRINT((ndo, ""\n\t     Priority : 0  1  2  3  4  5  6  7""));
        ND_PRINT((ndo, ""\n\t     Value    : ""));
        for(i=0;i<NO_OF_BITS;i++)
            ND_PRINT((ndo, ""%-2d "", (tval >> i) & 0x01));
        tval=*(tptr+5);
        ND_PRINT((ndo, ""\n\t    Pre-Priority Ready Indicator""));
        ND_PRINT((ndo, ""\n\t     Priority : 0  1  2  3  4  5  6  7""));
        ND_PRINT((ndo, ""\n\t     Value    : ""));
        for(i=0;i<NO_OF_BITS;i++)
            ND_PRINT((ndo, ""%-2d "", (tval >> i) & 0x01));
        break;

    case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH) {
            return hexdump;
        }
        tval=*(tptr+4);
        ND_PRINT((ndo, ""\n\t    Willing:%d, CBS:%d, RES:%d, Max TCs:%d"",
        	tval >> 7, (tval >> 6) & 0x02, (tval >> 3) & 0x07, tval & 0x07));

        /*Print Priority Assignment Table*/
        print_ets_priority_assignment_table(ndo, tptr + 5);

        /*Print TC Bandwidth Table*/
        print_tc_bandwidth_table(ndo, tptr + 9);

        /* Print TSA Assignment Table */
        print_tsa_assignment_table(ndo, tptr + 17);

        break;

    case LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION_LENGTH) {
        	return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    RES: %d"", *(tptr + 4)));
        /*Print Priority Assignment Table */
        print_ets_priority_assignment_table(ndo, tptr + 5);
        /*Print TC Bandwidth Table */
        print_tc_bandwidth_table(ndo, tptr + 9);
        /* Print TSA Assignment Table */
        print_tsa_assignment_table(ndo, tptr + 17);
        break;

    case LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION_LENGTH) {
            return hexdump;
        }
        tval=*(tptr+4);
        ND_PRINT((ndo, ""\n\t    Willing: %d, MBC: %d, RES: %d, PFC cap:%d "",
        	tval >> 7, (tval >> 6) & 0x01, (tval >> 4) & 0x03, (tval & 0x0f)));
        ND_PRINT((ndo, ""\n\t    PFC Enable""));
        tval=*(tptr+5);
        ND_PRINT((ndo, ""\n\t     Priority : 0  1  2  3  4  5  6  7""));
        ND_PRINT((ndo, ""\n\t     Value    : ""));
        for(i=0;i<NO_OF_BITS;i++)
            ND_PRINT((ndo, ""%-2d "", (tval >> i) & 0x01));
        break;

    case LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    RES: %d"", *(tptr + 4)));
        if(tlv_len<=LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH){
        	return hexdump;
        }
        /*  Length of Application Priority Table */
        sublen=tlv_len-5;
        if(sublen%3!=0){
        	return hexdump;
        }
        i=0;
         ND_PRINT((ndo, ""\n\t    Application Priority Table""));
         while(i<sublen) {
         	tval=*(tptr+i+5);
        	ND_PRINT((ndo, ""\n\t      Priority: %d, RES: %d, Sel: %d"",
        		 tval >> 5, (tval >> 3) & 0x03, (tval & 0x07)));
        	ND_PRINT((ndo, ""Protocol ID: %d"", EXTRACT_16BITS(tptr + i + 5)));
         	i=i+3;
         }
         break;
    case LLDP_PRIVATE_8021_SUBTYPE_EVB:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH){
        	return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    EVB Bridge Status""));
        tval=*(tptr+4);
        ND_PRINT((ndo, ""\n\t      RES: %d, BGID: %d, RRCAP: %d, RRCTR: %d"",
        	tval >> 3, (tval >> 2) & 0x01, (tval >> 1) & 0x01, tval & 0x01));
        ND_PRINT((ndo, ""\n\t    EVB Station Status""));
        tval=*(tptr+5);
        ND_PRINT((ndo, ""\n\t      RES: %d, SGID: %d, RRREQ: %d,RRSTAT: %d"",
        	tval >> 4, (tval >> 3) & 0x01, (tval >> 2) & 0x01, tval & 0x03));
        tval=*(tptr+6);
        ND_PRINT((ndo, ""\n\t    R: %d, RTE: %d, "",tval >> 5, tval & 0x1f));
        tval=*(tptr+7);
        ND_PRINT((ndo, ""EVB Mode: %s [%d]"",
        	tok2str(lldp_evb_mode_values, ""unknown"", tval >> 6), tval >> 6));
        ND_PRINT((ndo, ""\n\t    ROL: %d, RWD: %d, "", (tval >> 5) & 0x01, tval & 0x1f));
        tval=*(tptr+8);
        ND_PRINT((ndo, ""RES: %d, ROL: %d, RKA: %d"", tval >> 6, (tval >> 5) & 0x01, tval & 0x1f));
        break;

    case LLDP_PRIVATE_8021_SUBTYPE_CDCP:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CDCP_MIN_LENGTH){
        	return hexdump;
        }
        tval=*(tptr+4);
        ND_PRINT((ndo, ""\n\t    Role: %d, RES: %d, Scomp: %d "",
        	tval >> 7, (tval >> 4) & 0x07, (tval >> 3) & 0x01));
        ND_PRINT((ndo, ""ChnCap: %d"", EXTRACT_16BITS(tptr + 6) & 0x0fff));
        sublen=tlv_len-8;
        if(sublen%3!=0) {
        	return hexdump;
        }
        i=0;
        while(i<sublen) {
        	tval=EXTRACT_24BITS(tptr+i+8);
        	ND_PRINT((ndo, ""\n\t    SCID: %d, SVID: %d"",
        		tval >> 12, tval & 0x000fff));
        	i=i+3;
        }
        break;

    default:
        hexdump = TRUE;
        break;
    }

    return hexdump;
}
",C,"    u_int i;
        	ND_PRINT((ndo, ""\n\t      Priority: %u, RES: %u, Sel: %u, Protocol ID: %u"",
        		 tval >> 5, (tval >> 3) & 0x03, (tval & 0x07),
        		 EXTRACT_16BITS(tptr + i + 5)));
","    uint8_t i;
        	ND_PRINT((ndo, ""\n\t      Priority: %d, RES: %d, Sel: %d"",
        		 tval >> 5, (tval >> 3) & 0x03, (tval & 0x07)));
        	ND_PRINT((ndo, ""Protocol ID: %d"", EXTRACT_16BITS(tptr + i + 5)));
",,"@@ -651,7 +651,7 @@ lldp_private_8021_print(netdissect_options *ndo,
     int subtype, hexdump = FALSE;
     u_int sublen;
     u_int tval;
-    uint8_t i;
+    u_int i;
 
     if (tlv_len < 4) {
         return hexdump;
@@ -787,9 +787,9 @@ lldp_private_8021_print(netdissect_options *ndo,
         ND_PRINT((ndo, ""\n\t    Application Priority Table""));
         while(i<sublen) {
         	tval=*(tptr+i+5);
-        	ND_PRINT((ndo, ""\n\t      Priority: %d, RES: %d, Sel: %d"",
-        		 tval >> 5, (tval >> 3) & 0x03, (tval & 0x07)));
-        	ND_PRINT((ndo, ""Protocol ID: %d"", EXTRACT_16BITS(tptr + i + 5)));
+        	ND_PRINT((ndo, ""\n\t      Priority: %u, RES: %u, Sel: %u, Protocol ID: %u"",
+        		 tval >> 5, (tval >> 3) & 0x03, (tval & 0x07),
+        		 EXTRACT_16BITS(tptr + i + 5)));
         	i=i+3;
         }
         break;",tcpdump,34cec721d39c76be1e0a600829a7b17bdfb832b6,979dcefd7b259e9e233f77fe1c5312793bfd948f,1,"lldp_private_8021_print(netdissect_options *ndo,
                        const u_char *tptr, u_int tlv_len)
{
     int subtype, hexdump = FALSE;
     u_int sublen;
     u_int tval;
//flaw_line_below:
    uint8_t i;
//fix_flaw_line_below:
//    u_int i;
 
     if (tlv_len < 4) {
         return hexdump;
    }
    subtype = *(tptr+3);

    ND_PRINT((ndo, ""\n\t  %s Subtype (%u)"",
           tok2str(lldp_8021_subtype_values, ""unknown"", subtype),
           subtype));

    switch (subtype) {
    case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID:
        if (tlv_len < 6) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    port vlan id (PVID): %u"",
               EXTRACT_16BITS(tptr + 4)));
        break;
    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID:
        if (tlv_len < 7) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    port and protocol vlan id (PPVID): %u, flags [%s] (0x%02x)"",
               EXTRACT_16BITS(tptr+5),
	       bittok2str(lldp_8021_port_protocol_id_values, ""none"", *(tptr+4)),
	       *(tptr + 4)));
        break;
    case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME:
        if (tlv_len < 6) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    vlan id (VID): %u"", EXTRACT_16BITS(tptr + 4)));
        if (tlv_len < 7) {
            return hexdump;
        }
        sublen = *(tptr+6);
        if (tlv_len < 7+sublen) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    vlan name: ""));
        safeputs(ndo, tptr + 7, sublen);
        break;
    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY:
        if (tlv_len < 5) {
            return hexdump;
        }
        sublen = *(tptr+4);
        if (tlv_len < 5+sublen) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    protocol identity: ""));
        safeputs(ndo, tptr + 5, sublen);
        break;
    case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH){
        	return hexdump;
        }
        tval=*(tptr+4);
        ND_PRINT((ndo, ""\n\t    Pre-Priority CNPV Indicator""));
        ND_PRINT((ndo, ""\n\t     Priority : 0  1  2  3  4  5  6  7""));
        ND_PRINT((ndo, ""\n\t     Value    : ""));
        for(i=0;i<NO_OF_BITS;i++)
            ND_PRINT((ndo, ""%-2d "", (tval >> i) & 0x01));
        tval=*(tptr+5);
        ND_PRINT((ndo, ""\n\t    Pre-Priority Ready Indicator""));
        ND_PRINT((ndo, ""\n\t     Priority : 0  1  2  3  4  5  6  7""));
        ND_PRINT((ndo, ""\n\t     Value    : ""));
        for(i=0;i<NO_OF_BITS;i++)
            ND_PRINT((ndo, ""%-2d "", (tval >> i) & 0x01));
        break;

    case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH) {
            return hexdump;
        }
        tval=*(tptr+4);
        ND_PRINT((ndo, ""\n\t    Willing:%d, CBS:%d, RES:%d, Max TCs:%d"",
        	tval >> 7, (tval >> 6) & 0x02, (tval >> 3) & 0x07, tval & 0x07));

        /*Print Priority Assignment Table*/
        print_ets_priority_assignment_table(ndo, tptr + 5);

        /*Print TC Bandwidth Table*/
        print_tc_bandwidth_table(ndo, tptr + 9);

        /* Print TSA Assignment Table */
        print_tsa_assignment_table(ndo, tptr + 17);

        break;

    case LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION_LENGTH) {
        	return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    RES: %d"", *(tptr + 4)));
        /*Print Priority Assignment Table */
        print_ets_priority_assignment_table(ndo, tptr + 5);
        /*Print TC Bandwidth Table */
        print_tc_bandwidth_table(ndo, tptr + 9);
        /* Print TSA Assignment Table */
        print_tsa_assignment_table(ndo, tptr + 17);
        break;

    case LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION_LENGTH) {
            return hexdump;
        }
        tval=*(tptr+4);
        ND_PRINT((ndo, ""\n\t    Willing: %d, MBC: %d, RES: %d, PFC cap:%d "",
        	tval >> 7, (tval >> 6) & 0x01, (tval >> 4) & 0x03, (tval & 0x0f)));
        ND_PRINT((ndo, ""\n\t    PFC Enable""));
        tval=*(tptr+5);
        ND_PRINT((ndo, ""\n\t     Priority : 0  1  2  3  4  5  6  7""));
        ND_PRINT((ndo, ""\n\t     Value    : ""));
        for(i=0;i<NO_OF_BITS;i++)
            ND_PRINT((ndo, ""%-2d "", (tval >> i) & 0x01));
        break;

    case LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    RES: %d"", *(tptr + 4)));
        if(tlv_len<=LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH){
        	return hexdump;
        }
        /*  Length of Application Priority Table */
        sublen=tlv_len-5;
        if(sublen%3!=0){
        	return hexdump;
        }
        i=0;
         ND_PRINT((ndo, ""\n\t    Application Priority Table""));
         while(i<sublen) {
         	tval=*(tptr+i+5);
//flaw_line_below:
        	ND_PRINT((ndo, ""\n\t      Priority: %d, RES: %d, Sel: %d"",
//flaw_line_below:
        		 tval >> 5, (tval >> 3) & 0x03, (tval & 0x07)));
//flaw_line_below:
        	ND_PRINT((ndo, ""Protocol ID: %d"", EXTRACT_16BITS(tptr + i + 5)));
//fix_flaw_line_below:
//        	ND_PRINT((ndo, ""\n\t      Priority: %u, RES: %u, Sel: %u, Protocol ID: %u"",
//fix_flaw_line_below:
//        		 tval >> 5, (tval >> 3) & 0x03, (tval & 0x07),
//fix_flaw_line_below:
//        		 EXTRACT_16BITS(tptr + i + 5)));
         	i=i+3;
         }
         break;
    case LLDP_PRIVATE_8021_SUBTYPE_EVB:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH){
        	return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    EVB Bridge Status""));
        tval=*(tptr+4);
        ND_PRINT((ndo, ""\n\t      RES: %d, BGID: %d, RRCAP: %d, RRCTR: %d"",
        	tval >> 3, (tval >> 2) & 0x01, (tval >> 1) & 0x01, tval & 0x01));
        ND_PRINT((ndo, ""\n\t    EVB Station Status""));
        tval=*(tptr+5);
        ND_PRINT((ndo, ""\n\t      RES: %d, SGID: %d, RRREQ: %d,RRSTAT: %d"",
        	tval >> 4, (tval >> 3) & 0x01, (tval >> 2) & 0x01, tval & 0x03));
        tval=*(tptr+6);
        ND_PRINT((ndo, ""\n\t    R: %d, RTE: %d, "",tval >> 5, tval & 0x1f));
        tval=*(tptr+7);
        ND_PRINT((ndo, ""EVB Mode: %s [%d]"",
        	tok2str(lldp_evb_mode_values, ""unknown"", tval >> 6), tval >> 6));
        ND_PRINT((ndo, ""\n\t    ROL: %d, RWD: %d, "", (tval >> 5) & 0x01, tval & 0x1f));
        tval=*(tptr+8);
        ND_PRINT((ndo, ""RES: %d, ROL: %d, RKA: %d"", tval >> 6, (tval >> 5) & 0x01, tval & 0x1f));
        break;

    case LLDP_PRIVATE_8021_SUBTYPE_CDCP:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CDCP_MIN_LENGTH){
        	return hexdump;
        }
        tval=*(tptr+4);
        ND_PRINT((ndo, ""\n\t    Role: %d, RES: %d, Scomp: %d "",
        	tval >> 7, (tval >> 4) & 0x07, (tval >> 3) & 0x01));
        ND_PRINT((ndo, ""ChnCap: %d"", EXTRACT_16BITS(tptr + 6) & 0x0fff));
        sublen=tlv_len-8;
        if(sublen%3!=0) {
        	return hexdump;
        }
        i=0;
        while(i<sublen) {
        	tval=EXTRACT_24BITS(tptr+i+8);
        	ND_PRINT((ndo, ""\n\t    SCID: %d, SVID: %d"",
        		tval >> 12, tval & 0x000fff));
        	i=i+3;
        }
        break;

    default:
        hexdump = TRUE;
        break;
    }

    return hexdump;
}
"
3348,181084,,Remote,Not required,Partial,CVE-2017-12995,https://www.cvedetails.com/cve/CVE-2017-12995/,CWE-835,Low,,,,2017-09-14,5.0,The DNS parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-domain.c:ns_print().,2019-10-02,,19,https://github.com/the-tcpdump-group/tcpdump/commit/3a76fd7c95fced2c2f8c8148a9055c3a542eff29,3a76fd7c95fced2c2f8c8148a9055c3a542eff29,"CVE-2017-12995/Check for DNS compression pointers that don't point backwards.

This is what BIND 9.11.0-P2 does; it not only detects pointers that
loop, as ""point backwards"" means ""point before anything we've processed
so far, including what we're processing right now"", so the pointer can't
point to itself (as that's what we're processing right now).

This fixes an infinite loop discovered by Forcepoint's security
researchers Otto Airamo & Antti Levomki.

Add a test using the capture file supplied by the reporter(s).

Also, add some infinite-pointer-loop captures.

More checks should be done.  We might, for example, want to make sure
the upper 2 bits of the label length/pointer byte are 00 or 11, and that
if we encounter a pointer and jump backwards to what we think is a label
the label ends before the beginning of the last label we processed, to
make sure the pointer doesn't point backwards into the *middle* of a
label, and also make sure the entire name is <= 255 bytes long.",17,print-domain.c,"{""sha"": ""9a2b9e85687b633fcb4564ff299cd85f738c358e"", ""filename"": ""print-domain.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 18, ""changes"": 37, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/print-domain.c"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/print-domain.c"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/print-domain.c?ref=3a76fd7c95fced2c2f8c8148a9055c3a542eff29"", ""patch"": ""@@ -151,15 +151,14 @@ ns_nprint(netdissect_options *ndo,\n \tregister u_int i, l;\n \tregister const u_char *rp = NULL;\n \tregister int compress = 0;\n-\tint chars_processed;\n \tint elt;\n-\tint data_size = ndo->ndo_snapend - bp;\n+\tu_int offset, max_offset;\n \n \tif ((l = labellen(ndo, cp)) == (u_int)-1)\n \t\treturn(NULL);\n \tif (!ND_TTEST2(*cp, 1))\n \t\treturn(NULL);\n-\tchars_processed = 1;\n+\tmax_offset = (u_int)(cp - bp);\n \tif (((i = *cp++) & INDIR_MASK) != INDIR_MASK) {\n \t\tcompress = 0;\n \t\trp = cp + l;\n@@ -174,24 +173,28 @@ ns_nprint(netdissect_options *ndo,\n \t\t\t\t}\n \t\t\t\tif (!ND_TTEST2(*cp, 1))\n \t\t\t\t\treturn(NULL);\n-\t\t\t\tcp = bp + (((i << 8) | *cp) & 0x3fff);\n+\t\t\t\toffset = (((i << 8) | *cp) & 0x3fff);\n+\t\t\t\t/*\n+\t\t\t\t * This must move backwards in the packet.\n+\t\t\t\t * No RFC explicitly says that, but BIND's\n+\t\t\t\t * name decompression code requires it,\n+\t\t\t\t * as a way of preventing infinite loops\n+\t\t\t\t * and other bad behavior, and it's probably\n+\t\t\t\t * what was intended (compress by pointing\n+\t\t\t\t * to domain name suffixes already seen in\n+\t\t\t\t * the packet).\n+\t\t\t\t */\n+\t\t\t\tif (offset >= max_offset) {\n+\t\t\t\t\tND_PRINT((ndo, \""<BAD PTR>\""));\n+\t\t\t\t\treturn(NULL);\n+\t\t\t\t}\n+\t\t\t\tmax_offset = offset;\n+\t\t\t\tcp = bp + offset;\n \t\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n \t\t\t\t\treturn(NULL);\n \t\t\t\tif (!ND_TTEST2(*cp, 1))\n \t\t\t\t\treturn(NULL);\n \t\t\t\ti = *cp++;\n-\t\t\t\tchars_processed++;\n-\n-\t\t\t\t/*\n-\t\t\t\t * If we've looked at every character in\n-\t\t\t\t * the message, this pointer will make\n-\t\t\t\t * us look at some character again,\n-\t\t\t\t * which means we're looping.\n-\t\t\t\t */\n-\t\t\t\tif (chars_processed >= data_size) {\n-\t\t\t\t\tND_PRINT((ndo, \""<LOOP>\""));\n-\t\t\t\t\treturn (NULL);\n-\t\t\t\t}\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif ((i & INDIR_MASK) == EDNS0_MASK) {\n@@ -212,14 +215,12 @@ ns_nprint(netdissect_options *ndo,\n \t\t\t}\n \n \t\t\tcp += l;\n-\t\t\tchars_processed += l;\n \t\t\tND_PRINT((ndo, \"".\""));\n \t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n \t\t\t\treturn(NULL);\n \t\t\tif (!ND_TTEST2(*cp, 1))\n \t\t\t\treturn(NULL);\n \t\t\ti = *cp++;\n-\t\t\tchars_processed++;\n \t\t\tif (!compress)\n \t\t\t\trp += l + 1;\n \t\t}""}<_**next**_>{""sha"": ""0ddc63e39a8fd53584e1ed60a8ef7b70967aeb6b"", ""filename"": ""tests/TESTLIST"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests/TESTLIST"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests/TESTLIST"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/TESTLIST?ref=3a76fd7c95fced2c2f8c8148a9055c3a542eff29"", ""patch"": ""@@ -474,6 +474,7 @@ zephyr-oobr\t\tzephyr-oobr.pcap\t\tzephyr-oobr.out\t\t-vvv -e\n isakmp-no-none-np\tisakmp-no-none-np.pcap\t\tisakmp-no-none-np.out\t-vvv -e\n telnet-iac-check-oobr\ttelnet-iac-check-oobr.pcap\ttelnet-iac-check-oobr.out\t-vvv -e\n resp_4_infiniteloop\tresp_4_infiniteloop.pcap\tresp_4_infiniteloop.out\t-vvv -e\n+dns_fwdptr\t\tdns_fwdptr.pcap\t\t\tdns_fwdptr.out\t\t-vvv -e\n \n # RTP tests\n # fuzzed pcap\n@@ -483,3 +484,11 @@ rtp-seg-fault-2  rtp-seg-fault-2.pcap  rtp-seg-fault-2.out  -v -T rtp\n # NFS tests\n # fuzzed pcap\n nfs-seg-fault-1  nfs-seg-fault-1.pcap  nfs-seg-fault-1.out\n+\n+# DNS infinite loop tests\n+#\n+# See http://marc.info/?l=tcpdump-workers&m=95552439022555\n+#\n+dns-zlip-1\t\tdns-zlip-1.pcap\t\tdns-zlip-1.out\n+dns-zlip-2\t\tdns-zlip-2.pcap\t\tdns-zlip-2.out\n+dns-zlip-3\t\tdns-zlip-3.pcap\t\tdns-zlip-3.out""}<_**next**_>{""sha"": ""ce12748da260f4da98145cc6a5b34552a5facaad"", ""filename"": ""tests/dns-zlip-1.out"", ""status"": ""added"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests/dns-zlip-1.out"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests/dns-zlip-1.out"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/dns-zlip-1.out?ref=3a76fd7c95fced2c2f8c8148a9055c3a542eff29"", ""patch"": ""@@ -0,0 +1 @@\n+IP 10.0.0.1.1024 > 146.84.28.88.53: 60777 Type49159 (Class 49168)? <BAD PTR>[|domain]""}<_**next**_>{""sha"": ""4ec844c0fc9fd0572e10b1cb91a871e49ce2a80b"", ""filename"": ""tests/dns-zlip-1.pcap"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests/dns-zlip-1.pcap"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests/dns-zlip-1.pcap"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/dns-zlip-1.pcap?ref=3a76fd7c95fced2c2f8c8148a9055c3a542eff29""}<_**next**_>{""sha"": ""dbabefbfc105674270fcdf9122a4b65eb43a786d"", ""filename"": ""tests/dns-zlip-2.out"", ""status"": ""added"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests/dns-zlip-2.out"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests/dns-zlip-2.out"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/dns-zlip-2.out?ref=3a76fd7c95fced2c2f8c8148a9055c3a542eff29"", ""patch"": ""@@ -0,0 +1 @@\n+IP 10.0.0.1.1024 > 146.84.28.88.53: 18992 Type49164 (Class 49168)? <BAD PTR>[|domain]""}<_**next**_>{""sha"": ""5f74f226499430dd893fb19b5e3135b491e50385"", ""filename"": ""tests/dns-zlip-2.pcap"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests/dns-zlip-2.pcap"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests/dns-zlip-2.pcap"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/dns-zlip-2.pcap?ref=3a76fd7c95fced2c2f8c8148a9055c3a542eff29""}<_**next**_>{""sha"": ""beb173045bbcafa1beb265bd4000203493dd7a41"", ""filename"": ""tests/dns-zlip-3.out"", ""status"": ""added"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests/dns-zlip-3.out"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests/dns-zlip-3.out"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/dns-zlip-3.out?ref=3a76fd7c95fced2c2f8c8148a9055c3a542eff29"", ""patch"": ""@@ -0,0 +1 @@\n+IP 10.0.0.1.1024 > 146.84.28.88.53: 65483 Type49164 (Class 49164)? thisleetostringwillcrashyourlittlenameserverforsurehahahahahah.<BAD PTR>[|domain]""}<_**next**_>{""sha"": ""c0c076a636551554f6553ebe6fe214f0e5202074"", ""filename"": ""tests/dns-zlip-3.pcap"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests/dns-zlip-3.pcap"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests/dns-zlip-3.pcap"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/dns-zlip-3.pcap?ref=3a76fd7c95fced2c2f8c8148a9055c3a542eff29""}<_**next**_>{""sha"": ""4a37b7fb371e6740edb3a792722e0d0f1eb002d9"", ""filename"": ""tests/dns_fwdptr.out"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests/dns_fwdptr.out"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests/dns_fwdptr.out"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/dns_fwdptr.out?ref=3a76fd7c95fced2c2f8c8148a9055c3a542eff29"", ""patch"": ""@@ -0,0 +1,2 @@\n+be:af:ca:ce:ff:ff > de:ad:be:ef:00:01, ethertype IPv4 (0x0800), length 63207: (tos 0x0, ttl 128, id 36039, offset 0, flags [none], proto UDP (17), length 63193)\n+    156.118.17.235.53 > 156.118.27.229.500: [udp sum ok] 51584 zoneRef NoChange*|$ [64259q] q: Type507 (Class 769)? M-{.^AM-{^C.M-{.^AM-{^C.M-{.^AM-{^C.M-{.^AM-{^C.M-{.^AM-{ .M-{^C^A.<BAD PTR>[|domain]""}<_**next**_>{""sha"": ""67a8461197684db8a1fc5658aed7a5db3d077af1"", ""filename"": ""tests/dns_fwdptr.pcap"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests/dns_fwdptr.pcap"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests/dns_fwdptr.pcap"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/dns_fwdptr.pcap?ref=3a76fd7c95fced2c2f8c8148a9055c3a542eff29""}","ns_nprint(netdissect_options *ndo,
          register const u_char *cp, register const u_char *bp)
{
 	register u_int i, l;
 	register const u_char *rp = NULL;
 	register int compress = 0;
 	int elt;
	u_int offset, max_offset;
 
 	if ((l = labellen(ndo, cp)) == (u_int)-1)
 		return(NULL);
 	if (!ND_TTEST2(*cp, 1))
 		return(NULL);
	max_offset = (u_int)(cp - bp);
 	if (((i = *cp++) & INDIR_MASK) != INDIR_MASK) {
 		compress = 0;
 		rp = cp + l;
	}

	if (i != 0)
		while (i && cp < ndo->ndo_snapend) {
			if ((i & INDIR_MASK) == INDIR_MASK) {
				if (!compress) {
					rp = cp + 1;
					compress = 1;
 				}
 				if (!ND_TTEST2(*cp, 1))
 					return(NULL);
				offset = (((i << 8) | *cp) & 0x3fff);
				/*
				 * This must move backwards in the packet.
				 * No RFC explicitly says that, but BIND's
				 * name decompression code requires it,
				 * as a way of preventing infinite loops
				 * and other bad behavior, and it's probably
				 * what was intended (compress by pointing
				 * to domain name suffixes already seen in
				 * the packet).
				 */
				if (offset >= max_offset) {
					ND_PRINT((ndo, ""<BAD PTR>""));
					return(NULL);
				}
				max_offset = offset;
				cp = bp + offset;
 				if ((l = labellen(ndo, cp)) == (u_int)-1)
 					return(NULL);
 				if (!ND_TTEST2(*cp, 1))
 					return(NULL);
 				i = *cp++;
 				continue;
 			}
 			if ((i & INDIR_MASK) == EDNS0_MASK) {
				elt = (i & ~INDIR_MASK);
				switch(elt) {
				case EDNS0_ELT_BITLABEL:
					if (blabel_print(ndo, cp) == NULL)
						return (NULL);
					break;
				default:
					/* unknown ELT */
					ND_PRINT((ndo, ""<ELT %d>"", elt));
					return(NULL);
				}
			} else {
				if (fn_printn(ndo, cp, l, ndo->ndo_snapend))
					return(NULL);
 			}
 
 			cp += l;
 			ND_PRINT((ndo, "".""));
 			if ((l = labellen(ndo, cp)) == (u_int)-1)
 				return(NULL);
 			if (!ND_TTEST2(*cp, 1))
 				return(NULL);
 			i = *cp++;
 			if (!compress)
 				rp += l + 1;
 		}
	else
		ND_PRINT((ndo, "".""));
	return (rp);
}
","ns_nprint(netdissect_options *ndo,
          register const u_char *cp, register const u_char *bp)
{
 	register u_int i, l;
 	register const u_char *rp = NULL;
 	register int compress = 0;
	int chars_processed;
 	int elt;
	int data_size = ndo->ndo_snapend - bp;
 
 	if ((l = labellen(ndo, cp)) == (u_int)-1)
 		return(NULL);
 	if (!ND_TTEST2(*cp, 1))
 		return(NULL);
	chars_processed = 1;
 	if (((i = *cp++) & INDIR_MASK) != INDIR_MASK) {
 		compress = 0;
 		rp = cp + l;
	}

	if (i != 0)
		while (i && cp < ndo->ndo_snapend) {
			if ((i & INDIR_MASK) == INDIR_MASK) {
				if (!compress) {
					rp = cp + 1;
					compress = 1;
 				}
 				if (!ND_TTEST2(*cp, 1))
 					return(NULL);
				cp = bp + (((i << 8) | *cp) & 0x3fff);
 				if ((l = labellen(ndo, cp)) == (u_int)-1)
 					return(NULL);
 				if (!ND_TTEST2(*cp, 1))
 					return(NULL);
 				i = *cp++;
				chars_processed++;
				/*
				 * If we've looked at every character in
				 * the message, this pointer will make
				 * us look at some character again,
				 * which means we're looping.
				 */
				if (chars_processed >= data_size) {
					ND_PRINT((ndo, ""<LOOP>""));
					return (NULL);
				}
 				continue;
 			}
 			if ((i & INDIR_MASK) == EDNS0_MASK) {
				elt = (i & ~INDIR_MASK);
				switch(elt) {
				case EDNS0_ELT_BITLABEL:
					if (blabel_print(ndo, cp) == NULL)
						return (NULL);
					break;
				default:
					/* unknown ELT */
					ND_PRINT((ndo, ""<ELT %d>"", elt));
					return(NULL);
				}
			} else {
				if (fn_printn(ndo, cp, l, ndo->ndo_snapend))
					return(NULL);
 			}
 
 			cp += l;
			chars_processed += l;
 			ND_PRINT((ndo, "".""));
 			if ((l = labellen(ndo, cp)) == (u_int)-1)
 				return(NULL);
 			if (!ND_TTEST2(*cp, 1))
 				return(NULL);
 			i = *cp++;
			chars_processed++;
 			if (!compress)
 				rp += l + 1;
 		}
	else
		ND_PRINT((ndo, "".""));
	return (rp);
}
",C,"	u_int offset, max_offset;
	max_offset = (u_int)(cp - bp);
				offset = (((i << 8) | *cp) & 0x3fff);
				/*
				 * This must move backwards in the packet.
				 * No RFC explicitly says that, but BIND's
				 * name decompression code requires it,
				 * as a way of preventing infinite loops
				 * and other bad behavior, and it's probably
				 * what was intended (compress by pointing
				 * to domain name suffixes already seen in
				 * the packet).
				 */
				if (offset >= max_offset) {
					ND_PRINT((ndo, ""<BAD PTR>""));
					return(NULL);
				}
				max_offset = offset;
				cp = bp + offset;
","	int chars_processed;
	int data_size = ndo->ndo_snapend - bp;
	chars_processed = 1;
				cp = bp + (((i << 8) | *cp) & 0x3fff);
				chars_processed++;
				/*
				 * If we've looked at every character in
				 * the message, this pointer will make
				 * us look at some character again,
				 * which means we're looping.
				 */
				if (chars_processed >= data_size) {
					ND_PRINT((ndo, ""<LOOP>""));
					return (NULL);
				}
			chars_processed += l;
			chars_processed++;
",,"@@ -151,15 +151,14 @@ ns_nprint(netdissect_options *ndo,
 	register u_int i, l;
 	register const u_char *rp = NULL;
 	register int compress = 0;
-	int chars_processed;
 	int elt;
-	int data_size = ndo->ndo_snapend - bp;
+	u_int offset, max_offset;
 
 	if ((l = labellen(ndo, cp)) == (u_int)-1)
 		return(NULL);
 	if (!ND_TTEST2(*cp, 1))
 		return(NULL);
-	chars_processed = 1;
+	max_offset = (u_int)(cp - bp);
 	if (((i = *cp++) & INDIR_MASK) != INDIR_MASK) {
 		compress = 0;
 		rp = cp + l;
@@ -174,24 +173,28 @@ ns_nprint(netdissect_options *ndo,
 				}
 				if (!ND_TTEST2(*cp, 1))
 					return(NULL);
-				cp = bp + (((i << 8) | *cp) & 0x3fff);
+				offset = (((i << 8) | *cp) & 0x3fff);
+				/*
+				 * This must move backwards in the packet.
+				 * No RFC explicitly says that, but BIND's
+				 * name decompression code requires it,
+				 * as a way of preventing infinite loops
+				 * and other bad behavior, and it's probably
+				 * what was intended (compress by pointing
+				 * to domain name suffixes already seen in
+				 * the packet).
+				 */
+				if (offset >= max_offset) {
+					ND_PRINT((ndo, ""<BAD PTR>""));
+					return(NULL);
+				}
+				max_offset = offset;
+				cp = bp + offset;
 				if ((l = labellen(ndo, cp)) == (u_int)-1)
 					return(NULL);
 				if (!ND_TTEST2(*cp, 1))
 					return(NULL);
 				i = *cp++;
-				chars_processed++;
-
-				/*
-				 * If we've looked at every character in
-				 * the message, this pointer will make
-				 * us look at some character again,
-				 * which means we're looping.
-				 */
-				if (chars_processed >= data_size) {
-					ND_PRINT((ndo, ""<LOOP>""));
-					return (NULL);
-				}
 				continue;
 			}
 			if ((i & INDIR_MASK) == EDNS0_MASK) {
@@ -212,14 +215,12 @@ ns_nprint(netdissect_options *ndo,
 			}
 
 			cp += l;
-			chars_processed += l;
 			ND_PRINT((ndo, "".""));
 			if ((l = labellen(ndo, cp)) == (u_int)-1)
 				return(NULL);
 			if (!ND_TTEST2(*cp, 1))
 				return(NULL);
 			i = *cp++;
-			chars_processed++;
 			if (!compress)
 				rp += l + 1;
 		}",tcpdump,3a76fd7c95fced2c2f8c8148a9055c3a542eff29,866c60236c41cea1e1654c8a071897292f64be49,1,"ns_nprint(netdissect_options *ndo,
          register const u_char *cp, register const u_char *bp)
{
 	register u_int i, l;
 	register const u_char *rp = NULL;
 	register int compress = 0;
//flaw_line_below:
	int chars_processed;
 	int elt;
//flaw_line_below:
	int data_size = ndo->ndo_snapend - bp;
//fix_flaw_line_below:
//	u_int offset, max_offset;
 
 	if ((l = labellen(ndo, cp)) == (u_int)-1)
 		return(NULL);
 	if (!ND_TTEST2(*cp, 1))
 		return(NULL);
//flaw_line_below:
	chars_processed = 1;
//fix_flaw_line_below:
//	max_offset = (u_int)(cp - bp);
 	if (((i = *cp++) & INDIR_MASK) != INDIR_MASK) {
 		compress = 0;
 		rp = cp + l;
	}

	if (i != 0)
		while (i && cp < ndo->ndo_snapend) {
			if ((i & INDIR_MASK) == INDIR_MASK) {
				if (!compress) {
					rp = cp + 1;
					compress = 1;
 				}
 				if (!ND_TTEST2(*cp, 1))
 					return(NULL);
//flaw_line_below:
				cp = bp + (((i << 8) | *cp) & 0x3fff);
//fix_flaw_line_below:
//				offset = (((i << 8) | *cp) & 0x3fff);
//fix_flaw_line_below:
//				/*
//fix_flaw_line_below:
//				 * This must move backwards in the packet.
//fix_flaw_line_below:
//				 * No RFC explicitly says that, but BIND's
//fix_flaw_line_below:
//				 * name decompression code requires it,
//fix_flaw_line_below:
//				 * as a way of preventing infinite loops
//fix_flaw_line_below:
//				 * and other bad behavior, and it's probably
//fix_flaw_line_below:
//				 * what was intended (compress by pointing
//fix_flaw_line_below:
//				 * to domain name suffixes already seen in
//fix_flaw_line_below:
//				 * the packet).
//fix_flaw_line_below:
//				 */
//fix_flaw_line_below:
//				if (offset >= max_offset) {
//fix_flaw_line_below:
//					ND_PRINT((ndo, ""<BAD PTR>""));
//fix_flaw_line_below:
//					return(NULL);
//fix_flaw_line_below:
//				}
//fix_flaw_line_below:
//				max_offset = offset;
//fix_flaw_line_below:
//				cp = bp + offset;
 				if ((l = labellen(ndo, cp)) == (u_int)-1)
 					return(NULL);
 				if (!ND_TTEST2(*cp, 1))
 					return(NULL);
 				i = *cp++;
//flaw_line_below:
				chars_processed++;
//flaw_line_below:

//flaw_line_below:
				/*
//flaw_line_below:
				 * If we've looked at every character in
//flaw_line_below:
				 * the message, this pointer will make
//flaw_line_below:
				 * us look at some character again,
//flaw_line_below:
				 * which means we're looping.
//flaw_line_below:
				 */
//flaw_line_below:
				if (chars_processed >= data_size) {
//flaw_line_below:
					ND_PRINT((ndo, ""<LOOP>""));
//flaw_line_below:
					return (NULL);
//flaw_line_below:
				}
 				continue;
 			}
 			if ((i & INDIR_MASK) == EDNS0_MASK) {
				elt = (i & ~INDIR_MASK);
				switch(elt) {
				case EDNS0_ELT_BITLABEL:
					if (blabel_print(ndo, cp) == NULL)
						return (NULL);
					break;
				default:
					/* unknown ELT */
					ND_PRINT((ndo, ""<ELT %d>"", elt));
					return(NULL);
				}
			} else {
				if (fn_printn(ndo, cp, l, ndo->ndo_snapend))
					return(NULL);
 			}
 
 			cp += l;
//flaw_line_below:
			chars_processed += l;
 			ND_PRINT((ndo, "".""));
 			if ((l = labellen(ndo, cp)) == (u_int)-1)
 				return(NULL);
 			if (!ND_TTEST2(*cp, 1))
 				return(NULL);
 			i = *cp++;
//flaw_line_below:
			chars_processed++;
 			if (!compress)
 				rp += l + 1;
 		}
	else
		ND_PRINT((ndo, "".""));
	return (rp);
}
"
3360,181096,,Remote,Not required,Partial,CVE-2017-12990,https://www.cvedetails.com/cve/CVE-2017-12990/,CWE-835,Low,,,,2017-09-14,5.0,"The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.",2019-10-02,,20,https://github.com/the-tcpdump-group/tcpdump/commit/c2ef693866beae071a24b45c49f9674af1df4028,c2ef693866beae071a24b45c49f9674af1df4028,"CVE-2017-12990/Fix printing of ISAKMPv1 Notification payload data.

The closest thing to a specification for the contents of the payload
data is draft-ietf-ipsec-notifymsg-04, and nothing in there says that it
is ever a complete ISAKMP message, so don't dissect types we don't have
specific code for as a complete ISAKMP message.

While we're at it, fix a comment, and clean up printing of V1 Nonce,
V2 Authentication payloads, and v2 Notice payloads.

This fixes an infinite loop discovered by Forcepoint's security
researchers Otto Airamo & Antti Levomki.

Add a test using the capture file supplied by the reporter(s).",14,print-isakmp.c,"{""sha"": ""9de9b75d21e74156a74f0708a5b2fa636861b803"", ""filename"": ""print-isakmp.c"", ""status"": ""modified"", ""additions"": 60, ""deletions"": 52, ""changes"": 112, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/c2ef693866beae071a24b45c49f9674af1df4028/print-isakmp.c"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/c2ef693866beae071a24b45c49f9674af1df4028/print-isakmp.c"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/print-isakmp.c?ref=c2ef693866beae071a24b45c49f9674af1df4028"", ""patch"": ""@@ -428,7 +428,7 @@ struct notify_messages {\n \tchar     *msg;\n };\n \n-/* 3.8 Notification Payload */\n+/* 3.8 Authentication Payload */\n struct ikev2_auth {\n \tstruct isakmp_gen h;\n \tuint8_t  auth_method;  /* Protocol-ID */\n@@ -1590,15 +1590,20 @@ ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n \n \tND_TCHECK(*ext);\n \tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n-\tND_PRINT((ndo,\"" n len=%d\"", ntohs(e.len) - 4));\n-\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n-\t\tND_PRINT((ndo,\"" \""));\n-\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n-\t\t\tgoto trunc;\n-\t} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n-\t\tND_PRINT((ndo,\"" \""));\n-\t\tif (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))\n-\t\t\tgoto trunc;\n+\t/*\n+\t * Our caller has ensured that the length is >= 4.\n+\t */\n+\tND_PRINT((ndo,\"" n len=%u\"", ntohs(e.len) - 4));\n+\tif (ntohs(e.len) > 4) {\n+\t\tif (ndo->ndo_vflag > 2) {\n+\t\t\tND_PRINT((ndo, \"" \""));\n+\t\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n+\t\t\t\tgoto trunc;\n+\t\t} else if (ndo->ndo_vflag > 1) {\n+\t\t\tND_PRINT((ndo, \"" \""));\n+\t\t\tif (!ike_show_somedata(ndo, (const u_char *)(ext + 1), ep))\n+\t\t\t\tgoto trunc;\n+\t\t}\n \t}\n \treturn (const u_char *)ext + ntohs(e.len);\n trunc:\n@@ -1609,8 +1614,8 @@ ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n static const u_char *\n ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n \t      const struct isakmp_gen *ext, u_int item_len,\n-\t      const u_char *ep, uint32_t phase, uint32_t doi0 _U_,\n-\t      uint32_t proto0 _U_, int depth)\n+\t      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,\n+\t      uint32_t proto0 _U_, int depth _U_)\n {\n \tconst struct ikev1_pl_n *p;\n \tstruct ikev1_pl_n n;\n@@ -1712,35 +1717,41 @@ ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n \tep2 = (const u_char *)p + item_len;\n \n \tif (cp < ep) {\n-\t\tND_PRINT((ndo,\"" orig=(\""));\n \t\tswitch (ntohs(n.type)) {\n \t\tcase IPSECDOI_NTYPE_RESPONDER_LIFETIME:\n \t\t    {\n \t\t\tconst struct attrmap *map = oakley_t_map;\n \t\t\tsize_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);\n+\t\t\tND_PRINT((ndo,\"" attrs=(\""));\n \t\t\twhile (cp < ep && cp < ep2) {\n \t\t\t\tcp = ikev1_attrmap_print(ndo, cp,\n \t\t\t\t\t(ep < ep2) ? ep : ep2, map, nmap);\n \t\t\t}\n+\t\t\tND_PRINT((ndo,\"")\""));\n \t\t\tbreak;\n \t\t    }\n \t\tcase IPSECDOI_NTYPE_REPLAY_STATUS:\n+\t\t\tND_PRINT((ndo,\"" status=(\""));\n \t\t\tND_PRINT((ndo,\""replay detection %sabled\"",\n \t\t\t\t  EXTRACT_32BITS(cp) ? \""en\"" : \""dis\""));\n-\t\t\tbreak;\n-\t\tcase ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN:\n-\t\t\tif (ikev1_sub_print(ndo, ISAKMP_NPTYPE_SA,\n-\t\t\t\t\t    (const struct isakmp_gen *)cp, ep, phase, doi, proto,\n-\t\t\t\t\t    depth) == NULL)\n-\t\t\t\treturn NULL;\n+\t\t\tND_PRINT((ndo,\"")\""));\n \t\t\tbreak;\n \t\tdefault:\n-\t\t\t/* NULL is dummy */\n-\t\t\tisakmp_print(ndo, cp,\n-\t\t\t\t     item_len - sizeof(*p) - n.spi_size,\n-\t\t\t\t     NULL);\n+\t\t\t/*\n+\t\t\t * XXX - fill in more types here; see, for example,\n+\t\t\t * draft-ietf-ipsec-notifymsg-04.\n+\t\t\t */\n+\t\t\tif (ndo->ndo_vflag > 3) {\n+\t\t\t\tND_PRINT((ndo,\"" data=(\""));\n+\t\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n+\t\t\t\t\tgoto trunc;\n+\t\t\t\tND_PRINT((ndo,\"")\""));\n+\t\t\t} else {\n+\t\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n+\t\t\t\t\tgoto trunc;\n+\t\t\t}\n+\t\t\tbreak;\n \t\t}\n-\t\tND_PRINT((ndo,\"")\""));\n \t}\n \treturn (const u_char *)ext + item_len;\n trunc:\n@@ -2264,16 +2275,21 @@ ikev2_auth_print(netdissect_options *ndo, u_char tpay,\n \tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n \tlen = ntohs(a.h.len);\n \n-\tND_PRINT((ndo,\"" len=%d method=%s\"", len-4,\n+\t/*\n+\t * Our caller has ensured that the length is >= 4.\n+\t */\n+\tND_PRINT((ndo,\"" len=%u method=%s\"", len-4,\n \t\t  STR_OR_ID(a.auth_method, v2_auth)));\n-\n-\tif (1 < ndo->ndo_vflag && 4 < len) {\n-\t\tND_PRINT((ndo,\"" authdata=(\""));\n-\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n-\t\t\tgoto trunc;\n-\t\tND_PRINT((ndo,\"") \""));\n-\t} else if(ndo->ndo_vflag && 4 < len) {\n-\t\tif(!ike_show_somedata(ndo, authdata, ep)) goto trunc;\n+\tif (len > 4) {\n+\t\tif (ndo->ndo_vflag > 1) {\n+\t\t\tND_PRINT((ndo, \"" authdata=(\""));\n+\t\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n+\t\t\t\tgoto trunc;\n+\t\t\tND_PRINT((ndo, \"") \""));\n+\t\t} else if (ndo->ndo_vflag) {\n+\t\t\tif (!ike_show_somedata(ndo, authdata, ep))\n+\t\t\t\tgoto trunc;\n+\t\t}\n \t}\n \n \treturn (const u_char *)ext + len;\n@@ -2322,7 +2338,7 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n \tconst struct ikev2_n *p;\n \tstruct ikev2_n n;\n \tconst u_char *cp;\n-\tu_char showspi, showdata, showsomedata;\n+\tu_char showspi, showsomedata;\n \tconst char *notify_name;\n \tuint32_t type;\n \n@@ -2332,7 +2348,6 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n \tikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_N), n.h.critical);\n \n \tshowspi = 1;\n-\tshowdata = 0;\n \tshowsomedata=0;\n \tnotify_name=NULL;\n \n@@ -2446,7 +2461,6 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n \t\tnotify_name = \""cookie\"";\n \t\tshowspi = 1;\n \t\tshowsomedata= 1;\n-\t\tshowdata= 0;\n \t\tbreak;\n \n \tcase IV2_NOTIFY_USE_TRANSPORT_MODE:\n@@ -2499,19 +2513,17 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n \n \tcp = (const u_char *)(p + 1) + n.spi_size;\n \n-\tif(3 < ndo->ndo_vflag) {\n-\t\tshowdata = 1;\n-\t}\n-\n-\tif ((showdata || (showsomedata && ep-cp < 30)) && cp < ep) {\n-\t\tND_PRINT((ndo,\"" data=(\""));\n-\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n-\t\t\tgoto trunc;\n-\n-\t\tND_PRINT((ndo,\"")\""));\n+\tif (cp < ep) {\n+\t\tif (ndo->ndo_vflag > 3 || (showsomedata && ep-cp < 30)) {\n+\t\t\tND_PRINT((ndo,\"" data=(\""));\n+\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n+\t\t\t\tgoto trunc;\n \n-\t} else if(showsomedata && cp < ep) {\n-\t\tif(!ike_show_somedata(ndo, cp, ep)) goto trunc;\n+\t\t\tND_PRINT((ndo,\"")\""));\n+\t\t} else if (showsomedata) {\n+\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n+\t\t\t\tgoto trunc;\n+\t\t}\n \t}\n \n \treturn (const u_char *)ext + item_len;\n@@ -3091,7 +3103,3 @@ isakmp_rfc3948_print(netdissect_options *ndo,\n  * c-basic-offset: 8\n  * End:\n  */\n-\n-\n-\n-""}<_**next**_>{""sha"": ""ed5b82aa348d9366ad7745abec943618d413f14a"", ""filename"": ""tests/TESTLIST"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/c2ef693866beae071a24b45c49f9674af1df4028/tests/TESTLIST"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/c2ef693866beae071a24b45c49f9674af1df4028/tests/TESTLIST"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/TESTLIST?ref=c2ef693866beae071a24b45c49f9674af1df4028"", ""patch"": ""@@ -465,6 +465,7 @@ tok2str-oobr-2\t\ttok2str-oobr-2.pcap\t\ttok2str-oobr-2.out\t-vvv -e\n eigrp-tlv-oobr\t\teigrp-tlv-oobr.pcap\t\teigrp-tlv-oobr.out\t-vvv -e\n zephyr-oobr\t\tzephyr-oobr.pcap\t\tzephyr-oobr.out\t\t-vvv -e\n bgp-as-path-oobr\tbgp-as-path-oobr.pcap\t\tbgp-as-path-oobr.out\t-vvv -e\n+isakmp-no-none-np\tisakmp-no-none-np.pcap\t\tisakmp-no-none-np.out\t-vvv -e\n \n # RTP tests\n # fuzzed pcap""}<_**next**_>{""sha"": ""eb91c804a87aaa6ec37215ca06a6bf17593d861b"", ""filename"": ""tests/isakmp-no-none-np.out"", ""status"": ""added"", ""additions"": 78, ""deletions"": 0, ""changes"": 78, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/c2ef693866beae071a24b45c49f9674af1df4028/tests/isakmp-no-none-np.out"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/c2ef693866beae071a24b45c49f9674af1df4028/tests/isakmp-no-none-np.out"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/isakmp-no-none-np.out?ref=c2ef693866beae071a24b45c49f9674af1df4028"", ""patch"": ""@@ -0,0 +1,78 @@\n+00:0c:29:86:c8:36 > 00:1a:4b:6a:ce:fe, ethertype IPv4 (0x0800), length 2228: (tos 0x0, ttl 128, id 28793, offset 0, flags [none], proto UDP (17), length 2214)\n+    192.168.1.25.500 > 192.168.1.10.500: [udp sum ok] isakmp 1.0 msgid 5f724dc6 cookie 0000000000000000->0000000000000000: phase 2/others ? inf:\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=0000000000000000000000000010ba00 data=(00ff1d00020082001101...0100000700000000000000000000000000000000)) [|n] (len mismatch: isakmp 84/ip 2186)""}<_**next**_>{""sha"": ""fd388d617e4f2937fdb1214bdcce59c8c159a90c"", ""filename"": ""tests/isakmp-no-none-np.pcap"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/c2ef693866beae071a24b45c49f9674af1df4028/tests/isakmp-no-none-np.pcap"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/c2ef693866beae071a24b45c49f9674af1df4028/tests/isakmp-no-none-np.pcap"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/isakmp-no-none-np.pcap?ref=c2ef693866beae071a24b45c49f9674af1df4028""}"," ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,
 	      const struct isakmp_gen *ext, u_int item_len,
	      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,
	      uint32_t proto0 _U_, int depth _U_)
 {
 	const struct ikev1_pl_n *p;
 	struct ikev1_pl_n n;
	const u_char *cp;
	const u_char *ep2;
	uint32_t doi;
	uint32_t proto;
	static const char *notify_error_str[] = {
		NULL,				""INVALID-PAYLOAD-TYPE"",
		""DOI-NOT-SUPPORTED"",		""SITUATION-NOT-SUPPORTED"",
		""INVALID-COOKIE"",		""INVALID-MAJOR-VERSION"",
		""INVALID-MINOR-VERSION"",	""INVALID-EXCHANGE-TYPE"",
		""INVALID-FLAGS"",		""INVALID-MESSAGE-ID"",
		""INVALID-PROTOCOL-ID"",		""INVALID-SPI"",
		""INVALID-TRANSFORM-ID"",		""ATTRIBUTES-NOT-SUPPORTED"",
		""NO-PROPOSAL-CHOSEN"",		""BAD-PROPOSAL-SYNTAX"",
		""PAYLOAD-MALFORMED"",		""INVALID-KEY-INFORMATION"",
		""INVALID-ID-INFORMATION"",	""INVALID-CERT-ENCODING"",
		""INVALID-CERTIFICATE"",		""CERT-TYPE-UNSUPPORTED"",
		""INVALID-CERT-AUTHORITY"",	""INVALID-HASH-INFORMATION"",
		""AUTHENTICATION-FAILED"",	""INVALID-SIGNATURE"",
		""ADDRESS-NOTIFICATION"",		""NOTIFY-SA-LIFETIME"",
		""CERTIFICATE-UNAVAILABLE"",	""UNSUPPORTED-EXCHANGE-TYPE"",
		""UNEQUAL-PAYLOAD-LENGTHS"",
	};
	static const char *ipsec_notify_error_str[] = {
		""RESERVED"",
	};
	static const char *notify_status_str[] = {
		""CONNECTED"",
	};
	static const char *ipsec_notify_status_str[] = {
		""RESPONDER-LIFETIME"",		""REPLAY-STATUS"",
		""INITIAL-CONTACT"",
	};
/* NOTE: these macro must be called with x in proper range */

/* 0 - 8191 */
#define NOTIFY_ERROR_STR(x) \
	STR_OR_ID((x), notify_error_str)

/* 8192 - 16383 */
#define IPSEC_NOTIFY_ERROR_STR(x) \
	STR_OR_ID((u_int)((x) - 8192), ipsec_notify_error_str)

/* 16384 - 24575 */
#define NOTIFY_STATUS_STR(x) \
	STR_OR_ID((u_int)((x) - 16384), notify_status_str)

/* 24576 - 32767 */
#define IPSEC_NOTIFY_STATUS_STR(x) \
	STR_OR_ID((u_int)((x) - 24576), ipsec_notify_status_str)

	ND_PRINT((ndo,""%s:"", NPSTR(ISAKMP_NPTYPE_N)));

	p = (const struct ikev1_pl_n *)ext;
	ND_TCHECK(*p);
	UNALIGNED_MEMCPY(&n, ext, sizeof(n));
	doi = ntohl(n.doi);
	proto = n.prot_id;
	if (doi != 1) {
		ND_PRINT((ndo,"" doi=%d"", doi));
		ND_PRINT((ndo,"" proto=%d"", proto));
		if (ntohs(n.type) < 8192)
			ND_PRINT((ndo,"" type=%s"", NOTIFY_ERROR_STR(ntohs(n.type))));
		else if (ntohs(n.type) < 16384)
			ND_PRINT((ndo,"" type=%s"", numstr(ntohs(n.type))));
		else if (ntohs(n.type) < 24576)
			ND_PRINT((ndo,"" type=%s"", NOTIFY_STATUS_STR(ntohs(n.type))));
		else
			ND_PRINT((ndo,"" type=%s"", numstr(ntohs(n.type))));
		if (n.spi_size) {
			ND_PRINT((ndo,"" spi=""));
			if (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))
				goto trunc;
		}
		return (const u_char *)(p + 1) + n.spi_size;
	}

	ND_PRINT((ndo,"" doi=ipsec""));
	ND_PRINT((ndo,"" proto=%s"", PROTOIDSTR(proto)));
	if (ntohs(n.type) < 8192)
		ND_PRINT((ndo,"" type=%s"", NOTIFY_ERROR_STR(ntohs(n.type))));
	else if (ntohs(n.type) < 16384)
		ND_PRINT((ndo,"" type=%s"", IPSEC_NOTIFY_ERROR_STR(ntohs(n.type))));
	else if (ntohs(n.type) < 24576)
		ND_PRINT((ndo,"" type=%s"", NOTIFY_STATUS_STR(ntohs(n.type))));
	else if (ntohs(n.type) < 32768)
		ND_PRINT((ndo,"" type=%s"", IPSEC_NOTIFY_STATUS_STR(ntohs(n.type))));
	else
		ND_PRINT((ndo,"" type=%s"", numstr(ntohs(n.type))));
	if (n.spi_size) {
		ND_PRINT((ndo,"" spi=""));
		if (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))
			goto trunc;
	}

	cp = (const u_char *)(p + 1) + n.spi_size;
 	ep2 = (const u_char *)p + item_len;
 
 	if (cp < ep) {
 		switch (ntohs(n.type)) {
 		case IPSECDOI_NTYPE_RESPONDER_LIFETIME:
 		    {
 			const struct attrmap *map = oakley_t_map;
 			size_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);
			ND_PRINT((ndo,"" attrs=(""));
 			while (cp < ep && cp < ep2) {
 				cp = ikev1_attrmap_print(ndo, cp,
 					(ep < ep2) ? ep : ep2, map, nmap);
 			}
			ND_PRINT((ndo,"")""));
 			break;
 		    }
 		case IPSECDOI_NTYPE_REPLAY_STATUS:
			ND_PRINT((ndo,"" status=(""));
 			ND_PRINT((ndo,""replay detection %sabled"",
 				  EXTRACT_32BITS(cp) ? ""en"" : ""dis""));
			ND_PRINT((ndo,"")""));
 			break;
 		default:
			/*
			 * XXX - fill in more types here; see, for example,
			 * draft-ietf-ipsec-notifymsg-04.
			 */
			if (ndo->ndo_vflag > 3) {
				ND_PRINT((ndo,"" data=(""));
				if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
					goto trunc;
				ND_PRINT((ndo,"")""));
			} else {
				if (!ike_show_somedata(ndo, cp, ep))
					goto trunc;
			}
			break;
 		}
 	}
 	return (const u_char *)ext + item_len;
 trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_N)));
	return NULL;
}
"," ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,
 	      const struct isakmp_gen *ext, u_int item_len,
	      const u_char *ep, uint32_t phase, uint32_t doi0 _U_,
	      uint32_t proto0 _U_, int depth)
 {
 	const struct ikev1_pl_n *p;
 	struct ikev1_pl_n n;
	const u_char *cp;
	const u_char *ep2;
	uint32_t doi;
	uint32_t proto;
	static const char *notify_error_str[] = {
		NULL,				""INVALID-PAYLOAD-TYPE"",
		""DOI-NOT-SUPPORTED"",		""SITUATION-NOT-SUPPORTED"",
		""INVALID-COOKIE"",		""INVALID-MAJOR-VERSION"",
		""INVALID-MINOR-VERSION"",	""INVALID-EXCHANGE-TYPE"",
		""INVALID-FLAGS"",		""INVALID-MESSAGE-ID"",
		""INVALID-PROTOCOL-ID"",		""INVALID-SPI"",
		""INVALID-TRANSFORM-ID"",		""ATTRIBUTES-NOT-SUPPORTED"",
		""NO-PROPOSAL-CHOSEN"",		""BAD-PROPOSAL-SYNTAX"",
		""PAYLOAD-MALFORMED"",		""INVALID-KEY-INFORMATION"",
		""INVALID-ID-INFORMATION"",	""INVALID-CERT-ENCODING"",
		""INVALID-CERTIFICATE"",		""CERT-TYPE-UNSUPPORTED"",
		""INVALID-CERT-AUTHORITY"",	""INVALID-HASH-INFORMATION"",
		""AUTHENTICATION-FAILED"",	""INVALID-SIGNATURE"",
		""ADDRESS-NOTIFICATION"",		""NOTIFY-SA-LIFETIME"",
		""CERTIFICATE-UNAVAILABLE"",	""UNSUPPORTED-EXCHANGE-TYPE"",
		""UNEQUAL-PAYLOAD-LENGTHS"",
	};
	static const char *ipsec_notify_error_str[] = {
		""RESERVED"",
	};
	static const char *notify_status_str[] = {
		""CONNECTED"",
	};
	static const char *ipsec_notify_status_str[] = {
		""RESPONDER-LIFETIME"",		""REPLAY-STATUS"",
		""INITIAL-CONTACT"",
	};
/* NOTE: these macro must be called with x in proper range */

/* 0 - 8191 */
#define NOTIFY_ERROR_STR(x) \
	STR_OR_ID((x), notify_error_str)

/* 8192 - 16383 */
#define IPSEC_NOTIFY_ERROR_STR(x) \
	STR_OR_ID((u_int)((x) - 8192), ipsec_notify_error_str)

/* 16384 - 24575 */
#define NOTIFY_STATUS_STR(x) \
	STR_OR_ID((u_int)((x) - 16384), notify_status_str)

/* 24576 - 32767 */
#define IPSEC_NOTIFY_STATUS_STR(x) \
	STR_OR_ID((u_int)((x) - 24576), ipsec_notify_status_str)

	ND_PRINT((ndo,""%s:"", NPSTR(ISAKMP_NPTYPE_N)));

	p = (const struct ikev1_pl_n *)ext;
	ND_TCHECK(*p);
	UNALIGNED_MEMCPY(&n, ext, sizeof(n));
	doi = ntohl(n.doi);
	proto = n.prot_id;
	if (doi != 1) {
		ND_PRINT((ndo,"" doi=%d"", doi));
		ND_PRINT((ndo,"" proto=%d"", proto));
		if (ntohs(n.type) < 8192)
			ND_PRINT((ndo,"" type=%s"", NOTIFY_ERROR_STR(ntohs(n.type))));
		else if (ntohs(n.type) < 16384)
			ND_PRINT((ndo,"" type=%s"", numstr(ntohs(n.type))));
		else if (ntohs(n.type) < 24576)
			ND_PRINT((ndo,"" type=%s"", NOTIFY_STATUS_STR(ntohs(n.type))));
		else
			ND_PRINT((ndo,"" type=%s"", numstr(ntohs(n.type))));
		if (n.spi_size) {
			ND_PRINT((ndo,"" spi=""));
			if (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))
				goto trunc;
		}
		return (const u_char *)(p + 1) + n.spi_size;
	}

	ND_PRINT((ndo,"" doi=ipsec""));
	ND_PRINT((ndo,"" proto=%s"", PROTOIDSTR(proto)));
	if (ntohs(n.type) < 8192)
		ND_PRINT((ndo,"" type=%s"", NOTIFY_ERROR_STR(ntohs(n.type))));
	else if (ntohs(n.type) < 16384)
		ND_PRINT((ndo,"" type=%s"", IPSEC_NOTIFY_ERROR_STR(ntohs(n.type))));
	else if (ntohs(n.type) < 24576)
		ND_PRINT((ndo,"" type=%s"", NOTIFY_STATUS_STR(ntohs(n.type))));
	else if (ntohs(n.type) < 32768)
		ND_PRINT((ndo,"" type=%s"", IPSEC_NOTIFY_STATUS_STR(ntohs(n.type))));
	else
		ND_PRINT((ndo,"" type=%s"", numstr(ntohs(n.type))));
	if (n.spi_size) {
		ND_PRINT((ndo,"" spi=""));
		if (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))
			goto trunc;
	}

	cp = (const u_char *)(p + 1) + n.spi_size;
 	ep2 = (const u_char *)p + item_len;
 
 	if (cp < ep) {
		ND_PRINT((ndo,"" orig=(""));
 		switch (ntohs(n.type)) {
 		case IPSECDOI_NTYPE_RESPONDER_LIFETIME:
 		    {
 			const struct attrmap *map = oakley_t_map;
 			size_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);
 			while (cp < ep && cp < ep2) {
 				cp = ikev1_attrmap_print(ndo, cp,
 					(ep < ep2) ? ep : ep2, map, nmap);
 			}
 			break;
 		    }
 		case IPSECDOI_NTYPE_REPLAY_STATUS:
 			ND_PRINT((ndo,""replay detection %sabled"",
 				  EXTRACT_32BITS(cp) ? ""en"" : ""dis""));
			break;
		case ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN:
			if (ikev1_sub_print(ndo, ISAKMP_NPTYPE_SA,
					    (const struct isakmp_gen *)cp, ep, phase, doi, proto,
					    depth) == NULL)
				return NULL;
 			break;
 		default:
			/* NULL is dummy */
			isakmp_print(ndo, cp,
				     item_len - sizeof(*p) - n.spi_size,
				     NULL);
 		}
		ND_PRINT((ndo,"")""));
 	}
 	return (const u_char *)ext + item_len;
 trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_N)));
	return NULL;
}
",C,"	      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,
	      uint32_t proto0 _U_, int depth _U_)
			ND_PRINT((ndo,"" attrs=(""));
			ND_PRINT((ndo,"")""));
			ND_PRINT((ndo,"" status=(""));
			ND_PRINT((ndo,"")""));
			/*
			 * XXX - fill in more types here; see, for example,
			 * draft-ietf-ipsec-notifymsg-04.
			 */
			if (ndo->ndo_vflag > 3) {
				ND_PRINT((ndo,"" data=(""));
				if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
					goto trunc;
				ND_PRINT((ndo,"")""));
			} else {
				if (!ike_show_somedata(ndo, cp, ep))
					goto trunc;
			}
			break;
","	      const u_char *ep, uint32_t phase, uint32_t doi0 _U_,
	      uint32_t proto0 _U_, int depth)
		ND_PRINT((ndo,"" orig=(""));
			break;
		case ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN:
			if (ikev1_sub_print(ndo, ISAKMP_NPTYPE_SA,
					    (const struct isakmp_gen *)cp, ep, phase, doi, proto,
					    depth) == NULL)
				return NULL;
			/* NULL is dummy */
			isakmp_print(ndo, cp,
				     item_len - sizeof(*p) - n.spi_size,
				     NULL);
		ND_PRINT((ndo,"")""));
",,"@@ -428,7 +428,7 @@ struct notify_messages {
 	char     *msg;
 };
 
-/* 3.8 Notification Payload */
+/* 3.8 Authentication Payload */
 struct ikev2_auth {
 	struct isakmp_gen h;
 	uint8_t  auth_method;  /* Protocol-ID */
@@ -1590,15 +1590,20 @@ ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,
 
 	ND_TCHECK(*ext);
 	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
-	ND_PRINT((ndo,"" n len=%d"", ntohs(e.len) - 4));
-	if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
-		ND_PRINT((ndo,"" ""));
-		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
-			goto trunc;
-	} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
-		ND_PRINT((ndo,"" ""));
-		if (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))
-			goto trunc;
+	/*
+	 * Our caller has ensured that the length is >= 4.
+	 */
+	ND_PRINT((ndo,"" n len=%u"", ntohs(e.len) - 4));
+	if (ntohs(e.len) > 4) {
+		if (ndo->ndo_vflag > 2) {
+			ND_PRINT((ndo, "" ""));
+			if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
+				goto trunc;
+		} else if (ndo->ndo_vflag > 1) {
+			ND_PRINT((ndo, "" ""));
+			if (!ike_show_somedata(ndo, (const u_char *)(ext + 1), ep))
+				goto trunc;
+		}
 	}
 	return (const u_char *)ext + ntohs(e.len);
 trunc:
@@ -1609,8 +1614,8 @@ ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,
 static const u_char *
 ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,
 	      const struct isakmp_gen *ext, u_int item_len,
-	      const u_char *ep, uint32_t phase, uint32_t doi0 _U_,
-	      uint32_t proto0 _U_, int depth)
+	      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,
+	      uint32_t proto0 _U_, int depth _U_)
 {
 	const struct ikev1_pl_n *p;
 	struct ikev1_pl_n n;
@@ -1712,35 +1717,41 @@ ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,
 	ep2 = (const u_char *)p + item_len;
 
 	if (cp < ep) {
-		ND_PRINT((ndo,"" orig=(""));
 		switch (ntohs(n.type)) {
 		case IPSECDOI_NTYPE_RESPONDER_LIFETIME:
 		    {
 			const struct attrmap *map = oakley_t_map;
 			size_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);
+			ND_PRINT((ndo,"" attrs=(""));
 			while (cp < ep && cp < ep2) {
 				cp = ikev1_attrmap_print(ndo, cp,
 					(ep < ep2) ? ep : ep2, map, nmap);
 			}
+			ND_PRINT((ndo,"")""));
 			break;
 		    }
 		case IPSECDOI_NTYPE_REPLAY_STATUS:
+			ND_PRINT((ndo,"" status=(""));
 			ND_PRINT((ndo,""replay detection %sabled"",
 				  EXTRACT_32BITS(cp) ? ""en"" : ""dis""));
-			break;
-		case ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN:
-			if (ikev1_sub_print(ndo, ISAKMP_NPTYPE_SA,
-					    (const struct isakmp_gen *)cp, ep, phase, doi, proto,
-					    depth) == NULL)
-				return NULL;
+			ND_PRINT((ndo,"")""));
 			break;
 		default:
-			/* NULL is dummy */
-			isakmp_print(ndo, cp,
-				     item_len - sizeof(*p) - n.spi_size,
-				     NULL);
+			/*
+			 * XXX - fill in more types here; see, for example,
+			 * draft-ietf-ipsec-notifymsg-04.
+			 */
+			if (ndo->ndo_vflag > 3) {
+				ND_PRINT((ndo,"" data=(""));
+				if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
+					goto trunc;
+				ND_PRINT((ndo,"")""));
+			} else {
+				if (!ike_show_somedata(ndo, cp, ep))
+					goto trunc;
+			}
+			break;
 		}
-		ND_PRINT((ndo,"")""));
 	}
 	return (const u_char *)ext + item_len;
 trunc:
@@ -2264,16 +2275,21 @@ ikev2_auth_print(netdissect_options *ndo, u_char tpay,
 	ikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);
 	len = ntohs(a.h.len);
 
-	ND_PRINT((ndo,"" len=%d method=%s"", len-4,
+	/*
+	 * Our caller has ensured that the length is >= 4.
+	 */
+	ND_PRINT((ndo,"" len=%u method=%s"", len-4,
 		  STR_OR_ID(a.auth_method, v2_auth)));
-
-	if (1 < ndo->ndo_vflag && 4 < len) {
-		ND_PRINT((ndo,"" authdata=(""));
-		if (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))
-			goto trunc;
-		ND_PRINT((ndo,"") ""));
-	} else if(ndo->ndo_vflag && 4 < len) {
-		if(!ike_show_somedata(ndo, authdata, ep)) goto trunc;
+	if (len > 4) {
+		if (ndo->ndo_vflag > 1) {
+			ND_PRINT((ndo, "" authdata=(""));
+			if (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))
+				goto trunc;
+			ND_PRINT((ndo, "") ""));
+		} else if (ndo->ndo_vflag) {
+			if (!ike_show_somedata(ndo, authdata, ep))
+				goto trunc;
+		}
 	}
 
 	return (const u_char *)ext + len;
@@ -2322,7 +2338,7 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
 	const struct ikev2_n *p;
 	struct ikev2_n n;
 	const u_char *cp;
-	u_char showspi, showdata, showsomedata;
+	u_char showspi, showsomedata;
 	const char *notify_name;
 	uint32_t type;
 
@@ -2332,7 +2348,6 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
 	ikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_N), n.h.critical);
 
 	showspi = 1;
-	showdata = 0;
 	showsomedata=0;
 	notify_name=NULL;
 
@@ -2446,7 +2461,6 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
 		notify_name = ""cookie"";
 		showspi = 1;
 		showsomedata= 1;
-		showdata= 0;
 		break;
 
 	case IV2_NOTIFY_USE_TRANSPORT_MODE:
@@ -2499,19 +2513,17 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
 
 	cp = (const u_char *)(p + 1) + n.spi_size;
 
-	if(3 < ndo->ndo_vflag) {
-		showdata = 1;
-	}
-
-	if ((showdata || (showsomedata && ep-cp < 30)) && cp < ep) {
-		ND_PRINT((ndo,"" data=(""));
-		if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
-			goto trunc;
-
-		ND_PRINT((ndo,"")""));
+	if (cp < ep) {
+		if (ndo->ndo_vflag > 3 || (showsomedata && ep-cp < 30)) {
+			ND_PRINT((ndo,"" data=(""));
+			if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
+				goto trunc;
 
-	} else if(showsomedata && cp < ep) {
-		if(!ike_show_somedata(ndo, cp, ep)) goto trunc;
+			ND_PRINT((ndo,"")""));
+		} else if (showsomedata) {
+			if (!ike_show_somedata(ndo, cp, ep))
+				goto trunc;
+		}
 	}
 
 	return (const u_char *)ext + item_len;
@@ -3091,7 +3103,3 @@ isakmp_rfc3948_print(netdissect_options *ndo,
  * c-basic-offset: 8
  * End:
  */
-
-
-
-",tcpdump,c2ef693866beae071a24b45c49f9674af1df4028,50a44b6b8e4f7c127440dbd4239cf571945cc1e7,1," ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,
 	      const struct isakmp_gen *ext, u_int item_len,
//flaw_line_below:
	      const u_char *ep, uint32_t phase, uint32_t doi0 _U_,
//flaw_line_below:
	      uint32_t proto0 _U_, int depth)
//fix_flaw_line_below:
//	      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,
//fix_flaw_line_below:
//	      uint32_t proto0 _U_, int depth _U_)
 {
 	const struct ikev1_pl_n *p;
 	struct ikev1_pl_n n;
	const u_char *cp;
	const u_char *ep2;
	uint32_t doi;
	uint32_t proto;
	static const char *notify_error_str[] = {
		NULL,				""INVALID-PAYLOAD-TYPE"",
		""DOI-NOT-SUPPORTED"",		""SITUATION-NOT-SUPPORTED"",
		""INVALID-COOKIE"",		""INVALID-MAJOR-VERSION"",
		""INVALID-MINOR-VERSION"",	""INVALID-EXCHANGE-TYPE"",
		""INVALID-FLAGS"",		""INVALID-MESSAGE-ID"",
		""INVALID-PROTOCOL-ID"",		""INVALID-SPI"",
		""INVALID-TRANSFORM-ID"",		""ATTRIBUTES-NOT-SUPPORTED"",
		""NO-PROPOSAL-CHOSEN"",		""BAD-PROPOSAL-SYNTAX"",
		""PAYLOAD-MALFORMED"",		""INVALID-KEY-INFORMATION"",
		""INVALID-ID-INFORMATION"",	""INVALID-CERT-ENCODING"",
		""INVALID-CERTIFICATE"",		""CERT-TYPE-UNSUPPORTED"",
		""INVALID-CERT-AUTHORITY"",	""INVALID-HASH-INFORMATION"",
		""AUTHENTICATION-FAILED"",	""INVALID-SIGNATURE"",
		""ADDRESS-NOTIFICATION"",		""NOTIFY-SA-LIFETIME"",
		""CERTIFICATE-UNAVAILABLE"",	""UNSUPPORTED-EXCHANGE-TYPE"",
		""UNEQUAL-PAYLOAD-LENGTHS"",
	};
	static const char *ipsec_notify_error_str[] = {
		""RESERVED"",
	};
	static const char *notify_status_str[] = {
		""CONNECTED"",
	};
	static const char *ipsec_notify_status_str[] = {
		""RESPONDER-LIFETIME"",		""REPLAY-STATUS"",
		""INITIAL-CONTACT"",
	};
/* NOTE: these macro must be called with x in proper range */

/* 0 - 8191 */
#define NOTIFY_ERROR_STR(x) \
	STR_OR_ID((x), notify_error_str)

/* 8192 - 16383 */
#define IPSEC_NOTIFY_ERROR_STR(x) \
	STR_OR_ID((u_int)((x) - 8192), ipsec_notify_error_str)

/* 16384 - 24575 */
#define NOTIFY_STATUS_STR(x) \
	STR_OR_ID((u_int)((x) - 16384), notify_status_str)

/* 24576 - 32767 */
#define IPSEC_NOTIFY_STATUS_STR(x) \
	STR_OR_ID((u_int)((x) - 24576), ipsec_notify_status_str)

	ND_PRINT((ndo,""%s:"", NPSTR(ISAKMP_NPTYPE_N)));

	p = (const struct ikev1_pl_n *)ext;
	ND_TCHECK(*p);
	UNALIGNED_MEMCPY(&n, ext, sizeof(n));
	doi = ntohl(n.doi);
	proto = n.prot_id;
	if (doi != 1) {
		ND_PRINT((ndo,"" doi=%d"", doi));
		ND_PRINT((ndo,"" proto=%d"", proto));
		if (ntohs(n.type) < 8192)
			ND_PRINT((ndo,"" type=%s"", NOTIFY_ERROR_STR(ntohs(n.type))));
		else if (ntohs(n.type) < 16384)
			ND_PRINT((ndo,"" type=%s"", numstr(ntohs(n.type))));
		else if (ntohs(n.type) < 24576)
			ND_PRINT((ndo,"" type=%s"", NOTIFY_STATUS_STR(ntohs(n.type))));
		else
			ND_PRINT((ndo,"" type=%s"", numstr(ntohs(n.type))));
		if (n.spi_size) {
			ND_PRINT((ndo,"" spi=""));
			if (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))
				goto trunc;
		}
		return (const u_char *)(p + 1) + n.spi_size;
	}

	ND_PRINT((ndo,"" doi=ipsec""));
	ND_PRINT((ndo,"" proto=%s"", PROTOIDSTR(proto)));
	if (ntohs(n.type) < 8192)
		ND_PRINT((ndo,"" type=%s"", NOTIFY_ERROR_STR(ntohs(n.type))));
	else if (ntohs(n.type) < 16384)
		ND_PRINT((ndo,"" type=%s"", IPSEC_NOTIFY_ERROR_STR(ntohs(n.type))));
	else if (ntohs(n.type) < 24576)
		ND_PRINT((ndo,"" type=%s"", NOTIFY_STATUS_STR(ntohs(n.type))));
	else if (ntohs(n.type) < 32768)
		ND_PRINT((ndo,"" type=%s"", IPSEC_NOTIFY_STATUS_STR(ntohs(n.type))));
	else
		ND_PRINT((ndo,"" type=%s"", numstr(ntohs(n.type))));
	if (n.spi_size) {
		ND_PRINT((ndo,"" spi=""));
		if (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))
			goto trunc;
	}

	cp = (const u_char *)(p + 1) + n.spi_size;
 	ep2 = (const u_char *)p + item_len;
 
 	if (cp < ep) {
//flaw_line_below:
		ND_PRINT((ndo,"" orig=(""));
 		switch (ntohs(n.type)) {
 		case IPSECDOI_NTYPE_RESPONDER_LIFETIME:
 		    {
 			const struct attrmap *map = oakley_t_map;
 			size_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);
//fix_flaw_line_below:
//			ND_PRINT((ndo,"" attrs=(""));
 			while (cp < ep && cp < ep2) {
 				cp = ikev1_attrmap_print(ndo, cp,
 					(ep < ep2) ? ep : ep2, map, nmap);
 			}
//fix_flaw_line_below:
//			ND_PRINT((ndo,"")""));
 			break;
 		    }
 		case IPSECDOI_NTYPE_REPLAY_STATUS:
//fix_flaw_line_below:
//			ND_PRINT((ndo,"" status=(""));
 			ND_PRINT((ndo,""replay detection %sabled"",
 				  EXTRACT_32BITS(cp) ? ""en"" : ""dis""));
//flaw_line_below:
			break;
//flaw_line_below:
		case ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN:
//flaw_line_below:
			if (ikev1_sub_print(ndo, ISAKMP_NPTYPE_SA,
//flaw_line_below:
					    (const struct isakmp_gen *)cp, ep, phase, doi, proto,
//flaw_line_below:
					    depth) == NULL)
//flaw_line_below:
				return NULL;
//fix_flaw_line_below:
//			ND_PRINT((ndo,"")""));
 			break;
 		default:
//flaw_line_below:
			/* NULL is dummy */
//flaw_line_below:
			isakmp_print(ndo, cp,
//flaw_line_below:
				     item_len - sizeof(*p) - n.spi_size,
//flaw_line_below:
				     NULL);
//fix_flaw_line_below:
//			/*
//fix_flaw_line_below:
//			 * XXX - fill in more types here; see, for example,
//fix_flaw_line_below:
//			 * draft-ietf-ipsec-notifymsg-04.
//fix_flaw_line_below:
//			 */
//fix_flaw_line_below:
//			if (ndo->ndo_vflag > 3) {
//fix_flaw_line_below:
//				ND_PRINT((ndo,"" data=(""));
//fix_flaw_line_below:
//				if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
//fix_flaw_line_below:
//					goto trunc;
//fix_flaw_line_below:
//				ND_PRINT((ndo,"")""));
//fix_flaw_line_below:
//			} else {
//fix_flaw_line_below:
//				if (!ike_show_somedata(ndo, cp, ep))
//fix_flaw_line_below:
//					goto trunc;
//fix_flaw_line_below:
//			}
//fix_flaw_line_below:
//			break;
 		}
//flaw_line_below:
		ND_PRINT((ndo,"")""));
 	}
 	return (const u_char *)ext + item_len;
 trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_N)));
	return NULL;
}
"
3361,181097,,Remote,Not required,Partial,CVE-2017-12990,https://www.cvedetails.com/cve/CVE-2017-12990/,CWE-835,Low,,,,2017-09-14,5.0,"The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.",2019-10-02,,14,https://github.com/the-tcpdump-group/tcpdump/commit/c2ef693866beae071a24b45c49f9674af1df4028,c2ef693866beae071a24b45c49f9674af1df4028,"CVE-2017-12990/Fix printing of ISAKMPv1 Notification payload data.

The closest thing to a specification for the contents of the payload
data is draft-ietf-ipsec-notifymsg-04, and nothing in there says that it
is ever a complete ISAKMP message, so don't dissect types we don't have
specific code for as a complete ISAKMP message.

While we're at it, fix a comment, and clean up printing of V1 Nonce,
V2 Authentication payloads, and v2 Notice payloads.

This fixes an infinite loop discovered by Forcepoint's security
researchers Otto Airamo & Antti Levomki.

Add a test using the capture file supplied by the reporter(s).",9,print-isakmp.c,"{""sha"": ""9de9b75d21e74156a74f0708a5b2fa636861b803"", ""filename"": ""print-isakmp.c"", ""status"": ""modified"", ""additions"": 60, ""deletions"": 52, ""changes"": 112, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/c2ef693866beae071a24b45c49f9674af1df4028/print-isakmp.c"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/c2ef693866beae071a24b45c49f9674af1df4028/print-isakmp.c"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/print-isakmp.c?ref=c2ef693866beae071a24b45c49f9674af1df4028"", ""patch"": ""@@ -428,7 +428,7 @@ struct notify_messages {\n \tchar     *msg;\n };\n \n-/* 3.8 Notification Payload */\n+/* 3.8 Authentication Payload */\n struct ikev2_auth {\n \tstruct isakmp_gen h;\n \tuint8_t  auth_method;  /* Protocol-ID */\n@@ -1590,15 +1590,20 @@ ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n \n \tND_TCHECK(*ext);\n \tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n-\tND_PRINT((ndo,\"" n len=%d\"", ntohs(e.len) - 4));\n-\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n-\t\tND_PRINT((ndo,\"" \""));\n-\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n-\t\t\tgoto trunc;\n-\t} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n-\t\tND_PRINT((ndo,\"" \""));\n-\t\tif (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))\n-\t\t\tgoto trunc;\n+\t/*\n+\t * Our caller has ensured that the length is >= 4.\n+\t */\n+\tND_PRINT((ndo,\"" n len=%u\"", ntohs(e.len) - 4));\n+\tif (ntohs(e.len) > 4) {\n+\t\tif (ndo->ndo_vflag > 2) {\n+\t\t\tND_PRINT((ndo, \"" \""));\n+\t\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n+\t\t\t\tgoto trunc;\n+\t\t} else if (ndo->ndo_vflag > 1) {\n+\t\t\tND_PRINT((ndo, \"" \""));\n+\t\t\tif (!ike_show_somedata(ndo, (const u_char *)(ext + 1), ep))\n+\t\t\t\tgoto trunc;\n+\t\t}\n \t}\n \treturn (const u_char *)ext + ntohs(e.len);\n trunc:\n@@ -1609,8 +1614,8 @@ ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n static const u_char *\n ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n \t      const struct isakmp_gen *ext, u_int item_len,\n-\t      const u_char *ep, uint32_t phase, uint32_t doi0 _U_,\n-\t      uint32_t proto0 _U_, int depth)\n+\t      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,\n+\t      uint32_t proto0 _U_, int depth _U_)\n {\n \tconst struct ikev1_pl_n *p;\n \tstruct ikev1_pl_n n;\n@@ -1712,35 +1717,41 @@ ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n \tep2 = (const u_char *)p + item_len;\n \n \tif (cp < ep) {\n-\t\tND_PRINT((ndo,\"" orig=(\""));\n \t\tswitch (ntohs(n.type)) {\n \t\tcase IPSECDOI_NTYPE_RESPONDER_LIFETIME:\n \t\t    {\n \t\t\tconst struct attrmap *map = oakley_t_map;\n \t\t\tsize_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);\n+\t\t\tND_PRINT((ndo,\"" attrs=(\""));\n \t\t\twhile (cp < ep && cp < ep2) {\n \t\t\t\tcp = ikev1_attrmap_print(ndo, cp,\n \t\t\t\t\t(ep < ep2) ? ep : ep2, map, nmap);\n \t\t\t}\n+\t\t\tND_PRINT((ndo,\"")\""));\n \t\t\tbreak;\n \t\t    }\n \t\tcase IPSECDOI_NTYPE_REPLAY_STATUS:\n+\t\t\tND_PRINT((ndo,\"" status=(\""));\n \t\t\tND_PRINT((ndo,\""replay detection %sabled\"",\n \t\t\t\t  EXTRACT_32BITS(cp) ? \""en\"" : \""dis\""));\n-\t\t\tbreak;\n-\t\tcase ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN:\n-\t\t\tif (ikev1_sub_print(ndo, ISAKMP_NPTYPE_SA,\n-\t\t\t\t\t    (const struct isakmp_gen *)cp, ep, phase, doi, proto,\n-\t\t\t\t\t    depth) == NULL)\n-\t\t\t\treturn NULL;\n+\t\t\tND_PRINT((ndo,\"")\""));\n \t\t\tbreak;\n \t\tdefault:\n-\t\t\t/* NULL is dummy */\n-\t\t\tisakmp_print(ndo, cp,\n-\t\t\t\t     item_len - sizeof(*p) - n.spi_size,\n-\t\t\t\t     NULL);\n+\t\t\t/*\n+\t\t\t * XXX - fill in more types here; see, for example,\n+\t\t\t * draft-ietf-ipsec-notifymsg-04.\n+\t\t\t */\n+\t\t\tif (ndo->ndo_vflag > 3) {\n+\t\t\t\tND_PRINT((ndo,\"" data=(\""));\n+\t\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n+\t\t\t\t\tgoto trunc;\n+\t\t\t\tND_PRINT((ndo,\"")\""));\n+\t\t\t} else {\n+\t\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n+\t\t\t\t\tgoto trunc;\n+\t\t\t}\n+\t\t\tbreak;\n \t\t}\n-\t\tND_PRINT((ndo,\"")\""));\n \t}\n \treturn (const u_char *)ext + item_len;\n trunc:\n@@ -2264,16 +2275,21 @@ ikev2_auth_print(netdissect_options *ndo, u_char tpay,\n \tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n \tlen = ntohs(a.h.len);\n \n-\tND_PRINT((ndo,\"" len=%d method=%s\"", len-4,\n+\t/*\n+\t * Our caller has ensured that the length is >= 4.\n+\t */\n+\tND_PRINT((ndo,\"" len=%u method=%s\"", len-4,\n \t\t  STR_OR_ID(a.auth_method, v2_auth)));\n-\n-\tif (1 < ndo->ndo_vflag && 4 < len) {\n-\t\tND_PRINT((ndo,\"" authdata=(\""));\n-\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n-\t\t\tgoto trunc;\n-\t\tND_PRINT((ndo,\"") \""));\n-\t} else if(ndo->ndo_vflag && 4 < len) {\n-\t\tif(!ike_show_somedata(ndo, authdata, ep)) goto trunc;\n+\tif (len > 4) {\n+\t\tif (ndo->ndo_vflag > 1) {\n+\t\t\tND_PRINT((ndo, \"" authdata=(\""));\n+\t\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n+\t\t\t\tgoto trunc;\n+\t\t\tND_PRINT((ndo, \"") \""));\n+\t\t} else if (ndo->ndo_vflag) {\n+\t\t\tif (!ike_show_somedata(ndo, authdata, ep))\n+\t\t\t\tgoto trunc;\n+\t\t}\n \t}\n \n \treturn (const u_char *)ext + len;\n@@ -2322,7 +2338,7 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n \tconst struct ikev2_n *p;\n \tstruct ikev2_n n;\n \tconst u_char *cp;\n-\tu_char showspi, showdata, showsomedata;\n+\tu_char showspi, showsomedata;\n \tconst char *notify_name;\n \tuint32_t type;\n \n@@ -2332,7 +2348,6 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n \tikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_N), n.h.critical);\n \n \tshowspi = 1;\n-\tshowdata = 0;\n \tshowsomedata=0;\n \tnotify_name=NULL;\n \n@@ -2446,7 +2461,6 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n \t\tnotify_name = \""cookie\"";\n \t\tshowspi = 1;\n \t\tshowsomedata= 1;\n-\t\tshowdata= 0;\n \t\tbreak;\n \n \tcase IV2_NOTIFY_USE_TRANSPORT_MODE:\n@@ -2499,19 +2513,17 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n \n \tcp = (const u_char *)(p + 1) + n.spi_size;\n \n-\tif(3 < ndo->ndo_vflag) {\n-\t\tshowdata = 1;\n-\t}\n-\n-\tif ((showdata || (showsomedata && ep-cp < 30)) && cp < ep) {\n-\t\tND_PRINT((ndo,\"" data=(\""));\n-\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n-\t\t\tgoto trunc;\n-\n-\t\tND_PRINT((ndo,\"")\""));\n+\tif (cp < ep) {\n+\t\tif (ndo->ndo_vflag > 3 || (showsomedata && ep-cp < 30)) {\n+\t\t\tND_PRINT((ndo,\"" data=(\""));\n+\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n+\t\t\t\tgoto trunc;\n \n-\t} else if(showsomedata && cp < ep) {\n-\t\tif(!ike_show_somedata(ndo, cp, ep)) goto trunc;\n+\t\t\tND_PRINT((ndo,\"")\""));\n+\t\t} else if (showsomedata) {\n+\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n+\t\t\t\tgoto trunc;\n+\t\t}\n \t}\n \n \treturn (const u_char *)ext + item_len;\n@@ -3091,7 +3103,3 @@ isakmp_rfc3948_print(netdissect_options *ndo,\n  * c-basic-offset: 8\n  * End:\n  */\n-\n-\n-\n-""}<_**next**_>{""sha"": ""ed5b82aa348d9366ad7745abec943618d413f14a"", ""filename"": ""tests/TESTLIST"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/c2ef693866beae071a24b45c49f9674af1df4028/tests/TESTLIST"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/c2ef693866beae071a24b45c49f9674af1df4028/tests/TESTLIST"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/TESTLIST?ref=c2ef693866beae071a24b45c49f9674af1df4028"", ""patch"": ""@@ -465,6 +465,7 @@ tok2str-oobr-2\t\ttok2str-oobr-2.pcap\t\ttok2str-oobr-2.out\t-vvv -e\n eigrp-tlv-oobr\t\teigrp-tlv-oobr.pcap\t\teigrp-tlv-oobr.out\t-vvv -e\n zephyr-oobr\t\tzephyr-oobr.pcap\t\tzephyr-oobr.out\t\t-vvv -e\n bgp-as-path-oobr\tbgp-as-path-oobr.pcap\t\tbgp-as-path-oobr.out\t-vvv -e\n+isakmp-no-none-np\tisakmp-no-none-np.pcap\t\tisakmp-no-none-np.out\t-vvv -e\n \n # RTP tests\n # fuzzed pcap""}<_**next**_>{""sha"": ""eb91c804a87aaa6ec37215ca06a6bf17593d861b"", ""filename"": ""tests/isakmp-no-none-np.out"", ""status"": ""added"", ""additions"": 78, ""deletions"": 0, ""changes"": 78, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/c2ef693866beae071a24b45c49f9674af1df4028/tests/isakmp-no-none-np.out"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/c2ef693866beae071a24b45c49f9674af1df4028/tests/isakmp-no-none-np.out"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/isakmp-no-none-np.out?ref=c2ef693866beae071a24b45c49f9674af1df4028"", ""patch"": ""@@ -0,0 +1,78 @@\n+00:0c:29:86:c8:36 > 00:1a:4b:6a:ce:fe, ethertype IPv4 (0x0800), length 2228: (tos 0x0, ttl 128, id 28793, offset 0, flags [none], proto UDP (17), length 2214)\n+    192.168.1.25.500 > 192.168.1.10.500: [udp sum ok] isakmp 1.0 msgid 5f724dc6 cookie 0000000000000000->0000000000000000: phase 2/others ? inf:\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=0000000000000000000000000010ba00 data=(00ff1d00020082001101...0100000700000000000000000000000000000000)) [|n] (len mismatch: isakmp 84/ip 2186)""}<_**next**_>{""sha"": ""fd388d617e4f2937fdb1214bdcce59c8c159a90c"", ""filename"": ""tests/isakmp-no-none-np.pcap"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/c2ef693866beae071a24b45c49f9674af1df4028/tests/isakmp-no-none-np.pcap"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/c2ef693866beae071a24b45c49f9674af1df4028/tests/isakmp-no-none-np.pcap"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/isakmp-no-none-np.pcap?ref=c2ef693866beae071a24b45c49f9674af1df4028""}","ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,
		  const struct isakmp_gen *ext,
		  u_int item_len _U_,
		  const u_char *ep,
		  uint32_t phase _U_, uint32_t doi _U_,
		  uint32_t proto _U_, int depth _U_)
{
	struct isakmp_gen e;

	ND_PRINT((ndo,""%s:"", NPSTR(ISAKMP_NPTYPE_NONCE)));
 
 	ND_TCHECK(*ext);
 	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
	/*
	 * Our caller has ensured that the length is >= 4.
	 */
	ND_PRINT((ndo,"" n len=%u"", ntohs(e.len) - 4));
	if (ntohs(e.len) > 4) {
		if (ndo->ndo_vflag > 2) {
			ND_PRINT((ndo, "" ""));
			if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
				goto trunc;
		} else if (ndo->ndo_vflag > 1) {
			ND_PRINT((ndo, "" ""));
			if (!ike_show_somedata(ndo, (const u_char *)(ext + 1), ep))
				goto trunc;
		}
 	}
 	return (const u_char *)ext + ntohs(e.len);
 trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_NONCE)));
	return NULL;
}
","ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,
		  const struct isakmp_gen *ext,
		  u_int item_len _U_,
		  const u_char *ep,
		  uint32_t phase _U_, uint32_t doi _U_,
		  uint32_t proto _U_, int depth _U_)
{
	struct isakmp_gen e;

	ND_PRINT((ndo,""%s:"", NPSTR(ISAKMP_NPTYPE_NONCE)));
 
 	ND_TCHECK(*ext);
 	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
	ND_PRINT((ndo,"" n len=%d"", ntohs(e.len) - 4));
	if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
		ND_PRINT((ndo,"" ""));
		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
			goto trunc;
	} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
		ND_PRINT((ndo,"" ""));
		if (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))
			goto trunc;
 	}
 	return (const u_char *)ext + ntohs(e.len);
 trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_NONCE)));
	return NULL;
}
",C,"	/*
	 * Our caller has ensured that the length is >= 4.
	 */
	ND_PRINT((ndo,"" n len=%u"", ntohs(e.len) - 4));
	if (ntohs(e.len) > 4) {
		if (ndo->ndo_vflag > 2) {
			ND_PRINT((ndo, "" ""));
			if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
				goto trunc;
		} else if (ndo->ndo_vflag > 1) {
			ND_PRINT((ndo, "" ""));
			if (!ike_show_somedata(ndo, (const u_char *)(ext + 1), ep))
				goto trunc;
		}
","	ND_PRINT((ndo,"" n len=%d"", ntohs(e.len) - 4));
	if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
		ND_PRINT((ndo,"" ""));
		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
			goto trunc;
	} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
		ND_PRINT((ndo,"" ""));
		if (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))
			goto trunc;
",,"@@ -428,7 +428,7 @@ struct notify_messages {
 	char     *msg;
 };
 
-/* 3.8 Notification Payload */
+/* 3.8 Authentication Payload */
 struct ikev2_auth {
 	struct isakmp_gen h;
 	uint8_t  auth_method;  /* Protocol-ID */
@@ -1590,15 +1590,20 @@ ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,
 
 	ND_TCHECK(*ext);
 	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
-	ND_PRINT((ndo,"" n len=%d"", ntohs(e.len) - 4));
-	if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
-		ND_PRINT((ndo,"" ""));
-		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
-			goto trunc;
-	} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
-		ND_PRINT((ndo,"" ""));
-		if (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))
-			goto trunc;
+	/*
+	 * Our caller has ensured that the length is >= 4.
+	 */
+	ND_PRINT((ndo,"" n len=%u"", ntohs(e.len) - 4));
+	if (ntohs(e.len) > 4) {
+		if (ndo->ndo_vflag > 2) {
+			ND_PRINT((ndo, "" ""));
+			if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
+				goto trunc;
+		} else if (ndo->ndo_vflag > 1) {
+			ND_PRINT((ndo, "" ""));
+			if (!ike_show_somedata(ndo, (const u_char *)(ext + 1), ep))
+				goto trunc;
+		}
 	}
 	return (const u_char *)ext + ntohs(e.len);
 trunc:
@@ -1609,8 +1614,8 @@ ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,
 static const u_char *
 ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,
 	      const struct isakmp_gen *ext, u_int item_len,
-	      const u_char *ep, uint32_t phase, uint32_t doi0 _U_,
-	      uint32_t proto0 _U_, int depth)
+	      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,
+	      uint32_t proto0 _U_, int depth _U_)
 {
 	const struct ikev1_pl_n *p;
 	struct ikev1_pl_n n;
@@ -1712,35 +1717,41 @@ ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,
 	ep2 = (const u_char *)p + item_len;
 
 	if (cp < ep) {
-		ND_PRINT((ndo,"" orig=(""));
 		switch (ntohs(n.type)) {
 		case IPSECDOI_NTYPE_RESPONDER_LIFETIME:
 		    {
 			const struct attrmap *map = oakley_t_map;
 			size_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);
+			ND_PRINT((ndo,"" attrs=(""));
 			while (cp < ep && cp < ep2) {
 				cp = ikev1_attrmap_print(ndo, cp,
 					(ep < ep2) ? ep : ep2, map, nmap);
 			}
+			ND_PRINT((ndo,"")""));
 			break;
 		    }
 		case IPSECDOI_NTYPE_REPLAY_STATUS:
+			ND_PRINT((ndo,"" status=(""));
 			ND_PRINT((ndo,""replay detection %sabled"",
 				  EXTRACT_32BITS(cp) ? ""en"" : ""dis""));
-			break;
-		case ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN:
-			if (ikev1_sub_print(ndo, ISAKMP_NPTYPE_SA,
-					    (const struct isakmp_gen *)cp, ep, phase, doi, proto,
-					    depth) == NULL)
-				return NULL;
+			ND_PRINT((ndo,"")""));
 			break;
 		default:
-			/* NULL is dummy */
-			isakmp_print(ndo, cp,
-				     item_len - sizeof(*p) - n.spi_size,
-				     NULL);
+			/*
+			 * XXX - fill in more types here; see, for example,
+			 * draft-ietf-ipsec-notifymsg-04.
+			 */
+			if (ndo->ndo_vflag > 3) {
+				ND_PRINT((ndo,"" data=(""));
+				if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
+					goto trunc;
+				ND_PRINT((ndo,"")""));
+			} else {
+				if (!ike_show_somedata(ndo, cp, ep))
+					goto trunc;
+			}
+			break;
 		}
-		ND_PRINT((ndo,"")""));
 	}
 	return (const u_char *)ext + item_len;
 trunc:
@@ -2264,16 +2275,21 @@ ikev2_auth_print(netdissect_options *ndo, u_char tpay,
 	ikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);
 	len = ntohs(a.h.len);
 
-	ND_PRINT((ndo,"" len=%d method=%s"", len-4,
+	/*
+	 * Our caller has ensured that the length is >= 4.
+	 */
+	ND_PRINT((ndo,"" len=%u method=%s"", len-4,
 		  STR_OR_ID(a.auth_method, v2_auth)));
-
-	if (1 < ndo->ndo_vflag && 4 < len) {
-		ND_PRINT((ndo,"" authdata=(""));
-		if (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))
-			goto trunc;
-		ND_PRINT((ndo,"") ""));
-	} else if(ndo->ndo_vflag && 4 < len) {
-		if(!ike_show_somedata(ndo, authdata, ep)) goto trunc;
+	if (len > 4) {
+		if (ndo->ndo_vflag > 1) {
+			ND_PRINT((ndo, "" authdata=(""));
+			if (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))
+				goto trunc;
+			ND_PRINT((ndo, "") ""));
+		} else if (ndo->ndo_vflag) {
+			if (!ike_show_somedata(ndo, authdata, ep))
+				goto trunc;
+		}
 	}
 
 	return (const u_char *)ext + len;
@@ -2322,7 +2338,7 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
 	const struct ikev2_n *p;
 	struct ikev2_n n;
 	const u_char *cp;
-	u_char showspi, showdata, showsomedata;
+	u_char showspi, showsomedata;
 	const char *notify_name;
 	uint32_t type;
 
@@ -2332,7 +2348,6 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
 	ikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_N), n.h.critical);
 
 	showspi = 1;
-	showdata = 0;
 	showsomedata=0;
 	notify_name=NULL;
 
@@ -2446,7 +2461,6 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
 		notify_name = ""cookie"";
 		showspi = 1;
 		showsomedata= 1;
-		showdata= 0;
 		break;
 
 	case IV2_NOTIFY_USE_TRANSPORT_MODE:
@@ -2499,19 +2513,17 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
 
 	cp = (const u_char *)(p + 1) + n.spi_size;
 
-	if(3 < ndo->ndo_vflag) {
-		showdata = 1;
-	}
-
-	if ((showdata || (showsomedata && ep-cp < 30)) && cp < ep) {
-		ND_PRINT((ndo,"" data=(""));
-		if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
-			goto trunc;
-
-		ND_PRINT((ndo,"")""));
+	if (cp < ep) {
+		if (ndo->ndo_vflag > 3 || (showsomedata && ep-cp < 30)) {
+			ND_PRINT((ndo,"" data=(""));
+			if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
+				goto trunc;
 
-	} else if(showsomedata && cp < ep) {
-		if(!ike_show_somedata(ndo, cp, ep)) goto trunc;
+			ND_PRINT((ndo,"")""));
+		} else if (showsomedata) {
+			if (!ike_show_somedata(ndo, cp, ep))
+				goto trunc;
+		}
 	}
 
 	return (const u_char *)ext + item_len;
@@ -3091,7 +3103,3 @@ isakmp_rfc3948_print(netdissect_options *ndo,
  * c-basic-offset: 8
  * End:
  */
-
-
-
-",tcpdump,c2ef693866beae071a24b45c49f9674af1df4028,50a44b6b8e4f7c127440dbd4239cf571945cc1e7,1,"ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,
		  const struct isakmp_gen *ext,
		  u_int item_len _U_,
		  const u_char *ep,
		  uint32_t phase _U_, uint32_t doi _U_,
		  uint32_t proto _U_, int depth _U_)
{
	struct isakmp_gen e;

	ND_PRINT((ndo,""%s:"", NPSTR(ISAKMP_NPTYPE_NONCE)));
 
 	ND_TCHECK(*ext);
 	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
//flaw_line_below:
	ND_PRINT((ndo,"" n len=%d"", ntohs(e.len) - 4));
//flaw_line_below:
	if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
//flaw_line_below:
		ND_PRINT((ndo,"" ""));
//flaw_line_below:
		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
//flaw_line_below:
			goto trunc;
//flaw_line_below:
	} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
//flaw_line_below:
		ND_PRINT((ndo,"" ""));
//flaw_line_below:
		if (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))
//flaw_line_below:
			goto trunc;
//fix_flaw_line_below:
//	/*
//fix_flaw_line_below:
//	 * Our caller has ensured that the length is >= 4.
//fix_flaw_line_below:
//	 */
//fix_flaw_line_below:
//	ND_PRINT((ndo,"" n len=%u"", ntohs(e.len) - 4));
//fix_flaw_line_below:
//	if (ntohs(e.len) > 4) {
//fix_flaw_line_below:
//		if (ndo->ndo_vflag > 2) {
//fix_flaw_line_below:
//			ND_PRINT((ndo, "" ""));
//fix_flaw_line_below:
//			if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
//fix_flaw_line_below:
//				goto trunc;
//fix_flaw_line_below:
//		} else if (ndo->ndo_vflag > 1) {
//fix_flaw_line_below:
//			ND_PRINT((ndo, "" ""));
//fix_flaw_line_below:
//			if (!ike_show_somedata(ndo, (const u_char *)(ext + 1), ep))
//fix_flaw_line_below:
//				goto trunc;
//fix_flaw_line_below:
//		}
 	}
 	return (const u_char *)ext + ntohs(e.len);
 trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_NONCE)));
	return NULL;
}
"
3362,181098,,Remote,Not required,Partial,CVE-2017-12990,https://www.cvedetails.com/cve/CVE-2017-12990/,CWE-835,Low,,,,2017-09-14,5.0,"The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.",2019-10-02,,14,https://github.com/the-tcpdump-group/tcpdump/commit/c2ef693866beae071a24b45c49f9674af1df4028,c2ef693866beae071a24b45c49f9674af1df4028,"CVE-2017-12990/Fix printing of ISAKMPv1 Notification payload data.

The closest thing to a specification for the contents of the payload
data is draft-ietf-ipsec-notifymsg-04, and nothing in there says that it
is ever a complete ISAKMP message, so don't dissect types we don't have
specific code for as a complete ISAKMP message.

While we're at it, fix a comment, and clean up printing of V1 Nonce,
V2 Authentication payloads, and v2 Notice payloads.

This fixes an infinite loop discovered by Forcepoint's security
researchers Otto Airamo & Antti Levomki.

Add a test using the capture file supplied by the reporter(s).",8,print-isakmp.c,"{""sha"": ""9de9b75d21e74156a74f0708a5b2fa636861b803"", ""filename"": ""print-isakmp.c"", ""status"": ""modified"", ""additions"": 60, ""deletions"": 52, ""changes"": 112, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/c2ef693866beae071a24b45c49f9674af1df4028/print-isakmp.c"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/c2ef693866beae071a24b45c49f9674af1df4028/print-isakmp.c"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/print-isakmp.c?ref=c2ef693866beae071a24b45c49f9674af1df4028"", ""patch"": ""@@ -428,7 +428,7 @@ struct notify_messages {\n \tchar     *msg;\n };\n \n-/* 3.8 Notification Payload */\n+/* 3.8 Authentication Payload */\n struct ikev2_auth {\n \tstruct isakmp_gen h;\n \tuint8_t  auth_method;  /* Protocol-ID */\n@@ -1590,15 +1590,20 @@ ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n \n \tND_TCHECK(*ext);\n \tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n-\tND_PRINT((ndo,\"" n len=%d\"", ntohs(e.len) - 4));\n-\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n-\t\tND_PRINT((ndo,\"" \""));\n-\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n-\t\t\tgoto trunc;\n-\t} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n-\t\tND_PRINT((ndo,\"" \""));\n-\t\tif (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))\n-\t\t\tgoto trunc;\n+\t/*\n+\t * Our caller has ensured that the length is >= 4.\n+\t */\n+\tND_PRINT((ndo,\"" n len=%u\"", ntohs(e.len) - 4));\n+\tif (ntohs(e.len) > 4) {\n+\t\tif (ndo->ndo_vflag > 2) {\n+\t\t\tND_PRINT((ndo, \"" \""));\n+\t\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n+\t\t\t\tgoto trunc;\n+\t\t} else if (ndo->ndo_vflag > 1) {\n+\t\t\tND_PRINT((ndo, \"" \""));\n+\t\t\tif (!ike_show_somedata(ndo, (const u_char *)(ext + 1), ep))\n+\t\t\t\tgoto trunc;\n+\t\t}\n \t}\n \treturn (const u_char *)ext + ntohs(e.len);\n trunc:\n@@ -1609,8 +1614,8 @@ ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n static const u_char *\n ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n \t      const struct isakmp_gen *ext, u_int item_len,\n-\t      const u_char *ep, uint32_t phase, uint32_t doi0 _U_,\n-\t      uint32_t proto0 _U_, int depth)\n+\t      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,\n+\t      uint32_t proto0 _U_, int depth _U_)\n {\n \tconst struct ikev1_pl_n *p;\n \tstruct ikev1_pl_n n;\n@@ -1712,35 +1717,41 @@ ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n \tep2 = (const u_char *)p + item_len;\n \n \tif (cp < ep) {\n-\t\tND_PRINT((ndo,\"" orig=(\""));\n \t\tswitch (ntohs(n.type)) {\n \t\tcase IPSECDOI_NTYPE_RESPONDER_LIFETIME:\n \t\t    {\n \t\t\tconst struct attrmap *map = oakley_t_map;\n \t\t\tsize_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);\n+\t\t\tND_PRINT((ndo,\"" attrs=(\""));\n \t\t\twhile (cp < ep && cp < ep2) {\n \t\t\t\tcp = ikev1_attrmap_print(ndo, cp,\n \t\t\t\t\t(ep < ep2) ? ep : ep2, map, nmap);\n \t\t\t}\n+\t\t\tND_PRINT((ndo,\"")\""));\n \t\t\tbreak;\n \t\t    }\n \t\tcase IPSECDOI_NTYPE_REPLAY_STATUS:\n+\t\t\tND_PRINT((ndo,\"" status=(\""));\n \t\t\tND_PRINT((ndo,\""replay detection %sabled\"",\n \t\t\t\t  EXTRACT_32BITS(cp) ? \""en\"" : \""dis\""));\n-\t\t\tbreak;\n-\t\tcase ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN:\n-\t\t\tif (ikev1_sub_print(ndo, ISAKMP_NPTYPE_SA,\n-\t\t\t\t\t    (const struct isakmp_gen *)cp, ep, phase, doi, proto,\n-\t\t\t\t\t    depth) == NULL)\n-\t\t\t\treturn NULL;\n+\t\t\tND_PRINT((ndo,\"")\""));\n \t\t\tbreak;\n \t\tdefault:\n-\t\t\t/* NULL is dummy */\n-\t\t\tisakmp_print(ndo, cp,\n-\t\t\t\t     item_len - sizeof(*p) - n.spi_size,\n-\t\t\t\t     NULL);\n+\t\t\t/*\n+\t\t\t * XXX - fill in more types here; see, for example,\n+\t\t\t * draft-ietf-ipsec-notifymsg-04.\n+\t\t\t */\n+\t\t\tif (ndo->ndo_vflag > 3) {\n+\t\t\t\tND_PRINT((ndo,\"" data=(\""));\n+\t\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n+\t\t\t\t\tgoto trunc;\n+\t\t\t\tND_PRINT((ndo,\"")\""));\n+\t\t\t} else {\n+\t\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n+\t\t\t\t\tgoto trunc;\n+\t\t\t}\n+\t\t\tbreak;\n \t\t}\n-\t\tND_PRINT((ndo,\"")\""));\n \t}\n \treturn (const u_char *)ext + item_len;\n trunc:\n@@ -2264,16 +2275,21 @@ ikev2_auth_print(netdissect_options *ndo, u_char tpay,\n \tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n \tlen = ntohs(a.h.len);\n \n-\tND_PRINT((ndo,\"" len=%d method=%s\"", len-4,\n+\t/*\n+\t * Our caller has ensured that the length is >= 4.\n+\t */\n+\tND_PRINT((ndo,\"" len=%u method=%s\"", len-4,\n \t\t  STR_OR_ID(a.auth_method, v2_auth)));\n-\n-\tif (1 < ndo->ndo_vflag && 4 < len) {\n-\t\tND_PRINT((ndo,\"" authdata=(\""));\n-\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n-\t\t\tgoto trunc;\n-\t\tND_PRINT((ndo,\"") \""));\n-\t} else if(ndo->ndo_vflag && 4 < len) {\n-\t\tif(!ike_show_somedata(ndo, authdata, ep)) goto trunc;\n+\tif (len > 4) {\n+\t\tif (ndo->ndo_vflag > 1) {\n+\t\t\tND_PRINT((ndo, \"" authdata=(\""));\n+\t\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n+\t\t\t\tgoto trunc;\n+\t\t\tND_PRINT((ndo, \"") \""));\n+\t\t} else if (ndo->ndo_vflag) {\n+\t\t\tif (!ike_show_somedata(ndo, authdata, ep))\n+\t\t\t\tgoto trunc;\n+\t\t}\n \t}\n \n \treturn (const u_char *)ext + len;\n@@ -2322,7 +2338,7 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n \tconst struct ikev2_n *p;\n \tstruct ikev2_n n;\n \tconst u_char *cp;\n-\tu_char showspi, showdata, showsomedata;\n+\tu_char showspi, showsomedata;\n \tconst char *notify_name;\n \tuint32_t type;\n \n@@ -2332,7 +2348,6 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n \tikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_N), n.h.critical);\n \n \tshowspi = 1;\n-\tshowdata = 0;\n \tshowsomedata=0;\n \tnotify_name=NULL;\n \n@@ -2446,7 +2461,6 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n \t\tnotify_name = \""cookie\"";\n \t\tshowspi = 1;\n \t\tshowsomedata= 1;\n-\t\tshowdata= 0;\n \t\tbreak;\n \n \tcase IV2_NOTIFY_USE_TRANSPORT_MODE:\n@@ -2499,19 +2513,17 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n \n \tcp = (const u_char *)(p + 1) + n.spi_size;\n \n-\tif(3 < ndo->ndo_vflag) {\n-\t\tshowdata = 1;\n-\t}\n-\n-\tif ((showdata || (showsomedata && ep-cp < 30)) && cp < ep) {\n-\t\tND_PRINT((ndo,\"" data=(\""));\n-\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n-\t\t\tgoto trunc;\n-\n-\t\tND_PRINT((ndo,\"")\""));\n+\tif (cp < ep) {\n+\t\tif (ndo->ndo_vflag > 3 || (showsomedata && ep-cp < 30)) {\n+\t\t\tND_PRINT((ndo,\"" data=(\""));\n+\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n+\t\t\t\tgoto trunc;\n \n-\t} else if(showsomedata && cp < ep) {\n-\t\tif(!ike_show_somedata(ndo, cp, ep)) goto trunc;\n+\t\t\tND_PRINT((ndo,\"")\""));\n+\t\t} else if (showsomedata) {\n+\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n+\t\t\t\tgoto trunc;\n+\t\t}\n \t}\n \n \treturn (const u_char *)ext + item_len;\n@@ -3091,7 +3103,3 @@ isakmp_rfc3948_print(netdissect_options *ndo,\n  * c-basic-offset: 8\n  * End:\n  */\n-\n-\n-\n-""}<_**next**_>{""sha"": ""ed5b82aa348d9366ad7745abec943618d413f14a"", ""filename"": ""tests/TESTLIST"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/c2ef693866beae071a24b45c49f9674af1df4028/tests/TESTLIST"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/c2ef693866beae071a24b45c49f9674af1df4028/tests/TESTLIST"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/TESTLIST?ref=c2ef693866beae071a24b45c49f9674af1df4028"", ""patch"": ""@@ -465,6 +465,7 @@ tok2str-oobr-2\t\ttok2str-oobr-2.pcap\t\ttok2str-oobr-2.out\t-vvv -e\n eigrp-tlv-oobr\t\teigrp-tlv-oobr.pcap\t\teigrp-tlv-oobr.out\t-vvv -e\n zephyr-oobr\t\tzephyr-oobr.pcap\t\tzephyr-oobr.out\t\t-vvv -e\n bgp-as-path-oobr\tbgp-as-path-oobr.pcap\t\tbgp-as-path-oobr.out\t-vvv -e\n+isakmp-no-none-np\tisakmp-no-none-np.pcap\t\tisakmp-no-none-np.out\t-vvv -e\n \n # RTP tests\n # fuzzed pcap""}<_**next**_>{""sha"": ""eb91c804a87aaa6ec37215ca06a6bf17593d861b"", ""filename"": ""tests/isakmp-no-none-np.out"", ""status"": ""added"", ""additions"": 78, ""deletions"": 0, ""changes"": 78, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/c2ef693866beae071a24b45c49f9674af1df4028/tests/isakmp-no-none-np.out"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/c2ef693866beae071a24b45c49f9674af1df4028/tests/isakmp-no-none-np.out"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/isakmp-no-none-np.out?ref=c2ef693866beae071a24b45c49f9674af1df4028"", ""patch"": ""@@ -0,0 +1,78 @@\n+00:0c:29:86:c8:36 > 00:1a:4b:6a:ce:fe, ethertype IPv4 (0x0800), length 2228: (tos 0x0, ttl 128, id 28793, offset 0, flags [none], proto UDP (17), length 2214)\n+    192.168.1.25.500 > 192.168.1.10.500: [udp sum ok] isakmp 1.0 msgid 5f724dc6 cookie 0000000000000000->0000000000000000: phase 2/others ? inf:\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=0000000000000000000000000010ba00 data=(00ff1d00020082001101...0100000700000000000000000000000000000000)) [|n] (len mismatch: isakmp 84/ip 2186)""}<_**next**_>{""sha"": ""fd388d617e4f2937fdb1214bdcce59c8c159a90c"", ""filename"": ""tests/isakmp-no-none-np.pcap"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/c2ef693866beae071a24b45c49f9674af1df4028/tests/isakmp-no-none-np.pcap"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/c2ef693866beae071a24b45c49f9674af1df4028/tests/isakmp-no-none-np.pcap"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/isakmp-no-none-np.pcap?ref=c2ef693866beae071a24b45c49f9674af1df4028""}","ikev2_auth_print(netdissect_options *ndo, u_char tpay,
		const struct isakmp_gen *ext,
		u_int item_len _U_, const u_char *ep,
		uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, int depth _U_)
{
	struct ikev2_auth a;
	const char *v2_auth[]={ ""invalid"", ""rsasig"",
				""shared-secret"", ""dsssig"" };
	const u_char *authdata = (const u_char*)ext + sizeof(a);
	unsigned int len;

	ND_TCHECK(*ext);
	UNALIGNED_MEMCPY(&a, ext, sizeof(a));
 	ikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);
 	len = ntohs(a.h.len);
 
	/*
	 * Our caller has ensured that the length is >= 4.
	 */
	ND_PRINT((ndo,"" len=%u method=%s"", len-4,
 		  STR_OR_ID(a.auth_method, v2_auth)));
	if (len > 4) {
		if (ndo->ndo_vflag > 1) {
			ND_PRINT((ndo, "" authdata=(""));
			if (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))
				goto trunc;
			ND_PRINT((ndo, "") ""));
		} else if (ndo->ndo_vflag) {
			if (!ike_show_somedata(ndo, authdata, ep))
				goto trunc;
		}
 	}
 
 	return (const u_char *)ext + len;
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(tpay)));
	return NULL;
}
","ikev2_auth_print(netdissect_options *ndo, u_char tpay,
		const struct isakmp_gen *ext,
		u_int item_len _U_, const u_char *ep,
		uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, int depth _U_)
{
	struct ikev2_auth a;
	const char *v2_auth[]={ ""invalid"", ""rsasig"",
				""shared-secret"", ""dsssig"" };
	const u_char *authdata = (const u_char*)ext + sizeof(a);
	unsigned int len;

	ND_TCHECK(*ext);
	UNALIGNED_MEMCPY(&a, ext, sizeof(a));
 	ikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);
 	len = ntohs(a.h.len);
 
	ND_PRINT((ndo,"" len=%d method=%s"", len-4,
 		  STR_OR_ID(a.auth_method, v2_auth)));
	if (1 < ndo->ndo_vflag && 4 < len) {
		ND_PRINT((ndo,"" authdata=(""));
		if (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))
			goto trunc;
		ND_PRINT((ndo,"") ""));
	} else if(ndo->ndo_vflag && 4 < len) {
		if(!ike_show_somedata(ndo, authdata, ep)) goto trunc;
 	}
 
 	return (const u_char *)ext + len;
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(tpay)));
	return NULL;
}
",C,"	/*
	 * Our caller has ensured that the length is >= 4.
	 */
	ND_PRINT((ndo,"" len=%u method=%s"", len-4,
	if (len > 4) {
		if (ndo->ndo_vflag > 1) {
			ND_PRINT((ndo, "" authdata=(""));
			if (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))
				goto trunc;
			ND_PRINT((ndo, "") ""));
		} else if (ndo->ndo_vflag) {
			if (!ike_show_somedata(ndo, authdata, ep))
				goto trunc;
		}
","	ND_PRINT((ndo,"" len=%d method=%s"", len-4,
	if (1 < ndo->ndo_vflag && 4 < len) {
		ND_PRINT((ndo,"" authdata=(""));
		if (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))
			goto trunc;
		ND_PRINT((ndo,"") ""));
	} else if(ndo->ndo_vflag && 4 < len) {
		if(!ike_show_somedata(ndo, authdata, ep)) goto trunc;
",,"@@ -428,7 +428,7 @@ struct notify_messages {
 	char     *msg;
 };
 
-/* 3.8 Notification Payload */
+/* 3.8 Authentication Payload */
 struct ikev2_auth {
 	struct isakmp_gen h;
 	uint8_t  auth_method;  /* Protocol-ID */
@@ -1590,15 +1590,20 @@ ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,
 
 	ND_TCHECK(*ext);
 	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
-	ND_PRINT((ndo,"" n len=%d"", ntohs(e.len) - 4));
-	if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
-		ND_PRINT((ndo,"" ""));
-		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
-			goto trunc;
-	} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
-		ND_PRINT((ndo,"" ""));
-		if (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))
-			goto trunc;
+	/*
+	 * Our caller has ensured that the length is >= 4.
+	 */
+	ND_PRINT((ndo,"" n len=%u"", ntohs(e.len) - 4));
+	if (ntohs(e.len) > 4) {
+		if (ndo->ndo_vflag > 2) {
+			ND_PRINT((ndo, "" ""));
+			if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
+				goto trunc;
+		} else if (ndo->ndo_vflag > 1) {
+			ND_PRINT((ndo, "" ""));
+			if (!ike_show_somedata(ndo, (const u_char *)(ext + 1), ep))
+				goto trunc;
+		}
 	}
 	return (const u_char *)ext + ntohs(e.len);
 trunc:
@@ -1609,8 +1614,8 @@ ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,
 static const u_char *
 ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,
 	      const struct isakmp_gen *ext, u_int item_len,
-	      const u_char *ep, uint32_t phase, uint32_t doi0 _U_,
-	      uint32_t proto0 _U_, int depth)
+	      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,
+	      uint32_t proto0 _U_, int depth _U_)
 {
 	const struct ikev1_pl_n *p;
 	struct ikev1_pl_n n;
@@ -1712,35 +1717,41 @@ ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,
 	ep2 = (const u_char *)p + item_len;
 
 	if (cp < ep) {
-		ND_PRINT((ndo,"" orig=(""));
 		switch (ntohs(n.type)) {
 		case IPSECDOI_NTYPE_RESPONDER_LIFETIME:
 		    {
 			const struct attrmap *map = oakley_t_map;
 			size_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);
+			ND_PRINT((ndo,"" attrs=(""));
 			while (cp < ep && cp < ep2) {
 				cp = ikev1_attrmap_print(ndo, cp,
 					(ep < ep2) ? ep : ep2, map, nmap);
 			}
+			ND_PRINT((ndo,"")""));
 			break;
 		    }
 		case IPSECDOI_NTYPE_REPLAY_STATUS:
+			ND_PRINT((ndo,"" status=(""));
 			ND_PRINT((ndo,""replay detection %sabled"",
 				  EXTRACT_32BITS(cp) ? ""en"" : ""dis""));
-			break;
-		case ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN:
-			if (ikev1_sub_print(ndo, ISAKMP_NPTYPE_SA,
-					    (const struct isakmp_gen *)cp, ep, phase, doi, proto,
-					    depth) == NULL)
-				return NULL;
+			ND_PRINT((ndo,"")""));
 			break;
 		default:
-			/* NULL is dummy */
-			isakmp_print(ndo, cp,
-				     item_len - sizeof(*p) - n.spi_size,
-				     NULL);
+			/*
+			 * XXX - fill in more types here; see, for example,
+			 * draft-ietf-ipsec-notifymsg-04.
+			 */
+			if (ndo->ndo_vflag > 3) {
+				ND_PRINT((ndo,"" data=(""));
+				if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
+					goto trunc;
+				ND_PRINT((ndo,"")""));
+			} else {
+				if (!ike_show_somedata(ndo, cp, ep))
+					goto trunc;
+			}
+			break;
 		}
-		ND_PRINT((ndo,"")""));
 	}
 	return (const u_char *)ext + item_len;
 trunc:
@@ -2264,16 +2275,21 @@ ikev2_auth_print(netdissect_options *ndo, u_char tpay,
 	ikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);
 	len = ntohs(a.h.len);
 
-	ND_PRINT((ndo,"" len=%d method=%s"", len-4,
+	/*
+	 * Our caller has ensured that the length is >= 4.
+	 */
+	ND_PRINT((ndo,"" len=%u method=%s"", len-4,
 		  STR_OR_ID(a.auth_method, v2_auth)));
-
-	if (1 < ndo->ndo_vflag && 4 < len) {
-		ND_PRINT((ndo,"" authdata=(""));
-		if (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))
-			goto trunc;
-		ND_PRINT((ndo,"") ""));
-	} else if(ndo->ndo_vflag && 4 < len) {
-		if(!ike_show_somedata(ndo, authdata, ep)) goto trunc;
+	if (len > 4) {
+		if (ndo->ndo_vflag > 1) {
+			ND_PRINT((ndo, "" authdata=(""));
+			if (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))
+				goto trunc;
+			ND_PRINT((ndo, "") ""));
+		} else if (ndo->ndo_vflag) {
+			if (!ike_show_somedata(ndo, authdata, ep))
+				goto trunc;
+		}
 	}
 
 	return (const u_char *)ext + len;
@@ -2322,7 +2338,7 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
 	const struct ikev2_n *p;
 	struct ikev2_n n;
 	const u_char *cp;
-	u_char showspi, showdata, showsomedata;
+	u_char showspi, showsomedata;
 	const char *notify_name;
 	uint32_t type;
 
@@ -2332,7 +2348,6 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
 	ikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_N), n.h.critical);
 
 	showspi = 1;
-	showdata = 0;
 	showsomedata=0;
 	notify_name=NULL;
 
@@ -2446,7 +2461,6 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
 		notify_name = ""cookie"";
 		showspi = 1;
 		showsomedata= 1;
-		showdata= 0;
 		break;
 
 	case IV2_NOTIFY_USE_TRANSPORT_MODE:
@@ -2499,19 +2513,17 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
 
 	cp = (const u_char *)(p + 1) + n.spi_size;
 
-	if(3 < ndo->ndo_vflag) {
-		showdata = 1;
-	}
-
-	if ((showdata || (showsomedata && ep-cp < 30)) && cp < ep) {
-		ND_PRINT((ndo,"" data=(""));
-		if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
-			goto trunc;
-
-		ND_PRINT((ndo,"")""));
+	if (cp < ep) {
+		if (ndo->ndo_vflag > 3 || (showsomedata && ep-cp < 30)) {
+			ND_PRINT((ndo,"" data=(""));
+			if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
+				goto trunc;
 
-	} else if(showsomedata && cp < ep) {
-		if(!ike_show_somedata(ndo, cp, ep)) goto trunc;
+			ND_PRINT((ndo,"")""));
+		} else if (showsomedata) {
+			if (!ike_show_somedata(ndo, cp, ep))
+				goto trunc;
+		}
 	}
 
 	return (const u_char *)ext + item_len;
@@ -3091,7 +3103,3 @@ isakmp_rfc3948_print(netdissect_options *ndo,
  * c-basic-offset: 8
  * End:
  */
-
-
-
-",tcpdump,c2ef693866beae071a24b45c49f9674af1df4028,50a44b6b8e4f7c127440dbd4239cf571945cc1e7,1,"ikev2_auth_print(netdissect_options *ndo, u_char tpay,
		const struct isakmp_gen *ext,
		u_int item_len _U_, const u_char *ep,
		uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, int depth _U_)
{
	struct ikev2_auth a;
	const char *v2_auth[]={ ""invalid"", ""rsasig"",
				""shared-secret"", ""dsssig"" };
	const u_char *authdata = (const u_char*)ext + sizeof(a);
	unsigned int len;

	ND_TCHECK(*ext);
	UNALIGNED_MEMCPY(&a, ext, sizeof(a));
 	ikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);
 	len = ntohs(a.h.len);
 
//flaw_line_below:
	ND_PRINT((ndo,"" len=%d method=%s"", len-4,
//fix_flaw_line_below:
//	/*
//fix_flaw_line_below:
//	 * Our caller has ensured that the length is >= 4.
//fix_flaw_line_below:
//	 */
//fix_flaw_line_below:
//	ND_PRINT((ndo,"" len=%u method=%s"", len-4,
 		  STR_OR_ID(a.auth_method, v2_auth)));
//flaw_line_below:

//flaw_line_below:
	if (1 < ndo->ndo_vflag && 4 < len) {
//flaw_line_below:
		ND_PRINT((ndo,"" authdata=(""));
//flaw_line_below:
		if (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))
//flaw_line_below:
			goto trunc;
//flaw_line_below:
		ND_PRINT((ndo,"") ""));
//flaw_line_below:
	} else if(ndo->ndo_vflag && 4 < len) {
//flaw_line_below:
		if(!ike_show_somedata(ndo, authdata, ep)) goto trunc;
//fix_flaw_line_below:
//	if (len > 4) {
//fix_flaw_line_below:
//		if (ndo->ndo_vflag > 1) {
//fix_flaw_line_below:
//			ND_PRINT((ndo, "" authdata=(""));
//fix_flaw_line_below:
//			if (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))
//fix_flaw_line_below:
//				goto trunc;
//fix_flaw_line_below:
//			ND_PRINT((ndo, "") ""));
//fix_flaw_line_below:
//		} else if (ndo->ndo_vflag) {
//fix_flaw_line_below:
//			if (!ike_show_somedata(ndo, authdata, ep))
//fix_flaw_line_below:
//				goto trunc;
//fix_flaw_line_below:
//		}
 	}
 
 	return (const u_char *)ext + len;
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(tpay)));
	return NULL;
}
"
3363,181099,,Remote,Not required,Partial,CVE-2017-12990,https://www.cvedetails.com/cve/CVE-2017-12990/,CWE-835,Low,,,,2017-09-14,5.0,"The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.",2019-10-02,,11,https://github.com/the-tcpdump-group/tcpdump/commit/c2ef693866beae071a24b45c49f9674af1df4028,c2ef693866beae071a24b45c49f9674af1df4028,"CVE-2017-12990/Fix printing of ISAKMPv1 Notification payload data.

The closest thing to a specification for the contents of the payload
data is draft-ietf-ipsec-notifymsg-04, and nothing in there says that it
is ever a complete ISAKMP message, so don't dissect types we don't have
specific code for as a complete ISAKMP message.

While we're at it, fix a comment, and clean up printing of V1 Nonce,
V2 Authentication payloads, and v2 Notice payloads.

This fixes an infinite loop discovered by Forcepoint's security
researchers Otto Airamo & Antti Levomki.

Add a test using the capture file supplied by the reporter(s).",13,print-isakmp.c,"{""sha"": ""9de9b75d21e74156a74f0708a5b2fa636861b803"", ""filename"": ""print-isakmp.c"", ""status"": ""modified"", ""additions"": 60, ""deletions"": 52, ""changes"": 112, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/c2ef693866beae071a24b45c49f9674af1df4028/print-isakmp.c"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/c2ef693866beae071a24b45c49f9674af1df4028/print-isakmp.c"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/print-isakmp.c?ref=c2ef693866beae071a24b45c49f9674af1df4028"", ""patch"": ""@@ -428,7 +428,7 @@ struct notify_messages {\n \tchar     *msg;\n };\n \n-/* 3.8 Notification Payload */\n+/* 3.8 Authentication Payload */\n struct ikev2_auth {\n \tstruct isakmp_gen h;\n \tuint8_t  auth_method;  /* Protocol-ID */\n@@ -1590,15 +1590,20 @@ ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n \n \tND_TCHECK(*ext);\n \tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n-\tND_PRINT((ndo,\"" n len=%d\"", ntohs(e.len) - 4));\n-\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n-\t\tND_PRINT((ndo,\"" \""));\n-\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n-\t\t\tgoto trunc;\n-\t} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n-\t\tND_PRINT((ndo,\"" \""));\n-\t\tif (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))\n-\t\t\tgoto trunc;\n+\t/*\n+\t * Our caller has ensured that the length is >= 4.\n+\t */\n+\tND_PRINT((ndo,\"" n len=%u\"", ntohs(e.len) - 4));\n+\tif (ntohs(e.len) > 4) {\n+\t\tif (ndo->ndo_vflag > 2) {\n+\t\t\tND_PRINT((ndo, \"" \""));\n+\t\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n+\t\t\t\tgoto trunc;\n+\t\t} else if (ndo->ndo_vflag > 1) {\n+\t\t\tND_PRINT((ndo, \"" \""));\n+\t\t\tif (!ike_show_somedata(ndo, (const u_char *)(ext + 1), ep))\n+\t\t\t\tgoto trunc;\n+\t\t}\n \t}\n \treturn (const u_char *)ext + ntohs(e.len);\n trunc:\n@@ -1609,8 +1614,8 @@ ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n static const u_char *\n ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n \t      const struct isakmp_gen *ext, u_int item_len,\n-\t      const u_char *ep, uint32_t phase, uint32_t doi0 _U_,\n-\t      uint32_t proto0 _U_, int depth)\n+\t      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,\n+\t      uint32_t proto0 _U_, int depth _U_)\n {\n \tconst struct ikev1_pl_n *p;\n \tstruct ikev1_pl_n n;\n@@ -1712,35 +1717,41 @@ ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n \tep2 = (const u_char *)p + item_len;\n \n \tif (cp < ep) {\n-\t\tND_PRINT((ndo,\"" orig=(\""));\n \t\tswitch (ntohs(n.type)) {\n \t\tcase IPSECDOI_NTYPE_RESPONDER_LIFETIME:\n \t\t    {\n \t\t\tconst struct attrmap *map = oakley_t_map;\n \t\t\tsize_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);\n+\t\t\tND_PRINT((ndo,\"" attrs=(\""));\n \t\t\twhile (cp < ep && cp < ep2) {\n \t\t\t\tcp = ikev1_attrmap_print(ndo, cp,\n \t\t\t\t\t(ep < ep2) ? ep : ep2, map, nmap);\n \t\t\t}\n+\t\t\tND_PRINT((ndo,\"")\""));\n \t\t\tbreak;\n \t\t    }\n \t\tcase IPSECDOI_NTYPE_REPLAY_STATUS:\n+\t\t\tND_PRINT((ndo,\"" status=(\""));\n \t\t\tND_PRINT((ndo,\""replay detection %sabled\"",\n \t\t\t\t  EXTRACT_32BITS(cp) ? \""en\"" : \""dis\""));\n-\t\t\tbreak;\n-\t\tcase ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN:\n-\t\t\tif (ikev1_sub_print(ndo, ISAKMP_NPTYPE_SA,\n-\t\t\t\t\t    (const struct isakmp_gen *)cp, ep, phase, doi, proto,\n-\t\t\t\t\t    depth) == NULL)\n-\t\t\t\treturn NULL;\n+\t\t\tND_PRINT((ndo,\"")\""));\n \t\t\tbreak;\n \t\tdefault:\n-\t\t\t/* NULL is dummy */\n-\t\t\tisakmp_print(ndo, cp,\n-\t\t\t\t     item_len - sizeof(*p) - n.spi_size,\n-\t\t\t\t     NULL);\n+\t\t\t/*\n+\t\t\t * XXX - fill in more types here; see, for example,\n+\t\t\t * draft-ietf-ipsec-notifymsg-04.\n+\t\t\t */\n+\t\t\tif (ndo->ndo_vflag > 3) {\n+\t\t\t\tND_PRINT((ndo,\"" data=(\""));\n+\t\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n+\t\t\t\t\tgoto trunc;\n+\t\t\t\tND_PRINT((ndo,\"")\""));\n+\t\t\t} else {\n+\t\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n+\t\t\t\t\tgoto trunc;\n+\t\t\t}\n+\t\t\tbreak;\n \t\t}\n-\t\tND_PRINT((ndo,\"")\""));\n \t}\n \treturn (const u_char *)ext + item_len;\n trunc:\n@@ -2264,16 +2275,21 @@ ikev2_auth_print(netdissect_options *ndo, u_char tpay,\n \tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n \tlen = ntohs(a.h.len);\n \n-\tND_PRINT((ndo,\"" len=%d method=%s\"", len-4,\n+\t/*\n+\t * Our caller has ensured that the length is >= 4.\n+\t */\n+\tND_PRINT((ndo,\"" len=%u method=%s\"", len-4,\n \t\t  STR_OR_ID(a.auth_method, v2_auth)));\n-\n-\tif (1 < ndo->ndo_vflag && 4 < len) {\n-\t\tND_PRINT((ndo,\"" authdata=(\""));\n-\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n-\t\t\tgoto trunc;\n-\t\tND_PRINT((ndo,\"") \""));\n-\t} else if(ndo->ndo_vflag && 4 < len) {\n-\t\tif(!ike_show_somedata(ndo, authdata, ep)) goto trunc;\n+\tif (len > 4) {\n+\t\tif (ndo->ndo_vflag > 1) {\n+\t\t\tND_PRINT((ndo, \"" authdata=(\""));\n+\t\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n+\t\t\t\tgoto trunc;\n+\t\t\tND_PRINT((ndo, \"") \""));\n+\t\t} else if (ndo->ndo_vflag) {\n+\t\t\tif (!ike_show_somedata(ndo, authdata, ep))\n+\t\t\t\tgoto trunc;\n+\t\t}\n \t}\n \n \treturn (const u_char *)ext + len;\n@@ -2322,7 +2338,7 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n \tconst struct ikev2_n *p;\n \tstruct ikev2_n n;\n \tconst u_char *cp;\n-\tu_char showspi, showdata, showsomedata;\n+\tu_char showspi, showsomedata;\n \tconst char *notify_name;\n \tuint32_t type;\n \n@@ -2332,7 +2348,6 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n \tikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_N), n.h.critical);\n \n \tshowspi = 1;\n-\tshowdata = 0;\n \tshowsomedata=0;\n \tnotify_name=NULL;\n \n@@ -2446,7 +2461,6 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n \t\tnotify_name = \""cookie\"";\n \t\tshowspi = 1;\n \t\tshowsomedata= 1;\n-\t\tshowdata= 0;\n \t\tbreak;\n \n \tcase IV2_NOTIFY_USE_TRANSPORT_MODE:\n@@ -2499,19 +2513,17 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n \n \tcp = (const u_char *)(p + 1) + n.spi_size;\n \n-\tif(3 < ndo->ndo_vflag) {\n-\t\tshowdata = 1;\n-\t}\n-\n-\tif ((showdata || (showsomedata && ep-cp < 30)) && cp < ep) {\n-\t\tND_PRINT((ndo,\"" data=(\""));\n-\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n-\t\t\tgoto trunc;\n-\n-\t\tND_PRINT((ndo,\"")\""));\n+\tif (cp < ep) {\n+\t\tif (ndo->ndo_vflag > 3 || (showsomedata && ep-cp < 30)) {\n+\t\t\tND_PRINT((ndo,\"" data=(\""));\n+\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n+\t\t\t\tgoto trunc;\n \n-\t} else if(showsomedata && cp < ep) {\n-\t\tif(!ike_show_somedata(ndo, cp, ep)) goto trunc;\n+\t\t\tND_PRINT((ndo,\"")\""));\n+\t\t} else if (showsomedata) {\n+\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n+\t\t\t\tgoto trunc;\n+\t\t}\n \t}\n \n \treturn (const u_char *)ext + item_len;\n@@ -3091,7 +3103,3 @@ isakmp_rfc3948_print(netdissect_options *ndo,\n  * c-basic-offset: 8\n  * End:\n  */\n-\n-\n-\n-""}<_**next**_>{""sha"": ""ed5b82aa348d9366ad7745abec943618d413f14a"", ""filename"": ""tests/TESTLIST"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/c2ef693866beae071a24b45c49f9674af1df4028/tests/TESTLIST"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/c2ef693866beae071a24b45c49f9674af1df4028/tests/TESTLIST"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/TESTLIST?ref=c2ef693866beae071a24b45c49f9674af1df4028"", ""patch"": ""@@ -465,6 +465,7 @@ tok2str-oobr-2\t\ttok2str-oobr-2.pcap\t\ttok2str-oobr-2.out\t-vvv -e\n eigrp-tlv-oobr\t\teigrp-tlv-oobr.pcap\t\teigrp-tlv-oobr.out\t-vvv -e\n zephyr-oobr\t\tzephyr-oobr.pcap\t\tzephyr-oobr.out\t\t-vvv -e\n bgp-as-path-oobr\tbgp-as-path-oobr.pcap\t\tbgp-as-path-oobr.out\t-vvv -e\n+isakmp-no-none-np\tisakmp-no-none-np.pcap\t\tisakmp-no-none-np.out\t-vvv -e\n \n # RTP tests\n # fuzzed pcap""}<_**next**_>{""sha"": ""eb91c804a87aaa6ec37215ca06a6bf17593d861b"", ""filename"": ""tests/isakmp-no-none-np.out"", ""status"": ""added"", ""additions"": 78, ""deletions"": 0, ""changes"": 78, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/c2ef693866beae071a24b45c49f9674af1df4028/tests/isakmp-no-none-np.out"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/c2ef693866beae071a24b45c49f9674af1df4028/tests/isakmp-no-none-np.out"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/isakmp-no-none-np.out?ref=c2ef693866beae071a24b45c49f9674af1df4028"", ""patch"": ""@@ -0,0 +1,78 @@\n+00:0c:29:86:c8:36 > 00:1a:4b:6a:ce:fe, ethertype IPv4 (0x0800), length 2228: (tos 0x0, ttl 128, id 28793, offset 0, flags [none], proto UDP (17), length 2214)\n+    192.168.1.25.500 > 192.168.1.10.500: [udp sum ok] isakmp 1.0 msgid 5f724dc6 cookie 0000000000000000->0000000000000000: phase 2/others ? inf:\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=0000000000000000000000000010ba00 data=(00ff1d00020082001101...0100000700000000000000000000000000000000)) [|n] (len mismatch: isakmp 84/ip 2186)""}<_**next**_>{""sha"": ""fd388d617e4f2937fdb1214bdcce59c8c159a90c"", ""filename"": ""tests/isakmp-no-none-np.pcap"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/c2ef693866beae071a24b45c49f9674af1df4028/tests/isakmp-no-none-np.pcap"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/c2ef693866beae071a24b45c49f9674af1df4028/tests/isakmp-no-none-np.pcap"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/isakmp-no-none-np.pcap?ref=c2ef693866beae071a24b45c49f9674af1df4028""}","ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
		const struct isakmp_gen *ext,
		u_int item_len, const u_char *ep,
		uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, int depth _U_)
{
 	const struct ikev2_n *p;
 	struct ikev2_n n;
 	const u_char *cp;
	u_char showspi, showsomedata;
 	const char *notify_name;
 	uint32_t type;
 
	p = (const struct ikev2_n *)ext;
	ND_TCHECK(*p);
	UNALIGNED_MEMCPY(&n, ext, sizeof(n));
 	ikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_N), n.h.critical);
 
 	showspi = 1;
 	showsomedata=0;
 	notify_name=NULL;
 
	ND_PRINT((ndo,"" prot_id=%s"", PROTOIDSTR(n.prot_id)));

	type = ntohs(n.type);

	/* notify space is annoying sparse */
	switch(type) {
	case IV2_NOTIFY_UNSUPPORTED_CRITICAL_PAYLOAD:
		notify_name = ""unsupported_critical_payload"";
		showspi = 0;
		break;

	case IV2_NOTIFY_INVALID_IKE_SPI:
		notify_name = ""invalid_ike_spi"";
		showspi = 1;
		break;

	case IV2_NOTIFY_INVALID_MAJOR_VERSION:
		notify_name = ""invalid_major_version"";
		showspi = 0;
		break;

	case IV2_NOTIFY_INVALID_SYNTAX:
		notify_name = ""invalid_syntax"";
		showspi = 1;
		break;

	case IV2_NOTIFY_INVALID_MESSAGE_ID:
		notify_name = ""invalid_message_id"";
		showspi = 1;
		break;

	case IV2_NOTIFY_INVALID_SPI:
		notify_name = ""invalid_spi"";
		showspi = 1;
		break;

	case IV2_NOTIFY_NO_PROPOSAL_CHOSEN:
		notify_name = ""no_protocol_chosen"";
		showspi = 1;
		break;

	case IV2_NOTIFY_INVALID_KE_PAYLOAD:
		notify_name = ""invalid_ke_payload"";
		showspi = 1;
		break;

	case IV2_NOTIFY_AUTHENTICATION_FAILED:
		notify_name = ""authentication_failed"";
		showspi = 1;
		break;

	case IV2_NOTIFY_SINGLE_PAIR_REQUIRED:
		notify_name = ""single_pair_required"";
		showspi = 1;
		break;

	case IV2_NOTIFY_NO_ADDITIONAL_SAS:
		notify_name = ""no_additional_sas"";
		showspi = 0;
		break;

	case IV2_NOTIFY_INTERNAL_ADDRESS_FAILURE:
		notify_name = ""internal_address_failure"";
		showspi = 0;
		break;

	case IV2_NOTIFY_FAILED_CP_REQUIRED:
		notify_name = ""failed:cp_required"";
		showspi = 0;
		break;

	case IV2_NOTIFY_INVALID_SELECTORS:
		notify_name = ""invalid_selectors"";
		showspi = 0;
		break;

	case IV2_NOTIFY_INITIAL_CONTACT:
		notify_name = ""initial_contact"";
		showspi = 0;
		break;

	case IV2_NOTIFY_SET_WINDOW_SIZE:
		notify_name = ""set_window_size"";
		showspi = 0;
		break;

	case IV2_NOTIFY_ADDITIONAL_TS_POSSIBLE:
		notify_name = ""additional_ts_possible"";
		showspi = 0;
		break;

	case IV2_NOTIFY_IPCOMP_SUPPORTED:
		notify_name = ""ipcomp_supported"";
		showspi = 0;
		break;

	case IV2_NOTIFY_NAT_DETECTION_SOURCE_IP:
		notify_name = ""nat_detection_source_ip"";
		showspi = 1;
		break;

	case IV2_NOTIFY_NAT_DETECTION_DESTINATION_IP:
		notify_name = ""nat_detection_destination_ip"";
		showspi = 1;
		break;

	case IV2_NOTIFY_COOKIE:
 		notify_name = ""cookie"";
 		showspi = 1;
 		showsomedata= 1;
 		break;
 
 	case IV2_NOTIFY_USE_TRANSPORT_MODE:
		notify_name = ""use_transport_mode"";
		showspi = 0;
		break;

	case IV2_NOTIFY_HTTP_CERT_LOOKUP_SUPPORTED:
		notify_name = ""http_cert_lookup_supported"";
		showspi = 0;
		break;

	case IV2_NOTIFY_REKEY_SA:
		notify_name = ""rekey_sa"";
		showspi = 1;
		break;

	case IV2_NOTIFY_ESP_TFC_PADDING_NOT_SUPPORTED:
		notify_name = ""tfc_padding_not_supported"";
		showspi = 0;
		break;

	case IV2_NOTIFY_NON_FIRST_FRAGMENTS_ALSO:
		notify_name = ""non_first_fragment_also"";
		showspi = 0;
		break;

	default:
		if (type < 8192) {
			notify_name=""error"";
		} else if(type < 16384) {
			notify_name=""private-error"";
		} else if(type < 40960) {
			notify_name=""status"";
		} else {
			notify_name=""private-status"";
		}
	}

	if(notify_name) {
		ND_PRINT((ndo,"" type=%u(%s)"", type, notify_name));
	}


	if (showspi && n.spi_size) {
		ND_PRINT((ndo,"" spi=""));
		if (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))
			goto trunc;
	}
 
 	cp = (const u_char *)(p + 1) + n.spi_size;
 
	if (cp < ep) {
		if (ndo->ndo_vflag > 3 || (showsomedata && ep-cp < 30)) {
			ND_PRINT((ndo,"" data=(""));
			if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
				goto trunc;
 
			ND_PRINT((ndo,"")""));
		} else if (showsomedata) {
			if (!ike_show_somedata(ndo, cp, ep))
				goto trunc;
		}
 	}
 
 	return (const u_char *)ext + item_len;
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_N)));
	return NULL;
}
","ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
		const struct isakmp_gen *ext,
		u_int item_len, const u_char *ep,
		uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, int depth _U_)
{
 	const struct ikev2_n *p;
 	struct ikev2_n n;
 	const u_char *cp;
	u_char showspi, showdata, showsomedata;
 	const char *notify_name;
 	uint32_t type;
 
	p = (const struct ikev2_n *)ext;
	ND_TCHECK(*p);
	UNALIGNED_MEMCPY(&n, ext, sizeof(n));
 	ikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_N), n.h.critical);
 
 	showspi = 1;
	showdata = 0;
 	showsomedata=0;
 	notify_name=NULL;
 
	ND_PRINT((ndo,"" prot_id=%s"", PROTOIDSTR(n.prot_id)));

	type = ntohs(n.type);

	/* notify space is annoying sparse */
	switch(type) {
	case IV2_NOTIFY_UNSUPPORTED_CRITICAL_PAYLOAD:
		notify_name = ""unsupported_critical_payload"";
		showspi = 0;
		break;

	case IV2_NOTIFY_INVALID_IKE_SPI:
		notify_name = ""invalid_ike_spi"";
		showspi = 1;
		break;

	case IV2_NOTIFY_INVALID_MAJOR_VERSION:
		notify_name = ""invalid_major_version"";
		showspi = 0;
		break;

	case IV2_NOTIFY_INVALID_SYNTAX:
		notify_name = ""invalid_syntax"";
		showspi = 1;
		break;

	case IV2_NOTIFY_INVALID_MESSAGE_ID:
		notify_name = ""invalid_message_id"";
		showspi = 1;
		break;

	case IV2_NOTIFY_INVALID_SPI:
		notify_name = ""invalid_spi"";
		showspi = 1;
		break;

	case IV2_NOTIFY_NO_PROPOSAL_CHOSEN:
		notify_name = ""no_protocol_chosen"";
		showspi = 1;
		break;

	case IV2_NOTIFY_INVALID_KE_PAYLOAD:
		notify_name = ""invalid_ke_payload"";
		showspi = 1;
		break;

	case IV2_NOTIFY_AUTHENTICATION_FAILED:
		notify_name = ""authentication_failed"";
		showspi = 1;
		break;

	case IV2_NOTIFY_SINGLE_PAIR_REQUIRED:
		notify_name = ""single_pair_required"";
		showspi = 1;
		break;

	case IV2_NOTIFY_NO_ADDITIONAL_SAS:
		notify_name = ""no_additional_sas"";
		showspi = 0;
		break;

	case IV2_NOTIFY_INTERNAL_ADDRESS_FAILURE:
		notify_name = ""internal_address_failure"";
		showspi = 0;
		break;

	case IV2_NOTIFY_FAILED_CP_REQUIRED:
		notify_name = ""failed:cp_required"";
		showspi = 0;
		break;

	case IV2_NOTIFY_INVALID_SELECTORS:
		notify_name = ""invalid_selectors"";
		showspi = 0;
		break;

	case IV2_NOTIFY_INITIAL_CONTACT:
		notify_name = ""initial_contact"";
		showspi = 0;
		break;

	case IV2_NOTIFY_SET_WINDOW_SIZE:
		notify_name = ""set_window_size"";
		showspi = 0;
		break;

	case IV2_NOTIFY_ADDITIONAL_TS_POSSIBLE:
		notify_name = ""additional_ts_possible"";
		showspi = 0;
		break;

	case IV2_NOTIFY_IPCOMP_SUPPORTED:
		notify_name = ""ipcomp_supported"";
		showspi = 0;
		break;

	case IV2_NOTIFY_NAT_DETECTION_SOURCE_IP:
		notify_name = ""nat_detection_source_ip"";
		showspi = 1;
		break;

	case IV2_NOTIFY_NAT_DETECTION_DESTINATION_IP:
		notify_name = ""nat_detection_destination_ip"";
		showspi = 1;
		break;

	case IV2_NOTIFY_COOKIE:
 		notify_name = ""cookie"";
 		showspi = 1;
 		showsomedata= 1;
		showdata= 0;
 		break;
 
 	case IV2_NOTIFY_USE_TRANSPORT_MODE:
		notify_name = ""use_transport_mode"";
		showspi = 0;
		break;

	case IV2_NOTIFY_HTTP_CERT_LOOKUP_SUPPORTED:
		notify_name = ""http_cert_lookup_supported"";
		showspi = 0;
		break;

	case IV2_NOTIFY_REKEY_SA:
		notify_name = ""rekey_sa"";
		showspi = 1;
		break;

	case IV2_NOTIFY_ESP_TFC_PADDING_NOT_SUPPORTED:
		notify_name = ""tfc_padding_not_supported"";
		showspi = 0;
		break;

	case IV2_NOTIFY_NON_FIRST_FRAGMENTS_ALSO:
		notify_name = ""non_first_fragment_also"";
		showspi = 0;
		break;

	default:
		if (type < 8192) {
			notify_name=""error"";
		} else if(type < 16384) {
			notify_name=""private-error"";
		} else if(type < 40960) {
			notify_name=""status"";
		} else {
			notify_name=""private-status"";
		}
	}

	if(notify_name) {
		ND_PRINT((ndo,"" type=%u(%s)"", type, notify_name));
	}


	if (showspi && n.spi_size) {
		ND_PRINT((ndo,"" spi=""));
		if (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))
			goto trunc;
	}
 
 	cp = (const u_char *)(p + 1) + n.spi_size;
 
	if(3 < ndo->ndo_vflag) {
		showdata = 1;
	}
	if ((showdata || (showsomedata && ep-cp < 30)) && cp < ep) {
		ND_PRINT((ndo,"" data=(""));
		if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
			goto trunc;
		ND_PRINT((ndo,"")""));
 
	} else if(showsomedata && cp < ep) {
		if(!ike_show_somedata(ndo, cp, ep)) goto trunc;
 	}
 
 	return (const u_char *)ext + item_len;
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_N)));
	return NULL;
}
",C,"	u_char showspi, showsomedata;
	if (cp < ep) {
		if (ndo->ndo_vflag > 3 || (showsomedata && ep-cp < 30)) {
			ND_PRINT((ndo,"" data=(""));
			if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
				goto trunc;
			ND_PRINT((ndo,"")""));
		} else if (showsomedata) {
			if (!ike_show_somedata(ndo, cp, ep))
				goto trunc;
		}
","	u_char showspi, showdata, showsomedata;
	showdata = 0;
		showdata= 0;
	if(3 < ndo->ndo_vflag) {
		showdata = 1;
	}
	if ((showdata || (showsomedata && ep-cp < 30)) && cp < ep) {
		ND_PRINT((ndo,"" data=(""));
		if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
			goto trunc;
		ND_PRINT((ndo,"")""));
	} else if(showsomedata && cp < ep) {
		if(!ike_show_somedata(ndo, cp, ep)) goto trunc;
",,"@@ -428,7 +428,7 @@ struct notify_messages {
 	char     *msg;
 };
 
-/* 3.8 Notification Payload */
+/* 3.8 Authentication Payload */
 struct ikev2_auth {
 	struct isakmp_gen h;
 	uint8_t  auth_method;  /* Protocol-ID */
@@ -1590,15 +1590,20 @@ ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,
 
 	ND_TCHECK(*ext);
 	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
-	ND_PRINT((ndo,"" n len=%d"", ntohs(e.len) - 4));
-	if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
-		ND_PRINT((ndo,"" ""));
-		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
-			goto trunc;
-	} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
-		ND_PRINT((ndo,"" ""));
-		if (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))
-			goto trunc;
+	/*
+	 * Our caller has ensured that the length is >= 4.
+	 */
+	ND_PRINT((ndo,"" n len=%u"", ntohs(e.len) - 4));
+	if (ntohs(e.len) > 4) {
+		if (ndo->ndo_vflag > 2) {
+			ND_PRINT((ndo, "" ""));
+			if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
+				goto trunc;
+		} else if (ndo->ndo_vflag > 1) {
+			ND_PRINT((ndo, "" ""));
+			if (!ike_show_somedata(ndo, (const u_char *)(ext + 1), ep))
+				goto trunc;
+		}
 	}
 	return (const u_char *)ext + ntohs(e.len);
 trunc:
@@ -1609,8 +1614,8 @@ ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,
 static const u_char *
 ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,
 	      const struct isakmp_gen *ext, u_int item_len,
-	      const u_char *ep, uint32_t phase, uint32_t doi0 _U_,
-	      uint32_t proto0 _U_, int depth)
+	      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,
+	      uint32_t proto0 _U_, int depth _U_)
 {
 	const struct ikev1_pl_n *p;
 	struct ikev1_pl_n n;
@@ -1712,35 +1717,41 @@ ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,
 	ep2 = (const u_char *)p + item_len;
 
 	if (cp < ep) {
-		ND_PRINT((ndo,"" orig=(""));
 		switch (ntohs(n.type)) {
 		case IPSECDOI_NTYPE_RESPONDER_LIFETIME:
 		    {
 			const struct attrmap *map = oakley_t_map;
 			size_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);
+			ND_PRINT((ndo,"" attrs=(""));
 			while (cp < ep && cp < ep2) {
 				cp = ikev1_attrmap_print(ndo, cp,
 					(ep < ep2) ? ep : ep2, map, nmap);
 			}
+			ND_PRINT((ndo,"")""));
 			break;
 		    }
 		case IPSECDOI_NTYPE_REPLAY_STATUS:
+			ND_PRINT((ndo,"" status=(""));
 			ND_PRINT((ndo,""replay detection %sabled"",
 				  EXTRACT_32BITS(cp) ? ""en"" : ""dis""));
-			break;
-		case ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN:
-			if (ikev1_sub_print(ndo, ISAKMP_NPTYPE_SA,
-					    (const struct isakmp_gen *)cp, ep, phase, doi, proto,
-					    depth) == NULL)
-				return NULL;
+			ND_PRINT((ndo,"")""));
 			break;
 		default:
-			/* NULL is dummy */
-			isakmp_print(ndo, cp,
-				     item_len - sizeof(*p) - n.spi_size,
-				     NULL);
+			/*
+			 * XXX - fill in more types here; see, for example,
+			 * draft-ietf-ipsec-notifymsg-04.
+			 */
+			if (ndo->ndo_vflag > 3) {
+				ND_PRINT((ndo,"" data=(""));
+				if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
+					goto trunc;
+				ND_PRINT((ndo,"")""));
+			} else {
+				if (!ike_show_somedata(ndo, cp, ep))
+					goto trunc;
+			}
+			break;
 		}
-		ND_PRINT((ndo,"")""));
 	}
 	return (const u_char *)ext + item_len;
 trunc:
@@ -2264,16 +2275,21 @@ ikev2_auth_print(netdissect_options *ndo, u_char tpay,
 	ikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);
 	len = ntohs(a.h.len);
 
-	ND_PRINT((ndo,"" len=%d method=%s"", len-4,
+	/*
+	 * Our caller has ensured that the length is >= 4.
+	 */
+	ND_PRINT((ndo,"" len=%u method=%s"", len-4,
 		  STR_OR_ID(a.auth_method, v2_auth)));
-
-	if (1 < ndo->ndo_vflag && 4 < len) {
-		ND_PRINT((ndo,"" authdata=(""));
-		if (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))
-			goto trunc;
-		ND_PRINT((ndo,"") ""));
-	} else if(ndo->ndo_vflag && 4 < len) {
-		if(!ike_show_somedata(ndo, authdata, ep)) goto trunc;
+	if (len > 4) {
+		if (ndo->ndo_vflag > 1) {
+			ND_PRINT((ndo, "" authdata=(""));
+			if (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))
+				goto trunc;
+			ND_PRINT((ndo, "") ""));
+		} else if (ndo->ndo_vflag) {
+			if (!ike_show_somedata(ndo, authdata, ep))
+				goto trunc;
+		}
 	}
 
 	return (const u_char *)ext + len;
@@ -2322,7 +2338,7 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
 	const struct ikev2_n *p;
 	struct ikev2_n n;
 	const u_char *cp;
-	u_char showspi, showdata, showsomedata;
+	u_char showspi, showsomedata;
 	const char *notify_name;
 	uint32_t type;
 
@@ -2332,7 +2348,6 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
 	ikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_N), n.h.critical);
 
 	showspi = 1;
-	showdata = 0;
 	showsomedata=0;
 	notify_name=NULL;
 
@@ -2446,7 +2461,6 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
 		notify_name = ""cookie"";
 		showspi = 1;
 		showsomedata= 1;
-		showdata= 0;
 		break;
 
 	case IV2_NOTIFY_USE_TRANSPORT_MODE:
@@ -2499,19 +2513,17 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
 
 	cp = (const u_char *)(p + 1) + n.spi_size;
 
-	if(3 < ndo->ndo_vflag) {
-		showdata = 1;
-	}
-
-	if ((showdata || (showsomedata && ep-cp < 30)) && cp < ep) {
-		ND_PRINT((ndo,"" data=(""));
-		if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
-			goto trunc;
-
-		ND_PRINT((ndo,"")""));
+	if (cp < ep) {
+		if (ndo->ndo_vflag > 3 || (showsomedata && ep-cp < 30)) {
+			ND_PRINT((ndo,"" data=(""));
+			if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
+				goto trunc;
 
-	} else if(showsomedata && cp < ep) {
-		if(!ike_show_somedata(ndo, cp, ep)) goto trunc;
+			ND_PRINT((ndo,"")""));
+		} else if (showsomedata) {
+			if (!ike_show_somedata(ndo, cp, ep))
+				goto trunc;
+		}
 	}
 
 	return (const u_char *)ext + item_len;
@@ -3091,7 +3103,3 @@ isakmp_rfc3948_print(netdissect_options *ndo,
  * c-basic-offset: 8
  * End:
  */
-
-
-
-",tcpdump,c2ef693866beae071a24b45c49f9674af1df4028,50a44b6b8e4f7c127440dbd4239cf571945cc1e7,1,"ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
		const struct isakmp_gen *ext,
		u_int item_len, const u_char *ep,
		uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, int depth _U_)
{
 	const struct ikev2_n *p;
 	struct ikev2_n n;
 	const u_char *cp;
//flaw_line_below:
	u_char showspi, showdata, showsomedata;
//fix_flaw_line_below:
//	u_char showspi, showsomedata;
 	const char *notify_name;
 	uint32_t type;
 
	p = (const struct ikev2_n *)ext;
	ND_TCHECK(*p);
	UNALIGNED_MEMCPY(&n, ext, sizeof(n));
 	ikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_N), n.h.critical);
 
 	showspi = 1;
//flaw_line_below:
	showdata = 0;
 	showsomedata=0;
 	notify_name=NULL;
 
	ND_PRINT((ndo,"" prot_id=%s"", PROTOIDSTR(n.prot_id)));

	type = ntohs(n.type);

	/* notify space is annoying sparse */
	switch(type) {
	case IV2_NOTIFY_UNSUPPORTED_CRITICAL_PAYLOAD:
		notify_name = ""unsupported_critical_payload"";
		showspi = 0;
		break;

	case IV2_NOTIFY_INVALID_IKE_SPI:
		notify_name = ""invalid_ike_spi"";
		showspi = 1;
		break;

	case IV2_NOTIFY_INVALID_MAJOR_VERSION:
		notify_name = ""invalid_major_version"";
		showspi = 0;
		break;

	case IV2_NOTIFY_INVALID_SYNTAX:
		notify_name = ""invalid_syntax"";
		showspi = 1;
		break;

	case IV2_NOTIFY_INVALID_MESSAGE_ID:
		notify_name = ""invalid_message_id"";
		showspi = 1;
		break;

	case IV2_NOTIFY_INVALID_SPI:
		notify_name = ""invalid_spi"";
		showspi = 1;
		break;

	case IV2_NOTIFY_NO_PROPOSAL_CHOSEN:
		notify_name = ""no_protocol_chosen"";
		showspi = 1;
		break;

	case IV2_NOTIFY_INVALID_KE_PAYLOAD:
		notify_name = ""invalid_ke_payload"";
		showspi = 1;
		break;

	case IV2_NOTIFY_AUTHENTICATION_FAILED:
		notify_name = ""authentication_failed"";
		showspi = 1;
		break;

	case IV2_NOTIFY_SINGLE_PAIR_REQUIRED:
		notify_name = ""single_pair_required"";
		showspi = 1;
		break;

	case IV2_NOTIFY_NO_ADDITIONAL_SAS:
		notify_name = ""no_additional_sas"";
		showspi = 0;
		break;

	case IV2_NOTIFY_INTERNAL_ADDRESS_FAILURE:
		notify_name = ""internal_address_failure"";
		showspi = 0;
		break;

	case IV2_NOTIFY_FAILED_CP_REQUIRED:
		notify_name = ""failed:cp_required"";
		showspi = 0;
		break;

	case IV2_NOTIFY_INVALID_SELECTORS:
		notify_name = ""invalid_selectors"";
		showspi = 0;
		break;

	case IV2_NOTIFY_INITIAL_CONTACT:
		notify_name = ""initial_contact"";
		showspi = 0;
		break;

	case IV2_NOTIFY_SET_WINDOW_SIZE:
		notify_name = ""set_window_size"";
		showspi = 0;
		break;

	case IV2_NOTIFY_ADDITIONAL_TS_POSSIBLE:
		notify_name = ""additional_ts_possible"";
		showspi = 0;
		break;

	case IV2_NOTIFY_IPCOMP_SUPPORTED:
		notify_name = ""ipcomp_supported"";
		showspi = 0;
		break;

	case IV2_NOTIFY_NAT_DETECTION_SOURCE_IP:
		notify_name = ""nat_detection_source_ip"";
		showspi = 1;
		break;

	case IV2_NOTIFY_NAT_DETECTION_DESTINATION_IP:
		notify_name = ""nat_detection_destination_ip"";
		showspi = 1;
		break;

	case IV2_NOTIFY_COOKIE:
 		notify_name = ""cookie"";
 		showspi = 1;
 		showsomedata= 1;
//flaw_line_below:
		showdata= 0;
 		break;
 
 	case IV2_NOTIFY_USE_TRANSPORT_MODE:
		notify_name = ""use_transport_mode"";
		showspi = 0;
		break;

	case IV2_NOTIFY_HTTP_CERT_LOOKUP_SUPPORTED:
		notify_name = ""http_cert_lookup_supported"";
		showspi = 0;
		break;

	case IV2_NOTIFY_REKEY_SA:
		notify_name = ""rekey_sa"";
		showspi = 1;
		break;

	case IV2_NOTIFY_ESP_TFC_PADDING_NOT_SUPPORTED:
		notify_name = ""tfc_padding_not_supported"";
		showspi = 0;
		break;

	case IV2_NOTIFY_NON_FIRST_FRAGMENTS_ALSO:
		notify_name = ""non_first_fragment_also"";
		showspi = 0;
		break;

	default:
		if (type < 8192) {
			notify_name=""error"";
		} else if(type < 16384) {
			notify_name=""private-error"";
		} else if(type < 40960) {
			notify_name=""status"";
		} else {
			notify_name=""private-status"";
		}
	}

	if(notify_name) {
		ND_PRINT((ndo,"" type=%u(%s)"", type, notify_name));
	}


	if (showspi && n.spi_size) {
		ND_PRINT((ndo,"" spi=""));
		if (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))
			goto trunc;
	}
 
 	cp = (const u_char *)(p + 1) + n.spi_size;
 
//flaw_line_below:
	if(3 < ndo->ndo_vflag) {
//flaw_line_below:
		showdata = 1;
//flaw_line_below:
	}
//flaw_line_below:

//flaw_line_below:
	if ((showdata || (showsomedata && ep-cp < 30)) && cp < ep) {
//flaw_line_below:
		ND_PRINT((ndo,"" data=(""));
//flaw_line_below:
		if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
//flaw_line_below:
			goto trunc;
//flaw_line_below:

//flaw_line_below:
		ND_PRINT((ndo,"")""));
//fix_flaw_line_below:
//	if (cp < ep) {
//fix_flaw_line_below:
//		if (ndo->ndo_vflag > 3 || (showsomedata && ep-cp < 30)) {
//fix_flaw_line_below:
//			ND_PRINT((ndo,"" data=(""));
//fix_flaw_line_below:
//			if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
//fix_flaw_line_below:
//				goto trunc;
 
//flaw_line_below:
	} else if(showsomedata && cp < ep) {
//flaw_line_below:
		if(!ike_show_somedata(ndo, cp, ep)) goto trunc;
//fix_flaw_line_below:
//			ND_PRINT((ndo,"")""));
//fix_flaw_line_below:
//		} else if (showsomedata) {
//fix_flaw_line_below:
//			if (!ike_show_somedata(ndo, cp, ep))
//fix_flaw_line_below:
//				goto trunc;
//fix_flaw_line_below:
//		}
 	}
 
 	return (const u_char *)ext + item_len;
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_N)));
	return NULL;
}
"
3364,181100,,Remote,Not required,Partial,CVE-2017-12989,https://www.cvedetails.com/cve/CVE-2017-12989/,CWE-835,Low,,,,2017-09-14,5.0,The RESP parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-resp.c:resp_get_length().,2019-10-02,,11,https://github.com/the-tcpdump-group/tcpdump/commit/db24063b01cba8e9d4d88b7d8ac70c9000c104e4,db24063b01cba8e9d4d88b7d8ac70c9000c104e4,"CVE-2017-12989/RESP: Make sure resp_get_length() advances the pointer for invalid lengths.

Make sure that it always sends *endp before returning and that, for
invalid lengths where we don't like a character in the length string,
what it sets *endp to is past the character in question, so we don't
run the risk of infinitely looping (or doing something else random) if a
character in the length is invalid.

This fixes an infinite loop discovered by Forcepoint's security
researchers Otto Airamo & Antti Levomki.

Add a test using the capture file supplied by the reporter(s).",3,print-resp.c,"{""sha"": ""dee22d63a2fd1fbf323bac06a3dad7b0c097a99b"", ""filename"": ""print-resp.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 3, ""changes"": 14, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/db24063b01cba8e9d4d88b7d8ac70c9000c104e4/print-resp.c"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/db24063b01cba8e9d4d88b7d8ac70c9000c104e4/print-resp.c"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/print-resp.c?ref=db24063b01cba8e9d4d88b7d8ac70c9000c104e4"", ""patch"": ""@@ -481,8 +481,10 @@ resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, con\n         ND_TCHECK(*bp);\n         c = *bp;\n         if (!(c >= '0' && c <= '9')) {\n-            if (!saw_digit)\n+            if (!saw_digit) {\n+                bp++;\n                 goto invalid;\n+            }\n             break;\n         }\n         c -= '0';\n@@ -510,15 +512,19 @@ resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, con\n     if (len == 0)\n         goto trunc;\n     ND_TCHECK(*bp);\n-    if (*bp != '\\r')\n+    if (*bp != '\\r') {\n+        bp++;\n         goto invalid;\n+    }\n     bp++;\n     len--;\n     if (len == 0)\n         goto trunc;\n     ND_TCHECK(*bp);\n-    if (*bp != '\\n')\n+    if (*bp != '\\n') {\n+        bp++;\n         goto invalid;\n+    }\n     bp++;\n     len--;\n     *endp = bp;\n@@ -531,8 +537,10 @@ resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, con\n     return (too_large ? -3 : result);\n \n trunc:\n+    *endp = bp;\n     return (-2);\n \n invalid:\n+    *endp = bp;\n     return (-5);\n }""}<_**next**_>{""sha"": ""ecf54f69bcc3ef41d28f342f3fcf2404dd8fb114"", ""filename"": ""tests/TESTLIST"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/db24063b01cba8e9d4d88b7d8ac70c9000c104e4/tests/TESTLIST"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/db24063b01cba8e9d4d88b7d8ac70c9000c104e4/tests/TESTLIST"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/TESTLIST?ref=db24063b01cba8e9d4d88b7d8ac70c9000c104e4"", ""patch"": ""@@ -468,6 +468,7 @@ zephyr-oobr\t\tzephyr-oobr.pcap\t\tzephyr-oobr.out\t\t-vvv -e\n bgp-as-path-oobr\tbgp-as-path-oobr.pcap\t\tbgp-as-path-oobr.out\t-vvv -e\n isakmp-no-none-np\tisakmp-no-none-np.pcap\t\tisakmp-no-none-np.out\t-vvv -e\n telnet-iac-check-oobr\ttelnet-iac-check-oobr.pcap\ttelnet-iac-check-oobr.out\t-vvv -e\n+resp_4_infiniteloop\tresp_4_infiniteloop.pcap\tresp_4_infiniteloop.out\t-vvv -e\n \n # RTP tests\n # fuzzed pcap""}<_**next**_>{""sha"": ""396cb8b39af56e1cd58ce38d20d03dd278a1d4ed"", ""filename"": ""tests/resp_4_infiniteloop.out"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/db24063b01cba8e9d4d88b7d8ac70c9000c104e4/tests/resp_4_infiniteloop.out"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/db24063b01cba8e9d4d88b7d8ac70c9000c104e4/tests/resp_4_infiniteloop.out"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/resp_4_infiniteloop.out?ref=db24063b01cba8e9d4d88b7d8ac70c9000c104e4"", ""patch"": ""@@ -0,0 +1,2 @@\n+00:50:56:b4:08:69 > 00:50:56:b4:4c:2a, ethertype IPv4 (0x0800), length 920: (tos 0x0, ttl 64, id 27576, offset 0, flags [DF], proto TCP (6), length 906)\n+    172.16.8.77.33926 > 172.16.8.149.6379: Flags [P.], cksum 0xa129 (incorrect -> 0xaaa0), seq 3839414413:3839415267, ack 2526552240, win 229, options [nop,nop,TS val 2407226 ecr 24894817], length 854: RESP length negative and not -1 invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid \""4\"" \""EVAL\"" invalid invalid invalid invalid \""GKMbNZq^@0\"" \""stuubt.pack('<ivdMFG4294967245',^V ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''319', 2',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',', '-1494241318543828858')'L')N))'r')')~D')')E)')')')')')')')'l')')')')')'M-`'o')')'Pp)U)\"" invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid \""1\"" [|RESP]""}<_**next**_>{""sha"": ""98a79bfb67d0098a747f02c3a945dcf401a98df9"", ""filename"": ""tests/resp_4_infiniteloop.pcap"", ""status"": ""added"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/the-tcpdump-group/tcpdump/blob/db24063b01cba8e9d4d88b7d8ac70c9000c104e4/tests/resp_4_infiniteloop.pcap"", ""raw_url"": ""https://github.com/the-tcpdump-group/tcpdump/raw/db24063b01cba8e9d4d88b7d8ac70c9000c104e4/tests/resp_4_infiniteloop.pcap"", ""contents_url"": ""https://api.github.com/repos/the-tcpdump-group/tcpdump/contents/tests/resp_4_infiniteloop.pcap?ref=db24063b01cba8e9d4d88b7d8ac70c9000c104e4""}","resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, const u_char **endp)
{
    int result;
    u_char c;
    int saw_digit;
    int neg;
    int too_large;

    if (len == 0)
        goto trunc;
    ND_TCHECK(*bp);
    too_large = 0;
    neg = 0;
    if (*bp == '-') {
        neg = 1;
        bp++;
        len--;
    }
    result = 0;
    saw_digit = 0;

    for (;;) {
        if (len == 0)
            goto trunc;
         ND_TCHECK(*bp);
         c = *bp;
         if (!(c >= '0' && c <= '9')) {
            if (!saw_digit) {
                bp++;
                 goto invalid;
            }
             break;
         }
         c -= '0';
        if (result > (INT_MAX / 10)) {
            /* This will overflow an int when we multiply it by 10. */
            too_large = 1;
        } else {
            result *= 10;
            if (result == INT_MAX && c > (INT_MAX % 10)) {
                /* This will overflow an int when we add c */
                too_large = 1;
            } else
                result += c;
        }
        bp++;
        len--;
        saw_digit = 1;
    }
    if (!saw_digit)
        goto invalid;

    /*
     * OK, the next thing should be \r\n.
     */
     if (len == 0)
         goto trunc;
     ND_TCHECK(*bp);
    if (*bp != '\r') {
        bp++;
         goto invalid;
    }
     bp++;
     len--;
     if (len == 0)
         goto trunc;
     ND_TCHECK(*bp);
    if (*bp != '\n') {
        bp++;
         goto invalid;
    }
     bp++;
     len--;
     *endp = bp;
    if (neg) {
        /* -1 means ""null"", anything else is invalid */
        if (too_large || result != 1)
            return (-4);
        result = -1;
    }
     return (too_large ? -3 : result);
 
 trunc:
    *endp = bp;
     return (-2);
 
 invalid:
    *endp = bp;
     return (-5);
 }
","resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, const u_char **endp)
{
    int result;
    u_char c;
    int saw_digit;
    int neg;
    int too_large;

    if (len == 0)
        goto trunc;
    ND_TCHECK(*bp);
    too_large = 0;
    neg = 0;
    if (*bp == '-') {
        neg = 1;
        bp++;
        len--;
    }
    result = 0;
    saw_digit = 0;

    for (;;) {
        if (len == 0)
            goto trunc;
         ND_TCHECK(*bp);
         c = *bp;
         if (!(c >= '0' && c <= '9')) {
            if (!saw_digit)
                 goto invalid;
             break;
         }
         c -= '0';
        if (result > (INT_MAX / 10)) {
            /* This will overflow an int when we multiply it by 10. */
            too_large = 1;
        } else {
            result *= 10;
            if (result == INT_MAX && c > (INT_MAX % 10)) {
                /* This will overflow an int when we add c */
                too_large = 1;
            } else
                result += c;
        }
        bp++;
        len--;
        saw_digit = 1;
    }
    if (!saw_digit)
        goto invalid;

    /*
     * OK, the next thing should be \r\n.
     */
     if (len == 0)
         goto trunc;
     ND_TCHECK(*bp);
    if (*bp != '\r')
         goto invalid;
     bp++;
     len--;
     if (len == 0)
         goto trunc;
     ND_TCHECK(*bp);
    if (*bp != '\n')
         goto invalid;
     bp++;
     len--;
     *endp = bp;
    if (neg) {
        /* -1 means ""null"", anything else is invalid */
        if (too_large || result != 1)
            return (-4);
        result = -1;
    }
     return (too_large ? -3 : result);
 
 trunc:
     return (-2);
 
 invalid:
     return (-5);
 }
",C,"            if (!saw_digit) {
                bp++;
            }
    if (*bp != '\r') {
        bp++;
    }
    if (*bp != '\n') {
        bp++;
    }
    *endp = bp;
    *endp = bp;
","            if (!saw_digit)
    if (*bp != '\r')
    if (*bp != '\n')
",,"@@ -481,8 +481,10 @@ resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, con
         ND_TCHECK(*bp);
         c = *bp;
         if (!(c >= '0' && c <= '9')) {
-            if (!saw_digit)
+            if (!saw_digit) {
+                bp++;
                 goto invalid;
+            }
             break;
         }
         c -= '0';
@@ -510,15 +512,19 @@ resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, con
     if (len == 0)
         goto trunc;
     ND_TCHECK(*bp);
-    if (*bp != '\r')
+    if (*bp != '\r') {
+        bp++;
         goto invalid;
+    }
     bp++;
     len--;
     if (len == 0)
         goto trunc;
     ND_TCHECK(*bp);
-    if (*bp != '\n')
+    if (*bp != '\n') {
+        bp++;
         goto invalid;
+    }
     bp++;
     len--;
     *endp = bp;
@@ -531,8 +537,10 @@ resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, con
     return (too_large ? -3 : result);
 
 trunc:
+    *endp = bp;
     return (-2);
 
 invalid:
+    *endp = bp;
     return (-5);
 }",tcpdump,db24063b01cba8e9d4d88b7d8ac70c9000c104e4,2ecb9d2c67d9119250c54811a6ce4d0f2ddf44f1,1,"resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, const u_char **endp)
{
    int result;
    u_char c;
    int saw_digit;
    int neg;
    int too_large;

    if (len == 0)
        goto trunc;
    ND_TCHECK(*bp);
    too_large = 0;
    neg = 0;
    if (*bp == '-') {
        neg = 1;
        bp++;
        len--;
    }
    result = 0;
    saw_digit = 0;

    for (;;) {
        if (len == 0)
            goto trunc;
         ND_TCHECK(*bp);
         c = *bp;
         if (!(c >= '0' && c <= '9')) {
//flaw_line_below:
            if (!saw_digit)
//fix_flaw_line_below:
//            if (!saw_digit) {
//fix_flaw_line_below:
//                bp++;
                 goto invalid;
//fix_flaw_line_below:
//            }
             break;
         }
         c -= '0';
        if (result > (INT_MAX / 10)) {
            /* This will overflow an int when we multiply it by 10. */
            too_large = 1;
        } else {
            result *= 10;
            if (result == INT_MAX && c > (INT_MAX % 10)) {
                /* This will overflow an int when we add c */
                too_large = 1;
            } else
                result += c;
        }
        bp++;
        len--;
        saw_digit = 1;
    }
    if (!saw_digit)
        goto invalid;

    /*
     * OK, the next thing should be \r\n.
     */
     if (len == 0)
         goto trunc;
     ND_TCHECK(*bp);
//flaw_line_below:
    if (*bp != '\r')
//fix_flaw_line_below:
//    if (*bp != '\r') {
//fix_flaw_line_below:
//        bp++;
         goto invalid;
//fix_flaw_line_below:
//    }
     bp++;
     len--;
     if (len == 0)
         goto trunc;
     ND_TCHECK(*bp);
//flaw_line_below:
    if (*bp != '\n')
//fix_flaw_line_below:
//    if (*bp != '\n') {
//fix_flaw_line_below:
//        bp++;
         goto invalid;
//fix_flaw_line_below:
//    }
     bp++;
     len--;
     *endp = bp;
    if (neg) {
        /* -1 means ""null"", anything else is invalid */
        if (too_large || result != 1)
            return (-4);
        result = -1;
    }
     return (too_large ? -3 : result);
 
 trunc:
//fix_flaw_line_below:
//    *endp = bp;
     return (-2);
 
 invalid:
//fix_flaw_line_below:
//    *endp = bp;
     return (-5);
 }
"
3444,181180,,Remote,Not required,Complete,CVE-2017-11523,https://www.cvedetails.com/cve/CVE-2017-11523/,CWE-835,Medium,,,,2017-07-22,7.1,"The ReadTXTImage function in coders/txt.c in ImageMagick through 6.9.9-0 and 7.x through 7.0.6-1 allows remote attackers to cause a denial of service (infinite loop) via a crafted file, because the end-of-file condition is not considered.",2019-10-02,DoS ,6,https://github.com/ImageMagick/ImageMagick/commit/a8f9c2aabed37cd6a728532d1aed13ae0f3dfd78,a8f9c2aabed37cd6a728532d1aed13ae0f3dfd78,https://github.com/ImageMagick/ImageMagick/issues/591,0,coders/txt.c,"{""sha"": ""f59418bbcc2fe8f81a4783bf3acec404560eb6d9"", ""filename"": ""coders/txt.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/a8f9c2aabed37cd6a728532d1aed13ae0f3dfd78/coders/txt.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/a8f9c2aabed37cd6a728532d1aed13ae0f3dfd78/coders/txt.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/txt.c?ref=a8f9c2aabed37cd6a728532d1aed13ae0f3dfd78"", ""patch"": ""@@ -580,6 +580,12 @@ static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n           break;\n       }\n     }\n+    if (EOFBlob(image) != MagickFalse)\n+      {\n+        ThrowFileException(exception,CorruptImageError,\""UnexpectedEndOfFile\"",\n+          image->filename);\n+        break;\n+      }\n     (void) ReadBlobString(image,text);\n     if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n       {""}","static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  char
    colorspace[MaxTextExtent],
    text[MaxTextExtent];

  Image
    *image;

  IndexPacket
    *indexes;

  long
    x_offset,
    y_offset;

  MagickBooleanType
    status;

  MagickPixelPacket
    pixel;

  QuantumAny
    range;

  register ssize_t
    i,
    x;

  register PixelPacket
    *q;

  ssize_t
    count,
    type,
    y;

  unsigned long
    depth,
    height,
    max_value,
    width;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  (void) ResetMagickMemory(text,0,sizeof(text));
  (void) ReadBlobString(image,text);
  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  do
  {
    width=0;
    height=0;
    max_value=0;
    *colorspace='\0';
    count=(ssize_t) sscanf(text+32,""%lu,%lu,%lu,%s"",&width,&height,&max_value,
      colorspace);
    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    image->columns=width;
    image->rows=height;
    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;
    image->depth=depth;
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
    LocaleLower(colorspace);
    i=(ssize_t) strlen(colorspace)-1;
    image->matte=MagickFalse;
    if ((i > 0) && (colorspace[i] == 'a'))
      {
        colorspace[i]='\0';
        image->matte=MagickTrue;
      }
    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);
    if (type < 0)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    image->colorspace=(ColorspaceType) type;
    (void) ResetMagickMemory(&pixel,0,sizeof(pixel));
    (void) SetImageBackgroundColor(image);
    range=GetQuantumRange(image->depth);
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      double
        blue,
        green,
        index,
        opacity,
        red;

      red=0.0;
      green=0.0;
      blue=0.0;
      index=0.0;
      opacity=0.0;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        if (ReadBlobString(image,text) == (char *) NULL)
          break;
        switch (image->colorspace)
        {
          case GRAYColorspace:
          {
            if (image->matte != MagickFalse)
              {
                (void) sscanf(text,""%ld,%ld: (%lf%*[%,]%lf%*[%,]"",&x_offset,
                  &y_offset,&red,&opacity);
                green=red;
                blue=red;
                break;
              }
            (void) sscanf(text,""%ld,%ld: (%lf%*[%,]"",&x_offset,&y_offset,&red);
            green=red;
            blue=red;
            break;
          }
          case CMYKColorspace:
          {
            if (image->matte != MagickFalse)
              {
                (void) sscanf(text,
                  ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                  &x_offset,&y_offset,&red,&green,&blue,&index,&opacity);
                break;
              }
            (void) sscanf(text,
              ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&x_offset,
              &y_offset,&red,&green,&blue,&index);
            break;
          }
          default:
          {
            if (image->matte != MagickFalse)
              {
                (void) sscanf(text,
                  ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                  &x_offset,&y_offset,&red,&green,&blue,&opacity);
                break;
              }
            (void) sscanf(text,""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
              &x_offset,&y_offset,&red,&green,&blue);
            break;
          }
        }
        if (strchr(text,'%') != (char *) NULL)
          {
            red*=0.01*range;
            green*=0.01*range;
            blue*=0.01*range;
            index*=0.01*range;
            opacity*=0.01*range;
          }
        if (image->colorspace == LabColorspace)
          {
            green+=(range+1)/2.0;
            blue+=(range+1)/2.0;
          }
        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),
          range);
        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),
          range);
        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),
          range);
        pixel.index=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (index+0.5),
          range);
        pixel.opacity=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (opacity+
          0.5),range);
        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,
          exception);
        if (q == (PixelPacket *) NULL)
          continue;
        SetPixelRed(q,pixel.red);
        SetPixelGreen(q,pixel.green);
        SetPixelBlue(q,pixel.blue);
        if (image->colorspace == CMYKColorspace)
          {
            indexes=GetAuthenticIndexQueue(image);
            SetPixelIndex(indexes,pixel.index);
          }
        if (image->matte != MagickFalse)
          SetPixelAlpha(q,pixel.opacity);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
           break;
       }
     }
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
     (void) ReadBlobString(image,text);
     if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)
       {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  char
    colorspace[MaxTextExtent],
    text[MaxTextExtent];

  Image
    *image;

  IndexPacket
    *indexes;

  long
    x_offset,
    y_offset;

  MagickBooleanType
    status;

  MagickPixelPacket
    pixel;

  QuantumAny
    range;

  register ssize_t
    i,
    x;

  register PixelPacket
    *q;

  ssize_t
    count,
    type,
    y;

  unsigned long
    depth,
    height,
    max_value,
    width;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  (void) ResetMagickMemory(text,0,sizeof(text));
  (void) ReadBlobString(image,text);
  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  do
  {
    width=0;
    height=0;
    max_value=0;
    *colorspace='\0';
    count=(ssize_t) sscanf(text+32,""%lu,%lu,%lu,%s"",&width,&height,&max_value,
      colorspace);
    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    image->columns=width;
    image->rows=height;
    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;
    image->depth=depth;
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
    LocaleLower(colorspace);
    i=(ssize_t) strlen(colorspace)-1;
    image->matte=MagickFalse;
    if ((i > 0) && (colorspace[i] == 'a'))
      {
        colorspace[i]='\0';
        image->matte=MagickTrue;
      }
    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);
    if (type < 0)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    image->colorspace=(ColorspaceType) type;
    (void) ResetMagickMemory(&pixel,0,sizeof(pixel));
    (void) SetImageBackgroundColor(image);
    range=GetQuantumRange(image->depth);
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      double
        blue,
        green,
        index,
        opacity,
        red;

      red=0.0;
      green=0.0;
      blue=0.0;
      index=0.0;
      opacity=0.0;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        if (ReadBlobString(image,text) == (char *) NULL)
          break;
        switch (image->colorspace)
        {
          case GRAYColorspace:
          {
            if (image->matte != MagickFalse)
              {
                (void) sscanf(text,""%ld,%ld: (%lf%*[%,]%lf%*[%,]"",&x_offset,
                  &y_offset,&red,&opacity);
                green=red;
                blue=red;
                break;
              }
            (void) sscanf(text,""%ld,%ld: (%lf%*[%,]"",&x_offset,&y_offset,&red);
            green=red;
            blue=red;
            break;
          }
          case CMYKColorspace:
          {
            if (image->matte != MagickFalse)
              {
                (void) sscanf(text,
                  ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                  &x_offset,&y_offset,&red,&green,&blue,&index,&opacity);
                break;
              }
            (void) sscanf(text,
              ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&x_offset,
              &y_offset,&red,&green,&blue,&index);
            break;
          }
          default:
          {
            if (image->matte != MagickFalse)
              {
                (void) sscanf(text,
                  ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                  &x_offset,&y_offset,&red,&green,&blue,&opacity);
                break;
              }
            (void) sscanf(text,""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
              &x_offset,&y_offset,&red,&green,&blue);
            break;
          }
        }
        if (strchr(text,'%') != (char *) NULL)
          {
            red*=0.01*range;
            green*=0.01*range;
            blue*=0.01*range;
            index*=0.01*range;
            opacity*=0.01*range;
          }
        if (image->colorspace == LabColorspace)
          {
            green+=(range+1)/2.0;
            blue+=(range+1)/2.0;
          }
        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),
          range);
        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),
          range);
        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),
          range);
        pixel.index=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (index+0.5),
          range);
        pixel.opacity=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (opacity+
          0.5),range);
        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,
          exception);
        if (q == (PixelPacket *) NULL)
          continue;
        SetPixelRed(q,pixel.red);
        SetPixelGreen(q,pixel.green);
        SetPixelBlue(q,pixel.blue);
        if (image->colorspace == CMYKColorspace)
          {
            indexes=GetAuthenticIndexQueue(image);
            SetPixelIndex(indexes,pixel.index);
          }
        if (image->matte != MagickFalse)
          SetPixelAlpha(q,pixel.opacity);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
           break;
       }
     }
     (void) ReadBlobString(image,text);
     if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)
       {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",C,"    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
",,,"@@ -580,6 +580,12 @@ static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)
           break;
       }
     }
+    if (EOFBlob(image) != MagickFalse)
+      {
+        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
+          image->filename);
+        break;
+      }
     (void) ReadBlobString(image,text);
     if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)
       {",ImageMagick,a8f9c2aabed37cd6a728532d1aed13ae0f3dfd78,af2e7e8018eb21ab48a07473acf6c04af80d7653,1,"static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  char
    colorspace[MaxTextExtent],
    text[MaxTextExtent];

  Image
    *image;

  IndexPacket
    *indexes;

  long
    x_offset,
    y_offset;

  MagickBooleanType
    status;

  MagickPixelPacket
    pixel;

  QuantumAny
    range;

  register ssize_t
    i,
    x;

  register PixelPacket
    *q;

  ssize_t
    count,
    type,
    y;

  unsigned long
    depth,
    height,
    max_value,
    width;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  (void) ResetMagickMemory(text,0,sizeof(text));
  (void) ReadBlobString(image,text);
  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  do
  {
    width=0;
    height=0;
    max_value=0;
    *colorspace='\0';
    count=(ssize_t) sscanf(text+32,""%lu,%lu,%lu,%s"",&width,&height,&max_value,
      colorspace);
    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    image->columns=width;
    image->rows=height;
    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;
    image->depth=depth;
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
    LocaleLower(colorspace);
    i=(ssize_t) strlen(colorspace)-1;
    image->matte=MagickFalse;
    if ((i > 0) && (colorspace[i] == 'a'))
      {
        colorspace[i]='\0';
        image->matte=MagickTrue;
      }
    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);
    if (type < 0)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    image->colorspace=(ColorspaceType) type;
    (void) ResetMagickMemory(&pixel,0,sizeof(pixel));
    (void) SetImageBackgroundColor(image);
    range=GetQuantumRange(image->depth);
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      double
        blue,
        green,
        index,
        opacity,
        red;

      red=0.0;
      green=0.0;
      blue=0.0;
      index=0.0;
      opacity=0.0;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        if (ReadBlobString(image,text) == (char *) NULL)
          break;
        switch (image->colorspace)
        {
          case GRAYColorspace:
          {
            if (image->matte != MagickFalse)
              {
                (void) sscanf(text,""%ld,%ld: (%lf%*[%,]%lf%*[%,]"",&x_offset,
                  &y_offset,&red,&opacity);
                green=red;
                blue=red;
                break;
              }
            (void) sscanf(text,""%ld,%ld: (%lf%*[%,]"",&x_offset,&y_offset,&red);
            green=red;
            blue=red;
            break;
          }
          case CMYKColorspace:
          {
            if (image->matte != MagickFalse)
              {
                (void) sscanf(text,
                  ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                  &x_offset,&y_offset,&red,&green,&blue,&index,&opacity);
                break;
              }
            (void) sscanf(text,
              ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&x_offset,
              &y_offset,&red,&green,&blue,&index);
            break;
          }
          default:
          {
            if (image->matte != MagickFalse)
              {
                (void) sscanf(text,
                  ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                  &x_offset,&y_offset,&red,&green,&blue,&opacity);
                break;
              }
            (void) sscanf(text,""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
              &x_offset,&y_offset,&red,&green,&blue);
            break;
          }
        }
        if (strchr(text,'%') != (char *) NULL)
          {
            red*=0.01*range;
            green*=0.01*range;
            blue*=0.01*range;
            index*=0.01*range;
            opacity*=0.01*range;
          }
        if (image->colorspace == LabColorspace)
          {
            green+=(range+1)/2.0;
            blue+=(range+1)/2.0;
          }
        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),
          range);
        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),
          range);
        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),
          range);
        pixel.index=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (index+0.5),
          range);
        pixel.opacity=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (opacity+
          0.5),range);
        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,
          exception);
        if (q == (PixelPacket *) NULL)
          continue;
        SetPixelRed(q,pixel.red);
        SetPixelGreen(q,pixel.green);
        SetPixelBlue(q,pixel.blue);
        if (image->colorspace == CMYKColorspace)
          {
            indexes=GetAuthenticIndexQueue(image);
            SetPixelIndex(indexes,pixel.index);
          }
        if (image->matte != MagickFalse)
          SetPixelAlpha(q,pixel.opacity);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
           break;
       }
     }
//fix_flaw_line_below:
//    if (EOFBlob(image) != MagickFalse)
//fix_flaw_line_below:
//      {
//fix_flaw_line_below:
//        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
//fix_flaw_line_below:
//          image->filename);
//fix_flaw_line_below:
//        break;
//fix_flaw_line_below:
//      }
     (void) ReadBlobString(image,text);
     if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)
       {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
"
3484,181220,,Local,Not required,Complete,CVE-2017-11171,https://www.cvedetails.com/cve/CVE-2017-11171/,CWE-835,Low,,,,2017-07-11,4.9,"Bad reference counting in the context of accept_ice_connection() in gsm-xsmp-server.c in old versions of gnome-session up until version 2.29.92 allows a local attacker to establish ICE connections to gnome-session with invalid authentication data (an invalid magic cookie). Each failed authentication attempt will leak a file descriptor in gnome-session. When the maximum number of file descriptors is exhausted in the gnome-session process, it will enter an infinite loop trying to communicate without success, consuming 100% of the CPU. The graphical session associated with the gnome-session process will stop working correctly, because communication with gnome-session is no longer possible.",2019-10-02,,0,https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d,b0dc999e0b45355314616321dbb6cb71e729fc9d,"[gsm] Delay the creation of the GsmXSMPClient until it really exists

We used to create the GsmXSMPClient before the XSMP connection is really
accepted. This can lead to some issues, though. An example is:
https://bugzilla.gnome.org/show_bug.cgi?id=598211#c19. Quoting:

 ""What is happening is that a new client (probably metacity in your
 case) is opening an ICE connection in the GSM_MANAGER_PHASE_END_SESSION
 phase, which causes a new GsmXSMPClient to be added to the client
 store. The GSM_MANAGER_PHASE_EXIT phase then begins before the client
 has had a chance to establish a xsmp connection, which means that
 client->priv->conn will not be initialized at the point that xsmp_stop
 is called on the new unregistered client.""

The fix is to create the GsmXSMPClient object when there's a real XSMP
connection. This implies moving the timeout that makes sure we don't
have an empty client to the XSMP server.

https://bugzilla.gnome.org/show_bug.cgi?id=598211",8,gnome-session/gsm-xsmp-client.c,"{""sha"": ""9da5fdc06ea8d46b29a5f0cdb172ce3d9b4a326c"", ""filename"": ""gnome-session/gsm-xsmp-client.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 30, ""changes"": 30, ""blob_url"": ""https://github.com/GNOME/gnome-session/blob/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-client.c"", ""raw_url"": ""https://github.com/GNOME/gnome-session/raw/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-client.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/gnome-session/contents/gnome-session/gsm-xsmp-client.c?ref=b0dc999e0b45355314616321dbb6cb71e729fc9d"", ""patch"": ""@@ -51,7 +51,6 @@ struct GsmXSMPClientPrivate\n         IceConn    ice_connection;\n \n         guint      watch_id;\n-        guint      protocol_timeout;\n \n         char      *description;\n         GPtrArray *props;\n@@ -115,22 +114,6 @@ client_iochannel_watch (GIOChannel    *channel,\n         return keep_going;\n }\n \n-/* Called if too much time passes between the initial connection and\n- * the XSMP protocol setup.\n- */\n-static gboolean\n-_client_protocol_timeout (GsmXSMPClient *client)\n-{\n-        g_debug (\""GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d\"",\n-                 client->priv->description,\n-                 IceConnectionStatus (client->priv->ice_connection));\n-\n-        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);\n-        gsm_client_disconnected (GSM_CLIENT (client));\n-\n-        return FALSE;\n-}\n-\n static SmProp *\n find_property (GsmXSMPClient *client,\n                const char    *name,\n@@ -193,10 +176,6 @@ setup_connection (GsmXSMPClient *client)\n                                                  client);\n         g_io_channel_unref (channel);\n \n-        client->priv->protocol_timeout = g_timeout_add_seconds (5,\n-                                                                (GSourceFunc)_client_protocol_timeout,\n-                                                                client);\n-\n         set_description (client);\n \n         g_debug (\""GsmXSMPClient: New client '%s'\"", client->priv->description);\n@@ -869,10 +848,6 @@ gsm_xsmp_client_disconnect (GsmXSMPClient *client)\n                 IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);\n                 IceCloseConnection (client->priv->ice_connection);\n         }\n-\n-        if (client->priv->protocol_timeout > 0) {\n-                g_source_remove (client->priv->protocol_timeout);\n-        }\n }\n \n static void\n@@ -1305,11 +1280,6 @@ gsm_xsmp_client_connect (GsmXSMPClient *client,\n {\n         client->priv->conn = conn;\n \n-        if (client->priv->protocol_timeout) {\n-                g_source_remove (client->priv->protocol_timeout);\n-                client->priv->protocol_timeout = 0;\n-        }\n-\n         g_debug (\""GsmXSMPClient: Initializing client %s\"", client->priv->description);\n \n         *mask_ret = 0;""}<_**next**_>{""sha"": ""1f0e04554982efbb283e1be102867bef03921cfd"", ""filename"": ""gnome-session/gsm-xsmp-server.c"", ""status"": ""modified"", ""additions"": 124, ""deletions"": 26, ""changes"": 150, ""blob_url"": ""https://github.com/GNOME/gnome-session/blob/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-server.c"", ""raw_url"": ""https://github.com/GNOME/gnome-session/raw/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-server.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/gnome-session/contents/gnome-session/gsm-xsmp-server.c?ref=b0dc999e0b45355314616321dbb6cb71e729fc9d"", ""patch"": ""@@ -91,44 +91,134 @@ typedef struct {\n         IceListenObj   listener;\n } GsmIceConnectionData;\n \n+typedef struct {\n+        guint watch_id;\n+        guint protocol_timeout;\n+} GsmIceConnectionWatch;\n+\n+static void\n+disconnect_ice_connection (IceConn ice_conn)\n+{\n+        IceSetShutdownNegotiation (ice_conn, FALSE);\n+        IceCloseConnection (ice_conn);\n+}\n+\n+static void\n+free_ice_connection_watch (GsmIceConnectionWatch *data)\n+{\n+        if (data->watch_id) {\n+                g_source_remove (data->watch_id);\n+                data->watch_id = 0;\n+        }\n+\n+        if (data->protocol_timeout) {\n+                g_source_remove (data->protocol_timeout);\n+                data->protocol_timeout = 0;\n+        }\n+\n+        g_free (data);\n+}\n+\n+static gboolean\n+ice_protocol_timeout (IceConn ice_conn)\n+{\n+        GsmIceConnectionWatch *data;\n+\n+        g_debug (\""GsmXsmpServer: ice_protocol_timeout for IceConn %p with status %d\"",\n+                 ice_conn, IceConnectionStatus (ice_conn));\n+\n+        data = ice_conn->context;\n+\n+        free_ice_connection_watch (data);\n+        disconnect_ice_connection (ice_conn);\n+\n+        return FALSE;\n+}\n+\n+static gboolean\n+auth_iochannel_watch (GIOChannel   *source,\n+                      GIOCondition  condition,\n+                      IceConn       ice_conn)\n+{\n+\n+        GsmIceConnectionWatch *data;\n+        gboolean               keep_going;\n+\n+        data = ice_conn->context;\n+\n+        switch (IceProcessMessages (ice_conn, NULL, NULL)) {\n+        case IceProcessMessagesSuccess:\n+                keep_going = TRUE;\n+                break;\n+        case IceProcessMessagesIOError:\n+                g_debug (\""GsmXsmpServer: IceProcessMessages returned IceProcessMessagesIOError\"");\n+                free_ice_connection_watch (data);\n+                disconnect_ice_connection (ice_conn);\n+                keep_going = FALSE;\n+                break;\n+        case IceProcessMessagesConnectionClosed:\n+                g_debug (\""GsmXsmpServer: IceProcessMessages returned IceProcessMessagesConnectionClosed\"");\n+                free_ice_connection_watch (data);\n+                keep_going = FALSE;\n+                break;\n+        default:\n+                g_assert_not_reached ();\n+        }\n+\n+        return keep_going;\n+}\n+\n+/* IceAcceptConnection returns a new ICE connection that is in a \""pending\"" state,\n+ * this is because authentification may be necessary.\n+ * So we've to authenticate it, before accept_xsmp_connection() is called.\n+ * Then each GsmXSMPClient will have its own IceConn watcher\n+ */\n+static void\n+auth_ice_connection (IceConn ice_conn)\n+{\n+        GIOChannel            *channel;\n+        GsmIceConnectionWatch *data;\n+        int                    fd;\n+\n+        g_debug (\""GsmXsmpServer: auth_ice_connection()\"");\n+\n+        fd = IceConnectionNumber (ice_conn);\n+        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n+        channel = g_io_channel_unix_new (fd);\n+\n+        data = g_new0 (GsmIceConnectionWatch, 1);\n+        ice_conn->context = data;\n+\n+        data->protocol_timeout = g_timeout_add_seconds (5,\n+                                                        (GSourceFunc)ice_protocol_timeout,\n+                                                        ice_conn);\n+        data->watch_id = g_io_add_watch (channel,\n+                                         G_IO_IN | G_IO_ERR,\n+                                         (GIOFunc)auth_iochannel_watch,\n+                                         ice_conn);\n+        g_io_channel_unref (channel);\n+}\n+\n /* This is called (by glib via xsmp->ice_connection_watch) when a\n- * connection is first received on the ICE listening socket. (We\n- * expect that the client will then initiate XSMP on the connection;\n- * if it does not, GsmXSMPClient will eventually time out and close\n- * the connection.)\n- *\n- * FIXME: it would probably make more sense to not create a\n- * GsmXSMPClient object until accept_xsmp_connection, below (and to do\n- * the timing-out here in xsmp.c).\n+ * connection is first received on the ICE listening socket.\n  */\n static gboolean\n accept_ice_connection (GIOChannel           *source,\n                        GIOCondition          condition,\n                        GsmIceConnectionData *data)\n {\n-        IceListenObj    listener;\n         IceConn         ice_conn;\n         IceAcceptStatus status;\n-        GsmClient      *client;\n-        GsmXsmpServer  *server;\n-\n-        listener = data->listener;\n-        server = data->server;\n \n         g_debug (\""GsmXsmpServer: accept_ice_connection()\"");\n \n-        ice_conn = IceAcceptConnection (listener, &status);\n+        ice_conn = IceAcceptConnection (data->listener, &status);\n         if (status != IceAcceptSuccess) {\n                 g_debug (\""GsmXsmpServer: IceAcceptConnection returned %d\"", status);\n                 return TRUE;\n         }\n \n-        client = gsm_xsmp_client_new (ice_conn);\n-        ice_conn->context = client;\n-\n-        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n-        /* the store will own the ref */\n-        g_object_unref (client);\n+        auth_ice_connection (ice_conn);\n \n         return TRUE;\n }\n@@ -224,8 +314,9 @@ accept_xsmp_connection (SmsConn        sms_conn,\n                         SmsCallbacks  *callbacks_ret,\n                         char         **failure_reason_ret)\n {\n-        IceConn        ice_conn;\n-        GsmXSMPClient *client;\n+        IceConn                ice_conn;\n+        GsmClient             *client;\n+        GsmIceConnectionWatch *data;\n \n         /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */\n         if (server->priv->xsmp_sockets == NULL) {\n@@ -236,11 +327,18 @@ accept_xsmp_connection (SmsConn        sms_conn,\n         }\n \n         ice_conn = SmsGetIceConnection (sms_conn);\n-        client = ice_conn->context;\n+        data = ice_conn->context;\n \n-        g_return_val_if_fail (client != NULL, TRUE);\n+        /* Each GsmXSMPClient has its own IceConn watcher */\n+        free_ice_connection_watch (data);\n+\n+        client = gsm_xsmp_client_new (ice_conn);\n+\n+        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n+        /* the store will own the ref */\n+        g_object_unref (client);\n \n-        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n+        gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);\n \n         return TRUE;\n }""}","_client_protocol_timeout (GsmXSMPClient *client)
","_client_protocol_timeout (GsmXSMPClient *client)
{
        g_debug (""GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d"",
                 client->priv->description,
                 IceConnectionStatus (client->priv->ice_connection));
        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);
        gsm_client_disconnected (GSM_CLIENT (client));
        return FALSE;
}
",C,,"{
        g_debug (""GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d"",
                 client->priv->description,
                 IceConnectionStatus (client->priv->ice_connection));
        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);
        gsm_client_disconnected (GSM_CLIENT (client));
        return FALSE;
}
",,"@@ -51,7 +51,6 @@ struct GsmXSMPClientPrivate
         IceConn    ice_connection;
 
         guint      watch_id;
-        guint      protocol_timeout;
 
         char      *description;
         GPtrArray *props;
@@ -115,22 +114,6 @@ client_iochannel_watch (GIOChannel    *channel,
         return keep_going;
 }
 
-/* Called if too much time passes between the initial connection and
- * the XSMP protocol setup.
- */
-static gboolean
-_client_protocol_timeout (GsmXSMPClient *client)
-{
-        g_debug (""GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d"",
-                 client->priv->description,
-                 IceConnectionStatus (client->priv->ice_connection));
-
-        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);
-        gsm_client_disconnected (GSM_CLIENT (client));
-
-        return FALSE;
-}
-
 static SmProp *
 find_property (GsmXSMPClient *client,
                const char    *name,
@@ -193,10 +176,6 @@ setup_connection (GsmXSMPClient *client)
                                                  client);
         g_io_channel_unref (channel);
 
-        client->priv->protocol_timeout = g_timeout_add_seconds (5,
-                                                                (GSourceFunc)_client_protocol_timeout,
-                                                                client);
-
         set_description (client);
 
         g_debug (""GsmXSMPClient: New client '%s'"", client->priv->description);
@@ -869,10 +848,6 @@ gsm_xsmp_client_disconnect (GsmXSMPClient *client)
                 IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);
                 IceCloseConnection (client->priv->ice_connection);
         }
-
-        if (client->priv->protocol_timeout > 0) {
-                g_source_remove (client->priv->protocol_timeout);
-        }
 }
 
 static void
@@ -1305,11 +1280,6 @@ gsm_xsmp_client_connect (GsmXSMPClient *client,
 {
         client->priv->conn = conn;
 
-        if (client->priv->protocol_timeout) {
-                g_source_remove (client->priv->protocol_timeout);
-                client->priv->protocol_timeout = 0;
-        }
-
         g_debug (""GsmXSMPClient: Initializing client %s"", client->priv->description);
 
         *mask_ret = 0;",gnome-session,b0dc999e0b45355314616321dbb6cb71e729fc9d,5198aa08d2b77204cd8bf669a64f2e044d9a9e0d,1,"_client_protocol_timeout (GsmXSMPClient *client)
//flaw_line_below:
{
//flaw_line_below:
        g_debug (""GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d"",
//flaw_line_below:
                 client->priv->description,
//flaw_line_below:
                 IceConnectionStatus (client->priv->ice_connection));
//flaw_line_below:

//flaw_line_below:
        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);
//flaw_line_below:
        gsm_client_disconnected (GSM_CLIENT (client));
//flaw_line_below:

//flaw_line_below:
        return FALSE;
//flaw_line_below:
}
"
3485,181221,,Local,Not required,Complete,CVE-2017-11171,https://www.cvedetails.com/cve/CVE-2017-11171/,CWE-835,Low,,,,2017-07-11,4.9,"Bad reference counting in the context of accept_ice_connection() in gsm-xsmp-server.c in old versions of gnome-session up until version 2.29.92 allows a local attacker to establish ICE connections to gnome-session with invalid authentication data (an invalid magic cookie). Each failed authentication attempt will leak a file descriptor in gnome-session. When the maximum number of file descriptors is exhausted in the gnome-session process, it will enter an infinite loop trying to communicate without success, consuming 100% of the CPU. The graphical session associated with the gnome-session process will stop working correctly, because communication with gnome-session is no longer possible.",2019-10-02,,0,https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d,b0dc999e0b45355314616321dbb6cb71e729fc9d,"[gsm] Delay the creation of the GsmXSMPClient until it really exists

We used to create the GsmXSMPClient before the XSMP connection is really
accepted. This can lead to some issues, though. An example is:
https://bugzilla.gnome.org/show_bug.cgi?id=598211#c19. Quoting:

 ""What is happening is that a new client (probably metacity in your
 case) is opening an ICE connection in the GSM_MANAGER_PHASE_END_SESSION
 phase, which causes a new GsmXSMPClient to be added to the client
 store. The GSM_MANAGER_PHASE_EXIT phase then begins before the client
 has had a chance to establish a xsmp connection, which means that
 client->priv->conn will not be initialized at the point that xsmp_stop
 is called on the new unregistered client.""

The fix is to create the GsmXSMPClient object when there's a real XSMP
connection. This implies moving the timeout that makes sure we don't
have an empty client to the XSMP server.

https://bugzilla.gnome.org/show_bug.cgi?id=598211",4,gnome-session/gsm-xsmp-client.c,"{""sha"": ""9da5fdc06ea8d46b29a5f0cdb172ce3d9b4a326c"", ""filename"": ""gnome-session/gsm-xsmp-client.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 30, ""changes"": 30, ""blob_url"": ""https://github.com/GNOME/gnome-session/blob/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-client.c"", ""raw_url"": ""https://github.com/GNOME/gnome-session/raw/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-client.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/gnome-session/contents/gnome-session/gsm-xsmp-client.c?ref=b0dc999e0b45355314616321dbb6cb71e729fc9d"", ""patch"": ""@@ -51,7 +51,6 @@ struct GsmXSMPClientPrivate\n         IceConn    ice_connection;\n \n         guint      watch_id;\n-        guint      protocol_timeout;\n \n         char      *description;\n         GPtrArray *props;\n@@ -115,22 +114,6 @@ client_iochannel_watch (GIOChannel    *channel,\n         return keep_going;\n }\n \n-/* Called if too much time passes between the initial connection and\n- * the XSMP protocol setup.\n- */\n-static gboolean\n-_client_protocol_timeout (GsmXSMPClient *client)\n-{\n-        g_debug (\""GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d\"",\n-                 client->priv->description,\n-                 IceConnectionStatus (client->priv->ice_connection));\n-\n-        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);\n-        gsm_client_disconnected (GSM_CLIENT (client));\n-\n-        return FALSE;\n-}\n-\n static SmProp *\n find_property (GsmXSMPClient *client,\n                const char    *name,\n@@ -193,10 +176,6 @@ setup_connection (GsmXSMPClient *client)\n                                                  client);\n         g_io_channel_unref (channel);\n \n-        client->priv->protocol_timeout = g_timeout_add_seconds (5,\n-                                                                (GSourceFunc)_client_protocol_timeout,\n-                                                                client);\n-\n         set_description (client);\n \n         g_debug (\""GsmXSMPClient: New client '%s'\"", client->priv->description);\n@@ -869,10 +848,6 @@ gsm_xsmp_client_disconnect (GsmXSMPClient *client)\n                 IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);\n                 IceCloseConnection (client->priv->ice_connection);\n         }\n-\n-        if (client->priv->protocol_timeout > 0) {\n-                g_source_remove (client->priv->protocol_timeout);\n-        }\n }\n \n static void\n@@ -1305,11 +1280,6 @@ gsm_xsmp_client_connect (GsmXSMPClient *client,\n {\n         client->priv->conn = conn;\n \n-        if (client->priv->protocol_timeout) {\n-                g_source_remove (client->priv->protocol_timeout);\n-                client->priv->protocol_timeout = 0;\n-        }\n-\n         g_debug (\""GsmXSMPClient: Initializing client %s\"", client->priv->description);\n \n         *mask_ret = 0;""}<_**next**_>{""sha"": ""1f0e04554982efbb283e1be102867bef03921cfd"", ""filename"": ""gnome-session/gsm-xsmp-server.c"", ""status"": ""modified"", ""additions"": 124, ""deletions"": 26, ""changes"": 150, ""blob_url"": ""https://github.com/GNOME/gnome-session/blob/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-server.c"", ""raw_url"": ""https://github.com/GNOME/gnome-session/raw/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-server.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/gnome-session/contents/gnome-session/gsm-xsmp-server.c?ref=b0dc999e0b45355314616321dbb6cb71e729fc9d"", ""patch"": ""@@ -91,44 +91,134 @@ typedef struct {\n         IceListenObj   listener;\n } GsmIceConnectionData;\n \n+typedef struct {\n+        guint watch_id;\n+        guint protocol_timeout;\n+} GsmIceConnectionWatch;\n+\n+static void\n+disconnect_ice_connection (IceConn ice_conn)\n+{\n+        IceSetShutdownNegotiation (ice_conn, FALSE);\n+        IceCloseConnection (ice_conn);\n+}\n+\n+static void\n+free_ice_connection_watch (GsmIceConnectionWatch *data)\n+{\n+        if (data->watch_id) {\n+                g_source_remove (data->watch_id);\n+                data->watch_id = 0;\n+        }\n+\n+        if (data->protocol_timeout) {\n+                g_source_remove (data->protocol_timeout);\n+                data->protocol_timeout = 0;\n+        }\n+\n+        g_free (data);\n+}\n+\n+static gboolean\n+ice_protocol_timeout (IceConn ice_conn)\n+{\n+        GsmIceConnectionWatch *data;\n+\n+        g_debug (\""GsmXsmpServer: ice_protocol_timeout for IceConn %p with status %d\"",\n+                 ice_conn, IceConnectionStatus (ice_conn));\n+\n+        data = ice_conn->context;\n+\n+        free_ice_connection_watch (data);\n+        disconnect_ice_connection (ice_conn);\n+\n+        return FALSE;\n+}\n+\n+static gboolean\n+auth_iochannel_watch (GIOChannel   *source,\n+                      GIOCondition  condition,\n+                      IceConn       ice_conn)\n+{\n+\n+        GsmIceConnectionWatch *data;\n+        gboolean               keep_going;\n+\n+        data = ice_conn->context;\n+\n+        switch (IceProcessMessages (ice_conn, NULL, NULL)) {\n+        case IceProcessMessagesSuccess:\n+                keep_going = TRUE;\n+                break;\n+        case IceProcessMessagesIOError:\n+                g_debug (\""GsmXsmpServer: IceProcessMessages returned IceProcessMessagesIOError\"");\n+                free_ice_connection_watch (data);\n+                disconnect_ice_connection (ice_conn);\n+                keep_going = FALSE;\n+                break;\n+        case IceProcessMessagesConnectionClosed:\n+                g_debug (\""GsmXsmpServer: IceProcessMessages returned IceProcessMessagesConnectionClosed\"");\n+                free_ice_connection_watch (data);\n+                keep_going = FALSE;\n+                break;\n+        default:\n+                g_assert_not_reached ();\n+        }\n+\n+        return keep_going;\n+}\n+\n+/* IceAcceptConnection returns a new ICE connection that is in a \""pending\"" state,\n+ * this is because authentification may be necessary.\n+ * So we've to authenticate it, before accept_xsmp_connection() is called.\n+ * Then each GsmXSMPClient will have its own IceConn watcher\n+ */\n+static void\n+auth_ice_connection (IceConn ice_conn)\n+{\n+        GIOChannel            *channel;\n+        GsmIceConnectionWatch *data;\n+        int                    fd;\n+\n+        g_debug (\""GsmXsmpServer: auth_ice_connection()\"");\n+\n+        fd = IceConnectionNumber (ice_conn);\n+        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n+        channel = g_io_channel_unix_new (fd);\n+\n+        data = g_new0 (GsmIceConnectionWatch, 1);\n+        ice_conn->context = data;\n+\n+        data->protocol_timeout = g_timeout_add_seconds (5,\n+                                                        (GSourceFunc)ice_protocol_timeout,\n+                                                        ice_conn);\n+        data->watch_id = g_io_add_watch (channel,\n+                                         G_IO_IN | G_IO_ERR,\n+                                         (GIOFunc)auth_iochannel_watch,\n+                                         ice_conn);\n+        g_io_channel_unref (channel);\n+}\n+\n /* This is called (by glib via xsmp->ice_connection_watch) when a\n- * connection is first received on the ICE listening socket. (We\n- * expect that the client will then initiate XSMP on the connection;\n- * if it does not, GsmXSMPClient will eventually time out and close\n- * the connection.)\n- *\n- * FIXME: it would probably make more sense to not create a\n- * GsmXSMPClient object until accept_xsmp_connection, below (and to do\n- * the timing-out here in xsmp.c).\n+ * connection is first received on the ICE listening socket.\n  */\n static gboolean\n accept_ice_connection (GIOChannel           *source,\n                        GIOCondition          condition,\n                        GsmIceConnectionData *data)\n {\n-        IceListenObj    listener;\n         IceConn         ice_conn;\n         IceAcceptStatus status;\n-        GsmClient      *client;\n-        GsmXsmpServer  *server;\n-\n-        listener = data->listener;\n-        server = data->server;\n \n         g_debug (\""GsmXsmpServer: accept_ice_connection()\"");\n \n-        ice_conn = IceAcceptConnection (listener, &status);\n+        ice_conn = IceAcceptConnection (data->listener, &status);\n         if (status != IceAcceptSuccess) {\n                 g_debug (\""GsmXsmpServer: IceAcceptConnection returned %d\"", status);\n                 return TRUE;\n         }\n \n-        client = gsm_xsmp_client_new (ice_conn);\n-        ice_conn->context = client;\n-\n-        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n-        /* the store will own the ref */\n-        g_object_unref (client);\n+        auth_ice_connection (ice_conn);\n \n         return TRUE;\n }\n@@ -224,8 +314,9 @@ accept_xsmp_connection (SmsConn        sms_conn,\n                         SmsCallbacks  *callbacks_ret,\n                         char         **failure_reason_ret)\n {\n-        IceConn        ice_conn;\n-        GsmXSMPClient *client;\n+        IceConn                ice_conn;\n+        GsmClient             *client;\n+        GsmIceConnectionWatch *data;\n \n         /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */\n         if (server->priv->xsmp_sockets == NULL) {\n@@ -236,11 +327,18 @@ accept_xsmp_connection (SmsConn        sms_conn,\n         }\n \n         ice_conn = SmsGetIceConnection (sms_conn);\n-        client = ice_conn->context;\n+        data = ice_conn->context;\n \n-        g_return_val_if_fail (client != NULL, TRUE);\n+        /* Each GsmXSMPClient has its own IceConn watcher */\n+        free_ice_connection_watch (data);\n+\n+        client = gsm_xsmp_client_new (ice_conn);\n+\n+        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n+        /* the store will own the ref */\n+        g_object_unref (client);\n \n-        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n+        gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);\n \n         return TRUE;\n }""}","gsm_xsmp_client_connect (GsmXSMPClient *client,
                         SmsConn        conn,
                         unsigned long *mask_ret,
                         SmsCallbacks  *callbacks_ret)
 {
         client->priv->conn = conn;
 
         g_debug (""GsmXSMPClient: Initializing client %s"", client->priv->description);
 
         *mask_ret = 0;

        *mask_ret |= SmsRegisterClientProcMask;
        callbacks_ret->register_client.callback = register_client_callback;
        callbacks_ret->register_client.manager_data  = client;

        *mask_ret |= SmsInteractRequestProcMask;
        callbacks_ret->interact_request.callback = interact_request_callback;
        callbacks_ret->interact_request.manager_data = client;

        *mask_ret |= SmsInteractDoneProcMask;
        callbacks_ret->interact_done.callback = interact_done_callback;
        callbacks_ret->interact_done.manager_data = client;

        *mask_ret |= SmsSaveYourselfRequestProcMask;
        callbacks_ret->save_yourself_request.callback = save_yourself_request_callback;
        callbacks_ret->save_yourself_request.manager_data = client;

        *mask_ret |= SmsSaveYourselfP2RequestProcMask;
        callbacks_ret->save_yourself_phase2_request.callback = save_yourself_phase2_request_callback;
        callbacks_ret->save_yourself_phase2_request.manager_data = client;

        *mask_ret |= SmsSaveYourselfDoneProcMask;
        callbacks_ret->save_yourself_done.callback = save_yourself_done_callback;
        callbacks_ret->save_yourself_done.manager_data = client;

        *mask_ret |= SmsCloseConnectionProcMask;
        callbacks_ret->close_connection.callback = close_connection_callback;
        callbacks_ret->close_connection.manager_data  = client;

        *mask_ret |= SmsSetPropertiesProcMask;
        callbacks_ret->set_properties.callback = set_properties_callback;
        callbacks_ret->set_properties.manager_data = client;

        *mask_ret |= SmsDeletePropertiesProcMask;
        callbacks_ret->delete_properties.callback = delete_properties_callback;
        callbacks_ret->delete_properties.manager_data = client;

        *mask_ret |= SmsGetPropertiesProcMask;
        callbacks_ret->get_properties.callback = get_properties_callback;
        callbacks_ret->get_properties.manager_data = client;
}
","gsm_xsmp_client_connect (GsmXSMPClient *client,
                         SmsConn        conn,
                         unsigned long *mask_ret,
                         SmsCallbacks  *callbacks_ret)
 {
         client->priv->conn = conn;
 
        if (client->priv->protocol_timeout) {
                g_source_remove (client->priv->protocol_timeout);
                client->priv->protocol_timeout = 0;
        }
         g_debug (""GsmXSMPClient: Initializing client %s"", client->priv->description);
 
         *mask_ret = 0;

        *mask_ret |= SmsRegisterClientProcMask;
        callbacks_ret->register_client.callback = register_client_callback;
        callbacks_ret->register_client.manager_data  = client;

        *mask_ret |= SmsInteractRequestProcMask;
        callbacks_ret->interact_request.callback = interact_request_callback;
        callbacks_ret->interact_request.manager_data = client;

        *mask_ret |= SmsInteractDoneProcMask;
        callbacks_ret->interact_done.callback = interact_done_callback;
        callbacks_ret->interact_done.manager_data = client;

        *mask_ret |= SmsSaveYourselfRequestProcMask;
        callbacks_ret->save_yourself_request.callback = save_yourself_request_callback;
        callbacks_ret->save_yourself_request.manager_data = client;

        *mask_ret |= SmsSaveYourselfP2RequestProcMask;
        callbacks_ret->save_yourself_phase2_request.callback = save_yourself_phase2_request_callback;
        callbacks_ret->save_yourself_phase2_request.manager_data = client;

        *mask_ret |= SmsSaveYourselfDoneProcMask;
        callbacks_ret->save_yourself_done.callback = save_yourself_done_callback;
        callbacks_ret->save_yourself_done.manager_data = client;

        *mask_ret |= SmsCloseConnectionProcMask;
        callbacks_ret->close_connection.callback = close_connection_callback;
        callbacks_ret->close_connection.manager_data  = client;

        *mask_ret |= SmsSetPropertiesProcMask;
        callbacks_ret->set_properties.callback = set_properties_callback;
        callbacks_ret->set_properties.manager_data = client;

        *mask_ret |= SmsDeletePropertiesProcMask;
        callbacks_ret->delete_properties.callback = delete_properties_callback;
        callbacks_ret->delete_properties.manager_data = client;

        *mask_ret |= SmsGetPropertiesProcMask;
        callbacks_ret->get_properties.callback = get_properties_callback;
        callbacks_ret->get_properties.manager_data = client;
}
",C,,"        if (client->priv->protocol_timeout) {
                g_source_remove (client->priv->protocol_timeout);
                client->priv->protocol_timeout = 0;
        }
",,"@@ -51,7 +51,6 @@ struct GsmXSMPClientPrivate
         IceConn    ice_connection;
 
         guint      watch_id;
-        guint      protocol_timeout;
 
         char      *description;
         GPtrArray *props;
@@ -115,22 +114,6 @@ client_iochannel_watch (GIOChannel    *channel,
         return keep_going;
 }
 
-/* Called if too much time passes between the initial connection and
- * the XSMP protocol setup.
- */
-static gboolean
-_client_protocol_timeout (GsmXSMPClient *client)
-{
-        g_debug (""GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d"",
-                 client->priv->description,
-                 IceConnectionStatus (client->priv->ice_connection));
-
-        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);
-        gsm_client_disconnected (GSM_CLIENT (client));
-
-        return FALSE;
-}
-
 static SmProp *
 find_property (GsmXSMPClient *client,
                const char    *name,
@@ -193,10 +176,6 @@ setup_connection (GsmXSMPClient *client)
                                                  client);
         g_io_channel_unref (channel);
 
-        client->priv->protocol_timeout = g_timeout_add_seconds (5,
-                                                                (GSourceFunc)_client_protocol_timeout,
-                                                                client);
-
         set_description (client);
 
         g_debug (""GsmXSMPClient: New client '%s'"", client->priv->description);
@@ -869,10 +848,6 @@ gsm_xsmp_client_disconnect (GsmXSMPClient *client)
                 IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);
                 IceCloseConnection (client->priv->ice_connection);
         }
-
-        if (client->priv->protocol_timeout > 0) {
-                g_source_remove (client->priv->protocol_timeout);
-        }
 }
 
 static void
@@ -1305,11 +1280,6 @@ gsm_xsmp_client_connect (GsmXSMPClient *client,
 {
         client->priv->conn = conn;
 
-        if (client->priv->protocol_timeout) {
-                g_source_remove (client->priv->protocol_timeout);
-                client->priv->protocol_timeout = 0;
-        }
-
         g_debug (""GsmXSMPClient: Initializing client %s"", client->priv->description);
 
         *mask_ret = 0;",gnome-session,b0dc999e0b45355314616321dbb6cb71e729fc9d,5198aa08d2b77204cd8bf669a64f2e044d9a9e0d,1,"gsm_xsmp_client_connect (GsmXSMPClient *client,
                         SmsConn        conn,
                         unsigned long *mask_ret,
                         SmsCallbacks  *callbacks_ret)
 {
         client->priv->conn = conn;
 
//flaw_line_below:
        if (client->priv->protocol_timeout) {
//flaw_line_below:
                g_source_remove (client->priv->protocol_timeout);
//flaw_line_below:
                client->priv->protocol_timeout = 0;
//flaw_line_below:
        }
//flaw_line_below:

         g_debug (""GsmXSMPClient: Initializing client %s"", client->priv->description);
 
         *mask_ret = 0;

        *mask_ret |= SmsRegisterClientProcMask;
        callbacks_ret->register_client.callback = register_client_callback;
        callbacks_ret->register_client.manager_data  = client;

        *mask_ret |= SmsInteractRequestProcMask;
        callbacks_ret->interact_request.callback = interact_request_callback;
        callbacks_ret->interact_request.manager_data = client;

        *mask_ret |= SmsInteractDoneProcMask;
        callbacks_ret->interact_done.callback = interact_done_callback;
        callbacks_ret->interact_done.manager_data = client;

        *mask_ret |= SmsSaveYourselfRequestProcMask;
        callbacks_ret->save_yourself_request.callback = save_yourself_request_callback;
        callbacks_ret->save_yourself_request.manager_data = client;

        *mask_ret |= SmsSaveYourselfP2RequestProcMask;
        callbacks_ret->save_yourself_phase2_request.callback = save_yourself_phase2_request_callback;
        callbacks_ret->save_yourself_phase2_request.manager_data = client;

        *mask_ret |= SmsSaveYourselfDoneProcMask;
        callbacks_ret->save_yourself_done.callback = save_yourself_done_callback;
        callbacks_ret->save_yourself_done.manager_data = client;

        *mask_ret |= SmsCloseConnectionProcMask;
        callbacks_ret->close_connection.callback = close_connection_callback;
        callbacks_ret->close_connection.manager_data  = client;

        *mask_ret |= SmsSetPropertiesProcMask;
        callbacks_ret->set_properties.callback = set_properties_callback;
        callbacks_ret->set_properties.manager_data = client;

        *mask_ret |= SmsDeletePropertiesProcMask;
        callbacks_ret->delete_properties.callback = delete_properties_callback;
        callbacks_ret->delete_properties.manager_data = client;

        *mask_ret |= SmsGetPropertiesProcMask;
        callbacks_ret->get_properties.callback = get_properties_callback;
        callbacks_ret->get_properties.manager_data = client;
}
"
3486,181222,,Local,Not required,Complete,CVE-2017-11171,https://www.cvedetails.com/cve/CVE-2017-11171/,CWE-835,Low,,,,2017-07-11,4.9,"Bad reference counting in the context of accept_ice_connection() in gsm-xsmp-server.c in old versions of gnome-session up until version 2.29.92 allows a local attacker to establish ICE connections to gnome-session with invalid authentication data (an invalid magic cookie). Each failed authentication attempt will leak a file descriptor in gnome-session. When the maximum number of file descriptors is exhausted in the gnome-session process, it will enter an infinite loop trying to communicate without success, consuming 100% of the CPU. The graphical session associated with the gnome-session process will stop working correctly, because communication with gnome-session is no longer possible.",2019-10-02,,0,https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d,b0dc999e0b45355314616321dbb6cb71e729fc9d,"[gsm] Delay the creation of the GsmXSMPClient until it really exists

We used to create the GsmXSMPClient before the XSMP connection is really
accepted. This can lead to some issues, though. An example is:
https://bugzilla.gnome.org/show_bug.cgi?id=598211#c19. Quoting:

 ""What is happening is that a new client (probably metacity in your
 case) is opening an ICE connection in the GSM_MANAGER_PHASE_END_SESSION
 phase, which causes a new GsmXSMPClient to be added to the client
 store. The GSM_MANAGER_PHASE_EXIT phase then begins before the client
 has had a chance to establish a xsmp connection, which means that
 client->priv->conn will not be initialized at the point that xsmp_stop
 is called on the new unregistered client.""

The fix is to create the GsmXSMPClient object when there's a real XSMP
connection. This implies moving the timeout that makes sure we don't
have an empty client to the XSMP server.

https://bugzilla.gnome.org/show_bug.cgi?id=598211",3,gnome-session/gsm-xsmp-client.c,"{""sha"": ""9da5fdc06ea8d46b29a5f0cdb172ce3d9b4a326c"", ""filename"": ""gnome-session/gsm-xsmp-client.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 30, ""changes"": 30, ""blob_url"": ""https://github.com/GNOME/gnome-session/blob/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-client.c"", ""raw_url"": ""https://github.com/GNOME/gnome-session/raw/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-client.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/gnome-session/contents/gnome-session/gsm-xsmp-client.c?ref=b0dc999e0b45355314616321dbb6cb71e729fc9d"", ""patch"": ""@@ -51,7 +51,6 @@ struct GsmXSMPClientPrivate\n         IceConn    ice_connection;\n \n         guint      watch_id;\n-        guint      protocol_timeout;\n \n         char      *description;\n         GPtrArray *props;\n@@ -115,22 +114,6 @@ client_iochannel_watch (GIOChannel    *channel,\n         return keep_going;\n }\n \n-/* Called if too much time passes between the initial connection and\n- * the XSMP protocol setup.\n- */\n-static gboolean\n-_client_protocol_timeout (GsmXSMPClient *client)\n-{\n-        g_debug (\""GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d\"",\n-                 client->priv->description,\n-                 IceConnectionStatus (client->priv->ice_connection));\n-\n-        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);\n-        gsm_client_disconnected (GSM_CLIENT (client));\n-\n-        return FALSE;\n-}\n-\n static SmProp *\n find_property (GsmXSMPClient *client,\n                const char    *name,\n@@ -193,10 +176,6 @@ setup_connection (GsmXSMPClient *client)\n                                                  client);\n         g_io_channel_unref (channel);\n \n-        client->priv->protocol_timeout = g_timeout_add_seconds (5,\n-                                                                (GSourceFunc)_client_protocol_timeout,\n-                                                                client);\n-\n         set_description (client);\n \n         g_debug (\""GsmXSMPClient: New client '%s'\"", client->priv->description);\n@@ -869,10 +848,6 @@ gsm_xsmp_client_disconnect (GsmXSMPClient *client)\n                 IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);\n                 IceCloseConnection (client->priv->ice_connection);\n         }\n-\n-        if (client->priv->protocol_timeout > 0) {\n-                g_source_remove (client->priv->protocol_timeout);\n-        }\n }\n \n static void\n@@ -1305,11 +1280,6 @@ gsm_xsmp_client_connect (GsmXSMPClient *client,\n {\n         client->priv->conn = conn;\n \n-        if (client->priv->protocol_timeout) {\n-                g_source_remove (client->priv->protocol_timeout);\n-                client->priv->protocol_timeout = 0;\n-        }\n-\n         g_debug (\""GsmXSMPClient: Initializing client %s\"", client->priv->description);\n \n         *mask_ret = 0;""}<_**next**_>{""sha"": ""1f0e04554982efbb283e1be102867bef03921cfd"", ""filename"": ""gnome-session/gsm-xsmp-server.c"", ""status"": ""modified"", ""additions"": 124, ""deletions"": 26, ""changes"": 150, ""blob_url"": ""https://github.com/GNOME/gnome-session/blob/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-server.c"", ""raw_url"": ""https://github.com/GNOME/gnome-session/raw/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-server.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/gnome-session/contents/gnome-session/gsm-xsmp-server.c?ref=b0dc999e0b45355314616321dbb6cb71e729fc9d"", ""patch"": ""@@ -91,44 +91,134 @@ typedef struct {\n         IceListenObj   listener;\n } GsmIceConnectionData;\n \n+typedef struct {\n+        guint watch_id;\n+        guint protocol_timeout;\n+} GsmIceConnectionWatch;\n+\n+static void\n+disconnect_ice_connection (IceConn ice_conn)\n+{\n+        IceSetShutdownNegotiation (ice_conn, FALSE);\n+        IceCloseConnection (ice_conn);\n+}\n+\n+static void\n+free_ice_connection_watch (GsmIceConnectionWatch *data)\n+{\n+        if (data->watch_id) {\n+                g_source_remove (data->watch_id);\n+                data->watch_id = 0;\n+        }\n+\n+        if (data->protocol_timeout) {\n+                g_source_remove (data->protocol_timeout);\n+                data->protocol_timeout = 0;\n+        }\n+\n+        g_free (data);\n+}\n+\n+static gboolean\n+ice_protocol_timeout (IceConn ice_conn)\n+{\n+        GsmIceConnectionWatch *data;\n+\n+        g_debug (\""GsmXsmpServer: ice_protocol_timeout for IceConn %p with status %d\"",\n+                 ice_conn, IceConnectionStatus (ice_conn));\n+\n+        data = ice_conn->context;\n+\n+        free_ice_connection_watch (data);\n+        disconnect_ice_connection (ice_conn);\n+\n+        return FALSE;\n+}\n+\n+static gboolean\n+auth_iochannel_watch (GIOChannel   *source,\n+                      GIOCondition  condition,\n+                      IceConn       ice_conn)\n+{\n+\n+        GsmIceConnectionWatch *data;\n+        gboolean               keep_going;\n+\n+        data = ice_conn->context;\n+\n+        switch (IceProcessMessages (ice_conn, NULL, NULL)) {\n+        case IceProcessMessagesSuccess:\n+                keep_going = TRUE;\n+                break;\n+        case IceProcessMessagesIOError:\n+                g_debug (\""GsmXsmpServer: IceProcessMessages returned IceProcessMessagesIOError\"");\n+                free_ice_connection_watch (data);\n+                disconnect_ice_connection (ice_conn);\n+                keep_going = FALSE;\n+                break;\n+        case IceProcessMessagesConnectionClosed:\n+                g_debug (\""GsmXsmpServer: IceProcessMessages returned IceProcessMessagesConnectionClosed\"");\n+                free_ice_connection_watch (data);\n+                keep_going = FALSE;\n+                break;\n+        default:\n+                g_assert_not_reached ();\n+        }\n+\n+        return keep_going;\n+}\n+\n+/* IceAcceptConnection returns a new ICE connection that is in a \""pending\"" state,\n+ * this is because authentification may be necessary.\n+ * So we've to authenticate it, before accept_xsmp_connection() is called.\n+ * Then each GsmXSMPClient will have its own IceConn watcher\n+ */\n+static void\n+auth_ice_connection (IceConn ice_conn)\n+{\n+        GIOChannel            *channel;\n+        GsmIceConnectionWatch *data;\n+        int                    fd;\n+\n+        g_debug (\""GsmXsmpServer: auth_ice_connection()\"");\n+\n+        fd = IceConnectionNumber (ice_conn);\n+        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n+        channel = g_io_channel_unix_new (fd);\n+\n+        data = g_new0 (GsmIceConnectionWatch, 1);\n+        ice_conn->context = data;\n+\n+        data->protocol_timeout = g_timeout_add_seconds (5,\n+                                                        (GSourceFunc)ice_protocol_timeout,\n+                                                        ice_conn);\n+        data->watch_id = g_io_add_watch (channel,\n+                                         G_IO_IN | G_IO_ERR,\n+                                         (GIOFunc)auth_iochannel_watch,\n+                                         ice_conn);\n+        g_io_channel_unref (channel);\n+}\n+\n /* This is called (by glib via xsmp->ice_connection_watch) when a\n- * connection is first received on the ICE listening socket. (We\n- * expect that the client will then initiate XSMP on the connection;\n- * if it does not, GsmXSMPClient will eventually time out and close\n- * the connection.)\n- *\n- * FIXME: it would probably make more sense to not create a\n- * GsmXSMPClient object until accept_xsmp_connection, below (and to do\n- * the timing-out here in xsmp.c).\n+ * connection is first received on the ICE listening socket.\n  */\n static gboolean\n accept_ice_connection (GIOChannel           *source,\n                        GIOCondition          condition,\n                        GsmIceConnectionData *data)\n {\n-        IceListenObj    listener;\n         IceConn         ice_conn;\n         IceAcceptStatus status;\n-        GsmClient      *client;\n-        GsmXsmpServer  *server;\n-\n-        listener = data->listener;\n-        server = data->server;\n \n         g_debug (\""GsmXsmpServer: accept_ice_connection()\"");\n \n-        ice_conn = IceAcceptConnection (listener, &status);\n+        ice_conn = IceAcceptConnection (data->listener, &status);\n         if (status != IceAcceptSuccess) {\n                 g_debug (\""GsmXsmpServer: IceAcceptConnection returned %d\"", status);\n                 return TRUE;\n         }\n \n-        client = gsm_xsmp_client_new (ice_conn);\n-        ice_conn->context = client;\n-\n-        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n-        /* the store will own the ref */\n-        g_object_unref (client);\n+        auth_ice_connection (ice_conn);\n \n         return TRUE;\n }\n@@ -224,8 +314,9 @@ accept_xsmp_connection (SmsConn        sms_conn,\n                         SmsCallbacks  *callbacks_ret,\n                         char         **failure_reason_ret)\n {\n-        IceConn        ice_conn;\n-        GsmXSMPClient *client;\n+        IceConn                ice_conn;\n+        GsmClient             *client;\n+        GsmIceConnectionWatch *data;\n \n         /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */\n         if (server->priv->xsmp_sockets == NULL) {\n@@ -236,11 +327,18 @@ accept_xsmp_connection (SmsConn        sms_conn,\n         }\n \n         ice_conn = SmsGetIceConnection (sms_conn);\n-        client = ice_conn->context;\n+        data = ice_conn->context;\n \n-        g_return_val_if_fail (client != NULL, TRUE);\n+        /* Each GsmXSMPClient has its own IceConn watcher */\n+        free_ice_connection_watch (data);\n+\n+        client = gsm_xsmp_client_new (ice_conn);\n+\n+        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n+        /* the store will own the ref */\n+        g_object_unref (client);\n \n-        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n+        gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);\n \n         return TRUE;\n }""}","gsm_xsmp_client_disconnect (GsmXSMPClient *client)
{
        if (client->priv->watch_id > 0) {
                g_source_remove (client->priv->watch_id);
        }

        if (client->priv->conn != NULL) {
                SmsCleanUp (client->priv->conn);
        }

        if (client->priv->ice_connection != NULL) {
                 IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);
                 IceCloseConnection (client->priv->ice_connection);
         }
 }
","gsm_xsmp_client_disconnect (GsmXSMPClient *client)
{
        if (client->priv->watch_id > 0) {
                g_source_remove (client->priv->watch_id);
        }

        if (client->priv->conn != NULL) {
                SmsCleanUp (client->priv->conn);
        }

        if (client->priv->ice_connection != NULL) {
                 IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);
                 IceCloseConnection (client->priv->ice_connection);
         }
        if (client->priv->protocol_timeout > 0) {
                g_source_remove (client->priv->protocol_timeout);
        }
 }
",C,,"        if (client->priv->protocol_timeout > 0) {
                g_source_remove (client->priv->protocol_timeout);
        }
",,"@@ -51,7 +51,6 @@ struct GsmXSMPClientPrivate
         IceConn    ice_connection;
 
         guint      watch_id;
-        guint      protocol_timeout;
 
         char      *description;
         GPtrArray *props;
@@ -115,22 +114,6 @@ client_iochannel_watch (GIOChannel    *channel,
         return keep_going;
 }
 
-/* Called if too much time passes between the initial connection and
- * the XSMP protocol setup.
- */
-static gboolean
-_client_protocol_timeout (GsmXSMPClient *client)
-{
-        g_debug (""GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d"",
-                 client->priv->description,
-                 IceConnectionStatus (client->priv->ice_connection));
-
-        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);
-        gsm_client_disconnected (GSM_CLIENT (client));
-
-        return FALSE;
-}
-
 static SmProp *
 find_property (GsmXSMPClient *client,
                const char    *name,
@@ -193,10 +176,6 @@ setup_connection (GsmXSMPClient *client)
                                                  client);
         g_io_channel_unref (channel);
 
-        client->priv->protocol_timeout = g_timeout_add_seconds (5,
-                                                                (GSourceFunc)_client_protocol_timeout,
-                                                                client);
-
         set_description (client);
 
         g_debug (""GsmXSMPClient: New client '%s'"", client->priv->description);
@@ -869,10 +848,6 @@ gsm_xsmp_client_disconnect (GsmXSMPClient *client)
                 IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);
                 IceCloseConnection (client->priv->ice_connection);
         }
-
-        if (client->priv->protocol_timeout > 0) {
-                g_source_remove (client->priv->protocol_timeout);
-        }
 }
 
 static void
@@ -1305,11 +1280,6 @@ gsm_xsmp_client_connect (GsmXSMPClient *client,
 {
         client->priv->conn = conn;
 
-        if (client->priv->protocol_timeout) {
-                g_source_remove (client->priv->protocol_timeout);
-                client->priv->protocol_timeout = 0;
-        }
-
         g_debug (""GsmXSMPClient: Initializing client %s"", client->priv->description);
 
         *mask_ret = 0;",gnome-session,b0dc999e0b45355314616321dbb6cb71e729fc9d,5198aa08d2b77204cd8bf669a64f2e044d9a9e0d,1,"gsm_xsmp_client_disconnect (GsmXSMPClient *client)
{
        if (client->priv->watch_id > 0) {
                g_source_remove (client->priv->watch_id);
        }

        if (client->priv->conn != NULL) {
                SmsCleanUp (client->priv->conn);
        }

        if (client->priv->ice_connection != NULL) {
                 IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);
                 IceCloseConnection (client->priv->ice_connection);
         }
//flaw_line_below:

//flaw_line_below:
        if (client->priv->protocol_timeout > 0) {
//flaw_line_below:
                g_source_remove (client->priv->protocol_timeout);
//flaw_line_below:
        }
 }
"
3487,181223,,Local,Not required,Complete,CVE-2017-11171,https://www.cvedetails.com/cve/CVE-2017-11171/,CWE-835,Low,,,,2017-07-11,4.9,"Bad reference counting in the context of accept_ice_connection() in gsm-xsmp-server.c in old versions of gnome-session up until version 2.29.92 allows a local attacker to establish ICE connections to gnome-session with invalid authentication data (an invalid magic cookie). Each failed authentication attempt will leak a file descriptor in gnome-session. When the maximum number of file descriptors is exhausted in the gnome-session process, it will enter an infinite loop trying to communicate without success, consuming 100% of the CPU. The graphical session associated with the gnome-session process will stop working correctly, because communication with gnome-session is no longer possible.",2019-10-02,,0,https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d,b0dc999e0b45355314616321dbb6cb71e729fc9d,"[gsm] Delay the creation of the GsmXSMPClient until it really exists

We used to create the GsmXSMPClient before the XSMP connection is really
accepted. This can lead to some issues, though. An example is:
https://bugzilla.gnome.org/show_bug.cgi?id=598211#c19. Quoting:

 ""What is happening is that a new client (probably metacity in your
 case) is opening an ICE connection in the GSM_MANAGER_PHASE_END_SESSION
 phase, which causes a new GsmXSMPClient to be added to the client
 store. The GSM_MANAGER_PHASE_EXIT phase then begins before the client
 has had a chance to establish a xsmp connection, which means that
 client->priv->conn will not be initialized at the point that xsmp_stop
 is called on the new unregistered client.""

The fix is to create the GsmXSMPClient object when there's a real XSMP
connection. This implies moving the timeout that makes sure we don't
have an empty client to the XSMP server.

https://bugzilla.gnome.org/show_bug.cgi?id=598211",3,gnome-session/gsm-xsmp-client.c,"{""sha"": ""9da5fdc06ea8d46b29a5f0cdb172ce3d9b4a326c"", ""filename"": ""gnome-session/gsm-xsmp-client.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 30, ""changes"": 30, ""blob_url"": ""https://github.com/GNOME/gnome-session/blob/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-client.c"", ""raw_url"": ""https://github.com/GNOME/gnome-session/raw/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-client.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/gnome-session/contents/gnome-session/gsm-xsmp-client.c?ref=b0dc999e0b45355314616321dbb6cb71e729fc9d"", ""patch"": ""@@ -51,7 +51,6 @@ struct GsmXSMPClientPrivate\n         IceConn    ice_connection;\n \n         guint      watch_id;\n-        guint      protocol_timeout;\n \n         char      *description;\n         GPtrArray *props;\n@@ -115,22 +114,6 @@ client_iochannel_watch (GIOChannel    *channel,\n         return keep_going;\n }\n \n-/* Called if too much time passes between the initial connection and\n- * the XSMP protocol setup.\n- */\n-static gboolean\n-_client_protocol_timeout (GsmXSMPClient *client)\n-{\n-        g_debug (\""GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d\"",\n-                 client->priv->description,\n-                 IceConnectionStatus (client->priv->ice_connection));\n-\n-        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);\n-        gsm_client_disconnected (GSM_CLIENT (client));\n-\n-        return FALSE;\n-}\n-\n static SmProp *\n find_property (GsmXSMPClient *client,\n                const char    *name,\n@@ -193,10 +176,6 @@ setup_connection (GsmXSMPClient *client)\n                                                  client);\n         g_io_channel_unref (channel);\n \n-        client->priv->protocol_timeout = g_timeout_add_seconds (5,\n-                                                                (GSourceFunc)_client_protocol_timeout,\n-                                                                client);\n-\n         set_description (client);\n \n         g_debug (\""GsmXSMPClient: New client '%s'\"", client->priv->description);\n@@ -869,10 +848,6 @@ gsm_xsmp_client_disconnect (GsmXSMPClient *client)\n                 IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);\n                 IceCloseConnection (client->priv->ice_connection);\n         }\n-\n-        if (client->priv->protocol_timeout > 0) {\n-                g_source_remove (client->priv->protocol_timeout);\n-        }\n }\n \n static void\n@@ -1305,11 +1280,6 @@ gsm_xsmp_client_connect (GsmXSMPClient *client,\n {\n         client->priv->conn = conn;\n \n-        if (client->priv->protocol_timeout) {\n-                g_source_remove (client->priv->protocol_timeout);\n-                client->priv->protocol_timeout = 0;\n-        }\n-\n         g_debug (\""GsmXSMPClient: Initializing client %s\"", client->priv->description);\n \n         *mask_ret = 0;""}<_**next**_>{""sha"": ""1f0e04554982efbb283e1be102867bef03921cfd"", ""filename"": ""gnome-session/gsm-xsmp-server.c"", ""status"": ""modified"", ""additions"": 124, ""deletions"": 26, ""changes"": 150, ""blob_url"": ""https://github.com/GNOME/gnome-session/blob/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-server.c"", ""raw_url"": ""https://github.com/GNOME/gnome-session/raw/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-server.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/gnome-session/contents/gnome-session/gsm-xsmp-server.c?ref=b0dc999e0b45355314616321dbb6cb71e729fc9d"", ""patch"": ""@@ -91,44 +91,134 @@ typedef struct {\n         IceListenObj   listener;\n } GsmIceConnectionData;\n \n+typedef struct {\n+        guint watch_id;\n+        guint protocol_timeout;\n+} GsmIceConnectionWatch;\n+\n+static void\n+disconnect_ice_connection (IceConn ice_conn)\n+{\n+        IceSetShutdownNegotiation (ice_conn, FALSE);\n+        IceCloseConnection (ice_conn);\n+}\n+\n+static void\n+free_ice_connection_watch (GsmIceConnectionWatch *data)\n+{\n+        if (data->watch_id) {\n+                g_source_remove (data->watch_id);\n+                data->watch_id = 0;\n+        }\n+\n+        if (data->protocol_timeout) {\n+                g_source_remove (data->protocol_timeout);\n+                data->protocol_timeout = 0;\n+        }\n+\n+        g_free (data);\n+}\n+\n+static gboolean\n+ice_protocol_timeout (IceConn ice_conn)\n+{\n+        GsmIceConnectionWatch *data;\n+\n+        g_debug (\""GsmXsmpServer: ice_protocol_timeout for IceConn %p with status %d\"",\n+                 ice_conn, IceConnectionStatus (ice_conn));\n+\n+        data = ice_conn->context;\n+\n+        free_ice_connection_watch (data);\n+        disconnect_ice_connection (ice_conn);\n+\n+        return FALSE;\n+}\n+\n+static gboolean\n+auth_iochannel_watch (GIOChannel   *source,\n+                      GIOCondition  condition,\n+                      IceConn       ice_conn)\n+{\n+\n+        GsmIceConnectionWatch *data;\n+        gboolean               keep_going;\n+\n+        data = ice_conn->context;\n+\n+        switch (IceProcessMessages (ice_conn, NULL, NULL)) {\n+        case IceProcessMessagesSuccess:\n+                keep_going = TRUE;\n+                break;\n+        case IceProcessMessagesIOError:\n+                g_debug (\""GsmXsmpServer: IceProcessMessages returned IceProcessMessagesIOError\"");\n+                free_ice_connection_watch (data);\n+                disconnect_ice_connection (ice_conn);\n+                keep_going = FALSE;\n+                break;\n+        case IceProcessMessagesConnectionClosed:\n+                g_debug (\""GsmXsmpServer: IceProcessMessages returned IceProcessMessagesConnectionClosed\"");\n+                free_ice_connection_watch (data);\n+                keep_going = FALSE;\n+                break;\n+        default:\n+                g_assert_not_reached ();\n+        }\n+\n+        return keep_going;\n+}\n+\n+/* IceAcceptConnection returns a new ICE connection that is in a \""pending\"" state,\n+ * this is because authentification may be necessary.\n+ * So we've to authenticate it, before accept_xsmp_connection() is called.\n+ * Then each GsmXSMPClient will have its own IceConn watcher\n+ */\n+static void\n+auth_ice_connection (IceConn ice_conn)\n+{\n+        GIOChannel            *channel;\n+        GsmIceConnectionWatch *data;\n+        int                    fd;\n+\n+        g_debug (\""GsmXsmpServer: auth_ice_connection()\"");\n+\n+        fd = IceConnectionNumber (ice_conn);\n+        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n+        channel = g_io_channel_unix_new (fd);\n+\n+        data = g_new0 (GsmIceConnectionWatch, 1);\n+        ice_conn->context = data;\n+\n+        data->protocol_timeout = g_timeout_add_seconds (5,\n+                                                        (GSourceFunc)ice_protocol_timeout,\n+                                                        ice_conn);\n+        data->watch_id = g_io_add_watch (channel,\n+                                         G_IO_IN | G_IO_ERR,\n+                                         (GIOFunc)auth_iochannel_watch,\n+                                         ice_conn);\n+        g_io_channel_unref (channel);\n+}\n+\n /* This is called (by glib via xsmp->ice_connection_watch) when a\n- * connection is first received on the ICE listening socket. (We\n- * expect that the client will then initiate XSMP on the connection;\n- * if it does not, GsmXSMPClient will eventually time out and close\n- * the connection.)\n- *\n- * FIXME: it would probably make more sense to not create a\n- * GsmXSMPClient object until accept_xsmp_connection, below (and to do\n- * the timing-out here in xsmp.c).\n+ * connection is first received on the ICE listening socket.\n  */\n static gboolean\n accept_ice_connection (GIOChannel           *source,\n                        GIOCondition          condition,\n                        GsmIceConnectionData *data)\n {\n-        IceListenObj    listener;\n         IceConn         ice_conn;\n         IceAcceptStatus status;\n-        GsmClient      *client;\n-        GsmXsmpServer  *server;\n-\n-        listener = data->listener;\n-        server = data->server;\n \n         g_debug (\""GsmXsmpServer: accept_ice_connection()\"");\n \n-        ice_conn = IceAcceptConnection (listener, &status);\n+        ice_conn = IceAcceptConnection (data->listener, &status);\n         if (status != IceAcceptSuccess) {\n                 g_debug (\""GsmXsmpServer: IceAcceptConnection returned %d\"", status);\n                 return TRUE;\n         }\n \n-        client = gsm_xsmp_client_new (ice_conn);\n-        ice_conn->context = client;\n-\n-        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n-        /* the store will own the ref */\n-        g_object_unref (client);\n+        auth_ice_connection (ice_conn);\n \n         return TRUE;\n }\n@@ -224,8 +314,9 @@ accept_xsmp_connection (SmsConn        sms_conn,\n                         SmsCallbacks  *callbacks_ret,\n                         char         **failure_reason_ret)\n {\n-        IceConn        ice_conn;\n-        GsmXSMPClient *client;\n+        IceConn                ice_conn;\n+        GsmClient             *client;\n+        GsmIceConnectionWatch *data;\n \n         /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */\n         if (server->priv->xsmp_sockets == NULL) {\n@@ -236,11 +327,18 @@ accept_xsmp_connection (SmsConn        sms_conn,\n         }\n \n         ice_conn = SmsGetIceConnection (sms_conn);\n-        client = ice_conn->context;\n+        data = ice_conn->context;\n \n-        g_return_val_if_fail (client != NULL, TRUE);\n+        /* Each GsmXSMPClient has its own IceConn watcher */\n+        free_ice_connection_watch (data);\n+\n+        client = gsm_xsmp_client_new (ice_conn);\n+\n+        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n+        /* the store will own the ref */\n+        g_object_unref (client);\n \n-        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n+        gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);\n \n         return TRUE;\n }""}","setup_connection (GsmXSMPClient *client)
{
        GIOChannel    *channel;
        int            fd;

        g_debug (""GsmXSMPClient: Setting up new connection"");

        fd = IceConnectionNumber (client->priv->ice_connection);
        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);
        channel = g_io_channel_unix_new (fd);
        client->priv->watch_id = g_io_add_watch (channel,
                                                 G_IO_IN | G_IO_ERR,
                                                 (GIOFunc)client_iochannel_watch,
                                                  client);
         g_io_channel_unref (channel);
 
         set_description (client);
 
         g_debug (""GsmXSMPClient: New client '%s'"", client->priv->description);
}
","setup_connection (GsmXSMPClient *client)
{
        GIOChannel    *channel;
        int            fd;

        g_debug (""GsmXSMPClient: Setting up new connection"");

        fd = IceConnectionNumber (client->priv->ice_connection);
        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);
        channel = g_io_channel_unix_new (fd);
        client->priv->watch_id = g_io_add_watch (channel,
                                                 G_IO_IN | G_IO_ERR,
                                                 (GIOFunc)client_iochannel_watch,
                                                  client);
         g_io_channel_unref (channel);
 
        client->priv->protocol_timeout = g_timeout_add_seconds (5,
                                                                (GSourceFunc)_client_protocol_timeout,
                                                                client);
         set_description (client);
 
         g_debug (""GsmXSMPClient: New client '%s'"", client->priv->description);
}
",C,,"        client->priv->protocol_timeout = g_timeout_add_seconds (5,
                                                                (GSourceFunc)_client_protocol_timeout,
                                                                client);
",,"@@ -51,7 +51,6 @@ struct GsmXSMPClientPrivate
         IceConn    ice_connection;
 
         guint      watch_id;
-        guint      protocol_timeout;
 
         char      *description;
         GPtrArray *props;
@@ -115,22 +114,6 @@ client_iochannel_watch (GIOChannel    *channel,
         return keep_going;
 }
 
-/* Called if too much time passes between the initial connection and
- * the XSMP protocol setup.
- */
-static gboolean
-_client_protocol_timeout (GsmXSMPClient *client)
-{
-        g_debug (""GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d"",
-                 client->priv->description,
-                 IceConnectionStatus (client->priv->ice_connection));
-
-        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);
-        gsm_client_disconnected (GSM_CLIENT (client));
-
-        return FALSE;
-}
-
 static SmProp *
 find_property (GsmXSMPClient *client,
                const char    *name,
@@ -193,10 +176,6 @@ setup_connection (GsmXSMPClient *client)
                                                  client);
         g_io_channel_unref (channel);
 
-        client->priv->protocol_timeout = g_timeout_add_seconds (5,
-                                                                (GSourceFunc)_client_protocol_timeout,
-                                                                client);
-
         set_description (client);
 
         g_debug (""GsmXSMPClient: New client '%s'"", client->priv->description);
@@ -869,10 +848,6 @@ gsm_xsmp_client_disconnect (GsmXSMPClient *client)
                 IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);
                 IceCloseConnection (client->priv->ice_connection);
         }
-
-        if (client->priv->protocol_timeout > 0) {
-                g_source_remove (client->priv->protocol_timeout);
-        }
 }
 
 static void
@@ -1305,11 +1280,6 @@ gsm_xsmp_client_connect (GsmXSMPClient *client,
 {
         client->priv->conn = conn;
 
-        if (client->priv->protocol_timeout) {
-                g_source_remove (client->priv->protocol_timeout);
-                client->priv->protocol_timeout = 0;
-        }
-
         g_debug (""GsmXSMPClient: Initializing client %s"", client->priv->description);
 
         *mask_ret = 0;",gnome-session,b0dc999e0b45355314616321dbb6cb71e729fc9d,5198aa08d2b77204cd8bf669a64f2e044d9a9e0d,1,"setup_connection (GsmXSMPClient *client)
{
        GIOChannel    *channel;
        int            fd;

        g_debug (""GsmXSMPClient: Setting up new connection"");

        fd = IceConnectionNumber (client->priv->ice_connection);
        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);
        channel = g_io_channel_unix_new (fd);
        client->priv->watch_id = g_io_add_watch (channel,
                                                 G_IO_IN | G_IO_ERR,
                                                 (GIOFunc)client_iochannel_watch,
                                                  client);
         g_io_channel_unref (channel);
 
//flaw_line_below:
        client->priv->protocol_timeout = g_timeout_add_seconds (5,
//flaw_line_below:
                                                                (GSourceFunc)_client_protocol_timeout,
//flaw_line_below:
                                                                client);
//flaw_line_below:

         set_description (client);
 
         g_debug (""GsmXSMPClient: New client '%s'"", client->priv->description);
}
"
3488,181224,,Local,Not required,Complete,CVE-2017-11171,https://www.cvedetails.com/cve/CVE-2017-11171/,CWE-835,Low,,,,2017-07-11,4.9,"Bad reference counting in the context of accept_ice_connection() in gsm-xsmp-server.c in old versions of gnome-session up until version 2.29.92 allows a local attacker to establish ICE connections to gnome-session with invalid authentication data (an invalid magic cookie). Each failed authentication attempt will leak a file descriptor in gnome-session. When the maximum number of file descriptors is exhausted in the gnome-session process, it will enter an infinite loop trying to communicate without success, consuming 100% of the CPU. The graphical session associated with the gnome-session process will stop working correctly, because communication with gnome-session is no longer possible.",2019-10-02,,2,https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d,b0dc999e0b45355314616321dbb6cb71e729fc9d,"[gsm] Delay the creation of the GsmXSMPClient until it really exists

We used to create the GsmXSMPClient before the XSMP connection is really
accepted. This can lead to some issues, though. An example is:
https://bugzilla.gnome.org/show_bug.cgi?id=598211#c19. Quoting:

 ""What is happening is that a new client (probably metacity in your
 case) is opening an ICE connection in the GSM_MANAGER_PHASE_END_SESSION
 phase, which causes a new GsmXSMPClient to be added to the client
 store. The GSM_MANAGER_PHASE_EXIT phase then begins before the client
 has had a chance to establish a xsmp connection, which means that
 client->priv->conn will not be initialized at the point that xsmp_stop
 is called on the new unregistered client.""

The fix is to create the GsmXSMPClient object when there's a real XSMP
connection. This implies moving the timeout that makes sure we don't
have an empty client to the XSMP server.

https://bugzilla.gnome.org/show_bug.cgi?id=598211",11,gnome-session/gsm-xsmp-server.c,"{""sha"": ""9da5fdc06ea8d46b29a5f0cdb172ce3d9b4a326c"", ""filename"": ""gnome-session/gsm-xsmp-client.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 30, ""changes"": 30, ""blob_url"": ""https://github.com/GNOME/gnome-session/blob/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-client.c"", ""raw_url"": ""https://github.com/GNOME/gnome-session/raw/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-client.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/gnome-session/contents/gnome-session/gsm-xsmp-client.c?ref=b0dc999e0b45355314616321dbb6cb71e729fc9d"", ""patch"": ""@@ -51,7 +51,6 @@ struct GsmXSMPClientPrivate\n         IceConn    ice_connection;\n \n         guint      watch_id;\n-        guint      protocol_timeout;\n \n         char      *description;\n         GPtrArray *props;\n@@ -115,22 +114,6 @@ client_iochannel_watch (GIOChannel    *channel,\n         return keep_going;\n }\n \n-/* Called if too much time passes between the initial connection and\n- * the XSMP protocol setup.\n- */\n-static gboolean\n-_client_protocol_timeout (GsmXSMPClient *client)\n-{\n-        g_debug (\""GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d\"",\n-                 client->priv->description,\n-                 IceConnectionStatus (client->priv->ice_connection));\n-\n-        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);\n-        gsm_client_disconnected (GSM_CLIENT (client));\n-\n-        return FALSE;\n-}\n-\n static SmProp *\n find_property (GsmXSMPClient *client,\n                const char    *name,\n@@ -193,10 +176,6 @@ setup_connection (GsmXSMPClient *client)\n                                                  client);\n         g_io_channel_unref (channel);\n \n-        client->priv->protocol_timeout = g_timeout_add_seconds (5,\n-                                                                (GSourceFunc)_client_protocol_timeout,\n-                                                                client);\n-\n         set_description (client);\n \n         g_debug (\""GsmXSMPClient: New client '%s'\"", client->priv->description);\n@@ -869,10 +848,6 @@ gsm_xsmp_client_disconnect (GsmXSMPClient *client)\n                 IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);\n                 IceCloseConnection (client->priv->ice_connection);\n         }\n-\n-        if (client->priv->protocol_timeout > 0) {\n-                g_source_remove (client->priv->protocol_timeout);\n-        }\n }\n \n static void\n@@ -1305,11 +1280,6 @@ gsm_xsmp_client_connect (GsmXSMPClient *client,\n {\n         client->priv->conn = conn;\n \n-        if (client->priv->protocol_timeout) {\n-                g_source_remove (client->priv->protocol_timeout);\n-                client->priv->protocol_timeout = 0;\n-        }\n-\n         g_debug (\""GsmXSMPClient: Initializing client %s\"", client->priv->description);\n \n         *mask_ret = 0;""}<_**next**_>{""sha"": ""1f0e04554982efbb283e1be102867bef03921cfd"", ""filename"": ""gnome-session/gsm-xsmp-server.c"", ""status"": ""modified"", ""additions"": 124, ""deletions"": 26, ""changes"": 150, ""blob_url"": ""https://github.com/GNOME/gnome-session/blob/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-server.c"", ""raw_url"": ""https://github.com/GNOME/gnome-session/raw/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-server.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/gnome-session/contents/gnome-session/gsm-xsmp-server.c?ref=b0dc999e0b45355314616321dbb6cb71e729fc9d"", ""patch"": ""@@ -91,44 +91,134 @@ typedef struct {\n         IceListenObj   listener;\n } GsmIceConnectionData;\n \n+typedef struct {\n+        guint watch_id;\n+        guint protocol_timeout;\n+} GsmIceConnectionWatch;\n+\n+static void\n+disconnect_ice_connection (IceConn ice_conn)\n+{\n+        IceSetShutdownNegotiation (ice_conn, FALSE);\n+        IceCloseConnection (ice_conn);\n+}\n+\n+static void\n+free_ice_connection_watch (GsmIceConnectionWatch *data)\n+{\n+        if (data->watch_id) {\n+                g_source_remove (data->watch_id);\n+                data->watch_id = 0;\n+        }\n+\n+        if (data->protocol_timeout) {\n+                g_source_remove (data->protocol_timeout);\n+                data->protocol_timeout = 0;\n+        }\n+\n+        g_free (data);\n+}\n+\n+static gboolean\n+ice_protocol_timeout (IceConn ice_conn)\n+{\n+        GsmIceConnectionWatch *data;\n+\n+        g_debug (\""GsmXsmpServer: ice_protocol_timeout for IceConn %p with status %d\"",\n+                 ice_conn, IceConnectionStatus (ice_conn));\n+\n+        data = ice_conn->context;\n+\n+        free_ice_connection_watch (data);\n+        disconnect_ice_connection (ice_conn);\n+\n+        return FALSE;\n+}\n+\n+static gboolean\n+auth_iochannel_watch (GIOChannel   *source,\n+                      GIOCondition  condition,\n+                      IceConn       ice_conn)\n+{\n+\n+        GsmIceConnectionWatch *data;\n+        gboolean               keep_going;\n+\n+        data = ice_conn->context;\n+\n+        switch (IceProcessMessages (ice_conn, NULL, NULL)) {\n+        case IceProcessMessagesSuccess:\n+                keep_going = TRUE;\n+                break;\n+        case IceProcessMessagesIOError:\n+                g_debug (\""GsmXsmpServer: IceProcessMessages returned IceProcessMessagesIOError\"");\n+                free_ice_connection_watch (data);\n+                disconnect_ice_connection (ice_conn);\n+                keep_going = FALSE;\n+                break;\n+        case IceProcessMessagesConnectionClosed:\n+                g_debug (\""GsmXsmpServer: IceProcessMessages returned IceProcessMessagesConnectionClosed\"");\n+                free_ice_connection_watch (data);\n+                keep_going = FALSE;\n+                break;\n+        default:\n+                g_assert_not_reached ();\n+        }\n+\n+        return keep_going;\n+}\n+\n+/* IceAcceptConnection returns a new ICE connection that is in a \""pending\"" state,\n+ * this is because authentification may be necessary.\n+ * So we've to authenticate it, before accept_xsmp_connection() is called.\n+ * Then each GsmXSMPClient will have its own IceConn watcher\n+ */\n+static void\n+auth_ice_connection (IceConn ice_conn)\n+{\n+        GIOChannel            *channel;\n+        GsmIceConnectionWatch *data;\n+        int                    fd;\n+\n+        g_debug (\""GsmXsmpServer: auth_ice_connection()\"");\n+\n+        fd = IceConnectionNumber (ice_conn);\n+        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n+        channel = g_io_channel_unix_new (fd);\n+\n+        data = g_new0 (GsmIceConnectionWatch, 1);\n+        ice_conn->context = data;\n+\n+        data->protocol_timeout = g_timeout_add_seconds (5,\n+                                                        (GSourceFunc)ice_protocol_timeout,\n+                                                        ice_conn);\n+        data->watch_id = g_io_add_watch (channel,\n+                                         G_IO_IN | G_IO_ERR,\n+                                         (GIOFunc)auth_iochannel_watch,\n+                                         ice_conn);\n+        g_io_channel_unref (channel);\n+}\n+\n /* This is called (by glib via xsmp->ice_connection_watch) when a\n- * connection is first received on the ICE listening socket. (We\n- * expect that the client will then initiate XSMP on the connection;\n- * if it does not, GsmXSMPClient will eventually time out and close\n- * the connection.)\n- *\n- * FIXME: it would probably make more sense to not create a\n- * GsmXSMPClient object until accept_xsmp_connection, below (and to do\n- * the timing-out here in xsmp.c).\n+ * connection is first received on the ICE listening socket.\n  */\n static gboolean\n accept_ice_connection (GIOChannel           *source,\n                        GIOCondition          condition,\n                        GsmIceConnectionData *data)\n {\n-        IceListenObj    listener;\n         IceConn         ice_conn;\n         IceAcceptStatus status;\n-        GsmClient      *client;\n-        GsmXsmpServer  *server;\n-\n-        listener = data->listener;\n-        server = data->server;\n \n         g_debug (\""GsmXsmpServer: accept_ice_connection()\"");\n \n-        ice_conn = IceAcceptConnection (listener, &status);\n+        ice_conn = IceAcceptConnection (data->listener, &status);\n         if (status != IceAcceptSuccess) {\n                 g_debug (\""GsmXsmpServer: IceAcceptConnection returned %d\"", status);\n                 return TRUE;\n         }\n \n-        client = gsm_xsmp_client_new (ice_conn);\n-        ice_conn->context = client;\n-\n-        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n-        /* the store will own the ref */\n-        g_object_unref (client);\n+        auth_ice_connection (ice_conn);\n \n         return TRUE;\n }\n@@ -224,8 +314,9 @@ accept_xsmp_connection (SmsConn        sms_conn,\n                         SmsCallbacks  *callbacks_ret,\n                         char         **failure_reason_ret)\n {\n-        IceConn        ice_conn;\n-        GsmXSMPClient *client;\n+        IceConn                ice_conn;\n+        GsmClient             *client;\n+        GsmIceConnectionWatch *data;\n \n         /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */\n         if (server->priv->xsmp_sockets == NULL) {\n@@ -236,11 +327,18 @@ accept_xsmp_connection (SmsConn        sms_conn,\n         }\n \n         ice_conn = SmsGetIceConnection (sms_conn);\n-        client = ice_conn->context;\n+        data = ice_conn->context;\n \n-        g_return_val_if_fail (client != NULL, TRUE);\n+        /* Each GsmXSMPClient has its own IceConn watcher */\n+        free_ice_connection_watch (data);\n+\n+        client = gsm_xsmp_client_new (ice_conn);\n+\n+        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n+        /* the store will own the ref */\n+        g_object_unref (client);\n \n-        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n+        gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);\n \n         return TRUE;\n }""}"," accept_ice_connection (GIOChannel           *source,
                        GIOCondition          condition,
                        GsmIceConnectionData *data)
 {
         IceConn         ice_conn;
         IceAcceptStatus status;
 
         g_debug (""GsmXsmpServer: accept_ice_connection()"");
 
        ice_conn = IceAcceptConnection (data->listener, &status);
         if (status != IceAcceptSuccess) {
                 g_debug (""GsmXsmpServer: IceAcceptConnection returned %d"", status);
                 return TRUE;
         }
 
        auth_ice_connection (ice_conn);
 
         return TRUE;
 }
"," accept_ice_connection (GIOChannel           *source,
                        GIOCondition          condition,
                        GsmIceConnectionData *data)
 {
        IceListenObj    listener;
         IceConn         ice_conn;
         IceAcceptStatus status;
        GsmClient      *client;
        GsmXsmpServer  *server;
        listener = data->listener;
        server = data->server;
 
         g_debug (""GsmXsmpServer: accept_ice_connection()"");
 
        ice_conn = IceAcceptConnection (listener, &status);
         if (status != IceAcceptSuccess) {
                 g_debug (""GsmXsmpServer: IceAcceptConnection returned %d"", status);
                 return TRUE;
         }
 
        client = gsm_xsmp_client_new (ice_conn);
        ice_conn->context = client;
        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
        /* the store will own the ref */
        g_object_unref (client);
 
         return TRUE;
 }
",C,"        ice_conn = IceAcceptConnection (data->listener, &status);
        auth_ice_connection (ice_conn);
","        IceListenObj    listener;
        GsmClient      *client;
        GsmXsmpServer  *server;
        listener = data->listener;
        server = data->server;
        ice_conn = IceAcceptConnection (listener, &status);
        client = gsm_xsmp_client_new (ice_conn);
        ice_conn->context = client;
        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
        /* the store will own the ref */
        g_object_unref (client);
",,"@@ -91,44 +91,134 @@ typedef struct {
         IceListenObj   listener;
 } GsmIceConnectionData;
 
+typedef struct {
+        guint watch_id;
+        guint protocol_timeout;
+} GsmIceConnectionWatch;
+
+static void
+disconnect_ice_connection (IceConn ice_conn)
+{
+        IceSetShutdownNegotiation (ice_conn, FALSE);
+        IceCloseConnection (ice_conn);
+}
+
+static void
+free_ice_connection_watch (GsmIceConnectionWatch *data)
+{
+        if (data->watch_id) {
+                g_source_remove (data->watch_id);
+                data->watch_id = 0;
+        }
+
+        if (data->protocol_timeout) {
+                g_source_remove (data->protocol_timeout);
+                data->protocol_timeout = 0;
+        }
+
+        g_free (data);
+}
+
+static gboolean
+ice_protocol_timeout (IceConn ice_conn)
+{
+        GsmIceConnectionWatch *data;
+
+        g_debug (""GsmXsmpServer: ice_protocol_timeout for IceConn %p with status %d"",
+                 ice_conn, IceConnectionStatus (ice_conn));
+
+        data = ice_conn->context;
+
+        free_ice_connection_watch (data);
+        disconnect_ice_connection (ice_conn);
+
+        return FALSE;
+}
+
+static gboolean
+auth_iochannel_watch (GIOChannel   *source,
+                      GIOCondition  condition,
+                      IceConn       ice_conn)
+{
+
+        GsmIceConnectionWatch *data;
+        gboolean               keep_going;
+
+        data = ice_conn->context;
+
+        switch (IceProcessMessages (ice_conn, NULL, NULL)) {
+        case IceProcessMessagesSuccess:
+                keep_going = TRUE;
+                break;
+        case IceProcessMessagesIOError:
+                g_debug (""GsmXsmpServer: IceProcessMessages returned IceProcessMessagesIOError"");
+                free_ice_connection_watch (data);
+                disconnect_ice_connection (ice_conn);
+                keep_going = FALSE;
+                break;
+        case IceProcessMessagesConnectionClosed:
+                g_debug (""GsmXsmpServer: IceProcessMessages returned IceProcessMessagesConnectionClosed"");
+                free_ice_connection_watch (data);
+                keep_going = FALSE;
+                break;
+        default:
+                g_assert_not_reached ();
+        }
+
+        return keep_going;
+}
+
+/* IceAcceptConnection returns a new ICE connection that is in a ""pending"" state,
+ * this is because authentification may be necessary.
+ * So we've to authenticate it, before accept_xsmp_connection() is called.
+ * Then each GsmXSMPClient will have its own IceConn watcher
+ */
+static void
+auth_ice_connection (IceConn ice_conn)
+{
+        GIOChannel            *channel;
+        GsmIceConnectionWatch *data;
+        int                    fd;
+
+        g_debug (""GsmXsmpServer: auth_ice_connection()"");
+
+        fd = IceConnectionNumber (ice_conn);
+        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);
+        channel = g_io_channel_unix_new (fd);
+
+        data = g_new0 (GsmIceConnectionWatch, 1);
+        ice_conn->context = data;
+
+        data->protocol_timeout = g_timeout_add_seconds (5,
+                                                        (GSourceFunc)ice_protocol_timeout,
+                                                        ice_conn);
+        data->watch_id = g_io_add_watch (channel,
+                                         G_IO_IN | G_IO_ERR,
+                                         (GIOFunc)auth_iochannel_watch,
+                                         ice_conn);
+        g_io_channel_unref (channel);
+}
+
 /* This is called (by glib via xsmp->ice_connection_watch) when a
- * connection is first received on the ICE listening socket. (We
- * expect that the client will then initiate XSMP on the connection;
- * if it does not, GsmXSMPClient will eventually time out and close
- * the connection.)
- *
- * FIXME: it would probably make more sense to not create a
- * GsmXSMPClient object until accept_xsmp_connection, below (and to do
- * the timing-out here in xsmp.c).
+ * connection is first received on the ICE listening socket.
  */
 static gboolean
 accept_ice_connection (GIOChannel           *source,
                        GIOCondition          condition,
                        GsmIceConnectionData *data)
 {
-        IceListenObj    listener;
         IceConn         ice_conn;
         IceAcceptStatus status;
-        GsmClient      *client;
-        GsmXsmpServer  *server;
-
-        listener = data->listener;
-        server = data->server;
 
         g_debug (""GsmXsmpServer: accept_ice_connection()"");
 
-        ice_conn = IceAcceptConnection (listener, &status);
+        ice_conn = IceAcceptConnection (data->listener, &status);
         if (status != IceAcceptSuccess) {
                 g_debug (""GsmXsmpServer: IceAcceptConnection returned %d"", status);
                 return TRUE;
         }
 
-        client = gsm_xsmp_client_new (ice_conn);
-        ice_conn->context = client;
-
-        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
-        /* the store will own the ref */
-        g_object_unref (client);
+        auth_ice_connection (ice_conn);
 
         return TRUE;
 }
@@ -224,8 +314,9 @@ accept_xsmp_connection (SmsConn        sms_conn,
                         SmsCallbacks  *callbacks_ret,
                         char         **failure_reason_ret)
 {
-        IceConn        ice_conn;
-        GsmXSMPClient *client;
+        IceConn                ice_conn;
+        GsmClient             *client;
+        GsmIceConnectionWatch *data;
 
         /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */
         if (server->priv->xsmp_sockets == NULL) {
@@ -236,11 +327,18 @@ accept_xsmp_connection (SmsConn        sms_conn,
         }
 
         ice_conn = SmsGetIceConnection (sms_conn);
-        client = ice_conn->context;
+        data = ice_conn->context;
 
-        g_return_val_if_fail (client != NULL, TRUE);
+        /* Each GsmXSMPClient has its own IceConn watcher */
+        free_ice_connection_watch (data);
+
+        client = gsm_xsmp_client_new (ice_conn);
+
+        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
+        /* the store will own the ref */
+        g_object_unref (client);
 
-        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);
+        gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);
 
         return TRUE;
 }",gnome-session,b0dc999e0b45355314616321dbb6cb71e729fc9d,5198aa08d2b77204cd8bf669a64f2e044d9a9e0d,1," accept_ice_connection (GIOChannel           *source,
                        GIOCondition          condition,
                        GsmIceConnectionData *data)
 {
//flaw_line_below:
        IceListenObj    listener;
         IceConn         ice_conn;
         IceAcceptStatus status;
//flaw_line_below:
        GsmClient      *client;
//flaw_line_below:
        GsmXsmpServer  *server;
//flaw_line_below:

//flaw_line_below:
        listener = data->listener;
//flaw_line_below:
        server = data->server;
 
         g_debug (""GsmXsmpServer: accept_ice_connection()"");
 
//flaw_line_below:
        ice_conn = IceAcceptConnection (listener, &status);
//fix_flaw_line_below:
//        ice_conn = IceAcceptConnection (data->listener, &status);
         if (status != IceAcceptSuccess) {
                 g_debug (""GsmXsmpServer: IceAcceptConnection returned %d"", status);
                 return TRUE;
         }
 
//flaw_line_below:
        client = gsm_xsmp_client_new (ice_conn);
//flaw_line_below:
        ice_conn->context = client;
//flaw_line_below:

//flaw_line_below:
        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
//flaw_line_below:
        /* the store will own the ref */
//flaw_line_below:
        g_object_unref (client);
//fix_flaw_line_below:
//        auth_ice_connection (ice_conn);
 
         return TRUE;
 }
"
3489,181225,,Local,Not required,Complete,CVE-2017-11171,https://www.cvedetails.com/cve/CVE-2017-11171/,CWE-835,Low,,,,2017-07-11,4.9,"Bad reference counting in the context of accept_ice_connection() in gsm-xsmp-server.c in old versions of gnome-session up until version 2.29.92 allows a local attacker to establish ICE connections to gnome-session with invalid authentication data (an invalid magic cookie). Each failed authentication attempt will leak a file descriptor in gnome-session. When the maximum number of file descriptors is exhausted in the gnome-session process, it will enter an infinite loop trying to communicate without success, consuming 100% of the CPU. The graphical session associated with the gnome-session process will stop working correctly, because communication with gnome-session is no longer possible.",2019-10-02,,13,https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d,b0dc999e0b45355314616321dbb6cb71e729fc9d,"[gsm] Delay the creation of the GsmXSMPClient until it really exists

We used to create the GsmXSMPClient before the XSMP connection is really
accepted. This can lead to some issues, though. An example is:
https://bugzilla.gnome.org/show_bug.cgi?id=598211#c19. Quoting:

 ""What is happening is that a new client (probably metacity in your
 case) is opening an ICE connection in the GSM_MANAGER_PHASE_END_SESSION
 phase, which causes a new GsmXSMPClient to be added to the client
 store. The GSM_MANAGER_PHASE_EXIT phase then begins before the client
 has had a chance to establish a xsmp connection, which means that
 client->priv->conn will not be initialized at the point that xsmp_stop
 is called on the new unregistered client.""

The fix is to create the GsmXSMPClient object when there's a real XSMP
connection. This implies moving the timeout that makes sure we don't
have an empty client to the XSMP server.

https://bugzilla.gnome.org/show_bug.cgi?id=598211",5,gnome-session/gsm-xsmp-server.c,"{""sha"": ""9da5fdc06ea8d46b29a5f0cdb172ce3d9b4a326c"", ""filename"": ""gnome-session/gsm-xsmp-client.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 30, ""changes"": 30, ""blob_url"": ""https://github.com/GNOME/gnome-session/blob/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-client.c"", ""raw_url"": ""https://github.com/GNOME/gnome-session/raw/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-client.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/gnome-session/contents/gnome-session/gsm-xsmp-client.c?ref=b0dc999e0b45355314616321dbb6cb71e729fc9d"", ""patch"": ""@@ -51,7 +51,6 @@ struct GsmXSMPClientPrivate\n         IceConn    ice_connection;\n \n         guint      watch_id;\n-        guint      protocol_timeout;\n \n         char      *description;\n         GPtrArray *props;\n@@ -115,22 +114,6 @@ client_iochannel_watch (GIOChannel    *channel,\n         return keep_going;\n }\n \n-/* Called if too much time passes between the initial connection and\n- * the XSMP protocol setup.\n- */\n-static gboolean\n-_client_protocol_timeout (GsmXSMPClient *client)\n-{\n-        g_debug (\""GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d\"",\n-                 client->priv->description,\n-                 IceConnectionStatus (client->priv->ice_connection));\n-\n-        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);\n-        gsm_client_disconnected (GSM_CLIENT (client));\n-\n-        return FALSE;\n-}\n-\n static SmProp *\n find_property (GsmXSMPClient *client,\n                const char    *name,\n@@ -193,10 +176,6 @@ setup_connection (GsmXSMPClient *client)\n                                                  client);\n         g_io_channel_unref (channel);\n \n-        client->priv->protocol_timeout = g_timeout_add_seconds (5,\n-                                                                (GSourceFunc)_client_protocol_timeout,\n-                                                                client);\n-\n         set_description (client);\n \n         g_debug (\""GsmXSMPClient: New client '%s'\"", client->priv->description);\n@@ -869,10 +848,6 @@ gsm_xsmp_client_disconnect (GsmXSMPClient *client)\n                 IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);\n                 IceCloseConnection (client->priv->ice_connection);\n         }\n-\n-        if (client->priv->protocol_timeout > 0) {\n-                g_source_remove (client->priv->protocol_timeout);\n-        }\n }\n \n static void\n@@ -1305,11 +1280,6 @@ gsm_xsmp_client_connect (GsmXSMPClient *client,\n {\n         client->priv->conn = conn;\n \n-        if (client->priv->protocol_timeout) {\n-                g_source_remove (client->priv->protocol_timeout);\n-                client->priv->protocol_timeout = 0;\n-        }\n-\n         g_debug (\""GsmXSMPClient: Initializing client %s\"", client->priv->description);\n \n         *mask_ret = 0;""}<_**next**_>{""sha"": ""1f0e04554982efbb283e1be102867bef03921cfd"", ""filename"": ""gnome-session/gsm-xsmp-server.c"", ""status"": ""modified"", ""additions"": 124, ""deletions"": 26, ""changes"": 150, ""blob_url"": ""https://github.com/GNOME/gnome-session/blob/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-server.c"", ""raw_url"": ""https://github.com/GNOME/gnome-session/raw/b0dc999e0b45355314616321dbb6cb71e729fc9d/gnome-session/gsm-xsmp-server.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/gnome-session/contents/gnome-session/gsm-xsmp-server.c?ref=b0dc999e0b45355314616321dbb6cb71e729fc9d"", ""patch"": ""@@ -91,44 +91,134 @@ typedef struct {\n         IceListenObj   listener;\n } GsmIceConnectionData;\n \n+typedef struct {\n+        guint watch_id;\n+        guint protocol_timeout;\n+} GsmIceConnectionWatch;\n+\n+static void\n+disconnect_ice_connection (IceConn ice_conn)\n+{\n+        IceSetShutdownNegotiation (ice_conn, FALSE);\n+        IceCloseConnection (ice_conn);\n+}\n+\n+static void\n+free_ice_connection_watch (GsmIceConnectionWatch *data)\n+{\n+        if (data->watch_id) {\n+                g_source_remove (data->watch_id);\n+                data->watch_id = 0;\n+        }\n+\n+        if (data->protocol_timeout) {\n+                g_source_remove (data->protocol_timeout);\n+                data->protocol_timeout = 0;\n+        }\n+\n+        g_free (data);\n+}\n+\n+static gboolean\n+ice_protocol_timeout (IceConn ice_conn)\n+{\n+        GsmIceConnectionWatch *data;\n+\n+        g_debug (\""GsmXsmpServer: ice_protocol_timeout for IceConn %p with status %d\"",\n+                 ice_conn, IceConnectionStatus (ice_conn));\n+\n+        data = ice_conn->context;\n+\n+        free_ice_connection_watch (data);\n+        disconnect_ice_connection (ice_conn);\n+\n+        return FALSE;\n+}\n+\n+static gboolean\n+auth_iochannel_watch (GIOChannel   *source,\n+                      GIOCondition  condition,\n+                      IceConn       ice_conn)\n+{\n+\n+        GsmIceConnectionWatch *data;\n+        gboolean               keep_going;\n+\n+        data = ice_conn->context;\n+\n+        switch (IceProcessMessages (ice_conn, NULL, NULL)) {\n+        case IceProcessMessagesSuccess:\n+                keep_going = TRUE;\n+                break;\n+        case IceProcessMessagesIOError:\n+                g_debug (\""GsmXsmpServer: IceProcessMessages returned IceProcessMessagesIOError\"");\n+                free_ice_connection_watch (data);\n+                disconnect_ice_connection (ice_conn);\n+                keep_going = FALSE;\n+                break;\n+        case IceProcessMessagesConnectionClosed:\n+                g_debug (\""GsmXsmpServer: IceProcessMessages returned IceProcessMessagesConnectionClosed\"");\n+                free_ice_connection_watch (data);\n+                keep_going = FALSE;\n+                break;\n+        default:\n+                g_assert_not_reached ();\n+        }\n+\n+        return keep_going;\n+}\n+\n+/* IceAcceptConnection returns a new ICE connection that is in a \""pending\"" state,\n+ * this is because authentification may be necessary.\n+ * So we've to authenticate it, before accept_xsmp_connection() is called.\n+ * Then each GsmXSMPClient will have its own IceConn watcher\n+ */\n+static void\n+auth_ice_connection (IceConn ice_conn)\n+{\n+        GIOChannel            *channel;\n+        GsmIceConnectionWatch *data;\n+        int                    fd;\n+\n+        g_debug (\""GsmXsmpServer: auth_ice_connection()\"");\n+\n+        fd = IceConnectionNumber (ice_conn);\n+        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n+        channel = g_io_channel_unix_new (fd);\n+\n+        data = g_new0 (GsmIceConnectionWatch, 1);\n+        ice_conn->context = data;\n+\n+        data->protocol_timeout = g_timeout_add_seconds (5,\n+                                                        (GSourceFunc)ice_protocol_timeout,\n+                                                        ice_conn);\n+        data->watch_id = g_io_add_watch (channel,\n+                                         G_IO_IN | G_IO_ERR,\n+                                         (GIOFunc)auth_iochannel_watch,\n+                                         ice_conn);\n+        g_io_channel_unref (channel);\n+}\n+\n /* This is called (by glib via xsmp->ice_connection_watch) when a\n- * connection is first received on the ICE listening socket. (We\n- * expect that the client will then initiate XSMP on the connection;\n- * if it does not, GsmXSMPClient will eventually time out and close\n- * the connection.)\n- *\n- * FIXME: it would probably make more sense to not create a\n- * GsmXSMPClient object until accept_xsmp_connection, below (and to do\n- * the timing-out here in xsmp.c).\n+ * connection is first received on the ICE listening socket.\n  */\n static gboolean\n accept_ice_connection (GIOChannel           *source,\n                        GIOCondition          condition,\n                        GsmIceConnectionData *data)\n {\n-        IceListenObj    listener;\n         IceConn         ice_conn;\n         IceAcceptStatus status;\n-        GsmClient      *client;\n-        GsmXsmpServer  *server;\n-\n-        listener = data->listener;\n-        server = data->server;\n \n         g_debug (\""GsmXsmpServer: accept_ice_connection()\"");\n \n-        ice_conn = IceAcceptConnection (listener, &status);\n+        ice_conn = IceAcceptConnection (data->listener, &status);\n         if (status != IceAcceptSuccess) {\n                 g_debug (\""GsmXsmpServer: IceAcceptConnection returned %d\"", status);\n                 return TRUE;\n         }\n \n-        client = gsm_xsmp_client_new (ice_conn);\n-        ice_conn->context = client;\n-\n-        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n-        /* the store will own the ref */\n-        g_object_unref (client);\n+        auth_ice_connection (ice_conn);\n \n         return TRUE;\n }\n@@ -224,8 +314,9 @@ accept_xsmp_connection (SmsConn        sms_conn,\n                         SmsCallbacks  *callbacks_ret,\n                         char         **failure_reason_ret)\n {\n-        IceConn        ice_conn;\n-        GsmXSMPClient *client;\n+        IceConn                ice_conn;\n+        GsmClient             *client;\n+        GsmIceConnectionWatch *data;\n \n         /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */\n         if (server->priv->xsmp_sockets == NULL) {\n@@ -236,11 +327,18 @@ accept_xsmp_connection (SmsConn        sms_conn,\n         }\n \n         ice_conn = SmsGetIceConnection (sms_conn);\n-        client = ice_conn->context;\n+        data = ice_conn->context;\n \n-        g_return_val_if_fail (client != NULL, TRUE);\n+        /* Each GsmXSMPClient has its own IceConn watcher */\n+        free_ice_connection_watch (data);\n+\n+        client = gsm_xsmp_client_new (ice_conn);\n+\n+        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n+        /* the store will own the ref */\n+        g_object_unref (client);\n \n-        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n+        gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);\n \n         return TRUE;\n }""}","accept_xsmp_connection (SmsConn        sms_conn,
                        GsmXsmpServer *server,
                        unsigned long *mask_ret,
                         SmsCallbacks  *callbacks_ret,
                         char         **failure_reason_ret)
 {
        IceConn                ice_conn;
        GsmClient             *client;
        GsmIceConnectionWatch *data;
 
         /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */
         if (server->priv->xsmp_sockets == NULL) {
                g_debug (""GsmXsmpServer: In shutdown, rejecting new client"");

                *failure_reason_ret = strdup (_(""Refusing new client connection because the session is currently being shut down\n""));
                return FALSE;
         }
 
         ice_conn = SmsGetIceConnection (sms_conn);
        data = ice_conn->context;
 
        /* Each GsmXSMPClient has its own IceConn watcher */
        free_ice_connection_watch (data);

        client = gsm_xsmp_client_new (ice_conn);

        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
        /* the store will own the ref */
        g_object_unref (client);
 
        gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);
 
         return TRUE;
 }
","accept_xsmp_connection (SmsConn        sms_conn,
                        GsmXsmpServer *server,
                        unsigned long *mask_ret,
                         SmsCallbacks  *callbacks_ret,
                         char         **failure_reason_ret)
 {
        IceConn        ice_conn;
        GsmXSMPClient *client;
 
         /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */
         if (server->priv->xsmp_sockets == NULL) {
                g_debug (""GsmXsmpServer: In shutdown, rejecting new client"");

                *failure_reason_ret = strdup (_(""Refusing new client connection because the session is currently being shut down\n""));
                return FALSE;
         }
 
         ice_conn = SmsGetIceConnection (sms_conn);
        client = ice_conn->context;
 
        g_return_val_if_fail (client != NULL, TRUE);
 
        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);
 
         return TRUE;
 }
",C,"        IceConn                ice_conn;
        GsmClient             *client;
        GsmIceConnectionWatch *data;
        data = ice_conn->context;
        /* Each GsmXSMPClient has its own IceConn watcher */
        free_ice_connection_watch (data);

        client = gsm_xsmp_client_new (ice_conn);

        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
        /* the store will own the ref */
        g_object_unref (client);
        gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);
","        IceConn        ice_conn;
        GsmXSMPClient *client;
        client = ice_conn->context;
        g_return_val_if_fail (client != NULL, TRUE);
        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);
",,"@@ -91,44 +91,134 @@ typedef struct {
         IceListenObj   listener;
 } GsmIceConnectionData;
 
+typedef struct {
+        guint watch_id;
+        guint protocol_timeout;
+} GsmIceConnectionWatch;
+
+static void
+disconnect_ice_connection (IceConn ice_conn)
+{
+        IceSetShutdownNegotiation (ice_conn, FALSE);
+        IceCloseConnection (ice_conn);
+}
+
+static void
+free_ice_connection_watch (GsmIceConnectionWatch *data)
+{
+        if (data->watch_id) {
+                g_source_remove (data->watch_id);
+                data->watch_id = 0;
+        }
+
+        if (data->protocol_timeout) {
+                g_source_remove (data->protocol_timeout);
+                data->protocol_timeout = 0;
+        }
+
+        g_free (data);
+}
+
+static gboolean
+ice_protocol_timeout (IceConn ice_conn)
+{
+        GsmIceConnectionWatch *data;
+
+        g_debug (""GsmXsmpServer: ice_protocol_timeout for IceConn %p with status %d"",
+                 ice_conn, IceConnectionStatus (ice_conn));
+
+        data = ice_conn->context;
+
+        free_ice_connection_watch (data);
+        disconnect_ice_connection (ice_conn);
+
+        return FALSE;
+}
+
+static gboolean
+auth_iochannel_watch (GIOChannel   *source,
+                      GIOCondition  condition,
+                      IceConn       ice_conn)
+{
+
+        GsmIceConnectionWatch *data;
+        gboolean               keep_going;
+
+        data = ice_conn->context;
+
+        switch (IceProcessMessages (ice_conn, NULL, NULL)) {
+        case IceProcessMessagesSuccess:
+                keep_going = TRUE;
+                break;
+        case IceProcessMessagesIOError:
+                g_debug (""GsmXsmpServer: IceProcessMessages returned IceProcessMessagesIOError"");
+                free_ice_connection_watch (data);
+                disconnect_ice_connection (ice_conn);
+                keep_going = FALSE;
+                break;
+        case IceProcessMessagesConnectionClosed:
+                g_debug (""GsmXsmpServer: IceProcessMessages returned IceProcessMessagesConnectionClosed"");
+                free_ice_connection_watch (data);
+                keep_going = FALSE;
+                break;
+        default:
+                g_assert_not_reached ();
+        }
+
+        return keep_going;
+}
+
+/* IceAcceptConnection returns a new ICE connection that is in a ""pending"" state,
+ * this is because authentification may be necessary.
+ * So we've to authenticate it, before accept_xsmp_connection() is called.
+ * Then each GsmXSMPClient will have its own IceConn watcher
+ */
+static void
+auth_ice_connection (IceConn ice_conn)
+{
+        GIOChannel            *channel;
+        GsmIceConnectionWatch *data;
+        int                    fd;
+
+        g_debug (""GsmXsmpServer: auth_ice_connection()"");
+
+        fd = IceConnectionNumber (ice_conn);
+        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);
+        channel = g_io_channel_unix_new (fd);
+
+        data = g_new0 (GsmIceConnectionWatch, 1);
+        ice_conn->context = data;
+
+        data->protocol_timeout = g_timeout_add_seconds (5,
+                                                        (GSourceFunc)ice_protocol_timeout,
+                                                        ice_conn);
+        data->watch_id = g_io_add_watch (channel,
+                                         G_IO_IN | G_IO_ERR,
+                                         (GIOFunc)auth_iochannel_watch,
+                                         ice_conn);
+        g_io_channel_unref (channel);
+}
+
 /* This is called (by glib via xsmp->ice_connection_watch) when a
- * connection is first received on the ICE listening socket. (We
- * expect that the client will then initiate XSMP on the connection;
- * if it does not, GsmXSMPClient will eventually time out and close
- * the connection.)
- *
- * FIXME: it would probably make more sense to not create a
- * GsmXSMPClient object until accept_xsmp_connection, below (and to do
- * the timing-out here in xsmp.c).
+ * connection is first received on the ICE listening socket.
  */
 static gboolean
 accept_ice_connection (GIOChannel           *source,
                        GIOCondition          condition,
                        GsmIceConnectionData *data)
 {
-        IceListenObj    listener;
         IceConn         ice_conn;
         IceAcceptStatus status;
-        GsmClient      *client;
-        GsmXsmpServer  *server;
-
-        listener = data->listener;
-        server = data->server;
 
         g_debug (""GsmXsmpServer: accept_ice_connection()"");
 
-        ice_conn = IceAcceptConnection (listener, &status);
+        ice_conn = IceAcceptConnection (data->listener, &status);
         if (status != IceAcceptSuccess) {
                 g_debug (""GsmXsmpServer: IceAcceptConnection returned %d"", status);
                 return TRUE;
         }
 
-        client = gsm_xsmp_client_new (ice_conn);
-        ice_conn->context = client;
-
-        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
-        /* the store will own the ref */
-        g_object_unref (client);
+        auth_ice_connection (ice_conn);
 
         return TRUE;
 }
@@ -224,8 +314,9 @@ accept_xsmp_connection (SmsConn        sms_conn,
                         SmsCallbacks  *callbacks_ret,
                         char         **failure_reason_ret)
 {
-        IceConn        ice_conn;
-        GsmXSMPClient *client;
+        IceConn                ice_conn;
+        GsmClient             *client;
+        GsmIceConnectionWatch *data;
 
         /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */
         if (server->priv->xsmp_sockets == NULL) {
@@ -236,11 +327,18 @@ accept_xsmp_connection (SmsConn        sms_conn,
         }
 
         ice_conn = SmsGetIceConnection (sms_conn);
-        client = ice_conn->context;
+        data = ice_conn->context;
 
-        g_return_val_if_fail (client != NULL, TRUE);
+        /* Each GsmXSMPClient has its own IceConn watcher */
+        free_ice_connection_watch (data);
+
+        client = gsm_xsmp_client_new (ice_conn);
+
+        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
+        /* the store will own the ref */
+        g_object_unref (client);
 
-        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);
+        gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);
 
         return TRUE;
 }",gnome-session,b0dc999e0b45355314616321dbb6cb71e729fc9d,5198aa08d2b77204cd8bf669a64f2e044d9a9e0d,1,"accept_xsmp_connection (SmsConn        sms_conn,
                        GsmXsmpServer *server,
                        unsigned long *mask_ret,
                         SmsCallbacks  *callbacks_ret,
                         char         **failure_reason_ret)
 {
//flaw_line_below:
        IceConn        ice_conn;
//flaw_line_below:
        GsmXSMPClient *client;
//fix_flaw_line_below:
//        IceConn                ice_conn;
//fix_flaw_line_below:
//        GsmClient             *client;
//fix_flaw_line_below:
//        GsmIceConnectionWatch *data;
 
         /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */
         if (server->priv->xsmp_sockets == NULL) {
                g_debug (""GsmXsmpServer: In shutdown, rejecting new client"");

                *failure_reason_ret = strdup (_(""Refusing new client connection because the session is currently being shut down\n""));
                return FALSE;
         }
 
         ice_conn = SmsGetIceConnection (sms_conn);
//flaw_line_below:
        client = ice_conn->context;
//fix_flaw_line_below:
//        data = ice_conn->context;
 
//flaw_line_below:
        g_return_val_if_fail (client != NULL, TRUE);
//fix_flaw_line_below:
//        /* Each GsmXSMPClient has its own IceConn watcher */
//fix_flaw_line_below:
//        free_ice_connection_watch (data);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        client = gsm_xsmp_client_new (ice_conn);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
//fix_flaw_line_below:
//        /* the store will own the ref */
//fix_flaw_line_below:
//        g_object_unref (client);
 
//flaw_line_below:
        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);
//fix_flaw_line_below:
//        gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);
 
         return TRUE;
 }
"
3797,181533,,Remote,Not required,Partial,CVE-2017-6214,https://www.cvedetails.com/cve/CVE-2017-6214/,CWE-835,Low,,,,2017-02-23,5.0,The tcp_splice_read function in net/ipv4/tcp.c in the Linux kernel before 4.9.11 allows remote attackers to cause a denial of service (infinite loop and soft lockup) via vectors involving a TCP packet with the URG flag.,2019-10-02,DoS ,6,https://github.com/torvalds/linux/commit/ccf7abb93af09ad0868ae9033d1ca8108bdaec82,ccf7abb93af09ad0868ae9033d1ca8108bdaec82,"tcp: avoid infinite loop in tcp_splice_read()

Splicing from TCP socket is vulnerable when a packet with URG flag is
received and stored into receive queue.

__tcp_splice_read() returns 0, and sk_wait_data() immediately
returns since there is the problematic skb in queue.

This is a nice way to burn cpu (aka infinite loop) and trigger
soft lockups.

Again, this gem was found by syzkaller tool.

Fixes: 9c55e01c0cc8 (""[TCP]: Splice receive support."")
Signed-off-by: Eric Dumazet <edumazet@google.com>
Reported-by: Dmitry Vyukov  <dvyukov@google.com>
Cc: Willy Tarreau <w@1wt.eu>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/ipv4/tcp.c,"{""sha"": ""0efb4c7f6704f662b6c762e48698a41564add2a4"", ""filename"": ""net/ipv4/tcp.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/ccf7abb93af09ad0868ae9033d1ca8108bdaec82/net/ipv4/tcp.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/ccf7abb93af09ad0868ae9033d1ca8108bdaec82/net/ipv4/tcp.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/tcp.c?ref=ccf7abb93af09ad0868ae9033d1ca8108bdaec82"", ""patch"": ""@@ -770,6 +770,12 @@ ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,\n \t\t\t\tret = -EAGAIN;\n \t\t\t\tbreak;\n \t\t\t}\n+\t\t\t/* if __tcp_splice_read() got nothing while we have\n+\t\t\t * an skb in receive queue, we do not want to loop.\n+\t\t\t * This might happen with URG data.\n+\t\t\t */\n+\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue))\n+\t\t\t\tbreak;\n \t\t\tsk_wait_data(sk, &timeo, NULL);\n \t\t\tif (signal_pending(current)) {\n \t\t\t\tret = sock_intr_errno(timeo);""}","ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,
			struct pipe_inode_info *pipe, size_t len,
			unsigned int flags)
{
	struct sock *sk = sock->sk;
	struct tcp_splice_state tss = {
		.pipe = pipe,
		.len = len,
		.flags = flags,
	};
	long timeo;
	ssize_t spliced;
	int ret;

	sock_rps_record_flow(sk);
	/*
	 * We can't seek on a socket input
	 */
	if (unlikely(*ppos))
		return -ESPIPE;

	ret = spliced = 0;

	lock_sock(sk);

	timeo = sock_rcvtimeo(sk, sock->file->f_flags & O_NONBLOCK);
	while (tss.len) {
		ret = __tcp_splice_read(sk, &tss);
		if (ret < 0)
			break;
		else if (!ret) {
			if (spliced)
				break;
			if (sock_flag(sk, SOCK_DONE))
				break;
			if (sk->sk_err) {
				ret = sock_error(sk);
				break;
			}
			if (sk->sk_shutdown & RCV_SHUTDOWN)
				break;
			if (sk->sk_state == TCP_CLOSE) {
				/*
				 * This occurs when user tries to read
				 * from never connected socket.
				 */
				if (!sock_flag(sk, SOCK_DONE))
					ret = -ENOTCONN;
				break;
			}
			if (!timeo) {
 				ret = -EAGAIN;
 				break;
 			}
			/* if __tcp_splice_read() got nothing while we have
			 * an skb in receive queue, we do not want to loop.
			 * This might happen with URG data.
			 */
			if (!skb_queue_empty(&sk->sk_receive_queue))
				break;
 			sk_wait_data(sk, &timeo, NULL);
 			if (signal_pending(current)) {
 				ret = sock_intr_errno(timeo);
				break;
			}
			continue;
		}
		tss.len -= ret;
		spliced += ret;

		if (!timeo)
			break;
		release_sock(sk);
		lock_sock(sk);

		if (sk->sk_err || sk->sk_state == TCP_CLOSE ||
		    (sk->sk_shutdown & RCV_SHUTDOWN) ||
		    signal_pending(current))
			break;
	}

	release_sock(sk);

	if (spliced)
		return spliced;

	return ret;
}
","ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,
			struct pipe_inode_info *pipe, size_t len,
			unsigned int flags)
{
	struct sock *sk = sock->sk;
	struct tcp_splice_state tss = {
		.pipe = pipe,
		.len = len,
		.flags = flags,
	};
	long timeo;
	ssize_t spliced;
	int ret;

	sock_rps_record_flow(sk);
	/*
	 * We can't seek on a socket input
	 */
	if (unlikely(*ppos))
		return -ESPIPE;

	ret = spliced = 0;

	lock_sock(sk);

	timeo = sock_rcvtimeo(sk, sock->file->f_flags & O_NONBLOCK);
	while (tss.len) {
		ret = __tcp_splice_read(sk, &tss);
		if (ret < 0)
			break;
		else if (!ret) {
			if (spliced)
				break;
			if (sock_flag(sk, SOCK_DONE))
				break;
			if (sk->sk_err) {
				ret = sock_error(sk);
				break;
			}
			if (sk->sk_shutdown & RCV_SHUTDOWN)
				break;
			if (sk->sk_state == TCP_CLOSE) {
				/*
				 * This occurs when user tries to read
				 * from never connected socket.
				 */
				if (!sock_flag(sk, SOCK_DONE))
					ret = -ENOTCONN;
				break;
			}
			if (!timeo) {
 				ret = -EAGAIN;
 				break;
 			}
 			sk_wait_data(sk, &timeo, NULL);
 			if (signal_pending(current)) {
 				ret = sock_intr_errno(timeo);
				break;
			}
			continue;
		}
		tss.len -= ret;
		spliced += ret;

		if (!timeo)
			break;
		release_sock(sk);
		lock_sock(sk);

		if (sk->sk_err || sk->sk_state == TCP_CLOSE ||
		    (sk->sk_shutdown & RCV_SHUTDOWN) ||
		    signal_pending(current))
			break;
	}

	release_sock(sk);

	if (spliced)
		return spliced;

	return ret;
}
",C,"			/* if __tcp_splice_read() got nothing while we have
			 * an skb in receive queue, we do not want to loop.
			 * This might happen with URG data.
			 */
			if (!skb_queue_empty(&sk->sk_receive_queue))
				break;
",,,"@@ -770,6 +770,12 @@ ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,
 				ret = -EAGAIN;
 				break;
 			}
+			/* if __tcp_splice_read() got nothing while we have
+			 * an skb in receive queue, we do not want to loop.
+			 * This might happen with URG data.
+			 */
+			if (!skb_queue_empty(&sk->sk_receive_queue))
+				break;
 			sk_wait_data(sk, &timeo, NULL);
 			if (signal_pending(current)) {
 				ret = sock_intr_errno(timeo);",linux,ccf7abb93af09ad0868ae9033d1ca8108bdaec82,b3f2d07f4649adcf6905953a10d217b5683e4077,1,"ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,
			struct pipe_inode_info *pipe, size_t len,
			unsigned int flags)
{
	struct sock *sk = sock->sk;
	struct tcp_splice_state tss = {
		.pipe = pipe,
		.len = len,
		.flags = flags,
	};
	long timeo;
	ssize_t spliced;
	int ret;

	sock_rps_record_flow(sk);
	/*
	 * We can't seek on a socket input
	 */
	if (unlikely(*ppos))
		return -ESPIPE;

	ret = spliced = 0;

	lock_sock(sk);

	timeo = sock_rcvtimeo(sk, sock->file->f_flags & O_NONBLOCK);
	while (tss.len) {
		ret = __tcp_splice_read(sk, &tss);
		if (ret < 0)
			break;
		else if (!ret) {
			if (spliced)
				break;
			if (sock_flag(sk, SOCK_DONE))
				break;
			if (sk->sk_err) {
				ret = sock_error(sk);
				break;
			}
			if (sk->sk_shutdown & RCV_SHUTDOWN)
				break;
			if (sk->sk_state == TCP_CLOSE) {
				/*
				 * This occurs when user tries to read
				 * from never connected socket.
				 */
				if (!sock_flag(sk, SOCK_DONE))
					ret = -ENOTCONN;
				break;
			}
			if (!timeo) {
 				ret = -EAGAIN;
 				break;
 			}
//fix_flaw_line_below:
//			/* if __tcp_splice_read() got nothing while we have
//fix_flaw_line_below:
//			 * an skb in receive queue, we do not want to loop.
//fix_flaw_line_below:
//			 * This might happen with URG data.
//fix_flaw_line_below:
//			 */
//fix_flaw_line_below:
//			if (!skb_queue_empty(&sk->sk_receive_queue))
//fix_flaw_line_below:
//				break;
 			sk_wait_data(sk, &timeo, NULL);
 			if (signal_pending(current)) {
 				ret = sock_intr_errno(timeo);
				break;
			}
			continue;
		}
		tss.len -= ret;
		spliced += ret;

		if (!timeo)
			break;
		release_sock(sk);
		lock_sock(sk);

		if (sk->sk_err || sk->sk_state == TCP_CLOSE ||
		    (sk->sk_shutdown & RCV_SHUTDOWN) ||
		    signal_pending(current))
			break;
	}

	release_sock(sk);

	if (spliced)
		return spliced;

	return ret;
}
"
4361,182097,,Remote,Not required,Complete,CVE-2018-1999012,https://www.cvedetails.com/cve/CVE-2018-1999012/,CWE-835,Medium,,,,2018-07-23,7.1,FFmpeg before commit 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 contains a CWE-835: Infinite loop vulnerability in pva format demuxer that can result in a Vulnerability that allows attackers to consume excessive amount of resources like CPU and RAM. This attack appear to be exploitable via specially crafted PVA file has to be provided as input. This vulnerability appears to have been fixed in 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 and later.,2019-10-02,,4,https://github.com/FFmpeg/FFmpeg/commit/9807d3976be0e92e4ece3b4b1701be894cd7c2e1,9807d3976be0e92e4ece3b4b1701be894cd7c2e1,"avformat/pva: Check for EOF before retrying in read_part_of_packet()

Fixes: Infinite loop
Fixes: pva-4b1835dbc2027bf3c567005dcc78e85199240d06

Found-by: Paul Ch <paulcher@icloud.com>
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",0,libavformat/pva.c,"{""sha"": ""04ae8e2800cce1cd203d712929bb96c4b1f50ea6"", ""filename"": ""libavformat/pva.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/9807d3976be0e92e4ece3b4b1701be894cd7c2e1/libavformat/pva.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/9807d3976be0e92e4ece3b4b1701be894cd7c2e1/libavformat/pva.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavformat/pva.c?ref=9807d3976be0e92e4ece3b4b1701be894cd7c2e1"", ""patch"": ""@@ -134,6 +134,10 @@ static int read_part_of_packet(AVFormatContext *s, int64_t *pts,\n             pes_flags              = avio_rb16(pb);\n             pes_header_data_length = avio_r8(pb);\n \n+            if (avio_feof(pb)) {\n+                return AVERROR_EOF;\n+            }\n+\n             if (pes_signal != 1 || pes_header_data_length == 0) {\n                 pva_log(s, AV_LOG_WARNING, \""expected non empty signaled PES packet, \""\n                                           \""trying to recover\\n\"");""}","static int read_part_of_packet(AVFormatContext *s, int64_t *pts,
                               int *len, int *strid, int read_packet) {
    AVIOContext *pb = s->pb;
    PVAContext *pvactx = s->priv_data;
    int syncword, streamid, reserved, flags, length, pts_flag;
    int64_t pva_pts = AV_NOPTS_VALUE, startpos;
    int ret;

recover:
    startpos = avio_tell(pb);

    syncword = avio_rb16(pb);
    streamid = avio_r8(pb);
    avio_r8(pb);               /* counter not used */
    reserved = avio_r8(pb);
    flags    = avio_r8(pb);
    length   = avio_rb16(pb);

    pts_flag = flags & 0x10;

    if (syncword != PVA_MAGIC) {
        pva_log(s, AV_LOG_ERROR, ""invalid syncword\n"");
        return AVERROR(EIO);
    }
    if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) {
        pva_log(s, AV_LOG_ERROR, ""invalid streamid\n"");
        return AVERROR(EIO);
    }
    if (reserved != 0x55) {
        pva_log(s, AV_LOG_WARNING, ""expected reserved byte to be 0x55\n"");
    }
    if (length > PVA_MAX_PAYLOAD_LENGTH) {
        pva_log(s, AV_LOG_ERROR, ""invalid payload length %u\n"", length);
        return AVERROR(EIO);
    }

    if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) {
        pva_pts = avio_rb32(pb);
        length -= 4;
    } else if (streamid == PVA_AUDIO_PAYLOAD) {
        /* PVA Audio Packets either start with a signaled PES packet or
         * are a continuation of the previous PES packet. New PES packets
         * always start at the beginning of a PVA Packet, never somewhere in
         * the middle. */
        if (!pvactx->continue_pes) {
            int pes_signal, pes_header_data_length, pes_packet_length,
                pes_flags;
            unsigned char pes_header_data[256];

            pes_signal             = avio_rb24(pb);
            avio_r8(pb);
            pes_packet_length      = avio_rb16(pb);
             pes_flags              = avio_rb16(pb);
             pes_header_data_length = avio_r8(pb);
 
            if (avio_feof(pb)) {
                return AVERROR_EOF;
            }

             if (pes_signal != 1 || pes_header_data_length == 0) {
                 pva_log(s, AV_LOG_WARNING, ""expected non empty signaled PES packet, ""
                                           ""trying to recover\n"");
                avio_skip(pb, length - 9);
                if (!read_packet)
                    return AVERROR(EIO);
                goto recover;
            }

            ret = avio_read(pb, pes_header_data, pes_header_data_length);
            if (ret != pes_header_data_length)
                return ret < 0 ? ret : AVERROR_INVALIDDATA;
            length -= 9 + pes_header_data_length;

            pes_packet_length -= 3 + pes_header_data_length;

            pvactx->continue_pes = pes_packet_length;

            if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20) {
                if (pes_header_data_length < 5) {
                    pva_log(s, AV_LOG_ERROR, ""header too short\n"");
                    avio_skip(pb, length);
                    return AVERROR_INVALIDDATA;
                }
                pva_pts = ff_parse_pes_pts(pes_header_data);
            }
        }

        pvactx->continue_pes -= length;

        if (pvactx->continue_pes < 0) {
            pva_log(s, AV_LOG_WARNING, ""audio data corruption\n"");
            pvactx->continue_pes = 0;
        }
    }

    if (pva_pts != AV_NOPTS_VALUE)
        av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME);

    *pts   = pva_pts;
    *len   = length;
    *strid = streamid;
    return 0;
}
","static int read_part_of_packet(AVFormatContext *s, int64_t *pts,
                               int *len, int *strid, int read_packet) {
    AVIOContext *pb = s->pb;
    PVAContext *pvactx = s->priv_data;
    int syncword, streamid, reserved, flags, length, pts_flag;
    int64_t pva_pts = AV_NOPTS_VALUE, startpos;
    int ret;

recover:
    startpos = avio_tell(pb);

    syncword = avio_rb16(pb);
    streamid = avio_r8(pb);
    avio_r8(pb);               /* counter not used */
    reserved = avio_r8(pb);
    flags    = avio_r8(pb);
    length   = avio_rb16(pb);

    pts_flag = flags & 0x10;

    if (syncword != PVA_MAGIC) {
        pva_log(s, AV_LOG_ERROR, ""invalid syncword\n"");
        return AVERROR(EIO);
    }
    if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) {
        pva_log(s, AV_LOG_ERROR, ""invalid streamid\n"");
        return AVERROR(EIO);
    }
    if (reserved != 0x55) {
        pva_log(s, AV_LOG_WARNING, ""expected reserved byte to be 0x55\n"");
    }
    if (length > PVA_MAX_PAYLOAD_LENGTH) {
        pva_log(s, AV_LOG_ERROR, ""invalid payload length %u\n"", length);
        return AVERROR(EIO);
    }

    if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) {
        pva_pts = avio_rb32(pb);
        length -= 4;
    } else if (streamid == PVA_AUDIO_PAYLOAD) {
        /* PVA Audio Packets either start with a signaled PES packet or
         * are a continuation of the previous PES packet. New PES packets
         * always start at the beginning of a PVA Packet, never somewhere in
         * the middle. */
        if (!pvactx->continue_pes) {
            int pes_signal, pes_header_data_length, pes_packet_length,
                pes_flags;
            unsigned char pes_header_data[256];

            pes_signal             = avio_rb24(pb);
            avio_r8(pb);
            pes_packet_length      = avio_rb16(pb);
             pes_flags              = avio_rb16(pb);
             pes_header_data_length = avio_r8(pb);
 
             if (pes_signal != 1 || pes_header_data_length == 0) {
                 pva_log(s, AV_LOG_WARNING, ""expected non empty signaled PES packet, ""
                                           ""trying to recover\n"");
                avio_skip(pb, length - 9);
                if (!read_packet)
                    return AVERROR(EIO);
                goto recover;
            }

            ret = avio_read(pb, pes_header_data, pes_header_data_length);
            if (ret != pes_header_data_length)
                return ret < 0 ? ret : AVERROR_INVALIDDATA;
            length -= 9 + pes_header_data_length;

            pes_packet_length -= 3 + pes_header_data_length;

            pvactx->continue_pes = pes_packet_length;

            if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20) {
                if (pes_header_data_length < 5) {
                    pva_log(s, AV_LOG_ERROR, ""header too short\n"");
                    avio_skip(pb, length);
                    return AVERROR_INVALIDDATA;
                }
                pva_pts = ff_parse_pes_pts(pes_header_data);
            }
        }

        pvactx->continue_pes -= length;

        if (pvactx->continue_pes < 0) {
            pva_log(s, AV_LOG_WARNING, ""audio data corruption\n"");
            pvactx->continue_pes = 0;
        }
    }

    if (pva_pts != AV_NOPTS_VALUE)
        av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME);

    *pts   = pva_pts;
    *len   = length;
    *strid = streamid;
    return 0;
}
",C,"            if (avio_feof(pb)) {
                return AVERROR_EOF;
            }

",,,"@@ -134,6 +134,10 @@ static int read_part_of_packet(AVFormatContext *s, int64_t *pts,
             pes_flags              = avio_rb16(pb);
             pes_header_data_length = avio_r8(pb);
 
+            if (avio_feof(pb)) {
+                return AVERROR_EOF;
+            }
+
             if (pes_signal != 1 || pes_header_data_length == 0) {
                 pva_log(s, AV_LOG_WARNING, ""expected non empty signaled PES packet, ""
                                           ""trying to recover\n"");",FFmpeg,9807d3976be0e92e4ece3b4b1701be894cd7c2e1,a7e032a277452366771951e29fd0bf2bd5c029f0,1,"static int read_part_of_packet(AVFormatContext *s, int64_t *pts,
                               int *len, int *strid, int read_packet) {
    AVIOContext *pb = s->pb;
    PVAContext *pvactx = s->priv_data;
    int syncword, streamid, reserved, flags, length, pts_flag;
    int64_t pva_pts = AV_NOPTS_VALUE, startpos;
    int ret;

recover:
    startpos = avio_tell(pb);

    syncword = avio_rb16(pb);
    streamid = avio_r8(pb);
    avio_r8(pb);               /* counter not used */
    reserved = avio_r8(pb);
    flags    = avio_r8(pb);
    length   = avio_rb16(pb);

    pts_flag = flags & 0x10;

    if (syncword != PVA_MAGIC) {
        pva_log(s, AV_LOG_ERROR, ""invalid syncword\n"");
        return AVERROR(EIO);
    }
    if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) {
        pva_log(s, AV_LOG_ERROR, ""invalid streamid\n"");
        return AVERROR(EIO);
    }
    if (reserved != 0x55) {
        pva_log(s, AV_LOG_WARNING, ""expected reserved byte to be 0x55\n"");
    }
    if (length > PVA_MAX_PAYLOAD_LENGTH) {
        pva_log(s, AV_LOG_ERROR, ""invalid payload length %u\n"", length);
        return AVERROR(EIO);
    }

    if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) {
        pva_pts = avio_rb32(pb);
        length -= 4;
    } else if (streamid == PVA_AUDIO_PAYLOAD) {
        /* PVA Audio Packets either start with a signaled PES packet or
         * are a continuation of the previous PES packet. New PES packets
         * always start at the beginning of a PVA Packet, never somewhere in
         * the middle. */
        if (!pvactx->continue_pes) {
            int pes_signal, pes_header_data_length, pes_packet_length,
                pes_flags;
            unsigned char pes_header_data[256];

            pes_signal             = avio_rb24(pb);
            avio_r8(pb);
            pes_packet_length      = avio_rb16(pb);
             pes_flags              = avio_rb16(pb);
             pes_header_data_length = avio_r8(pb);
 
//fix_flaw_line_below:
//            if (avio_feof(pb)) {
//fix_flaw_line_below:
//                return AVERROR_EOF;
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//
             if (pes_signal != 1 || pes_header_data_length == 0) {
                 pva_log(s, AV_LOG_WARNING, ""expected non empty signaled PES packet, ""
                                           ""trying to recover\n"");
                avio_skip(pb, length - 9);
                if (!read_packet)
                    return AVERROR(EIO);
                goto recover;
            }

            ret = avio_read(pb, pes_header_data, pes_header_data_length);
            if (ret != pes_header_data_length)
                return ret < 0 ? ret : AVERROR_INVALIDDATA;
            length -= 9 + pes_header_data_length;

            pes_packet_length -= 3 + pes_header_data_length;

            pvactx->continue_pes = pes_packet_length;

            if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20) {
                if (pes_header_data_length < 5) {
                    pva_log(s, AV_LOG_ERROR, ""header too short\n"");
                    avio_skip(pb, length);
                    return AVERROR_INVALIDDATA;
                }
                pva_pts = ff_parse_pes_pts(pes_header_data);
            }
        }

        pvactx->continue_pes -= length;

        if (pvactx->continue_pes < 0) {
            pva_log(s, AV_LOG_WARNING, ""audio data corruption\n"");
            pvactx->continue_pes = 0;
        }
    }

    if (pva_pts != AV_NOPTS_VALUE)
        av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME);

    *pts   = pva_pts;
    *len   = length;
    *strid = streamid;
    return 0;
}
"
4389,182125,,Remote,Not required,Partial,CVE-2018-20467,https://www.cvedetails.com/cve/CVE-2018-20467/,CWE-835,Medium,,,,2018-12-25,4.3,"In coders/bmp.c in ImageMagick before 7.0.8-16, an input file can result in an infinite loop and hang, with high CPU and memory consumption. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted file.",2019-10-02,DoS ,6,https://github.com/ImageMagick/ImageMagick/commit/db0add932fb850d762b02604ca3053b7d7ab6deb,db0add932fb850d762b02604ca3053b7d7ab6deb,Prevent infinite loop,7,coders/bmp.c,"{""sha"": ""edc5cda546279ec543cead0e0b7352fd46534b03"", ""filename"": ""coders/bmp.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/db0add932fb850d762b02604ca3053b7d7ab6deb/coders/bmp.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/db0add932fb850d762b02604ca3053b7d7ab6deb/coders/bmp.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/bmp.c?ref=db0add932fb850d762b02604ca3053b7d7ab6deb"", ""patch"": ""@@ -660,7 +660,7 @@ static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         bmp_info.x_pixels=ReadBlobLSBLong(image);\n         bmp_info.y_pixels=ReadBlobLSBLong(image);\n         bmp_info.number_colors=ReadBlobLSBLong(image);\n-        if (bmp_info.number_colors > GetBlobSize(image))\n+        if ((MagickSizeType) bmp_info.number_colors > GetBlobSize(image))\n           ThrowReaderException(CorruptImageError,\""InsufficientImageDataInFile\"");\n         bmp_info.colors_important=ReadBlobLSBLong(image);\n         if (image->debug != MagickFalse)\n@@ -1444,13 +1444,12 @@ static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     if (image_info->number_scenes != 0)\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n+    offset=(MagickOffsetType) bmp_info.ba_offset;\n+    if (offset != 0)\n+      if ((offset < TellBlob(image)) ||\n+          (SeekBlob(image,offset,SEEK_SET) != offset))\n+        ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n     *magick='\\0';\n-    if (bmp_info.ba_offset != 0)\n-      {\n-        offset=SeekBlob(image,(MagickOffsetType) bmp_info.ba_offset,SEEK_SET);\n-        if (offset < 0)\n-          ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n-      }\n     count=ReadBlob(image,2,magick);\n     if ((count == 2) && (IsBMP(magick,2) != MagickFalse))\n       {""}","static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  BMPInfo
    bmp_info;

  Image
    *image;

  MagickBooleanType
    status;

  MagickOffsetType
    offset,
    start_position;

  MemoryInfo
    *pixel_info;

  Quantum
    index;

  register Quantum
    *q;

  register ssize_t
    i,
    x;

  register unsigned char
    *p;

  size_t
    bit,
    bytes_per_line,
    length;

  ssize_t
    count,
    y;

  unsigned char
    magick[12],
    *pixels;

  unsigned int
    blue,
    green,
    offset_bits,
    red;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Determine if this a BMP file.
  */
  (void) memset(&bmp_info,0,sizeof(bmp_info));
  bmp_info.ba_offset=0;
  start_position=0;
  offset_bits=0;
  count=ReadBlob(image,2,magick);
  if (count != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  do
  {
    PixelInfo
      quantum_bits;

    PixelPacket
      shift;

    /*
      Verify BMP identifier.
    */
    start_position=TellBlob(image)-2;
    bmp_info.ba_offset=0;
    while (LocaleNCompare((char *) magick,""BA"",2) == 0)
    {
      bmp_info.file_size=ReadBlobLSBLong(image);
      bmp_info.ba_offset=ReadBlobLSBLong(image);
      bmp_info.offset_bits=ReadBlobLSBLong(image);
      count=ReadBlob(image,2,magick);
      if (count != 2)
        break;
    }
    if (image->debug != MagickFalse)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Magick: %c%c"",
        magick[0],magick[1]);
    if ((count != 2) || ((LocaleNCompare((char *) magick,""BM"",2) != 0) &&
        (LocaleNCompare((char *) magick,""CI"",2) != 0)))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    bmp_info.file_size=ReadBlobLSBLong(image);
    (void) ReadBlobLSBLong(image);
    bmp_info.offset_bits=ReadBlobLSBLong(image);
    bmp_info.size=ReadBlobLSBLong(image);
    if (image->debug != MagickFalse)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  BMP size: %u"",
        bmp_info.size);
    if (bmp_info.size == 12)
      {
        /*
          OS/2 BMP image file.
        */
        (void) CopyMagickString(image->magick,""BMP2"",MagickPathExtent);
        bmp_info.width=(ssize_t) ((short) ReadBlobLSBShort(image));
        bmp_info.height=(ssize_t) ((short) ReadBlobLSBShort(image));
        bmp_info.planes=ReadBlobLSBShort(image);
        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);
        bmp_info.x_pixels=0;
        bmp_info.y_pixels=0;
        bmp_info.number_colors=0;
        bmp_info.compression=BI_RGB;
        bmp_info.image_size=0;
        bmp_info.alpha_mask=0;
        if (image->debug != MagickFalse)
          {
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Format: OS/2 Bitmap"");
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Geometry: %.20gx%.20g"",(double) bmp_info.width,(double)
              bmp_info.height);
          }
      }
    else
      {
        /*
          Microsoft Windows BMP image file.
        */
        if (bmp_info.size < 40)
          ThrowReaderException(CorruptImageError,""NonOS2HeaderSizeError"");
        bmp_info.width=(ssize_t) ReadBlobLSBSignedLong(image);
        bmp_info.height=(ssize_t) ReadBlobLSBSignedLong(image);
        bmp_info.planes=ReadBlobLSBShort(image);
        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);
        bmp_info.compression=ReadBlobLSBLong(image);
        bmp_info.image_size=ReadBlobLSBLong(image);
         bmp_info.x_pixels=ReadBlobLSBLong(image);
         bmp_info.y_pixels=ReadBlobLSBLong(image);
         bmp_info.number_colors=ReadBlobLSBLong(image);
        if ((MagickSizeType) bmp_info.number_colors > GetBlobSize(image))
           ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
         bmp_info.colors_important=ReadBlobLSBLong(image);
         if (image->debug != MagickFalse)
          {
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Format: MS Windows bitmap"");
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Geometry: %.20gx%.20g"",(double) bmp_info.width,(double)
              bmp_info.height);
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Bits per pixel: %.20g"",(double) bmp_info.bits_per_pixel);
            switch (bmp_info.compression)
            {
              case BI_RGB:
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Compression: BI_RGB"");
                break;
              }
              case BI_RLE4:
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Compression: BI_RLE4"");
                break;
              }
              case BI_RLE8:
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Compression: BI_RLE8"");
                break;
              }
              case BI_BITFIELDS:
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Compression: BI_BITFIELDS"");
                break;
              }
              case BI_PNG:
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Compression: BI_PNG"");
                break;
              }
              case BI_JPEG:
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Compression: BI_JPEG"");
                break;
              }
              default:
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Compression: UNKNOWN (%u)"",bmp_info.compression);
              }
            }
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Number of colors: %u"",bmp_info.number_colors);
          }
        bmp_info.red_mask=ReadBlobLSBLong(image);
        bmp_info.green_mask=ReadBlobLSBLong(image);
        bmp_info.blue_mask=ReadBlobLSBLong(image);
        if (bmp_info.size > 40)
          {
            double
              gamma;

            /*
              Read color management information.
            */
            bmp_info.alpha_mask=ReadBlobLSBLong(image);
            bmp_info.colorspace=ReadBlobLSBSignedLong(image);
            /*
              Decode 2^30 fixed point formatted CIE primaries.
            */
#           define BMP_DENOM ((double) 0x40000000)
            bmp_info.red_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.red_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.red_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.green_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.green_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.green_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.blue_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.blue_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.blue_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;

            gamma=bmp_info.red_primary.x+bmp_info.red_primary.y+
              bmp_info.red_primary.z;
            gamma=PerceptibleReciprocal(gamma);
            bmp_info.red_primary.x*=gamma;
            bmp_info.red_primary.y*=gamma;
            image->chromaticity.red_primary.x=bmp_info.red_primary.x;
            image->chromaticity.red_primary.y=bmp_info.red_primary.y;

            gamma=bmp_info.green_primary.x+bmp_info.green_primary.y+
              bmp_info.green_primary.z;
            gamma=PerceptibleReciprocal(gamma);
            bmp_info.green_primary.x*=gamma;
            bmp_info.green_primary.y*=gamma;
            image->chromaticity.green_primary.x=bmp_info.green_primary.x;
            image->chromaticity.green_primary.y=bmp_info.green_primary.y;

            gamma=bmp_info.blue_primary.x+bmp_info.blue_primary.y+
              bmp_info.blue_primary.z;
            gamma=PerceptibleReciprocal(gamma);
            bmp_info.blue_primary.x*=gamma;
            bmp_info.blue_primary.y*=gamma;
            image->chromaticity.blue_primary.x=bmp_info.blue_primary.x;
            image->chromaticity.blue_primary.y=bmp_info.blue_primary.y;

            /*
              Decode 16^16 fixed point formatted gamma_scales.
            */
            bmp_info.gamma_scale.x=(double) ReadBlobLSBLong(image)/0x10000;
            bmp_info.gamma_scale.y=(double) ReadBlobLSBLong(image)/0x10000;
            bmp_info.gamma_scale.z=(double) ReadBlobLSBLong(image)/0x10000;
            /*
              Compute a single gamma from the BMP 3-channel gamma.
            */
            image->gamma=(bmp_info.gamma_scale.x+bmp_info.gamma_scale.y+
              bmp_info.gamma_scale.z)/3.0;
          }
        else
          (void) CopyMagickString(image->magick,""BMP3"",MagickPathExtent);

        if (bmp_info.size > 108)
          {
            size_t
              intent;

            /*
              Read BMP Version 5 color management information.
            */
            intent=ReadBlobLSBLong(image);
            switch ((int) intent)
            {
              case LCS_GM_BUSINESS:
              {
                image->rendering_intent=SaturationIntent;
                break;
              }
              case LCS_GM_GRAPHICS:
              {
                image->rendering_intent=RelativeIntent;
                break;
              }
              case LCS_GM_IMAGES:
              {
                image->rendering_intent=PerceptualIntent;
                break;
              }
              case LCS_GM_ABS_COLORIMETRIC:
              {
                image->rendering_intent=AbsoluteIntent;
                break;
              }
            }
            (void) ReadBlobLSBLong(image);  /* Profile data */
            (void) ReadBlobLSBLong(image);  /* Profile size */
            (void) ReadBlobLSBLong(image);  /* Reserved byte */
          }
      }
    if ((MagickSizeType) bmp_info.file_size > GetBlobSize(image))
      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,
        ""LengthAndFilesizeDoNotMatch"",""`%s'"",image->filename);
    else
      if ((MagickSizeType) bmp_info.file_size < GetBlobSize(image))
        (void) ThrowMagickException(exception,GetMagickModule(),
          CorruptImageWarning,""LengthAndFilesizeDoNotMatch"",""`%s'"",
          image->filename);
    if (bmp_info.width <= 0)
      ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
    if (bmp_info.height == 0)
      ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
    if (bmp_info.planes != 1)
      ThrowReaderException(CorruptImageError,""StaticPlanesValueNotEqualToOne"");
    if ((bmp_info.bits_per_pixel != 1) && (bmp_info.bits_per_pixel != 4) &&
        (bmp_info.bits_per_pixel != 8) && (bmp_info.bits_per_pixel != 16) &&
        (bmp_info.bits_per_pixel != 24) && (bmp_info.bits_per_pixel != 32))
      ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");
    if (bmp_info.bits_per_pixel < 16 &&
        bmp_info.number_colors > (1U << bmp_info.bits_per_pixel))
      ThrowReaderException(CorruptImageError,""UnrecognizedNumberOfColors"");
    if ((bmp_info.compression == 1) && (bmp_info.bits_per_pixel != 8))
      ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");
    if ((bmp_info.compression == 2) && (bmp_info.bits_per_pixel != 4))
      ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");
    if ((bmp_info.compression == 3) && (bmp_info.bits_per_pixel < 16))
      ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");
    switch (bmp_info.compression)
    {
      case BI_RGB:
        image->compression=NoCompression;
        break;
      case BI_RLE8:
      case BI_RLE4:
        image->compression=RLECompression;
        break;
      case BI_BITFIELDS:
        break;
      case BI_JPEG:
        ThrowReaderException(CoderError,""JPEGCompressNotSupported"");
      case BI_PNG:
        ThrowReaderException(CoderError,""PNGCompressNotSupported"");
      default:
        ThrowReaderException(CorruptImageError,""UnrecognizedImageCompression"");
    }
    image->columns=(size_t) MagickAbsoluteValue(bmp_info.width);
    image->rows=(size_t) MagickAbsoluteValue(bmp_info.height);
    image->depth=bmp_info.bits_per_pixel <= 8 ? bmp_info.bits_per_pixel : 8;
    image->alpha_trait=((bmp_info.alpha_mask != 0) &&
      (bmp_info.compression == BI_BITFIELDS)) ? BlendPixelTrait :
      UndefinedPixelTrait;
    if (bmp_info.bits_per_pixel < 16)
      {
        size_t
          one;

        image->storage_class=PseudoClass;
        image->colors=bmp_info.number_colors;
        one=1;
        if (image->colors == 0)
          image->colors=one << bmp_info.bits_per_pixel;
      }
    image->resolution.x=(double) bmp_info.x_pixels/100.0;
    image->resolution.y=(double) bmp_info.y_pixels/100.0;
    image->units=PixelsPerCentimeterResolution;
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    if (image->storage_class == PseudoClass)
      {
        unsigned char
          *bmp_colormap;

        size_t
          packet_size;

        /*
          Read BMP raster colormap.
        */
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  Reading colormap of %.20g colors"",(double) image->colors);
        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t)
          image->colors,4*sizeof(*bmp_colormap));
        if (bmp_colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        if ((bmp_info.size == 12) || (bmp_info.size == 64))
          packet_size=3;
        else
          packet_size=4;
        offset=SeekBlob(image,start_position+14+bmp_info.size,SEEK_SET);
        if (offset < 0)
          {
            bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);
            ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
          }
        count=ReadBlob(image,packet_size*image->colors,bmp_colormap);
        if (count != (ssize_t) (packet_size*image->colors))
          {
            bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);
            ThrowReaderException(CorruptImageError,
              ""InsufficientImageDataInFile"");
          }
        p=bmp_colormap;
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(*p++);
          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(*p++);
          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(*p++);
          if (packet_size == 4)
            p++;
        }
        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);
      }
    /*
      Read image data.
    */
    if (bmp_info.offset_bits == offset_bits)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    offset_bits=bmp_info.offset_bits;
    offset=SeekBlob(image,start_position+bmp_info.offset_bits,SEEK_SET);
    if (offset < 0)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if (bmp_info.compression == BI_RLE4)
      bmp_info.bits_per_pixel<<=1;
    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);
    length=(size_t) bytes_per_line*image->rows;
    if ((bmp_info.compression == BI_RGB) ||
        (bmp_info.compression == BI_BITFIELDS))
      {
        if ((MagickSizeType) length > GetBlobSize(image))
          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
        pixel_info=AcquireVirtualMemory(image->rows,
          MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));
        if (pixel_info == (MemoryInfo *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  Reading pixels (%.20g bytes)"",(double) length);
        count=ReadBlob(image,length,pixels);
        if (count != (ssize_t) length)
          {
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(CorruptImageError,
              ""InsufficientImageDataInFile"");
          }
      }
    else
      {
        /*
          Convert run-length encoded raster pixels.
        */
        pixel_info=AcquireVirtualMemory(image->rows,
          MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));
        if (pixel_info == (MemoryInfo *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
        status=DecodeImage(image,bmp_info.compression,pixels,
          image->columns*image->rows);
        if (status == MagickFalse)
          {
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(CorruptImageError,
              ""UnableToRunlengthDecodeImage"");
          }
      }
    /*
      Convert BMP raster image to pixel packets.
    */
    if (bmp_info.compression == BI_RGB)
      {
        /*
          We should ignore the alpha value in BMP3 files but there have been
          reports about 32 bit files with alpha. We do a quick check to see if
          the alpha channel contains a value that is not zero (default value).
          If we find a non zero value we asume the program that wrote the file
          wants to use the alpha channel.
        */
        if ((image->alpha_trait == UndefinedPixelTrait) && (bmp_info.size == 40) &&
            (bmp_info.bits_per_pixel == 32))
          {
            bytes_per_line=4*(image->columns);
            for (y=(ssize_t) image->rows-1; y >= 0; y--)
            {
              p=pixels+(image->rows-y-1)*bytes_per_line;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                if (*(p+3) != 0)
                  {
                    image->alpha_trait=BlendPixelTrait;
                    y=-1;
                    break;
                  }
                p+=4;
              }
            }
          }
        bmp_info.alpha_mask=image->alpha_trait != UndefinedPixelTrait ?
          0xff000000U : 0U;
        bmp_info.red_mask=0x00ff0000U;
        bmp_info.green_mask=0x0000ff00U;
        bmp_info.blue_mask=0x000000ffU;
        if (bmp_info.bits_per_pixel == 16)
          {
            /*
              RGB555.
            */
            bmp_info.red_mask=0x00007c00U;
            bmp_info.green_mask=0x000003e0U;
            bmp_info.blue_mask=0x0000001fU;
          }
      }
    (void) memset(&shift,0,sizeof(shift));
    (void) memset(&quantum_bits,0,sizeof(quantum_bits));
    if ((bmp_info.bits_per_pixel == 16) || (bmp_info.bits_per_pixel == 32))
      {
        register unsigned int
          sample;

        /*
          Get shift and quantum bits info from bitfield masks.
        */
        if (bmp_info.red_mask != 0)
          while (((bmp_info.red_mask << shift.red) & 0x80000000UL) == 0)
          {
            shift.red++;
            if (shift.red >= 32U)
              break;
          }
        if (bmp_info.green_mask != 0)
          while (((bmp_info.green_mask << shift.green) & 0x80000000UL) == 0)
          {
            shift.green++;
            if (shift.green >= 32U)
              break;
          }
        if (bmp_info.blue_mask != 0)
          while (((bmp_info.blue_mask << shift.blue) & 0x80000000UL) == 0)
          {
            shift.blue++;
            if (shift.blue >= 32U)
              break;
          }
        if (bmp_info.alpha_mask != 0)
          while (((bmp_info.alpha_mask << shift.alpha) & 0x80000000UL) == 0)
          {
            shift.alpha++;
            if (shift.alpha >= 32U)
              break;
          }
        sample=shift.red;
        while (((bmp_info.red_mask << sample) & 0x80000000UL) != 0)
        {
          sample++;
          if (sample >= 32U)
            break;
        }
        quantum_bits.red=(MagickRealType) (sample-shift.red);
        sample=shift.green;
        while (((bmp_info.green_mask << sample) & 0x80000000UL) != 0)
        {
          sample++;
          if (sample >= 32U)
            break;
        }
        quantum_bits.green=(MagickRealType) (sample-shift.green);
        sample=shift.blue;
        while (((bmp_info.blue_mask << sample) & 0x80000000UL) != 0)
        {
          sample++;
          if (sample >= 32U)
            break;
        }
        quantum_bits.blue=(MagickRealType) (sample-shift.blue);
        sample=shift.alpha;
        while (((bmp_info.alpha_mask << sample) & 0x80000000UL) != 0)
        {
          sample++;
          if (sample >= 32U)
            break;
        }
        quantum_bits.alpha=(MagickRealType) (sample-shift.alpha);
      }
    switch (bmp_info.bits_per_pixel)
    {
      case 1:
      {
        /*
          Convert bitmap scanline.
        */
        for (y=(ssize_t) image->rows-1; y >= 0; y--)
        {
          p=pixels+(image->rows-y-1)*bytes_per_line;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < ((ssize_t) image->columns-7); x+=8)
          {
            for (bit=0; bit < 8; bit++)
            {
              index=(Quantum) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);
              SetPixelIndex(image,index,q);
              q+=GetPixelChannels(image);
            }
            p++;
          }
          if ((image->columns % 8) != 0)
            {
              for (bit=0; bit < (image->columns % 8); bit++)
              {
                index=(Quantum) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);
                SetPixelIndex(image,index,q);
                q+=GetPixelChannels(image);
              }
              p++;
            }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                (image->rows-y),image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        (void) SyncImage(image,exception);
        break;
      }
      case 4:
      {
        /*
          Convert PseudoColor scanline.
        */
        for (y=(ssize_t) image->rows-1; y >= 0; y--)
        {
          p=pixels+(image->rows-y-1)*bytes_per_line;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < ((ssize_t) image->columns-1); x+=2)
          {
            ValidateColormapValue(image,(ssize_t) ((*p >> 4) & 0x0f),&index,
              exception);
            SetPixelIndex(image,index,q);
            q+=GetPixelChannels(image);
            ValidateColormapValue(image,(ssize_t) (*p & 0x0f),&index,exception);
            SetPixelIndex(image,index,q);
            q+=GetPixelChannels(image);
            p++;
          }
          if ((image->columns % 2) != 0)
            {
              ValidateColormapValue(image,(ssize_t) ((*p >> 4) & 0xf),&index,
                exception);
              SetPixelIndex(image,index,q);
              q+=GetPixelChannels(image);
              p++;
              x++;
            }
          if (x < (ssize_t) image->columns)
            break;
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                (image->rows-y),image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        (void) SyncImage(image,exception);
        break;
      }
      case 8:
      {
        /*
          Convert PseudoColor scanline.
        */
        if ((bmp_info.compression == BI_RLE8) ||
            (bmp_info.compression == BI_RLE4))
          bytes_per_line=image->columns;
        for (y=(ssize_t) image->rows-1; y >= 0; y--)
        {
          p=pixels+(image->rows-y-1)*bytes_per_line;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=(ssize_t) image->columns; x != 0; --x)
          {
            ValidateColormapValue(image,(ssize_t) *p++,&index,exception);
            SetPixelIndex(image,index,q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          offset=(MagickOffsetType) (image->rows-y-1);
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                (image->rows-y),image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        (void) SyncImage(image,exception);
        break;
      }
      case 16:
      {
        unsigned int
          alpha,
          pixel;

        /*
          Convert bitfield encoded 16-bit PseudoColor scanline.
        */
        if ((bmp_info.compression != BI_RGB) &&
            (bmp_info.compression != BI_BITFIELDS))
          {
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(CorruptImageError,
              ""UnrecognizedImageCompression"");
          }
        bytes_per_line=2*(image->columns+image->columns % 2);
        image->storage_class=DirectClass;
        for (y=(ssize_t) image->rows-1; y >= 0; y--)
        {
          p=pixels+(image->rows-y-1)*bytes_per_line;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            pixel=(unsigned int) (*p++);
            pixel|=(*p++) << 8;
            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;
            if (quantum_bits.red == 5)
              red|=((red & 0xe000) >> 5);
            if (quantum_bits.red <= 8)
              red|=((red & 0xff00) >> 8);
            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;
            if (quantum_bits.green == 5)
              green|=((green & 0xe000) >> 5);
            if (quantum_bits.green == 6)
              green|=((green & 0xc000) >> 6);
            if (quantum_bits.green <= 8)
              green|=((green & 0xff00) >> 8);
            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;
            if (quantum_bits.blue == 5)
              blue|=((blue & 0xe000) >> 5);
            if (quantum_bits.blue <= 8)
              blue|=((blue & 0xff00) >> 8);
            SetPixelRed(image,ScaleShortToQuantum((unsigned short) red),q);
            SetPixelGreen(image,ScaleShortToQuantum((unsigned short) green),q);
            SetPixelBlue(image,ScaleShortToQuantum((unsigned short) blue),q);
            SetPixelAlpha(image,OpaqueAlpha,q);
            if (image->alpha_trait != UndefinedPixelTrait)
              {
                alpha=((pixel & bmp_info.alpha_mask) << shift.alpha) >> 16;
                if (quantum_bits.alpha <= 8)
                  alpha|=((alpha & 0xff00) >> 8);
                SetPixelAlpha(image,ScaleShortToQuantum(
                  (unsigned short) alpha),q);
              }
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          offset=(MagickOffsetType) (image->rows-y-1);
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                (image->rows-y),image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case 24:
      {
        /*
          Convert DirectColor scanline.
        */
        bytes_per_line=4*((image->columns*24+31)/32);
        for (y=(ssize_t) image->rows-1; y >= 0; y--)
        {
          p=pixels+(image->rows-y-1)*bytes_per_line;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
            SetPixelRed(image,ScaleCharToQuantum(*p++),q);
            SetPixelAlpha(image,OpaqueAlpha,q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          offset=(MagickOffsetType) (image->rows-y-1);
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                (image->rows-y),image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case 32:
      {
        /*
          Convert bitfield encoded DirectColor scanline.
        */
        if ((bmp_info.compression != BI_RGB) &&
            (bmp_info.compression != BI_BITFIELDS))
          {
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(CorruptImageError,
              ""UnrecognizedImageCompression"");
          }
        bytes_per_line=4*(image->columns);
        for (y=(ssize_t) image->rows-1; y >= 0; y--)
        {
          unsigned int
            alpha,
            pixel;

          p=pixels+(image->rows-y-1)*bytes_per_line;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            pixel=(unsigned int) (*p++);
            pixel|=((unsigned int) *p++ << 8);
            pixel|=((unsigned int) *p++ << 16);
            pixel|=((unsigned int) *p++ << 24);
            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;
            if (quantum_bits.red == 8)
              red|=(red >> 8);
            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;
            if (quantum_bits.green == 8)
              green|=(green >> 8);
            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;
            if (quantum_bits.blue == 8)
              blue|=(blue >> 8);
            SetPixelRed(image,ScaleShortToQuantum((unsigned short) red),q);
            SetPixelGreen(image,ScaleShortToQuantum((unsigned short) green),q);
            SetPixelBlue(image,ScaleShortToQuantum((unsigned short) blue),q);
            SetPixelAlpha(image,OpaqueAlpha,q);
            if (image->alpha_trait != UndefinedPixelTrait)
              {
                alpha=((pixel & bmp_info.alpha_mask) << shift.alpha) >> 16;
                if (quantum_bits.alpha == 8)
                  alpha|=(alpha >> 8);
                SetPixelAlpha(image,ScaleShortToQuantum(
                  (unsigned short) alpha),q);
              }
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          offset=(MagickOffsetType) (image->rows-y-1);
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                (image->rows-y),image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      default:
      {
        pixel_info=RelinquishVirtualMemory(pixel_info);
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      }
    }
    pixel_info=RelinquishVirtualMemory(pixel_info);
    if (y > 0)
      break;
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    if (bmp_info.height < 0)
      {
        Image
          *flipped_image;

        /*
          Correct image orientation.
        */
        flipped_image=FlipImage(image,exception);
        if (flipped_image != (Image *) NULL)
          {
            DuplicateBlob(flipped_image,image);
            ReplaceImageInList(&image, flipped_image);
            image=flipped_image;
          }
      }
    /*
      Proceed to next image.
    */
     if (image_info->number_scenes != 0)
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
    offset=(MagickOffsetType) bmp_info.ba_offset;
    if (offset != 0)
      if ((offset < TellBlob(image)) ||
          (SeekBlob(image,offset,SEEK_SET) != offset))
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     *magick='\0';
     count=ReadBlob(image,2,magick);
     if ((count == 2) && (IsBMP(magick,2) != MagickFalse))
       {
        /*
          Acquire next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            status=MagickFalse;
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while (IsBMP(magick,2) != MagickFalse);
  (void) CloseBlob(image);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  return(GetFirstImageInList(image));
}
","static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  BMPInfo
    bmp_info;

  Image
    *image;

  MagickBooleanType
    status;

  MagickOffsetType
    offset,
    start_position;

  MemoryInfo
    *pixel_info;

  Quantum
    index;

  register Quantum
    *q;

  register ssize_t
    i,
    x;

  register unsigned char
    *p;

  size_t
    bit,
    bytes_per_line,
    length;

  ssize_t
    count,
    y;

  unsigned char
    magick[12],
    *pixels;

  unsigned int
    blue,
    green,
    offset_bits,
    red;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Determine if this a BMP file.
  */
  (void) memset(&bmp_info,0,sizeof(bmp_info));
  bmp_info.ba_offset=0;
  start_position=0;
  offset_bits=0;
  count=ReadBlob(image,2,magick);
  if (count != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  do
  {
    PixelInfo
      quantum_bits;

    PixelPacket
      shift;

    /*
      Verify BMP identifier.
    */
    start_position=TellBlob(image)-2;
    bmp_info.ba_offset=0;
    while (LocaleNCompare((char *) magick,""BA"",2) == 0)
    {
      bmp_info.file_size=ReadBlobLSBLong(image);
      bmp_info.ba_offset=ReadBlobLSBLong(image);
      bmp_info.offset_bits=ReadBlobLSBLong(image);
      count=ReadBlob(image,2,magick);
      if (count != 2)
        break;
    }
    if (image->debug != MagickFalse)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Magick: %c%c"",
        magick[0],magick[1]);
    if ((count != 2) || ((LocaleNCompare((char *) magick,""BM"",2) != 0) &&
        (LocaleNCompare((char *) magick,""CI"",2) != 0)))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    bmp_info.file_size=ReadBlobLSBLong(image);
    (void) ReadBlobLSBLong(image);
    bmp_info.offset_bits=ReadBlobLSBLong(image);
    bmp_info.size=ReadBlobLSBLong(image);
    if (image->debug != MagickFalse)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  BMP size: %u"",
        bmp_info.size);
    if (bmp_info.size == 12)
      {
        /*
          OS/2 BMP image file.
        */
        (void) CopyMagickString(image->magick,""BMP2"",MagickPathExtent);
        bmp_info.width=(ssize_t) ((short) ReadBlobLSBShort(image));
        bmp_info.height=(ssize_t) ((short) ReadBlobLSBShort(image));
        bmp_info.planes=ReadBlobLSBShort(image);
        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);
        bmp_info.x_pixels=0;
        bmp_info.y_pixels=0;
        bmp_info.number_colors=0;
        bmp_info.compression=BI_RGB;
        bmp_info.image_size=0;
        bmp_info.alpha_mask=0;
        if (image->debug != MagickFalse)
          {
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Format: OS/2 Bitmap"");
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Geometry: %.20gx%.20g"",(double) bmp_info.width,(double)
              bmp_info.height);
          }
      }
    else
      {
        /*
          Microsoft Windows BMP image file.
        */
        if (bmp_info.size < 40)
          ThrowReaderException(CorruptImageError,""NonOS2HeaderSizeError"");
        bmp_info.width=(ssize_t) ReadBlobLSBSignedLong(image);
        bmp_info.height=(ssize_t) ReadBlobLSBSignedLong(image);
        bmp_info.planes=ReadBlobLSBShort(image);
        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);
        bmp_info.compression=ReadBlobLSBLong(image);
        bmp_info.image_size=ReadBlobLSBLong(image);
         bmp_info.x_pixels=ReadBlobLSBLong(image);
         bmp_info.y_pixels=ReadBlobLSBLong(image);
         bmp_info.number_colors=ReadBlobLSBLong(image);
        if (bmp_info.number_colors > GetBlobSize(image))
           ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
         bmp_info.colors_important=ReadBlobLSBLong(image);
         if (image->debug != MagickFalse)
          {
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Format: MS Windows bitmap"");
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Geometry: %.20gx%.20g"",(double) bmp_info.width,(double)
              bmp_info.height);
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Bits per pixel: %.20g"",(double) bmp_info.bits_per_pixel);
            switch (bmp_info.compression)
            {
              case BI_RGB:
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Compression: BI_RGB"");
                break;
              }
              case BI_RLE4:
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Compression: BI_RLE4"");
                break;
              }
              case BI_RLE8:
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Compression: BI_RLE8"");
                break;
              }
              case BI_BITFIELDS:
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Compression: BI_BITFIELDS"");
                break;
              }
              case BI_PNG:
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Compression: BI_PNG"");
                break;
              }
              case BI_JPEG:
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Compression: BI_JPEG"");
                break;
              }
              default:
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Compression: UNKNOWN (%u)"",bmp_info.compression);
              }
            }
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Number of colors: %u"",bmp_info.number_colors);
          }
        bmp_info.red_mask=ReadBlobLSBLong(image);
        bmp_info.green_mask=ReadBlobLSBLong(image);
        bmp_info.blue_mask=ReadBlobLSBLong(image);
        if (bmp_info.size > 40)
          {
            double
              gamma;

            /*
              Read color management information.
            */
            bmp_info.alpha_mask=ReadBlobLSBLong(image);
            bmp_info.colorspace=ReadBlobLSBSignedLong(image);
            /*
              Decode 2^30 fixed point formatted CIE primaries.
            */
#           define BMP_DENOM ((double) 0x40000000)
            bmp_info.red_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.red_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.red_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.green_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.green_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.green_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.blue_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.blue_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.blue_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;

            gamma=bmp_info.red_primary.x+bmp_info.red_primary.y+
              bmp_info.red_primary.z;
            gamma=PerceptibleReciprocal(gamma);
            bmp_info.red_primary.x*=gamma;
            bmp_info.red_primary.y*=gamma;
            image->chromaticity.red_primary.x=bmp_info.red_primary.x;
            image->chromaticity.red_primary.y=bmp_info.red_primary.y;

            gamma=bmp_info.green_primary.x+bmp_info.green_primary.y+
              bmp_info.green_primary.z;
            gamma=PerceptibleReciprocal(gamma);
            bmp_info.green_primary.x*=gamma;
            bmp_info.green_primary.y*=gamma;
            image->chromaticity.green_primary.x=bmp_info.green_primary.x;
            image->chromaticity.green_primary.y=bmp_info.green_primary.y;

            gamma=bmp_info.blue_primary.x+bmp_info.blue_primary.y+
              bmp_info.blue_primary.z;
            gamma=PerceptibleReciprocal(gamma);
            bmp_info.blue_primary.x*=gamma;
            bmp_info.blue_primary.y*=gamma;
            image->chromaticity.blue_primary.x=bmp_info.blue_primary.x;
            image->chromaticity.blue_primary.y=bmp_info.blue_primary.y;

            /*
              Decode 16^16 fixed point formatted gamma_scales.
            */
            bmp_info.gamma_scale.x=(double) ReadBlobLSBLong(image)/0x10000;
            bmp_info.gamma_scale.y=(double) ReadBlobLSBLong(image)/0x10000;
            bmp_info.gamma_scale.z=(double) ReadBlobLSBLong(image)/0x10000;
            /*
              Compute a single gamma from the BMP 3-channel gamma.
            */
            image->gamma=(bmp_info.gamma_scale.x+bmp_info.gamma_scale.y+
              bmp_info.gamma_scale.z)/3.0;
          }
        else
          (void) CopyMagickString(image->magick,""BMP3"",MagickPathExtent);

        if (bmp_info.size > 108)
          {
            size_t
              intent;

            /*
              Read BMP Version 5 color management information.
            */
            intent=ReadBlobLSBLong(image);
            switch ((int) intent)
            {
              case LCS_GM_BUSINESS:
              {
                image->rendering_intent=SaturationIntent;
                break;
              }
              case LCS_GM_GRAPHICS:
              {
                image->rendering_intent=RelativeIntent;
                break;
              }
              case LCS_GM_IMAGES:
              {
                image->rendering_intent=PerceptualIntent;
                break;
              }
              case LCS_GM_ABS_COLORIMETRIC:
              {
                image->rendering_intent=AbsoluteIntent;
                break;
              }
            }
            (void) ReadBlobLSBLong(image);  /* Profile data */
            (void) ReadBlobLSBLong(image);  /* Profile size */
            (void) ReadBlobLSBLong(image);  /* Reserved byte */
          }
      }
    if ((MagickSizeType) bmp_info.file_size > GetBlobSize(image))
      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,
        ""LengthAndFilesizeDoNotMatch"",""`%s'"",image->filename);
    else
      if ((MagickSizeType) bmp_info.file_size < GetBlobSize(image))
        (void) ThrowMagickException(exception,GetMagickModule(),
          CorruptImageWarning,""LengthAndFilesizeDoNotMatch"",""`%s'"",
          image->filename);
    if (bmp_info.width <= 0)
      ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
    if (bmp_info.height == 0)
      ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
    if (bmp_info.planes != 1)
      ThrowReaderException(CorruptImageError,""StaticPlanesValueNotEqualToOne"");
    if ((bmp_info.bits_per_pixel != 1) && (bmp_info.bits_per_pixel != 4) &&
        (bmp_info.bits_per_pixel != 8) && (bmp_info.bits_per_pixel != 16) &&
        (bmp_info.bits_per_pixel != 24) && (bmp_info.bits_per_pixel != 32))
      ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");
    if (bmp_info.bits_per_pixel < 16 &&
        bmp_info.number_colors > (1U << bmp_info.bits_per_pixel))
      ThrowReaderException(CorruptImageError,""UnrecognizedNumberOfColors"");
    if ((bmp_info.compression == 1) && (bmp_info.bits_per_pixel != 8))
      ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");
    if ((bmp_info.compression == 2) && (bmp_info.bits_per_pixel != 4))
      ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");
    if ((bmp_info.compression == 3) && (bmp_info.bits_per_pixel < 16))
      ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");
    switch (bmp_info.compression)
    {
      case BI_RGB:
        image->compression=NoCompression;
        break;
      case BI_RLE8:
      case BI_RLE4:
        image->compression=RLECompression;
        break;
      case BI_BITFIELDS:
        break;
      case BI_JPEG:
        ThrowReaderException(CoderError,""JPEGCompressNotSupported"");
      case BI_PNG:
        ThrowReaderException(CoderError,""PNGCompressNotSupported"");
      default:
        ThrowReaderException(CorruptImageError,""UnrecognizedImageCompression"");
    }
    image->columns=(size_t) MagickAbsoluteValue(bmp_info.width);
    image->rows=(size_t) MagickAbsoluteValue(bmp_info.height);
    image->depth=bmp_info.bits_per_pixel <= 8 ? bmp_info.bits_per_pixel : 8;
    image->alpha_trait=((bmp_info.alpha_mask != 0) &&
      (bmp_info.compression == BI_BITFIELDS)) ? BlendPixelTrait :
      UndefinedPixelTrait;
    if (bmp_info.bits_per_pixel < 16)
      {
        size_t
          one;

        image->storage_class=PseudoClass;
        image->colors=bmp_info.number_colors;
        one=1;
        if (image->colors == 0)
          image->colors=one << bmp_info.bits_per_pixel;
      }
    image->resolution.x=(double) bmp_info.x_pixels/100.0;
    image->resolution.y=(double) bmp_info.y_pixels/100.0;
    image->units=PixelsPerCentimeterResolution;
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    if (image->storage_class == PseudoClass)
      {
        unsigned char
          *bmp_colormap;

        size_t
          packet_size;

        /*
          Read BMP raster colormap.
        */
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  Reading colormap of %.20g colors"",(double) image->colors);
        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t)
          image->colors,4*sizeof(*bmp_colormap));
        if (bmp_colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        if ((bmp_info.size == 12) || (bmp_info.size == 64))
          packet_size=3;
        else
          packet_size=4;
        offset=SeekBlob(image,start_position+14+bmp_info.size,SEEK_SET);
        if (offset < 0)
          {
            bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);
            ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
          }
        count=ReadBlob(image,packet_size*image->colors,bmp_colormap);
        if (count != (ssize_t) (packet_size*image->colors))
          {
            bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);
            ThrowReaderException(CorruptImageError,
              ""InsufficientImageDataInFile"");
          }
        p=bmp_colormap;
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(*p++);
          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(*p++);
          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(*p++);
          if (packet_size == 4)
            p++;
        }
        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);
      }
    /*
      Read image data.
    */
    if (bmp_info.offset_bits == offset_bits)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    offset_bits=bmp_info.offset_bits;
    offset=SeekBlob(image,start_position+bmp_info.offset_bits,SEEK_SET);
    if (offset < 0)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if (bmp_info.compression == BI_RLE4)
      bmp_info.bits_per_pixel<<=1;
    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);
    length=(size_t) bytes_per_line*image->rows;
    if ((bmp_info.compression == BI_RGB) ||
        (bmp_info.compression == BI_BITFIELDS))
      {
        if ((MagickSizeType) length > GetBlobSize(image))
          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
        pixel_info=AcquireVirtualMemory(image->rows,
          MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));
        if (pixel_info == (MemoryInfo *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  Reading pixels (%.20g bytes)"",(double) length);
        count=ReadBlob(image,length,pixels);
        if (count != (ssize_t) length)
          {
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(CorruptImageError,
              ""InsufficientImageDataInFile"");
          }
      }
    else
      {
        /*
          Convert run-length encoded raster pixels.
        */
        pixel_info=AcquireVirtualMemory(image->rows,
          MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));
        if (pixel_info == (MemoryInfo *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
        status=DecodeImage(image,bmp_info.compression,pixels,
          image->columns*image->rows);
        if (status == MagickFalse)
          {
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(CorruptImageError,
              ""UnableToRunlengthDecodeImage"");
          }
      }
    /*
      Convert BMP raster image to pixel packets.
    */
    if (bmp_info.compression == BI_RGB)
      {
        /*
          We should ignore the alpha value in BMP3 files but there have been
          reports about 32 bit files with alpha. We do a quick check to see if
          the alpha channel contains a value that is not zero (default value).
          If we find a non zero value we asume the program that wrote the file
          wants to use the alpha channel.
        */
        if ((image->alpha_trait == UndefinedPixelTrait) && (bmp_info.size == 40) &&
            (bmp_info.bits_per_pixel == 32))
          {
            bytes_per_line=4*(image->columns);
            for (y=(ssize_t) image->rows-1; y >= 0; y--)
            {
              p=pixels+(image->rows-y-1)*bytes_per_line;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                if (*(p+3) != 0)
                  {
                    image->alpha_trait=BlendPixelTrait;
                    y=-1;
                    break;
                  }
                p+=4;
              }
            }
          }
        bmp_info.alpha_mask=image->alpha_trait != UndefinedPixelTrait ?
          0xff000000U : 0U;
        bmp_info.red_mask=0x00ff0000U;
        bmp_info.green_mask=0x0000ff00U;
        bmp_info.blue_mask=0x000000ffU;
        if (bmp_info.bits_per_pixel == 16)
          {
            /*
              RGB555.
            */
            bmp_info.red_mask=0x00007c00U;
            bmp_info.green_mask=0x000003e0U;
            bmp_info.blue_mask=0x0000001fU;
          }
      }
    (void) memset(&shift,0,sizeof(shift));
    (void) memset(&quantum_bits,0,sizeof(quantum_bits));
    if ((bmp_info.bits_per_pixel == 16) || (bmp_info.bits_per_pixel == 32))
      {
        register unsigned int
          sample;

        /*
          Get shift and quantum bits info from bitfield masks.
        */
        if (bmp_info.red_mask != 0)
          while (((bmp_info.red_mask << shift.red) & 0x80000000UL) == 0)
          {
            shift.red++;
            if (shift.red >= 32U)
              break;
          }
        if (bmp_info.green_mask != 0)
          while (((bmp_info.green_mask << shift.green) & 0x80000000UL) == 0)
          {
            shift.green++;
            if (shift.green >= 32U)
              break;
          }
        if (bmp_info.blue_mask != 0)
          while (((bmp_info.blue_mask << shift.blue) & 0x80000000UL) == 0)
          {
            shift.blue++;
            if (shift.blue >= 32U)
              break;
          }
        if (bmp_info.alpha_mask != 0)
          while (((bmp_info.alpha_mask << shift.alpha) & 0x80000000UL) == 0)
          {
            shift.alpha++;
            if (shift.alpha >= 32U)
              break;
          }
        sample=shift.red;
        while (((bmp_info.red_mask << sample) & 0x80000000UL) != 0)
        {
          sample++;
          if (sample >= 32U)
            break;
        }
        quantum_bits.red=(MagickRealType) (sample-shift.red);
        sample=shift.green;
        while (((bmp_info.green_mask << sample) & 0x80000000UL) != 0)
        {
          sample++;
          if (sample >= 32U)
            break;
        }
        quantum_bits.green=(MagickRealType) (sample-shift.green);
        sample=shift.blue;
        while (((bmp_info.blue_mask << sample) & 0x80000000UL) != 0)
        {
          sample++;
          if (sample >= 32U)
            break;
        }
        quantum_bits.blue=(MagickRealType) (sample-shift.blue);
        sample=shift.alpha;
        while (((bmp_info.alpha_mask << sample) & 0x80000000UL) != 0)
        {
          sample++;
          if (sample >= 32U)
            break;
        }
        quantum_bits.alpha=(MagickRealType) (sample-shift.alpha);
      }
    switch (bmp_info.bits_per_pixel)
    {
      case 1:
      {
        /*
          Convert bitmap scanline.
        */
        for (y=(ssize_t) image->rows-1; y >= 0; y--)
        {
          p=pixels+(image->rows-y-1)*bytes_per_line;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < ((ssize_t) image->columns-7); x+=8)
          {
            for (bit=0; bit < 8; bit++)
            {
              index=(Quantum) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);
              SetPixelIndex(image,index,q);
              q+=GetPixelChannels(image);
            }
            p++;
          }
          if ((image->columns % 8) != 0)
            {
              for (bit=0; bit < (image->columns % 8); bit++)
              {
                index=(Quantum) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);
                SetPixelIndex(image,index,q);
                q+=GetPixelChannels(image);
              }
              p++;
            }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                (image->rows-y),image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        (void) SyncImage(image,exception);
        break;
      }
      case 4:
      {
        /*
          Convert PseudoColor scanline.
        */
        for (y=(ssize_t) image->rows-1; y >= 0; y--)
        {
          p=pixels+(image->rows-y-1)*bytes_per_line;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < ((ssize_t) image->columns-1); x+=2)
          {
            ValidateColormapValue(image,(ssize_t) ((*p >> 4) & 0x0f),&index,
              exception);
            SetPixelIndex(image,index,q);
            q+=GetPixelChannels(image);
            ValidateColormapValue(image,(ssize_t) (*p & 0x0f),&index,exception);
            SetPixelIndex(image,index,q);
            q+=GetPixelChannels(image);
            p++;
          }
          if ((image->columns % 2) != 0)
            {
              ValidateColormapValue(image,(ssize_t) ((*p >> 4) & 0xf),&index,
                exception);
              SetPixelIndex(image,index,q);
              q+=GetPixelChannels(image);
              p++;
              x++;
            }
          if (x < (ssize_t) image->columns)
            break;
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                (image->rows-y),image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        (void) SyncImage(image,exception);
        break;
      }
      case 8:
      {
        /*
          Convert PseudoColor scanline.
        */
        if ((bmp_info.compression == BI_RLE8) ||
            (bmp_info.compression == BI_RLE4))
          bytes_per_line=image->columns;
        for (y=(ssize_t) image->rows-1; y >= 0; y--)
        {
          p=pixels+(image->rows-y-1)*bytes_per_line;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=(ssize_t) image->columns; x != 0; --x)
          {
            ValidateColormapValue(image,(ssize_t) *p++,&index,exception);
            SetPixelIndex(image,index,q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          offset=(MagickOffsetType) (image->rows-y-1);
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                (image->rows-y),image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        (void) SyncImage(image,exception);
        break;
      }
      case 16:
      {
        unsigned int
          alpha,
          pixel;

        /*
          Convert bitfield encoded 16-bit PseudoColor scanline.
        */
        if ((bmp_info.compression != BI_RGB) &&
            (bmp_info.compression != BI_BITFIELDS))
          {
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(CorruptImageError,
              ""UnrecognizedImageCompression"");
          }
        bytes_per_line=2*(image->columns+image->columns % 2);
        image->storage_class=DirectClass;
        for (y=(ssize_t) image->rows-1; y >= 0; y--)
        {
          p=pixels+(image->rows-y-1)*bytes_per_line;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            pixel=(unsigned int) (*p++);
            pixel|=(*p++) << 8;
            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;
            if (quantum_bits.red == 5)
              red|=((red & 0xe000) >> 5);
            if (quantum_bits.red <= 8)
              red|=((red & 0xff00) >> 8);
            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;
            if (quantum_bits.green == 5)
              green|=((green & 0xe000) >> 5);
            if (quantum_bits.green == 6)
              green|=((green & 0xc000) >> 6);
            if (quantum_bits.green <= 8)
              green|=((green & 0xff00) >> 8);
            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;
            if (quantum_bits.blue == 5)
              blue|=((blue & 0xe000) >> 5);
            if (quantum_bits.blue <= 8)
              blue|=((blue & 0xff00) >> 8);
            SetPixelRed(image,ScaleShortToQuantum((unsigned short) red),q);
            SetPixelGreen(image,ScaleShortToQuantum((unsigned short) green),q);
            SetPixelBlue(image,ScaleShortToQuantum((unsigned short) blue),q);
            SetPixelAlpha(image,OpaqueAlpha,q);
            if (image->alpha_trait != UndefinedPixelTrait)
              {
                alpha=((pixel & bmp_info.alpha_mask) << shift.alpha) >> 16;
                if (quantum_bits.alpha <= 8)
                  alpha|=((alpha & 0xff00) >> 8);
                SetPixelAlpha(image,ScaleShortToQuantum(
                  (unsigned short) alpha),q);
              }
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          offset=(MagickOffsetType) (image->rows-y-1);
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                (image->rows-y),image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case 24:
      {
        /*
          Convert DirectColor scanline.
        */
        bytes_per_line=4*((image->columns*24+31)/32);
        for (y=(ssize_t) image->rows-1; y >= 0; y--)
        {
          p=pixels+(image->rows-y-1)*bytes_per_line;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
            SetPixelRed(image,ScaleCharToQuantum(*p++),q);
            SetPixelAlpha(image,OpaqueAlpha,q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          offset=(MagickOffsetType) (image->rows-y-1);
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                (image->rows-y),image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case 32:
      {
        /*
          Convert bitfield encoded DirectColor scanline.
        */
        if ((bmp_info.compression != BI_RGB) &&
            (bmp_info.compression != BI_BITFIELDS))
          {
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(CorruptImageError,
              ""UnrecognizedImageCompression"");
          }
        bytes_per_line=4*(image->columns);
        for (y=(ssize_t) image->rows-1; y >= 0; y--)
        {
          unsigned int
            alpha,
            pixel;

          p=pixels+(image->rows-y-1)*bytes_per_line;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            pixel=(unsigned int) (*p++);
            pixel|=((unsigned int) *p++ << 8);
            pixel|=((unsigned int) *p++ << 16);
            pixel|=((unsigned int) *p++ << 24);
            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;
            if (quantum_bits.red == 8)
              red|=(red >> 8);
            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;
            if (quantum_bits.green == 8)
              green|=(green >> 8);
            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;
            if (quantum_bits.blue == 8)
              blue|=(blue >> 8);
            SetPixelRed(image,ScaleShortToQuantum((unsigned short) red),q);
            SetPixelGreen(image,ScaleShortToQuantum((unsigned short) green),q);
            SetPixelBlue(image,ScaleShortToQuantum((unsigned short) blue),q);
            SetPixelAlpha(image,OpaqueAlpha,q);
            if (image->alpha_trait != UndefinedPixelTrait)
              {
                alpha=((pixel & bmp_info.alpha_mask) << shift.alpha) >> 16;
                if (quantum_bits.alpha == 8)
                  alpha|=(alpha >> 8);
                SetPixelAlpha(image,ScaleShortToQuantum(
                  (unsigned short) alpha),q);
              }
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          offset=(MagickOffsetType) (image->rows-y-1);
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                (image->rows-y),image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      default:
      {
        pixel_info=RelinquishVirtualMemory(pixel_info);
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      }
    }
    pixel_info=RelinquishVirtualMemory(pixel_info);
    if (y > 0)
      break;
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    if (bmp_info.height < 0)
      {
        Image
          *flipped_image;

        /*
          Correct image orientation.
        */
        flipped_image=FlipImage(image,exception);
        if (flipped_image != (Image *) NULL)
          {
            DuplicateBlob(flipped_image,image);
            ReplaceImageInList(&image, flipped_image);
            image=flipped_image;
          }
      }
    /*
      Proceed to next image.
    */
     if (image_info->number_scenes != 0)
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     *magick='\0';
    if (bmp_info.ba_offset != 0)
      {
        offset=SeekBlob(image,(MagickOffsetType) bmp_info.ba_offset,SEEK_SET);
        if (offset < 0)
          ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      }
     count=ReadBlob(image,2,magick);
     if ((count == 2) && (IsBMP(magick,2) != MagickFalse))
       {
        /*
          Acquire next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            status=MagickFalse;
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while (IsBMP(magick,2) != MagickFalse);
  (void) CloseBlob(image);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  return(GetFirstImageInList(image));
}
",C,"        if ((MagickSizeType) bmp_info.number_colors > GetBlobSize(image))
    offset=(MagickOffsetType) bmp_info.ba_offset;
    if (offset != 0)
      if ((offset < TellBlob(image)) ||
          (SeekBlob(image,offset,SEEK_SET) != offset))
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
","        if (bmp_info.number_colors > GetBlobSize(image))
    if (bmp_info.ba_offset != 0)
      {
        offset=SeekBlob(image,(MagickOffsetType) bmp_info.ba_offset,SEEK_SET);
        if (offset < 0)
          ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      }
",,"@@ -660,7 +660,7 @@ static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)
         bmp_info.x_pixels=ReadBlobLSBLong(image);
         bmp_info.y_pixels=ReadBlobLSBLong(image);
         bmp_info.number_colors=ReadBlobLSBLong(image);
-        if (bmp_info.number_colors > GetBlobSize(image))
+        if ((MagickSizeType) bmp_info.number_colors > GetBlobSize(image))
           ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
         bmp_info.colors_important=ReadBlobLSBLong(image);
         if (image->debug != MagickFalse)
@@ -1444,13 +1444,12 @@ static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)
     if (image_info->number_scenes != 0)
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
+    offset=(MagickOffsetType) bmp_info.ba_offset;
+    if (offset != 0)
+      if ((offset < TellBlob(image)) ||
+          (SeekBlob(image,offset,SEEK_SET) != offset))
+        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     *magick='\0';
-    if (bmp_info.ba_offset != 0)
-      {
-        offset=SeekBlob(image,(MagickOffsetType) bmp_info.ba_offset,SEEK_SET);
-        if (offset < 0)
-          ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
-      }
     count=ReadBlob(image,2,magick);
     if ((count == 2) && (IsBMP(magick,2) != MagickFalse))
       {",ImageMagick,db0add932fb850d762b02604ca3053b7d7ab6deb,6a7ac23af498532443ccbfe1941a140100255502,1,"static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  BMPInfo
    bmp_info;

  Image
    *image;

  MagickBooleanType
    status;

  MagickOffsetType
    offset,
    start_position;

  MemoryInfo
    *pixel_info;

  Quantum
    index;

  register Quantum
    *q;

  register ssize_t
    i,
    x;

  register unsigned char
    *p;

  size_t
    bit,
    bytes_per_line,
    length;

  ssize_t
    count,
    y;

  unsigned char
    magick[12],
    *pixels;

  unsigned int
    blue,
    green,
    offset_bits,
    red;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Determine if this a BMP file.
  */
  (void) memset(&bmp_info,0,sizeof(bmp_info));
  bmp_info.ba_offset=0;
  start_position=0;
  offset_bits=0;
  count=ReadBlob(image,2,magick);
  if (count != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  do
  {
    PixelInfo
      quantum_bits;

    PixelPacket
      shift;

    /*
      Verify BMP identifier.
    */
    start_position=TellBlob(image)-2;
    bmp_info.ba_offset=0;
    while (LocaleNCompare((char *) magick,""BA"",2) == 0)
    {
      bmp_info.file_size=ReadBlobLSBLong(image);
      bmp_info.ba_offset=ReadBlobLSBLong(image);
      bmp_info.offset_bits=ReadBlobLSBLong(image);
      count=ReadBlob(image,2,magick);
      if (count != 2)
        break;
    }
    if (image->debug != MagickFalse)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Magick: %c%c"",
        magick[0],magick[1]);
    if ((count != 2) || ((LocaleNCompare((char *) magick,""BM"",2) != 0) &&
        (LocaleNCompare((char *) magick,""CI"",2) != 0)))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    bmp_info.file_size=ReadBlobLSBLong(image);
    (void) ReadBlobLSBLong(image);
    bmp_info.offset_bits=ReadBlobLSBLong(image);
    bmp_info.size=ReadBlobLSBLong(image);
    if (image->debug != MagickFalse)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  BMP size: %u"",
        bmp_info.size);
    if (bmp_info.size == 12)
      {
        /*
          OS/2 BMP image file.
        */
        (void) CopyMagickString(image->magick,""BMP2"",MagickPathExtent);
        bmp_info.width=(ssize_t) ((short) ReadBlobLSBShort(image));
        bmp_info.height=(ssize_t) ((short) ReadBlobLSBShort(image));
        bmp_info.planes=ReadBlobLSBShort(image);
        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);
        bmp_info.x_pixels=0;
        bmp_info.y_pixels=0;
        bmp_info.number_colors=0;
        bmp_info.compression=BI_RGB;
        bmp_info.image_size=0;
        bmp_info.alpha_mask=0;
        if (image->debug != MagickFalse)
          {
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Format: OS/2 Bitmap"");
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Geometry: %.20gx%.20g"",(double) bmp_info.width,(double)
              bmp_info.height);
          }
      }
    else
      {
        /*
          Microsoft Windows BMP image file.
        */
        if (bmp_info.size < 40)
          ThrowReaderException(CorruptImageError,""NonOS2HeaderSizeError"");
        bmp_info.width=(ssize_t) ReadBlobLSBSignedLong(image);
        bmp_info.height=(ssize_t) ReadBlobLSBSignedLong(image);
        bmp_info.planes=ReadBlobLSBShort(image);
        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);
        bmp_info.compression=ReadBlobLSBLong(image);
        bmp_info.image_size=ReadBlobLSBLong(image);
         bmp_info.x_pixels=ReadBlobLSBLong(image);
         bmp_info.y_pixels=ReadBlobLSBLong(image);
         bmp_info.number_colors=ReadBlobLSBLong(image);
//flaw_line_below:
        if (bmp_info.number_colors > GetBlobSize(image))
//fix_flaw_line_below:
//        if ((MagickSizeType) bmp_info.number_colors > GetBlobSize(image))
           ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
         bmp_info.colors_important=ReadBlobLSBLong(image);
         if (image->debug != MagickFalse)
          {
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Format: MS Windows bitmap"");
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Geometry: %.20gx%.20g"",(double) bmp_info.width,(double)
              bmp_info.height);
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Bits per pixel: %.20g"",(double) bmp_info.bits_per_pixel);
            switch (bmp_info.compression)
            {
              case BI_RGB:
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Compression: BI_RGB"");
                break;
              }
              case BI_RLE4:
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Compression: BI_RLE4"");
                break;
              }
              case BI_RLE8:
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Compression: BI_RLE8"");
                break;
              }
              case BI_BITFIELDS:
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Compression: BI_BITFIELDS"");
                break;
              }
              case BI_PNG:
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Compression: BI_PNG"");
                break;
              }
              case BI_JPEG:
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Compression: BI_JPEG"");
                break;
              }
              default:
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Compression: UNKNOWN (%u)"",bmp_info.compression);
              }
            }
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Number of colors: %u"",bmp_info.number_colors);
          }
        bmp_info.red_mask=ReadBlobLSBLong(image);
        bmp_info.green_mask=ReadBlobLSBLong(image);
        bmp_info.blue_mask=ReadBlobLSBLong(image);
        if (bmp_info.size > 40)
          {
            double
              gamma;

            /*
              Read color management information.
            */
            bmp_info.alpha_mask=ReadBlobLSBLong(image);
            bmp_info.colorspace=ReadBlobLSBSignedLong(image);
            /*
              Decode 2^30 fixed point formatted CIE primaries.
            */
#           define BMP_DENOM ((double) 0x40000000)
            bmp_info.red_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.red_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.red_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.green_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.green_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.green_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.blue_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.blue_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;
            bmp_info.blue_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;

            gamma=bmp_info.red_primary.x+bmp_info.red_primary.y+
              bmp_info.red_primary.z;
            gamma=PerceptibleReciprocal(gamma);
            bmp_info.red_primary.x*=gamma;
            bmp_info.red_primary.y*=gamma;
            image->chromaticity.red_primary.x=bmp_info.red_primary.x;
            image->chromaticity.red_primary.y=bmp_info.red_primary.y;

            gamma=bmp_info.green_primary.x+bmp_info.green_primary.y+
              bmp_info.green_primary.z;
            gamma=PerceptibleReciprocal(gamma);
            bmp_info.green_primary.x*=gamma;
            bmp_info.green_primary.y*=gamma;
            image->chromaticity.green_primary.x=bmp_info.green_primary.x;
            image->chromaticity.green_primary.y=bmp_info.green_primary.y;

            gamma=bmp_info.blue_primary.x+bmp_info.blue_primary.y+
              bmp_info.blue_primary.z;
            gamma=PerceptibleReciprocal(gamma);
            bmp_info.blue_primary.x*=gamma;
            bmp_info.blue_primary.y*=gamma;
            image->chromaticity.blue_primary.x=bmp_info.blue_primary.x;
            image->chromaticity.blue_primary.y=bmp_info.blue_primary.y;

            /*
              Decode 16^16 fixed point formatted gamma_scales.
            */
            bmp_info.gamma_scale.x=(double) ReadBlobLSBLong(image)/0x10000;
            bmp_info.gamma_scale.y=(double) ReadBlobLSBLong(image)/0x10000;
            bmp_info.gamma_scale.z=(double) ReadBlobLSBLong(image)/0x10000;
            /*
              Compute a single gamma from the BMP 3-channel gamma.
            */
            image->gamma=(bmp_info.gamma_scale.x+bmp_info.gamma_scale.y+
              bmp_info.gamma_scale.z)/3.0;
          }
        else
          (void) CopyMagickString(image->magick,""BMP3"",MagickPathExtent);

        if (bmp_info.size > 108)
          {
            size_t
              intent;

            /*
              Read BMP Version 5 color management information.
            */
            intent=ReadBlobLSBLong(image);
            switch ((int) intent)
            {
              case LCS_GM_BUSINESS:
              {
                image->rendering_intent=SaturationIntent;
                break;
              }
              case LCS_GM_GRAPHICS:
              {
                image->rendering_intent=RelativeIntent;
                break;
              }
              case LCS_GM_IMAGES:
              {
                image->rendering_intent=PerceptualIntent;
                break;
              }
              case LCS_GM_ABS_COLORIMETRIC:
              {
                image->rendering_intent=AbsoluteIntent;
                break;
              }
            }
            (void) ReadBlobLSBLong(image);  /* Profile data */
            (void) ReadBlobLSBLong(image);  /* Profile size */
            (void) ReadBlobLSBLong(image);  /* Reserved byte */
          }
      }
    if ((MagickSizeType) bmp_info.file_size > GetBlobSize(image))
      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,
        ""LengthAndFilesizeDoNotMatch"",""`%s'"",image->filename);
    else
      if ((MagickSizeType) bmp_info.file_size < GetBlobSize(image))
        (void) ThrowMagickException(exception,GetMagickModule(),
          CorruptImageWarning,""LengthAndFilesizeDoNotMatch"",""`%s'"",
          image->filename);
    if (bmp_info.width <= 0)
      ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
    if (bmp_info.height == 0)
      ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
    if (bmp_info.planes != 1)
      ThrowReaderException(CorruptImageError,""StaticPlanesValueNotEqualToOne"");
    if ((bmp_info.bits_per_pixel != 1) && (bmp_info.bits_per_pixel != 4) &&
        (bmp_info.bits_per_pixel != 8) && (bmp_info.bits_per_pixel != 16) &&
        (bmp_info.bits_per_pixel != 24) && (bmp_info.bits_per_pixel != 32))
      ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");
    if (bmp_info.bits_per_pixel < 16 &&
        bmp_info.number_colors > (1U << bmp_info.bits_per_pixel))
      ThrowReaderException(CorruptImageError,""UnrecognizedNumberOfColors"");
    if ((bmp_info.compression == 1) && (bmp_info.bits_per_pixel != 8))
      ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");
    if ((bmp_info.compression == 2) && (bmp_info.bits_per_pixel != 4))
      ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");
    if ((bmp_info.compression == 3) && (bmp_info.bits_per_pixel < 16))
      ThrowReaderException(CorruptImageError,""UnrecognizedBitsPerPixel"");
    switch (bmp_info.compression)
    {
      case BI_RGB:
        image->compression=NoCompression;
        break;
      case BI_RLE8:
      case BI_RLE4:
        image->compression=RLECompression;
        break;
      case BI_BITFIELDS:
        break;
      case BI_JPEG:
        ThrowReaderException(CoderError,""JPEGCompressNotSupported"");
      case BI_PNG:
        ThrowReaderException(CoderError,""PNGCompressNotSupported"");
      default:
        ThrowReaderException(CorruptImageError,""UnrecognizedImageCompression"");
    }
    image->columns=(size_t) MagickAbsoluteValue(bmp_info.width);
    image->rows=(size_t) MagickAbsoluteValue(bmp_info.height);
    image->depth=bmp_info.bits_per_pixel <= 8 ? bmp_info.bits_per_pixel : 8;
    image->alpha_trait=((bmp_info.alpha_mask != 0) &&
      (bmp_info.compression == BI_BITFIELDS)) ? BlendPixelTrait :
      UndefinedPixelTrait;
    if (bmp_info.bits_per_pixel < 16)
      {
        size_t
          one;

        image->storage_class=PseudoClass;
        image->colors=bmp_info.number_colors;
        one=1;
        if (image->colors == 0)
          image->colors=one << bmp_info.bits_per_pixel;
      }
    image->resolution.x=(double) bmp_info.x_pixels/100.0;
    image->resolution.y=(double) bmp_info.y_pixels/100.0;
    image->units=PixelsPerCentimeterResolution;
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    if (image->storage_class == PseudoClass)
      {
        unsigned char
          *bmp_colormap;

        size_t
          packet_size;

        /*
          Read BMP raster colormap.
        */
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  Reading colormap of %.20g colors"",(double) image->colors);
        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t)
          image->colors,4*sizeof(*bmp_colormap));
        if (bmp_colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        if ((bmp_info.size == 12) || (bmp_info.size == 64))
          packet_size=3;
        else
          packet_size=4;
        offset=SeekBlob(image,start_position+14+bmp_info.size,SEEK_SET);
        if (offset < 0)
          {
            bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);
            ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
          }
        count=ReadBlob(image,packet_size*image->colors,bmp_colormap);
        if (count != (ssize_t) (packet_size*image->colors))
          {
            bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);
            ThrowReaderException(CorruptImageError,
              ""InsufficientImageDataInFile"");
          }
        p=bmp_colormap;
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(*p++);
          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(*p++);
          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(*p++);
          if (packet_size == 4)
            p++;
        }
        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);
      }
    /*
      Read image data.
    */
    if (bmp_info.offset_bits == offset_bits)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    offset_bits=bmp_info.offset_bits;
    offset=SeekBlob(image,start_position+bmp_info.offset_bits,SEEK_SET);
    if (offset < 0)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if (bmp_info.compression == BI_RLE4)
      bmp_info.bits_per_pixel<<=1;
    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);
    length=(size_t) bytes_per_line*image->rows;
    if ((bmp_info.compression == BI_RGB) ||
        (bmp_info.compression == BI_BITFIELDS))
      {
        if ((MagickSizeType) length > GetBlobSize(image))
          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
        pixel_info=AcquireVirtualMemory(image->rows,
          MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));
        if (pixel_info == (MemoryInfo *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  Reading pixels (%.20g bytes)"",(double) length);
        count=ReadBlob(image,length,pixels);
        if (count != (ssize_t) length)
          {
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(CorruptImageError,
              ""InsufficientImageDataInFile"");
          }
      }
    else
      {
        /*
          Convert run-length encoded raster pixels.
        */
        pixel_info=AcquireVirtualMemory(image->rows,
          MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));
        if (pixel_info == (MemoryInfo *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
        status=DecodeImage(image,bmp_info.compression,pixels,
          image->columns*image->rows);
        if (status == MagickFalse)
          {
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(CorruptImageError,
              ""UnableToRunlengthDecodeImage"");
          }
      }
    /*
      Convert BMP raster image to pixel packets.
    */
    if (bmp_info.compression == BI_RGB)
      {
        /*
          We should ignore the alpha value in BMP3 files but there have been
          reports about 32 bit files with alpha. We do a quick check to see if
          the alpha channel contains a value that is not zero (default value).
          If we find a non zero value we asume the program that wrote the file
          wants to use the alpha channel.
        */
        if ((image->alpha_trait == UndefinedPixelTrait) && (bmp_info.size == 40) &&
            (bmp_info.bits_per_pixel == 32))
          {
            bytes_per_line=4*(image->columns);
            for (y=(ssize_t) image->rows-1; y >= 0; y--)
            {
              p=pixels+(image->rows-y-1)*bytes_per_line;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                if (*(p+3) != 0)
                  {
                    image->alpha_trait=BlendPixelTrait;
                    y=-1;
                    break;
                  }
                p+=4;
              }
            }
          }
        bmp_info.alpha_mask=image->alpha_trait != UndefinedPixelTrait ?
          0xff000000U : 0U;
        bmp_info.red_mask=0x00ff0000U;
        bmp_info.green_mask=0x0000ff00U;
        bmp_info.blue_mask=0x000000ffU;
        if (bmp_info.bits_per_pixel == 16)
          {
            /*
              RGB555.
            */
            bmp_info.red_mask=0x00007c00U;
            bmp_info.green_mask=0x000003e0U;
            bmp_info.blue_mask=0x0000001fU;
          }
      }
    (void) memset(&shift,0,sizeof(shift));
    (void) memset(&quantum_bits,0,sizeof(quantum_bits));
    if ((bmp_info.bits_per_pixel == 16) || (bmp_info.bits_per_pixel == 32))
      {
        register unsigned int
          sample;

        /*
          Get shift and quantum bits info from bitfield masks.
        */
        if (bmp_info.red_mask != 0)
          while (((bmp_info.red_mask << shift.red) & 0x80000000UL) == 0)
          {
            shift.red++;
            if (shift.red >= 32U)
              break;
          }
        if (bmp_info.green_mask != 0)
          while (((bmp_info.green_mask << shift.green) & 0x80000000UL) == 0)
          {
            shift.green++;
            if (shift.green >= 32U)
              break;
          }
        if (bmp_info.blue_mask != 0)
          while (((bmp_info.blue_mask << shift.blue) & 0x80000000UL) == 0)
          {
            shift.blue++;
            if (shift.blue >= 32U)
              break;
          }
        if (bmp_info.alpha_mask != 0)
          while (((bmp_info.alpha_mask << shift.alpha) & 0x80000000UL) == 0)
          {
            shift.alpha++;
            if (shift.alpha >= 32U)
              break;
          }
        sample=shift.red;
        while (((bmp_info.red_mask << sample) & 0x80000000UL) != 0)
        {
          sample++;
          if (sample >= 32U)
            break;
        }
        quantum_bits.red=(MagickRealType) (sample-shift.red);
        sample=shift.green;
        while (((bmp_info.green_mask << sample) & 0x80000000UL) != 0)
        {
          sample++;
          if (sample >= 32U)
            break;
        }
        quantum_bits.green=(MagickRealType) (sample-shift.green);
        sample=shift.blue;
        while (((bmp_info.blue_mask << sample) & 0x80000000UL) != 0)
        {
          sample++;
          if (sample >= 32U)
            break;
        }
        quantum_bits.blue=(MagickRealType) (sample-shift.blue);
        sample=shift.alpha;
        while (((bmp_info.alpha_mask << sample) & 0x80000000UL) != 0)
        {
          sample++;
          if (sample >= 32U)
            break;
        }
        quantum_bits.alpha=(MagickRealType) (sample-shift.alpha);
      }
    switch (bmp_info.bits_per_pixel)
    {
      case 1:
      {
        /*
          Convert bitmap scanline.
        */
        for (y=(ssize_t) image->rows-1; y >= 0; y--)
        {
          p=pixels+(image->rows-y-1)*bytes_per_line;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < ((ssize_t) image->columns-7); x+=8)
          {
            for (bit=0; bit < 8; bit++)
            {
              index=(Quantum) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);
              SetPixelIndex(image,index,q);
              q+=GetPixelChannels(image);
            }
            p++;
          }
          if ((image->columns % 8) != 0)
            {
              for (bit=0; bit < (image->columns % 8); bit++)
              {
                index=(Quantum) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);
                SetPixelIndex(image,index,q);
                q+=GetPixelChannels(image);
              }
              p++;
            }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                (image->rows-y),image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        (void) SyncImage(image,exception);
        break;
      }
      case 4:
      {
        /*
          Convert PseudoColor scanline.
        */
        for (y=(ssize_t) image->rows-1; y >= 0; y--)
        {
          p=pixels+(image->rows-y-1)*bytes_per_line;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < ((ssize_t) image->columns-1); x+=2)
          {
            ValidateColormapValue(image,(ssize_t) ((*p >> 4) & 0x0f),&index,
              exception);
            SetPixelIndex(image,index,q);
            q+=GetPixelChannels(image);
            ValidateColormapValue(image,(ssize_t) (*p & 0x0f),&index,exception);
            SetPixelIndex(image,index,q);
            q+=GetPixelChannels(image);
            p++;
          }
          if ((image->columns % 2) != 0)
            {
              ValidateColormapValue(image,(ssize_t) ((*p >> 4) & 0xf),&index,
                exception);
              SetPixelIndex(image,index,q);
              q+=GetPixelChannels(image);
              p++;
              x++;
            }
          if (x < (ssize_t) image->columns)
            break;
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                (image->rows-y),image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        (void) SyncImage(image,exception);
        break;
      }
      case 8:
      {
        /*
          Convert PseudoColor scanline.
        */
        if ((bmp_info.compression == BI_RLE8) ||
            (bmp_info.compression == BI_RLE4))
          bytes_per_line=image->columns;
        for (y=(ssize_t) image->rows-1; y >= 0; y--)
        {
          p=pixels+(image->rows-y-1)*bytes_per_line;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=(ssize_t) image->columns; x != 0; --x)
          {
            ValidateColormapValue(image,(ssize_t) *p++,&index,exception);
            SetPixelIndex(image,index,q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          offset=(MagickOffsetType) (image->rows-y-1);
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                (image->rows-y),image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        (void) SyncImage(image,exception);
        break;
      }
      case 16:
      {
        unsigned int
          alpha,
          pixel;

        /*
          Convert bitfield encoded 16-bit PseudoColor scanline.
        */
        if ((bmp_info.compression != BI_RGB) &&
            (bmp_info.compression != BI_BITFIELDS))
          {
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(CorruptImageError,
              ""UnrecognizedImageCompression"");
          }
        bytes_per_line=2*(image->columns+image->columns % 2);
        image->storage_class=DirectClass;
        for (y=(ssize_t) image->rows-1; y >= 0; y--)
        {
          p=pixels+(image->rows-y-1)*bytes_per_line;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            pixel=(unsigned int) (*p++);
            pixel|=(*p++) << 8;
            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;
            if (quantum_bits.red == 5)
              red|=((red & 0xe000) >> 5);
            if (quantum_bits.red <= 8)
              red|=((red & 0xff00) >> 8);
            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;
            if (quantum_bits.green == 5)
              green|=((green & 0xe000) >> 5);
            if (quantum_bits.green == 6)
              green|=((green & 0xc000) >> 6);
            if (quantum_bits.green <= 8)
              green|=((green & 0xff00) >> 8);
            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;
            if (quantum_bits.blue == 5)
              blue|=((blue & 0xe000) >> 5);
            if (quantum_bits.blue <= 8)
              blue|=((blue & 0xff00) >> 8);
            SetPixelRed(image,ScaleShortToQuantum((unsigned short) red),q);
            SetPixelGreen(image,ScaleShortToQuantum((unsigned short) green),q);
            SetPixelBlue(image,ScaleShortToQuantum((unsigned short) blue),q);
            SetPixelAlpha(image,OpaqueAlpha,q);
            if (image->alpha_trait != UndefinedPixelTrait)
              {
                alpha=((pixel & bmp_info.alpha_mask) << shift.alpha) >> 16;
                if (quantum_bits.alpha <= 8)
                  alpha|=((alpha & 0xff00) >> 8);
                SetPixelAlpha(image,ScaleShortToQuantum(
                  (unsigned short) alpha),q);
              }
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          offset=(MagickOffsetType) (image->rows-y-1);
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                (image->rows-y),image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case 24:
      {
        /*
          Convert DirectColor scanline.
        */
        bytes_per_line=4*((image->columns*24+31)/32);
        for (y=(ssize_t) image->rows-1; y >= 0; y--)
        {
          p=pixels+(image->rows-y-1)*bytes_per_line;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
            SetPixelRed(image,ScaleCharToQuantum(*p++),q);
            SetPixelAlpha(image,OpaqueAlpha,q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          offset=(MagickOffsetType) (image->rows-y-1);
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                (image->rows-y),image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case 32:
      {
        /*
          Convert bitfield encoded DirectColor scanline.
        */
        if ((bmp_info.compression != BI_RGB) &&
            (bmp_info.compression != BI_BITFIELDS))
          {
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(CorruptImageError,
              ""UnrecognizedImageCompression"");
          }
        bytes_per_line=4*(image->columns);
        for (y=(ssize_t) image->rows-1; y >= 0; y--)
        {
          unsigned int
            alpha,
            pixel;

          p=pixels+(image->rows-y-1)*bytes_per_line;
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            pixel=(unsigned int) (*p++);
            pixel|=((unsigned int) *p++ << 8);
            pixel|=((unsigned int) *p++ << 16);
            pixel|=((unsigned int) *p++ << 24);
            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;
            if (quantum_bits.red == 8)
              red|=(red >> 8);
            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;
            if (quantum_bits.green == 8)
              green|=(green >> 8);
            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;
            if (quantum_bits.blue == 8)
              blue|=(blue >> 8);
            SetPixelRed(image,ScaleShortToQuantum((unsigned short) red),q);
            SetPixelGreen(image,ScaleShortToQuantum((unsigned short) green),q);
            SetPixelBlue(image,ScaleShortToQuantum((unsigned short) blue),q);
            SetPixelAlpha(image,OpaqueAlpha,q);
            if (image->alpha_trait != UndefinedPixelTrait)
              {
                alpha=((pixel & bmp_info.alpha_mask) << shift.alpha) >> 16;
                if (quantum_bits.alpha == 8)
                  alpha|=(alpha >> 8);
                SetPixelAlpha(image,ScaleShortToQuantum(
                  (unsigned short) alpha),q);
              }
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          offset=(MagickOffsetType) (image->rows-y-1);
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                (image->rows-y),image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      default:
      {
        pixel_info=RelinquishVirtualMemory(pixel_info);
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      }
    }
    pixel_info=RelinquishVirtualMemory(pixel_info);
    if (y > 0)
      break;
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    if (bmp_info.height < 0)
      {
        Image
          *flipped_image;

        /*
          Correct image orientation.
        */
        flipped_image=FlipImage(image,exception);
        if (flipped_image != (Image *) NULL)
          {
            DuplicateBlob(flipped_image,image);
            ReplaceImageInList(&image, flipped_image);
            image=flipped_image;
          }
      }
    /*
      Proceed to next image.
    */
     if (image_info->number_scenes != 0)
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
//fix_flaw_line_below:
//    offset=(MagickOffsetType) bmp_info.ba_offset;
//fix_flaw_line_below:
//    if (offset != 0)
//fix_flaw_line_below:
//      if ((offset < TellBlob(image)) ||
//fix_flaw_line_below:
//          (SeekBlob(image,offset,SEEK_SET) != offset))
//fix_flaw_line_below:
//        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     *magick='\0';
//flaw_line_below:
    if (bmp_info.ba_offset != 0)
//flaw_line_below:
      {
//flaw_line_below:
        offset=SeekBlob(image,(MagickOffsetType) bmp_info.ba_offset,SEEK_SET);
//flaw_line_below:
        if (offset < 0)
//flaw_line_below:
          ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
//flaw_line_below:
      }
     count=ReadBlob(image,2,magick);
     if ((count == 2) && (IsBMP(magick,2) != MagickFalse))
       {
        /*
          Acquire next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            status=MagickFalse;
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while (IsBMP(magick,2) != MagickFalse);
  (void) CloseBlob(image);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  return(GetFirstImageInList(image));
}
"
4408,182144,,Remote,Not required,Partial,CVE-2018-19840,https://www.cvedetails.com/cve/CVE-2018-19840/,CWE-835,Medium,,,,2018-12-04,4.3,The function WavpackPackInit in pack_utils.c in libwavpack.a in WavPack through 5.1.0 allows attackers to cause a denial-of-service (resource exhaustion caused by an infinite loop) via a crafted wav audio file because WavpackSetConfiguration64 mishandles a sample rate of zero.,2019-10-02,,5,https://github.com/dbry/WavPack/commit/070ef6f138956d9ea9612e69586152339dbefe51,070ef6f138956d9ea9612e69586152339dbefe51,issue #53: error out on zero sample rate,0,src/pack_utils.c,"{""sha"": ""2a834978a9166cfbd1c7a0ab734ca75ed8d7c66d"", ""filename"": ""src/pack_utils.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/dbry/WavPack/blob/070ef6f138956d9ea9612e69586152339dbefe51/src/pack_utils.c"", ""raw_url"": ""https://github.com/dbry/WavPack/raw/070ef6f138956d9ea9612e69586152339dbefe51/src/pack_utils.c"", ""contents_url"": ""https://api.github.com/repos/dbry/WavPack/contents/src/pack_utils.c?ref=070ef6f138956d9ea9612e69586152339dbefe51"", ""patch"": ""@@ -195,6 +195,11 @@ int WavpackSetConfiguration64 (WavpackContext *wpc, WavpackConfig *config, int64\n     int num_chans = config->num_channels;\n     int i;\n \n+    if (!config->sample_rate) {\n+        strcpy (wpc->error_message, \""sample rate cannot be zero!\"");\n+        return FALSE;\n+    }\n+\n     wpc->stream_version = (config->flags & CONFIG_COMPATIBLE_WRITE) ? CUR_STREAM_VERS : MAX_STREAM_VERS;\n \n     if ((config->qmode & QMODE_DSD_AUDIO) && config->bytes_per_sample == 1 && config->bits_per_sample == 8) {""}","int WavpackSetConfiguration64 (WavpackContext *wpc, WavpackConfig *config, int64_t total_samples, const unsigned char *chan_ids)
{
    uint32_t flags, bps = 0;
    uint32_t chan_mask = config->channel_mask;
     int num_chans = config->num_channels;
     int i;
 
    if (!config->sample_rate) {
        strcpy (wpc->error_message, ""sample rate cannot be zero!"");
        return FALSE;
    }

     wpc->stream_version = (config->flags & CONFIG_COMPATIBLE_WRITE) ? CUR_STREAM_VERS : MAX_STREAM_VERS;
 
     if ((config->qmode & QMODE_DSD_AUDIO) && config->bytes_per_sample == 1 && config->bits_per_sample == 8) {
#ifdef ENABLE_DSD
        wpc->dsd_multiplier = 1;
        flags = DSD_FLAG;

        for (i = 14; i >= 0; --i)
            if (config->sample_rate % sample_rates [i] == 0) {
                int divisor = config->sample_rate / sample_rates [i];

                if (divisor && (divisor & (divisor - 1)) == 0) {
                    config->sample_rate /= divisor;
                    wpc->dsd_multiplier = divisor;
                    break;
                }
            }

        if (config->flags & CONFIG_HYBRID_FLAG) {
            strcpy (wpc->error_message, ""hybrid mode not available for DSD!"");
            return FALSE;
        }

        config->flags &= (CONFIG_HIGH_FLAG | CONFIG_MD5_CHECKSUM | CONFIG_PAIR_UNDEF_CHANS);
        config->float_norm_exp = config->xmode = 0;
#else
        strcpy (wpc->error_message, ""libwavpack not configured for DSD!"");
        return FALSE;
#endif
    }
    else
        flags = config->bytes_per_sample - 1;

    wpc->total_samples = total_samples;
    wpc->config.sample_rate = config->sample_rate;
    wpc->config.num_channels = config->num_channels;
    wpc->config.channel_mask = config->channel_mask;
    wpc->config.bits_per_sample = config->bits_per_sample;
    wpc->config.bytes_per_sample = config->bytes_per_sample;
    wpc->config.block_samples = config->block_samples;
    wpc->config.flags = config->flags;
    wpc->config.qmode = config->qmode;

    if (config->flags & CONFIG_VERY_HIGH_FLAG)
        wpc->config.flags |= CONFIG_HIGH_FLAG;

    for (i = 0; i < 15; ++i)
        if (wpc->config.sample_rate == sample_rates [i])
            break;

    flags |= i << SRATE_LSB;


    if (!(flags & DSD_FLAG)) {
        if (config->float_norm_exp) {
            wpc->config.float_norm_exp = config->float_norm_exp;
            wpc->config.flags |= CONFIG_FLOAT_DATA;
            flags |= FLOAT_DATA;
        }
        else
            flags |= ((config->bytes_per_sample * 8) - config->bits_per_sample) << SHIFT_LSB;

        if (config->flags & CONFIG_HYBRID_FLAG) {
            flags |= HYBRID_FLAG | HYBRID_BITRATE | HYBRID_BALANCE;

            if (!(wpc->config.flags & CONFIG_SHAPE_OVERRIDE)) {
                wpc->config.flags |= CONFIG_HYBRID_SHAPE | CONFIG_AUTO_SHAPING;
                flags |= HYBRID_SHAPE | NEW_SHAPING;
            }
            else if (wpc->config.flags & CONFIG_HYBRID_SHAPE) {
                wpc->config.shaping_weight = config->shaping_weight;
                flags |= HYBRID_SHAPE | NEW_SHAPING;
            }

            if (wpc->config.flags & (CONFIG_CROSS_DECORR | CONFIG_OPTIMIZE_WVC))
                flags |= CROSS_DECORR;

            if (config->flags & CONFIG_BITRATE_KBPS) {
                bps = (uint32_t) floor (config->bitrate * 256000.0 / config->sample_rate / config->num_channels + 0.5);

                if (bps > (64 << 8))
                    bps = 64 << 8;
            }
            else
                bps = (uint32_t) floor (config->bitrate * 256.0 + 0.5);
        }
        else
            flags |= CROSS_DECORR;

        if (!(config->flags & CONFIG_JOINT_OVERRIDE) || (config->flags & CONFIG_JOINT_STEREO))
            flags |= JOINT_STEREO;

        if (config->flags & CONFIG_CREATE_WVC)
            wpc->wvc_flag = TRUE;
    }


    if (chan_ids) {
        int lastchan = 0, mask_copy = chan_mask;

        if ((int) strlen ((char *) chan_ids) > num_chans) {          // can't be more than num channels!
            strcpy (wpc->error_message, ""chan_ids longer than num channels!"");
            return FALSE;
        }


        while (*chan_ids)
            if (*chan_ids <= 32 && *chan_ids > lastchan && (mask_copy & (1 << (*chan_ids-1)))) {
                mask_copy &= ~(1 << (*chan_ids-1));
                lastchan = *chan_ids++;
            }
            else
                break;


        for (i = 0; chan_ids [i]; i++)
            if (chan_ids [i] != 0xff) {
                wpc->channel_identities = (unsigned char *) strdup ((char *) chan_ids);
                break;
            }
    }


    for (wpc->current_stream = 0; num_chans; wpc->current_stream++) {
        WavpackStream *wps = malloc (sizeof (WavpackStream));
        unsigned char left_chan_id = 0, right_chan_id = 0;
        int pos, chans = 1;

        wpc->streams = realloc (wpc->streams, (wpc->current_stream + 1) * sizeof (wpc->streams [0]));
        wpc->streams [wpc->current_stream] = wps;
        CLEAR (*wps);

        if (chan_mask)
            for (pos = 0; pos < 32; ++pos)
                if (chan_mask & (1 << pos)) {
                    if (left_chan_id) {
                        right_chan_id = pos + 1;
                        break;
                    }
                    else {
                        chan_mask &= ~(1 << pos);
                        left_chan_id = pos + 1;
                    }
                }

        while (!right_chan_id && chan_ids && *chan_ids)
            if (left_chan_id)
                right_chan_id = *chan_ids;
            else
                left_chan_id = *chan_ids++;

        if (!left_chan_id)
            left_chan_id = right_chan_id = 0xff;
        else if (!right_chan_id)
            right_chan_id = 0xff;

        if (num_chans >= 2) {
            if ((config->flags & CONFIG_PAIR_UNDEF_CHANS) && left_chan_id == 0xff && right_chan_id == 0xff)
                chans = 2;
            else
                for (i = 0; i < NUM_STEREO_PAIRS; ++i)
                    if ((left_chan_id == stereo_pairs [i].a && right_chan_id == stereo_pairs [i].b) ||
                        (left_chan_id == stereo_pairs [i].b && right_chan_id == stereo_pairs [i].a)) {
                            if (right_chan_id <= 32 && (chan_mask & (1 << (right_chan_id-1))))
                                chan_mask &= ~(1 << (right_chan_id-1));
                            else if (chan_ids && *chan_ids == right_chan_id)
                                chan_ids++;

                            chans = 2;
                            break;
                        }
        }

        num_chans -= chans;

        if (num_chans && wpc->current_stream == NEW_MAX_STREAMS - 1)
            break;

        memcpy (wps->wphdr.ckID, ""wvpk"", 4);
        wps->wphdr.ckSize = sizeof (WavpackHeader) - 8;
        SET_TOTAL_SAMPLES (wps->wphdr, wpc->total_samples);
        wps->wphdr.version = wpc->stream_version;
        wps->wphdr.flags = flags;
        wps->bits = bps;

        if (!wpc->current_stream)
            wps->wphdr.flags |= INITIAL_BLOCK;

        if (!num_chans)
            wps->wphdr.flags |= FINAL_BLOCK;

        if (chans == 1) {
            wps->wphdr.flags &= ~(JOINT_STEREO | CROSS_DECORR | HYBRID_BALANCE);
            wps->wphdr.flags |= MONO_FLAG;
        }
    }

    wpc->num_streams = wpc->current_stream;
    wpc->current_stream = 0;

    if (num_chans) {
        strcpy (wpc->error_message, ""too many channels!"");
        return FALSE;
    }

    if (config->flags & CONFIG_EXTRA_MODE)
        wpc->config.xmode = config->xmode ? config->xmode : 1;

    return TRUE;
}
","int WavpackSetConfiguration64 (WavpackContext *wpc, WavpackConfig *config, int64_t total_samples, const unsigned char *chan_ids)
{
    uint32_t flags, bps = 0;
    uint32_t chan_mask = config->channel_mask;
     int num_chans = config->num_channels;
     int i;
 
     wpc->stream_version = (config->flags & CONFIG_COMPATIBLE_WRITE) ? CUR_STREAM_VERS : MAX_STREAM_VERS;
 
     if ((config->qmode & QMODE_DSD_AUDIO) && config->bytes_per_sample == 1 && config->bits_per_sample == 8) {
#ifdef ENABLE_DSD
        wpc->dsd_multiplier = 1;
        flags = DSD_FLAG;

        for (i = 14; i >= 0; --i)
            if (config->sample_rate % sample_rates [i] == 0) {
                int divisor = config->sample_rate / sample_rates [i];

                if (divisor && (divisor & (divisor - 1)) == 0) {
                    config->sample_rate /= divisor;
                    wpc->dsd_multiplier = divisor;
                    break;
                }
            }

        if (config->flags & CONFIG_HYBRID_FLAG) {
            strcpy (wpc->error_message, ""hybrid mode not available for DSD!"");
            return FALSE;
        }

        config->flags &= (CONFIG_HIGH_FLAG | CONFIG_MD5_CHECKSUM | CONFIG_PAIR_UNDEF_CHANS);
        config->float_norm_exp = config->xmode = 0;
#else
        strcpy (wpc->error_message, ""libwavpack not configured for DSD!"");
        return FALSE;
#endif
    }
    else
        flags = config->bytes_per_sample - 1;

    wpc->total_samples = total_samples;
    wpc->config.sample_rate = config->sample_rate;
    wpc->config.num_channels = config->num_channels;
    wpc->config.channel_mask = config->channel_mask;
    wpc->config.bits_per_sample = config->bits_per_sample;
    wpc->config.bytes_per_sample = config->bytes_per_sample;
    wpc->config.block_samples = config->block_samples;
    wpc->config.flags = config->flags;
    wpc->config.qmode = config->qmode;

    if (config->flags & CONFIG_VERY_HIGH_FLAG)
        wpc->config.flags |= CONFIG_HIGH_FLAG;

    for (i = 0; i < 15; ++i)
        if (wpc->config.sample_rate == sample_rates [i])
            break;

    flags |= i << SRATE_LSB;


    if (!(flags & DSD_FLAG)) {
        if (config->float_norm_exp) {
            wpc->config.float_norm_exp = config->float_norm_exp;
            wpc->config.flags |= CONFIG_FLOAT_DATA;
            flags |= FLOAT_DATA;
        }
        else
            flags |= ((config->bytes_per_sample * 8) - config->bits_per_sample) << SHIFT_LSB;

        if (config->flags & CONFIG_HYBRID_FLAG) {
            flags |= HYBRID_FLAG | HYBRID_BITRATE | HYBRID_BALANCE;

            if (!(wpc->config.flags & CONFIG_SHAPE_OVERRIDE)) {
                wpc->config.flags |= CONFIG_HYBRID_SHAPE | CONFIG_AUTO_SHAPING;
                flags |= HYBRID_SHAPE | NEW_SHAPING;
            }
            else if (wpc->config.flags & CONFIG_HYBRID_SHAPE) {
                wpc->config.shaping_weight = config->shaping_weight;
                flags |= HYBRID_SHAPE | NEW_SHAPING;
            }

            if (wpc->config.flags & (CONFIG_CROSS_DECORR | CONFIG_OPTIMIZE_WVC))
                flags |= CROSS_DECORR;

            if (config->flags & CONFIG_BITRATE_KBPS) {
                bps = (uint32_t) floor (config->bitrate * 256000.0 / config->sample_rate / config->num_channels + 0.5);

                if (bps > (64 << 8))
                    bps = 64 << 8;
            }
            else
                bps = (uint32_t) floor (config->bitrate * 256.0 + 0.5);
        }
        else
            flags |= CROSS_DECORR;

        if (!(config->flags & CONFIG_JOINT_OVERRIDE) || (config->flags & CONFIG_JOINT_STEREO))
            flags |= JOINT_STEREO;

        if (config->flags & CONFIG_CREATE_WVC)
            wpc->wvc_flag = TRUE;
    }


    if (chan_ids) {
        int lastchan = 0, mask_copy = chan_mask;

        if ((int) strlen ((char *) chan_ids) > num_chans) {          // can't be more than num channels!
            strcpy (wpc->error_message, ""chan_ids longer than num channels!"");
            return FALSE;
        }


        while (*chan_ids)
            if (*chan_ids <= 32 && *chan_ids > lastchan && (mask_copy & (1 << (*chan_ids-1)))) {
                mask_copy &= ~(1 << (*chan_ids-1));
                lastchan = *chan_ids++;
            }
            else
                break;


        for (i = 0; chan_ids [i]; i++)
            if (chan_ids [i] != 0xff) {
                wpc->channel_identities = (unsigned char *) strdup ((char *) chan_ids);
                break;
            }
    }


    for (wpc->current_stream = 0; num_chans; wpc->current_stream++) {
        WavpackStream *wps = malloc (sizeof (WavpackStream));
        unsigned char left_chan_id = 0, right_chan_id = 0;
        int pos, chans = 1;

        wpc->streams = realloc (wpc->streams, (wpc->current_stream + 1) * sizeof (wpc->streams [0]));
        wpc->streams [wpc->current_stream] = wps;
        CLEAR (*wps);

        if (chan_mask)
            for (pos = 0; pos < 32; ++pos)
                if (chan_mask & (1 << pos)) {
                    if (left_chan_id) {
                        right_chan_id = pos + 1;
                        break;
                    }
                    else {
                        chan_mask &= ~(1 << pos);
                        left_chan_id = pos + 1;
                    }
                }

        while (!right_chan_id && chan_ids && *chan_ids)
            if (left_chan_id)
                right_chan_id = *chan_ids;
            else
                left_chan_id = *chan_ids++;

        if (!left_chan_id)
            left_chan_id = right_chan_id = 0xff;
        else if (!right_chan_id)
            right_chan_id = 0xff;

        if (num_chans >= 2) {
            if ((config->flags & CONFIG_PAIR_UNDEF_CHANS) && left_chan_id == 0xff && right_chan_id == 0xff)
                chans = 2;
            else
                for (i = 0; i < NUM_STEREO_PAIRS; ++i)
                    if ((left_chan_id == stereo_pairs [i].a && right_chan_id == stereo_pairs [i].b) ||
                        (left_chan_id == stereo_pairs [i].b && right_chan_id == stereo_pairs [i].a)) {
                            if (right_chan_id <= 32 && (chan_mask & (1 << (right_chan_id-1))))
                                chan_mask &= ~(1 << (right_chan_id-1));
                            else if (chan_ids && *chan_ids == right_chan_id)
                                chan_ids++;

                            chans = 2;
                            break;
                        }
        }

        num_chans -= chans;

        if (num_chans && wpc->current_stream == NEW_MAX_STREAMS - 1)
            break;

        memcpy (wps->wphdr.ckID, ""wvpk"", 4);
        wps->wphdr.ckSize = sizeof (WavpackHeader) - 8;
        SET_TOTAL_SAMPLES (wps->wphdr, wpc->total_samples);
        wps->wphdr.version = wpc->stream_version;
        wps->wphdr.flags = flags;
        wps->bits = bps;

        if (!wpc->current_stream)
            wps->wphdr.flags |= INITIAL_BLOCK;

        if (!num_chans)
            wps->wphdr.flags |= FINAL_BLOCK;

        if (chans == 1) {
            wps->wphdr.flags &= ~(JOINT_STEREO | CROSS_DECORR | HYBRID_BALANCE);
            wps->wphdr.flags |= MONO_FLAG;
        }
    }

    wpc->num_streams = wpc->current_stream;
    wpc->current_stream = 0;

    if (num_chans) {
        strcpy (wpc->error_message, ""too many channels!"");
        return FALSE;
    }

    if (config->flags & CONFIG_EXTRA_MODE)
        wpc->config.xmode = config->xmode ? config->xmode : 1;

    return TRUE;
}
",C,"    if (!config->sample_rate) {
        strcpy (wpc->error_message, ""sample rate cannot be zero!"");
        return FALSE;
    }

",,,"@@ -195,6 +195,11 @@ int WavpackSetConfiguration64 (WavpackContext *wpc, WavpackConfig *config, int64
     int num_chans = config->num_channels;
     int i;
 
+    if (!config->sample_rate) {
+        strcpy (wpc->error_message, ""sample rate cannot be zero!"");
+        return FALSE;
+    }
+
     wpc->stream_version = (config->flags & CONFIG_COMPATIBLE_WRITE) ? CUR_STREAM_VERS : MAX_STREAM_VERS;
 
     if ((config->qmode & QMODE_DSD_AUDIO) && config->bytes_per_sample == 1 && config->bits_per_sample == 8) {",WavPack,070ef6f138956d9ea9612e69586152339dbefe51,e731cea83d52cccb4d3cde4f6503b22ba145de21,1,"int WavpackSetConfiguration64 (WavpackContext *wpc, WavpackConfig *config, int64_t total_samples, const unsigned char *chan_ids)
{
    uint32_t flags, bps = 0;
    uint32_t chan_mask = config->channel_mask;
     int num_chans = config->num_channels;
     int i;
 
//fix_flaw_line_below:
//    if (!config->sample_rate) {
//fix_flaw_line_below:
//        strcpy (wpc->error_message, ""sample rate cannot be zero!"");
//fix_flaw_line_below:
//        return FALSE;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     wpc->stream_version = (config->flags & CONFIG_COMPATIBLE_WRITE) ? CUR_STREAM_VERS : MAX_STREAM_VERS;
 
     if ((config->qmode & QMODE_DSD_AUDIO) && config->bytes_per_sample == 1 && config->bits_per_sample == 8) {
#ifdef ENABLE_DSD
        wpc->dsd_multiplier = 1;
        flags = DSD_FLAG;

        for (i = 14; i >= 0; --i)
            if (config->sample_rate % sample_rates [i] == 0) {
                int divisor = config->sample_rate / sample_rates [i];

                if (divisor && (divisor & (divisor - 1)) == 0) {
                    config->sample_rate /= divisor;
                    wpc->dsd_multiplier = divisor;
                    break;
                }
            }

        // most options that don't apply to DSD we can simply ignore for now, but NOT hybrid mode!
        if (config->flags & CONFIG_HYBRID_FLAG) {
            strcpy (wpc->error_message, ""hybrid mode not available for DSD!"");
            return FALSE;
        }

        // with DSD, very few PCM options work (or make sense), so only allow those that do
        config->flags &= (CONFIG_HIGH_FLAG | CONFIG_MD5_CHECKSUM | CONFIG_PAIR_UNDEF_CHANS);
        config->float_norm_exp = config->xmode = 0;
#else
        strcpy (wpc->error_message, ""libwavpack not configured for DSD!"");
        return FALSE;
#endif
    }
    else
        flags = config->bytes_per_sample - 1;

    wpc->total_samples = total_samples;
    wpc->config.sample_rate = config->sample_rate;
    wpc->config.num_channels = config->num_channels;
    wpc->config.channel_mask = config->channel_mask;
    wpc->config.bits_per_sample = config->bits_per_sample;
    wpc->config.bytes_per_sample = config->bytes_per_sample;
    wpc->config.block_samples = config->block_samples;
    wpc->config.flags = config->flags;
    wpc->config.qmode = config->qmode;

    if (config->flags & CONFIG_VERY_HIGH_FLAG)
        wpc->config.flags |= CONFIG_HIGH_FLAG;

    for (i = 0; i < 15; ++i)
        if (wpc->config.sample_rate == sample_rates [i])
            break;

    flags |= i << SRATE_LSB;

    // all of this stuff only applies to PCM

    if (!(flags & DSD_FLAG)) {
        if (config->float_norm_exp) {
            wpc->config.float_norm_exp = config->float_norm_exp;
            wpc->config.flags |= CONFIG_FLOAT_DATA;
            flags |= FLOAT_DATA;
        }
        else
            flags |= ((config->bytes_per_sample * 8) - config->bits_per_sample) << SHIFT_LSB;

        if (config->flags & CONFIG_HYBRID_FLAG) {
            flags |= HYBRID_FLAG | HYBRID_BITRATE | HYBRID_BALANCE;

            if (!(wpc->config.flags & CONFIG_SHAPE_OVERRIDE)) {
                wpc->config.flags |= CONFIG_HYBRID_SHAPE | CONFIG_AUTO_SHAPING;
                flags |= HYBRID_SHAPE | NEW_SHAPING;
            }
            else if (wpc->config.flags & CONFIG_HYBRID_SHAPE) {
                wpc->config.shaping_weight = config->shaping_weight;
                flags |= HYBRID_SHAPE | NEW_SHAPING;
            }

            if (wpc->config.flags & (CONFIG_CROSS_DECORR | CONFIG_OPTIMIZE_WVC))
                flags |= CROSS_DECORR;

            if (config->flags & CONFIG_BITRATE_KBPS) {
                bps = (uint32_t) floor (config->bitrate * 256000.0 / config->sample_rate / config->num_channels + 0.5);

                if (bps > (64 << 8))
                    bps = 64 << 8;
            }
            else
                bps = (uint32_t) floor (config->bitrate * 256.0 + 0.5);
        }
        else
            flags |= CROSS_DECORR;

        if (!(config->flags & CONFIG_JOINT_OVERRIDE) || (config->flags & CONFIG_JOINT_STEREO))
            flags |= JOINT_STEREO;

        if (config->flags & CONFIG_CREATE_WVC)
            wpc->wvc_flag = TRUE;
    }

    // if a channel-identities string was specified, process that here, otherwise all channels
    // not present in the channel mask are considered ""unassigned""

    if (chan_ids) {
        int lastchan = 0, mask_copy = chan_mask;

        if ((int) strlen ((char *) chan_ids) > num_chans) {          // can't be more than num channels!
            strcpy (wpc->error_message, ""chan_ids longer than num channels!"");
            return FALSE;
        }

        // skip past channels that are specified in the channel mask (no reason to store those)

        while (*chan_ids)
            if (*chan_ids <= 32 && *chan_ids > lastchan && (mask_copy & (1 << (*chan_ids-1)))) {
                mask_copy &= ~(1 << (*chan_ids-1));
                lastchan = *chan_ids++;
            }
            else
                break;

        // now scan the string for an actually defined channel (and don't store if there aren't any)

        for (i = 0; chan_ids [i]; i++)
            if (chan_ids [i] != 0xff) {
                wpc->channel_identities = (unsigned char *) strdup ((char *) chan_ids);
                break;
            }
    }

    // This loop goes through all the channels and creates the Wavpack ""streams"" for them to go in.
    // A stream can hold either one or two channels, so we have several rules to determine how many
    // channels will go in each stream.

    for (wpc->current_stream = 0; num_chans; wpc->current_stream++) {
        WavpackStream *wps = malloc (sizeof (WavpackStream));
        unsigned char left_chan_id = 0, right_chan_id = 0;
        int pos, chans = 1;

        // allocate the stream and initialize the pointer to it
        wpc->streams = realloc (wpc->streams, (wpc->current_stream + 1) * sizeof (wpc->streams [0]));
        wpc->streams [wpc->current_stream] = wps;
        CLEAR (*wps);

        // if there are any bits [still] set in the channel_mask, get the next one or two IDs from there
        if (chan_mask)
            for (pos = 0; pos < 32; ++pos)
                if (chan_mask & (1 << pos)) {
                    if (left_chan_id) {
                        right_chan_id = pos + 1;
                        break;
                    }
                    else {
                        chan_mask &= ~(1 << pos);
                        left_chan_id = pos + 1;
                    }
                }

        // next check for any channels identified in the channel-identities string
        while (!right_chan_id && chan_ids && *chan_ids)
            if (left_chan_id)
                right_chan_id = *chan_ids;
            else
                left_chan_id = *chan_ids++;

        // assume anything we did not get is ""unassigned""
        if (!left_chan_id)
            left_chan_id = right_chan_id = 0xff;
        else if (!right_chan_id)
            right_chan_id = 0xff;

        // if we have 2 channels, this is where we decide if we can combine them into one stream:
        // 1. they are ""unassigned"" and we've been told to combine unassigned pairs, or
        // 2. they appear together in the valid ""pairings"" list
        if (num_chans >= 2) {
            if ((config->flags & CONFIG_PAIR_UNDEF_CHANS) && left_chan_id == 0xff && right_chan_id == 0xff)
                chans = 2;
            else
                for (i = 0; i < NUM_STEREO_PAIRS; ++i)
                    if ((left_chan_id == stereo_pairs [i].a && right_chan_id == stereo_pairs [i].b) ||
                        (left_chan_id == stereo_pairs [i].b && right_chan_id == stereo_pairs [i].a)) {
                            if (right_chan_id <= 32 && (chan_mask & (1 << (right_chan_id-1))))
                                chan_mask &= ~(1 << (right_chan_id-1));
                            else if (chan_ids && *chan_ids == right_chan_id)
                                chan_ids++;

                            chans = 2;
                            break;
                        }
        }

        num_chans -= chans;

        if (num_chans && wpc->current_stream == NEW_MAX_STREAMS - 1)
            break;

        memcpy (wps->wphdr.ckID, ""wvpk"", 4);
        wps->wphdr.ckSize = sizeof (WavpackHeader) - 8;
        SET_TOTAL_SAMPLES (wps->wphdr, wpc->total_samples);
        wps->wphdr.version = wpc->stream_version;
        wps->wphdr.flags = flags;
        wps->bits = bps;

        if (!wpc->current_stream)
            wps->wphdr.flags |= INITIAL_BLOCK;

        if (!num_chans)
            wps->wphdr.flags |= FINAL_BLOCK;

        if (chans == 1) {
            wps->wphdr.flags &= ~(JOINT_STEREO | CROSS_DECORR | HYBRID_BALANCE);
            wps->wphdr.flags |= MONO_FLAG;
        }
    }

    wpc->num_streams = wpc->current_stream;
    wpc->current_stream = 0;

    if (num_chans) {
        strcpy (wpc->error_message, ""too many channels!"");
        return FALSE;
    }

    if (config->flags & CONFIG_EXTRA_MODE)
        wpc->config.xmode = config->xmode ? config->xmode : 1;

    return TRUE;
}
"
4530,182266,,Local,Not required,Partial,CVE-2018-15856,https://www.cvedetails.com/cve/CVE-2018-15856/,CWE-835,Low,,,,2018-08-25,2.1,An infinite loop when reaching EOL unexpectedly in compose/parser.c (aka the keymap parser) in xkbcommon before 0.8.1 could be used by local attackers to cause a denial of service during parsing of crafted keymap files.,2019-10-02,DoS ,1,https://github.com/xkbcommon/libxkbcommon/commit/842e4351c2c97de6051cab6ce36b4a81e709a0e1,842e4351c2c97de6051cab6ce36b4a81e709a0e1,"compose: fix infinite loop in parser on some inputs

The parser would enter an infinite loop if an unterminated keysym
literal occurs at EOF.

Found with the afl fuzzer.

Signed-off-by: Ran Benita <ran234@gmail.com>",1,src/compose/parser.c,"{""sha"": ""439d404f06b4c1e8bdc217248019e0ca6af53b51"", ""filename"": ""src/compose/parser.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/xkbcommon/libxkbcommon/blob/842e4351c2c97de6051cab6ce36b4a81e709a0e1/src/compose/parser.c"", ""raw_url"": ""https://github.com/xkbcommon/libxkbcommon/raw/842e4351c2c97de6051cab6ce36b4a81e709a0e1/src/compose/parser.c"", ""contents_url"": ""https://api.github.com/repos/xkbcommon/libxkbcommon/contents/src/compose/parser.c?ref=842e4351c2c97de6051cab6ce36b4a81e709a0e1"", ""patch"": ""@@ -144,7 +144,7 @@ lex(struct scanner *s, union lvalue *val)\n \n     /* LHS Keysym. */\n     if (chr(s, '<')) {\n-        while (peek(s) != '>' && !eol(s))\n+        while (peek(s) != '>' && !eol(s) && !eof(s))\n             buf_append(s, next(s));\n         if (!chr(s, '>')) {\n             scanner_err(s, \""unterminated keysym literal\"");""}","lex(struct scanner *s, union lvalue *val)
{
skip_more_whitespace_and_comments:
    /* Skip spaces. */
    while (is_space(peek(s)))
        if (next(s) == '\n')
            return TOK_END_OF_LINE;

    /* Skip comments. */
    if (chr(s, '#')) {
        skip_to_eol(s);
        goto skip_more_whitespace_and_comments;
    }

    /* See if we're done. */
    if (eof(s)) return TOK_END_OF_FILE;

    /* New token. */
    s->token_line = s->line;
    s->token_column = s->column;
    s->buf_pos = 0;
 
     /* LHS Keysym. */
     if (chr(s, '<')) {
        while (peek(s) != '>' && !eol(s) && !eof(s))
             buf_append(s, next(s));
         if (!chr(s, '>')) {
             scanner_err(s, ""unterminated keysym literal"");
            return TOK_ERROR;
        }
        if (!buf_append(s, '\0')) {
            scanner_err(s, ""keysym literal is too long"");
            return TOK_ERROR;
        }
        val->string.str = s->buf;
        val->string.len = s->buf_pos;
        return TOK_LHS_KEYSYM;
    }

    /* Colon. */
    if (chr(s, ':'))
        return TOK_COLON;
    if (chr(s, '!'))
        return TOK_BANG;
    if (chr(s, '~'))
        return TOK_TILDE;

    /* String literal. */
    if (chr(s, '\""')) {
        while (!eof(s) && !eol(s) && peek(s) != '\""') {
            if (chr(s, '\\')) {
                uint8_t o;
                if (chr(s, '\\')) {
                    buf_append(s, '\\');
                }
                else if (chr(s, '""')) {
                    buf_append(s, '""');
                }
                else if (chr(s, 'x') || chr(s, 'X')) {
                    if (hex(s, &o))
                        buf_append(s, (char) o);
                    else
                        scanner_warn(s, ""illegal hexadecimal escape sequence in string literal"");
                }
                else if (oct(s, &o)) {
                    buf_append(s, (char) o);
                }
                else {
                    scanner_warn(s, ""unknown escape sequence (%c) in string literal"", peek(s));
                    /* Ignore. */
                }
            } else {
                buf_append(s, next(s));
            }
        }
        if (!chr(s, '\""')) {
            scanner_err(s, ""unterminated string literal"");
            return TOK_ERROR;
        }
        if (!buf_append(s, '\0')) {
            scanner_err(s, ""string literal is too long"");
            return TOK_ERROR;
        }
        if (!is_valid_utf8(s->buf, s->buf_pos - 1)) {
            scanner_err(s, ""string literal is not a valid UTF-8 string"");
            return TOK_ERROR;
        }
        val->string.str = s->buf;
        val->string.len = s->buf_pos;
        return TOK_STRING;
    }

    /* Identifier or include. */
    if (is_alpha(peek(s)) || peek(s) == '_') {
        s->buf_pos = 0;
        while (is_alnum(peek(s)) || peek(s) == '_')
            buf_append(s, next(s));
        if (!buf_append(s, '\0')) {
            scanner_err(s, ""identifier is too long"");
            return TOK_ERROR;
        }

        if (streq(s->buf, ""include""))
            return TOK_INCLUDE;

        val->string.str = s->buf;
        val->string.len = s->buf_pos;
        return TOK_IDENT;
    }

    /* Discard rest of line. */
    skip_to_eol(s);

    scanner_err(s, ""unrecognized token"");
    return TOK_ERROR;
}
","lex(struct scanner *s, union lvalue *val)
{
skip_more_whitespace_and_comments:
    /* Skip spaces. */
    while (is_space(peek(s)))
        if (next(s) == '\n')
            return TOK_END_OF_LINE;

    /* Skip comments. */
    if (chr(s, '#')) {
        skip_to_eol(s);
        goto skip_more_whitespace_and_comments;
    }

    /* See if we're done. */
    if (eof(s)) return TOK_END_OF_FILE;

    /* New token. */
    s->token_line = s->line;
    s->token_column = s->column;
    s->buf_pos = 0;
 
     /* LHS Keysym. */
     if (chr(s, '<')) {
        while (peek(s) != '>' && !eol(s))
             buf_append(s, next(s));
         if (!chr(s, '>')) {
             scanner_err(s, ""unterminated keysym literal"");
            return TOK_ERROR;
        }
        if (!buf_append(s, '\0')) {
            scanner_err(s, ""keysym literal is too long"");
            return TOK_ERROR;
        }
        val->string.str = s->buf;
        val->string.len = s->buf_pos;
        return TOK_LHS_KEYSYM;
    }

    /* Colon. */
    if (chr(s, ':'))
        return TOK_COLON;
    if (chr(s, '!'))
        return TOK_BANG;
    if (chr(s, '~'))
        return TOK_TILDE;

    /* String literal. */
    if (chr(s, '\""')) {
        while (!eof(s) && !eol(s) && peek(s) != '\""') {
            if (chr(s, '\\')) {
                uint8_t o;
                if (chr(s, '\\')) {
                    buf_append(s, '\\');
                }
                else if (chr(s, '""')) {
                    buf_append(s, '""');
                }
                else if (chr(s, 'x') || chr(s, 'X')) {
                    if (hex(s, &o))
                        buf_append(s, (char) o);
                    else
                        scanner_warn(s, ""illegal hexadecimal escape sequence in string literal"");
                }
                else if (oct(s, &o)) {
                    buf_append(s, (char) o);
                }
                else {
                    scanner_warn(s, ""unknown escape sequence (%c) in string literal"", peek(s));
                    /* Ignore. */
                }
            } else {
                buf_append(s, next(s));
            }
        }
        if (!chr(s, '\""')) {
            scanner_err(s, ""unterminated string literal"");
            return TOK_ERROR;
        }
        if (!buf_append(s, '\0')) {
            scanner_err(s, ""string literal is too long"");
            return TOK_ERROR;
        }
        if (!is_valid_utf8(s->buf, s->buf_pos - 1)) {
            scanner_err(s, ""string literal is not a valid UTF-8 string"");
            return TOK_ERROR;
        }
        val->string.str = s->buf;
        val->string.len = s->buf_pos;
        return TOK_STRING;
    }

    /* Identifier or include. */
    if (is_alpha(peek(s)) || peek(s) == '_') {
        s->buf_pos = 0;
        while (is_alnum(peek(s)) || peek(s) == '_')
            buf_append(s, next(s));
        if (!buf_append(s, '\0')) {
            scanner_err(s, ""identifier is too long"");
            return TOK_ERROR;
        }

        if (streq(s->buf, ""include""))
            return TOK_INCLUDE;

        val->string.str = s->buf;
        val->string.len = s->buf_pos;
        return TOK_IDENT;
    }

    /* Discard rest of line. */
    skip_to_eol(s);

    scanner_err(s, ""unrecognized token"");
    return TOK_ERROR;
}
",C,"        while (peek(s) != '>' && !eol(s) && !eof(s))
","        while (peek(s) != '>' && !eol(s))
",,"@@ -144,7 +144,7 @@ lex(struct scanner *s, union lvalue *val)
 
     /* LHS Keysym. */
     if (chr(s, '<')) {
-        while (peek(s) != '>' && !eol(s))
+        while (peek(s) != '>' && !eol(s) && !eof(s))
             buf_append(s, next(s));
         if (!chr(s, '>')) {
             scanner_err(s, ""unterminated keysym literal"");",libxkbcommon,842e4351c2c97de6051cab6ce36b4a81e709a0e1,917636b1d0d70205a13f89062b95e3a0fc31d4ff,1,"lex(struct scanner *s, union lvalue *val)
{
skip_more_whitespace_and_comments:
    /* Skip spaces. */
    while (is_space(peek(s)))
        if (next(s) == '\n')
            return TOK_END_OF_LINE;

    /* Skip comments. */
    if (chr(s, '#')) {
        skip_to_eol(s);
        goto skip_more_whitespace_and_comments;
    }

    /* See if we're done. */
    if (eof(s)) return TOK_END_OF_FILE;

    /* New token. */
    s->token_line = s->line;
    s->token_column = s->column;
    s->buf_pos = 0;
 
     /* LHS Keysym. */
     if (chr(s, '<')) {
//flaw_line_below:
        while (peek(s) != '>' && !eol(s))
//fix_flaw_line_below:
//        while (peek(s) != '>' && !eol(s) && !eof(s))
             buf_append(s, next(s));
         if (!chr(s, '>')) {
             scanner_err(s, ""unterminated keysym literal"");
            return TOK_ERROR;
        }
        if (!buf_append(s, '\0')) {
            scanner_err(s, ""keysym literal is too long"");
            return TOK_ERROR;
        }
        val->string.str = s->buf;
        val->string.len = s->buf_pos;
        return TOK_LHS_KEYSYM;
    }

    /* Colon. */
    if (chr(s, ':'))
        return TOK_COLON;
    if (chr(s, '!'))
        return TOK_BANG;
    if (chr(s, '~'))
        return TOK_TILDE;

    /* String literal. */
    if (chr(s, '\""')) {
        while (!eof(s) && !eol(s) && peek(s) != '\""') {
            if (chr(s, '\\')) {
                uint8_t o;
                if (chr(s, '\\')) {
                    buf_append(s, '\\');
                }
                else if (chr(s, '""')) {
                    buf_append(s, '""');
                }
                else if (chr(s, 'x') || chr(s, 'X')) {
                    if (hex(s, &o))
                        buf_append(s, (char) o);
                    else
                        scanner_warn(s, ""illegal hexadecimal escape sequence in string literal"");
                }
                else if (oct(s, &o)) {
                    buf_append(s, (char) o);
                }
                else {
                    scanner_warn(s, ""unknown escape sequence (%c) in string literal"", peek(s));
                    /* Ignore. */
                }
            } else {
                buf_append(s, next(s));
            }
        }
        if (!chr(s, '\""')) {
            scanner_err(s, ""unterminated string literal"");
            return TOK_ERROR;
        }
        if (!buf_append(s, '\0')) {
            scanner_err(s, ""string literal is too long"");
            return TOK_ERROR;
        }
        if (!is_valid_utf8(s->buf, s->buf_pos - 1)) {
            scanner_err(s, ""string literal is not a valid UTF-8 string"");
            return TOK_ERROR;
        }
        val->string.str = s->buf;
        val->string.len = s->buf_pos;
        return TOK_STRING;
    }

    /* Identifier or include. */
    if (is_alpha(peek(s)) || peek(s) == '_') {
        s->buf_pos = 0;
        while (is_alnum(peek(s)) || peek(s) == '_')
            buf_append(s, next(s));
        if (!buf_append(s, '\0')) {
            scanner_err(s, ""identifier is too long"");
            return TOK_ERROR;
        }

        if (streq(s->buf, ""include""))
            return TOK_INCLUDE;

        val->string.str = s->buf;
        val->string.len = s->buf_pos;
        return TOK_IDENT;
    }

    /* Discard rest of line. */
    skip_to_eol(s);

    scanner_err(s, ""unrecognized token"");
    return TOK_ERROR;
}
"
4784,182520,,Remote,Not required,Partial,CVE-2018-6196,https://www.cvedetails.com/cve/CVE-2018-6196/,CWE-835,Low,,,,2018-01-24,5.0,w3m through 0.5.3 is prone to an infinite recursion flaw in HTMLlineproc0 because the feed_table_block_tag function in table.c does not prevent a negative indent value.,2019-10-02,,4,https://github.com/tats/w3m/commit/8354763b90490d4105695df52674d0fcef823e92,8354763b90490d4105695df52674d0fcef823e92,"Prevent negative indent value in feed_table_block_tag()

Bug-Debian: https://github.com/tats/w3m/issues/88",0,table.c,"{""sha"": ""4f193e155b1772e0f0d03b7c2366bab7e2e310be"", ""filename"": ""table.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/tats/w3m/blob/8354763b90490d4105695df52674d0fcef823e92/table.c"", ""raw_url"": ""https://github.com/tats/w3m/raw/8354763b90490d4105695df52674d0fcef823e92/table.c"", ""contents_url"": ""https://api.github.com/repos/tats/w3m/contents/table.c?ref=8354763b90490d4105695df52674d0fcef823e92"", ""patch"": ""@@ -2356,10 +2356,14 @@ feed_table_block_tag(struct table *tbl,\n \tif (mode->indent_level < MAX_INDENT_LEVEL)\n \t    tbl->indent -= INDENT_INCR;\n     }\n+    if (tbl->indent < 0)\n+\ttbl->indent = 0;\n     offset = tbl->indent;\n     if (cmd == HTML_DT) {\n \tif (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)\n \t    offset -= INDENT_INCR;\n+\tif (offset < 0)\n+\t    offset = 0;\n     }\n     if (tbl->indent > 0) {\n \tcheck_minimum0(tbl, 0);""}","feed_table_block_tag(struct table *tbl,
		     char *line, struct table_mode *mode, int indent, int cmd)
{
    int offset;
    if (mode->indent_level <= 0 && indent == -1)
	return;
    if (mode->indent_level >= CHAR_MAX && indent == 1)
	return;
    setwidth(tbl, mode);
    feed_table_inline_tag(tbl, line, mode, -1);
    clearcontentssize(tbl, mode);
    if (indent == 1) {
	mode->indent_level++;
	if (mode->indent_level <= MAX_INDENT_LEVEL)
	    tbl->indent += INDENT_INCR;
    }
    else if (indent == -1) {
	mode->indent_level--;
 	if (mode->indent_level < MAX_INDENT_LEVEL)
 	    tbl->indent -= INDENT_INCR;
     }
    if (tbl->indent < 0)
	tbl->indent = 0;
     offset = tbl->indent;
     if (cmd == HTML_DT) {
 	if (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)
 	    offset -= INDENT_INCR;
	if (offset < 0)
	    offset = 0;
     }
     if (tbl->indent > 0) {
 	check_minimum0(tbl, 0);
	addcontentssize(tbl, offset);
    }
}
","feed_table_block_tag(struct table *tbl,
		     char *line, struct table_mode *mode, int indent, int cmd)
{
    int offset;
    if (mode->indent_level <= 0 && indent == -1)
	return;
    if (mode->indent_level >= CHAR_MAX && indent == 1)
	return;
    setwidth(tbl, mode);
    feed_table_inline_tag(tbl, line, mode, -1);
    clearcontentssize(tbl, mode);
    if (indent == 1) {
	mode->indent_level++;
	if (mode->indent_level <= MAX_INDENT_LEVEL)
	    tbl->indent += INDENT_INCR;
    }
    else if (indent == -1) {
	mode->indent_level--;
 	if (mode->indent_level < MAX_INDENT_LEVEL)
 	    tbl->indent -= INDENT_INCR;
     }
     offset = tbl->indent;
     if (cmd == HTML_DT) {
 	if (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)
 	    offset -= INDENT_INCR;
     }
     if (tbl->indent > 0) {
 	check_minimum0(tbl, 0);
	addcontentssize(tbl, offset);
    }
}
",C,"    if (tbl->indent < 0)
	tbl->indent = 0;
	if (offset < 0)
	    offset = 0;
",,,"@@ -2356,10 +2356,14 @@ feed_table_block_tag(struct table *tbl,
 	if (mode->indent_level < MAX_INDENT_LEVEL)
 	    tbl->indent -= INDENT_INCR;
     }
+    if (tbl->indent < 0)
+	tbl->indent = 0;
     offset = tbl->indent;
     if (cmd == HTML_DT) {
 	if (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)
 	    offset -= INDENT_INCR;
+	if (offset < 0)
+	    offset = 0;
     }
     if (tbl->indent > 0) {
 	check_minimum0(tbl, 0);",w3m,8354763b90490d4105695df52674d0fcef823e92,707fb45073dda8c04f6e324dbadbabd5d0a18e93,1,"feed_table_block_tag(struct table *tbl,
		     char *line, struct table_mode *mode, int indent, int cmd)
{
    int offset;
    if (mode->indent_level <= 0 && indent == -1)
	return;
    if (mode->indent_level >= CHAR_MAX && indent == 1)
	return;
    setwidth(tbl, mode);
    feed_table_inline_tag(tbl, line, mode, -1);
    clearcontentssize(tbl, mode);
    if (indent == 1) {
	mode->indent_level++;
	if (mode->indent_level <= MAX_INDENT_LEVEL)
	    tbl->indent += INDENT_INCR;
    }
    else if (indent == -1) {
	mode->indent_level--;
 	if (mode->indent_level < MAX_INDENT_LEVEL)
 	    tbl->indent -= INDENT_INCR;
     }
//fix_flaw_line_below:
//    if (tbl->indent < 0)
//fix_flaw_line_below:
//	tbl->indent = 0;
     offset = tbl->indent;
     if (cmd == HTML_DT) {
 	if (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)
 	    offset -= INDENT_INCR;
//fix_flaw_line_below:
//	if (offset < 0)
//fix_flaw_line_below:
//	    offset = 0;
     }
     if (tbl->indent > 0) {
 	check_minimum0(tbl, 0);
	addcontentssize(tbl, offset);
    }
}
"
4845,182581,,Local,Not required,Complete,CVE-2017-18208,https://www.cvedetails.com/cve/CVE-2017-18208/,CWE-835,Low,,,,2018-03-01,4.9,The madvise_willneed function in mm/madvise.c in the Linux kernel before 4.14.4 allows local users to cause a denial of service (infinite loop) by triggering use of MADVISE_WILLNEED for a DAX mapping.,2019-10-02,DoS ,1,https://github.com/torvalds/linux/commit/6ea8d958a2c95a1d514015d4e29ba21a8c0a1a91,6ea8d958a2c95a1d514015d4e29ba21a8c0a1a91,"mm/madvise.c: fix madvise() infinite loop under special circumstances

MADVISE_WILLNEED has always been a noop for DAX (formerly XIP) mappings.
Unfortunately madvise_willneed() doesn't communicate this information
properly to the generic madvise syscall implementation.  The calling
convention is quite subtle there.  madvise_vma() is supposed to either
return an error or update &prev otherwise the main loop will never
advance to the next vma and it will keep looping for ever without a way
to get out of the kernel.

It seems this has been broken since introduction.  Nobody has noticed
because nobody seems to be using MADVISE_WILLNEED on these DAX mappings.

[mhocko@suse.com: rewrite changelog]
Link: http://lkml.kernel.org/r/20171127115318.911-1-guoxuenan@huawei.com
Fixes: fe77ba6f4f97 (""[PATCH] xip: madvice/fadvice: execute in place"")
Signed-off-by: chenjie <chenjie6@huawei.com>
Signed-off-by: guoxuenan <guoxuenan@huawei.com>
Acked-by: Michal Hocko <mhocko@suse.com>
Cc: Minchan Kim <minchan@kernel.org>
Cc: zhangyi (F) <yi.zhang@huawei.com>
Cc: Miao Xie <miaoxie@huawei.com>
Cc: Mike Rapoport <rppt@linux.vnet.ibm.com>
Cc: Shaohua Li <shli@fb.com>
Cc: Andrea Arcangeli <aarcange@redhat.com>
Cc: Mel Gorman <mgorman@techsingularity.net>
Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Cc: David Rientjes <rientjes@google.com>
Cc: Anshuman Khandual <khandual@linux.vnet.ibm.com>
Cc: Rik van Riel <riel@redhat.com>
Cc: Carsten Otte <cotte@de.ibm.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",3,mm/madvise.c,"{""sha"": ""751e97aa22106f9be73919033271ad9f98498fca"", ""filename"": ""mm/madvise.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/6ea8d958a2c95a1d514015d4e29ba21a8c0a1a91/mm/madvise.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/6ea8d958a2c95a1d514015d4e29ba21a8c0a1a91/mm/madvise.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/madvise.c?ref=6ea8d958a2c95a1d514015d4e29ba21a8c0a1a91"", ""patch"": ""@@ -276,15 +276,14 @@ static long madvise_willneed(struct vm_area_struct *vma,\n {\n \tstruct file *file = vma->vm_file;\n \n+\t*prev = vma;\n #ifdef CONFIG_SWAP\n \tif (!file) {\n-\t\t*prev = vma;\n \t\tforce_swapin_readahead(vma, start, end);\n \t\treturn 0;\n \t}\n \n \tif (shmem_mapping(file->f_mapping)) {\n-\t\t*prev = vma;\n \t\tforce_shm_swapin_readahead(vma, start, end,\n \t\t\t\t\tfile->f_mapping);\n \t\treturn 0;\n@@ -299,7 +298,6 @@ static long madvise_willneed(struct vm_area_struct *vma,\n \t\treturn 0;\n \t}\n \n-\t*prev = vma;\n \tstart = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n \tif (end > vma->vm_end)\n \t\tend = vma->vm_end;""}","static long madvise_willneed(struct vm_area_struct *vma,
			     struct vm_area_struct **prev,
			     unsigned long start, unsigned long end)
 {
 	struct file *file = vma->vm_file;
 
	*prev = vma;
 #ifdef CONFIG_SWAP
 	if (!file) {
 		force_swapin_readahead(vma, start, end);
 		return 0;
 	}
 
 	if (shmem_mapping(file->f_mapping)) {
 		force_shm_swapin_readahead(vma, start, end,
 					file->f_mapping);
 		return 0;
	}
#else
	if (!file)
		return -EBADF;
#endif

	if (IS_DAX(file_inode(file))) {
		/* no bad return value, but ignore advice */
 		return 0;
 	}
 
 	start = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;
 	if (end > vma->vm_end)
 		end = vma->vm_end;
	end = ((end - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;

	force_page_cache_readahead(file->f_mapping, file, start, end - start);
	return 0;
}
","static long madvise_willneed(struct vm_area_struct *vma,
			     struct vm_area_struct **prev,
			     unsigned long start, unsigned long end)
 {
 	struct file *file = vma->vm_file;
 
 #ifdef CONFIG_SWAP
 	if (!file) {
		*prev = vma;
 		force_swapin_readahead(vma, start, end);
 		return 0;
 	}
 
 	if (shmem_mapping(file->f_mapping)) {
		*prev = vma;
 		force_shm_swapin_readahead(vma, start, end,
 					file->f_mapping);
 		return 0;
	}
#else
	if (!file)
		return -EBADF;
#endif

	if (IS_DAX(file_inode(file))) {
		/* no bad return value, but ignore advice */
 		return 0;
 	}
 
	*prev = vma;
 	start = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;
 	if (end > vma->vm_end)
 		end = vma->vm_end;
	end = ((end - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;

	force_page_cache_readahead(file->f_mapping, file, start, end - start);
	return 0;
}
",C,"	*prev = vma;
","		*prev = vma;
		*prev = vma;
	*prev = vma;
",,"@@ -276,15 +276,14 @@ static long madvise_willneed(struct vm_area_struct *vma,
 {
 	struct file *file = vma->vm_file;
 
+	*prev = vma;
 #ifdef CONFIG_SWAP
 	if (!file) {
-		*prev = vma;
 		force_swapin_readahead(vma, start, end);
 		return 0;
 	}
 
 	if (shmem_mapping(file->f_mapping)) {
-		*prev = vma;
 		force_shm_swapin_readahead(vma, start, end,
 					file->f_mapping);
 		return 0;
@@ -299,7 +298,6 @@ static long madvise_willneed(struct vm_area_struct *vma,
 		return 0;
 	}
 
-	*prev = vma;
 	start = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;
 	if (end > vma->vm_end)
 		end = vma->vm_end;",linux,6ea8d958a2c95a1d514015d4e29ba21a8c0a1a91,04e35f4495dd560db30c25efca4eecae8ec8c375,1,"static long madvise_willneed(struct vm_area_struct *vma,
			     struct vm_area_struct **prev,
			     unsigned long start, unsigned long end)
 {
 	struct file *file = vma->vm_file;
 
//fix_flaw_line_below:
//	*prev = vma;
 #ifdef CONFIG_SWAP
 	if (!file) {
//flaw_line_below:
		*prev = vma;
 		force_swapin_readahead(vma, start, end);
 		return 0;
 	}
 
 	if (shmem_mapping(file->f_mapping)) {
//flaw_line_below:
		*prev = vma;
 		force_shm_swapin_readahead(vma, start, end,
 					file->f_mapping);
 		return 0;
	}
#else
	if (!file)
		return -EBADF;
#endif

	if (IS_DAX(file_inode(file))) {
		/* no bad return value, but ignore advice */
 		return 0;
 	}
 
//flaw_line_below:
	*prev = vma;
 	start = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;
 	if (end > vma->vm_end)
 		end = vma->vm_end;
	end = ((end - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;

	force_page_cache_readahead(file->f_mapping, file, start, end - start);
	return 0;
}
"
5474,183210,,Remote,Not required,Complete,CVE-2017-11523,https://www.cvedetails.com/cve/CVE-2017-11523/,CWE-835,Medium,,,,2017-07-22,7.1,"The ReadTXTImage function in coders/txt.c in ImageMagick through 6.9.9-0 and 7.x through 7.0.6-1 allows remote attackers to cause a denial of service (infinite loop) via a crafted file, because the end-of-file condition is not considered.",2019-10-02,DoS ,6,https://github.com/ImageMagick/ImageMagick/commit/83e0f8ffd7eeb7661b0ff83257da23d24ca7f078,83e0f8ffd7eeb7661b0ff83257da23d24ca7f078,https://github.com/ImageMagick/ImageMagick/issues/591,0,coders/txt.c,"{""sha"": ""16e7ac2e94c7f7a0925e3eadc2fe2128b07c5ae2"", ""filename"": ""coders/txt.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/83e0f8ffd7eeb7661b0ff83257da23d24ca7f078/coders/txt.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/83e0f8ffd7eeb7661b0ff83257da23d24ca7f078/coders/txt.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/txt.c?ref=83e0f8ffd7eeb7661b0ff83257da23d24ca7f078"", ""patch"": ""@@ -563,6 +563,12 @@ static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n           break;\n       }\n     }\n+    if (EOFBlob(image) != MagickFalse)\n+      {\n+        ThrowFileException(exception,CorruptImageError,\""UnexpectedEndOfFile\"",\n+          image->filename);\n+        break;\n+      }\n     (void) ReadBlobString(image,text);\n     if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n       {""}","static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  char
    colorspace[MagickPathExtent],
    text[MagickPathExtent];

  Image
    *image;

  long
    x_offset,
    y_offset;

  PixelInfo
    pixel;

  MagickBooleanType
    status;

  QuantumAny
    range;

  register ssize_t
    i,
    x;

  register Quantum
    *q;

  ssize_t
    count,
    type,
    y;

  unsigned long
    depth,
    height,
    max_value,
    width;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  (void) ResetMagickMemory(text,0,sizeof(text));
  (void) ReadBlobString(image,text);
  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  do
  {
    width=0;
    height=0;
    max_value=0;
    *colorspace='\0';
    count=(ssize_t) sscanf(text+32,""%lu,%lu,%lu,%s"",&width,&height,&max_value,
      colorspace);
    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    image->columns=width;
    image->rows=height;
    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;
    image->depth=depth;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    LocaleLower(colorspace);
    i=(ssize_t) strlen(colorspace)-1;
    image->alpha_trait=UndefinedPixelTrait;
    if ((i > 0) && (colorspace[i] == 'a'))
      {
        colorspace[i]='\0';
        image->alpha_trait=BlendPixelTrait;
      }
    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);
    if (type < 0)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    (void) SetImageBackgroundColor(image,exception);
    (void) SetImageColorspace(image,(ColorspaceType) type,exception);
    GetPixelInfo(image,&pixel);
    range=GetQuantumRange(image->depth);
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      double
        alpha,
        black,
        blue,
        green,
        red;

      red=0.0;
      green=0.0;
      blue=0.0;
      black=0.0;
      alpha=0.0;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        if (ReadBlobString(image,text) == (char *) NULL)
          break;
        switch (image->colorspace)
        {
          case GRAYColorspace:
          {
            if (image->alpha_trait != UndefinedPixelTrait)
              {
                count=(ssize_t) sscanf(text,""%ld,%ld: (%lf%*[%,]%lf%*[%,]"",
                  &x_offset,&y_offset,&red,&alpha);
                green=red;
                blue=red;
                break;
              }
            count=(ssize_t) sscanf(text,""%ld,%ld: (%lf%*[%,]"",&x_offset,
              &y_offset,&red);
            green=red;
            blue=red;
            break;       
          }
          case CMYKColorspace:
          {
            if (image->alpha_trait != UndefinedPixelTrait)
              {
                count=(ssize_t) sscanf(text,
                  ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                  &x_offset,&y_offset,&red,&green,&blue,&black,&alpha);
                break;
              }
            count=(ssize_t) sscanf(text,
              ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&x_offset,
              &y_offset,&red,&green,&blue,&black);
            break;
          }
          default:
          {
            if (image->alpha_trait != UndefinedPixelTrait)
              {
                count=(ssize_t) sscanf(text,
                  ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                  &x_offset,&y_offset,&red,&green,&blue,&alpha);
                break;
              }
            count=(ssize_t) sscanf(text,
              ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&x_offset,
              &y_offset,&red,&green,&blue);
            break;       
          }
        }
        if (strchr(text,'%') != (char *) NULL)
          {
            red*=0.01*range;
            green*=0.01*range;
            blue*=0.01*range;
            black*=0.01*range;
            alpha*=0.01*range;
          }
        if (image->colorspace == LabColorspace)
          {
            green+=(range+1)/2.0;
            blue+=(range+1)/2.0;
          }
        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),
          range);
        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),
          range);
        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),
          range);
        pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (black+0.5),
          range);
        pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (alpha+0.5),
          range);
        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,
          exception);
        if (q == (Quantum *) NULL)
          continue;
        SetPixelViaPixelInfo(image,&pixel,q);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
           break;
       }
     }
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
     (void) ReadBlobString(image,text);
     if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)
       {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  char
    colorspace[MagickPathExtent],
    text[MagickPathExtent];

  Image
    *image;

  long
    x_offset,
    y_offset;

  PixelInfo
    pixel;

  MagickBooleanType
    status;

  QuantumAny
    range;

  register ssize_t
    i,
    x;

  register Quantum
    *q;

  ssize_t
    count,
    type,
    y;

  unsigned long
    depth,
    height,
    max_value,
    width;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  (void) ResetMagickMemory(text,0,sizeof(text));
  (void) ReadBlobString(image,text);
  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  do
  {
    width=0;
    height=0;
    max_value=0;
    *colorspace='\0';
    count=(ssize_t) sscanf(text+32,""%lu,%lu,%lu,%s"",&width,&height,&max_value,
      colorspace);
    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    image->columns=width;
    image->rows=height;
    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;
    image->depth=depth;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    LocaleLower(colorspace);
    i=(ssize_t) strlen(colorspace)-1;
    image->alpha_trait=UndefinedPixelTrait;
    if ((i > 0) && (colorspace[i] == 'a'))
      {
        colorspace[i]='\0';
        image->alpha_trait=BlendPixelTrait;
      }
    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);
    if (type < 0)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    (void) SetImageBackgroundColor(image,exception);
    (void) SetImageColorspace(image,(ColorspaceType) type,exception);
    GetPixelInfo(image,&pixel);
    range=GetQuantumRange(image->depth);
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      double
        alpha,
        black,
        blue,
        green,
        red;

      red=0.0;
      green=0.0;
      blue=0.0;
      black=0.0;
      alpha=0.0;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        if (ReadBlobString(image,text) == (char *) NULL)
          break;
        switch (image->colorspace)
        {
          case GRAYColorspace:
          {
            if (image->alpha_trait != UndefinedPixelTrait)
              {
                count=(ssize_t) sscanf(text,""%ld,%ld: (%lf%*[%,]%lf%*[%,]"",
                  &x_offset,&y_offset,&red,&alpha);
                green=red;
                blue=red;
                break;
              }
            count=(ssize_t) sscanf(text,""%ld,%ld: (%lf%*[%,]"",&x_offset,
              &y_offset,&red);
            green=red;
            blue=red;
            break;       
          }
          case CMYKColorspace:
          {
            if (image->alpha_trait != UndefinedPixelTrait)
              {
                count=(ssize_t) sscanf(text,
                  ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                  &x_offset,&y_offset,&red,&green,&blue,&black,&alpha);
                break;
              }
            count=(ssize_t) sscanf(text,
              ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&x_offset,
              &y_offset,&red,&green,&blue,&black);
            break;
          }
          default:
          {
            if (image->alpha_trait != UndefinedPixelTrait)
              {
                count=(ssize_t) sscanf(text,
                  ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                  &x_offset,&y_offset,&red,&green,&blue,&alpha);
                break;
              }
            count=(ssize_t) sscanf(text,
              ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&x_offset,
              &y_offset,&red,&green,&blue);
            break;       
          }
        }
        if (strchr(text,'%') != (char *) NULL)
          {
            red*=0.01*range;
            green*=0.01*range;
            blue*=0.01*range;
            black*=0.01*range;
            alpha*=0.01*range;
          }
        if (image->colorspace == LabColorspace)
          {
            green+=(range+1)/2.0;
            blue+=(range+1)/2.0;
          }
        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),
          range);
        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),
          range);
        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),
          range);
        pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (black+0.5),
          range);
        pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (alpha+0.5),
          range);
        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,
          exception);
        if (q == (Quantum *) NULL)
          continue;
        SetPixelViaPixelInfo(image,&pixel,q);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
           break;
       }
     }
     (void) ReadBlobString(image,text);
     if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)
       {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",C,"    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
",,,"@@ -563,6 +563,12 @@ static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)
           break;
       }
     }
+    if (EOFBlob(image) != MagickFalse)
+      {
+        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
+          image->filename);
+        break;
+      }
     (void) ReadBlobString(image,text);
     if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)
       {",ImageMagick,83e0f8ffd7eeb7661b0ff83257da23d24ca7f078,cd494bc82b4d61ef02da92ac2f0082b018125d00,1,"static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  char
    colorspace[MagickPathExtent],
    text[MagickPathExtent];

  Image
    *image;

  long
    x_offset,
    y_offset;

  PixelInfo
    pixel;

  MagickBooleanType
    status;

  QuantumAny
    range;

  register ssize_t
    i,
    x;

  register Quantum
    *q;

  ssize_t
    count,
    type,
    y;

  unsigned long
    depth,
    height,
    max_value,
    width;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  (void) ResetMagickMemory(text,0,sizeof(text));
  (void) ReadBlobString(image,text);
  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  do
  {
    width=0;
    height=0;
    max_value=0;
    *colorspace='\0';
    count=(ssize_t) sscanf(text+32,""%lu,%lu,%lu,%s"",&width,&height,&max_value,
      colorspace);
    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    image->columns=width;
    image->rows=height;
    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;
    image->depth=depth;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    LocaleLower(colorspace);
    i=(ssize_t) strlen(colorspace)-1;
    image->alpha_trait=UndefinedPixelTrait;
    if ((i > 0) && (colorspace[i] == 'a'))
      {
        colorspace[i]='\0';
        image->alpha_trait=BlendPixelTrait;
      }
    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);
    if (type < 0)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    (void) SetImageBackgroundColor(image,exception);
    (void) SetImageColorspace(image,(ColorspaceType) type,exception);
    GetPixelInfo(image,&pixel);
    range=GetQuantumRange(image->depth);
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      double
        alpha,
        black,
        blue,
        green,
        red;

      red=0.0;
      green=0.0;
      blue=0.0;
      black=0.0;
      alpha=0.0;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        if (ReadBlobString(image,text) == (char *) NULL)
          break;
        switch (image->colorspace)
        {
          case GRAYColorspace:
          {
            if (image->alpha_trait != UndefinedPixelTrait)
              {
                count=(ssize_t) sscanf(text,""%ld,%ld: (%lf%*[%,]%lf%*[%,]"",
                  &x_offset,&y_offset,&red,&alpha);
                green=red;
                blue=red;
                break;
              }
            count=(ssize_t) sscanf(text,""%ld,%ld: (%lf%*[%,]"",&x_offset,
              &y_offset,&red);
            green=red;
            blue=red;
            break;       
          }
          case CMYKColorspace:
          {
            if (image->alpha_trait != UndefinedPixelTrait)
              {
                count=(ssize_t) sscanf(text,
                  ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                  &x_offset,&y_offset,&red,&green,&blue,&black,&alpha);
                break;
              }
            count=(ssize_t) sscanf(text,
              ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&x_offset,
              &y_offset,&red,&green,&blue,&black);
            break;
          }
          default:
          {
            if (image->alpha_trait != UndefinedPixelTrait)
              {
                count=(ssize_t) sscanf(text,
                  ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                  &x_offset,&y_offset,&red,&green,&blue,&alpha);
                break;
              }
            count=(ssize_t) sscanf(text,
              ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&x_offset,
              &y_offset,&red,&green,&blue);
            break;       
          }
        }
        if (strchr(text,'%') != (char *) NULL)
          {
            red*=0.01*range;
            green*=0.01*range;
            blue*=0.01*range;
            black*=0.01*range;
            alpha*=0.01*range;
          }
        if (image->colorspace == LabColorspace)
          {
            green+=(range+1)/2.0;
            blue+=(range+1)/2.0;
          }
        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),
          range);
        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),
          range);
        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),
          range);
        pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (black+0.5),
          range);
        pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (alpha+0.5),
          range);
        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,
          exception);
        if (q == (Quantum *) NULL)
          continue;
        SetPixelViaPixelInfo(image,&pixel,q);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
           break;
       }
     }
//fix_flaw_line_below:
//    if (EOFBlob(image) != MagickFalse)
//fix_flaw_line_below:
//      {
//fix_flaw_line_below:
//        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
//fix_flaw_line_below:
//          image->filename);
//fix_flaw_line_below:
//        break;
//fix_flaw_line_below:
//      }
     (void) ReadBlobString(image,text);
     if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)
       {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
"
