,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,T1_Top_10_CWE_IDs,T2_Correctly_Found_CWE,T3_IFA
0,0,177869,177869,,Remote,Not required,Partial,CVE-2018-16513,https://www.cvedetails.com/cve/CVE-2018-16513/,CWE-704,Medium,Partial,Partial,,2018-09-05,6.8,"In Artifex Ghostscript before 9.24, attackers able to supply crafted PostScript files could use a type confusion in the setcolor function to crash the interpreter or possibly have unspecified other impact.",2019-04-25,,3,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=b326a71659b7837d3acde954b18bda1a6f5e9498,b326a71659b7837d3acde954b18bda1a6f5e9498,,2,,,"zsetcolor(i_ctx_t * i_ctx_p)
{
    os_ptr                  op = osp;
    es_ptr ep;
    const gs_color_space *  pcs = gs_currentcolorspace(igs);
    gs_client_color         cc;
    int                     n_comps, n_numeric_comps, num_offset = 0, code, depth;
    PS_colour_space_t *space;

    /* initialize the client color pattern pointer for GC */
    cc.pattern = 0;

    /* check for a pattern color space */
    if ((n_comps = cs_num_components(pcs)) < 0) {
        n_comps = -n_comps;
         if (r_has_type(op, t_dictionary)) {
             ref     *pImpl, pPatInst;
 
            if ((code = dict_find_string(op, ""Implementation"", &pImpl)) < 0)
                return code;
            if (code > 0) {
                 code = array_get(imemory, pImpl, 0, &pPatInst);
                 if (code < 0)
                     return code;
                n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern)
                      ? n_comps - 1
                      : 0 );
            } else
                n_numeric_comps = 0;
        } else
            n_numeric_comps = 0;
        num_offset = 1;
    } else
        n_numeric_comps = n_comps;

    /* gather the numeric operands */
    code = float_params(op - num_offset, n_numeric_comps, cc.paint.values);
    if (code < 0)
        return code;
    /* The values are copied to graphic state and compared with */
    /* other colors by memcmp() in gx_hld_saved_color_equal()   */
    /* This is the easiest way to avoid indeterminism */
    memset(cc.paint.values + n_numeric_comps, 0,
            sizeof(cc.paint.values) - sizeof(*cc.paint.values)*n_numeric_comps);

    code = get_space_object(i_ctx_p, &istate->colorspace[0].array, &space);
    if (code < 0)
        return code;
    if (space->validatecomponents) {
        code = space->validatecomponents(i_ctx_p,
                                         &istate->colorspace[0].array,
                                         cc.paint.values, n_numeric_comps);
        if (code < 0)
            return code;
    }

    /* pass the color to the graphic library */
    if ((code = gs_setcolor(igs, &cc)) >= 0) {

        if (n_comps > n_numeric_comps) {
            istate->pattern[0] = *op;      /* save pattern dict or null */
        }
    }

    /* Check the color spaces, to see if we need to run any tint transform
     * procedures. Some Adobe applications *eg Photoshop) expect that the
     * tint transform will be run and use this to set up duotone DeviceN
     * spaces.
     */
    code = validate_spaces(i_ctx_p, &istate->colorspace[0].array, &depth);
    if (code < 0)
        return code;
    /* Set up for the continuation procedure which will do the work */
    /* Make sure the exec stack has enough space */
    check_estack(5);
    /* A place holder for data potentially used by transform functions */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'depth' of the space returned during checking above */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'stage' of processing (initially 0) */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store a pointer to the color space stored on the operand stack
     * as the stack may grow unpredictably making further access
     * to the space difficult
     */
    ep = esp += 1;
    *ep = istate->colorspace[0].array;
    /* Finally, the actual continuation routine */
    push_op_estack(setcolor_cont);
    return o_push_estack;
}
","zsetcolor(i_ctx_t * i_ctx_p)
{
    os_ptr                  op = osp;
    es_ptr ep;
    const gs_color_space *  pcs = gs_currentcolorspace(igs);
    gs_client_color         cc;
    int                     n_comps, n_numeric_comps, num_offset = 0, code, depth;
    PS_colour_space_t *space;

    /* initialize the client color pattern pointer for GC */
    cc.pattern = 0;

    /* check for a pattern color space */
    if ((n_comps = cs_num_components(pcs)) < 0) {
        n_comps = -n_comps;
         if (r_has_type(op, t_dictionary)) {
             ref     *pImpl, pPatInst;
 
            code = dict_find_string(op, ""Implementation"", &pImpl);
            if (code != 0) {
                 code = array_get(imemory, pImpl, 0, &pPatInst);
                 if (code < 0)
                     return code;
                n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern)
                      ? n_comps - 1
                      : 0 );
            } else
                n_numeric_comps = 0;
        } else
            n_numeric_comps = 0;
        num_offset = 1;
    } else
        n_numeric_comps = n_comps;

    /* gather the numeric operands */
    code = float_params(op - num_offset, n_numeric_comps, cc.paint.values);
    if (code < 0)
        return code;
    /* The values are copied to graphic state and compared with */
    /* other colors by memcmp() in gx_hld_saved_color_equal()   */
    /* This is the easiest way to avoid indeterminism */
    memset(cc.paint.values + n_numeric_comps, 0,
            sizeof(cc.paint.values) - sizeof(*cc.paint.values)*n_numeric_comps);

    code = get_space_object(i_ctx_p, &istate->colorspace[0].array, &space);
    if (code < 0)
        return code;
    if (space->validatecomponents) {
        code = space->validatecomponents(i_ctx_p,
                                         &istate->colorspace[0].array,
                                         cc.paint.values, n_numeric_comps);
        if (code < 0)
            return code;
    }

    /* pass the color to the graphic library */
    if ((code = gs_setcolor(igs, &cc)) >= 0) {

        if (n_comps > n_numeric_comps) {
            istate->pattern[0] = *op;      /* save pattern dict or null */
        }
    }

    /* Check the color spaces, to see if we need to run any tint transform
     * procedures. Some Adobe applications *eg Photoshop) expect that the
     * tint transform will be run and use this to set up duotone DeviceN
     * spaces.
     */
    code = validate_spaces(i_ctx_p, &istate->colorspace[0].array, &depth);
    if (code < 0)
        return code;
    /* Set up for the continuation procedure which will do the work */
    /* Make sure the exec stack has enough space */
    check_estack(5);
    /* A place holder for data potentially used by transform functions */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'depth' of the space returned during checking above */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'stage' of processing (initially 0) */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store a pointer to the color space stored on the operand stack
     * as the stack may grow unpredictably making further access
     * to the space difficult
     */
    ep = esp += 1;
    *ep = istate->colorspace[0].array;
    /* Finally, the actual continuation routine */
    push_op_estack(setcolor_cont);
    return o_push_estack;
}
",C,"            if ((code = dict_find_string(op, ""Implementation"", &pImpl)) < 0)
                return code;
            if (code > 0) {
","            code = dict_find_string(op, ""Implementation"", &pImpl);
            if (code != 0) {
",f25045e88de674a1202c1239565ee99e9ddabe91,"@@ -283,8 +283,9 @@ zsetcolor(i_ctx_t * i_ctx_p)
         if (r_has_type(op, t_dictionary)) {
             ref     *pImpl, pPatInst;
 
-            code = dict_find_string(op, ""Implementation"", &pImpl);
-            if (code != 0) {
+            if ((code = dict_find_string(op, ""Implementation"", &pImpl)) < 0)
+                return code;
+            if (code > 0) {
                 code = array_get(imemory, pImpl, 0, &pPatInst);
                 if (code < 0)
                     return code;",ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/zcolor.c;h=e27baf98880bfb3a3b4ae82e96936ceefacdac78;hb=e27baf98880bfb3a3b4ae82e96936ceefacdac78,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/zcolor.c;h=4c0f25827e320ceaa9b510c98f9b1926532a26d5;hb=4c0f25827e320ceaa9b510c98f9b1926532a26d5,1,"zsetcolor(i_ctx_t * i_ctx_p)
{
    os_ptr                  op = osp;
    es_ptr ep;
    const gs_color_space *  pcs = gs_currentcolorspace(igs);
    gs_client_color         cc;
    int                     n_comps, n_numeric_comps, num_offset = 0, code, depth;
    PS_colour_space_t *space;

    /* initialize the client color pattern pointer for GC */
    cc.pattern = 0;

    /* check for a pattern color space */
    if ((n_comps = cs_num_components(pcs)) < 0) {
        n_comps = -n_comps;
         if (r_has_type(op, t_dictionary)) {
             ref     *pImpl, pPatInst;
 
//flaw_line_below:
            code = dict_find_string(op, ""Implementation"", &pImpl);
//flaw_line_below:
            if (code != 0) {
//fix_flaw_line_below:
//            if ((code = dict_find_string(op, ""Implementation"", &pImpl)) < 0)
//fix_flaw_line_below:
//                return code;
//fix_flaw_line_below:
//            if (code > 0) {
                 code = array_get(imemory, pImpl, 0, &pPatInst);
                 if (code < 0)
                     return code;
                n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern)
                      ? n_comps - 1
                      : 0 );
            } else
                n_numeric_comps = 0;
        } else
            n_numeric_comps = 0;
        num_offset = 1;
    } else
        n_numeric_comps = n_comps;

    /* gather the numeric operands */
    code = float_params(op - num_offset, n_numeric_comps, cc.paint.values);
    if (code < 0)
        return code;
    /* The values are copied to graphic state and compared with */
    /* other colors by memcmp() in gx_hld_saved_color_equal()   */
    /* This is the easiest way to avoid indeterminism */
    memset(cc.paint.values + n_numeric_comps, 0,
            sizeof(cc.paint.values) - sizeof(*cc.paint.values)*n_numeric_comps);

    code = get_space_object(i_ctx_p, &istate->colorspace[0].array, &space);
    if (code < 0)
        return code;
    if (space->validatecomponents) {
        code = space->validatecomponents(i_ctx_p,
                                         &istate->colorspace[0].array,
                                         cc.paint.values, n_numeric_comps);
        if (code < 0)
            return code;
    }

    /* pass the color to the graphic library */
    if ((code = gs_setcolor(igs, &cc)) >= 0) {

        if (n_comps > n_numeric_comps) {
            istate->pattern[0] = *op;      /* save pattern dict or null */
        }
    }

    /* Check the color spaces, to see if we need to run any tint transform
     * procedures. Some Adobe applications *eg Photoshop) expect that the
     * tint transform will be run and use this to set up duotone DeviceN
     * spaces.
     */
    code = validate_spaces(i_ctx_p, &istate->colorspace[0].array, &depth);
    if (code < 0)
        return code;
    /* Set up for the continuation procedure which will do the work */
    /* Make sure the exec stack has enough space */
    check_estack(5);
    /* A place holder for data potentially used by transform functions */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'depth' of the space returned during checking above */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'stage' of processing (initially 0) */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store a pointer to the color space stored on the operand stack
     * as the stack may grow unpredictably making further access
     * to the space difficult
     */
    ep = esp += 1;
    *ep = istate->colorspace[0].array;
    /* Finally, the actual continuation routine */
    push_op_estack(setcolor_cont);
    return o_push_estack;
}
",177869,"zsetcolor(i_ctx_t * i_ctx_p)
{
    os_ptr                  op = osp;
    es_ptr ep;
    const gs_color_space *  pcs = gs_currentcolorspace(igs);
    gs_client_color         cc;
    int                     n_comps, n_numeric_comps, num_offset = 0, code, depth;
    PS_colour_space_t *space;

    /* initialize the client color pattern pointer for GC */
    cc.pattern = 0;

    /* check for a pattern color space */
    if ((n_comps = cs_num_components(pcs)) < 0) {
        n_comps = -n_comps;
         if (r_has_type(op, t_dictionary)) {
             ref     *pImpl, pPatInst;
 
            code = dict_find_string(op, ""Implementation"", &pImpl);
            if (code != 0) {
                 code = array_get(imemory, pImpl, 0, &pPatInst);
                 if (code < 0)
                     return code;
                n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern)
                      ? n_comps - 1
                      : 0 );
            } else
                n_numeric_comps = 0;
        } else
            n_numeric_comps = 0;
        num_offset = 1;
    } else
        n_numeric_comps = n_comps;

    /* gather the numeric operands */
    code = float_params(op - num_offset, n_numeric_comps, cc.paint.values);
    if (code < 0)
        return code;
    /* The values are copied to graphic state and compared with */
    /* other colors by memcmp() in gx_hld_saved_color_equal()   */
    /* This is the easiest way to avoid indeterminism */
    memset(cc.paint.values + n_numeric_comps, 0,
            sizeof(cc.paint.values) - sizeof(*cc.paint.values)*n_numeric_comps);

    code = get_space_object(i_ctx_p, &istate->colorspace[0].array, &space);
    if (code < 0)
        return code;
    if (space->validatecomponents) {
        code = space->validatecomponents(i_ctx_p,
                                         &istate->colorspace[0].array,
                                         cc.paint.values, n_numeric_comps);
        if (code < 0)
            return code;
    }

    /* pass the color to the graphic library */
    if ((code = gs_setcolor(igs, &cc)) >= 0) {

        if (n_comps > n_numeric_comps) {
            istate->pattern[0] = *op;      /* save pattern dict or null */
        }
    }

    /* Check the color spaces, to see if we need to run any tint transform
     * procedures. Some Adobe applications *eg Photoshop) expect that the
     * tint transform will be run and use this to set up duotone DeviceN
     * spaces.
     */
    code = validate_spaces(i_ctx_p, &istate->colorspace[0].array, &depth);
    if (code < 0)
        return code;
    /* Set up for the continuation procedure which will do the work */
    /* Make sure the exec stack has enough space */
    check_estack(5);
    /* A place holder for data potentially used by transform functions */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'depth' of the space returned during checking above */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'stage' of processing (initially 0) */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store a pointer to the color space stored on the operand stack
     * as the stack may grow unpredictably making further access
     * to the space difficult
     */
    ep = esp += 1;
    *ep = istate->colorspace[0].array;
    /* Finally, the actual continuation routine */
    push_op_estack(setcolor_cont);
    return o_push_estack;
}
","zsetcolor(i_ctx_t * i_ctx_p)
{
    os_ptr                  op = osp;
    es_ptr ep;
    const gs_color_space *  pcs = gs_currentcolorspace(igs);
    gs_client_color         cc;
    int                     n_comps, n_numeric_comps, num_offset = 0, code, depth;
    PS_colour_space_t *space;

    /* initialize the client color pattern pointer for GC */
    cc.pattern = 0;

    /* check for a pattern color space */
    if ((n_comps = cs_num_components(pcs)) < 0) {
        n_comps = -n_comps;
         if (r_has_type(op, t_dictionary)) {
             ref     *pImpl, pPatInst;
 
            if ((code = dict_find_string(op, ""Implementation"", &pImpl)) < 0)
                return code;
            if (code > 0) {
                 code = array_get(imemory, pImpl, 0, &pPatInst);
                 if (code < 0)
                     return code;
                n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern)
                      ? n_comps - 1
                      : 0 );
            } else
                n_numeric_comps = 0;
        } else
            n_numeric_comps = 0;
        num_offset = 1;
    } else
        n_numeric_comps = n_comps;

    /* gather the numeric operands */
    code = float_params(op - num_offset, n_numeric_comps, cc.paint.values);
    if (code < 0)
        return code;
    /* The values are copied to graphic state and compared with */
    /* other colors by memcmp() in gx_hld_saved_color_equal()   */
    /* This is the easiest way to avoid indeterminism */
    memset(cc.paint.values + n_numeric_comps, 0,
            sizeof(cc.paint.values) - sizeof(*cc.paint.values)*n_numeric_comps);

    code = get_space_object(i_ctx_p, &istate->colorspace[0].array, &space);
    if (code < 0)
        return code;
    if (space->validatecomponents) {
        code = space->validatecomponents(i_ctx_p,
                                         &istate->colorspace[0].array,
                                         cc.paint.values, n_numeric_comps);
        if (code < 0)
            return code;
    }

    /* pass the color to the graphic library */
    if ((code = gs_setcolor(igs, &cc)) >= 0) {

        if (n_comps > n_numeric_comps) {
            istate->pattern[0] = *op;      /* save pattern dict or null */
        }
    }

    /* Check the color spaces, to see if we need to run any tint transform
     * procedures. Some Adobe applications *eg Photoshop) expect that the
     * tint transform will be run and use this to set up duotone DeviceN
     * spaces.
     */
    code = validate_spaces(i_ctx_p, &istate->colorspace[0].array, &depth);
    if (code < 0)
        return code;
    /* Set up for the continuation procedure which will do the work */
    /* Make sure the exec stack has enough space */
    check_estack(5);
    /* A place holder for data potentially used by transform functions */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'depth' of the space returned during checking above */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store the 'stage' of processing (initially 0) */
    ep = esp += 1;
    make_int(ep, 0);
    /* Store a pointer to the color space stored on the operand stack
     * as the stack may grow unpredictably making further access
     * to the space difficult
     */
    ep = esp += 1;
    *ep = istate->colorspace[0].array;
    /* Finally, the actual continuation routine */
    push_op_estack(setcolor_cont);
    return o_push_estack;
}
","The `zsetcolor` function is designed to set the color in a graphics context based on the current color space and the provided operands. It begins by determining the number of components in the color space and checks if a pattern is involved. The function gathers numeric color values from the operand stack, validates them against the color space, and prepares them for use in the graphics library. It also handles potential tint transformations for specific applications. Finally, it sets up a continuation procedure for further processing, ensuring the execution stack has sufficient space for additional operations related to color setting.","The code defines a function that sets a color in a graphics context based on the current color space and input parameters. It first checks the number of components in the color space and determines if a pattern is involved. The function collects numeric color values, validates them against the color space, and prepares them for use in rendering. It also accounts for potential tint transformations required by certain applications. Finally, the function sets up a continuation process for further operations, ensuring that the execution stack has enough space for additional tasks related to color management.","The vulnerability identified by CWE-704, which pertains to incorrect handling of exceptional conditions, was present in the original code due to insufficient checks after retrieving the ""Implementation"" string from the dictionary. In the fixed code, the condition now checks if the result of `dict_find_string` is negative before proceeding, ensuring that any failure in finding the implementation is handled appropriately. This prevents the function from continuing with potentially invalid or uninitialized data, thereby mitigating risks associated with undefined behavior or crashes that could arise from improper state management in the graphics context.","The vulnerability identified by CWE-704 arises from inadequate handling of exceptional conditions, specifically when retrieving a critical value from a data structure. In the original code, there was no check to ensure that the retrieval operation succeeded before proceeding, which could lead to the use of invalid or uninitialized data. The fixed code addresses this issue by introducing a validation step that checks the result of the retrieval operation. This ensures that the function only continues if the operation is successful, thereby preventing potential crashes or undefined behavior that could compromise the stability and security of the application.","The vulnerability was fixed by adding a validation check after the call to `dict_find_string`, which retrieves the ""Implementation"" string from the dictionary. In the original code, there was no verification of the return value from this function, potentially leading to the use of invalid data. The updated code now checks if the result of `dict_find_string` is negative, indicating a failure. If the check fails, the function returns an error code immediately, preventing further execution with uninitialized or invalid data, thus enhancing the robustness and reliability of the color setting process.","The vulnerability was fixed by implementing a validation step that checks the result of a critical retrieval operation before proceeding with further processing. In the revised code, the function now verifies whether the retrieval was successful by checking for a negative return value. If the check indicates a failure, the function immediately returns an error code, preventing any subsequent operations from using potentially invalid or uninitialized data. This change ensures that the function only continues under valid conditions, thereby enhancing the overall stability and security of the application by avoiding undefined behavior.","CWE-754, CWE-252, CWE-476, CWE-690, CWE-248, CWE-457, CWE-391, CWE-456, CWE-703, CWE-253",N,-1
1,1,178435,178435,,Remote,Not required,Partial,CVE-2016-8602,https://www.cvedetails.com/cve/CVE-2016-8602/,CWE-704,Medium,Partial,Partial,,2017-04-14,6.8,The .sethalftone5 function in psi/zht2.c in Ghostscript before 9.21 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted Postscript document that calls .sethalftone5 with an empty operand stack.,2018-01-04,DoS Exec Code,10,http://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=f5c7555c303,f5c7555c30393e64ec1f5ab0dfae5b55b3b3fc78,,2,,,"zsethalftone5(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    uint count;
    gs_halftone_component *phtc = 0;
    gs_halftone_component *pc;
    int code = 0;
    int j;
    bool have_default;
    gs_halftone *pht = 0;
    gx_device_halftone *pdht = 0;
    ref sprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
    ref tprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
     gs_memory_t *mem;
     uint edepth = ref_stack_count(&e_stack);
     int npop = 2;
    int dict_enum;
     ref rvalue[2];
     int cname, colorant_number;
     byte * pname;
     uint name_size;
     int halftonetype, type = 0;
     gs_gstate *pgs = igs;
    int space_index;

    if (ref_stack_count(&o_stack) < 2)
        return_error(gs_error_stackunderflow);
    check_type(*op, t_dictionary);
    check_type(*(op - 1), t_dictionary);

    dict_enum = dict_first(op);
    space_index = r_space_index(op - 1);
 
     mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];
     * the device color space, so we need to mark them
     * with a different internal halftone type.
     */
    code = dict_int_param(op - 1, ""HalftoneType"", 1, 100, 0, &type);
    if (code < 0)
          return code;
    halftonetype = (type == 2 || type == 4)
                        ? ht_type_multiple_colorscreen
                        : ht_type_multiple;

    /* Count how many components that we will actually use. */

    have_default = false;
    for (count = 0; ;) {

        /* Move to next element in the dictionary */
        if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
            break;
        /*
         * Verify that we have a valid component.  We may have a
         * /HalfToneType entry.
         */
        if (!r_has_type(&rvalue[0], t_name))
            continue;
        if (!r_has_type(&rvalue[1], t_dictionary))
            continue;

        /* Get the name of the component  verify that we will use it. */
        cname = name_index(mem, &rvalue[0]);
        code = gs_get_colorname_string(mem, cname, &pname, &name_size);
        if (code < 0)
            break;
        colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
        if (colorant_number < 0)
            continue;
        else if (colorant_number == GX_DEVICE_COLOR_MAX_COMPONENTS) {
            /* If here then we have the ""Default"" component */
            if (have_default)
                return_error(gs_error_rangecheck);
            have_default = true;
        }

        count++;
        /*
         * Check to see if we have already reached the legal number of
         * components.
         */
        if (count > GS_CLIENT_COLOR_MAX_COMPONENTS + 1) {
            code = gs_note_error(gs_error_rangecheck);
            break;
        }
    }
    if (count == 0 || (halftonetype == ht_type_multiple && ! have_default))
        code = gs_note_error(gs_error_rangecheck);

    if (code >= 0) {
        check_estack(5);		/* for sampling Type 1 screens */
        refset_null(sprocs, count);
        refset_null(tprocs, count);
        rc_alloc_struct_0(pht, gs_halftone, &st_halftone,
                          imemory, pht = 0, "".sethalftone5"");
        phtc = gs_alloc_struct_array(mem, count, gs_halftone_component,
                                     &st_ht_component_element,
                                     "".sethalftone5"");
        rc_alloc_struct_0(pdht, gx_device_halftone, &st_device_halftone,
                          imemory, pdht = 0, "".sethalftone5"");
        if (pht == 0 || phtc == 0 || pdht == 0) {
            j = 0; /* Quiet the compiler:
                      gs_note_error isn't necessarily identity,
                      so j could be left ununitialized. */
            code = gs_note_error(gs_error_VMerror);
        }
    }
    if (code >= 0) {
        dict_enum = dict_first(op);
        for (j = 0, pc = phtc; ;) {
            int type;

            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;
            /*
             * Verify that we have a valid component.  We may have a
             * /HalfToneType entry.
             */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;		/* Do not use this component */
            pc->cname = cname;
            pc->comp_number = colorant_number;

            /* Now process the component dictionary */
            check_dict_read(rvalue[1]);
            if (dict_int_param(&rvalue[1], ""HalftoneType"", 1, 7, 0, &type) < 0) {
                code = gs_note_error(gs_error_typecheck);
                break;
            }
            switch (type) {
                default:
                    code = gs_note_error(gs_error_rangecheck);
                    break;
                case 1:
                    code = dict_spot_params(&rvalue[1], &pc->params.spot,
                                                sprocs + j, tprocs + j, mem);
                    pc->params.spot.screen.spot_function = spot1_dummy;
                    pc->type = ht_type_spot;
                    break;
                case 3:
                    code = dict_threshold_params(&rvalue[1], &pc->params.threshold,
                                                        tprocs + j);
                    pc->type = ht_type_threshold;
                    break;
                case 7:
                    code = dict_threshold2_params(&rvalue[1], &pc->params.threshold2,
                                                        tprocs + j, imemory);
                    pc->type = ht_type_threshold2;
                    break;
            }
            if (code < 0)
                break;
            pc++;
            j++;
        }
    }
    if (code >= 0) {
        pht->type = halftonetype;
        pht->params.multiple.components = phtc;
        pht->params.multiple.num_comp = j;
        pht->params.multiple.get_colorname_string = gs_get_colorname_string;
        code = gs_sethalftone_prepare(igs, pht, pdht);
    }
    if (code >= 0) {
        /*
         * Put the actual frequency and angle in the spot function component dictionaries.
         */
        dict_enum = dict_first(op);
        for (pc = phtc; ; ) {
            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;

            /* Verify that we have a valid component */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component and verify that we will use it. */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;

            if (pc->type == ht_type_spot) {
                code = dict_spot_results(i_ctx_p, &rvalue[1], &pc->params.spot);
                if (code < 0)
                    break;
            }
            pc++;
        }
    }
    if (code >= 0) {
        /*
         * Schedule the sampling of any Type 1 screens,
         * and any (Type 1 or Type 3) TransferFunctions.
         * Save the stack depths in case we have to back out.
         */
        uint odepth = ref_stack_count(&o_stack);
        ref odict, odict5;

        odict = op[-1];
        odict5 = *op;
        pop(2);
        op = osp;
        esp += 5;
        make_mark_estack(esp - 4, es_other, sethalftone_cleanup);
        esp[-3] = odict;
        make_istruct(esp - 2, 0, pht);
        make_istruct(esp - 1, 0, pdht);
        make_op_estack(esp, sethalftone_finish);
        for (j = 0; j < count; j++) {
            gx_ht_order *porder = NULL;

            if (pdht->components == 0)
                porder = &pdht->order;
            else {
                /* Find the component in pdht that matches component j in
                   the pht; gs_sethalftone_prepare() may permute these. */
                int k;
                int comp_number = phtc[j].comp_number;
                for (k = 0; k < count; k++) {
                    if (pdht->components[k].comp_number == comp_number) {
                        porder = &pdht->components[k].corder;
                        break;
                    }
                }
            }
            switch (phtc[j].type) {
            case ht_type_spot:
                code = zscreen_enum_init(i_ctx_p, porder,
                                         &phtc[j].params.spot.screen,
                                         &sprocs[j], 0, 0, space_index);
                if (code < 0)
                    break;
                /* falls through */
            case ht_type_threshold:
                if (!r_has_type(tprocs + j, t__invalid)) {
                    /* Schedule TransferFunction sampling. */
                    /****** check_xstack IS WRONG ******/
                    check_ostack(zcolor_remap_one_ostack);
                    check_estack(zcolor_remap_one_estack);
                    code = zcolor_remap_one(i_ctx_p, tprocs + j,
                                            porder->transfer, igs,
                                            zcolor_remap_one_finish);
                    op = osp;
                }
                break;
            default:	/* not possible here, but to keep */
                                /* the compilers happy.... */
                ;
            }
            if (code < 0) {	/* Restore the stack. */
                ref_stack_pop_to(&o_stack, odepth);
                ref_stack_pop_to(&e_stack, edepth);
                op = osp;
                op[-1] = odict;
                *op = odict5;
                break;
            }
            npop = 0;
        }
    }
    if (code < 0) {
        gs_free_object(mem, pdht, "".sethalftone5"");
        gs_free_object(mem, phtc, "".sethalftone5"");
        gs_free_object(mem, pht, "".sethalftone5"");
        return code;
    }
    pop(npop);
    return (ref_stack_count(&e_stack) > edepth ? o_push_estack : 0);
}
","zsethalftone5(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    uint count;
    gs_halftone_component *phtc = 0;
    gs_halftone_component *pc;
    int code = 0;
    int j;
    bool have_default;
    gs_halftone *pht = 0;
    gx_device_halftone *pdht = 0;
    ref sprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
    ref tprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
     gs_memory_t *mem;
     uint edepth = ref_stack_count(&e_stack);
     int npop = 2;
    int dict_enum = dict_first(op);
     ref rvalue[2];
     int cname, colorant_number;
     byte * pname;
     uint name_size;
     int halftonetype, type = 0;
     gs_gstate *pgs = igs;
    int space_index = r_space_index(op - 1);
 
     mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];
     * the device color space, so we need to mark them
     * with a different internal halftone type.
     */
    code = dict_int_param(op - 1, ""HalftoneType"", 1, 100, 0, &type);
    if (code < 0)
          return code;
    halftonetype = (type == 2 || type == 4)
                        ? ht_type_multiple_colorscreen
                        : ht_type_multiple;

    /* Count how many components that we will actually use. */

    have_default = false;
    for (count = 0; ;) {

        /* Move to next element in the dictionary */
        if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
            break;
        /*
         * Verify that we have a valid component.  We may have a
         * /HalfToneType entry.
         */
        if (!r_has_type(&rvalue[0], t_name))
            continue;
        if (!r_has_type(&rvalue[1], t_dictionary))
            continue;

        /* Get the name of the component  verify that we will use it. */
        cname = name_index(mem, &rvalue[0]);
        code = gs_get_colorname_string(mem, cname, &pname, &name_size);
        if (code < 0)
            break;
        colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
        if (colorant_number < 0)
            continue;
        else if (colorant_number == GX_DEVICE_COLOR_MAX_COMPONENTS) {
            /* If here then we have the ""Default"" component */
            if (have_default)
                return_error(gs_error_rangecheck);
            have_default = true;
        }

        count++;
        /*
         * Check to see if we have already reached the legal number of
         * components.
         */
        if (count > GS_CLIENT_COLOR_MAX_COMPONENTS + 1) {
            code = gs_note_error(gs_error_rangecheck);
            break;
        }
    }
    if (count == 0 || (halftonetype == ht_type_multiple && ! have_default))
        code = gs_note_error(gs_error_rangecheck);

    if (code >= 0) {
        check_estack(5);		/* for sampling Type 1 screens */
        refset_null(sprocs, count);
        refset_null(tprocs, count);
        rc_alloc_struct_0(pht, gs_halftone, &st_halftone,
                          imemory, pht = 0, "".sethalftone5"");
        phtc = gs_alloc_struct_array(mem, count, gs_halftone_component,
                                     &st_ht_component_element,
                                     "".sethalftone5"");
        rc_alloc_struct_0(pdht, gx_device_halftone, &st_device_halftone,
                          imemory, pdht = 0, "".sethalftone5"");
        if (pht == 0 || phtc == 0 || pdht == 0) {
            j = 0; /* Quiet the compiler:
                      gs_note_error isn't necessarily identity,
                      so j could be left ununitialized. */
            code = gs_note_error(gs_error_VMerror);
        }
    }
    if (code >= 0) {
        dict_enum = dict_first(op);
        for (j = 0, pc = phtc; ;) {
            int type;

            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;
            /*
             * Verify that we have a valid component.  We may have a
             * /HalfToneType entry.
             */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;		/* Do not use this component */
            pc->cname = cname;
            pc->comp_number = colorant_number;

            /* Now process the component dictionary */
            check_dict_read(rvalue[1]);
            if (dict_int_param(&rvalue[1], ""HalftoneType"", 1, 7, 0, &type) < 0) {
                code = gs_note_error(gs_error_typecheck);
                break;
            }
            switch (type) {
                default:
                    code = gs_note_error(gs_error_rangecheck);
                    break;
                case 1:
                    code = dict_spot_params(&rvalue[1], &pc->params.spot,
                                                sprocs + j, tprocs + j, mem);
                    pc->params.spot.screen.spot_function = spot1_dummy;
                    pc->type = ht_type_spot;
                    break;
                case 3:
                    code = dict_threshold_params(&rvalue[1], &pc->params.threshold,
                                                        tprocs + j);
                    pc->type = ht_type_threshold;
                    break;
                case 7:
                    code = dict_threshold2_params(&rvalue[1], &pc->params.threshold2,
                                                        tprocs + j, imemory);
                    pc->type = ht_type_threshold2;
                    break;
            }
            if (code < 0)
                break;
            pc++;
            j++;
        }
    }
    if (code >= 0) {
        pht->type = halftonetype;
        pht->params.multiple.components = phtc;
        pht->params.multiple.num_comp = j;
        pht->params.multiple.get_colorname_string = gs_get_colorname_string;
        code = gs_sethalftone_prepare(igs, pht, pdht);
    }
    if (code >= 0) {
        /*
         * Put the actual frequency and angle in the spot function component dictionaries.
         */
        dict_enum = dict_first(op);
        for (pc = phtc; ; ) {
            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;

            /* Verify that we have a valid component */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component and verify that we will use it. */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;

            if (pc->type == ht_type_spot) {
                code = dict_spot_results(i_ctx_p, &rvalue[1], &pc->params.spot);
                if (code < 0)
                    break;
            }
            pc++;
        }
    }
    if (code >= 0) {
        /*
         * Schedule the sampling of any Type 1 screens,
         * and any (Type 1 or Type 3) TransferFunctions.
         * Save the stack depths in case we have to back out.
         */
        uint odepth = ref_stack_count(&o_stack);
        ref odict, odict5;

        odict = op[-1];
        odict5 = *op;
        pop(2);
        op = osp;
        esp += 5;
        make_mark_estack(esp - 4, es_other, sethalftone_cleanup);
        esp[-3] = odict;
        make_istruct(esp - 2, 0, pht);
        make_istruct(esp - 1, 0, pdht);
        make_op_estack(esp, sethalftone_finish);
        for (j = 0; j < count; j++) {
            gx_ht_order *porder = NULL;

            if (pdht->components == 0)
                porder = &pdht->order;
            else {
                /* Find the component in pdht that matches component j in
                   the pht; gs_sethalftone_prepare() may permute these. */
                int k;
                int comp_number = phtc[j].comp_number;
                for (k = 0; k < count; k++) {
                    if (pdht->components[k].comp_number == comp_number) {
                        porder = &pdht->components[k].corder;
                        break;
                    }
                }
            }
            switch (phtc[j].type) {
            case ht_type_spot:
                code = zscreen_enum_init(i_ctx_p, porder,
                                         &phtc[j].params.spot.screen,
                                         &sprocs[j], 0, 0, space_index);
                if (code < 0)
                    break;
                /* falls through */
            case ht_type_threshold:
                if (!r_has_type(tprocs + j, t__invalid)) {
                    /* Schedule TransferFunction sampling. */
                    /****** check_xstack IS WRONG ******/
                    check_ostack(zcolor_remap_one_ostack);
                    check_estack(zcolor_remap_one_estack);
                    code = zcolor_remap_one(i_ctx_p, tprocs + j,
                                            porder->transfer, igs,
                                            zcolor_remap_one_finish);
                    op = osp;
                }
                break;
            default:	/* not possible here, but to keep */
                                /* the compilers happy.... */
                ;
            }
            if (code < 0) {	/* Restore the stack. */
                ref_stack_pop_to(&o_stack, odepth);
                ref_stack_pop_to(&e_stack, edepth);
                op = osp;
                op[-1] = odict;
                *op = odict5;
                break;
            }
            npop = 0;
        }
    }
    if (code < 0) {
        gs_free_object(mem, pdht, "".sethalftone5"");
        gs_free_object(mem, phtc, "".sethalftone5"");
        gs_free_object(mem, pht, "".sethalftone5"");
        return code;
    }
    pop(npop);
    return (ref_stack_count(&e_stack) > edepth ? o_push_estack : 0);
}
",C,"    int dict_enum;
    int space_index;

    if (ref_stack_count(&o_stack) < 2)
        return_error(gs_error_stackunderflow);
    check_type(*op, t_dictionary);
    check_type(*(op - 1), t_dictionary);

    dict_enum = dict_first(op);
    space_index = r_space_index(op - 1);
","    int dict_enum = dict_first(op);
    int space_index = r_space_index(op - 1);
",a5360401495654e89301b2516703c1d2877fc5ba,"@@ -82,14 +82,22 @@ zsethalftone5(i_ctx_t *i_ctx_p)
     gs_memory_t *mem;
     uint edepth = ref_stack_count(&e_stack);
     int npop = 2;
-    int dict_enum = dict_first(op);
+    int dict_enum;
     ref rvalue[2];
     int cname, colorant_number;
     byte * pname;
     uint name_size;
     int halftonetype, type = 0;
     gs_gstate *pgs = igs;
-    int space_index = r_space_index(op - 1);
+    int space_index;
+
+    if (ref_stack_count(&o_stack) < 2)
+        return_error(gs_error_stackunderflow);
+    check_type(*op, t_dictionary);
+    check_type(*(op - 1), t_dictionary);
+
+    dict_enum = dict_first(op);
+    space_index = r_space_index(op - 1);
 
     mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];",ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/zht2.c;h=dfa27a40ff46f497c929e12053753023212fcb26;hb=f5c7555c303,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/zht2.c;h=fb4a2649d4de8879f7033256c66634b691fee691,1,"zsethalftone5(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    uint count;
    gs_halftone_component *phtc = 0;
    gs_halftone_component *pc;
    int code = 0;
    int j;
    bool have_default;
    gs_halftone *pht = 0;
    gx_device_halftone *pdht = 0;
    ref sprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
    ref tprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
     gs_memory_t *mem;
     uint edepth = ref_stack_count(&e_stack);
     int npop = 2;
//flaw_line_below:
    int dict_enum = dict_first(op);
//fix_flaw_line_below:
//    int dict_enum;
     ref rvalue[2];
     int cname, colorant_number;
     byte * pname;
     uint name_size;
     int halftonetype, type = 0;
     gs_gstate *pgs = igs;
//flaw_line_below:
    int space_index = r_space_index(op - 1);
//fix_flaw_line_below:
//    int space_index;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (ref_stack_count(&o_stack) < 2)
//fix_flaw_line_below:
//        return_error(gs_error_stackunderflow);
//fix_flaw_line_below:
//    check_type(*op, t_dictionary);
//fix_flaw_line_below:
//    check_type(*(op - 1), t_dictionary);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    dict_enum = dict_first(op);
//fix_flaw_line_below:
//    space_index = r_space_index(op - 1);
 
     mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];
     * the device color space, so we need to mark them
     * with a different internal halftone type.
     */
    code = dict_int_param(op - 1, ""HalftoneType"", 1, 100, 0, &type);
    if (code < 0)
          return code;
    halftonetype = (type == 2 || type == 4)
                        ? ht_type_multiple_colorscreen
                        : ht_type_multiple;

    /* Count how many components that we will actually use. */

    have_default = false;
    for (count = 0; ;) {

        /* Move to next element in the dictionary */
        if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
            break;
        /*
         * Verify that we have a valid component.  We may have a
         * /HalfToneType entry.
         */
        if (!r_has_type(&rvalue[0], t_name))
            continue;
        if (!r_has_type(&rvalue[1], t_dictionary))
            continue;

        /* Get the name of the component  verify that we will use it. */
        cname = name_index(mem, &rvalue[0]);
        code = gs_get_colorname_string(mem, cname, &pname, &name_size);
        if (code < 0)
            break;
        colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
        if (colorant_number < 0)
            continue;
        else if (colorant_number == GX_DEVICE_COLOR_MAX_COMPONENTS) {
            /* If here then we have the ""Default"" component */
            if (have_default)
                return_error(gs_error_rangecheck);
            have_default = true;
        }

        count++;
        /*
         * Check to see if we have already reached the legal number of
         * components.
         */
        if (count > GS_CLIENT_COLOR_MAX_COMPONENTS + 1) {
            code = gs_note_error(gs_error_rangecheck);
            break;
        }
    }
    if (count == 0 || (halftonetype == ht_type_multiple && ! have_default))
        code = gs_note_error(gs_error_rangecheck);

    if (code >= 0) {
        check_estack(5);		/* for sampling Type 1 screens */
        refset_null(sprocs, count);
        refset_null(tprocs, count);
        rc_alloc_struct_0(pht, gs_halftone, &st_halftone,
                          imemory, pht = 0, "".sethalftone5"");
        phtc = gs_alloc_struct_array(mem, count, gs_halftone_component,
                                     &st_ht_component_element,
                                     "".sethalftone5"");
        rc_alloc_struct_0(pdht, gx_device_halftone, &st_device_halftone,
                          imemory, pdht = 0, "".sethalftone5"");
        if (pht == 0 || phtc == 0 || pdht == 0) {
            j = 0; /* Quiet the compiler:
                      gs_note_error isn't necessarily identity,
                      so j could be left ununitialized. */
            code = gs_note_error(gs_error_VMerror);
        }
    }
    if (code >= 0) {
        dict_enum = dict_first(op);
        for (j = 0, pc = phtc; ;) {
            int type;

            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;
            /*
             * Verify that we have a valid component.  We may have a
             * /HalfToneType entry.
             */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;		/* Do not use this component */
            pc->cname = cname;
            pc->comp_number = colorant_number;

            /* Now process the component dictionary */
            check_dict_read(rvalue[1]);
            if (dict_int_param(&rvalue[1], ""HalftoneType"", 1, 7, 0, &type) < 0) {
                code = gs_note_error(gs_error_typecheck);
                break;
            }
            switch (type) {
                default:
                    code = gs_note_error(gs_error_rangecheck);
                    break;
                case 1:
                    code = dict_spot_params(&rvalue[1], &pc->params.spot,
                                                sprocs + j, tprocs + j, mem);
                    pc->params.spot.screen.spot_function = spot1_dummy;
                    pc->type = ht_type_spot;
                    break;
                case 3:
                    code = dict_threshold_params(&rvalue[1], &pc->params.threshold,
                                                        tprocs + j);
                    pc->type = ht_type_threshold;
                    break;
                case 7:
                    code = dict_threshold2_params(&rvalue[1], &pc->params.threshold2,
                                                        tprocs + j, imemory);
                    pc->type = ht_type_threshold2;
                    break;
            }
            if (code < 0)
                break;
            pc++;
            j++;
        }
    }
    if (code >= 0) {
        pht->type = halftonetype;
        pht->params.multiple.components = phtc;
        pht->params.multiple.num_comp = j;
        pht->params.multiple.get_colorname_string = gs_get_colorname_string;
        code = gs_sethalftone_prepare(igs, pht, pdht);
    }
    if (code >= 0) {
        /*
         * Put the actual frequency and angle in the spot function component dictionaries.
         */
        dict_enum = dict_first(op);
        for (pc = phtc; ; ) {
            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;

            /* Verify that we have a valid component */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component and verify that we will use it. */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;

            if (pc->type == ht_type_spot) {
                code = dict_spot_results(i_ctx_p, &rvalue[1], &pc->params.spot);
                if (code < 0)
                    break;
            }
            pc++;
        }
    }
    if (code >= 0) {
        /*
         * Schedule the sampling of any Type 1 screens,
         * and any (Type 1 or Type 3) TransferFunctions.
         * Save the stack depths in case we have to back out.
         */
        uint odepth = ref_stack_count(&o_stack);
        ref odict, odict5;

        odict = op[-1];
        odict5 = *op;
        pop(2);
        op = osp;
        esp += 5;
        make_mark_estack(esp - 4, es_other, sethalftone_cleanup);
        esp[-3] = odict;
        make_istruct(esp - 2, 0, pht);
        make_istruct(esp - 1, 0, pdht);
        make_op_estack(esp, sethalftone_finish);
        for (j = 0; j < count; j++) {
            gx_ht_order *porder = NULL;

            if (pdht->components == 0)
                porder = &pdht->order;
            else {
                /* Find the component in pdht that matches component j in
                   the pht; gs_sethalftone_prepare() may permute these. */
                int k;
                int comp_number = phtc[j].comp_number;
                for (k = 0; k < count; k++) {
                    if (pdht->components[k].comp_number == comp_number) {
                        porder = &pdht->components[k].corder;
                        break;
                    }
                }
            }
            switch (phtc[j].type) {
            case ht_type_spot:
                code = zscreen_enum_init(i_ctx_p, porder,
                                         &phtc[j].params.spot.screen,
                                         &sprocs[j], 0, 0, space_index);
                if (code < 0)
                    break;
                /* falls through */
            case ht_type_threshold:
                if (!r_has_type(tprocs + j, t__invalid)) {
                    /* Schedule TransferFunction sampling. */
                    /****** check_xstack IS WRONG ******/
                    check_ostack(zcolor_remap_one_ostack);
                    check_estack(zcolor_remap_one_estack);
                    code = zcolor_remap_one(i_ctx_p, tprocs + j,
                                            porder->transfer, igs,
                                            zcolor_remap_one_finish);
                    op = osp;
                }
                break;
            default:	/* not possible here, but to keep */
                                /* the compilers happy.... */
                ;
            }
            if (code < 0) {	/* Restore the stack. */
                ref_stack_pop_to(&o_stack, odepth);
                ref_stack_pop_to(&e_stack, edepth);
                op = osp;
                op[-1] = odict;
                *op = odict5;
                break;
            }
            npop = 0;
        }
    }
    if (code < 0) {
        gs_free_object(mem, pdht, "".sethalftone5"");
        gs_free_object(mem, phtc, "".sethalftone5"");
        gs_free_object(mem, pht, "".sethalftone5"");
        return code;
    }
    pop(npop);
    return (ref_stack_count(&e_stack) > edepth ? o_push_estack : 0);
}
",178435,"zsethalftone5(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    uint count;
    gs_halftone_component *phtc = 0;
    gs_halftone_component *pc;
    int code = 0;
    int j;
    bool have_default;
    gs_halftone *pht = 0;
    gx_device_halftone *pdht = 0;
    ref sprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
    ref tprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
     gs_memory_t *mem;
     uint edepth = ref_stack_count(&e_stack);
     int npop = 2;
    int dict_enum = dict_first(op);
     ref rvalue[2];
     int cname, colorant_number;
     byte * pname;
     uint name_size;
     int halftonetype, type = 0;
     gs_gstate *pgs = igs;
    int space_index = r_space_index(op - 1);
 
     mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];
     * the device color space, so we need to mark them
     * with a different internal halftone type.
     */
    code = dict_int_param(op - 1, ""HalftoneType"", 1, 100, 0, &type);
    if (code < 0)
          return code;
    halftonetype = (type == 2 || type == 4)
                        ? ht_type_multiple_colorscreen
                        : ht_type_multiple;

    /* Count how many components that we will actually use. */

    have_default = false;
    for (count = 0; ;) {

        /* Move to next element in the dictionary */
        if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
            break;
        /*
         * Verify that we have a valid component.  We may have a
         * /HalfToneType entry.
         */
        if (!r_has_type(&rvalue[0], t_name))
            continue;
        if (!r_has_type(&rvalue[1], t_dictionary))
            continue;

        /* Get the name of the component  verify that we will use it. */
        cname = name_index(mem, &rvalue[0]);
        code = gs_get_colorname_string(mem, cname, &pname, &name_size);
        if (code < 0)
            break;
        colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
        if (colorant_number < 0)
            continue;
        else if (colorant_number == GX_DEVICE_COLOR_MAX_COMPONENTS) {
            /* If here then we have the ""Default"" component */
            if (have_default)
                return_error(gs_error_rangecheck);
            have_default = true;
        }

        count++;
        /*
         * Check to see if we have already reached the legal number of
         * components.
         */
        if (count > GS_CLIENT_COLOR_MAX_COMPONENTS + 1) {
            code = gs_note_error(gs_error_rangecheck);
            break;
        }
    }
    if (count == 0 || (halftonetype == ht_type_multiple && ! have_default))
        code = gs_note_error(gs_error_rangecheck);

    if (code >= 0) {
        check_estack(5);		/* for sampling Type 1 screens */
        refset_null(sprocs, count);
        refset_null(tprocs, count);
        rc_alloc_struct_0(pht, gs_halftone, &st_halftone,
                          imemory, pht = 0, "".sethalftone5"");
        phtc = gs_alloc_struct_array(mem, count, gs_halftone_component,
                                     &st_ht_component_element,
                                     "".sethalftone5"");
        rc_alloc_struct_0(pdht, gx_device_halftone, &st_device_halftone,
                          imemory, pdht = 0, "".sethalftone5"");
        if (pht == 0 || phtc == 0 || pdht == 0) {
            j = 0; /* Quiet the compiler:
                      gs_note_error isn't necessarily identity,
                      so j could be left ununitialized. */
            code = gs_note_error(gs_error_VMerror);
        }
    }
    if (code >= 0) {
        dict_enum = dict_first(op);
        for (j = 0, pc = phtc; ;) {
            int type;

            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;
            /*
             * Verify that we have a valid component.  We may have a
             * /HalfToneType entry.
             */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;		/* Do not use this component */
            pc->cname = cname;
            pc->comp_number = colorant_number;

            /* Now process the component dictionary */
            check_dict_read(rvalue[1]);
            if (dict_int_param(&rvalue[1], ""HalftoneType"", 1, 7, 0, &type) < 0) {
                code = gs_note_error(gs_error_typecheck);
                break;
            }
            switch (type) {
                default:
                    code = gs_note_error(gs_error_rangecheck);
                    break;
                case 1:
                    code = dict_spot_params(&rvalue[1], &pc->params.spot,
                                                sprocs + j, tprocs + j, mem);
                    pc->params.spot.screen.spot_function = spot1_dummy;
                    pc->type = ht_type_spot;
                    break;
                case 3:
                    code = dict_threshold_params(&rvalue[1], &pc->params.threshold,
                                                        tprocs + j);
                    pc->type = ht_type_threshold;
                    break;
                case 7:
                    code = dict_threshold2_params(&rvalue[1], &pc->params.threshold2,
                                                        tprocs + j, imemory);
                    pc->type = ht_type_threshold2;
                    break;
            }
            if (code < 0)
                break;
            pc++;
            j++;
        }
    }
    if (code >= 0) {
        pht->type = halftonetype;
        pht->params.multiple.components = phtc;
        pht->params.multiple.num_comp = j;
        pht->params.multiple.get_colorname_string = gs_get_colorname_string;
        code = gs_sethalftone_prepare(igs, pht, pdht);
    }
    if (code >= 0) {
        /*
         * Put the actual frequency and angle in the spot function component dictionaries.
         */
        dict_enum = dict_first(op);
        for (pc = phtc; ; ) {
            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;

            /* Verify that we have a valid component */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component and verify that we will use it. */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;

            if (pc->type == ht_type_spot) {
                code = dict_spot_results(i_ctx_p, &rvalue[1], &pc->params.spot);
                if (code < 0)
                    break;
            }
            pc++;
        }
    }
    if (code >= 0) {
        /*
         * Schedule the sampling of any Type 1 screens,
         * and any (Type 1 or Type 3) TransferFunctions.
         * Save the stack depths in case we have to back out.
         */
        uint odepth = ref_stack_count(&o_stack);
        ref odict, odict5;

        odict = op[-1];
        odict5 = *op;
        pop(2);
        op = osp;
        esp += 5;
        make_mark_estack(esp - 4, es_other, sethalftone_cleanup);
        esp[-3] = odict;
        make_istruct(esp - 2, 0, pht);
        make_istruct(esp - 1, 0, pdht);
        make_op_estack(esp, sethalftone_finish);
        for (j = 0; j < count; j++) {
            gx_ht_order *porder = NULL;

            if (pdht->components == 0)
                porder = &pdht->order;
            else {
                /* Find the component in pdht that matches component j in
                   the pht; gs_sethalftone_prepare() may permute these. */
                int k;
                int comp_number = phtc[j].comp_number;
                for (k = 0; k < count; k++) {
                    if (pdht->components[k].comp_number == comp_number) {
                        porder = &pdht->components[k].corder;
                        break;
                    }
                }
            }
            switch (phtc[j].type) {
            case ht_type_spot:
                code = zscreen_enum_init(i_ctx_p, porder,
                                         &phtc[j].params.spot.screen,
                                         &sprocs[j], 0, 0, space_index);
                if (code < 0)
                    break;
                /* falls through */
            case ht_type_threshold:
                if (!r_has_type(tprocs + j, t__invalid)) {
                    /* Schedule TransferFunction sampling. */
                    /****** check_xstack IS WRONG ******/
                    check_ostack(zcolor_remap_one_ostack);
                    check_estack(zcolor_remap_one_estack);
                    code = zcolor_remap_one(i_ctx_p, tprocs + j,
                                            porder->transfer, igs,
                                            zcolor_remap_one_finish);
                    op = osp;
                }
                break;
            default:	/* not possible here, but to keep */
                                /* the compilers happy.... */
                ;
            }
            if (code < 0) {	/* Restore the stack. */
                ref_stack_pop_to(&o_stack, odepth);
                ref_stack_pop_to(&e_stack, edepth);
                op = osp;
                op[-1] = odict;
                *op = odict5;
                break;
            }
            npop = 0;
        }
    }
    if (code < 0) {
        gs_free_object(mem, pdht, "".sethalftone5"");
        gs_free_object(mem, phtc, "".sethalftone5"");
        gs_free_object(mem, pht, "".sethalftone5"");
        return code;
    }
    pop(npop);
    return (ref_stack_count(&e_stack) > edepth ? o_push_estack : 0);
}
","zsethalftone5(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    uint count;
    gs_halftone_component *phtc = 0;
    gs_halftone_component *pc;
    int code = 0;
    int j;
    bool have_default;
    gs_halftone *pht = 0;
    gx_device_halftone *pdht = 0;
    ref sprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
    ref tprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];
     gs_memory_t *mem;
     uint edepth = ref_stack_count(&e_stack);
     int npop = 2;
    int dict_enum;
     ref rvalue[2];
     int cname, colorant_number;
     byte * pname;
     uint name_size;
     int halftonetype, type = 0;
     gs_gstate *pgs = igs;
    int space_index;

    if (ref_stack_count(&o_stack) < 2)
        return_error(gs_error_stackunderflow);
    check_type(*op, t_dictionary);
    check_type(*(op - 1), t_dictionary);

    dict_enum = dict_first(op);
    space_index = r_space_index(op - 1);
 
     mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];
     * the device color space, so we need to mark them
     * with a different internal halftone type.
     */
    code = dict_int_param(op - 1, ""HalftoneType"", 1, 100, 0, &type);
    if (code < 0)
          return code;
    halftonetype = (type == 2 || type == 4)
                        ? ht_type_multiple_colorscreen
                        : ht_type_multiple;

    /* Count how many components that we will actually use. */

    have_default = false;
    for (count = 0; ;) {

        /* Move to next element in the dictionary */
        if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
            break;
        /*
         * Verify that we have a valid component.  We may have a
         * /HalfToneType entry.
         */
        if (!r_has_type(&rvalue[0], t_name))
            continue;
        if (!r_has_type(&rvalue[1], t_dictionary))
            continue;

        /* Get the name of the component  verify that we will use it. */
        cname = name_index(mem, &rvalue[0]);
        code = gs_get_colorname_string(mem, cname, &pname, &name_size);
        if (code < 0)
            break;
        colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
        if (colorant_number < 0)
            continue;
        else if (colorant_number == GX_DEVICE_COLOR_MAX_COMPONENTS) {
            /* If here then we have the ""Default"" component */
            if (have_default)
                return_error(gs_error_rangecheck);
            have_default = true;
        }

        count++;
        /*
         * Check to see if we have already reached the legal number of
         * components.
         */
        if (count > GS_CLIENT_COLOR_MAX_COMPONENTS + 1) {
            code = gs_note_error(gs_error_rangecheck);
            break;
        }
    }
    if (count == 0 || (halftonetype == ht_type_multiple && ! have_default))
        code = gs_note_error(gs_error_rangecheck);

    if (code >= 0) {
        check_estack(5);		/* for sampling Type 1 screens */
        refset_null(sprocs, count);
        refset_null(tprocs, count);
        rc_alloc_struct_0(pht, gs_halftone, &st_halftone,
                          imemory, pht = 0, "".sethalftone5"");
        phtc = gs_alloc_struct_array(mem, count, gs_halftone_component,
                                     &st_ht_component_element,
                                     "".sethalftone5"");
        rc_alloc_struct_0(pdht, gx_device_halftone, &st_device_halftone,
                          imemory, pdht = 0, "".sethalftone5"");
        if (pht == 0 || phtc == 0 || pdht == 0) {
            j = 0; /* Quiet the compiler:
                      gs_note_error isn't necessarily identity,
                      so j could be left ununitialized. */
            code = gs_note_error(gs_error_VMerror);
        }
    }
    if (code >= 0) {
        dict_enum = dict_first(op);
        for (j = 0, pc = phtc; ;) {
            int type;

            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;
            /*
             * Verify that we have a valid component.  We may have a
             * /HalfToneType entry.
             */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;		/* Do not use this component */
            pc->cname = cname;
            pc->comp_number = colorant_number;

            /* Now process the component dictionary */
            check_dict_read(rvalue[1]);
            if (dict_int_param(&rvalue[1], ""HalftoneType"", 1, 7, 0, &type) < 0) {
                code = gs_note_error(gs_error_typecheck);
                break;
            }
            switch (type) {
                default:
                    code = gs_note_error(gs_error_rangecheck);
                    break;
                case 1:
                    code = dict_spot_params(&rvalue[1], &pc->params.spot,
                                                sprocs + j, tprocs + j, mem);
                    pc->params.spot.screen.spot_function = spot1_dummy;
                    pc->type = ht_type_spot;
                    break;
                case 3:
                    code = dict_threshold_params(&rvalue[1], &pc->params.threshold,
                                                        tprocs + j);
                    pc->type = ht_type_threshold;
                    break;
                case 7:
                    code = dict_threshold2_params(&rvalue[1], &pc->params.threshold2,
                                                        tprocs + j, imemory);
                    pc->type = ht_type_threshold2;
                    break;
            }
            if (code < 0)
                break;
            pc++;
            j++;
        }
    }
    if (code >= 0) {
        pht->type = halftonetype;
        pht->params.multiple.components = phtc;
        pht->params.multiple.num_comp = j;
        pht->params.multiple.get_colorname_string = gs_get_colorname_string;
        code = gs_sethalftone_prepare(igs, pht, pdht);
    }
    if (code >= 0) {
        /*
         * Put the actual frequency and angle in the spot function component dictionaries.
         */
        dict_enum = dict_first(op);
        for (pc = phtc; ; ) {
            /* Move to next element in the dictionary */
            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)
                break;

            /* Verify that we have a valid component */
            if (!r_has_type(&rvalue[0], t_name))
                continue;
            if (!r_has_type(&rvalue[1], t_dictionary))
                continue;

            /* Get the name of the component and verify that we will use it. */
            cname = name_index(mem, &rvalue[0]);
            code = gs_get_colorname_string(mem, cname, &pname, &name_size);
            if (code < 0)
                break;
            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,
                                                halftonetype);
            if (colorant_number < 0)
                continue;

            if (pc->type == ht_type_spot) {
                code = dict_spot_results(i_ctx_p, &rvalue[1], &pc->params.spot);
                if (code < 0)
                    break;
            }
            pc++;
        }
    }
    if (code >= 0) {
        /*
         * Schedule the sampling of any Type 1 screens,
         * and any (Type 1 or Type 3) TransferFunctions.
         * Save the stack depths in case we have to back out.
         */
        uint odepth = ref_stack_count(&o_stack);
        ref odict, odict5;

        odict = op[-1];
        odict5 = *op;
        pop(2);
        op = osp;
        esp += 5;
        make_mark_estack(esp - 4, es_other, sethalftone_cleanup);
        esp[-3] = odict;
        make_istruct(esp - 2, 0, pht);
        make_istruct(esp - 1, 0, pdht);
        make_op_estack(esp, sethalftone_finish);
        for (j = 0; j < count; j++) {
            gx_ht_order *porder = NULL;

            if (pdht->components == 0)
                porder = &pdht->order;
            else {
                /* Find the component in pdht that matches component j in
                   the pht; gs_sethalftone_prepare() may permute these. */
                int k;
                int comp_number = phtc[j].comp_number;
                for (k = 0; k < count; k++) {
                    if (pdht->components[k].comp_number == comp_number) {
                        porder = &pdht->components[k].corder;
                        break;
                    }
                }
            }
            switch (phtc[j].type) {
            case ht_type_spot:
                code = zscreen_enum_init(i_ctx_p, porder,
                                         &phtc[j].params.spot.screen,
                                         &sprocs[j], 0, 0, space_index);
                if (code < 0)
                    break;
                /* falls through */
            case ht_type_threshold:
                if (!r_has_type(tprocs + j, t__invalid)) {
                    /* Schedule TransferFunction sampling. */
                    /****** check_xstack IS WRONG ******/
                    check_ostack(zcolor_remap_one_ostack);
                    check_estack(zcolor_remap_one_estack);
                    code = zcolor_remap_one(i_ctx_p, tprocs + j,
                                            porder->transfer, igs,
                                            zcolor_remap_one_finish);
                    op = osp;
                }
                break;
            default:	/* not possible here, but to keep */
                                /* the compilers happy.... */
                ;
            }
            if (code < 0) {	/* Restore the stack. */
                ref_stack_pop_to(&o_stack, odepth);
                ref_stack_pop_to(&e_stack, edepth);
                op = osp;
                op[-1] = odict;
                *op = odict5;
                break;
            }
            npop = 0;
        }
    }
    if (code < 0) {
        gs_free_object(mem, pdht, "".sethalftone5"");
        gs_free_object(mem, phtc, "".sethalftone5"");
        gs_free_object(mem, pht, "".sethalftone5"");
        return code;
    }
    pop(npop);
    return (ref_stack_count(&e_stack) > edepth ? o_push_estack : 0);
}
","The `zsethalftone5` function is designed to configure halftone settings for a graphics device in a graphics processing context. It begins by retrieving parameters from a dictionary, including the halftone type and components, while ensuring valid entries and counting the components used. The function allocates memory for halftone structures and processes each component's parameters, including specific halftone types like spot and threshold. It prepares the halftone for use, schedules necessary sampling operations, and manages stack states for potential rollbacks. Finally, it cleans up allocated resources and returns an error code or success status based on the operations performed.","The code defines a function that configures halftone settings for a graphics device by processing a dictionary of parameters. It validates the halftone type and counts the components to be used, ensuring that they meet specific criteria. Memory is allocated for halftone structures, and each component's parameters are processed according to their type. The function prepares the halftone for application, schedules necessary sampling operations, and manages stack states for potential rollbacks in case of errors. Finally, it cleans up allocated resources and returns an appropriate status based on the success or failure of the operations performed.","The vulnerability identified in the original code, classified under CWE-704, arises from the potential for the function to operate on uninitialized or improperly validated stack references, leading to undefined behavior or crashes. In the fixed code, the addition of a check for stack underflow ensures that there are at least two elements on the stack before proceeding with operations that rely on these references. This validation prevents the function from accessing invalid memory locations, thereby mitigating the risk of dereferencing null or garbage pointers, which could lead to security issues or application instability.","The vulnerability identified in the original code, categorized as CWE-704, stems from the potential for dereferencing uninitialized or invalid stack references, which could lead to undefined behavior or crashes. The fix introduced a validation step to ensure that the stack contains a sufficient number of elements before performing operations that depend on these references. This additional check prevents the function from accessing memory locations that are not properly initialized, thereby reducing the risk of accessing null or garbage pointers, which could compromise the stability and security of the application.","The vulnerability was fixed by adding a check for stack underflow at the beginning of the function, specifically by verifying that the reference stack contains at least two elements before proceeding with further operations. This was implemented with the condition `if (ref_stack_count(&o_stack) < 2)`, which ensures that there are enough elements on the stack to safely access the required references. By enforcing this validation, the code prevents potential dereferencing of uninitialized or invalid pointers, thereby enhancing the stability and security of the function during its execution.","The vulnerability was addressed by implementing a validation check at the start of the function to ensure that the stack contains a sufficient number of elements before any operations are performed. This check prevents the function from proceeding if there are not enough elements, thereby avoiding the risk of dereferencing uninitialized or invalid memory locations. By enforcing this condition, the fix enhances the robustness of the code, ensuring that it only operates on valid references and significantly reducing the likelihood of undefined behavior or application crashes.","CWE-476, CWE-824, CWE-457, CWE-119, CWE-125, CWE-787, CWE-416, CWE-682, CWE-665, CWE-674",N,-1
2,2,182365,182365,,Remote,Not required,Partial,CVE-2018-12453,https://www.cvedetails.com/cve/CVE-2018-12453/,CWE-704,Low,,,,2018-06-16,5.0,Type confusion in the xgroupCommand function in t_stream.c in redis-server in Redis before 5.0 allows remote attackers to cause denial-of-service via an XGROUP command in which the key is not a stream.,2018-08-14,,1,https://github.com/antirez/redis/commit/c04082cf138f1f51cedf05ee9ad36fb6763cafc6,c04082cf138f1f51cedf05ee9ad36fb6763cafc6,Abort in XGROUP if the key is not a stream,1,src/t_stream.c,"{""sha"": ""c48928018c04d68e68b0191e202144978fe327a4"", ""filename"": ""src/t_stream.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/antirez/redis/blob/c04082cf138f1f51cedf05ee9ad36fb6763cafc6/src/t_stream.c"", ""raw_url"": ""https://github.com/antirez/redis/raw/c04082cf138f1f51cedf05ee9ad36fb6763cafc6/src/t_stream.c"", ""contents_url"": ""https://api.github.com/repos/antirez/redis/contents/src/t_stream.c?ref=c04082cf138f1f51cedf05ee9ad36fb6763cafc6"", ""patch"": ""@@ -1576,7 +1576,7 @@ NULL\n     /* Lookup the key now, this is common for all the subcommands but HELP. */\n     if (c->argc >= 4) {\n         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);\n-        if (o == NULL) return;\n+        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;\n         s = o->ptr;\n         grpname = c->argv[3]->ptr;\n ""}","void xgroupCommand(client *c) {
    const char *help[] = {
""CREATE      <key> <groupname> <id or $>  -- Create a new consumer group."",
""SETID       <key> <groupname> <id or $>  -- Set the current group ID."",
""DELGROUP    <key> <groupname>            -- Remove the specified group."",
""DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer."",
""HELP                                     -- Prints this help."",
NULL
    };
    stream *s = NULL;
    sds grpname = NULL;
    streamCG *cg = NULL;
    char *opt = c->argv[1]->ptr; /* Subcommand name. */

     /* Lookup the key now, this is common for all the subcommands but HELP. */
     if (c->argc >= 4) {
         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);
        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
         s = o->ptr;
         grpname = c->argv[3]->ptr;
 
        /* Certain subcommands require the group to exist. */
        if ((cg = streamLookupCG(s,grpname)) == NULL &&
            (!strcasecmp(opt,""SETID"") ||
             !strcasecmp(opt,""DELCONSUMER"")))
        {
            addReplyErrorFormat(c, ""-NOGROUP No such consumer group '%s' ""
                                   ""for key name '%s'"",
                                   (char*)grpname, (char*)c->argv[2]->ptr);
            return;
        }
    }

    /* Dispatch the different subcommands. */
    if (!strcasecmp(opt,""CREATE"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);
        if (cg) {
            addReply(c,shared.ok);
            server.dirty++;
        } else {
            addReplySds(c,
                sdsnew(""-BUSYGROUP Consumer Group name already exists\r\n""));
        }
    } else if (!strcasecmp(opt,""SETID"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        cg->last_id = id;
        addReply(c,shared.ok);
    } else if (!strcasecmp(opt,""DESTROY"") && c->argc == 4) {
        if (cg) {
            raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);
            streamFreeCG(cg);
            addReply(c,shared.cone);
        } else {
            addReply(c,shared.czero);
        }
    } else if (!strcasecmp(opt,""DELCONSUMER"") && c->argc == 5) {
        /* Delete the consumer and returns the number of pending messages
         * that were yet associated with such a consumer. */
        long long pending = streamDelConsumer(cg,c->argv[4]->ptr);
        addReplyLongLong(c,pending);
        server.dirty++;
    } else if (!strcasecmp(opt,""HELP"")) {
        addReplyHelp(c, help);
    } else {
        addReply(c,shared.syntaxerr);
    }
}
","void xgroupCommand(client *c) {
    const char *help[] = {
""CREATE      <key> <groupname> <id or $>  -- Create a new consumer group."",
""SETID       <key> <groupname> <id or $>  -- Set the current group ID."",
""DELGROUP    <key> <groupname>            -- Remove the specified group."",
""DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer."",
""HELP                                     -- Prints this help."",
NULL
    };
    stream *s = NULL;
    sds grpname = NULL;
    streamCG *cg = NULL;
    char *opt = c->argv[1]->ptr; /* Subcommand name. */

     /* Lookup the key now, this is common for all the subcommands but HELP. */
     if (c->argc >= 4) {
         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);
        if (o == NULL) return;
         s = o->ptr;
         grpname = c->argv[3]->ptr;
 
        /* Certain subcommands require the group to exist. */
        if ((cg = streamLookupCG(s,grpname)) == NULL &&
            (!strcasecmp(opt,""SETID"") ||
             !strcasecmp(opt,""DELCONSUMER"")))
        {
            addReplyErrorFormat(c, ""-NOGROUP No such consumer group '%s' ""
                                   ""for key name '%s'"",
                                   (char*)grpname, (char*)c->argv[2]->ptr);
            return;
        }
    }

    /* Dispatch the different subcommands. */
    if (!strcasecmp(opt,""CREATE"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);
        if (cg) {
            addReply(c,shared.ok);
            server.dirty++;
        } else {
            addReplySds(c,
                sdsnew(""-BUSYGROUP Consumer Group name already exists\r\n""));
        }
    } else if (!strcasecmp(opt,""SETID"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        cg->last_id = id;
        addReply(c,shared.ok);
    } else if (!strcasecmp(opt,""DESTROY"") && c->argc == 4) {
        if (cg) {
            raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);
            streamFreeCG(cg);
            addReply(c,shared.cone);
        } else {
            addReply(c,shared.czero);
        }
    } else if (!strcasecmp(opt,""DELCONSUMER"") && c->argc == 5) {
        /* Delete the consumer and returns the number of pending messages
         * that were yet associated with such a consumer. */
        long long pending = streamDelConsumer(cg,c->argv[4]->ptr);
        addReplyLongLong(c,pending);
        server.dirty++;
    } else if (!strcasecmp(opt,""HELP"")) {
        addReplyHelp(c, help);
    } else {
        addReply(c,shared.syntaxerr);
    }
}
",C,"        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
","        if (o == NULL) return;
",,"@@ -1576,7 +1576,7 @@ NULL
     /* Lookup the key now, this is common for all the subcommands but HELP. */
     if (c->argc >= 4) {
         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);
-        if (o == NULL) return;
+        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
         s = o->ptr;
         grpname = c->argv[3]->ptr;
 ",redis,c04082cf138f1f51cedf05ee9ad36fb6763cafc6,be899b824edd312d4e3a1998c56626d66fae3b61,1,"void xgroupCommand(client *c) {
    const char *help[] = {
""CREATE      <key> <groupname> <id or $>  -- Create a new consumer group."",
""SETID       <key> <groupname> <id or $>  -- Set the current group ID."",
""DELGROUP    <key> <groupname>            -- Remove the specified group."",
""DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer."",
""HELP                                     -- Prints this help."",
NULL
    };
    stream *s = NULL;
    sds grpname = NULL;
    streamCG *cg = NULL;
    char *opt = c->argv[1]->ptr; /* Subcommand name. */

     /* Lookup the key now, this is common for all the subcommands but HELP. */
     if (c->argc >= 4) {
         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);
//flaw_line_below:
        if (o == NULL) return;
//fix_flaw_line_below:
//        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
         s = o->ptr;
         grpname = c->argv[3]->ptr;
 
        /* Certain subcommands require the group to exist. */
        if ((cg = streamLookupCG(s,grpname)) == NULL &&
            (!strcasecmp(opt,""SETID"") ||
             !strcasecmp(opt,""DELCONSUMER"")))
        {
            addReplyErrorFormat(c, ""-NOGROUP No such consumer group '%s' ""
                                   ""for key name '%s'"",
                                   (char*)grpname, (char*)c->argv[2]->ptr);
            return;
        }
    }

    /* Dispatch the different subcommands. */
    if (!strcasecmp(opt,""CREATE"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);
        if (cg) {
            addReply(c,shared.ok);
            server.dirty++;
        } else {
            addReplySds(c,
                sdsnew(""-BUSYGROUP Consumer Group name already exists\r\n""));
        }
    } else if (!strcasecmp(opt,""SETID"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        cg->last_id = id;
        addReply(c,shared.ok);
    } else if (!strcasecmp(opt,""DESTROY"") && c->argc == 4) {
        if (cg) {
            raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);
            streamFreeCG(cg);
            addReply(c,shared.cone);
        } else {
            addReply(c,shared.czero);
        }
    } else if (!strcasecmp(opt,""DELCONSUMER"") && c->argc == 5) {
        /* Delete the consumer and returns the number of pending messages
         * that were yet associated with such a consumer. */
        long long pending = streamDelConsumer(cg,c->argv[4]->ptr);
        addReplyLongLong(c,pending);
        server.dirty++;
    } else if (!strcasecmp(opt,""HELP"")) {
        addReplyHelp(c, help);
    } else {
        addReply(c,shared.syntaxerr);
    }
}
",182365,"void xgroupCommand(client *c) {
    const char *help[] = {
""CREATE      <key> <groupname> <id or $>  -- Create a new consumer group."",
""SETID       <key> <groupname> <id or $>  -- Set the current group ID."",
""DELGROUP    <key> <groupname>            -- Remove the specified group."",
""DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer."",
""HELP                                     -- Prints this help."",
NULL
    };
    stream *s = NULL;
    sds grpname = NULL;
    streamCG *cg = NULL;
    char *opt = c->argv[1]->ptr; /* Subcommand name. */

     /* Lookup the key now, this is common for all the subcommands but HELP. */
     if (c->argc >= 4) {
         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);
        if (o == NULL) return;
         s = o->ptr;
         grpname = c->argv[3]->ptr;
 
        /* Certain subcommands require the group to exist. */
        if ((cg = streamLookupCG(s,grpname)) == NULL &&
            (!strcasecmp(opt,""SETID"") ||
             !strcasecmp(opt,""DELCONSUMER"")))
        {
            addReplyErrorFormat(c, ""-NOGROUP No such consumer group '%s' ""
                                   ""for key name '%s'"",
                                   (char*)grpname, (char*)c->argv[2]->ptr);
            return;
        }
    }

    /* Dispatch the different subcommands. */
    if (!strcasecmp(opt,""CREATE"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);
        if (cg) {
            addReply(c,shared.ok);
            server.dirty++;
        } else {
            addReplySds(c,
                sdsnew(""-BUSYGROUP Consumer Group name already exists\r\n""));
        }
    } else if (!strcasecmp(opt,""SETID"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        cg->last_id = id;
        addReply(c,shared.ok);
    } else if (!strcasecmp(opt,""DESTROY"") && c->argc == 4) {
        if (cg) {
            raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);
            streamFreeCG(cg);
            addReply(c,shared.cone);
        } else {
            addReply(c,shared.czero);
        }
    } else if (!strcasecmp(opt,""DELCONSUMER"") && c->argc == 5) {
        /* Delete the consumer and returns the number of pending messages
         * that were yet associated with such a consumer. */
        long long pending = streamDelConsumer(cg,c->argv[4]->ptr);
        addReplyLongLong(c,pending);
        server.dirty++;
    } else if (!strcasecmp(opt,""HELP"")) {
        addReplyHelp(c, help);
    } else {
        addReply(c,shared.syntaxerr);
    }
}
","void xgroupCommand(client *c) {
    const char *help[] = {
""CREATE      <key> <groupname> <id or $>  -- Create a new consumer group."",
""SETID       <key> <groupname> <id or $>  -- Set the current group ID."",
""DELGROUP    <key> <groupname>            -- Remove the specified group."",
""DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer."",
""HELP                                     -- Prints this help."",
NULL
    };
    stream *s = NULL;
    sds grpname = NULL;
    streamCG *cg = NULL;
    char *opt = c->argv[1]->ptr; /* Subcommand name. */

     /* Lookup the key now, this is common for all the subcommands but HELP. */
     if (c->argc >= 4) {
         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);
        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
         s = o->ptr;
         grpname = c->argv[3]->ptr;
 
        /* Certain subcommands require the group to exist. */
        if ((cg = streamLookupCG(s,grpname)) == NULL &&
            (!strcasecmp(opt,""SETID"") ||
             !strcasecmp(opt,""DELCONSUMER"")))
        {
            addReplyErrorFormat(c, ""-NOGROUP No such consumer group '%s' ""
                                   ""for key name '%s'"",
                                   (char*)grpname, (char*)c->argv[2]->ptr);
            return;
        }
    }

    /* Dispatch the different subcommands. */
    if (!strcasecmp(opt,""CREATE"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);
        if (cg) {
            addReply(c,shared.ok);
            server.dirty++;
        } else {
            addReplySds(c,
                sdsnew(""-BUSYGROUP Consumer Group name already exists\r\n""));
        }
    } else if (!strcasecmp(opt,""SETID"") && c->argc == 5) {
        streamID id;
        if (!strcmp(c->argv[4]->ptr,""$"")) {
            id = s->last_id;
        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
            return;
        }
        cg->last_id = id;
        addReply(c,shared.ok);
    } else if (!strcasecmp(opt,""DESTROY"") && c->argc == 4) {
        if (cg) {
            raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);
            streamFreeCG(cg);
            addReply(c,shared.cone);
        } else {
            addReply(c,shared.czero);
        }
    } else if (!strcasecmp(opt,""DELCONSUMER"") && c->argc == 5) {
        /* Delete the consumer and returns the number of pending messages
         * that were yet associated with such a consumer. */
        long long pending = streamDelConsumer(cg,c->argv[4]->ptr);
        addReplyLongLong(c,pending);
        server.dirty++;
    } else if (!strcasecmp(opt,""HELP"")) {
        addReplyHelp(c, help);
    } else {
        addReply(c,shared.syntaxerr);
    }
}
","The `xgroupCommand` function manages consumer groups in a stream data structure, allowing clients to create, modify, and delete groups and consumers. It first checks the command type and validates the provided key and group name. Depending on the subcommand (CREATE, SETID, DESTROY, DELCONSUMER, HELP), it performs specific actions: creating a new group, setting the current group ID, removing a group, deleting a consumer, or displaying help information. The function ensures proper error handling for non-existent groups and invalid commands, responding with appropriate messages to the client based on the operation's success or failure.","The provided code implements a command handler for managing consumer groups within a stream data structure. It allows clients to create new groups, set the current group ID, delete groups, and remove specific consumers. The handler first validates the input parameters and checks for the existence of the specified group when necessary. Depending on the command issued, it performs the corresponding action, ensuring proper error handling for invalid operations or non-existent groups. Additionally, it can provide help information to guide users on the available commands, responding with appropriate messages based on the outcome of each operation.","The vulnerability identified as CWE-704, which pertains to incorrect handling of exceptional conditions, was present in the original code due to the lack of type checking for the stream object. Specifically, after retrieving the object with `lookupKeyWriteOrReply`, the code did not verify if the object was indeed of the expected stream type before proceeding with operations that assumed this type. The fixed code addresses this issue by adding a check using `checkType(c, o, OBJ_STREAM)`, ensuring that the object is validated before any further actions are taken, thus preventing potential misuse or crashes from invalid object types.","The vulnerability identified as CWE-704, related to incorrect handling of exceptional conditions, arose from the original code's failure to verify the type of an object after it was retrieved. This oversight allowed the code to proceed with operations that assumed the object was of a specific type, potentially leading to undefined behavior or crashes if the assumption was incorrect. The fixed code addresses this issue by incorporating a type check to ensure that the object is of the expected type before any further actions are taken, thereby enhancing the robustness and reliability of the code against invalid inputs.","The vulnerability was fixed by adding a type verification step after retrieving the object with `lookupKeyWriteOrReply`. In the updated code, the function now includes a call to `checkType(c, o, OBJ_STREAM)` to ensure that the retrieved object is indeed of the expected stream type. This check prevents the code from proceeding with operations that assume the object is a stream, thereby mitigating the risk of undefined behavior or crashes. By enforcing this validation, the code becomes more robust and secure against invalid inputs that could lead to erroneous execution paths.","The vulnerability was fixed by introducing a validation step to ensure that the retrieved object is of the correct type before proceeding with any operations. This additional check prevents the code from executing actions that assume the object meets specific type requirements, thereby reducing the risk of undefined behavior or crashes due to incorrect assumptions. By enforcing this type verification, the code enhances its robustness and security, ensuring that only valid objects are processed, which ultimately leads to safer execution and improved error handling in the event of unexpected input.","CWE-843, CWE-704, CWE-681, CWE-136, CWE-119, CWE-20, CWE-825, CWE-1287, CWE-502, CWE-1286",N,-1
3,3,183037,183037,,Remote,Not required,Partial,CVE-2016-7398,https://www.cvedetails.com/cve/CVE-2016-7398/,CWE-704,Low,Partial,Partial,,2019-09-06,7.5,A type confusion vulnerability in the merge_param() function of php_http_params.c in PHP's pecl-http extension 3.1.0beta2 (PHP 7) and earlier as well as 2.6.0beta2 (PHP 5) and earlier allows attackers to crash PHP and possibly execute arbitrary code via crafted HTTP requests.,2019-09-20,Exec Code ,1,https://github.com/m6w6/ext-http/commit/17137d4ab1ce81a2cee0fae842340a344ef3da83,17137d4ab1ce81a2cee0fae842340a344ef3da83,fix bug #73055,1,src/php_http_params.c,"{""sha"": ""45ac1a5f203ae766bd3662ce1fe7a59e677ceb02"", ""filename"": "".gitignore"", ""status"": ""modified"", ""additions"": 33, ""deletions"": 0, ""changes"": 33, ""blob_url"": ""https://github.com/m6w6/ext-http/blob/17137d4ab1ce81a2cee0fae842340a344ef3da83/.gitignore"", ""raw_url"": ""https://github.com/m6w6/ext-http/raw/17137d4ab1ce81a2cee0fae842340a344ef3da83/.gitignore"", ""contents_url"": ""https://api.github.com/repos/m6w6/ext-http/contents/.gitignore?ref=17137d4ab1ce81a2cee0fae842340a344ef3da83"", ""patch"": ""@@ -42,3 +42,36 @@ lcov_data\n *.phar\n vendor/\n tests/helper/server.log\n+php_http_api.h\n+php_http_buffer.h\n+php_http_client.h\n+php_http_client_curl.h\n+php_http_client_curl_event.h\n+php_http_client_curl_user.h\n+php_http_client_request.h\n+php_http_client_response.h\n+php_http_cookie.h\n+php_http_curl.h\n+php_http_encoding.h\n+php_http_env.h\n+php_http_env_request.h\n+php_http_env_response.h\n+php_http_etag.h\n+php_http_exception.h\n+php_http_filter.h\n+php_http_header.h\n+php_http_header_parser.h\n+php_http_info.h\n+php_http_message.h\n+php_http_message_body.h\n+php_http_message_parser.h\n+php_http_misc.h\n+php_http_negotiate.h\n+php_http_object.h\n+php_http_options.h\n+php_http_params.h\n+php_http_querystring.h\n+php_http_response_codes.h\n+php_http_url.h\n+php_http_utf8.h\n+php_http_version.h""}<_**next**_>{""sha"": ""7191f314ad8cc64d1d99491e09010f271a89ae9c"", ""filename"": ""package.xml"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 2, ""changes"": 9, ""blob_url"": ""https://github.com/m6w6/ext-http/blob/17137d4ab1ce81a2cee0fae842340a344ef3da83/package.xml"", ""raw_url"": ""https://github.com/m6w6/ext-http/raw/17137d4ab1ce81a2cee0fae842340a344ef3da83/package.xml"", ""contents_url"": ""https://api.github.com/repos/m6w6/ext-http/contents/package.xml?ref=17137d4ab1ce81a2cee0fae842340a344ef3da83"", ""patch"": ""@@ -31,9 +31,9 @@ https://mdref.m6w6.name/http\n   <email>mike@php.net</email>\n   <active>yes</active>\n  </lead>\n- <date>2016-09-07</date>\n+ <date>2016-09-12</date>\n  <version>\n-  <release>2.6.0beta2</release>\n+  <release>2.6.0RC1</release>\n   <api>2.6.0</api>\n  </version>\n  <stability>\n@@ -69,6 +69,10 @@ https://mdref.m6w6.name/http\n Changes from beta1:\n * Fixed PHP-5.3 compatibility\n * Fixed recursive calls to the event loop dispatcher\n+\n+Changes from beta2:\n+* Fix bug #73055: crash in http\\QueryString (Mike, @rc0r)\n+* Fix HTTP/2 version parser for older libcurl versions (Mike)\n ]]></notes>\n  <contents>\n   <dir name=\""/\"">\n@@ -185,6 +189,7 @@ Changes from beta1:\n      <file role=\""test\"" name=\""bug69313.phpt\""/>\n      <file role=\""test\"" name=\""bug69357.phpt\""/>\n      <file role=\""test\"" name=\""bug71719.phpt\""/>\n+     <file role=\""test\"" name=\""bug73055.phpt\""/>\n      <file role=\""test\"" name=\""client001.phpt\""/>\n      <file role=\""test\"" name=\""client002.phpt\""/>\n      <file role=\""test\"" name=\""client003.phpt\""/>""}<_**next**_>{""sha"": ""90710684deabe6d08bd5e81d8e1563086f0095a6"", ""filename"": ""src/php_http_params.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/m6w6/ext-http/blob/17137d4ab1ce81a2cee0fae842340a344ef3da83/src/php_http_params.c"", ""raw_url"": ""https://github.com/m6w6/ext-http/raw/17137d4ab1ce81a2cee0fae842340a344ef3da83/src/php_http_params.c"", ""contents_url"": ""https://api.github.com/repos/m6w6/ext-http/contents/src/php_http_params.c?ref=17137d4ab1ce81a2cee0fae842340a344ef3da83"", ""patch"": ""@@ -470,7 +470,7 @@ static void merge_param(HashTable *params, zval *zdata, zval ***current_param, z\n \t\t\twhile (Z_TYPE_PP(zdata_ptr) == IS_ARRAY\n \t\t\t&&\tSUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)\n \t\t\t) {\n-\t\t\t\tif (Z_TYPE_PP(test_ptr) == IS_ARRAY) {\n+\t\t\t\tif (Z_TYPE_PP(test_ptr) == IS_ARRAY && Z_TYPE_PP(ptr) == IS_ARRAY) {\n \n \t\t\t\t\t/* now find key in ptr */\n \t\t\t\t\tif (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {""}","static void merge_param(HashTable *params, zval *zdata, zval ***current_param, zval ***current_args TSRMLS_DC)
{
	zval **ptr, **zdata_ptr;
	php_http_array_hashkey_t hkey = php_http_array_hashkey_init(0);

#if 0
	{
		zval tmp;
		INIT_PZVAL_ARRAY(&tmp, params);
		fprintf(stderr, ""params = "");
		zend_print_zval_r(&tmp, 1 TSRMLS_CC);
		fprintf(stderr, ""\n"");
	}
#endif

	hkey.type = zend_hash_get_current_key_ex(Z_ARRVAL_P(zdata), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL);

	if ((hkey.type == HASH_KEY_IS_STRING && !zend_hash_exists(params, hkey.str, hkey.len))
	||	(hkey.type == HASH_KEY_IS_LONG && !zend_hash_index_exists(params, hkey.num))
	) {
		zval *tmp, *arg, **args;

		/* create the entry if it doesn't exist */
		zend_hash_get_current_data(Z_ARRVAL_P(zdata), (void *) &ptr);
		Z_ADDREF_PP(ptr);
		MAKE_STD_ZVAL(tmp);
		array_init(tmp);
		add_assoc_zval_ex(tmp, ZEND_STRS(""value""), *ptr);

		MAKE_STD_ZVAL(arg);
		array_init(arg);
		zend_hash_update(Z_ARRVAL_P(tmp), ""arguments"", sizeof(""arguments""), (void *) &arg, sizeof(zval *), (void *) &args);
		*current_args = args;

		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_update(params, hkey.str, hkey.len, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		} else {
			zend_hash_index_update(params, hkey.num, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		}
	} else {
		/* merge */
		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_find(params, hkey.str, hkey.len, (void *) &ptr);
		} else {
			zend_hash_index_find(params, hkey.num, (void *) &ptr);
		}

		zdata_ptr = &zdata;

		if (Z_TYPE_PP(ptr) == IS_ARRAY
		&&	SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), ""value"", sizeof(""value""), (void *) &ptr)
		&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &zdata_ptr)
		) {
			/*
			 * params = [arr => [value => [0 => 1]]]
			 *                            ^- ptr
			 * zdata  = [arr => [0 => NULL]]
			 *                  ^- zdata_ptr
			 */
			zval **test_ptr;

 			while (Z_TYPE_PP(zdata_ptr) == IS_ARRAY
 			&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)
 			) {
				if (Z_TYPE_PP(test_ptr) == IS_ARRAY && Z_TYPE_PP(ptr) == IS_ARRAY) {
 
 					/* now find key in ptr */
 					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						if (SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					} else {
						if (SUCCESS == zend_hash_index_find(Z_ARRVAL_PP(ptr), hkey.num, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else if (hkey.num) {
							Z_ADDREF_PP(test_ptr);
							zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					}
				} else {
					/* this is the leaf */
					Z_ADDREF_PP(test_ptr);
					if (Z_TYPE_PP(ptr) != IS_ARRAY) {
						zval_dtor(*ptr);
						array_init(*ptr);
					}
					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else if (hkey.num) {
						zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else {
						zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					}
					break;
				}
			}

		}
	}

	/* bubble up */
	while (Z_TYPE_PP(ptr) == IS_ARRAY && SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(ptr), (void *) &ptr));
	*current_param = ptr;
}
","static void merge_param(HashTable *params, zval *zdata, zval ***current_param, zval ***current_args TSRMLS_DC)
{
	zval **ptr, **zdata_ptr;
	php_http_array_hashkey_t hkey = php_http_array_hashkey_init(0);

#if 0
	{
		zval tmp;
		INIT_PZVAL_ARRAY(&tmp, params);
		fprintf(stderr, ""params = "");
		zend_print_zval_r(&tmp, 1 TSRMLS_CC);
		fprintf(stderr, ""\n"");
	}
#endif

	hkey.type = zend_hash_get_current_key_ex(Z_ARRVAL_P(zdata), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL);

	if ((hkey.type == HASH_KEY_IS_STRING && !zend_hash_exists(params, hkey.str, hkey.len))
	||	(hkey.type == HASH_KEY_IS_LONG && !zend_hash_index_exists(params, hkey.num))
	) {
		zval *tmp, *arg, **args;

		/* create the entry if it doesn't exist */
		zend_hash_get_current_data(Z_ARRVAL_P(zdata), (void *) &ptr);
		Z_ADDREF_PP(ptr);
		MAKE_STD_ZVAL(tmp);
		array_init(tmp);
		add_assoc_zval_ex(tmp, ZEND_STRS(""value""), *ptr);

		MAKE_STD_ZVAL(arg);
		array_init(arg);
		zend_hash_update(Z_ARRVAL_P(tmp), ""arguments"", sizeof(""arguments""), (void *) &arg, sizeof(zval *), (void *) &args);
		*current_args = args;

		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_update(params, hkey.str, hkey.len, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		} else {
			zend_hash_index_update(params, hkey.num, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		}
	} else {
		/* merge */
		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_find(params, hkey.str, hkey.len, (void *) &ptr);
		} else {
			zend_hash_index_find(params, hkey.num, (void *) &ptr);
		}

		zdata_ptr = &zdata;

		if (Z_TYPE_PP(ptr) == IS_ARRAY
		&&	SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), ""value"", sizeof(""value""), (void *) &ptr)
		&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &zdata_ptr)
		) {
			/*
			 * params = [arr => [value => [0 => 1]]]
			 *                            ^- ptr
			 * zdata  = [arr => [0 => NULL]]
			 *                  ^- zdata_ptr
			 */
			zval **test_ptr;

 			while (Z_TYPE_PP(zdata_ptr) == IS_ARRAY
 			&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)
 			) {
				if (Z_TYPE_PP(test_ptr) == IS_ARRAY) {
 
 					/* now find key in ptr */
 					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						if (SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					} else {
						if (SUCCESS == zend_hash_index_find(Z_ARRVAL_PP(ptr), hkey.num, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else if (hkey.num) {
							Z_ADDREF_PP(test_ptr);
							zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					}
				} else {
					/* this is the leaf */
					Z_ADDREF_PP(test_ptr);
					if (Z_TYPE_PP(ptr) != IS_ARRAY) {
						zval_dtor(*ptr);
						array_init(*ptr);
					}
					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else if (hkey.num) {
						zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else {
						zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					}
					break;
				}
			}

		}
	}

	/* bubble up */
	while (Z_TYPE_PP(ptr) == IS_ARRAY && SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(ptr), (void *) &ptr));
	*current_param = ptr;
}
",C,"				if (Z_TYPE_PP(test_ptr) == IS_ARRAY && Z_TYPE_PP(ptr) == IS_ARRAY) {
","				if (Z_TYPE_PP(test_ptr) == IS_ARRAY) {
",,"@@ -470,7 +470,7 @@ static void merge_param(HashTable *params, zval *zdata, zval ***current_param, z
 			while (Z_TYPE_PP(zdata_ptr) == IS_ARRAY
 			&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)
 			) {
-				if (Z_TYPE_PP(test_ptr) == IS_ARRAY) {
+				if (Z_TYPE_PP(test_ptr) == IS_ARRAY && Z_TYPE_PP(ptr) == IS_ARRAY) {
 
 					/* now find key in ptr */
 					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {",ext-http,17137d4ab1ce81a2cee0fae842340a344ef3da83,3c7b514d38d844b855d430fcbaed6dea67c9c17b,1,"static void merge_param(HashTable *params, zval *zdata, zval ***current_param, zval ***current_args TSRMLS_DC)
{
	zval **ptr, **zdata_ptr;
	php_http_array_hashkey_t hkey = php_http_array_hashkey_init(0);

#if 0
	{
		zval tmp;
		INIT_PZVAL_ARRAY(&tmp, params);
		fprintf(stderr, ""params = "");
		zend_print_zval_r(&tmp, 1 TSRMLS_CC);
		fprintf(stderr, ""\n"");
	}
#endif

	hkey.type = zend_hash_get_current_key_ex(Z_ARRVAL_P(zdata), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL);

	if ((hkey.type == HASH_KEY_IS_STRING && !zend_hash_exists(params, hkey.str, hkey.len))
	||	(hkey.type == HASH_KEY_IS_LONG && !zend_hash_index_exists(params, hkey.num))
	) {
		zval *tmp, *arg, **args;

		/* create the entry if it doesn't exist */
		zend_hash_get_current_data(Z_ARRVAL_P(zdata), (void *) &ptr);
		Z_ADDREF_PP(ptr);
		MAKE_STD_ZVAL(tmp);
		array_init(tmp);
		add_assoc_zval_ex(tmp, ZEND_STRS(""value""), *ptr);

		MAKE_STD_ZVAL(arg);
		array_init(arg);
		zend_hash_update(Z_ARRVAL_P(tmp), ""arguments"", sizeof(""arguments""), (void *) &arg, sizeof(zval *), (void *) &args);
		*current_args = args;

		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_update(params, hkey.str, hkey.len, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		} else {
			zend_hash_index_update(params, hkey.num, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		}
	} else {
		/* merge */
		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_find(params, hkey.str, hkey.len, (void *) &ptr);
		} else {
			zend_hash_index_find(params, hkey.num, (void *) &ptr);
		}

		zdata_ptr = &zdata;

		if (Z_TYPE_PP(ptr) == IS_ARRAY
		&&	SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), ""value"", sizeof(""value""), (void *) &ptr)
		&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &zdata_ptr)
		) {
			/*
			 * params = [arr => [value => [0 => 1]]]
			 *                            ^- ptr
			 * zdata  = [arr => [0 => NULL]]
			 *                  ^- zdata_ptr
			 */
			zval **test_ptr;

 			while (Z_TYPE_PP(zdata_ptr) == IS_ARRAY
 			&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)
 			) {
//flaw_line_below:
				if (Z_TYPE_PP(test_ptr) == IS_ARRAY) {
//fix_flaw_line_below:
//				if (Z_TYPE_PP(test_ptr) == IS_ARRAY && Z_TYPE_PP(ptr) == IS_ARRAY) {
 
 					/* now find key in ptr */
 					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						if (SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					} else {
						if (SUCCESS == zend_hash_index_find(Z_ARRVAL_PP(ptr), hkey.num, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else if (hkey.num) {
							Z_ADDREF_PP(test_ptr);
							zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					}
				} else {
					/* this is the leaf */
					Z_ADDREF_PP(test_ptr);
					if (Z_TYPE_PP(ptr) != IS_ARRAY) {
						zval_dtor(*ptr);
						array_init(*ptr);
					}
					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else if (hkey.num) {
						zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else {
						zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					}
					break;
				}
			}

		}
	}

	/* bubble up */
	while (Z_TYPE_PP(ptr) == IS_ARRAY && SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(ptr), (void *) &ptr));
	*current_param = ptr;
}
",183037,"static void merge_param(HashTable *params, zval *zdata, zval ***current_param, zval ***current_args TSRMLS_DC)
{
	zval **ptr, **zdata_ptr;
	php_http_array_hashkey_t hkey = php_http_array_hashkey_init(0);

#if 0
	{
		zval tmp;
		INIT_PZVAL_ARRAY(&tmp, params);
		fprintf(stderr, ""params = "");
		zend_print_zval_r(&tmp, 1 TSRMLS_CC);
		fprintf(stderr, ""\n"");
	}
#endif

	hkey.type = zend_hash_get_current_key_ex(Z_ARRVAL_P(zdata), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL);

	if ((hkey.type == HASH_KEY_IS_STRING && !zend_hash_exists(params, hkey.str, hkey.len))
	||	(hkey.type == HASH_KEY_IS_LONG && !zend_hash_index_exists(params, hkey.num))
	) {
		zval *tmp, *arg, **args;

		/* create the entry if it doesn't exist */
		zend_hash_get_current_data(Z_ARRVAL_P(zdata), (void *) &ptr);
		Z_ADDREF_PP(ptr);
		MAKE_STD_ZVAL(tmp);
		array_init(tmp);
		add_assoc_zval_ex(tmp, ZEND_STRS(""value""), *ptr);

		MAKE_STD_ZVAL(arg);
		array_init(arg);
		zend_hash_update(Z_ARRVAL_P(tmp), ""arguments"", sizeof(""arguments""), (void *) &arg, sizeof(zval *), (void *) &args);
		*current_args = args;

		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_update(params, hkey.str, hkey.len, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		} else {
			zend_hash_index_update(params, hkey.num, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		}
	} else {
		/* merge */
		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_find(params, hkey.str, hkey.len, (void *) &ptr);
		} else {
			zend_hash_index_find(params, hkey.num, (void *) &ptr);
		}

		zdata_ptr = &zdata;

		if (Z_TYPE_PP(ptr) == IS_ARRAY
		&&	SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), ""value"", sizeof(""value""), (void *) &ptr)
		&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &zdata_ptr)
		) {
			/*
			 * params = [arr => [value => [0 => 1]]]
			 *                            ^- ptr
			 * zdata  = [arr => [0 => NULL]]
			 *                  ^- zdata_ptr
			 */
			zval **test_ptr;

 			while (Z_TYPE_PP(zdata_ptr) == IS_ARRAY
 			&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)
 			) {
				if (Z_TYPE_PP(test_ptr) == IS_ARRAY) {
 
 					/* now find key in ptr */
 					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						if (SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					} else {
						if (SUCCESS == zend_hash_index_find(Z_ARRVAL_PP(ptr), hkey.num, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else if (hkey.num) {
							Z_ADDREF_PP(test_ptr);
							zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					}
				} else {
					/* this is the leaf */
					Z_ADDREF_PP(test_ptr);
					if (Z_TYPE_PP(ptr) != IS_ARRAY) {
						zval_dtor(*ptr);
						array_init(*ptr);
					}
					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else if (hkey.num) {
						zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else {
						zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					}
					break;
				}
			}

		}
	}

	/* bubble up */
	while (Z_TYPE_PP(ptr) == IS_ARRAY && SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(ptr), (void *) &ptr));
	*current_param = ptr;
}
","static void merge_param(HashTable *params, zval *zdata, zval ***current_param, zval ***current_args TSRMLS_DC)
{
	zval **ptr, **zdata_ptr;
	php_http_array_hashkey_t hkey = php_http_array_hashkey_init(0);

#if 0
	{
		zval tmp;
		INIT_PZVAL_ARRAY(&tmp, params);
		fprintf(stderr, ""params = "");
		zend_print_zval_r(&tmp, 1 TSRMLS_CC);
		fprintf(stderr, ""\n"");
	}
#endif

	hkey.type = zend_hash_get_current_key_ex(Z_ARRVAL_P(zdata), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL);

	if ((hkey.type == HASH_KEY_IS_STRING && !zend_hash_exists(params, hkey.str, hkey.len))
	||	(hkey.type == HASH_KEY_IS_LONG && !zend_hash_index_exists(params, hkey.num))
	) {
		zval *tmp, *arg, **args;

		/* create the entry if it doesn't exist */
		zend_hash_get_current_data(Z_ARRVAL_P(zdata), (void *) &ptr);
		Z_ADDREF_PP(ptr);
		MAKE_STD_ZVAL(tmp);
		array_init(tmp);
		add_assoc_zval_ex(tmp, ZEND_STRS(""value""), *ptr);

		MAKE_STD_ZVAL(arg);
		array_init(arg);
		zend_hash_update(Z_ARRVAL_P(tmp), ""arguments"", sizeof(""arguments""), (void *) &arg, sizeof(zval *), (void *) &args);
		*current_args = args;

		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_update(params, hkey.str, hkey.len, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		} else {
			zend_hash_index_update(params, hkey.num, (void *) &tmp, sizeof(zval *), (void *) &ptr);
		}
	} else {
		/* merge */
		if (hkey.type == HASH_KEY_IS_STRING) {
			zend_hash_find(params, hkey.str, hkey.len, (void *) &ptr);
		} else {
			zend_hash_index_find(params, hkey.num, (void *) &ptr);
		}

		zdata_ptr = &zdata;

		if (Z_TYPE_PP(ptr) == IS_ARRAY
		&&	SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), ""value"", sizeof(""value""), (void *) &ptr)
		&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &zdata_ptr)
		) {
			/*
			 * params = [arr => [value => [0 => 1]]]
			 *                            ^- ptr
			 * zdata  = [arr => [0 => NULL]]
			 *                  ^- zdata_ptr
			 */
			zval **test_ptr;

 			while (Z_TYPE_PP(zdata_ptr) == IS_ARRAY
 			&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)
 			) {
				if (Z_TYPE_PP(test_ptr) == IS_ARRAY && Z_TYPE_PP(ptr) == IS_ARRAY) {
 
 					/* now find key in ptr */
 					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						if (SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					} else {
						if (SUCCESS == zend_hash_index_find(Z_ARRVAL_PP(ptr), hkey.num, (void *) &ptr)) {
							zdata_ptr = test_ptr;
						} else if (hkey.num) {
							Z_ADDREF_PP(test_ptr);
							zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						} else {
							Z_ADDREF_PP(test_ptr);
							zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
							break;
						}
					}
				} else {
					/* this is the leaf */
					Z_ADDREF_PP(test_ptr);
					if (Z_TYPE_PP(ptr) != IS_ARRAY) {
						zval_dtor(*ptr);
						array_init(*ptr);
					}
					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
						zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else if (hkey.num) {
						zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					} else {
						zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);
					}
					break;
				}
			}

		}
	}

	/* bubble up */
	while (Z_TYPE_PP(ptr) == IS_ARRAY && SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(ptr), (void *) &ptr));
	*current_param = ptr;
}
","The `merge_param` function is designed to merge parameters from a given `zdata` array into a `params` hash table, handling both the creation of new entries and the merging of existing ones. It first checks if the current key from `zdata` exists in `params`; if not, it initializes a new entry with the current value. If the key exists, it recursively merges the values, ensuring that arrays are properly handled and that values are added or updated as necessary. The function also maintains references to the current parameter and arguments, facilitating further operations on the merged data.","The provided code defines a function that merges data from one array into a hash table, managing both the creation of new entries and the updating of existing ones. It checks if the current key from the input array exists in the hash table; if not, it initializes a new entry with the corresponding value. If the key is found, it recursively merges the values, ensuring that nested arrays are handled appropriately. The function also keeps track of the current parameter and arguments, allowing for further manipulation of the merged data structure.","The vulnerability identified in the original code, classified under CWE-704, arises from improper handling of data types during the merging process, which can lead to unexpected behavior or crashes. Specifically, the code did not adequately check if the current data being processed was an array before attempting to access its elements, potentially leading to dereferencing null or invalid pointers. The fixed code introduces additional checks to ensure that both the current data and the parameters being merged are indeed arrays, thereby preventing such unsafe operations and enhancing the overall robustness of the merging functionality.","The vulnerability identified in the original code, categorized under CWE-704, stems from inadequate type checking during the merging process, which can lead to dereferencing invalid or null pointers. This oversight occurs when the code attempts to access elements of data structures without confirming their types, potentially resulting in crashes or undefined behavior. The fixed code addresses this issue by implementing additional checks to ensure that the data being processed is of the expected type before any operations are performed. This enhancement significantly improves the safety and stability of the merging functionality, preventing potential exploitation or errors.","The vulnerability was fixed by adding explicit type checks to ensure that both the current data being processed and the parameters being merged are arrays before any operations are performed. In the updated code, conditions were introduced to verify the type of `ptr` and `test_ptr` using `Z_TYPE_PP`, ensuring they are arrays before accessing their elements. Additionally, the code now checks the success of operations like `zend_hash_find` and `zend_hash_index_find` to confirm valid data retrieval. These enhancements prevent unsafe dereferencing and ensure that only valid data structures are manipulated, thereby improving overall stability and security.","The vulnerability was addressed by implementing additional type checks to ensure that the data structures being accessed are of the expected type before any operations are performed. The updated code includes conditions that verify the integrity of the data, preventing operations on invalid or null pointers. Furthermore, the code now confirms the success of data retrieval operations, ensuring that only valid entries are processed. These modifications enhance the robustness of the merging functionality, significantly reducing the risk of crashes or undefined behavior due to improper handling of data types.","CWE-476, CWE-704, CWE-843, CWE-681, CWE-588, CWE-416, CWE-119, CWE-457, CWE-628, CWE-703",N,-1
4,4,186285,186285,,Remote,Not required,,CVE-2017-5094,https://www.cvedetails.com/cve/CVE-2017-5094/,CWE-704,Medium,,Partial,,2017-10-27,4.3,"Type confusion in extensions JavaScript bindings in Google Chrome prior to 60.0.3112.78 for Mac, Windows, Linux, and Android allowed a remote attacker to potentially maliciously modify objects via a crafted HTML page.",2018-01-04,,18,https://github.com/chromium/chromium/commit/41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c,41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c,"SkiaRenderer: Support changing color space

SkiaOutputSurfaceImpl did not handle the color space changing after it
was created previously. The SkSurfaceCharacterization color space was
only set during the first time Reshape() ran when the charactization is
returned from the GPU thread. If the color space was changed later the
SkSurface and SkDDL color spaces no longer matched and draw failed.

Bug: 1009452
Change-Id: Ib6d2083efc7e7eb6f94782342e92a809b69d6fdc
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1841811
Reviewed-by: Peng Huang <penghuang@chromium.org>
Commit-Queue: kylechar <kylechar@chromium.org>
Cr-Commit-Position: refs/heads/master@{#702946}",9,components/viz/service/display_embedder/skia_output_surface_impl.cc,"{""sha"": ""2e06d978df84358e1db9b704d4bdf275fbfbfd60"", ""filename"": ""components/viz/service/display_embedder/skia_output_surface_impl.cc"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 10, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c/components/viz/service/display_embedder/skia_output_surface_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c/components/viz/service/display_embedder/skia_output_surface_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/viz/service/display_embedder/skia_output_surface_impl.cc?ref=41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c"", ""patch"": ""@@ -193,14 +193,22 @@ void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (initialize_waitable_event_) {\n     initialize_waitable_event_->Wait();\n-    initialize_waitable_event_ = nullptr;\n+    initialize_waitable_event_.reset();\n   }\n \n   SkSurfaceCharacterization* characterization = nullptr;\n   if (characterization_.isValid()) {\n-    // TODO(weiliang): support color space. https://crbug.com/795132\n-    characterization_ =\n-        characterization_.createResized(size.width(), size.height());\n+    sk_sp<SkColorSpace> sk_color_space = color_space.ToSkColorSpace();\n+    if (!SkColorSpace::Equals(characterization_.refColorSpace().get(),\n+                              sk_color_space.get())) {\n+      characterization_ = characterization_.createColorSpace(sk_color_space);\n+    }\n+    if (size.width() != characterization_.width() ||\n+        size.height() != characterization_.height()) {\n+      characterization_ =\n+          characterization_.createResized(size.width(), size.height());\n+    }\n+    // TODO(kylechar): Update |characterization_| if |use_alpha| changes.\n     RecreateRootRecorder();\n   } else {\n     characterization = &characterization_;\n@@ -211,12 +219,12 @@ void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,\n \n   // impl_on_gpu_ is released on the GPU thread by a posted task from\n   // SkiaOutputSurfaceImpl::dtor. So it is safe to use base::Unretained.\n-  auto callback = base::BindOnce(\n-      &SkiaOutputSurfaceImplOnGpu::Reshape,\n-      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,\n-      std::move(color_space), has_alpha, use_stencil, pre_transform_,\n-      characterization, initialize_waitable_event_.get());\n-  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());\n+  auto task = base::BindOnce(&SkiaOutputSurfaceImplOnGpu::Reshape,\n+                             base::Unretained(impl_on_gpu_.get()), size,\n+                             device_scale_factor, color_space, has_alpha,\n+                             use_stencil, pre_transform_, characterization,\n+                             initialize_waitable_event_.get());\n+  ScheduleGpuTask(std::move(task), {});\n }\n \n void SkiaOutputSurfaceImpl::SetUpdateVSyncParametersCallback(""}<_**next**_>{""sha"": ""df9015ce046774c45d6f45db1818fcfbeabbff88"", ""filename"": ""components/viz/service/display_embedder/skia_output_surface_impl_unittest.cc"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 4, ""changes"": 32, ""blob_url"": ""https://github.com/chromium/chromium/blob/41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c/components/viz/service/display_embedder/skia_output_surface_impl_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c/components/viz/service/display_embedder/skia_output_surface_impl_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/viz/service/display_embedder/skia_output_surface_impl_unittest.cc?ref=41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c"", ""patch"": ""@@ -11,13 +11,15 @@\n #include \""base/base64.h\""\n #include \""base/bind.h\""\n #include \""base/command_line.h\""\n+#include \""base/run_loop.h\""\n #include \""base/test/scoped_feature_list.h\""\n #include \""cc/test/fake_output_surface_client.h\""\n #include \""cc/test/pixel_test_utils.h\""\n #include \""components/viz/common/display/renderer_settings.h\""\n #include \""components/viz/common/frame_sinks/copy_output_request.h\""\n #include \""components/viz/common/frame_sinks/copy_output_result.h\""\n #include \""components/viz/common/frame_sinks/copy_output_util.h\""\n+#include \""components/viz/service/display/output_surface_frame.h\""\n #include \""components/viz/service/display_embedder/skia_output_surface_dependency_impl.h\""\n #include \""components/viz/service/gl/gpu_service_impl.h\""\n #include \""components/viz/test/test_gpu_service_holder.h\""\n@@ -197,12 +199,34 @@ TEST_P(SkiaOutputSurfaceImplTest, SubmitPaint) {\n       base::BindOnce(&SkiaOutputSurfaceImplTest::CheckSyncTokenOnGpuThread,\n                      base::Unretained(this), sync_token);\n \n-  std::vector<gpu::SyncToken> resource_sync_tokens;\n-  resource_sync_tokens.push_back(sync_token);\n-  output_surface_->ScheduleGpuTaskForTesting(std::move(closure),\n-                                             std::move(resource_sync_tokens));\n+  output_surface_->ScheduleGpuTaskForTesting(std::move(closure), {sync_token});\n   BlockMainThread();\n   EXPECT_TRUE(on_finished_called);\n }\n \n+// Draws two frames and calls Reshape() between the two frames changing the\n+// color space. Verifies draw after color space change is successful.\n+TEST_P(SkiaOutputSurfaceImplTest, SupportsColorSpaceChange) {\n+  for (auto& color_space : {gfx::ColorSpace(), gfx::ColorSpace::CreateSRGB()}) {\n+    output_surface_->Reshape(kSurfaceRect.size(), 1, color_space,\n+                             /*has_alpha=*/false, /*use_stencil=*/false);\n+\n+    // Draw something, it's not important what.\n+    SkCanvas* root_canvas = output_surface_->BeginPaintCurrentFrame();\n+    SkPaint paint;\n+    paint.setColor(SK_ColorRED);\n+    root_canvas->drawRect(SkRect::MakeWH(10, 10), paint);\n+\n+    base::RunLoop run_loop;\n+    output_surface_->SubmitPaint(run_loop.QuitClosure());\n+\n+    OutputSurfaceFrame frame;\n+    frame.size = kSurfaceRect.size();\n+    output_surface_->SkiaSwapBuffers(std::move(frame),\n+                                     /*wants_sync_token=*/false);\n+\n+    run_loop.Run();\n+  }\n+}\n+\n }  // namespace viz""}","void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
                                    float device_scale_factor,
                                    const gfx::ColorSpace& color_space,
                                    bool has_alpha,
                                    bool use_stencil) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (initialize_waitable_event_) {
     initialize_waitable_event_->Wait();
    initialize_waitable_event_.reset();
   }
 
   SkSurfaceCharacterization* characterization = nullptr;
   if (characterization_.isValid()) {
    sk_sp<SkColorSpace> sk_color_space = color_space.ToSkColorSpace();
    if (!SkColorSpace::Equals(characterization_.refColorSpace().get(),
                              sk_color_space.get())) {
      characterization_ = characterization_.createColorSpace(sk_color_space);
    }
    if (size.width() != characterization_.width() ||
        size.height() != characterization_.height()) {
      characterization_ =
          characterization_.createResized(size.width(), size.height());
    }
    // TODO(kylechar): Update |characterization_| if |use_alpha| changes.
     RecreateRootRecorder();
   } else {
     characterization = &characterization_;
    initialize_waitable_event_ = std::make_unique<base::WaitableEvent>(
        base::WaitableEvent::ResetPolicy::MANUAL,
        base::WaitableEvent::InitialState::NOT_SIGNALED);
  }
 
  auto task = base::BindOnce(&SkiaOutputSurfaceImplOnGpu::Reshape,
                             base::Unretained(impl_on_gpu_.get()), size,
                             device_scale_factor, color_space, has_alpha,
                             use_stencil, pre_transform_, characterization,
                             initialize_waitable_event_.get());
  ScheduleGpuTask(std::move(task), {});
 }
","void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
                                    float device_scale_factor,
                                    const gfx::ColorSpace& color_space,
                                    bool has_alpha,
                                    bool use_stencil) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (initialize_waitable_event_) {
     initialize_waitable_event_->Wait();
    initialize_waitable_event_ = nullptr;
   }
 
   SkSurfaceCharacterization* characterization = nullptr;
   if (characterization_.isValid()) {
    characterization_ =
        characterization_.createResized(size.width(), size.height());
     RecreateRootRecorder();
   } else {
     characterization = &characterization_;
    initialize_waitable_event_ = std::make_unique<base::WaitableEvent>(
        base::WaitableEvent::ResetPolicy::MANUAL,
        base::WaitableEvent::InitialState::NOT_SIGNALED);
  }
 
  auto callback = base::BindOnce(
      &SkiaOutputSurfaceImplOnGpu::Reshape,
      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,
      std::move(color_space), has_alpha, use_stencil, pre_transform_,
      characterization, initialize_waitable_event_.get());
  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());
 }
",C,"    initialize_waitable_event_.reset();
    sk_sp<SkColorSpace> sk_color_space = color_space.ToSkColorSpace();
    if (!SkColorSpace::Equals(characterization_.refColorSpace().get(),
                              sk_color_space.get())) {
      characterization_ = characterization_.createColorSpace(sk_color_space);
    }
    if (size.width() != characterization_.width() ||
        size.height() != characterization_.height()) {
      characterization_ =
          characterization_.createResized(size.width(), size.height());
    }
    // TODO(kylechar): Update |characterization_| if |use_alpha| changes.
  auto task = base::BindOnce(&SkiaOutputSurfaceImplOnGpu::Reshape,
                             base::Unretained(impl_on_gpu_.get()), size,
                             device_scale_factor, color_space, has_alpha,
                             use_stencil, pre_transform_, characterization,
                             initialize_waitable_event_.get());
  ScheduleGpuTask(std::move(task), {});
","    initialize_waitable_event_ = nullptr;
    characterization_ =
        characterization_.createResized(size.width(), size.height());
  auto callback = base::BindOnce(
      &SkiaOutputSurfaceImplOnGpu::Reshape,
      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,
      std::move(color_space), has_alpha, use_stencil, pre_transform_,
      characterization, initialize_waitable_event_.get());
  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());
",,"@@ -193,14 +193,22 @@ void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (initialize_waitable_event_) {
     initialize_waitable_event_->Wait();
-    initialize_waitable_event_ = nullptr;
+    initialize_waitable_event_.reset();
   }
 
   SkSurfaceCharacterization* characterization = nullptr;
   if (characterization_.isValid()) {
-    // TODO(weiliang): support color space. https://crbug.com/795132
-    characterization_ =
-        characterization_.createResized(size.width(), size.height());
+    sk_sp<SkColorSpace> sk_color_space = color_space.ToSkColorSpace();
+    if (!SkColorSpace::Equals(characterization_.refColorSpace().get(),
+                              sk_color_space.get())) {
+      characterization_ = characterization_.createColorSpace(sk_color_space);
+    }
+    if (size.width() != characterization_.width() ||
+        size.height() != characterization_.height()) {
+      characterization_ =
+          characterization_.createResized(size.width(), size.height());
+    }
+    // TODO(kylechar): Update |characterization_| if |use_alpha| changes.
     RecreateRootRecorder();
   } else {
     characterization = &characterization_;
@@ -211,12 +219,12 @@ void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
 
   // impl_on_gpu_ is released on the GPU thread by a posted task from
   // SkiaOutputSurfaceImpl::dtor. So it is safe to use base::Unretained.
-  auto callback = base::BindOnce(
-      &SkiaOutputSurfaceImplOnGpu::Reshape,
-      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,
-      std::move(color_space), has_alpha, use_stencil, pre_transform_,
-      characterization, initialize_waitable_event_.get());
-  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());
+  auto task = base::BindOnce(&SkiaOutputSurfaceImplOnGpu::Reshape,
+                             base::Unretained(impl_on_gpu_.get()), size,
+                             device_scale_factor, color_space, has_alpha,
+                             use_stencil, pre_transform_, characterization,
+                             initialize_waitable_event_.get());
+  ScheduleGpuTask(std::move(task), {});
 }
 
 void SkiaOutputSurfaceImpl::SetUpdateVSyncParametersCallback(",Chrome,41f5b55ab27da6890af96f2f8f0f6dd5bc6cc93c,f223cb069262bb1fab90e47669e71d376f9db789,1,"void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
                                    float device_scale_factor,
                                    const gfx::ColorSpace& color_space,
                                    bool has_alpha,
                                    bool use_stencil) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (initialize_waitable_event_) {
     initialize_waitable_event_->Wait();
//flaw_line_below:
    initialize_waitable_event_ = nullptr;
//fix_flaw_line_below:
//    initialize_waitable_event_.reset();
   }
 
   SkSurfaceCharacterization* characterization = nullptr;
   if (characterization_.isValid()) {
//flaw_line_below:
    // TODO(weiliang): support color space. https://crbug.com/795132
//flaw_line_below:
    characterization_ =
//flaw_line_below:
        characterization_.createResized(size.width(), size.height());
//fix_flaw_line_below:
//    sk_sp<SkColorSpace> sk_color_space = color_space.ToSkColorSpace();
//fix_flaw_line_below:
//    if (!SkColorSpace::Equals(characterization_.refColorSpace().get(),
//fix_flaw_line_below:
//                              sk_color_space.get())) {
//fix_flaw_line_below:
//      characterization_ = characterization_.createColorSpace(sk_color_space);
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//    if (size.width() != characterization_.width() ||
//fix_flaw_line_below:
//        size.height() != characterization_.height()) {
//fix_flaw_line_below:
//      characterization_ =
//fix_flaw_line_below:
//          characterization_.createResized(size.width(), size.height());
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//    // TODO(kylechar): Update |characterization_| if |use_alpha| changes.
     RecreateRootRecorder();
   } else {
     characterization = &characterization_;
    initialize_waitable_event_ = std::make_unique<base::WaitableEvent>(
        base::WaitableEvent::ResetPolicy::MANUAL,
        base::WaitableEvent::InitialState::NOT_SIGNALED);
  }
 
   // impl_on_gpu_ is released on the GPU thread by a posted task from
   // SkiaOutputSurfaceImpl::dtor. So it is safe to use base::Unretained.
//flaw_line_below:
  auto callback = base::BindOnce(
//flaw_line_below:
      &SkiaOutputSurfaceImplOnGpu::Reshape,
//flaw_line_below:
      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,
//flaw_line_below:
      std::move(color_space), has_alpha, use_stencil, pre_transform_,
//flaw_line_below:
      characterization, initialize_waitable_event_.get());
//flaw_line_below:
  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());
//fix_flaw_line_below:
//  auto task = base::BindOnce(&SkiaOutputSurfaceImplOnGpu::Reshape,
//fix_flaw_line_below:
//                             base::Unretained(impl_on_gpu_.get()), size,
//fix_flaw_line_below:
//                             device_scale_factor, color_space, has_alpha,
//fix_flaw_line_below:
//                             use_stencil, pre_transform_, characterization,
//fix_flaw_line_below:
//                             initialize_waitable_event_.get());
//fix_flaw_line_below:
//  ScheduleGpuTask(std::move(task), {});
 }
",186285,"void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
                                    float device_scale_factor,
                                    const gfx::ColorSpace& color_space,
                                    bool has_alpha,
                                    bool use_stencil) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (initialize_waitable_event_) {
     initialize_waitable_event_->Wait();
    initialize_waitable_event_ = nullptr;
   }
 
   SkSurfaceCharacterization* characterization = nullptr;
   if (characterization_.isValid()) {
    characterization_ =
        characterization_.createResized(size.width(), size.height());
     RecreateRootRecorder();
   } else {
     characterization = &characterization_;
    initialize_waitable_event_ = std::make_unique<base::WaitableEvent>(
        base::WaitableEvent::ResetPolicy::MANUAL,
        base::WaitableEvent::InitialState::NOT_SIGNALED);
  }
 
  auto callback = base::BindOnce(
      &SkiaOutputSurfaceImplOnGpu::Reshape,
      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,
      std::move(color_space), has_alpha, use_stencil, pre_transform_,
      characterization, initialize_waitable_event_.get());
  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());
 }
","void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
                                    float device_scale_factor,
                                    const gfx::ColorSpace& color_space,
                                    bool has_alpha,
                                    bool use_stencil) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (initialize_waitable_event_) {
     initialize_waitable_event_->Wait();
    initialize_waitable_event_.reset();
   }
 
   SkSurfaceCharacterization* characterization = nullptr;
   if (characterization_.isValid()) {
    sk_sp<SkColorSpace> sk_color_space = color_space.ToSkColorSpace();
    if (!SkColorSpace::Equals(characterization_.refColorSpace().get(),
                              sk_color_space.get())) {
      characterization_ = characterization_.createColorSpace(sk_color_space);
    }
    if (size.width() != characterization_.width() ||
        size.height() != characterization_.height()) {
      characterization_ =
          characterization_.createResized(size.width(), size.height());
    }
    // TODO(kylechar): Update |characterization_| if |use_alpha| changes.
     RecreateRootRecorder();
   } else {
     characterization = &characterization_;
    initialize_waitable_event_ = std::make_unique<base::WaitableEvent>(
        base::WaitableEvent::ResetPolicy::MANUAL,
        base::WaitableEvent::InitialState::NOT_SIGNALED);
  }
 
  auto task = base::BindOnce(&SkiaOutputSurfaceImplOnGpu::Reshape,
                             base::Unretained(impl_on_gpu_.get()), size,
                             device_scale_factor, color_space, has_alpha,
                             use_stencil, pre_transform_, characterization,
                             initialize_waitable_event_.get());
  ScheduleGpuTask(std::move(task), {});
 }
","The `Reshape` function in the `SkiaOutputSurfaceImpl` class is responsible for adjusting the dimensions and properties of a graphics output surface. It first ensures that the function is called on a valid thread and waits for any initialization event to complete if necessary. The function checks if the existing surface characterization is valid; if so, it resizes it and recreates the root recorder. If not, it initializes a waitable event for synchronization. Finally, it schedules a GPU task to reshape the output surface with the specified size, device scale factor, color space, alpha channel presence, and stencil usage, using a callback to handle the operation on the GPU.","The provided code defines a method that adjusts the properties of a graphics output surface, ensuring it operates on a valid thread. It waits for any necessary initialization to complete before checking if the current surface configuration is valid. If it is, the method resizes the surface and updates its recorder; if not, it sets up a synchronization event. Finally, it schedules a task to perform the reshaping operation on the GPU, passing along the new dimensions and various attributes related to rendering, ensuring that the graphics output is correctly configured for subsequent operations.","The vulnerability identified by CWE-704, which pertains to the use of uninitialized or improperly initialized variables, was addressed in the updated code. In the original version, the `initialize_waitable_event_` was set to `nullptr` after waiting, which could lead to potential misuse if accessed later without proper checks. The fixed code ensures that `initialize_waitable_event_` is reset using `reset()` instead of setting it to `nullptr`, providing a clearer indication of its state. Additionally, the updated code checks the color space and dimensions before modifying the `characterization_`, ensuring that the surface properties are valid and initialized correctly before use.","The vulnerability identified by CWE-704 arises from the potential use of uninitialized or improperly initialized resources, which can lead to undefined behavior or crashes. In the original code, a synchronization event was set to a null state after being waited on, creating ambiguity about its readiness for future operations. The fixed code addresses this by explicitly resetting the synchronization event, ensuring that its state is clearly defined and managed. Additionally, the updated logic includes checks for the validity of properties before making modifications, thereby enhancing the robustness of the resource management and preventing misuse of uninitialized states.","The vulnerability was fixed by modifying how the `initialize_waitable_event_` is handled after it is waited on. In the original code, it was set to `nullptr`, which could lead to ambiguity regarding its state. The updated code uses `reset()` to explicitly clear the event, ensuring that its state is well-defined. Additionally, the fix introduces checks to compare the color space and dimensions before modifying `characterization_`, ensuring that it is only updated when necessary. This prevents the use of potentially uninitialized or invalid properties, thereby enhancing the overall stability and reliability of the code.","The vulnerability was addressed by improving the management of a synchronization event to ensure its state is clearly defined after use. Instead of setting the event to a null state, which could lead to confusion about its readiness for subsequent operations, the fix explicitly resets the event. Additionally, the updated code introduces validation checks for critical properties before making any modifications, ensuring that changes are only applied when necessary. This approach prevents the potential misuse of uninitialized or invalid resources, thereby enhancing the overall robustness and reliability of the code.","CWE-667,CWE-665,CWE-704,CWE-366,CWE-543,CWE-609,CWE-664,CWE-456,CWE-457,CWE-662",Y,3
5,5,186317,186317,,Remote,Not required,Partial,CVE-2017-5108,https://www.cvedetails.com/cve/CVE-2017-5108/,CWE-704,Medium,Partial,Partial,,2017-10-27,6.8,"Type confusion in PDFium in Google Chrome prior to 60.0.3112.78 for Mac, Windows, Linux, and Android allowed a remote attacker to potentially maliciously modify objects via a crafted PDF file.",2018-01-04,,2,https://github.com/chromium/chromium/commit/5cb799a393ba9e732f89f687ff3a322b4514ebfb,5cb799a393ba9e732f89f687ff3a322b4514ebfb,"autofocus: Fix a crash with an autofocus element in a document without browsing context.

ShouldAutofocus() should check existence of the browsing context.
Otherwise, doc.TopFrameOrigin() returns null.

Before crrev.com/695830, ShouldAutofocus() was called only for
rendered elements. That is to say, the document always had
browsing context.

Bug: 1003228
Change-Id: I2a941c34e9707d44869a6d7585dc7fb9f06e3bf4
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1800902
Commit-Queue: Kent Tamura <tkent@chromium.org>
Reviewed-by: Keishi Hattori <keishi@chromium.org>
Cr-Commit-Position: refs/heads/master@{#696291}",0,third_party/blink/renderer/core/html/forms/html_form_control_element.cc,"{""sha"": ""c134f907b1b8df93bd079d25ac525224c83b24db"", ""filename"": ""third_party/blink/renderer/core/html/forms/html_form_control_element.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/5cb799a393ba9e732f89f687ff3a322b4514ebfb/third_party/blink/renderer/core/html/forms/html_form_control_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5cb799a393ba9e732f89f687ff3a322b4514ebfb/third_party/blink/renderer/core/html/forms/html_form_control_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/forms/html_form_control_element.cc?ref=5cb799a393ba9e732f89f687ff3a322b4514ebfb"", ""patch"": ""@@ -234,6 +234,8 @@ static bool ShouldAutofocus(const HTMLFormControlElement* element) {\n   Document& doc = element->GetDocument();\n \n   // 3. If target's browsing context is null, then return.\n+  if (!doc.GetFrame())\n+    return false;\n \n   // 4. If target's active sandboxing flag set has the sandboxed automatic\n   // features browsing context flag, then return.""}<_**next**_>{""sha"": ""104dd5a4a5e371bf5002c7435e718d8e032fff5a"", ""filename"": ""third_party/blink/web_tests/external/wpt/html/semantics/forms/autofocus/skip-not-fully-active.html"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 1, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/5cb799a393ba9e732f89f687ff3a322b4514ebfb/third_party/blink/web_tests/external/wpt/html/semantics/forms/autofocus/skip-not-fully-active.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5cb799a393ba9e732f89f687ff3a322b4514ebfb/third_party/blink/web_tests/external/wpt/html/semantics/forms/autofocus/skip-not-fully-active.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/web_tests/external/wpt/html/semantics/forms/autofocus/skip-not-fully-active.html?ref=5cb799a393ba9e732f89f687ff3a322b4514ebfb"", ""patch"": ""@@ -8,11 +8,19 @@\n <script>\n 'use strict';\n \n+promise_test(async () => {\n+  let doc = document.cloneNode(false);\n+  doc.appendChild(doc.createElement('html'))\n+  doc.firstChild.innerHTML = '<body><input autofocus/></body>';\n+  await waitUntilStableAutofocusState();\n+  assert_equals(doc.activeElement, doc.body);\n+}, 'Autofocus element in not-fully-active document should not be queued.');\n+\n promise_test(async () => {\n   let iframe = document.querySelector('iframe');\n   let iframeDocument = iframe.contentDocument;\n   await waitForLoad(window);\n   assert_not_equals(document.activeElement, iframe);\n   assert_equals(iframeDocument.activeElement, iframeDocument.body);\n-}, 'Autofocus element in not-fully-active document should be skipped.');\n+}, 'Autofocus element in not-fully-active document should be skipped while flusing.');\n </script>""}","static bool ShouldAutofocus(const HTMLFormControlElement* element) {
  if (!element->isConnected())
    return false;
  if (!element->IsAutofocusable())
    return false;



   Document& doc = element->GetDocument();
 
  if (!doc.GetFrame())
    return false;
 
  if (doc.IsSandboxed(WebSandboxFlags::kAutomaticFeatures)) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control because the form's frame is ""
        ""sandboxed and the 'allow-scripts' permission is not set.""));
    return false;
  }

  if (!doc.IsInMainFrame() &&
      !doc.TopFrameOrigin()->CanAccess(doc.GetSecurityOrigin())) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control in a cross-origin subframe.""));
    return false;
  }

  return true;
}
","static bool ShouldAutofocus(const HTMLFormControlElement* element) {
  if (!element->isConnected())
    return false;
  if (!element->IsAutofocusable())
    return false;



   Document& doc = element->GetDocument();
 
 
  if (doc.IsSandboxed(WebSandboxFlags::kAutomaticFeatures)) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control because the form's frame is ""
        ""sandboxed and the 'allow-scripts' permission is not set.""));
    return false;
  }

  if (!doc.IsInMainFrame() &&
      !doc.TopFrameOrigin()->CanAccess(doc.GetSecurityOrigin())) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control in a cross-origin subframe.""));
    return false;
  }

  return true;
}
",C,"  if (!doc.GetFrame())
    return false;
",,,"@@ -234,6 +234,8 @@ static bool ShouldAutofocus(const HTMLFormControlElement* element) {
   Document& doc = element->GetDocument();
 
   // 3. If target's browsing context is null, then return.
+  if (!doc.GetFrame())
+    return false;
 
   // 4. If target's active sandboxing flag set has the sandboxed automatic
   // features browsing context flag, then return.",Chrome,5cb799a393ba9e732f89f687ff3a322b4514ebfb,9c7cd1e691d850ca82244fccd97d91d68b29a1d0,1,"static bool ShouldAutofocus(const HTMLFormControlElement* element) {
  // When an element with the autofocus attribute specified is inserted into a
  // document, run the following steps:
  if (!element->isConnected())
    return false;
  if (!element->IsAutofocusable())
    return false;

  // 1. If the user has indicated (for example, by starting to type in a form
  // control) that they do not wish focus to be changed, then optionally return.

  // We don't implement this optional step. If other browsers have such
  // behavior, we should follow it or standardize it.

  // 2. Let target be the element's node document.
   Document& doc = element->GetDocument();
 
   // 3. If target's browsing context is null, then return.
//fix_flaw_line_below:
//  if (!doc.GetFrame())
//fix_flaw_line_below:
//    return false;
 
   // 4. If target's active sandboxing flag set has the sandboxed automatic
   // features browsing context flag, then return.
  if (doc.IsSandboxed(WebSandboxFlags::kAutomaticFeatures)) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control because the form's frame is ""
        ""sandboxed and the 'allow-scripts' permission is not set.""));
    return false;
  }

  // 5. Let topDocument be the active document of target's browsing context's
  // top-level browsing context.
  // 6. If target's origin is not the same as the origin of topDocument,
  // then return.
  if (!doc.IsInMainFrame() &&
      !doc.TopFrameOrigin()->CanAccess(doc.GetSecurityOrigin())) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control in a cross-origin subframe.""));
    return false;
  }

  // Will call Document::EnqueueAutofocusCandidate() with |element|.
  return true;
}
",186317,"static bool ShouldAutofocus(const HTMLFormControlElement* element) {
  if (!element->isConnected())
    return false;
  if (!element->IsAutofocusable())
    return false;



   Document& doc = element->GetDocument();
 
 
  if (doc.IsSandboxed(WebSandboxFlags::kAutomaticFeatures)) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control because the form's frame is ""
        ""sandboxed and the 'allow-scripts' permission is not set.""));
    return false;
  }

  if (!doc.IsInMainFrame() &&
      !doc.TopFrameOrigin()->CanAccess(doc.GetSecurityOrigin())) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control in a cross-origin subframe.""));
    return false;
  }

  return true;
}
","static bool ShouldAutofocus(const HTMLFormControlElement* element) {
  if (!element->isConnected())
    return false;
  if (!element->IsAutofocusable())
    return false;



   Document& doc = element->GetDocument();
 
  if (!doc.GetFrame())
    return false;
 
  if (doc.IsSandboxed(WebSandboxFlags::kAutomaticFeatures)) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control because the form's frame is ""
        ""sandboxed and the 'allow-scripts' permission is not set.""));
    return false;
  }

  if (!doc.IsInMainFrame() &&
      !doc.TopFrameOrigin()->CanAccess(doc.GetSecurityOrigin())) {
    doc.AddConsoleMessage(ConsoleMessage::Create(
        mojom::ConsoleMessageSource::kSecurity,
        mojom::ConsoleMessageLevel::kError,
        ""Blocked autofocusing on a form control in a cross-origin subframe.""));
    return false;
  }

  return true;
}
","The `ShouldAutofocus` function determines whether a given HTML form control element should automatically receive focus. It first checks if the element is connected to the document and if it is capable of being focused. If the document is sandboxed without the 'allow-scripts' permission, or if the element is in a cross-origin subframe that cannot access the document's security origin, it logs an error message to the console and returns false. If all conditions are met, the function returns true, indicating that the element can be autofocused.","The code defines a function that assesses whether a form control element should automatically receive focus. It begins by verifying if the element is part of the document and if it can be focused. The function then checks if the document is restricted by sandboxing without the necessary permissions, logging an error if so. Additionally, it evaluates whether the element resides in a cross-origin frame that lacks access to the document's security context, again logging an error if this condition is met. If none of these restrictions apply, the function allows the element to be focused automatically.","The vulnerability identified by CWE-704, which pertains to incorrect handling of exceptional conditions, was present in the original code due to the lack of a check for the frame associated with the document. This oversight could lead to unintended behavior when attempting to autofocus elements in documents without a valid frame, potentially allowing unauthorized focus actions. The fixed code addresses this issue by introducing a check for `doc.GetFrame()`, ensuring that the function returns false if no frame exists. This additional validation prevents the function from proceeding under unsafe conditions, thereby enhancing security and robustness.","The vulnerability associated with CWE-704, which involves incorrect handling of exceptional conditions, was present in the original code due to the absence of a check for the existence of a frame in the document. This oversight could lead to situations where the function attempted to perform actions on elements in documents lacking a valid frame, potentially resulting in unintended behavior or security issues. The fixed code rectifies this by adding a validation step to ensure that a frame is present before proceeding, thereby preventing unsafe operations and enhancing the overall security and reliability of the function.","The vulnerability was fixed by introducing a check for the existence of a frame associated with the document. In the updated code, the condition `if (!doc.GetFrame()) return false;` was added early in the function. This ensures that if the document does not have a valid frame, the function will immediately return false, preventing any further processing that could lead to unsafe autofocus actions. This additional validation step effectively mitigates the risk of operating on elements in documents without a proper frame, thereby enhancing the security and robustness of the autofocus functionality.","The vulnerability was addressed by adding a crucial validation step to check for the presence of a valid frame associated with the document. This new condition ensures that the function will not proceed if the document lacks a frame, thereby preventing any subsequent operations that could lead to unsafe behavior. By implementing this check early in the process, the code effectively mitigates the risk of attempting to autofocus elements in contexts that are not secure or properly structured. This enhancement significantly improves the overall security and reliability of the functionality.","CWE-749, CWE-284, CWE-20, CWE-252, CWE-248, CWE-754, CWE-706, CWE-269, CWE-732, CWE-676",N,-1
6,6,187049,187049,,Remote,Not required,Partial,CVE-2019-5757,https://www.cvedetails.com/cve/CVE-2019-5757/,CWE-704,Medium,Partial,Partial,,2019-02-19,6.8,An incorrect object type assumption in SVG in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to potentially exploit object corruption via a crafted HTML page.,2019-04-18,,2,https://github.com/chromium/chromium/commit/032c3339bfb454c65ce38e7eafe49a54bac83073,032c3339bfb454c65ce38e7eafe49a54bac83073,"Fix SVG crash for v0 distribution into foreignObject.

We require a parent element to be an SVG element for non-svg-root
elements in order to create a LayoutObject for them. However, we checked
the light tree parent element, not the flat tree one which is the parent
for the layout tree construction. Note that this is just an issue in
Shadow DOM v0 since v1 does not allow shadow roots on SVG elements.

Bug: 915469
Change-Id: Id81843abad08814fae747b5bc81c09666583f130
Reviewed-on: https://chromium-review.googlesource.com/c/1382494
Reviewed-by: Fredrik Sderquist <fs@opera.com>
Commit-Queue: Rune Lillesveen <futhark@chromium.org>
Cr-Commit-Position: refs/heads/master@{#617487}",2,third_party/blink/renderer/core/svg/svg_element.cc,"{""sha"": ""b39b8168ec7c68ea811ec1f6f2be9f01a4c76405"", ""filename"": ""third_party/blink/renderer/core/svg/svg_element.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/032c3339bfb454c65ce38e7eafe49a54bac83073/third_party/blink/renderer/core/svg/svg_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/032c3339bfb454c65ce38e7eafe49a54bac83073/third_party/blink/renderer/core/svg/svg_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/svg/svg_element.cc?ref=032c3339bfb454c65ce38e7eafe49a54bac83073"", ""patch"": ""@@ -37,6 +37,7 @@\n #include \""third_party/blink/renderer/core/dom/document.h\""\n #include \""third_party/blink/renderer/core/dom/element_traversal.h\""\n #include \""third_party/blink/renderer/core/dom/events/event.h\""\n+#include \""third_party/blink/renderer/core/dom/flat_tree_traversal.h\""\n #include \""third_party/blink/renderer/core/dom/node_computed_style.h\""\n #include \""third_party/blink/renderer/core/dom/shadow_root.h\""\n #include \""third_party/blink/renderer/core/frame/csp/content_security_policy.h\""\n@@ -1034,10 +1035,8 @@ bool SVGElement::LayoutObjectIsNeeded(const ComputedStyle& style) const {\n }\n \n bool SVGElement::HasSVGParent() const {\n-  // Should we use the flat tree parent instead? If so, we should probably fix a\n-  // few other checks.\n-  return ParentOrShadowHostElement() &&\n-         ParentOrShadowHostElement()->IsSVGElement();\n+  Element* parent = FlatTreeTraversal::ParentElement(*this);\n+  return parent && parent->IsSVGElement();\n }\n \n MutableCSSPropertyValueSet* SVGElement::AnimatedSMILStyleProperties() const {""}<_**next**_>{""sha"": ""44ac3b0540b8f5a816a67b5be382b179623bd0cd"", ""filename"": ""third_party/blink/web_tests/svg/foreignObject/shadow-dom-v0-crash.html"", ""status"": ""added"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/032c3339bfb454c65ce38e7eafe49a54bac83073/third_party/blink/web_tests/svg/foreignObject/shadow-dom-v0-crash.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/032c3339bfb454c65ce38e7eafe49a54bac83073/third_party/blink/web_tests/svg/foreignObject/shadow-dom-v0-crash.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/web_tests/svg/foreignObject/shadow-dom-v0-crash.html?ref=032c3339bfb454c65ce38e7eafe49a54bac83073"", ""patch"": ""@@ -0,0 +1,11 @@\n+<!DOCTYPE html>\n+<script src=\""../../resources/testharness.js\""></script>\n+<script src=\""../../resources/testharnessreport.js\""></script>\n+<p>PASS if no crash or DCHECK failure.</p>\n+<svg id=\""svg\""><g /></svg>\n+<script>\n+  test(() => {\n+    const root = svg.createShadowRoot();\n+    root.innerHTML = '<foreignObject><div><content></content></div></foreignObject>';\n+  }, \""Rendering an svg g element distributed into a foreignObject will crash.\"");\n+</script>""}"," bool SVGElement::HasSVGParent() const {
  Element* parent = FlatTreeTraversal::ParentElement(*this);
  return parent && parent->IsSVGElement();
 }
"," bool SVGElement::HasSVGParent() const {
  return ParentOrShadowHostElement() &&
         ParentOrShadowHostElement()->IsSVGElement();
 }
",C,"  Element* parent = FlatTreeTraversal::ParentElement(*this);
  return parent && parent->IsSVGElement();
","  return ParentOrShadowHostElement() &&
         ParentOrShadowHostElement()->IsSVGElement();
",,"@@ -37,6 +37,7 @@
 #include ""third_party/blink/renderer/core/dom/document.h""
 #include ""third_party/blink/renderer/core/dom/element_traversal.h""
 #include ""third_party/blink/renderer/core/dom/events/event.h""
+#include ""third_party/blink/renderer/core/dom/flat_tree_traversal.h""
 #include ""third_party/blink/renderer/core/dom/node_computed_style.h""
 #include ""third_party/blink/renderer/core/dom/shadow_root.h""
 #include ""third_party/blink/renderer/core/frame/csp/content_security_policy.h""
@@ -1034,10 +1035,8 @@ bool SVGElement::LayoutObjectIsNeeded(const ComputedStyle& style) const {
 }
 
 bool SVGElement::HasSVGParent() const {
-  // Should we use the flat tree parent instead? If so, we should probably fix a
-  // few other checks.
-  return ParentOrShadowHostElement() &&
-         ParentOrShadowHostElement()->IsSVGElement();
+  Element* parent = FlatTreeTraversal::ParentElement(*this);
+  return parent && parent->IsSVGElement();
 }
 
 MutableCSSPropertyValueSet* SVGElement::AnimatedSMILStyleProperties() const {",Chrome,032c3339bfb454c65ce38e7eafe49a54bac83073,7917a910e959b8e46a16cde1391d2b681e64d4a8,1," bool SVGElement::HasSVGParent() const {
//flaw_line_below:
  // Should we use the flat tree parent instead? If so, we should probably fix a
//flaw_line_below:
  // few other checks.
//flaw_line_below:
  return ParentOrShadowHostElement() &&
//flaw_line_below:
         ParentOrShadowHostElement()->IsSVGElement();
//fix_flaw_line_below:
//  Element* parent = FlatTreeTraversal::ParentElement(*this);
//fix_flaw_line_below:
//  return parent && parent->IsSVGElement();
 }
",187049," bool SVGElement::HasSVGParent() const {
  return ParentOrShadowHostElement() &&
         ParentOrShadowHostElement()->IsSVGElement();
 }
"," bool SVGElement::HasSVGParent() const {
  Element* parent = FlatTreeTraversal::ParentElement(*this);
  return parent && parent->IsSVGElement();
 }
","The `HasSVGParent` function is a member of the `SVGElement` class that checks whether the current SVG element has a parent element that is also an SVG element. It first calls the `ParentOrShadowHostElement()` method to retrieve the parent or shadow host of the current element. If a parent exists, it then verifies if this parent is an SVG element by invoking the `IsSVGElement()` method on it. The function returns a boolean value: `true` if the current element has an SVG parent, and `false` otherwise, effectively determining the SVG hierarchy of the element.",The provided code defines a method that determines if a specific element belongs to an SVG hierarchy by checking its parent element. It first retrieves the parent or shadow host of the current element and then assesses whether this parent is also an SVG element. The method returns a boolean value indicating the presence of an SVG parent: it returns true if the current element has an SVG parent and false if it does not. This functionality is essential for understanding the structural relationships within SVG documents and ensuring proper rendering and behavior of SVG elements.,"The vulnerability identified by CWE-704, which pertains to the use of uninitialized or improperly checked pointers, is evident in the original code where the parent element is accessed without ensuring its validity. In the fixed code, the method retrieves the parent element using a traversal function, storing it in a variable before checking its validity. This change ensures that the parent is explicitly assigned and verified, preventing potential dereferencing of a null or invalid pointer. By using `FlatTreeTraversal::ParentElement(*this)`, the fixed code enhances safety and reliability in determining whether the current element has an SVG parent.","The vulnerability associated with CWE-704 arises from the potential dereferencing of a null or invalid pointer in the original code, which checks for a parent element without ensuring it is properly initialized. This oversight could lead to undefined behavior or crashes if the parent does not exist. The fixed code addresses this issue by first retrieving the parent element and storing it in a variable, allowing for a clear and explicit validity check before any further operations. This change enhances the robustness of the code by ensuring that only valid pointers are accessed, thereby preventing potential runtime errors.","The vulnerability was fixed by modifying the method to first retrieve the parent element using the `FlatTreeTraversal::ParentElement(*this)` function and storing it in a variable named `parent`. This approach ensures that the parent element is explicitly assigned before any checks are performed. The subsequent condition then verifies both the existence of the `parent` and whether it is an SVG element by calling `parent->IsSVGElement()`. This change prevents the potential dereferencing of a null pointer, thereby enhancing the safety and reliability of the code when determining if the current element has an SVG parent.","The vulnerability was addressed by restructuring the method to first retrieve and store the parent element in a variable before performing any checks. This ensures that the parent is explicitly defined and allows for a clear validation of its existence. By checking the validity of the parent element before proceeding to determine its type, the revised code prevents the risk of dereferencing a null or invalid pointer. This enhancement significantly improves the robustness of the code, ensuring that only valid elements are accessed and reducing the likelihood of runtime errors or crashes.","CWE-476, CWE-690, CWE-754, CWE-1254, CWE-685, CWE-456, CWE-628, CWE-822, CWE-415, CWE-119",N,-1
7,7,188116,188116,,Remote,Not required,Complete,CVE-2018-9490,https://www.cvedetails.com/cve/CVE-2018-9490/,CWE-704,Medium,Complete,Complete,,2018-10-02,9.3,"In CollectValuesOrEntriesImpl of elements.cc, there is possible remote code execution due to type confusion. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android. Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111274046",2018-12-28,Exec Code ,36,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb,a24543157ae2cdd25da43e20f4e48a07481e6ceb,"Backport: Fix Object.entries/values with changing elements

Bug: 111274046
Test: m -j proxy_resolver_v8_unittest && adb sync && adb shell \
/data/nativetest64/proxy_resolver_v8_unittest/proxy_resolver_v8_unittest
Change-Id: I705fc512cc5837e9364ed187559cc75d079aa5cb
(cherry picked from commit d8be9a10287afed07705ac8af027d6a46d4def99)
",5,src/elements.cc,"{""filename"": ""src/elements.cc"", ""raw_url"": ""https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/src/elements.cc"", ""patch"": ""@@ -511,6 +511,21 @@\n\n   return Just<int64_t>(-1);\n }\n \n+// The InternalElementsAccessor is a helper class to expose otherwise protected\n+// methods to its subclasses. Namely, we don't want to publicly expose methods\n+// that take an entry (instead of an index) as an argument.\n+class InternalElementsAccessor : public ElementsAccessor {\n+ public:\n+  explicit InternalElementsAccessor(const char* name)\n+      : ElementsAccessor(name) {}\n+\n+  virtual uint32_t GetEntryForIndex(Isolate* isolate, JSObject* holder,\n+                                    FixedArrayBase* backing_store,\n+                                    uint32_t index) = 0;\n+\n+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n+};\n+\n // Base class for element handler implementations. Contains the\n // the common logic for objects with different ElementsKinds.\n // Subclasses must specialize method for which the element\n@@ -529,10 +544,10 @@\n\n // CRTP to guarantee aggressive compile time optimizations (i.e.  inlining and\n // specialization of SomeElementsAccessor methods).\n template <typename Subclass, typename ElementsTraitsParam>\n-class ElementsAccessorBase : public ElementsAccessor {\n+class ElementsAccessorBase : public InternalElementsAccessor {\n  public:\n   explicit ElementsAccessorBase(const char* name)\n-      : ElementsAccessor(name) { }\n+      : InternalElementsAccessor(name) {}\n \n   typedef ElementsTraitsParam ElementsTraits;\n   typedef typename ElementsTraitsParam::BackingStore BackingStore;\n@@ -1014,35 +1029,66 @@\n\n       Isolate* isolate, Handle<JSObject> object,\n       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,\n       PropertyFilter filter) {\n-    int count = 0;\n+    DCHECK_EQ(*nof_items, 0);\n     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,\n                                ALL_PROPERTIES);\n     Subclass::CollectElementIndicesImpl(\n         object, handle(object->elements(), isolate), &accumulator);\n     Handle<FixedArray> keys = accumulator.GetKeys();\n \n-    for (int i = 0; i < keys->length(); ++i) {\n+    int count = 0;\n+    int i = 0;\n+    Handle<Map> original_map(object->map(), isolate);\n+\n+    for (; i < keys->length(); ++i) {\n       Handle<Object> key(keys->get(i), isolate);\n-      Handle<Object> value;\n       uint32_t index;\n       if (!key->ToUint32(&index)) continue;\n \n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = Subclass::GetEntryForIndexImpl(\n           isolate, *object, object->elements(), index, filter);\n       if (entry == kMaxUInt32) continue;\n \n       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);\n \n+      Handle<Object> value;\n       if (details.kind() == kData) {\n         value = Subclass::GetImpl(isolate, object->elements(), entry);\n       } else {\n+        // This might modify the elements and/or change the elements kind.\n         LookupIterator it(isolate, object, index, LookupIterator::OWN);\n         ASSIGN_RETURN_ON_EXCEPTION_VALUE(\n             isolate, value, Object::GetProperty(&it), Nothing<bool>());\n       }\n-      if (get_entries) {\n-        value = MakeEntryPair(isolate, index, value);\n+      if (get_entries) value = MakeEntryPair(isolate, index, value);\n+      values_or_entries->set(count++, *value);\n+      if (object->map() != *original_map) break;\n+    }\n+\n+    // Slow path caused by changes in elements kind during iteration.\n+    for (; i < keys->length(); i++) {\n+      Handle<Object> key(keys->get(i), isolate);\n+      uint32_t index;\n+      if (!key->ToUint32(&index)) continue;\n+\n+      if (filter & ONLY_ENUMERABLE) {\n+        InternalElementsAccessor* accessor =\n+            reinterpret_cast<InternalElementsAccessor*>(\n+                object->GetElementsAccessor());\n+        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,\n+                                                    object->elements(), index);\n+        if (entry == kMaxUInt32) continue;\n+        PropertyDetails details = accessor->GetDetails(*object, entry);\n+        if (!details.IsEnumerable()) continue;\n       }\n+\n+      Handle<Object> value;\n+      LookupIterator it(isolate, object, index, LookupIterator::OWN);\n+      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),\n+                                       Nothing<bool>());\n+\n+      if (get_entries) value = MakeEntryPair(isolate, index, value);\n       values_or_entries->set(count++, *value);\n     }\n \n@@ -1623,12 +1669,13 @@\n\n         return result;\n       }\n     }\n-\n+    Handle<Map> original_map(receiver->map(), isolate);\n     Handle<SeededNumberDictionary> dictionary(\n         SeededNumberDictionary::cast(receiver->elements()), isolate);\n     // Iterate through entire range, as accessing elements out of order is\n     // observable\n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(receiver->map(), *original_map);\n       int entry = dictionary->FindEntry(isolate, k);\n       if (entry == SeededNumberDictionary::kNotFound) {\n         if (search_for_hole) return Just(true);\n@@ -1690,11 +1737,13 @@\n\n                                          uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));\n \n+    Handle<Map> original_map(receiver->map(), isolate);\n     Handle<SeededNumberDictionary> dictionary(\n         SeededNumberDictionary::cast(receiver->elements()), isolate);\n     // Iterate through entire range, as accessing elements out of order is\n     // observable.\n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(receiver->map(), *original_map);\n       int entry = dictionary->FindEntry(isolate, k);\n       if (entry == SeededNumberDictionary::kNotFound) {\n         continue;\n@@ -3170,12 +3219,13 @@\n\n                                        Handle<Object> value,\n                                        uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n-    Handle<Map> original_map = handle(object->map(), isolate);\n+    Handle<Map> original_map(object->map(), isolate);\n     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                      isolate);\n     bool search_for_hole = value->IsUndefined(isolate);\n \n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                             ALL_PROPERTIES);\n       if (entry == kMaxUInt32) {\n@@ -3212,11 +3262,12 @@\n\n                                          Handle<Object> value,\n                                          uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n-    Handle<Map> original_map = handle(object->map(), isolate);\n+    Handle<Map> original_map(object->map(), isolate);\n     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                      isolate);\n \n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                             ALL_PROPERTIES);\n       if (entry == kMaxUInt32) {\n""}<_**next**_>{""filename"": ""src/elements.h"", ""raw_url"": ""https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/src/elements.h"", ""patch"": ""@@ -54,7 +54,6 @@\n\n \n   virtual Handle<Object> Get(Handle<JSObject> holder, uint32_t entry) = 0;\n \n-  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n   virtual bool HasAccessors(JSObject* holder) = 0;\n   virtual uint32_t NumberOfElements(JSObject* holder) = 0;\n \n@@ -65,9 +64,6 @@\n\n   // element that is non-deletable.\n   virtual void SetLength(Handle<JSArray> holder, uint32_t new_length) = 0;\n \n-  // Deletes an element in an object.\n-  virtual void Delete(Handle<JSObject> holder, uint32_t entry) = 0;\n-\n   // If kCopyToEnd is specified as the copy_size to CopyElements, it copies all\n   // of elements from source after source_start to the destination array.\n   static const int kCopyToEnd = -1;\n@@ -124,11 +120,6 @@\n\n \n   virtual void Set(Handle<JSObject> holder, uint32_t entry, Object* value) = 0;\n \n-  virtual void Reconfigure(Handle<JSObject> object,\n-                           Handle<FixedArrayBase> backing_store, uint32_t entry,\n-                           Handle<Object> value,\n-                           PropertyAttributes attributes) = 0;\n-\n   virtual void Add(Handle<JSObject> object, uint32_t index,\n                    Handle<Object> value, PropertyAttributes attributes,\n                    uint32_t new_capacity) = 0;\n@@ -193,6 +184,15 @@\n\n                                     FixedArrayBase* backing_store,\n                                     uint32_t index) = 0;\n \n+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;\n+  virtual void Reconfigure(Handle<JSObject> object,\n+                           Handle<FixedArrayBase> backing_store, uint32_t entry,\n+                           Handle<Object> value,\n+                           PropertyAttributes attributes) = 0;\n+\n+  // Deletes an element in an object.\n+  virtual void Delete(Handle<JSObject> holder, uint32_t entry) = 0;\n+\n   // NOTE: this method violates the handlified function signature convention:\n   // raw pointer parameter |source_holder| in the function that allocates.\n   // This is done intentionally to avoid ArrayConcat() builtin performance\n""}"," static Maybe<bool> CollectValuesOrEntriesImpl(

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
    DCHECK_EQ(*nof_items, 0);
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
    int count = 0;
    int i = 0;
    Handle<Map> original_map(object->map(), isolate);

    for (; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
      Handle<Object> value;
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
        // This might modify the elements and/or change the elements kind.
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
      if (get_entries) value = MakeEntryPair(isolate, index, value);
      values_or_entries->set(count++, *value);
      if (object->map() != *original_map) break;
    }

    // Slow path caused by changes in elements kind during iteration.
    for (; i < keys->length(); i++) {
      Handle<Object> key(keys->get(i), isolate);
      uint32_t index;
      if (!key->ToUint32(&index)) continue;

      if (filter & ONLY_ENUMERABLE) {
        InternalElementsAccessor* accessor =
            reinterpret_cast<InternalElementsAccessor*>(
                object->GetElementsAccessor());
        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,
                                                    object->elements(), index);
        if (entry == kMaxUInt32) continue;
        PropertyDetails details = accessor->GetDetails(*object, entry);
        if (!details.IsEnumerable()) continue;
       }

      Handle<Object> value;
      LookupIterator it(isolate, object, index, LookupIterator::OWN);
      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
                                       Nothing<bool>());

      if (get_entries) value = MakeEntryPair(isolate, index, value);
       values_or_entries->set(count++, *value);
     }
 
 *nof_items = count;
 return Just(true);
 }
"," static Maybe<bool> CollectValuesOrEntriesImpl(

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
    int count = 0;
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
    for (int i = 0; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
      Handle<Object> value;
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
      if (get_entries) {
        value = MakeEntryPair(isolate, index, value);
       }
       values_or_entries->set(count++, *value);
     }
 
 *nof_items = count;
 return Just(true);
 }
",C,"    DCHECK_EQ(*nof_items, 0);
    int count = 0;
    int i = 0;
    Handle<Map> original_map(object->map(), isolate);

    for (; i < keys->length(); ++i) {
      DCHECK_EQ(object->map(), *original_map);
      Handle<Object> value;
        // This might modify the elements and/or change the elements kind.
      if (get_entries) value = MakeEntryPair(isolate, index, value);
      values_or_entries->set(count++, *value);
      if (object->map() != *original_map) break;
    }

    // Slow path caused by changes in elements kind during iteration.
    for (; i < keys->length(); i++) {
      Handle<Object> key(keys->get(i), isolate);
      uint32_t index;
      if (!key->ToUint32(&index)) continue;

      if (filter & ONLY_ENUMERABLE) {
        InternalElementsAccessor* accessor =
            reinterpret_cast<InternalElementsAccessor*>(
                object->GetElementsAccessor());
        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,
                                                    object->elements(), index);
        if (entry == kMaxUInt32) continue;
        PropertyDetails details = accessor->GetDetails(*object, entry);
        if (!details.IsEnumerable()) continue;

      Handle<Object> value;
      LookupIterator it(isolate, object, index, LookupIterator::OWN);
      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
                                       Nothing<bool>());

      if (get_entries) value = MakeEntryPair(isolate, index, value);
","    int count = 0;
    for (int i = 0; i < keys->length(); ++i) {
      Handle<Object> value;
      if (get_entries) {
        value = MakeEntryPair(isolate, index, value);
",,"@@ -511,6 +511,21 @@

   return Just<int64_t>(-1);
 }
 
+// The InternalElementsAccessor is a helper class to expose otherwise protected
+// methods to its subclasses. Namely, we don't want to publicly expose methods
+// that take an entry (instead of an index) as an argument.
+class InternalElementsAccessor : public ElementsAccessor {
+ public:
+  explicit InternalElementsAccessor(const char* name)
+      : ElementsAccessor(name) {}
+
+  virtual uint32_t GetEntryForIndex(Isolate* isolate, JSObject* holder,
+                                    FixedArrayBase* backing_store,
+                                    uint32_t index) = 0;
+
+  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;
+};
+
 // Base class for element handler implementations. Contains the
 // the common logic for objects with different ElementsKinds.
 // Subclasses must specialize method for which the element
@@ -529,10 +544,10 @@

 // CRTP to guarantee aggressive compile time optimizations (i.e.  inlining and
 // specialization of SomeElementsAccessor methods).
 template <typename Subclass, typename ElementsTraitsParam>
-class ElementsAccessorBase : public ElementsAccessor {
+class ElementsAccessorBase : public InternalElementsAccessor {
  public:
   explicit ElementsAccessorBase(const char* name)
-      : ElementsAccessor(name) { }
+      : InternalElementsAccessor(name) {}
 
   typedef ElementsTraitsParam ElementsTraits;
   typedef typename ElementsTraitsParam::BackingStore BackingStore;
@@ -1014,35 +1029,66 @@

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
-    int count = 0;
+    DCHECK_EQ(*nof_items, 0);
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
-    for (int i = 0; i < keys->length(); ++i) {
+    int count = 0;
+    int i = 0;
+    Handle<Map> original_map(object->map(), isolate);
+
+    for (; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
-      Handle<Object> value;
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
+      Handle<Object> value;
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
+        // This might modify the elements and/or change the elements kind.
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
-      if (get_entries) {
-        value = MakeEntryPair(isolate, index, value);
+      if (get_entries) value = MakeEntryPair(isolate, index, value);
+      values_or_entries->set(count++, *value);
+      if (object->map() != *original_map) break;
+    }
+
+    // Slow path caused by changes in elements kind during iteration.
+    for (; i < keys->length(); i++) {
+      Handle<Object> key(keys->get(i), isolate);
+      uint32_t index;
+      if (!key->ToUint32(&index)) continue;
+
+      if (filter & ONLY_ENUMERABLE) {
+        InternalElementsAccessor* accessor =
+            reinterpret_cast<InternalElementsAccessor*>(
+                object->GetElementsAccessor());
+        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,
+                                                    object->elements(), index);
+        if (entry == kMaxUInt32) continue;
+        PropertyDetails details = accessor->GetDetails(*object, entry);
+        if (!details.IsEnumerable()) continue;
       }
+
+      Handle<Object> value;
+      LookupIterator it(isolate, object, index, LookupIterator::OWN);
+      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
+                                       Nothing<bool>());
+
+      if (get_entries) value = MakeEntryPair(isolate, index, value);
       values_or_entries->set(count++, *value);
     }
 
@@ -1623,12 +1669,13 @@

         return result;
       }
     }
-
+    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     // Iterate through entire range, as accessing elements out of order is
     // observable
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         if (search_for_hole) return Just(true);
@@ -1690,11 +1737,13 @@

                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
 
+    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
     // Iterate through entire range, as accessing elements out of order is
     // observable.
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         continue;
@@ -3170,12 +3219,13 @@

                                        Handle<Object> value,
                                        uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
-    Handle<Map> original_map = handle(object->map(), isolate);
+    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
     bool search_for_hole = value->IsUndefined(isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
@@ -3212,11 +3262,12 @@

                                          Handle<Object> value,
                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
-    Handle<Map> original_map = handle(object->map(), isolate);
+    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
+      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
",Android,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb/,https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb%5E/,1," static Maybe<bool> CollectValuesOrEntriesImpl(

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
//flaw_line_below:
    int count = 0;
//fix_flaw_line_below:
//    DCHECK_EQ(*nof_items, 0);
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
//flaw_line_below:
    for (int i = 0; i < keys->length(); ++i) {
//fix_flaw_line_below:
//    int count = 0;
//fix_flaw_line_below:
//    int i = 0;
//fix_flaw_line_below:
//    Handle<Map> original_map(object->map(), isolate);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    for (; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
//flaw_line_below:
      Handle<Object> value;
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
//fix_flaw_line_below:
//      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
//fix_flaw_line_below:
//      Handle<Object> value;
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
//fix_flaw_line_below:
//        // This might modify the elements and/or change the elements kind.
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
//flaw_line_below:
      if (get_entries) {
//flaw_line_below:
        value = MakeEntryPair(isolate, index, value);
//fix_flaw_line_below:
//      if (get_entries) value = MakeEntryPair(isolate, index, value);
//fix_flaw_line_below:
//      values_or_entries->set(count++, *value);
//fix_flaw_line_below:
//      if (object->map() != *original_map) break;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    // Slow path caused by changes in elements kind during iteration.
//fix_flaw_line_below:
//    for (; i < keys->length(); i++) {
//fix_flaw_line_below:
//      Handle<Object> key(keys->get(i), isolate);
//fix_flaw_line_below:
//      uint32_t index;
//fix_flaw_line_below:
//      if (!key->ToUint32(&index)) continue;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//      if (filter & ONLY_ENUMERABLE) {
//fix_flaw_line_below:
//        InternalElementsAccessor* accessor =
//fix_flaw_line_below:
//            reinterpret_cast<InternalElementsAccessor*>(
//fix_flaw_line_below:
//                object->GetElementsAccessor());
//fix_flaw_line_below:
//        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,
//fix_flaw_line_below:
//                                                    object->elements(), index);
//fix_flaw_line_below:
//        if (entry == kMaxUInt32) continue;
//fix_flaw_line_below:
//        PropertyDetails details = accessor->GetDetails(*object, entry);
//fix_flaw_line_below:
//        if (!details.IsEnumerable()) continue;
       }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//      Handle<Object> value;
//fix_flaw_line_below:
//      LookupIterator it(isolate, object, index, LookupIterator::OWN);
//fix_flaw_line_below:
//      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
//fix_flaw_line_below:
//                                       Nothing<bool>());
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//      if (get_entries) value = MakeEntryPair(isolate, index, value);
       values_or_entries->set(count++, *value);
     }
 
 *nof_items = count;
 return Just(true);
 }
",188116," static Maybe<bool> CollectValuesOrEntriesImpl(

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
    int count = 0;
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
    for (int i = 0; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
      Handle<Object> value;
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
      if (get_entries) {
        value = MakeEntryPair(isolate, index, value);
       }
       values_or_entries->set(count++, *value);
     }
 
 *nof_items = count;
 return Just(true);
 }
"," static Maybe<bool> CollectValuesOrEntriesImpl(

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
    DCHECK_EQ(*nof_items, 0);
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
    int count = 0;
    int i = 0;
    Handle<Map> original_map(object->map(), isolate);

    for (; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
      Handle<Object> value;
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
        // This might modify the elements and/or change the elements kind.
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
      if (get_entries) value = MakeEntryPair(isolate, index, value);
      values_or_entries->set(count++, *value);
      if (object->map() != *original_map) break;
    }

    // Slow path caused by changes in elements kind during iteration.
    for (; i < keys->length(); i++) {
      Handle<Object> key(keys->get(i), isolate);
      uint32_t index;
      if (!key->ToUint32(&index)) continue;

      if (filter & ONLY_ENUMERABLE) {
        InternalElementsAccessor* accessor =
            reinterpret_cast<InternalElementsAccessor*>(
                object->GetElementsAccessor());
        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,
                                                    object->elements(), index);
        if (entry == kMaxUInt32) continue;
        PropertyDetails details = accessor->GetDetails(*object, entry);
        if (!details.IsEnumerable()) continue;
       }

      Handle<Object> value;
      LookupIterator it(isolate, object, index, LookupIterator::OWN);
      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
                                       Nothing<bool>());

      if (get_entries) value = MakeEntryPair(isolate, index, value);
       values_or_entries->set(count++, *value);
     }
 
 *nof_items = count;
 return Just(true);
 }
","The `CollectValuesOrEntriesImpl` function is designed to collect either property values or entries from a JavaScript object within a V8 isolate. It initializes a key accumulator to gather keys from the object's own properties and iterates through these keys to retrieve corresponding values or entries based on the specified `get_entries` flag. For each key, it checks if it can convert the key to a uint32 index and retrieves the associated entry. Depending on the property type, it either fetches the value directly or uses a lookup iterator. The collected values or entries are stored in a provided `FixedArray`, and the function returns a success status along with the count of items collected.","The function is responsible for gathering either property values or entries from a specified JavaScript object within a particular execution context. It begins by initializing a mechanism to collect keys from the object's own properties and iterates through these keys to obtain their corresponding values or entries based on a specified condition. For each key, it checks if it can be converted to an index and retrieves the associated entry. Depending on the type of property, it either directly fetches the value or uses an iterator for lookup. The collected results are stored in a provided array, and the function indicates success along with the count of items collected.","The vulnerability identified by CWE-704, which pertains to the use of uninitialized or stale data, was present in the original code due to the potential modification of the object's internal structure during iteration. Specifically, the original code did not verify if the object's map had changed while collecting values or entries, which could lead to inconsistent or incorrect data being processed. The fix introduced a check using `DCHECK_EQ` to ensure that the object's map remains unchanged throughout the iteration. Additionally, a secondary loop was added to handle cases where the elements' kind might change, ensuring that the integrity of the collected data is maintained.","The vulnerability associated with CWE-704 arises from the potential for data inconsistency during the iteration process, as the internal structure of the object could be modified while values or entries are being collected. This could lead to the use of stale or incorrect data, resulting in unpredictable behavior or errors. The fix implemented a safeguard to verify that the object's structure remains unchanged throughout the iteration. Additionally, a secondary mechanism was introduced to handle scenarios where modifications might occur, ensuring that the integrity of the collected data is preserved and that the function operates reliably.","The vulnerability was fixed by introducing a check to ensure that the object's map remains unchanged during the iteration process. This was accomplished by storing the original map in a variable and using `DCHECK_EQ` to compare it with the current map at each iteration. If a change is detected, the loop breaks to prevent further processing of potentially inconsistent data. Additionally, a secondary loop was added to handle cases where the elements' kind might change, allowing for a more robust collection of values or entries while maintaining data integrity throughout the operation.","The vulnerability was addressed by implementing a mechanism to verify that the object's internal structure remains consistent throughout the data collection process. This involved storing the original state of the object and checking it against the current state during iteration. If any changes were detected, the iteration would terminate early to prevent the use of potentially stale or incorrect data. Additionally, a secondary loop was introduced to handle scenarios where modifications to the object's elements might occur, ensuring that the integrity of the collected data is maintained and that the function operates reliably under varying conditions.","CWE-665, CWE-664, CWE-374, CWE-366, CWE-367, CWE-488, CWE-471, CWE-672, CWE-833, CWE-375",N,-1
