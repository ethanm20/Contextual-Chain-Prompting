,Unnamed: 0.3,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,G1_Clarity_C3_C5,G2_Relevance_C3_C5,G3_Completeness_C3_C5,G4_Actionability_C3_C5,T1_Top_10_CWE_IDs,T2_Correctly_Found_CWE,T3_IFA
0,0,0,180887,180887,,Remote,Not required,,CVE-2017-15906,https://www.cvedetails.com/cve/CVE-2017-15906/,CWE-269,Low,,Partial,,2017-10-25,5.0,"The process_open function in sftp-server.c in OpenSSH before 7.6 does not properly prevent write operations in readonly mode, which allows attackers to create zero-length files.",2019-10-02,,2,https://github.com/openbsd/src/commit/a6981567e8e215acc1ef690c8dbb30f2d9b00a19,a6981567e8e215acc1ef690c8dbb30f2d9b00a19,"disallow creation (of empty files) in read-only mode; reported by
Michal Zalewski, feedback & ok deraadt@",2,usr.bin/ssh/sftp-server.c,"{""sha"": ""42249ebd60d0f46a2219d61203a30e0da65d38ec"", ""filename"": ""usr.bin/ssh/sftp-server.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/openbsd/src/blob/a6981567e8e215acc1ef690c8dbb30f2d9b00a19/usr.bin/ssh/sftp-server.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/a6981567e8e215acc1ef690c8dbb30f2d9b00a19/usr.bin/ssh/sftp-server.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/sftp-server.c?ref=a6981567e8e215acc1ef690c8dbb30f2d9b00a19"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: sftp-server.c,v 1.110 2016/09/12 01:22:38 deraadt Exp $ */\n+/* $OpenBSD: sftp-server.c,v 1.111 2017/04/04 00:24:56 djm Exp $ */\n /*\n  * Copyright (c) 2000-2004 Markus Friedl.  All rights reserved.\n  *\n@@ -683,8 +683,8 @@ process_open(u_int32_t id)\n \tlogit(\""open \\\""%s\\\"" flags %s mode 0%o\"",\n \t    name, string_from_portable(pflags), mode);\n \tif (readonly &&\n-\t    ((flags & O_ACCMODE) == O_WRONLY ||\n-\t    (flags & O_ACCMODE) == O_RDWR)) {\n+\t    ((flags & O_ACCMODE) != O_RDONLY ||\n+\t    (flags & (O_CREAT|O_TRUNC)) != 0)) {\n \t\tverbose(\""Refusing open request in read-only mode\"");\n \t\tstatus = SSH2_FX_PERMISSION_DENIED;\n \t} else {""}","process_open(u_int32_t id)
{
	u_int32_t pflags;
	Attrib a;
	char *name;
	int r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;

	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||
	    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */
	    (r = decode_attrib(iqueue, &a)) != 0)
		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));

	debug3(""request %u: open flags %d"", id, pflags);
	flags = flags_from_portable(pflags);
	mode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;
 	logit(""open \""%s\"" flags %s mode 0%o"",
 	    name, string_from_portable(pflags), mode);
 	if (readonly &&
	    ((flags & O_ACCMODE) != O_RDONLY ||
	    (flags & (O_CREAT|O_TRUNC)) != 0)) {
 		verbose(""Refusing open request in read-only mode"");
 		status = SSH2_FX_PERMISSION_DENIED;
 	} else {
		fd = open(name, flags, mode);
		if (fd < 0) {
			status = errno_to_portable(errno);
		} else {
			handle = handle_new(HANDLE_FILE, name, fd, flags, NULL);
			if (handle < 0) {
				close(fd);
			} else {
				send_handle(id, handle);
				status = SSH2_FX_OK;
			}
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	free(name);
}
","process_open(u_int32_t id)
{
	u_int32_t pflags;
	Attrib a;
	char *name;
	int r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;

	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||
	    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */
	    (r = decode_attrib(iqueue, &a)) != 0)
		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));

	debug3(""request %u: open flags %d"", id, pflags);
	flags = flags_from_portable(pflags);
	mode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;
 	logit(""open \""%s\"" flags %s mode 0%o"",
 	    name, string_from_portable(pflags), mode);
 	if (readonly &&
	    ((flags & O_ACCMODE) == O_WRONLY ||
	    (flags & O_ACCMODE) == O_RDWR)) {
 		verbose(""Refusing open request in read-only mode"");
 		status = SSH2_FX_PERMISSION_DENIED;
 	} else {
		fd = open(name, flags, mode);
		if (fd < 0) {
			status = errno_to_portable(errno);
		} else {
			handle = handle_new(HANDLE_FILE, name, fd, flags, NULL);
			if (handle < 0) {
				close(fd);
			} else {
				send_handle(id, handle);
				status = SSH2_FX_OK;
			}
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	free(name);
}
",C,"	    ((flags & O_ACCMODE) != O_RDONLY ||
	    (flags & (O_CREAT|O_TRUNC)) != 0)) {
","	    ((flags & O_ACCMODE) == O_WRONLY ||
	    (flags & O_ACCMODE) == O_RDWR)) {
",,"@@ -1,4 +1,4 @@
-/* $OpenBSD: sftp-server.c,v 1.110 2016/09/12 01:22:38 deraadt Exp $ */
+/* $OpenBSD: sftp-server.c,v 1.111 2017/04/04 00:24:56 djm Exp $ */
 /*
  * Copyright (c) 2000-2004 Markus Friedl.  All rights reserved.
  *
@@ -683,8 +683,8 @@ process_open(u_int32_t id)
 	logit(""open \""%s\"" flags %s mode 0%o"",
 	    name, string_from_portable(pflags), mode);
 	if (readonly &&
-	    ((flags & O_ACCMODE) == O_WRONLY ||
-	    (flags & O_ACCMODE) == O_RDWR)) {
+	    ((flags & O_ACCMODE) != O_RDONLY ||
+	    (flags & (O_CREAT|O_TRUNC)) != 0)) {
 		verbose(""Refusing open request in read-only mode"");
 		status = SSH2_FX_PERMISSION_DENIED;
 	} else {",src,a6981567e8e215acc1ef690c8dbb30f2d9b00a19,f7bf1b90edbc30ad71b90a869e7a850ec6700918,1,"process_open(u_int32_t id)
{
	u_int32_t pflags;
	Attrib a;
	char *name;
	int r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;

	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||
	    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */
	    (r = decode_attrib(iqueue, &a)) != 0)
		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));

	debug3(""request %u: open flags %d"", id, pflags);
	flags = flags_from_portable(pflags);
	mode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;
 	logit(""open \""%s\"" flags %s mode 0%o"",
 	    name, string_from_portable(pflags), mode);
 	if (readonly &&
//flaw_line_below:
	    ((flags & O_ACCMODE) == O_WRONLY ||
//flaw_line_below:
	    (flags & O_ACCMODE) == O_RDWR)) {
//fix_flaw_line_below:
//	    ((flags & O_ACCMODE) != O_RDONLY ||
//fix_flaw_line_below:
//	    (flags & (O_CREAT|O_TRUNC)) != 0)) {
 		verbose(""Refusing open request in read-only mode"");
 		status = SSH2_FX_PERMISSION_DENIED;
 	} else {
		fd = open(name, flags, mode);
		if (fd < 0) {
			status = errno_to_portable(errno);
		} else {
			handle = handle_new(HANDLE_FILE, name, fd, flags, NULL);
			if (handle < 0) {
				close(fd);
			} else {
				send_handle(id, handle);
				status = SSH2_FX_OK;
			}
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	free(name);
}
",180887,"process_open(u_int32_t id)
{
	u_int32_t pflags;
	Attrib a;
	char *name;
	int r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;

	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||
	    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */
	    (r = decode_attrib(iqueue, &a)) != 0)
		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));

	debug3(""request %u: open flags %d"", id, pflags);
	flags = flags_from_portable(pflags);
	mode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;
 	logit(""open \""%s\"" flags %s mode 0%o"",
 	    name, string_from_portable(pflags), mode);
 	if (readonly &&
	    ((flags & O_ACCMODE) == O_WRONLY ||
	    (flags & O_ACCMODE) == O_RDWR)) {
 		verbose(""Refusing open request in read-only mode"");
 		status = SSH2_FX_PERMISSION_DENIED;
 	} else {
		fd = open(name, flags, mode);
		if (fd < 0) {
			status = errno_to_portable(errno);
		} else {
			handle = handle_new(HANDLE_FILE, name, fd, flags, NULL);
			if (handle < 0) {
				close(fd);
			} else {
				send_handle(id, handle);
				status = SSH2_FX_OK;
			}
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	free(name);
}
","process_open(u_int32_t id)
{
	u_int32_t pflags;
	Attrib a;
	char *name;
	int r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;

	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||
	    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */
	    (r = decode_attrib(iqueue, &a)) != 0)
		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));

	debug3(""request %u: open flags %d"", id, pflags);
	flags = flags_from_portable(pflags);
	mode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;
 	logit(""open \""%s\"" flags %s mode 0%o"",
 	    name, string_from_portable(pflags), mode);
 	if (readonly &&
	    ((flags & O_ACCMODE) != O_RDONLY ||
	    (flags & (O_CREAT|O_TRUNC)) != 0)) {
 		verbose(""Refusing open request in read-only mode"");
 		status = SSH2_FX_PERMISSION_DENIED;
 	} else {
		fd = open(name, flags, mode);
		if (fd < 0) {
			status = errno_to_portable(errno);
		} else {
			handle = handle_new(HANDLE_FILE, name, fd, flags, NULL);
			if (handle < 0) {
				close(fd);
			} else {
				send_handle(id, handle);
				status = SSH2_FX_OK;
			}
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	free(name);
}
","The `process_open` function handles file opening requests in a secure shell (SSH) context. It retrieves the requested file name, portable flags, and attributes from a buffer, checking for errors during this process. The function logs the request details and determines the appropriate file access mode based on the provided flags and permissions. If the system is in read-only mode, it denies write access. If the file can be opened, it creates a new handle for the file and sends it back to the requester; otherwise, it returns an error status. Finally, it frees the allocated memory for the file name.","The function processes file opening requests within a secure shell environment by extracting necessary information from a buffer, including the file name and access flags. It logs the request details and determines the appropriate permissions for the file based on the extracted attributes. If the system is set to read-only mode, it denies any write access attempts. Upon successfully opening the file, it creates a handle for it and sends this handle back to the requester. If any errors occur during the process, an appropriate error status is returned, and any allocated resources are released.","The vulnerability identified by CWE-269, which relates to improper privilege management, was present in the original code due to insufficient checks on the access flags when opening files. Specifically, the code allowed write access even in read-only mode if the flags were not explicitly checked against both read-only conditions and the creation or truncation flags. The fixed code enhances security by ensuring that if the system is in read-only mode, it explicitly denies any open requests that attempt to write or create files, thereby preventing unauthorized modifications and ensuring proper privilege enforcement.","The vulnerability associated with CWE-269, which pertains to improper privilege management, arose from inadequate validation of access permissions when handling file open requests. In the original code, the system could inadvertently allow write operations even when it was supposed to be in read-only mode, as it did not sufficiently check the access flags against specific conditions. The fixed code addresses this issue by implementing stricter checks to ensure that any attempt to open files for writing or creation is explicitly denied when the system is in read-only mode, thereby reinforcing proper privilege enforcement and preventing unauthorized access.","The vulnerability was fixed by enhancing the conditional checks related to access flags in the code. In the revised version, the condition that checks if the system is in read-only mode now explicitly verifies that the flags do not allow for write access by ensuring that the flags do not include write-only or read-write modes, as well as checking that the creation or truncation flags are not set. This is achieved through the updated condition that combines checks for both read-only access and the presence of specific flags, thereby preventing unauthorized file modifications and ensuring proper privilege management.","The vulnerability was fixed by implementing stricter validation of access permissions when processing file open requests. The updated code introduces additional checks to ensure that if the system is in read-only mode, any attempts to open files for writing or creation are explicitly denied. This is accomplished by refining the conditions that evaluate the access flags, ensuring that only read access is permitted under these circumstances. By enforcing these checks, the code effectively prevents unauthorized modifications and reinforces proper privilege management, thereby mitigating the risk of exploitation associated with the original implementation.","4, 4","5,5","4,4","4,3","CWE-732, CWE-285, CWE-284, CWE-269, CWE-264, CWE-669, CWE-552, CWE-732, CWE-275, CWE-266",N,-1
1,1,1,181590,181590,,Local,Not required,Complete,CVE-2017-5207,https://www.cvedetails.com/cve/CVE-2017-5207/,CWE-269,Low,Complete,Complete,,2017-03-23,7.2,"Firejail before 0.9.44.4, when running a bandwidth command, allows local users to gain root privileges via the --shell argument.",2019-10-02,+Priv ,1,https://github.com/netblue30/firejail/commit/5d43fdcd215203868d440ffc42036f5f5ffc89fc,5d43fdcd215203868d440ffc42036f5f5ffc89fc,security fix,7,src/firejail/bandwidth.c,"{""sha"": ""b9a982d776a62e8200bbf0db7916d8ccece262a4"", ""filename"": ""RELNOTES"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/netblue30/firejail/blob/5d43fdcd215203868d440ffc42036f5f5ffc89fc/RELNOTES"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/5d43fdcd215203868d440ffc42036f5f5ffc89fc/RELNOTES"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/RELNOTES?ref=5d43fdcd215203868d440ffc42036f5f5ffc89fc"", ""patch"": ""@@ -1,5 +1,6 @@\n firejail (0.9.45) baseline; urgency=low\n   * development version, work in progress\n+  * security: --bandwidth root shel found by Martin Carpenter\n   * security: disabled --allow-debuggers when running on kernel\n     versions prior to 4.8; a kernel bug in ptrace system call\n     allows a full bypass of seccomp filter; problem reported by Lizzie Dixon""}<_**next**_>{""sha"": ""84c9dc53a331e5787941bf31dd3b7ba5dbe77e2f"", ""filename"": ""src/firejail/bandwidth.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 8, ""changes"": 9, ""blob_url"": ""https://github.com/netblue30/firejail/blob/5d43fdcd215203868d440ffc42036f5f5ffc89fc/src/firejail/bandwidth.c"", ""raw_url"": ""https://github.com/netblue30/firejail/raw/5d43fdcd215203868d440ffc42036f5f5ffc89fc/src/firejail/bandwidth.c"", ""contents_url"": ""https://api.github.com/repos/netblue30/firejail/contents/src/firejail/bandwidth.c?ref=5d43fdcd215203868d440ffc42036f5f5ffc89fc"", ""patch"": ""@@ -435,15 +435,8 @@ void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, in\n \tif (setregid(0, 0))\n \t\terrExit(\""setregid\"");\n \n-\tif (!cfg.shell)\n-\t\tcfg.shell = guess_shell();\n-\tif (!cfg.shell) {\n-\t\tfprintf(stderr, \""Error: no POSIX shell found, please use --shell command line option\\n\"");\n-\t\texit(1);\n-\t}\n-\n \tchar *arg[4];\n-\targ[0] = cfg.shell;\n+\targ[0] = \""/bin/sh\"";\n \targ[1] = \""-c\"";\n \targ[2] = cmd;\n \targ[3] = NULL;""}","void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) {
	EUID_ASSERT();
	EUID_ROOT();
	char *comm = pid_proc_comm(pid);
	EUID_USER();
	if (!comm) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}

	if (strcmp(comm, ""firejail"") != 0) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}
	free(comm);
	
	char *name;
	if (asprintf(&name, ""/run/firejail/network/%d-netmap"", pid) == -1)
		errExit(""asprintf"");
	struct stat s;
	if (stat(name, &s) == -1) {
		fprintf(stderr, ""Error: the sandbox doesn't use a new network namespace\n"");
		exit(1);
	}

	pid_t child;
	if (find_child(pid, &child) == -1) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	EUID_ROOT();
	if (join_namespace(child, ""net"")) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	if (strcmp(command, ""set"") == 0)
		bandwidth_set(pid, dev, down, up);
	else if (strcmp(command, ""clear"") == 0)
		bandwidth_remove(pid, dev);

	char *devname = NULL;
	if (dev) {
		char *fname;
		if (asprintf(&fname, ""%s/%d-netmap"", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)
			errExit(""asprintf"");
		FILE *fp = fopen(fname, ""r"");
		if (!fp) {
			fprintf(stderr, ""Error: cannot read network map file %s\n"", fname);
			exit(1);
		}
		
		char buf[1024];
		int len = strlen(dev);
		while (fgets(buf, 1024, fp)) {
			char *ptr = strchr(buf, '\n');
			if (ptr)
				*ptr = '\0';
			if (*buf == '\0')
				break;

			if (strncmp(buf, dev, len) == 0  && buf[len] == ':') {
				devname = strdup(buf + len + 1);
				if (!devname)
					errExit(""strdup"");
				if (if_nametoindex(devname) == 0) {
					fprintf(stderr, ""Error: cannot find network device %s\n"", devname);
					exit(1);
				}
				break;
			}
		}
		free(fname);
		fclose(fp);
	}
	
	char *cmd = NULL;
	if (devname) {
		if (strcmp(command, ""set"") == 0) {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s %d %d"",
				LIBDIR, command, devname, down, up) == -1)
				errExit(""asprintf"");
		}
		else {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s"",
				LIBDIR, command, devname) == -1)
				errExit(""asprintf"");
		}
	}
	else {
		if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s"", LIBDIR, command) == -1)
			errExit(""asprintf"");
	}
	assert(cmd);

	environ = NULL;

	if (setreuid(0, 0))
		errExit(""setreuid"");
 	if (setregid(0, 0))
 		errExit(""setregid"");
 
 	char *arg[4];
	arg[0] = ""/bin/sh"";
 	arg[1] = ""-c"";
 	arg[2] = cmd;
 	arg[3] = NULL;
	clearenv();
	execvp(arg[0], arg);
	
	errExit(""execvp"");
}
","void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) {
	EUID_ASSERT();
	EUID_ROOT();
	char *comm = pid_proc_comm(pid);
	EUID_USER();
	if (!comm) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}

	if (strcmp(comm, ""firejail"") != 0) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}
	free(comm);
	
	char *name;
	if (asprintf(&name, ""/run/firejail/network/%d-netmap"", pid) == -1)
		errExit(""asprintf"");
	struct stat s;
	if (stat(name, &s) == -1) {
		fprintf(stderr, ""Error: the sandbox doesn't use a new network namespace\n"");
		exit(1);
	}

	pid_t child;
	if (find_child(pid, &child) == -1) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	EUID_ROOT();
	if (join_namespace(child, ""net"")) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	if (strcmp(command, ""set"") == 0)
		bandwidth_set(pid, dev, down, up);
	else if (strcmp(command, ""clear"") == 0)
		bandwidth_remove(pid, dev);

	char *devname = NULL;
	if (dev) {
		char *fname;
		if (asprintf(&fname, ""%s/%d-netmap"", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)
			errExit(""asprintf"");
		FILE *fp = fopen(fname, ""r"");
		if (!fp) {
			fprintf(stderr, ""Error: cannot read network map file %s\n"", fname);
			exit(1);
		}
		
		char buf[1024];
		int len = strlen(dev);
		while (fgets(buf, 1024, fp)) {
			char *ptr = strchr(buf, '\n');
			if (ptr)
				*ptr = '\0';
			if (*buf == '\0')
				break;

			if (strncmp(buf, dev, len) == 0  && buf[len] == ':') {
				devname = strdup(buf + len + 1);
				if (!devname)
					errExit(""strdup"");
				if (if_nametoindex(devname) == 0) {
					fprintf(stderr, ""Error: cannot find network device %s\n"", devname);
					exit(1);
				}
				break;
			}
		}
		free(fname);
		fclose(fp);
	}
	
	char *cmd = NULL;
	if (devname) {
		if (strcmp(command, ""set"") == 0) {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s %d %d"",
				LIBDIR, command, devname, down, up) == -1)
				errExit(""asprintf"");
		}
		else {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s"",
				LIBDIR, command, devname) == -1)
				errExit(""asprintf"");
		}
	}
	else {
		if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s"", LIBDIR, command) == -1)
			errExit(""asprintf"");
	}
	assert(cmd);

	environ = NULL;

	if (setreuid(0, 0))
		errExit(""setreuid"");
 	if (setregid(0, 0))
 		errExit(""setregid"");
 
	if (!cfg.shell)
		cfg.shell = guess_shell();
	if (!cfg.shell) {
		fprintf(stderr, ""Error: no POSIX shell found, please use --shell command line option\n"");
		exit(1);
	}
 	char *arg[4];
	arg[0] = cfg.shell;
 	arg[1] = ""-c"";
 	arg[2] = cmd;
 	arg[3] = NULL;
	clearenv();
	execvp(arg[0], arg);
	
	errExit(""execvp"");
}
",C,"	arg[0] = ""/bin/sh"";
","	if (!cfg.shell)
		cfg.shell = guess_shell();
	if (!cfg.shell) {
		fprintf(stderr, ""Error: no POSIX shell found, please use --shell command line option\n"");
		exit(1);
	}
	arg[0] = cfg.shell;
",,"@@ -435,15 +435,8 @@ void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, in
 	if (setregid(0, 0))
 		errExit(""setregid"");
 
-	if (!cfg.shell)
-		cfg.shell = guess_shell();
-	if (!cfg.shell) {
-		fprintf(stderr, ""Error: no POSIX shell found, please use --shell command line option\n"");
-		exit(1);
-	}
-
 	char *arg[4];
-	arg[0] = cfg.shell;
+	arg[0] = ""/bin/sh"";
 	arg[1] = ""-c"";
 	arg[2] = cmd;
 	arg[3] = NULL;",firejail,5d43fdcd215203868d440ffc42036f5f5ffc89fc,6435525696e8eda2d1bc0ef50488523422b9126d,1,"void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) {
	EUID_ASSERT();
	//************************
	// verify sandbox
	//************************
	EUID_ROOT();
	char *comm = pid_proc_comm(pid);
	EUID_USER();
	if (!comm) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}

	// check for firejail sandbox
	if (strcmp(comm, ""firejail"") != 0) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}
	free(comm);
	
	// check network namespace
	char *name;
	if (asprintf(&name, ""/run/firejail/network/%d-netmap"", pid) == -1)
		errExit(""asprintf"");
	struct stat s;
	if (stat(name, &s) == -1) {
		fprintf(stderr, ""Error: the sandbox doesn't use a new network namespace\n"");
		exit(1);
	}

	//************************
	// join the network namespace
	//************************
	pid_t child;
	if (find_child(pid, &child) == -1) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	EUID_ROOT();
	if (join_namespace(child, ""net"")) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	// set run file
	if (strcmp(command, ""set"") == 0)
		bandwidth_set(pid, dev, down, up);
	else if (strcmp(command, ""clear"") == 0)
		bandwidth_remove(pid, dev);

	//************************
	// build command
	//************************
	char *devname = NULL;
	if (dev) {
		// read network map file
		char *fname;
		if (asprintf(&fname, ""%s/%d-netmap"", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)
			errExit(""asprintf"");
		FILE *fp = fopen(fname, ""r"");
		if (!fp) {
			fprintf(stderr, ""Error: cannot read network map file %s\n"", fname);
			exit(1);
		}
		
		char buf[1024];
		int len = strlen(dev);
		while (fgets(buf, 1024, fp)) {
			// remove '\n'
			char *ptr = strchr(buf, '\n');
			if (ptr)
				*ptr = '\0';
			if (*buf == '\0')
				break;

			if (strncmp(buf, dev, len) == 0  && buf[len] == ':') {
				devname = strdup(buf + len + 1);
				if (!devname)
					errExit(""strdup"");
				// check device in namespace
				if (if_nametoindex(devname) == 0) {
					fprintf(stderr, ""Error: cannot find network device %s\n"", devname);
					exit(1);
				}
				break;
			}
		}
		free(fname);
		fclose(fp);
	}
	
	// build fshaper.sh command
	char *cmd = NULL;
	if (devname) {
		if (strcmp(command, ""set"") == 0) {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s %d %d"",
				LIBDIR, command, devname, down, up) == -1)
				errExit(""asprintf"");
		}
		else {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s"",
				LIBDIR, command, devname) == -1)
				errExit(""asprintf"");
		}
	}
	else {
		if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s"", LIBDIR, command) == -1)
			errExit(""asprintf"");
	}
	assert(cmd);

	// wipe out environment variables
	environ = NULL;

	//************************
	// build command
	//************************
	// elevate privileges
	if (setreuid(0, 0))
		errExit(""setreuid"");
 	if (setregid(0, 0))
 		errExit(""setregid"");
 
//flaw_line_below:
	if (!cfg.shell)
//flaw_line_below:
		cfg.shell = guess_shell();
//flaw_line_below:
	if (!cfg.shell) {
//flaw_line_below:
		fprintf(stderr, ""Error: no POSIX shell found, please use --shell command line option\n"");
//flaw_line_below:
		exit(1);
//flaw_line_below:
	}
//flaw_line_below:

 	char *arg[4];
//flaw_line_below:
	arg[0] = cfg.shell;
//fix_flaw_line_below:
//	arg[0] = ""/bin/sh"";
 	arg[1] = ""-c"";
 	arg[2] = cmd;
 	arg[3] = NULL;
	clearenv();
	execvp(arg[0], arg);
	
	// it will never get here
	errExit(""execvp"");
}
",181590,"void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) {
	EUID_ASSERT();
	EUID_ROOT();
	char *comm = pid_proc_comm(pid);
	EUID_USER();
	if (!comm) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}

	if (strcmp(comm, ""firejail"") != 0) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}
	free(comm);
	
	char *name;
	if (asprintf(&name, ""/run/firejail/network/%d-netmap"", pid) == -1)
		errExit(""asprintf"");
	struct stat s;
	if (stat(name, &s) == -1) {
		fprintf(stderr, ""Error: the sandbox doesn't use a new network namespace\n"");
		exit(1);
	}

	pid_t child;
	if (find_child(pid, &child) == -1) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	EUID_ROOT();
	if (join_namespace(child, ""net"")) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	if (strcmp(command, ""set"") == 0)
		bandwidth_set(pid, dev, down, up);
	else if (strcmp(command, ""clear"") == 0)
		bandwidth_remove(pid, dev);

	char *devname = NULL;
	if (dev) {
		char *fname;
		if (asprintf(&fname, ""%s/%d-netmap"", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)
			errExit(""asprintf"");
		FILE *fp = fopen(fname, ""r"");
		if (!fp) {
			fprintf(stderr, ""Error: cannot read network map file %s\n"", fname);
			exit(1);
		}
		
		char buf[1024];
		int len = strlen(dev);
		while (fgets(buf, 1024, fp)) {
			char *ptr = strchr(buf, '\n');
			if (ptr)
				*ptr = '\0';
			if (*buf == '\0')
				break;

			if (strncmp(buf, dev, len) == 0  && buf[len] == ':') {
				devname = strdup(buf + len + 1);
				if (!devname)
					errExit(""strdup"");
				if (if_nametoindex(devname) == 0) {
					fprintf(stderr, ""Error: cannot find network device %s\n"", devname);
					exit(1);
				}
				break;
			}
		}
		free(fname);
		fclose(fp);
	}
	
	char *cmd = NULL;
	if (devname) {
		if (strcmp(command, ""set"") == 0) {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s %d %d"",
				LIBDIR, command, devname, down, up) == -1)
				errExit(""asprintf"");
		}
		else {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s"",
				LIBDIR, command, devname) == -1)
				errExit(""asprintf"");
		}
	}
	else {
		if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s"", LIBDIR, command) == -1)
			errExit(""asprintf"");
	}
	assert(cmd);

	environ = NULL;

	if (setreuid(0, 0))
		errExit(""setreuid"");
 	if (setregid(0, 0))
 		errExit(""setregid"");
 
	if (!cfg.shell)
		cfg.shell = guess_shell();
	if (!cfg.shell) {
		fprintf(stderr, ""Error: no POSIX shell found, please use --shell command line option\n"");
		exit(1);
	}
 	char *arg[4];
	arg[0] = cfg.shell;
 	arg[1] = ""-c"";
 	arg[2] = cmd;
 	arg[3] = NULL;
	clearenv();
	execvp(arg[0], arg);
	
	errExit(""execvp"");
}
","void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) {
	EUID_ASSERT();
	EUID_ROOT();
	char *comm = pid_proc_comm(pid);
	EUID_USER();
	if (!comm) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}

	if (strcmp(comm, ""firejail"") != 0) {
		fprintf(stderr, ""Error: cannot find sandbox\n"");
		exit(1);
	}
	free(comm);
	
	char *name;
	if (asprintf(&name, ""/run/firejail/network/%d-netmap"", pid) == -1)
		errExit(""asprintf"");
	struct stat s;
	if (stat(name, &s) == -1) {
		fprintf(stderr, ""Error: the sandbox doesn't use a new network namespace\n"");
		exit(1);
	}

	pid_t child;
	if (find_child(pid, &child) == -1) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	EUID_ROOT();
	if (join_namespace(child, ""net"")) {
		fprintf(stderr, ""Error: cannot join the network namespace\n"");
		exit(1);
	}

	if (strcmp(command, ""set"") == 0)
		bandwidth_set(pid, dev, down, up);
	else if (strcmp(command, ""clear"") == 0)
		bandwidth_remove(pid, dev);

	char *devname = NULL;
	if (dev) {
		char *fname;
		if (asprintf(&fname, ""%s/%d-netmap"", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)
			errExit(""asprintf"");
		FILE *fp = fopen(fname, ""r"");
		if (!fp) {
			fprintf(stderr, ""Error: cannot read network map file %s\n"", fname);
			exit(1);
		}
		
		char buf[1024];
		int len = strlen(dev);
		while (fgets(buf, 1024, fp)) {
			char *ptr = strchr(buf, '\n');
			if (ptr)
				*ptr = '\0';
			if (*buf == '\0')
				break;

			if (strncmp(buf, dev, len) == 0  && buf[len] == ':') {
				devname = strdup(buf + len + 1);
				if (!devname)
					errExit(""strdup"");
				if (if_nametoindex(devname) == 0) {
					fprintf(stderr, ""Error: cannot find network device %s\n"", devname);
					exit(1);
				}
				break;
			}
		}
		free(fname);
		fclose(fp);
	}
	
	char *cmd = NULL;
	if (devname) {
		if (strcmp(command, ""set"") == 0) {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s %d %d"",
				LIBDIR, command, devname, down, up) == -1)
				errExit(""asprintf"");
		}
		else {
			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s"",
				LIBDIR, command, devname) == -1)
				errExit(""asprintf"");
		}
	}
	else {
		if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s"", LIBDIR, command) == -1)
			errExit(""asprintf"");
	}
	assert(cmd);

	environ = NULL;

	if (setreuid(0, 0))
		errExit(""setreuid"");
 	if (setregid(0, 0))
 		errExit(""setregid"");
 
 	char *arg[4];
	arg[0] = ""/bin/sh"";
 	arg[1] = ""-c"";
 	arg[2] = cmd;
 	arg[3] = NULL;
	clearenv();
	execvp(arg[0], arg);
	
	errExit(""execvp"");
}
","The `bandwidth_pid` function manages network bandwidth settings for a specified process identified by its PID, ensuring it operates within a Firejail sandbox. It first verifies that the process is running under Firejail and checks for a valid network namespace. Depending on the command (""set"" or ""clear""), it either applies bandwidth limits or removes them for a specified network device. The function constructs a command to invoke a shell script for bandwidth shaping, sets the necessary user and group IDs to root, and executes the command in a new shell environment. Error handling is implemented throughout to ensure robustness.","The code manages network bandwidth settings for a specified process within a sandbox environment. It verifies that the process is running under a specific security framework and checks for a valid network namespace. Based on the provided command, it either sets bandwidth limits or removes them for a designated network device. The code constructs a command to execute a shell script responsible for bandwidth shaping, adjusts user permissions to root, and runs the command in a new shell environment. Throughout the process, it includes error handling to ensure proper execution and user feedback in case of issues.","The vulnerability identified by CWE-269, which relates to improper privilege management, was present in the original code due to the lack of adequate checks before executing commands with elevated privileges. Specifically, the code allowed arbitrary commands to be executed without validating the input, which could lead to privilege escalation. In the fixed code, the execution context is more securely managed by ensuring that the process is running in a controlled environment, verifying the sandbox's identity, and using a specific shell for command execution. This reduces the risk of executing unintended or malicious commands, thereby enhancing security.","The vulnerability associated with CWE-269 arises from improper privilege management, allowing potentially malicious commands to be executed with elevated permissions. In the original code, there were insufficient checks to ensure that the commands being run were safe and appropriate for the context, which could lead to privilege escalation. The fixed code addresses this issue by implementing stricter validation of the execution environment, ensuring that commands are only executed within a controlled and verified context. This enhancement significantly reduces the risk of executing unintended or harmful commands, thereby improving the overall security of the application.","The vulnerability was fixed by enhancing the validation and control over command execution. The code now verifies that the process is running within a specific sandbox by checking the process name with `pid_proc_comm`, ensuring it matches the expected environment. Additionally, the code uses `setreuid` and `setregid` to securely set user and group IDs to root only after confirming the environment's integrity. The command is constructed using a specific shell, and the environment is cleared with `clearenv`, which mitigates the risk of executing arbitrary commands, thus improving the security of the privilege management process.","The vulnerability was addressed by implementing stricter checks to ensure that commands are executed only within a verified and secure environment. The code now confirms that the process is operating within a specific sandbox, preventing unauthorized access. Additionally, it establishes user and group permissions securely before executing any commands, which helps to mitigate the risk of privilege escalation. By constructing commands for execution in a controlled manner and clearing the environment beforehand, the code significantly reduces the likelihood of executing unintended or malicious commands, thereby enhancing overall security.","4, 4","5,5","5,5","4,4","CWE-78, CWE-269, CWE-250, CWE-284, CWE-426, CWE-266, CWE-265, CWE-749, CWE-88, CWE-77",N,-1
2,2,2,182325,182325,,Local,Not required,Partial,CVE-2018-13405,https://www.cvedetails.com/cve/CVE-2018-13405/,CWE-269,Low,Partial,Partial,,2018-07-06,4.6,"The inode_init_owner function in fs/inode.c in the Linux kernel through 4.17.4 allows local users to create files with an unintended group ownership, in a scenario where a directory is SGID to a certain group and is writable by a user who is not a member of that group. Here, the non-member can trigger creation of a plain file whose group ownership is that group. The intended behavior was that the non-member can trigger creation of a directory (but not a plain file) whose group ownership is that group. The non-member can escalate privileges by making the plain file executable and SGID.",2019-10-02,,6,https://github.com/torvalds/linux/commit/0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7,0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7,"Fix up non-directory creation in SGID directories

sgid directories have special semantics, making newly created files in
the directory belong to the group of the directory, and newly created
subdirectories will also become sgid.  This is historically used for
group-shared directories.

But group directories writable by non-group members should not imply
that such non-group members can magically join the group, so make sure
to clear the sgid bit on non-directories for non-members (but remember
that sgid without group execute means ""mandatory locking"", just to
confuse things even more).

Reported-by: Jann Horn <jannh@google.com>
Cc: Andy Lutomirski <luto@kernel.org>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,fs/inode.c,"{""sha"": ""8c86c809ca17b30e003913e169626aa42df2e908"", ""filename"": ""fs/inode.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7/fs/inode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7/fs/inode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/inode.c?ref=0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7"", ""patch"": ""@@ -1999,8 +1999,14 @@ void inode_init_owner(struct inode *inode, const struct inode *dir,\n \tinode->i_uid = current_fsuid();\n \tif (dir && dir->i_mode & S_ISGID) {\n \t\tinode->i_gid = dir->i_gid;\n+\n+\t\t/* Directories are special, and always inherit S_ISGID */\n \t\tif (S_ISDIR(mode))\n \t\t\tmode |= S_ISGID;\n+\t\telse if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&\n+\t\t\t !in_group_p(inode->i_gid) &&\n+\t\t\t !capable_wrt_inode_uidgid(dir, CAP_FSETID))\n+\t\t\tmode &= ~S_ISGID;\n \t} else\n \t\tinode->i_gid = current_fsgid();\n \tinode->i_mode = mode;""}","void inode_init_owner(struct inode *inode, const struct inode *dir,
			umode_t mode)
{
 	inode->i_uid = current_fsuid();
 	if (dir && dir->i_mode & S_ISGID) {
 		inode->i_gid = dir->i_gid;

		/* Directories are special, and always inherit S_ISGID */
 		if (S_ISDIR(mode))
 			mode |= S_ISGID;
		else if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&
			 !in_group_p(inode->i_gid) &&
			 !capable_wrt_inode_uidgid(dir, CAP_FSETID))
			mode &= ~S_ISGID;
 	} else
 		inode->i_gid = current_fsgid();
 	inode->i_mode = mode;
}
","void inode_init_owner(struct inode *inode, const struct inode *dir,
			umode_t mode)
{
 	inode->i_uid = current_fsuid();
 	if (dir && dir->i_mode & S_ISGID) {
 		inode->i_gid = dir->i_gid;
 		if (S_ISDIR(mode))
 			mode |= S_ISGID;
 	} else
 		inode->i_gid = current_fsgid();
 	inode->i_mode = mode;
}
",C,"
		/* Directories are special, and always inherit S_ISGID */
		else if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&
			 !in_group_p(inode->i_gid) &&
			 !capable_wrt_inode_uidgid(dir, CAP_FSETID))
			mode &= ~S_ISGID;
",,,"@@ -1999,8 +1999,14 @@ void inode_init_owner(struct inode *inode, const struct inode *dir,
 	inode->i_uid = current_fsuid();
 	if (dir && dir->i_mode & S_ISGID) {
 		inode->i_gid = dir->i_gid;
+
+		/* Directories are special, and always inherit S_ISGID */
 		if (S_ISDIR(mode))
 			mode |= S_ISGID;
+		else if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&
+			 !in_group_p(inode->i_gid) &&
+			 !capable_wrt_inode_uidgid(dir, CAP_FSETID))
+			mode &= ~S_ISGID;
 	} else
 		inode->i_gid = current_fsgid();
 	inode->i_mode = mode;",linux,0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7,d02d21ea007b6b33cdaf15c2f84fb1fea996ecc2,1,"void inode_init_owner(struct inode *inode, const struct inode *dir,
			umode_t mode)
{
 	inode->i_uid = current_fsuid();
 	if (dir && dir->i_mode & S_ISGID) {
 		inode->i_gid = dir->i_gid;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//		/* Directories are special, and always inherit S_ISGID */
 		if (S_ISDIR(mode))
 			mode |= S_ISGID;
//fix_flaw_line_below:
//		else if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&
//fix_flaw_line_below:
//			 !in_group_p(inode->i_gid) &&
//fix_flaw_line_below:
//			 !capable_wrt_inode_uidgid(dir, CAP_FSETID))
//fix_flaw_line_below:
//			mode &= ~S_ISGID;
 	} else
 		inode->i_gid = current_fsgid();
 	inode->i_mode = mode;
}
",182325,"void inode_init_owner(struct inode *inode, const struct inode *dir,
			umode_t mode)
{
 	inode->i_uid = current_fsuid();
 	if (dir && dir->i_mode & S_ISGID) {
 		inode->i_gid = dir->i_gid;
 		if (S_ISDIR(mode))
 			mode |= S_ISGID;
 	} else
 		inode->i_gid = current_fsgid();
 	inode->i_mode = mode;
}
","void inode_init_owner(struct inode *inode, const struct inode *dir,
			umode_t mode)
{
 	inode->i_uid = current_fsuid();
 	if (dir && dir->i_mode & S_ISGID) {
 		inode->i_gid = dir->i_gid;

		/* Directories are special, and always inherit S_ISGID */
 		if (S_ISDIR(mode))
 			mode |= S_ISGID;
		else if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&
			 !in_group_p(inode->i_gid) &&
			 !capable_wrt_inode_uidgid(dir, CAP_FSETID))
			mode &= ~S_ISGID;
 	} else
 		inode->i_gid = current_fsgid();
 	inode->i_mode = mode;
}
","The `inode_init_owner` function initializes the ownership and permissions of a newly created inode in a filesystem. It sets the inode's user ID (`i_uid`) to the current filesystem user ID. If the parent directory (`dir`) exists and has the setgid bit set, the inode's group ID (`i_gid`) is inherited from the directory, and if the new inode is a directory, the setgid bit is also applied to its mode. If the directory does not exist or lacks the setgid bit, the inode's group ID is set to the current filesystem group ID, and the mode is assigned as specified.","The provided code initializes the ownership and permissions of a newly created file system object. It assigns the user identifier based on the current user context. If a parent directory is specified and has a specific permission set, the new object inherits the group identifier from that directory, and if the object is a directory itself, it also receives that specific permission. If the parent directory is not specified or does not have the specific permission, the group identifier is set based on the current group context, while the permissions are set according to the provided mode.","The vulnerability in the original code, identified as CWE-269, arises from improper handling of the setgid permission when creating new files or directories. In the vulnerable version, if a parent directory has the setgid bit set, the new object's group identifier is inherited without adequate checks, potentially allowing unauthorized users to gain elevated permissions. The fixed code introduces additional conditions to ensure that the setgid bit is only retained if the new object is a directory or if the user belongs to the group associated with the inherited group identifier. This prevents unauthorized privilege escalation by ensuring proper permission checks are enforced.","The vulnerability identified as CWE-269 in the original code stems from inadequate checks when inheriting group permissions, specifically the setgid bit, from a parent directory. This oversight allowed unauthorized users to potentially gain elevated privileges on newly created files or directories, as the permissions were inherited without proper validation. The fixed code addresses this issue by implementing additional conditions that ensure the setgid bit is only applied under specific circumstances, such as when the new object is a directory or when the user belongs to the appropriate group. This enhancement effectively mitigates the risk of privilege escalation.","The vulnerability was fixed by adding checks to ensure that the setgid bit is only retained under appropriate conditions. In the updated code, after inheriting the group identifier from the parent directory, it checks if the mode indicates a directory or if the mode includes both the setgid bit and execute permission for the group. Additionally, it verifies that the current user is part of the group associated with the inherited group identifier and that they have the necessary capabilities to modify the setgid bit. If these conditions are not met, the setgid bit is removed from the mode, preventing unauthorized privilege escalation.","The vulnerability was addressed by implementing additional checks to control the inheritance of the setgid permission. The updated code ensures that the setgid bit is only applied if the new object is a directory or if specific conditions regarding group permissions and user capabilities are met. This includes verifying that the user belongs to the group associated with the inherited permissions and has the necessary rights to modify them. By enforcing these conditions, the fix prevents unauthorized users from gaining elevated privileges through improper permission inheritance, thereby enhancing overall security.","4,4","5,5","4,5","4,5","CWE-732, CWE-264, CWE-269, CWE-284, CWE-266, CWE-279, CWE-668, CWE-281, CWE-280, CWE-277",N,-1
3,3,3,183250,183250,,Remote,Not required,Complete,CVE-2017-6903,https://www.cvedetails.com/cve/CVE-2017-6903/,CWE-269,Medium,Complete,Complete,,2017-03-14,9.3,"In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.",2019-10-02,,7,https://github.com/ioquake/ioq3/commit/f61fe5f6a0419ef4a88d46a128052f2e8352e85d,f61fe5f6a0419ef4a88d46a128052f2e8352e85d,Don't open .pk3 files as OpenAL drivers.,1,code/client/snd_openal.c,"{""sha"": ""319ea371b8a038c3cfc0d8533c7eaf7a09636066"", ""filename"": ""code/client/snd_openal.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/ioquake/ioq3/blob/f61fe5f6a0419ef4a88d46a128052f2e8352e85d/code/client/snd_openal.c"", ""raw_url"": ""https://github.com/ioquake/ioq3/raw/f61fe5f6a0419ef4a88d46a128052f2e8352e85d/code/client/snd_openal.c"", ""contents_url"": ""https://api.github.com/repos/ioquake/ioq3/contents/code/client/snd_openal.c?ref=f61fe5f6a0419ef4a88d46a128052f2e8352e85d"", ""patch"": ""@@ -2512,11 +2512,17 @@ qboolean S_AL_Init( soundInterface_t *si )\n \ts_alRolloff = Cvar_Get( \""s_alRolloff\"", \""2\"", CVAR_CHEAT);\n \ts_alGraceDistance = Cvar_Get(\""s_alGraceDistance\"", \""512\"", CVAR_CHEAT);\n \n-\ts_alDriver = Cvar_Get( \""s_alDriver\"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );\n+\ts_alDriver = Cvar_Get( \""s_alDriver\"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );\n \n \ts_alInputDevice = Cvar_Get( \""s_alInputDevice\"", \""\"", CVAR_ARCHIVE | CVAR_LATCH );\n \ts_alDevice = Cvar_Get(\""s_alDevice\"", \""\"", CVAR_ARCHIVE | CVAR_LATCH);\n \n+\tif ( COM_CompareExtension( s_alDriver->string, \"".pk3\"" ) )\n+\t{\n+\t\tCom_Printf( \""Rejecting DLL named \\\""%s\\\""\"", s_alDriver->string );\n+\t\treturn qfalse;\n+\t}\n+\n \t// Load QAL\n \tif( !QAL_Init( s_alDriver->string ) )\n \t{""}","qboolean S_AL_Init( soundInterface_t *si )
{
#ifdef USE_OPENAL
	const char* device = NULL;
	const char* inputdevice = NULL;
	int i;

	if( !si ) {
		return qfalse;
	}

	for (i = 0; i < MAX_RAW_STREAMS; i++) {
		streamSourceHandles[i] = -1;
		streamPlaying[i] = qfalse;
		streamSources[i] = 0;
		streamNumBuffers[i] = 0;
		streamBufIndex[i] = 0;
	}

	s_alPrecache = Cvar_Get( ""s_alPrecache"", ""1"", CVAR_ARCHIVE );
	s_alGain = Cvar_Get( ""s_alGain"", ""1.0"", CVAR_ARCHIVE );
	s_alSources = Cvar_Get( ""s_alSources"", ""96"", CVAR_ARCHIVE );
	s_alDopplerFactor = Cvar_Get( ""s_alDopplerFactor"", ""1.0"", CVAR_ARCHIVE );
	s_alDopplerSpeed = Cvar_Get( ""s_alDopplerSpeed"", ""9000"", CVAR_ARCHIVE );
	s_alMinDistance = Cvar_Get( ""s_alMinDistance"", ""120"", CVAR_CHEAT );
	s_alMaxDistance = Cvar_Get(""s_alMaxDistance"", ""1024"", CVAR_CHEAT);
 	s_alRolloff = Cvar_Get( ""s_alRolloff"", ""2"", CVAR_CHEAT);
 	s_alGraceDistance = Cvar_Get(""s_alGraceDistance"", ""512"", CVAR_CHEAT);
 
	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );
 
 	s_alInputDevice = Cvar_Get( ""s_alInputDevice"", """", CVAR_ARCHIVE | CVAR_LATCH );
 	s_alDevice = Cvar_Get(""s_alDevice"", """", CVAR_ARCHIVE | CVAR_LATCH);
 
	if ( COM_CompareExtension( s_alDriver->string, "".pk3"" ) )
	{
		Com_Printf( ""Rejecting DLL named \""%s\"""", s_alDriver->string );
		return qfalse;
	}

 	if( !QAL_Init( s_alDriver->string ) )
 	{
		Com_Printf( ""Failed to load library: \""%s\"".\n"", s_alDriver->string );
		if( !Q_stricmp( s_alDriver->string, ALDRIVER_DEFAULT ) || !QAL_Init( ALDRIVER_DEFAULT ) ) {
			return qfalse;
		}
	}

	device = s_alDevice->string;
	if(device && !*device)
		device = NULL;

	inputdevice = s_alInputDevice->string;
	if(inputdevice && !*inputdevice)
		inputdevice = NULL;


	enumeration_all_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATE_ALL_EXT"");
	enumeration_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATION_EXT"");

	if(enumeration_ext || enumeration_all_ext)
	{
		char devicenames[16384] = """";
		const char *devicelist;
#ifdef _WIN32
		const char *defaultdevice;
#endif
		int curlen;

		if(enumeration_all_ext)
		{
			devicelist = qalcGetString(NULL, ALC_ALL_DEVICES_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_ALL_DEVICES_SPECIFIER);
#endif
		}
		else
		{
			devicelist = qalcGetString(NULL, ALC_DEVICE_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);
#endif
			enumeration_ext = qtrue;
		}

#ifdef _WIN32
		if(!device && defaultdevice && !strcmp(defaultdevice, ""Generic Hardware""))
			device = ""Generic Software"";
#endif


		if(devicelist)
		{
			while((curlen = strlen(devicelist)))
			{
				Q_strcat(devicenames, sizeof(devicenames), devicelist);
				Q_strcat(devicenames, sizeof(devicenames), ""\n"");

				devicelist += curlen + 1;
			}
		}

		s_alAvailableDevices = Cvar_Get(""s_alAvailableDevices"", devicenames, CVAR_ROM | CVAR_NORESTART);
	}

	alDevice = qalcOpenDevice(device);
	if( !alDevice && device )
	{
		Com_Printf( ""Failed to open OpenAL device '%s', trying default.\n"", device );
		alDevice = qalcOpenDevice(NULL);
	}

	if( !alDevice )
	{
		QAL_Shutdown( );
		Com_Printf( ""Failed to open OpenAL device.\n"" );
		return qfalse;
	}

	alContext = qalcCreateContext( alDevice, NULL );
	if( !alContext )
	{
		QAL_Shutdown( );
		qalcCloseDevice( alDevice );
		Com_Printf( ""Failed to create OpenAL context.\n"" );
		return qfalse;
	}
	qalcMakeContextCurrent( alContext );

	S_AL_BufferInit( );
	S_AL_SrcInit( );

	qalDistanceModel(AL_INVERSE_DISTANCE_CLAMPED);
	qalDopplerFactor( s_alDopplerFactor->value );
	qalSpeedOfSound( s_alDopplerSpeed->value );

#ifdef USE_VOIP
	s_alCapture = Cvar_Get( ""s_alCapture"", ""1"", CVAR_ARCHIVE | CVAR_LATCH );
	if (!s_alCapture->integer)
	{
		Com_Printf(""OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\n"");
	}
#if USE_MUMBLE
	else if (cl_useMumble->integer)
	{
		Com_Printf(""OpenAL capture support disabled for Mumble support\n"");
	}
#endif
	else
	{
#ifdef __APPLE__
		if (qalcCaptureOpenDevice == NULL)
#else
		if (!qalcIsExtensionPresent(NULL, ""ALC_EXT_capture""))
#endif
		{
			Com_Printf(""No ALC_EXT_capture support, can't record audio.\n"");
		}
		else
		{
			char inputdevicenames[16384] = """";
			const char *inputdevicelist;
			const char *defaultinputdevice;
			int curlen;

			capture_ext = qtrue;

			inputdevicelist = qalcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER);
			defaultinputdevice = qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);

			if (inputdevicelist)
			{
				while((curlen = strlen(inputdevicelist)))
				{
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), inputdevicelist);
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), ""\n"");
					inputdevicelist += curlen + 1;
				}
			}

			s_alAvailableInputDevices = Cvar_Get(""s_alAvailableInputDevices"", inputdevicenames, CVAR_ROM | CVAR_NORESTART);

			Com_Printf(""OpenAL default capture device is '%s'\n"", defaultinputdevice ? defaultinputdevice : ""none"");
			alCaptureDevice = qalcCaptureOpenDevice(inputdevice, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			if( !alCaptureDevice && inputdevice )
			{
				Com_Printf( ""Failed to open OpenAL Input device '%s', trying default.\n"", inputdevice );
				alCaptureDevice = qalcCaptureOpenDevice(NULL, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			}
			Com_Printf( ""OpenAL capture device %s.\n"",
				    (alCaptureDevice == NULL) ? ""failed to open"" : ""opened"");
		}
	}
#endif

	si->Shutdown = S_AL_Shutdown;
	si->StartSound = S_AL_StartSound;
	si->StartLocalSound = S_AL_StartLocalSound;
	si->StartBackgroundTrack = S_AL_StartBackgroundTrack;
	si->StopBackgroundTrack = S_AL_StopBackgroundTrack;
	si->RawSamples = S_AL_RawSamples;
	si->StopAllSounds = S_AL_StopAllSounds;
	si->ClearLoopingSounds = S_AL_ClearLoopingSounds;
	si->AddLoopingSound = S_AL_AddLoopingSound;
	si->AddRealLoopingSound = S_AL_AddRealLoopingSound;
	si->StopLoopingSound = S_AL_StopLoopingSound;
	si->Respatialize = S_AL_Respatialize;
	si->UpdateEntityPosition = S_AL_UpdateEntityPosition;
	si->Update = S_AL_Update;
	si->DisableSounds = S_AL_DisableSounds;
	si->BeginRegistration = S_AL_BeginRegistration;
	si->RegisterSound = S_AL_RegisterSound;
	si->ClearSoundBuffer = S_AL_ClearSoundBuffer;
	si->SoundInfo = S_AL_SoundInfo;
	si->SoundList = S_AL_SoundList;

#ifdef USE_VOIP
	si->StartCapture = S_AL_StartCapture;
	si->AvailableCaptureSamples = S_AL_AvailableCaptureSamples;
	si->Capture = S_AL_Capture;
	si->StopCapture = S_AL_StopCapture;
	si->MasterGain = S_AL_MasterGain;
#endif

	return qtrue;
#else
	return qfalse;
#endif
}
","qboolean S_AL_Init( soundInterface_t *si )
{
#ifdef USE_OPENAL
	const char* device = NULL;
	const char* inputdevice = NULL;
	int i;

	if( !si ) {
		return qfalse;
	}

	for (i = 0; i < MAX_RAW_STREAMS; i++) {
		streamSourceHandles[i] = -1;
		streamPlaying[i] = qfalse;
		streamSources[i] = 0;
		streamNumBuffers[i] = 0;
		streamBufIndex[i] = 0;
	}

	s_alPrecache = Cvar_Get( ""s_alPrecache"", ""1"", CVAR_ARCHIVE );
	s_alGain = Cvar_Get( ""s_alGain"", ""1.0"", CVAR_ARCHIVE );
	s_alSources = Cvar_Get( ""s_alSources"", ""96"", CVAR_ARCHIVE );
	s_alDopplerFactor = Cvar_Get( ""s_alDopplerFactor"", ""1.0"", CVAR_ARCHIVE );
	s_alDopplerSpeed = Cvar_Get( ""s_alDopplerSpeed"", ""9000"", CVAR_ARCHIVE );
	s_alMinDistance = Cvar_Get( ""s_alMinDistance"", ""120"", CVAR_CHEAT );
	s_alMaxDistance = Cvar_Get(""s_alMaxDistance"", ""1024"", CVAR_CHEAT);
 	s_alRolloff = Cvar_Get( ""s_alRolloff"", ""2"", CVAR_CHEAT);
 	s_alGraceDistance = Cvar_Get(""s_alGraceDistance"", ""512"", CVAR_CHEAT);
 
	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );
 
 	s_alInputDevice = Cvar_Get( ""s_alInputDevice"", """", CVAR_ARCHIVE | CVAR_LATCH );
 	s_alDevice = Cvar_Get(""s_alDevice"", """", CVAR_ARCHIVE | CVAR_LATCH);
 
 	if( !QAL_Init( s_alDriver->string ) )
 	{
		Com_Printf( ""Failed to load library: \""%s\"".\n"", s_alDriver->string );
		if( !Q_stricmp( s_alDriver->string, ALDRIVER_DEFAULT ) || !QAL_Init( ALDRIVER_DEFAULT ) ) {
			return qfalse;
		}
	}

	device = s_alDevice->string;
	if(device && !*device)
		device = NULL;

	inputdevice = s_alInputDevice->string;
	if(inputdevice && !*inputdevice)
		inputdevice = NULL;


	enumeration_all_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATE_ALL_EXT"");
	enumeration_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATION_EXT"");

	if(enumeration_ext || enumeration_all_ext)
	{
		char devicenames[16384] = """";
		const char *devicelist;
#ifdef _WIN32
		const char *defaultdevice;
#endif
		int curlen;

		if(enumeration_all_ext)
		{
			devicelist = qalcGetString(NULL, ALC_ALL_DEVICES_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_ALL_DEVICES_SPECIFIER);
#endif
		}
		else
		{
			devicelist = qalcGetString(NULL, ALC_DEVICE_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);
#endif
			enumeration_ext = qtrue;
		}

#ifdef _WIN32
		if(!device && defaultdevice && !strcmp(defaultdevice, ""Generic Hardware""))
			device = ""Generic Software"";
#endif


		if(devicelist)
		{
			while((curlen = strlen(devicelist)))
			{
				Q_strcat(devicenames, sizeof(devicenames), devicelist);
				Q_strcat(devicenames, sizeof(devicenames), ""\n"");

				devicelist += curlen + 1;
			}
		}

		s_alAvailableDevices = Cvar_Get(""s_alAvailableDevices"", devicenames, CVAR_ROM | CVAR_NORESTART);
	}

	alDevice = qalcOpenDevice(device);
	if( !alDevice && device )
	{
		Com_Printf( ""Failed to open OpenAL device '%s', trying default.\n"", device );
		alDevice = qalcOpenDevice(NULL);
	}

	if( !alDevice )
	{
		QAL_Shutdown( );
		Com_Printf( ""Failed to open OpenAL device.\n"" );
		return qfalse;
	}

	alContext = qalcCreateContext( alDevice, NULL );
	if( !alContext )
	{
		QAL_Shutdown( );
		qalcCloseDevice( alDevice );
		Com_Printf( ""Failed to create OpenAL context.\n"" );
		return qfalse;
	}
	qalcMakeContextCurrent( alContext );

	S_AL_BufferInit( );
	S_AL_SrcInit( );

	qalDistanceModel(AL_INVERSE_DISTANCE_CLAMPED);
	qalDopplerFactor( s_alDopplerFactor->value );
	qalSpeedOfSound( s_alDopplerSpeed->value );

#ifdef USE_VOIP
	s_alCapture = Cvar_Get( ""s_alCapture"", ""1"", CVAR_ARCHIVE | CVAR_LATCH );
	if (!s_alCapture->integer)
	{
		Com_Printf(""OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\n"");
	}
#if USE_MUMBLE
	else if (cl_useMumble->integer)
	{
		Com_Printf(""OpenAL capture support disabled for Mumble support\n"");
	}
#endif
	else
	{
#ifdef __APPLE__
		if (qalcCaptureOpenDevice == NULL)
#else
		if (!qalcIsExtensionPresent(NULL, ""ALC_EXT_capture""))
#endif
		{
			Com_Printf(""No ALC_EXT_capture support, can't record audio.\n"");
		}
		else
		{
			char inputdevicenames[16384] = """";
			const char *inputdevicelist;
			const char *defaultinputdevice;
			int curlen;

			capture_ext = qtrue;

			inputdevicelist = qalcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER);
			defaultinputdevice = qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);

			if (inputdevicelist)
			{
				while((curlen = strlen(inputdevicelist)))
				{
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), inputdevicelist);
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), ""\n"");
					inputdevicelist += curlen + 1;
				}
			}

			s_alAvailableInputDevices = Cvar_Get(""s_alAvailableInputDevices"", inputdevicenames, CVAR_ROM | CVAR_NORESTART);

			Com_Printf(""OpenAL default capture device is '%s'\n"", defaultinputdevice ? defaultinputdevice : ""none"");
			alCaptureDevice = qalcCaptureOpenDevice(inputdevice, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			if( !alCaptureDevice && inputdevice )
			{
				Com_Printf( ""Failed to open OpenAL Input device '%s', trying default.\n"", inputdevice );
				alCaptureDevice = qalcCaptureOpenDevice(NULL, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			}
			Com_Printf( ""OpenAL capture device %s.\n"",
				    (alCaptureDevice == NULL) ? ""failed to open"" : ""opened"");
		}
	}
#endif

	si->Shutdown = S_AL_Shutdown;
	si->StartSound = S_AL_StartSound;
	si->StartLocalSound = S_AL_StartLocalSound;
	si->StartBackgroundTrack = S_AL_StartBackgroundTrack;
	si->StopBackgroundTrack = S_AL_StopBackgroundTrack;
	si->RawSamples = S_AL_RawSamples;
	si->StopAllSounds = S_AL_StopAllSounds;
	si->ClearLoopingSounds = S_AL_ClearLoopingSounds;
	si->AddLoopingSound = S_AL_AddLoopingSound;
	si->AddRealLoopingSound = S_AL_AddRealLoopingSound;
	si->StopLoopingSound = S_AL_StopLoopingSound;
	si->Respatialize = S_AL_Respatialize;
	si->UpdateEntityPosition = S_AL_UpdateEntityPosition;
	si->Update = S_AL_Update;
	si->DisableSounds = S_AL_DisableSounds;
	si->BeginRegistration = S_AL_BeginRegistration;
	si->RegisterSound = S_AL_RegisterSound;
	si->ClearSoundBuffer = S_AL_ClearSoundBuffer;
	si->SoundInfo = S_AL_SoundInfo;
	si->SoundList = S_AL_SoundList;

#ifdef USE_VOIP
	si->StartCapture = S_AL_StartCapture;
	si->AvailableCaptureSamples = S_AL_AvailableCaptureSamples;
	si->Capture = S_AL_Capture;
	si->StopCapture = S_AL_StopCapture;
	si->MasterGain = S_AL_MasterGain;
#endif

	return qtrue;
#else
	return qfalse;
#endif
}
",C,"	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );
	if ( COM_CompareExtension( s_alDriver->string, "".pk3"" ) )
	{
		Com_Printf( ""Rejecting DLL named \""%s\"""", s_alDriver->string );
		return qfalse;
	}

","	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );
",,"@@ -2512,11 +2512,17 @@ qboolean S_AL_Init( soundInterface_t *si )
 	s_alRolloff = Cvar_Get( ""s_alRolloff"", ""2"", CVAR_CHEAT);
 	s_alGraceDistance = Cvar_Get(""s_alGraceDistance"", ""512"", CVAR_CHEAT);
 
-	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );
+	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );
 
 	s_alInputDevice = Cvar_Get( ""s_alInputDevice"", """", CVAR_ARCHIVE | CVAR_LATCH );
 	s_alDevice = Cvar_Get(""s_alDevice"", """", CVAR_ARCHIVE | CVAR_LATCH);
 
+	if ( COM_CompareExtension( s_alDriver->string, "".pk3"" ) )
+	{
+		Com_Printf( ""Rejecting DLL named \""%s\"""", s_alDriver->string );
+		return qfalse;
+	}
+
 	// Load QAL
 	if( !QAL_Init( s_alDriver->string ) )
 	{",OpenJK,f61fe5f6a0419ef4a88d46a128052f2e8352e85d,376267d534476a875d8b9228149c4ee18b74a4fd,1,"qboolean S_AL_Init( soundInterface_t *si )
{
#ifdef USE_OPENAL
	const char* device = NULL;
	const char* inputdevice = NULL;
	int i;

	if( !si ) {
		return qfalse;
	}

	for (i = 0; i < MAX_RAW_STREAMS; i++) {
		streamSourceHandles[i] = -1;
		streamPlaying[i] = qfalse;
		streamSources[i] = 0;
		streamNumBuffers[i] = 0;
		streamBufIndex[i] = 0;
	}

	// New console variables
	s_alPrecache = Cvar_Get( ""s_alPrecache"", ""1"", CVAR_ARCHIVE );
	s_alGain = Cvar_Get( ""s_alGain"", ""1.0"", CVAR_ARCHIVE );
	s_alSources = Cvar_Get( ""s_alSources"", ""96"", CVAR_ARCHIVE );
	s_alDopplerFactor = Cvar_Get( ""s_alDopplerFactor"", ""1.0"", CVAR_ARCHIVE );
	s_alDopplerSpeed = Cvar_Get( ""s_alDopplerSpeed"", ""9000"", CVAR_ARCHIVE );
	s_alMinDistance = Cvar_Get( ""s_alMinDistance"", ""120"", CVAR_CHEAT );
	s_alMaxDistance = Cvar_Get(""s_alMaxDistance"", ""1024"", CVAR_CHEAT);
 	s_alRolloff = Cvar_Get( ""s_alRolloff"", ""2"", CVAR_CHEAT);
 	s_alGraceDistance = Cvar_Get(""s_alGraceDistance"", ""512"", CVAR_CHEAT);
 
//flaw_line_below:
	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );
//fix_flaw_line_below:
//	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );
 
 	s_alInputDevice = Cvar_Get( ""s_alInputDevice"", """", CVAR_ARCHIVE | CVAR_LATCH );
 	s_alDevice = Cvar_Get(""s_alDevice"", """", CVAR_ARCHIVE | CVAR_LATCH);
 
//fix_flaw_line_below:
//	if ( COM_CompareExtension( s_alDriver->string, "".pk3"" ) )
//fix_flaw_line_below:
//	{
//fix_flaw_line_below:
//		Com_Printf( ""Rejecting DLL named \""%s\"""", s_alDriver->string );
//fix_flaw_line_below:
//		return qfalse;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	// Load QAL
 	if( !QAL_Init( s_alDriver->string ) )
 	{
		Com_Printf( ""Failed to load library: \""%s\"".\n"", s_alDriver->string );
		if( !Q_stricmp( s_alDriver->string, ALDRIVER_DEFAULT ) || !QAL_Init( ALDRIVER_DEFAULT ) ) {
			return qfalse;
		}
	}

	device = s_alDevice->string;
	if(device && !*device)
		device = NULL;

	inputdevice = s_alInputDevice->string;
	if(inputdevice && !*inputdevice)
		inputdevice = NULL;


	// Device enumeration support
	enumeration_all_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATE_ALL_EXT"");
	enumeration_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATION_EXT"");

	if(enumeration_ext || enumeration_all_ext)
	{
		char devicenames[16384] = """";
		const char *devicelist;
#ifdef _WIN32
		const char *defaultdevice;
#endif
		int curlen;

		// get all available devices + the default device name.
		if(enumeration_all_ext)
		{
			devicelist = qalcGetString(NULL, ALC_ALL_DEVICES_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_ALL_DEVICES_SPECIFIER);
#endif
		}
		else
		{
			// We don't have ALC_ENUMERATE_ALL_EXT but normal enumeration.
			devicelist = qalcGetString(NULL, ALC_DEVICE_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);
#endif
			enumeration_ext = qtrue;
		}

#ifdef _WIN32
		// check whether the default device is generic hardware. If it is, change to
		// Generic Software as that one works more reliably with various sound systems.
		// If it's not, use OpenAL's default selection as we don't want to ignore
		// native hardware acceleration.
		if(!device && defaultdevice && !strcmp(defaultdevice, ""Generic Hardware""))
			device = ""Generic Software"";
#endif

		// dump a list of available devices to a cvar for the user to see.

		if(devicelist)
		{
			while((curlen = strlen(devicelist)))
			{
				Q_strcat(devicenames, sizeof(devicenames), devicelist);
				Q_strcat(devicenames, sizeof(devicenames), ""\n"");

				devicelist += curlen + 1;
			}
		}

		s_alAvailableDevices = Cvar_Get(""s_alAvailableDevices"", devicenames, CVAR_ROM | CVAR_NORESTART);
	}

	alDevice = qalcOpenDevice(device);
	if( !alDevice && device )
	{
		Com_Printf( ""Failed to open OpenAL device '%s', trying default.\n"", device );
		alDevice = qalcOpenDevice(NULL);
	}

	if( !alDevice )
	{
		QAL_Shutdown( );
		Com_Printf( ""Failed to open OpenAL device.\n"" );
		return qfalse;
	}

	// Create OpenAL context
	alContext = qalcCreateContext( alDevice, NULL );
	if( !alContext )
	{
		QAL_Shutdown( );
		qalcCloseDevice( alDevice );
		Com_Printf( ""Failed to create OpenAL context.\n"" );
		return qfalse;
	}
	qalcMakeContextCurrent( alContext );

	// Initialize sources, buffers, music
	S_AL_BufferInit( );
	S_AL_SrcInit( );

	// Set up OpenAL parameters (doppler, etc)
	qalDistanceModel(AL_INVERSE_DISTANCE_CLAMPED);
	qalDopplerFactor( s_alDopplerFactor->value );
	qalSpeedOfSound( s_alDopplerSpeed->value );

#ifdef USE_VOIP
	// !!! FIXME: some of these alcCaptureOpenDevice() values should be cvars.
	// !!! FIXME: add support for capture device enumeration.
	// !!! FIXME: add some better error reporting.
	s_alCapture = Cvar_Get( ""s_alCapture"", ""1"", CVAR_ARCHIVE | CVAR_LATCH );
	if (!s_alCapture->integer)
	{
		Com_Printf(""OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\n"");
	}
#if USE_MUMBLE
	else if (cl_useMumble->integer)
	{
		Com_Printf(""OpenAL capture support disabled for Mumble support\n"");
	}
#endif
	else
	{
#ifdef __APPLE__
		// !!! FIXME: Apple has a 1.1-compliant OpenAL, which includes
		// !!! FIXME:  capture support, but they don't list it in the
		// !!! FIXME:  extension string. We need to check the version string,
		// !!! FIXME:  then the extension string, but that's too much trouble,
		// !!! FIXME:  so we'll just check the function pointer for now.
		if (qalcCaptureOpenDevice == NULL)
#else
		if (!qalcIsExtensionPresent(NULL, ""ALC_EXT_capture""))
#endif
		{
			Com_Printf(""No ALC_EXT_capture support, can't record audio.\n"");
		}
		else
		{
			char inputdevicenames[16384] = """";
			const char *inputdevicelist;
			const char *defaultinputdevice;
			int curlen;

			capture_ext = qtrue;

			// get all available input devices + the default input device name.
			inputdevicelist = qalcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER);
			defaultinputdevice = qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);

			// dump a list of available devices to a cvar for the user to see.
			if (inputdevicelist)
			{
				while((curlen = strlen(inputdevicelist)))
				{
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), inputdevicelist);
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), ""\n"");
					inputdevicelist += curlen + 1;
				}
			}

			s_alAvailableInputDevices = Cvar_Get(""s_alAvailableInputDevices"", inputdevicenames, CVAR_ROM | CVAR_NORESTART);

			Com_Printf(""OpenAL default capture device is '%s'\n"", defaultinputdevice ? defaultinputdevice : ""none"");
			alCaptureDevice = qalcCaptureOpenDevice(inputdevice, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			if( !alCaptureDevice && inputdevice )
			{
				Com_Printf( ""Failed to open OpenAL Input device '%s', trying default.\n"", inputdevice );
				alCaptureDevice = qalcCaptureOpenDevice(NULL, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			}
			Com_Printf( ""OpenAL capture device %s.\n"",
				    (alCaptureDevice == NULL) ? ""failed to open"" : ""opened"");
		}
	}
#endif

	si->Shutdown = S_AL_Shutdown;
	si->StartSound = S_AL_StartSound;
	si->StartLocalSound = S_AL_StartLocalSound;
	si->StartBackgroundTrack = S_AL_StartBackgroundTrack;
	si->StopBackgroundTrack = S_AL_StopBackgroundTrack;
	si->RawSamples = S_AL_RawSamples;
	si->StopAllSounds = S_AL_StopAllSounds;
	si->ClearLoopingSounds = S_AL_ClearLoopingSounds;
	si->AddLoopingSound = S_AL_AddLoopingSound;
	si->AddRealLoopingSound = S_AL_AddRealLoopingSound;
	si->StopLoopingSound = S_AL_StopLoopingSound;
	si->Respatialize = S_AL_Respatialize;
	si->UpdateEntityPosition = S_AL_UpdateEntityPosition;
	si->Update = S_AL_Update;
	si->DisableSounds = S_AL_DisableSounds;
	si->BeginRegistration = S_AL_BeginRegistration;
	si->RegisterSound = S_AL_RegisterSound;
	si->ClearSoundBuffer = S_AL_ClearSoundBuffer;
	si->SoundInfo = S_AL_SoundInfo;
	si->SoundList = S_AL_SoundList;

#ifdef USE_VOIP
	si->StartCapture = S_AL_StartCapture;
	si->AvailableCaptureSamples = S_AL_AvailableCaptureSamples;
	si->Capture = S_AL_Capture;
	si->StopCapture = S_AL_StopCapture;
	si->MasterGain = S_AL_MasterGain;
#endif

	return qtrue;
#else
	return qfalse;
#endif
}
",183250,"qboolean S_AL_Init( soundInterface_t *si )
{
#ifdef USE_OPENAL
	const char* device = NULL;
	const char* inputdevice = NULL;
	int i;

	if( !si ) {
		return qfalse;
	}

	for (i = 0; i < MAX_RAW_STREAMS; i++) {
		streamSourceHandles[i] = -1;
		streamPlaying[i] = qfalse;
		streamSources[i] = 0;
		streamNumBuffers[i] = 0;
		streamBufIndex[i] = 0;
	}

	s_alPrecache = Cvar_Get( ""s_alPrecache"", ""1"", CVAR_ARCHIVE );
	s_alGain = Cvar_Get( ""s_alGain"", ""1.0"", CVAR_ARCHIVE );
	s_alSources = Cvar_Get( ""s_alSources"", ""96"", CVAR_ARCHIVE );
	s_alDopplerFactor = Cvar_Get( ""s_alDopplerFactor"", ""1.0"", CVAR_ARCHIVE );
	s_alDopplerSpeed = Cvar_Get( ""s_alDopplerSpeed"", ""9000"", CVAR_ARCHIVE );
	s_alMinDistance = Cvar_Get( ""s_alMinDistance"", ""120"", CVAR_CHEAT );
	s_alMaxDistance = Cvar_Get(""s_alMaxDistance"", ""1024"", CVAR_CHEAT);
 	s_alRolloff = Cvar_Get( ""s_alRolloff"", ""2"", CVAR_CHEAT);
 	s_alGraceDistance = Cvar_Get(""s_alGraceDistance"", ""512"", CVAR_CHEAT);
 
	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );
 
 	s_alInputDevice = Cvar_Get( ""s_alInputDevice"", """", CVAR_ARCHIVE | CVAR_LATCH );
 	s_alDevice = Cvar_Get(""s_alDevice"", """", CVAR_ARCHIVE | CVAR_LATCH);
 
 	if( !QAL_Init( s_alDriver->string ) )
 	{
		Com_Printf( ""Failed to load library: \""%s\"".\n"", s_alDriver->string );
		if( !Q_stricmp( s_alDriver->string, ALDRIVER_DEFAULT ) || !QAL_Init( ALDRIVER_DEFAULT ) ) {
			return qfalse;
		}
	}

	device = s_alDevice->string;
	if(device && !*device)
		device = NULL;

	inputdevice = s_alInputDevice->string;
	if(inputdevice && !*inputdevice)
		inputdevice = NULL;


	enumeration_all_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATE_ALL_EXT"");
	enumeration_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATION_EXT"");

	if(enumeration_ext || enumeration_all_ext)
	{
		char devicenames[16384] = """";
		const char *devicelist;
#ifdef _WIN32
		const char *defaultdevice;
#endif
		int curlen;

		if(enumeration_all_ext)
		{
			devicelist = qalcGetString(NULL, ALC_ALL_DEVICES_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_ALL_DEVICES_SPECIFIER);
#endif
		}
		else
		{
			devicelist = qalcGetString(NULL, ALC_DEVICE_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);
#endif
			enumeration_ext = qtrue;
		}

#ifdef _WIN32
		if(!device && defaultdevice && !strcmp(defaultdevice, ""Generic Hardware""))
			device = ""Generic Software"";
#endif


		if(devicelist)
		{
			while((curlen = strlen(devicelist)))
			{
				Q_strcat(devicenames, sizeof(devicenames), devicelist);
				Q_strcat(devicenames, sizeof(devicenames), ""\n"");

				devicelist += curlen + 1;
			}
		}

		s_alAvailableDevices = Cvar_Get(""s_alAvailableDevices"", devicenames, CVAR_ROM | CVAR_NORESTART);
	}

	alDevice = qalcOpenDevice(device);
	if( !alDevice && device )
	{
		Com_Printf( ""Failed to open OpenAL device '%s', trying default.\n"", device );
		alDevice = qalcOpenDevice(NULL);
	}

	if( !alDevice )
	{
		QAL_Shutdown( );
		Com_Printf( ""Failed to open OpenAL device.\n"" );
		return qfalse;
	}

	alContext = qalcCreateContext( alDevice, NULL );
	if( !alContext )
	{
		QAL_Shutdown( );
		qalcCloseDevice( alDevice );
		Com_Printf( ""Failed to create OpenAL context.\n"" );
		return qfalse;
	}
	qalcMakeContextCurrent( alContext );

	S_AL_BufferInit( );
	S_AL_SrcInit( );

	qalDistanceModel(AL_INVERSE_DISTANCE_CLAMPED);
	qalDopplerFactor( s_alDopplerFactor->value );
	qalSpeedOfSound( s_alDopplerSpeed->value );

#ifdef USE_VOIP
	s_alCapture = Cvar_Get( ""s_alCapture"", ""1"", CVAR_ARCHIVE | CVAR_LATCH );
	if (!s_alCapture->integer)
	{
		Com_Printf(""OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\n"");
	}
#if USE_MUMBLE
	else if (cl_useMumble->integer)
	{
		Com_Printf(""OpenAL capture support disabled for Mumble support\n"");
	}
#endif
	else
	{
#ifdef __APPLE__
		if (qalcCaptureOpenDevice == NULL)
#else
		if (!qalcIsExtensionPresent(NULL, ""ALC_EXT_capture""))
#endif
		{
			Com_Printf(""No ALC_EXT_capture support, can't record audio.\n"");
		}
		else
		{
			char inputdevicenames[16384] = """";
			const char *inputdevicelist;
			const char *defaultinputdevice;
			int curlen;

			capture_ext = qtrue;

			inputdevicelist = qalcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER);
			defaultinputdevice = qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);

			if (inputdevicelist)
			{
				while((curlen = strlen(inputdevicelist)))
				{
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), inputdevicelist);
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), ""\n"");
					inputdevicelist += curlen + 1;
				}
			}

			s_alAvailableInputDevices = Cvar_Get(""s_alAvailableInputDevices"", inputdevicenames, CVAR_ROM | CVAR_NORESTART);

			Com_Printf(""OpenAL default capture device is '%s'\n"", defaultinputdevice ? defaultinputdevice : ""none"");
			alCaptureDevice = qalcCaptureOpenDevice(inputdevice, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			if( !alCaptureDevice && inputdevice )
			{
				Com_Printf( ""Failed to open OpenAL Input device '%s', trying default.\n"", inputdevice );
				alCaptureDevice = qalcCaptureOpenDevice(NULL, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			}
			Com_Printf( ""OpenAL capture device %s.\n"",
				    (alCaptureDevice == NULL) ? ""failed to open"" : ""opened"");
		}
	}
#endif

	si->Shutdown = S_AL_Shutdown;
	si->StartSound = S_AL_StartSound;
	si->StartLocalSound = S_AL_StartLocalSound;
	si->StartBackgroundTrack = S_AL_StartBackgroundTrack;
	si->StopBackgroundTrack = S_AL_StopBackgroundTrack;
	si->RawSamples = S_AL_RawSamples;
	si->StopAllSounds = S_AL_StopAllSounds;
	si->ClearLoopingSounds = S_AL_ClearLoopingSounds;
	si->AddLoopingSound = S_AL_AddLoopingSound;
	si->AddRealLoopingSound = S_AL_AddRealLoopingSound;
	si->StopLoopingSound = S_AL_StopLoopingSound;
	si->Respatialize = S_AL_Respatialize;
	si->UpdateEntityPosition = S_AL_UpdateEntityPosition;
	si->Update = S_AL_Update;
	si->DisableSounds = S_AL_DisableSounds;
	si->BeginRegistration = S_AL_BeginRegistration;
	si->RegisterSound = S_AL_RegisterSound;
	si->ClearSoundBuffer = S_AL_ClearSoundBuffer;
	si->SoundInfo = S_AL_SoundInfo;
	si->SoundList = S_AL_SoundList;

#ifdef USE_VOIP
	si->StartCapture = S_AL_StartCapture;
	si->AvailableCaptureSamples = S_AL_AvailableCaptureSamples;
	si->Capture = S_AL_Capture;
	si->StopCapture = S_AL_StopCapture;
	si->MasterGain = S_AL_MasterGain;
#endif

	return qtrue;
#else
	return qfalse;
#endif
}
","qboolean S_AL_Init( soundInterface_t *si )
{
#ifdef USE_OPENAL
	const char* device = NULL;
	const char* inputdevice = NULL;
	int i;

	if( !si ) {
		return qfalse;
	}

	for (i = 0; i < MAX_RAW_STREAMS; i++) {
		streamSourceHandles[i] = -1;
		streamPlaying[i] = qfalse;
		streamSources[i] = 0;
		streamNumBuffers[i] = 0;
		streamBufIndex[i] = 0;
	}

	s_alPrecache = Cvar_Get( ""s_alPrecache"", ""1"", CVAR_ARCHIVE );
	s_alGain = Cvar_Get( ""s_alGain"", ""1.0"", CVAR_ARCHIVE );
	s_alSources = Cvar_Get( ""s_alSources"", ""96"", CVAR_ARCHIVE );
	s_alDopplerFactor = Cvar_Get( ""s_alDopplerFactor"", ""1.0"", CVAR_ARCHIVE );
	s_alDopplerSpeed = Cvar_Get( ""s_alDopplerSpeed"", ""9000"", CVAR_ARCHIVE );
	s_alMinDistance = Cvar_Get( ""s_alMinDistance"", ""120"", CVAR_CHEAT );
	s_alMaxDistance = Cvar_Get(""s_alMaxDistance"", ""1024"", CVAR_CHEAT);
 	s_alRolloff = Cvar_Get( ""s_alRolloff"", ""2"", CVAR_CHEAT);
 	s_alGraceDistance = Cvar_Get(""s_alGraceDistance"", ""512"", CVAR_CHEAT);
 
	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );
 
 	s_alInputDevice = Cvar_Get( ""s_alInputDevice"", """", CVAR_ARCHIVE | CVAR_LATCH );
 	s_alDevice = Cvar_Get(""s_alDevice"", """", CVAR_ARCHIVE | CVAR_LATCH);
 
	if ( COM_CompareExtension( s_alDriver->string, "".pk3"" ) )
	{
		Com_Printf( ""Rejecting DLL named \""%s\"""", s_alDriver->string );
		return qfalse;
	}

 	if( !QAL_Init( s_alDriver->string ) )
 	{
		Com_Printf( ""Failed to load library: \""%s\"".\n"", s_alDriver->string );
		if( !Q_stricmp( s_alDriver->string, ALDRIVER_DEFAULT ) || !QAL_Init( ALDRIVER_DEFAULT ) ) {
			return qfalse;
		}
	}

	device = s_alDevice->string;
	if(device && !*device)
		device = NULL;

	inputdevice = s_alInputDevice->string;
	if(inputdevice && !*inputdevice)
		inputdevice = NULL;


	enumeration_all_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATE_ALL_EXT"");
	enumeration_ext = qalcIsExtensionPresent(NULL, ""ALC_ENUMERATION_EXT"");

	if(enumeration_ext || enumeration_all_ext)
	{
		char devicenames[16384] = """";
		const char *devicelist;
#ifdef _WIN32
		const char *defaultdevice;
#endif
		int curlen;

		if(enumeration_all_ext)
		{
			devicelist = qalcGetString(NULL, ALC_ALL_DEVICES_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_ALL_DEVICES_SPECIFIER);
#endif
		}
		else
		{
			devicelist = qalcGetString(NULL, ALC_DEVICE_SPECIFIER);
#ifdef _WIN32
			defaultdevice = qalcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);
#endif
			enumeration_ext = qtrue;
		}

#ifdef _WIN32
		if(!device && defaultdevice && !strcmp(defaultdevice, ""Generic Hardware""))
			device = ""Generic Software"";
#endif


		if(devicelist)
		{
			while((curlen = strlen(devicelist)))
			{
				Q_strcat(devicenames, sizeof(devicenames), devicelist);
				Q_strcat(devicenames, sizeof(devicenames), ""\n"");

				devicelist += curlen + 1;
			}
		}

		s_alAvailableDevices = Cvar_Get(""s_alAvailableDevices"", devicenames, CVAR_ROM | CVAR_NORESTART);
	}

	alDevice = qalcOpenDevice(device);
	if( !alDevice && device )
	{
		Com_Printf( ""Failed to open OpenAL device '%s', trying default.\n"", device );
		alDevice = qalcOpenDevice(NULL);
	}

	if( !alDevice )
	{
		QAL_Shutdown( );
		Com_Printf( ""Failed to open OpenAL device.\n"" );
		return qfalse;
	}

	alContext = qalcCreateContext( alDevice, NULL );
	if( !alContext )
	{
		QAL_Shutdown( );
		qalcCloseDevice( alDevice );
		Com_Printf( ""Failed to create OpenAL context.\n"" );
		return qfalse;
	}
	qalcMakeContextCurrent( alContext );

	S_AL_BufferInit( );
	S_AL_SrcInit( );

	qalDistanceModel(AL_INVERSE_DISTANCE_CLAMPED);
	qalDopplerFactor( s_alDopplerFactor->value );
	qalSpeedOfSound( s_alDopplerSpeed->value );

#ifdef USE_VOIP
	s_alCapture = Cvar_Get( ""s_alCapture"", ""1"", CVAR_ARCHIVE | CVAR_LATCH );
	if (!s_alCapture->integer)
	{
		Com_Printf(""OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\n"");
	}
#if USE_MUMBLE
	else if (cl_useMumble->integer)
	{
		Com_Printf(""OpenAL capture support disabled for Mumble support\n"");
	}
#endif
	else
	{
#ifdef __APPLE__
		if (qalcCaptureOpenDevice == NULL)
#else
		if (!qalcIsExtensionPresent(NULL, ""ALC_EXT_capture""))
#endif
		{
			Com_Printf(""No ALC_EXT_capture support, can't record audio.\n"");
		}
		else
		{
			char inputdevicenames[16384] = """";
			const char *inputdevicelist;
			const char *defaultinputdevice;
			int curlen;

			capture_ext = qtrue;

			inputdevicelist = qalcGetString(NULL, ALC_CAPTURE_DEVICE_SPECIFIER);
			defaultinputdevice = qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER);

			if (inputdevicelist)
			{
				while((curlen = strlen(inputdevicelist)))
				{
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), inputdevicelist);
					Q_strcat(inputdevicenames, sizeof(inputdevicenames), ""\n"");
					inputdevicelist += curlen + 1;
				}
			}

			s_alAvailableInputDevices = Cvar_Get(""s_alAvailableInputDevices"", inputdevicenames, CVAR_ROM | CVAR_NORESTART);

			Com_Printf(""OpenAL default capture device is '%s'\n"", defaultinputdevice ? defaultinputdevice : ""none"");
			alCaptureDevice = qalcCaptureOpenDevice(inputdevice, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			if( !alCaptureDevice && inputdevice )
			{
				Com_Printf( ""Failed to open OpenAL Input device '%s', trying default.\n"", inputdevice );
				alCaptureDevice = qalcCaptureOpenDevice(NULL, 48000, AL_FORMAT_MONO16, VOIP_MAX_PACKET_SAMPLES*4);
			}
			Com_Printf( ""OpenAL capture device %s.\n"",
				    (alCaptureDevice == NULL) ? ""failed to open"" : ""opened"");
		}
	}
#endif

	si->Shutdown = S_AL_Shutdown;
	si->StartSound = S_AL_StartSound;
	si->StartLocalSound = S_AL_StartLocalSound;
	si->StartBackgroundTrack = S_AL_StartBackgroundTrack;
	si->StopBackgroundTrack = S_AL_StopBackgroundTrack;
	si->RawSamples = S_AL_RawSamples;
	si->StopAllSounds = S_AL_StopAllSounds;
	si->ClearLoopingSounds = S_AL_ClearLoopingSounds;
	si->AddLoopingSound = S_AL_AddLoopingSound;
	si->AddRealLoopingSound = S_AL_AddRealLoopingSound;
	si->StopLoopingSound = S_AL_StopLoopingSound;
	si->Respatialize = S_AL_Respatialize;
	si->UpdateEntityPosition = S_AL_UpdateEntityPosition;
	si->Update = S_AL_Update;
	si->DisableSounds = S_AL_DisableSounds;
	si->BeginRegistration = S_AL_BeginRegistration;
	si->RegisterSound = S_AL_RegisterSound;
	si->ClearSoundBuffer = S_AL_ClearSoundBuffer;
	si->SoundInfo = S_AL_SoundInfo;
	si->SoundList = S_AL_SoundList;

#ifdef USE_VOIP
	si->StartCapture = S_AL_StartCapture;
	si->AvailableCaptureSamples = S_AL_AvailableCaptureSamples;
	si->Capture = S_AL_Capture;
	si->StopCapture = S_AL_StopCapture;
	si->MasterGain = S_AL_MasterGain;
#endif

	return qtrue;
#else
	return qfalse;
#endif
}
","The `S_AL_Init` function initializes the OpenAL sound system for a given sound interface, setting up various parameters and configurations. It first checks if the sound interface pointer is valid, then initializes arrays for managing audio streams. The function retrieves configuration variables for sound properties such as gain, distance, and device settings. It attempts to load the OpenAL library and open the specified audio device, falling back to defaults if necessary. Additionally, it sets up audio capture capabilities if enabled. Finally, it assigns function pointers for sound operations to the provided interface and returns a success status.","The code initializes an audio system using a specific library, ensuring that the necessary configurations and parameters are set for sound playback and capture. It checks for the validity of the input interface and prepares arrays to manage audio streams. The function retrieves various settings related to sound properties and attempts to load the audio library and open the designated audio device, falling back to defaults if needed. Additionally, it sets up audio capture capabilities if enabled and assigns various sound operation functions to the provided interface, ultimately returning a success status upon completion.","The vulnerability identified as CWE-269, which pertains to improper privilege management, was present in the original code due to the lack of validation for the audio driver input. Specifically, the code did not check if the driver name ended with a specific extension, allowing potentially malicious DLLs to be loaded. The fix introduced a check using a comparison function to reject any driver names that matched a certain pattern, thereby preventing the loading of unauthorized or harmful libraries. This enhancement ensures that only legitimate audio drivers are utilized, mitigating the risk of privilege escalation or code execution vulnerabilities.","The vulnerability identified as CWE-269, related to improper privilege management, arose from the lack of validation for user-supplied input regarding the audio driver. This oversight allowed potentially malicious libraries to be loaded, posing a significant security risk. The fix implemented a validation check to reject any driver names that matched specific patterns, effectively preventing the loading of unauthorized or harmful components. By ensuring that only legitimate and safe audio drivers are accepted, the revised code mitigates the risk of privilege escalation and enhances the overall security of the system.","The vulnerability was fixed by introducing a validation check for the audio driver name using the `COM_CompareExtension` function. This check specifically rejects any driver names that end with a certain extension, preventing the loading of potentially malicious DLLs. If the driver name is deemed unsafe, the code prints a rejection message and returns a failure status. Additionally, the driver retrieval process was enhanced by marking the driver variable with specific flags to ensure better protection. These changes collectively ensure that only legitimate audio drivers are loaded, thereby mitigating the risk of privilege escalation and unauthorized code execution.","The vulnerability was addressed by implementing a validation mechanism that checks the audio driver name against specific criteria to prevent the loading of potentially harmful libraries. This mechanism ensures that any driver names matching certain patterns are rejected, thereby blocking unauthorized or malicious components from being utilized. Additionally, the code was enhanced to include protective flags during the driver retrieval process, further securing the system against exploitation. These measures collectively strengthen the integrity of the audio initialization process, significantly reducing the risk of privilege escalation and unauthorized code execution.","5,4","4, 4","4, 4","4,5","CWE-284,CWE-269,CWE-426,CWE-114,CWE-782,CWE-732,CWE-272,CWE-346,CWE-441,CWE-250",Y,2
