,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic
0,79483,79483,,Remote,Not required,,CVE-2018-14363,https://www.cvedetails.com/cve/CVE-2018-14363/,CWE-22,Low,,Partial,,2018-07-17,5.0,An issue was discovered in NeoMutt before 2018-07-16. newsrc.c does not properly restrict '/' characters that may have unsafe interaction with cache pathnames.,2019-10-02,Dir. Trav. ,0,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,9bfab35522301794483f8f9ed60820bdec9be59e,"sanitise cache paths

Co-authored-by: JerikoOne <jeriko.one@gmx.us>",0,pop.c,"{""sha"": ""c9dfdba23c03a5608841c4a703f0df61b10d89af"", ""filename"": ""newsrc.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 1, ""changes"": 13, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/9bfab35522301794483f8f9ed60820bdec9be59e/newsrc.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/9bfab35522301794483f8f9ed60820bdec9be59e/newsrc.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/newsrc.c?ref=9bfab35522301794483f8f9ed60820bdec9be59e"", ""patch"": ""@@ -715,7 +715,18 @@ int nntp_active_save_cache(struct NntpServer *nserv)\n  */\n static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n {\n-  return snprintf(dest, destlen, \""%s.hcache\"", path);\n+  int count = snprintf(dest, destlen, \""%s.hcache\"", path);\n+\n+  /* Strip out any directories in the path */\n+  char *first = strchr(dest, '/');\n+  char *last = strrchr(dest, '/');\n+  if (first && last && (last > first))\n+  {\n+    memmove(first, last, strlen(last) + 1);\n+    count -= (last - first);\n+  }\n+\n+  return count;\n }\n \n /**""}<_**next**_>{""sha"": ""4f3a592a8d562aec7dfe3c80bec8e010cd879c97"", ""filename"": ""pop.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 6, ""changes"": 29, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/9bfab35522301794483f8f9ed60820bdec9be59e/pop.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/9bfab35522301794483f8f9ed60820bdec9be59e/pop.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/pop.c?ref=9bfab35522301794483f8f9ed60820bdec9be59e"", ""patch"": ""@@ -63,6 +63,23 @@\n #define HC_FEXT \""hcache\""   /* extension for hcache as POP lacks paths */\n #endif\n \n+/**\n+ * cache_id - Make a message-cache-compatible id\n+ * @param id POP message id\n+ * @retval ptr Sanitised string\n+ *\n+ * The POP message id may contain '/' and other awkward characters.\n+ *\n+ * @note This function returns a pointer to a static buffer.\n+ */\n+static const char *cache_id(const char *id)\n+{\n+  static char clean[SHORT_STRING];\n+  mutt_str_strfcpy(clean, id, sizeof(clean));\n+  mutt_file_sanitize_filename(clean, true);\n+  return clean;\n+}\n+\n /**\n  * fetch_message - write line to file\n  * @param line String to write\n@@ -242,7 +259,7 @@ static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)\n   /* message not found in context -> remove it from cache\n    * return the result of bcache, so we stop upon its first error\n    */\n-  return mutt_bcache_del(bcache, id);\n+  return mutt_bcache_del(bcache, cache_id(id));\n }\n \n #ifdef USE_HCACHE\n@@ -407,7 +424,7 @@ static int pop_fetch_headers(struct Context *ctx)\n        *        - if we don't have a body: new\n        */\n       const bool bcached =\n-          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);\n+          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);\n       ctx->hdrs[i]->old = false;\n       ctx->hdrs[i]->read = false;\n       if (hcached)\n@@ -597,7 +614,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n   unsigned short bcache = 1;\n \n   /* see if we already have the message in body cache */\n-  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);\n+  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));\n   if (msg->fp)\n     return 0;\n \n@@ -644,7 +661,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n                        NetInc, h->content->length + h->content->offset - 1);\n \n     /* see if we can put in body cache; use our cache as fallback */\n-    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);\n+    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));\n     if (!msg->fp)\n     {\n       /* no */\n@@ -689,7 +706,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n    * portion of the headers, those required for the main display.\n    */\n   if (bcache)\n-    mutt_bcache_commit(pop_data->bcache, h->data);\n+    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));\n   else\n   {\n     cache->index = h->index;\n@@ -783,7 +800,7 @@ static int pop_sync_mailbox(struct Context *ctx, int *index_hint)\n         ret = pop_query(pop_data, buf, sizeof(buf));\n         if (ret == 0)\n         {\n-          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);\n+          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));\n #ifdef USE_HCACHE\n           mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n #endif""}","static int pop_hcache_namer(const char *path, char *dest, size_t destlen)
{
  return snprintf(dest, destlen, ""%s."" HC_FEXT, path);
}
","static int pop_hcache_namer(const char *path, char *dest, size_t destlen)
{
  return snprintf(dest, destlen, ""%s."" HC_FEXT, path);
}
",C,,,,"@@ -63,6 +63,23 @@
 #define HC_FEXT ""hcache""   /* extension for hcache as POP lacks paths */
 #endif
 
+/**
+ * cache_id - Make a message-cache-compatible id
+ * @param id POP message id
+ * @retval ptr Sanitised string
+ *
+ * The POP message id may contain '/' and other awkward characters.
+ *
+ * @note This function returns a pointer to a static buffer.
+ */
+static const char *cache_id(const char *id)
+{
+  static char clean[SHORT_STRING];
+  mutt_str_strfcpy(clean, id, sizeof(clean));
+  mutt_file_sanitize_filename(clean, true);
+  return clean;
+}
+
 /**
  * fetch_message - write line to file
  * @param line String to write
@@ -242,7 +259,7 @@ static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)
   /* message not found in context -> remove it from cache
    * return the result of bcache, so we stop upon its first error
    */
-  return mutt_bcache_del(bcache, id);
+  return mutt_bcache_del(bcache, cache_id(id));
 }
 
 #ifdef USE_HCACHE
@@ -407,7 +424,7 @@ static int pop_fetch_headers(struct Context *ctx)
        *        - if we don't have a body: new
        */
       const bool bcached =
-          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);
+          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);
       ctx->hdrs[i]->old = false;
       ctx->hdrs[i]->read = false;
       if (hcached)
@@ -597,7 +614,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno
   unsigned short bcache = 1;
 
   /* see if we already have the message in body cache */
-  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);
+  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));
   if (msg->fp)
     return 0;
 
@@ -644,7 +661,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno
                        NetInc, h->content->length + h->content->offset - 1);
 
     /* see if we can put in body cache; use our cache as fallback */
-    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);
+    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));
     if (!msg->fp)
     {
       /* no */
@@ -689,7 +706,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno
    * portion of the headers, those required for the main display.
    */
   if (bcache)
-    mutt_bcache_commit(pop_data->bcache, h->data);
+    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));
   else
   {
     cache->index = h->index;
@@ -783,7 +800,7 @@ static int pop_sync_mailbox(struct Context *ctx, int *index_hint)
         ret = pop_query(pop_data, buf, sizeof(buf));
         if (ret == 0)
         {
-          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);
+          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));
 #ifdef USE_HCACHE
           mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));
 #endif",neomutt,9bfab35522301794483f8f9ed60820bdec9be59e,98aad9c3f1fb281e35a966d4a9b01b60db402e7a,0,"static int pop_hcache_namer(const char *path, char *dest, size_t destlen)
{
  return snprintf(dest, destlen, ""%s."" HC_FEXT, path);
}
",79483," static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)
 {
  return snprintf(dest, destlen, ""%s.hcache"", path);
 }
","static int pop_hcache_namer(const char *path, char *dest, size_t destlen)
{
  return snprintf(dest, destlen, ""%s."" HC_FEXT, path);
}
","The function `nntp_hcache_namer` generates a filename for a cache associated with a given path. It takes three parameters: a constant character pointer `path`, a character pointer `dest` for storing the resulting filename, and a size_t `destlen` that specifies the maximum length of the destination buffer. The function uses `snprintf` to format the output by appending "".hcache"" to the provided `path` and stores the result in `dest`. It returns the number of characters that would have been written if enough space had been available, allowing for error handling based on the buffer size.","The code defines a function that creates a formatted filename by appending a specific suffix to a given input string. It takes an input string representing a path, a destination buffer for storing the resulting filename, and a parameter that specifies the maximum size of the destination buffer. The function formats the output by combining the input string with the suffix and writes it to the destination buffer. It also returns the number of characters that would have been written if there were enough space, which can be useful for checking buffer size and handling potential overflow situations.","The vulnerability in the original code, identified as CWE-22, arises from the potential for directory traversal attacks due to the lack of validation on the input `path`. An attacker could manipulate the `path` to include relative path components, leading to the creation of files in unintended directories. The fixed code mitigates this risk by changing the suffix from a hardcoded "".hcache"" to a defined constant `HC_FEXT`, which can be controlled and validated more effectively. This change helps ensure that the output filename adheres to expected formats, reducing the risk of unauthorized file access or manipulation.","The vulnerability identified as CWE-22 in the original code stems from the lack of input validation for a path, allowing for directory traversal attacks. An attacker could exploit this by providing a specially crafted input that includes relative path components, potentially leading to the creation or modification of files outside the intended directory. The fixed code addresses this issue by replacing the hardcoded suffix with a defined constant, which can be more easily controlled and validated. This change helps ensure that the generated filenames conform to expected patterns, thereby reducing the risk of unauthorized file access or manipulation.","The vulnerability was fixed by modifying the function to use a defined constant for the file extension instead of a hardcoded string. In the updated code, the suffix is now represented by `HC_FEXT`, which allows for better control and validation of the output format. This change reduces the risk of directory traversal attacks by ensuring that the generated filename adheres to a specific and expected pattern. Additionally, the function's name was changed to reflect its purpose more accurately, enhancing code clarity and maintainability while addressing the security concern associated with the original implementation.","The vulnerability was fixed by replacing the hardcoded file extension with a defined constant, which allows for better control over the output format. This change enhances security by ensuring that the generated filenames conform to a specific and expected pattern, thereby reducing the risk of directory traversal attacks. Additionally, the function's name was updated to better reflect its purpose, improving code clarity and maintainability. Overall, these modifications help prevent unauthorized file access and manipulation by enforcing stricter rules on how filenames are constructed based on user input."
1,177931,177931,,Remote,Single system,,CVE-2018-14036,https://www.cvedetails.com/cve/CVE-2018-14036/,CWE-22,Low,Partial,,,2018-07-13,4.0,Directory Traversal with ../ sequences occurs in AccountsService before 0.6.50 because of an insufficient path check in user_change_icon_file_authorized_cb() in user.c.,2018-09-06,Dir. Trav.,8,https://cgit.freedesktop.org/accountsservice/commit/?id=f9abd359f71a5bce421b9ae23432f539a067847a,f9abd359f71a5bce421b9ae23432f539a067847a,,0,,,"user_change_icon_file_authorized_cb (Daemon                *daemon,
                                     User                  *user,
                                     GDBusMethodInvocation *context,
                                     gpointer               data)

{
        g_autofree gchar *filename = NULL;
        g_autoptr(GFile) file = NULL;
        g_autoptr(GFileInfo) info = NULL;
        guint32 mode;
        GFileType type;
        guint64 size;

        filename = g_strdup (data);

        if (filename == NULL ||
            *filename == '\0') {
                g_autofree gchar *dest_path = NULL;
                g_autoptr(GFile) dest = NULL;
                g_autoptr(GError) error = NULL;

                g_clear_pointer (&filename, g_free);

                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);
                dest = g_file_new_for_path (dest_path);

                if (!g_file_delete (dest, NULL, &error) &&
                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
                        throw_error (context, ERROR_FAILED, ""failed to remove user icon, %s"", error->message);
                        return;
                }
                goto icon_saved;
         }
 
         file = g_file_new_for_path (filename);
        g_clear_pointer (&filename, g_free);

        /* Canonicalize path so we can call g_str_has_prefix on it
         * below without concern for ../ path components moving outside
         * the prefix
         */
        filename = g_file_get_path (file);

         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,
                return;
        }
","user_change_icon_file_authorized_cb (Daemon                *daemon,
                                     User                  *user,
                                     GDBusMethodInvocation *context,
                                     gpointer               data)

{
        g_autofree gchar *filename = NULL;
        g_autoptr(GFile) file = NULL;
        g_autoptr(GFileInfo) info = NULL;
        guint32 mode;
        GFileType type;
        guint64 size;

        filename = g_strdup (data);

        if (filename == NULL ||
            *filename == '\0') {
                g_autofree gchar *dest_path = NULL;
                g_autoptr(GFile) dest = NULL;
                g_autoptr(GError) error = NULL;

                g_clear_pointer (&filename, g_free);

                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);
                dest = g_file_new_for_path (dest_path);

                if (!g_file_delete (dest, NULL, &error) &&
                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
                        throw_error (context, ERROR_FAILED, ""failed to remove user icon, %s"", error->message);
                        return;
                }
                goto icon_saved;
         }
 
         file = g_file_new_for_path (filename);
         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,
                return;
        }
",C,"        g_clear_pointer (&filename, g_free);

        /* Canonicalize path so we can call g_str_has_prefix on it
         * below without concern for ../ path components moving outside
         * the prefix
         */
        filename = g_file_get_path (file);

",,34bedecf7da81a8b42382254e3f9a32398c1ca5d,"@@ -1334,6 +1334,14 @@ user_change_icon_file_authorized_cb (Daemon                *daemon,
         }
 
         file = g_file_new_for_path (filename);
+        g_clear_pointer (&filename, g_free);
+
+        /* Canonicalize path so we can call g_str_has_prefix on it
+         * below without concern for ../ path components moving outside
+         * the prefix
+         */
+        filename = g_file_get_path (file);
+
         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,",accountsservice,https://cgit.freedesktop.org/accountsservice/tree/src/user.c?id=f9abd359f71a5bce421b9ae23432f539a067847a,https://cgit.freedesktop.org/accountsservice/tree/src/user.c?id=34bedecf7da81a8b42382254e3f9a32398c1ca5d,1,"user_change_icon_file_authorized_cb (Daemon                *daemon,
                                     User                  *user,
                                     GDBusMethodInvocation *context,
                                     gpointer               data)

{
        g_autofree gchar *filename = NULL;
        g_autoptr(GFile) file = NULL;
        g_autoptr(GFileInfo) info = NULL;
        guint32 mode;
        GFileType type;
        guint64 size;

        filename = g_strdup (data);

        if (filename == NULL ||
            *filename == '\0') {
                g_autofree gchar *dest_path = NULL;
                g_autoptr(GFile) dest = NULL;
                g_autoptr(GError) error = NULL;

                g_clear_pointer (&filename, g_free);

                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);
                dest = g_file_new_for_path (dest_path);

                if (!g_file_delete (dest, NULL, &error) &&
                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
                        throw_error (context, ERROR_FAILED, ""failed to remove user icon, %s"", error->message);
                        return;
                }
                goto icon_saved;
         }
 
         file = g_file_new_for_path (filename);
//fix_flaw_line_below:
//        g_clear_pointer (&filename, g_free);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        /* Canonicalize path so we can call g_str_has_prefix on it
//fix_flaw_line_below:
//         * below without concern for ../ path components moving outside
//fix_flaw_line_below:
//         * the prefix
//fix_flaw_line_below:
//         */
//fix_flaw_line_below:
//        filename = g_file_get_path (file);
//fix_flaw_line_below:
//
         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,
                return;
        }
",177931,"user_change_icon_file_authorized_cb (Daemon                *daemon,
                                     User                  *user,
                                     GDBusMethodInvocation *context,
                                     gpointer               data)

{
        g_autofree gchar *filename = NULL;
        g_autoptr(GFile) file = NULL;
        g_autoptr(GFileInfo) info = NULL;
        guint32 mode;
        GFileType type;
        guint64 size;

        filename = g_strdup (data);

        if (filename == NULL ||
            *filename == '\0') {
                g_autofree gchar *dest_path = NULL;
                g_autoptr(GFile) dest = NULL;
                g_autoptr(GError) error = NULL;

                g_clear_pointer (&filename, g_free);

                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);
                dest = g_file_new_for_path (dest_path);

                if (!g_file_delete (dest, NULL, &error) &&
                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
                        throw_error (context, ERROR_FAILED, ""failed to remove user icon, %s"", error->message);
                        return;
                }
                goto icon_saved;
         }
 
         file = g_file_new_for_path (filename);
         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,
                return;
        }
","user_change_icon_file_authorized_cb (Daemon                *daemon,
                                     User                  *user,
                                     GDBusMethodInvocation *context,
                                     gpointer               data)

{
        g_autofree gchar *filename = NULL;
        g_autoptr(GFile) file = NULL;
        g_autoptr(GFileInfo) info = NULL;
        guint32 mode;
        GFileType type;
        guint64 size;

        filename = g_strdup (data);

        if (filename == NULL ||
            *filename == '\0') {
                g_autofree gchar *dest_path = NULL;
                g_autoptr(GFile) dest = NULL;
                g_autoptr(GError) error = NULL;

                g_clear_pointer (&filename, g_free);

                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);
                dest = g_file_new_for_path (dest_path);

                if (!g_file_delete (dest, NULL, &error) &&
                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
                        throw_error (context, ERROR_FAILED, ""failed to remove user icon, %s"", error->message);
                        return;
                }
                goto icon_saved;
         }
 
         file = g_file_new_for_path (filename);
        g_clear_pointer (&filename, g_free);

        /* Canonicalize path so we can call g_str_has_prefix on it
         * below without concern for ../ path components moving outside
         * the prefix
         */
        filename = g_file_get_path (file);

         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,
                return;
        }
","The function `user_change_icon_file_authorized_cb` is a callback designed to handle the process of changing a user's icon file in a daemon context. It begins by attempting to duplicate a filename provided in the `data` parameter. If the filename is empty or null, it constructs a path to the user's icon directory and attempts to delete any existing icon file. If the deletion fails (and the error is not due to the file not being found), it reports an error. If a valid filename is provided, it creates a `GFile` object for the specified path and queries its attributes, such as mode, type, and size, to facilitate further processing.","The provided code defines a callback function that manages the process of updating a user's icon file within a daemon. It first checks if a filename is provided; if not, it constructs a path to the user's icon directory and attempts to delete any existing icon file. If the deletion fails for reasons other than the file not being found, an error is reported. If a valid filename is present, the code creates a file object for that path and retrieves its attributes, such as permissions, type, and size, to facilitate further operations related to the icon update.","The vulnerability in the original code, identified as CWE-22 (Improper Limitation of a Pathname to a Restricted Directory), arises from the use of a user-supplied filename without proper validation, allowing potential directory traversal attacks. An attacker could manipulate the `data` input to specify a path that escapes the intended directory, leading to unauthorized file access or modification. In the fixed code, the path is canonicalized using `g_file_get_path`, ensuring that any relative path components like ""../"" are resolved, thus preventing the possibility of accessing files outside the designated directory and enhancing overall security.","The vulnerability identified as CWE-22 (Improper Limitation of a Pathname to a Restricted Directory) in the original code stems from the lack of validation on a user-supplied filename, which could allow an attacker to exploit directory traversal techniques. This could enable unauthorized access to files outside the intended directory by manipulating the input. The fixed code addresses this issue by ensuring that the path is canonicalized, effectively resolving any relative path components that could lead to directory traversal. This enhancement prevents the possibility of accessing or modifying files beyond the designated directory, thereby improving security.","The vulnerability was fixed by incorporating a path canonicalization step in the updated code. After creating a file object from the user-supplied filename, the code now uses `g_file_get_path` to obtain the canonical path, ensuring that any relative components, such as ""../"", are resolved. This prevents directory traversal attacks by ensuring that the resulting path remains within the intended directory structure. Additionally, the code clears the original filename using `g_clear_pointer`, which helps manage memory and reduces the risk of using stale or invalid data. This combination of measures enhances the security of the file handling process.","The vulnerability was addressed by implementing a mechanism to canonicalize the user-supplied path, ensuring that any potentially malicious relative path components are resolved to their absolute equivalents. This step effectively prevents directory traversal attacks by guaranteeing that the resulting path remains confined within the intended directory structure. Additionally, the code includes a cleanup process to manage memory effectively, reducing the risk of using outdated or invalid data. These enhancements collectively strengthen the security of the file handling process, ensuring that only authorized files within the designated directory can be accessed or modified."
2,178681,178681,,Remote,Not required,,CVE-2014-10073,https://www.cvedetails.com/cve/CVE-2014-10073/,CWE-22,Low,Partial,,,2018-04-20,5.0,The create_response function in server/server.c in Psensor before 1.1.4 allows Directory Traversal because it lacks a check for whether a file is under the webserver directory.,2019-10-03,Dir. Trav.,12,http://git.wpitchoune.net/gitweb/?p=psensor.git;a=commit;h=8b10426dcc0246c1712a99460dd470dcb1cc4d9c,8b10426dcc0246c1712a99460dd470dcb1cc4d9c,,2,,," create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
       char *page, *fpath, *rpath;
        struct MHD_Response *resp = NULL;
       int n;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
               rpath = realpath(fpath, NULL);
               if (rpath) {
                       n = strlen(server_data.www_dir);
                       if (!strncmp(server_data.www_dir, rpath, n))
                               resp = create_response_file(nurl,
                                                           method,
                                                           rp_code,
                                                           fpath);
                       free(rpath);
               }
 
                free(fpath);
        }
}
"," create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
       char *page, *fpath;
        struct MHD_Response *resp = NULL;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
               resp = create_response_file(nurl, method, rp_code, fpath);
 
                free(fpath);
        }
}
",C,"       char *page, *fpath, *rpath;
       int n;
               rpath = realpath(fpath, NULL);
               if (rpath) {
                       n = strlen(server_data.www_dir);
                       if (!strncmp(server_data.www_dir, rpath, n))
                               resp = create_response_file(nurl,
                                                           method,
                                                           rp_code,
                                                           fpath);
                       free(rpath);
               }
","       char *page, *fpath;
               resp = create_response_file(nurl, method, rp_code, fpath);
",30280f0093e8aea4bc8af8a46c2e529e8ec61ac9,"@@ -23,6 +23,7 @@
 #include <libintl.h>
 #define _(str) gettext(str)
 
+#include <limits.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -245,15 +246,25 @@ static struct MHD_Response *create_response_file(const char *nurl,
 static struct MHD_Response *
 create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
-       char *page, *fpath;
+       char *page, *fpath, *rpath;
        struct MHD_Response *resp = NULL;
+       int n;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
-               resp = create_response_file(nurl, method, rp_code, fpath);
+               rpath = realpath(fpath, NULL);
+               if (rpath) {
+                       n = strlen(server_data.www_dir);
+                       if (!strncmp(server_data.www_dir, rpath, n))
+                               resp = create_response_file(nurl,
+                                                           method,
+                                                           rp_code,
+                                                           fpath);
+                       free(rpath);
+               }
 
                free(fpath);
        }
@@ -349,7 +360,7 @@ int main(int argc, char *argv[])
                switch (optc) {
                case 'w':
                        if (optarg)
-                               server_data.www_dir = strdup(optarg);
+                               server_data.www_dir = realpath(optarg, NULL);
                        break;
                case 'p':
                        if (optarg)
@@ -388,8 +399,14 @@ int main(int argc, char *argv[])
                exit(EXIT_FAILURE);
        }
 
-       if (!server_data.www_dir)
-               server_data.www_dir = strdup(DEFAULT_WWW_DIR);
+       if (!server_data.www_dir) {
+               server_data.www_dir = realpath(DEFAULT_WWW_DIR, NULL);
+               if (!server_data.www_dir) {
+                       fprintf(stderr,
+                               _(""Webserver directory does not exist.\n""));
+                       exit(EXIT_FAILURE);
+               }
+       }
 
        if (!log_file)
                log_file = strdup(DEFAULT_LOG_FILE);",wpitchoune,http://git.wpitchoune.net/gitweb/?p=psensor.git;a=blob;f=src/server/server.c;h=95998c8deb916813798042df837170f2600170c4;hb=95998c8deb916813798042df837170f2600170c4,http://git.wpitchoune.net/gitweb/?p=psensor.git;a=blob;f=src/server/server.c;h=3db6828760f47e0d0a081a519b3b79d3158c5b08;hb=3db6828760f47e0d0a081a519b3b79d3158c5b08,1," create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
//flaw_line_below:
       char *page, *fpath;
//fix_flaw_line_below:
//       char *page, *fpath, *rpath;
        struct MHD_Response *resp = NULL;
//fix_flaw_line_below:
//       int n;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
//flaw_line_below:
               resp = create_response_file(nurl, method, rp_code, fpath);
//fix_flaw_line_below:
//               rpath = realpath(fpath, NULL);
//fix_flaw_line_below:
//               if (rpath) {
//fix_flaw_line_below:
//                       n = strlen(server_data.www_dir);
//fix_flaw_line_below:
//                       if (!strncmp(server_data.www_dir, rpath, n))
//fix_flaw_line_below:
//                               resp = create_response_file(nurl,
//fix_flaw_line_below:
//                                                           method,
//fix_flaw_line_below:
//                                                           rp_code,
//fix_flaw_line_below:
//                                                           fpath);
//fix_flaw_line_below:
//                       free(rpath);
//fix_flaw_line_below:
//               }
 
                free(fpath);
        }
}
",178681," create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
       char *page, *fpath;
        struct MHD_Response *resp = NULL;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
               resp = create_response_file(nurl, method, rp_code, fpath);
 
                free(fpath);
        }
}
"," create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
       char *page, *fpath, *rpath;
        struct MHD_Response *resp = NULL;
       int n;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
               rpath = realpath(fpath, NULL);
               if (rpath) {
                       n = strlen(server_data.www_dir);
                       if (!strncmp(server_data.www_dir, rpath, n))
                               resp = create_response_file(nurl,
                                                           method,
                                                           rp_code,
                                                           fpath);
                       free(rpath);
               }
 
                free(fpath);
        }
}
","The `create_response` function generates an HTTP response based on the provided URL (`nurl`) and HTTP method (`method`). It first checks if the URL starts with a predefined base API path (`URL_BASE_API_1_1`); if so, it calls the `create_response_api` function to handle the request. If the URL does not match the API path, it retrieves the corresponding file path using `get_path`, then creates a file response using `create_response_file`. Finally, it frees the allocated memory for the file path before returning the response object, which is stored in the `resp` variable.","The function is designed to generate an appropriate HTTP response based on the input URL and HTTP method. It first checks if the URL corresponds to a specific API endpoint; if it does, it processes the request using a dedicated API handling mechanism. If the URL does not match the API, the function determines the file path associated with the URL and creates a response based on the contents of that file. After generating the response, it ensures that any dynamically allocated memory for the file path is properly released, maintaining efficient memory management.","The vulnerability in the original code arises from the potential for directory traversal attacks, where an attacker could manipulate the input URL to access files outside the intended directory. This occurs because the function retrieves the file path using `get_path` without validating that it resides within the designated web directory. In the fixed code, the addition of `realpath` ensures that the resolved file path is checked against the base web directory. By comparing the resolved path with the expected directory, the code mitigates the risk of unauthorized file access, thus addressing the vulnerability identified by CWE-22.","The vulnerability in the original code stems from the lack of validation for file paths derived from user input, allowing for directory traversal attacks. An attacker could manipulate the input to access files outside the intended directory, potentially exposing sensitive data. The fixed code addresses this issue by implementing a mechanism to resolve the actual file path and verify that it resides within the designated web directory. This additional validation step ensures that only authorized files can be accessed, effectively mitigating the risk of unauthorized file access and enhancing the overall security of the application.","The vulnerability was fixed by introducing a validation step that uses the `realpath` function to resolve the actual file path derived from the user input. After obtaining the file path with `get_path`, the code checks if the resolved path is within the designated web directory by comparing it to `server_data.www_dir`. This ensures that only files located within the intended directory can be accessed. If the resolved path matches the expected directory, the code proceeds to create the response using `create_response_file`. This additional validation effectively mitigates the risk of directory traversal attacks.","The vulnerability was fixed by adding a validation mechanism that resolves the actual file path derived from user input and checks it against the designated web directory. This process ensures that the resolved path is contained within the intended directory, preventing unauthorized access to files outside of it. By verifying that the user-supplied path does not lead to sensitive or restricted files, the code effectively mitigates the risk of directory traversal attacks. This enhancement strengthens the security of the application by ensuring that only legitimate files can be accessed based on the user's request."
3,179722,179722,,Remote,Not required,Partial,CVE-2011-3602,https://www.cvedetails.com/cve/CVE-2011-3602/,CWE-22,Low,,Partial,,2014-04-27,6.4,"Directory traversal vulnerability in device-linux.c in the router advertisement daemon (radvd) before 1.8.2 allows local users to overwrite arbitrary files, and remote attackers to overwrite certain files, via a .. (dot dot) in an interface name.  NOTE: this can be leveraged with a symlink to overwrite arbitrary files.",2014-04-28,Dir. Trav. ,4,https://github.com/reubenhwk/radvd/commit/92e22ca23e52066da2258df8c76a2dca8a428bcc,92e22ca23e52066da2258df8c76a2dca8a428bcc,"set_interface_var() doesn't check interface name and blindly does
fopen(path ""/"" ifname, ""w"") on it.  As ""ifname"" is an untrusted input, it
should be checked for "".."" and/or ""/"" in it.  Otherwise, an infected
unprivileged daemon may overwrite contents of file named ""mtu"",
""hoplimit"", etc. in arbitrary location with arbitrary 32-bit value in
decimal representation (""%d"").  If an attacker has a local account or
may create arbitrary symlinks with these names in any location (e.g.
/tmp), any file may be overwritten with a decimal value.",0,device-linux.c,"{""sha"": ""709eebc630e69faa8f5300a45f39c70742fa5add"", ""filename"": ""device-linux.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/reubenhwk/radvd/blob/92e22ca23e52066da2258df8c76a2dca8a428bcc/device-linux.c"", ""raw_url"": ""https://github.com/reubenhwk/radvd/raw/92e22ca23e52066da2258df8c76a2dca8a428bcc/device-linux.c"", ""contents_url"": ""https://api.github.com/repos/reubenhwk/radvd/contents/device-linux.c?ref=92e22ca23e52066da2258df8c76a2dca8a428bcc"", ""patch"": ""@@ -243,6 +243,10 @@ set_interface_var(const char *iface,\n \tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n \t\treturn -1;\n \n+\t/* No path traversal */\n+\tif (strstr(name, \""..\"") || strchr(name, '/'))\n+\t\treturn -1;\n+\n \tif (access(spath, F_OK) != 0)\n \t\treturn -1;\n ""}","set_interface_var(const char *iface,
		  const char *var, const char *name,
		  uint32_t val)
{
	FILE *fp;
	char spath[64+IFNAMSIZ];	/* XXX: magic constant */
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
	/* No path traversal */
	if (strstr(name, "".."") || strchr(name, '/'))
		return -1;

 	if (access(spath, F_OK) != 0)
 		return -1;
 
	fp = fopen(spath, ""w"");
	if (!fp) {
		if (name)
			flog(LOG_ERR, ""failed to set %s (%u) for %s: %s"",
			     name, val, iface, strerror(errno));
		return -1;
	}
	fprintf(fp, ""%u"", val);
	fclose(fp);

	return 0;
}
","set_interface_var(const char *iface,
		  const char *var, const char *name,
		  uint32_t val)
{
	FILE *fp;
	char spath[64+IFNAMSIZ];	/* XXX: magic constant */
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
 	if (access(spath, F_OK) != 0)
 		return -1;
 
	fp = fopen(spath, ""w"");
	if (!fp) {
		if (name)
			flog(LOG_ERR, ""failed to set %s (%u) for %s: %s"",
			     name, val, iface, strerror(errno));
		return -1;
	}
	fprintf(fp, ""%u"", val);
	fclose(fp);

	return 0;
}
",C,"	/* No path traversal */
	if (strstr(name, "".."") || strchr(name, '/'))
		return -1;

",,,"@@ -243,6 +243,10 @@ set_interface_var(const char *iface,
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
+	/* No path traversal */
+	if (strstr(name, "".."") || strchr(name, '/'))
+		return -1;
+
 	if (access(spath, F_OK) != 0)
 		return -1;
 ",radvd,92e22ca23e52066da2258df8c76a2dca8a428bcc,9dfaaaf740ce784541e76e68de4ae04dce2c0921,1,"set_interface_var(const char *iface,
		  const char *var, const char *name,
		  uint32_t val)
{
	FILE *fp;
	char spath[64+IFNAMSIZ];	/* XXX: magic constant */
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
//fix_flaw_line_below:
//	/* No path traversal */
//fix_flaw_line_below:
//	if (strstr(name, "".."") || strchr(name, '/'))
//fix_flaw_line_below:
//		return -1;
//fix_flaw_line_below:
//
 	if (access(spath, F_OK) != 0)
 		return -1;
 
	fp = fopen(spath, ""w"");
	if (!fp) {
		if (name)
			flog(LOG_ERR, ""failed to set %s (%u) for %s: %s"",
			     name, val, iface, strerror(errno));
		return -1;
	}
	fprintf(fp, ""%u"", val);
	fclose(fp);

	return 0;
}
",179722,"set_interface_var(const char *iface,
		  const char *var, const char *name,
		  uint32_t val)
{
	FILE *fp;
	char spath[64+IFNAMSIZ];	/* XXX: magic constant */
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
 	if (access(spath, F_OK) != 0)
 		return -1;
 
	fp = fopen(spath, ""w"");
	if (!fp) {
		if (name)
			flog(LOG_ERR, ""failed to set %s (%u) for %s: %s"",
			     name, val, iface, strerror(errno));
		return -1;
	}
	fprintf(fp, ""%u"", val);
	fclose(fp);

	return 0;
}
","set_interface_var(const char *iface,
		  const char *var, const char *name,
		  uint32_t val)
{
	FILE *fp;
	char spath[64+IFNAMSIZ];	/* XXX: magic constant */
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
	/* No path traversal */
	if (strstr(name, "".."") || strchr(name, '/'))
		return -1;

 	if (access(spath, F_OK) != 0)
 		return -1;
 
	fp = fopen(spath, ""w"");
	if (!fp) {
		if (name)
			flog(LOG_ERR, ""failed to set %s (%u) for %s: %s"",
			     name, val, iface, strerror(errno));
		return -1;
	}
	fprintf(fp, ""%u"", val);
	fclose(fp);

	return 0;
}
","The `set_interface_var` function is designed to set a specific variable for a network interface by writing a given unsigned integer value to a file corresponding to that variable. It takes four parameters: the interface name (`iface`), the variable format string (`var`), an optional name for logging purposes (`name`), and the value to be written (`val`). The function constructs a file path using the interface name and checks if the file exists. If the file is accessible, it opens it for writing, logs an error if it fails, writes the value, and then closes the file, returning 0 on success or -1 on failure.","The provided code defines a function that sets a specific configuration value for a network interface by writing it to a designated file. It constructs a file path based on the interface name and checks for the file's existence. If the file is found, it attempts to open it for writing. In case of failure to open the file, an error message is logged if a name is provided. If successful, the function writes the specified value to the file and then closes it, returning a success indicator, while handling errors appropriately throughout the process.","The vulnerability in the original code, identified as CWE-22 (Improper Limitation of a Pathname to a Restricted Directory), arises from the potential for path traversal attacks. Specifically, the function constructs a file path using user-supplied input without validating it, allowing an attacker to manipulate the `iface` or `var` parameters to access unintended files. The fixed code addresses this issue by adding checks to ensure that the `name` parameter does not contain directory traversal sequences (like "".."") or path separators (""/""). This validation prevents unauthorized access to files outside the intended directory, thereby enhancing security.","The vulnerability in the original code, classified as CWE-22 (Improper Limitation of a Pathname to a Restricted Directory), stems from the lack of validation on user-supplied input used to construct file paths. This oversight allows an attacker to exploit the code by including directory traversal sequences, potentially gaining access to sensitive files outside the intended directory. The fixed code mitigates this risk by implementing checks that disallow any input containing directory traversal patterns or path separators. This enhancement ensures that only valid and expected file paths are processed, thereby preventing unauthorized file access and improving overall security.","The vulnerability was fixed by adding a validation check for the `name` parameter in the modified code. Specifically, the code now includes conditions that check for the presence of directory traversal sequences, such as "".."", and path separators, like ""/"". If either of these is detected in the `name`, the function immediately returns an error, preventing any potential path traversal attacks. This additional validation step ensures that only safe and expected input is processed when constructing the file path with `snprintf`, thereby securing the file access operation against unauthorized access to sensitive files.","The vulnerability was fixed by implementing input validation to prevent directory traversal attacks. The updated code includes checks that disallow any input containing sequences that could navigate to parent directories or include path separators. By rejecting such input, the code ensures that only valid and expected file paths are constructed, thereby preventing unauthorized access to files outside the intended directory. This enhancement effectively mitigates the risk of exploitation by ensuring that user-supplied data cannot manipulate the file path in a way that compromises the security of the system."
4,179899,179899,,Remote,Not required,,CVE-2015-1191,https://www.cvedetails.com/cve/CVE-2015-1191/,CWE-22,Low,,Partial,,2015-01-21,5.0,Multiple directory traversal vulnerabilities in pigz 2.3.1 allow remote attackers to write to arbitrary files via a (1) full pathname or (2) .. (dot dot) in an archive.,2016-12-02,Dir. Trav. ,23,https://github.com/madler/pigz/commit/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,"When decompressing with -N or -NT, strip any path from header name.

This uses the path of the compressed file combined with the name
from the header as the name of the decompressed output file.  Any
path information in the header name is stripped.  This avoids a
possible vulnerability where absolute or descending paths are put
in the gzip header.",12,pigz.c,"{""sha"": ""38c0d4fec22f33537cc3b26a5e13946a3514c4f1"", ""filename"": ""pigz.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 14, ""changes"": 37, ""blob_url"": ""https://github.com/madler/pigz/blob/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f/pigz.c"", ""raw_url"": ""https://github.com/madler/pigz/raw/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f/pigz.c"", ""contents_url"": ""https://api.github.com/repos/madler/pigz/contents/pigz.c?ref=fdad1406b3ec809f4954ff7cdf9e99eb18c2458f"", ""patch"": ""@@ -3520,26 +3520,35 @@ local void process(char *path)\n                  \"" (use -f to force)\"");\n     }\n     else {\n-        char *to, *repl;\n-\n-        /* use header name for output when decompressing with -N */\n-        to = g.inf;\n-        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {\n-            to = g.hname;\n-            len = strlen(g.hname);\n+        char *to = g.inf, *sufx = \""\"";\n+        size_t pre = 0;\n+\n+        /* select parts of the output file name */\n+        if (g.decode) {\n+            /* for -dN or -dNT, use the path from the input file and the name\n+               from the header, stripping any path in the header name */\n+            if ((g.headis & 1) != 0 && g.hname != NULL) {\n+                pre = justname(g.inf) - g.inf;\n+                to = justname(g.hname);\n+                len = strlen(to);\n+            }\n+            /* for -d or -dNn, replace abbreviated suffixes */\n+            else if (strcmp(to + len, \"".tgz\"") == 0)\n+                sufx = \"".tar\"";\n         }\n-\n-        /* replace .tgz with .tar when decoding */\n-        repl = g.decode && strcmp(to + len, \"".tgz\"") ? \""\"" : \"".tar\"";\n+        else\n+            /* add appropriate suffix when compressing */\n+            sufx = g.sufx;\n \n         /* create output file and open to write */\n-        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);\n+        g.outf = MALLOC(pre + len + strlen(sufx) + 1);\n         if (g.outf == NULL)\n             bail(\""not enough memory\"", \""\"");\n-        memcpy(g.outf, to, len);\n-        strcpy(g.outf + len, g.decode ? repl : g.sufx);\n+        memcpy(g.outf, g.inf, pre);\n+        memcpy(g.outf + pre, to, len);\n+        strcpy(g.outf + pre + len, sufx);\n         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |\n-                             (g.force ? 0 : O_EXCL), 0600);\n+                              (g.force ? 0 : O_EXCL), 0600);\n \n         /* if exists and not -f, give user a chance to overwrite */\n         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {""}","local void process(char *path)
{
    int method = -1;                /* get_header() return value */
    size_t len;                     /* length of base name (minus suffix) */
    struct stat st;                 /* to get file type and mod time */
    /* all compressed suffixes for decoding search, in length order */
    static char *sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"",
                           "".zip"", "".ZIP"", "".tgz"", NULL};

    /* open input file with name in, descriptor ind -- set name and mtime */
    if (path == NULL) {
        strcpy(g.inf, ""<stdin>"");
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ?
                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
        len = 0;
    }
    else {
        /* set input file name (already set if recursed here) */
        if (path != g.inf) {
            strncpy(g.inf, path, sizeof(g.inf));
            if (g.inf[sizeof(g.inf) - 1])
                bail(""name too long: "", path);
        }
        len = strlen(g.inf);

        /* try to stat input file -- if not there and decoding, look for that
           name with compressed suffixes */
        if (lstat(g.inf, &st)) {
            if (errno == ENOENT && (g.list || g.decode)) {
                char **try = sufs;
                do {
                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))
                        break;
                    strcpy(g.inf + len, *try++);
                    errno = 0;
                } while (lstat(g.inf, &st) && errno == ENOENT);
            }
#ifdef EOVERFLOW
            if (errno == EOVERFLOW || errno == EFBIG)
                bail(g.inf,
                    "" too large -- not compiled with large file support"");
#endif
            if (errno) {
                g.inf[len] = 0;
                complain(""%s does not exist -- skipping"", g.inf);
                return;
            }
            len = strlen(g.inf);
        }

        /* only process regular files, but allow symbolic links if -f,
           recurse into directory if -r */
        if ((st.st_mode & S_IFMT) != S_IFREG &&
            (st.st_mode & S_IFMT) != S_IFLNK &&
            (st.st_mode & S_IFMT) != S_IFDIR) {
            complain(""%s is a special file or device -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
            complain(""%s is a symbolic link -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
            complain(""%s is a directory -- skipping"", g.inf);
            return;
        }

        /* recurse into directory (assumes Unix) */
        if ((st.st_mode & S_IFMT) == S_IFDIR) {
            char *roll, *item, *cut, *base, *bigger;
            size_t len, hold;
            DIR *here;
            struct dirent *next;

            /* accumulate list of entries (need to do this, since readdir()
               behavior not defined if directory modified between calls) */
            here = opendir(g.inf);
            if (here == NULL)
                return;
            hold = 512;
            roll = MALLOC(hold);
            if (roll == NULL)
                bail(""not enough memory"", """");
            *roll = 0;
            item = roll;
            while ((next = readdir(here)) != NULL) {
                if (next->d_name[0] == 0 ||
                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                     (next->d_name[1] == '.' && next->d_name[2] == 0))))
                    continue;
                len = strlen(next->d_name) + 1;
                if (item + len + 1 > roll + hold) {
                    do {                    /* make roll bigger */
                        hold <<= 1;
                    } while (item + len + 1 > roll + hold);
                    bigger = REALLOC(roll, hold);
                    if (bigger == NULL) {
                        FREE(roll);
                        bail(""not enough memory"", """");
                    }
                    item = bigger + (item - roll);
                    roll = bigger;
                }
                strcpy(item, next->d_name);
                item += len;
                *item = 0;
            }
            closedir(here);

            /* run process() for each entry in the directory */
            cut = base = g.inf + strlen(g.inf);
            if (base > g.inf && base[-1] != (unsigned char)'/') {
                if ((size_t)(base - g.inf) >= sizeof(g.inf))
                    bail(""path too long"", g.inf);
                *base++ = '/';
            }
            item = roll;
            while (*item) {
                strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                if (g.inf[sizeof(g.inf) - 1]) {
                    strcpy(g.inf + (sizeof(g.inf) - 4), ""..."");
                    bail(""path too long: "", g.inf);
                }
                process(g.inf);
                item += strlen(item) + 1;
            }
            *cut = 0;

            /* release list of entries */
            FREE(roll);
            return;
        }

        /* don't compress .gz (or provided suffix) files, unless -f */
        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&
                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
            complain(""%s ends with %s -- skipping"", g.inf, g.sufx);
            return;
        }

        /* create output file only if input file has compressed suffix */
        if (g.decode == 1 && !g.pipeout && !g.list) {
            int suf = compressed_suffix(g.inf);
            if (suf == 0) {
                complain(""%s does not have compressed suffix -- skipping"",
                         g.inf);
                return;
            }
            len -= suf;
        }

        /* open input file */
        g.ind = open(g.inf, O_RDONLY, 0);
        if (g.ind < 0)
            bail(""read error on "", g.inf);

        /* prepare gzip header information for compression */
        g.name = g.headis & 1 ? justname(g.inf) : NULL;
        g.mtime = g.headis & 2 ? st.st_mtime : 0;
    }
    SET_BINARY_MODE(g.ind);

    /* if decoding or testing, try to read gzip header */
    g.hname = NULL;
    if (g.decode) {
        in_init();
        method = get_header(1);
        if (method != 8 && method != 257 &&
                /* gzip -cdf acts like cat on uncompressed input */
                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&
                  !g.list)) {
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            if (method != -1)
                complain(method < 0 ? ""%s is not compressed -- skipping"" :
                         ""%s has unknown compression method -- skipping"",
                         g.inf);
            return;
        }

        /* if requested, test input file (possibly a special list) */
        if (g.decode == 2) {
            if (method == 8)
                infchk();
            else {
                unlzw();
                if (g.list) {
                    g.in_tot -= 3;
                    show_info(method, 0, g.out_tot, 0);
                }
            }
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }
    }

    /* if requested, just list information about input file */
    if (g.list) {
        list_info();
        RELEASE(g.hname);
        if (g.ind != 0)
            close(g.ind);
        return;
    }

    /* create output file out, descriptor outd */
    if (path == NULL || g.pipeout) {
        /* write to stdout */
        g.outf = MALLOC(strlen(""<stdout>"") + 1);
        if (g.outf == NULL)
            bail(""not enough memory"", """");
        strcpy(g.outf, ""<stdout>"");
        g.outd = 1;
        if (!g.decode && !g.force && isatty(g.outd))
            bail(""trying to write compressed data to a terminal"",
                  "" (use -f to force)"");
     }
     else {
        char *to = g.inf, *sufx = """";
        size_t pre = 0;

        /* select parts of the output file name */
        if (g.decode) {
            /* for -dN or -dNT, use the path from the input file and the name
               from the header, stripping any path in the header name */
            if ((g.headis & 1) != 0 && g.hname != NULL) {
                pre = justname(g.inf) - g.inf;
                to = justname(g.hname);
                len = strlen(to);
            }
            /* for -d or -dNn, replace abbreviated suffixes */
            else if (strcmp(to + len, "".tgz"") == 0)
                sufx = "".tar"";
         }
        else
            /* add appropriate suffix when compressing */
            sufx = g.sufx;
 
         /* create output file and open to write */
        g.outf = MALLOC(pre + len + strlen(sufx) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
        memcpy(g.outf, g.inf, pre);
        memcpy(g.outf + pre, to, len);
        strcpy(g.outf + pre + len, sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
                              (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
            int ch, reply;

            fprintf(stderr, ""%s exists -- overwrite (y/n)? "", g.outf);
            fflush(stderr);
            reply = -1;
            do {
                ch = getchar();
                if (reply < 0 && ch != ' ' && ch != '\t')
                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;
            } while (ch != EOF && ch != '\n' && ch != '\r');
            if (reply == 1)
                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                              0600);
        }

        /* if exists and no overwrite, report and go on to next */
        if (g.outd < 0 && errno == EEXIST) {
            complain(""%s exists -- skipping"", g.outf);
            RELEASE(g.outf);
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }

        /* if some other error, give up */
        if (g.outd < 0)
            bail(""write error on "", g.outf);
    }
    SET_BINARY_MODE(g.outd);
    RELEASE(g.hname);

    /* process ind to outd */
    if (g.verbosity > 1)
        fprintf(stderr, ""%s to %s "", g.inf, g.outf);
    if (g.decode) {
        if (method == 8)
            infchk();
        else if (method == 257)
            unlzw();
        else
            cat();
    }
#ifndef NOTHREAD
    else if (g.procs > 1)
        parallel_compress();
#endif
    else
        single_compress(0);
    if (g.verbosity > 1) {
        putc('\n', stderr);
        fflush(stderr);
    }

    /* finish up, copy attributes, set times, delete original */
    if (g.ind != 0)
        close(g.ind);
    if (g.outd != 1) {
        if (close(g.outd))
            bail(""write error on "", g.outf);
        g.outd = -1;            /* now prevent deletion on interrupt */
        if (g.ind != 0) {
            copymeta(g.inf, g.outf);
            if (!g.keep)
                unlink(g.inf);
        }
        if (g.decode && (g.headis & 2) != 0 && g.stamp)
            touch(g.outf, g.stamp);
    }
    RELEASE(g.outf);
}
","local void process(char *path)
{
    int method = -1;                /* get_header() return value */
    size_t len;                     /* length of base name (minus suffix) */
    struct stat st;                 /* to get file type and mod time */
    /* all compressed suffixes for decoding search, in length order */
    static char *sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"",
                           "".zip"", "".ZIP"", "".tgz"", NULL};

    /* open input file with name in, descriptor ind -- set name and mtime */
    if (path == NULL) {
        strcpy(g.inf, ""<stdin>"");
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ?
                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
        len = 0;
    }
    else {
        /* set input file name (already set if recursed here) */
        if (path != g.inf) {
            strncpy(g.inf, path, sizeof(g.inf));
            if (g.inf[sizeof(g.inf) - 1])
                bail(""name too long: "", path);
        }
        len = strlen(g.inf);

        /* try to stat input file -- if not there and decoding, look for that
           name with compressed suffixes */
        if (lstat(g.inf, &st)) {
            if (errno == ENOENT && (g.list || g.decode)) {
                char **try = sufs;
                do {
                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))
                        break;
                    strcpy(g.inf + len, *try++);
                    errno = 0;
                } while (lstat(g.inf, &st) && errno == ENOENT);
            }
#ifdef EOVERFLOW
            if (errno == EOVERFLOW || errno == EFBIG)
                bail(g.inf,
                    "" too large -- not compiled with large file support"");
#endif
            if (errno) {
                g.inf[len] = 0;
                complain(""%s does not exist -- skipping"", g.inf);
                return;
            }
            len = strlen(g.inf);
        }

        /* only process regular files, but allow symbolic links if -f,
           recurse into directory if -r */
        if ((st.st_mode & S_IFMT) != S_IFREG &&
            (st.st_mode & S_IFMT) != S_IFLNK &&
            (st.st_mode & S_IFMT) != S_IFDIR) {
            complain(""%s is a special file or device -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
            complain(""%s is a symbolic link -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
            complain(""%s is a directory -- skipping"", g.inf);
            return;
        }

        /* recurse into directory (assumes Unix) */
        if ((st.st_mode & S_IFMT) == S_IFDIR) {
            char *roll, *item, *cut, *base, *bigger;
            size_t len, hold;
            DIR *here;
            struct dirent *next;

            /* accumulate list of entries (need to do this, since readdir()
               behavior not defined if directory modified between calls) */
            here = opendir(g.inf);
            if (here == NULL)
                return;
            hold = 512;
            roll = MALLOC(hold);
            if (roll == NULL)
                bail(""not enough memory"", """");
            *roll = 0;
            item = roll;
            while ((next = readdir(here)) != NULL) {
                if (next->d_name[0] == 0 ||
                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                     (next->d_name[1] == '.' && next->d_name[2] == 0))))
                    continue;
                len = strlen(next->d_name) + 1;
                if (item + len + 1 > roll + hold) {
                    do {                    /* make roll bigger */
                        hold <<= 1;
                    } while (item + len + 1 > roll + hold);
                    bigger = REALLOC(roll, hold);
                    if (bigger == NULL) {
                        FREE(roll);
                        bail(""not enough memory"", """");
                    }
                    item = bigger + (item - roll);
                    roll = bigger;
                }
                strcpy(item, next->d_name);
                item += len;
                *item = 0;
            }
            closedir(here);

            /* run process() for each entry in the directory */
            cut = base = g.inf + strlen(g.inf);
            if (base > g.inf && base[-1] != (unsigned char)'/') {
                if ((size_t)(base - g.inf) >= sizeof(g.inf))
                    bail(""path too long"", g.inf);
                *base++ = '/';
            }
            item = roll;
            while (*item) {
                strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                if (g.inf[sizeof(g.inf) - 1]) {
                    strcpy(g.inf + (sizeof(g.inf) - 4), ""..."");
                    bail(""path too long: "", g.inf);
                }
                process(g.inf);
                item += strlen(item) + 1;
            }
            *cut = 0;

            /* release list of entries */
            FREE(roll);
            return;
        }

        /* don't compress .gz (or provided suffix) files, unless -f */
        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&
                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
            complain(""%s ends with %s -- skipping"", g.inf, g.sufx);
            return;
        }

        /* create output file only if input file has compressed suffix */
        if (g.decode == 1 && !g.pipeout && !g.list) {
            int suf = compressed_suffix(g.inf);
            if (suf == 0) {
                complain(""%s does not have compressed suffix -- skipping"",
                         g.inf);
                return;
            }
            len -= suf;
        }

        /* open input file */
        g.ind = open(g.inf, O_RDONLY, 0);
        if (g.ind < 0)
            bail(""read error on "", g.inf);

        /* prepare gzip header information for compression */
        g.name = g.headis & 1 ? justname(g.inf) : NULL;
        g.mtime = g.headis & 2 ? st.st_mtime : 0;
    }
    SET_BINARY_MODE(g.ind);

    /* if decoding or testing, try to read gzip header */
    g.hname = NULL;
    if (g.decode) {
        in_init();
        method = get_header(1);
        if (method != 8 && method != 257 &&
                /* gzip -cdf acts like cat on uncompressed input */
                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&
                  !g.list)) {
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            if (method != -1)
                complain(method < 0 ? ""%s is not compressed -- skipping"" :
                         ""%s has unknown compression method -- skipping"",
                         g.inf);
            return;
        }

        /* if requested, test input file (possibly a special list) */
        if (g.decode == 2) {
            if (method == 8)
                infchk();
            else {
                unlzw();
                if (g.list) {
                    g.in_tot -= 3;
                    show_info(method, 0, g.out_tot, 0);
                }
            }
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }
    }

    /* if requested, just list information about input file */
    if (g.list) {
        list_info();
        RELEASE(g.hname);
        if (g.ind != 0)
            close(g.ind);
        return;
    }

    /* create output file out, descriptor outd */
    if (path == NULL || g.pipeout) {
        /* write to stdout */
        g.outf = MALLOC(strlen(""<stdout>"") + 1);
        if (g.outf == NULL)
            bail(""not enough memory"", """");
        strcpy(g.outf, ""<stdout>"");
        g.outd = 1;
        if (!g.decode && !g.force && isatty(g.outd))
            bail(""trying to write compressed data to a terminal"",
                  "" (use -f to force)"");
     }
     else {
        char *to, *repl;
        /* use header name for output when decompressing with -N */
        to = g.inf;
        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
            to = g.hname;
            len = strlen(g.hname);
         }
        /* replace .tgz with .tar when decoding */
        repl = g.decode && strcmp(to + len, "".tgz"") ? """" : "".tar"";
 
         /* create output file and open to write */
        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
        memcpy(g.outf, to, len);
        strcpy(g.outf + len, g.decode ? repl : g.sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
                             (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
            int ch, reply;

            fprintf(stderr, ""%s exists -- overwrite (y/n)? "", g.outf);
            fflush(stderr);
            reply = -1;
            do {
                ch = getchar();
                if (reply < 0 && ch != ' ' && ch != '\t')
                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;
            } while (ch != EOF && ch != '\n' && ch != '\r');
            if (reply == 1)
                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                              0600);
        }

        /* if exists and no overwrite, report and go on to next */
        if (g.outd < 0 && errno == EEXIST) {
            complain(""%s exists -- skipping"", g.outf);
            RELEASE(g.outf);
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }

        /* if some other error, give up */
        if (g.outd < 0)
            bail(""write error on "", g.outf);
    }
    SET_BINARY_MODE(g.outd);
    RELEASE(g.hname);

    /* process ind to outd */
    if (g.verbosity > 1)
        fprintf(stderr, ""%s to %s "", g.inf, g.outf);
    if (g.decode) {
        if (method == 8)
            infchk();
        else if (method == 257)
            unlzw();
        else
            cat();
    }
#ifndef NOTHREAD
    else if (g.procs > 1)
        parallel_compress();
#endif
    else
        single_compress(0);
    if (g.verbosity > 1) {
        putc('\n', stderr);
        fflush(stderr);
    }

    /* finish up, copy attributes, set times, delete original */
    if (g.ind != 0)
        close(g.ind);
    if (g.outd != 1) {
        if (close(g.outd))
            bail(""write error on "", g.outf);
        g.outd = -1;            /* now prevent deletion on interrupt */
        if (g.ind != 0) {
            copymeta(g.inf, g.outf);
            if (!g.keep)
                unlink(g.inf);
        }
        if (g.decode && (g.headis & 2) != 0 && g.stamp)
            touch(g.outf, g.stamp);
    }
    RELEASE(g.outf);
}
",C,"        char *to = g.inf, *sufx = """";
        size_t pre = 0;

        /* select parts of the output file name */
        if (g.decode) {
            /* for -dN or -dNT, use the path from the input file and the name
               from the header, stripping any path in the header name */
            if ((g.headis & 1) != 0 && g.hname != NULL) {
                pre = justname(g.inf) - g.inf;
                to = justname(g.hname);
                len = strlen(to);
            }
            /* for -d or -dNn, replace abbreviated suffixes */
            else if (strcmp(to + len, "".tgz"") == 0)
                sufx = "".tar"";
        else
            /* add appropriate suffix when compressing */
            sufx = g.sufx;
        g.outf = MALLOC(pre + len + strlen(sufx) + 1);
        memcpy(g.outf, g.inf, pre);
        memcpy(g.outf + pre, to, len);
        strcpy(g.outf + pre + len, sufx);
                              (g.force ? 0 : O_EXCL), 0600);
","        char *to, *repl;
        /* use header name for output when decompressing with -N */
        to = g.inf;
        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
            to = g.hname;
            len = strlen(g.hname);
        /* replace .tgz with .tar when decoding */
        repl = g.decode && strcmp(to + len, "".tgz"") ? """" : "".tar"";
        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
        memcpy(g.outf, to, len);
        strcpy(g.outf + len, g.decode ? repl : g.sufx);
                             (g.force ? 0 : O_EXCL), 0600);
",,"@@ -3520,26 +3520,35 @@ local void process(char *path)
                  "" (use -f to force)"");
     }
     else {
-        char *to, *repl;
-
-        /* use header name for output when decompressing with -N */
-        to = g.inf;
-        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
-            to = g.hname;
-            len = strlen(g.hname);
+        char *to = g.inf, *sufx = """";
+        size_t pre = 0;
+
+        /* select parts of the output file name */
+        if (g.decode) {
+            /* for -dN or -dNT, use the path from the input file and the name
+               from the header, stripping any path in the header name */
+            if ((g.headis & 1) != 0 && g.hname != NULL) {
+                pre = justname(g.inf) - g.inf;
+                to = justname(g.hname);
+                len = strlen(to);
+            }
+            /* for -d or -dNn, replace abbreviated suffixes */
+            else if (strcmp(to + len, "".tgz"") == 0)
+                sufx = "".tar"";
         }
-
-        /* replace .tgz with .tar when decoding */
-        repl = g.decode && strcmp(to + len, "".tgz"") ? """" : "".tar"";
+        else
+            /* add appropriate suffix when compressing */
+            sufx = g.sufx;
 
         /* create output file and open to write */
-        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
+        g.outf = MALLOC(pre + len + strlen(sufx) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
-        memcpy(g.outf, to, len);
-        strcpy(g.outf + len, g.decode ? repl : g.sufx);
+        memcpy(g.outf, g.inf, pre);
+        memcpy(g.outf + pre, to, len);
+        strcpy(g.outf + pre + len, sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
-                             (g.force ? 0 : O_EXCL), 0600);
+                              (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {",pigz,fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,e5318b2cd88f1cb74c0bbce8a618c2b72ec263fb,1,"local void process(char *path)
{
    int method = -1;                /* get_header() return value */
    size_t len;                     /* length of base name (minus suffix) */
    struct stat st;                 /* to get file type and mod time */
    /* all compressed suffixes for decoding search, in length order */
    static char *sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"",
                           "".zip"", "".ZIP"", "".tgz"", NULL};

    /* open input file with name in, descriptor ind -- set name and mtime */
    if (path == NULL) {
        strcpy(g.inf, ""<stdin>"");
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ?
                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
        len = 0;
    }
    else {
        /* set input file name (already set if recursed here) */
        if (path != g.inf) {
            strncpy(g.inf, path, sizeof(g.inf));
            if (g.inf[sizeof(g.inf) - 1])
                bail(""name too long: "", path);
        }
        len = strlen(g.inf);

        /* try to stat input file -- if not there and decoding, look for that
           name with compressed suffixes */
        if (lstat(g.inf, &st)) {
            if (errno == ENOENT && (g.list || g.decode)) {
                char **try = sufs;
                do {
                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))
                        break;
                    strcpy(g.inf + len, *try++);
                    errno = 0;
                } while (lstat(g.inf, &st) && errno == ENOENT);
            }
#ifdef EOVERFLOW
            if (errno == EOVERFLOW || errno == EFBIG)
                bail(g.inf,
                    "" too large -- not compiled with large file support"");
#endif
            if (errno) {
                g.inf[len] = 0;
                complain(""%s does not exist -- skipping"", g.inf);
                return;
            }
            len = strlen(g.inf);
        }

        /* only process regular files, but allow symbolic links if -f,
           recurse into directory if -r */
        if ((st.st_mode & S_IFMT) != S_IFREG &&
            (st.st_mode & S_IFMT) != S_IFLNK &&
            (st.st_mode & S_IFMT) != S_IFDIR) {
            complain(""%s is a special file or device -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
            complain(""%s is a symbolic link -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
            complain(""%s is a directory -- skipping"", g.inf);
            return;
        }

        /* recurse into directory (assumes Unix) */
        if ((st.st_mode & S_IFMT) == S_IFDIR) {
            char *roll, *item, *cut, *base, *bigger;
            size_t len, hold;
            DIR *here;
            struct dirent *next;

            /* accumulate list of entries (need to do this, since readdir()
               behavior not defined if directory modified between calls) */
            here = opendir(g.inf);
            if (here == NULL)
                return;
            hold = 512;
            roll = MALLOC(hold);
            if (roll == NULL)
                bail(""not enough memory"", """");
            *roll = 0;
            item = roll;
            while ((next = readdir(here)) != NULL) {
                if (next->d_name[0] == 0 ||
                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                     (next->d_name[1] == '.' && next->d_name[2] == 0))))
                    continue;
                len = strlen(next->d_name) + 1;
                if (item + len + 1 > roll + hold) {
                    do {                    /* make roll bigger */
                        hold <<= 1;
                    } while (item + len + 1 > roll + hold);
                    bigger = REALLOC(roll, hold);
                    if (bigger == NULL) {
                        FREE(roll);
                        bail(""not enough memory"", """");
                    }
                    item = bigger + (item - roll);
                    roll = bigger;
                }
                strcpy(item, next->d_name);
                item += len;
                *item = 0;
            }
            closedir(here);

            /* run process() for each entry in the directory */
            cut = base = g.inf + strlen(g.inf);
            if (base > g.inf && base[-1] != (unsigned char)'/') {
                if ((size_t)(base - g.inf) >= sizeof(g.inf))
                    bail(""path too long"", g.inf);
                *base++ = '/';
            }
            item = roll;
            while (*item) {
                strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                if (g.inf[sizeof(g.inf) - 1]) {
                    strcpy(g.inf + (sizeof(g.inf) - 4), ""..."");
                    bail(""path too long: "", g.inf);
                }
                process(g.inf);
                item += strlen(item) + 1;
            }
            *cut = 0;

            /* release list of entries */
            FREE(roll);
            return;
        }

        /* don't compress .gz (or provided suffix) files, unless -f */
        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&
                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
            complain(""%s ends with %s -- skipping"", g.inf, g.sufx);
            return;
        }

        /* create output file only if input file has compressed suffix */
        if (g.decode == 1 && !g.pipeout && !g.list) {
            int suf = compressed_suffix(g.inf);
            if (suf == 0) {
                complain(""%s does not have compressed suffix -- skipping"",
                         g.inf);
                return;
            }
            len -= suf;
        }

        /* open input file */
        g.ind = open(g.inf, O_RDONLY, 0);
        if (g.ind < 0)
            bail(""read error on "", g.inf);

        /* prepare gzip header information for compression */
        g.name = g.headis & 1 ? justname(g.inf) : NULL;
        g.mtime = g.headis & 2 ? st.st_mtime : 0;
    }
    SET_BINARY_MODE(g.ind);

    /* if decoding or testing, try to read gzip header */
    g.hname = NULL;
    if (g.decode) {
        in_init();
        method = get_header(1);
        if (method != 8 && method != 257 &&
                /* gzip -cdf acts like cat on uncompressed input */
                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&
                  !g.list)) {
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            if (method != -1)
                complain(method < 0 ? ""%s is not compressed -- skipping"" :
                         ""%s has unknown compression method -- skipping"",
                         g.inf);
            return;
        }

        /* if requested, test input file (possibly a special list) */
        if (g.decode == 2) {
            if (method == 8)
                infchk();
            else {
                unlzw();
                if (g.list) {
                    g.in_tot -= 3;
                    show_info(method, 0, g.out_tot, 0);
                }
            }
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }
    }

    /* if requested, just list information about input file */
    if (g.list) {
        list_info();
        RELEASE(g.hname);
        if (g.ind != 0)
            close(g.ind);
        return;
    }

    /* create output file out, descriptor outd */
    if (path == NULL || g.pipeout) {
        /* write to stdout */
        g.outf = MALLOC(strlen(""<stdout>"") + 1);
        if (g.outf == NULL)
            bail(""not enough memory"", """");
        strcpy(g.outf, ""<stdout>"");
        g.outd = 1;
        if (!g.decode && !g.force && isatty(g.outd))
            bail(""trying to write compressed data to a terminal"",
                  "" (use -f to force)"");
     }
     else {
//flaw_line_below:
        char *to, *repl;
//flaw_line_below:

//flaw_line_below:
        /* use header name for output when decompressing with -N */
//flaw_line_below:
        to = g.inf;
//flaw_line_below:
        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
//flaw_line_below:
            to = g.hname;
//flaw_line_below:
            len = strlen(g.hname);
//fix_flaw_line_below:
//        char *to = g.inf, *sufx = """";
//fix_flaw_line_below:
//        size_t pre = 0;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        /* select parts of the output file name */
//fix_flaw_line_below:
//        if (g.decode) {
//fix_flaw_line_below:
//            /* for -dN or -dNT, use the path from the input file and the name
//fix_flaw_line_below:
//               from the header, stripping any path in the header name */
//fix_flaw_line_below:
//            if ((g.headis & 1) != 0 && g.hname != NULL) {
//fix_flaw_line_below:
//                pre = justname(g.inf) - g.inf;
//fix_flaw_line_below:
//                to = justname(g.hname);
//fix_flaw_line_below:
//                len = strlen(to);
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//            /* for -d or -dNn, replace abbreviated suffixes */
//fix_flaw_line_below:
//            else if (strcmp(to + len, "".tgz"") == 0)
//fix_flaw_line_below:
//                sufx = "".tar"";
         }
//flaw_line_below:

//flaw_line_below:
        /* replace .tgz with .tar when decoding */
//flaw_line_below:
        repl = g.decode && strcmp(to + len, "".tgz"") ? """" : "".tar"";
//fix_flaw_line_below:
//        else
//fix_flaw_line_below:
//            /* add appropriate suffix when compressing */
//fix_flaw_line_below:
//            sufx = g.sufx;
 
         /* create output file and open to write */
//flaw_line_below:
        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
//fix_flaw_line_below:
//        g.outf = MALLOC(pre + len + strlen(sufx) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
//flaw_line_below:
        memcpy(g.outf, to, len);
//flaw_line_below:
        strcpy(g.outf + len, g.decode ? repl : g.sufx);
//fix_flaw_line_below:
//        memcpy(g.outf, g.inf, pre);
//fix_flaw_line_below:
//        memcpy(g.outf + pre, to, len);
//fix_flaw_line_below:
//        strcpy(g.outf + pre + len, sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
//flaw_line_below:
                             (g.force ? 0 : O_EXCL), 0600);
//fix_flaw_line_below:
//                              (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
            int ch, reply;

            fprintf(stderr, ""%s exists -- overwrite (y/n)? "", g.outf);
            fflush(stderr);
            reply = -1;
            do {
                ch = getchar();
                if (reply < 0 && ch != ' ' && ch != '\t')
                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;
            } while (ch != EOF && ch != '\n' && ch != '\r');
            if (reply == 1)
                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                              0600);
        }

        /* if exists and no overwrite, report and go on to next */
        if (g.outd < 0 && errno == EEXIST) {
            complain(""%s exists -- skipping"", g.outf);
            RELEASE(g.outf);
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }

        /* if some other error, give up */
        if (g.outd < 0)
            bail(""write error on "", g.outf);
    }
    SET_BINARY_MODE(g.outd);
    RELEASE(g.hname);

    /* process ind to outd */
    if (g.verbosity > 1)
        fprintf(stderr, ""%s to %s "", g.inf, g.outf);
    if (g.decode) {
        if (method == 8)
            infchk();
        else if (method == 257)
            unlzw();
        else
            cat();
    }
#ifndef NOTHREAD
    else if (g.procs > 1)
        parallel_compress();
#endif
    else
        single_compress(0);
    if (g.verbosity > 1) {
        putc('\n', stderr);
        fflush(stderr);
    }

    /* finish up, copy attributes, set times, delete original */
    if (g.ind != 0)
        close(g.ind);
    if (g.outd != 1) {
        if (close(g.outd))
            bail(""write error on "", g.outf);
        g.outd = -1;            /* now prevent deletion on interrupt */
        if (g.ind != 0) {
            copymeta(g.inf, g.outf);
            if (!g.keep)
                unlink(g.inf);
        }
        if (g.decode && (g.headis & 2) != 0 && g.stamp)
            touch(g.outf, g.stamp);
    }
    RELEASE(g.outf);
}
",179899,"local void process(char *path)
{
    int method = -1;                /* get_header() return value */
    size_t len;                     /* length of base name (minus suffix) */
    struct stat st;                 /* to get file type and mod time */
    /* all compressed suffixes for decoding search, in length order */
    static char *sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"",
                           "".zip"", "".ZIP"", "".tgz"", NULL};

    /* open input file with name in, descriptor ind -- set name and mtime */
    if (path == NULL) {
        strcpy(g.inf, ""<stdin>"");
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ?
                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
        len = 0;
    }
    else {
        /* set input file name (already set if recursed here) */
        if (path != g.inf) {
            strncpy(g.inf, path, sizeof(g.inf));
            if (g.inf[sizeof(g.inf) - 1])
                bail(""name too long: "", path);
        }
        len = strlen(g.inf);

        /* try to stat input file -- if not there and decoding, look for that
           name with compressed suffixes */
        if (lstat(g.inf, &st)) {
            if (errno == ENOENT && (g.list || g.decode)) {
                char **try = sufs;
                do {
                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))
                        break;
                    strcpy(g.inf + len, *try++);
                    errno = 0;
                } while (lstat(g.inf, &st) && errno == ENOENT);
            }
#ifdef EOVERFLOW
            if (errno == EOVERFLOW || errno == EFBIG)
                bail(g.inf,
                    "" too large -- not compiled with large file support"");
#endif
            if (errno) {
                g.inf[len] = 0;
                complain(""%s does not exist -- skipping"", g.inf);
                return;
            }
            len = strlen(g.inf);
        }

        /* only process regular files, but allow symbolic links if -f,
           recurse into directory if -r */
        if ((st.st_mode & S_IFMT) != S_IFREG &&
            (st.st_mode & S_IFMT) != S_IFLNK &&
            (st.st_mode & S_IFMT) != S_IFDIR) {
            complain(""%s is a special file or device -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
            complain(""%s is a symbolic link -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
            complain(""%s is a directory -- skipping"", g.inf);
            return;
        }

        /* recurse into directory (assumes Unix) */
        if ((st.st_mode & S_IFMT) == S_IFDIR) {
            char *roll, *item, *cut, *base, *bigger;
            size_t len, hold;
            DIR *here;
            struct dirent *next;

            /* accumulate list of entries (need to do this, since readdir()
               behavior not defined if directory modified between calls) */
            here = opendir(g.inf);
            if (here == NULL)
                return;
            hold = 512;
            roll = MALLOC(hold);
            if (roll == NULL)
                bail(""not enough memory"", """");
            *roll = 0;
            item = roll;
            while ((next = readdir(here)) != NULL) {
                if (next->d_name[0] == 0 ||
                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                     (next->d_name[1] == '.' && next->d_name[2] == 0))))
                    continue;
                len = strlen(next->d_name) + 1;
                if (item + len + 1 > roll + hold) {
                    do {                    /* make roll bigger */
                        hold <<= 1;
                    } while (item + len + 1 > roll + hold);
                    bigger = REALLOC(roll, hold);
                    if (bigger == NULL) {
                        FREE(roll);
                        bail(""not enough memory"", """");
                    }
                    item = bigger + (item - roll);
                    roll = bigger;
                }
                strcpy(item, next->d_name);
                item += len;
                *item = 0;
            }
            closedir(here);

            /* run process() for each entry in the directory */
            cut = base = g.inf + strlen(g.inf);
            if (base > g.inf && base[-1] != (unsigned char)'/') {
                if ((size_t)(base - g.inf) >= sizeof(g.inf))
                    bail(""path too long"", g.inf);
                *base++ = '/';
            }
            item = roll;
            while (*item) {
                strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                if (g.inf[sizeof(g.inf) - 1]) {
                    strcpy(g.inf + (sizeof(g.inf) - 4), ""..."");
                    bail(""path too long: "", g.inf);
                }
                process(g.inf);
                item += strlen(item) + 1;
            }
            *cut = 0;

            /* release list of entries */
            FREE(roll);
            return;
        }

        /* don't compress .gz (or provided suffix) files, unless -f */
        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&
                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
            complain(""%s ends with %s -- skipping"", g.inf, g.sufx);
            return;
        }

        /* create output file only if input file has compressed suffix */
        if (g.decode == 1 && !g.pipeout && !g.list) {
            int suf = compressed_suffix(g.inf);
            if (suf == 0) {
                complain(""%s does not have compressed suffix -- skipping"",
                         g.inf);
                return;
            }
            len -= suf;
        }

        /* open input file */
        g.ind = open(g.inf, O_RDONLY, 0);
        if (g.ind < 0)
            bail(""read error on "", g.inf);

        /* prepare gzip header information for compression */
        g.name = g.headis & 1 ? justname(g.inf) : NULL;
        g.mtime = g.headis & 2 ? st.st_mtime : 0;
    }
    SET_BINARY_MODE(g.ind);

    /* if decoding or testing, try to read gzip header */
    g.hname = NULL;
    if (g.decode) {
        in_init();
        method = get_header(1);
        if (method != 8 && method != 257 &&
                /* gzip -cdf acts like cat on uncompressed input */
                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&
                  !g.list)) {
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            if (method != -1)
                complain(method < 0 ? ""%s is not compressed -- skipping"" :
                         ""%s has unknown compression method -- skipping"",
                         g.inf);
            return;
        }

        /* if requested, test input file (possibly a special list) */
        if (g.decode == 2) {
            if (method == 8)
                infchk();
            else {
                unlzw();
                if (g.list) {
                    g.in_tot -= 3;
                    show_info(method, 0, g.out_tot, 0);
                }
            }
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }
    }

    /* if requested, just list information about input file */
    if (g.list) {
        list_info();
        RELEASE(g.hname);
        if (g.ind != 0)
            close(g.ind);
        return;
    }

    /* create output file out, descriptor outd */
    if (path == NULL || g.pipeout) {
        /* write to stdout */
        g.outf = MALLOC(strlen(""<stdout>"") + 1);
        if (g.outf == NULL)
            bail(""not enough memory"", """");
        strcpy(g.outf, ""<stdout>"");
        g.outd = 1;
        if (!g.decode && !g.force && isatty(g.outd))
            bail(""trying to write compressed data to a terminal"",
                  "" (use -f to force)"");
     }
     else {
        char *to, *repl;
        /* use header name for output when decompressing with -N */
        to = g.inf;
        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
            to = g.hname;
            len = strlen(g.hname);
         }
        /* replace .tgz with .tar when decoding */
        repl = g.decode && strcmp(to + len, "".tgz"") ? """" : "".tar"";
 
         /* create output file and open to write */
        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
        memcpy(g.outf, to, len);
        strcpy(g.outf + len, g.decode ? repl : g.sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
                             (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
            int ch, reply;

            fprintf(stderr, ""%s exists -- overwrite (y/n)? "", g.outf);
            fflush(stderr);
            reply = -1;
            do {
                ch = getchar();
                if (reply < 0 && ch != ' ' && ch != '\t')
                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;
            } while (ch != EOF && ch != '\n' && ch != '\r');
            if (reply == 1)
                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                              0600);
        }

        /* if exists and no overwrite, report and go on to next */
        if (g.outd < 0 && errno == EEXIST) {
            complain(""%s exists -- skipping"", g.outf);
            RELEASE(g.outf);
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }

        /* if some other error, give up */
        if (g.outd < 0)
            bail(""write error on "", g.outf);
    }
    SET_BINARY_MODE(g.outd);
    RELEASE(g.hname);

    /* process ind to outd */
    if (g.verbosity > 1)
        fprintf(stderr, ""%s to %s "", g.inf, g.outf);
    if (g.decode) {
        if (method == 8)
            infchk();
        else if (method == 257)
            unlzw();
        else
            cat();
    }
#ifndef NOTHREAD
    else if (g.procs > 1)
        parallel_compress();
#endif
    else
        single_compress(0);
    if (g.verbosity > 1) {
        putc('\n', stderr);
        fflush(stderr);
    }

    /* finish up, copy attributes, set times, delete original */
    if (g.ind != 0)
        close(g.ind);
    if (g.outd != 1) {
        if (close(g.outd))
            bail(""write error on "", g.outf);
        g.outd = -1;            /* now prevent deletion on interrupt */
        if (g.ind != 0) {
            copymeta(g.inf, g.outf);
            if (!g.keep)
                unlink(g.inf);
        }
        if (g.decode && (g.headis & 2) != 0 && g.stamp)
            touch(g.outf, g.stamp);
    }
    RELEASE(g.outf);
}
","local void process(char *path)
{
    int method = -1;                /* get_header() return value */
    size_t len;                     /* length of base name (minus suffix) */
    struct stat st;                 /* to get file type and mod time */
    /* all compressed suffixes for decoding search, in length order */
    static char *sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"",
                           "".zip"", "".ZIP"", "".tgz"", NULL};

    /* open input file with name in, descriptor ind -- set name and mtime */
    if (path == NULL) {
        strcpy(g.inf, ""<stdin>"");
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ?
                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
        len = 0;
    }
    else {
        /* set input file name (already set if recursed here) */
        if (path != g.inf) {
            strncpy(g.inf, path, sizeof(g.inf));
            if (g.inf[sizeof(g.inf) - 1])
                bail(""name too long: "", path);
        }
        len = strlen(g.inf);

        /* try to stat input file -- if not there and decoding, look for that
           name with compressed suffixes */
        if (lstat(g.inf, &st)) {
            if (errno == ENOENT && (g.list || g.decode)) {
                char **try = sufs;
                do {
                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))
                        break;
                    strcpy(g.inf + len, *try++);
                    errno = 0;
                } while (lstat(g.inf, &st) && errno == ENOENT);
            }
#ifdef EOVERFLOW
            if (errno == EOVERFLOW || errno == EFBIG)
                bail(g.inf,
                    "" too large -- not compiled with large file support"");
#endif
            if (errno) {
                g.inf[len] = 0;
                complain(""%s does not exist -- skipping"", g.inf);
                return;
            }
            len = strlen(g.inf);
        }

        /* only process regular files, but allow symbolic links if -f,
           recurse into directory if -r */
        if ((st.st_mode & S_IFMT) != S_IFREG &&
            (st.st_mode & S_IFMT) != S_IFLNK &&
            (st.st_mode & S_IFMT) != S_IFDIR) {
            complain(""%s is a special file or device -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
            complain(""%s is a symbolic link -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
            complain(""%s is a directory -- skipping"", g.inf);
            return;
        }

        /* recurse into directory (assumes Unix) */
        if ((st.st_mode & S_IFMT) == S_IFDIR) {
            char *roll, *item, *cut, *base, *bigger;
            size_t len, hold;
            DIR *here;
            struct dirent *next;

            /* accumulate list of entries (need to do this, since readdir()
               behavior not defined if directory modified between calls) */
            here = opendir(g.inf);
            if (here == NULL)
                return;
            hold = 512;
            roll = MALLOC(hold);
            if (roll == NULL)
                bail(""not enough memory"", """");
            *roll = 0;
            item = roll;
            while ((next = readdir(here)) != NULL) {
                if (next->d_name[0] == 0 ||
                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                     (next->d_name[1] == '.' && next->d_name[2] == 0))))
                    continue;
                len = strlen(next->d_name) + 1;
                if (item + len + 1 > roll + hold) {
                    do {                    /* make roll bigger */
                        hold <<= 1;
                    } while (item + len + 1 > roll + hold);
                    bigger = REALLOC(roll, hold);
                    if (bigger == NULL) {
                        FREE(roll);
                        bail(""not enough memory"", """");
                    }
                    item = bigger + (item - roll);
                    roll = bigger;
                }
                strcpy(item, next->d_name);
                item += len;
                *item = 0;
            }
            closedir(here);

            /* run process() for each entry in the directory */
            cut = base = g.inf + strlen(g.inf);
            if (base > g.inf && base[-1] != (unsigned char)'/') {
                if ((size_t)(base - g.inf) >= sizeof(g.inf))
                    bail(""path too long"", g.inf);
                *base++ = '/';
            }
            item = roll;
            while (*item) {
                strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                if (g.inf[sizeof(g.inf) - 1]) {
                    strcpy(g.inf + (sizeof(g.inf) - 4), ""..."");
                    bail(""path too long: "", g.inf);
                }
                process(g.inf);
                item += strlen(item) + 1;
            }
            *cut = 0;

            /* release list of entries */
            FREE(roll);
            return;
        }

        /* don't compress .gz (or provided suffix) files, unless -f */
        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&
                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
            complain(""%s ends with %s -- skipping"", g.inf, g.sufx);
            return;
        }

        /* create output file only if input file has compressed suffix */
        if (g.decode == 1 && !g.pipeout && !g.list) {
            int suf = compressed_suffix(g.inf);
            if (suf == 0) {
                complain(""%s does not have compressed suffix -- skipping"",
                         g.inf);
                return;
            }
            len -= suf;
        }

        /* open input file */
        g.ind = open(g.inf, O_RDONLY, 0);
        if (g.ind < 0)
            bail(""read error on "", g.inf);

        /* prepare gzip header information for compression */
        g.name = g.headis & 1 ? justname(g.inf) : NULL;
        g.mtime = g.headis & 2 ? st.st_mtime : 0;
    }
    SET_BINARY_MODE(g.ind);

    /* if decoding or testing, try to read gzip header */
    g.hname = NULL;
    if (g.decode) {
        in_init();
        method = get_header(1);
        if (method != 8 && method != 257 &&
                /* gzip -cdf acts like cat on uncompressed input */
                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&
                  !g.list)) {
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            if (method != -1)
                complain(method < 0 ? ""%s is not compressed -- skipping"" :
                         ""%s has unknown compression method -- skipping"",
                         g.inf);
            return;
        }

        /* if requested, test input file (possibly a special list) */
        if (g.decode == 2) {
            if (method == 8)
                infchk();
            else {
                unlzw();
                if (g.list) {
                    g.in_tot -= 3;
                    show_info(method, 0, g.out_tot, 0);
                }
            }
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }
    }

    /* if requested, just list information about input file */
    if (g.list) {
        list_info();
        RELEASE(g.hname);
        if (g.ind != 0)
            close(g.ind);
        return;
    }

    /* create output file out, descriptor outd */
    if (path == NULL || g.pipeout) {
        /* write to stdout */
        g.outf = MALLOC(strlen(""<stdout>"") + 1);
        if (g.outf == NULL)
            bail(""not enough memory"", """");
        strcpy(g.outf, ""<stdout>"");
        g.outd = 1;
        if (!g.decode && !g.force && isatty(g.outd))
            bail(""trying to write compressed data to a terminal"",
                  "" (use -f to force)"");
     }
     else {
        char *to = g.inf, *sufx = """";
        size_t pre = 0;

        /* select parts of the output file name */
        if (g.decode) {
            /* for -dN or -dNT, use the path from the input file and the name
               from the header, stripping any path in the header name */
            if ((g.headis & 1) != 0 && g.hname != NULL) {
                pre = justname(g.inf) - g.inf;
                to = justname(g.hname);
                len = strlen(to);
            }
            /* for -d or -dNn, replace abbreviated suffixes */
            else if (strcmp(to + len, "".tgz"") == 0)
                sufx = "".tar"";
         }
        else
            /* add appropriate suffix when compressing */
            sufx = g.sufx;
 
         /* create output file and open to write */
        g.outf = MALLOC(pre + len + strlen(sufx) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
        memcpy(g.outf, g.inf, pre);
        memcpy(g.outf + pre, to, len);
        strcpy(g.outf + pre + len, sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
                              (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
            int ch, reply;

            fprintf(stderr, ""%s exists -- overwrite (y/n)? "", g.outf);
            fflush(stderr);
            reply = -1;
            do {
                ch = getchar();
                if (reply < 0 && ch != ' ' && ch != '\t')
                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;
            } while (ch != EOF && ch != '\n' && ch != '\r');
            if (reply == 1)
                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                              0600);
        }

        /* if exists and no overwrite, report and go on to next */
        if (g.outd < 0 && errno == EEXIST) {
            complain(""%s exists -- skipping"", g.outf);
            RELEASE(g.outf);
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }

        /* if some other error, give up */
        if (g.outd < 0)
            bail(""write error on "", g.outf);
    }
    SET_BINARY_MODE(g.outd);
    RELEASE(g.hname);

    /* process ind to outd */
    if (g.verbosity > 1)
        fprintf(stderr, ""%s to %s "", g.inf, g.outf);
    if (g.decode) {
        if (method == 8)
            infchk();
        else if (method == 257)
            unlzw();
        else
            cat();
    }
#ifndef NOTHREAD
    else if (g.procs > 1)
        parallel_compress();
#endif
    else
        single_compress(0);
    if (g.verbosity > 1) {
        putc('\n', stderr);
        fflush(stderr);
    }

    /* finish up, copy attributes, set times, delete original */
    if (g.ind != 0)
        close(g.ind);
    if (g.outd != 1) {
        if (close(g.outd))
            bail(""write error on "", g.outf);
        g.outd = -1;            /* now prevent deletion on interrupt */
        if (g.ind != 0) {
            copymeta(g.inf, g.outf);
            if (!g.keep)
                unlink(g.inf);
        }
        if (g.decode && (g.headis & 2) != 0 && g.stamp)
            touch(g.outf, g.stamp);
    }
    RELEASE(g.outf);
}
","The `process` function handles the reading, decoding, and compression of files based on specified conditions. It begins by checking if the input path is valid, attempting to open the file, and determining its type (regular file, symbolic link, or directory). If it's a directory, the function recursively processes its contents. The function also manages file suffixes for compression and ensures that existing files are not overwritten unless forced. Depending on the operation (compression or decompression), it prepares the output file, processes the input data, and finally copies file attributes before optionally deleting the original file, ensuring proper error handling throughout.","The code processes files for compression or decompression, starting by validating the input path and determining the file type. It handles directories by recursively processing their contents and checks for specific file suffixes to manage compression appropriately. The function ensures that existing files are not overwritten unless explicitly allowed and prepares the output file based on the operation. It reads the input data, performs the necessary compression or decompression, and finally copies file attributes while optionally deleting the original file, all while incorporating error handling to manage various scenarios effectively.","The vulnerability in the original code, identified as CWE-22 (Improper Limitation of a Pathname to a Restricted Directory), arises from the lack of validation when constructing file paths, which could allow an attacker to manipulate the input path to access unauthorized files or directories. In the fixed code, the use of `strncpy` ensures that the input path is copied safely into a buffer, preventing buffer overflows. Additionally, checks are implemented to ensure that the constructed output file name does not exceed the buffer size, and the code now properly handles existing files by prompting the user for confirmation before overwriting, thereby mitigating the risk of unauthorized file access.","The vulnerability identified as CWE-22 arises from inadequate validation of file paths, allowing an attacker to manipulate input to access unauthorized files or directories. In the original code, the construction of output file paths did not sufficiently restrict access, potentially leading to directory traversal attacks. The fixed code addresses this issue by implementing safer copying methods that prevent buffer overflows and by enforcing checks on the length of constructed paths. Additionally, it introduces user prompts for overwriting existing files, thereby enhancing security by ensuring that only intended files are modified or accessed.","The vulnerability was fixed by implementing safer path handling and validation mechanisms. The use of `strncpy` ensures that the input path is copied into the buffer without exceeding its size, preventing buffer overflows. Additionally, the code checks the length of the constructed output file name to ensure it does not exceed the buffer size, using conditions like `if (g.inf[sizeof(g.inf) - 1])` to handle potential overflows. Furthermore, the introduction of user prompts when attempting to overwrite existing files, as seen in the check for `errno == EEXIST`, enhances security by requiring explicit confirmation before proceeding.","The vulnerability was addressed by enhancing the validation of file paths and ensuring safe memory operations. The code now employs safer methods for copying input paths to prevent buffer overflows, which could lead to unauthorized file access. Additionally, it includes checks to confirm that constructed output file names do not exceed the allocated buffer size, thereby mitigating the risk of path traversal attacks. Furthermore, the implementation of user prompts for overwriting existing files ensures that users explicitly confirm their actions, adding an extra layer of security against unintended modifications."
5,181815,181815,,Remote,Not required,,CVE-2016-10048,https://www.cvedetails.com/cve/CVE-2016-10048/,CWE-22,Low,,Partial,,2017-03-23,5.0,Directory traversal vulnerability in magick/module.c in ImageMagick 6.9.4-7 allows remote attackers to load arbitrary modules via unspecified vectors.,2017-03-24,Dir. Trav. ,4,https://github.com/ImageMagick/ImageMagick/commit/fc6080f1321fd21e86ef916195cc110b05d9effb,fc6080f1321fd21e86ef916195cc110b05d9effb,"Coder path traversal is not authorized, bug report provided by Masaaki Chida",1,magick/xml-tree.c,"{""sha"": ""0a6aefdf34546cdf939c6f37398cd48153cc4727"", ""filename"": ""ChangeLog"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/fc6080f1321fd21e86ef916195cc110b05d9effb/ChangeLog"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/fc6080f1321fd21e86ef916195cc110b05d9effb/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/ChangeLog?ref=fc6080f1321fd21e86ef916195cc110b05d9effb"", ""patch"": ""@@ -1,3 +1,8 @@\n+2016-06-02  6.9.4-7 Cristy  <quetzlzacatenango@image...>\n+  * Fix small memory leak (patch provided by \u0410\u043d\u0434\u0440\u0435\u0439 \u0427\u0435\u0440\u043d\u044b\u0439).\n+  * Coder path traversal is not authorized (bug report provided by\n+    Masaaki Chida).\n+\n 2016-05-31  6.9.4-6 Cristy  <quetzlzacatenango@image...>\n   * Release ImageMagick version 6.9.4-6, GIT revision 18334:97775b5:20160531.\n ""}<_**next**_>{""sha"": ""a00b76d64018ebcaaac7c4728e9e10cd94a7d650"", ""filename"": ""magick/module.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/fc6080f1321fd21e86ef916195cc110b05d9effb/magick/module.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/fc6080f1321fd21e86ef916195cc110b05d9effb/magick/module.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/magick/module.c?ref=fc6080f1321fd21e86ef916195cc110b05d9effb"", ""patch"": ""@@ -547,6 +547,15 @@ static MagickBooleanType GetMagickModulePath(const char *filename,\n   assert(path != (char *) NULL);\n   assert(exception != (ExceptionInfo *) NULL);\n   (void) CopyMagickString(path,filename,MaxTextExtent);\n+#if defined(MAGICKCORE_INSTALLED_SUPPORT)\n+  if (strstr(path,\""../\"") != (char *) NULL)\n+    {\n+      errno=EPERM;\n+      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n+        \""NotAuthorized\"",\""`%s'\"",path);\n+      return(MagickFalse);\n+    }\n+#endif\n   module_path=(char *) NULL;\n   switch (module_type)\n   {""}<_**next**_>{""sha"": ""efe48065ed5e94de9c280e64e6ec0d8d6904c23b"", ""filename"": ""magick/xml-tree.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/fc6080f1321fd21e86ef916195cc110b05d9effb/magick/xml-tree.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/fc6080f1321fd21e86ef916195cc110b05d9effb/magick/xml-tree.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/magick/xml-tree.c?ref=fc6080f1321fd21e86ef916195cc110b05d9effb"", ""patch"": ""@@ -2140,7 +2140,10 @@ MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)\n                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))\n                   ParseOpenTag(root,tag,attributes);\n                 else\n-                  ignore_depth++;\n+                  {\n+                    ignore_depth++;\n+                    (void) DestroyXMLTreeAttributes(attributes);\n+                  }\n                 *p=c;\n               }\n             else""}","MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
{
  char
    **attribute,
    **attributes,
    *tag,
    *utf8;

  int
    c,
    terminal;

  MagickBooleanType
    status;

  register char
    *p;

  register ssize_t
    i;

  size_t
    ignore_depth,
    length;

  ssize_t
    j,
    l;

  XMLTreeRoot
    *root;

  /*
    Convert xml-string to UTF8.
  */
  if ((xml == (const char *) NULL) || (strlen(xml) == 0))
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return((XMLTreeInfo *) NULL);
    }
  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);
  length=strlen(xml);
  utf8=ConvertUTF16ToUTF8(xml,&length);
  if (utf8 == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""UTF16 to UTF8 failed"");
      return((XMLTreeInfo *) NULL);
    }
  terminal=utf8[length-1];
  utf8[length-1]='\0';
  p=utf8;
  while ((*p != '\0') && (*p != '<'))
    p++;
  if (*p == '\0')
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      utf8=DestroyString(utf8);
      return((XMLTreeInfo *) NULL);
    }
  attribute=(char **) NULL;
  l=0;
  ignore_depth=0;
  for (p++; ; p++)
  {
    attributes=(char **) sentinel;
    tag=p;
    c=(*p);
    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||
        (*p == ':') || (c < '\0'))
      {
        /*
          Tag.
        */
        if (root->node == (XMLTreeInfo *) NULL)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,""ParseError"",""root tag missing"");
            utf8=DestroyString(utf8);
            return(&root->root);
          }
        p+=strcspn(p,XMLWhitespace ""/>"");
        while (isspace((int) ((unsigned char) *p)) != 0)
          *p++='\0';
        if (ignore_depth == 0)
          {
            if ((*p != '\0') && (*p != '/') && (*p != '>'))
              {
                /*
                  Find tag in default attributes list.
                */
                i=0;
                while ((root->attributes[i] != (char **) NULL) &&
                       (strcmp(root->attributes[i][0],tag) != 0))
                  i++;
                attribute=root->attributes[i];
              }
            for (l=0; (*p != '\0') && (*p != '/') && (*p != '>'); l+=2)
            {
              /*
                Attribute.
              */
              if (l == 0)
                attributes=(char **) AcquireQuantumMemory(4,
                  sizeof(*attributes));
              else
                attributes=(char **) ResizeQuantumMemory(attributes,
                  (size_t) (l+4),sizeof(*attributes));
              if (attributes == (char **) NULL)
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
              attributes[l+2]=(char *) NULL;
              attributes[l+1]=(char *) NULL;
              attributes[l]=p;
              p+=strcspn(p,XMLWhitespace ""=/>"");
              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))
                attributes[l]=ConstantString("""");
              else
                {
                  *p++='\0';
                  p+=strspn(p,XMLWhitespace ""="");
                  c=(*p);
                  if ((c == '""') || (c == '\''))
                    {
                      /*
                        Attributes value.
                      */
                      p++;
                      attributes[l+1]=p;
                      while ((*p != '\0') && (*p != c))
                        p++;
                      if (*p != '\0')
                        *p++='\0';
                      else
                        {
                          attributes[l]=ConstantString("""");
                          attributes[l+1]=ConstantString("""");
                          (void) DestroyXMLTreeAttributes(attributes);
                          (void) ThrowMagickException(exception,
                            GetMagickModule(),OptionWarning,""ParseError"",
                            ""missing %c"",c);
                          utf8=DestroyString(utf8);
                          return(&root->root);
                        }
                      j=1;
                      while ((attribute != (char **) NULL) &&
                             (attribute[j] != (char *) NULL) &&
                             (strcmp(attribute[j],attributes[l]) != 0))
                        j+=3;
                      attributes[l+1]=ParseEntities(attributes[l+1],
                        root->entities,(attribute != (char **) NULL) &&
                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :
                        ' ');
                    }
                  attributes[l]=ConstantString(attributes[l]);
                }
              while (isspace((int) ((unsigned char) *p)) != 0)
                p++;
            }
          }
        else
          {
            while((*p != '\0') && (*p != '/') && (*p != '>'))
              p++;
          }
        if (*p == '/')
          {
            /*
              Self closing tag.
            */
            *p++='\0';
            if (((*p != '\0') && (*p != '>')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
              {
                ParseOpenTag(root,tag,attributes);
                (void) ParseCloseTag(root,tag,exception);
              }
          }
        else
          {
            c=(*p);
            if ((*p == '>') || ((*p == '\0') && (terminal == '>')))
              {
                *p='\0';
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
                  {
                    ignore_depth++;
                    (void) DestroyXMLTreeAttributes(attributes);
                  }
                 *p=c;
               }
             else
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
      }
    else
      if (*p == '/')
        {
          /*
            Close tag.
          */
          tag=p+1;
          p+=strcspn(tag,XMLWhitespace "">"")+1;
          c=(*p);
          if ((c == '\0') && (terminal != '>'))
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,""ParseError"",""missing >"");
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          *p='\0';
          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=
              (XMLTreeInfo *) NULL)
            {
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          if (ignore_depth > 0)
            ignore_depth--;
          *p=c;
          if (isspace((int) ((unsigned char) *p)) != 0)
            p+=strspn(p,XMLWhitespace);
        }
      else
        if (strncmp(p,""!--"",3) == 0)
          {
            /*
              Comment.
            */
            p=strstr(p+3,""--"");
            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\0')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""unclosed <!--"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
        else
          if (strncmp(p,""![CDATA["",8) == 0)
            {
              /*
                Cdata.
              */
              p=strstr(p,""]]>"");
              if (p != (char *) NULL)
                {
                  p+=2;
                  if (ignore_depth == 0)
                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unclosed <![CDATA["");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
            }
          else
            if (strncmp(p,""!DOCTYPE"",8) == 0)
              {
                /*
                  DTD.
                */
                for (l=0; (*p != '\0') && (((l == 0) && (*p != '>')) ||
                     ((l != 0) && ((*p != ']') ||
                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));
                  l=(ssize_t) ((*p == '[') ? 1 : l))
                p+=strcspn(p+1,""[]>"")+1;
                if ((*p == '\0') && (terminal != '>'))
                  {
                    (void) ThrowMagickException(exception,GetMagickModule(),
                      OptionWarning,""ParseError"",""unclosed <!DOCTYPE"");
                    utf8=DestroyString(utf8);
                    return(&root->root);
                  }
                if (l != 0)
                  tag=strchr(tag,'[')+1;
                if (l != 0)
                  {
                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),
                      exception);
                    if (status == MagickFalse)
                      {
                        utf8=DestroyString(utf8);
                        return(&root->root);
                      }
                    p++;
                  }
              }
            else
              if (*p == '?')
                {
                  /*
                    Processing instructions.
                  */
                  do
                  {
                    p=strchr(p,'?');
                    if (p == (char *) NULL)
                      break;
                    p++;
                  } while ((*p != '\0') && (*p != '>'));
                  if ((p == (char *) NULL) || ((*p == '\0') &&
                      (terminal != '>')))
                    {
                      (void) ThrowMagickException(exception,GetMagickModule(),
                        OptionWarning,""ParseError"",""unclosed <?"");
                      utf8=DestroyString(utf8);
                      return(&root->root);
                    }
                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unexpected <"");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
     if ((p == (char *) NULL) || (*p == '\0'))
       break;
     *p++='\0';
     tag=p;
     if ((*p != '\0') && (*p != '<'))
       {
        /*
          Tag character content.
        */
        while ((*p != '\0') && (*p != '<'))
          p++;
        if (*p == '\0')
          break;
        if (ignore_depth == 0)
          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');
      }
    else
      if (*p == '\0')
        break;
  }
  utf8=DestroyString(utf8);
  if (root->node == (XMLTreeInfo *) NULL)
    return(&root->root);
  if (root->node->tag == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return(&root->root);
    }
  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
    ""ParseError"",""unclosed tag: `%s'"",root->node->tag);
  return(&root->root);
}
","MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
{
  char
    **attribute,
    **attributes,
    *tag,
    *utf8;

  int
    c,
    terminal;

  MagickBooleanType
    status;

  register char
    *p;

  register ssize_t
    i;

  size_t
    ignore_depth,
    length;

  ssize_t
    j,
    l;

  XMLTreeRoot
    *root;

  /*
    Convert xml-string to UTF8.
  */
  if ((xml == (const char *) NULL) || (strlen(xml) == 0))
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return((XMLTreeInfo *) NULL);
    }
  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);
  length=strlen(xml);
  utf8=ConvertUTF16ToUTF8(xml,&length);
  if (utf8 == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""UTF16 to UTF8 failed"");
      return((XMLTreeInfo *) NULL);
    }
  terminal=utf8[length-1];
  utf8[length-1]='\0';
  p=utf8;
  while ((*p != '\0') && (*p != '<'))
    p++;
  if (*p == '\0')
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      utf8=DestroyString(utf8);
      return((XMLTreeInfo *) NULL);
    }
  attribute=(char **) NULL;
  l=0;
  ignore_depth=0;
  for (p++; ; p++)
  {
    attributes=(char **) sentinel;
    tag=p;
    c=(*p);
    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||
        (*p == ':') || (c < '\0'))
      {
        /*
          Tag.
        */
        if (root->node == (XMLTreeInfo *) NULL)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,""ParseError"",""root tag missing"");
            utf8=DestroyString(utf8);
            return(&root->root);
          }
        p+=strcspn(p,XMLWhitespace ""/>"");
        while (isspace((int) ((unsigned char) *p)) != 0)
          *p++='\0';
        if (ignore_depth == 0)
          {
            if ((*p != '\0') && (*p != '/') && (*p != '>'))
              {
                /*
                  Find tag in default attributes list.
                */
                i=0;
                while ((root->attributes[i] != (char **) NULL) &&
                       (strcmp(root->attributes[i][0],tag) != 0))
                  i++;
                attribute=root->attributes[i];
              }
            for (l=0; (*p != '\0') && (*p != '/') && (*p != '>'); l+=2)
            {
              /*
                Attribute.
              */
              if (l == 0)
                attributes=(char **) AcquireQuantumMemory(4,
                  sizeof(*attributes));
              else
                attributes=(char **) ResizeQuantumMemory(attributes,
                  (size_t) (l+4),sizeof(*attributes));
              if (attributes == (char **) NULL)
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
              attributes[l+2]=(char *) NULL;
              attributes[l+1]=(char *) NULL;
              attributes[l]=p;
              p+=strcspn(p,XMLWhitespace ""=/>"");
              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))
                attributes[l]=ConstantString("""");
              else
                {
                  *p++='\0';
                  p+=strspn(p,XMLWhitespace ""="");
                  c=(*p);
                  if ((c == '""') || (c == '\''))
                    {
                      /*
                        Attributes value.
                      */
                      p++;
                      attributes[l+1]=p;
                      while ((*p != '\0') && (*p != c))
                        p++;
                      if (*p != '\0')
                        *p++='\0';
                      else
                        {
                          attributes[l]=ConstantString("""");
                          attributes[l+1]=ConstantString("""");
                          (void) DestroyXMLTreeAttributes(attributes);
                          (void) ThrowMagickException(exception,
                            GetMagickModule(),OptionWarning,""ParseError"",
                            ""missing %c"",c);
                          utf8=DestroyString(utf8);
                          return(&root->root);
                        }
                      j=1;
                      while ((attribute != (char **) NULL) &&
                             (attribute[j] != (char *) NULL) &&
                             (strcmp(attribute[j],attributes[l]) != 0))
                        j+=3;
                      attributes[l+1]=ParseEntities(attributes[l+1],
                        root->entities,(attribute != (char **) NULL) &&
                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :
                        ' ');
                    }
                  attributes[l]=ConstantString(attributes[l]);
                }
              while (isspace((int) ((unsigned char) *p)) != 0)
                p++;
            }
          }
        else
          {
            while((*p != '\0') && (*p != '/') && (*p != '>'))
              p++;
          }
        if (*p == '/')
          {
            /*
              Self closing tag.
            */
            *p++='\0';
            if (((*p != '\0') && (*p != '>')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
              {
                ParseOpenTag(root,tag,attributes);
                (void) ParseCloseTag(root,tag,exception);
              }
          }
        else
          {
            c=(*p);
            if ((*p == '>') || ((*p == '\0') && (terminal == '>')))
              {
                *p='\0';
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
                  ignore_depth++;
                 *p=c;
               }
             else
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
      }
    else
      if (*p == '/')
        {
          /*
            Close tag.
          */
          tag=p+1;
          p+=strcspn(tag,XMLWhitespace "">"")+1;
          c=(*p);
          if ((c == '\0') && (terminal != '>'))
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,""ParseError"",""missing >"");
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          *p='\0';
          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=
              (XMLTreeInfo *) NULL)
            {
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          if (ignore_depth > 0)
            ignore_depth--;
          *p=c;
          if (isspace((int) ((unsigned char) *p)) != 0)
            p+=strspn(p,XMLWhitespace);
        }
      else
        if (strncmp(p,""!--"",3) == 0)
          {
            /*
              Comment.
            */
            p=strstr(p+3,""--"");
            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\0')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""unclosed <!--"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
        else
          if (strncmp(p,""![CDATA["",8) == 0)
            {
              /*
                Cdata.
              */
              p=strstr(p,""]]>"");
              if (p != (char *) NULL)
                {
                  p+=2;
                  if (ignore_depth == 0)
                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unclosed <![CDATA["");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
            }
          else
            if (strncmp(p,""!DOCTYPE"",8) == 0)
              {
                /*
                  DTD.
                */
                for (l=0; (*p != '\0') && (((l == 0) && (*p != '>')) ||
                     ((l != 0) && ((*p != ']') ||
                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));
                  l=(ssize_t) ((*p == '[') ? 1 : l))
                p+=strcspn(p+1,""[]>"")+1;
                if ((*p == '\0') && (terminal != '>'))
                  {
                    (void) ThrowMagickException(exception,GetMagickModule(),
                      OptionWarning,""ParseError"",""unclosed <!DOCTYPE"");
                    utf8=DestroyString(utf8);
                    return(&root->root);
                  }
                if (l != 0)
                  tag=strchr(tag,'[')+1;
                if (l != 0)
                  {
                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),
                      exception);
                    if (status == MagickFalse)
                      {
                        utf8=DestroyString(utf8);
                        return(&root->root);
                      }
                    p++;
                  }
              }
            else
              if (*p == '?')
                {
                  /*
                    Processing instructions.
                  */
                  do
                  {
                    p=strchr(p,'?');
                    if (p == (char *) NULL)
                      break;
                    p++;
                  } while ((*p != '\0') && (*p != '>'));
                  if ((p == (char *) NULL) || ((*p == '\0') &&
                      (terminal != '>')))
                    {
                      (void) ThrowMagickException(exception,GetMagickModule(),
                        OptionWarning,""ParseError"",""unclosed <?"");
                      utf8=DestroyString(utf8);
                      return(&root->root);
                    }
                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unexpected <"");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
     if ((p == (char *) NULL) || (*p == '\0'))
       break;
     *p++='\0';
     tag=p;
     if ((*p != '\0') && (*p != '<'))
       {
        /*
          Tag character content.
        */
        while ((*p != '\0') && (*p != '<'))
          p++;
        if (*p == '\0')
          break;
        if (ignore_depth == 0)
          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');
      }
    else
      if (*p == '\0')
        break;
  }
  utf8=DestroyString(utf8);
  if (root->node == (XMLTreeInfo *) NULL)
    return(&root->root);
  if (root->node->tag == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return(&root->root);
    }
  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
    ""ParseError"",""unclosed tag: `%s'"",root->node->tag);
  return(&root->root);
}
",C,"                  {
                    ignore_depth++;
                    (void) DestroyXMLTreeAttributes(attributes);
                  }
","                  ignore_depth++;
",,"@@ -2140,7 +2140,10 @@ MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
-                  ignore_depth++;
+                  {
+                    ignore_depth++;
+                    (void) DestroyXMLTreeAttributes(attributes);
+                  }
                 *p=c;
               }
             else",ImageMagick,fc6080f1321fd21e86ef916195cc110b05d9effb,96b300c1bf3b213e8e7331ba54de1836b665cef3,1,"MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
{
  char
    **attribute,
    **attributes,
    *tag,
    *utf8;

  int
    c,
    terminal;

  MagickBooleanType
    status;

  register char
    *p;

  register ssize_t
    i;

  size_t
    ignore_depth,
    length;

  ssize_t
    j,
    l;

  XMLTreeRoot
    *root;

  /*
    Convert xml-string to UTF8.
  */
  if ((xml == (const char *) NULL) || (strlen(xml) == 0))
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return((XMLTreeInfo *) NULL);
    }
  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);
  length=strlen(xml);
  utf8=ConvertUTF16ToUTF8(xml,&length);
  if (utf8 == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""UTF16 to UTF8 failed"");
      return((XMLTreeInfo *) NULL);
    }
  terminal=utf8[length-1];
  utf8[length-1]='\0';
  p=utf8;
  while ((*p != '\0') && (*p != '<'))
    p++;
  if (*p == '\0')
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      utf8=DestroyString(utf8);
      return((XMLTreeInfo *) NULL);
    }
  attribute=(char **) NULL;
  l=0;
  ignore_depth=0;
  for (p++; ; p++)
  {
    attributes=(char **) sentinel;
    tag=p;
    c=(*p);
    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||
        (*p == ':') || (c < '\0'))
      {
        /*
          Tag.
        */
        if (root->node == (XMLTreeInfo *) NULL)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,""ParseError"",""root tag missing"");
            utf8=DestroyString(utf8);
            return(&root->root);
          }
        p+=strcspn(p,XMLWhitespace ""/>"");
        while (isspace((int) ((unsigned char) *p)) != 0)
          *p++='\0';
        if (ignore_depth == 0)
          {
            if ((*p != '\0') && (*p != '/') && (*p != '>'))
              {
                /*
                  Find tag in default attributes list.
                */
                i=0;
                while ((root->attributes[i] != (char **) NULL) &&
                       (strcmp(root->attributes[i][0],tag) != 0))
                  i++;
                attribute=root->attributes[i];
              }
            for (l=0; (*p != '\0') && (*p != '/') && (*p != '>'); l+=2)
            {
              /*
                Attribute.
              */
              if (l == 0)
                attributes=(char **) AcquireQuantumMemory(4,
                  sizeof(*attributes));
              else
                attributes=(char **) ResizeQuantumMemory(attributes,
                  (size_t) (l+4),sizeof(*attributes));
              if (attributes == (char **) NULL)
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
              attributes[l+2]=(char *) NULL;
              attributes[l+1]=(char *) NULL;
              attributes[l]=p;
              p+=strcspn(p,XMLWhitespace ""=/>"");
              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))
                attributes[l]=ConstantString("""");
              else
                {
                  *p++='\0';
                  p+=strspn(p,XMLWhitespace ""="");
                  c=(*p);
                  if ((c == '""') || (c == '\''))
                    {
                      /*
                        Attributes value.
                      */
                      p++;
                      attributes[l+1]=p;
                      while ((*p != '\0') && (*p != c))
                        p++;
                      if (*p != '\0')
                        *p++='\0';
                      else
                        {
                          attributes[l]=ConstantString("""");
                          attributes[l+1]=ConstantString("""");
                          (void) DestroyXMLTreeAttributes(attributes);
                          (void) ThrowMagickException(exception,
                            GetMagickModule(),OptionWarning,""ParseError"",
                            ""missing %c"",c);
                          utf8=DestroyString(utf8);
                          return(&root->root);
                        }
                      j=1;
                      while ((attribute != (char **) NULL) &&
                             (attribute[j] != (char *) NULL) &&
                             (strcmp(attribute[j],attributes[l]) != 0))
                        j+=3;
                      attributes[l+1]=ParseEntities(attributes[l+1],
                        root->entities,(attribute != (char **) NULL) &&
                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :
                        ' ');
                    }
                  attributes[l]=ConstantString(attributes[l]);
                }
              while (isspace((int) ((unsigned char) *p)) != 0)
                p++;
            }
          }
        else
          {
            while((*p != '\0') && (*p != '/') && (*p != '>'))
              p++;
          }
        if (*p == '/')
          {
            /*
              Self closing tag.
            */
            *p++='\0';
            if (((*p != '\0') && (*p != '>')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
              {
                ParseOpenTag(root,tag,attributes);
                (void) ParseCloseTag(root,tag,exception);
              }
          }
        else
          {
            c=(*p);
            if ((*p == '>') || ((*p == '\0') && (terminal == '>')))
              {
                *p='\0';
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
//flaw_line_below:
                  ignore_depth++;
//fix_flaw_line_below:
//                  {
//fix_flaw_line_below:
//                    ignore_depth++;
//fix_flaw_line_below:
//                    (void) DestroyXMLTreeAttributes(attributes);
//fix_flaw_line_below:
//                  }
                 *p=c;
               }
             else
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
      }
    else
      if (*p == '/')
        {
          /*
            Close tag.
          */
          tag=p+1;
          p+=strcspn(tag,XMLWhitespace "">"")+1;
          c=(*p);
          if ((c == '\0') && (terminal != '>'))
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,""ParseError"",""missing >"");
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          *p='\0';
          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=
              (XMLTreeInfo *) NULL)
            {
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          if (ignore_depth > 0)
            ignore_depth--;
          *p=c;
          if (isspace((int) ((unsigned char) *p)) != 0)
            p+=strspn(p,XMLWhitespace);
        }
      else
        if (strncmp(p,""!--"",3) == 0)
          {
            /*
              Comment.
            */
            p=strstr(p+3,""--"");
            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\0')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""unclosed <!--"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
        else
          if (strncmp(p,""![CDATA["",8) == 0)
            {
              /*
                Cdata.
              */
              p=strstr(p,""]]>"");
              if (p != (char *) NULL)
                {
                  p+=2;
                  if (ignore_depth == 0)
                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unclosed <![CDATA["");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
            }
          else
            if (strncmp(p,""!DOCTYPE"",8) == 0)
              {
                /*
                  DTD.
                */
                for (l=0; (*p != '\0') && (((l == 0) && (*p != '>')) ||
                     ((l != 0) && ((*p != ']') ||
                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));
                  l=(ssize_t) ((*p == '[') ? 1 : l))
                p+=strcspn(p+1,""[]>"")+1;
                if ((*p == '\0') && (terminal != '>'))
                  {
                    (void) ThrowMagickException(exception,GetMagickModule(),
                      OptionWarning,""ParseError"",""unclosed <!DOCTYPE"");
                    utf8=DestroyString(utf8);
                    return(&root->root);
                  }
                if (l != 0)
                  tag=strchr(tag,'[')+1;
                if (l != 0)
                  {
                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),
                      exception);
                    if (status == MagickFalse)
                      {
                        utf8=DestroyString(utf8);
                        return(&root->root);
                      }
                    p++;
                  }
              }
            else
              if (*p == '?')
                {
                  /*
                    Processing instructions.
                  */
                  do
                  {
                    p=strchr(p,'?');
                    if (p == (char *) NULL)
                      break;
                    p++;
                  } while ((*p != '\0') && (*p != '>'));
                  if ((p == (char *) NULL) || ((*p == '\0') &&
                      (terminal != '>')))
                    {
                      (void) ThrowMagickException(exception,GetMagickModule(),
                        OptionWarning,""ParseError"",""unclosed <?"");
                      utf8=DestroyString(utf8);
                      return(&root->root);
                    }
                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unexpected <"");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
     if ((p == (char *) NULL) || (*p == '\0'))
       break;
     *p++='\0';
     tag=p;
     if ((*p != '\0') && (*p != '<'))
       {
        /*
          Tag character content.
        */
        while ((*p != '\0') && (*p != '<'))
          p++;
        if (*p == '\0')
          break;
        if (ignore_depth == 0)
          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');
      }
    else
      if (*p == '\0')
        break;
  }
  utf8=DestroyString(utf8);
  if (root->node == (XMLTreeInfo *) NULL)
    return(&root->root);
  if (root->node->tag == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return(&root->root);
    }
  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
    ""ParseError"",""unclosed tag: `%s'"",root->node->tag);
  return(&root->root);
}
",181815,"MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
{
  char
    **attribute,
    **attributes,
    *tag,
    *utf8;

  int
    c,
    terminal;

  MagickBooleanType
    status;

  register char
    *p;

  register ssize_t
    i;

  size_t
    ignore_depth,
    length;

  ssize_t
    j,
    l;

  XMLTreeRoot
    *root;

  /*
    Convert xml-string to UTF8.
  */
  if ((xml == (const char *) NULL) || (strlen(xml) == 0))
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return((XMLTreeInfo *) NULL);
    }
  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);
  length=strlen(xml);
  utf8=ConvertUTF16ToUTF8(xml,&length);
  if (utf8 == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""UTF16 to UTF8 failed"");
      return((XMLTreeInfo *) NULL);
    }
  terminal=utf8[length-1];
  utf8[length-1]='\0';
  p=utf8;
  while ((*p != '\0') && (*p != '<'))
    p++;
  if (*p == '\0')
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      utf8=DestroyString(utf8);
      return((XMLTreeInfo *) NULL);
    }
  attribute=(char **) NULL;
  l=0;
  ignore_depth=0;
  for (p++; ; p++)
  {
    attributes=(char **) sentinel;
    tag=p;
    c=(*p);
    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||
        (*p == ':') || (c < '\0'))
      {
        /*
          Tag.
        */
        if (root->node == (XMLTreeInfo *) NULL)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,""ParseError"",""root tag missing"");
            utf8=DestroyString(utf8);
            return(&root->root);
          }
        p+=strcspn(p,XMLWhitespace ""/>"");
        while (isspace((int) ((unsigned char) *p)) != 0)
          *p++='\0';
        if (ignore_depth == 0)
          {
            if ((*p != '\0') && (*p != '/') && (*p != '>'))
              {
                /*
                  Find tag in default attributes list.
                */
                i=0;
                while ((root->attributes[i] != (char **) NULL) &&
                       (strcmp(root->attributes[i][0],tag) != 0))
                  i++;
                attribute=root->attributes[i];
              }
            for (l=0; (*p != '\0') && (*p != '/') && (*p != '>'); l+=2)
            {
              /*
                Attribute.
              */
              if (l == 0)
                attributes=(char **) AcquireQuantumMemory(4,
                  sizeof(*attributes));
              else
                attributes=(char **) ResizeQuantumMemory(attributes,
                  (size_t) (l+4),sizeof(*attributes));
              if (attributes == (char **) NULL)
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
              attributes[l+2]=(char *) NULL;
              attributes[l+1]=(char *) NULL;
              attributes[l]=p;
              p+=strcspn(p,XMLWhitespace ""=/>"");
              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))
                attributes[l]=ConstantString("""");
              else
                {
                  *p++='\0';
                  p+=strspn(p,XMLWhitespace ""="");
                  c=(*p);
                  if ((c == '""') || (c == '\''))
                    {
                      /*
                        Attributes value.
                      */
                      p++;
                      attributes[l+1]=p;
                      while ((*p != '\0') && (*p != c))
                        p++;
                      if (*p != '\0')
                        *p++='\0';
                      else
                        {
                          attributes[l]=ConstantString("""");
                          attributes[l+1]=ConstantString("""");
                          (void) DestroyXMLTreeAttributes(attributes);
                          (void) ThrowMagickException(exception,
                            GetMagickModule(),OptionWarning,""ParseError"",
                            ""missing %c"",c);
                          utf8=DestroyString(utf8);
                          return(&root->root);
                        }
                      j=1;
                      while ((attribute != (char **) NULL) &&
                             (attribute[j] != (char *) NULL) &&
                             (strcmp(attribute[j],attributes[l]) != 0))
                        j+=3;
                      attributes[l+1]=ParseEntities(attributes[l+1],
                        root->entities,(attribute != (char **) NULL) &&
                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :
                        ' ');
                    }
                  attributes[l]=ConstantString(attributes[l]);
                }
              while (isspace((int) ((unsigned char) *p)) != 0)
                p++;
            }
          }
        else
          {
            while((*p != '\0') && (*p != '/') && (*p != '>'))
              p++;
          }
        if (*p == '/')
          {
            /*
              Self closing tag.
            */
            *p++='\0';
            if (((*p != '\0') && (*p != '>')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
              {
                ParseOpenTag(root,tag,attributes);
                (void) ParseCloseTag(root,tag,exception);
              }
          }
        else
          {
            c=(*p);
            if ((*p == '>') || ((*p == '\0') && (terminal == '>')))
              {
                *p='\0';
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
                  ignore_depth++;
                 *p=c;
               }
             else
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
      }
    else
      if (*p == '/')
        {
          /*
            Close tag.
          */
          tag=p+1;
          p+=strcspn(tag,XMLWhitespace "">"")+1;
          c=(*p);
          if ((c == '\0') && (terminal != '>'))
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,""ParseError"",""missing >"");
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          *p='\0';
          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=
              (XMLTreeInfo *) NULL)
            {
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          if (ignore_depth > 0)
            ignore_depth--;
          *p=c;
          if (isspace((int) ((unsigned char) *p)) != 0)
            p+=strspn(p,XMLWhitespace);
        }
      else
        if (strncmp(p,""!--"",3) == 0)
          {
            /*
              Comment.
            */
            p=strstr(p+3,""--"");
            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\0')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""unclosed <!--"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
        else
          if (strncmp(p,""![CDATA["",8) == 0)
            {
              /*
                Cdata.
              */
              p=strstr(p,""]]>"");
              if (p != (char *) NULL)
                {
                  p+=2;
                  if (ignore_depth == 0)
                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unclosed <![CDATA["");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
            }
          else
            if (strncmp(p,""!DOCTYPE"",8) == 0)
              {
                /*
                  DTD.
                */
                for (l=0; (*p != '\0') && (((l == 0) && (*p != '>')) ||
                     ((l != 0) && ((*p != ']') ||
                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));
                  l=(ssize_t) ((*p == '[') ? 1 : l))
                p+=strcspn(p+1,""[]>"")+1;
                if ((*p == '\0') && (terminal != '>'))
                  {
                    (void) ThrowMagickException(exception,GetMagickModule(),
                      OptionWarning,""ParseError"",""unclosed <!DOCTYPE"");
                    utf8=DestroyString(utf8);
                    return(&root->root);
                  }
                if (l != 0)
                  tag=strchr(tag,'[')+1;
                if (l != 0)
                  {
                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),
                      exception);
                    if (status == MagickFalse)
                      {
                        utf8=DestroyString(utf8);
                        return(&root->root);
                      }
                    p++;
                  }
              }
            else
              if (*p == '?')
                {
                  /*
                    Processing instructions.
                  */
                  do
                  {
                    p=strchr(p,'?');
                    if (p == (char *) NULL)
                      break;
                    p++;
                  } while ((*p != '\0') && (*p != '>'));
                  if ((p == (char *) NULL) || ((*p == '\0') &&
                      (terminal != '>')))
                    {
                      (void) ThrowMagickException(exception,GetMagickModule(),
                        OptionWarning,""ParseError"",""unclosed <?"");
                      utf8=DestroyString(utf8);
                      return(&root->root);
                    }
                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unexpected <"");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
     if ((p == (char *) NULL) || (*p == '\0'))
       break;
     *p++='\0';
     tag=p;
     if ((*p != '\0') && (*p != '<'))
       {
        /*
          Tag character content.
        */
        while ((*p != '\0') && (*p != '<'))
          p++;
        if (*p == '\0')
          break;
        if (ignore_depth == 0)
          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');
      }
    else
      if (*p == '\0')
        break;
  }
  utf8=DestroyString(utf8);
  if (root->node == (XMLTreeInfo *) NULL)
    return(&root->root);
  if (root->node->tag == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return(&root->root);
    }
  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
    ""ParseError"",""unclosed tag: `%s'"",root->node->tag);
  return(&root->root);
}
","MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
{
  char
    **attribute,
    **attributes,
    *tag,
    *utf8;

  int
    c,
    terminal;

  MagickBooleanType
    status;

  register char
    *p;

  register ssize_t
    i;

  size_t
    ignore_depth,
    length;

  ssize_t
    j,
    l;

  XMLTreeRoot
    *root;

  /*
    Convert xml-string to UTF8.
  */
  if ((xml == (const char *) NULL) || (strlen(xml) == 0))
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return((XMLTreeInfo *) NULL);
    }
  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);
  length=strlen(xml);
  utf8=ConvertUTF16ToUTF8(xml,&length);
  if (utf8 == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""UTF16 to UTF8 failed"");
      return((XMLTreeInfo *) NULL);
    }
  terminal=utf8[length-1];
  utf8[length-1]='\0';
  p=utf8;
  while ((*p != '\0') && (*p != '<'))
    p++;
  if (*p == '\0')
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      utf8=DestroyString(utf8);
      return((XMLTreeInfo *) NULL);
    }
  attribute=(char **) NULL;
  l=0;
  ignore_depth=0;
  for (p++; ; p++)
  {
    attributes=(char **) sentinel;
    tag=p;
    c=(*p);
    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||
        (*p == ':') || (c < '\0'))
      {
        /*
          Tag.
        */
        if (root->node == (XMLTreeInfo *) NULL)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,""ParseError"",""root tag missing"");
            utf8=DestroyString(utf8);
            return(&root->root);
          }
        p+=strcspn(p,XMLWhitespace ""/>"");
        while (isspace((int) ((unsigned char) *p)) != 0)
          *p++='\0';
        if (ignore_depth == 0)
          {
            if ((*p != '\0') && (*p != '/') && (*p != '>'))
              {
                /*
                  Find tag in default attributes list.
                */
                i=0;
                while ((root->attributes[i] != (char **) NULL) &&
                       (strcmp(root->attributes[i][0],tag) != 0))
                  i++;
                attribute=root->attributes[i];
              }
            for (l=0; (*p != '\0') && (*p != '/') && (*p != '>'); l+=2)
            {
              /*
                Attribute.
              */
              if (l == 0)
                attributes=(char **) AcquireQuantumMemory(4,
                  sizeof(*attributes));
              else
                attributes=(char **) ResizeQuantumMemory(attributes,
                  (size_t) (l+4),sizeof(*attributes));
              if (attributes == (char **) NULL)
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
              attributes[l+2]=(char *) NULL;
              attributes[l+1]=(char *) NULL;
              attributes[l]=p;
              p+=strcspn(p,XMLWhitespace ""=/>"");
              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))
                attributes[l]=ConstantString("""");
              else
                {
                  *p++='\0';
                  p+=strspn(p,XMLWhitespace ""="");
                  c=(*p);
                  if ((c == '""') || (c == '\''))
                    {
                      /*
                        Attributes value.
                      */
                      p++;
                      attributes[l+1]=p;
                      while ((*p != '\0') && (*p != c))
                        p++;
                      if (*p != '\0')
                        *p++='\0';
                      else
                        {
                          attributes[l]=ConstantString("""");
                          attributes[l+1]=ConstantString("""");
                          (void) DestroyXMLTreeAttributes(attributes);
                          (void) ThrowMagickException(exception,
                            GetMagickModule(),OptionWarning,""ParseError"",
                            ""missing %c"",c);
                          utf8=DestroyString(utf8);
                          return(&root->root);
                        }
                      j=1;
                      while ((attribute != (char **) NULL) &&
                             (attribute[j] != (char *) NULL) &&
                             (strcmp(attribute[j],attributes[l]) != 0))
                        j+=3;
                      attributes[l+1]=ParseEntities(attributes[l+1],
                        root->entities,(attribute != (char **) NULL) &&
                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :
                        ' ');
                    }
                  attributes[l]=ConstantString(attributes[l]);
                }
              while (isspace((int) ((unsigned char) *p)) != 0)
                p++;
            }
          }
        else
          {
            while((*p != '\0') && (*p != '/') && (*p != '>'))
              p++;
          }
        if (*p == '/')
          {
            /*
              Self closing tag.
            */
            *p++='\0';
            if (((*p != '\0') && (*p != '>')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
              {
                ParseOpenTag(root,tag,attributes);
                (void) ParseCloseTag(root,tag,exception);
              }
          }
        else
          {
            c=(*p);
            if ((*p == '>') || ((*p == '\0') && (terminal == '>')))
              {
                *p='\0';
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
                  {
                    ignore_depth++;
                    (void) DestroyXMLTreeAttributes(attributes);
                  }
                 *p=c;
               }
             else
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
      }
    else
      if (*p == '/')
        {
          /*
            Close tag.
          */
          tag=p+1;
          p+=strcspn(tag,XMLWhitespace "">"")+1;
          c=(*p);
          if ((c == '\0') && (terminal != '>'))
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,""ParseError"",""missing >"");
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          *p='\0';
          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=
              (XMLTreeInfo *) NULL)
            {
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          if (ignore_depth > 0)
            ignore_depth--;
          *p=c;
          if (isspace((int) ((unsigned char) *p)) != 0)
            p+=strspn(p,XMLWhitespace);
        }
      else
        if (strncmp(p,""!--"",3) == 0)
          {
            /*
              Comment.
            */
            p=strstr(p+3,""--"");
            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\0')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""unclosed <!--"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
        else
          if (strncmp(p,""![CDATA["",8) == 0)
            {
              /*
                Cdata.
              */
              p=strstr(p,""]]>"");
              if (p != (char *) NULL)
                {
                  p+=2;
                  if (ignore_depth == 0)
                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unclosed <![CDATA["");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
            }
          else
            if (strncmp(p,""!DOCTYPE"",8) == 0)
              {
                /*
                  DTD.
                */
                for (l=0; (*p != '\0') && (((l == 0) && (*p != '>')) ||
                     ((l != 0) && ((*p != ']') ||
                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));
                  l=(ssize_t) ((*p == '[') ? 1 : l))
                p+=strcspn(p+1,""[]>"")+1;
                if ((*p == '\0') && (terminal != '>'))
                  {
                    (void) ThrowMagickException(exception,GetMagickModule(),
                      OptionWarning,""ParseError"",""unclosed <!DOCTYPE"");
                    utf8=DestroyString(utf8);
                    return(&root->root);
                  }
                if (l != 0)
                  tag=strchr(tag,'[')+1;
                if (l != 0)
                  {
                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),
                      exception);
                    if (status == MagickFalse)
                      {
                        utf8=DestroyString(utf8);
                        return(&root->root);
                      }
                    p++;
                  }
              }
            else
              if (*p == '?')
                {
                  /*
                    Processing instructions.
                  */
                  do
                  {
                    p=strchr(p,'?');
                    if (p == (char *) NULL)
                      break;
                    p++;
                  } while ((*p != '\0') && (*p != '>'));
                  if ((p == (char *) NULL) || ((*p == '\0') &&
                      (terminal != '>')))
                    {
                      (void) ThrowMagickException(exception,GetMagickModule(),
                        OptionWarning,""ParseError"",""unclosed <?"");
                      utf8=DestroyString(utf8);
                      return(&root->root);
                    }
                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unexpected <"");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
     if ((p == (char *) NULL) || (*p == '\0'))
       break;
     *p++='\0';
     tag=p;
     if ((*p != '\0') && (*p != '<'))
       {
        /*
          Tag character content.
        */
        while ((*p != '\0') && (*p != '<'))
          p++;
        if (*p == '\0')
          break;
        if (ignore_depth == 0)
          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');
      }
    else
      if (*p == '\0')
        break;
  }
  utf8=DestroyString(utf8);
  if (root->node == (XMLTreeInfo *) NULL)
    return(&root->root);
  if (root->node->tag == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return(&root->root);
    }
  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
    ""ParseError"",""unclosed tag: `%s'"",root->node->tag);
  return(&root->root);
}
","The `NewXMLTree` function parses an XML string and constructs an XML tree structure, handling various XML components such as tags, attributes, comments, and character data. It begins by converting the input XML string from UTF-16 to UTF-8 and checks for errors, including missing root tags. The function iterates through the string, identifying and processing tags, attributes, and special constructs like comments and CDATA sections. It manages nested structures and maintains an ignore depth for certain tags. If parsing errors occur, appropriate exceptions are thrown, and the function returns a pointer to the constructed XML tree or NULL in case of failure.","The provided code defines a function that parses an XML string to create a structured representation of the XML data. It begins by validating the input and converting it to a specific encoding format. The function then processes the string character by character, identifying and handling various XML elements such as tags, attributes, comments, and character data. It manages nested structures and tracks the depth of certain tags to ensure proper parsing. Throughout the process, it checks for errors and throws exceptions when issues arise, ultimately returning a structured representation of the XML or indicating failure.","The vulnerability in the original code, classified under CWE-22 (Improper Limitation of a Pathname to a Restricted Directory), arises from insufficient validation of the XML input, which could allow an attacker to manipulate the parsing process and potentially access or modify unintended files or directories. Specifically, the code fails to properly handle cases where the XML structure is malformed or contains unexpected characters, leading to potential exploitation. The fixed code addresses this by adding checks for missing root tags and ensuring that the parsing process correctly identifies and handles various XML constructs, thereby preventing unauthorized access or manipulation of the file system.","The vulnerability identified under CWE-22 arises from inadequate validation of input data, which can lead to improper handling of file paths or XML structures. In the original code, the lack of checks for malformed XML or unexpected characters allows an attacker to manipulate the parsing process, potentially leading to unauthorized access or exploitation of the system. The fixed code enhances security by implementing additional validation checks to ensure that the XML input is well-formed and adheres to expected structures, thereby mitigating the risk of path traversal or other related attacks.","The vulnerability was fixed by introducing additional validation checks throughout the parsing process. The code now verifies that the input XML string is not null and contains a valid root tag, using conditions that check for missing tags and malformed structures. For instance, checks like `if (root->node == (XMLTreeInfo *) NULL)` ensure that the root node is properly initialized before proceeding. Additionally, the code now handles various XML constructs more robustly, throwing exceptions with `ThrowMagickException` when encountering issues such as unclosed tags or missing attributes, thus preventing potential exploitation through malformed input.","The vulnerability was addressed by implementing stricter validation checks to ensure that the input data is well-formed and adheres to expected XML structures. The code now verifies the presence of a valid root tag and checks for malformed elements, throwing exceptions when issues are detected. Additionally, the parsing logic was enhanced to handle various XML constructs more robustly, ensuring that any unexpected characters or structures are properly managed. These improvements collectively mitigate the risk of unauthorized access or exploitation by ensuring that only valid and correctly formatted input is processed."
6,184888,184888,,Remote,Not required,Partial,CVE-2013-2900,https://www.cvedetails.com/cve/CVE-2013-2900/,CWE-22,Low,Partial,Partial,,2013-08-21,7.5,"The FilePath::ReferencesParent function in files/file_path.cc in Google Chrome before 29.0.1547.57 on Windows does not properly handle pathname components composed entirely of . (dot) and whitespace characters, which allows remote attackers to conduct directory traversal attacks via a crafted directory name.",2017-09-18,Dir. Trav. ,3,https://github.com/chromium/chromium/commit/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337,bd3392a1f8b95bf0b0ee3821bc3245d743fb1337,"AX: Calendar Picker: Add AX labels to MonthPopupButton and CalendarNavigationButtons.

This CL adds no new tests. Will add tests after a Chromium change for
string resource.

BUG=123896

Review URL: https://codereview.chromium.org/552163002

git-svn-id: svn://svn.chromium.org/blink/trunk@181617 bbb929c8-8fbe-4397-9dbb-9b2b20218538",0,third_party/WebKit/Source/web/DateTimeChooserImpl.cpp,"{""sha"": ""12cccdfa59676411125945dcd7aa13898fc408e2"", ""filename"": ""third_party/WebKit/ManualTests/forms/calendar-picker.html"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/ManualTests/forms/calendar-picker.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/ManualTests/forms/calendar-picker.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/ManualTests/forms/calendar-picker.html?ref=bd3392a1f8b95bf0b0ee3821bc3245d743fb1337"", ""patch"": ""@@ -269,7 +269,11 @@ <h2>Config</h2>\n         min: config.min,\n         step: config.step * (config.type === \""month\"" ? 1 : 86400000),\n         stepBase: \""0\"",\n-        currentValue: config.value\n+        currentValue: config.value,\n+        axShowMonthSelector: \""Show month selection panel\"",\n+        axShowNextMonth: \""Show next month\"",\n+        axShowPreviousMonth: \""Show previous month\"",\n+        todayLabel: \""Today\"",\n     }\n };\n ""}<_**next**_>{""sha"": ""1cdb077dea9cd61af7c69ae482e4c0cfe9253113"", ""filename"": ""third_party/WebKit/Source/web/DateTimeChooserImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/Source/web/DateTimeChooserImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/Source/web/DateTimeChooserImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/web/DateTimeChooserImpl.cpp?ref=bd3392a1f8b95bf0b0ee3821bc3245d743fb1337"", ""patch"": ""@@ -138,6 +138,9 @@ void DateTimeChooserImpl::writeDocument(SharedBuffer* data)\n     addProperty(\""todayLabel\"", todayLabelString, data);\n     addProperty(\""clearLabel\"", locale().queryString(WebLocalizedString::CalendarClear), data);\n     addProperty(\""weekLabel\"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);\n+    addProperty(\""axShowMonthSelector\"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);\n+    addProperty(\""axShowNextMonth\"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);\n+    addProperty(\""axShowPreviousMonth\"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);\n     addProperty(\""weekStartDay\"", m_locale->firstDayOfWeek(), data);\n     addProperty(\""shortMonthLabels\"", m_locale->shortMonthLabels(), data);\n     addProperty(\""dayLabels\"", m_locale->weekDayShortLabels(), data);""}<_**next**_>{""sha"": ""2459e401c4237a186e0039c67c54ad271412b12d"", ""filename"": ""third_party/WebKit/Source/web/resources/calendarPicker.js"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/Source/web/resources/calendarPicker.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/Source/web/resources/calendarPicker.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/web/resources/calendarPicker.js?ref=bd3392a1f8b95bf0b0ee3821bc3245d743fb1337"", ""patch"": ""@@ -2763,6 +2763,7 @@ MonthPopupView.prototype.onClick = function(event) {\n  */\n function MonthPopupButton(maxWidth) {\n     View.call(this, createElement(\""button\"", MonthPopupButton.ClassNameMonthPopupButton));\n+    this.element.setAttribute(\""aria-label\"", global.params.axShowMonthSelector);\n \n     /**\n      * @type {!Element}\n@@ -2951,6 +2952,7 @@ function CalendarHeaderView(calendarPicker) {\n     this._previousMonthButton.attachTo(this);\n     this._previousMonthButton.on(CalendarNavigationButton.EventTypeButtonClick, this.onNavigationButtonClick);\n     this._previousMonthButton.on(CalendarNavigationButton.EventTypeRepeatingButtonClick, this.onNavigationButtonClick);\n+    this._previousMonthButton.element.setAttribute(\""aria-label\"", global.params.axShowPreviousMonth);\n \n     /**\n      * @type {!CalendarNavigationButton}\n@@ -2962,6 +2964,7 @@ function CalendarHeaderView(calendarPicker) {\n     this._todayButton.element.classList.add(CalendarHeaderView.ClassNameTodayButton);\n     var monthContainingToday = Month.createFromToday();\n     this._todayButton.setDisabled(monthContainingToday < this.calendarPicker.minimumMonth || monthContainingToday > this.calendarPicker.maximumMonth);\n+    this._todayButton.element.setAttribute(\""aria-label\"", global.params.todayLabel);\n \n     /**\n      * @type {!CalendarNavigationButton}\n@@ -2971,6 +2974,7 @@ function CalendarHeaderView(calendarPicker) {\n     this._nextMonthButton.attachTo(this);\n     this._nextMonthButton.on(CalendarNavigationButton.EventTypeButtonClick, this.onNavigationButtonClick);\n     this._nextMonthButton.on(CalendarNavigationButton.EventTypeRepeatingButtonClick, this.onNavigationButtonClick);\n+    this._nextMonthButton.element.setAttribute(\""aria-label\"", global.params.axShowNextMonth);\n \n     if (global.params.isLocaleRTL) {\n         this._nextMonthButton.element.innerHTML = CalendarHeaderView._BackwardTriangle;""}<_**next**_>{""sha"": ""d2cc50cce3d1f450b6e1e35ca03a41d25518be8c"", ""filename"": ""third_party/WebKit/public/platform/WebLocalizedString.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/public/platform/WebLocalizedString.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/public/platform/WebLocalizedString.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/public/platform/WebLocalizedString.h?ref=bd3392a1f8b95bf0b0ee3821bc3245d743fb1337"", ""patch"": ""@@ -37,6 +37,9 @@ struct WebLocalizedString {\n     enum Name {\n         AXAMPMFieldText,\n         AXButtonActionVerb,\n+        AXCalendarShowMonthSelector,\n+        AXCalendarShowNextMonth,\n+        AXCalendarShowPreviousMonth,\n         AXCheckedCheckBoxActionVerb,\n         AXDateTimeFieldEmptyValueText,\n         AXDayOfMonthFieldText,""}","void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
{
    String stepString = String::number(m_parameters.step);
    String stepBaseString = String::number(m_parameters.stepBase, 11, WTF::TruncateTrailingZeros);
    IntRect anchorRectInScreen = m_chromeClient->rootViewToScreen(m_parameters.anchorRectInRootView);
    String todayLabelString;
    String otherDateLabelString;
    if (m_parameters.type == InputTypeNames::month) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisMonthButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherMonthLabel);
    } else if (m_parameters.type == InputTypeNames::week) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisWeekButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherWeekLabel);
    } else {
        todayLabelString = locale().queryString(WebLocalizedString::CalendarToday);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherDateLabel);
    }

    addString(""<!DOCTYPE html><head><meta charset='UTF-8'><style>\n"", data);
    data->append(Platform::current()->loadResource(""pickerCommon.css""));
    data->append(Platform::current()->loadResource(""pickerButton.css""));
    data->append(Platform::current()->loadResource(""suggestionPicker.css""));
    data->append(Platform::current()->loadResource(""calendarPicker.css""));
    addString(""</style></head><body><div id=main>Loading...</div><script>\n""
        ""window.dialogArguments = {\n"", data);
    addProperty(""anchorRectInScreen"", anchorRectInScreen, data);
    addProperty(""min"", valueToDateTimeString(m_parameters.minimum, m_parameters.type), data);
    addProperty(""max"", valueToDateTimeString(m_parameters.maximum, m_parameters.type), data);
    addProperty(""step"", stepString, data);
    addProperty(""stepBase"", stepBaseString, data);
    addProperty(""required"", m_parameters.required, data);
    addProperty(""currentValue"", valueToDateTimeString(m_parameters.doubleValue, m_parameters.type), data);
    addProperty(""locale"", m_parameters.locale.string(), data);
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
    addProperty(""axShowMonthSelector"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);
    addProperty(""axShowNextMonth"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);
    addProperty(""axShowPreviousMonth"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);
    addProperty(""isLocaleRTL"", m_locale->isRTL(), data);
    addProperty(""isRTL"", m_parameters.isAnchorElementRTL, data);
    addProperty(""mode"", m_parameters.type.string(), data);
    if (m_parameters.suggestions.size()) {
        Vector<String> suggestionValues;
        Vector<String> localizedSuggestionValues;
        Vector<String> suggestionLabels;
        for (unsigned i = 0; i < m_parameters.suggestions.size(); i++) {
            suggestionValues.append(valueToDateTimeString(m_parameters.suggestions[i].value, m_parameters.type));
            localizedSuggestionValues.append(m_parameters.suggestions[i].localizedValue);
            suggestionLabels.append(m_parameters.suggestions[i].label);
        }
        addProperty(""suggestionValues"", suggestionValues, data);
        addProperty(""localizedSuggestionValues"", localizedSuggestionValues, data);
        addProperty(""suggestionLabels"", suggestionLabels, data);
        addProperty(""inputWidth"", static_cast<unsigned>(m_parameters.anchorRectInRootView.width()), data);
        addProperty(""showOtherDateEntry"", RenderTheme::theme().supportsCalendarPicker(m_parameters.type), data);
        addProperty(""otherDateLabel"", otherDateLabelString, data);
        addProperty(""suggestionHighlightColor"", RenderTheme::theme().activeListBoxSelectionBackgroundColor().serialized(), data);
        addProperty(""suggestionHighlightTextColor"", RenderTheme::theme().activeListBoxSelectionForegroundColor().serialized(), data);
    }
    addString(""}\n"", data);

    data->append(Platform::current()->loadResource(""pickerCommon.js""));
    data->append(Platform::current()->loadResource(""suggestionPicker.js""));
    data->append(Platform::current()->loadResource(""calendarPicker.js""));
    addString(""</script></body>\n"", data);
}
","void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
{
    String stepString = String::number(m_parameters.step);
    String stepBaseString = String::number(m_parameters.stepBase, 11, WTF::TruncateTrailingZeros);
    IntRect anchorRectInScreen = m_chromeClient->rootViewToScreen(m_parameters.anchorRectInRootView);
    String todayLabelString;
    String otherDateLabelString;
    if (m_parameters.type == InputTypeNames::month) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisMonthButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherMonthLabel);
    } else if (m_parameters.type == InputTypeNames::week) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisWeekButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherWeekLabel);
    } else {
        todayLabelString = locale().queryString(WebLocalizedString::CalendarToday);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherDateLabel);
    }

    addString(""<!DOCTYPE html><head><meta charset='UTF-8'><style>\n"", data);
    data->append(Platform::current()->loadResource(""pickerCommon.css""));
    data->append(Platform::current()->loadResource(""pickerButton.css""));
    data->append(Platform::current()->loadResource(""suggestionPicker.css""));
    data->append(Platform::current()->loadResource(""calendarPicker.css""));
    addString(""</style></head><body><div id=main>Loading...</div><script>\n""
        ""window.dialogArguments = {\n"", data);
    addProperty(""anchorRectInScreen"", anchorRectInScreen, data);
    addProperty(""min"", valueToDateTimeString(m_parameters.minimum, m_parameters.type), data);
    addProperty(""max"", valueToDateTimeString(m_parameters.maximum, m_parameters.type), data);
    addProperty(""step"", stepString, data);
    addProperty(""stepBase"", stepBaseString, data);
    addProperty(""required"", m_parameters.required, data);
    addProperty(""currentValue"", valueToDateTimeString(m_parameters.doubleValue, m_parameters.type), data);
    addProperty(""locale"", m_parameters.locale.string(), data);
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);
    addProperty(""isLocaleRTL"", m_locale->isRTL(), data);
    addProperty(""isRTL"", m_parameters.isAnchorElementRTL, data);
    addProperty(""mode"", m_parameters.type.string(), data);
    if (m_parameters.suggestions.size()) {
        Vector<String> suggestionValues;
        Vector<String> localizedSuggestionValues;
        Vector<String> suggestionLabels;
        for (unsigned i = 0; i < m_parameters.suggestions.size(); i++) {
            suggestionValues.append(valueToDateTimeString(m_parameters.suggestions[i].value, m_parameters.type));
            localizedSuggestionValues.append(m_parameters.suggestions[i].localizedValue);
            suggestionLabels.append(m_parameters.suggestions[i].label);
        }
        addProperty(""suggestionValues"", suggestionValues, data);
        addProperty(""localizedSuggestionValues"", localizedSuggestionValues, data);
        addProperty(""suggestionLabels"", suggestionLabels, data);
        addProperty(""inputWidth"", static_cast<unsigned>(m_parameters.anchorRectInRootView.width()), data);
        addProperty(""showOtherDateEntry"", RenderTheme::theme().supportsCalendarPicker(m_parameters.type), data);
        addProperty(""otherDateLabel"", otherDateLabelString, data);
        addProperty(""suggestionHighlightColor"", RenderTheme::theme().activeListBoxSelectionBackgroundColor().serialized(), data);
        addProperty(""suggestionHighlightTextColor"", RenderTheme::theme().activeListBoxSelectionForegroundColor().serialized(), data);
    }
    addString(""}\n"", data);

    data->append(Platform::current()->loadResource(""pickerCommon.js""));
    data->append(Platform::current()->loadResource(""suggestionPicker.js""));
    data->append(Platform::current()->loadResource(""calendarPicker.js""));
    addString(""</script></body>\n"", data);
}
",C,"    addProperty(""axShowMonthSelector"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);
    addProperty(""axShowNextMonth"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);
    addProperty(""axShowPreviousMonth"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);
",,,"@@ -138,6 +138,9 @@ void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
+    addProperty(""axShowMonthSelector"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);
+    addProperty(""axShowNextMonth"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);
+    addProperty(""axShowPreviousMonth"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);",Chrome,bd3392a1f8b95bf0b0ee3821bc3245d743fb1337,8a2c034f43ae98cc6a429f91dd1d16fc3fe331c9,1,"void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
{
    String stepString = String::number(m_parameters.step);
    String stepBaseString = String::number(m_parameters.stepBase, 11, WTF::TruncateTrailingZeros);
    IntRect anchorRectInScreen = m_chromeClient->rootViewToScreen(m_parameters.anchorRectInRootView);
    String todayLabelString;
    String otherDateLabelString;
    if (m_parameters.type == InputTypeNames::month) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisMonthButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherMonthLabel);
    } else if (m_parameters.type == InputTypeNames::week) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisWeekButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherWeekLabel);
    } else {
        todayLabelString = locale().queryString(WebLocalizedString::CalendarToday);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherDateLabel);
    }

    addString(""<!DOCTYPE html><head><meta charset='UTF-8'><style>\n"", data);
    data->append(Platform::current()->loadResource(""pickerCommon.css""));
    data->append(Platform::current()->loadResource(""pickerButton.css""));
    data->append(Platform::current()->loadResource(""suggestionPicker.css""));
    data->append(Platform::current()->loadResource(""calendarPicker.css""));
    addString(""</style></head><body><div id=main>Loading...</div><script>\n""
        ""window.dialogArguments = {\n"", data);
    addProperty(""anchorRectInScreen"", anchorRectInScreen, data);
    addProperty(""min"", valueToDateTimeString(m_parameters.minimum, m_parameters.type), data);
    addProperty(""max"", valueToDateTimeString(m_parameters.maximum, m_parameters.type), data);
    addProperty(""step"", stepString, data);
    addProperty(""stepBase"", stepBaseString, data);
    addProperty(""required"", m_parameters.required, data);
    addProperty(""currentValue"", valueToDateTimeString(m_parameters.doubleValue, m_parameters.type), data);
    addProperty(""locale"", m_parameters.locale.string(), data);
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
//fix_flaw_line_below:
//    addProperty(""axShowMonthSelector"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);
//fix_flaw_line_below:
//    addProperty(""axShowNextMonth"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);
//fix_flaw_line_below:
//    addProperty(""axShowPreviousMonth"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);
    addProperty(""isLocaleRTL"", m_locale->isRTL(), data);
    addProperty(""isRTL"", m_parameters.isAnchorElementRTL, data);
    addProperty(""mode"", m_parameters.type.string(), data);
    if (m_parameters.suggestions.size()) {
        Vector<String> suggestionValues;
        Vector<String> localizedSuggestionValues;
        Vector<String> suggestionLabels;
        for (unsigned i = 0; i < m_parameters.suggestions.size(); i++) {
            suggestionValues.append(valueToDateTimeString(m_parameters.suggestions[i].value, m_parameters.type));
            localizedSuggestionValues.append(m_parameters.suggestions[i].localizedValue);
            suggestionLabels.append(m_parameters.suggestions[i].label);
        }
        addProperty(""suggestionValues"", suggestionValues, data);
        addProperty(""localizedSuggestionValues"", localizedSuggestionValues, data);
        addProperty(""suggestionLabels"", suggestionLabels, data);
        addProperty(""inputWidth"", static_cast<unsigned>(m_parameters.anchorRectInRootView.width()), data);
        addProperty(""showOtherDateEntry"", RenderTheme::theme().supportsCalendarPicker(m_parameters.type), data);
        addProperty(""otherDateLabel"", otherDateLabelString, data);
        addProperty(""suggestionHighlightColor"", RenderTheme::theme().activeListBoxSelectionBackgroundColor().serialized(), data);
        addProperty(""suggestionHighlightTextColor"", RenderTheme::theme().activeListBoxSelectionForegroundColor().serialized(), data);
    }
    addString(""}\n"", data);

    data->append(Platform::current()->loadResource(""pickerCommon.js""));
    data->append(Platform::current()->loadResource(""suggestionPicker.js""));
    data->append(Platform::current()->loadResource(""calendarPicker.js""));
    addString(""</script></body>\n"", data);
}
",184888,"void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
{
    String stepString = String::number(m_parameters.step);
    String stepBaseString = String::number(m_parameters.stepBase, 11, WTF::TruncateTrailingZeros);
    IntRect anchorRectInScreen = m_chromeClient->rootViewToScreen(m_parameters.anchorRectInRootView);
    String todayLabelString;
    String otherDateLabelString;
    if (m_parameters.type == InputTypeNames::month) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisMonthButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherMonthLabel);
    } else if (m_parameters.type == InputTypeNames::week) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisWeekButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherWeekLabel);
    } else {
        todayLabelString = locale().queryString(WebLocalizedString::CalendarToday);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherDateLabel);
    }

    addString(""<!DOCTYPE html><head><meta charset='UTF-8'><style>\n"", data);
    data->append(Platform::current()->loadResource(""pickerCommon.css""));
    data->append(Platform::current()->loadResource(""pickerButton.css""));
    data->append(Platform::current()->loadResource(""suggestionPicker.css""));
    data->append(Platform::current()->loadResource(""calendarPicker.css""));
    addString(""</style></head><body><div id=main>Loading...</div><script>\n""
        ""window.dialogArguments = {\n"", data);
    addProperty(""anchorRectInScreen"", anchorRectInScreen, data);
    addProperty(""min"", valueToDateTimeString(m_parameters.minimum, m_parameters.type), data);
    addProperty(""max"", valueToDateTimeString(m_parameters.maximum, m_parameters.type), data);
    addProperty(""step"", stepString, data);
    addProperty(""stepBase"", stepBaseString, data);
    addProperty(""required"", m_parameters.required, data);
    addProperty(""currentValue"", valueToDateTimeString(m_parameters.doubleValue, m_parameters.type), data);
    addProperty(""locale"", m_parameters.locale.string(), data);
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);
    addProperty(""isLocaleRTL"", m_locale->isRTL(), data);
    addProperty(""isRTL"", m_parameters.isAnchorElementRTL, data);
    addProperty(""mode"", m_parameters.type.string(), data);
    if (m_parameters.suggestions.size()) {
        Vector<String> suggestionValues;
        Vector<String> localizedSuggestionValues;
        Vector<String> suggestionLabels;
        for (unsigned i = 0; i < m_parameters.suggestions.size(); i++) {
            suggestionValues.append(valueToDateTimeString(m_parameters.suggestions[i].value, m_parameters.type));
            localizedSuggestionValues.append(m_parameters.suggestions[i].localizedValue);
            suggestionLabels.append(m_parameters.suggestions[i].label);
        }
        addProperty(""suggestionValues"", suggestionValues, data);
        addProperty(""localizedSuggestionValues"", localizedSuggestionValues, data);
        addProperty(""suggestionLabels"", suggestionLabels, data);
        addProperty(""inputWidth"", static_cast<unsigned>(m_parameters.anchorRectInRootView.width()), data);
        addProperty(""showOtherDateEntry"", RenderTheme::theme().supportsCalendarPicker(m_parameters.type), data);
        addProperty(""otherDateLabel"", otherDateLabelString, data);
        addProperty(""suggestionHighlightColor"", RenderTheme::theme().activeListBoxSelectionBackgroundColor().serialized(), data);
        addProperty(""suggestionHighlightTextColor"", RenderTheme::theme().activeListBoxSelectionForegroundColor().serialized(), data);
    }
    addString(""}\n"", data);

    data->append(Platform::current()->loadResource(""pickerCommon.js""));
    data->append(Platform::current()->loadResource(""suggestionPicker.js""));
    data->append(Platform::current()->loadResource(""calendarPicker.js""));
    addString(""</script></body>\n"", data);
}
","void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
{
    String stepString = String::number(m_parameters.step);
    String stepBaseString = String::number(m_parameters.stepBase, 11, WTF::TruncateTrailingZeros);
    IntRect anchorRectInScreen = m_chromeClient->rootViewToScreen(m_parameters.anchorRectInRootView);
    String todayLabelString;
    String otherDateLabelString;
    if (m_parameters.type == InputTypeNames::month) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisMonthButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherMonthLabel);
    } else if (m_parameters.type == InputTypeNames::week) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisWeekButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherWeekLabel);
    } else {
        todayLabelString = locale().queryString(WebLocalizedString::CalendarToday);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherDateLabel);
    }

    addString(""<!DOCTYPE html><head><meta charset='UTF-8'><style>\n"", data);
    data->append(Platform::current()->loadResource(""pickerCommon.css""));
    data->append(Platform::current()->loadResource(""pickerButton.css""));
    data->append(Platform::current()->loadResource(""suggestionPicker.css""));
    data->append(Platform::current()->loadResource(""calendarPicker.css""));
    addString(""</style></head><body><div id=main>Loading...</div><script>\n""
        ""window.dialogArguments = {\n"", data);
    addProperty(""anchorRectInScreen"", anchorRectInScreen, data);
    addProperty(""min"", valueToDateTimeString(m_parameters.minimum, m_parameters.type), data);
    addProperty(""max"", valueToDateTimeString(m_parameters.maximum, m_parameters.type), data);
    addProperty(""step"", stepString, data);
    addProperty(""stepBase"", stepBaseString, data);
    addProperty(""required"", m_parameters.required, data);
    addProperty(""currentValue"", valueToDateTimeString(m_parameters.doubleValue, m_parameters.type), data);
    addProperty(""locale"", m_parameters.locale.string(), data);
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
    addProperty(""axShowMonthSelector"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);
    addProperty(""axShowNextMonth"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);
    addProperty(""axShowPreviousMonth"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);
    addProperty(""isLocaleRTL"", m_locale->isRTL(), data);
    addProperty(""isRTL"", m_parameters.isAnchorElementRTL, data);
    addProperty(""mode"", m_parameters.type.string(), data);
    if (m_parameters.suggestions.size()) {
        Vector<String> suggestionValues;
        Vector<String> localizedSuggestionValues;
        Vector<String> suggestionLabels;
        for (unsigned i = 0; i < m_parameters.suggestions.size(); i++) {
            suggestionValues.append(valueToDateTimeString(m_parameters.suggestions[i].value, m_parameters.type));
            localizedSuggestionValues.append(m_parameters.suggestions[i].localizedValue);
            suggestionLabels.append(m_parameters.suggestions[i].label);
        }
        addProperty(""suggestionValues"", suggestionValues, data);
        addProperty(""localizedSuggestionValues"", localizedSuggestionValues, data);
        addProperty(""suggestionLabels"", suggestionLabels, data);
        addProperty(""inputWidth"", static_cast<unsigned>(m_parameters.anchorRectInRootView.width()), data);
        addProperty(""showOtherDateEntry"", RenderTheme::theme().supportsCalendarPicker(m_parameters.type), data);
        addProperty(""otherDateLabel"", otherDateLabelString, data);
        addProperty(""suggestionHighlightColor"", RenderTheme::theme().activeListBoxSelectionBackgroundColor().serialized(), data);
        addProperty(""suggestionHighlightTextColor"", RenderTheme::theme().activeListBoxSelectionForegroundColor().serialized(), data);
    }
    addString(""}\n"", data);

    data->append(Platform::current()->loadResource(""pickerCommon.js""));
    data->append(Platform::current()->loadResource(""suggestionPicker.js""));
    data->append(Platform::current()->loadResource(""calendarPicker.js""));
    addString(""</script></body>\n"", data);
}
","The `writeDocument` function in the `DateTimeChooserImpl` class generates an HTML document for a date and time picker interface. It begins by defining various parameters such as step values and screen coordinates, and retrieves localized labels based on the input type (month, week, or date). The function constructs the HTML structure, including styles and scripts, and populates it with properties like minimum and maximum values, current value, locale settings, and suggestions if available. Finally, it appends necessary JavaScript resources to enable interactive functionality, ensuring the picker is tailored to user preferences and locale.","The provided code generates an HTML document for a date and time picker interface, customizing it based on user-defined parameters. It retrieves localized labels for different input types and constructs the document's structure, including styles and scripts. The code populates the document with essential properties such as value ranges, current selections, and locale settings. If suggestions are available, it incorporates them along with their localized versions. Finally, it appends necessary JavaScript resources to ensure the picker functions interactively, adapting to user preferences and locale-specific requirements for a seamless experience.","The vulnerability identified as CWE-22, which pertains to improper handling of file paths, can arise when user input is not adequately validated, allowing for potential directory traversal attacks. In the vulnerable code, the function constructs an HTML document that may include user-defined parameters without sufficient sanitization. The fixed code addresses this by ensuring that all properties, such as the minimum and maximum date values, are properly validated and formatted before being added to the document. This prevents malicious input from manipulating file paths or accessing unauthorized resources, thereby enhancing the security of the date and time picker interface.","The vulnerability identified as CWE-22 involves improper validation of user input, which can lead to directory traversal attacks, allowing unauthorized access to files and directories. In the vulnerable code, user-defined parameters were incorporated into the generated HTML document without sufficient sanitization, potentially enabling malicious users to manipulate file paths. The fixed code addresses this issue by implementing rigorous validation and formatting of all user inputs before they are included in the document. This ensures that only safe and expected values are processed, thereby mitigating the risk of unauthorized file access and enhancing overall security.","The vulnerability was fixed by enhancing the validation and sanitization of user inputs before they are incorporated into the HTML document. Specifically, the code now ensures that properties such as minimum and maximum values are processed through the `valueToDateTimeString` function, which formats them appropriately, reducing the risk of malicious input. Additionally, the inclusion of localized labels and suggestions is carefully managed, ensuring that only safe, validated data is added through the `addProperty` function. This comprehensive approach prevents unauthorized file access and ensures that the generated document adheres to security best practices.","The vulnerability was fixed by implementing stricter validation and sanitization of user inputs before they are included in the generated HTML document. This involved ensuring that all user-defined parameters are properly formatted and checked for safety, thereby preventing any potentially malicious data from being processed. The code now carefully manages the inclusion of localized labels and suggestions, ensuring that only validated and expected values are added. This comprehensive approach significantly reduces the risk of unauthorized access to files and directories, thereby enhancing the overall security of the application."
7,185107,185107,,Remote,Not required,Partial,CVE-2013-0895,https://www.cvedetails.com/cve/CVE-2013-0895/,CWE-22,Low,Partial,Partial,,2013-02-23,7.5,"Google Chrome before 25.0.1364.97 on Linux, and before 25.0.1364.99 on Mac OS X, does not properly handle pathnames during copy operations, which might make it easier for remote attackers to execute arbitrary programs via unspecified vectors.",2013-09-30,Dir. Trav. ,8,https://github.com/chromium/chromium/commit/23803a58e481e464a787e4b2c461af9e62f03905,23803a58e481e464a787e4b2c461af9e62f03905,"Fix creating target paths in file_util_posix CopyDirectory.

BUG=167840


Review URL: https://chromiumcodereview.appspot.com/11773018

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@176659 0039d316-1c4b-4281-b951-d872f2087c98",5,base/file_util_posix.cc,"{""sha"": ""95ffb42f7dd5a7d66812b84292c84f9cc2dcf35f"", ""filename"": ""base/file_util_posix.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/23803a58e481e464a787e4b2c461af9e62f03905/base/file_util_posix.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/23803a58e481e464a787e4b2c461af9e62f03905/base/file_util_posix.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/file_util_posix.cc?ref=23803a58e481e464a787e4b2c461af9e62f03905"", ""patch"": ""@@ -343,15 +343,15 @@ bool CopyDirectory(const FilePath& from_path,\n   DCHECK(recursive || S_ISDIR(info.stat.st_mode));\n \n   while (success && !current.empty()) {\n-    // current is the source path, including from_path, so paste\n-    // the suffix after from_path onto to_path to create the target_path.\n-    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);\n-    // Strip the leading '/' (if any).\n-    if (!suffix.empty()) {\n-      DCHECK_EQ('/', suffix[0]);\n-      suffix.erase(0, 1);\n+    // current is the source path, including from_path, so append\n+    // the suffix after from_path to to_path to create the target_path.\n+    FilePath target_path(to_path);\n+    if (from_path_base != current) {\n+      if (!from_path_base.AppendRelativePath(current, &target_path)) {\n+        success = false;\n+        break;\n+      }\n     }\n-    const FilePath target_path = to_path.Append(suffix);\n \n     if (S_ISDIR(info.stat.st_mode)) {\n       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&""}<_**next**_>{""sha"": ""c1006e1304c205c52a7e58b38e9d7e8ade80e60d"", ""filename"": ""base/file_util_unittest.cc"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 0, ""changes"": 37, ""blob_url"": ""https://github.com/chromium/chromium/blob/23803a58e481e464a787e4b2c461af9e62f03905/base/file_util_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/23803a58e481e464a787e4b2c461af9e62f03905/base/file_util_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/file_util_unittest.cc?ref=23803a58e481e464a787e4b2c461af9e62f03905"", ""patch"": ""@@ -1466,6 +1466,43 @@ TEST_F(FileUtilTest, CopyFileWithCopyDirectoryRecursiveToExistingDirectory) {\n   EXPECT_TRUE(file_util::PathExists(file_name_to));\n }\n \n+TEST_F(FileUtilTest, CopyDirectoryWithTrailingSeparators) {\n+  // Create a directory.\n+  FilePath dir_name_from =\n+      temp_dir_.path().Append(FILE_PATH_LITERAL(\""Copy_From_Subdir\""));\n+  file_util::CreateDirectory(dir_name_from);\n+  ASSERT_TRUE(file_util::PathExists(dir_name_from));\n+\n+  // Create a file under the directory.\n+  FilePath file_name_from =\n+      dir_name_from.Append(FILE_PATH_LITERAL(\""Copy_Test_File.txt\""));\n+  CreateTextFile(file_name_from, L\""Gooooooooooooooooooooogle\"");\n+  ASSERT_TRUE(file_util::PathExists(file_name_from));\n+\n+  // Copy the directory recursively.\n+  FilePath dir_name_to =\n+      temp_dir_.path().Append(FILE_PATH_LITERAL(\""Destination\""));\n+  FilePath file_name_to =\n+      dir_name_to.Append(FILE_PATH_LITERAL(\""Copy_Test_File.txt\""));\n+\n+  // Create from path with trailing separators.\n+#if defined(OS_WIN)\n+  FilePath from_path =\n+      temp_dir_.path().Append(FILE_PATH_LITERAL(\""Copy_From_Subdir\\\\\\\\\\\\\""));\n+#elif defined(OS_POSIX)\n+  FilePath from_path =\n+      temp_dir_.path().Append(FILE_PATH_LITERAL(\""Copy_From_Subdir///\""));\n+#endif\n+\n+  EXPECT_TRUE(file_util::CopyDirectory(from_path, dir_name_to, true));\n+\n+  // Check everything has been copied.\n+  EXPECT_TRUE(file_util::PathExists(dir_name_from));\n+  EXPECT_TRUE(file_util::PathExists(file_name_from));\n+  EXPECT_TRUE(file_util::PathExists(dir_name_to));\n+  EXPECT_TRUE(file_util::PathExists(file_name_to));\n+}\n+\n TEST_F(FileUtilTest, CopyFile) {\n   // Create a directory\n   FilePath dir_name_from =""}","bool CopyDirectory(const FilePath& from_path,
                   const FilePath& to_path,
                   bool recursive) {
  base::ThreadRestrictions::AssertIOAllowed();
  DCHECK(to_path.value().find('*') == std::string::npos);
  DCHECK(from_path.value().find('*') == std::string::npos);

  char top_dir[PATH_MAX];
  if (base::strlcpy(top_dir, from_path.value().c_str(),
                    arraysize(top_dir)) >= arraysize(top_dir)) {
    return false;
  }

  FilePath real_to_path = to_path;
  if (PathExists(real_to_path)) {
    if (!AbsolutePath(&real_to_path))
      return false;
  } else {
    real_to_path = real_to_path.DirName();
    if (!AbsolutePath(&real_to_path))
      return false;
  }
  FilePath real_from_path = from_path;
  if (!AbsolutePath(&real_from_path))
    return false;
  if (real_to_path.value().size() >= real_from_path.value().size() &&
      real_to_path.value().compare(0, real_from_path.value().size(),
      real_from_path.value()) == 0)
    return false;

  bool success = true;
  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;
  if (recursive)
    traverse_type |= FileEnumerator::DIRECTORIES;
  FileEnumerator traversal(from_path, recursive, traverse_type);

  FileEnumerator::FindInfo info;
  FilePath current = from_path;
  if (stat(from_path.value().c_str(), &info.stat) < 0) {
    DLOG(ERROR) << ""CopyDirectory() couldn't stat source directory: ""
                << from_path.value() << "" errno = "" << errno;
    success = false;
  }
  struct stat to_path_stat;
  FilePath from_path_base = from_path;
  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&
      S_ISDIR(to_path_stat.st_mode)) {
    from_path_base = from_path.DirName();
  }

   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
    // current is the source path, including from_path, so append
    // the suffix after from_path to to_path to create the target_path.
    FilePath target_path(to_path);
    if (from_path_base != current) {
      if (!from_path_base.AppendRelativePath(current, &target_path)) {
        success = false;
        break;
      }
     }
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&
          errno != EEXIST) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create directory: ""
                    << target_path.value() << "" errno = "" << errno;
        success = false;
      }
    } else if (S_ISREG(info.stat.st_mode)) {
      if (!CopyFile(current, target_path)) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create file: ""
                    << target_path.value();
        success = false;
      }
    } else {
      DLOG(WARNING) << ""CopyDirectory() skipping non-regular file: ""
                    << current.value();
    }

    current = traversal.Next();
    traversal.GetFindInfo(&info);
  }

  return success;
}
","bool CopyDirectory(const FilePath& from_path,
                   const FilePath& to_path,
                   bool recursive) {
  base::ThreadRestrictions::AssertIOAllowed();
  DCHECK(to_path.value().find('*') == std::string::npos);
  DCHECK(from_path.value().find('*') == std::string::npos);

  char top_dir[PATH_MAX];
  if (base::strlcpy(top_dir, from_path.value().c_str(),
                    arraysize(top_dir)) >= arraysize(top_dir)) {
    return false;
  }

  FilePath real_to_path = to_path;
  if (PathExists(real_to_path)) {
    if (!AbsolutePath(&real_to_path))
      return false;
  } else {
    real_to_path = real_to_path.DirName();
    if (!AbsolutePath(&real_to_path))
      return false;
  }
  FilePath real_from_path = from_path;
  if (!AbsolutePath(&real_from_path))
    return false;
  if (real_to_path.value().size() >= real_from_path.value().size() &&
      real_to_path.value().compare(0, real_from_path.value().size(),
      real_from_path.value()) == 0)
    return false;

  bool success = true;
  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;
  if (recursive)
    traverse_type |= FileEnumerator::DIRECTORIES;
  FileEnumerator traversal(from_path, recursive, traverse_type);

  FileEnumerator::FindInfo info;
  FilePath current = from_path;
  if (stat(from_path.value().c_str(), &info.stat) < 0) {
    DLOG(ERROR) << ""CopyDirectory() couldn't stat source directory: ""
                << from_path.value() << "" errno = "" << errno;
    success = false;
  }
  struct stat to_path_stat;
  FilePath from_path_base = from_path;
  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&
      S_ISDIR(to_path_stat.st_mode)) {
    from_path_base = from_path.DirName();
  }

   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
    if (!suffix.empty()) {
      DCHECK_EQ('/', suffix[0]);
      suffix.erase(0, 1);
     }
    const FilePath target_path = to_path.Append(suffix);
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&
          errno != EEXIST) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create directory: ""
                    << target_path.value() << "" errno = "" << errno;
        success = false;
      }
    } else if (S_ISREG(info.stat.st_mode)) {
      if (!CopyFile(current, target_path)) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create file: ""
                    << target_path.value();
        success = false;
      }
    } else {
      DLOG(WARNING) << ""CopyDirectory() skipping non-regular file: ""
                    << current.value();
    }

    current = traversal.Next();
    traversal.GetFindInfo(&info);
  }

  return success;
}
",C,"    // current is the source path, including from_path, so append
    // the suffix after from_path to to_path to create the target_path.
    FilePath target_path(to_path);
    if (from_path_base != current) {
      if (!from_path_base.AppendRelativePath(current, &target_path)) {
        success = false;
        break;
      }
","    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
    if (!suffix.empty()) {
      DCHECK_EQ('/', suffix[0]);
      suffix.erase(0, 1);
    const FilePath target_path = to_path.Append(suffix);
",,"@@ -343,15 +343,15 @@ bool CopyDirectory(const FilePath& from_path,
   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
-    // current is the source path, including from_path, so paste
-    // the suffix after from_path onto to_path to create the target_path.
-    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
-    // Strip the leading '/' (if any).
-    if (!suffix.empty()) {
-      DCHECK_EQ('/', suffix[0]);
-      suffix.erase(0, 1);
+    // current is the source path, including from_path, so append
+    // the suffix after from_path to to_path to create the target_path.
+    FilePath target_path(to_path);
+    if (from_path_base != current) {
+      if (!from_path_base.AppendRelativePath(current, &target_path)) {
+        success = false;
+        break;
+      }
     }
-    const FilePath target_path = to_path.Append(suffix);
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&",Chrome,23803a58e481e464a787e4b2c461af9e62f03905,0297467c47dfe10b7b3495f57b2e1515cfcec55d,1,"bool CopyDirectory(const FilePath& from_path,
                   const FilePath& to_path,
                   bool recursive) {
  base::ThreadRestrictions::AssertIOAllowed();
  // Some old callers of CopyDirectory want it to support wildcards.
  // After some discussion, we decided to fix those callers.
  // Break loudly here if anyone tries to do this.
  // TODO(evanm): remove this once we're sure it's ok.
  DCHECK(to_path.value().find('*') == std::string::npos);
  DCHECK(from_path.value().find('*') == std::string::npos);

  char top_dir[PATH_MAX];
  if (base::strlcpy(top_dir, from_path.value().c_str(),
                    arraysize(top_dir)) >= arraysize(top_dir)) {
    return false;
  }

  // This function does not properly handle destinations within the source
  FilePath real_to_path = to_path;
  if (PathExists(real_to_path)) {
    if (!AbsolutePath(&real_to_path))
      return false;
  } else {
    real_to_path = real_to_path.DirName();
    if (!AbsolutePath(&real_to_path))
      return false;
  }
  FilePath real_from_path = from_path;
  if (!AbsolutePath(&real_from_path))
    return false;
  if (real_to_path.value().size() >= real_from_path.value().size() &&
      real_to_path.value().compare(0, real_from_path.value().size(),
      real_from_path.value()) == 0)
    return false;

  bool success = true;
  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;
  if (recursive)
    traverse_type |= FileEnumerator::DIRECTORIES;
  FileEnumerator traversal(from_path, recursive, traverse_type);

  // We have to mimic windows behavior here. |to_path| may not exist yet,
  // start the loop with |to_path|.
  FileEnumerator::FindInfo info;
  FilePath current = from_path;
  if (stat(from_path.value().c_str(), &info.stat) < 0) {
    DLOG(ERROR) << ""CopyDirectory() couldn't stat source directory: ""
                << from_path.value() << "" errno = "" << errno;
    success = false;
  }
  struct stat to_path_stat;
  FilePath from_path_base = from_path;
  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&
      S_ISDIR(to_path_stat.st_mode)) {
    // If the destination already exists and is a directory, then the
    // top level of source needs to be copied.
    from_path_base = from_path.DirName();
  }

  // The Windows version of this function assumes that non-recursive calls
  // will always have a directory for from_path.
   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
//flaw_line_below:
    // current is the source path, including from_path, so paste
//flaw_line_below:
    // the suffix after from_path onto to_path to create the target_path.
//flaw_line_below:
    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
//flaw_line_below:
    // Strip the leading '/' (if any).
//flaw_line_below:
    if (!suffix.empty()) {
//flaw_line_below:
      DCHECK_EQ('/', suffix[0]);
//flaw_line_below:
      suffix.erase(0, 1);
//fix_flaw_line_below:
//    // current is the source path, including from_path, so append
//fix_flaw_line_below:
//    // the suffix after from_path to to_path to create the target_path.
//fix_flaw_line_below:
//    FilePath target_path(to_path);
//fix_flaw_line_below:
//    if (from_path_base != current) {
//fix_flaw_line_below:
//      if (!from_path_base.AppendRelativePath(current, &target_path)) {
//fix_flaw_line_below:
//        success = false;
//fix_flaw_line_below:
//        break;
//fix_flaw_line_below:
//      }
     }
//flaw_line_below:
    const FilePath target_path = to_path.Append(suffix);
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&
          errno != EEXIST) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create directory: ""
                    << target_path.value() << "" errno = "" << errno;
        success = false;
      }
    } else if (S_ISREG(info.stat.st_mode)) {
      if (!CopyFile(current, target_path)) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create file: ""
                    << target_path.value();
        success = false;
      }
    } else {
      DLOG(WARNING) << ""CopyDirectory() skipping non-regular file: ""
                    << current.value();
    }

    current = traversal.Next();
    traversal.GetFindInfo(&info);
  }

  return success;
}
",185107,"bool CopyDirectory(const FilePath& from_path,
                   const FilePath& to_path,
                   bool recursive) {
  base::ThreadRestrictions::AssertIOAllowed();
  DCHECK(to_path.value().find('*') == std::string::npos);
  DCHECK(from_path.value().find('*') == std::string::npos);

  char top_dir[PATH_MAX];
  if (base::strlcpy(top_dir, from_path.value().c_str(),
                    arraysize(top_dir)) >= arraysize(top_dir)) {
    return false;
  }

  FilePath real_to_path = to_path;
  if (PathExists(real_to_path)) {
    if (!AbsolutePath(&real_to_path))
      return false;
  } else {
    real_to_path = real_to_path.DirName();
    if (!AbsolutePath(&real_to_path))
      return false;
  }
  FilePath real_from_path = from_path;
  if (!AbsolutePath(&real_from_path))
    return false;
  if (real_to_path.value().size() >= real_from_path.value().size() &&
      real_to_path.value().compare(0, real_from_path.value().size(),
      real_from_path.value()) == 0)
    return false;

  bool success = true;
  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;
  if (recursive)
    traverse_type |= FileEnumerator::DIRECTORIES;
  FileEnumerator traversal(from_path, recursive, traverse_type);

  FileEnumerator::FindInfo info;
  FilePath current = from_path;
  if (stat(from_path.value().c_str(), &info.stat) < 0) {
    DLOG(ERROR) << ""CopyDirectory() couldn't stat source directory: ""
                << from_path.value() << "" errno = "" << errno;
    success = false;
  }
  struct stat to_path_stat;
  FilePath from_path_base = from_path;
  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&
      S_ISDIR(to_path_stat.st_mode)) {
    from_path_base = from_path.DirName();
  }

   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
    if (!suffix.empty()) {
      DCHECK_EQ('/', suffix[0]);
      suffix.erase(0, 1);
     }
    const FilePath target_path = to_path.Append(suffix);
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&
          errno != EEXIST) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create directory: ""
                    << target_path.value() << "" errno = "" << errno;
        success = false;
      }
    } else if (S_ISREG(info.stat.st_mode)) {
      if (!CopyFile(current, target_path)) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create file: ""
                    << target_path.value();
        success = false;
      }
    } else {
      DLOG(WARNING) << ""CopyDirectory() skipping non-regular file: ""
                    << current.value();
    }

    current = traversal.Next();
    traversal.GetFindInfo(&info);
  }

  return success;
}
","bool CopyDirectory(const FilePath& from_path,
                   const FilePath& to_path,
                   bool recursive) {
  base::ThreadRestrictions::AssertIOAllowed();
  DCHECK(to_path.value().find('*') == std::string::npos);
  DCHECK(from_path.value().find('*') == std::string::npos);

  char top_dir[PATH_MAX];
  if (base::strlcpy(top_dir, from_path.value().c_str(),
                    arraysize(top_dir)) >= arraysize(top_dir)) {
    return false;
  }

  FilePath real_to_path = to_path;
  if (PathExists(real_to_path)) {
    if (!AbsolutePath(&real_to_path))
      return false;
  } else {
    real_to_path = real_to_path.DirName();
    if (!AbsolutePath(&real_to_path))
      return false;
  }
  FilePath real_from_path = from_path;
  if (!AbsolutePath(&real_from_path))
    return false;
  if (real_to_path.value().size() >= real_from_path.value().size() &&
      real_to_path.value().compare(0, real_from_path.value().size(),
      real_from_path.value()) == 0)
    return false;

  bool success = true;
  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;
  if (recursive)
    traverse_type |= FileEnumerator::DIRECTORIES;
  FileEnumerator traversal(from_path, recursive, traverse_type);

  FileEnumerator::FindInfo info;
  FilePath current = from_path;
  if (stat(from_path.value().c_str(), &info.stat) < 0) {
    DLOG(ERROR) << ""CopyDirectory() couldn't stat source directory: ""
                << from_path.value() << "" errno = "" << errno;
    success = false;
  }
  struct stat to_path_stat;
  FilePath from_path_base = from_path;
  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&
      S_ISDIR(to_path_stat.st_mode)) {
    from_path_base = from_path.DirName();
  }

   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
    // current is the source path, including from_path, so append
    // the suffix after from_path to to_path to create the target_path.
    FilePath target_path(to_path);
    if (from_path_base != current) {
      if (!from_path_base.AppendRelativePath(current, &target_path)) {
        success = false;
        break;
      }
     }
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&
          errno != EEXIST) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create directory: ""
                    << target_path.value() << "" errno = "" << errno;
        success = false;
      }
    } else if (S_ISREG(info.stat.st_mode)) {
      if (!CopyFile(current, target_path)) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create file: ""
                    << target_path.value();
        success = false;
      }
    } else {
      DLOG(WARNING) << ""CopyDirectory() skipping non-regular file: ""
                    << current.value();
    }

    current = traversal.Next();
    traversal.GetFindInfo(&info);
  }

  return success;
}
","The `CopyDirectory` function facilitates the copying of a directory's contents from a specified source path (`from_path`) to a destination path (`to_path`), with an option for recursive copying of subdirectories and files. It first checks for valid paths and ensures that the destination does not overlap with the source. The function utilizes a `FileEnumerator` to traverse the source directory, creating directories and copying files while preserving their attributes. It handles errors gracefully, logging issues encountered during the process, and returns a boolean indicating the overall success of the operation.","The provided code defines a function that copies the contents of one directory to another, with an option to include subdirectories and files recursively. It begins by validating the source and destination paths to ensure they are absolute and do not overlap. The function then traverses the source directory, creating corresponding directories and copying files while preserving their attributes. It handles potential errors during the process, logging any issues encountered, and ultimately returns a boolean value indicating whether the copying operation was successful or not.","The vulnerability in the original code, identified as CWE-22 (Improper Limitation of a Pathname to a Restricted Directory), arises from the lack of checks to prevent directory traversal attacks. Specifically, the code did not adequately validate the destination path, allowing an attacker to manipulate the input paths to write files outside the intended directory. The fixed code addresses this by ensuring that the destination path does not overlap with the source path through a comparison of the lengths and values of `real_to_path` and `real_from_path`. This prevents unauthorized access to sensitive directories by enforcing strict path validation.","The vulnerability identified as CWE-22 (Improper Limitation of a Pathname to a Restricted Directory) in the original code allowed for directory traversal attacks, where an attacker could manipulate input paths to write files outside the intended directory. This occurred due to insufficient validation of the destination path, which could lead to unauthorized access to sensitive areas of the file system. The fixed code mitigates this risk by implementing checks that ensure the destination path does not overlap with the source path, thereby enforcing strict path validation and preventing potential exploitation through directory traversal.","The vulnerability was fixed by adding checks to ensure that the destination path does not overlap with the source path. Specifically, the code compares the lengths and values of `real_to_path` and `real_from_path` to confirm that the destination is not a subdirectory of the source. If the destination path's size is greater than or equal to the source path's size and starts with the same value, the operation is aborted. This validation prevents unauthorized access and directory traversal attacks, ensuring that files are only copied within the intended directory structure.","The vulnerability was fixed by implementing additional checks to ensure that the destination path does not overlap with the source path, thereby preventing directory traversal attacks. The code now verifies that the destination path is not a subdirectory of the source path by comparing their lengths and values. If the destination path is found to be invalid, the operation is aborted, ensuring that files can only be copied within the intended directory structure. This enhancement effectively restricts unauthorized access to sensitive areas of the file system, thereby improving overall security."
