,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic
0,182309,182309,,Remote,Not required,Partial,CVE-2018-14354,https://www.cvedetails.com/cve/CVE-2018-14354/,CWE-77,Low,Partial,Partial,,2018-07-17,7.5,"An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with a manual subscription or unsubscription.",2019-10-02,Exec Code ,3,https://github.com/neomutt/neomutt/commit/95e80bf9ff10f68cb6443f760b85df4117cb15eb,95e80bf9ff10f68cb6443f760b85df4117cb15eb,Quote path in imap_subscribe,1,imap/imap.c,"{""sha"": ""f1706885620c7afd61bdc5bd03593557980bd0ab"", ""filename"": ""imap/imap.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/95e80bf9ff10f68cb6443f760b85df4117cb15eb/imap/imap.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/95e80bf9ff10f68cb6443f760b85df4117cb15eb/imap/imap.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/imap.c?ref=95e80bf9ff10f68cb6443f760b85df4117cb15eb"", ""patch"": ""@@ -1709,6 +1709,7 @@ int imap_subscribe(char *path, bool subscribe)\n   char errstr[STRING];\n   struct Buffer err, token;\n   struct ImapMbox mx;\n+  size_t len = 0;\n \n   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)\n   {\n@@ -1729,7 +1730,8 @@ int imap_subscribe(char *path, bool subscribe)\n     mutt_buffer_init(&err);\n     err.data = errstr;\n     err.dsize = sizeof(errstr);\n-    snprintf(mbox, sizeof(mbox), \""%smailboxes \\\""%s\\\""\"", subscribe ? \""\"" : \""un\"", path);\n+\tlen = snprintf(mbox, sizeof(mbox), \""%smailboxes \"", subscribe ? \""\"" : \""un\"");\n+\timap_quote_string(mbox + len, sizeof(mbox) - len, path, true);\n     if (mutt_parse_rc_line(mbox, &token, &err))\n       mutt_debug(1, \""Error adding subscribed mailbox: %s\\n\"", errstr);\n     FREE(&token.data);""}","int imap_subscribe(char *path, bool subscribe)
{
  struct ImapData *idata = NULL;
  char buf[LONG_STRING];
  char mbox[LONG_STRING];
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
  size_t len = 0;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
    mutt_error(_(""Bad mailbox name""));
    return -1;
  }
  idata = imap_conn_find(&(mx.account), 0);
  if (!idata)
    goto fail;

  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));
  if (!*buf)
    mutt_str_strfcpy(buf, ""INBOX"", sizeof(buf));

  if (ImapCheckSubscribed)
  {
    mutt_buffer_init(&token);
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
	len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un"");
	imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);
  }

  if (subscribe)
    mutt_message(_(""Subscribing to %s...""), buf);
  else
    mutt_message(_(""Unsubscribing from %s...""), buf);
  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);

  snprintf(buf, sizeof(buf), ""%sSUBSCRIBE %s"", subscribe ? """" : ""UN"", mbox);

  if (imap_exec(idata, buf, 0) < 0)
    goto fail;

  imap_unmunge_mbox_name(idata, mx.mbox);
  if (subscribe)
    mutt_message(_(""Subscribed to %s""), mx.mbox);
  else
    mutt_message(_(""Unsubscribed from %s""), mx.mbox);
  FREE(&mx.mbox);
  return 0;

fail:
  FREE(&mx.mbox);
  return -1;
}
","int imap_subscribe(char *path, bool subscribe)
{
  struct ImapData *idata = NULL;
  char buf[LONG_STRING];
  char mbox[LONG_STRING];
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
    mutt_error(_(""Bad mailbox name""));
    return -1;
  }
  idata = imap_conn_find(&(mx.account), 0);
  if (!idata)
    goto fail;

  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));
  if (!*buf)
    mutt_str_strfcpy(buf, ""INBOX"", sizeof(buf));

  if (ImapCheckSubscribed)
  {
    mutt_buffer_init(&token);
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
    snprintf(mbox, sizeof(mbox), ""%smailboxes \""%s\"""", subscribe ? """" : ""un"", path);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);
  }

  if (subscribe)
    mutt_message(_(""Subscribing to %s...""), buf);
  else
    mutt_message(_(""Unsubscribing from %s...""), buf);
  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);

  snprintf(buf, sizeof(buf), ""%sSUBSCRIBE %s"", subscribe ? """" : ""UN"", mbox);

  if (imap_exec(idata, buf, 0) < 0)
    goto fail;

  imap_unmunge_mbox_name(idata, mx.mbox);
  if (subscribe)
    mutt_message(_(""Subscribed to %s""), mx.mbox);
  else
    mutt_message(_(""Unsubscribed from %s""), mx.mbox);
  FREE(&mx.mbox);
  return 0;

fail:
  FREE(&mx.mbox);
  return -1;
}
",C,"  size_t len = 0;
	len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un"");
	imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);
","    snprintf(mbox, sizeof(mbox), ""%smailboxes \""%s\"""", subscribe ? """" : ""un"", path);
",,"@@ -1709,6 +1709,7 @@ int imap_subscribe(char *path, bool subscribe)
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
+  size_t len = 0;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
@@ -1729,7 +1730,8 @@ int imap_subscribe(char *path, bool subscribe)
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
-    snprintf(mbox, sizeof(mbox), ""%smailboxes \""%s\"""", subscribe ? """" : ""un"", path);
+	len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un"");
+	imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);",neomutt,95e80bf9ff10f68cb6443f760b85df4117cb15eb,51c4efb8ccae3dab550fe8909fc76fb2462f0a89,1,"int imap_subscribe(char *path, bool subscribe)
{
  struct ImapData *idata = NULL;
  char buf[LONG_STRING];
  char mbox[LONG_STRING];
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
//fix_flaw_line_below:
//  size_t len = 0;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
    mutt_error(_(""Bad mailbox name""));
    return -1;
  }
  idata = imap_conn_find(&(mx.account), 0);
  if (!idata)
    goto fail;

  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));
  if (!*buf)
    mutt_str_strfcpy(buf, ""INBOX"", sizeof(buf));

  if (ImapCheckSubscribed)
  {
    mutt_buffer_init(&token);
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
//flaw_line_below:
    snprintf(mbox, sizeof(mbox), ""%smailboxes \""%s\"""", subscribe ? """" : ""un"", path);
//fix_flaw_line_below:
//	len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un"");
//fix_flaw_line_below:
//	imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);
  }

  if (subscribe)
    mutt_message(_(""Subscribing to %s...""), buf);
  else
    mutt_message(_(""Unsubscribing from %s...""), buf);
  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);

  snprintf(buf, sizeof(buf), ""%sSUBSCRIBE %s"", subscribe ? """" : ""UN"", mbox);

  if (imap_exec(idata, buf, 0) < 0)
    goto fail;

  imap_unmunge_mbox_name(idata, mx.mbox);
  if (subscribe)
    mutt_message(_(""Subscribed to %s""), mx.mbox);
  else
    mutt_message(_(""Unsubscribed from %s""), mx.mbox);
  FREE(&mx.mbox);
  return 0;

fail:
  FREE(&mx.mbox);
  return -1;
}
",182309,"int imap_subscribe(char *path, bool subscribe)
{
  struct ImapData *idata = NULL;
  char buf[LONG_STRING];
  char mbox[LONG_STRING];
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
    mutt_error(_(""Bad mailbox name""));
    return -1;
  }
  idata = imap_conn_find(&(mx.account), 0);
  if (!idata)
    goto fail;

  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));
  if (!*buf)
    mutt_str_strfcpy(buf, ""INBOX"", sizeof(buf));

  if (ImapCheckSubscribed)
  {
    mutt_buffer_init(&token);
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
    snprintf(mbox, sizeof(mbox), ""%smailboxes \""%s\"""", subscribe ? """" : ""un"", path);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);
  }

  if (subscribe)
    mutt_message(_(""Subscribing to %s...""), buf);
  else
    mutt_message(_(""Unsubscribing from %s...""), buf);
  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);

  snprintf(buf, sizeof(buf), ""%sSUBSCRIBE %s"", subscribe ? """" : ""UN"", mbox);

  if (imap_exec(idata, buf, 0) < 0)
    goto fail;

  imap_unmunge_mbox_name(idata, mx.mbox);
  if (subscribe)
    mutt_message(_(""Subscribed to %s""), mx.mbox);
  else
    mutt_message(_(""Unsubscribed from %s""), mx.mbox);
  FREE(&mx.mbox);
  return 0;

fail:
  FREE(&mx.mbox);
  return -1;
}
","int imap_subscribe(char *path, bool subscribe)
{
  struct ImapData *idata = NULL;
  char buf[LONG_STRING];
  char mbox[LONG_STRING];
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
  size_t len = 0;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
    mutt_error(_(""Bad mailbox name""));
    return -1;
  }
  idata = imap_conn_find(&(mx.account), 0);
  if (!idata)
    goto fail;

  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));
  if (!*buf)
    mutt_str_strfcpy(buf, ""INBOX"", sizeof(buf));

  if (ImapCheckSubscribed)
  {
    mutt_buffer_init(&token);
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
	len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un"");
	imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);
  }

  if (subscribe)
    mutt_message(_(""Subscribing to %s...""), buf);
  else
    mutt_message(_(""Unsubscribing from %s...""), buf);
  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);

  snprintf(buf, sizeof(buf), ""%sSUBSCRIBE %s"", subscribe ? """" : ""UN"", mbox);

  if (imap_exec(idata, buf, 0) < 0)
    goto fail;

  imap_unmunge_mbox_name(idata, mx.mbox);
  if (subscribe)
    mutt_message(_(""Subscribed to %s""), mx.mbox);
  else
    mutt_message(_(""Unsubscribed from %s""), mx.mbox);
  FREE(&mx.mbox);
  return 0;

fail:
  FREE(&mx.mbox);
  return -1;
}
","The `imap_subscribe` function manages the subscription status of an IMAP mailbox, allowing users to either subscribe to or unsubscribe from a specified mailbox path. It first validates the mailbox path and retrieves the associated IMAP connection data. If the mailbox is valid, it constructs a command string based on the subscription action and executes it via the `imap_exec` function. The function also handles error reporting and user feedback, displaying messages indicating whether the action was successful or if an error occurred. Finally, it cleans up allocated resources before returning a success or failure status.","The code defines a function that manages the subscription status of a mailbox in an email client using the IMAP protocol. It begins by validating the mailbox path and retrieving the necessary connection data. If the mailbox is valid, it constructs a command to either subscribe to or unsubscribe from the mailbox, providing user feedback throughout the process. The function executes the command and handles any errors that may arise, ensuring proper resource management by cleaning up allocated memory before concluding with a success or failure status. Overall, it facilitates user interaction with email subscriptions effectively.","The vulnerability in the original code, identified as CWE-77 (Improper Neutralization of Special Elements used in a Command), arises from the potential for command injection when constructing the mailbox command string. Specifically, the original code directly concatenated the user-provided `path` into the command without sanitization, allowing an attacker to manipulate the command. The fix introduces a new function that safely quotes the `path` before appending it to the command string, ensuring that any special characters are properly escaped. This change mitigates the risk of command injection by preventing malicious input from altering the intended command execution.","The vulnerability in the original code, classified as CWE-77 (Improper Neutralization of Special Elements used in a Command), stems from the direct inclusion of user input into a command string without adequate sanitization. This oversight allows an attacker to inject malicious commands by manipulating the input, potentially leading to unauthorized actions on the server. The fix addresses this issue by implementing a mechanism that properly escapes special characters in the user input before it is concatenated into the command string. This enhancement effectively neutralizes the risk of command injection, ensuring that user input cannot alter the intended command execution.","The vulnerability was fixed by introducing a new function that safely quotes the user-provided input before it is included in the command string. Specifically, the code now uses `imap_quote_string` to sanitize the `path` variable, ensuring that any special characters are properly escaped. This occurs after constructing the initial part of the command string in the `mbox` variable, preventing any malicious input from being executed as part of the command. By implementing this sanitization step, the code effectively mitigates the risk of command injection, enhancing the overall security of the mailbox subscription functionality.","The vulnerability was addressed by incorporating a sanitization step that ensures user input is properly escaped before being included in the command string. This fix involves a new mechanism that quotes the user-provided input, preventing any special characters from being interpreted as part of the command. By doing so, the code effectively neutralizes the risk of command injection, ensuring that malicious input cannot alter the intended command execution. This enhancement significantly improves the security of the application by safeguarding against unauthorized actions that could arise from improperly handled user input."
1,182848,182848,,Local,Not required,,CVE-2019-11884,https://www.cvedetails.com/cve/CVE-2019-11884/,CWE-77,Low,Partial,,,2019-05-10,2.1,"The do_hidp_sock_ioctl function in net/bluetooth/hidp/sock.c in the Linux kernel before 5.0.15 allows a local user to obtain potentially sensitive information from kernel stack memory via a HIDPCONNADD command, because a name field may not end with a '0' character.",2019-05-31,+Info ,1,https://github.com/torvalds/linux/commit/a1616a5ac99ede5d605047a9012481ce7ff18b16,a1616a5ac99ede5d605047a9012481ce7ff18b16,"Bluetooth: hidp: fix buffer overflow

Struct ca is copied from userspace. It is not checked whether the ""name""
field is NULL terminated, which allows local users to obtain potentially
sensitive information from kernel stack memory, via a HIDPCONNADD command.

This vulnerability is similar to CVE-2011-1079.

Signed-off-by: Young Xiao <YangX92@hotmail.com>
Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
Cc: stable@vger.kernel.org",0,net/bluetooth/hidp/sock.c,"{""sha"": ""2151913892ce8705d093a96fa65c3888e8a6dbb1"", ""filename"": ""net/bluetooth/hidp/sock.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/a1616a5ac99ede5d605047a9012481ce7ff18b16/net/bluetooth/hidp/sock.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a1616a5ac99ede5d605047a9012481ce7ff18b16/net/bluetooth/hidp/sock.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/bluetooth/hidp/sock.c?ref=a1616a5ac99ede5d605047a9012481ce7ff18b16"", ""patch"": ""@@ -75,6 +75,7 @@ static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user\n \t\t\tsockfd_put(csock);\n \t\t\treturn err;\n \t\t}\n+\t\tca.name[sizeof(ca.name)-1] = 0;\n \n \t\terr = hidp_connection_add(&ca, csock, isock);\n \t\tif (!err && copy_to_user(argp, &ca, sizeof(ca)))""}","static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)
{
	struct hidp_connadd_req ca;
	struct hidp_conndel_req cd;
	struct hidp_connlist_req cl;
	struct hidp_conninfo ci;
	struct socket *csock;
	struct socket *isock;
	int err;

	BT_DBG(""cmd %x arg %p"", cmd, argp);

	switch (cmd) {
	case HIDPCONNADD:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&ca, argp, sizeof(ca)))
			return -EFAULT;

		csock = sockfd_lookup(ca.ctrl_sock, &err);
		if (!csock)
			return err;

		isock = sockfd_lookup(ca.intr_sock, &err);
		if (!isock) {
 			sockfd_put(csock);
 			return err;
 		}
		ca.name[sizeof(ca.name)-1] = 0;
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))
			err = -EFAULT;

		sockfd_put(csock);
		sockfd_put(isock);

		return err;

	case HIDPCONNDEL:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&cd, argp, sizeof(cd)))
			return -EFAULT;

		return hidp_connection_del(&cd);

	case HIDPGETCONNLIST:
		if (copy_from_user(&cl, argp, sizeof(cl)))
			return -EFAULT;

		if (cl.cnum <= 0)
			return -EINVAL;

		err = hidp_get_connlist(&cl);
		if (!err && copy_to_user(argp, &cl, sizeof(cl)))
			return -EFAULT;

		return err;

	case HIDPGETCONNINFO:
		if (copy_from_user(&ci, argp, sizeof(ci)))
			return -EFAULT;

		err = hidp_get_conninfo(&ci);
		if (!err && copy_to_user(argp, &ci, sizeof(ci)))
			return -EFAULT;

		return err;
	}

	return -EINVAL;
}
","static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)
{
	struct hidp_connadd_req ca;
	struct hidp_conndel_req cd;
	struct hidp_connlist_req cl;
	struct hidp_conninfo ci;
	struct socket *csock;
	struct socket *isock;
	int err;

	BT_DBG(""cmd %x arg %p"", cmd, argp);

	switch (cmd) {
	case HIDPCONNADD:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&ca, argp, sizeof(ca)))
			return -EFAULT;

		csock = sockfd_lookup(ca.ctrl_sock, &err);
		if (!csock)
			return err;

		isock = sockfd_lookup(ca.intr_sock, &err);
		if (!isock) {
 			sockfd_put(csock);
 			return err;
 		}
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))
			err = -EFAULT;

		sockfd_put(csock);
		sockfd_put(isock);

		return err;

	case HIDPCONNDEL:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&cd, argp, sizeof(cd)))
			return -EFAULT;

		return hidp_connection_del(&cd);

	case HIDPGETCONNLIST:
		if (copy_from_user(&cl, argp, sizeof(cl)))
			return -EFAULT;

		if (cl.cnum <= 0)
			return -EINVAL;

		err = hidp_get_connlist(&cl);
		if (!err && copy_to_user(argp, &cl, sizeof(cl)))
			return -EFAULT;

		return err;

	case HIDPGETCONNINFO:
		if (copy_from_user(&ci, argp, sizeof(ci)))
			return -EFAULT;

		err = hidp_get_conninfo(&ci);
		if (!err && copy_to_user(argp, &ci, sizeof(ci)))
			return -EFAULT;

		return err;
	}

	return -EINVAL;
}
",C,"		ca.name[sizeof(ca.name)-1] = 0;
",,,"@@ -75,6 +75,7 @@ static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user
 			sockfd_put(csock);
 			return err;
 		}
+		ca.name[sizeof(ca.name)-1] = 0;
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))",linux,a1616a5ac99ede5d605047a9012481ce7ff18b16,73623340546cceff421c95b53abd8140d1f2b2a2,1,"static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)
{
	struct hidp_connadd_req ca;
	struct hidp_conndel_req cd;
	struct hidp_connlist_req cl;
	struct hidp_conninfo ci;
	struct socket *csock;
	struct socket *isock;
	int err;

	BT_DBG(""cmd %x arg %p"", cmd, argp);

	switch (cmd) {
	case HIDPCONNADD:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&ca, argp, sizeof(ca)))
			return -EFAULT;

		csock = sockfd_lookup(ca.ctrl_sock, &err);
		if (!csock)
			return err;

		isock = sockfd_lookup(ca.intr_sock, &err);
		if (!isock) {
 			sockfd_put(csock);
 			return err;
 		}
//fix_flaw_line_below:
//		ca.name[sizeof(ca.name)-1] = 0;
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))
			err = -EFAULT;

		sockfd_put(csock);
		sockfd_put(isock);

		return err;

	case HIDPCONNDEL:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&cd, argp, sizeof(cd)))
			return -EFAULT;

		return hidp_connection_del(&cd);

	case HIDPGETCONNLIST:
		if (copy_from_user(&cl, argp, sizeof(cl)))
			return -EFAULT;

		if (cl.cnum <= 0)
			return -EINVAL;

		err = hidp_get_connlist(&cl);
		if (!err && copy_to_user(argp, &cl, sizeof(cl)))
			return -EFAULT;

		return err;

	case HIDPGETCONNINFO:
		if (copy_from_user(&ci, argp, sizeof(ci)))
			return -EFAULT;

		err = hidp_get_conninfo(&ci);
		if (!err && copy_to_user(argp, &ci, sizeof(ci)))
			return -EFAULT;

		return err;
	}

	return -EINVAL;
}
",182848,"static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)
{
	struct hidp_connadd_req ca;
	struct hidp_conndel_req cd;
	struct hidp_connlist_req cl;
	struct hidp_conninfo ci;
	struct socket *csock;
	struct socket *isock;
	int err;

	BT_DBG(""cmd %x arg %p"", cmd, argp);

	switch (cmd) {
	case HIDPCONNADD:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&ca, argp, sizeof(ca)))
			return -EFAULT;

		csock = sockfd_lookup(ca.ctrl_sock, &err);
		if (!csock)
			return err;

		isock = sockfd_lookup(ca.intr_sock, &err);
		if (!isock) {
 			sockfd_put(csock);
 			return err;
 		}
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))
			err = -EFAULT;

		sockfd_put(csock);
		sockfd_put(isock);

		return err;

	case HIDPCONNDEL:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&cd, argp, sizeof(cd)))
			return -EFAULT;

		return hidp_connection_del(&cd);

	case HIDPGETCONNLIST:
		if (copy_from_user(&cl, argp, sizeof(cl)))
			return -EFAULT;

		if (cl.cnum <= 0)
			return -EINVAL;

		err = hidp_get_connlist(&cl);
		if (!err && copy_to_user(argp, &cl, sizeof(cl)))
			return -EFAULT;

		return err;

	case HIDPGETCONNINFO:
		if (copy_from_user(&ci, argp, sizeof(ci)))
			return -EFAULT;

		err = hidp_get_conninfo(&ci);
		if (!err && copy_to_user(argp, &ci, sizeof(ci)))
			return -EFAULT;

		return err;
	}

	return -EINVAL;
}
","static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)
{
	struct hidp_connadd_req ca;
	struct hidp_conndel_req cd;
	struct hidp_connlist_req cl;
	struct hidp_conninfo ci;
	struct socket *csock;
	struct socket *isock;
	int err;

	BT_DBG(""cmd %x arg %p"", cmd, argp);

	switch (cmd) {
	case HIDPCONNADD:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&ca, argp, sizeof(ca)))
			return -EFAULT;

		csock = sockfd_lookup(ca.ctrl_sock, &err);
		if (!csock)
			return err;

		isock = sockfd_lookup(ca.intr_sock, &err);
		if (!isock) {
 			sockfd_put(csock);
 			return err;
 		}
		ca.name[sizeof(ca.name)-1] = 0;
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))
			err = -EFAULT;

		sockfd_put(csock);
		sockfd_put(isock);

		return err;

	case HIDPCONNDEL:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&cd, argp, sizeof(cd)))
			return -EFAULT;

		return hidp_connection_del(&cd);

	case HIDPGETCONNLIST:
		if (copy_from_user(&cl, argp, sizeof(cl)))
			return -EFAULT;

		if (cl.cnum <= 0)
			return -EINVAL;

		err = hidp_get_connlist(&cl);
		if (!err && copy_to_user(argp, &cl, sizeof(cl)))
			return -EFAULT;

		return err;

	case HIDPGETCONNINFO:
		if (copy_from_user(&ci, argp, sizeof(ci)))
			return -EFAULT;

		err = hidp_get_conninfo(&ci);
		if (!err && copy_to_user(argp, &ci, sizeof(ci)))
			return -EFAULT;

		return err;
	}

	return -EINVAL;
}
","The `do_hidp_sock_ioctl` function handles various IOCTL commands related to Bluetooth HID (Human Interface Device) connections. It processes commands such as adding a connection (`HIDPCONNADD`), deleting a connection (`HIDPCONNDEL`), retrieving a list of connections (`HIDPGETCONNLIST`), and fetching connection information (`HIDPGETCONNINFO`). The function checks for administrative privileges, copies data between user and kernel space, and manages socket references. It returns appropriate error codes for permission issues, memory access violations, or invalid parameters, ensuring robust interaction with HIDP socket operations while maintaining system security and stability.","The provided code implements a function that manages various operations related to Bluetooth HID connections through specific commands. It allows for adding and deleting connections, as well as retrieving lists and details of existing connections. The function ensures that only users with the appropriate administrative privileges can perform certain actions. It handles data transfer between user space and kernel space, checking for errors during these operations. Additionally, it maintains socket references to ensure proper resource management and returns relevant error codes for issues such as permission denial, memory access failures, or invalid input parameters.","The vulnerability in the original code, identified as CWE-77 (Improper Neutralization of Special Elements used in a Command), arose from the lack of proper validation and sanitization of user input, particularly in the handling of the `ca.name` field. This could allow an attacker to inject malicious data, potentially leading to arbitrary command execution or other unintended behaviors. The fix introduced a safeguard by explicitly null-terminating the `ca.name` string, ensuring that it does not exceed its allocated size. This change mitigates the risk of buffer overflows and command injection, enhancing the overall security of the function.","The vulnerability identified as CWE-77 in the original code stemmed from inadequate validation of user input, which allowed for the possibility of injecting malicious data into command execution contexts. This lack of proper sanitization could lead to unintended behaviors, including arbitrary command execution. The fix addressed this issue by implementing a safeguard that ensured the input string was properly null-terminated, preventing it from exceeding its intended size. This modification effectively mitigated the risk of buffer overflows and command injection, thereby enhancing the security and stability of the function by ensuring that user input is handled safely.","The vulnerability was fixed by adding a safeguard that explicitly null-terminates the `ca.name` string in the `HIDPCONNADD` case. By setting `ca.name[sizeof(ca.name)-1] = 0;`, the code ensures that the string does not exceed its allocated size, preventing potential buffer overflows and command injection vulnerabilities. This change effectively mitigates the risk associated with improper handling of user input, as it guarantees that any data copied into `ca.name` will be safely terminated. Consequently, this enhancement improves the overall security of the function by ensuring that user-supplied data is managed correctly.","The vulnerability was fixed by implementing a safeguard that ensures proper handling of user input, specifically by null-terminating a critical string to prevent it from exceeding its allocated size. This adjustment prevents potential buffer overflows and mitigates the risk of command injection, which could arise from improperly sanitized input. By ensuring that the string is safely terminated, the code enhances its robustness against malicious data manipulation. This change significantly improves the security of the function, ensuring that user-supplied data is managed correctly and reducing the likelihood of unintended behaviors or exploits."
2,187046,187046,,Local,Not required,,CVE-2019-5804,https://www.cvedetails.com/cve/CVE-2019-5804/,CWE-77,Low,,Partial,,2019-05-23,2.1,Incorrect command line processing in Chrome in Google Chrome prior to 73.0.3683.75 allowed a local attacker to perform domain spoofing via a crafted domain name.,2019-06-28,,4,https://github.com/chromium/chromium/commit/08965161257ab9aeef9a3548c1cd1a44525dc562,08965161257ab9aeef9a3548c1cd1a44525dc562,"Ignore switches following ""--"" when parsing a command line.

BUG=933004
R=wfh@chromium.org

Change-Id: I911be4cbfc38a4d41dec85d85f7fe0f50ddca392
Reviewed-on: https://chromium-review.googlesource.com/c/1481210
Auto-Submit: Greg Thompson <grt@chromium.org>
Commit-Queue: Julian Pastarmov <pastarmovj@chromium.org>
Reviewed-by: Julian Pastarmov <pastarmovj@chromium.org>
Cr-Commit-Position: refs/heads/master@{#634604}",2,chrome/install_static/install_util.cc,"{""sha"": ""7c7b6c5343bb05ebea63212a0c00fdfbd675efc7"", ""filename"": ""chrome/install_static/install_util.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/install_static/install_util.cc?ref=08965161257ab9aeef9a3548c1cd1a44525dc562"", ""patch"": ""@@ -847,13 +847,15 @@ std::vector<std::wstring> TokenizeCommandLineToArray(\n \n std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,\n                                            const std::wstring& switch_name) {\n+  static constexpr wchar_t kSwitchTerminator[] = L\""--\"";\n   assert(!command_line.empty());\n   assert(!switch_name.empty());\n \n   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);\n   std::wstring switch_with_equal = L\""--\"" + switch_name + L\""=\"";\n-  for (size_t i = 1; i < as_array.size(); ++i) {\n-    const std::wstring& arg = as_array[i];\n+  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);\n+  for (auto scan = as_array.cbegin(); scan != end; ++scan) {\n+    const std::wstring& arg = *scan;\n     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)\n       return arg.substr(switch_with_equal.size());\n   }""}<_**next**_>{""sha"": ""27a55e3bd94ca5a377ca300fe5240874f4efdcf5"", ""filename"": ""chrome/install_static/install_util.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/install_static/install_util.h?ref=08965161257ab9aeef9a3548c1cd1a44525dc562"", ""patch"": ""@@ -275,9 +275,10 @@ std::vector<std::wstring> TokenizeString16(const std::wstring& str,\n std::vector<std::wstring> TokenizeCommandLineToArray(\n     const std::wstring& command_line);\n \n-// We assume that the command line |command_line| contains multiple switches\n-// with the format --<switch name>=<switch value>. This function returns the\n-// value of the |switch_name| passed in.\n+// Returns the value of a switch of the form \""--<switch name>=<switch value>\"" in\n+// |command_line|. An empty switch in |command_line| (\""--\"") denotes the end of\n+// switches and the beginning of args. Anything of the form --<switch\n+// name>=<switch value> following \""--\"" is ignored.\n std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,\n                                            const std::wstring& switch_name);\n ""}<_**next**_>{""sha"": ""a05794655ddd653123941c14ce20076e5c07c79d"", ""filename"": ""chrome/install_static/install_util_unittest.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/install_static/install_util_unittest.cc?ref=08965161257ab9aeef9a3548c1cd1a44525dc562"", ""patch"": ""@@ -96,6 +96,10 @@ TEST(InstallStaticTest, GetSwitchValueFromCommandLineTest) {\n   // Bad command line without closing quotes. Should not crash.\n   value = GetSwitchValueFromCommandLine(L\""\\\""blah --type=\\t\\t\\t\"", L\""type\"");\n   EXPECT_TRUE(value.empty());\n+\n+  // Anything following \""--\"" should be considered args and therfore ignored.\n+  value = GetSwitchValueFromCommandLine(L\""blah -- --type=bleh\"", L\""type\"");\n+  EXPECT_TRUE(value.empty());\n }\n \n TEST(InstallStaticTest, SpacesAndQuotesInCommandLineArguments) {""}"," std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
  static constexpr wchar_t kSwitchTerminator[] = L""--"";
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);
  for (auto scan = as_array.cbegin(); scan != end; ++scan) {
    const std::wstring& arg = *scan;
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }

  return std::wstring();
}
"," std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
  for (size_t i = 1; i < as_array.size(); ++i) {
    const std::wstring& arg = as_array[i];
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }

  return std::wstring();
}
",C,"  static constexpr wchar_t kSwitchTerminator[] = L""--"";
  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);
  for (auto scan = as_array.cbegin(); scan != end; ++scan) {
    const std::wstring& arg = *scan;
","  for (size_t i = 1; i < as_array.size(); ++i) {
    const std::wstring& arg = as_array[i];
",,"@@ -847,13 +847,15 @@ std::vector<std::wstring> TokenizeCommandLineToArray(
 
 std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
+  static constexpr wchar_t kSwitchTerminator[] = L""--"";
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
-  for (size_t i = 1; i < as_array.size(); ++i) {
-    const std::wstring& arg = as_array[i];
+  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);
+  for (auto scan = as_array.cbegin(); scan != end; ++scan) {
+    const std::wstring& arg = *scan;
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }",Chrome,08965161257ab9aeef9a3548c1cd1a44525dc562,fba5eff0d4a6451e2d4a925c4f47973fbf10bb91,1," std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
//fix_flaw_line_below:
//  static constexpr wchar_t kSwitchTerminator[] = L""--"";
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
//flaw_line_below:
  for (size_t i = 1; i < as_array.size(); ++i) {
//flaw_line_below:
    const std::wstring& arg = as_array[i];
//fix_flaw_line_below:
//  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);
//fix_flaw_line_below:
//  for (auto scan = as_array.cbegin(); scan != end; ++scan) {
//fix_flaw_line_below:
//    const std::wstring& arg = *scan;
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }

  return std::wstring();
}
",187046," std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
  for (size_t i = 1; i < as_array.size(); ++i) {
    const std::wstring& arg = as_array[i];
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }

  return std::wstring();
}
"," std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
  static constexpr wchar_t kSwitchTerminator[] = L""--"";
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);
  for (auto scan = as_array.cbegin(); scan != end; ++scan) {
    const std::wstring& arg = *scan;
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }

  return std::wstring();
}
","The provided code defines a function `GetSwitchValueFromCommandLine` that extracts the value associated with a specified command-line switch from a given command line string. It first checks that neither the command line nor the switch name is empty. The function then tokenizes the command line into an array of arguments and constructs a string representing the switch in the format `--switch_name=`. It iterates through the tokenized arguments, comparing each one to the constructed switch string. If a match is found, it returns the value following the equal sign; otherwise, it returns an empty string.","The code defines a function that retrieves the value associated with a specific command-line option from a provided command line string. It begins by ensuring that both the command line and the option name are not empty. The function then splits the command line into individual arguments and constructs a string that represents the desired option format. It iterates through the list of arguments, checking for a match with the constructed option string. If a match is found, it extracts and returns the value that follows the equal sign; if no match is found, it returns an empty string.","The vulnerability in the original code, identified as CWE-77 (Improper Neutralization of Special Elements used in a Command), arises from the lack of validation on the command-line arguments, which could allow an attacker to inject malicious input through the `switch_name` variable. This could lead to unintended command execution or manipulation. The fixed code addresses this issue by introducing a static constant that defines a switch terminator, ensuring that the function only processes arguments up to this terminator. By limiting the scanning range to valid arguments, the risk of executing harmful commands is significantly reduced, enhancing overall security.","The vulnerability in the original code, classified as CWE-77 (Improper Neutralization of Special Elements used in a Command), stems from the lack of proper validation and constraints on user input, allowing for potential command injection through unsanitized command-line arguments. This could enable an attacker to manipulate the command execution flow by injecting harmful commands. The fixed code mitigates this risk by introducing a mechanism to limit the processing of arguments to a defined range, ensuring that only valid options are considered. This enhancement effectively reduces the attack surface and prevents the execution of unintended or malicious commands.","The vulnerability was fixed by introducing a static constant that defines a switch terminator, which restricts the range of arguments processed by the function. In the updated code, the `end` iterator is determined using `std::find` to locate the switch terminator within the tokenized argument array. The loop then iterates only from the beginning of the argument list to this `end` point, ensuring that any arguments beyond the terminator are not evaluated. This change effectively limits the scope of input that can be processed, reducing the risk of command injection and enhancing the overall security of the function.","The vulnerability was fixed by implementing a mechanism to limit the processing of command-line arguments to a defined range, specifically up to a designated terminator. This was achieved by identifying the position of the terminator within the list of arguments and ensuring that the function only iterates through the valid arguments before this point. By restricting the scope of input that can be evaluated, the updated code effectively prevents the possibility of processing malicious or unintended commands, thereby enhancing the security and integrity of the command-line parsing functionality."
