,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic
0,59950,59950,,Local,Not required,Complete,CVE-2017-16528,https://www.cvedetails.com/cve/CVE-2017-16528/,CWE-416,Low,Complete,Complete,,2017-11-03,7.2,sound/core/seq_device.c in the Linux kernel before 4.13.4 allows local users to cause a denial of service (snd_rawmidi_dev_seq_free use-after-free and system crash) or possibly have unspecified other impact via a crafted USB device.,2018-04-06,DoS ,0,https://github.com/torvalds/linux/commit/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57,fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57,"ALSA: seq: Cancel pending autoload work at unbinding device

ALSA sequencer core has a mechanism to load the enumerated devices
automatically, and it's performed in an off-load work.  This seems
causing some race when a sequencer is removed while the pending
autoload work is running.  As syzkaller spotted, it may lead to some
use-after-free:
  BUG: KASAN: use-after-free in snd_rawmidi_dev_seq_free+0x69/0x70
  sound/core/rawmidi.c:1617
  Write of size 8 at addr ffff88006c611d90 by task kworker/2:1/567

  CPU: 2 PID: 567 Comm: kworker/2:1 Not tainted 4.13.0+ #29
  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
  Workqueue: events autoload_drivers
  Call Trace:
   __dump_stack lib/dump_stack.c:16 [inline]
   dump_stack+0x192/0x22c lib/dump_stack.c:52
   print_address_description+0x78/0x280 mm/kasan/report.c:252
   kasan_report_error mm/kasan/report.c:351 [inline]
   kasan_report+0x230/0x340 mm/kasan/report.c:409
   __asan_report_store8_noabort+0x1c/0x20 mm/kasan/report.c:435
   snd_rawmidi_dev_seq_free+0x69/0x70 sound/core/rawmidi.c:1617
   snd_seq_dev_release+0x4f/0x70 sound/core/seq_device.c:192
   device_release+0x13f/0x210 drivers/base/core.c:814
   kobject_cleanup lib/kobject.c:648 [inline]
   kobject_release lib/kobject.c:677 [inline]
   kref_put include/linux/kref.h:70 [inline]
   kobject_put+0x145/0x240 lib/kobject.c:694
   put_device+0x25/0x30 drivers/base/core.c:1799
   klist_devices_put+0x36/0x40 drivers/base/bus.c:827
   klist_next+0x264/0x4a0 lib/klist.c:403
   next_device drivers/base/bus.c:270 [inline]
   bus_for_each_dev+0x17e/0x210 drivers/base/bus.c:312
   autoload_drivers+0x3b/0x50 sound/core/seq_device.c:117
   process_one_work+0x9fb/0x1570 kernel/workqueue.c:2097
   worker_thread+0x1e4/0x1350 kernel/workqueue.c:2231
   kthread+0x324/0x3f0 kernel/kthread.c:231
   ret_from_fork+0x25/0x30 arch/x86/entry/entry_64.S:425

The fix is simply to assure canceling the autoload work at removing
the device.

Reported-by: Andrey Konovalov <andreyknvl@google.com>
Tested-by: Andrey Konovalov <andreyknvl@google.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>",0,sound/core/seq_device.c,"{""sha"": ""e40a2cba5002a817876252074c91de620c6dbce2"", ""filename"": ""sound/core/seq_device.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57/sound/core/seq_device.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57/sound/core/seq_device.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/sound/core/seq_device.c?ref=fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57"", ""patch"": ""@@ -148,8 +148,10 @@ void snd_seq_device_load_drivers(void)\n \tflush_work(&autoload_work);\n }\n EXPORT_SYMBOL(snd_seq_device_load_drivers);\n+#define cancel_autoload_drivers()\tcancel_work_sync(&autoload_work)\n #else\n #define queue_autoload_drivers() /* NOP */\n+#define cancel_autoload_drivers() /* NOP */\n #endif\n \n /*\n@@ -159,6 +161,7 @@ static int snd_seq_device_dev_free(struct snd_device *device)\n {\n \tstruct snd_seq_device *dev = device->device_data;\n \n+\tcancel_autoload_drivers();\n \tput_device(&dev->dev);\n \treturn 0;\n }""}","static int snd_seq_device_dev_disconnect(struct snd_device *device)
{
	struct snd_seq_device *dev = device->device_data;

	device_del(&dev->dev);
	return 0;
}
","static int snd_seq_device_dev_disconnect(struct snd_device *device)
{
	struct snd_seq_device *dev = device->device_data;

	device_del(&dev->dev);
	return 0;
}
",C,,,,"@@ -148,8 +148,10 @@ void snd_seq_device_load_drivers(void)
 	flush_work(&autoload_work);
 }
 EXPORT_SYMBOL(snd_seq_device_load_drivers);
+#define cancel_autoload_drivers()	cancel_work_sync(&autoload_work)
 #else
 #define queue_autoload_drivers() /* NOP */
+#define cancel_autoload_drivers() /* NOP */
 #endif
 
 /*
@@ -159,6 +161,7 @@ static int snd_seq_device_dev_free(struct snd_device *device)
 {
 	struct snd_seq_device *dev = device->device_data;
 
+	cancel_autoload_drivers();
 	put_device(&dev->dev);
 	return 0;
 }",linux,fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57,f16e666b9b7e07237ca0669df9b89ccf8dfc102c,0,"static int snd_seq_device_dev_disconnect(struct snd_device *device)
{
	struct snd_seq_device *dev = device->device_data;

	device_del(&dev->dev);
	return 0;
}
",59950,"static int snd_seq_device_dev_free(struct snd_device *device)
 {
 	struct snd_seq_device *dev = device->device_data;
 
 	put_device(&dev->dev);
 	return 0;
 }
","static int snd_seq_device_dev_disconnect(struct snd_device *device)
{
	struct snd_seq_device *dev = device->device_data;

	device_del(&dev->dev);
	return 0;
}
","The vulnerability in the original code, `snd_seq_device_dev_free`, arises from using `put_device(&dev->dev)`, which only decreases the reference count of the device but does not properly disconnect it from the device model, potentially leading to use-after-free issues. In the fixed code, `snd_seq_device_dev_disconnect` replaces `put_device` with `device_del(&dev->dev)`, which not only decreases the reference count but also removes the device from the system, ensuring that it is fully disconnected and preventing any further access to the device after it has been freed, thus mitigating the vulnerability.","The vulnerability in the original code stems from inadequate handling of device disconnection, which only reduces the reference count without properly removing the device from the system. This oversight can lead to use-after-free vulnerabilities, where the device may still be accessed after it has been deallocated, potentially causing crashes or security issues. The revised code addresses this vulnerability by implementing a proper disconnection process that not only decreases the reference count but also ensures the device is fully removed from the device model. This change effectively prevents any further access to the device after it has been freed, enhancing overall safety."
1,82760,82760,,Remote,Not required,Partial,CVE-2018-11383,https://www.cvedetails.com/cve/CVE-2018-11383/,CWE-416,Medium,,,,2018-05-22,4.3,The r_strbuf_fini() function in radare2 2.5.0 allows remote attackers to cause a denial of service (invalid free and application crash) via a crafted ELF file because of an uninitialized variable in the CPSE handler in libr/anal/p/anal_avr.c.,2018-06-27,DoS ,0,https://github.com/radare/radare2/commit/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,Fix #9943 - Invalid free on RAnal.avr,0,libr/anal/p/anal_avr.c,"{""sha"": ""93d72ce52ade371a28d0008573d07892499f4b6c"", ""filename"": ""libr/anal/p/anal_avr.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/radareorg/radare2/blob/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a/libr/anal/p/anal_avr.c"", ""raw_url"": ""https://github.com/radareorg/radare2/raw/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a/libr/anal/p/anal_avr.c"", ""contents_url"": ""https://api.github.com/repos/radareorg/radare2/contents/libr/anal/p/anal_avr.c?ref=9d348bcc2c4bbd3805e7eec97b594be9febbdf9a"", ""patch"": ""@@ -619,7 +619,7 @@ INST_HANDLER (cpi) { // CPI Rd, K\n INST_HANDLER (cpse) {\t// CPSE Rd, Rr\n \tint r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);\n \tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n-\tRAnalOp next_op;\n+\tRAnalOp next_op = {0};\n \n \t// calculate next instruction size (call recursively avr_op_analyze)\n \t// and free next_op's esil string (we dont need it now)""}<_**next**_>{""sha"": ""969cf32a33d41e5c043608d5cc38f6452d52339a"", ""filename"": ""libr/core/cmd_anal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/radareorg/radare2/blob/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a/libr/core/cmd_anal.c"", ""raw_url"": ""https://github.com/radareorg/radare2/raw/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a/libr/core/cmd_anal.c"", ""contents_url"": ""https://api.github.com/repos/radareorg/radare2/contents/libr/core/cmd_anal.c?ref=9d348bcc2c4bbd3805e7eec97b594be9febbdf9a"", ""patch"": ""@@ -4350,8 +4350,9 @@ static void cmd_anal_esil(RCore *core, const char *input) {\n \t\t{\n \t\t\t// anal ESIL to REIL.\n \t\t\tRAnalEsil *esil = r_anal_esil_new (stacksize, iotrap, addrsize);\n-\t\t\tif (!esil)\n+\t\t\tif (!esil) {\n \t\t\t\treturn;\n+\t\t\t}\n \t\t\tr_anal_esil_to_reil_setup (esil, core->anal, romem, stats);\n \t\t\tr_anal_esil_set_pc (esil, core->offset);\n \t\t\tr_anal_esil_parse (esil, input + 2);""}","INST_HANDLER (sbrx) {	// SBRC Rr, b
	int b = buf[0] & 0x7;
	int r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);
	RAnalOp next_op = {0};

	avr_op_analyze (anal,
			&next_op,
			op->addr + op->size, buf + op->size, len - op->size,
			cpu);
	r_strbuf_fini (&next_op.esil);
	op->jump = op->addr + next_op.size + 2;

	op->cycles = 1;	// XXX: This is a bug, because depends on eval state,
	ESIL_A (""%d,1,<<,r%d,&,"", b, r);			// Rr(b)
	ESIL_A ((buf[1] & 0xe) == 0xc
			? ""!,""		// SBRC => branch if cleared
			: ""!,!,"");	// SBRS => branch if set
	ESIL_A (""?{,%""PFMT64d"",pc,=,},"", op->jump);	// ?true => jmp
}
","INST_HANDLER (sbrx) {	// SBRC Rr, b
	int b = buf[0] & 0x7;
	int r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);
	RAnalOp next_op = {0};

	avr_op_analyze (anal,
			&next_op,
			op->addr + op->size, buf + op->size, len - op->size,
			cpu);
	r_strbuf_fini (&next_op.esil);
	op->jump = op->addr + next_op.size + 2;

	op->cycles = 1;	// XXX: This is a bug, because depends on eval state,
	ESIL_A (""%d,1,<<,r%d,&,"", b, r);			// Rr(b)
	ESIL_A ((buf[1] & 0xe) == 0xc
			? ""!,""		// SBRC => branch if cleared
			: ""!,!,"");	// SBRS => branch if set
	ESIL_A (""?{,%""PFMT64d"",pc,=,},"", op->jump);	// ?true => jmp
}
",C,,,,"@@ -619,7 +619,7 @@ INST_HANDLER (cpi) { // CPI Rd, K
 INST_HANDLER (cpse) {	// CPSE Rd, Rr
 	int r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);
 	int d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);
-	RAnalOp next_op;
+	RAnalOp next_op = {0};
 
 	// calculate next instruction size (call recursively avr_op_analyze)
 	// and free next_op's esil string (we dont need it now)",radare2,9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,ec75785c7cfde4ec36bc3877357ba5e33d80cc31,0,"INST_HANDLER (sbrx) {	// SBRC Rr, b
			// SBRS Rr, b
	int b = buf[0] & 0x7;
	int r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);
	RAnalOp next_op = {0};

	// calculate next instruction size (call recursively avr_op_analyze)
	// and free next_op's esil string (we dont need it now)
	avr_op_analyze (anal,
			&next_op,
			op->addr + op->size, buf + op->size, len - op->size,
			cpu);
	r_strbuf_fini (&next_op.esil);
	op->jump = op->addr + next_op.size + 2;

	// cycles
	op->cycles = 1;	// XXX: This is a bug, because depends on eval state,
			// so it cannot be really be known until this
			// instruction is executed by the ESIL interpreter!!!
			// In case of evaluating to false, this instruction
			// needs 2/3 cycles, elsewhere it needs only 1 cycle.
	ESIL_A (""%d,1,<<,r%d,&,"", b, r);			// Rr(b)
	ESIL_A ((buf[1] & 0xe) == 0xc
			? ""!,""		// SBRC => branch if cleared
			: ""!,!,"");	// SBRS => branch if set
	ESIL_A (""?{,%""PFMT64d"",pc,=,},"", op->jump);	// ?true => jmp
}
",82760,"INST_HANDLER (cpse) {	// CPSE Rd, Rr
	int r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);
	int d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);
	RAnalOp next_op;

	// calculate next instruction size (call recursively avr_op_analyze)
	// and free next_op's esil string (we dont need it now)
	avr_op_analyze (anal,
			&next_op,
			op->addr + op->size, buf + op->size, len - op->size,
			cpu);
	r_strbuf_fini (&next_op.esil);
	op->jump = op->addr + next_op.size + 2;

	// cycles
	op->cycles = 1;	// XXX: This is a bug, because depends on eval state,
			// so it cannot be really be known until this
			// instruction is executed by the ESIL interpreter!!!
			// In case of evaluating to true, this instruction
			// needs 2/3 cycles, elsewhere it needs only 1 cycle.
	ESIL_A (""r%d,r%d,^,!,"", r, d);			// Rr == Rd
	ESIL_A (""?{,%""PFMT64d"",pc,=,},"", op->jump);	// ?true => jmp
}","INST_HANDLER (sbrx) {	// SBRC Rr, b
	int b = buf[0] & 0x7;
	int r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);
	RAnalOp next_op = {0};

	avr_op_analyze (anal,
			&next_op,
			op->addr + op->size, buf + op->size, len - op->size,
			cpu);
	r_strbuf_fini (&next_op.esil);
	op->jump = op->addr + next_op.size + 2;

	op->cycles = 1;	// XXX: This is a bug, because depends on eval state,
	ESIL_A (""%d,1,<<,r%d,&,"", b, r);			// Rr(b)
	ESIL_A ((buf[1] & 0xe) == 0xc
			? ""!,""		// SBRC => branch if cleared
			: ""!,!,"");	// SBRS => branch if set
	ESIL_A (""?{,%""PFMT64d"",pc,=,},"", op->jump);	// ?true => jmp
}
","The vulnerability in the original code lies in the incorrect handling of the `op->cycles` variable, which is set to a static value of 1 without considering the actual execution state of the instruction. This oversight could lead to inaccurate cycle counts, as the instruction may require 2 or 3 cycles depending on the evaluation state. In the fixed code, while the comment about the cycle bug remains, the handling of the `ESIL_A` function has been improved by introducing a conditional expression that differentiates between the SBRC and SBRS instructions, ensuring that the correct branching logic is applied based on the state of the bits, thus enhancing the overall accuracy of the instruction execution.","The vulnerability in the original code stems from the incorrect assignment of a static cycle count, which fails to account for the actual execution state of the instruction. This oversight could lead to inaccurate cycle estimations, potentially causing performance issues or incorrect behavior during execution. In the revised code, while the static cycle assignment remains, the logic for handling branching has been improved. The new implementation introduces a conditional check that differentiates between two types of instructions, ensuring that the correct branching behavior is applied based on the state of the relevant bits, thereby enhancing the accuracy of the instruction's execution."
2,177749,177749,,Remote,Not required,Partial,CVE-2018-1000039,https://www.cvedetails.com/cve/CVE-2018-1000039/,CWE-416,Medium,Partial,Partial,,2018-05-24,6.8,"In MuPDF 1.12.0 and earlier, multiple heap use after free bugs in the PDF parser could allow an attacker to execute arbitrary code, read memory, or cause a denial of service via a crafted file.",2018-11-27,DoS Exec Code,1,http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=f597300439e62f5e921f0d7b1e880b5c1a1f1607;hp=093fc3b098dc5fadef5d8ad4b225db9fb124758b,f597300439e62f5e921f0d7b1e880b5c1a1f1607,,0,,,"add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
	int current;
	cmap_splay *tree;

	if (low > high)
	{
		fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
		return;
	}

	tree = cmap->tree;

	if (cmap->tlen)
	{
		unsigned int move = cmap->ttop;
		unsigned int gt = EMPTY;
		unsigned int lt = EMPTY;
		if (check_for_overlap)
		{
			/* Check for collision with the current node */
			do
			{
				current = move;
				/* Cases we might meet:
				 * tree[i]:        <----->
				 * case 0:     <->
				 * case 1:     <------->
				 * case 2:     <------------->
				 * case 3:           <->
				 * case 4:           <------->
				 * case 5:                 <->
				 */
				if (low <= tree[current].low && tree[current].low <= high)
				{
					/* case 1, reduces to case 0 */
					/* or case 2, deleting the node */
					tree[current].out += high + 1 - tree[current].low;
					tree[current].low = high + 1;
					if (tree[current].low > tree[current].high)
					{
						move = delete_node(cmap, current);
						current = EMPTY;
						continue;
					}
				}
				else if (low <= tree[current].high && tree[current].high <= high)
				{
					/* case 4, reduces to case 5 */
					tree[current].high = low - 1;
					assert(tree[current].low <= tree[current].high);
				}
				else if (tree[current].low < low && high < tree[current].high)
				{
					/* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                        add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
                                       tree = cmap->tree;
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			}
			while (move != EMPTY);
		}
		else
		{
			do
			{
				current = move;
				if (tree[current].low > high)
				{
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			} while (move != EMPTY);
		}
		/* current is now the node to which we would be adding the new node */
		/* lt is the last node we traversed which is lt the new node. */
		/* gt is the last node we traversed which is gt the new node. */

		if (!many)
		{
			/* Check for the 'merge' cases. */
			if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
			{
				tree[lt].high = high;
				if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
				{
					tree[lt].high = tree[gt].high;
					delete_node(cmap, gt);
				}
				goto exit;
			}
			if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
			{
				tree[gt].low = low;
				tree[gt].out = out;
				goto exit;
			}
		}
	}
	else
		current = EMPTY;

	if (cmap->tlen == cmap->tcap)
	{
		int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
		tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
		cmap->tcap = new_cap;
	}
	tree[cmap->tlen].low = low;
	tree[cmap->tlen].high = high;
	tree[cmap->tlen].out = out;
	tree[cmap->tlen].parent = current;
	tree[cmap->tlen].left = EMPTY;
	tree[cmap->tlen].right = EMPTY;
	tree[cmap->tlen].many = many;
	cmap->tlen++;
	if (current == EMPTY)
		cmap->ttop = 0;
	else if (tree[current].low > high)
		tree[current].left = cmap->tlen-1;
	else
	{
		assert(tree[current].high < low);
		tree[current].right = cmap->tlen-1;
	}
	move_to_root(tree, cmap->tlen-1);
	cmap->ttop = cmap->tlen-1;
exit:
	{}
#ifdef CHECK_SPLAY
	check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
	dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}
","add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
	int current;
	cmap_splay *tree;

	if (low > high)
	{
		fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
		return;
	}

	tree = cmap->tree;

	if (cmap->tlen)
	{
		unsigned int move = cmap->ttop;
		unsigned int gt = EMPTY;
		unsigned int lt = EMPTY;
		if (check_for_overlap)
		{
			/* Check for collision with the current node */
			do
			{
				current = move;
				/* Cases we might meet:
				 * tree[i]:        <----->
				 * case 0:     <->
				 * case 1:     <------->
				 * case 2:     <------------->
				 * case 3:           <->
				 * case 4:           <------->
				 * case 5:                 <->
				 */
				if (low <= tree[current].low && tree[current].low <= high)
				{
					/* case 1, reduces to case 0 */
					/* or case 2, deleting the node */
					tree[current].out += high + 1 - tree[current].low;
					tree[current].low = high + 1;
					if (tree[current].low > tree[current].high)
					{
						move = delete_node(cmap, current);
						current = EMPTY;
						continue;
					}
				}
				else if (low <= tree[current].high && tree[current].high <= high)
				{
					/* case 4, reduces to case 5 */
					tree[current].high = low - 1;
					assert(tree[current].low <= tree[current].high);
				}
				else if (tree[current].low < low && high < tree[current].high)
				{
					/* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                        add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			}
			while (move != EMPTY);
		}
		else
		{
			do
			{
				current = move;
				if (tree[current].low > high)
				{
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			} while (move != EMPTY);
		}
		/* current is now the node to which we would be adding the new node */
		/* lt is the last node we traversed which is lt the new node. */
		/* gt is the last node we traversed which is gt the new node. */

		if (!many)
		{
			/* Check for the 'merge' cases. */
			if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
			{
				tree[lt].high = high;
				if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
				{
					tree[lt].high = tree[gt].high;
					delete_node(cmap, gt);
				}
				goto exit;
			}
			if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
			{
				tree[gt].low = low;
				tree[gt].out = out;
				goto exit;
			}
		}
	}
	else
		current = EMPTY;

	if (cmap->tlen == cmap->tcap)
	{
		int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
		tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
		cmap->tcap = new_cap;
	}
	tree[cmap->tlen].low = low;
	tree[cmap->tlen].high = high;
	tree[cmap->tlen].out = out;
	tree[cmap->tlen].parent = current;
	tree[cmap->tlen].left = EMPTY;
	tree[cmap->tlen].right = EMPTY;
	tree[cmap->tlen].many = many;
	cmap->tlen++;
	if (current == EMPTY)
		cmap->ttop = 0;
	else if (tree[current].low > high)
		tree[current].left = cmap->tlen-1;
	else
	{
		assert(tree[current].high < low);
		tree[current].right = cmap->tlen-1;
	}
	move_to_root(tree, cmap->tlen-1);
	cmap->ttop = cmap->tlen-1;
exit:
	{}
#ifdef CHECK_SPLAY
	check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
	dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}
",C,"                                       tree = cmap->tree;
",,093fc3b098dc5fadef5d8ad4b225db9fb124758b,"@@ -525,6 +525,7 @@ add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high,
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                        add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
+                                       tree = cmap->tree;
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {",ghostscript,http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-cmap.c;h=00e2afb72bab07def6ddece70db56c15cee241b9;hb=f597300439e62f5e921f0d7b1e880b5c1a1f1607,http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-cmap.c;h=29d9c50693d0fb6ac35437e3997f713af729111f;hb=093fc3b098dc5fadef5d8ad4b225db9fb124758b,1,"add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
	int current;
	cmap_splay *tree;

	if (low > high)
	{
		fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
		return;
	}

	tree = cmap->tree;

	if (cmap->tlen)
	{
		unsigned int move = cmap->ttop;
		unsigned int gt = EMPTY;
		unsigned int lt = EMPTY;
		if (check_for_overlap)
		{
			/* Check for collision with the current node */
			do
			{
				current = move;
				/* Cases we might meet:
				 * tree[i]:        <----->
				 * case 0:     <->
				 * case 1:     <------->
				 * case 2:     <------------->
				 * case 3:           <->
				 * case 4:           <------->
				 * case 5:                 <->
				 */
				if (low <= tree[current].low && tree[current].low <= high)
				{
					/* case 1, reduces to case 0 */
					/* or case 2, deleting the node */
					tree[current].out += high + 1 - tree[current].low;
					tree[current].low = high + 1;
					if (tree[current].low > tree[current].high)
					{
						move = delete_node(cmap, current);
						current = EMPTY;
						continue;
					}
				}
				else if (low <= tree[current].high && tree[current].high <= high)
				{
					/* case 4, reduces to case 5 */
					tree[current].high = low - 1;
					assert(tree[current].low <= tree[current].high);
				}
				else if (tree[current].low < low && high < tree[current].high)
				{
					/* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                        add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
//fix_flaw_line_below:
//                                       tree = cmap->tree;
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			}
			while (move != EMPTY);
		}
		else
		{
			do
			{
				current = move;
				if (tree[current].low > high)
				{
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			} while (move != EMPTY);
		}
		/* current is now the node to which we would be adding the new node */
		/* lt is the last node we traversed which is lt the new node. */
		/* gt is the last node we traversed which is gt the new node. */

		if (!many)
		{
			/* Check for the 'merge' cases. */
			if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
			{
				tree[lt].high = high;
				if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
				{
					tree[lt].high = tree[gt].high;
					delete_node(cmap, gt);
				}
				goto exit;
			}
			if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
			{
				tree[gt].low = low;
				tree[gt].out = out;
				goto exit;
			}
		}
	}
	else
		current = EMPTY;

	if (cmap->tlen == cmap->tcap)
	{
		int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
		tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
		cmap->tcap = new_cap;
	}
	tree[cmap->tlen].low = low;
	tree[cmap->tlen].high = high;
	tree[cmap->tlen].out = out;
	tree[cmap->tlen].parent = current;
	tree[cmap->tlen].left = EMPTY;
	tree[cmap->tlen].right = EMPTY;
	tree[cmap->tlen].many = many;
	cmap->tlen++;
	if (current == EMPTY)
		cmap->ttop = 0;
	else if (tree[current].low > high)
		tree[current].left = cmap->tlen-1;
	else
	{
		assert(tree[current].high < low);
		tree[current].right = cmap->tlen-1;
	}
	move_to_root(tree, cmap->tlen-1);
	cmap->ttop = cmap->tlen-1;
exit:
	{}
#ifdef CHECK_SPLAY
	check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
	dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}
",177749,"add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
	int current;
	cmap_splay *tree;

	if (low > high)
	{
		fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
		return;
	}

	tree = cmap->tree;

	if (cmap->tlen)
	{
		unsigned int move = cmap->ttop;
		unsigned int gt = EMPTY;
		unsigned int lt = EMPTY;
		if (check_for_overlap)
		{
			/* Check for collision with the current node */
			do
			{
				current = move;
				/* Cases we might meet:
				 * tree[i]:        <----->
				 * case 0:     <->
				 * case 1:     <------->
				 * case 2:     <------------->
				 * case 3:           <->
				 * case 4:           <------->
				 * case 5:                 <->
				 */
				if (low <= tree[current].low && tree[current].low <= high)
				{
					/* case 1, reduces to case 0 */
					/* or case 2, deleting the node */
					tree[current].out += high + 1 - tree[current].low;
					tree[current].low = high + 1;
					if (tree[current].low > tree[current].high)
					{
						move = delete_node(cmap, current);
						current = EMPTY;
						continue;
					}
				}
				else if (low <= tree[current].high && tree[current].high <= high)
				{
					/* case 4, reduces to case 5 */
					tree[current].high = low - 1;
					assert(tree[current].low <= tree[current].high);
				}
				else if (tree[current].low < low && high < tree[current].high)
				{
					/* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                        add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			}
			while (move != EMPTY);
		}
		else
		{
			do
			{
				current = move;
				if (tree[current].low > high)
				{
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			} while (move != EMPTY);
		}
		/* current is now the node to which we would be adding the new node */
		/* lt is the last node we traversed which is lt the new node. */
		/* gt is the last node we traversed which is gt the new node. */

		if (!many)
		{
			/* Check for the 'merge' cases. */
			if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
			{
				tree[lt].high = high;
				if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
				{
					tree[lt].high = tree[gt].high;
					delete_node(cmap, gt);
				}
				goto exit;
			}
			if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
			{
				tree[gt].low = low;
				tree[gt].out = out;
				goto exit;
			}
		}
	}
	else
		current = EMPTY;

	if (cmap->tlen == cmap->tcap)
	{
		int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
		tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
		cmap->tcap = new_cap;
	}
	tree[cmap->tlen].low = low;
	tree[cmap->tlen].high = high;
	tree[cmap->tlen].out = out;
	tree[cmap->tlen].parent = current;
	tree[cmap->tlen].left = EMPTY;
	tree[cmap->tlen].right = EMPTY;
	tree[cmap->tlen].many = many;
	cmap->tlen++;
	if (current == EMPTY)
		cmap->ttop = 0;
	else if (tree[current].low > high)
		tree[current].left = cmap->tlen-1;
	else
	{
		assert(tree[current].high < low);
		tree[current].right = cmap->tlen-1;
	}
	move_to_root(tree, cmap->tlen-1);
	cmap->ttop = cmap->tlen-1;
exit:
	{}
#ifdef CHECK_SPLAY
	check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
	dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}
","add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
	int current;
	cmap_splay *tree;

	if (low > high)
	{
		fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
		return;
	}

	tree = cmap->tree;

	if (cmap->tlen)
	{
		unsigned int move = cmap->ttop;
		unsigned int gt = EMPTY;
		unsigned int lt = EMPTY;
		if (check_for_overlap)
		{
			/* Check for collision with the current node */
			do
			{
				current = move;
				/* Cases we might meet:
				 * tree[i]:        <----->
				 * case 0:     <->
				 * case 1:     <------->
				 * case 2:     <------------->
				 * case 3:           <->
				 * case 4:           <------->
				 * case 5:                 <->
				 */
				if (low <= tree[current].low && tree[current].low <= high)
				{
					/* case 1, reduces to case 0 */
					/* or case 2, deleting the node */
					tree[current].out += high + 1 - tree[current].low;
					tree[current].low = high + 1;
					if (tree[current].low > tree[current].high)
					{
						move = delete_node(cmap, current);
						current = EMPTY;
						continue;
					}
				}
				else if (low <= tree[current].high && tree[current].high <= high)
				{
					/* case 4, reduces to case 5 */
					tree[current].high = low - 1;
					assert(tree[current].low <= tree[current].high);
				}
				else if (tree[current].low < low && high < tree[current].high)
				{
					/* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                        add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
                                       tree = cmap->tree;
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			}
			while (move != EMPTY);
		}
		else
		{
			do
			{
				current = move;
				if (tree[current].low > high)
				{
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			} while (move != EMPTY);
		}
		/* current is now the node to which we would be adding the new node */
		/* lt is the last node we traversed which is lt the new node. */
		/* gt is the last node we traversed which is gt the new node. */

		if (!many)
		{
			/* Check for the 'merge' cases. */
			if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
			{
				tree[lt].high = high;
				if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
				{
					tree[lt].high = tree[gt].high;
					delete_node(cmap, gt);
				}
				goto exit;
			}
			if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
			{
				tree[gt].low = low;
				tree[gt].out = out;
				goto exit;
			}
		}
	}
	else
		current = EMPTY;

	if (cmap->tlen == cmap->tcap)
	{
		int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
		tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
		cmap->tcap = new_cap;
	}
	tree[cmap->tlen].low = low;
	tree[cmap->tlen].high = high;
	tree[cmap->tlen].out = out;
	tree[cmap->tlen].parent = current;
	tree[cmap->tlen].left = EMPTY;
	tree[cmap->tlen].right = EMPTY;
	tree[cmap->tlen].many = many;
	cmap->tlen++;
	if (current == EMPTY)
		cmap->ttop = 0;
	else if (tree[current].low > high)
		tree[current].left = cmap->tlen-1;
	else
	{
		assert(tree[current].high < low);
		tree[current].right = cmap->tlen-1;
	}
	move_to_root(tree, cmap->tlen-1);
	cmap->ttop = cmap->tlen-1;
exit:
	{}
#ifdef CHECK_SPLAY
	check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
	dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}
","The vulnerability in the original `add_range` function arises from improper handling of the `current` variable during the overlap checks, particularly in the case where `tree[current].low < low && high < tree[current].high`. This could lead to incorrect tree modifications or infinite recursion if the conditions are not met properly. In the fixed code, the line `tree = cmap->tree;` was added after the recursive call to `add_range`, ensuring that the tree structure is correctly referenced after potential modifications, thus preventing any inconsistencies or infinite loops that could arise from stale references to the tree.","The vulnerability in the original code stems from inadequate management of the data structure during overlap checks, which could lead to incorrect modifications or infinite recursion. Specifically, when handling cases of overlapping ranges, the code did not ensure that the data structure was consistently updated after recursive calls, potentially referencing outdated or invalid nodes. The fix involved re-establishing the correct reference to the data structure after a recursive call, ensuring that any changes made during the overlap checks were accurately reflected in subsequent operations, thus preventing inconsistencies and enhancing the overall stability of the function."
3,177751,177751,,Remote,Not required,Partial,CVE-2018-1000039,https://www.cvedetails.com/cve/CVE-2018-1000039/,CWE-416,Medium,Partial,Partial,,2018-05-24,6.8,"In MuPDF 1.12.0 and earlier, multiple heap use after free bugs in the PDF parser could allow an attacker to execute arbitrary code, read memory, or cause a denial of service via a crafted file.",2018-11-27,DoS Exec Code,1,http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=71ceebcf56e682504da22c4035b39a2d451e8ffd;hp=7f82c01523505052615492f8e220f4348ba46995,71ceebcf56e682504da22c4035b39a2d451e8ffd,,1,,,"add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
	int current;
	cmap_splay *tree;

	if (low > high)
	{
		fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
		return;
	}

	tree = cmap->tree;

	if (cmap->tlen)
	{
		unsigned int move = cmap->ttop;
		unsigned int gt = EMPTY;
		unsigned int lt = EMPTY;
		if (check_for_overlap)
		{
			/* Check for collision with the current node */
			do
			{
				current = move;
				/* Cases we might meet:
				 * tree[i]:        <----->
				 * case 0:     <->
				 * case 1:     <------->
				 * case 2:     <------------->
				 * case 3:           <->
				 * case 4:           <------->
				 * case 5:                 <->
				 */
				if (low <= tree[current].low && tree[current].low <= high)
				{
					/* case 1, reduces to case 0 */
					/* or case 2, deleting the node */
					tree[current].out += high + 1 - tree[current].low;
					tree[current].low = high + 1;
					if (tree[current].low > tree[current].high)
					{
						move = delete_node(cmap, current);
						current = EMPTY;
						continue;
					}
				}
				else if (low <= tree[current].high && tree[current].high <= high)
				{
					/* case 4, reduces to case 5 */
					tree[current].high = low - 1;
					assert(tree[current].low <= tree[current].high);
				}
				else if (tree[current].low < low && high < tree[current].high)
				{
                                        /* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			}
			while (move != EMPTY);
		}
		else
		{
			do
			{
				current = move;
				if (tree[current].low > high)
				{
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			} while (move != EMPTY);
		}
		/* current is now the node to which we would be adding the new node */
		/* lt is the last node we traversed which is lt the new node. */
		/* gt is the last node we traversed which is gt the new node. */

		if (!many)
		{
			/* Check for the 'merge' cases. */
			if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
			{
				tree[lt].high = high;
				if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
				{
					tree[lt].high = tree[gt].high;
					delete_node(cmap, gt);
				}
				goto exit;
			}
			if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
			{
				tree[gt].low = low;
				tree[gt].out = out;
				goto exit;
			}
		}
	}
	else
		current = EMPTY;

	if (cmap->tlen == cmap->tcap)
	{
		int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
		tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
		cmap->tcap = new_cap;
	}
	tree[cmap->tlen].low = low;
	tree[cmap->tlen].high = high;
	tree[cmap->tlen].out = out;
	tree[cmap->tlen].parent = current;
	tree[cmap->tlen].left = EMPTY;
	tree[cmap->tlen].right = EMPTY;
	tree[cmap->tlen].many = many;
	cmap->tlen++;
	if (current == EMPTY)
		cmap->ttop = 0;
	else if (tree[current].low > high)
		tree[current].left = cmap->tlen-1;
	else
	{
		assert(tree[current].high < low);
		tree[current].right = cmap->tlen-1;
	}
	move_to_root(tree, cmap->tlen-1);
	cmap->ttop = cmap->tlen-1;
exit:
	{}
#ifdef CHECK_SPLAY
	check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
	dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}
","add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
	int current;
	cmap_splay *tree;

	if (low > high)
	{
		fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
		return;
	}

	tree = cmap->tree;

	if (cmap->tlen)
	{
		unsigned int move = cmap->ttop;
		unsigned int gt = EMPTY;
		unsigned int lt = EMPTY;
		if (check_for_overlap)
		{
			/* Check for collision with the current node */
			do
			{
				current = move;
				/* Cases we might meet:
				 * tree[i]:        <----->
				 * case 0:     <->
				 * case 1:     <------->
				 * case 2:     <------------->
				 * case 3:           <->
				 * case 4:           <------->
				 * case 5:                 <->
				 */
				if (low <= tree[current].low && tree[current].low <= high)
				{
					/* case 1, reduces to case 0 */
					/* or case 2, deleting the node */
					tree[current].out += high + 1 - tree[current].low;
					tree[current].low = high + 1;
					if (tree[current].low > tree[current].high)
					{
						move = delete_node(cmap, current);
						current = EMPTY;
						continue;
					}
				}
				else if (low <= tree[current].high && tree[current].high <= high)
				{
					/* case 4, reduces to case 5 */
					tree[current].high = low - 1;
					assert(tree[current].low <= tree[current].high);
				}
				else if (tree[current].low < low && high < tree[current].high)
				{
                                        /* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, many);
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			}
			while (move != EMPTY);
		}
		else
		{
			do
			{
				current = move;
				if (tree[current].low > high)
				{
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			} while (move != EMPTY);
		}
		/* current is now the node to which we would be adding the new node */
		/* lt is the last node we traversed which is lt the new node. */
		/* gt is the last node we traversed which is gt the new node. */

		if (!many)
		{
			/* Check for the 'merge' cases. */
			if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
			{
				tree[lt].high = high;
				if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
				{
					tree[lt].high = tree[gt].high;
					delete_node(cmap, gt);
				}
				goto exit;
			}
			if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
			{
				tree[gt].low = low;
				tree[gt].out = out;
				goto exit;
			}
		}
	}
	else
		current = EMPTY;

	if (cmap->tlen == cmap->tcap)
	{
		int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
		tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
		cmap->tcap = new_cap;
	}
	tree[cmap->tlen].low = low;
	tree[cmap->tlen].high = high;
	tree[cmap->tlen].out = out;
	tree[cmap->tlen].parent = current;
	tree[cmap->tlen].left = EMPTY;
	tree[cmap->tlen].right = EMPTY;
	tree[cmap->tlen].many = many;
	cmap->tlen++;
	if (current == EMPTY)
		cmap->ttop = 0;
	else if (tree[current].low > high)
		tree[current].left = cmap->tlen-1;
	else
	{
		assert(tree[current].high < low);
		tree[current].right = cmap->tlen-1;
	}
	move_to_root(tree, cmap->tlen-1);
	cmap->ttop = cmap->tlen-1;
exit:
	{}
#ifdef CHECK_SPLAY
	check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
	dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}
",C,"                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
","                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, many);
",7f82c01523505052615492f8e220f4348ba46995,"@@ -520,7 +520,7 @@ add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high,
                                        /* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
-                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, many);
+                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {",ghostscript,http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-cmap.c;h=bedc13045aa0566e40cc1b4179e108f961d28ff6;hb=71ceebcf56e682504da22c4035b39a2d451e8ffd,http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-cmap.c;h=ade72c443be3388fe522c55ea1105fbd8a7c1735;hb=7f82c01523505052615492f8e220f4348ba46995,1,"add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
	int current;
	cmap_splay *tree;

	if (low > high)
	{
		fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
		return;
	}

	tree = cmap->tree;

	if (cmap->tlen)
	{
		unsigned int move = cmap->ttop;
		unsigned int gt = EMPTY;
		unsigned int lt = EMPTY;
		if (check_for_overlap)
		{
			/* Check for collision with the current node */
			do
			{
				current = move;
				/* Cases we might meet:
				 * tree[i]:        <----->
				 * case 0:     <->
				 * case 1:     <------->
				 * case 2:     <------------->
				 * case 3:           <->
				 * case 4:           <------->
				 * case 5:                 <->
				 */
				if (low <= tree[current].low && tree[current].low <= high)
				{
					/* case 1, reduces to case 0 */
					/* or case 2, deleting the node */
					tree[current].out += high + 1 - tree[current].low;
					tree[current].low = high + 1;
					if (tree[current].low > tree[current].high)
					{
						move = delete_node(cmap, current);
						current = EMPTY;
						continue;
					}
				}
				else if (low <= tree[current].high && tree[current].high <= high)
				{
					/* case 4, reduces to case 5 */
					tree[current].high = low - 1;
					assert(tree[current].low <= tree[current].high);
				}
				else if (tree[current].low < low && high < tree[current].high)
				{
                                        /* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
//flaw_line_below:
                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, many);
//fix_flaw_line_below:
//                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			}
			while (move != EMPTY);
		}
		else
		{
			do
			{
				current = move;
				if (tree[current].low > high)
				{
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			} while (move != EMPTY);
		}
		/* current is now the node to which we would be adding the new node */
		/* lt is the last node we traversed which is lt the new node. */
		/* gt is the last node we traversed which is gt the new node. */

		if (!many)
		{
			/* Check for the 'merge' cases. */
			if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
			{
				tree[lt].high = high;
				if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
				{
					tree[lt].high = tree[gt].high;
					delete_node(cmap, gt);
				}
				goto exit;
			}
			if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
			{
				tree[gt].low = low;
				tree[gt].out = out;
				goto exit;
			}
		}
	}
	else
		current = EMPTY;

	if (cmap->tlen == cmap->tcap)
	{
		int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
		tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
		cmap->tcap = new_cap;
	}
	tree[cmap->tlen].low = low;
	tree[cmap->tlen].high = high;
	tree[cmap->tlen].out = out;
	tree[cmap->tlen].parent = current;
	tree[cmap->tlen].left = EMPTY;
	tree[cmap->tlen].right = EMPTY;
	tree[cmap->tlen].many = many;
	cmap->tlen++;
	if (current == EMPTY)
		cmap->ttop = 0;
	else if (tree[current].low > high)
		tree[current].left = cmap->tlen-1;
	else
	{
		assert(tree[current].high < low);
		tree[current].right = cmap->tlen-1;
	}
	move_to_root(tree, cmap->tlen-1);
	cmap->ttop = cmap->tlen-1;
exit:
	{}
#ifdef CHECK_SPLAY
	check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
	dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}
",177751,"add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
	int current;
	cmap_splay *tree;

	if (low > high)
	{
		fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
		return;
	}

	tree = cmap->tree;

	if (cmap->tlen)
	{
		unsigned int move = cmap->ttop;
		unsigned int gt = EMPTY;
		unsigned int lt = EMPTY;
		if (check_for_overlap)
		{
			/* Check for collision with the current node */
			do
			{
				current = move;
				/* Cases we might meet:
				 * tree[i]:        <----->
				 * case 0:     <->
				 * case 1:     <------->
				 * case 2:     <------------->
				 * case 3:           <->
				 * case 4:           <------->
				 * case 5:                 <->
				 */
				if (low <= tree[current].low && tree[current].low <= high)
				{
					/* case 1, reduces to case 0 */
					/* or case 2, deleting the node */
					tree[current].out += high + 1 - tree[current].low;
					tree[current].low = high + 1;
					if (tree[current].low > tree[current].high)
					{
						move = delete_node(cmap, current);
						current = EMPTY;
						continue;
					}
				}
				else if (low <= tree[current].high && tree[current].high <= high)
				{
					/* case 4, reduces to case 5 */
					tree[current].high = low - 1;
					assert(tree[current].low <= tree[current].high);
				}
				else if (tree[current].low < low && high < tree[current].high)
				{
                                        /* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, many);
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			}
			while (move != EMPTY);
		}
		else
		{
			do
			{
				current = move;
				if (tree[current].low > high)
				{
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			} while (move != EMPTY);
		}
		/* current is now the node to which we would be adding the new node */
		/* lt is the last node we traversed which is lt the new node. */
		/* gt is the last node we traversed which is gt the new node. */

		if (!many)
		{
			/* Check for the 'merge' cases. */
			if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
			{
				tree[lt].high = high;
				if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
				{
					tree[lt].high = tree[gt].high;
					delete_node(cmap, gt);
				}
				goto exit;
			}
			if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
			{
				tree[gt].low = low;
				tree[gt].out = out;
				goto exit;
			}
		}
	}
	else
		current = EMPTY;

	if (cmap->tlen == cmap->tcap)
	{
		int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
		tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
		cmap->tcap = new_cap;
	}
	tree[cmap->tlen].low = low;
	tree[cmap->tlen].high = high;
	tree[cmap->tlen].out = out;
	tree[cmap->tlen].parent = current;
	tree[cmap->tlen].left = EMPTY;
	tree[cmap->tlen].right = EMPTY;
	tree[cmap->tlen].many = many;
	cmap->tlen++;
	if (current == EMPTY)
		cmap->ttop = 0;
	else if (tree[current].low > high)
		tree[current].left = cmap->tlen-1;
	else
	{
		assert(tree[current].high < low);
		tree[current].right = cmap->tlen-1;
	}
	move_to_root(tree, cmap->tlen-1);
	cmap->ttop = cmap->tlen-1;
exit:
	{}
#ifdef CHECK_SPLAY
	check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
	dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}
","add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
	int current;
	cmap_splay *tree;

	if (low > high)
	{
		fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
		return;
	}

	tree = cmap->tree;

	if (cmap->tlen)
	{
		unsigned int move = cmap->ttop;
		unsigned int gt = EMPTY;
		unsigned int lt = EMPTY;
		if (check_for_overlap)
		{
			/* Check for collision with the current node */
			do
			{
				current = move;
				/* Cases we might meet:
				 * tree[i]:        <----->
				 * case 0:     <->
				 * case 1:     <------->
				 * case 2:     <------------->
				 * case 3:           <->
				 * case 4:           <------->
				 * case 5:                 <->
				 */
				if (low <= tree[current].low && tree[current].low <= high)
				{
					/* case 1, reduces to case 0 */
					/* or case 2, deleting the node */
					tree[current].out += high + 1 - tree[current].low;
					tree[current].low = high + 1;
					if (tree[current].low > tree[current].high)
					{
						move = delete_node(cmap, current);
						current = EMPTY;
						continue;
					}
				}
				else if (low <= tree[current].high && tree[current].high <= high)
				{
					/* case 4, reduces to case 5 */
					tree[current].high = low - 1;
					assert(tree[current].low <= tree[current].high);
				}
				else if (tree[current].low < low && high < tree[current].high)
				{
                                        /* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			}
			while (move != EMPTY);
		}
		else
		{
			do
			{
				current = move;
				if (tree[current].low > high)
				{
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			} while (move != EMPTY);
		}
		/* current is now the node to which we would be adding the new node */
		/* lt is the last node we traversed which is lt the new node. */
		/* gt is the last node we traversed which is gt the new node. */

		if (!many)
		{
			/* Check for the 'merge' cases. */
			if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
			{
				tree[lt].high = high;
				if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
				{
					tree[lt].high = tree[gt].high;
					delete_node(cmap, gt);
				}
				goto exit;
			}
			if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
			{
				tree[gt].low = low;
				tree[gt].out = out;
				goto exit;
			}
		}
	}
	else
		current = EMPTY;

	if (cmap->tlen == cmap->tcap)
	{
		int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
		tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
		cmap->tcap = new_cap;
	}
	tree[cmap->tlen].low = low;
	tree[cmap->tlen].high = high;
	tree[cmap->tlen].out = out;
	tree[cmap->tlen].parent = current;
	tree[cmap->tlen].left = EMPTY;
	tree[cmap->tlen].right = EMPTY;
	tree[cmap->tlen].many = many;
	cmap->tlen++;
	if (current == EMPTY)
		cmap->ttop = 0;
	else if (tree[current].low > high)
		tree[current].left = cmap->tlen-1;
	else
	{
		assert(tree[current].high < low);
		tree[current].right = cmap->tlen-1;
	}
	move_to_root(tree, cmap->tlen-1);
	cmap->ttop = cmap->tlen-1;
exit:
	{}
#ifdef CHECK_SPLAY
	check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
	dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}
","The vulnerability in the original code lies in the recursive call to `add_range` where the `many` parameter was incorrectly set to `0`, potentially leading to incorrect handling of overlapping ranges. This could result in improper tree structure modifications, allowing for unintended behavior or memory corruption. In the fixed code, the `many` parameter is now passed as `tree[current].many`, ensuring that the original state of the node is preserved during the recursive call. This change prevents the mishandling of range overlaps and maintains the integrity of the splay tree structure.","The vulnerability in the original code stems from improper handling of overlapping ranges during the addition of new nodes, which could lead to incorrect tree modifications and potential memory corruption. Specifically, the recursive call to add a range did not preserve the state of the original node, risking unintended behavior. The fix involved ensuring that the original state was maintained during recursive calls, allowing for correct management of overlapping ranges. This adjustment enhances the integrity of the data structure, preventing issues related to incorrect node handling and ensuring the proper functioning of the overall algorithm."
4,177867,177867,,Remote,Not required,Partial,CVE-2018-16541,https://www.cvedetails.com/cve/CVE-2018-16541/,CWE-416,Medium,,,,2018-09-05,4.3,"In Artifex Ghostscript before 9.24, attackers able to supply crafted PostScript files could use incorrect free logic in pagedevice replacement to crash the interpreter.",2018-12-18,,10,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=241d91112771a6104de10b3948c3f350d6690c1d,241d91112771a6104de10b3948c3f350d6690c1d,,0,,,"gs_main_finit(gs_main_instance * minst, int exit_status, int code)
{
    i_ctx_t *i_ctx_p = minst->i_ctx_p;
    gs_dual_memory_t dmem = {0};
    int exit_code;
    ref error_object;
    char *tempnames;

    /* NB: need to free gs_name_table
     */

    /*
     * Previous versions of this code closed the devices in the
     * device list here.  Since these devices are now prototypes,
     * they cannot be opened, so they do not need to be closed;
     * alloc_restore_all will close dynamically allocated devices.
     */
    tempnames = gs_main_tempnames(minst);

    /* by the time we get here, we *must* avoid any random redefinitions of
     * operators etc, so we push systemdict onto the top of the dict stack.
     * We do this in C to avoid running into any other re-defininitions in the
     * Postscript world.
     */
    gs_finit_push_systemdict(i_ctx_p);

    /* We have to disable BGPrint before we call interp_reclaim() to prevent the
     * parent rendering thread initialising for the next page, whilst we are
     * removing objects it may want to access - for example, the I/O device table.
     * We also have to mess with the BeginPage/EndPage procs so that we don't
     * trigger a spurious extra page to be emitted.
     */
    if (minst->init_done >= 2) {
        gs_main_run_string(minst,
            ""/BGPrint /GetDeviceParam .special_op \
            {{ <</BeginPage {pop} /EndPage {pop pop //false } \
              /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \
              serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \
              .systemvar exec"",
            0 , &exit_code, &error_object);
    }

    /*
     * Close the ""main"" device, because it may need to write out
     * data before destruction. pdfwrite needs so.
     */
    if (minst->init_done >= 2) {
        int code = 0;

        if (idmemory->reclaim != 0) {
            code = interp_reclaim(&minst->i_ctx_p, avm_global);

            if (code < 0) {
                ref error_name;
                if (tempnames)
                    free(tempnames);

                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {
                    char err_str[32] = {0};
                    name_string_ref(imemory, &error_name, &error_name);
                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));
                    emprintf2(imemory, ""ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\n"", err_str, code);
                }
                else {
                    emprintf1(imemory, ""UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\n"", code);
                }
#ifdef MEMENTO_SQUEEZE_BUILD
                if (code != gs_error_VMerror ) return gs_error_Fatal;
#else
                return gs_error_Fatal;
#endif
            }
             i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */
         }
 
        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL &&
            gx_device_is_null(i_ctx_p->pgs->device)) {
            /* if the job replaced the device with the nulldevice, we we need to grestore
               away that device, so the block below can properly dispense
               with the default device.
             */
            int code = gs_grestoreall(i_ctx_p->pgs);
            if (code < 0) return_error(gs_error_Fatal);
        }

         if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {
             gx_device *pdev = i_ctx_p->pgs->device;
             const char * dname = pdev->dname;
            if (code < 0) {
                ref error_name;
                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {
                    char err_str[32] = {0};
                    name_string_ref(imemory, &error_name, &error_name);
                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));
                    emprintf3(imemory, ""ERROR: %s (%d) on closing %s device.\n"", err_str, code, dname);
                }
                else {
                    emprintf2(imemory, ""UNKNOWN ERROR %d closing %s device.\n"", code, dname);
               }
            }
            rc_decrement(pdev, ""gs_main_finit"");                /* device might be freed */
            if (exit_status == 0 || exit_status == gs_error_Quit)
                exit_status = code;
        }

      /* Flush stdout and stderr */
      gs_main_run_string(minst,
        ""(%stdout) (w) file closefile (%stderr) (w) file closefile \
        serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \
          systemdict /savedinitialgstate .forceundef"",
        0 , &exit_code, &error_object);
    }
    gp_readline_finit(minst->readline_data);
    i_ctx_p = minst->i_ctx_p;		/* get current interp context */
    if (gs_debug_c(':')) {
        print_resource_usage(minst, &gs_imemory, ""Final"");
        dmprintf1(minst->heap, ""%% Exiting instance 0x%p\n"", minst);
    }
    /* Do the equivalent of a restore ""past the bottom"". */
    /* This will release all memory, close all open files, etc. */
    if (minst->init_done >= 1) {
        gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory;
        i_plugin_holder *h = i_ctx_p->plugin_list;

        dmem = *idmemory;
        code = alloc_restore_all(i_ctx_p);
        if (code < 0)
            emprintf1(mem_raw,
                      ""ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\n"",
                      code);
        i_iodev_finit(&dmem);
        i_plugin_finit(mem_raw, h);
    }

    /* clean up redirected stdout */
    if (minst->heap->gs_lib_ctx->fstdout2
        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstdout)
        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstderr)) {
        fclose(minst->heap->gs_lib_ctx->fstdout2);
        minst->heap->gs_lib_ctx->fstdout2 = (FILE *)NULL;
    }

    minst->heap->gs_lib_ctx->stdout_is_redirected = 0;
    minst->heap->gs_lib_ctx->stdout_to_stderr = 0;
    /* remove any temporary files, after ghostscript has closed files */
    if (tempnames) {
        char *p = tempnames;
        while (*p) {
            unlink(p);
            p += strlen(p) + 1;
        }
        free(tempnames);
    }
    gs_lib_finit(exit_status, code, minst->heap);

    gs_free_object(minst->heap, minst->lib_path.container.value.refs, ""lib_path array"");
    ialloc_finit(&dmem);
    return exit_status;
}
","gs_main_finit(gs_main_instance * minst, int exit_status, int code)
{
    i_ctx_t *i_ctx_p = minst->i_ctx_p;
    gs_dual_memory_t dmem = {0};
    int exit_code;
    ref error_object;
    char *tempnames;

    /* NB: need to free gs_name_table
     */

    /*
     * Previous versions of this code closed the devices in the
     * device list here.  Since these devices are now prototypes,
     * they cannot be opened, so they do not need to be closed;
     * alloc_restore_all will close dynamically allocated devices.
     */
    tempnames = gs_main_tempnames(minst);

    /* by the time we get here, we *must* avoid any random redefinitions of
     * operators etc, so we push systemdict onto the top of the dict stack.
     * We do this in C to avoid running into any other re-defininitions in the
     * Postscript world.
     */
    gs_finit_push_systemdict(i_ctx_p);

    /* We have to disable BGPrint before we call interp_reclaim() to prevent the
     * parent rendering thread initialising for the next page, whilst we are
     * removing objects it may want to access - for example, the I/O device table.
     * We also have to mess with the BeginPage/EndPage procs so that we don't
     * trigger a spurious extra page to be emitted.
     */
    if (minst->init_done >= 2) {
        gs_main_run_string(minst,
            ""/BGPrint /GetDeviceParam .special_op \
            {{ <</BeginPage {pop} /EndPage {pop pop //false } \
              /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \
              serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \
              .systemvar exec"",
            0 , &exit_code, &error_object);
    }

    /*
     * Close the ""main"" device, because it may need to write out
     * data before destruction. pdfwrite needs so.
     */
    if (minst->init_done >= 2) {
        int code = 0;

        if (idmemory->reclaim != 0) {
            code = interp_reclaim(&minst->i_ctx_p, avm_global);

            if (code < 0) {
                ref error_name;
                if (tempnames)
                    free(tempnames);

                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {
                    char err_str[32] = {0};
                    name_string_ref(imemory, &error_name, &error_name);
                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));
                    emprintf2(imemory, ""ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\n"", err_str, code);
                }
                else {
                    emprintf1(imemory, ""UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\n"", code);
                }
#ifdef MEMENTO_SQUEEZE_BUILD
                if (code != gs_error_VMerror ) return gs_error_Fatal;
#else
                return gs_error_Fatal;
#endif
            }
             i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */
         }
 
         if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {
             gx_device *pdev = i_ctx_p->pgs->device;
             const char * dname = pdev->dname;
            if (code < 0) {
                ref error_name;
                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {
                    char err_str[32] = {0};
                    name_string_ref(imemory, &error_name, &error_name);
                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));
                    emprintf3(imemory, ""ERROR: %s (%d) on closing %s device.\n"", err_str, code, dname);
                }
                else {
                    emprintf2(imemory, ""UNKNOWN ERROR %d closing %s device.\n"", code, dname);
               }
            }
            rc_decrement(pdev, ""gs_main_finit"");                /* device might be freed */
            if (exit_status == 0 || exit_status == gs_error_Quit)
                exit_status = code;
        }

      /* Flush stdout and stderr */
      gs_main_run_string(minst,
        ""(%stdout) (w) file closefile (%stderr) (w) file closefile \
        serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \
          systemdict /savedinitialgstate .forceundef"",
        0 , &exit_code, &error_object);
    }
    gp_readline_finit(minst->readline_data);
    i_ctx_p = minst->i_ctx_p;		/* get current interp context */
    if (gs_debug_c(':')) {
        print_resource_usage(minst, &gs_imemory, ""Final"");
        dmprintf1(minst->heap, ""%% Exiting instance 0x%p\n"", minst);
    }
    /* Do the equivalent of a restore ""past the bottom"". */
    /* This will release all memory, close all open files, etc. */
    if (minst->init_done >= 1) {
        gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory;
        i_plugin_holder *h = i_ctx_p->plugin_list;

        dmem = *idmemory;
        code = alloc_restore_all(i_ctx_p);
        if (code < 0)
            emprintf1(mem_raw,
                      ""ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\n"",
                      code);
        i_iodev_finit(&dmem);
        i_plugin_finit(mem_raw, h);
    }

    /* clean up redirected stdout */
    if (minst->heap->gs_lib_ctx->fstdout2
        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstdout)
        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstderr)) {
        fclose(minst->heap->gs_lib_ctx->fstdout2);
        minst->heap->gs_lib_ctx->fstdout2 = (FILE *)NULL;
    }

    minst->heap->gs_lib_ctx->stdout_is_redirected = 0;
    minst->heap->gs_lib_ctx->stdout_to_stderr = 0;
    /* remove any temporary files, after ghostscript has closed files */
    if (tempnames) {
        char *p = tempnames;
        while (*p) {
            unlink(p);
            p += strlen(p) + 1;
        }
        free(tempnames);
    }
    gs_lib_finit(exit_status, code, minst->heap);

    gs_free_object(minst->heap, minst->lib_path.container.value.refs, ""lib_path array"");
    ialloc_finit(&dmem);
    return exit_status;
}
",C,"        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL &&
            gx_device_is_null(i_ctx_p->pgs->device)) {
            /* if the job replaced the device with the nulldevice, we we need to grestore
               away that device, so the block below can properly dispense
               with the default device.
             */
            int code = gs_grestoreall(i_ctx_p->pgs);
            if (code < 0) return_error(gs_error_Fatal);
        }

",,c432131c3fdb2143e148e8ba88555f7f7a63b25e,"@@ -936,6 +936,16 @@ gs_main_finit(gs_main_instance * minst, int exit_status, int code)
             i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */
         }
 
+        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL &&
+            gx_device_is_null(i_ctx_p->pgs->device)) {
+            /* if the job replaced the device with the nulldevice, we we need to grestore
+               away that device, so the block below can properly dispense
+               with the default device.
+             */
+            int code = gs_grestoreall(i_ctx_p->pgs);
+            if (code < 0) return_error(gs_error_Fatal);
+        }
+
         if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {
             gx_device *pdev = i_ctx_p->pgs->device;
             const char * dname = pdev->dname;",ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/imain.c;h=138bfc82b0accdad0772ad82bcf8fce51eba782d;hb=138bfc82b0accdad0772ad82bcf8fce51eba782d,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/imain.c;h=2fe15465ebadc9f0219c25e7a47faf51f94f226f;hb=2fe15465ebadc9f0219c25e7a47faf51f94f226f,1,"gs_main_finit(gs_main_instance * minst, int exit_status, int code)
{
    i_ctx_t *i_ctx_p = minst->i_ctx_p;
    gs_dual_memory_t dmem = {0};
    int exit_code;
    ref error_object;
    char *tempnames;

    /* NB: need to free gs_name_table
     */

    /*
     * Previous versions of this code closed the devices in the
     * device list here.  Since these devices are now prototypes,
     * they cannot be opened, so they do not need to be closed;
     * alloc_restore_all will close dynamically allocated devices.
     */
    tempnames = gs_main_tempnames(minst);

    /* by the time we get here, we *must* avoid any random redefinitions of
     * operators etc, so we push systemdict onto the top of the dict stack.
     * We do this in C to avoid running into any other re-defininitions in the
     * Postscript world.
     */
    gs_finit_push_systemdict(i_ctx_p);

    /* We have to disable BGPrint before we call interp_reclaim() to prevent the
     * parent rendering thread initialising for the next page, whilst we are
     * removing objects it may want to access - for example, the I/O device table.
     * We also have to mess with the BeginPage/EndPage procs so that we don't
     * trigger a spurious extra page to be emitted.
     */
    if (minst->init_done >= 2) {
        gs_main_run_string(minst,
            ""/BGPrint /GetDeviceParam .special_op \
            {{ <</BeginPage {pop} /EndPage {pop pop //false } \
              /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \
              serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \
              .systemvar exec"",
            0 , &exit_code, &error_object);
    }

    /*
     * Close the ""main"" device, because it may need to write out
     * data before destruction. pdfwrite needs so.
     */
    if (minst->init_done >= 2) {
        int code = 0;

        if (idmemory->reclaim != 0) {
            code = interp_reclaim(&minst->i_ctx_p, avm_global);

            if (code < 0) {
                ref error_name;
                if (tempnames)
                    free(tempnames);

                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {
                    char err_str[32] = {0};
                    name_string_ref(imemory, &error_name, &error_name);
                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));
                    emprintf2(imemory, ""ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\n"", err_str, code);
                }
                else {
                    emprintf1(imemory, ""UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\n"", code);
                }
#ifdef MEMENTO_SQUEEZE_BUILD
                if (code != gs_error_VMerror ) return gs_error_Fatal;
#else
                return gs_error_Fatal;
#endif
            }
             i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */
         }
 
//fix_flaw_line_below:
//        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL &&
//fix_flaw_line_below:
//            gx_device_is_null(i_ctx_p->pgs->device)) {
//fix_flaw_line_below:
//            /* if the job replaced the device with the nulldevice, we we need to grestore
//fix_flaw_line_below:
//               away that device, so the block below can properly dispense
//fix_flaw_line_below:
//               with the default device.
//fix_flaw_line_below:
//             */
//fix_flaw_line_below:
//            int code = gs_grestoreall(i_ctx_p->pgs);
//fix_flaw_line_below:
//            if (code < 0) return_error(gs_error_Fatal);
//fix_flaw_line_below:
//        }
//fix_flaw_line_below:
//
         if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {
             gx_device *pdev = i_ctx_p->pgs->device;
             const char * dname = pdev->dname;
            if (code < 0) {
                ref error_name;
                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {
                    char err_str[32] = {0};
                    name_string_ref(imemory, &error_name, &error_name);
                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));
                    emprintf3(imemory, ""ERROR: %s (%d) on closing %s device.\n"", err_str, code, dname);
                }
                else {
                    emprintf2(imemory, ""UNKNOWN ERROR %d closing %s device.\n"", code, dname);
               }
            }
            rc_decrement(pdev, ""gs_main_finit"");                /* device might be freed */
            if (exit_status == 0 || exit_status == gs_error_Quit)
                exit_status = code;
        }

      /* Flush stdout and stderr */
      gs_main_run_string(minst,
        ""(%stdout) (w) file closefile (%stderr) (w) file closefile \
        serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \
          systemdict /savedinitialgstate .forceundef"",
        0 , &exit_code, &error_object);
    }
    gp_readline_finit(minst->readline_data);
    i_ctx_p = minst->i_ctx_p;		/* get current interp context */
    if (gs_debug_c(':')) {
        print_resource_usage(minst, &gs_imemory, ""Final"");
        dmprintf1(minst->heap, ""%% Exiting instance 0x%p\n"", minst);
    }
    /* Do the equivalent of a restore ""past the bottom"". */
    /* This will release all memory, close all open files, etc. */
    if (minst->init_done >= 1) {
        gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory;
        i_plugin_holder *h = i_ctx_p->plugin_list;

        dmem = *idmemory;
        code = alloc_restore_all(i_ctx_p);
        if (code < 0)
            emprintf1(mem_raw,
                      ""ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\n"",
                      code);
        i_iodev_finit(&dmem);
        i_plugin_finit(mem_raw, h);
    }

    /* clean up redirected stdout */
    if (minst->heap->gs_lib_ctx->fstdout2
        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstdout)
        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstderr)) {
        fclose(minst->heap->gs_lib_ctx->fstdout2);
        minst->heap->gs_lib_ctx->fstdout2 = (FILE *)NULL;
    }

    minst->heap->gs_lib_ctx->stdout_is_redirected = 0;
    minst->heap->gs_lib_ctx->stdout_to_stderr = 0;
    /* remove any temporary files, after ghostscript has closed files */
    if (tempnames) {
        char *p = tempnames;
        while (*p) {
            unlink(p);
            p += strlen(p) + 1;
        }
        free(tempnames);
    }
    gs_lib_finit(exit_status, code, minst->heap);

    gs_free_object(minst->heap, minst->lib_path.container.value.refs, ""lib_path array"");
    ialloc_finit(&dmem);
    return exit_status;
}
",177867,"gs_main_finit(gs_main_instance * minst, int exit_status, int code)
{
    i_ctx_t *i_ctx_p = minst->i_ctx_p;
    gs_dual_memory_t dmem = {0};
    int exit_code;
    ref error_object;
    char *tempnames;

    /* NB: need to free gs_name_table
     */

    /*
     * Previous versions of this code closed the devices in the
     * device list here.  Since these devices are now prototypes,
     * they cannot be opened, so they do not need to be closed;
     * alloc_restore_all will close dynamically allocated devices.
     */
    tempnames = gs_main_tempnames(minst);

    /* by the time we get here, we *must* avoid any random redefinitions of
     * operators etc, so we push systemdict onto the top of the dict stack.
     * We do this in C to avoid running into any other re-defininitions in the
     * Postscript world.
     */
    gs_finit_push_systemdict(i_ctx_p);

    /* We have to disable BGPrint before we call interp_reclaim() to prevent the
     * parent rendering thread initialising for the next page, whilst we are
     * removing objects it may want to access - for example, the I/O device table.
     * We also have to mess with the BeginPage/EndPage procs so that we don't
     * trigger a spurious extra page to be emitted.
     */
    if (minst->init_done >= 2) {
        gs_main_run_string(minst,
            ""/BGPrint /GetDeviceParam .special_op \
            {{ <</BeginPage {pop} /EndPage {pop pop //false } \
              /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \
              serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \
              .systemvar exec"",
            0 , &exit_code, &error_object);
    }

    /*
     * Close the ""main"" device, because it may need to write out
     * data before destruction. pdfwrite needs so.
     */
    if (minst->init_done >= 2) {
        int code = 0;

        if (idmemory->reclaim != 0) {
            code = interp_reclaim(&minst->i_ctx_p, avm_global);

            if (code < 0) {
                ref error_name;
                if (tempnames)
                    free(tempnames);

                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {
                    char err_str[32] = {0};
                    name_string_ref(imemory, &error_name, &error_name);
                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));
                    emprintf2(imemory, ""ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\n"", err_str, code);
                }
                else {
                    emprintf1(imemory, ""UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\n"", code);
                }
#ifdef MEMENTO_SQUEEZE_BUILD
                if (code != gs_error_VMerror ) return gs_error_Fatal;
#else
                return gs_error_Fatal;
#endif
            }
             i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */
         }
 
         if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {
             gx_device *pdev = i_ctx_p->pgs->device;
             const char * dname = pdev->dname;
            if (code < 0) {
                ref error_name;
                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {
                    char err_str[32] = {0};
                    name_string_ref(imemory, &error_name, &error_name);
                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));
                    emprintf3(imemory, ""ERROR: %s (%d) on closing %s device.\n"", err_str, code, dname);
                }
                else {
                    emprintf2(imemory, ""UNKNOWN ERROR %d closing %s device.\n"", code, dname);
               }
            }
            rc_decrement(pdev, ""gs_main_finit"");                /* device might be freed */
            if (exit_status == 0 || exit_status == gs_error_Quit)
                exit_status = code;
        }

      /* Flush stdout and stderr */
      gs_main_run_string(minst,
        ""(%stdout) (w) file closefile (%stderr) (w) file closefile \
        serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \
          systemdict /savedinitialgstate .forceundef"",
        0 , &exit_code, &error_object);
    }
    gp_readline_finit(minst->readline_data);
    i_ctx_p = minst->i_ctx_p;		/* get current interp context */
    if (gs_debug_c(':')) {
        print_resource_usage(minst, &gs_imemory, ""Final"");
        dmprintf1(minst->heap, ""%% Exiting instance 0x%p\n"", minst);
    }
    /* Do the equivalent of a restore ""past the bottom"". */
    /* This will release all memory, close all open files, etc. */
    if (minst->init_done >= 1) {
        gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory;
        i_plugin_holder *h = i_ctx_p->plugin_list;

        dmem = *idmemory;
        code = alloc_restore_all(i_ctx_p);
        if (code < 0)
            emprintf1(mem_raw,
                      ""ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\n"",
                      code);
        i_iodev_finit(&dmem);
        i_plugin_finit(mem_raw, h);
    }

    /* clean up redirected stdout */
    if (minst->heap->gs_lib_ctx->fstdout2
        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstdout)
        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstderr)) {
        fclose(minst->heap->gs_lib_ctx->fstdout2);
        minst->heap->gs_lib_ctx->fstdout2 = (FILE *)NULL;
    }

    minst->heap->gs_lib_ctx->stdout_is_redirected = 0;
    minst->heap->gs_lib_ctx->stdout_to_stderr = 0;
    /* remove any temporary files, after ghostscript has closed files */
    if (tempnames) {
        char *p = tempnames;
        while (*p) {
            unlink(p);
            p += strlen(p) + 1;
        }
        free(tempnames);
    }
    gs_lib_finit(exit_status, code, minst->heap);

    gs_free_object(minst->heap, minst->lib_path.container.value.refs, ""lib_path array"");
    ialloc_finit(&dmem);
    return exit_status;
}
","gs_main_finit(gs_main_instance * minst, int exit_status, int code)
{
    i_ctx_t *i_ctx_p = minst->i_ctx_p;
    gs_dual_memory_t dmem = {0};
    int exit_code;
    ref error_object;
    char *tempnames;

    /* NB: need to free gs_name_table
     */

    /*
     * Previous versions of this code closed the devices in the
     * device list here.  Since these devices are now prototypes,
     * they cannot be opened, so they do not need to be closed;
     * alloc_restore_all will close dynamically allocated devices.
     */
    tempnames = gs_main_tempnames(minst);

    /* by the time we get here, we *must* avoid any random redefinitions of
     * operators etc, so we push systemdict onto the top of the dict stack.
     * We do this in C to avoid running into any other re-defininitions in the
     * Postscript world.
     */
    gs_finit_push_systemdict(i_ctx_p);

    /* We have to disable BGPrint before we call interp_reclaim() to prevent the
     * parent rendering thread initialising for the next page, whilst we are
     * removing objects it may want to access - for example, the I/O device table.
     * We also have to mess with the BeginPage/EndPage procs so that we don't
     * trigger a spurious extra page to be emitted.
     */
    if (minst->init_done >= 2) {
        gs_main_run_string(minst,
            ""/BGPrint /GetDeviceParam .special_op \
            {{ <</BeginPage {pop} /EndPage {pop pop //false } \
              /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \
              serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \
              .systemvar exec"",
            0 , &exit_code, &error_object);
    }

    /*
     * Close the ""main"" device, because it may need to write out
     * data before destruction. pdfwrite needs so.
     */
    if (minst->init_done >= 2) {
        int code = 0;

        if (idmemory->reclaim != 0) {
            code = interp_reclaim(&minst->i_ctx_p, avm_global);

            if (code < 0) {
                ref error_name;
                if (tempnames)
                    free(tempnames);

                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {
                    char err_str[32] = {0};
                    name_string_ref(imemory, &error_name, &error_name);
                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));
                    emprintf2(imemory, ""ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\n"", err_str, code);
                }
                else {
                    emprintf1(imemory, ""UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\n"", code);
                }
#ifdef MEMENTO_SQUEEZE_BUILD
                if (code != gs_error_VMerror ) return gs_error_Fatal;
#else
                return gs_error_Fatal;
#endif
            }
             i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */
         }
 
        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL &&
            gx_device_is_null(i_ctx_p->pgs->device)) {
            /* if the job replaced the device with the nulldevice, we we need to grestore
               away that device, so the block below can properly dispense
               with the default device.
             */
            int code = gs_grestoreall(i_ctx_p->pgs);
            if (code < 0) return_error(gs_error_Fatal);
        }

         if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {
             gx_device *pdev = i_ctx_p->pgs->device;
             const char * dname = pdev->dname;
            if (code < 0) {
                ref error_name;
                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {
                    char err_str[32] = {0};
                    name_string_ref(imemory, &error_name, &error_name);
                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));
                    emprintf3(imemory, ""ERROR: %s (%d) on closing %s device.\n"", err_str, code, dname);
                }
                else {
                    emprintf2(imemory, ""UNKNOWN ERROR %d closing %s device.\n"", code, dname);
               }
            }
            rc_decrement(pdev, ""gs_main_finit"");                /* device might be freed */
            if (exit_status == 0 || exit_status == gs_error_Quit)
                exit_status = code;
        }

      /* Flush stdout and stderr */
      gs_main_run_string(minst,
        ""(%stdout) (w) file closefile (%stderr) (w) file closefile \
        serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \
          systemdict /savedinitialgstate .forceundef"",
        0 , &exit_code, &error_object);
    }
    gp_readline_finit(minst->readline_data);
    i_ctx_p = minst->i_ctx_p;		/* get current interp context */
    if (gs_debug_c(':')) {
        print_resource_usage(minst, &gs_imemory, ""Final"");
        dmprintf1(minst->heap, ""%% Exiting instance 0x%p\n"", minst);
    }
    /* Do the equivalent of a restore ""past the bottom"". */
    /* This will release all memory, close all open files, etc. */
    if (minst->init_done >= 1) {
        gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory;
        i_plugin_holder *h = i_ctx_p->plugin_list;

        dmem = *idmemory;
        code = alloc_restore_all(i_ctx_p);
        if (code < 0)
            emprintf1(mem_raw,
                      ""ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\n"",
                      code);
        i_iodev_finit(&dmem);
        i_plugin_finit(mem_raw, h);
    }

    /* clean up redirected stdout */
    if (minst->heap->gs_lib_ctx->fstdout2
        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstdout)
        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstderr)) {
        fclose(minst->heap->gs_lib_ctx->fstdout2);
        minst->heap->gs_lib_ctx->fstdout2 = (FILE *)NULL;
    }

    minst->heap->gs_lib_ctx->stdout_is_redirected = 0;
    minst->heap->gs_lib_ctx->stdout_to_stderr = 0;
    /* remove any temporary files, after ghostscript has closed files */
    if (tempnames) {
        char *p = tempnames;
        while (*p) {
            unlink(p);
            p += strlen(p) + 1;
        }
        free(tempnames);
    }
    gs_lib_finit(exit_status, code, minst->heap);

    gs_free_object(minst->heap, minst->lib_path.container.value.refs, ""lib_path array"");
    ialloc_finit(&dmem);
    return exit_status;
}
","The vulnerability in the original code lies in the handling of the device context, specifically when closing devices. The code checks if `i_ctx_p->pgs->device` is not NULL but does not verify if it is a valid device, which could lead to dereferencing a NULL or invalid pointer, potentially causing a crash or undefined behavior. The fix introduces a check using `gx_device_is_null(i_ctx_p->pgs->device)` to ensure that if the device has been replaced with a null device, it properly calls `gs_grestoreall(i_ctx_p->pgs)` to restore the context before proceeding, thus preventing potential memory access violations.","The vulnerability in the original code arises from inadequate checks on the device context, which could lead to dereferencing a NULL or invalid pointer when attempting to close devices. This oversight may result in crashes or undefined behavior during execution. The fix addresses this issue by introducing a validation step to ensure that the device context is not only present but also valid before any operations are performed. This additional check prevents potential memory access violations, thereby enhancing the stability and reliability of the code during the finalization process."
5,178125,178125,,Local,Not required,Partial,CVE-2016-6833,https://www.cvedetails.com/cve/CVE-2016-6833/,CWE-416,Low,,,,2016-12-09,2.1,Use-after-free vulnerability in the vmxnet3_io_bar0_write function in hw/net/vmxnet3.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (QEMU instance crash) by leveraging failure to check if the device is active.,2018-09-07,DoS,4,https://git.qemu.org/?p=qemu.git;a=commit;h=6c352ca9b4ee3e1e286ea9e8434bd8e69ac7d0d8,6c352ca9b4ee3e1e286ea9e8434bd8e69ac7d0d8,,0,,,"vmxnet3_io_bar0_write(void *opaque, hwaddr addr,
                      uint64_t val, unsigned size)
 {
     VMXNET3State *s = opaque;
 
    if (!s->device_active) {
        return;
    }

     if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_TXPROD,
                         VMXNET3_DEVICE_MAX_TX_QUEUES, VMXNET3_REG_ALIGN)) {
         int tx_queue_idx =
        return;
    }

    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,
                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {
        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,
                                         VMXNET3_REG_ALIGN);

        VMW_CBPRN(""Interrupt mask for line %d written: 0x%"" PRIx64, l, val);

        vmxnet3_on_interrupt_mask_changed(s, l, val);
        return;
    }

    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD,
                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN) ||
       VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD2,
                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN)) {
        return;
    }

    VMW_WRPRN(""BAR0 unknown write [%"" PRIx64 ""] = %"" PRIx64 "", size %d"",
              (uint64_t) addr, val, size);
}
","vmxnet3_io_bar0_write(void *opaque, hwaddr addr,
                      uint64_t val, unsigned size)
 {
     VMXNET3State *s = opaque;
 
     if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_TXPROD,
                         VMXNET3_DEVICE_MAX_TX_QUEUES, VMXNET3_REG_ALIGN)) {
         int tx_queue_idx =
        return;
    }

    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,
                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {
        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,
                                         VMXNET3_REG_ALIGN);

        VMW_CBPRN(""Interrupt mask for line %d written: 0x%"" PRIx64, l, val);

        vmxnet3_on_interrupt_mask_changed(s, l, val);
        return;
    }

    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD,
                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN) ||
       VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD2,
                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN)) {
        return;
    }

    VMW_WRPRN(""BAR0 unknown write [%"" PRIx64 ""] = %"" PRIx64 "", size %d"",
              (uint64_t) addr, val, size);
}
",C,"    if (!s->device_active) {
        return;
    }

",,ead315e43ea0c2ca3491209c6c8db8ce3f2bbe05,"@@ -1167,6 +1167,10 @@ vmxnet3_io_bar0_write(void *opaque, hwaddr addr,
 {
     VMXNET3State *s = opaque;
 
+    if (!s->device_active) {
+        return;
+    }
+
     if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_TXPROD,
                         VMXNET3_DEVICE_MAX_TX_QUEUES, VMXNET3_REG_ALIGN)) {
         int tx_queue_idx =",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/net/vmxnet3.c;h=90f69436687167907a4e927e1429702c543ec2d2;hb=90f69436687167907a4e927e1429702c543ec2d2,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/net/vmxnet3.c;h=bbf44adbcc54fb5ba0c041a259e06978116397b1;hb=bbf44adbcc54fb5ba0c041a259e06978116397b1,1,"vmxnet3_io_bar0_write(void *opaque, hwaddr addr,
                      uint64_t val, unsigned size)
 {
     VMXNET3State *s = opaque;
 
//fix_flaw_line_below:
//    if (!s->device_active) {
//fix_flaw_line_below:
//        return;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_TXPROD,
                         VMXNET3_DEVICE_MAX_TX_QUEUES, VMXNET3_REG_ALIGN)) {
         int tx_queue_idx =
        return;
    }

    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,
                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {
        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,
                                         VMXNET3_REG_ALIGN);

        VMW_CBPRN(""Interrupt mask for line %d written: 0x%"" PRIx64, l, val);

        vmxnet3_on_interrupt_mask_changed(s, l, val);
        return;
    }

    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD,
                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN) ||
       VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD2,
                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN)) {
        return;
    }

    VMW_WRPRN(""BAR0 unknown write [%"" PRIx64 ""] = %"" PRIx64 "", size %d"",
              (uint64_t) addr, val, size);
}
",178125,"vmxnet3_io_bar0_write(void *opaque, hwaddr addr,
                      uint64_t val, unsigned size)
 {
     VMXNET3State *s = opaque;
 
     if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_TXPROD,
                         VMXNET3_DEVICE_MAX_TX_QUEUES, VMXNET3_REG_ALIGN)) {
         int tx_queue_idx =
        return;
    }

    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,
                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {
        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,
                                         VMXNET3_REG_ALIGN);

        VMW_CBPRN(""Interrupt mask for line %d written: 0x%"" PRIx64, l, val);

        vmxnet3_on_interrupt_mask_changed(s, l, val);
        return;
    }

    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD,
                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN) ||
       VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD2,
                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN)) {
        return;
    }

    VMW_WRPRN(""BAR0 unknown write [%"" PRIx64 ""] = %"" PRIx64 "", size %d"",
              (uint64_t) addr, val, size);
}
","vmxnet3_io_bar0_write(void *opaque, hwaddr addr,
                      uint64_t val, unsigned size)
 {
     VMXNET3State *s = opaque;
 
    if (!s->device_active) {
        return;
    }

     if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_TXPROD,
                         VMXNET3_DEVICE_MAX_TX_QUEUES, VMXNET3_REG_ALIGN)) {
         int tx_queue_idx =
        return;
    }

    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,
                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {
        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,
                                         VMXNET3_REG_ALIGN);

        VMW_CBPRN(""Interrupt mask for line %d written: 0x%"" PRIx64, l, val);

        vmxnet3_on_interrupt_mask_changed(s, l, val);
        return;
    }

    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD,
                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN) ||
       VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD2,
                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN)) {
        return;
    }

    VMW_WRPRN(""BAR0 unknown write [%"" PRIx64 ""] = %"" PRIx64 "", size %d"",
              (uint64_t) addr, val, size);
}
","The vulnerability in the original code lies in the lack of a check for the device's active state before processing write operations. This oversight allows unauthorized writes to occur when the device is inactive, potentially leading to undefined behavior or security issues. The fix in the modified code introduces a conditional check (`if (!s->device_active)`) at the beginning of the function, which ensures that any write operations are only executed if the device is active. This prevents unintended writes and enhances the overall robustness and security of the `vmxnet3_io_bar0_write` function.","The vulnerability in the original code stems from the absence of a check to verify whether the device is active before processing write operations. This oversight allows for potential unauthorized writes when the device is inactive, which could lead to unpredictable behavior or security risks. The modified code addresses this issue by introducing a conditional check at the beginning of the function to ensure that write operations are only executed if the device is confirmed to be active. This enhancement effectively prevents unintended writes and improves the overall security and stability of the function."
6,178153,178153,,Remote,Not required,Partial,CVE-2016-6290,https://www.cvedetails.com/cve/CVE-2016-6290/,CWE-416,Low,Partial,Partial,,2016-07-25,7.5,"ext/session/session.c in PHP before 5.5.38, 5.6.x before 5.6.24, and 7.x before 7.0.9 does not properly maintain a certain hash data structure, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via vectors related to session deserialization.",2018-01-04,DoS,1,https://git.php.net/?p=php-src.git;a=commit;h=3798eb6fd5dddb211b01d41495072fd9858d4e32,3798eb6fd5dddb211b01d41495072fd9858d4e32,,0,,,"PS_SERIALIZER_DECODE_FUNC(php_binary) /* {{{ */
{
	const char *p;
	char *name;
	const char *endptr = val + vallen;
	zval *current;
	int namelen;
	int has_value;
	php_unserialize_data_t var_hash;

	PHP_VAR_UNSERIALIZE_INIT(var_hash);

	for (p = val; p < endptr; ) {
		zval **tmp;
                namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);
 
                if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {
                       PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
                        return FAILURE;
                }

		name = estrndup(p + 1, namelen);

		p += namelen + 1;

		if (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {
			if ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {
				efree(name);
				continue;
			}
		}

		if (has_value) {
			ALLOC_INIT_ZVAL(current);
			if (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {
				php_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);
			} else {
				PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
				return FAILURE;
			}
			var_push_dtor_no_addref(&var_hash, &current);
		}
		PS_ADD_VARL(name, namelen);
		efree(name);
	}

	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);

	return SUCCESS;
}
/* }}} */
","PS_SERIALIZER_DECODE_FUNC(php_binary) /* {{{ */
{
	const char *p;
	char *name;
	const char *endptr = val + vallen;
	zval *current;
	int namelen;
	int has_value;
	php_unserialize_data_t var_hash;

	PHP_VAR_UNSERIALIZE_INIT(var_hash);

	for (p = val; p < endptr; ) {
		zval **tmp;
                namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);
 
                if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {
                        return FAILURE;
                }

		name = estrndup(p + 1, namelen);

		p += namelen + 1;

		if (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {
			if ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {
				efree(name);
				continue;
			}
		}

		if (has_value) {
			ALLOC_INIT_ZVAL(current);
			if (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {
				php_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);
			} else {
				PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
				return FAILURE;
			}
			var_push_dtor_no_addref(&var_hash, &current);
		}
		PS_ADD_VARL(name, namelen);
		efree(name);
	}

	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);

	return SUCCESS;
}
/* }}} */
",C,"                       PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
",,aa82e99ed8003c01f1ef4f0940e56b85c5b032d4,"@@ -866,7 +866,7 @@ PS_SERIALIZER_DECODE_FUNC(php_serialize) /* {{{ */
        if (php_var_unserialize(&session_vars, &val, endptr, &var_hash TSRMLS_CC)) {
                var_push_dtor(&var_hash, &session_vars);
        }
-       
+
        PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
        if (PS(http_session_vars)) {
                zval_ptr_dtor(&PS(http_session_vars));
@@ -931,6 +931,7 @@ PS_SERIALIZER_DECODE_FUNC(php_binary) /* {{{ */
                namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);
 
                if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {
+                       PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
                        return FAILURE;
                }",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/session/session.c;h=cb6cc01f219c12922f4ef7f4152aa08de2745123;hb=3798eb6fd5dddb211b01d41495072fd9858d4e32,https://git.php.net/?p=php-src.git;a=blob;f=ext/session/session.c;h=f5439ea79c5b94b9c68adf8a1c5a77e8c318cf24,1,"PS_SERIALIZER_DECODE_FUNC(php_binary) /* {{{ */
{
	const char *p;
	char *name;
	const char *endptr = val + vallen;
	zval *current;
	int namelen;
	int has_value;
	php_unserialize_data_t var_hash;

	PHP_VAR_UNSERIALIZE_INIT(var_hash);

	for (p = val; p < endptr; ) {
		zval **tmp;
                namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);
 
                if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {
//fix_flaw_line_below:
//                       PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
                        return FAILURE;
                }

		name = estrndup(p + 1, namelen);

		p += namelen + 1;

		if (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {
			if ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {
				efree(name);
				continue;
			}
		}

		if (has_value) {
			ALLOC_INIT_ZVAL(current);
			if (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {
				php_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);
			} else {
				PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
				return FAILURE;
			}
			var_push_dtor_no_addref(&var_hash, &current);
		}
		PS_ADD_VARL(name, namelen);
		efree(name);
	}

	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);

	return SUCCESS;
}
/* }}} */
",178153,"PS_SERIALIZER_DECODE_FUNC(php_binary) /* {{{ */
{
	const char *p;
	char *name;
	const char *endptr = val + vallen;
	zval *current;
	int namelen;
	int has_value;
	php_unserialize_data_t var_hash;

	PHP_VAR_UNSERIALIZE_INIT(var_hash);

	for (p = val; p < endptr; ) {
		zval **tmp;
                namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);
 
                if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {
                        return FAILURE;
                }

		name = estrndup(p + 1, namelen);

		p += namelen + 1;

		if (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {
			if ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {
				efree(name);
				continue;
			}
		}

		if (has_value) {
			ALLOC_INIT_ZVAL(current);
			if (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {
				php_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);
			} else {
				PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
				return FAILURE;
			}
			var_push_dtor_no_addref(&var_hash, &current);
		}
		PS_ADD_VARL(name, namelen);
		efree(name);
	}

	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);

	return SUCCESS;
}
/* }}} */
","PS_SERIALIZER_DECODE_FUNC(php_binary) /* {{{ */
{
	const char *p;
	char *name;
	const char *endptr = val + vallen;
	zval *current;
	int namelen;
	int has_value;
	php_unserialize_data_t var_hash;

	PHP_VAR_UNSERIALIZE_INIT(var_hash);

	for (p = val; p < endptr; ) {
		zval **tmp;
                namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);
 
                if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {
                       PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
                        return FAILURE;
                }

		name = estrndup(p + 1, namelen);

		p += namelen + 1;

		if (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {
			if ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {
				efree(name);
				continue;
			}
		}

		if (has_value) {
			ALLOC_INIT_ZVAL(current);
			if (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {
				php_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);
			} else {
				PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
				return FAILURE;
			}
			var_push_dtor_no_addref(&var_hash, &current);
		}
		PS_ADD_VARL(name, namelen);
		efree(name);
	}

	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);

	return SUCCESS;
}
/* }}} */
","The vulnerability in the original code lies in the handling of the `namelen` variable, which could potentially be negative or exceed `PS_BIN_MAX`, leading to buffer overflows or memory corruption when accessing memory beyond the allocated bounds. Specifically, the check for `namelen` was insufficient, allowing the code to proceed without properly cleaning up resources. In the fixed code, the addition of `PHP_VAR_UNSERIALIZE_DESTROY(var_hash);` before returning `FAILURE` ensures that any allocated resources are properly released, preventing memory leaks and enhancing the overall stability and security of the function.","The vulnerability in the original code stems from inadequate validation of a length variable, which could lead to accessing memory outside of allocated bounds, resulting in potential buffer overflows or memory corruption. This oversight allowed the function to continue processing even when the length was invalid, risking resource leaks. The fix implemented in the revised code introduces a cleanup step that ensures all allocated resources are properly released before the function exits upon encountering an error. This change enhances the function's robustness by preventing memory leaks and improving overall stability and security."
7,179630,179630,,Local Network,Not required,,CVE-2014-0131,https://www.cvedetails.com/cve/CVE-2014-0131/,CWE-416,Medium,Partial,,,2014-03-24,2.9,Use-after-free vulnerability in the skb_segment function in net/core/skbuff.c in the Linux kernel through 3.13.6 allows attackers to obtain sensitive information from kernel memory by leveraging the absence of a certain orphaning operation.,2019-05-13,+Info ,6,https://github.com/torvalds/linux/commit/1fd819ecb90cc9b822cd84d3056ddba315d3340f,1fd819ecb90cc9b822cd84d3056ddba315d3340f,"skbuff: skb_segment: orphan frags before copying

skb_segment copies frags around, so we need
to copy them carefully to avoid accessing
user memory after reporting completion to userspace
through a callback.

skb_segment doesn't normally happen on datapath:
TSO needs to be disabled - so disabling zero copy
in this case does not look like a big deal.

Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/core/skbuff.c,"{""sha"": ""869c7afe3b070576464693e4d6ca00482c151f42"", ""filename"": ""net/core/skbuff.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/1fd819ecb90cc9b822cd84d3056ddba315d3340f/net/core/skbuff.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/1fd819ecb90cc9b822cd84d3056ddba315d3340f/net/core/skbuff.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/core/skbuff.c?ref=1fd819ecb90cc9b822cd84d3056ddba315d3340f"", ""patch"": ""@@ -2854,6 +2854,7 @@ struct sk_buff *skb_segment(struct sk_buff *head_skb,\n \tskb_frag_t *frag = skb_shinfo(head_skb)->frags;\n \tunsigned int mss = skb_shinfo(head_skb)->gso_size;\n \tunsigned int doffset = head_skb->data - skb_mac_header(head_skb);\n+\tstruct sk_buff *frag_skb = head_skb;\n \tunsigned int offset = doffset;\n \tunsigned int tnl_hlen = skb_tnl_header_len(head_skb);\n \tunsigned int headroom;\n@@ -2898,6 +2899,7 @@ struct sk_buff *skb_segment(struct sk_buff *head_skb,\n \t\t\ti = 0;\n \t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n \t\t\tfrag = skb_shinfo(list_skb)->frags;\n+\t\t\tfrag_skb = list_skb;\n \t\t\tpos += skb_headlen(list_skb);\n \n \t\t\twhile (pos < offset + len) {\n@@ -2985,6 +2987,7 @@ struct sk_buff *skb_segment(struct sk_buff *head_skb,\n \t\t\t\ti = 0;\n \t\t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n \t\t\t\tfrag = skb_shinfo(list_skb)->frags;\n+\t\t\t\tfrag_skb = list_skb;\n \n \t\t\t\tBUG_ON(!nfrags);\n \n@@ -2999,6 +3002,9 @@ struct sk_buff *skb_segment(struct sk_buff *head_skb,\n \t\t\t\tgoto err;\n \t\t\t}\n \n+\t\t\tif (unlikely(skb_orphan_frags(frag_skb, GFP_ATOMIC)))\n+\t\t\t\tgoto err;\n+\n \t\t\t*nskb_frag = *frag;\n \t\t\t__skb_frag_ref(nskb_frag);\n \t\t\tsize = skb_frag_size(nskb_frag);""}","struct sk_buff *skb_segment(struct sk_buff *head_skb,
			    netdev_features_t features)
{
	struct sk_buff *segs = NULL;
	struct sk_buff *tail = NULL;
	struct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list;
 	skb_frag_t *frag = skb_shinfo(head_skb)->frags;
 	unsigned int mss = skb_shinfo(head_skb)->gso_size;
 	unsigned int doffset = head_skb->data - skb_mac_header(head_skb);
	struct sk_buff *frag_skb = head_skb;
 	unsigned int offset = doffset;
 	unsigned int tnl_hlen = skb_tnl_header_len(head_skb);
 	unsigned int headroom;
	unsigned int len;
	__be16 proto;
	bool csum;
	int sg = !!(features & NETIF_F_SG);
	int nfrags = skb_shinfo(head_skb)->nr_frags;
	int err = -ENOMEM;
	int i = 0;
	int pos;

	proto = skb_network_protocol(head_skb);
	if (unlikely(!proto))
		return ERR_PTR(-EINVAL);

	csum = !!can_checksum_protocol(features, proto);
	__skb_push(head_skb, doffset);
	headroom = skb_headroom(head_skb);
	pos = skb_headlen(head_skb);

	do {
		struct sk_buff *nskb;
		skb_frag_t *nskb_frag;
		int hsize;
		int size;

		len = head_skb->len - offset;
		if (len > mss)
			len = mss;

		hsize = skb_headlen(head_skb) - offset;
		if (hsize < 0)
			hsize = 0;
		if (hsize > len || !sg)
			hsize = len;

		if (!hsize && i >= nfrags && skb_headlen(list_skb) &&
		    (skb_headlen(list_skb) == len || sg)) {
			BUG_ON(skb_headlen(list_skb) > len);

 			i = 0;
 			nfrags = skb_shinfo(list_skb)->nr_frags;
 			frag = skb_shinfo(list_skb)->frags;
			frag_skb = list_skb;
 			pos += skb_headlen(list_skb);
 
 			while (pos < offset + len) {
				BUG_ON(i >= nfrags);

				size = skb_frag_size(frag);
				if (pos + size > offset + len)
					break;

				i++;
				pos += size;
				frag++;
			}

			nskb = skb_clone(list_skb, GFP_ATOMIC);
			list_skb = list_skb->next;

			if (unlikely(!nskb))
				goto err;

			if (unlikely(pskb_trim(nskb, len))) {
				kfree_skb(nskb);
				goto err;
			}

			hsize = skb_end_offset(nskb);
			if (skb_cow_head(nskb, doffset + headroom)) {
				kfree_skb(nskb);
				goto err;
			}

			nskb->truesize += skb_end_offset(nskb) - hsize;
			skb_release_head_state(nskb);
			__skb_push(nskb, doffset);
		} else {
			nskb = __alloc_skb(hsize + doffset + headroom,
					   GFP_ATOMIC, skb_alloc_rx_flag(head_skb),
					   NUMA_NO_NODE);

			if (unlikely(!nskb))
				goto err;

			skb_reserve(nskb, headroom);
			__skb_put(nskb, doffset);
		}

		if (segs)
			tail->next = nskb;
		else
			segs = nskb;
		tail = nskb;

		__copy_skb_header(nskb, head_skb);
		nskb->mac_len = head_skb->mac_len;

		skb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);

		skb_copy_from_linear_data_offset(head_skb, -tnl_hlen,
						 nskb->data - tnl_hlen,
						 doffset + tnl_hlen);

		if (nskb->len == len + doffset)
			goto perform_csum_check;

		if (!sg) {
			nskb->ip_summed = CHECKSUM_NONE;
			nskb->csum = skb_copy_and_csum_bits(head_skb, offset,
							    skb_put(nskb, len),
							    len, 0);
			continue;
		}

		nskb_frag = skb_shinfo(nskb)->frags;

		skb_copy_from_linear_data_offset(head_skb, offset,
						 skb_put(nskb, hsize), hsize);

		skb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags &
			SKBTX_SHARED_FRAG;

		while (pos < offset + len) {
			if (i >= nfrags) {
				BUG_ON(skb_headlen(list_skb));

 				i = 0;
 				nfrags = skb_shinfo(list_skb)->nr_frags;
 				frag = skb_shinfo(list_skb)->frags;
				frag_skb = list_skb;
 
 				BUG_ON(!nfrags);
 
				list_skb = list_skb->next;
			}

			if (unlikely(skb_shinfo(nskb)->nr_frags >=
				     MAX_SKB_FRAGS)) {
				net_warn_ratelimited(
					""skb_segment: too many frags: %u %u\n"",
					pos, mss);
 				goto err;
 			}
 
			if (unlikely(skb_orphan_frags(frag_skb, GFP_ATOMIC)))
				goto err;

 			*nskb_frag = *frag;
 			__skb_frag_ref(nskb_frag);
 			size = skb_frag_size(nskb_frag);

			if (pos < offset) {
				nskb_frag->page_offset += offset - pos;
				skb_frag_size_sub(nskb_frag, offset - pos);
			}

			skb_shinfo(nskb)->nr_frags++;

			if (pos + size <= offset + len) {
				i++;
				frag++;
				pos += size;
			} else {
				skb_frag_size_sub(nskb_frag, pos + size - (offset + len));
				goto skip_fraglist;
			}

			nskb_frag++;
		}

skip_fraglist:
		nskb->data_len = len - hsize;
		nskb->len += nskb->data_len;
		nskb->truesize += nskb->data_len;

perform_csum_check:
		if (!csum) {
			nskb->csum = skb_checksum(nskb, doffset,
						  nskb->len - doffset, 0);
			nskb->ip_summed = CHECKSUM_NONE;
		}
	} while ((offset += len) < head_skb->len);

	return segs;

err:
	kfree_skb_list(segs);
	return ERR_PTR(err);
}
","struct sk_buff *skb_segment(struct sk_buff *head_skb,
			    netdev_features_t features)
{
	struct sk_buff *segs = NULL;
	struct sk_buff *tail = NULL;
	struct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list;
 	skb_frag_t *frag = skb_shinfo(head_skb)->frags;
 	unsigned int mss = skb_shinfo(head_skb)->gso_size;
 	unsigned int doffset = head_skb->data - skb_mac_header(head_skb);
 	unsigned int offset = doffset;
 	unsigned int tnl_hlen = skb_tnl_header_len(head_skb);
 	unsigned int headroom;
	unsigned int len;
	__be16 proto;
	bool csum;
	int sg = !!(features & NETIF_F_SG);
	int nfrags = skb_shinfo(head_skb)->nr_frags;
	int err = -ENOMEM;
	int i = 0;
	int pos;

	proto = skb_network_protocol(head_skb);
	if (unlikely(!proto))
		return ERR_PTR(-EINVAL);

	csum = !!can_checksum_protocol(features, proto);
	__skb_push(head_skb, doffset);
	headroom = skb_headroom(head_skb);
	pos = skb_headlen(head_skb);

	do {
		struct sk_buff *nskb;
		skb_frag_t *nskb_frag;
		int hsize;
		int size;

		len = head_skb->len - offset;
		if (len > mss)
			len = mss;

		hsize = skb_headlen(head_skb) - offset;
		if (hsize < 0)
			hsize = 0;
		if (hsize > len || !sg)
			hsize = len;

		if (!hsize && i >= nfrags && skb_headlen(list_skb) &&
		    (skb_headlen(list_skb) == len || sg)) {
			BUG_ON(skb_headlen(list_skb) > len);

 			i = 0;
 			nfrags = skb_shinfo(list_skb)->nr_frags;
 			frag = skb_shinfo(list_skb)->frags;
 			pos += skb_headlen(list_skb);
 
 			while (pos < offset + len) {
				BUG_ON(i >= nfrags);

				size = skb_frag_size(frag);
				if (pos + size > offset + len)
					break;

				i++;
				pos += size;
				frag++;
			}

			nskb = skb_clone(list_skb, GFP_ATOMIC);
			list_skb = list_skb->next;

			if (unlikely(!nskb))
				goto err;

			if (unlikely(pskb_trim(nskb, len))) {
				kfree_skb(nskb);
				goto err;
			}

			hsize = skb_end_offset(nskb);
			if (skb_cow_head(nskb, doffset + headroom)) {
				kfree_skb(nskb);
				goto err;
			}

			nskb->truesize += skb_end_offset(nskb) - hsize;
			skb_release_head_state(nskb);
			__skb_push(nskb, doffset);
		} else {
			nskb = __alloc_skb(hsize + doffset + headroom,
					   GFP_ATOMIC, skb_alloc_rx_flag(head_skb),
					   NUMA_NO_NODE);

			if (unlikely(!nskb))
				goto err;

			skb_reserve(nskb, headroom);
			__skb_put(nskb, doffset);
		}

		if (segs)
			tail->next = nskb;
		else
			segs = nskb;
		tail = nskb;

		__copy_skb_header(nskb, head_skb);
		nskb->mac_len = head_skb->mac_len;

		skb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);

		skb_copy_from_linear_data_offset(head_skb, -tnl_hlen,
						 nskb->data - tnl_hlen,
						 doffset + tnl_hlen);

		if (nskb->len == len + doffset)
			goto perform_csum_check;

		if (!sg) {
			nskb->ip_summed = CHECKSUM_NONE;
			nskb->csum = skb_copy_and_csum_bits(head_skb, offset,
							    skb_put(nskb, len),
							    len, 0);
			continue;
		}

		nskb_frag = skb_shinfo(nskb)->frags;

		skb_copy_from_linear_data_offset(head_skb, offset,
						 skb_put(nskb, hsize), hsize);

		skb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags &
			SKBTX_SHARED_FRAG;

		while (pos < offset + len) {
			if (i >= nfrags) {
				BUG_ON(skb_headlen(list_skb));

 				i = 0;
 				nfrags = skb_shinfo(list_skb)->nr_frags;
 				frag = skb_shinfo(list_skb)->frags;
 
 				BUG_ON(!nfrags);
 
				list_skb = list_skb->next;
			}

			if (unlikely(skb_shinfo(nskb)->nr_frags >=
				     MAX_SKB_FRAGS)) {
				net_warn_ratelimited(
					""skb_segment: too many frags: %u %u\n"",
					pos, mss);
 				goto err;
 			}
 
 			*nskb_frag = *frag;
 			__skb_frag_ref(nskb_frag);
 			size = skb_frag_size(nskb_frag);

			if (pos < offset) {
				nskb_frag->page_offset += offset - pos;
				skb_frag_size_sub(nskb_frag, offset - pos);
			}

			skb_shinfo(nskb)->nr_frags++;

			if (pos + size <= offset + len) {
				i++;
				frag++;
				pos += size;
			} else {
				skb_frag_size_sub(nskb_frag, pos + size - (offset + len));
				goto skip_fraglist;
			}

			nskb_frag++;
		}

skip_fraglist:
		nskb->data_len = len - hsize;
		nskb->len += nskb->data_len;
		nskb->truesize += nskb->data_len;

perform_csum_check:
		if (!csum) {
			nskb->csum = skb_checksum(nskb, doffset,
						  nskb->len - doffset, 0);
			nskb->ip_summed = CHECKSUM_NONE;
		}
	} while ((offset += len) < head_skb->len);

	return segs;

err:
	kfree_skb_list(segs);
	return ERR_PTR(err);
}
",C,"	struct sk_buff *frag_skb = head_skb;
			frag_skb = list_skb;
				frag_skb = list_skb;
			if (unlikely(skb_orphan_frags(frag_skb, GFP_ATOMIC)))
				goto err;

",,,"@@ -2854,6 +2854,7 @@ struct sk_buff *skb_segment(struct sk_buff *head_skb,
 	skb_frag_t *frag = skb_shinfo(head_skb)->frags;
 	unsigned int mss = skb_shinfo(head_skb)->gso_size;
 	unsigned int doffset = head_skb->data - skb_mac_header(head_skb);
+	struct sk_buff *frag_skb = head_skb;
 	unsigned int offset = doffset;
 	unsigned int tnl_hlen = skb_tnl_header_len(head_skb);
 	unsigned int headroom;
@@ -2898,6 +2899,7 @@ struct sk_buff *skb_segment(struct sk_buff *head_skb,
 			i = 0;
 			nfrags = skb_shinfo(list_skb)->nr_frags;
 			frag = skb_shinfo(list_skb)->frags;
+			frag_skb = list_skb;
 			pos += skb_headlen(list_skb);
 
 			while (pos < offset + len) {
@@ -2985,6 +2987,7 @@ struct sk_buff *skb_segment(struct sk_buff *head_skb,
 				i = 0;
 				nfrags = skb_shinfo(list_skb)->nr_frags;
 				frag = skb_shinfo(list_skb)->frags;
+				frag_skb = list_skb;
 
 				BUG_ON(!nfrags);
 
@@ -2999,6 +3002,9 @@ struct sk_buff *skb_segment(struct sk_buff *head_skb,
 				goto err;
 			}
 
+			if (unlikely(skb_orphan_frags(frag_skb, GFP_ATOMIC)))
+				goto err;
+
 			*nskb_frag = *frag;
 			__skb_frag_ref(nskb_frag);
 			size = skb_frag_size(nskb_frag);",linux,1fd819ecb90cc9b822cd84d3056ddba315d3340f,1a4cedaf65491e66e1e55b8428c89209da729209,1,"struct sk_buff *skb_segment(struct sk_buff *head_skb,
			    netdev_features_t features)
{
	struct sk_buff *segs = NULL;
	struct sk_buff *tail = NULL;
	struct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list;
 	skb_frag_t *frag = skb_shinfo(head_skb)->frags;
 	unsigned int mss = skb_shinfo(head_skb)->gso_size;
 	unsigned int doffset = head_skb->data - skb_mac_header(head_skb);
//fix_flaw_line_below:
//	struct sk_buff *frag_skb = head_skb;
 	unsigned int offset = doffset;
 	unsigned int tnl_hlen = skb_tnl_header_len(head_skb);
 	unsigned int headroom;
	unsigned int len;
	__be16 proto;
	bool csum;
	int sg = !!(features & NETIF_F_SG);
	int nfrags = skb_shinfo(head_skb)->nr_frags;
	int err = -ENOMEM;
	int i = 0;
	int pos;

	proto = skb_network_protocol(head_skb);
	if (unlikely(!proto))
		return ERR_PTR(-EINVAL);

	csum = !!can_checksum_protocol(features, proto);
	__skb_push(head_skb, doffset);
	headroom = skb_headroom(head_skb);
	pos = skb_headlen(head_skb);

	do {
		struct sk_buff *nskb;
		skb_frag_t *nskb_frag;
		int hsize;
		int size;

		len = head_skb->len - offset;
		if (len > mss)
			len = mss;

		hsize = skb_headlen(head_skb) - offset;
		if (hsize < 0)
			hsize = 0;
		if (hsize > len || !sg)
			hsize = len;

		if (!hsize && i >= nfrags && skb_headlen(list_skb) &&
		    (skb_headlen(list_skb) == len || sg)) {
			BUG_ON(skb_headlen(list_skb) > len);

 			i = 0;
 			nfrags = skb_shinfo(list_skb)->nr_frags;
 			frag = skb_shinfo(list_skb)->frags;
//fix_flaw_line_below:
//			frag_skb = list_skb;
 			pos += skb_headlen(list_skb);
 
 			while (pos < offset + len) {
				BUG_ON(i >= nfrags);

				size = skb_frag_size(frag);
				if (pos + size > offset + len)
					break;

				i++;
				pos += size;
				frag++;
			}

			nskb = skb_clone(list_skb, GFP_ATOMIC);
			list_skb = list_skb->next;

			if (unlikely(!nskb))
				goto err;

			if (unlikely(pskb_trim(nskb, len))) {
				kfree_skb(nskb);
				goto err;
			}

			hsize = skb_end_offset(nskb);
			if (skb_cow_head(nskb, doffset + headroom)) {
				kfree_skb(nskb);
				goto err;
			}

			nskb->truesize += skb_end_offset(nskb) - hsize;
			skb_release_head_state(nskb);
			__skb_push(nskb, doffset);
		} else {
			nskb = __alloc_skb(hsize + doffset + headroom,
					   GFP_ATOMIC, skb_alloc_rx_flag(head_skb),
					   NUMA_NO_NODE);

			if (unlikely(!nskb))
				goto err;

			skb_reserve(nskb, headroom);
			__skb_put(nskb, doffset);
		}

		if (segs)
			tail->next = nskb;
		else
			segs = nskb;
		tail = nskb;

		__copy_skb_header(nskb, head_skb);
		nskb->mac_len = head_skb->mac_len;

		skb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);

		skb_copy_from_linear_data_offset(head_skb, -tnl_hlen,
						 nskb->data - tnl_hlen,
						 doffset + tnl_hlen);

		if (nskb->len == len + doffset)
			goto perform_csum_check;

		if (!sg) {
			nskb->ip_summed = CHECKSUM_NONE;
			nskb->csum = skb_copy_and_csum_bits(head_skb, offset,
							    skb_put(nskb, len),
							    len, 0);
			continue;
		}

		nskb_frag = skb_shinfo(nskb)->frags;

		skb_copy_from_linear_data_offset(head_skb, offset,
						 skb_put(nskb, hsize), hsize);

		skb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags &
			SKBTX_SHARED_FRAG;

		while (pos < offset + len) {
			if (i >= nfrags) {
				BUG_ON(skb_headlen(list_skb));

 				i = 0;
 				nfrags = skb_shinfo(list_skb)->nr_frags;
 				frag = skb_shinfo(list_skb)->frags;
//fix_flaw_line_below:
//				frag_skb = list_skb;
 
 				BUG_ON(!nfrags);
 
				list_skb = list_skb->next;
			}

			if (unlikely(skb_shinfo(nskb)->nr_frags >=
				     MAX_SKB_FRAGS)) {
				net_warn_ratelimited(
					""skb_segment: too many frags: %u %u\n"",
					pos, mss);
 				goto err;
 			}
 
//fix_flaw_line_below:
//			if (unlikely(skb_orphan_frags(frag_skb, GFP_ATOMIC)))
//fix_flaw_line_below:
//				goto err;
//fix_flaw_line_below:
//
 			*nskb_frag = *frag;
 			__skb_frag_ref(nskb_frag);
 			size = skb_frag_size(nskb_frag);

			if (pos < offset) {
				nskb_frag->page_offset += offset - pos;
				skb_frag_size_sub(nskb_frag, offset - pos);
			}

			skb_shinfo(nskb)->nr_frags++;

			if (pos + size <= offset + len) {
				i++;
				frag++;
				pos += size;
			} else {
				skb_frag_size_sub(nskb_frag, pos + size - (offset + len));
				goto skip_fraglist;
			}

			nskb_frag++;
		}

skip_fraglist:
		nskb->data_len = len - hsize;
		nskb->len += nskb->data_len;
		nskb->truesize += nskb->data_len;

perform_csum_check:
		if (!csum) {
			nskb->csum = skb_checksum(nskb, doffset,
						  nskb->len - doffset, 0);
			nskb->ip_summed = CHECKSUM_NONE;
		}
	} while ((offset += len) < head_skb->len);

	return segs;

err:
	kfree_skb_list(segs);
	return ERR_PTR(err);
}
",179630,"struct sk_buff *skb_segment(struct sk_buff *head_skb,
			    netdev_features_t features)
{
	struct sk_buff *segs = NULL;
	struct sk_buff *tail = NULL;
	struct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list;
 	skb_frag_t *frag = skb_shinfo(head_skb)->frags;
 	unsigned int mss = skb_shinfo(head_skb)->gso_size;
 	unsigned int doffset = head_skb->data - skb_mac_header(head_skb);
 	unsigned int offset = doffset;
 	unsigned int tnl_hlen = skb_tnl_header_len(head_skb);
 	unsigned int headroom;
	unsigned int len;
	__be16 proto;
	bool csum;
	int sg = !!(features & NETIF_F_SG);
	int nfrags = skb_shinfo(head_skb)->nr_frags;
	int err = -ENOMEM;
	int i = 0;
	int pos;

	proto = skb_network_protocol(head_skb);
	if (unlikely(!proto))
		return ERR_PTR(-EINVAL);

	csum = !!can_checksum_protocol(features, proto);
	__skb_push(head_skb, doffset);
	headroom = skb_headroom(head_skb);
	pos = skb_headlen(head_skb);

	do {
		struct sk_buff *nskb;
		skb_frag_t *nskb_frag;
		int hsize;
		int size;

		len = head_skb->len - offset;
		if (len > mss)
			len = mss;

		hsize = skb_headlen(head_skb) - offset;
		if (hsize < 0)
			hsize = 0;
		if (hsize > len || !sg)
			hsize = len;

		if (!hsize && i >= nfrags && skb_headlen(list_skb) &&
		    (skb_headlen(list_skb) == len || sg)) {
			BUG_ON(skb_headlen(list_skb) > len);

 			i = 0;
 			nfrags = skb_shinfo(list_skb)->nr_frags;
 			frag = skb_shinfo(list_skb)->frags;
 			pos += skb_headlen(list_skb);
 
 			while (pos < offset + len) {
				BUG_ON(i >= nfrags);

				size = skb_frag_size(frag);
				if (pos + size > offset + len)
					break;

				i++;
				pos += size;
				frag++;
			}

			nskb = skb_clone(list_skb, GFP_ATOMIC);
			list_skb = list_skb->next;

			if (unlikely(!nskb))
				goto err;

			if (unlikely(pskb_trim(nskb, len))) {
				kfree_skb(nskb);
				goto err;
			}

			hsize = skb_end_offset(nskb);
			if (skb_cow_head(nskb, doffset + headroom)) {
				kfree_skb(nskb);
				goto err;
			}

			nskb->truesize += skb_end_offset(nskb) - hsize;
			skb_release_head_state(nskb);
			__skb_push(nskb, doffset);
		} else {
			nskb = __alloc_skb(hsize + doffset + headroom,
					   GFP_ATOMIC, skb_alloc_rx_flag(head_skb),
					   NUMA_NO_NODE);

			if (unlikely(!nskb))
				goto err;

			skb_reserve(nskb, headroom);
			__skb_put(nskb, doffset);
		}

		if (segs)
			tail->next = nskb;
		else
			segs = nskb;
		tail = nskb;

		__copy_skb_header(nskb, head_skb);
		nskb->mac_len = head_skb->mac_len;

		skb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);

		skb_copy_from_linear_data_offset(head_skb, -tnl_hlen,
						 nskb->data - tnl_hlen,
						 doffset + tnl_hlen);

		if (nskb->len == len + doffset)
			goto perform_csum_check;

		if (!sg) {
			nskb->ip_summed = CHECKSUM_NONE;
			nskb->csum = skb_copy_and_csum_bits(head_skb, offset,
							    skb_put(nskb, len),
							    len, 0);
			continue;
		}

		nskb_frag = skb_shinfo(nskb)->frags;

		skb_copy_from_linear_data_offset(head_skb, offset,
						 skb_put(nskb, hsize), hsize);

		skb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags &
			SKBTX_SHARED_FRAG;

		while (pos < offset + len) {
			if (i >= nfrags) {
				BUG_ON(skb_headlen(list_skb));

 				i = 0;
 				nfrags = skb_shinfo(list_skb)->nr_frags;
 				frag = skb_shinfo(list_skb)->frags;
 
 				BUG_ON(!nfrags);
 
				list_skb = list_skb->next;
			}

			if (unlikely(skb_shinfo(nskb)->nr_frags >=
				     MAX_SKB_FRAGS)) {
				net_warn_ratelimited(
					""skb_segment: too many frags: %u %u\n"",
					pos, mss);
 				goto err;
 			}
 
 			*nskb_frag = *frag;
 			__skb_frag_ref(nskb_frag);
 			size = skb_frag_size(nskb_frag);

			if (pos < offset) {
				nskb_frag->page_offset += offset - pos;
				skb_frag_size_sub(nskb_frag, offset - pos);
			}

			skb_shinfo(nskb)->nr_frags++;

			if (pos + size <= offset + len) {
				i++;
				frag++;
				pos += size;
			} else {
				skb_frag_size_sub(nskb_frag, pos + size - (offset + len));
				goto skip_fraglist;
			}

			nskb_frag++;
		}

skip_fraglist:
		nskb->data_len = len - hsize;
		nskb->len += nskb->data_len;
		nskb->truesize += nskb->data_len;

perform_csum_check:
		if (!csum) {
			nskb->csum = skb_checksum(nskb, doffset,
						  nskb->len - doffset, 0);
			nskb->ip_summed = CHECKSUM_NONE;
		}
	} while ((offset += len) < head_skb->len);

	return segs;

err:
	kfree_skb_list(segs);
	return ERR_PTR(err);
}
","struct sk_buff *skb_segment(struct sk_buff *head_skb,
			    netdev_features_t features)
{
	struct sk_buff *segs = NULL;
	struct sk_buff *tail = NULL;
	struct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list;
 	skb_frag_t *frag = skb_shinfo(head_skb)->frags;
 	unsigned int mss = skb_shinfo(head_skb)->gso_size;
 	unsigned int doffset = head_skb->data - skb_mac_header(head_skb);
	struct sk_buff *frag_skb = head_skb;
 	unsigned int offset = doffset;
 	unsigned int tnl_hlen = skb_tnl_header_len(head_skb);
 	unsigned int headroom;
	unsigned int len;
	__be16 proto;
	bool csum;
	int sg = !!(features & NETIF_F_SG);
	int nfrags = skb_shinfo(head_skb)->nr_frags;
	int err = -ENOMEM;
	int i = 0;
	int pos;

	proto = skb_network_protocol(head_skb);
	if (unlikely(!proto))
		return ERR_PTR(-EINVAL);

	csum = !!can_checksum_protocol(features, proto);
	__skb_push(head_skb, doffset);
	headroom = skb_headroom(head_skb);
	pos = skb_headlen(head_skb);

	do {
		struct sk_buff *nskb;
		skb_frag_t *nskb_frag;
		int hsize;
		int size;

		len = head_skb->len - offset;
		if (len > mss)
			len = mss;

		hsize = skb_headlen(head_skb) - offset;
		if (hsize < 0)
			hsize = 0;
		if (hsize > len || !sg)
			hsize = len;

		if (!hsize && i >= nfrags && skb_headlen(list_skb) &&
		    (skb_headlen(list_skb) == len || sg)) {
			BUG_ON(skb_headlen(list_skb) > len);

 			i = 0;
 			nfrags = skb_shinfo(list_skb)->nr_frags;
 			frag = skb_shinfo(list_skb)->frags;
			frag_skb = list_skb;
 			pos += skb_headlen(list_skb);
 
 			while (pos < offset + len) {
				BUG_ON(i >= nfrags);

				size = skb_frag_size(frag);
				if (pos + size > offset + len)
					break;

				i++;
				pos += size;
				frag++;
			}

			nskb = skb_clone(list_skb, GFP_ATOMIC);
			list_skb = list_skb->next;

			if (unlikely(!nskb))
				goto err;

			if (unlikely(pskb_trim(nskb, len))) {
				kfree_skb(nskb);
				goto err;
			}

			hsize = skb_end_offset(nskb);
			if (skb_cow_head(nskb, doffset + headroom)) {
				kfree_skb(nskb);
				goto err;
			}

			nskb->truesize += skb_end_offset(nskb) - hsize;
			skb_release_head_state(nskb);
			__skb_push(nskb, doffset);
		} else {
			nskb = __alloc_skb(hsize + doffset + headroom,
					   GFP_ATOMIC, skb_alloc_rx_flag(head_skb),
					   NUMA_NO_NODE);

			if (unlikely(!nskb))
				goto err;

			skb_reserve(nskb, headroom);
			__skb_put(nskb, doffset);
		}

		if (segs)
			tail->next = nskb;
		else
			segs = nskb;
		tail = nskb;

		__copy_skb_header(nskb, head_skb);
		nskb->mac_len = head_skb->mac_len;

		skb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);

		skb_copy_from_linear_data_offset(head_skb, -tnl_hlen,
						 nskb->data - tnl_hlen,
						 doffset + tnl_hlen);

		if (nskb->len == len + doffset)
			goto perform_csum_check;

		if (!sg) {
			nskb->ip_summed = CHECKSUM_NONE;
			nskb->csum = skb_copy_and_csum_bits(head_skb, offset,
							    skb_put(nskb, len),
							    len, 0);
			continue;
		}

		nskb_frag = skb_shinfo(nskb)->frags;

		skb_copy_from_linear_data_offset(head_skb, offset,
						 skb_put(nskb, hsize), hsize);

		skb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags &
			SKBTX_SHARED_FRAG;

		while (pos < offset + len) {
			if (i >= nfrags) {
				BUG_ON(skb_headlen(list_skb));

 				i = 0;
 				nfrags = skb_shinfo(list_skb)->nr_frags;
 				frag = skb_shinfo(list_skb)->frags;
				frag_skb = list_skb;
 
 				BUG_ON(!nfrags);
 
				list_skb = list_skb->next;
			}

			if (unlikely(skb_shinfo(nskb)->nr_frags >=
				     MAX_SKB_FRAGS)) {
				net_warn_ratelimited(
					""skb_segment: too many frags: %u %u\n"",
					pos, mss);
 				goto err;
 			}
 
			if (unlikely(skb_orphan_frags(frag_skb, GFP_ATOMIC)))
				goto err;

 			*nskb_frag = *frag;
 			__skb_frag_ref(nskb_frag);
 			size = skb_frag_size(nskb_frag);

			if (pos < offset) {
				nskb_frag->page_offset += offset - pos;
				skb_frag_size_sub(nskb_frag, offset - pos);
			}

			skb_shinfo(nskb)->nr_frags++;

			if (pos + size <= offset + len) {
				i++;
				frag++;
				pos += size;
			} else {
				skb_frag_size_sub(nskb_frag, pos + size - (offset + len));
				goto skip_fraglist;
			}

			nskb_frag++;
		}

skip_fraglist:
		nskb->data_len = len - hsize;
		nskb->len += nskb->data_len;
		nskb->truesize += nskb->data_len;

perform_csum_check:
		if (!csum) {
			nskb->csum = skb_checksum(nskb, doffset,
						  nskb->len - doffset, 0);
			nskb->ip_summed = CHECKSUM_NONE;
		}
	} while ((offset += len) < head_skb->len);

	return segs;

err:
	kfree_skb_list(segs);
	return ERR_PTR(err);
}
","The vulnerability in the original code lies in the handling of fragmented packets, specifically in the loop that processes fragments. The code did not properly manage the state of the fragment list, which could lead to dereferencing invalid memory or accessing out-of-bounds fragments, potentially causing a crash or memory corruption. The fix introduced the `frag_skb` variable to track the current fragment's state and added a check with `skb_orphan_frags(frag_skb, GFP_ATOMIC)` to ensure that the fragments are correctly orphaned before being processed. This prevents misuse of the fragment list and enhances memory safety.","The vulnerability in the original code stemmed from inadequate management of fragmented packets, which could lead to dereferencing invalid memory or accessing out-of-bounds fragments. This oversight risked crashes or memory corruption due to improper handling of the fragment list during processing. The fix addressed this issue by introducing a mechanism to track the current state of fragments and ensuring that they were correctly orphaned before further processing. This enhancement improved memory safety and stability by preventing misuse of the fragment list, thereby mitigating the risk of crashes or data corruption."
8,180012,180012,,Local,Not required,Complete,CVE-2016-10088,https://www.cvedetails.com/cve/CVE-2016-10088/,CWE-416,Medium,Complete,Complete,,2016-12-30,6.9,"The sg implementation in the Linux kernel through 4.9 does not properly restrict write operations in situations where the KERNEL_DS option is set, which allows local users to read or write to arbitrary kernel memory locations or cause a denial of service (use-after-free) by leveraging access to a /dev/sg device, related to block/bsg.c and drivers/scsi/sg.c.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-9576.",2018-01-04,DoS ,3,https://github.com/torvalds/linux/commit/128394eff343fc6d2f32172f03e24829539c5835,128394eff343fc6d2f32172f03e24829539c5835,"sg_write()/bsg_write() is not fit to be called under KERNEL_DS

Both damn things interpret userland pointers embedded into the payload;
worse, they are actually traversing those.  Leaving aside the bad
API design, this is very much _not_ safe to call with KERNEL_DS.
Bail out early if that happens.

Cc: stable@vger.kernel.org
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",0,block/bsg.c,"{""sha"": ""a57046de2f07f00eae78aaabe9b5e43c1ecc178f"", ""filename"": ""block/bsg.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/128394eff343fc6d2f32172f03e24829539c5835/block/bsg.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/128394eff343fc6d2f32172f03e24829539c5835/block/bsg.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/block/bsg.c?ref=128394eff343fc6d2f32172f03e24829539c5835"", ""patch"": ""@@ -655,6 +655,9 @@ bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n \n \tdprintk(\""%s: write %Zd bytes\\n\"", bd->name, count);\n \n+\tif (unlikely(segment_eq(get_fs(), KERNEL_DS)))\n+\t\treturn -EINVAL;\n+\n \tbsg_set_block(bd, file);\n \n \tbytes_written = 0;""}<_**next**_>{""sha"": ""dbe5b4b95df0d9d317dbdc2261914e4d8771991f"", ""filename"": ""drivers/scsi/sg.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/128394eff343fc6d2f32172f03e24829539c5835/drivers/scsi/sg.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/128394eff343fc6d2f32172f03e24829539c5835/drivers/scsi/sg.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/scsi/sg.c?ref=128394eff343fc6d2f32172f03e24829539c5835"", ""patch"": ""@@ -581,6 +581,9 @@ sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)\n \tsg_io_hdr_t *hp;\n \tunsigned char cmnd[SG_MAX_CDB_SIZE];\n \n+\tif (unlikely(segment_eq(get_fs(), KERNEL_DS)))\n+\t\treturn -EINVAL;\n+\n \tif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\n \t\treturn -ENXIO;\n \tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,""}","bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
{
	struct bsg_device *bd = file->private_data;
	ssize_t bytes_written;
	int ret;
 
 	dprintk(""%s: write %Zd bytes\n"", bd->name, count);
 
	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
		return -EINVAL;

 	bsg_set_block(bd, file);
 
 	bytes_written = 0;
	ret = __bsg_write(bd, buf, count, &bytes_written,
			  file->f_mode & FMODE_WRITE);

	*ppos = bytes_written;

	/*
	 * return bytes written on non-fatal errors
	 */
	if (!bytes_written || err_block_err(ret))
		bytes_written = ret;

	dprintk(""%s: returning %Zd\n"", bd->name, bytes_written);
	return bytes_written;
}
","bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
{
	struct bsg_device *bd = file->private_data;
	ssize_t bytes_written;
	int ret;
 
 	dprintk(""%s: write %Zd bytes\n"", bd->name, count);
 
 	bsg_set_block(bd, file);
 
 	bytes_written = 0;
	ret = __bsg_write(bd, buf, count, &bytes_written,
			  file->f_mode & FMODE_WRITE);

	*ppos = bytes_written;

	/*
	 * return bytes written on non-fatal errors
	 */
	if (!bytes_written || err_block_err(ret))
		bytes_written = ret;

	dprintk(""%s: returning %Zd\n"", bd->name, bytes_written);
	return bytes_written;
}
",C,"	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
		return -EINVAL;

",,,"@@ -655,6 +655,9 @@ bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
 
 	dprintk(""%s: write %Zd bytes\n"", bd->name, count);
 
+	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
+		return -EINVAL;
+
 	bsg_set_block(bd, file);
 
 	bytes_written = 0;",linux,128394eff343fc6d2f32172f03e24829539c5835,f698cccbc89e33cda4795a375e47daaa3689485e,1,"bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
{
	struct bsg_device *bd = file->private_data;
	ssize_t bytes_written;
	int ret;
 
 	dprintk(""%s: write %Zd bytes\n"", bd->name, count);
 
//fix_flaw_line_below:
//	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
//fix_flaw_line_below:
//		return -EINVAL;
//fix_flaw_line_below:
//
 	bsg_set_block(bd, file);
 
 	bytes_written = 0;
	ret = __bsg_write(bd, buf, count, &bytes_written,
			  file->f_mode & FMODE_WRITE);

	*ppos = bytes_written;

	/*
	 * return bytes written on non-fatal errors
	 */
	if (!bytes_written || err_block_err(ret))
		bytes_written = ret;

	dprintk(""%s: returning %Zd\n"", bd->name, bytes_written);
	return bytes_written;
}
",180012,"bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
{
	struct bsg_device *bd = file->private_data;
	ssize_t bytes_written;
	int ret;
 
 	dprintk(""%s: write %Zd bytes\n"", bd->name, count);
 
 	bsg_set_block(bd, file);
 
 	bytes_written = 0;
	ret = __bsg_write(bd, buf, count, &bytes_written,
			  file->f_mode & FMODE_WRITE);

	*ppos = bytes_written;

	/*
	 * return bytes written on non-fatal errors
	 */
	if (!bytes_written || err_block_err(ret))
		bytes_written = ret;

	dprintk(""%s: returning %Zd\n"", bd->name, bytes_written);
	return bytes_written;
}
","bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
{
	struct bsg_device *bd = file->private_data;
	ssize_t bytes_written;
	int ret;
 
 	dprintk(""%s: write %Zd bytes\n"", bd->name, count);
 
	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
		return -EINVAL;

 	bsg_set_block(bd, file);
 
 	bytes_written = 0;
	ret = __bsg_write(bd, buf, count, &bytes_written,
			  file->f_mode & FMODE_WRITE);

	*ppos = bytes_written;

	/*
	 * return bytes written on non-fatal errors
	 */
	if (!bytes_written || err_block_err(ret))
		bytes_written = ret;

	dprintk(""%s: returning %Zd\n"", bd->name, bytes_written);
	return bytes_written;
}
","The vulnerability in the original code lies in the lack of validation for the address space from which the data is being written. Specifically, the function does not check if the memory segment is from user space or kernel space, which could lead to potential exploitation, such as accessing invalid memory or causing a kernel crash. The fix introduces a check using `unlikely(segment_eq(get_fs(), KERNEL_DS))`, which verifies if the current address space is the kernel's. If it is, the function returns `-EINVAL`, effectively preventing unauthorized access and enhancing the security of the `bsg_write` function.","The vulnerability in the original code stems from the absence of checks to ensure that the memory being accessed is from a safe user space rather than kernel space. This oversight could allow malicious users to write to kernel memory, potentially leading to crashes or unauthorized access to sensitive data. The fix addresses this issue by implementing a validation step that checks the current address space before proceeding with the write operation. If the address space is determined to be kernel space, the function immediately returns an error, thereby preventing any unsafe memory operations and enhancing overall system security."
9,180013,180013,,Local,Not required,Complete,CVE-2016-10088,https://www.cvedetails.com/cve/CVE-2016-10088/,CWE-416,Medium,Complete,Complete,,2016-12-30,6.9,"The sg implementation in the Linux kernel through 4.9 does not properly restrict write operations in situations where the KERNEL_DS option is set, which allows local users to read or write to arbitrary kernel memory locations or cause a denial of service (use-after-free) by leveraging access to a /dev/sg device, related to block/bsg.c and drivers/scsi/sg.c.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-9576.",2018-01-04,DoS ,3,https://github.com/torvalds/linux/commit/128394eff343fc6d2f32172f03e24829539c5835,128394eff343fc6d2f32172f03e24829539c5835,"sg_write()/bsg_write() is not fit to be called under KERNEL_DS

Both damn things interpret userland pointers embedded into the payload;
worse, they are actually traversing those.  Leaving aside the bad
API design, this is very much _not_ safe to call with KERNEL_DS.
Bail out early if that happens.

Cc: stable@vger.kernel.org
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",0,drivers/scsi/sg.c,"{""sha"": ""a57046de2f07f00eae78aaabe9b5e43c1ecc178f"", ""filename"": ""block/bsg.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/128394eff343fc6d2f32172f03e24829539c5835/block/bsg.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/128394eff343fc6d2f32172f03e24829539c5835/block/bsg.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/block/bsg.c?ref=128394eff343fc6d2f32172f03e24829539c5835"", ""patch"": ""@@ -655,6 +655,9 @@ bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n \n \tdprintk(\""%s: write %Zd bytes\\n\"", bd->name, count);\n \n+\tif (unlikely(segment_eq(get_fs(), KERNEL_DS)))\n+\t\treturn -EINVAL;\n+\n \tbsg_set_block(bd, file);\n \n \tbytes_written = 0;""}<_**next**_>{""sha"": ""dbe5b4b95df0d9d317dbdc2261914e4d8771991f"", ""filename"": ""drivers/scsi/sg.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/128394eff343fc6d2f32172f03e24829539c5835/drivers/scsi/sg.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/128394eff343fc6d2f32172f03e24829539c5835/drivers/scsi/sg.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/scsi/sg.c?ref=128394eff343fc6d2f32172f03e24829539c5835"", ""patch"": ""@@ -581,6 +581,9 @@ sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)\n \tsg_io_hdr_t *hp;\n \tunsigned char cmnd[SG_MAX_CDB_SIZE];\n \n+\tif (unlikely(segment_eq(get_fs(), KERNEL_DS)))\n+\t\treturn -EINVAL;\n+\n \tif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\n \t\treturn -ENXIO;\n \tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,""}","sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
{
	int mxsize, cmd_size, k;
	int input_size, blocking;
	unsigned char opcode;
	Sg_device *sdp;
	Sg_fd *sfp;
	Sg_request *srp;
	struct sg_header old_hdr;
 	sg_io_hdr_t *hp;
 	unsigned char cmnd[SG_MAX_CDB_SIZE];
 
	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
		return -EINVAL;

 	if ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))
 		return -ENXIO;
 	SCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,
				      ""sg_write: count=%d\n"", (int) count));
	if (atomic_read(&sdp->detaching))
		return -ENODEV;
	if (!((filp->f_flags & O_NONBLOCK) ||
	      scsi_block_when_processing_errors(sdp->device)))
		return -ENXIO;

	if (!access_ok(VERIFY_READ, buf, count))
		return -EFAULT;	/* protects following copy_from_user()s + get_user()s */
	if (count < SZ_SG_HEADER)
		return -EIO;
	if (__copy_from_user(&old_hdr, buf, SZ_SG_HEADER))
		return -EFAULT;
	blocking = !(filp->f_flags & O_NONBLOCK);
	if (old_hdr.reply_len < 0)
		return sg_new_write(sfp, filp, buf, count,
				    blocking, 0, 0, NULL);
	if (count < (SZ_SG_HEADER + 6))
		return -EIO;	/* The minimum scsi command length is 6 bytes. */

	if (!(srp = sg_add_request(sfp))) {
		SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sdp,
					      ""sg_write: queue full\n""));
		return -EDOM;
	}
	buf += SZ_SG_HEADER;
	__get_user(opcode, buf);
	if (sfp->next_cmd_len > 0) {
		cmd_size = sfp->next_cmd_len;
		sfp->next_cmd_len = 0;	/* reset so only this write() effected */
	} else {
		cmd_size = COMMAND_SIZE(opcode);	/* based on SCSI command group */
		if ((opcode >= 0xc0) && old_hdr.twelve_byte)
			cmd_size = 12;
	}
	SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sdp,
		""sg_write:   scsi opcode=0x%02x, cmd_size=%d\n"", (int) opcode, cmd_size));
/* Determine buffer size.  */
	input_size = count - cmd_size;
	mxsize = (input_size > old_hdr.reply_len) ? input_size : old_hdr.reply_len;
	mxsize -= SZ_SG_HEADER;
	input_size -= SZ_SG_HEADER;
	if (input_size < 0) {
		sg_remove_request(sfp, srp);
		return -EIO;	/* User did not pass enough bytes for this command. */
	}
	hp = &srp->header;
	hp->interface_id = '\0';	/* indicator of old interface tunnelled */
	hp->cmd_len = (unsigned char) cmd_size;
	hp->iovec_count = 0;
	hp->mx_sb_len = 0;
	if (input_size > 0)
		hp->dxfer_direction = (old_hdr.reply_len > SZ_SG_HEADER) ?
		    SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV;
	else
		hp->dxfer_direction = (mxsize > 0) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE;
	hp->dxfer_len = mxsize;
	if ((hp->dxfer_direction == SG_DXFER_TO_DEV) ||
	    (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV))
		hp->dxferp = (char __user *)buf + cmd_size;
	else
		hp->dxferp = NULL;
	hp->sbp = NULL;
	hp->timeout = old_hdr.reply_len;	/* structure abuse ... */
	hp->flags = input_size;	/* structure abuse ... */
	hp->pack_id = old_hdr.pack_id;
	hp->usr_ptr = NULL;
	if (__copy_from_user(cmnd, buf, cmd_size))
		return -EFAULT;
	/*
	 * SG_DXFER_TO_FROM_DEV is functionally equivalent to SG_DXFER_FROM_DEV,
	 * but is is possible that the app intended SG_DXFER_TO_DEV, because there
	 * is a non-zero input_size, so emit a warning.
	 */
	if (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV) {
		static char cmd[TASK_COMM_LEN];
		if (strcmp(current->comm, cmd)) {
			printk_ratelimited(KERN_WARNING
					   ""sg_write: data in/out %d/%d bytes ""
					   ""for SCSI command 0x%x-- guessing ""
					   ""data in;\n   program %s not setting ""
					   ""count and/or reply_len properly\n"",
					   old_hdr.reply_len - (int)SZ_SG_HEADER,
					   input_size, (unsigned int) cmnd[0],
					   current->comm);
			strcpy(cmd, current->comm);
		}
	}
	k = sg_common_write(sfp, srp, cmnd, sfp->timeout, blocking);
	return (k < 0) ? k : count;
}
","sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
{
	int mxsize, cmd_size, k;
	int input_size, blocking;
	unsigned char opcode;
	Sg_device *sdp;
	Sg_fd *sfp;
	Sg_request *srp;
	struct sg_header old_hdr;
 	sg_io_hdr_t *hp;
 	unsigned char cmnd[SG_MAX_CDB_SIZE];
 
 	if ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))
 		return -ENXIO;
 	SCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,
				      ""sg_write: count=%d\n"", (int) count));
	if (atomic_read(&sdp->detaching))
		return -ENODEV;
	if (!((filp->f_flags & O_NONBLOCK) ||
	      scsi_block_when_processing_errors(sdp->device)))
		return -ENXIO;

	if (!access_ok(VERIFY_READ, buf, count))
		return -EFAULT;	/* protects following copy_from_user()s + get_user()s */
	if (count < SZ_SG_HEADER)
		return -EIO;
	if (__copy_from_user(&old_hdr, buf, SZ_SG_HEADER))
		return -EFAULT;
	blocking = !(filp->f_flags & O_NONBLOCK);
	if (old_hdr.reply_len < 0)
		return sg_new_write(sfp, filp, buf, count,
				    blocking, 0, 0, NULL);
	if (count < (SZ_SG_HEADER + 6))
		return -EIO;	/* The minimum scsi command length is 6 bytes. */

	if (!(srp = sg_add_request(sfp))) {
		SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sdp,
					      ""sg_write: queue full\n""));
		return -EDOM;
	}
	buf += SZ_SG_HEADER;
	__get_user(opcode, buf);
	if (sfp->next_cmd_len > 0) {
		cmd_size = sfp->next_cmd_len;
		sfp->next_cmd_len = 0;	/* reset so only this write() effected */
	} else {
		cmd_size = COMMAND_SIZE(opcode);	/* based on SCSI command group */
		if ((opcode >= 0xc0) && old_hdr.twelve_byte)
			cmd_size = 12;
	}
	SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sdp,
		""sg_write:   scsi opcode=0x%02x, cmd_size=%d\n"", (int) opcode, cmd_size));
/* Determine buffer size.  */
	input_size = count - cmd_size;
	mxsize = (input_size > old_hdr.reply_len) ? input_size : old_hdr.reply_len;
	mxsize -= SZ_SG_HEADER;
	input_size -= SZ_SG_HEADER;
	if (input_size < 0) {
		sg_remove_request(sfp, srp);
		return -EIO;	/* User did not pass enough bytes for this command. */
	}
	hp = &srp->header;
	hp->interface_id = '\0';	/* indicator of old interface tunnelled */
	hp->cmd_len = (unsigned char) cmd_size;
	hp->iovec_count = 0;
	hp->mx_sb_len = 0;
	if (input_size > 0)
		hp->dxfer_direction = (old_hdr.reply_len > SZ_SG_HEADER) ?
		    SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV;
	else
		hp->dxfer_direction = (mxsize > 0) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE;
	hp->dxfer_len = mxsize;
	if ((hp->dxfer_direction == SG_DXFER_TO_DEV) ||
	    (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV))
		hp->dxferp = (char __user *)buf + cmd_size;
	else
		hp->dxferp = NULL;
	hp->sbp = NULL;
	hp->timeout = old_hdr.reply_len;	/* structure abuse ... */
	hp->flags = input_size;	/* structure abuse ... */
	hp->pack_id = old_hdr.pack_id;
	hp->usr_ptr = NULL;
	if (__copy_from_user(cmnd, buf, cmd_size))
		return -EFAULT;
	/*
	 * SG_DXFER_TO_FROM_DEV is functionally equivalent to SG_DXFER_FROM_DEV,
	 * but is is possible that the app intended SG_DXFER_TO_DEV, because there
	 * is a non-zero input_size, so emit a warning.
	 */
	if (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV) {
		static char cmd[TASK_COMM_LEN];
		if (strcmp(current->comm, cmd)) {
			printk_ratelimited(KERN_WARNING
					   ""sg_write: data in/out %d/%d bytes ""
					   ""for SCSI command 0x%x-- guessing ""
					   ""data in;\n   program %s not setting ""
					   ""count and/or reply_len properly\n"",
					   old_hdr.reply_len - (int)SZ_SG_HEADER,
					   input_size, (unsigned int) cmnd[0],
					   current->comm);
			strcpy(cmd, current->comm);
		}
	}
	k = sg_common_write(sfp, srp, cmnd, sfp->timeout, blocking);
	return (k < 0) ? k : count;
}
",C,"	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
		return -EINVAL;

",,,"@@ -581,6 +581,9 @@ sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
 	sg_io_hdr_t *hp;
 	unsigned char cmnd[SG_MAX_CDB_SIZE];
 
+	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
+		return -EINVAL;
+
 	if ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))
 		return -ENXIO;
 	SCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,",linux,128394eff343fc6d2f32172f03e24829539c5835,f698cccbc89e33cda4795a375e47daaa3689485e,1,"sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
{
	int mxsize, cmd_size, k;
	int input_size, blocking;
	unsigned char opcode;
	Sg_device *sdp;
	Sg_fd *sfp;
	Sg_request *srp;
	struct sg_header old_hdr;
 	sg_io_hdr_t *hp;
 	unsigned char cmnd[SG_MAX_CDB_SIZE];
 
//fix_flaw_line_below:
//	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
//fix_flaw_line_below:
//		return -EINVAL;
//fix_flaw_line_below:
//
 	if ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))
 		return -ENXIO;
 	SCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,
				      ""sg_write: count=%d\n"", (int) count));
	if (atomic_read(&sdp->detaching))
		return -ENODEV;
	if (!((filp->f_flags & O_NONBLOCK) ||
	      scsi_block_when_processing_errors(sdp->device)))
		return -ENXIO;

	if (!access_ok(VERIFY_READ, buf, count))
		return -EFAULT;	/* protects following copy_from_user()s + get_user()s */
	if (count < SZ_SG_HEADER)
		return -EIO;
	if (__copy_from_user(&old_hdr, buf, SZ_SG_HEADER))
		return -EFAULT;
	blocking = !(filp->f_flags & O_NONBLOCK);
	if (old_hdr.reply_len < 0)
		return sg_new_write(sfp, filp, buf, count,
				    blocking, 0, 0, NULL);
	if (count < (SZ_SG_HEADER + 6))
		return -EIO;	/* The minimum scsi command length is 6 bytes. */

	if (!(srp = sg_add_request(sfp))) {
		SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sdp,
					      ""sg_write: queue full\n""));
		return -EDOM;
	}
	buf += SZ_SG_HEADER;
	__get_user(opcode, buf);
	if (sfp->next_cmd_len > 0) {
		cmd_size = sfp->next_cmd_len;
		sfp->next_cmd_len = 0;	/* reset so only this write() effected */
	} else {
		cmd_size = COMMAND_SIZE(opcode);	/* based on SCSI command group */
		if ((opcode >= 0xc0) && old_hdr.twelve_byte)
			cmd_size = 12;
	}
	SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sdp,
		""sg_write:   scsi opcode=0x%02x, cmd_size=%d\n"", (int) opcode, cmd_size));
/* Determine buffer size.  */
	input_size = count - cmd_size;
	mxsize = (input_size > old_hdr.reply_len) ? input_size : old_hdr.reply_len;
	mxsize -= SZ_SG_HEADER;
	input_size -= SZ_SG_HEADER;
	if (input_size < 0) {
		sg_remove_request(sfp, srp);
		return -EIO;	/* User did not pass enough bytes for this command. */
	}
	hp = &srp->header;
	hp->interface_id = '\0';	/* indicator of old interface tunnelled */
	hp->cmd_len = (unsigned char) cmd_size;
	hp->iovec_count = 0;
	hp->mx_sb_len = 0;
	if (input_size > 0)
		hp->dxfer_direction = (old_hdr.reply_len > SZ_SG_HEADER) ?
		    SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV;
	else
		hp->dxfer_direction = (mxsize > 0) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE;
	hp->dxfer_len = mxsize;
	if ((hp->dxfer_direction == SG_DXFER_TO_DEV) ||
	    (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV))
		hp->dxferp = (char __user *)buf + cmd_size;
	else
		hp->dxferp = NULL;
	hp->sbp = NULL;
	hp->timeout = old_hdr.reply_len;	/* structure abuse ... */
	hp->flags = input_size;	/* structure abuse ... */
	hp->pack_id = old_hdr.pack_id;
	hp->usr_ptr = NULL;
	if (__copy_from_user(cmnd, buf, cmd_size))
		return -EFAULT;
	/*
	 * SG_DXFER_TO_FROM_DEV is functionally equivalent to SG_DXFER_FROM_DEV,
	 * but is is possible that the app intended SG_DXFER_TO_DEV, because there
	 * is a non-zero input_size, so emit a warning.
	 */
	if (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV) {
		static char cmd[TASK_COMM_LEN];
		if (strcmp(current->comm, cmd)) {
			printk_ratelimited(KERN_WARNING
					   ""sg_write: data in/out %d/%d bytes ""
					   ""for SCSI command 0x%x-- guessing ""
					   ""data in;\n   program %s not setting ""
					   ""count and/or reply_len properly\n"",
					   old_hdr.reply_len - (int)SZ_SG_HEADER,
					   input_size, (unsigned int) cmnd[0],
					   current->comm);
			strcpy(cmd, current->comm);
		}
	}
	k = sg_common_write(sfp, srp, cmnd, sfp->timeout, blocking);
	return (k < 0) ? k : count;
}
",180013,"sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
{
	int mxsize, cmd_size, k;
	int input_size, blocking;
	unsigned char opcode;
	Sg_device *sdp;
	Sg_fd *sfp;
	Sg_request *srp;
	struct sg_header old_hdr;
 	sg_io_hdr_t *hp;
 	unsigned char cmnd[SG_MAX_CDB_SIZE];
 
 	if ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))
 		return -ENXIO;
 	SCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,
				      ""sg_write: count=%d\n"", (int) count));
	if (atomic_read(&sdp->detaching))
		return -ENODEV;
	if (!((filp->f_flags & O_NONBLOCK) ||
	      scsi_block_when_processing_errors(sdp->device)))
		return -ENXIO;

	if (!access_ok(VERIFY_READ, buf, count))
		return -EFAULT;	/* protects following copy_from_user()s + get_user()s */
	if (count < SZ_SG_HEADER)
		return -EIO;
	if (__copy_from_user(&old_hdr, buf, SZ_SG_HEADER))
		return -EFAULT;
	blocking = !(filp->f_flags & O_NONBLOCK);
	if (old_hdr.reply_len < 0)
		return sg_new_write(sfp, filp, buf, count,
				    blocking, 0, 0, NULL);
	if (count < (SZ_SG_HEADER + 6))
		return -EIO;	/* The minimum scsi command length is 6 bytes. */

	if (!(srp = sg_add_request(sfp))) {
		SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sdp,
					      ""sg_write: queue full\n""));
		return -EDOM;
	}
	buf += SZ_SG_HEADER;
	__get_user(opcode, buf);
	if (sfp->next_cmd_len > 0) {
		cmd_size = sfp->next_cmd_len;
		sfp->next_cmd_len = 0;	/* reset so only this write() effected */
	} else {
		cmd_size = COMMAND_SIZE(opcode);	/* based on SCSI command group */
		if ((opcode >= 0xc0) && old_hdr.twelve_byte)
			cmd_size = 12;
	}
	SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sdp,
		""sg_write:   scsi opcode=0x%02x, cmd_size=%d\n"", (int) opcode, cmd_size));
/* Determine buffer size.  */
	input_size = count - cmd_size;
	mxsize = (input_size > old_hdr.reply_len) ? input_size : old_hdr.reply_len;
	mxsize -= SZ_SG_HEADER;
	input_size -= SZ_SG_HEADER;
	if (input_size < 0) {
		sg_remove_request(sfp, srp);
		return -EIO;	/* User did not pass enough bytes for this command. */
	}
	hp = &srp->header;
	hp->interface_id = '\0';	/* indicator of old interface tunnelled */
	hp->cmd_len = (unsigned char) cmd_size;
	hp->iovec_count = 0;
	hp->mx_sb_len = 0;
	if (input_size > 0)
		hp->dxfer_direction = (old_hdr.reply_len > SZ_SG_HEADER) ?
		    SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV;
	else
		hp->dxfer_direction = (mxsize > 0) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE;
	hp->dxfer_len = mxsize;
	if ((hp->dxfer_direction == SG_DXFER_TO_DEV) ||
	    (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV))
		hp->dxferp = (char __user *)buf + cmd_size;
	else
		hp->dxferp = NULL;
	hp->sbp = NULL;
	hp->timeout = old_hdr.reply_len;	/* structure abuse ... */
	hp->flags = input_size;	/* structure abuse ... */
	hp->pack_id = old_hdr.pack_id;
	hp->usr_ptr = NULL;
	if (__copy_from_user(cmnd, buf, cmd_size))
		return -EFAULT;
	/*
	 * SG_DXFER_TO_FROM_DEV is functionally equivalent to SG_DXFER_FROM_DEV,
	 * but is is possible that the app intended SG_DXFER_TO_DEV, because there
	 * is a non-zero input_size, so emit a warning.
	 */
	if (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV) {
		static char cmd[TASK_COMM_LEN];
		if (strcmp(current->comm, cmd)) {
			printk_ratelimited(KERN_WARNING
					   ""sg_write: data in/out %d/%d bytes ""
					   ""for SCSI command 0x%x-- guessing ""
					   ""data in;\n   program %s not setting ""
					   ""count and/or reply_len properly\n"",
					   old_hdr.reply_len - (int)SZ_SG_HEADER,
					   input_size, (unsigned int) cmnd[0],
					   current->comm);
			strcpy(cmd, current->comm);
		}
	}
	k = sg_common_write(sfp, srp, cmnd, sfp->timeout, blocking);
	return (k < 0) ? k : count;
}
","sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
{
	int mxsize, cmd_size, k;
	int input_size, blocking;
	unsigned char opcode;
	Sg_device *sdp;
	Sg_fd *sfp;
	Sg_request *srp;
	struct sg_header old_hdr;
 	sg_io_hdr_t *hp;
 	unsigned char cmnd[SG_MAX_CDB_SIZE];
 
	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
		return -EINVAL;

 	if ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))
 		return -ENXIO;
 	SCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,
				      ""sg_write: count=%d\n"", (int) count));
	if (atomic_read(&sdp->detaching))
		return -ENODEV;
	if (!((filp->f_flags & O_NONBLOCK) ||
	      scsi_block_when_processing_errors(sdp->device)))
		return -ENXIO;

	if (!access_ok(VERIFY_READ, buf, count))
		return -EFAULT;	/* protects following copy_from_user()s + get_user()s */
	if (count < SZ_SG_HEADER)
		return -EIO;
	if (__copy_from_user(&old_hdr, buf, SZ_SG_HEADER))
		return -EFAULT;
	blocking = !(filp->f_flags & O_NONBLOCK);
	if (old_hdr.reply_len < 0)
		return sg_new_write(sfp, filp, buf, count,
				    blocking, 0, 0, NULL);
	if (count < (SZ_SG_HEADER + 6))
		return -EIO;	/* The minimum scsi command length is 6 bytes. */

	if (!(srp = sg_add_request(sfp))) {
		SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sdp,
					      ""sg_write: queue full\n""));
		return -EDOM;
	}
	buf += SZ_SG_HEADER;
	__get_user(opcode, buf);
	if (sfp->next_cmd_len > 0) {
		cmd_size = sfp->next_cmd_len;
		sfp->next_cmd_len = 0;	/* reset so only this write() effected */
	} else {
		cmd_size = COMMAND_SIZE(opcode);	/* based on SCSI command group */
		if ((opcode >= 0xc0) && old_hdr.twelve_byte)
			cmd_size = 12;
	}
	SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sdp,
		""sg_write:   scsi opcode=0x%02x, cmd_size=%d\n"", (int) opcode, cmd_size));
/* Determine buffer size.  */
	input_size = count - cmd_size;
	mxsize = (input_size > old_hdr.reply_len) ? input_size : old_hdr.reply_len;
	mxsize -= SZ_SG_HEADER;
	input_size -= SZ_SG_HEADER;
	if (input_size < 0) {
		sg_remove_request(sfp, srp);
		return -EIO;	/* User did not pass enough bytes for this command. */
	}
	hp = &srp->header;
	hp->interface_id = '\0';	/* indicator of old interface tunnelled */
	hp->cmd_len = (unsigned char) cmd_size;
	hp->iovec_count = 0;
	hp->mx_sb_len = 0;
	if (input_size > 0)
		hp->dxfer_direction = (old_hdr.reply_len > SZ_SG_HEADER) ?
		    SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV;
	else
		hp->dxfer_direction = (mxsize > 0) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE;
	hp->dxfer_len = mxsize;
	if ((hp->dxfer_direction == SG_DXFER_TO_DEV) ||
	    (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV))
		hp->dxferp = (char __user *)buf + cmd_size;
	else
		hp->dxferp = NULL;
	hp->sbp = NULL;
	hp->timeout = old_hdr.reply_len;	/* structure abuse ... */
	hp->flags = input_size;	/* structure abuse ... */
	hp->pack_id = old_hdr.pack_id;
	hp->usr_ptr = NULL;
	if (__copy_from_user(cmnd, buf, cmd_size))
		return -EFAULT;
	/*
	 * SG_DXFER_TO_FROM_DEV is functionally equivalent to SG_DXFER_FROM_DEV,
	 * but is is possible that the app intended SG_DXFER_TO_DEV, because there
	 * is a non-zero input_size, so emit a warning.
	 */
	if (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV) {
		static char cmd[TASK_COMM_LEN];
		if (strcmp(current->comm, cmd)) {
			printk_ratelimited(KERN_WARNING
					   ""sg_write: data in/out %d/%d bytes ""
					   ""for SCSI command 0x%x-- guessing ""
					   ""data in;\n   program %s not setting ""
					   ""count and/or reply_len properly\n"",
					   old_hdr.reply_len - (int)SZ_SG_HEADER,
					   input_size, (unsigned int) cmnd[0],
					   current->comm);
			strcpy(cmd, current->comm);
		}
	}
	k = sg_common_write(sfp, srp, cmnd, sfp->timeout, blocking);
	return (k < 0) ? k : count;
}
","The vulnerability in the original `sg_write` function arises from the lack of validation for the address space of the `buf` parameter, which could allow a user to pass a kernel address, leading to potential memory corruption or unauthorized access. The check for the address space was missing, making the function susceptible to exploitation. The fix introduces a validation check using `unlikely(segment_eq(get_fs(), KERNEL_DS))`, which ensures that the function returns `-EINVAL` if the address space is the kernel's, thus preventing any operations on kernel memory and enhancing overall security by ensuring that only user-space addresses are processed.","The vulnerability in the original code stems from the absence of checks to ensure that the memory address provided by the user is valid and not pointing to kernel space. This oversight could allow an attacker to manipulate kernel memory, leading to potential crashes or unauthorized access. The fix addresses this issue by implementing a validation check that verifies whether the address belongs to user space. If the address is found to be in kernel space, the function immediately returns an error, thereby preventing any unsafe operations and enhancing the security of the code."
10,180017,180017,,Local,Not required,Complete,CVE-2016-9794,https://www.cvedetails.com/cve/CVE-2016-9794/,CWE-416,Low,Complete,Complete,,2016-12-28,7.2,Race condition in the snd_pcm_period_elapsed function in sound/core/pcm_lib.c in the ALSA subsystem in the Linux kernel before 4.7 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted SNDRV_PCM_TRIGGER_START command.,2018-01-04,DoS ,1,https://github.com/torvalds/linux/commit/3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4,3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4,"ALSA: pcm : Call kill_fasync() in stream lock

Currently kill_fasync() is called outside the stream lock in
snd_pcm_period_elapsed().  This is potentially racy, since the stream
may get released even during the irq handler is running.  Although
snd_pcm_release_substream() calls snd_pcm_drop(), this doesn't
guarantee that the irq handler finishes, thus the kill_fasync() call
outside the stream spin lock may be invoked after the substream is
detached, as recently reported by KASAN.

As a quick workaround, move kill_fasync() call inside the stream
lock.  The fasync is rarely used interface, so this shouldn't have a
big impact from the performance POV.

Ideally, we should implement some sync mechanism for the proper finish
of stream and irq handler.  But this oneliner should suffice for most
cases, so far.

Reported-by: Baozeng Ding <sploving1@gmail.com>
Signed-off-by: Takashi Iwai <tiwai@suse.de>",1,sound/core/pcm_lib.c,"{""sha"": ""0aca39762ed0ec981fb4f612741010a255a97587"", ""filename"": ""sound/core/pcm_lib.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4/sound/core/pcm_lib.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4/sound/core/pcm_lib.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/sound/core/pcm_lib.c?ref=3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4"", ""patch"": ""@@ -1886,8 +1886,8 @@ void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n \t\tsnd_timer_interrupt(substream->timer, 1);\n #endif\n  _end:\n-\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n \tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n+\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n }\n \n EXPORT_SYMBOL(snd_pcm_period_elapsed);""}","void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
{
	struct snd_pcm_runtime *runtime;
	unsigned long flags;

	if (PCM_RUNTIME_CHECK(substream))
		return;
	runtime = substream->runtime;

	snd_pcm_stream_lock_irqsave(substream, flags);
	if (!snd_pcm_running(substream) ||
	    snd_pcm_update_hw_ptr0(substream, 1) < 0)
		goto _end;

#ifdef CONFIG_SND_PCM_TIMER
	if (substream->timer_running)
 		snd_timer_interrupt(substream->timer, 1);
 #endif
  _end:
 	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
	snd_pcm_stream_unlock_irqrestore(substream, flags);
 }
","void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
{
	struct snd_pcm_runtime *runtime;
	unsigned long flags;

	if (PCM_RUNTIME_CHECK(substream))
		return;
	runtime = substream->runtime;

	snd_pcm_stream_lock_irqsave(substream, flags);
	if (!snd_pcm_running(substream) ||
	    snd_pcm_update_hw_ptr0(substream, 1) < 0)
		goto _end;

#ifdef CONFIG_SND_PCM_TIMER
	if (substream->timer_running)
 		snd_timer_interrupt(substream->timer, 1);
 #endif
  _end:
	snd_pcm_stream_unlock_irqrestore(substream, flags);
 	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
 }
",C,"	snd_pcm_stream_unlock_irqrestore(substream, flags);
","	snd_pcm_stream_unlock_irqrestore(substream, flags);
",,"@@ -1886,8 +1886,8 @@ void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
 		snd_timer_interrupt(substream->timer, 1);
 #endif
  _end:
-	snd_pcm_stream_unlock_irqrestore(substream, flags);
 	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
+	snd_pcm_stream_unlock_irqrestore(substream, flags);
 }
 
 EXPORT_SYMBOL(snd_pcm_period_elapsed);",linux,3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4,fa44b7ec9bc4115513e59f31da1167166bd6346a,1,"void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
{
	struct snd_pcm_runtime *runtime;
	unsigned long flags;

	if (PCM_RUNTIME_CHECK(substream))
		return;
	runtime = substream->runtime;

	snd_pcm_stream_lock_irqsave(substream, flags);
	if (!snd_pcm_running(substream) ||
	    snd_pcm_update_hw_ptr0(substream, 1) < 0)
		goto _end;

#ifdef CONFIG_SND_PCM_TIMER
	if (substream->timer_running)
 		snd_timer_interrupt(substream->timer, 1);
 #endif
  _end:
//flaw_line_below:
	snd_pcm_stream_unlock_irqrestore(substream, flags);
 	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
//fix_flaw_line_below:
//	snd_pcm_stream_unlock_irqrestore(substream, flags);
 }
",180017,"void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
{
	struct snd_pcm_runtime *runtime;
	unsigned long flags;

	if (PCM_RUNTIME_CHECK(substream))
		return;
	runtime = substream->runtime;

	snd_pcm_stream_lock_irqsave(substream, flags);
	if (!snd_pcm_running(substream) ||
	    snd_pcm_update_hw_ptr0(substream, 1) < 0)
		goto _end;

#ifdef CONFIG_SND_PCM_TIMER
	if (substream->timer_running)
 		snd_timer_interrupt(substream->timer, 1);
 #endif
  _end:
	snd_pcm_stream_unlock_irqrestore(substream, flags);
 	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
 }
","void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
{
	struct snd_pcm_runtime *runtime;
	unsigned long flags;

	if (PCM_RUNTIME_CHECK(substream))
		return;
	runtime = substream->runtime;

	snd_pcm_stream_lock_irqsave(substream, flags);
	if (!snd_pcm_running(substream) ||
	    snd_pcm_update_hw_ptr0(substream, 1) < 0)
		goto _end;

#ifdef CONFIG_SND_PCM_TIMER
	if (substream->timer_running)
 		snd_timer_interrupt(substream->timer, 1);
 #endif
  _end:
 	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
	snd_pcm_stream_unlock_irqrestore(substream, flags);
 }
","The vulnerability in the original code lies in the order of operations regarding the locking mechanism. The function `snd_pcm_stream_unlock_irqrestore(substream, flags)` was called after `kill_fasync(&runtime->fasync, SIGIO, POLL_IN)`, which could lead to a race condition if an interrupt occurred during the execution of `kill_fasync`, potentially allowing concurrent access to shared resources. In the fixed code, the order was corrected by moving `snd_pcm_stream_unlock_irqrestore(substream, flags)` to follow the `kill_fasync` call, ensuring that the stream is properly unlocked only after the asynchronous notification is sent, thus mitigating the race condition vulnerability.","The vulnerability in the original code stems from the improper handling of a locking mechanism, which could lead to a race condition. Specifically, the code allowed for the possibility of concurrent access to shared resources while performing critical operations, as the unlocking of the stream occurred after sending an asynchronous notification. This could result in inconsistent states or data corruption if an interrupt occurred during the notification process. The fixed code addressed this issue by rearranging the order of operations, ensuring that the stream was properly unlocked only after the critical operation was completed, thereby enhancing the overall safety and integrity of the code."
11,180030,180030,,Local,Not required,Complete,CVE-2016-9576,https://www.cvedetails.com/cve/CVE-2016-9576/,CWE-416,Low,Complete,Complete,,2016-12-28,7.2,"The blk_rq_map_user_iov function in block/blk-map.c in the Linux kernel before 4.8.14 does not properly restrict the type of iterator, which allows local users to read or write to arbitrary kernel memory locations or cause a denial of service (use-after-free) by leveraging access to a /dev/sg device.",2018-01-04,DoS ,4,https://github.com/torvalds/linux/commit/a0ac402cfcdc904f9772e1762b3fda112dcc56a0,a0ac402cfcdc904f9772e1762b3fda112dcc56a0,"Don't feed anything but regular iovec's to blk_rq_map_user_iov

In theory we could map other things, but there's a reason that function
is called ""user_iov"".  Using anything else (like splice can do) just
confuses it.

Reported-and-tested-by: Johannes Thumshirn <jthumshirn@suse.de>
Cc: Al Viro <viro@ZenIV.linux.org.uk>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,block/blk-map.c,"{""sha"": ""27fd8d92892d47e3478d9bcf3e1294a8eb28da89"", ""filename"": ""block/blk-map.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/a0ac402cfcdc904f9772e1762b3fda112dcc56a0/block/blk-map.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a0ac402cfcdc904f9772e1762b3fda112dcc56a0/block/blk-map.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/block/blk-map.c?ref=a0ac402cfcdc904f9772e1762b3fda112dcc56a0"", ""patch"": ""@@ -118,6 +118,9 @@ int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n \tstruct iov_iter i;\n \tint ret;\n \n+\tif (!iter_is_iovec(iter))\n+\t\tgoto fail;\n+\n \tif (map_data)\n \t\tcopy = true;\n \telse if (iov_iter_alignment(iter) & align)\n@@ -140,6 +143,7 @@ int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n \n unmap_rq:\n \t__blk_rq_unmap_user(bio);\n+fail:\n \trq->bio = NULL;\n \treturn -EINVAL;\n }""}","int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,
			struct rq_map_data *map_data,
			const struct iov_iter *iter, gfp_t gfp_mask)
{
	bool copy = false;
	unsigned long align = q->dma_pad_mask | queue_dma_alignment(q);
	struct bio *bio = NULL;
 	struct iov_iter i;
 	int ret;
 
	if (!iter_is_iovec(iter))
		goto fail;

 	if (map_data)
 		copy = true;
 	else if (iov_iter_alignment(iter) & align)
		copy = true;
	else if (queue_virt_boundary(q))
		copy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);

	i = *iter;
	do {
		ret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);
		if (ret)
			goto unmap_rq;
		if (!bio)
			bio = rq->bio;
	} while (iov_iter_count(&i));

	if (!bio_flagged(bio, BIO_USER_MAPPED))
		rq->cmd_flags |= REQ_COPY_USER;
	return 0;
 
 unmap_rq:
 	__blk_rq_unmap_user(bio);
fail:
 	rq->bio = NULL;
 	return -EINVAL;
 }
","int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,
			struct rq_map_data *map_data,
			const struct iov_iter *iter, gfp_t gfp_mask)
{
	bool copy = false;
	unsigned long align = q->dma_pad_mask | queue_dma_alignment(q);
	struct bio *bio = NULL;
 	struct iov_iter i;
 	int ret;
 
 	if (map_data)
 		copy = true;
 	else if (iov_iter_alignment(iter) & align)
		copy = true;
	else if (queue_virt_boundary(q))
		copy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);

	i = *iter;
	do {
		ret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);
		if (ret)
			goto unmap_rq;
		if (!bio)
			bio = rq->bio;
	} while (iov_iter_count(&i));

	if (!bio_flagged(bio, BIO_USER_MAPPED))
		rq->cmd_flags |= REQ_COPY_USER;
	return 0;
 
 unmap_rq:
 	__blk_rq_unmap_user(bio);
 	rq->bio = NULL;
 	return -EINVAL;
 }
",C,"	if (!iter_is_iovec(iter))
		goto fail;

fail:
",,,"@@ -118,6 +118,9 @@ int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,
 	struct iov_iter i;
 	int ret;
 
+	if (!iter_is_iovec(iter))
+		goto fail;
+
 	if (map_data)
 		copy = true;
 	else if (iov_iter_alignment(iter) & align)
@@ -140,6 +143,7 @@ int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,
 
 unmap_rq:
 	__blk_rq_unmap_user(bio);
+fail:
 	rq->bio = NULL;
 	return -EINVAL;
 }",linux,a0ac402cfcdc904f9772e1762b3fda112dcc56a0,bc3913a5378cd0ddefd1dfec6917cc12eb23a946,1,"int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,
			struct rq_map_data *map_data,
			const struct iov_iter *iter, gfp_t gfp_mask)
{
	bool copy = false;
	unsigned long align = q->dma_pad_mask | queue_dma_alignment(q);
	struct bio *bio = NULL;
 	struct iov_iter i;
 	int ret;
 
//fix_flaw_line_below:
//	if (!iter_is_iovec(iter))
//fix_flaw_line_below:
//		goto fail;
//fix_flaw_line_below:
//
 	if (map_data)
 		copy = true;
 	else if (iov_iter_alignment(iter) & align)
		copy = true;
	else if (queue_virt_boundary(q))
		copy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);

	i = *iter;
	do {
		ret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);
		if (ret)
			goto unmap_rq;
		if (!bio)
			bio = rq->bio;
	} while (iov_iter_count(&i));

	if (!bio_flagged(bio, BIO_USER_MAPPED))
		rq->cmd_flags |= REQ_COPY_USER;
	return 0;
 
 unmap_rq:
 	__blk_rq_unmap_user(bio);
//fix_flaw_line_below:
//fail:
 	rq->bio = NULL;
 	return -EINVAL;
 }
",180030,"int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,
			struct rq_map_data *map_data,
			const struct iov_iter *iter, gfp_t gfp_mask)
{
	bool copy = false;
	unsigned long align = q->dma_pad_mask | queue_dma_alignment(q);
	struct bio *bio = NULL;
 	struct iov_iter i;
 	int ret;
 
 	if (map_data)
 		copy = true;
 	else if (iov_iter_alignment(iter) & align)
		copy = true;
	else if (queue_virt_boundary(q))
		copy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);

	i = *iter;
	do {
		ret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);
		if (ret)
			goto unmap_rq;
		if (!bio)
			bio = rq->bio;
	} while (iov_iter_count(&i));

	if (!bio_flagged(bio, BIO_USER_MAPPED))
		rq->cmd_flags |= REQ_COPY_USER;
	return 0;
 
 unmap_rq:
 	__blk_rq_unmap_user(bio);
 	rq->bio = NULL;
 	return -EINVAL;
 }
","int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,
			struct rq_map_data *map_data,
			const struct iov_iter *iter, gfp_t gfp_mask)
{
	bool copy = false;
	unsigned long align = q->dma_pad_mask | queue_dma_alignment(q);
	struct bio *bio = NULL;
 	struct iov_iter i;
 	int ret;
 
	if (!iter_is_iovec(iter))
		goto fail;

 	if (map_data)
 		copy = true;
 	else if (iov_iter_alignment(iter) & align)
		copy = true;
	else if (queue_virt_boundary(q))
		copy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);

	i = *iter;
	do {
		ret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);
		if (ret)
			goto unmap_rq;
		if (!bio)
			bio = rq->bio;
	} while (iov_iter_count(&i));

	if (!bio_flagged(bio, BIO_USER_MAPPED))
		rq->cmd_flags |= REQ_COPY_USER;
	return 0;
 
 unmap_rq:
 	__blk_rq_unmap_user(bio);
fail:
 	rq->bio = NULL;
 	return -EINVAL;
 }
","The vulnerability in the original code lies in the lack of validation for the `iter` parameter, which could lead to undefined behavior if it points to an invalid or malicious memory region. This oversight allows potential exploitation, such as memory corruption or access violations. The fix in the modified code introduces a check using `iter_is_iovec(iter)` to ensure that the `iter` is a valid I/O vector before proceeding with the mapping process. If the check fails, the function jumps to the `fail` label, ensuring that the request is safely handled and preventing further processing with potentially unsafe data.","The vulnerability in the original code stems from the absence of validation for a critical input parameter, which could allow for the processing of invalid or malicious data. This oversight could lead to undefined behavior, including memory corruption or access violations, potentially enabling an attacker to exploit the system. The revised code addresses this issue by implementing a validation check to ensure that the input parameter is legitimate before any further processing occurs. If the validation fails, the function safely exits, preventing any operations that could compromise system integrity or security."
12,180071,180071,,Remote,Not required,Complete,CVE-2016-9120,https://www.cvedetails.com/cve/CVE-2016-9120/,CWE-416,Medium,Complete,Complete,,2016-12-08,9.3,Race condition in the ion_ioctl function in drivers/staging/android/ion/ion.c in the Linux kernel before 4.6 allows local users to gain privileges or cause a denial of service (use-after-free) by calling ION_IOC_FREE on two CPUs at the same time.,2016-12-09,DoS +Priv ,8,https://github.com/torvalds/linux/commit/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,"staging/android/ion : fix a race condition in the ion driver

There is a use-after-free problem in the ion driver.
This is caused by a race condition in the ion_ioctl()
function.

A handle has ref count of 1 and two tasks on different
cpus calls ION_IOC_FREE simultaneously.

cpu 0                                   cpu 1
-------------------------------------------------------
ion_handle_get_by_id()
(ref == 2)
                            ion_handle_get_by_id()
                            (ref == 3)

ion_free()
(ref == 2)

ion_handle_put()
(ref == 1)

                            ion_free()
                            (ref == 0 so ion_handle_destroy() is
                            called
                            and the handle is freed.)

                            ion_handle_put() is called and it
                            decreases the slub's next free pointer

The problem is detected as an unaligned access in the
spin lock functions since it uses load exclusive
 instruction. In some cases it corrupts the slub's
free pointer which causes a mis-aligned access to the
next free pointer.(kmalloc returns a pointer like
ffffc0745b4580aa). And it causes lots of other
hard-to-debug problems.

This symptom is caused since the first member in the
ion_handle structure is the reference count and the
ion driver decrements the reference after it has been
freed.

To fix this problem client->lock mutex is extended
to protect all the codes that uses the handle.

Signed-off-by: Eun Taik Lee <eun.taik.lee@samsung.com>
Reviewed-by: Laura Abbott <labbott@redhat.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",4,drivers/staging/android/ion/ion.c,"{""sha"": ""33b390e7ea31174558dd95e5da961a61464999e3"", ""filename"": ""drivers/staging/android/ion/ion.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 13, ""changes"": 55, ""blob_url"": ""https://github.com/torvalds/linux/blob/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7/drivers/staging/android/ion/ion.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7/drivers/staging/android/ion/ion.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/staging/android/ion/ion.c?ref=9590232bb4f4cc824f3425a6e1349afbe6d6d2b7"", ""patch"": ""@@ -387,13 +387,22 @@ static void ion_handle_get(struct ion_handle *handle)\n \tkref_get(&handle->ref);\n }\n \n-static int ion_handle_put(struct ion_handle *handle)\n+static int ion_handle_put_nolock(struct ion_handle *handle)\n+{\n+\tint ret;\n+\n+\tret = kref_put(&handle->ref, ion_handle_destroy);\n+\n+\treturn ret;\n+}\n+\n+int ion_handle_put(struct ion_handle *handle)\n {\n \tstruct ion_client *client = handle->client;\n \tint ret;\n \n \tmutex_lock(&client->lock);\n-\tret = kref_put(&handle->ref, ion_handle_destroy);\n+\tret = ion_handle_put_nolock(handle);\n \tmutex_unlock(&client->lock);\n \n \treturn ret;\n@@ -417,20 +426,30 @@ static struct ion_handle *ion_handle_lookup(struct ion_client *client,\n \treturn ERR_PTR(-EINVAL);\n }\n \n-static struct ion_handle *ion_handle_get_by_id(struct ion_client *client,\n+static struct ion_handle *ion_handle_get_by_id_nolock(struct ion_client *client,\n \t\t\t\t\t\tint id)\n {\n \tstruct ion_handle *handle;\n \n-\tmutex_lock(&client->lock);\n \thandle = idr_find(&client->idr, id);\n \tif (handle)\n \t\tion_handle_get(handle);\n-\tmutex_unlock(&client->lock);\n \n \treturn handle ? handle : ERR_PTR(-EINVAL);\n }\n \n+struct ion_handle *ion_handle_get_by_id(struct ion_client *client,\n+\t\t\t\t\t\tint id)\n+{\n+\tstruct ion_handle *handle;\n+\n+\tmutex_lock(&client->lock);\n+\thandle = ion_handle_get_by_id_nolock(client, id);\n+\tmutex_unlock(&client->lock);\n+\n+\treturn handle;\n+}\n+\n static bool ion_handle_validate(struct ion_client *client,\n \t\t\t\tstruct ion_handle *handle)\n {\n@@ -532,22 +551,28 @@ struct ion_handle *ion_alloc(struct ion_client *client, size_t len,\n }\n EXPORT_SYMBOL(ion_alloc);\n \n-void ion_free(struct ion_client *client, struct ion_handle *handle)\n+static void ion_free_nolock(struct ion_client *client, struct ion_handle *handle)\n {\n \tbool valid_handle;\n \n \tBUG_ON(client != handle->client);\n \n-\tmutex_lock(&client->lock);\n \tvalid_handle = ion_handle_validate(client, handle);\n \n \tif (!valid_handle) {\n \t\tWARN(1, \""%s: invalid handle passed to free.\\n\"", __func__);\n-\t\tmutex_unlock(&client->lock);\n \t\treturn;\n \t}\n+\tion_handle_put_nolock(handle);\n+}\n+\n+void ion_free(struct ion_client *client, struct ion_handle *handle)\n+{\n+\tBUG_ON(client != handle->client);\n+\n+\tmutex_lock(&client->lock);\n+\tion_free_nolock(client, handle);\n \tmutex_unlock(&client->lock);\n-\tion_handle_put(handle);\n }\n EXPORT_SYMBOL(ion_free);\n \n@@ -1332,11 +1357,15 @@ static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n \t{\n \t\tstruct ion_handle *handle;\n \n-\t\thandle = ion_handle_get_by_id(client, data.handle.handle);\n-\t\tif (IS_ERR(handle))\n+\t\tmutex_lock(&client->lock);\n+\t\thandle = ion_handle_get_by_id_nolock(client, data.handle.handle);\n+\t\tif (IS_ERR(handle)) {\n+\t\t\tmutex_unlock(&client->lock);\n \t\t\treturn PTR_ERR(handle);\n-\t\tion_free(client, handle);\n-\t\tion_handle_put(handle);\n+\t\t}\n+\t\tion_free_nolock(client, handle);\n+\t\tion_handle_put_nolock(handle);\n+\t\tmutex_unlock(&client->lock);\n \t\tbreak;\n \t}\n \tcase ION_IOC_SHARE:""}","static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	struct ion_client *client = filp->private_data;
	struct ion_device *dev = client->dev;
	struct ion_handle *cleanup_handle = NULL;
	int ret = 0;
	unsigned int dir;

	union {
		struct ion_fd_data fd;
		struct ion_allocation_data allocation;
		struct ion_handle_data handle;
		struct ion_custom_data custom;
	} data;

	dir = ion_ioctl_dir(cmd);

	if (_IOC_SIZE(cmd) > sizeof(data))
		return -EINVAL;

	if (dir & _IOC_WRITE)
		if (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))
			return -EFAULT;

	switch (cmd) {
	case ION_IOC_ALLOC:
	{
		struct ion_handle *handle;

		handle = ion_alloc(client, data.allocation.len,
						data.allocation.align,
						data.allocation.heap_id_mask,
						data.allocation.flags);
		if (IS_ERR(handle))
			return PTR_ERR(handle);

		data.allocation.handle = handle->id;

		cleanup_handle = handle;
		break;
	}
	case ION_IOC_FREE:
 	{
 		struct ion_handle *handle;
 
		mutex_lock(&client->lock);
		handle = ion_handle_get_by_id_nolock(client, data.handle.handle);
		if (IS_ERR(handle)) {
			mutex_unlock(&client->lock);
 			return PTR_ERR(handle);
		}
		ion_free_nolock(client, handle);
		ion_handle_put_nolock(handle);
		mutex_unlock(&client->lock);
 		break;
 	}
 	case ION_IOC_SHARE:
	case ION_IOC_MAP:
	{
		struct ion_handle *handle;

		handle = ion_handle_get_by_id(client, data.handle.handle);
		if (IS_ERR(handle))
			return PTR_ERR(handle);
		data.fd.fd = ion_share_dma_buf_fd(client, handle);
		ion_handle_put(handle);
		if (data.fd.fd < 0)
			ret = data.fd.fd;
		break;
	}
	case ION_IOC_IMPORT:
	{
		struct ion_handle *handle;

		handle = ion_import_dma_buf_fd(client, data.fd.fd);
		if (IS_ERR(handle))
			ret = PTR_ERR(handle);
		else
			data.handle.handle = handle->id;
		break;
	}
	case ION_IOC_SYNC:
	{
		ret = ion_sync_for_device(client, data.fd.fd);
		break;
	}
	case ION_IOC_CUSTOM:
	{
		if (!dev->custom_ioctl)
			return -ENOTTY;
		ret = dev->custom_ioctl(client, data.custom.cmd,
						data.custom.arg);
		break;
	}
	default:
		return -ENOTTY;
	}

	if (dir & _IOC_READ) {
		if (copy_to_user((void __user *)arg, &data, _IOC_SIZE(cmd))) {
			if (cleanup_handle)
				ion_free(client, cleanup_handle);
			return -EFAULT;
		}
	}
	return ret;
}
","static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	struct ion_client *client = filp->private_data;
	struct ion_device *dev = client->dev;
	struct ion_handle *cleanup_handle = NULL;
	int ret = 0;
	unsigned int dir;

	union {
		struct ion_fd_data fd;
		struct ion_allocation_data allocation;
		struct ion_handle_data handle;
		struct ion_custom_data custom;
	} data;

	dir = ion_ioctl_dir(cmd);

	if (_IOC_SIZE(cmd) > sizeof(data))
		return -EINVAL;

	if (dir & _IOC_WRITE)
		if (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))
			return -EFAULT;

	switch (cmd) {
	case ION_IOC_ALLOC:
	{
		struct ion_handle *handle;

		handle = ion_alloc(client, data.allocation.len,
						data.allocation.align,
						data.allocation.heap_id_mask,
						data.allocation.flags);
		if (IS_ERR(handle))
			return PTR_ERR(handle);

		data.allocation.handle = handle->id;

		cleanup_handle = handle;
		break;
	}
	case ION_IOC_FREE:
 	{
 		struct ion_handle *handle;
 
		handle = ion_handle_get_by_id(client, data.handle.handle);
		if (IS_ERR(handle))
 			return PTR_ERR(handle);
		ion_free(client, handle);
		ion_handle_put(handle);
 		break;
 	}
 	case ION_IOC_SHARE:
	case ION_IOC_MAP:
	{
		struct ion_handle *handle;

		handle = ion_handle_get_by_id(client, data.handle.handle);
		if (IS_ERR(handle))
			return PTR_ERR(handle);
		data.fd.fd = ion_share_dma_buf_fd(client, handle);
		ion_handle_put(handle);
		if (data.fd.fd < 0)
			ret = data.fd.fd;
		break;
	}
	case ION_IOC_IMPORT:
	{
		struct ion_handle *handle;

		handle = ion_import_dma_buf_fd(client, data.fd.fd);
		if (IS_ERR(handle))
			ret = PTR_ERR(handle);
		else
			data.handle.handle = handle->id;
		break;
	}
	case ION_IOC_SYNC:
	{
		ret = ion_sync_for_device(client, data.fd.fd);
		break;
	}
	case ION_IOC_CUSTOM:
	{
		if (!dev->custom_ioctl)
			return -ENOTTY;
		ret = dev->custom_ioctl(client, data.custom.cmd,
						data.custom.arg);
		break;
	}
	default:
		return -ENOTTY;
	}

	if (dir & _IOC_READ) {
		if (copy_to_user((void __user *)arg, &data, _IOC_SIZE(cmd))) {
			if (cleanup_handle)
				ion_free(client, cleanup_handle);
			return -EFAULT;
		}
	}
	return ret;
}
",C,"		mutex_lock(&client->lock);
		handle = ion_handle_get_by_id_nolock(client, data.handle.handle);
		if (IS_ERR(handle)) {
			mutex_unlock(&client->lock);
		}
		ion_free_nolock(client, handle);
		ion_handle_put_nolock(handle);
		mutex_unlock(&client->lock);
","		handle = ion_handle_get_by_id(client, data.handle.handle);
		if (IS_ERR(handle))
		ion_free(client, handle);
		ion_handle_put(handle);
",,"@@ -387,13 +387,22 @@ static void ion_handle_get(struct ion_handle *handle)
 	kref_get(&handle->ref);
 }
 
-static int ion_handle_put(struct ion_handle *handle)
+static int ion_handle_put_nolock(struct ion_handle *handle)
+{
+	int ret;
+
+	ret = kref_put(&handle->ref, ion_handle_destroy);
+
+	return ret;
+}
+
+int ion_handle_put(struct ion_handle *handle)
 {
 	struct ion_client *client = handle->client;
 	int ret;
 
 	mutex_lock(&client->lock);
-	ret = kref_put(&handle->ref, ion_handle_destroy);
+	ret = ion_handle_put_nolock(handle);
 	mutex_unlock(&client->lock);
 
 	return ret;
@@ -417,20 +426,30 @@ static struct ion_handle *ion_handle_lookup(struct ion_client *client,
 	return ERR_PTR(-EINVAL);
 }
 
-static struct ion_handle *ion_handle_get_by_id(struct ion_client *client,
+static struct ion_handle *ion_handle_get_by_id_nolock(struct ion_client *client,
 						int id)
 {
 	struct ion_handle *handle;
 
-	mutex_lock(&client->lock);
 	handle = idr_find(&client->idr, id);
 	if (handle)
 		ion_handle_get(handle);
-	mutex_unlock(&client->lock);
 
 	return handle ? handle : ERR_PTR(-EINVAL);
 }
 
+struct ion_handle *ion_handle_get_by_id(struct ion_client *client,
+						int id)
+{
+	struct ion_handle *handle;
+
+	mutex_lock(&client->lock);
+	handle = ion_handle_get_by_id_nolock(client, id);
+	mutex_unlock(&client->lock);
+
+	return handle;
+}
+
 static bool ion_handle_validate(struct ion_client *client,
 				struct ion_handle *handle)
 {
@@ -532,22 +551,28 @@ struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
 }
 EXPORT_SYMBOL(ion_alloc);
 
-void ion_free(struct ion_client *client, struct ion_handle *handle)
+static void ion_free_nolock(struct ion_client *client, struct ion_handle *handle)
 {
 	bool valid_handle;
 
 	BUG_ON(client != handle->client);
 
-	mutex_lock(&client->lock);
 	valid_handle = ion_handle_validate(client, handle);
 
 	if (!valid_handle) {
 		WARN(1, ""%s: invalid handle passed to free.\n"", __func__);
-		mutex_unlock(&client->lock);
 		return;
 	}
+	ion_handle_put_nolock(handle);
+}
+
+void ion_free(struct ion_client *client, struct ion_handle *handle)
+{
+	BUG_ON(client != handle->client);
+
+	mutex_lock(&client->lock);
+	ion_free_nolock(client, handle);
 	mutex_unlock(&client->lock);
-	ion_handle_put(handle);
 }
 EXPORT_SYMBOL(ion_free);
 
@@ -1332,11 +1357,15 @@ static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 	{
 		struct ion_handle *handle;
 
-		handle = ion_handle_get_by_id(client, data.handle.handle);
-		if (IS_ERR(handle))
+		mutex_lock(&client->lock);
+		handle = ion_handle_get_by_id_nolock(client, data.handle.handle);
+		if (IS_ERR(handle)) {
+			mutex_unlock(&client->lock);
 			return PTR_ERR(handle);
-		ion_free(client, handle);
-		ion_handle_put(handle);
+		}
+		ion_free_nolock(client, handle);
+		ion_handle_put_nolock(handle);
+		mutex_unlock(&client->lock);
 		break;
 	}
 	case ION_IOC_SHARE:",linux,9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,5a20df724f712e9daa9fd41b430ff63ecd203e85,1,"static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	struct ion_client *client = filp->private_data;
	struct ion_device *dev = client->dev;
	struct ion_handle *cleanup_handle = NULL;
	int ret = 0;
	unsigned int dir;

	union {
		struct ion_fd_data fd;
		struct ion_allocation_data allocation;
		struct ion_handle_data handle;
		struct ion_custom_data custom;
	} data;

	dir = ion_ioctl_dir(cmd);

	if (_IOC_SIZE(cmd) > sizeof(data))
		return -EINVAL;

	if (dir & _IOC_WRITE)
		if (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))
			return -EFAULT;

	switch (cmd) {
	case ION_IOC_ALLOC:
	{
		struct ion_handle *handle;

		handle = ion_alloc(client, data.allocation.len,
						data.allocation.align,
						data.allocation.heap_id_mask,
						data.allocation.flags);
		if (IS_ERR(handle))
			return PTR_ERR(handle);

		data.allocation.handle = handle->id;

		cleanup_handle = handle;
		break;
	}
	case ION_IOC_FREE:
 	{
 		struct ion_handle *handle;
 
//flaw_line_below:
		handle = ion_handle_get_by_id(client, data.handle.handle);
//flaw_line_below:
		if (IS_ERR(handle))
//fix_flaw_line_below:
//		mutex_lock(&client->lock);
//fix_flaw_line_below:
//		handle = ion_handle_get_by_id_nolock(client, data.handle.handle);
//fix_flaw_line_below:
//		if (IS_ERR(handle)) {
//fix_flaw_line_below:
//			mutex_unlock(&client->lock);
 			return PTR_ERR(handle);
//flaw_line_below:
		ion_free(client, handle);
//flaw_line_below:
		ion_handle_put(handle);
//fix_flaw_line_below:
//		}
//fix_flaw_line_below:
//		ion_free_nolock(client, handle);
//fix_flaw_line_below:
//		ion_handle_put_nolock(handle);
//fix_flaw_line_below:
//		mutex_unlock(&client->lock);
 		break;
 	}
 	case ION_IOC_SHARE:
	case ION_IOC_MAP:
	{
		struct ion_handle *handle;

		handle = ion_handle_get_by_id(client, data.handle.handle);
		if (IS_ERR(handle))
			return PTR_ERR(handle);
		data.fd.fd = ion_share_dma_buf_fd(client, handle);
		ion_handle_put(handle);
		if (data.fd.fd < 0)
			ret = data.fd.fd;
		break;
	}
	case ION_IOC_IMPORT:
	{
		struct ion_handle *handle;

		handle = ion_import_dma_buf_fd(client, data.fd.fd);
		if (IS_ERR(handle))
			ret = PTR_ERR(handle);
		else
			data.handle.handle = handle->id;
		break;
	}
	case ION_IOC_SYNC:
	{
		ret = ion_sync_for_device(client, data.fd.fd);
		break;
	}
	case ION_IOC_CUSTOM:
	{
		if (!dev->custom_ioctl)
			return -ENOTTY;
		ret = dev->custom_ioctl(client, data.custom.cmd,
						data.custom.arg);
		break;
	}
	default:
		return -ENOTTY;
	}

	if (dir & _IOC_READ) {
		if (copy_to_user((void __user *)arg, &data, _IOC_SIZE(cmd))) {
			if (cleanup_handle)
				ion_free(client, cleanup_handle);
			return -EFAULT;
		}
	}
	return ret;
}
",180071,"static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	struct ion_client *client = filp->private_data;
	struct ion_device *dev = client->dev;
	struct ion_handle *cleanup_handle = NULL;
	int ret = 0;
	unsigned int dir;

	union {
		struct ion_fd_data fd;
		struct ion_allocation_data allocation;
		struct ion_handle_data handle;
		struct ion_custom_data custom;
	} data;

	dir = ion_ioctl_dir(cmd);

	if (_IOC_SIZE(cmd) > sizeof(data))
		return -EINVAL;

	if (dir & _IOC_WRITE)
		if (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))
			return -EFAULT;

	switch (cmd) {
	case ION_IOC_ALLOC:
	{
		struct ion_handle *handle;

		handle = ion_alloc(client, data.allocation.len,
						data.allocation.align,
						data.allocation.heap_id_mask,
						data.allocation.flags);
		if (IS_ERR(handle))
			return PTR_ERR(handle);

		data.allocation.handle = handle->id;

		cleanup_handle = handle;
		break;
	}
	case ION_IOC_FREE:
 	{
 		struct ion_handle *handle;
 
		handle = ion_handle_get_by_id(client, data.handle.handle);
		if (IS_ERR(handle))
 			return PTR_ERR(handle);
		ion_free(client, handle);
		ion_handle_put(handle);
 		break;
 	}
 	case ION_IOC_SHARE:
	case ION_IOC_MAP:
	{
		struct ion_handle *handle;

		handle = ion_handle_get_by_id(client, data.handle.handle);
		if (IS_ERR(handle))
			return PTR_ERR(handle);
		data.fd.fd = ion_share_dma_buf_fd(client, handle);
		ion_handle_put(handle);
		if (data.fd.fd < 0)
			ret = data.fd.fd;
		break;
	}
	case ION_IOC_IMPORT:
	{
		struct ion_handle *handle;

		handle = ion_import_dma_buf_fd(client, data.fd.fd);
		if (IS_ERR(handle))
			ret = PTR_ERR(handle);
		else
			data.handle.handle = handle->id;
		break;
	}
	case ION_IOC_SYNC:
	{
		ret = ion_sync_for_device(client, data.fd.fd);
		break;
	}
	case ION_IOC_CUSTOM:
	{
		if (!dev->custom_ioctl)
			return -ENOTTY;
		ret = dev->custom_ioctl(client, data.custom.cmd,
						data.custom.arg);
		break;
	}
	default:
		return -ENOTTY;
	}

	if (dir & _IOC_READ) {
		if (copy_to_user((void __user *)arg, &data, _IOC_SIZE(cmd))) {
			if (cleanup_handle)
				ion_free(client, cleanup_handle);
			return -EFAULT;
		}
	}
	return ret;
}
","static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	struct ion_client *client = filp->private_data;
	struct ion_device *dev = client->dev;
	struct ion_handle *cleanup_handle = NULL;
	int ret = 0;
	unsigned int dir;

	union {
		struct ion_fd_data fd;
		struct ion_allocation_data allocation;
		struct ion_handle_data handle;
		struct ion_custom_data custom;
	} data;

	dir = ion_ioctl_dir(cmd);

	if (_IOC_SIZE(cmd) > sizeof(data))
		return -EINVAL;

	if (dir & _IOC_WRITE)
		if (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))
			return -EFAULT;

	switch (cmd) {
	case ION_IOC_ALLOC:
	{
		struct ion_handle *handle;

		handle = ion_alloc(client, data.allocation.len,
						data.allocation.align,
						data.allocation.heap_id_mask,
						data.allocation.flags);
		if (IS_ERR(handle))
			return PTR_ERR(handle);

		data.allocation.handle = handle->id;

		cleanup_handle = handle;
		break;
	}
	case ION_IOC_FREE:
 	{
 		struct ion_handle *handle;
 
		mutex_lock(&client->lock);
		handle = ion_handle_get_by_id_nolock(client, data.handle.handle);
		if (IS_ERR(handle)) {
			mutex_unlock(&client->lock);
 			return PTR_ERR(handle);
		}
		ion_free_nolock(client, handle);
		ion_handle_put_nolock(handle);
		mutex_unlock(&client->lock);
 		break;
 	}
 	case ION_IOC_SHARE:
	case ION_IOC_MAP:
	{
		struct ion_handle *handle;

		handle = ion_handle_get_by_id(client, data.handle.handle);
		if (IS_ERR(handle))
			return PTR_ERR(handle);
		data.fd.fd = ion_share_dma_buf_fd(client, handle);
		ion_handle_put(handle);
		if (data.fd.fd < 0)
			ret = data.fd.fd;
		break;
	}
	case ION_IOC_IMPORT:
	{
		struct ion_handle *handle;

		handle = ion_import_dma_buf_fd(client, data.fd.fd);
		if (IS_ERR(handle))
			ret = PTR_ERR(handle);
		else
			data.handle.handle = handle->id;
		break;
	}
	case ION_IOC_SYNC:
	{
		ret = ion_sync_for_device(client, data.fd.fd);
		break;
	}
	case ION_IOC_CUSTOM:
	{
		if (!dev->custom_ioctl)
			return -ENOTTY;
		ret = dev->custom_ioctl(client, data.custom.cmd,
						data.custom.arg);
		break;
	}
	default:
		return -ENOTTY;
	}

	if (dir & _IOC_READ) {
		if (copy_to_user((void __user *)arg, &data, _IOC_SIZE(cmd))) {
			if (cleanup_handle)
				ion_free(client, cleanup_handle);
			return -EFAULT;
		}
	}
	return ret;
}
","The vulnerability in the original code lies in the lack of proper locking mechanisms when accessing shared resources, particularly in the `ION_IOC_FREE` case. This could lead to race conditions, where multiple threads might attempt to free or manipulate the same `ion_handle`, potentially causing memory corruption or crashes. The fix introduces a mutex lock (`mutex_lock(&client->lock)`) around the critical section where the handle is retrieved and freed, ensuring that only one thread can access this part of the code at a time. This change prevents concurrent access issues, enhancing the overall stability and security of the code.","The vulnerability in the original code stems from inadequate synchronization when accessing shared resources, which can lead to race conditions. Specifically, multiple threads could concurrently manipulate the same resource, resulting in potential memory corruption or crashes. The fix addresses this issue by implementing a locking mechanism that ensures only one thread can access the critical section of code at a time. This change effectively prevents concurrent access problems, thereby enhancing the stability and security of the code by ensuring that resource management operations are performed safely and consistently."
13,180096,180096,,Remote,Not required,Complete,CVE-2016-7912,https://www.cvedetails.com/cve/CVE-2016-7912/,CWE-416,Medium,Complete,Complete,,2016-11-16,9.3,Use-after-free vulnerability in the ffs_user_copy_worker function in drivers/usb/gadget/function/f_fs.c in the Linux kernel before 4.5.3 allows local users to gain privileges by accessing an I/O data structure after a certain callback call.,2016-11-28,+Priv ,2,https://github.com/torvalds/linux/commit/38740a5b87d53ceb89eb2c970150f6e94e00373a,38740a5b87d53ceb89eb2c970150f6e94e00373a,"usb: gadget: f_fs: Fix use-after-free

When using asynchronous read or write operations on the USB endpoints the
issuer of the IO request is notified by calling the ki_complete() callback
of the submitted kiocb when the URB has been completed.

Calling this ki_complete() callback will free kiocb. Make sure that the
structure is no longer accessed beyond that point, otherwise undefined
behaviour might occur.

Fixes: 2e4c7553cd6f (""usb: gadget: f_fs: add aio support"")
Cc: <stable@vger.kernel.org> # v3.15+
Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>",3,drivers/usb/gadget/function/f_fs.c,"{""sha"": ""15b648cbc75c4141bb5c51bd03c2c6e5b5f6c821"", ""filename"": ""drivers/usb/gadget/function/f_fs.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/38740a5b87d53ceb89eb2c970150f6e94e00373a/drivers/usb/gadget/function/f_fs.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/38740a5b87d53ceb89eb2c970150f6e94e00373a/drivers/usb/gadget/function/f_fs.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/gadget/function/f_fs.c?ref=38740a5b87d53ceb89eb2c970150f6e94e00373a"", ""patch"": ""@@ -646,6 +646,7 @@ static void ffs_user_copy_worker(struct work_struct *work)\n \t\t\t\t\t\t   work);\n \tint ret = io_data->req->status ? io_data->req->status :\n \t\t\t\t\t io_data->req->actual;\n+\tbool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;\n \n \tif (io_data->read && ret > 0) {\n \t\tuse_mm(io_data->mm);\n@@ -657,13 +658,11 @@ static void ffs_user_copy_worker(struct work_struct *work)\n \n \tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n \n-\tif (io_data->ffs->ffs_eventfd &&\n-\t    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))\n+\tif (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)\n \t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n \n \tusb_ep_free_request(io_data->ep, io_data->req);\n \n-\tio_data->kiocb->private = NULL;\n \tif (io_data->read)\n \t\tkfree(io_data->to_free);\n \tkfree(io_data->buf);""}","static void ffs_user_copy_worker(struct work_struct *work)
{
	struct ffs_io_data *io_data = container_of(work, struct ffs_io_data,
 						   work);
 	int ret = io_data->req->status ? io_data->req->status :
 					 io_data->req->actual;
	bool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;
 
 	if (io_data->read && ret > 0) {
 		use_mm(io_data->mm);
		ret = copy_to_iter(io_data->buf, ret, &io_data->data);
		if (iov_iter_count(&io_data->data))
			ret = -EFAULT;
		unuse_mm(io_data->mm);
	}
 
 	io_data->kiocb->ki_complete(io_data->kiocb, ret, ret);
 
	if (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)
 		eventfd_signal(io_data->ffs->ffs_eventfd, 1);
 
 	usb_ep_free_request(io_data->ep, io_data->req);
 
 	if (io_data->read)
 		kfree(io_data->to_free);
 	kfree(io_data->buf);
	kfree(io_data);
}
","static void ffs_user_copy_worker(struct work_struct *work)
{
	struct ffs_io_data *io_data = container_of(work, struct ffs_io_data,
 						   work);
 	int ret = io_data->req->status ? io_data->req->status :
 					 io_data->req->actual;
 
 	if (io_data->read && ret > 0) {
 		use_mm(io_data->mm);
		ret = copy_to_iter(io_data->buf, ret, &io_data->data);
		if (iov_iter_count(&io_data->data))
			ret = -EFAULT;
		unuse_mm(io_data->mm);
	}
 
 	io_data->kiocb->ki_complete(io_data->kiocb, ret, ret);
 
	if (io_data->ffs->ffs_eventfd &&
	    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))
 		eventfd_signal(io_data->ffs->ffs_eventfd, 1);
 
 	usb_ep_free_request(io_data->ep, io_data->req);
 
	io_data->kiocb->private = NULL;
 	if (io_data->read)
 		kfree(io_data->to_free);
 	kfree(io_data->buf);
	kfree(io_data);
}
",C,"	bool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;
	if (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)
","	if (io_data->ffs->ffs_eventfd &&
	    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))
	io_data->kiocb->private = NULL;
",,"@@ -646,6 +646,7 @@ static void ffs_user_copy_worker(struct work_struct *work)
 						   work);
 	int ret = io_data->req->status ? io_data->req->status :
 					 io_data->req->actual;
+	bool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;
 
 	if (io_data->read && ret > 0) {
 		use_mm(io_data->mm);
@@ -657,13 +658,11 @@ static void ffs_user_copy_worker(struct work_struct *work)
 
 	io_data->kiocb->ki_complete(io_data->kiocb, ret, ret);
 
-	if (io_data->ffs->ffs_eventfd &&
-	    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))
+	if (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)
 		eventfd_signal(io_data->ffs->ffs_eventfd, 1);
 
 	usb_ep_free_request(io_data->ep, io_data->req);
 
-	io_data->kiocb->private = NULL;
 	if (io_data->read)
 		kfree(io_data->to_free);
 	kfree(io_data->buf);",linux,38740a5b87d53ceb89eb2c970150f6e94e00373a,9772b47a4c2916d645c551228b6085ea24acbe5d,1,"static void ffs_user_copy_worker(struct work_struct *work)
{
	struct ffs_io_data *io_data = container_of(work, struct ffs_io_data,
 						   work);
 	int ret = io_data->req->status ? io_data->req->status :
 					 io_data->req->actual;
//fix_flaw_line_below:
//	bool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;
 
 	if (io_data->read && ret > 0) {
 		use_mm(io_data->mm);
		ret = copy_to_iter(io_data->buf, ret, &io_data->data);
		if (iov_iter_count(&io_data->data))
			ret = -EFAULT;
		unuse_mm(io_data->mm);
	}
 
 	io_data->kiocb->ki_complete(io_data->kiocb, ret, ret);
 
//flaw_line_below:
	if (io_data->ffs->ffs_eventfd &&
//flaw_line_below:
	    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))
//fix_flaw_line_below:
//	if (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)
 		eventfd_signal(io_data->ffs->ffs_eventfd, 1);
 
 	usb_ep_free_request(io_data->ep, io_data->req);
 
//flaw_line_below:
	io_data->kiocb->private = NULL;
 	if (io_data->read)
 		kfree(io_data->to_free);
 	kfree(io_data->buf);
	kfree(io_data);
}
",180096,"static void ffs_user_copy_worker(struct work_struct *work)
{
	struct ffs_io_data *io_data = container_of(work, struct ffs_io_data,
 						   work);
 	int ret = io_data->req->status ? io_data->req->status :
 					 io_data->req->actual;
 
 	if (io_data->read && ret > 0) {
 		use_mm(io_data->mm);
		ret = copy_to_iter(io_data->buf, ret, &io_data->data);
		if (iov_iter_count(&io_data->data))
			ret = -EFAULT;
		unuse_mm(io_data->mm);
	}
 
 	io_data->kiocb->ki_complete(io_data->kiocb, ret, ret);
 
	if (io_data->ffs->ffs_eventfd &&
	    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))
 		eventfd_signal(io_data->ffs->ffs_eventfd, 1);
 
 	usb_ep_free_request(io_data->ep, io_data->req);
 
	io_data->kiocb->private = NULL;
 	if (io_data->read)
 		kfree(io_data->to_free);
 	kfree(io_data->buf);
	kfree(io_data);
}
","static void ffs_user_copy_worker(struct work_struct *work)
{
	struct ffs_io_data *io_data = container_of(work, struct ffs_io_data,
 						   work);
 	int ret = io_data->req->status ? io_data->req->status :
 					 io_data->req->actual;
	bool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;
 
 	if (io_data->read && ret > 0) {
 		use_mm(io_data->mm);
		ret = copy_to_iter(io_data->buf, ret, &io_data->data);
		if (iov_iter_count(&io_data->data))
			ret = -EFAULT;
		unuse_mm(io_data->mm);
	}
 
 	io_data->kiocb->ki_complete(io_data->kiocb, ret, ret);
 
	if (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)
 		eventfd_signal(io_data->ffs->ffs_eventfd, 1);
 
 	usb_ep_free_request(io_data->ep, io_data->req);
 
 	if (io_data->read)
 		kfree(io_data->to_free);
 	kfree(io_data->buf);
	kfree(io_data);
}
","The vulnerability in the original code arises from the potential for a race condition when checking the `kiocb->ki_flags` for the `IOCB_EVENTFD` flag after the completion of the I/O operation. If the `kiocb` is modified by another thread before the check, it could lead to incorrect signaling of the event file descriptor, causing inconsistent behavior. In the fixed code, the check for the `IOCB_EVENTFD` flag is stored in the `kiocb_has_eventfd` boolean variable before the completion call, ensuring that the state is consistent and preventing race conditions, thus enhancing the reliability of the event signaling mechanism.","The vulnerability in the original code stems from a potential race condition that occurs when checking a specific flag after completing an I/O operation. This situation allows for the possibility that another thread could modify the flag's state before the check is performed, leading to inconsistent behavior in signaling an event. The fix addresses this issue by storing the flag's state in a separate variable prior to the completion call. This ensures that the check is based on a consistent value, thereby preventing race conditions and enhancing the overall reliability of the event signaling process."
14,180108,180108,,Remote,Not required,Partial,CVE-2016-7413,https://www.cvedetails.com/cve/CVE-2016-7413/,CWE-416,Low,Partial,Partial,,2016-09-17,7.5,"Use-after-free vulnerability in the wddx_stack_destroy function in ext/wddx/wddx.c in PHP before 5.6.26 and 7.x before 7.0.11 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a wddxPacket XML document that lacks an end-tag for a recordset field element, leading to mishandling in a wddx_deserialize call.",2018-05-03,DoS ,2,https://github.com/php/php-src/commit/b88393f08a558eec14964a55d3c680fe67407712?w=1,b88393f08a558eec14964a55d3c680fe67407712?w=1,Fix bug #72860: wddx_deserialize use-after-free,1,ext/wddx/wddx.c,"{""sha"": ""6385457e8ee41b58082462379a87030b1e2cfe23"", ""filename"": ""ext/wddx/tests/bug72860.phpt"", ""status"": ""added"", ""additions"": 27, ""deletions"": 0, ""changes"": 27, ""blob_url"": ""https://github.com/php/php-src/blob/b88393f08a558eec14964a55d3c680fe67407712/ext/wddx/tests/bug72860.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/b88393f08a558eec14964a55d3c680fe67407712/ext/wddx/tests/bug72860.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/tests/bug72860.phpt?ref=b88393f08a558eec14964a55d3c680fe67407712"", ""patch"": ""@@ -0,0 +1,27 @@\n+--TEST--\n+Bug #72860: wddx_deserialize use-after-free\n+--SKIPIF--\n+<?php\n+if (!extension_loaded('wddx')) {\n+    die('skip. wddx not available');\n+}\n+?>\n+--FILE--\n+<?php\n+\n+$xml=<<<XML\n+<?xml version='1.0'?>\n+<!DOCTYPE wddxPacket SYSTEM 'wddx_0100.dtd'>\n+<wddxPacket version='1.0'>\n+       <recordset fieldNames='F'>\n+               <field name='F'>\n+       </recordset>\n+</wddxPacket>\n+XML;\n+\n+var_dump(wddx_deserialize($xml));\n+?>\n+DONE\n+--EXPECT--\n+NULL\n+DONE\n\\ No newline at end of file""}<_**next**_>{""sha"": ""b02d2f07ded469c5ed8256e422428d3ce8bee637"", ""filename"": ""ext/wddx/wddx.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/php/php-src/blob/b88393f08a558eec14964a55d3c680fe67407712/ext/wddx/wddx.c"", ""raw_url"": ""https://github.com/php/php-src/raw/b88393f08a558eec14964a55d3c680fe67407712/ext/wddx/wddx.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/wddx.c?ref=b88393f08a558eec14964a55d3c680fe67407712"", ""patch"": ""@@ -230,7 +230,8 @@ static int wddx_stack_destroy(wddx_stack *stack)\n \n \tif (stack->elements) {\n \t\tfor (i = 0; i < stack->top; i++) {\n-\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n+\t\t\tif (((st_entry *)stack->elements[i])->data\n+\t\t\t\t\t&& ((st_entry *)stack->elements[i])->type != ST_FIELD)\t{\n \t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n \t\t\t}\n \t\t\tif (((st_entry *)stack->elements[i])->varname) {""}","static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
 
 	if (stack->elements) {
 		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data
					&& ((st_entry *)stack->elements[i])->type != ST_FIELD)	{
 				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
 			}
 			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;
}
","static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
 
 	if (stack->elements) {
 		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
 				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
 			}
 			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;
}
",C,"			if (((st_entry *)stack->elements[i])->data
					&& ((st_entry *)stack->elements[i])->type != ST_FIELD)	{
","			if (((st_entry *)stack->elements[i])->data)	{
",,"@@ -230,7 +230,8 @@ static int wddx_stack_destroy(wddx_stack *stack)
 
 	if (stack->elements) {
 		for (i = 0; i < stack->top; i++) {
-			if (((st_entry *)stack->elements[i])->data)	{
+			if (((st_entry *)stack->elements[i])->data
+					&& ((st_entry *)stack->elements[i])->type != ST_FIELD)	{
 				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
 			}
 			if (((st_entry *)stack->elements[i])->varname) {",php-src,b88393f08a558eec14964a55d3c680fe67407712?w=1,65c8caafa83ca78a8b2fa22257b4dea85b6114e5,1,"static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
 
 	if (stack->elements) {
 		for (i = 0; i < stack->top; i++) {
//flaw_line_below:
			if (((st_entry *)stack->elements[i])->data)	{
//fix_flaw_line_below:
//			if (((st_entry *)stack->elements[i])->data
//fix_flaw_line_below:
//					&& ((st_entry *)stack->elements[i])->type != ST_FIELD)	{
 				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
 			}
 			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;
}
",180108,"static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
 
 	if (stack->elements) {
 		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
 				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
 			}
 			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;
}
","static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
 
 	if (stack->elements) {
 		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data
					&& ((st_entry *)stack->elements[i])->type != ST_FIELD)	{
 				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
 			}
 			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;
}
","The vulnerability in the original code lies in the lack of type checking before dereferencing the `data` pointer in the `wddx_stack_destroy` function. Specifically, the code does not verify the type of the `st_entry` before calling `zval_ptr_dtor`, which could lead to undefined behavior if `data` is not valid for certain types. The fix introduces a condition that checks if `((st_entry *)stack->elements[i])->type` is not equal to `ST_FIELD` before dereferencing `data`. This additional check ensures that `zval_ptr_dtor` is only called on valid data types, thereby preventing potential memory corruption or crashes.","The vulnerability in the original code arises from the lack of type validation before accessing and manipulating data, which can lead to undefined behavior or memory corruption if the data is not appropriate for the operation being performed. This oversight could result in dereferencing invalid pointers or freeing memory that should not be freed, potentially causing crashes or security issues. The fix addresses this vulnerability by introducing a conditional check that ensures the data is of the correct type before any operations are executed. This additional validation step enhances the robustness of the code and prevents unintended consequences."
15,180401,180401,,Local,Not required,Complete,CVE-2016-4805,https://www.cvedetails.com/cve/CVE-2016-4805/,CWE-416,Low,Complete,Complete,,2016-05-23,7.2,"Use-after-free vulnerability in drivers/net/ppp/ppp_generic.c in the Linux kernel before 4.5.2 allows local users to cause a denial of service (memory corruption and system crash, or spinlock) or possibly have unspecified other impact by removing a network namespace, related to the ppp_register_net_channel and ppp_unregister_channel functions.",2019-04-22,DoS Mem. Corr. ,1,https://github.com/torvalds/linux/commit/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,"ppp: take reference on channels netns

Let channels hold a reference on their network namespace.
Some channel types, like ppp_async and ppp_synctty, can have their
userspace controller running in a different namespace. Therefore they
can't rely on them to preclude their netns from being removed from
under them.

==================================================================
BUG: KASAN: use-after-free in ppp_unregister_channel+0x372/0x3a0 at
addr ffff880064e217e0
Read of size 8 by task syz-executor/11581
=============================================================================
BUG net_namespace (Not tainted): kasan: bad access detected
-----------------------------------------------------------------------------

Disabling lock debugging due to kernel taint
INFO: Allocated in copy_net_ns+0x6b/0x1a0 age=92569 cpu=3 pid=6906
[<      none      >] ___slab_alloc+0x4c7/0x500 kernel/mm/slub.c:2440
[<      none      >] __slab_alloc+0x4c/0x90 kernel/mm/slub.c:2469
[<     inline     >] slab_alloc_node kernel/mm/slub.c:2532
[<     inline     >] slab_alloc kernel/mm/slub.c:2574
[<      none      >] kmem_cache_alloc+0x23a/0x2b0 kernel/mm/slub.c:2579
[<     inline     >] kmem_cache_zalloc kernel/include/linux/slab.h:597
[<     inline     >] net_alloc kernel/net/core/net_namespace.c:325
[<      none      >] copy_net_ns+0x6b/0x1a0 kernel/net/core/net_namespace.c:360
[<      none      >] create_new_namespaces+0x2f6/0x610 kernel/kernel/nsproxy.c:95
[<      none      >] copy_namespaces+0x297/0x320 kernel/kernel/nsproxy.c:150
[<      none      >] copy_process.part.35+0x1bf4/0x5760 kernel/kernel/fork.c:1451
[<     inline     >] copy_process kernel/kernel/fork.c:1274
[<      none      >] _do_fork+0x1bc/0xcb0 kernel/kernel/fork.c:1723
[<     inline     >] SYSC_clone kernel/kernel/fork.c:1832
[<      none      >] SyS_clone+0x37/0x50 kernel/kernel/fork.c:1826
[<      none      >] entry_SYSCALL_64_fastpath+0x16/0x7a kernel/arch/x86/entry/entry_64.S:185

INFO: Freed in net_drop_ns+0x67/0x80 age=575 cpu=2 pid=2631
[<      none      >] __slab_free+0x1fc/0x320 kernel/mm/slub.c:2650
[<     inline     >] slab_free kernel/mm/slub.c:2805
[<      none      >] kmem_cache_free+0x2a0/0x330 kernel/mm/slub.c:2814
[<     inline     >] net_free kernel/net/core/net_namespace.c:341
[<      none      >] net_drop_ns+0x67/0x80 kernel/net/core/net_namespace.c:348
[<      none      >] cleanup_net+0x4e5/0x600 kernel/net/core/net_namespace.c:448
[<      none      >] process_one_work+0x794/0x1440 kernel/kernel/workqueue.c:2036
[<      none      >] worker_thread+0xdb/0xfc0 kernel/kernel/workqueue.c:2170
[<      none      >] kthread+0x23f/0x2d0 kernel/drivers/block/aoe/aoecmd.c:1303
[<      none      >] ret_from_fork+0x3f/0x70 kernel/arch/x86/entry/entry_64.S:468
INFO: Slab 0xffffea0001938800 objects=3 used=0 fp=0xffff880064e20000
flags=0x5fffc0000004080
INFO: Object 0xffff880064e20000 @offset=0 fp=0xffff880064e24200

CPU: 1 PID: 11581 Comm: syz-executor Tainted: G    B           4.4.0+
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
rel-1.8.2-0-g33fbe13 by qemu-project.org 04/01/2014
 00000000ffffffff ffff8800662c7790 ffffffff8292049d ffff88003e36a300
 ffff880064e20000 ffff880064e20000 ffff8800662c77c0 ffffffff816f2054
 ffff88003e36a300 ffffea0001938800 ffff880064e20000 0000000000000000
Call Trace:
 [<     inline     >] __dump_stack kernel/lib/dump_stack.c:15
 [<ffffffff8292049d>] dump_stack+0x6f/0xa2 kernel/lib/dump_stack.c:50
 [<ffffffff816f2054>] print_trailer+0xf4/0x150 kernel/mm/slub.c:654
 [<ffffffff816f875f>] object_err+0x2f/0x40 kernel/mm/slub.c:661
 [<     inline     >] print_address_description kernel/mm/kasan/report.c:138
 [<ffffffff816fb0c5>] kasan_report_error+0x215/0x530 kernel/mm/kasan/report.c:236
 [<     inline     >] kasan_report kernel/mm/kasan/report.c:259
 [<ffffffff816fb4de>] __asan_report_load8_noabort+0x3e/0x40 kernel/mm/kasan/report.c:280
 [<     inline     >] ? ppp_pernet kernel/include/linux/compiler.h:218
 [<ffffffff83ad71b2>] ? ppp_unregister_channel+0x372/0x3a0 kernel/drivers/net/ppp/ppp_generic.c:2392
 [<     inline     >] ppp_pernet kernel/include/linux/compiler.h:218
 [<ffffffff83ad71b2>] ppp_unregister_channel+0x372/0x3a0 kernel/drivers/net/ppp/ppp_generic.c:2392
 [<     inline     >] ? ppp_pernet kernel/drivers/net/ppp/ppp_generic.c:293
 [<ffffffff83ad6f26>] ? ppp_unregister_channel+0xe6/0x3a0 kernel/drivers/net/ppp/ppp_generic.c:2392
 [<ffffffff83ae18f3>] ppp_asynctty_close+0xa3/0x130 kernel/drivers/net/ppp/ppp_async.c:241
 [<ffffffff83ae1850>] ? async_lcp_peek+0x5b0/0x5b0 kernel/drivers/net/ppp/ppp_async.c:1000
 [<ffffffff82c33239>] tty_ldisc_close.isra.1+0x99/0xe0 kernel/drivers/tty/tty_ldisc.c:478
 [<ffffffff82c332c0>] tty_ldisc_kill+0x40/0x170 kernel/drivers/tty/tty_ldisc.c:744
 [<ffffffff82c34943>] tty_ldisc_release+0x1b3/0x260 kernel/drivers/tty/tty_ldisc.c:772
 [<ffffffff82c1ef21>] tty_release+0xac1/0x13e0 kernel/drivers/tty/tty_io.c:1901
 [<ffffffff82c1e460>] ? release_tty+0x320/0x320 kernel/drivers/tty/tty_io.c:1688
 [<ffffffff8174de36>] __fput+0x236/0x780 kernel/fs/file_table.c:208
 [<ffffffff8174e405>] ____fput+0x15/0x20 kernel/fs/file_table.c:244
 [<ffffffff813595ab>] task_work_run+0x16b/0x200 kernel/kernel/task_work.c:115
 [<     inline     >] exit_task_work kernel/include/linux/task_work.h:21
 [<ffffffff81307105>] do_exit+0x8b5/0x2c60 kernel/kernel/exit.c:750
 [<ffffffff813fdd20>] ? debug_check_no_locks_freed+0x290/0x290 kernel/kernel/locking/lockdep.c:4123
 [<ffffffff81306850>] ? mm_update_next_owner+0x6f0/0x6f0 kernel/kernel/exit.c:357
 [<ffffffff813215e6>] ? __dequeue_signal+0x136/0x470 kernel/kernel/signal.c:550
 [<ffffffff8132067b>] ? recalc_sigpending_tsk+0x13b/0x180 kernel/kernel/signal.c:145
 [<ffffffff81309628>] do_group_exit+0x108/0x330 kernel/kernel/exit.c:880
 [<ffffffff8132b9d4>] get_signal+0x5e4/0x14f0 kernel/kernel/signal.c:2307
 [<     inline     >] ? kretprobe_table_lock kernel/kernel/kprobes.c:1113
 [<ffffffff8151d355>] ? kprobe_flush_task+0xb5/0x450 kernel/kernel/kprobes.c:1158
 [<ffffffff8115f7d3>] do_signal+0x83/0x1c90 kernel/arch/x86/kernel/signal.c:712
 [<ffffffff8151d2a0>] ? recycle_rp_inst+0x310/0x310 kernel/include/linux/list.h:655
 [<ffffffff8115f750>] ? setup_sigcontext+0x780/0x780 kernel/arch/x86/kernel/signal.c:165
 [<ffffffff81380864>] ? finish_task_switch+0x424/0x5f0 kernel/kernel/sched/core.c:2692
 [<     inline     >] ? finish_lock_switch kernel/kernel/sched/sched.h:1099
 [<ffffffff81380560>] ? finish_task_switch+0x120/0x5f0 kernel/kernel/sched/core.c:2678
 [<     inline     >] ? context_switch kernel/kernel/sched/core.c:2807
 [<ffffffff85d794e9>] ? __schedule+0x919/0x1bd0 kernel/kernel/sched/core.c:3283
 [<ffffffff81003901>] exit_to_usermode_loop+0xf1/0x1a0 kernel/arch/x86/entry/common.c:247
 [<     inline     >] prepare_exit_to_usermode kernel/arch/x86/entry/common.c:282
 [<ffffffff810062ef>] syscall_return_slowpath+0x19f/0x210 kernel/arch/x86/entry/common.c:344
 [<ffffffff85d88022>] int_ret_from_sys_call+0x25/0x9f kernel/arch/x86/entry/entry_64.S:281
Memory state around the buggy address:
 ffff880064e21680: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff880064e21700: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
>ffff880064e21780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                                       ^
 ffff880064e21800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff880064e21880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
==================================================================

Fixes: 273ec51dd7ce (""net: ppp_generic - introduce net-namespace functionality v2"")
Reported-by: Baozeng Ding <sploving1@gmail.com>
Signed-off-by: Guillaume Nault <g.nault@alphalink.fr>
Reviewed-by: Cyrill Gorcunov <gorcunov@openvz.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,drivers/net/ppp/ppp_generic.c,"{""sha"": ""f572b31a2b20cef55e560b8db932c419f14bd8b3"", ""filename"": ""drivers/net/ppp/ppp_generic.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89/drivers/net/ppp/ppp_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89/drivers/net/ppp/ppp_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ppp/ppp_generic.c?ref=1f461dcdd296eecedaffffc6bae2bfa90bd7eb89"", ""patch"": ""@@ -2307,7 +2307,7 @@ int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)\n \n \tpch->ppp = NULL;\n \tpch->chan = chan;\n-\tpch->chan_net = net;\n+\tpch->chan_net = get_net(net);\n \tchan->ppp = pch;\n \tinit_ppp_file(&pch->file, CHANNEL);\n \tpch->file.hdrlen = chan->hdrlen;\n@@ -2404,6 +2404,8 @@ ppp_unregister_channel(struct ppp_channel *chan)\n \tspin_lock_bh(&pn->all_channels_lock);\n \tlist_del(&pch->list);\n \tspin_unlock_bh(&pn->all_channels_lock);\n+\tput_net(pch->chan_net);\n+\tpch->chan_net = NULL;\n \n \tpch->file.dead = 1;\n \twake_up_interruptible(&pch->file.rwait);""}","int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)
{
	struct channel *pch;
	struct ppp_net *pn;

	pch = kzalloc(sizeof(struct channel), GFP_KERNEL);
	if (!pch)
		return -ENOMEM;

	pn = ppp_pernet(net);
 
 	pch->ppp = NULL;
 	pch->chan = chan;
	pch->chan_net = get_net(net);
 	chan->ppp = pch;
 	init_ppp_file(&pch->file, CHANNEL);
 	pch->file.hdrlen = chan->hdrlen;
#ifdef CONFIG_PPP_MULTILINK
	pch->lastseq = -1;
#endif /* CONFIG_PPP_MULTILINK */
	init_rwsem(&pch->chan_sem);
	spin_lock_init(&pch->downl);
	rwlock_init(&pch->upl);

	spin_lock_bh(&pn->all_channels_lock);
	pch->file.index = ++pn->last_channel_index;
	list_add(&pch->list, &pn->new_channels);
	atomic_inc(&channel_count);
	spin_unlock_bh(&pn->all_channels_lock);

	return 0;
}
","int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)
{
	struct channel *pch;
	struct ppp_net *pn;

	pch = kzalloc(sizeof(struct channel), GFP_KERNEL);
	if (!pch)
		return -ENOMEM;

	pn = ppp_pernet(net);
 
 	pch->ppp = NULL;
 	pch->chan = chan;
	pch->chan_net = net;
 	chan->ppp = pch;
 	init_ppp_file(&pch->file, CHANNEL);
 	pch->file.hdrlen = chan->hdrlen;
#ifdef CONFIG_PPP_MULTILINK
	pch->lastseq = -1;
#endif /* CONFIG_PPP_MULTILINK */
	init_rwsem(&pch->chan_sem);
	spin_lock_init(&pch->downl);
	rwlock_init(&pch->upl);

	spin_lock_bh(&pn->all_channels_lock);
	pch->file.index = ++pn->last_channel_index;
	list_add(&pch->list, &pn->new_channels);
	atomic_inc(&channel_count);
	spin_unlock_bh(&pn->all_channels_lock);

	return 0;
}
",C,"	pch->chan_net = get_net(net);
","	pch->chan_net = net;
",,"@@ -2307,7 +2307,7 @@ int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)
 
 	pch->ppp = NULL;
 	pch->chan = chan;
-	pch->chan_net = net;
+	pch->chan_net = get_net(net);
 	chan->ppp = pch;
 	init_ppp_file(&pch->file, CHANNEL);
 	pch->file.hdrlen = chan->hdrlen;
@@ -2404,6 +2404,8 @@ ppp_unregister_channel(struct ppp_channel *chan)
 	spin_lock_bh(&pn->all_channels_lock);
 	list_del(&pch->list);
 	spin_unlock_bh(&pn->all_channels_lock);
+	put_net(pch->chan_net);
+	pch->chan_net = NULL;
 
 	pch->file.dead = 1;
 	wake_up_interruptible(&pch->file.rwait);",linux,1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,5197f3499c470ccc4b247db66ff883e597e3adda,1,"int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)
{
	struct channel *pch;
	struct ppp_net *pn;

	pch = kzalloc(sizeof(struct channel), GFP_KERNEL);
	if (!pch)
		return -ENOMEM;

	pn = ppp_pernet(net);
 
 	pch->ppp = NULL;
 	pch->chan = chan;
//flaw_line_below:
	pch->chan_net = net;
//fix_flaw_line_below:
//	pch->chan_net = get_net(net);
 	chan->ppp = pch;
 	init_ppp_file(&pch->file, CHANNEL);
 	pch->file.hdrlen = chan->hdrlen;
#ifdef CONFIG_PPP_MULTILINK
	pch->lastseq = -1;
#endif /* CONFIG_PPP_MULTILINK */
	init_rwsem(&pch->chan_sem);
	spin_lock_init(&pch->downl);
	rwlock_init(&pch->upl);

	spin_lock_bh(&pn->all_channels_lock);
	pch->file.index = ++pn->last_channel_index;
	list_add(&pch->list, &pn->new_channels);
	atomic_inc(&channel_count);
	spin_unlock_bh(&pn->all_channels_lock);

	return 0;
}
",180401,"int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)
{
	struct channel *pch;
	struct ppp_net *pn;

	pch = kzalloc(sizeof(struct channel), GFP_KERNEL);
	if (!pch)
		return -ENOMEM;

	pn = ppp_pernet(net);
 
 	pch->ppp = NULL;
 	pch->chan = chan;
	pch->chan_net = net;
 	chan->ppp = pch;
 	init_ppp_file(&pch->file, CHANNEL);
 	pch->file.hdrlen = chan->hdrlen;
#ifdef CONFIG_PPP_MULTILINK
	pch->lastseq = -1;
#endif /* CONFIG_PPP_MULTILINK */
	init_rwsem(&pch->chan_sem);
	spin_lock_init(&pch->downl);
	rwlock_init(&pch->upl);

	spin_lock_bh(&pn->all_channels_lock);
	pch->file.index = ++pn->last_channel_index;
	list_add(&pch->list, &pn->new_channels);
	atomic_inc(&channel_count);
	spin_unlock_bh(&pn->all_channels_lock);

	return 0;
}
","int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)
{
	struct channel *pch;
	struct ppp_net *pn;

	pch = kzalloc(sizeof(struct channel), GFP_KERNEL);
	if (!pch)
		return -ENOMEM;

	pn = ppp_pernet(net);
 
 	pch->ppp = NULL;
 	pch->chan = chan;
	pch->chan_net = get_net(net);
 	chan->ppp = pch;
 	init_ppp_file(&pch->file, CHANNEL);
 	pch->file.hdrlen = chan->hdrlen;
#ifdef CONFIG_PPP_MULTILINK
	pch->lastseq = -1;
#endif /* CONFIG_PPP_MULTILINK */
	init_rwsem(&pch->chan_sem);
	spin_lock_init(&pch->downl);
	rwlock_init(&pch->upl);

	spin_lock_bh(&pn->all_channels_lock);
	pch->file.index = ++pn->last_channel_index;
	list_add(&pch->list, &pn->new_channels);
	atomic_inc(&channel_count);
	spin_unlock_bh(&pn->all_channels_lock);

	return 0;
}
","The vulnerability in the original code arises from the assignment of `pch->chan_net = net;`, which directly references the `net` structure without ensuring proper reference counting. This can lead to use-after-free issues if the `net` structure is released while still in use. The fix in the modified code addresses this vulnerability by changing the assignment to `pch->chan_net = get_net(net);`, which increments the reference count of the `net` structure, ensuring that it remains valid for the lifetime of `pch`. This change enhances memory safety by preventing premature deallocation of the `net` structure.","The vulnerability in the original code stems from directly referencing a structure without ensuring that it remains valid throughout its intended use, which can lead to potential use-after-free errors. This occurs when the referenced structure is deallocated while still being accessed, resulting in undefined behavior or crashes. The fix in the modified code addresses this issue by implementing a mechanism that increments the reference count of the structure, ensuring that it remains valid for the duration of its use. This change enhances memory safety and prevents premature deallocation, thereby mitigating the risk of accessing invalid memory."
16,180402,180402,,Local,Not required,Complete,CVE-2016-4805,https://www.cvedetails.com/cve/CVE-2016-4805/,CWE-416,Low,Complete,Complete,,2016-05-23,7.2,"Use-after-free vulnerability in drivers/net/ppp/ppp_generic.c in the Linux kernel before 4.5.2 allows local users to cause a denial of service (memory corruption and system crash, or spinlock) or possibly have unspecified other impact by removing a network namespace, related to the ppp_register_net_channel and ppp_unregister_channel functions.",2019-04-22,DoS Mem. Corr. ,2,https://github.com/torvalds/linux/commit/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,"ppp: take reference on channels netns

Let channels hold a reference on their network namespace.
Some channel types, like ppp_async and ppp_synctty, can have their
userspace controller running in a different namespace. Therefore they
can't rely on them to preclude their netns from being removed from
under them.

==================================================================
BUG: KASAN: use-after-free in ppp_unregister_channel+0x372/0x3a0 at
addr ffff880064e217e0
Read of size 8 by task syz-executor/11581
=============================================================================
BUG net_namespace (Not tainted): kasan: bad access detected
-----------------------------------------------------------------------------

Disabling lock debugging due to kernel taint
INFO: Allocated in copy_net_ns+0x6b/0x1a0 age=92569 cpu=3 pid=6906
[<      none      >] ___slab_alloc+0x4c7/0x500 kernel/mm/slub.c:2440
[<      none      >] __slab_alloc+0x4c/0x90 kernel/mm/slub.c:2469
[<     inline     >] slab_alloc_node kernel/mm/slub.c:2532
[<     inline     >] slab_alloc kernel/mm/slub.c:2574
[<      none      >] kmem_cache_alloc+0x23a/0x2b0 kernel/mm/slub.c:2579
[<     inline     >] kmem_cache_zalloc kernel/include/linux/slab.h:597
[<     inline     >] net_alloc kernel/net/core/net_namespace.c:325
[<      none      >] copy_net_ns+0x6b/0x1a0 kernel/net/core/net_namespace.c:360
[<      none      >] create_new_namespaces+0x2f6/0x610 kernel/kernel/nsproxy.c:95
[<      none      >] copy_namespaces+0x297/0x320 kernel/kernel/nsproxy.c:150
[<      none      >] copy_process.part.35+0x1bf4/0x5760 kernel/kernel/fork.c:1451
[<     inline     >] copy_process kernel/kernel/fork.c:1274
[<      none      >] _do_fork+0x1bc/0xcb0 kernel/kernel/fork.c:1723
[<     inline     >] SYSC_clone kernel/kernel/fork.c:1832
[<      none      >] SyS_clone+0x37/0x50 kernel/kernel/fork.c:1826
[<      none      >] entry_SYSCALL_64_fastpath+0x16/0x7a kernel/arch/x86/entry/entry_64.S:185

INFO: Freed in net_drop_ns+0x67/0x80 age=575 cpu=2 pid=2631
[<      none      >] __slab_free+0x1fc/0x320 kernel/mm/slub.c:2650
[<     inline     >] slab_free kernel/mm/slub.c:2805
[<      none      >] kmem_cache_free+0x2a0/0x330 kernel/mm/slub.c:2814
[<     inline     >] net_free kernel/net/core/net_namespace.c:341
[<      none      >] net_drop_ns+0x67/0x80 kernel/net/core/net_namespace.c:348
[<      none      >] cleanup_net+0x4e5/0x600 kernel/net/core/net_namespace.c:448
[<      none      >] process_one_work+0x794/0x1440 kernel/kernel/workqueue.c:2036
[<      none      >] worker_thread+0xdb/0xfc0 kernel/kernel/workqueue.c:2170
[<      none      >] kthread+0x23f/0x2d0 kernel/drivers/block/aoe/aoecmd.c:1303
[<      none      >] ret_from_fork+0x3f/0x70 kernel/arch/x86/entry/entry_64.S:468
INFO: Slab 0xffffea0001938800 objects=3 used=0 fp=0xffff880064e20000
flags=0x5fffc0000004080
INFO: Object 0xffff880064e20000 @offset=0 fp=0xffff880064e24200

CPU: 1 PID: 11581 Comm: syz-executor Tainted: G    B           4.4.0+
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
rel-1.8.2-0-g33fbe13 by qemu-project.org 04/01/2014
 00000000ffffffff ffff8800662c7790 ffffffff8292049d ffff88003e36a300
 ffff880064e20000 ffff880064e20000 ffff8800662c77c0 ffffffff816f2054
 ffff88003e36a300 ffffea0001938800 ffff880064e20000 0000000000000000
Call Trace:
 [<     inline     >] __dump_stack kernel/lib/dump_stack.c:15
 [<ffffffff8292049d>] dump_stack+0x6f/0xa2 kernel/lib/dump_stack.c:50
 [<ffffffff816f2054>] print_trailer+0xf4/0x150 kernel/mm/slub.c:654
 [<ffffffff816f875f>] object_err+0x2f/0x40 kernel/mm/slub.c:661
 [<     inline     >] print_address_description kernel/mm/kasan/report.c:138
 [<ffffffff816fb0c5>] kasan_report_error+0x215/0x530 kernel/mm/kasan/report.c:236
 [<     inline     >] kasan_report kernel/mm/kasan/report.c:259
 [<ffffffff816fb4de>] __asan_report_load8_noabort+0x3e/0x40 kernel/mm/kasan/report.c:280
 [<     inline     >] ? ppp_pernet kernel/include/linux/compiler.h:218
 [<ffffffff83ad71b2>] ? ppp_unregister_channel+0x372/0x3a0 kernel/drivers/net/ppp/ppp_generic.c:2392
 [<     inline     >] ppp_pernet kernel/include/linux/compiler.h:218
 [<ffffffff83ad71b2>] ppp_unregister_channel+0x372/0x3a0 kernel/drivers/net/ppp/ppp_generic.c:2392
 [<     inline     >] ? ppp_pernet kernel/drivers/net/ppp/ppp_generic.c:293
 [<ffffffff83ad6f26>] ? ppp_unregister_channel+0xe6/0x3a0 kernel/drivers/net/ppp/ppp_generic.c:2392
 [<ffffffff83ae18f3>] ppp_asynctty_close+0xa3/0x130 kernel/drivers/net/ppp/ppp_async.c:241
 [<ffffffff83ae1850>] ? async_lcp_peek+0x5b0/0x5b0 kernel/drivers/net/ppp/ppp_async.c:1000
 [<ffffffff82c33239>] tty_ldisc_close.isra.1+0x99/0xe0 kernel/drivers/tty/tty_ldisc.c:478
 [<ffffffff82c332c0>] tty_ldisc_kill+0x40/0x170 kernel/drivers/tty/tty_ldisc.c:744
 [<ffffffff82c34943>] tty_ldisc_release+0x1b3/0x260 kernel/drivers/tty/tty_ldisc.c:772
 [<ffffffff82c1ef21>] tty_release+0xac1/0x13e0 kernel/drivers/tty/tty_io.c:1901
 [<ffffffff82c1e460>] ? release_tty+0x320/0x320 kernel/drivers/tty/tty_io.c:1688
 [<ffffffff8174de36>] __fput+0x236/0x780 kernel/fs/file_table.c:208
 [<ffffffff8174e405>] ____fput+0x15/0x20 kernel/fs/file_table.c:244
 [<ffffffff813595ab>] task_work_run+0x16b/0x200 kernel/kernel/task_work.c:115
 [<     inline     >] exit_task_work kernel/include/linux/task_work.h:21
 [<ffffffff81307105>] do_exit+0x8b5/0x2c60 kernel/kernel/exit.c:750
 [<ffffffff813fdd20>] ? debug_check_no_locks_freed+0x290/0x290 kernel/kernel/locking/lockdep.c:4123
 [<ffffffff81306850>] ? mm_update_next_owner+0x6f0/0x6f0 kernel/kernel/exit.c:357
 [<ffffffff813215e6>] ? __dequeue_signal+0x136/0x470 kernel/kernel/signal.c:550
 [<ffffffff8132067b>] ? recalc_sigpending_tsk+0x13b/0x180 kernel/kernel/signal.c:145
 [<ffffffff81309628>] do_group_exit+0x108/0x330 kernel/kernel/exit.c:880
 [<ffffffff8132b9d4>] get_signal+0x5e4/0x14f0 kernel/kernel/signal.c:2307
 [<     inline     >] ? kretprobe_table_lock kernel/kernel/kprobes.c:1113
 [<ffffffff8151d355>] ? kprobe_flush_task+0xb5/0x450 kernel/kernel/kprobes.c:1158
 [<ffffffff8115f7d3>] do_signal+0x83/0x1c90 kernel/arch/x86/kernel/signal.c:712
 [<ffffffff8151d2a0>] ? recycle_rp_inst+0x310/0x310 kernel/include/linux/list.h:655
 [<ffffffff8115f750>] ? setup_sigcontext+0x780/0x780 kernel/arch/x86/kernel/signal.c:165
 [<ffffffff81380864>] ? finish_task_switch+0x424/0x5f0 kernel/kernel/sched/core.c:2692
 [<     inline     >] ? finish_lock_switch kernel/kernel/sched/sched.h:1099
 [<ffffffff81380560>] ? finish_task_switch+0x120/0x5f0 kernel/kernel/sched/core.c:2678
 [<     inline     >] ? context_switch kernel/kernel/sched/core.c:2807
 [<ffffffff85d794e9>] ? __schedule+0x919/0x1bd0 kernel/kernel/sched/core.c:3283
 [<ffffffff81003901>] exit_to_usermode_loop+0xf1/0x1a0 kernel/arch/x86/entry/common.c:247
 [<     inline     >] prepare_exit_to_usermode kernel/arch/x86/entry/common.c:282
 [<ffffffff810062ef>] syscall_return_slowpath+0x19f/0x210 kernel/arch/x86/entry/common.c:344
 [<ffffffff85d88022>] int_ret_from_sys_call+0x25/0x9f kernel/arch/x86/entry/entry_64.S:281
Memory state around the buggy address:
 ffff880064e21680: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff880064e21700: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
>ffff880064e21780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                                       ^
 ffff880064e21800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff880064e21880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
==================================================================

Fixes: 273ec51dd7ce (""net: ppp_generic - introduce net-namespace functionality v2"")
Reported-by: Baozeng Ding <sploving1@gmail.com>
Signed-off-by: Guillaume Nault <g.nault@alphalink.fr>
Reviewed-by: Cyrill Gorcunov <gorcunov@openvz.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,drivers/net/ppp/ppp_generic.c,"{""sha"": ""f572b31a2b20cef55e560b8db932c419f14bd8b3"", ""filename"": ""drivers/net/ppp/ppp_generic.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89/drivers/net/ppp/ppp_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89/drivers/net/ppp/ppp_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ppp/ppp_generic.c?ref=1f461dcdd296eecedaffffc6bae2bfa90bd7eb89"", ""patch"": ""@@ -2307,7 +2307,7 @@ int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)\n \n \tpch->ppp = NULL;\n \tpch->chan = chan;\n-\tpch->chan_net = net;\n+\tpch->chan_net = get_net(net);\n \tchan->ppp = pch;\n \tinit_ppp_file(&pch->file, CHANNEL);\n \tpch->file.hdrlen = chan->hdrlen;\n@@ -2404,6 +2404,8 @@ ppp_unregister_channel(struct ppp_channel *chan)\n \tspin_lock_bh(&pn->all_channels_lock);\n \tlist_del(&pch->list);\n \tspin_unlock_bh(&pn->all_channels_lock);\n+\tput_net(pch->chan_net);\n+\tpch->chan_net = NULL;\n \n \tpch->file.dead = 1;\n \twake_up_interruptible(&pch->file.rwait);""}","ppp_unregister_channel(struct ppp_channel *chan)
{
	struct channel *pch = chan->ppp;
	struct ppp_net *pn;

	if (!pch)
		return;		/* should never happen */

	chan->ppp = NULL;

	/*
	 * This ensures that we have returned from any calls into the
	 * the channel's start_xmit or ioctl routine before we proceed.
	 */
	down_write(&pch->chan_sem);
	spin_lock_bh(&pch->downl);
	pch->chan = NULL;
	spin_unlock_bh(&pch->downl);
	up_write(&pch->chan_sem);
	ppp_disconnect_channel(pch);

	pn = ppp_pernet(pch->chan_net);
 	spin_lock_bh(&pn->all_channels_lock);
 	list_del(&pch->list);
 	spin_unlock_bh(&pn->all_channels_lock);
	put_net(pch->chan_net);
	pch->chan_net = NULL;
 
 	pch->file.dead = 1;
 	wake_up_interruptible(&pch->file.rwait);
	if (atomic_dec_and_test(&pch->file.refcnt))
		ppp_destroy_channel(pch);
}
","ppp_unregister_channel(struct ppp_channel *chan)
{
	struct channel *pch = chan->ppp;
	struct ppp_net *pn;

	if (!pch)
		return;		/* should never happen */

	chan->ppp = NULL;

	/*
	 * This ensures that we have returned from any calls into the
	 * the channel's start_xmit or ioctl routine before we proceed.
	 */
	down_write(&pch->chan_sem);
	spin_lock_bh(&pch->downl);
	pch->chan = NULL;
	spin_unlock_bh(&pch->downl);
	up_write(&pch->chan_sem);
	ppp_disconnect_channel(pch);

	pn = ppp_pernet(pch->chan_net);
 	spin_lock_bh(&pn->all_channels_lock);
 	list_del(&pch->list);
 	spin_unlock_bh(&pn->all_channels_lock);
 
 	pch->file.dead = 1;
 	wake_up_interruptible(&pch->file.rwait);
	if (atomic_dec_and_test(&pch->file.refcnt))
		ppp_destroy_channel(pch);
}
",C,"	put_net(pch->chan_net);
	pch->chan_net = NULL;
",,,"@@ -2307,7 +2307,7 @@ int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)
 
 	pch->ppp = NULL;
 	pch->chan = chan;
-	pch->chan_net = net;
+	pch->chan_net = get_net(net);
 	chan->ppp = pch;
 	init_ppp_file(&pch->file, CHANNEL);
 	pch->file.hdrlen = chan->hdrlen;
@@ -2404,6 +2404,8 @@ ppp_unregister_channel(struct ppp_channel *chan)
 	spin_lock_bh(&pn->all_channels_lock);
 	list_del(&pch->list);
 	spin_unlock_bh(&pn->all_channels_lock);
+	put_net(pch->chan_net);
+	pch->chan_net = NULL;
 
 	pch->file.dead = 1;
 	wake_up_interruptible(&pch->file.rwait);",linux,1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,5197f3499c470ccc4b247db66ff883e597e3adda,1,"ppp_unregister_channel(struct ppp_channel *chan)
{
	struct channel *pch = chan->ppp;
	struct ppp_net *pn;

	if (!pch)
		return;		/* should never happen */

	chan->ppp = NULL;

	/*
	 * This ensures that we have returned from any calls into the
	 * the channel's start_xmit or ioctl routine before we proceed.
	 */
	down_write(&pch->chan_sem);
	spin_lock_bh(&pch->downl);
	pch->chan = NULL;
	spin_unlock_bh(&pch->downl);
	up_write(&pch->chan_sem);
	ppp_disconnect_channel(pch);

	pn = ppp_pernet(pch->chan_net);
 	spin_lock_bh(&pn->all_channels_lock);
 	list_del(&pch->list);
 	spin_unlock_bh(&pn->all_channels_lock);
//fix_flaw_line_below:
//	put_net(pch->chan_net);
//fix_flaw_line_below:
//	pch->chan_net = NULL;
 
 	pch->file.dead = 1;
 	wake_up_interruptible(&pch->file.rwait);
	if (atomic_dec_and_test(&pch->file.refcnt))
		ppp_destroy_channel(pch);
}
",180402,"ppp_unregister_channel(struct ppp_channel *chan)
{
	struct channel *pch = chan->ppp;
	struct ppp_net *pn;

	if (!pch)
		return;		/* should never happen */

	chan->ppp = NULL;

	/*
	 * This ensures that we have returned from any calls into the
	 * the channel's start_xmit or ioctl routine before we proceed.
	 */
	down_write(&pch->chan_sem);
	spin_lock_bh(&pch->downl);
	pch->chan = NULL;
	spin_unlock_bh(&pch->downl);
	up_write(&pch->chan_sem);
	ppp_disconnect_channel(pch);

	pn = ppp_pernet(pch->chan_net);
 	spin_lock_bh(&pn->all_channels_lock);
 	list_del(&pch->list);
 	spin_unlock_bh(&pn->all_channels_lock);
 
 	pch->file.dead = 1;
 	wake_up_interruptible(&pch->file.rwait);
	if (atomic_dec_and_test(&pch->file.refcnt))
		ppp_destroy_channel(pch);
}
","ppp_unregister_channel(struct ppp_channel *chan)
{
	struct channel *pch = chan->ppp;
	struct ppp_net *pn;

	if (!pch)
		return;		/* should never happen */

	chan->ppp = NULL;

	/*
	 * This ensures that we have returned from any calls into the
	 * the channel's start_xmit or ioctl routine before we proceed.
	 */
	down_write(&pch->chan_sem);
	spin_lock_bh(&pch->downl);
	pch->chan = NULL;
	spin_unlock_bh(&pch->downl);
	up_write(&pch->chan_sem);
	ppp_disconnect_channel(pch);

	pn = ppp_pernet(pch->chan_net);
 	spin_lock_bh(&pn->all_channels_lock);
 	list_del(&pch->list);
 	spin_unlock_bh(&pn->all_channels_lock);
	put_net(pch->chan_net);
	pch->chan_net = NULL;
 
 	pch->file.dead = 1;
 	wake_up_interruptible(&pch->file.rwait);
	if (atomic_dec_and_test(&pch->file.refcnt))
		ppp_destroy_channel(pch);
}
","The vulnerability in the original code lies in the handling of the `pch->chan_net` reference, which could lead to a resource leak if the channel is unregistered without properly releasing the associated network namespace. In the fixed code, the addition of `put_net(pch->chan_net);` ensures that the reference to the network namespace is decremented, effectively preventing a memory leak. Furthermore, setting `pch->chan_net` to `NULL` after releasing it helps avoid potential use-after-free issues, thereby enhancing the overall stability and security of the `ppp_unregister_channel` function.","The vulnerability in the original code stems from the failure to properly release a reference to a resource associated with a network namespace when a channel is unregistered. This oversight could lead to a memory leak, as the resource would remain allocated even after it is no longer needed. The fixed code addresses this issue by explicitly decrementing the reference count for the network namespace, ensuring that the resource is correctly released. Additionally, nullifying the reference after release prevents potential use-after-free errors, thereby improving the code's robustness and security."
17,180637,180637,,Remote,Not required,Complete,CVE-2015-8961,https://www.cvedetails.com/cve/CVE-2015-8961/,CWE-416,Medium,Complete,Complete,,2016-11-16,9.3,The __ext4_journal_stop function in fs/ext4/ext4_jbd2.c in the Linux kernel before 4.3.3 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging improper access to a certain error field.,2017-01-17,DoS +Priv ,3,https://github.com/torvalds/linux/commit/6934da9238da947628be83635e365df41064b09b,6934da9238da947628be83635e365df41064b09b,"ext4: fix potential use after free in __ext4_journal_stop

There is a use-after-free possibility in __ext4_journal_stop() in the
case that we free the handle in the first jbd2_journal_stop() because
we're referencing handle->h_err afterwards. This was introduced in
9705acd63b125dee8b15c705216d7186daea4625 and it is wrong. Fix it by
storing the handle->h_err value beforehand and avoid referencing
potentially freed handle.

Fixes: 9705acd63b125dee8b15c705216d7186daea4625
Signed-off-by: Lukas Czerner <lczerner@redhat.com>
Reviewed-by: Andreas Dilger <adilger@dilger.ca>
Cc: stable@vger.kernel.org",3,fs/ext4/ext4_jbd2.c,"{""sha"": ""e770c1ee4613ed6084518f2ec9dca0ff9e53a29a"", ""filename"": ""fs/ext4/ext4_jbd2.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/6934da9238da947628be83635e365df41064b09b/fs/ext4/ext4_jbd2.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/6934da9238da947628be83635e365df41064b09b/fs/ext4/ext4_jbd2.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext4/ext4_jbd2.c?ref=6934da9238da947628be83635e365df41064b09b"", ""patch"": ""@@ -88,13 +88,13 @@ int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n \t\treturn 0;\n \t}\n \n+\terr = handle->h_err;\n \tif (!handle->h_transaction) {\n-\t\terr = jbd2_journal_stop(handle);\n-\t\treturn handle->h_err ? handle->h_err : err;\n+\t\trc = jbd2_journal_stop(handle);\n+\t\treturn err ? err : rc;\n \t}\n \n \tsb = handle->h_transaction->t_journal->j_private;\n-\terr = handle->h_err;\n \trc = jbd2_journal_stop(handle);\n \n \tif (!err)""}","int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)
{
	struct super_block *sb;
	int err;
	int rc;

	if (!ext4_handle_valid(handle)) {
		ext4_put_nojournal(handle);
 		return 0;
 	}
 
	err = handle->h_err;
 	if (!handle->h_transaction) {
		rc = jbd2_journal_stop(handle);
		return err ? err : rc;
 	}
 
 	sb = handle->h_transaction->t_journal->j_private;
 	rc = jbd2_journal_stop(handle);
 
 	if (!err)
		err = rc;
	if (err)
		__ext4_std_error(sb, where, line, err);
	return err;
}
","int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)
{
	struct super_block *sb;
	int err;
	int rc;

	if (!ext4_handle_valid(handle)) {
		ext4_put_nojournal(handle);
 		return 0;
 	}
 
 	if (!handle->h_transaction) {
		err = jbd2_journal_stop(handle);
		return handle->h_err ? handle->h_err : err;
 	}
 
 	sb = handle->h_transaction->t_journal->j_private;
	err = handle->h_err;
 	rc = jbd2_journal_stop(handle);
 
 	if (!err)
		err = rc;
	if (err)
		__ext4_std_error(sb, where, line, err);
	return err;
}
",C,"	err = handle->h_err;
		rc = jbd2_journal_stop(handle);
		return err ? err : rc;
","		err = jbd2_journal_stop(handle);
		return handle->h_err ? handle->h_err : err;
	err = handle->h_err;
",,"@@ -88,13 +88,13 @@ int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)
 		return 0;
 	}
 
+	err = handle->h_err;
 	if (!handle->h_transaction) {
-		err = jbd2_journal_stop(handle);
-		return handle->h_err ? handle->h_err : err;
+		rc = jbd2_journal_stop(handle);
+		return err ? err : rc;
 	}
 
 	sb = handle->h_transaction->t_journal->j_private;
-	err = handle->h_err;
 	rc = jbd2_journal_stop(handle);
 
 	if (!err)",linux,6934da9238da947628be83635e365df41064b09b,33d14975e5ac469963d5d63856b61698ad0bff07,1,"int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)
{
	struct super_block *sb;
	int err;
	int rc;

	if (!ext4_handle_valid(handle)) {
		ext4_put_nojournal(handle);
 		return 0;
 	}
 
//fix_flaw_line_below:
//	err = handle->h_err;
 	if (!handle->h_transaction) {
//flaw_line_below:
		err = jbd2_journal_stop(handle);
//flaw_line_below:
		return handle->h_err ? handle->h_err : err;
//fix_flaw_line_below:
//		rc = jbd2_journal_stop(handle);
//fix_flaw_line_below:
//		return err ? err : rc;
 	}
 
 	sb = handle->h_transaction->t_journal->j_private;
//flaw_line_below:
	err = handle->h_err;
 	rc = jbd2_journal_stop(handle);
 
 	if (!err)
		err = rc;
	if (err)
		__ext4_std_error(sb, where, line, err);
	return err;
}
",180637,"int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)
{
	struct super_block *sb;
	int err;
	int rc;

	if (!ext4_handle_valid(handle)) {
		ext4_put_nojournal(handle);
 		return 0;
 	}
 
 	if (!handle->h_transaction) {
		err = jbd2_journal_stop(handle);
		return handle->h_err ? handle->h_err : err;
 	}
 
 	sb = handle->h_transaction->t_journal->j_private;
	err = handle->h_err;
 	rc = jbd2_journal_stop(handle);
 
 	if (!err)
		err = rc;
	if (err)
		__ext4_std_error(sb, where, line, err);
	return err;
}
","int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)
{
	struct super_block *sb;
	int err;
	int rc;

	if (!ext4_handle_valid(handle)) {
		ext4_put_nojournal(handle);
 		return 0;
 	}
 
	err = handle->h_err;
 	if (!handle->h_transaction) {
		rc = jbd2_journal_stop(handle);
		return err ? err : rc;
 	}
 
 	sb = handle->h_transaction->t_journal->j_private;
 	rc = jbd2_journal_stop(handle);
 
 	if (!err)
		err = rc;
	if (err)
		__ext4_std_error(sb, where, line, err);
	return err;
}
","The vulnerability in the original code arises from the handling of the `handle->h_err` variable before checking if `handle->h_transaction` is valid. If `handle->h_transaction` is NULL, the code directly calls `jbd2_journal_stop(handle)` without first ensuring that `handle->h_err` is appropriately set, potentially leading to incorrect error reporting. In the fixed code, the assignment of `err` is moved to before the transaction check, ensuring that the error state is captured correctly. This change prevents the misuse of an uninitialized or stale error value, thereby improving the reliability of error handling in the function.","The vulnerability in the original code stems from the improper handling of error states when a specific condition is met. If a certain check fails, the code proceeds to execute a function that could potentially return an error, but it does so without first ensuring that the error state is correctly captured. This oversight can lead to misleading error reporting, as the function may return an uninitialized or incorrect error value. The revised code addresses this issue by rearranging the logic to ensure that the error state is properly assigned before any further operations, thus enhancing the accuracy of error handling."
18,180801,180801,,Remote,Not required,,CVE-2017-1000211,https://www.cvedetails.com/cve/CVE-2017-1000211/,CWE-416,Low,Partial,,,2017-11-17,5.0,"Lynx before 2.8.9dev.16 is vulnerable to a use after free in the HTML parser resulting in memory disclosure, because HTML_put_string() can append a chunk onto itself.",2018-02-03,,18,https://github.com/ThomasDickey/lynx-snapshots/commit/280a61b300a1614f6037efc0902ff7ecf17146e9,280a61b300a1614f6037efc0902ff7ecf17146e9,"snapshot of project ""lynx"", label v2-8-9dev_15b",7,src/HTML.c,"{""sha"": ""641bd27747db2dabcd8eb41f35b6f9248f526d05"", ""filename"": ""CHANGES"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/ThomasDickey/lynx-snapshots/blob/280a61b300a1614f6037efc0902ff7ecf17146e9/CHANGES"", ""raw_url"": ""https://github.com/ThomasDickey/lynx-snapshots/raw/280a61b300a1614f6037efc0902ff7ecf17146e9/CHANGES"", ""contents_url"": ""https://api.github.com/repos/ThomasDickey/lynx-snapshots/contents/CHANGES?ref=280a61b300a1614f6037efc0902ff7ecf17146e9"", ""patch"": ""@@ -1,9 +1,11 @@\n--- $LynxId: CHANGES,v 1.910 2017/07/05 20:39:40 tom Exp $\n+-- $LynxId: CHANGES,v 1.911 2017/07/05 22:23:00 tom Exp $\n ===============================================================================\n Changes since Lynx 2.8 release\n ===============================================================================\n \n 2017-07-05 (2.8.9dev.16)\n+* add a check to ensure that HTML_put_string() will not append a chunk onto\n+  itself (report by Ned Williamson) -TD\n * update et.po, tr.po from\n     http://translationproject.org/latest/lynx\n ""}<_**next**_>{""sha"": ""a2345b7e5447376f358568d187be471ce6c33e9a"", ""filename"": ""PACKAGE/debian/lynx-dev.lintian-overrides"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/ThomasDickey/lynx-snapshots/blob/280a61b300a1614f6037efc0902ff7ecf17146e9/PACKAGE/debian/lynx-dev.lintian-overrides"", ""raw_url"": ""https://github.com/ThomasDickey/lynx-snapshots/raw/280a61b300a1614f6037efc0902ff7ecf17146e9/PACKAGE/debian/lynx-dev.lintian-overrides"", ""contents_url"": ""https://api.github.com/repos/ThomasDickey/lynx-snapshots/contents/PACKAGE/debian/lynx-dev.lintian-overrides?ref=280a61b300a1614f6037efc0902ff7ecf17146e9"", ""patch"": ""@@ -1,5 +1,5 @@\n # Lynx's version-numbering is not understood by lintian, though legal.\n-lynx-dev: rc-version-greater-than-expected-version 2.8.9dev.15 > 2.8.9 (consider using 2.8.9~dev.15)\n+lynx-dev: rc-version-greater-than-expected-version\n \n # This is intentional because it is referenced from the documentation.\n lynx-dev: extra-license-file usr/share/doc/lynx-dev/COPYING""}<_**next**_>{""sha"": ""63d6720644aa89348cb119fee6dbd9fcb4074bce"", ""filename"": ""src/HTML.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 8, ""changes"": 27, ""blob_url"": ""https://github.com/ThomasDickey/lynx-snapshots/blob/280a61b300a1614f6037efc0902ff7ecf17146e9/src/HTML.c"", ""raw_url"": ""https://github.com/ThomasDickey/lynx-snapshots/raw/280a61b300a1614f6037efc0902ff7ecf17146e9/src/HTML.c"", ""contents_url"": ""https://api.github.com/repos/ThomasDickey/lynx-snapshots/contents/src/HTML.c?ref=280a61b300a1614f6037efc0902ff7ecf17146e9"", ""patch"": ""@@ -1,5 +1,5 @@\n /*\n- * $LynxId: HTML.c,v 1.173 2017/07/04 20:05:01 tom Exp $\n+ * $LynxId: HTML.c,v 1.174 2017/07/05 22:48:09 tom Exp $\n  *\n  *\t\tStructured stream to Rich hypertext converter\n  *\t\t============================================\n@@ -505,6 +505,8 @@ void HTML_put_character(HTStructured * me, int c)\n  */\n void HTML_put_string(HTStructured * me, const char *s)\n {\n+    HTChunk *target = NULL;\n+\n #ifdef USE_PRETTYSRC\n     char *translated_string = NULL;\n #endif\n@@ -525,15 +527,15 @@ void HTML_put_string(HTStructured * me, const char *s)\n \tbreak;\t\t\t/* Do Nothing */\n \n     case HTML_TITLE:\n-\tHTChunkPuts(&me->title, s);\n+\ttarget = &me->title;\n \tbreak;\n \n     case HTML_STYLE:\n-\tHTChunkPuts(&me->style_block, s);\n+\ttarget = &me->style_block;\n \tbreak;\n \n     case HTML_SCRIPT:\n-\tHTChunkPuts(&me->script, s);\n+\ttarget = &me->script;\n \tbreak;\n \n     case HTML_PRE:\t\t/* Formatted text */\n@@ -547,20 +549,20 @@ void HTML_put_string(HTStructured * me, const char *s)\n \tbreak;\n \n     case HTML_OBJECT:\n-\tHTChunkPuts(&me->object, s);\n+\ttarget = &me->object;\n \tbreak;\n \n     case HTML_TEXTAREA:\n-\tHTChunkPuts(&me->textarea, s);\n+\ttarget = &me->textarea;\n \tbreak;\n \n     case HTML_SELECT:\n     case HTML_OPTION:\n-\tHTChunkPuts(&me->option, s);\n+\ttarget = &me->option;\n \tbreak;\n \n     case HTML_MATH:\n-\tHTChunkPuts(&me->math, s);\n+\ttarget = &me->math;\n \tbreak;\n \n     default:\t\t\t/* Free format text? */\n@@ -651,6 +653,15 @@ void HTML_put_string(HTStructured * me, const char *s)\n \t    }\t\t\t/* for */\n \t}\n     }\t\t\t\t/* end switch */\n+\n+    if (target != NULL) {\n+\tif (target->data == s) {\n+\t    CTRACE((tfp, \""BUG: appending chunk to itself: `%.*s'\\n\"",\n+\t\t    target->size, target->data));\n+\t} else {\n+\t    HTChunkPuts(target, s);\n+\t}\n+    }\n #ifdef USE_PRETTYSRC\n     if (psrc_convert_string) {\n \tpsrc_convert_string = FALSE;""}"," void HTML_put_string(HTStructured * me, const char *s)
 {
    HTChunk *target = NULL;

 #ifdef USE_PRETTYSRC
     char *translated_string = NULL;
 #endif

    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))
	return;
#ifdef USE_PRETTYSRC
    if (psrc_convert_string) {
	StrAllocCopy(translated_string, s);
	TRANSLATE_AND_UNESCAPE_ENTITIES(&translated_string, TRUE, FALSE);
	s = (const char *) translated_string;
    }
#endif

    switch (me->sp[0].tag_number) {

    case HTML_COMMENT:
 	break;			/* Do Nothing */
 
     case HTML_TITLE:
	target = &me->title;
 	break;
 
     case HTML_STYLE:
	target = &me->style_block;
 	break;
 
     case HTML_SCRIPT:
	target = &me->script;
 	break;
 
     case HTML_PRE:		/* Formatted text */
    case HTML_LISTING:		/* Literal text */
    case HTML_XMP:
    case HTML_PLAINTEXT:
	/*
	 * We guarantee that the style is up-to-date in begin_litteral
	 */
	HText_appendText(me->text, s);
 	break;
 
     case HTML_OBJECT:
	target = &me->object;
 	break;
 
     case HTML_TEXTAREA:
	target = &me->textarea;
 	break;
 
     case HTML_SELECT:
     case HTML_OPTION:
	target = &me->option;
 	break;
 
     case HTML_MATH:
	target = &me->math;
 	break;
 
     default:			/* Free format text? */
	if (!me->sp->style->freeFormat) {
	    /*
	     * If we are within a preformatted text style not caught by the
	     * cases above (HTML_PRE or similar may not be the last element
	     * pushed on the style stack).  - kw
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		/*
		 * We do this so that a raw '\r' in the string will not be
		 * interpreted as an internal request to break a line - passing
		 * '\r' to HText_appendText is treated by it as a request to
		 * insert a blank line - VH
		 */
		for (; *s; ++s)
		    HTML_put_character(me, *s);
	    } else
#endif
		HText_appendText(me->text, s);
	    break;
	} else {
	    const char *p = s;
	    char c;

	    if (me->style_change) {
		for (; *p && ((*p == '\n') || (*p == '\r') ||
			      (*p == ' ') || (*p == '\t')); p++) ;	/* Ignore leaders */
		if (!*p)
		    break;
		UPDATE_STYLE;
	    }
	    for (; *p; p++) {
		if (*p == 13 && p[1] != 10) {
		    /*
		     * Treat any '\r' which is not followed by '\n' as '\n', to
		     * account for macintosh lineend in ALT attributes etc.  -
		     * kw
		     */
		    c = '\n';
		} else {
		    c = *p;
		}
		if (me->style_change) {
		    if ((c == '\n') || (c == ' ') || (c == '\t'))
			continue;	/* Ignore it */
		    UPDATE_STYLE;
		}
		if (c == '\n') {
		    if (!FIX_JAPANESE_SPACES) {
			if (me->in_word) {
			    if (HText_getLastChar(me->text) != ' ')
				HText_appendCharacter(me->text, ' ');
			    me->in_word = NO;
			}
		    }

		} else if (c == ' ' || c == '\t') {
		    if (HText_getLastChar(me->text) != ' ')
			HText_appendCharacter(me->text, ' ');

		} else if (c == '\r') {
		    /* ignore */
		} else {
		    HText_appendCharacter(me->text, c);
		    me->in_word = YES;
		}

		/* set the Last Character */
		if (c == '\n' || c == '\t') {
		    /* set it to a generic separator */
		    HText_setLastChar(me->text, ' ');
		} else if (c == '\r' &&
			   HText_getLastChar(me->text) == ' ') {
		    /*
		     * \r's are ignored.  In order to keep collapsing spaces
		     * correctly, we must default back to the previous
		     * separator, if there was one.  So we set LastChar to a
		     * generic separator.
		     */
		    HText_setLastChar(me->text, ' ');
		} else {
		    HText_setLastChar(me->text, c);
		}

 	    }			/* for */
 	}
     }				/* end switch */

    if (target != NULL) {
	if (target->data == s) {
	    CTRACE((tfp, ""BUG: appending chunk to itself: `%.*s'\n"",
		    target->size, target->data));
	} else {
	    HTChunkPuts(target, s);
	}
    }
 #ifdef USE_PRETTYSRC
     if (psrc_convert_string) {
 	psrc_convert_string = FALSE;
	FREE(translated_string);
    }
#endif
}
"," void HTML_put_string(HTStructured * me, const char *s)
 {
 #ifdef USE_PRETTYSRC
     char *translated_string = NULL;
 #endif

    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))
	return;
#ifdef USE_PRETTYSRC
    if (psrc_convert_string) {
	StrAllocCopy(translated_string, s);
	TRANSLATE_AND_UNESCAPE_ENTITIES(&translated_string, TRUE, FALSE);
	s = (const char *) translated_string;
    }
#endif

    switch (me->sp[0].tag_number) {

    case HTML_COMMENT:
 	break;			/* Do Nothing */
 
     case HTML_TITLE:
	HTChunkPuts(&me->title, s);
 	break;
 
     case HTML_STYLE:
	HTChunkPuts(&me->style_block, s);
 	break;
 
     case HTML_SCRIPT:
	HTChunkPuts(&me->script, s);
 	break;
 
     case HTML_PRE:		/* Formatted text */
    case HTML_LISTING:		/* Literal text */
    case HTML_XMP:
    case HTML_PLAINTEXT:
	/*
	 * We guarantee that the style is up-to-date in begin_litteral
	 */
	HText_appendText(me->text, s);
 	break;
 
     case HTML_OBJECT:
	HTChunkPuts(&me->object, s);
 	break;
 
     case HTML_TEXTAREA:
	HTChunkPuts(&me->textarea, s);
 	break;
 
     case HTML_SELECT:
     case HTML_OPTION:
	HTChunkPuts(&me->option, s);
 	break;
 
     case HTML_MATH:
	HTChunkPuts(&me->math, s);
 	break;
 
     default:			/* Free format text? */
	if (!me->sp->style->freeFormat) {
	    /*
	     * If we are within a preformatted text style not caught by the
	     * cases above (HTML_PRE or similar may not be the last element
	     * pushed on the style stack).  - kw
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		/*
		 * We do this so that a raw '\r' in the string will not be
		 * interpreted as an internal request to break a line - passing
		 * '\r' to HText_appendText is treated by it as a request to
		 * insert a blank line - VH
		 */
		for (; *s; ++s)
		    HTML_put_character(me, *s);
	    } else
#endif
		HText_appendText(me->text, s);
	    break;
	} else {
	    const char *p = s;
	    char c;

	    if (me->style_change) {
		for (; *p && ((*p == '\n') || (*p == '\r') ||
			      (*p == ' ') || (*p == '\t')); p++) ;	/* Ignore leaders */
		if (!*p)
		    break;
		UPDATE_STYLE;
	    }
	    for (; *p; p++) {
		if (*p == 13 && p[1] != 10) {
		    /*
		     * Treat any '\r' which is not followed by '\n' as '\n', to
		     * account for macintosh lineend in ALT attributes etc.  -
		     * kw
		     */
		    c = '\n';
		} else {
		    c = *p;
		}
		if (me->style_change) {
		    if ((c == '\n') || (c == ' ') || (c == '\t'))
			continue;	/* Ignore it */
		    UPDATE_STYLE;
		}
		if (c == '\n') {
		    if (!FIX_JAPANESE_SPACES) {
			if (me->in_word) {
			    if (HText_getLastChar(me->text) != ' ')
				HText_appendCharacter(me->text, ' ');
			    me->in_word = NO;
			}
		    }

		} else if (c == ' ' || c == '\t') {
		    if (HText_getLastChar(me->text) != ' ')
			HText_appendCharacter(me->text, ' ');

		} else if (c == '\r') {
		    /* ignore */
		} else {
		    HText_appendCharacter(me->text, c);
		    me->in_word = YES;
		}

		/* set the Last Character */
		if (c == '\n' || c == '\t') {
		    /* set it to a generic separator */
		    HText_setLastChar(me->text, ' ');
		} else if (c == '\r' &&
			   HText_getLastChar(me->text) == ' ') {
		    /*
		     * \r's are ignored.  In order to keep collapsing spaces
		     * correctly, we must default back to the previous
		     * separator, if there was one.  So we set LastChar to a
		     * generic separator.
		     */
		    HText_setLastChar(me->text, ' ');
		} else {
		    HText_setLastChar(me->text, c);
		}

 	    }			/* for */
 	}
     }				/* end switch */
 #ifdef USE_PRETTYSRC
     if (psrc_convert_string) {
 	psrc_convert_string = FALSE;
	FREE(translated_string);
    }
#endif
}
",C,"    HTChunk *target = NULL;

	target = &me->title;
	target = &me->style_block;
	target = &me->script;
	target = &me->object;
	target = &me->textarea;
	target = &me->option;
	target = &me->math;

    if (target != NULL) {
	if (target->data == s) {
	    CTRACE((tfp, ""BUG: appending chunk to itself: `%.*s'\n"",
		    target->size, target->data));
	} else {
	    HTChunkPuts(target, s);
	}
    }
","	HTChunkPuts(&me->title, s);
	HTChunkPuts(&me->style_block, s);
	HTChunkPuts(&me->script, s);
	HTChunkPuts(&me->object, s);
	HTChunkPuts(&me->textarea, s);
	HTChunkPuts(&me->option, s);
	HTChunkPuts(&me->math, s);
",,"@@ -1,5 +1,5 @@
 /*
- * $LynxId: HTML.c,v 1.173 2017/07/04 20:05:01 tom Exp $
+ * $LynxId: HTML.c,v 1.174 2017/07/05 22:48:09 tom Exp $
  *
  *		Structured stream to Rich hypertext converter
  *		============================================
@@ -505,6 +505,8 @@ void HTML_put_character(HTStructured * me, int c)
  */
 void HTML_put_string(HTStructured * me, const char *s)
 {
+    HTChunk *target = NULL;
+
 #ifdef USE_PRETTYSRC
     char *translated_string = NULL;
 #endif
@@ -525,15 +527,15 @@ void HTML_put_string(HTStructured * me, const char *s)
 	break;			/* Do Nothing */
 
     case HTML_TITLE:
-	HTChunkPuts(&me->title, s);
+	target = &me->title;
 	break;
 
     case HTML_STYLE:
-	HTChunkPuts(&me->style_block, s);
+	target = &me->style_block;
 	break;
 
     case HTML_SCRIPT:
-	HTChunkPuts(&me->script, s);
+	target = &me->script;
 	break;
 
     case HTML_PRE:		/* Formatted text */
@@ -547,20 +549,20 @@ void HTML_put_string(HTStructured * me, const char *s)
 	break;
 
     case HTML_OBJECT:
-	HTChunkPuts(&me->object, s);
+	target = &me->object;
 	break;
 
     case HTML_TEXTAREA:
-	HTChunkPuts(&me->textarea, s);
+	target = &me->textarea;
 	break;
 
     case HTML_SELECT:
     case HTML_OPTION:
-	HTChunkPuts(&me->option, s);
+	target = &me->option;
 	break;
 
     case HTML_MATH:
-	HTChunkPuts(&me->math, s);
+	target = &me->math;
 	break;
 
     default:			/* Free format text? */
@@ -651,6 +653,15 @@ void HTML_put_string(HTStructured * me, const char *s)
 	    }			/* for */
 	}
     }				/* end switch */
+
+    if (target != NULL) {
+	if (target->data == s) {
+	    CTRACE((tfp, ""BUG: appending chunk to itself: `%.*s'\n"",
+		    target->size, target->data));
+	} else {
+	    HTChunkPuts(target, s);
+	}
+    }
 #ifdef USE_PRETTYSRC
     if (psrc_convert_string) {
 	psrc_convert_string = FALSE;",lynx-snapshots,280a61b300a1614f6037efc0902ff7ecf17146e9,3c6d755816137c48e386c84490f685efcd0066ba,1," void HTML_put_string(HTStructured * me, const char *s)
 {
//fix_flaw_line_below:
//    HTChunk *target = NULL;
//fix_flaw_line_below:
//
 #ifdef USE_PRETTYSRC
     char *translated_string = NULL;
 #endif

    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))
	return;
#ifdef USE_PRETTYSRC
    if (psrc_convert_string) {
	StrAllocCopy(translated_string, s);
	TRANSLATE_AND_UNESCAPE_ENTITIES(&translated_string, TRUE, FALSE);
	s = (const char *) translated_string;
    }
#endif

    switch (me->sp[0].tag_number) {

    case HTML_COMMENT:
 	break;			/* Do Nothing */
 
     case HTML_TITLE:
//flaw_line_below:
	HTChunkPuts(&me->title, s);
//fix_flaw_line_below:
//	target = &me->title;
 	break;
 
     case HTML_STYLE:
//flaw_line_below:
	HTChunkPuts(&me->style_block, s);
//fix_flaw_line_below:
//	target = &me->style_block;
 	break;
 
     case HTML_SCRIPT:
//flaw_line_below:
	HTChunkPuts(&me->script, s);
//fix_flaw_line_below:
//	target = &me->script;
 	break;
 
     case HTML_PRE:		/* Formatted text */
    case HTML_LISTING:		/* Literal text */
    case HTML_XMP:
    case HTML_PLAINTEXT:
	/*
	 * We guarantee that the style is up-to-date in begin_litteral
	 */
	HText_appendText(me->text, s);
 	break;
 
     case HTML_OBJECT:
//flaw_line_below:
	HTChunkPuts(&me->object, s);
//fix_flaw_line_below:
//	target = &me->object;
 	break;
 
     case HTML_TEXTAREA:
//flaw_line_below:
	HTChunkPuts(&me->textarea, s);
//fix_flaw_line_below:
//	target = &me->textarea;
 	break;
 
     case HTML_SELECT:
     case HTML_OPTION:
//flaw_line_below:
	HTChunkPuts(&me->option, s);
//fix_flaw_line_below:
//	target = &me->option;
 	break;
 
     case HTML_MATH:
//flaw_line_below:
	HTChunkPuts(&me->math, s);
//fix_flaw_line_below:
//	target = &me->math;
 	break;
 
     default:			/* Free format text? */
	if (!me->sp->style->freeFormat) {
	    /*
	     * If we are within a preformatted text style not caught by the
	     * cases above (HTML_PRE or similar may not be the last element
	     * pushed on the style stack).  - kw
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		/*
		 * We do this so that a raw '\r' in the string will not be
		 * interpreted as an internal request to break a line - passing
		 * '\r' to HText_appendText is treated by it as a request to
		 * insert a blank line - VH
		 */
		for (; *s; ++s)
		    HTML_put_character(me, *s);
	    } else
#endif
		HText_appendText(me->text, s);
	    break;
	} else {
	    const char *p = s;
	    char c;

	    if (me->style_change) {
		for (; *p && ((*p == '\n') || (*p == '\r') ||
			      (*p == ' ') || (*p == '\t')); p++) ;	/* Ignore leaders */
		if (!*p)
		    break;
		UPDATE_STYLE;
	    }
	    for (; *p; p++) {
		if (*p == 13 && p[1] != 10) {
		    /*
		     * Treat any '\r' which is not followed by '\n' as '\n', to
		     * account for macintosh lineend in ALT attributes etc.  -
		     * kw
		     */
		    c = '\n';
		} else {
		    c = *p;
		}
		if (me->style_change) {
		    if ((c == '\n') || (c == ' ') || (c == '\t'))
			continue;	/* Ignore it */
		    UPDATE_STYLE;
		}
		if (c == '\n') {
		    if (!FIX_JAPANESE_SPACES) {
			if (me->in_word) {
			    if (HText_getLastChar(me->text) != ' ')
				HText_appendCharacter(me->text, ' ');
			    me->in_word = NO;
			}
		    }

		} else if (c == ' ' || c == '\t') {
		    if (HText_getLastChar(me->text) != ' ')
			HText_appendCharacter(me->text, ' ');

		} else if (c == '\r') {
		    /* ignore */
		} else {
		    HText_appendCharacter(me->text, c);
		    me->in_word = YES;
		}

		/* set the Last Character */
		if (c == '\n' || c == '\t') {
		    /* set it to a generic separator */
		    HText_setLastChar(me->text, ' ');
		} else if (c == '\r' &&
			   HText_getLastChar(me->text) == ' ') {
		    /*
		     * \r's are ignored.  In order to keep collapsing spaces
		     * correctly, we must default back to the previous
		     * separator, if there was one.  So we set LastChar to a
		     * generic separator.
		     */
		    HText_setLastChar(me->text, ' ');
		} else {
		    HText_setLastChar(me->text, c);
		}

 	    }			/* for */
 	}
     }				/* end switch */
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (target != NULL) {
//fix_flaw_line_below:
//	if (target->data == s) {
//fix_flaw_line_below:
//	    CTRACE((tfp, ""BUG: appending chunk to itself: `%.*s'\n"",
//fix_flaw_line_below:
//		    target->size, target->data));
//fix_flaw_line_below:
//	} else {
//fix_flaw_line_below:
//	    HTChunkPuts(target, s);
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//    }
 #ifdef USE_PRETTYSRC
     if (psrc_convert_string) {
 	psrc_convert_string = FALSE;
	FREE(translated_string);
    }
#endif
}
",180801," void HTML_put_string(HTStructured * me, const char *s)
 {
 #ifdef USE_PRETTYSRC
     char *translated_string = NULL;
 #endif

    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))
	return;
#ifdef USE_PRETTYSRC
    if (psrc_convert_string) {
	StrAllocCopy(translated_string, s);
	TRANSLATE_AND_UNESCAPE_ENTITIES(&translated_string, TRUE, FALSE);
	s = (const char *) translated_string;
    }
#endif

    switch (me->sp[0].tag_number) {

    case HTML_COMMENT:
 	break;			/* Do Nothing */
 
     case HTML_TITLE:
	HTChunkPuts(&me->title, s);
 	break;
 
     case HTML_STYLE:
	HTChunkPuts(&me->style_block, s);
 	break;
 
     case HTML_SCRIPT:
	HTChunkPuts(&me->script, s);
 	break;
 
     case HTML_PRE:		/* Formatted text */
    case HTML_LISTING:		/* Literal text */
    case HTML_XMP:
    case HTML_PLAINTEXT:
	/*
	 * We guarantee that the style is up-to-date in begin_litteral
	 */
	HText_appendText(me->text, s);
 	break;
 
     case HTML_OBJECT:
	HTChunkPuts(&me->object, s);
 	break;
 
     case HTML_TEXTAREA:
	HTChunkPuts(&me->textarea, s);
 	break;
 
     case HTML_SELECT:
     case HTML_OPTION:
	HTChunkPuts(&me->option, s);
 	break;
 
     case HTML_MATH:
	HTChunkPuts(&me->math, s);
 	break;
 
     default:			/* Free format text? */
	if (!me->sp->style->freeFormat) {
	    /*
	     * If we are within a preformatted text style not caught by the
	     * cases above (HTML_PRE or similar may not be the last element
	     * pushed on the style stack).  - kw
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		/*
		 * We do this so that a raw '\r' in the string will not be
		 * interpreted as an internal request to break a line - passing
		 * '\r' to HText_appendText is treated by it as a request to
		 * insert a blank line - VH
		 */
		for (; *s; ++s)
		    HTML_put_character(me, *s);
	    } else
#endif
		HText_appendText(me->text, s);
	    break;
	} else {
	    const char *p = s;
	    char c;

	    if (me->style_change) {
		for (; *p && ((*p == '\n') || (*p == '\r') ||
			      (*p == ' ') || (*p == '\t')); p++) ;	/* Ignore leaders */
		if (!*p)
		    break;
		UPDATE_STYLE;
	    }
	    for (; *p; p++) {
		if (*p == 13 && p[1] != 10) {
		    /*
		     * Treat any '\r' which is not followed by '\n' as '\n', to
		     * account for macintosh lineend in ALT attributes etc.  -
		     * kw
		     */
		    c = '\n';
		} else {
		    c = *p;
		}
		if (me->style_change) {
		    if ((c == '\n') || (c == ' ') || (c == '\t'))
			continue;	/* Ignore it */
		    UPDATE_STYLE;
		}
		if (c == '\n') {
		    if (!FIX_JAPANESE_SPACES) {
			if (me->in_word) {
			    if (HText_getLastChar(me->text) != ' ')
				HText_appendCharacter(me->text, ' ');
			    me->in_word = NO;
			}
		    }

		} else if (c == ' ' || c == '\t') {
		    if (HText_getLastChar(me->text) != ' ')
			HText_appendCharacter(me->text, ' ');

		} else if (c == '\r') {
		    /* ignore */
		} else {
		    HText_appendCharacter(me->text, c);
		    me->in_word = YES;
		}

		/* set the Last Character */
		if (c == '\n' || c == '\t') {
		    /* set it to a generic separator */
		    HText_setLastChar(me->text, ' ');
		} else if (c == '\r' &&
			   HText_getLastChar(me->text) == ' ') {
		    /*
		     * \r's are ignored.  In order to keep collapsing spaces
		     * correctly, we must default back to the previous
		     * separator, if there was one.  So we set LastChar to a
		     * generic separator.
		     */
		    HText_setLastChar(me->text, ' ');
		} else {
		    HText_setLastChar(me->text, c);
		}

 	    }			/* for */
 	}
     }				/* end switch */
 #ifdef USE_PRETTYSRC
     if (psrc_convert_string) {
 	psrc_convert_string = FALSE;
	FREE(translated_string);
    }
#endif
}
"," void HTML_put_string(HTStructured * me, const char *s)
 {
    HTChunk *target = NULL;

 #ifdef USE_PRETTYSRC
     char *translated_string = NULL;
 #endif

    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))
	return;
#ifdef USE_PRETTYSRC
    if (psrc_convert_string) {
	StrAllocCopy(translated_string, s);
	TRANSLATE_AND_UNESCAPE_ENTITIES(&translated_string, TRUE, FALSE);
	s = (const char *) translated_string;
    }
#endif

    switch (me->sp[0].tag_number) {

    case HTML_COMMENT:
 	break;			/* Do Nothing */
 
     case HTML_TITLE:
	target = &me->title;
 	break;
 
     case HTML_STYLE:
	target = &me->style_block;
 	break;
 
     case HTML_SCRIPT:
	target = &me->script;
 	break;
 
     case HTML_PRE:		/* Formatted text */
    case HTML_LISTING:		/* Literal text */
    case HTML_XMP:
    case HTML_PLAINTEXT:
	/*
	 * We guarantee that the style is up-to-date in begin_litteral
	 */
	HText_appendText(me->text, s);
 	break;
 
     case HTML_OBJECT:
	target = &me->object;
 	break;
 
     case HTML_TEXTAREA:
	target = &me->textarea;
 	break;
 
     case HTML_SELECT:
     case HTML_OPTION:
	target = &me->option;
 	break;
 
     case HTML_MATH:
	target = &me->math;
 	break;
 
     default:			/* Free format text? */
	if (!me->sp->style->freeFormat) {
	    /*
	     * If we are within a preformatted text style not caught by the
	     * cases above (HTML_PRE or similar may not be the last element
	     * pushed on the style stack).  - kw
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		/*
		 * We do this so that a raw '\r' in the string will not be
		 * interpreted as an internal request to break a line - passing
		 * '\r' to HText_appendText is treated by it as a request to
		 * insert a blank line - VH
		 */
		for (; *s; ++s)
		    HTML_put_character(me, *s);
	    } else
#endif
		HText_appendText(me->text, s);
	    break;
	} else {
	    const char *p = s;
	    char c;

	    if (me->style_change) {
		for (; *p && ((*p == '\n') || (*p == '\r') ||
			      (*p == ' ') || (*p == '\t')); p++) ;	/* Ignore leaders */
		if (!*p)
		    break;
		UPDATE_STYLE;
	    }
	    for (; *p; p++) {
		if (*p == 13 && p[1] != 10) {
		    /*
		     * Treat any '\r' which is not followed by '\n' as '\n', to
		     * account for macintosh lineend in ALT attributes etc.  -
		     * kw
		     */
		    c = '\n';
		} else {
		    c = *p;
		}
		if (me->style_change) {
		    if ((c == '\n') || (c == ' ') || (c == '\t'))
			continue;	/* Ignore it */
		    UPDATE_STYLE;
		}
		if (c == '\n') {
		    if (!FIX_JAPANESE_SPACES) {
			if (me->in_word) {
			    if (HText_getLastChar(me->text) != ' ')
				HText_appendCharacter(me->text, ' ');
			    me->in_word = NO;
			}
		    }

		} else if (c == ' ' || c == '\t') {
		    if (HText_getLastChar(me->text) != ' ')
			HText_appendCharacter(me->text, ' ');

		} else if (c == '\r') {
		    /* ignore */
		} else {
		    HText_appendCharacter(me->text, c);
		    me->in_word = YES;
		}

		/* set the Last Character */
		if (c == '\n' || c == '\t') {
		    /* set it to a generic separator */
		    HText_setLastChar(me->text, ' ');
		} else if (c == '\r' &&
			   HText_getLastChar(me->text) == ' ') {
		    /*
		     * \r's are ignored.  In order to keep collapsing spaces
		     * correctly, we must default back to the previous
		     * separator, if there was one.  So we set LastChar to a
		     * generic separator.
		     */
		    HText_setLastChar(me->text, ' ');
		} else {
		    HText_setLastChar(me->text, c);
		}

 	    }			/* for */
 	}
     }				/* end switch */

    if (target != NULL) {
	if (target->data == s) {
	    CTRACE((tfp, ""BUG: appending chunk to itself: `%.*s'\n"",
		    target->size, target->data));
	} else {
	    HTChunkPuts(target, s);
	}
    }
 #ifdef USE_PRETTYSRC
     if (psrc_convert_string) {
 	psrc_convert_string = FALSE;
	FREE(translated_string);
    }
#endif
}
","The vulnerability in the original code lies in the potential for a self-referential append operation when using `HTChunkPuts`, specifically when `target->data` is equal to `s`. This could lead to undefined behavior or memory corruption. In the fixed code, a check is introduced to ensure that `target` is not the same as `s` before calling `HTChunkPuts(target, s)`. This prevents the function from appending the string to itself, thereby mitigating the risk of corruption or crashes. The addition of the conditional check enhances the robustness of the function against erroneous input.","The vulnerability in the original code arises from the lack of checks to prevent self-referential operations, which can lead to undefined behavior or memory corruption when appending a string to itself. This situation can occur if the input string is the same as the target data being modified. The fixed code addresses this issue by introducing a conditional check that verifies the input string is not the same as the target data before performing the append operation. This safeguard effectively prevents potential crashes or data corruption, enhancing the overall stability and security of the function."
19,180828,180828,,Local,Not required,Complete,CVE-2017-17052,https://www.cvedetails.com/cve/CVE-2017-17052/,CWE-416,Low,Complete,Complete,,2017-11-28,7.2,"The mm_init function in kernel/fork.c in the Linux kernel before 4.12.10 does not clear the ->exe_file member of a new process's mm_struct, allowing a local attacker to achieve a use-after-free or possibly have unspecified other impact by running a specially crafted program.",2017-12-20,,1,https://github.com/torvalds/linux/commit/2b7e8665b4ff51c034c55df3cff76518d1a9ee3a,2b7e8665b4ff51c034c55df3cff76518d1a9ee3a,"fork: fix incorrect fput of ->exe_file causing use-after-free

Commit 7c051267931a (""mm, fork: make dup_mmap wait for mmap_sem for
write killable"") made it possible to kill a forking task while it is
waiting to acquire its ->mmap_sem for write, in dup_mmap().

However, it was overlooked that this introduced an new error path before
a reference is taken on the mm_struct's ->exe_file.  Since the
->exe_file of the new mm_struct was already set to the old ->exe_file by
the memcpy() in dup_mm(), it was possible for the mmput() in the error
path of dup_mm() to drop a reference to ->exe_file which was never
taken.

This caused the struct file to later be freed prematurely.

Fix it by updating mm_init() to NULL out the ->exe_file, in the same
place it clears other things like the list of mmaps.

This bug was found by syzkaller.  It can be reproduced using the
following C program:

    #define _GNU_SOURCE
    #include <pthread.h>
    #include <stdlib.h>
    #include <sys/mman.h>
    #include <sys/syscall.h>
    #include <sys/wait.h>
    #include <unistd.h>

    static void *mmap_thread(void *_arg)
    {
        for (;;) {
            mmap(NULL, 0x1000000, PROT_READ,
                 MAP_POPULATE|MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
        }
    }

    static void *fork_thread(void *_arg)
    {
        usleep(rand() % 10000);
        fork();
    }

    int main(void)
    {
        fork();
        fork();
        fork();
        for (;;) {
            if (fork() == 0) {
                pthread_t t;

                pthread_create(&t, NULL, mmap_thread, NULL);
                pthread_create(&t, NULL, fork_thread, NULL);
                usleep(rand() % 10000);
                syscall(__NR_exit_group, 0);
            }
            wait(NULL);
        }
    }

No special kernel config options are needed.  It usually causes a NULL
pointer dereference in __remove_shared_vm_struct() during exit, or in
dup_mmap() (which is usually inlined into copy_process()) during fork.
Both are due to a vm_area_struct's ->vm_file being used after it's
already been freed.

Google Bug Id: 64772007

Link: http://lkml.kernel.org/r/20170823211408.31198-1-ebiggers3@gmail.com
Fixes: 7c051267931a (""mm, fork: make dup_mmap wait for mmap_sem for write killable"")
Signed-off-by: Eric Biggers <ebiggers@google.com>
Tested-by: Mark Rutland <mark.rutland@arm.com>
Acked-by: Michal Hocko <mhocko@suse.com>
Cc: Dmitry Vyukov <dvyukov@google.com>
Cc: Ingo Molnar <mingo@kernel.org>
Cc: Konstantin Khlebnikov <koct9i@gmail.com>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Vlastimil Babka <vbabka@suse.cz>
Cc: <stable@vger.kernel.org>	[v4.7+]
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,kernel/fork.c,"{""sha"": ""cbbea277b3fba7a8a1ff73ffaf620202a706036a"", ""filename"": ""kernel/fork.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/2b7e8665b4ff51c034c55df3cff76518d1a9ee3a/kernel/fork.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/2b7e8665b4ff51c034c55df3cff76518d1a9ee3a/kernel/fork.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/fork.c?ref=2b7e8665b4ff51c034c55df3cff76518d1a9ee3a"", ""patch"": ""@@ -806,6 +806,7 @@ static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n \tmm_init_cpumask(mm);\n \tmm_init_aio(mm);\n \tmm_init_owner(mm, p);\n+\tRCU_INIT_POINTER(mm->exe_file, NULL);\n \tmmu_notifier_mm_init(mm);\n \tinit_tlb_flush_pending(mm);\n #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS""}","static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,
	struct user_namespace *user_ns)
{
	mm->mmap = NULL;
	mm->mm_rb = RB_ROOT;
	mm->vmacache_seqnum = 0;
	atomic_set(&mm->mm_users, 1);
	atomic_set(&mm->mm_count, 1);
	init_rwsem(&mm->mmap_sem);
	INIT_LIST_HEAD(&mm->mmlist);
	mm->core_state = NULL;
	atomic_long_set(&mm->nr_ptes, 0);
	mm_nr_pmds_init(mm);
	mm->map_count = 0;
	mm->locked_vm = 0;
	mm->pinned_vm = 0;
	memset(&mm->rss_stat, 0, sizeof(mm->rss_stat));
	spin_lock_init(&mm->page_table_lock);
 	mm_init_cpumask(mm);
 	mm_init_aio(mm);
 	mm_init_owner(mm, p);
	RCU_INIT_POINTER(mm->exe_file, NULL);
 	mmu_notifier_mm_init(mm);
 	init_tlb_flush_pending(mm);
 #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS
	mm->pmd_huge_pte = NULL;
#endif

	if (current->mm) {
		mm->flags = current->mm->flags & MMF_INIT_MASK;
		mm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;
	} else {
		mm->flags = default_dump_filter;
		mm->def_flags = 0;
	}

	if (mm_alloc_pgd(mm))
		goto fail_nopgd;

	if (init_new_context(p, mm))
		goto fail_nocontext;

	mm->user_ns = get_user_ns(user_ns);
	return mm;

fail_nocontext:
	mm_free_pgd(mm);
fail_nopgd:
	free_mm(mm);
	return NULL;
}
","static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,
	struct user_namespace *user_ns)
{
	mm->mmap = NULL;
	mm->mm_rb = RB_ROOT;
	mm->vmacache_seqnum = 0;
	atomic_set(&mm->mm_users, 1);
	atomic_set(&mm->mm_count, 1);
	init_rwsem(&mm->mmap_sem);
	INIT_LIST_HEAD(&mm->mmlist);
	mm->core_state = NULL;
	atomic_long_set(&mm->nr_ptes, 0);
	mm_nr_pmds_init(mm);
	mm->map_count = 0;
	mm->locked_vm = 0;
	mm->pinned_vm = 0;
	memset(&mm->rss_stat, 0, sizeof(mm->rss_stat));
	spin_lock_init(&mm->page_table_lock);
 	mm_init_cpumask(mm);
 	mm_init_aio(mm);
 	mm_init_owner(mm, p);
 	mmu_notifier_mm_init(mm);
 	init_tlb_flush_pending(mm);
 #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS
	mm->pmd_huge_pte = NULL;
#endif

	if (current->mm) {
		mm->flags = current->mm->flags & MMF_INIT_MASK;
		mm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;
	} else {
		mm->flags = default_dump_filter;
		mm->def_flags = 0;
	}

	if (mm_alloc_pgd(mm))
		goto fail_nopgd;

	if (init_new_context(p, mm))
		goto fail_nocontext;

	mm->user_ns = get_user_ns(user_ns);
	return mm;

fail_nocontext:
	mm_free_pgd(mm);
fail_nopgd:
	free_mm(mm);
	return NULL;
}
",C,"	RCU_INIT_POINTER(mm->exe_file, NULL);
",,,"@@ -806,6 +806,7 @@ static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,
 	mm_init_cpumask(mm);
 	mm_init_aio(mm);
 	mm_init_owner(mm, p);
+	RCU_INIT_POINTER(mm->exe_file, NULL);
 	mmu_notifier_mm_init(mm);
 	init_tlb_flush_pending(mm);
 #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS",linux,2b7e8665b4ff51c034c55df3cff76518d1a9ee3a,263630e8d176d87308481ebdcd78ef9426739c6b,1,"static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,
	struct user_namespace *user_ns)
{
	mm->mmap = NULL;
	mm->mm_rb = RB_ROOT;
	mm->vmacache_seqnum = 0;
	atomic_set(&mm->mm_users, 1);
	atomic_set(&mm->mm_count, 1);
	init_rwsem(&mm->mmap_sem);
	INIT_LIST_HEAD(&mm->mmlist);
	mm->core_state = NULL;
	atomic_long_set(&mm->nr_ptes, 0);
	mm_nr_pmds_init(mm);
	mm->map_count = 0;
	mm->locked_vm = 0;
	mm->pinned_vm = 0;
	memset(&mm->rss_stat, 0, sizeof(mm->rss_stat));
	spin_lock_init(&mm->page_table_lock);
 	mm_init_cpumask(mm);
 	mm_init_aio(mm);
 	mm_init_owner(mm, p);
//fix_flaw_line_below:
//	RCU_INIT_POINTER(mm->exe_file, NULL);
 	mmu_notifier_mm_init(mm);
 	init_tlb_flush_pending(mm);
 #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS
	mm->pmd_huge_pte = NULL;
#endif

	if (current->mm) {
		mm->flags = current->mm->flags & MMF_INIT_MASK;
		mm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;
	} else {
		mm->flags = default_dump_filter;
		mm->def_flags = 0;
	}

	if (mm_alloc_pgd(mm))
		goto fail_nopgd;

	if (init_new_context(p, mm))
		goto fail_nocontext;

	mm->user_ns = get_user_ns(user_ns);
	return mm;

fail_nocontext:
	mm_free_pgd(mm);
fail_nopgd:
	free_mm(mm);
	return NULL;
}
",180828,"static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,
	struct user_namespace *user_ns)
{
	mm->mmap = NULL;
	mm->mm_rb = RB_ROOT;
	mm->vmacache_seqnum = 0;
	atomic_set(&mm->mm_users, 1);
	atomic_set(&mm->mm_count, 1);
	init_rwsem(&mm->mmap_sem);
	INIT_LIST_HEAD(&mm->mmlist);
	mm->core_state = NULL;
	atomic_long_set(&mm->nr_ptes, 0);
	mm_nr_pmds_init(mm);
	mm->map_count = 0;
	mm->locked_vm = 0;
	mm->pinned_vm = 0;
	memset(&mm->rss_stat, 0, sizeof(mm->rss_stat));
	spin_lock_init(&mm->page_table_lock);
 	mm_init_cpumask(mm);
 	mm_init_aio(mm);
 	mm_init_owner(mm, p);
 	mmu_notifier_mm_init(mm);
 	init_tlb_flush_pending(mm);
 #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS
	mm->pmd_huge_pte = NULL;
#endif

	if (current->mm) {
		mm->flags = current->mm->flags & MMF_INIT_MASK;
		mm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;
	} else {
		mm->flags = default_dump_filter;
		mm->def_flags = 0;
	}

	if (mm_alloc_pgd(mm))
		goto fail_nopgd;

	if (init_new_context(p, mm))
		goto fail_nocontext;

	mm->user_ns = get_user_ns(user_ns);
	return mm;

fail_nocontext:
	mm_free_pgd(mm);
fail_nopgd:
	free_mm(mm);
	return NULL;
}
","static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,
	struct user_namespace *user_ns)
{
	mm->mmap = NULL;
	mm->mm_rb = RB_ROOT;
	mm->vmacache_seqnum = 0;
	atomic_set(&mm->mm_users, 1);
	atomic_set(&mm->mm_count, 1);
	init_rwsem(&mm->mmap_sem);
	INIT_LIST_HEAD(&mm->mmlist);
	mm->core_state = NULL;
	atomic_long_set(&mm->nr_ptes, 0);
	mm_nr_pmds_init(mm);
	mm->map_count = 0;
	mm->locked_vm = 0;
	mm->pinned_vm = 0;
	memset(&mm->rss_stat, 0, sizeof(mm->rss_stat));
	spin_lock_init(&mm->page_table_lock);
 	mm_init_cpumask(mm);
 	mm_init_aio(mm);
 	mm_init_owner(mm, p);
	RCU_INIT_POINTER(mm->exe_file, NULL);
 	mmu_notifier_mm_init(mm);
 	init_tlb_flush_pending(mm);
 #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS
	mm->pmd_huge_pte = NULL;
#endif

	if (current->mm) {
		mm->flags = current->mm->flags & MMF_INIT_MASK;
		mm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;
	} else {
		mm->flags = default_dump_filter;
		mm->def_flags = 0;
	}

	if (mm_alloc_pgd(mm))
		goto fail_nopgd;

	if (init_new_context(p, mm))
		goto fail_nocontext;

	mm->user_ns = get_user_ns(user_ns);
	return mm;

fail_nocontext:
	mm_free_pgd(mm);
fail_nopgd:
	free_mm(mm);
	return NULL;
}
","The vulnerability in the original code lies in the lack of initialization for the `mm->exe_file` pointer, which could lead to undefined behavior if accessed before being set. This oversight may allow for potential use-after-free vulnerabilities or memory corruption, as the pointer could inadvertently reference invalid memory. In the fixed code, the vulnerability is addressed by adding the line `RCU_INIT_POINTER(mm->exe_file, NULL);`, which explicitly initializes the `exe_file` pointer to NULL, ensuring that it does not point to any arbitrary memory location and thus enhancing the stability and security of the memory management structure.","The vulnerability in the original code stems from the failure to initialize a critical pointer, which could lead to undefined behavior if accessed before being properly set. This oversight increases the risk of use-after-free vulnerabilities or memory corruption, as the pointer might reference invalid or unintended memory locations. The fixed code addresses this issue by explicitly initializing the pointer to NULL, ensuring that it does not point to any arbitrary memory. This change enhances the overall stability and security of the memory management structure, preventing potential exploitation and improving the reliability of the system."
20,180859,180859,,Local,Not required,Complete,CVE-2017-16525,https://www.cvedetails.com/cve/CVE-2017-16525/,CWE-416,Low,Complete,Complete,,2017-11-03,7.2,"The usb_serial_console_disconnect function in drivers/usb/serial/console.c in the Linux kernel before 4.13.8 allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via a crafted USB device, related to disconnection and failed setup.",2018-03-15,DoS ,1,https://github.com/torvalds/linux/commit/299d7572e46f98534033a9e65973f13ad1ce9047,299d7572e46f98534033a9e65973f13ad1ce9047,"USB: serial: console: fix use-after-free after failed setup

Make sure to reset the USB-console port pointer when console setup fails
in order to avoid having the struct usb_serial be prematurely freed by
the console code when the device is later disconnected.

Fixes: 73e487fdb75f (""[PATCH] USB console: fix disconnection issues"")
Cc: stable <stable@vger.kernel.org>	# 2.6.18
Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Johan Hovold <johan@kernel.org>",0,drivers/usb/serial/console.c,"{""sha"": ""43a862a90a77592eda9eab2aa75be90a69981ffc"", ""filename"": ""drivers/usb/serial/console.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/299d7572e46f98534033a9e65973f13ad1ce9047/drivers/usb/serial/console.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/299d7572e46f98534033a9e65973f13ad1ce9047/drivers/usb/serial/console.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/serial/console.c?ref=299d7572e46f98534033a9e65973f13ad1ce9047"", ""patch"": ""@@ -186,6 +186,7 @@ static int usb_console_setup(struct console *co, char *options)\n \ttty_kref_put(tty);\n  reset_open_count:\n \tport->port.count = 0;\n+\tinfo->port = NULL;\n \tusb_autopm_put_interface(serial->interface);\n  error_get_interface:\n \tusb_serial_put(serial);""}","static int usb_console_setup(struct console *co, char *options)
{
	struct usbcons_info *info = &usbcons_info;
	int baud = 9600;
	int bits = 8;
	int parity = 'n';
	int doflow = 0;
	int cflag = CREAD | HUPCL | CLOCAL;
	char *s;
	struct usb_serial *serial;
	struct usb_serial_port *port;
	int retval;
	struct tty_struct *tty = NULL;
	struct ktermios dummy;

	if (options) {
		baud = simple_strtoul(options, NULL, 10);
		s = options;
		while (*s >= '0' && *s <= '9')
			s++;
		if (*s)
			parity = *s++;
		if (*s)
			bits   = *s++ - '0';
		if (*s)
			doflow = (*s++ == 'r');
	}
	
	/* Sane default */
	if (baud == 0)
		baud = 9600;

	switch (bits) {
	case 7:
		cflag |= CS7;
		break;
	default:
	case 8:
		cflag |= CS8;
		break;
	}
	switch (parity) {
	case 'o': case 'O':
		cflag |= PARODD;
		break;
	case 'e': case 'E':
		cflag |= PARENB;
		break;
	}
	co->cflag = cflag;

	/*
	 * no need to check the index here: if the index is wrong, console
	 * code won't call us
	 */
	port = usb_serial_port_get_by_minor(co->index);
	if (port == NULL) {
		/* no device is connected yet, sorry :( */
		pr_err(""No USB device connected to ttyUSB%i\n"", co->index);
		return -ENODEV;
	}
	serial = port->serial;

	retval = usb_autopm_get_interface(serial->interface);
	if (retval)
		goto error_get_interface;

	tty_port_tty_set(&port->port, NULL);

	info->port = port;

	++port->port.count;
	if (!tty_port_initialized(&port->port)) {
		if (serial->type->set_termios) {
			/*
			 * allocate a fake tty so the driver can initialize
			 * the termios structure, then later call set_termios to
			 * configure according to command line arguments
			 */
			tty = kzalloc(sizeof(*tty), GFP_KERNEL);
			if (!tty) {
				retval = -ENOMEM;
				goto reset_open_count;
			}
			kref_init(&tty->kref);
			tty->driver = usb_serial_tty_driver;
			tty->index = co->index;
			init_ldsem(&tty->ldisc_sem);
			spin_lock_init(&tty->files_lock);
			INIT_LIST_HEAD(&tty->tty_files);
			kref_get(&tty->driver->kref);
			__module_get(tty->driver->owner);
			tty->ops = &usb_console_fake_tty_ops;
			tty_init_termios(tty);
			tty_port_tty_set(&port->port, tty);
		}

		/* only call the device specific open if this
		 * is the first time the port is opened */
		retval = serial->type->open(NULL, port);
		if (retval) {
			dev_err(&port->dev, ""could not open USB console port\n"");
			goto fail;
		}

		if (serial->type->set_termios) {
			tty->termios.c_cflag = cflag;
			tty_termios_encode_baud_rate(&tty->termios, baud, baud);
			memset(&dummy, 0, sizeof(struct ktermios));
			serial->type->set_termios(tty, port, &dummy);

			tty_port_tty_set(&port->port, NULL);
			tty_kref_put(tty);
		}
		tty_port_set_initialized(&port->port, 1);
	}
	/* Now that any required fake tty operations are completed restore
	 * the tty port count */
	--port->port.count;
	/* The console is special in terms of closing the device so
	 * indicate this port is now acting as a system console. */
	port->port.console = 1;

	mutex_unlock(&serial->disc_mutex);
	return retval;

 fail:
	tty_port_tty_set(&port->port, NULL);
 	tty_kref_put(tty);
  reset_open_count:
 	port->port.count = 0;
	info->port = NULL;
 	usb_autopm_put_interface(serial->interface);
  error_get_interface:
 	usb_serial_put(serial);
	mutex_unlock(&serial->disc_mutex);
	return retval;
}
","static int usb_console_setup(struct console *co, char *options)
{
	struct usbcons_info *info = &usbcons_info;
	int baud = 9600;
	int bits = 8;
	int parity = 'n';
	int doflow = 0;
	int cflag = CREAD | HUPCL | CLOCAL;
	char *s;
	struct usb_serial *serial;
	struct usb_serial_port *port;
	int retval;
	struct tty_struct *tty = NULL;
	struct ktermios dummy;

	if (options) {
		baud = simple_strtoul(options, NULL, 10);
		s = options;
		while (*s >= '0' && *s <= '9')
			s++;
		if (*s)
			parity = *s++;
		if (*s)
			bits   = *s++ - '0';
		if (*s)
			doflow = (*s++ == 'r');
	}
	
	/* Sane default */
	if (baud == 0)
		baud = 9600;

	switch (bits) {
	case 7:
		cflag |= CS7;
		break;
	default:
	case 8:
		cflag |= CS8;
		break;
	}
	switch (parity) {
	case 'o': case 'O':
		cflag |= PARODD;
		break;
	case 'e': case 'E':
		cflag |= PARENB;
		break;
	}
	co->cflag = cflag;

	/*
	 * no need to check the index here: if the index is wrong, console
	 * code won't call us
	 */
	port = usb_serial_port_get_by_minor(co->index);
	if (port == NULL) {
		/* no device is connected yet, sorry :( */
		pr_err(""No USB device connected to ttyUSB%i\n"", co->index);
		return -ENODEV;
	}
	serial = port->serial;

	retval = usb_autopm_get_interface(serial->interface);
	if (retval)
		goto error_get_interface;

	tty_port_tty_set(&port->port, NULL);

	info->port = port;

	++port->port.count;
	if (!tty_port_initialized(&port->port)) {
		if (serial->type->set_termios) {
			/*
			 * allocate a fake tty so the driver can initialize
			 * the termios structure, then later call set_termios to
			 * configure according to command line arguments
			 */
			tty = kzalloc(sizeof(*tty), GFP_KERNEL);
			if (!tty) {
				retval = -ENOMEM;
				goto reset_open_count;
			}
			kref_init(&tty->kref);
			tty->driver = usb_serial_tty_driver;
			tty->index = co->index;
			init_ldsem(&tty->ldisc_sem);
			spin_lock_init(&tty->files_lock);
			INIT_LIST_HEAD(&tty->tty_files);
			kref_get(&tty->driver->kref);
			__module_get(tty->driver->owner);
			tty->ops = &usb_console_fake_tty_ops;
			tty_init_termios(tty);
			tty_port_tty_set(&port->port, tty);
		}

		/* only call the device specific open if this
		 * is the first time the port is opened */
		retval = serial->type->open(NULL, port);
		if (retval) {
			dev_err(&port->dev, ""could not open USB console port\n"");
			goto fail;
		}

		if (serial->type->set_termios) {
			tty->termios.c_cflag = cflag;
			tty_termios_encode_baud_rate(&tty->termios, baud, baud);
			memset(&dummy, 0, sizeof(struct ktermios));
			serial->type->set_termios(tty, port, &dummy);

			tty_port_tty_set(&port->port, NULL);
			tty_kref_put(tty);
		}
		tty_port_set_initialized(&port->port, 1);
	}
	/* Now that any required fake tty operations are completed restore
	 * the tty port count */
	--port->port.count;
	/* The console is special in terms of closing the device so
	 * indicate this port is now acting as a system console. */
	port->port.console = 1;

	mutex_unlock(&serial->disc_mutex);
	return retval;

 fail:
	tty_port_tty_set(&port->port, NULL);
 	tty_kref_put(tty);
  reset_open_count:
 	port->port.count = 0;
 	usb_autopm_put_interface(serial->interface);
  error_get_interface:
 	usb_serial_put(serial);
	mutex_unlock(&serial->disc_mutex);
	return retval;
}
",C,"	info->port = NULL;
",,,"@@ -186,6 +186,7 @@ static int usb_console_setup(struct console *co, char *options)
 	tty_kref_put(tty);
  reset_open_count:
 	port->port.count = 0;
+	info->port = NULL;
 	usb_autopm_put_interface(serial->interface);
  error_get_interface:
 	usb_serial_put(serial);",linux,299d7572e46f98534033a9e65973f13ad1ce9047,bd998c2e0df0469707503023d50d46cf0b10c787,1,"static int usb_console_setup(struct console *co, char *options)
{
	struct usbcons_info *info = &usbcons_info;
	int baud = 9600;
	int bits = 8;
	int parity = 'n';
	int doflow = 0;
	int cflag = CREAD | HUPCL | CLOCAL;
	char *s;
	struct usb_serial *serial;
	struct usb_serial_port *port;
	int retval;
	struct tty_struct *tty = NULL;
	struct ktermios dummy;

	if (options) {
		baud = simple_strtoul(options, NULL, 10);
		s = options;
		while (*s >= '0' && *s <= '9')
			s++;
		if (*s)
			parity = *s++;
		if (*s)
			bits   = *s++ - '0';
		if (*s)
			doflow = (*s++ == 'r');
	}
	
	/* Sane default */
	if (baud == 0)
		baud = 9600;

	switch (bits) {
	case 7:
		cflag |= CS7;
		break;
	default:
	case 8:
		cflag |= CS8;
		break;
	}
	switch (parity) {
	case 'o': case 'O':
		cflag |= PARODD;
		break;
	case 'e': case 'E':
		cflag |= PARENB;
		break;
	}
	co->cflag = cflag;

	/*
	 * no need to check the index here: if the index is wrong, console
	 * code won't call us
	 */
	port = usb_serial_port_get_by_minor(co->index);
	if (port == NULL) {
		/* no device is connected yet, sorry :( */
		pr_err(""No USB device connected to ttyUSB%i\n"", co->index);
		return -ENODEV;
	}
	serial = port->serial;

	retval = usb_autopm_get_interface(serial->interface);
	if (retval)
		goto error_get_interface;

	tty_port_tty_set(&port->port, NULL);

	info->port = port;

	++port->port.count;
	if (!tty_port_initialized(&port->port)) {
		if (serial->type->set_termios) {
			/*
			 * allocate a fake tty so the driver can initialize
			 * the termios structure, then later call set_termios to
			 * configure according to command line arguments
			 */
			tty = kzalloc(sizeof(*tty), GFP_KERNEL);
			if (!tty) {
				retval = -ENOMEM;
				goto reset_open_count;
			}
			kref_init(&tty->kref);
			tty->driver = usb_serial_tty_driver;
			tty->index = co->index;
			init_ldsem(&tty->ldisc_sem);
			spin_lock_init(&tty->files_lock);
			INIT_LIST_HEAD(&tty->tty_files);
			kref_get(&tty->driver->kref);
			__module_get(tty->driver->owner);
			tty->ops = &usb_console_fake_tty_ops;
			tty_init_termios(tty);
			tty_port_tty_set(&port->port, tty);
		}

		/* only call the device specific open if this
		 * is the first time the port is opened */
		retval = serial->type->open(NULL, port);
		if (retval) {
			dev_err(&port->dev, ""could not open USB console port\n"");
			goto fail;
		}

		if (serial->type->set_termios) {
			tty->termios.c_cflag = cflag;
			tty_termios_encode_baud_rate(&tty->termios, baud, baud);
			memset(&dummy, 0, sizeof(struct ktermios));
			serial->type->set_termios(tty, port, &dummy);

			tty_port_tty_set(&port->port, NULL);
			tty_kref_put(tty);
		}
		tty_port_set_initialized(&port->port, 1);
	}
	/* Now that any required fake tty operations are completed restore
	 * the tty port count */
	--port->port.count;
	/* The console is special in terms of closing the device so
	 * indicate this port is now acting as a system console. */
	port->port.console = 1;

	mutex_unlock(&serial->disc_mutex);
	return retval;

 fail:
	tty_port_tty_set(&port->port, NULL);
 	tty_kref_put(tty);
  reset_open_count:
 	port->port.count = 0;
//fix_flaw_line_below:
//	info->port = NULL;
 	usb_autopm_put_interface(serial->interface);
  error_get_interface:
 	usb_serial_put(serial);
	mutex_unlock(&serial->disc_mutex);
	return retval;
}
",180859,"static int usb_console_setup(struct console *co, char *options)
{
	struct usbcons_info *info = &usbcons_info;
	int baud = 9600;
	int bits = 8;
	int parity = 'n';
	int doflow = 0;
	int cflag = CREAD | HUPCL | CLOCAL;
	char *s;
	struct usb_serial *serial;
	struct usb_serial_port *port;
	int retval;
	struct tty_struct *tty = NULL;
	struct ktermios dummy;

	if (options) {
		baud = simple_strtoul(options, NULL, 10);
		s = options;
		while (*s >= '0' && *s <= '9')
			s++;
		if (*s)
			parity = *s++;
		if (*s)
			bits   = *s++ - '0';
		if (*s)
			doflow = (*s++ == 'r');
	}
	
	/* Sane default */
	if (baud == 0)
		baud = 9600;

	switch (bits) {
	case 7:
		cflag |= CS7;
		break;
	default:
	case 8:
		cflag |= CS8;
		break;
	}
	switch (parity) {
	case 'o': case 'O':
		cflag |= PARODD;
		break;
	case 'e': case 'E':
		cflag |= PARENB;
		break;
	}
	co->cflag = cflag;

	/*
	 * no need to check the index here: if the index is wrong, console
	 * code won't call us
	 */
	port = usb_serial_port_get_by_minor(co->index);
	if (port == NULL) {
		/* no device is connected yet, sorry :( */
		pr_err(""No USB device connected to ttyUSB%i\n"", co->index);
		return -ENODEV;
	}
	serial = port->serial;

	retval = usb_autopm_get_interface(serial->interface);
	if (retval)
		goto error_get_interface;

	tty_port_tty_set(&port->port, NULL);

	info->port = port;

	++port->port.count;
	if (!tty_port_initialized(&port->port)) {
		if (serial->type->set_termios) {
			/*
			 * allocate a fake tty so the driver can initialize
			 * the termios structure, then later call set_termios to
			 * configure according to command line arguments
			 */
			tty = kzalloc(sizeof(*tty), GFP_KERNEL);
			if (!tty) {
				retval = -ENOMEM;
				goto reset_open_count;
			}
			kref_init(&tty->kref);
			tty->driver = usb_serial_tty_driver;
			tty->index = co->index;
			init_ldsem(&tty->ldisc_sem);
			spin_lock_init(&tty->files_lock);
			INIT_LIST_HEAD(&tty->tty_files);
			kref_get(&tty->driver->kref);
			__module_get(tty->driver->owner);
			tty->ops = &usb_console_fake_tty_ops;
			tty_init_termios(tty);
			tty_port_tty_set(&port->port, tty);
		}

		/* only call the device specific open if this
		 * is the first time the port is opened */
		retval = serial->type->open(NULL, port);
		if (retval) {
			dev_err(&port->dev, ""could not open USB console port\n"");
			goto fail;
		}

		if (serial->type->set_termios) {
			tty->termios.c_cflag = cflag;
			tty_termios_encode_baud_rate(&tty->termios, baud, baud);
			memset(&dummy, 0, sizeof(struct ktermios));
			serial->type->set_termios(tty, port, &dummy);

			tty_port_tty_set(&port->port, NULL);
			tty_kref_put(tty);
		}
		tty_port_set_initialized(&port->port, 1);
	}
	/* Now that any required fake tty operations are completed restore
	 * the tty port count */
	--port->port.count;
	/* The console is special in terms of closing the device so
	 * indicate this port is now acting as a system console. */
	port->port.console = 1;

	mutex_unlock(&serial->disc_mutex);
	return retval;

 fail:
	tty_port_tty_set(&port->port, NULL);
 	tty_kref_put(tty);
  reset_open_count:
 	port->port.count = 0;
 	usb_autopm_put_interface(serial->interface);
  error_get_interface:
 	usb_serial_put(serial);
	mutex_unlock(&serial->disc_mutex);
	return retval;
}
","static int usb_console_setup(struct console *co, char *options)
{
	struct usbcons_info *info = &usbcons_info;
	int baud = 9600;
	int bits = 8;
	int parity = 'n';
	int doflow = 0;
	int cflag = CREAD | HUPCL | CLOCAL;
	char *s;
	struct usb_serial *serial;
	struct usb_serial_port *port;
	int retval;
	struct tty_struct *tty = NULL;
	struct ktermios dummy;

	if (options) {
		baud = simple_strtoul(options, NULL, 10);
		s = options;
		while (*s >= '0' && *s <= '9')
			s++;
		if (*s)
			parity = *s++;
		if (*s)
			bits   = *s++ - '0';
		if (*s)
			doflow = (*s++ == 'r');
	}
	
	/* Sane default */
	if (baud == 0)
		baud = 9600;

	switch (bits) {
	case 7:
		cflag |= CS7;
		break;
	default:
	case 8:
		cflag |= CS8;
		break;
	}
	switch (parity) {
	case 'o': case 'O':
		cflag |= PARODD;
		break;
	case 'e': case 'E':
		cflag |= PARENB;
		break;
	}
	co->cflag = cflag;

	/*
	 * no need to check the index here: if the index is wrong, console
	 * code won't call us
	 */
	port = usb_serial_port_get_by_minor(co->index);
	if (port == NULL) {
		/* no device is connected yet, sorry :( */
		pr_err(""No USB device connected to ttyUSB%i\n"", co->index);
		return -ENODEV;
	}
	serial = port->serial;

	retval = usb_autopm_get_interface(serial->interface);
	if (retval)
		goto error_get_interface;

	tty_port_tty_set(&port->port, NULL);

	info->port = port;

	++port->port.count;
	if (!tty_port_initialized(&port->port)) {
		if (serial->type->set_termios) {
			/*
			 * allocate a fake tty so the driver can initialize
			 * the termios structure, then later call set_termios to
			 * configure according to command line arguments
			 */
			tty = kzalloc(sizeof(*tty), GFP_KERNEL);
			if (!tty) {
				retval = -ENOMEM;
				goto reset_open_count;
			}
			kref_init(&tty->kref);
			tty->driver = usb_serial_tty_driver;
			tty->index = co->index;
			init_ldsem(&tty->ldisc_sem);
			spin_lock_init(&tty->files_lock);
			INIT_LIST_HEAD(&tty->tty_files);
			kref_get(&tty->driver->kref);
			__module_get(tty->driver->owner);
			tty->ops = &usb_console_fake_tty_ops;
			tty_init_termios(tty);
			tty_port_tty_set(&port->port, tty);
		}

		/* only call the device specific open if this
		 * is the first time the port is opened */
		retval = serial->type->open(NULL, port);
		if (retval) {
			dev_err(&port->dev, ""could not open USB console port\n"");
			goto fail;
		}

		if (serial->type->set_termios) {
			tty->termios.c_cflag = cflag;
			tty_termios_encode_baud_rate(&tty->termios, baud, baud);
			memset(&dummy, 0, sizeof(struct ktermios));
			serial->type->set_termios(tty, port, &dummy);

			tty_port_tty_set(&port->port, NULL);
			tty_kref_put(tty);
		}
		tty_port_set_initialized(&port->port, 1);
	}
	/* Now that any required fake tty operations are completed restore
	 * the tty port count */
	--port->port.count;
	/* The console is special in terms of closing the device so
	 * indicate this port is now acting as a system console. */
	port->port.console = 1;

	mutex_unlock(&serial->disc_mutex);
	return retval;

 fail:
	tty_port_tty_set(&port->port, NULL);
 	tty_kref_put(tty);
  reset_open_count:
 	port->port.count = 0;
	info->port = NULL;
 	usb_autopm_put_interface(serial->interface);
  error_get_interface:
 	usb_serial_put(serial);
	mutex_unlock(&serial->disc_mutex);
	return retval;
}
","The vulnerability in the original code lies in the handling of the `tty` pointer, which could lead to a use-after-free condition if the allocation fails or if the `serial->type->open` function fails. Specifically, if `tty` is allocated but not properly released in the failure paths, it could result in dereferencing a freed pointer. In the fixed code, the line `info->port = NULL;` was added in the `reset_open_count` section to ensure that the `info->port` is cleared if an error occurs, preventing any potential misuse of the `tty` pointer and ensuring proper resource management. This change enhances the stability and security of the code.","The vulnerability in the original code arises from inadequate handling of resource management, particularly concerning memory allocation and pointer dereferencing. If the allocation fails or if subsequent operations encounter errors, the code does not properly reset or clear certain pointers, leading to potential use-after-free issues. This could result in dereferencing invalid memory, causing crashes or security vulnerabilities. The fixed code addresses this by ensuring that pointers are explicitly cleared in error handling paths, thereby preventing misuse of freed resources and enhancing overall stability and security in resource management."
21,180900,180900,,Local,Not required,Complete,CVE-2017-15265,https://www.cvedetails.com/cve/CVE-2017-15265/,CWE-416,Medium,Complete,Complete,,2017-10-16,6.9,"Race condition in the ALSA subsystem in the Linux kernel before 4.13.8 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted /dev/snd/seq ioctl calls, related to sound/core/seq/seq_clientmgr.c and sound/core/seq/seq_ports.c.",2019-04-23,DoS ,5,https://github.com/torvalds/linux/commit/71105998845fb012937332fe2e806d443c09e026,71105998845fb012937332fe2e806d443c09e026,"ALSA: seq: Fix use-after-free at creating a port

There is a potential race window opened at creating and deleting a
port via ioctl, as spotted by fuzzing.  snd_seq_create_port() creates
a port object and returns its pointer, but it doesn't take the
refcount, thus it can be deleted immediately by another thread.
Meanwhile, snd_seq_ioctl_create_port() still calls the function
snd_seq_system_client_ev_port_start() with the created port object
that is being deleted, and this triggers use-after-free like:

 BUG: KASAN: use-after-free in snd_seq_ioctl_create_port+0x504/0x630 [snd_seq] at addr ffff8801f2241cb1
 =============================================================================
 BUG kmalloc-512 (Tainted: G    B          ): kasan: bad access detected
 -----------------------------------------------------------------------------
 INFO: Allocated in snd_seq_create_port+0x94/0x9b0 [snd_seq] age=1 cpu=3 pid=4511
 	___slab_alloc+0x425/0x460
 	__slab_alloc+0x20/0x40
  	kmem_cache_alloc_trace+0x150/0x190
	snd_seq_create_port+0x94/0x9b0 [snd_seq]
	snd_seq_ioctl_create_port+0xd1/0x630 [snd_seq]
 	snd_seq_do_ioctl+0x11c/0x190 [snd_seq]
 	snd_seq_ioctl+0x40/0x80 [snd_seq]
 	do_vfs_ioctl+0x54b/0xda0
 	SyS_ioctl+0x79/0x90
 	entry_SYSCALL_64_fastpath+0x16/0x75
 INFO: Freed in port_delete+0x136/0x1a0 [snd_seq] age=1 cpu=2 pid=4717
 	__slab_free+0x204/0x310
 	kfree+0x15f/0x180
 	port_delete+0x136/0x1a0 [snd_seq]
 	snd_seq_delete_port+0x235/0x350 [snd_seq]
 	snd_seq_ioctl_delete_port+0xc8/0x180 [snd_seq]
 	snd_seq_do_ioctl+0x11c/0x190 [snd_seq]
 	snd_seq_ioctl+0x40/0x80 [snd_seq]
 	do_vfs_ioctl+0x54b/0xda0
 	SyS_ioctl+0x79/0x90
 	entry_SYSCALL_64_fastpath+0x16/0x75
 Call Trace:
  [<ffffffff81b03781>] dump_stack+0x63/0x82
  [<ffffffff81531b3b>] print_trailer+0xfb/0x160
  [<ffffffff81536db4>] object_err+0x34/0x40
  [<ffffffff815392d3>] kasan_report.part.2+0x223/0x520
  [<ffffffffa07aadf4>] ? snd_seq_ioctl_create_port+0x504/0x630 [snd_seq]
  [<ffffffff815395fe>] __asan_report_load1_noabort+0x2e/0x30
  [<ffffffffa07aadf4>] snd_seq_ioctl_create_port+0x504/0x630 [snd_seq]
  [<ffffffffa07aa8f0>] ? snd_seq_ioctl_delete_port+0x180/0x180 [snd_seq]
  [<ffffffff8136be50>] ? taskstats_exit+0xbc0/0xbc0
  [<ffffffffa07abc5c>] snd_seq_do_ioctl+0x11c/0x190 [snd_seq]
  [<ffffffffa07abd10>] snd_seq_ioctl+0x40/0x80 [snd_seq]
  [<ffffffff8136d433>] ? acct_account_cputime+0x63/0x80
  [<ffffffff815b515b>] do_vfs_ioctl+0x54b/0xda0
  .....

We may fix this in a few different ways, and in this patch, it's fixed
simply by taking the refcount properly at snd_seq_create_port() and
letting the caller unref the object after use.  Also, there is another
potential use-after-free by sprintf() call in snd_seq_create_port(),
and this is moved inside the lock.

This fix covers CVE-2017-15265.

Reported-and-tested-by: Michael23 Yu <ycqzsy@gmail.com>
Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>",1,sound/core/seq/seq_clientmgr.c,"{""sha"": ""6c9cba2166d95b3b9175cc9eb39ca14e3a14f0f5"", ""filename"": ""sound/core/seq/seq_clientmgr.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/71105998845fb012937332fe2e806d443c09e026/sound/core/seq/seq_clientmgr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/71105998845fb012937332fe2e806d443c09e026/sound/core/seq/seq_clientmgr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/sound/core/seq/seq_clientmgr.c?ref=71105998845fb012937332fe2e806d443c09e026"", ""patch"": ""@@ -1259,6 +1259,7 @@ static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n \tstruct snd_seq_port_info *info = arg;\n \tstruct snd_seq_client_port *port;\n \tstruct snd_seq_port_callback *callback;\n+\tint port_idx;\n \n \t/* it is not allowed to create the port for an another client */\n \tif (info->addr.client != client->number)\n@@ -1269,7 +1270,9 @@ static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n \t\treturn -ENOMEM;\n \n \tif (client->type == USER_CLIENT && info->kernel) {\n-\t\tsnd_seq_delete_port(client, port->addr.port);\n+\t\tport_idx = port->addr.port;\n+\t\tsnd_seq_port_unlock(port);\n+\t\tsnd_seq_delete_port(client, port_idx);\n \t\treturn -EINVAL;\n \t}\n \tif (client->type == KERNEL_CLIENT) {\n@@ -1290,6 +1293,7 @@ static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n \n \tsnd_seq_set_port_info(port, info);\n \tsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\n+\tsnd_seq_port_unlock(port);\n \n \treturn 0;\n }""}<_**next**_>{""sha"": ""d21ece9f8d7365e5e621156f1e44b85aa11eb1a1"", ""filename"": ""sound/core/seq/seq_ports.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/71105998845fb012937332fe2e806d443c09e026/sound/core/seq/seq_ports.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/71105998845fb012937332fe2e806d443c09e026/sound/core/seq/seq_ports.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/sound/core/seq/seq_ports.c?ref=71105998845fb012937332fe2e806d443c09e026"", ""patch"": ""@@ -122,7 +122,9 @@ static void port_subs_info_init(struct snd_seq_port_subs_info *grp)\n }\n \n \n-/* create a port, port number is returned (-1 on failure) */\n+/* create a port, port number is returned (-1 on failure);\n+ * the caller needs to unref the port via snd_seq_port_unlock() appropriately\n+ */\n struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n \t\t\t\t\t\tint port)\n {\n@@ -151,6 +153,7 @@ struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n \tsnd_use_lock_init(&new_port->use_lock);\n \tport_subs_info_init(&new_port->c_src);\n \tport_subs_info_init(&new_port->c_dest);\n+\tsnd_use_lock_use(&new_port->use_lock);\n \n \tnum = port >= 0 ? port : 0;\n \tmutex_lock(&client->ports_mutex);\n@@ -165,9 +168,9 @@ struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n \tlist_add_tail(&new_port->list, &p->list);\n \tclient->num_ports++;\n \tnew_port->addr.port = num;\t/* store the port number in the port */\n+\tsprintf(new_port->name, \""port-%d\"", num);\n \twrite_unlock_irqrestore(&client->ports_lock, flags);\n \tmutex_unlock(&client->ports_mutex);\n-\tsprintf(new_port->name, \""port-%d\"", num);\n \n \treturn new_port;\n }""}","static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)
{
 	struct snd_seq_port_info *info = arg;
 	struct snd_seq_client_port *port;
 	struct snd_seq_port_callback *callback;
	int port_idx;
 
 	/* it is not allowed to create the port for an another client */
 	if (info->addr.client != client->number)
		return -EPERM;

	port = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);
	if (port == NULL)
 		return -ENOMEM;
 
 	if (client->type == USER_CLIENT && info->kernel) {
		port_idx = port->addr.port;
		snd_seq_port_unlock(port);
		snd_seq_delete_port(client, port_idx);
 		return -EINVAL;
 	}
 	if (client->type == KERNEL_CLIENT) {
		if ((callback = info->kernel) != NULL) {
			if (callback->owner)
				port->owner = callback->owner;
			port->private_data = callback->private_data;
			port->private_free = callback->private_free;
			port->event_input = callback->event_input;
			port->c_src.open = callback->subscribe;
			port->c_src.close = callback->unsubscribe;
			port->c_dest.open = callback->use;
			port->c_dest.close = callback->unuse;
		}
	}

	info->addr = port->addr;
 
 	snd_seq_set_port_info(port, info);
 	snd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);
	snd_seq_port_unlock(port);
 
 	return 0;
 }
","static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)
{
 	struct snd_seq_port_info *info = arg;
 	struct snd_seq_client_port *port;
 	struct snd_seq_port_callback *callback;
 
 	/* it is not allowed to create the port for an another client */
 	if (info->addr.client != client->number)
		return -EPERM;

	port = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);
	if (port == NULL)
 		return -ENOMEM;
 
 	if (client->type == USER_CLIENT && info->kernel) {
		snd_seq_delete_port(client, port->addr.port);
 		return -EINVAL;
 	}
 	if (client->type == KERNEL_CLIENT) {
		if ((callback = info->kernel) != NULL) {
			if (callback->owner)
				port->owner = callback->owner;
			port->private_data = callback->private_data;
			port->private_free = callback->private_free;
			port->event_input = callback->event_input;
			port->c_src.open = callback->subscribe;
			port->c_src.close = callback->unsubscribe;
			port->c_dest.open = callback->use;
			port->c_dest.close = callback->unuse;
		}
	}

	info->addr = port->addr;
 
 	snd_seq_set_port_info(port, info);
 	snd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);
 
 	return 0;
 }
",C,"	int port_idx;
		port_idx = port->addr.port;
		snd_seq_port_unlock(port);
		snd_seq_delete_port(client, port_idx);
	snd_seq_port_unlock(port);
","		snd_seq_delete_port(client, port->addr.port);
",,"@@ -1259,6 +1259,7 @@ static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)
 	struct snd_seq_port_info *info = arg;
 	struct snd_seq_client_port *port;
 	struct snd_seq_port_callback *callback;
+	int port_idx;
 
 	/* it is not allowed to create the port for an another client */
 	if (info->addr.client != client->number)
@@ -1269,7 +1270,9 @@ static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)
 		return -ENOMEM;
 
 	if (client->type == USER_CLIENT && info->kernel) {
-		snd_seq_delete_port(client, port->addr.port);
+		port_idx = port->addr.port;
+		snd_seq_port_unlock(port);
+		snd_seq_delete_port(client, port_idx);
 		return -EINVAL;
 	}
 	if (client->type == KERNEL_CLIENT) {
@@ -1290,6 +1293,7 @@ static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)
 
 	snd_seq_set_port_info(port, info);
 	snd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);
+	snd_seq_port_unlock(port);
 
 	return 0;
 }",linux,71105998845fb012937332fe2e806d443c09e026,124751d5e63c823092060074bd0abaae61aaa9c4,1,"static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)
{
 	struct snd_seq_port_info *info = arg;
 	struct snd_seq_client_port *port;
 	struct snd_seq_port_callback *callback;
//fix_flaw_line_below:
//	int port_idx;
 
 	/* it is not allowed to create the port for an another client */
 	if (info->addr.client != client->number)
		return -EPERM;

	port = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);
	if (port == NULL)
 		return -ENOMEM;
 
 	if (client->type == USER_CLIENT && info->kernel) {
//flaw_line_below:
		snd_seq_delete_port(client, port->addr.port);
//fix_flaw_line_below:
//		port_idx = port->addr.port;
//fix_flaw_line_below:
//		snd_seq_port_unlock(port);
//fix_flaw_line_below:
//		snd_seq_delete_port(client, port_idx);
 		return -EINVAL;
 	}
 	if (client->type == KERNEL_CLIENT) {
		if ((callback = info->kernel) != NULL) {
			if (callback->owner)
				port->owner = callback->owner;
			port->private_data = callback->private_data;
			port->private_free = callback->private_free;
			port->event_input = callback->event_input;
			port->c_src.open = callback->subscribe;
			port->c_src.close = callback->unsubscribe;
			port->c_dest.open = callback->use;
			port->c_dest.close = callback->unuse;
		}
	}

	info->addr = port->addr;
 
 	snd_seq_set_port_info(port, info);
 	snd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);
//fix_flaw_line_below:
//	snd_seq_port_unlock(port);
 
 	return 0;
 }
",180900,"static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)
{
 	struct snd_seq_port_info *info = arg;
 	struct snd_seq_client_port *port;
 	struct snd_seq_port_callback *callback;
 
 	/* it is not allowed to create the port for an another client */
 	if (info->addr.client != client->number)
		return -EPERM;

	port = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);
	if (port == NULL)
 		return -ENOMEM;
 
 	if (client->type == USER_CLIENT && info->kernel) {
		snd_seq_delete_port(client, port->addr.port);
 		return -EINVAL;
 	}
 	if (client->type == KERNEL_CLIENT) {
		if ((callback = info->kernel) != NULL) {
			if (callback->owner)
				port->owner = callback->owner;
			port->private_data = callback->private_data;
			port->private_free = callback->private_free;
			port->event_input = callback->event_input;
			port->c_src.open = callback->subscribe;
			port->c_src.close = callback->unsubscribe;
			port->c_dest.open = callback->use;
			port->c_dest.close = callback->unuse;
		}
	}

	info->addr = port->addr;
 
 	snd_seq_set_port_info(port, info);
 	snd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);
 
 	return 0;
 }
","static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)
{
 	struct snd_seq_port_info *info = arg;
 	struct snd_seq_client_port *port;
 	struct snd_seq_port_callback *callback;
	int port_idx;
 
 	/* it is not allowed to create the port for an another client */
 	if (info->addr.client != client->number)
		return -EPERM;

	port = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);
	if (port == NULL)
 		return -ENOMEM;
 
 	if (client->type == USER_CLIENT && info->kernel) {
		port_idx = port->addr.port;
		snd_seq_port_unlock(port);
		snd_seq_delete_port(client, port_idx);
 		return -EINVAL;
 	}
 	if (client->type == KERNEL_CLIENT) {
		if ((callback = info->kernel) != NULL) {
			if (callback->owner)
				port->owner = callback->owner;
			port->private_data = callback->private_data;
			port->private_free = callback->private_free;
			port->event_input = callback->event_input;
			port->c_src.open = callback->subscribe;
			port->c_src.close = callback->unsubscribe;
			port->c_dest.open = callback->use;
			port->c_dest.close = callback->unuse;
		}
	}

	info->addr = port->addr;
 
 	snd_seq_set_port_info(port, info);
 	snd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);
	snd_seq_port_unlock(port);
 
 	return 0;
 }
","The vulnerability in the original code arises from the potential for a race condition when a user client attempts to create a port while holding a reference to it. Specifically, if `info->kernel` is true for a user client, the port is deleted without first unlocking it, which could lead to undefined behavior or memory corruption. In the fixed code, the addition of `port_idx = port->addr.port;` and `snd_seq_port_unlock(port);` before calling `snd_seq_delete_port(client, port_idx);` ensures that the port is properly unlocked before deletion, mitigating the risk of race conditions and ensuring safe memory management.","The vulnerability in the original code stems from a race condition that occurs when a user client attempts to create a port while holding a reference to it. If certain conditions are met, the code deletes the port without properly unlocking it first, which can lead to undefined behavior or memory corruption. The fixed code addresses this issue by ensuring that the port is unlocked before it is deleted. This change prevents potential conflicts and ensures that memory management is handled safely, thereby eliminating the risk of race conditions and enhancing the overall stability of the system."
22,180901,180901,,Local,Not required,Complete,CVE-2017-15265,https://www.cvedetails.com/cve/CVE-2017-15265/,CWE-416,Medium,Complete,Complete,,2017-10-16,6.9,"Race condition in the ALSA subsystem in the Linux kernel before 4.13.8 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted /dev/snd/seq ioctl calls, related to sound/core/seq/seq_clientmgr.c and sound/core/seq/seq_ports.c.",2019-04-23,DoS ,2,https://github.com/torvalds/linux/commit/71105998845fb012937332fe2e806d443c09e026,71105998845fb012937332fe2e806d443c09e026,"ALSA: seq: Fix use-after-free at creating a port

There is a potential race window opened at creating and deleting a
port via ioctl, as spotted by fuzzing.  snd_seq_create_port() creates
a port object and returns its pointer, but it doesn't take the
refcount, thus it can be deleted immediately by another thread.
Meanwhile, snd_seq_ioctl_create_port() still calls the function
snd_seq_system_client_ev_port_start() with the created port object
that is being deleted, and this triggers use-after-free like:

 BUG: KASAN: use-after-free in snd_seq_ioctl_create_port+0x504/0x630 [snd_seq] at addr ffff8801f2241cb1
 =============================================================================
 BUG kmalloc-512 (Tainted: G    B          ): kasan: bad access detected
 -----------------------------------------------------------------------------
 INFO: Allocated in snd_seq_create_port+0x94/0x9b0 [snd_seq] age=1 cpu=3 pid=4511
 	___slab_alloc+0x425/0x460
 	__slab_alloc+0x20/0x40
  	kmem_cache_alloc_trace+0x150/0x190
	snd_seq_create_port+0x94/0x9b0 [snd_seq]
	snd_seq_ioctl_create_port+0xd1/0x630 [snd_seq]
 	snd_seq_do_ioctl+0x11c/0x190 [snd_seq]
 	snd_seq_ioctl+0x40/0x80 [snd_seq]
 	do_vfs_ioctl+0x54b/0xda0
 	SyS_ioctl+0x79/0x90
 	entry_SYSCALL_64_fastpath+0x16/0x75
 INFO: Freed in port_delete+0x136/0x1a0 [snd_seq] age=1 cpu=2 pid=4717
 	__slab_free+0x204/0x310
 	kfree+0x15f/0x180
 	port_delete+0x136/0x1a0 [snd_seq]
 	snd_seq_delete_port+0x235/0x350 [snd_seq]
 	snd_seq_ioctl_delete_port+0xc8/0x180 [snd_seq]
 	snd_seq_do_ioctl+0x11c/0x190 [snd_seq]
 	snd_seq_ioctl+0x40/0x80 [snd_seq]
 	do_vfs_ioctl+0x54b/0xda0
 	SyS_ioctl+0x79/0x90
 	entry_SYSCALL_64_fastpath+0x16/0x75
 Call Trace:
  [<ffffffff81b03781>] dump_stack+0x63/0x82
  [<ffffffff81531b3b>] print_trailer+0xfb/0x160
  [<ffffffff81536db4>] object_err+0x34/0x40
  [<ffffffff815392d3>] kasan_report.part.2+0x223/0x520
  [<ffffffffa07aadf4>] ? snd_seq_ioctl_create_port+0x504/0x630 [snd_seq]
  [<ffffffff815395fe>] __asan_report_load1_noabort+0x2e/0x30
  [<ffffffffa07aadf4>] snd_seq_ioctl_create_port+0x504/0x630 [snd_seq]
  [<ffffffffa07aa8f0>] ? snd_seq_ioctl_delete_port+0x180/0x180 [snd_seq]
  [<ffffffff8136be50>] ? taskstats_exit+0xbc0/0xbc0
  [<ffffffffa07abc5c>] snd_seq_do_ioctl+0x11c/0x190 [snd_seq]
  [<ffffffffa07abd10>] snd_seq_ioctl+0x40/0x80 [snd_seq]
  [<ffffffff8136d433>] ? acct_account_cputime+0x63/0x80
  [<ffffffff815b515b>] do_vfs_ioctl+0x54b/0xda0
  .....

We may fix this in a few different ways, and in this patch, it's fixed
simply by taking the refcount properly at snd_seq_create_port() and
letting the caller unref the object after use.  Also, there is another
potential use-after-free by sprintf() call in snd_seq_create_port(),
and this is moved inside the lock.

This fix covers CVE-2017-15265.

Reported-and-tested-by: Michael23 Yu <ycqzsy@gmail.com>
Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>",1,sound/core/seq/seq_ports.c,"{""sha"": ""6c9cba2166d95b3b9175cc9eb39ca14e3a14f0f5"", ""filename"": ""sound/core/seq/seq_clientmgr.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/71105998845fb012937332fe2e806d443c09e026/sound/core/seq/seq_clientmgr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/71105998845fb012937332fe2e806d443c09e026/sound/core/seq/seq_clientmgr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/sound/core/seq/seq_clientmgr.c?ref=71105998845fb012937332fe2e806d443c09e026"", ""patch"": ""@@ -1259,6 +1259,7 @@ static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n \tstruct snd_seq_port_info *info = arg;\n \tstruct snd_seq_client_port *port;\n \tstruct snd_seq_port_callback *callback;\n+\tint port_idx;\n \n \t/* it is not allowed to create the port for an another client */\n \tif (info->addr.client != client->number)\n@@ -1269,7 +1270,9 @@ static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n \t\treturn -ENOMEM;\n \n \tif (client->type == USER_CLIENT && info->kernel) {\n-\t\tsnd_seq_delete_port(client, port->addr.port);\n+\t\tport_idx = port->addr.port;\n+\t\tsnd_seq_port_unlock(port);\n+\t\tsnd_seq_delete_port(client, port_idx);\n \t\treturn -EINVAL;\n \t}\n \tif (client->type == KERNEL_CLIENT) {\n@@ -1290,6 +1293,7 @@ static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n \n \tsnd_seq_set_port_info(port, info);\n \tsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\n+\tsnd_seq_port_unlock(port);\n \n \treturn 0;\n }""}<_**next**_>{""sha"": ""d21ece9f8d7365e5e621156f1e44b85aa11eb1a1"", ""filename"": ""sound/core/seq/seq_ports.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/71105998845fb012937332fe2e806d443c09e026/sound/core/seq/seq_ports.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/71105998845fb012937332fe2e806d443c09e026/sound/core/seq/seq_ports.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/sound/core/seq/seq_ports.c?ref=71105998845fb012937332fe2e806d443c09e026"", ""patch"": ""@@ -122,7 +122,9 @@ static void port_subs_info_init(struct snd_seq_port_subs_info *grp)\n }\n \n \n-/* create a port, port number is returned (-1 on failure) */\n+/* create a port, port number is returned (-1 on failure);\n+ * the caller needs to unref the port via snd_seq_port_unlock() appropriately\n+ */\n struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n \t\t\t\t\t\tint port)\n {\n@@ -151,6 +153,7 @@ struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n \tsnd_use_lock_init(&new_port->use_lock);\n \tport_subs_info_init(&new_port->c_src);\n \tport_subs_info_init(&new_port->c_dest);\n+\tsnd_use_lock_use(&new_port->use_lock);\n \n \tnum = port >= 0 ? port : 0;\n \tmutex_lock(&client->ports_mutex);\n@@ -165,9 +168,9 @@ struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n \tlist_add_tail(&new_port->list, &p->list);\n \tclient->num_ports++;\n \tnew_port->addr.port = num;\t/* store the port number in the port */\n+\tsprintf(new_port->name, \""port-%d\"", num);\n \twrite_unlock_irqrestore(&client->ports_lock, flags);\n \tmutex_unlock(&client->ports_mutex);\n-\tsprintf(new_port->name, \""port-%d\"", num);\n \n \treturn new_port;\n }""}"," struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 						int port)
 {
	unsigned long flags;
	struct snd_seq_client_port *new_port, *p;
	int num = -1;
	
	/* sanity check */
	if (snd_BUG_ON(!client))
		return NULL;

	if (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {
		pr_warn(""ALSA: seq: too many ports for client %d\n"", client->number);
		return NULL;
	}

	/* create a new port */
	new_port = kzalloc(sizeof(*new_port), GFP_KERNEL);
	if (!new_port)
		return NULL;	/* failure, out of memory */
	/* init port data */
	new_port->addr.client = client->number;
	new_port->addr.port = -1;
	new_port->owner = THIS_MODULE;
	sprintf(new_port->name, ""port-%d"", num);
 	snd_use_lock_init(&new_port->use_lock);
 	port_subs_info_init(&new_port->c_src);
 	port_subs_info_init(&new_port->c_dest);
	snd_use_lock_use(&new_port->use_lock);
 
 	num = port >= 0 ? port : 0;
 	mutex_lock(&client->ports_mutex);
	write_lock_irqsave(&client->ports_lock, flags);
	list_for_each_entry(p, &client->ports_list_head, list) {
		if (p->addr.port > num)
			break;
		if (port < 0) /* auto-probe mode */
			num = p->addr.port + 1;
	}
	/* insert the new port */
 	list_add_tail(&new_port->list, &p->list);
 	client->num_ports++;
 	new_port->addr.port = num;	/* store the port number in the port */
	sprintf(new_port->name, ""port-%d"", num);
 	write_unlock_irqrestore(&client->ports_lock, flags);
 	mutex_unlock(&client->ports_mutex);
 
 	return new_port;
 }
"," struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 						int port)
 {
	unsigned long flags;
	struct snd_seq_client_port *new_port, *p;
	int num = -1;
	
	/* sanity check */
	if (snd_BUG_ON(!client))
		return NULL;

	if (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {
		pr_warn(""ALSA: seq: too many ports for client %d\n"", client->number);
		return NULL;
	}

	/* create a new port */
	new_port = kzalloc(sizeof(*new_port), GFP_KERNEL);
	if (!new_port)
		return NULL;	/* failure, out of memory */
	/* init port data */
	new_port->addr.client = client->number;
	new_port->addr.port = -1;
	new_port->owner = THIS_MODULE;
	sprintf(new_port->name, ""port-%d"", num);
 	snd_use_lock_init(&new_port->use_lock);
 	port_subs_info_init(&new_port->c_src);
 	port_subs_info_init(&new_port->c_dest);
 
 	num = port >= 0 ? port : 0;
 	mutex_lock(&client->ports_mutex);
	write_lock_irqsave(&client->ports_lock, flags);
	list_for_each_entry(p, &client->ports_list_head, list) {
		if (p->addr.port > num)
			break;
		if (port < 0) /* auto-probe mode */
			num = p->addr.port + 1;
	}
	/* insert the new port */
 	list_add_tail(&new_port->list, &p->list);
 	client->num_ports++;
 	new_port->addr.port = num;	/* store the port number in the port */
 	write_unlock_irqrestore(&client->ports_lock, flags);
 	mutex_unlock(&client->ports_mutex);
	sprintf(new_port->name, ""port-%d"", num);
 
 	return new_port;
 }
",C,"	snd_use_lock_use(&new_port->use_lock);
	sprintf(new_port->name, ""port-%d"", num);
","	sprintf(new_port->name, ""port-%d"", num);
",,"@@ -122,7 +122,9 @@ static void port_subs_info_init(struct snd_seq_port_subs_info *grp)
 }
 
 
-/* create a port, port number is returned (-1 on failure) */
+/* create a port, port number is returned (-1 on failure);
+ * the caller needs to unref the port via snd_seq_port_unlock() appropriately
+ */
 struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 						int port)
 {
@@ -151,6 +153,7 @@ struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 	snd_use_lock_init(&new_port->use_lock);
 	port_subs_info_init(&new_port->c_src);
 	port_subs_info_init(&new_port->c_dest);
+	snd_use_lock_use(&new_port->use_lock);
 
 	num = port >= 0 ? port : 0;
 	mutex_lock(&client->ports_mutex);
@@ -165,9 +168,9 @@ struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 	list_add_tail(&new_port->list, &p->list);
 	client->num_ports++;
 	new_port->addr.port = num;	/* store the port number in the port */
+	sprintf(new_port->name, ""port-%d"", num);
 	write_unlock_irqrestore(&client->ports_lock, flags);
 	mutex_unlock(&client->ports_mutex);
-	sprintf(new_port->name, ""port-%d"", num);
 
 	return new_port;
 }",linux,71105998845fb012937332fe2e806d443c09e026,124751d5e63c823092060074bd0abaae61aaa9c4,1," struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 						int port)
 {
	unsigned long flags;
	struct snd_seq_client_port *new_port, *p;
	int num = -1;
	
	/* sanity check */
	if (snd_BUG_ON(!client))
		return NULL;

	if (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {
		pr_warn(""ALSA: seq: too many ports for client %d\n"", client->number);
		return NULL;
	}

	/* create a new port */
	new_port = kzalloc(sizeof(*new_port), GFP_KERNEL);
	if (!new_port)
		return NULL;	/* failure, out of memory */
	/* init port data */
	new_port->addr.client = client->number;
	new_port->addr.port = -1;
	new_port->owner = THIS_MODULE;
	sprintf(new_port->name, ""port-%d"", num);
 	snd_use_lock_init(&new_port->use_lock);
 	port_subs_info_init(&new_port->c_src);
 	port_subs_info_init(&new_port->c_dest);
//fix_flaw_line_below:
//	snd_use_lock_use(&new_port->use_lock);
 
 	num = port >= 0 ? port : 0;
 	mutex_lock(&client->ports_mutex);
	write_lock_irqsave(&client->ports_lock, flags);
	list_for_each_entry(p, &client->ports_list_head, list) {
		if (p->addr.port > num)
			break;
		if (port < 0) /* auto-probe mode */
			num = p->addr.port + 1;
	}
	/* insert the new port */
 	list_add_tail(&new_port->list, &p->list);
 	client->num_ports++;
 	new_port->addr.port = num;	/* store the port number in the port */
//fix_flaw_line_below:
//	sprintf(new_port->name, ""port-%d"", num);
 	write_unlock_irqrestore(&client->ports_lock, flags);
 	mutex_unlock(&client->ports_mutex);
//flaw_line_below:
	sprintf(new_port->name, ""port-%d"", num);
 
 	return new_port;
 }
",180901," struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 						int port)
 {
	unsigned long flags;
	struct snd_seq_client_port *new_port, *p;
	int num = -1;
	
	/* sanity check */
	if (snd_BUG_ON(!client))
		return NULL;

	if (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {
		pr_warn(""ALSA: seq: too many ports for client %d\n"", client->number);
		return NULL;
	}

	/* create a new port */
	new_port = kzalloc(sizeof(*new_port), GFP_KERNEL);
	if (!new_port)
		return NULL;	/* failure, out of memory */
	/* init port data */
	new_port->addr.client = client->number;
	new_port->addr.port = -1;
	new_port->owner = THIS_MODULE;
	sprintf(new_port->name, ""port-%d"", num);
 	snd_use_lock_init(&new_port->use_lock);
 	port_subs_info_init(&new_port->c_src);
 	port_subs_info_init(&new_port->c_dest);
 
 	num = port >= 0 ? port : 0;
 	mutex_lock(&client->ports_mutex);
	write_lock_irqsave(&client->ports_lock, flags);
	list_for_each_entry(p, &client->ports_list_head, list) {
		if (p->addr.port > num)
			break;
		if (port < 0) /* auto-probe mode */
			num = p->addr.port + 1;
	}
	/* insert the new port */
 	list_add_tail(&new_port->list, &p->list);
 	client->num_ports++;
 	new_port->addr.port = num;	/* store the port number in the port */
 	write_unlock_irqrestore(&client->ports_lock, flags);
 	mutex_unlock(&client->ports_mutex);
	sprintf(new_port->name, ""port-%d"", num);
 
 	return new_port;
 }
"," struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 						int port)
 {
	unsigned long flags;
	struct snd_seq_client_port *new_port, *p;
	int num = -1;
	
	/* sanity check */
	if (snd_BUG_ON(!client))
		return NULL;

	if (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {
		pr_warn(""ALSA: seq: too many ports for client %d\n"", client->number);
		return NULL;
	}

	/* create a new port */
	new_port = kzalloc(sizeof(*new_port), GFP_KERNEL);
	if (!new_port)
		return NULL;	/* failure, out of memory */
	/* init port data */
	new_port->addr.client = client->number;
	new_port->addr.port = -1;
	new_port->owner = THIS_MODULE;
	sprintf(new_port->name, ""port-%d"", num);
 	snd_use_lock_init(&new_port->use_lock);
 	port_subs_info_init(&new_port->c_src);
 	port_subs_info_init(&new_port->c_dest);
	snd_use_lock_use(&new_port->use_lock);
 
 	num = port >= 0 ? port : 0;
 	mutex_lock(&client->ports_mutex);
	write_lock_irqsave(&client->ports_lock, flags);
	list_for_each_entry(p, &client->ports_list_head, list) {
		if (p->addr.port > num)
			break;
		if (port < 0) /* auto-probe mode */
			num = p->addr.port + 1;
	}
	/* insert the new port */
 	list_add_tail(&new_port->list, &p->list);
 	client->num_ports++;
 	new_port->addr.port = num;	/* store the port number in the port */
	sprintf(new_port->name, ""port-%d"", num);
 	write_unlock_irqrestore(&client->ports_lock, flags);
 	mutex_unlock(&client->ports_mutex);
 
 	return new_port;
 }
","The vulnerability in the original code lies in the lack of proper locking mechanisms when accessing the `new_port` structure, particularly before it is fully initialized and added to the `client->ports_list_head`. This could lead to race conditions, where multiple threads might attempt to access or modify `new_port` simultaneously, potentially causing data corruption or crashes. The fix introduces `snd_use_lock_use(&new_port->use_lock)` to ensure that the `use_lock` is properly initialized and used, providing a safeguard against concurrent access issues, thus enhancing the thread safety of the port creation process.","The vulnerability in the original code stems from inadequate synchronization when accessing shared resources, which can lead to race conditions. Specifically, the code allows multiple threads to interact with an uninitialized structure, risking data corruption or crashes if concurrent modifications occur. The fix addresses this issue by introducing a locking mechanism that ensures proper initialization and access control over the shared resource. This enhancement effectively prevents simultaneous access by multiple threads, thereby improving the overall thread safety and stability of the port creation process in the system."
23,180908,180908,,Local,Not required,Complete,CVE-2017-15115,https://www.cvedetails.com/cve/CVE-2017-15115/,CWE-416,Low,Complete,Complete,,2017-11-15,7.2,"The sctp_do_peeloff function in net/sctp/socket.c in the Linux kernel before 4.14 does not check whether the intended netns is used in a peel-off action, which allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via crafted system calls.",2019-05-08,DoS ,4,https://github.com/torvalds/linux/commit/df80cd9b28b9ebaa284a41df611dbf3a2d05ca74,df80cd9b28b9ebaa284a41df611dbf3a2d05ca74,"sctp: do not peel off an assoc from one netns to another one

Now when peeling off an association to the sock in another netns, all
transports in this assoc are not to be rehashed and keep use the old
key in hashtable.

As a transport uses sk->net as the hash key to insert into hashtable,
it would miss removing these transports from hashtable due to the new
netns when closing the sock and all transports are being freeed, then
later an use-after-free issue could be caused when looking up an asoc
and dereferencing those transports.

This is a very old issue since very beginning, ChunYu found it with
syzkaller fuzz testing with this series:

  socket$inet6_sctp()
  bind$inet6()
  sendto$inet6()
  unshare(0x40000000)
  getsockopt$inet_sctp6_SCTP_GET_ASSOC_ID_LIST()
  getsockopt$inet_sctp6_SCTP_SOCKOPT_PEELOFF()

This patch is to block this call when peeling one assoc off from one
netns to another one, so that the netns of all transport would not
go out-sync with the key in hashtable.

Note that this patch didn't fix it by rehashing transports, as it's
difficult to handle the situation when the tuple is already in use
in the new netns. Besides, no one would like to peel off one assoc
to another netns, considering ipaddrs, ifaces, etc. are usually
different.

Reported-by: ChunYu Wang <chunwang@redhat.com>
Signed-off-by: Xin Long <lucien.xin@gmail.com>
Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Acked-by: Neil Horman <nhorman@tuxdriver.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/sctp/socket.c,"{""sha"": ""17841ab30798ecb2d7269296dcda3c62d434d622"", ""filename"": ""net/sctp/socket.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/df80cd9b28b9ebaa284a41df611dbf3a2d05ca74/net/sctp/socket.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/df80cd9b28b9ebaa284a41df611dbf3a2d05ca74/net/sctp/socket.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/sctp/socket.c?ref=df80cd9b28b9ebaa284a41df611dbf3a2d05ca74"", ""patch"": ""@@ -4906,6 +4906,10 @@ int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n \tstruct socket *sock;\n \tint err = 0;\n \n+\t/* Do not peel off from one netns to another one. */\n+\tif (!net_eq(current->nsproxy->net_ns, sock_net(sk)))\n+\t\treturn -EINVAL;\n+\n \tif (!asoc)\n \t\treturn -EINVAL;\n ""}","int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
 	struct socket *sock;
 	int err = 0;
 
	/* Do not peel off from one netns to another one. */
	if (!net_eq(current->nsproxy->net_ns, sock_net(sk)))
		return -EINVAL;

 	if (!asoc)
 		return -EINVAL;
 
	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;

	/* An association cannot be branched off from an already peeled-off
	 * socket, nor is this supported for tcp style sockets.
	 */
	if (!sctp_style(sk, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sk, sk, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
}
","int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
 	struct socket *sock;
 	int err = 0;
 
 	if (!asoc)
 		return -EINVAL;
 
	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;

	/* An association cannot be branched off from an already peeled-off
	 * socket, nor is this supported for tcp style sockets.
	 */
	if (!sctp_style(sk, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sk, sk, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
}
",C,"	/* Do not peel off from one netns to another one. */
	if (!net_eq(current->nsproxy->net_ns, sock_net(sk)))
		return -EINVAL;

",,,"@@ -4906,6 +4906,10 @@ int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
 	struct socket *sock;
 	int err = 0;
 
+	/* Do not peel off from one netns to another one. */
+	if (!net_eq(current->nsproxy->net_ns, sock_net(sk)))
+		return -EINVAL;
+
 	if (!asoc)
 		return -EINVAL;
 ",linux,df80cd9b28b9ebaa284a41df611dbf3a2d05ca74,4bbb5083484016d4448739237aa1e6a9577ebb43,1,"int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
 	struct socket *sock;
 	int err = 0;
 
//fix_flaw_line_below:
//	/* Do not peel off from one netns to another one. */
//fix_flaw_line_below:
//	if (!net_eq(current->nsproxy->net_ns, sock_net(sk)))
//fix_flaw_line_below:
//		return -EINVAL;
//fix_flaw_line_below:
//
 	if (!asoc)
 		return -EINVAL;
 
	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;

	/* An association cannot be branched off from an already peeled-off
	 * socket, nor is this supported for tcp style sockets.
	 */
	if (!sctp_style(sk, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sk, sk, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
}
",180908,"int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
 	struct socket *sock;
 	int err = 0;
 
 	if (!asoc)
 		return -EINVAL;
 
	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;

	/* An association cannot be branched off from an already peeled-off
	 * socket, nor is this supported for tcp style sockets.
	 */
	if (!sctp_style(sk, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sk, sk, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
}
","int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
 	struct socket *sock;
 	int err = 0;
 
	/* Do not peel off from one netns to another one. */
	if (!net_eq(current->nsproxy->net_ns, sock_net(sk)))
		return -EINVAL;

 	if (!asoc)
 		return -EINVAL;
 
	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;

	/* An association cannot be branched off from an already peeled-off
	 * socket, nor is this supported for tcp style sockets.
	 */
	if (!sctp_style(sk, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sk, sk, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
}
","The vulnerability in the original code lies in the lack of a check to ensure that the socket being peeled off is within the same network namespace. This oversight could allow a socket to be peeled off across different network namespaces, potentially leading to security issues such as unauthorized access to socket resources. The fixed code addresses this vulnerability by introducing a new condition that checks if the current network namespace (`current->nsproxy->net_ns`) is equal to the network namespace of the socket (`sock_net(sk)`). If they are not equal, the function returns `-EINVAL`, preventing the operation.","The vulnerability in the original code stems from the absence of a check to ensure that the socket being peeled off belongs to the same network namespace, which could allow unauthorized access to socket resources across different namespaces. This oversight could lead to security risks, such as data leakage or manipulation between isolated network environments. The fixed code rectifies this issue by adding a condition that verifies the network namespace of the current process against that of the socket. If they do not match, the operation is aborted, thereby enhancing security and maintaining proper isolation between network namespaces."
24,181134,181134,,Remote,Not required,Partial,CVE-2017-12877,https://www.cvedetails.com/cve/CVE-2017-12877/,CWE-416,Medium,,,,2017-08-28,4.3,Use-after-free vulnerability in the DestroyImage function in image.c in ImageMagick before 7.0.6-6 allows remote attackers to cause a denial of service via a crafted file.,2018-06-13,DoS ,2,https://github.com/ImageMagick/ImageMagick/commit/04178de2247e353fc095846784b9a10fefdbf890,04178de2247e353fc095846784b9a10fefdbf890,https://github.com/ImageMagick/ImageMagick/issues/662,2,coders/mat.c,"{""sha"": ""fc8da2b144d7c8b08e25b6b110c0db52f0eaeb3a"", ""filename"": ""coders/mat.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/04178de2247e353fc095846784b9a10fefdbf890/coders/mat.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/04178de2247e353fc095846784b9a10fefdbf890/coders/mat.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/mat.c?ref=04178de2247e353fc095846784b9a10fefdbf890"", ""patch"": ""@@ -1330,8 +1330,6 @@ RestoreMSCWarning\n   if (quantum_info != (QuantumInfo *) NULL)\n     quantum_info=DestroyQuantumInfo(quantum_info);\n END_OF_READING:\n-  if (clone_info)\n-    clone_info=DestroyImageInfo(clone_info);\n   CloseBlob(image);\n \n \n@@ -1349,6 +1347,8 @@ RestoreMSCWarning\n         Image *tmp=p;\n         if ((p->rows == 0) || (p->columns == 0)) {\n           p=p->previous;\n+          if (tmp == image2)\n+            image2=(Image *) NULL;\n           DeleteImageFromList(&tmp);\n         } else {\n           image=p;""}","static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  register Quantum *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  /*
     Open image file.
   */
  image = AcquireImage(image_info,exception);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  quantum_info=(QuantumInfo *) NULL;
  clone_info=(ImageInfo *) NULL;
  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
    {
MATLAB_KO:
      if ((image != image2) && (image2 != (Image *) NULL))
        image2=DestroyImage(image2);
      if (clone_info != (ImageInfo *) NULL)
        clone_info=DestroyImageInfo(clone_info);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf(""pos=%X\n"",TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))
      goto MATLAB_KO;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    clone_info=CloneImageInfo(image_info);
    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if (MATLAB_HDR.DataType!=miMATRIX)
      {
        clone_info=DestroyImageInfo(clone_info);
        continue;  /* skip another objects. */
      }

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           (void) ReadBlobXXXLong(image2);
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
            ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default:
        if (clone_info != (ImageInfo *) NULL)
          clone_info=DestroyImageInfo(clone_info);
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

    NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        if (clone_info)
          clone_info=DestroyImageInfo(clone_info);
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
      goto MATLAB_KO;
    /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        image->type=GrayscaleType;
        SetImageColorspace(image,GRAYColorspace,exception);
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      {
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        return(DestroyImageList(image));
      }
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");

  /* ----- Load raster data ----- */
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
    if (BImgBuff == NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (Quantum *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(image,q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,
            exception);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,
            exception);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image,exception);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }
    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
          }
        }
        }

    if (quantum_info != (QuantumInfo *) NULL)
      quantum_info=DestroyQuantumInfo(quantum_info);
    if (clone_info)
      clone_info=DestroyImageInfo(clone_info);
  }

  RelinquishMagickMemory(BImgBuff);
   if (quantum_info != (QuantumInfo *) NULL)
     quantum_info=DestroyQuantumInfo(quantum_info);
 END_OF_READING:
   CloseBlob(image);
 
 
  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
         Image *tmp=p;
         if ((p->rows == 0) || (p->columns == 0)) {
           p=p->previous;
          if (tmp == image2)
            image2=(Image *) NULL;
           DeleteImageFromList(&tmp);
         } else {
           image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if (image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"")
  else
    if ((image != image2) && (image2 != (Image *) NULL))
      image2=DestroyImage(image2);
  return (image);
}
","static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  register Quantum *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  /*
     Open image file.
   */
  image = AcquireImage(image_info,exception);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  quantum_info=(QuantumInfo *) NULL;
  clone_info=(ImageInfo *) NULL;
  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
    {
MATLAB_KO:
      if ((image != image2) && (image2 != (Image *) NULL))
        image2=DestroyImage(image2);
      if (clone_info != (ImageInfo *) NULL)
        clone_info=DestroyImageInfo(clone_info);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf(""pos=%X\n"",TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))
      goto MATLAB_KO;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    clone_info=CloneImageInfo(image_info);
    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if (MATLAB_HDR.DataType!=miMATRIX)
      {
        clone_info=DestroyImageInfo(clone_info);
        continue;  /* skip another objects. */
      }

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           (void) ReadBlobXXXLong(image2);
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
            ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default:
        if (clone_info != (ImageInfo *) NULL)
          clone_info=DestroyImageInfo(clone_info);
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

    NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        if (clone_info)
          clone_info=DestroyImageInfo(clone_info);
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
      goto MATLAB_KO;
    /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        image->type=GrayscaleType;
        SetImageColorspace(image,GRAYColorspace,exception);
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      {
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        return(DestroyImageList(image));
      }
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");

  /* ----- Load raster data ----- */
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
    if (BImgBuff == NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (Quantum *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(image,q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,
            exception);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,
            exception);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image,exception);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }
    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
          }
        }
        }

    if (quantum_info != (QuantumInfo *) NULL)
      quantum_info=DestroyQuantumInfo(quantum_info);
    if (clone_info)
      clone_info=DestroyImageInfo(clone_info);
  }

  RelinquishMagickMemory(BImgBuff);
   if (quantum_info != (QuantumInfo *) NULL)
     quantum_info=DestroyQuantumInfo(quantum_info);
 END_OF_READING:
  if (clone_info)
    clone_info=DestroyImageInfo(clone_info);
   CloseBlob(image);
 
 
  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
         Image *tmp=p;
         if ((p->rows == 0) || (p->columns == 0)) {
           p=p->previous;
           DeleteImageFromList(&tmp);
         } else {
           image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if (image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"")
  else
    if ((image != image2) && (image2 != (Image *) NULL))
      image2=DestroyImage(image2);
  return (image);
}
",C,"          if (tmp == image2)
            image2=(Image *) NULL;
","  if (clone_info)
    clone_info=DestroyImageInfo(clone_info);
",,"@@ -1330,8 +1330,6 @@ RestoreMSCWarning
   if (quantum_info != (QuantumInfo *) NULL)
     quantum_info=DestroyQuantumInfo(quantum_info);
 END_OF_READING:
-  if (clone_info)
-    clone_info=DestroyImageInfo(clone_info);
   CloseBlob(image);
 
 
@@ -1349,6 +1347,8 @@ RestoreMSCWarning
         Image *tmp=p;
         if ((p->rows == 0) || (p->columns == 0)) {
           p=p->previous;
+          if (tmp == image2)
+            image2=(Image *) NULL;
           DeleteImageFromList(&tmp);
         } else {
           image=p;",ImageMagick,04178de2247e353fc095846784b9a10fefdbf890,44c66e1521d7e3f88e64f070395e0b4de8a3964c,1,"static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  register Quantum *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  /*
     Open image file.
   */
  image = AcquireImage(image_info,exception);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  quantum_info=(QuantumInfo *) NULL;
  clone_info=(ImageInfo *) NULL;
  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
    {
MATLAB_KO:
      if ((image != image2) && (image2 != (Image *) NULL))
        image2=DestroyImage(image2);
      if (clone_info != (ImageInfo *) NULL)
        clone_info=DestroyImageInfo(clone_info);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf(""pos=%X\n"",TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))
      goto MATLAB_KO;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    clone_info=CloneImageInfo(image_info);
    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if (MATLAB_HDR.DataType!=miMATRIX)
      {
        clone_info=DestroyImageInfo(clone_info);
        continue;  /* skip another objects. */
      }

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           (void) ReadBlobXXXLong(image2);
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
            ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default:
        if (clone_info != (ImageInfo *) NULL)
          clone_info=DestroyImageInfo(clone_info);
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

    NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        if (clone_info)
          clone_info=DestroyImageInfo(clone_info);
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
      goto MATLAB_KO;
    /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        image->type=GrayscaleType;
        SetImageColorspace(image,GRAYColorspace,exception);
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      {
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        return(DestroyImageList(image));
      }
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");

  /* ----- Load raster data ----- */
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
    if (BImgBuff == NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (Quantum *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(image,q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,
            exception);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,
            exception);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image,exception);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }
    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
          }
        }
        }

    if (quantum_info != (QuantumInfo *) NULL)
      quantum_info=DestroyQuantumInfo(quantum_info);
    if (clone_info)
      clone_info=DestroyImageInfo(clone_info);
  }

  RelinquishMagickMemory(BImgBuff);
   if (quantum_info != (QuantumInfo *) NULL)
     quantum_info=DestroyQuantumInfo(quantum_info);
 END_OF_READING:
//flaw_line_below:
  if (clone_info)
//flaw_line_below:
    clone_info=DestroyImageInfo(clone_info);
   CloseBlob(image);
 
 
  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
         Image *tmp=p;
         if ((p->rows == 0) || (p->columns == 0)) {
           p=p->previous;
//fix_flaw_line_below:
//          if (tmp == image2)
//fix_flaw_line_below:
//            image2=(Image *) NULL;
           DeleteImageFromList(&tmp);
         } else {
           image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if (image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"")
  else
    if ((image != image2) && (image2 != (Image *) NULL))
      image2=DestroyImage(image2);
  return (image);
}
",181134,"static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  register Quantum *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  /*
     Open image file.
   */
  image = AcquireImage(image_info,exception);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  quantum_info=(QuantumInfo *) NULL;
  clone_info=(ImageInfo *) NULL;
  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
    {
MATLAB_KO:
      if ((image != image2) && (image2 != (Image *) NULL))
        image2=DestroyImage(image2);
      if (clone_info != (ImageInfo *) NULL)
        clone_info=DestroyImageInfo(clone_info);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf(""pos=%X\n"",TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))
      goto MATLAB_KO;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    clone_info=CloneImageInfo(image_info);
    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if (MATLAB_HDR.DataType!=miMATRIX)
      {
        clone_info=DestroyImageInfo(clone_info);
        continue;  /* skip another objects. */
      }

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           (void) ReadBlobXXXLong(image2);
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
            ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default:
        if (clone_info != (ImageInfo *) NULL)
          clone_info=DestroyImageInfo(clone_info);
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

    NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        if (clone_info)
          clone_info=DestroyImageInfo(clone_info);
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
      goto MATLAB_KO;
    /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        image->type=GrayscaleType;
        SetImageColorspace(image,GRAYColorspace,exception);
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      {
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        return(DestroyImageList(image));
      }
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");

  /* ----- Load raster data ----- */
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
    if (BImgBuff == NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (Quantum *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(image,q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,
            exception);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,
            exception);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image,exception);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }
    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
          }
        }
        }

    if (quantum_info != (QuantumInfo *) NULL)
      quantum_info=DestroyQuantumInfo(quantum_info);
    if (clone_info)
      clone_info=DestroyImageInfo(clone_info);
  }

  RelinquishMagickMemory(BImgBuff);
   if (quantum_info != (QuantumInfo *) NULL)
     quantum_info=DestroyQuantumInfo(quantum_info);
 END_OF_READING:
  if (clone_info)
    clone_info=DestroyImageInfo(clone_info);
   CloseBlob(image);
 
 
  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
         Image *tmp=p;
         if ((p->rows == 0) || (p->columns == 0)) {
           p=p->previous;
           DeleteImageFromList(&tmp);
         } else {
           image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if (image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"")
  else
    if ((image != image2) && (image2 != (Image *) NULL))
      image2=DestroyImage(image2);
  return (image);
}
","static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  register Quantum *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  /*
     Open image file.
   */
  image = AcquireImage(image_info,exception);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  quantum_info=(QuantumInfo *) NULL;
  clone_info=(ImageInfo *) NULL;
  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
    {
MATLAB_KO:
      if ((image != image2) && (image2 != (Image *) NULL))
        image2=DestroyImage(image2);
      if (clone_info != (ImageInfo *) NULL)
        clone_info=DestroyImageInfo(clone_info);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf(""pos=%X\n"",TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))
      goto MATLAB_KO;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    clone_info=CloneImageInfo(image_info);
    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if (MATLAB_HDR.DataType!=miMATRIX)
      {
        clone_info=DestroyImageInfo(clone_info);
        continue;  /* skip another objects. */
      }

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           (void) ReadBlobXXXLong(image2);
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
            ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default:
        if (clone_info != (ImageInfo *) NULL)
          clone_info=DestroyImageInfo(clone_info);
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

    NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        if (clone_info)
          clone_info=DestroyImageInfo(clone_info);
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
      goto MATLAB_KO;
    /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        image->type=GrayscaleType;
        SetImageColorspace(image,GRAYColorspace,exception);
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      {
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        return(DestroyImageList(image));
      }
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");

  /* ----- Load raster data ----- */
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
    if (BImgBuff == NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (Quantum *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(image,q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,
            exception);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,
            exception);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image,exception);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }
    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
          }
        }
        }

    if (quantum_info != (QuantumInfo *) NULL)
      quantum_info=DestroyQuantumInfo(quantum_info);
    if (clone_info)
      clone_info=DestroyImageInfo(clone_info);
  }

  RelinquishMagickMemory(BImgBuff);
   if (quantum_info != (QuantumInfo *) NULL)
     quantum_info=DestroyQuantumInfo(quantum_info);
 END_OF_READING:
   CloseBlob(image);
 
 
  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
         Image *tmp=p;
         if ((p->rows == 0) || (p->columns == 0)) {
           p=p->previous;
          if (tmp == image2)
            image2=(Image *) NULL;
           DeleteImageFromList(&tmp);
         } else {
           image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if (image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"")
  else
    if ((image != image2) && (image2 != (Image *) NULL))
      image2=DestroyImage(image2);
  return (image);
}
","The vulnerability in the original code lies in the handling of the `image2` variable, which could lead to a use-after-free condition. Specifically, if `image2` is assigned a value and then later destroyed without proper checks, it may still be referenced elsewhere, causing undefined behavior. The code also fails to ensure that `image2` is set to `NULL` after deletion, which could lead to further erroneous access. In the fixed code, additional checks ensure that `image2` is set to `NULL` after it is deleted, preventing potential use-after-free issues and ensuring safer memory management throughout the function.","The vulnerability in the original code stems from improper handling of memory management, particularly regarding the deletion of temporary image references. If a temporary image is deleted without ensuring that all references to it are cleared, subsequent operations may attempt to access freed memory, leading to undefined behavior or crashes. The fixed code addresses this issue by implementing additional checks to ensure that any references to the deleted image are set to null, thereby preventing accidental access to invalid memory. This change enhances the overall stability and safety of the code by ensuring proper memory management practices."
25,181219,181219,,Local,Not required,Complete,CVE-2017-11176,https://www.cvedetails.com/cve/CVE-2017-11176/,CWE-416,Low,Complete,Complete,,2017-07-11,7.2,"The mq_notify function in the Linux kernel through 4.11.9 does not set the sock pointer to NULL upon entry into the retry logic. During a user-space close of a Netlink socket, it allows attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact.",2018-12-13,DoS ,3,https://github.com/torvalds/linux/commit/f991af3daabaecff34684fd51fac80319d1baad1,f991af3daabaecff34684fd51fac80319d1baad1,"mqueue: fix a use-after-free in sys_mq_notify()

The retry logic for netlink_attachskb() inside sys_mq_notify()
is nasty and vulnerable:

1) The sock refcnt is already released when retry is needed
2) The fd is controllable by user-space because we already
   release the file refcnt

so we when retry but the fd has been just closed by user-space
during this small window, we end up calling netlink_detachskb()
on the error path which releases the sock again, later when
the user-space closes this socket a use-after-free could be
triggered.

Setting 'sock' to NULL here should be sufficient to fix it.

Reported-by: GeneBlue <geneblue.mail@gmail.com>
Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Manfred Spraul <manfred@colorfullife.com>
Cc: stable@kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",1,ipc/mqueue.c,"{""sha"": ""eb1391b52c6f84fe75dec4e8366d858341ac665a"", ""filename"": ""ipc/mqueue.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/f991af3daabaecff34684fd51fac80319d1baad1/ipc/mqueue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f991af3daabaecff34684fd51fac80319d1baad1/ipc/mqueue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/ipc/mqueue.c?ref=f991af3daabaecff34684fd51fac80319d1baad1"", ""patch"": ""@@ -1270,8 +1270,10 @@ static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n \n \t\t\ttimeo = MAX_SCHEDULE_TIMEOUT;\n \t\t\tret = netlink_attachskb(sock, nc, &timeo, NULL);\n-\t\t\tif (ret == 1)\n+\t\t\tif (ret == 1) {\n+\t\t\t\tsock = NULL;\n \t\t\t\tgoto retry;\n+\t\t\t}\n \t\t\tif (ret) {\n \t\t\t\tsock = NULL;\n \t\t\t\tnc = NULL;""}","static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)
{
	int ret;
	struct fd f;
	struct sock *sock;
	struct inode *inode;
	struct mqueue_inode_info *info;
	struct sk_buff *nc;

	audit_mq_notify(mqdes, notification);

	nc = NULL;
	sock = NULL;
	if (notification != NULL) {
		if (unlikely(notification->sigev_notify != SIGEV_NONE &&
			     notification->sigev_notify != SIGEV_SIGNAL &&
			     notification->sigev_notify != SIGEV_THREAD))
			return -EINVAL;
		if (notification->sigev_notify == SIGEV_SIGNAL &&
			!valid_signal(notification->sigev_signo)) {
			return -EINVAL;
		}
		if (notification->sigev_notify == SIGEV_THREAD) {
			long timeo;

			/* create the notify skb */
			nc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);
			if (!nc) {
				ret = -ENOMEM;
				goto out;
			}
			if (copy_from_user(nc->data,
					notification->sigev_value.sival_ptr,
					NOTIFY_COOKIE_LEN)) {
				ret = -EFAULT;
				goto out;
			}

			/* TODO: add a header? */
			skb_put(nc, NOTIFY_COOKIE_LEN);
			/* and attach it to the socket */
retry:
			f = fdget(notification->sigev_signo);
			if (!f.file) {
				ret = -EBADF;
				goto out;
			}
			sock = netlink_getsockbyfilp(f.file);
			fdput(f);
			if (IS_ERR(sock)) {
				ret = PTR_ERR(sock);
				sock = NULL;
				goto out;
			}
 
 			timeo = MAX_SCHEDULE_TIMEOUT;
 			ret = netlink_attachskb(sock, nc, &timeo, NULL);
			if (ret == 1) {
				sock = NULL;
 				goto retry;
			}
 			if (ret) {
 				sock = NULL;
 				nc = NULL;
				goto out;
			}
		}
	}

	f = fdget(mqdes);
	if (!f.file) {
		ret = -EBADF;
		goto out;
	}

	inode = file_inode(f.file);
	if (unlikely(f.file->f_op != &mqueue_file_operations)) {
		ret = -EBADF;
		goto out_fput;
	}
	info = MQUEUE_I(inode);

	ret = 0;
	spin_lock(&info->lock);
	if (notification == NULL) {
		if (info->notify_owner == task_tgid(current)) {
			remove_notification(info);
			inode->i_atime = inode->i_ctime = current_time(inode);
		}
	} else if (info->notify_owner != NULL) {
		ret = -EBUSY;
	} else {
		switch (notification->sigev_notify) {
		case SIGEV_NONE:
			info->notify.sigev_notify = SIGEV_NONE;
			break;
		case SIGEV_THREAD:
			info->notify_sock = sock;
			info->notify_cookie = nc;
			sock = NULL;
			nc = NULL;
			info->notify.sigev_notify = SIGEV_THREAD;
			break;
		case SIGEV_SIGNAL:
			info->notify.sigev_signo = notification->sigev_signo;
			info->notify.sigev_value = notification->sigev_value;
			info->notify.sigev_notify = SIGEV_SIGNAL;
			break;
		}

		info->notify_owner = get_pid(task_tgid(current));
		info->notify_user_ns = get_user_ns(current_user_ns());
		inode->i_atime = inode->i_ctime = current_time(inode);
	}
	spin_unlock(&info->lock);
out_fput:
	fdput(f);
out:
	if (sock)
		netlink_detachskb(sock, nc);
	else if (nc)
		dev_kfree_skb(nc);

	return ret;
}
","static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)
{
	int ret;
	struct fd f;
	struct sock *sock;
	struct inode *inode;
	struct mqueue_inode_info *info;
	struct sk_buff *nc;

	audit_mq_notify(mqdes, notification);

	nc = NULL;
	sock = NULL;
	if (notification != NULL) {
		if (unlikely(notification->sigev_notify != SIGEV_NONE &&
			     notification->sigev_notify != SIGEV_SIGNAL &&
			     notification->sigev_notify != SIGEV_THREAD))
			return -EINVAL;
		if (notification->sigev_notify == SIGEV_SIGNAL &&
			!valid_signal(notification->sigev_signo)) {
			return -EINVAL;
		}
		if (notification->sigev_notify == SIGEV_THREAD) {
			long timeo;

			/* create the notify skb */
			nc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);
			if (!nc) {
				ret = -ENOMEM;
				goto out;
			}
			if (copy_from_user(nc->data,
					notification->sigev_value.sival_ptr,
					NOTIFY_COOKIE_LEN)) {
				ret = -EFAULT;
				goto out;
			}

			/* TODO: add a header? */
			skb_put(nc, NOTIFY_COOKIE_LEN);
			/* and attach it to the socket */
retry:
			f = fdget(notification->sigev_signo);
			if (!f.file) {
				ret = -EBADF;
				goto out;
			}
			sock = netlink_getsockbyfilp(f.file);
			fdput(f);
			if (IS_ERR(sock)) {
				ret = PTR_ERR(sock);
				sock = NULL;
				goto out;
			}
 
 			timeo = MAX_SCHEDULE_TIMEOUT;
 			ret = netlink_attachskb(sock, nc, &timeo, NULL);
			if (ret == 1)
 				goto retry;
 			if (ret) {
 				sock = NULL;
 				nc = NULL;
				goto out;
			}
		}
	}

	f = fdget(mqdes);
	if (!f.file) {
		ret = -EBADF;
		goto out;
	}

	inode = file_inode(f.file);
	if (unlikely(f.file->f_op != &mqueue_file_operations)) {
		ret = -EBADF;
		goto out_fput;
	}
	info = MQUEUE_I(inode);

	ret = 0;
	spin_lock(&info->lock);
	if (notification == NULL) {
		if (info->notify_owner == task_tgid(current)) {
			remove_notification(info);
			inode->i_atime = inode->i_ctime = current_time(inode);
		}
	} else if (info->notify_owner != NULL) {
		ret = -EBUSY;
	} else {
		switch (notification->sigev_notify) {
		case SIGEV_NONE:
			info->notify.sigev_notify = SIGEV_NONE;
			break;
		case SIGEV_THREAD:
			info->notify_sock = sock;
			info->notify_cookie = nc;
			sock = NULL;
			nc = NULL;
			info->notify.sigev_notify = SIGEV_THREAD;
			break;
		case SIGEV_SIGNAL:
			info->notify.sigev_signo = notification->sigev_signo;
			info->notify.sigev_value = notification->sigev_value;
			info->notify.sigev_notify = SIGEV_SIGNAL;
			break;
		}

		info->notify_owner = get_pid(task_tgid(current));
		info->notify_user_ns = get_user_ns(current_user_ns());
		inode->i_atime = inode->i_ctime = current_time(inode);
	}
	spin_unlock(&info->lock);
out_fput:
	fdput(f);
out:
	if (sock)
		netlink_detachskb(sock, nc);
	else if (nc)
		dev_kfree_skb(nc);

	return ret;
}
",C,"			if (ret == 1) {
				sock = NULL;
			}
","			if (ret == 1)
",,"@@ -1270,8 +1270,10 @@ static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)
 
 			timeo = MAX_SCHEDULE_TIMEOUT;
 			ret = netlink_attachskb(sock, nc, &timeo, NULL);
-			if (ret == 1)
+			if (ret == 1) {
+				sock = NULL;
 				goto retry;
+			}
 			if (ret) {
 				sock = NULL;
 				nc = NULL;",linux,f991af3daabaecff34684fd51fac80319d1baad1,2b976203417cf033079e0be30cae5f41d88e385e,1,"static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)
{
	int ret;
	struct fd f;
	struct sock *sock;
	struct inode *inode;
	struct mqueue_inode_info *info;
	struct sk_buff *nc;

	audit_mq_notify(mqdes, notification);

	nc = NULL;
	sock = NULL;
	if (notification != NULL) {
		if (unlikely(notification->sigev_notify != SIGEV_NONE &&
			     notification->sigev_notify != SIGEV_SIGNAL &&
			     notification->sigev_notify != SIGEV_THREAD))
			return -EINVAL;
		if (notification->sigev_notify == SIGEV_SIGNAL &&
			!valid_signal(notification->sigev_signo)) {
			return -EINVAL;
		}
		if (notification->sigev_notify == SIGEV_THREAD) {
			long timeo;

			/* create the notify skb */
			nc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);
			if (!nc) {
				ret = -ENOMEM;
				goto out;
			}
			if (copy_from_user(nc->data,
					notification->sigev_value.sival_ptr,
					NOTIFY_COOKIE_LEN)) {
				ret = -EFAULT;
				goto out;
			}

			/* TODO: add a header? */
			skb_put(nc, NOTIFY_COOKIE_LEN);
			/* and attach it to the socket */
retry:
			f = fdget(notification->sigev_signo);
			if (!f.file) {
				ret = -EBADF;
				goto out;
			}
			sock = netlink_getsockbyfilp(f.file);
			fdput(f);
			if (IS_ERR(sock)) {
				ret = PTR_ERR(sock);
				sock = NULL;
				goto out;
			}
 
 			timeo = MAX_SCHEDULE_TIMEOUT;
 			ret = netlink_attachskb(sock, nc, &timeo, NULL);
//flaw_line_below:
			if (ret == 1)
//fix_flaw_line_below:
//			if (ret == 1) {
//fix_flaw_line_below:
//				sock = NULL;
 				goto retry;
//fix_flaw_line_below:
//			}
 			if (ret) {
 				sock = NULL;
 				nc = NULL;
				goto out;
			}
		}
	}

	f = fdget(mqdes);
	if (!f.file) {
		ret = -EBADF;
		goto out;
	}

	inode = file_inode(f.file);
	if (unlikely(f.file->f_op != &mqueue_file_operations)) {
		ret = -EBADF;
		goto out_fput;
	}
	info = MQUEUE_I(inode);

	ret = 0;
	spin_lock(&info->lock);
	if (notification == NULL) {
		if (info->notify_owner == task_tgid(current)) {
			remove_notification(info);
			inode->i_atime = inode->i_ctime = current_time(inode);
		}
	} else if (info->notify_owner != NULL) {
		ret = -EBUSY;
	} else {
		switch (notification->sigev_notify) {
		case SIGEV_NONE:
			info->notify.sigev_notify = SIGEV_NONE;
			break;
		case SIGEV_THREAD:
			info->notify_sock = sock;
			info->notify_cookie = nc;
			sock = NULL;
			nc = NULL;
			info->notify.sigev_notify = SIGEV_THREAD;
			break;
		case SIGEV_SIGNAL:
			info->notify.sigev_signo = notification->sigev_signo;
			info->notify.sigev_value = notification->sigev_value;
			info->notify.sigev_notify = SIGEV_SIGNAL;
			break;
		}

		info->notify_owner = get_pid(task_tgid(current));
		info->notify_user_ns = get_user_ns(current_user_ns());
		inode->i_atime = inode->i_ctime = current_time(inode);
	}
	spin_unlock(&info->lock);
out_fput:
	fdput(f);
out:
	if (sock)
		netlink_detachskb(sock, nc);
	else if (nc)
		dev_kfree_skb(nc);

	return ret;
}
",181219,"static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)
{
	int ret;
	struct fd f;
	struct sock *sock;
	struct inode *inode;
	struct mqueue_inode_info *info;
	struct sk_buff *nc;

	audit_mq_notify(mqdes, notification);

	nc = NULL;
	sock = NULL;
	if (notification != NULL) {
		if (unlikely(notification->sigev_notify != SIGEV_NONE &&
			     notification->sigev_notify != SIGEV_SIGNAL &&
			     notification->sigev_notify != SIGEV_THREAD))
			return -EINVAL;
		if (notification->sigev_notify == SIGEV_SIGNAL &&
			!valid_signal(notification->sigev_signo)) {
			return -EINVAL;
		}
		if (notification->sigev_notify == SIGEV_THREAD) {
			long timeo;

			/* create the notify skb */
			nc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);
			if (!nc) {
				ret = -ENOMEM;
				goto out;
			}
			if (copy_from_user(nc->data,
					notification->sigev_value.sival_ptr,
					NOTIFY_COOKIE_LEN)) {
				ret = -EFAULT;
				goto out;
			}

			/* TODO: add a header? */
			skb_put(nc, NOTIFY_COOKIE_LEN);
			/* and attach it to the socket */
retry:
			f = fdget(notification->sigev_signo);
			if (!f.file) {
				ret = -EBADF;
				goto out;
			}
			sock = netlink_getsockbyfilp(f.file);
			fdput(f);
			if (IS_ERR(sock)) {
				ret = PTR_ERR(sock);
				sock = NULL;
				goto out;
			}
 
 			timeo = MAX_SCHEDULE_TIMEOUT;
 			ret = netlink_attachskb(sock, nc, &timeo, NULL);
			if (ret == 1)
 				goto retry;
 			if (ret) {
 				sock = NULL;
 				nc = NULL;
				goto out;
			}
		}
	}

	f = fdget(mqdes);
	if (!f.file) {
		ret = -EBADF;
		goto out;
	}

	inode = file_inode(f.file);
	if (unlikely(f.file->f_op != &mqueue_file_operations)) {
		ret = -EBADF;
		goto out_fput;
	}
	info = MQUEUE_I(inode);

	ret = 0;
	spin_lock(&info->lock);
	if (notification == NULL) {
		if (info->notify_owner == task_tgid(current)) {
			remove_notification(info);
			inode->i_atime = inode->i_ctime = current_time(inode);
		}
	} else if (info->notify_owner != NULL) {
		ret = -EBUSY;
	} else {
		switch (notification->sigev_notify) {
		case SIGEV_NONE:
			info->notify.sigev_notify = SIGEV_NONE;
			break;
		case SIGEV_THREAD:
			info->notify_sock = sock;
			info->notify_cookie = nc;
			sock = NULL;
			nc = NULL;
			info->notify.sigev_notify = SIGEV_THREAD;
			break;
		case SIGEV_SIGNAL:
			info->notify.sigev_signo = notification->sigev_signo;
			info->notify.sigev_value = notification->sigev_value;
			info->notify.sigev_notify = SIGEV_SIGNAL;
			break;
		}

		info->notify_owner = get_pid(task_tgid(current));
		info->notify_user_ns = get_user_ns(current_user_ns());
		inode->i_atime = inode->i_ctime = current_time(inode);
	}
	spin_unlock(&info->lock);
out_fput:
	fdput(f);
out:
	if (sock)
		netlink_detachskb(sock, nc);
	else if (nc)
		dev_kfree_skb(nc);

	return ret;
}
","static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)
{
	int ret;
	struct fd f;
	struct sock *sock;
	struct inode *inode;
	struct mqueue_inode_info *info;
	struct sk_buff *nc;

	audit_mq_notify(mqdes, notification);

	nc = NULL;
	sock = NULL;
	if (notification != NULL) {
		if (unlikely(notification->sigev_notify != SIGEV_NONE &&
			     notification->sigev_notify != SIGEV_SIGNAL &&
			     notification->sigev_notify != SIGEV_THREAD))
			return -EINVAL;
		if (notification->sigev_notify == SIGEV_SIGNAL &&
			!valid_signal(notification->sigev_signo)) {
			return -EINVAL;
		}
		if (notification->sigev_notify == SIGEV_THREAD) {
			long timeo;

			/* create the notify skb */
			nc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);
			if (!nc) {
				ret = -ENOMEM;
				goto out;
			}
			if (copy_from_user(nc->data,
					notification->sigev_value.sival_ptr,
					NOTIFY_COOKIE_LEN)) {
				ret = -EFAULT;
				goto out;
			}

			/* TODO: add a header? */
			skb_put(nc, NOTIFY_COOKIE_LEN);
			/* and attach it to the socket */
retry:
			f = fdget(notification->sigev_signo);
			if (!f.file) {
				ret = -EBADF;
				goto out;
			}
			sock = netlink_getsockbyfilp(f.file);
			fdput(f);
			if (IS_ERR(sock)) {
				ret = PTR_ERR(sock);
				sock = NULL;
				goto out;
			}
 
 			timeo = MAX_SCHEDULE_TIMEOUT;
 			ret = netlink_attachskb(sock, nc, &timeo, NULL);
			if (ret == 1) {
				sock = NULL;
 				goto retry;
			}
 			if (ret) {
 				sock = NULL;
 				nc = NULL;
				goto out;
			}
		}
	}

	f = fdget(mqdes);
	if (!f.file) {
		ret = -EBADF;
		goto out;
	}

	inode = file_inode(f.file);
	if (unlikely(f.file->f_op != &mqueue_file_operations)) {
		ret = -EBADF;
		goto out_fput;
	}
	info = MQUEUE_I(inode);

	ret = 0;
	spin_lock(&info->lock);
	if (notification == NULL) {
		if (info->notify_owner == task_tgid(current)) {
			remove_notification(info);
			inode->i_atime = inode->i_ctime = current_time(inode);
		}
	} else if (info->notify_owner != NULL) {
		ret = -EBUSY;
	} else {
		switch (notification->sigev_notify) {
		case SIGEV_NONE:
			info->notify.sigev_notify = SIGEV_NONE;
			break;
		case SIGEV_THREAD:
			info->notify_sock = sock;
			info->notify_cookie = nc;
			sock = NULL;
			nc = NULL;
			info->notify.sigev_notify = SIGEV_THREAD;
			break;
		case SIGEV_SIGNAL:
			info->notify.sigev_signo = notification->sigev_signo;
			info->notify.sigev_value = notification->sigev_value;
			info->notify.sigev_notify = SIGEV_SIGNAL;
			break;
		}

		info->notify_owner = get_pid(task_tgid(current));
		info->notify_user_ns = get_user_ns(current_user_ns());
		inode->i_atime = inode->i_ctime = current_time(inode);
	}
	spin_unlock(&info->lock);
out_fput:
	fdput(f);
out:
	if (sock)
		netlink_detachskb(sock, nc);
	else if (nc)
		dev_kfree_skb(nc);

	return ret;
}
","The vulnerability in the original code lies in the handling of the `notification` structure, particularly when `sigev_notify` is set to `SIGEV_THREAD`. If the `sigev_signo` is invalid, the code does not adequately prevent the use of an invalid socket, potentially leading to a use-after-free or memory corruption. The fix improves the error handling by ensuring that if `netlink_attachskb` returns `1`, the socket is set to `NULL` before retrying, preventing the reuse of an invalid socket. This change enhances the robustness of the code against potential exploitation through improper socket management.","The vulnerability in the original code arises from inadequate validation of user input, particularly in the handling of notifications. If the notification structure is improperly configured, it could lead to the use of invalid resources, resulting in potential memory corruption or crashes. The fix addresses this issue by enhancing error handling, ensuring that invalid resources are not reused and that proper cleanup occurs before retrying operations. This change significantly improves the code's resilience against exploitation by ensuring that all user inputs are validated and managed correctly, thereby preventing unintended behavior."
26,181266,181266,,Remote,Not required,Partial,CVE-2017-9527,https://www.cvedetails.com/cve/CVE-2017-9527/,CWE-416,Medium,Partial,Partial,,2017-06-11,6.8,The mark_context_stack function in gc.c in mruby through 1.2.0 allows attackers to cause a denial of service (heap-based use-after-free and application crash) or possibly have unspecified other impact via a crafted .rb file.,2017-06-22,DoS ,7,https://github.com/mruby/mruby/commit/5c114c91d4ff31859fcd84cf8bf349b737b90d99,5c114c91d4ff31859fcd84cf8bf349b737b90d99,Clear unused stack region that may refer freed objects; fix #3596,6,src/gc.c,"{""sha"": ""19bc1ad4b2bb5103803a6a813567031cab2cdc78"", ""filename"": ""src/gc.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 6, ""changes"": 13, ""blob_url"": ""https://github.com/mruby/mruby/blob/5c114c91d4ff31859fcd84cf8bf349b737b90d99/src/gc.c"", ""raw_url"": ""https://github.com/mruby/mruby/raw/5c114c91d4ff31859fcd84cf8bf349b737b90d99/src/gc.c"", ""contents_url"": ""https://api.github.com/repos/mruby/mruby/contents/src/gc.c?ref=5c114c91d4ff31859fcd84cf8bf349b737b90d99"", ""patch"": ""@@ -544,6 +544,7 @@ mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n {\n   size_t i;\n   size_t e;\n+  mrb_value nil;\n \n   if (c->stack == NULL) return;\n   e = c->stack - c->stbase;\n@@ -553,14 +554,14 @@ mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n     mrb_value v = c->stbase[i];\n \n     if (!mrb_immediate_p(v)) {\n-      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {\n-        c->stbase[i] = mrb_nil_value();\n-      }\n-      else {\n-        mrb_gc_mark(mrb, mrb_basic_ptr(v));\n-      }\n+      mrb_gc_mark(mrb, mrb_basic_ptr(v));\n     }\n   }\n+  e = c->stend - c->stbase;\n+  nil = mrb_nil_value();\n+  for (; i<e; i++) {\n+    c->stbase[i] = nil;\n+  }\n }\n \n static void""}","mark_context_stack(mrb_state *mrb, struct mrb_context *c)
 {
   size_t i;
   size_t e;
  mrb_value nil;
 
   if (c->stack == NULL) return;
   e = c->stack - c->stbase;
  if (c->ci) e += c->ci->nregs;
  if (c->stbase + e > c->stend) e = c->stend - c->stbase;
  for (i=0; i<e; i++) {
     mrb_value v = c->stbase[i];
 
     if (!mrb_immediate_p(v)) {
      mrb_gc_mark(mrb, mrb_basic_ptr(v));
     }
   }
  e = c->stend - c->stbase;
  nil = mrb_nil_value();
  for (; i<e; i++) {
    c->stbase[i] = nil;
  }
 }
","mark_context_stack(mrb_state *mrb, struct mrb_context *c)
 {
   size_t i;
   size_t e;
 
   if (c->stack == NULL) return;
   e = c->stack - c->stbase;
  if (c->ci) e += c->ci->nregs;
  if (c->stbase + e > c->stend) e = c->stend - c->stbase;
  for (i=0; i<e; i++) {
     mrb_value v = c->stbase[i];
 
     if (!mrb_immediate_p(v)) {
      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {
        c->stbase[i] = mrb_nil_value();
      }
      else {
        mrb_gc_mark(mrb, mrb_basic_ptr(v));
      }
     }
   }
 }
",C,"  mrb_value nil;
      mrb_gc_mark(mrb, mrb_basic_ptr(v));
  e = c->stend - c->stbase;
  nil = mrb_nil_value();
  for (; i<e; i++) {
    c->stbase[i] = nil;
  }
","      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {
        c->stbase[i] = mrb_nil_value();
      }
      else {
        mrb_gc_mark(mrb, mrb_basic_ptr(v));
      }
",,"@@ -544,6 +544,7 @@ mark_context_stack(mrb_state *mrb, struct mrb_context *c)
 {
   size_t i;
   size_t e;
+  mrb_value nil;
 
   if (c->stack == NULL) return;
   e = c->stack - c->stbase;
@@ -553,14 +554,14 @@ mark_context_stack(mrb_state *mrb, struct mrb_context *c)
     mrb_value v = c->stbase[i];
 
     if (!mrb_immediate_p(v)) {
-      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {
-        c->stbase[i] = mrb_nil_value();
-      }
-      else {
-        mrb_gc_mark(mrb, mrb_basic_ptr(v));
-      }
+      mrb_gc_mark(mrb, mrb_basic_ptr(v));
     }
   }
+  e = c->stend - c->stbase;
+  nil = mrb_nil_value();
+  for (; i<e; i++) {
+    c->stbase[i] = nil;
+  }
 }
 
 static void",mruby,5c114c91d4ff31859fcd84cf8bf349b737b90d99,491d68bb3004eb8d7deec4a3a682b25de0d4afc2,1,"mark_context_stack(mrb_state *mrb, struct mrb_context *c)
 {
   size_t i;
   size_t e;
//fix_flaw_line_below:
//  mrb_value nil;
 
   if (c->stack == NULL) return;
   e = c->stack - c->stbase;
  if (c->ci) e += c->ci->nregs;
  if (c->stbase + e > c->stend) e = c->stend - c->stbase;
  for (i=0; i<e; i++) {
     mrb_value v = c->stbase[i];
 
     if (!mrb_immediate_p(v)) {
//flaw_line_below:
      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {
//flaw_line_below:
        c->stbase[i] = mrb_nil_value();
//flaw_line_below:
      }
//flaw_line_below:
      else {
//flaw_line_below:
        mrb_gc_mark(mrb, mrb_basic_ptr(v));
//flaw_line_below:
      }
//fix_flaw_line_below:
//      mrb_gc_mark(mrb, mrb_basic_ptr(v));
     }
   }
//fix_flaw_line_below:
//  e = c->stend - c->stbase;
//fix_flaw_line_below:
//  nil = mrb_nil_value();
//fix_flaw_line_below:
//  for (; i<e; i++) {
//fix_flaw_line_below:
//    c->stbase[i] = nil;
//fix_flaw_line_below:
//  }
 }
",181266,"mark_context_stack(mrb_state *mrb, struct mrb_context *c)
 {
   size_t i;
   size_t e;
 
   if (c->stack == NULL) return;
   e = c->stack - c->stbase;
  if (c->ci) e += c->ci->nregs;
  if (c->stbase + e > c->stend) e = c->stend - c->stbase;
  for (i=0; i<e; i++) {
     mrb_value v = c->stbase[i];
 
     if (!mrb_immediate_p(v)) {
      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {
        c->stbase[i] = mrb_nil_value();
      }
      else {
        mrb_gc_mark(mrb, mrb_basic_ptr(v));
      }
     }
   }
 }
","mark_context_stack(mrb_state *mrb, struct mrb_context *c)
 {
   size_t i;
   size_t e;
  mrb_value nil;
 
   if (c->stack == NULL) return;
   e = c->stack - c->stbase;
  if (c->ci) e += c->ci->nregs;
  if (c->stbase + e > c->stend) e = c->stend - c->stbase;
  for (i=0; i<e; i++) {
     mrb_value v = c->stbase[i];
 
     if (!mrb_immediate_p(v)) {
      mrb_gc_mark(mrb, mrb_basic_ptr(v));
     }
   }
  e = c->stend - c->stbase;
  nil = mrb_nil_value();
  for (; i<e; i++) {
    c->stbase[i] = nil;
  }
 }
","The vulnerability in the original code arises from the handling of values in the context stack, particularly when a value's type is `MRB_TT_FREE`. In such cases, the code incorrectly sets the stack entry to `mrb_nil_value()` without ensuring that all entries beyond the valid range are also cleared, potentially leading to memory corruption or undefined behavior. The fixed code addresses this by first marking valid entries with `mrb_gc_mark(mrb, mrb_basic_ptr(v))` and then explicitly setting all remaining entries in the stack to `nil` using a separate loop, ensuring that the entire stack is properly initialized and preventing any unintended access to freed memory.","The vulnerability in the original code stems from improper handling of memory management, particularly when dealing with freed objects. When an object is marked as free, the code sets the corresponding stack entry to a nil value, but it fails to ensure that all remaining entries in the stack are also cleared. This oversight can lead to memory corruption or access to invalid memory locations, resulting in undefined behavior. The revised code rectifies this issue by first marking valid entries and then explicitly setting all remaining stack entries to nil, ensuring that the entire stack is safely initialized and preventing potential memory access violations."
27,181267,181267,,Remote,Not required,Partial,CVE-2017-9520,https://www.cvedetails.com/cve/CVE-2017-9520/,CWE-416,Medium,,,,2017-06-08,4.3,The r_config_set function in libr/config/config.c in radare2 1.5.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted DEX file.,2017-06-27,DoS ,2,https://github.com/radare/radare2/commit/f85bc674b2a2256a364fe796351bc1971e106005,f85bc674b2a2256a364fe796351bc1971e106005,Fix #7698 - UAF in r_config_set when loading a dex,1,libr/config/config.c,"{""sha"": ""c2b3662b294230c45c3acbf85628eeb85d996953"", ""filename"": ""libr/config/config.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/radareorg/radare2/blob/f85bc674b2a2256a364fe796351bc1971e106005/libr/config/config.c"", ""raw_url"": ""https://github.com/radareorg/radare2/raw/f85bc674b2a2256a364fe796351bc1971e106005/libr/config/config.c"", ""contents_url"": ""https://api.github.com/repos/radareorg/radare2/contents/libr/config/config.c?ref=f85bc674b2a2256a364fe796351bc1971e106005"", ""patch"": ""@@ -388,8 +388,9 @@ R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *valu\n \t\t\t\tif (node->value == value) {\n \t\t\t\t\tgoto beach;\n \t\t\t\t}\n-\t\t\t\tfree (node->value);\n+\t\t\t\tchar *tmp = node->value;\n \t\t\t\tnode->value = strdup (value);\n+\t\t\t\tfree (tmp);\n \t\t\t\tif (IS_DIGIT (*value)) {\n \t\t\t\t\tif (strchr (value, '/')) {\n \t\t\t\t\t\tnode->i_value = r_num_get (cfg->num, value);""}<_**next**_>{""sha"": ""add791c1c7a28159e92b6ba244d1c7628c1e7bb9"", ""filename"": ""libr/core/cbin.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 3, ""changes"": 9, ""blob_url"": ""https://github.com/radareorg/radare2/blob/f85bc674b2a2256a364fe796351bc1971e106005/libr/core/cbin.c"", ""raw_url"": ""https://github.com/radareorg/radare2/raw/f85bc674b2a2256a364fe796351bc1971e106005/libr/core/cbin.c"", ""contents_url"": ""https://api.github.com/repos/radareorg/radare2/contents/libr/core/cbin.c?ref=f85bc674b2a2256a364fe796351bc1971e106005"", ""patch"": ""@@ -96,7 +96,8 @@ R_API int r_core_bin_set_env(RCore *r, RBinFile *binfile) {\n \tRBinInfo *info = binobj ? binobj->info: NULL;\n \tif (info) {\n \t\tint va = info->has_va;\n-\t\tconst char * arch = info->arch;\n+\t\tchar * arch = strdup(info->arch);\n+\t\tchar * cpu = info->cpu? strdup(info->cpu): NULL;\n \t\tut16 bits = info->bits;\n \t\tut64 baseaddr = r_bin_get_baddr (r->bin);\n \t\t/* Hack to make baddr work on some corner */\n@@ -106,14 +107,16 @@ R_API int r_core_bin_set_env(RCore *r, RBinFile *binfile) {\n \t\tr_config_set (r->config, \""asm.arch\"", arch);\n \t\tr_config_set_i (r->config, \""asm.bits\"", bits);\n \t\tr_config_set (r->config, \""anal.arch\"", arch);\n-\t\tif (info->cpu && *info->cpu) {\n-\t\t\tr_config_set (r->config, \""anal.cpu\"", info->cpu);\n+\t\tif (cpu && *cpu) {\n+\t\t\tr_config_set (r->config, \""anal.cpu\"", cpu);\n \t\t} else {\n \t\t\tr_config_set (r->config, \""anal.cpu\"", arch);\n \t\t}\n \t\tr_asm_use (r->assembler, arch);\n \t\tr_core_bin_info (r, R_CORE_BIN_ACC_ALL, R_CORE_BIN_SET, va, NULL, NULL);\n \t\tr_core_bin_set_cur (r, binfile);\n+\t\tfree (cpu);\n+\t\tfree (arch);\n \t\treturn true;\n \t}\n \treturn false;""}","R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *value) {
	RConfigNode *node = NULL;
	char *ov = NULL;
	ut64 oi;
	if (!cfg || STRNULL (name)) {
		return NULL;
	}
	node = r_config_node_get (cfg, name);
	if (node) {
		if (node->flags & CN_RO) {
			eprintf (""(error: '%s' config key is read only)\n"", name);
			return node;
		}
		oi = node->i_value;
		if (node->value) {
			ov = strdup (node->value);
			if (!ov) {
				goto beach;
			}
		} else {
			free (node->value);
			node->value = strdup ("""");
		}
		if (node->flags & CN_BOOL) {
			bool b = is_true (value);
			node->i_value = (ut64) b? 1: 0;
			char *value = strdup (r_str_bool (b));
			if (value) {
				free (node->value);
				node->value = value;
			}
		} else {
			if (!value) {
				free (node->value);
				node->value = strdup ("""");
				node->i_value = 0;
			} else {
 				if (node->value == value) {
 					goto beach;
 				}
				char *tmp = node->value;
 				node->value = strdup (value);
				free (tmp);
 				if (IS_DIGIT (*value)) {
 					if (strchr (value, '/')) {
 						node->i_value = r_num_get (cfg->num, value);
					} else {
						node->i_value = r_num_math (cfg->num, value);
					}
				} else {
					node->i_value = 0;
				}
				node->flags |= CN_INT;
			}
		}
	} else { // Create a new RConfigNode
		oi = UT64_MAX;
		if (!cfg->lock) {
			node = r_config_node_new (name, value);
			if (node) {
				if (value && is_bool (value)) {
					node->flags |= CN_BOOL;
					node->i_value = is_true (value)? 1: 0;
				}
				if (cfg->ht) {
					ht_insert (cfg->ht, node->name, node);
					r_list_append (cfg->nodes, node);
					cfg->n_nodes++;
				}
			} else {
				eprintf (""r_config_set: unable to create a new RConfigNode\n"");
			}
		} else {
			eprintf (""r_config_set: variable '%s' not found\n"", name);
		}
	}

	if (node && node->setter) {
		int ret = node->setter (cfg->user, node);
		if (ret == false) {
			if (oi != UT64_MAX) {
				node->i_value = oi;
			}
			free (node->value);
			node->value = strdup (ov? ov: """");
		}
	}
beach:
	free (ov);
	return node;
}
","R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *value) {
	RConfigNode *node = NULL;
	char *ov = NULL;
	ut64 oi;
	if (!cfg || STRNULL (name)) {
		return NULL;
	}
	node = r_config_node_get (cfg, name);
	if (node) {
		if (node->flags & CN_RO) {
			eprintf (""(error: '%s' config key is read only)\n"", name);
			return node;
		}
		oi = node->i_value;
		if (node->value) {
			ov = strdup (node->value);
			if (!ov) {
				goto beach;
			}
		} else {
			free (node->value);
			node->value = strdup ("""");
		}
		if (node->flags & CN_BOOL) {
			bool b = is_true (value);
			node->i_value = (ut64) b? 1: 0;
			char *value = strdup (r_str_bool (b));
			if (value) {
				free (node->value);
				node->value = value;
			}
		} else {
			if (!value) {
				free (node->value);
				node->value = strdup ("""");
				node->i_value = 0;
			} else {
 				if (node->value == value) {
 					goto beach;
 				}
				free (node->value);
 				node->value = strdup (value);
 				if (IS_DIGIT (*value)) {
 					if (strchr (value, '/')) {
 						node->i_value = r_num_get (cfg->num, value);
					} else {
						node->i_value = r_num_math (cfg->num, value);
					}
				} else {
					node->i_value = 0;
				}
				node->flags |= CN_INT;
			}
		}
	} else { // Create a new RConfigNode
		oi = UT64_MAX;
		if (!cfg->lock) {
			node = r_config_node_new (name, value);
			if (node) {
				if (value && is_bool (value)) {
					node->flags |= CN_BOOL;
					node->i_value = is_true (value)? 1: 0;
				}
				if (cfg->ht) {
					ht_insert (cfg->ht, node->name, node);
					r_list_append (cfg->nodes, node);
					cfg->n_nodes++;
				}
			} else {
				eprintf (""r_config_set: unable to create a new RConfigNode\n"");
			}
		} else {
			eprintf (""r_config_set: variable '%s' not found\n"", name);
		}
	}

	if (node && node->setter) {
		int ret = node->setter (cfg->user, node);
		if (ret == false) {
			if (oi != UT64_MAX) {
				node->i_value = oi;
			}
			free (node->value);
			node->value = strdup (ov? ov: """");
		}
	}
beach:
	free (ov);
	return node;
}
",C,"				char *tmp = node->value;
				free (tmp);
","				free (node->value);
",,"@@ -388,8 +388,9 @@ R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *valu
 				if (node->value == value) {
 					goto beach;
 				}
-				free (node->value);
+				char *tmp = node->value;
 				node->value = strdup (value);
+				free (tmp);
 				if (IS_DIGIT (*value)) {
 					if (strchr (value, '/')) {
 						node->i_value = r_num_get (cfg->num, value);",radare2,f85bc674b2a2256a364fe796351bc1971e106005,bcdbfcaf8a5cc028edc10f38fab72b2ae8a5f101,1,"R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *value) {
	RConfigNode *node = NULL;
	char *ov = NULL;
	ut64 oi;
	if (!cfg || STRNULL (name)) {
		return NULL;
	}
	node = r_config_node_get (cfg, name);
	if (node) {
		if (node->flags & CN_RO) {
			eprintf (""(error: '%s' config key is read only)\n"", name);
			return node;
		}
		oi = node->i_value;
		if (node->value) {
			ov = strdup (node->value);
			if (!ov) {
				goto beach;
			}
		} else {
			free (node->value);
			node->value = strdup ("""");
		}
		if (node->flags & CN_BOOL) {
			bool b = is_true (value);
			node->i_value = (ut64) b? 1: 0;
			char *value = strdup (r_str_bool (b));
			if (value) {
				free (node->value);
				node->value = value;
			}
		} else {
			if (!value) {
				free (node->value);
				node->value = strdup ("""");
				node->i_value = 0;
			} else {
 				if (node->value == value) {
 					goto beach;
 				}
//flaw_line_below:
				free (node->value);
//fix_flaw_line_below:
//				char *tmp = node->value;
 				node->value = strdup (value);
//fix_flaw_line_below:
//				free (tmp);
 				if (IS_DIGIT (*value)) {
 					if (strchr (value, '/')) {
 						node->i_value = r_num_get (cfg->num, value);
					} else {
						node->i_value = r_num_math (cfg->num, value);
					}
				} else {
					node->i_value = 0;
				}
				node->flags |= CN_INT;
			}
		}
	} else { // Create a new RConfigNode
		oi = UT64_MAX;
		if (!cfg->lock) {
			node = r_config_node_new (name, value);
			if (node) {
				if (value && is_bool (value)) {
					node->flags |= CN_BOOL;
					node->i_value = is_true (value)? 1: 0;
				}
				if (cfg->ht) {
					ht_insert (cfg->ht, node->name, node);
					r_list_append (cfg->nodes, node);
					cfg->n_nodes++;
				}
			} else {
				eprintf (""r_config_set: unable to create a new RConfigNode\n"");
			}
		} else {
			eprintf (""r_config_set: variable '%s' not found\n"", name);
		}
	}

	if (node && node->setter) {
		int ret = node->setter (cfg->user, node);
		if (ret == false) {
			if (oi != UT64_MAX) {
				node->i_value = oi;
			}
			free (node->value);
			node->value = strdup (ov? ov: """");
		}
	}
beach:
	free (ov);
	return node;
}
",181267,"R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *value) {
	RConfigNode *node = NULL;
	char *ov = NULL;
	ut64 oi;
	if (!cfg || STRNULL (name)) {
		return NULL;
	}
	node = r_config_node_get (cfg, name);
	if (node) {
		if (node->flags & CN_RO) {
			eprintf (""(error: '%s' config key is read only)\n"", name);
			return node;
		}
		oi = node->i_value;
		if (node->value) {
			ov = strdup (node->value);
			if (!ov) {
				goto beach;
			}
		} else {
			free (node->value);
			node->value = strdup ("""");
		}
		if (node->flags & CN_BOOL) {
			bool b = is_true (value);
			node->i_value = (ut64) b? 1: 0;
			char *value = strdup (r_str_bool (b));
			if (value) {
				free (node->value);
				node->value = value;
			}
		} else {
			if (!value) {
				free (node->value);
				node->value = strdup ("""");
				node->i_value = 0;
			} else {
 				if (node->value == value) {
 					goto beach;
 				}
				free (node->value);
 				node->value = strdup (value);
 				if (IS_DIGIT (*value)) {
 					if (strchr (value, '/')) {
 						node->i_value = r_num_get (cfg->num, value);
					} else {
						node->i_value = r_num_math (cfg->num, value);
					}
				} else {
					node->i_value = 0;
				}
				node->flags |= CN_INT;
			}
		}
	} else { // Create a new RConfigNode
		oi = UT64_MAX;
		if (!cfg->lock) {
			node = r_config_node_new (name, value);
			if (node) {
				if (value && is_bool (value)) {
					node->flags |= CN_BOOL;
					node->i_value = is_true (value)? 1: 0;
				}
				if (cfg->ht) {
					ht_insert (cfg->ht, node->name, node);
					r_list_append (cfg->nodes, node);
					cfg->n_nodes++;
				}
			} else {
				eprintf (""r_config_set: unable to create a new RConfigNode\n"");
			}
		} else {
			eprintf (""r_config_set: variable '%s' not found\n"", name);
		}
	}

	if (node && node->setter) {
		int ret = node->setter (cfg->user, node);
		if (ret == false) {
			if (oi != UT64_MAX) {
				node->i_value = oi;
			}
			free (node->value);
			node->value = strdup (ov? ov: """");
		}
	}
beach:
	free (ov);
	return node;
}
","R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *value) {
	RConfigNode *node = NULL;
	char *ov = NULL;
	ut64 oi;
	if (!cfg || STRNULL (name)) {
		return NULL;
	}
	node = r_config_node_get (cfg, name);
	if (node) {
		if (node->flags & CN_RO) {
			eprintf (""(error: '%s' config key is read only)\n"", name);
			return node;
		}
		oi = node->i_value;
		if (node->value) {
			ov = strdup (node->value);
			if (!ov) {
				goto beach;
			}
		} else {
			free (node->value);
			node->value = strdup ("""");
		}
		if (node->flags & CN_BOOL) {
			bool b = is_true (value);
			node->i_value = (ut64) b? 1: 0;
			char *value = strdup (r_str_bool (b));
			if (value) {
				free (node->value);
				node->value = value;
			}
		} else {
			if (!value) {
				free (node->value);
				node->value = strdup ("""");
				node->i_value = 0;
			} else {
 				if (node->value == value) {
 					goto beach;
 				}
				char *tmp = node->value;
 				node->value = strdup (value);
				free (tmp);
 				if (IS_DIGIT (*value)) {
 					if (strchr (value, '/')) {
 						node->i_value = r_num_get (cfg->num, value);
					} else {
						node->i_value = r_num_math (cfg->num, value);
					}
				} else {
					node->i_value = 0;
				}
				node->flags |= CN_INT;
			}
		}
	} else { // Create a new RConfigNode
		oi = UT64_MAX;
		if (!cfg->lock) {
			node = r_config_node_new (name, value);
			if (node) {
				if (value && is_bool (value)) {
					node->flags |= CN_BOOL;
					node->i_value = is_true (value)? 1: 0;
				}
				if (cfg->ht) {
					ht_insert (cfg->ht, node->name, node);
					r_list_append (cfg->nodes, node);
					cfg->n_nodes++;
				}
			} else {
				eprintf (""r_config_set: unable to create a new RConfigNode\n"");
			}
		} else {
			eprintf (""r_config_set: variable '%s' not found\n"", name);
		}
	}

	if (node && node->setter) {
		int ret = node->setter (cfg->user, node);
		if (ret == false) {
			if (oi != UT64_MAX) {
				node->i_value = oi;
			}
			free (node->value);
			node->value = strdup (ov? ov: """");
		}
	}
beach:
	free (ov);
	return node;
}
","The vulnerability in the original code arises from improper memory management when updating the `node->value`. Specifically, if `node->value` is the same as `value`, the code incorrectly skips freeing the old value, leading to a potential memory leak. In the fixed code, this issue is addressed by introducing a temporary variable `char *tmp = node->value;` before updating `node->value` with `strdup(value)`. This ensures that the old value is freed correctly with `free(tmp)`, preventing memory leaks and ensuring proper resource management when the value is updated.","The vulnerability in the original code stems from inadequate memory management, particularly when updating a specific value. If the existing value is the same as the new value being assigned, the code fails to free the old memory, leading to a memory leak. This oversight can result in increased memory usage over time, potentially causing performance degradation or application crashes. The fixed code resolves this issue by introducing a temporary variable to hold the old value before updating it. This ensures that the old memory is properly freed, thus maintaining efficient memory usage and preventing leaks."
28,181444,181444,,Local,Not required,Complete,CVE-2017-7487,https://www.cvedetails.com/cve/CVE-2017-7487/,CWE-416,Low,Complete,Complete,,2017-05-14,7.2,"The ipxitf_ioctl function in net/ipx/af_ipx.c in the Linux kernel through 4.11.1 mishandles reference counts, which allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a failed SIOCGIFADDR ioctl call for an IPX interface.",2017-11-03,DoS ,2,https://github.com/torvalds/linux/commit/ee0d8d8482345ff97a75a7d747efc309f13b0d80,ee0d8d8482345ff97a75a7d747efc309f13b0d80,"ipx: call ipxitf_put() in ioctl error path

We should call ipxitf_put() if the copy_to_user() fails.

Reported-by:  <liqiang6-s@360.cn>
Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",3,net/ipx/af_ipx.c,"{""sha"": ""fa31ef29e3fa0bf3973e12e43c57b48eb7d1be45"", ""filename"": ""net/ipx/af_ipx.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/ee0d8d8482345ff97a75a7d747efc309f13b0d80/net/ipx/af_ipx.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/ee0d8d8482345ff97a75a7d747efc309f13b0d80/net/ipx/af_ipx.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipx/af_ipx.c?ref=ee0d8d8482345ff97a75a7d747efc309f13b0d80"", ""patch"": ""@@ -1168,11 +1168,10 @@ static int ipxitf_ioctl(unsigned int cmd, void __user *arg)\n \t\tsipx->sipx_network\t= ipxif->if_netnum;\n \t\tmemcpy(sipx->sipx_node, ipxif->if_node,\n \t\t\tsizeof(sipx->sipx_node));\n-\t\trc = -EFAULT;\n+\t\trc = 0;\n \t\tif (copy_to_user(arg, &ifr, sizeof(ifr)))\n-\t\t\tbreak;\n+\t\t\trc = -EFAULT;\n \t\tipxitf_put(ipxif);\n-\t\trc = 0;\n \t\tbreak;\n \t}\n \tcase SIOCAIPXITFCRT:""}","static int ipxitf_ioctl(unsigned int cmd, void __user *arg)
{
	int rc = -EINVAL;
	struct ifreq ifr;
	int val;

	switch (cmd) {
	case SIOCSIFADDR: {
		struct sockaddr_ipx *sipx;
		struct ipx_interface_definition f;

		rc = -EFAULT;
		if (copy_from_user(&ifr, arg, sizeof(ifr)))
			break;
		sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
		rc = -EINVAL;
		if (sipx->sipx_family != AF_IPX)
			break;
		f.ipx_network = sipx->sipx_network;
		memcpy(f.ipx_device, ifr.ifr_name,
			sizeof(f.ipx_device));
		memcpy(f.ipx_node, sipx->sipx_node, IPX_NODE_LEN);
		f.ipx_dlink_type = sipx->sipx_type;
		f.ipx_special = sipx->sipx_special;

		if (sipx->sipx_action == IPX_DLTITF)
			rc = ipxitf_delete(&f);
		else
			rc = ipxitf_create(&f);
		break;
	}
	case SIOCGIFADDR: {
		struct sockaddr_ipx *sipx;
		struct ipx_interface *ipxif;
		struct net_device *dev;

		rc = -EFAULT;
		if (copy_from_user(&ifr, arg, sizeof(ifr)))
			break;
		sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
		dev  = __dev_get_by_name(&init_net, ifr.ifr_name);
		rc   = -ENODEV;
		if (!dev)
			break;
		ipxif = ipxitf_find_using_phys(dev,
					   ipx_map_frame_type(sipx->sipx_type));
		rc = -EADDRNOTAVAIL;
		if (!ipxif)
			break;

		sipx->sipx_family	= AF_IPX;
 		sipx->sipx_network	= ipxif->if_netnum;
 		memcpy(sipx->sipx_node, ipxif->if_node,
 			sizeof(sipx->sipx_node));
		rc = 0;
 		if (copy_to_user(arg, &ifr, sizeof(ifr)))
			rc = -EFAULT;
 		ipxitf_put(ipxif);
 		break;
 	}
 	case SIOCAIPXITFCRT:
		rc = -EFAULT;
		if (get_user(val, (unsigned char __user *) arg))
			break;
		rc = 0;
		ipxcfg_auto_create_interfaces = val;
		break;
	case SIOCAIPXPRISLT:
		rc = -EFAULT;
		if (get_user(val, (unsigned char __user *) arg))
			break;
		rc = 0;
		ipxcfg_set_auto_select(val);
		break;
	}

	return rc;
}
","static int ipxitf_ioctl(unsigned int cmd, void __user *arg)
{
	int rc = -EINVAL;
	struct ifreq ifr;
	int val;

	switch (cmd) {
	case SIOCSIFADDR: {
		struct sockaddr_ipx *sipx;
		struct ipx_interface_definition f;

		rc = -EFAULT;
		if (copy_from_user(&ifr, arg, sizeof(ifr)))
			break;
		sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
		rc = -EINVAL;
		if (sipx->sipx_family != AF_IPX)
			break;
		f.ipx_network = sipx->sipx_network;
		memcpy(f.ipx_device, ifr.ifr_name,
			sizeof(f.ipx_device));
		memcpy(f.ipx_node, sipx->sipx_node, IPX_NODE_LEN);
		f.ipx_dlink_type = sipx->sipx_type;
		f.ipx_special = sipx->sipx_special;

		if (sipx->sipx_action == IPX_DLTITF)
			rc = ipxitf_delete(&f);
		else
			rc = ipxitf_create(&f);
		break;
	}
	case SIOCGIFADDR: {
		struct sockaddr_ipx *sipx;
		struct ipx_interface *ipxif;
		struct net_device *dev;

		rc = -EFAULT;
		if (copy_from_user(&ifr, arg, sizeof(ifr)))
			break;
		sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
		dev  = __dev_get_by_name(&init_net, ifr.ifr_name);
		rc   = -ENODEV;
		if (!dev)
			break;
		ipxif = ipxitf_find_using_phys(dev,
					   ipx_map_frame_type(sipx->sipx_type));
		rc = -EADDRNOTAVAIL;
		if (!ipxif)
			break;

		sipx->sipx_family	= AF_IPX;
 		sipx->sipx_network	= ipxif->if_netnum;
 		memcpy(sipx->sipx_node, ipxif->if_node,
 			sizeof(sipx->sipx_node));
		rc = -EFAULT;
 		if (copy_to_user(arg, &ifr, sizeof(ifr)))
			break;
 		ipxitf_put(ipxif);
		rc = 0;
 		break;
 	}
 	case SIOCAIPXITFCRT:
		rc = -EFAULT;
		if (get_user(val, (unsigned char __user *) arg))
			break;
		rc = 0;
		ipxcfg_auto_create_interfaces = val;
		break;
	case SIOCAIPXPRISLT:
		rc = -EFAULT;
		if (get_user(val, (unsigned char __user *) arg))
			break;
		rc = 0;
		ipxcfg_set_auto_select(val);
		break;
	}

	return rc;
}
",C,"		rc = 0;
			rc = -EFAULT;
","		rc = -EFAULT;
			break;
		rc = 0;
",,"@@ -1168,11 +1168,10 @@ static int ipxitf_ioctl(unsigned int cmd, void __user *arg)
 		sipx->sipx_network	= ipxif->if_netnum;
 		memcpy(sipx->sipx_node, ipxif->if_node,
 			sizeof(sipx->sipx_node));
-		rc = -EFAULT;
+		rc = 0;
 		if (copy_to_user(arg, &ifr, sizeof(ifr)))
-			break;
+			rc = -EFAULT;
 		ipxitf_put(ipxif);
-		rc = 0;
 		break;
 	}
 	case SIOCAIPXITFCRT:",linux,ee0d8d8482345ff97a75a7d747efc309f13b0d80,9da3242e6a83b6f315aa9c394c939da8e4ad7774,1,"static int ipxitf_ioctl(unsigned int cmd, void __user *arg)
{
	int rc = -EINVAL;
	struct ifreq ifr;
	int val;

	switch (cmd) {
	case SIOCSIFADDR: {
		struct sockaddr_ipx *sipx;
		struct ipx_interface_definition f;

		rc = -EFAULT;
		if (copy_from_user(&ifr, arg, sizeof(ifr)))
			break;
		sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
		rc = -EINVAL;
		if (sipx->sipx_family != AF_IPX)
			break;
		f.ipx_network = sipx->sipx_network;
		memcpy(f.ipx_device, ifr.ifr_name,
			sizeof(f.ipx_device));
		memcpy(f.ipx_node, sipx->sipx_node, IPX_NODE_LEN);
		f.ipx_dlink_type = sipx->sipx_type;
		f.ipx_special = sipx->sipx_special;

		if (sipx->sipx_action == IPX_DLTITF)
			rc = ipxitf_delete(&f);
		else
			rc = ipxitf_create(&f);
		break;
	}
	case SIOCGIFADDR: {
		struct sockaddr_ipx *sipx;
		struct ipx_interface *ipxif;
		struct net_device *dev;

		rc = -EFAULT;
		if (copy_from_user(&ifr, arg, sizeof(ifr)))
			break;
		sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
		dev  = __dev_get_by_name(&init_net, ifr.ifr_name);
		rc   = -ENODEV;
		if (!dev)
			break;
		ipxif = ipxitf_find_using_phys(dev,
					   ipx_map_frame_type(sipx->sipx_type));
		rc = -EADDRNOTAVAIL;
		if (!ipxif)
			break;

		sipx->sipx_family	= AF_IPX;
 		sipx->sipx_network	= ipxif->if_netnum;
 		memcpy(sipx->sipx_node, ipxif->if_node,
 			sizeof(sipx->sipx_node));
//flaw_line_below:
		rc = -EFAULT;
//fix_flaw_line_below:
//		rc = 0;
 		if (copy_to_user(arg, &ifr, sizeof(ifr)))
//flaw_line_below:
			break;
//fix_flaw_line_below:
//			rc = -EFAULT;
 		ipxitf_put(ipxif);
//flaw_line_below:
		rc = 0;
 		break;
 	}
 	case SIOCAIPXITFCRT:
		rc = -EFAULT;
		if (get_user(val, (unsigned char __user *) arg))
			break;
		rc = 0;
		ipxcfg_auto_create_interfaces = val;
		break;
	case SIOCAIPXPRISLT:
		rc = -EFAULT;
		if (get_user(val, (unsigned char __user *) arg))
			break;
		rc = 0;
		ipxcfg_set_auto_select(val);
		break;
	}

	return rc;
}
",181444,"static int ipxitf_ioctl(unsigned int cmd, void __user *arg)
{
	int rc = -EINVAL;
	struct ifreq ifr;
	int val;

	switch (cmd) {
	case SIOCSIFADDR: {
		struct sockaddr_ipx *sipx;
		struct ipx_interface_definition f;

		rc = -EFAULT;
		if (copy_from_user(&ifr, arg, sizeof(ifr)))
			break;
		sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
		rc = -EINVAL;
		if (sipx->sipx_family != AF_IPX)
			break;
		f.ipx_network = sipx->sipx_network;
		memcpy(f.ipx_device, ifr.ifr_name,
			sizeof(f.ipx_device));
		memcpy(f.ipx_node, sipx->sipx_node, IPX_NODE_LEN);
		f.ipx_dlink_type = sipx->sipx_type;
		f.ipx_special = sipx->sipx_special;

		if (sipx->sipx_action == IPX_DLTITF)
			rc = ipxitf_delete(&f);
		else
			rc = ipxitf_create(&f);
		break;
	}
	case SIOCGIFADDR: {
		struct sockaddr_ipx *sipx;
		struct ipx_interface *ipxif;
		struct net_device *dev;

		rc = -EFAULT;
		if (copy_from_user(&ifr, arg, sizeof(ifr)))
			break;
		sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
		dev  = __dev_get_by_name(&init_net, ifr.ifr_name);
		rc   = -ENODEV;
		if (!dev)
			break;
		ipxif = ipxitf_find_using_phys(dev,
					   ipx_map_frame_type(sipx->sipx_type));
		rc = -EADDRNOTAVAIL;
		if (!ipxif)
			break;

		sipx->sipx_family	= AF_IPX;
 		sipx->sipx_network	= ipxif->if_netnum;
 		memcpy(sipx->sipx_node, ipxif->if_node,
 			sizeof(sipx->sipx_node));
		rc = -EFAULT;
 		if (copy_to_user(arg, &ifr, sizeof(ifr)))
			break;
 		ipxitf_put(ipxif);
		rc = 0;
 		break;
 	}
 	case SIOCAIPXITFCRT:
		rc = -EFAULT;
		if (get_user(val, (unsigned char __user *) arg))
			break;
		rc = 0;
		ipxcfg_auto_create_interfaces = val;
		break;
	case SIOCAIPXPRISLT:
		rc = -EFAULT;
		if (get_user(val, (unsigned char __user *) arg))
			break;
		rc = 0;
		ipxcfg_set_auto_select(val);
		break;
	}

	return rc;
}
","static int ipxitf_ioctl(unsigned int cmd, void __user *arg)
{
	int rc = -EINVAL;
	struct ifreq ifr;
	int val;

	switch (cmd) {
	case SIOCSIFADDR: {
		struct sockaddr_ipx *sipx;
		struct ipx_interface_definition f;

		rc = -EFAULT;
		if (copy_from_user(&ifr, arg, sizeof(ifr)))
			break;
		sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
		rc = -EINVAL;
		if (sipx->sipx_family != AF_IPX)
			break;
		f.ipx_network = sipx->sipx_network;
		memcpy(f.ipx_device, ifr.ifr_name,
			sizeof(f.ipx_device));
		memcpy(f.ipx_node, sipx->sipx_node, IPX_NODE_LEN);
		f.ipx_dlink_type = sipx->sipx_type;
		f.ipx_special = sipx->sipx_special;

		if (sipx->sipx_action == IPX_DLTITF)
			rc = ipxitf_delete(&f);
		else
			rc = ipxitf_create(&f);
		break;
	}
	case SIOCGIFADDR: {
		struct sockaddr_ipx *sipx;
		struct ipx_interface *ipxif;
		struct net_device *dev;

		rc = -EFAULT;
		if (copy_from_user(&ifr, arg, sizeof(ifr)))
			break;
		sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
		dev  = __dev_get_by_name(&init_net, ifr.ifr_name);
		rc   = -ENODEV;
		if (!dev)
			break;
		ipxif = ipxitf_find_using_phys(dev,
					   ipx_map_frame_type(sipx->sipx_type));
		rc = -EADDRNOTAVAIL;
		if (!ipxif)
			break;

		sipx->sipx_family	= AF_IPX;
 		sipx->sipx_network	= ipxif->if_netnum;
 		memcpy(sipx->sipx_node, ipxif->if_node,
 			sizeof(sipx->sipx_node));
		rc = 0;
 		if (copy_to_user(arg, &ifr, sizeof(ifr)))
			rc = -EFAULT;
 		ipxitf_put(ipxif);
 		break;
 	}
 	case SIOCAIPXITFCRT:
		rc = -EFAULT;
		if (get_user(val, (unsigned char __user *) arg))
			break;
		rc = 0;
		ipxcfg_auto_create_interfaces = val;
		break;
	case SIOCAIPXPRISLT:
		rc = -EFAULT;
		if (get_user(val, (unsigned char __user *) arg))
			break;
		rc = 0;
		ipxcfg_set_auto_select(val);
		break;
	}

	return rc;
}
","The vulnerability in the original code lies in the handling of the return value from `copy_to_user(arg, &ifr, sizeof(ifr))` in the SIOCGIFADDR case. If this function fails, the code does not properly set the return code `rc` to indicate the error, potentially leading to incorrect behavior or data exposure. In the fixed code, this issue is addressed by checking the return value of `copy_to_user` and explicitly setting `rc` to `-EFAULT` if the copy fails, ensuring that the function correctly reports the error condition and preventing unintended consequences from an unhandled failure.","The vulnerability in the original code arises from inadequate error handling when copying data from user space. Specifically, if the copy operation fails, the code does not update the return value to reflect this error, which could lead to incorrect assumptions about the success of the operation and potentially expose sensitive data or cause undefined behavior. In the revised code, this issue is rectified by explicitly checking the result of the copy operation and setting the return value accordingly if an error occurs, thereby ensuring that the function accurately communicates failure conditions to the caller."
29,181487,181487,,Local,Not required,Complete,CVE-2017-6874,https://www.cvedetails.com/cve/CVE-2017-6874/,CWE-416,Medium,Complete,Complete,,2017-03-14,6.9,Race condition in kernel/ucount.c in the Linux kernel through 4.10.2 allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via crafted system calls that leverage certain decrement behavior that causes incorrect interaction between put_ucounts and get_ucounts.,2017-03-15,DoS ,4,https://github.com/torvalds/linux/commit/040757f738e13caaa9c5078bca79aa97e11dde88,040757f738e13caaa9c5078bca79aa97e11dde88,"ucount: Remove the atomicity from ucount->count

Always increment/decrement ucount->count under the ucounts_lock.  The
increments are there already and moving the decrements there means the
locking logic of the code is simpler.  This simplification in the
locking logic fixes a race between put_ucounts and get_ucounts that
could result in a use-after-free because the count could go zero then
be found by get_ucounts and then be freed by put_ucounts.

A bug presumably this one was found by a combination of syzkaller and
KASAN.  JongWhan Kim reported the syzkaller failure and Dmitry Vyukov
spotted the race in the code.

Cc: stable@vger.kernel.org
Fixes: f6b2db1a3e8d (""userns: Make the count of user namespaces per user"")
Reported-by: JongHwan Kim <zzoru007@gmail.com>
Reported-by: Dmitry Vyukov <dvyukov@google.com>
Reviewed-by: Andrei Vagin <avagin@gmail.com>
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",2,kernel/ucount.c,"{""sha"": ""32354b4b4b2ba5ae72034d00c3b1d43fa8c2a15c"", ""filename"": ""include/linux/user_namespace.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/040757f738e13caaa9c5078bca79aa97e11dde88/include/linux/user_namespace.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/040757f738e13caaa9c5078bca79aa97e11dde88/include/linux/user_namespace.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/user_namespace.h?ref=040757f738e13caaa9c5078bca79aa97e11dde88"", ""patch"": ""@@ -72,7 +72,7 @@ struct ucounts {\n \tstruct hlist_node node;\n \tstruct user_namespace *ns;\n \tkuid_t uid;\n-\tatomic_t count;\n+\tint count;\n \tatomic_t ucount[UCOUNT_COUNTS];\n };\n ""}<_**next**_>{""sha"": ""b4eeee03934fe8f083b70e9907be0721759bc3be"", ""filename"": ""kernel/ucount.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 7, ""changes"": 18, ""blob_url"": ""https://github.com/torvalds/linux/blob/040757f738e13caaa9c5078bca79aa97e11dde88/kernel/ucount.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/040757f738e13caaa9c5078bca79aa97e11dde88/kernel/ucount.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/ucount.c?ref=040757f738e13caaa9c5078bca79aa97e11dde88"", ""patch"": ""@@ -144,7 +144,7 @@ static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n \n \t\tnew->ns = ns;\n \t\tnew->uid = uid;\n-\t\tatomic_set(&new->count, 0);\n+\t\tnew->count = 0;\n \n \t\tspin_lock_irq(&ucounts_lock);\n \t\tucounts = find_ucounts(ns, uid, hashent);\n@@ -155,8 +155,10 @@ static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n \t\t\tucounts = new;\n \t\t}\n \t}\n-\tif (!atomic_add_unless(&ucounts->count, 1, INT_MAX))\n+\tif (ucounts->count == INT_MAX)\n \t\tucounts = NULL;\n+\telse\n+\t\tucounts->count += 1;\n \tspin_unlock_irq(&ucounts_lock);\n \treturn ucounts;\n }\n@@ -165,13 +167,15 @@ static void put_ucounts(struct ucounts *ucounts)\n {\n \tunsigned long flags;\n \n-\tif (atomic_dec_and_test(&ucounts->count)) {\n-\t\tspin_lock_irqsave(&ucounts_lock, flags);\n+\tspin_lock_irqsave(&ucounts_lock, flags);\n+\tucounts->count -= 1;\n+\tif (!ucounts->count)\n \t\thlist_del_init(&ucounts->node);\n-\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n+\telse\n+\t\tucounts = NULL;\n+\tspin_unlock_irqrestore(&ucounts_lock, flags);\n \n-\t\tkfree(ucounts);\n-\t}\n+\tkfree(ucounts);\n }\n \n static inline bool atomic_inc_below(atomic_t *v, int u)""}","static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)
{
	struct hlist_head *hashent = ucounts_hashentry(ns, uid);
	struct ucounts *ucounts, *new;

	spin_lock_irq(&ucounts_lock);
	ucounts = find_ucounts(ns, uid, hashent);
	if (!ucounts) {
		spin_unlock_irq(&ucounts_lock);

		new = kzalloc(sizeof(*new), GFP_KERNEL);
		if (!new)
			return NULL;
 
 		new->ns = ns;
 		new->uid = uid;
		new->count = 0;
 
 		spin_lock_irq(&ucounts_lock);
 		ucounts = find_ucounts(ns, uid, hashent);
		if (ucounts) {
			kfree(new);
		} else {
			hlist_add_head(&new->node, hashent);
 			ucounts = new;
 		}
 	}
	if (ucounts->count == INT_MAX)
 		ucounts = NULL;
	else
		ucounts->count += 1;
 	spin_unlock_irq(&ucounts_lock);
 	return ucounts;
 }
","static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)
{
	struct hlist_head *hashent = ucounts_hashentry(ns, uid);
	struct ucounts *ucounts, *new;

	spin_lock_irq(&ucounts_lock);
	ucounts = find_ucounts(ns, uid, hashent);
	if (!ucounts) {
		spin_unlock_irq(&ucounts_lock);

		new = kzalloc(sizeof(*new), GFP_KERNEL);
		if (!new)
			return NULL;
 
 		new->ns = ns;
 		new->uid = uid;
		atomic_set(&new->count, 0);
 
 		spin_lock_irq(&ucounts_lock);
 		ucounts = find_ucounts(ns, uid, hashent);
		if (ucounts) {
			kfree(new);
		} else {
			hlist_add_head(&new->node, hashent);
 			ucounts = new;
 		}
 	}
	if (!atomic_add_unless(&ucounts->count, 1, INT_MAX))
 		ucounts = NULL;
 	spin_unlock_irq(&ucounts_lock);
 	return ucounts;
 }
",C,"		new->count = 0;
	if (ucounts->count == INT_MAX)
	else
		ucounts->count += 1;
","		atomic_set(&new->count, 0);
	if (!atomic_add_unless(&ucounts->count, 1, INT_MAX))
",,"@@ -144,7 +144,7 @@ static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)
 
 		new->ns = ns;
 		new->uid = uid;
-		atomic_set(&new->count, 0);
+		new->count = 0;
 
 		spin_lock_irq(&ucounts_lock);
 		ucounts = find_ucounts(ns, uid, hashent);
@@ -155,8 +155,10 @@ static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)
 			ucounts = new;
 		}
 	}
-	if (!atomic_add_unless(&ucounts->count, 1, INT_MAX))
+	if (ucounts->count == INT_MAX)
 		ucounts = NULL;
+	else
+		ucounts->count += 1;
 	spin_unlock_irq(&ucounts_lock);
 	return ucounts;
 }
@@ -165,13 +167,15 @@ static void put_ucounts(struct ucounts *ucounts)
 {
 	unsigned long flags;
 
-	if (atomic_dec_and_test(&ucounts->count)) {
-		spin_lock_irqsave(&ucounts_lock, flags);
+	spin_lock_irqsave(&ucounts_lock, flags);
+	ucounts->count -= 1;
+	if (!ucounts->count)
 		hlist_del_init(&ucounts->node);
-		spin_unlock_irqrestore(&ucounts_lock, flags);
+	else
+		ucounts = NULL;
+	spin_unlock_irqrestore(&ucounts_lock, flags);
 
-		kfree(ucounts);
-	}
+	kfree(ucounts);
 }
 
 static inline bool atomic_inc_below(atomic_t *v, int u)",linux,040757f738e13caaa9c5078bca79aa97e11dde88,c1ae3cfa0e89fa1a7ecc4c99031f5e9ae99d9201,1,"static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)
{
	struct hlist_head *hashent = ucounts_hashentry(ns, uid);
	struct ucounts *ucounts, *new;

	spin_lock_irq(&ucounts_lock);
	ucounts = find_ucounts(ns, uid, hashent);
	if (!ucounts) {
		spin_unlock_irq(&ucounts_lock);

		new = kzalloc(sizeof(*new), GFP_KERNEL);
		if (!new)
			return NULL;
 
 		new->ns = ns;
 		new->uid = uid;
//flaw_line_below:
		atomic_set(&new->count, 0);
//fix_flaw_line_below:
//		new->count = 0;
 
 		spin_lock_irq(&ucounts_lock);
 		ucounts = find_ucounts(ns, uid, hashent);
		if (ucounts) {
			kfree(new);
		} else {
			hlist_add_head(&new->node, hashent);
 			ucounts = new;
 		}
 	}
//flaw_line_below:
	if (!atomic_add_unless(&ucounts->count, 1, INT_MAX))
//fix_flaw_line_below:
//	if (ucounts->count == INT_MAX)
 		ucounts = NULL;
//fix_flaw_line_below:
//	else
//fix_flaw_line_below:
//		ucounts->count += 1;
 	spin_unlock_irq(&ucounts_lock);
 	return ucounts;
 }
",181487,"static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)
{
	struct hlist_head *hashent = ucounts_hashentry(ns, uid);
	struct ucounts *ucounts, *new;

	spin_lock_irq(&ucounts_lock);
	ucounts = find_ucounts(ns, uid, hashent);
	if (!ucounts) {
		spin_unlock_irq(&ucounts_lock);

		new = kzalloc(sizeof(*new), GFP_KERNEL);
		if (!new)
			return NULL;
 
 		new->ns = ns;
 		new->uid = uid;
		atomic_set(&new->count, 0);
 
 		spin_lock_irq(&ucounts_lock);
 		ucounts = find_ucounts(ns, uid, hashent);
		if (ucounts) {
			kfree(new);
		} else {
			hlist_add_head(&new->node, hashent);
 			ucounts = new;
 		}
 	}
	if (!atomic_add_unless(&ucounts->count, 1, INT_MAX))
 		ucounts = NULL;
 	spin_unlock_irq(&ucounts_lock);
 	return ucounts;
 }
","static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)
{
	struct hlist_head *hashent = ucounts_hashentry(ns, uid);
	struct ucounts *ucounts, *new;

	spin_lock_irq(&ucounts_lock);
	ucounts = find_ucounts(ns, uid, hashent);
	if (!ucounts) {
		spin_unlock_irq(&ucounts_lock);

		new = kzalloc(sizeof(*new), GFP_KERNEL);
		if (!new)
			return NULL;
 
 		new->ns = ns;
 		new->uid = uid;
		new->count = 0;
 
 		spin_lock_irq(&ucounts_lock);
 		ucounts = find_ucounts(ns, uid, hashent);
		if (ucounts) {
			kfree(new);
		} else {
			hlist_add_head(&new->node, hashent);
 			ucounts = new;
 		}
 	}
	if (ucounts->count == INT_MAX)
 		ucounts = NULL;
	else
		ucounts->count += 1;
 	spin_unlock_irq(&ucounts_lock);
 	return ucounts;
 }
","The vulnerability in the original code lies in the use of `atomic_add_unless(&ucounts->count, 1, INT_MAX)`, which could lead to an integer overflow if `ucounts->count` reaches `INT_MAX`. This could allow for unexpected behavior or exploitation, as the count could wrap around to a negative value. In the fixed code, this vulnerability is addressed by checking if `ucounts->count` is equal to `INT_MAX` before incrementing it. If it is, `ucounts` is set to `NULL`, preventing the overflow. Otherwise, the count is safely incremented using `ucounts->count += 1`.","The vulnerability in the original code stems from the potential for integer overflow when incrementing a counter that tracks resource usage. If this counter reaches its maximum value, the subsequent increment could cause it to wrap around to a negative value, leading to incorrect behavior and possible exploitation. The fixed code addresses this issue by implementing a check to determine if the counter has already reached its maximum value before attempting to increment it. If it has, the function safely returns a null value instead of proceeding with the increment, thereby preventing the overflow and ensuring more robust handling of resource limits."
30,181488,181488,,Local,Not required,Complete,CVE-2017-6874,https://www.cvedetails.com/cve/CVE-2017-6874/,CWE-416,Medium,Complete,Complete,,2017-03-14,6.9,Race condition in kernel/ucount.c in the Linux kernel through 4.10.2 allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via crafted system calls that leverage certain decrement behavior that causes incorrect interaction between put_ucounts and get_ucounts.,2017-03-15,DoS ,7,https://github.com/torvalds/linux/commit/040757f738e13caaa9c5078bca79aa97e11dde88,040757f738e13caaa9c5078bca79aa97e11dde88,"ucount: Remove the atomicity from ucount->count

Always increment/decrement ucount->count under the ucounts_lock.  The
increments are there already and moving the decrements there means the
locking logic of the code is simpler.  This simplification in the
locking logic fixes a race between put_ucounts and get_ucounts that
could result in a use-after-free because the count could go zero then
be found by get_ucounts and then be freed by put_ucounts.

A bug presumably this one was found by a combination of syzkaller and
KASAN.  JongWhan Kim reported the syzkaller failure and Dmitry Vyukov
spotted the race in the code.

Cc: stable@vger.kernel.org
Fixes: f6b2db1a3e8d (""userns: Make the count of user namespaces per user"")
Reported-by: JongHwan Kim <zzoru007@gmail.com>
Reported-by: Dmitry Vyukov <dvyukov@google.com>
Reviewed-by: Andrei Vagin <avagin@gmail.com>
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",5,kernel/ucount.c,"{""sha"": ""32354b4b4b2ba5ae72034d00c3b1d43fa8c2a15c"", ""filename"": ""include/linux/user_namespace.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/040757f738e13caaa9c5078bca79aa97e11dde88/include/linux/user_namespace.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/040757f738e13caaa9c5078bca79aa97e11dde88/include/linux/user_namespace.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/user_namespace.h?ref=040757f738e13caaa9c5078bca79aa97e11dde88"", ""patch"": ""@@ -72,7 +72,7 @@ struct ucounts {\n \tstruct hlist_node node;\n \tstruct user_namespace *ns;\n \tkuid_t uid;\n-\tatomic_t count;\n+\tint count;\n \tatomic_t ucount[UCOUNT_COUNTS];\n };\n ""}<_**next**_>{""sha"": ""b4eeee03934fe8f083b70e9907be0721759bc3be"", ""filename"": ""kernel/ucount.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 7, ""changes"": 18, ""blob_url"": ""https://github.com/torvalds/linux/blob/040757f738e13caaa9c5078bca79aa97e11dde88/kernel/ucount.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/040757f738e13caaa9c5078bca79aa97e11dde88/kernel/ucount.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/ucount.c?ref=040757f738e13caaa9c5078bca79aa97e11dde88"", ""patch"": ""@@ -144,7 +144,7 @@ static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n \n \t\tnew->ns = ns;\n \t\tnew->uid = uid;\n-\t\tatomic_set(&new->count, 0);\n+\t\tnew->count = 0;\n \n \t\tspin_lock_irq(&ucounts_lock);\n \t\tucounts = find_ucounts(ns, uid, hashent);\n@@ -155,8 +155,10 @@ static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n \t\t\tucounts = new;\n \t\t}\n \t}\n-\tif (!atomic_add_unless(&ucounts->count, 1, INT_MAX))\n+\tif (ucounts->count == INT_MAX)\n \t\tucounts = NULL;\n+\telse\n+\t\tucounts->count += 1;\n \tspin_unlock_irq(&ucounts_lock);\n \treturn ucounts;\n }\n@@ -165,13 +167,15 @@ static void put_ucounts(struct ucounts *ucounts)\n {\n \tunsigned long flags;\n \n-\tif (atomic_dec_and_test(&ucounts->count)) {\n-\t\tspin_lock_irqsave(&ucounts_lock, flags);\n+\tspin_lock_irqsave(&ucounts_lock, flags);\n+\tucounts->count -= 1;\n+\tif (!ucounts->count)\n \t\thlist_del_init(&ucounts->node);\n-\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n+\telse\n+\t\tucounts = NULL;\n+\tspin_unlock_irqrestore(&ucounts_lock, flags);\n \n-\t\tkfree(ucounts);\n-\t}\n+\tkfree(ucounts);\n }\n \n static inline bool atomic_inc_below(atomic_t *v, int u)""}","static void put_ucounts(struct ucounts *ucounts)
 {
 	unsigned long flags;
 
	spin_lock_irqsave(&ucounts_lock, flags);
	ucounts->count -= 1;
	if (!ucounts->count)
 		hlist_del_init(&ucounts->node);
	else
		ucounts = NULL;
	spin_unlock_irqrestore(&ucounts_lock, flags);
 
	kfree(ucounts);
 }
","static void put_ucounts(struct ucounts *ucounts)
 {
 	unsigned long flags;
 
	if (atomic_dec_and_test(&ucounts->count)) {
		spin_lock_irqsave(&ucounts_lock, flags);
 		hlist_del_init(&ucounts->node);
		spin_unlock_irqrestore(&ucounts_lock, flags);
 
		kfree(ucounts);
	}
 }
",C,"	spin_lock_irqsave(&ucounts_lock, flags);
	ucounts->count -= 1;
	if (!ucounts->count)
	else
		ucounts = NULL;
	spin_unlock_irqrestore(&ucounts_lock, flags);
	kfree(ucounts);
","	if (atomic_dec_and_test(&ucounts->count)) {
		spin_lock_irqsave(&ucounts_lock, flags);
		spin_unlock_irqrestore(&ucounts_lock, flags);
		kfree(ucounts);
	}
",,"@@ -144,7 +144,7 @@ static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)
 
 		new->ns = ns;
 		new->uid = uid;
-		atomic_set(&new->count, 0);
+		new->count = 0;
 
 		spin_lock_irq(&ucounts_lock);
 		ucounts = find_ucounts(ns, uid, hashent);
@@ -155,8 +155,10 @@ static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)
 			ucounts = new;
 		}
 	}
-	if (!atomic_add_unless(&ucounts->count, 1, INT_MAX))
+	if (ucounts->count == INT_MAX)
 		ucounts = NULL;
+	else
+		ucounts->count += 1;
 	spin_unlock_irq(&ucounts_lock);
 	return ucounts;
 }
@@ -165,13 +167,15 @@ static void put_ucounts(struct ucounts *ucounts)
 {
 	unsigned long flags;
 
-	if (atomic_dec_and_test(&ucounts->count)) {
-		spin_lock_irqsave(&ucounts_lock, flags);
+	spin_lock_irqsave(&ucounts_lock, flags);
+	ucounts->count -= 1;
+	if (!ucounts->count)
 		hlist_del_init(&ucounts->node);
-		spin_unlock_irqrestore(&ucounts_lock, flags);
+	else
+		ucounts = NULL;
+	spin_unlock_irqrestore(&ucounts_lock, flags);
 
-		kfree(ucounts);
-	}
+	kfree(ucounts);
 }
 
 static inline bool atomic_inc_below(atomic_t *v, int u)",linux,040757f738e13caaa9c5078bca79aa97e11dde88,c1ae3cfa0e89fa1a7ecc4c99031f5e9ae99d9201,1,"static void put_ucounts(struct ucounts *ucounts)
 {
 	unsigned long flags;
 
//flaw_line_below:
	if (atomic_dec_and_test(&ucounts->count)) {
//flaw_line_below:
		spin_lock_irqsave(&ucounts_lock, flags);
//fix_flaw_line_below:
//	spin_lock_irqsave(&ucounts_lock, flags);
//fix_flaw_line_below:
//	ucounts->count -= 1;
//fix_flaw_line_below:
//	if (!ucounts->count)
 		hlist_del_init(&ucounts->node);
//flaw_line_below:
		spin_unlock_irqrestore(&ucounts_lock, flags);
//fix_flaw_line_below:
//	else
//fix_flaw_line_below:
//		ucounts = NULL;
//fix_flaw_line_below:
//	spin_unlock_irqrestore(&ucounts_lock, flags);
 
//flaw_line_below:
		kfree(ucounts);
//flaw_line_below:
	}
//fix_flaw_line_below:
//	kfree(ucounts);
 }
",181488,"static void put_ucounts(struct ucounts *ucounts)
 {
 	unsigned long flags;
 
	if (atomic_dec_and_test(&ucounts->count)) {
		spin_lock_irqsave(&ucounts_lock, flags);
 		hlist_del_init(&ucounts->node);
		spin_unlock_irqrestore(&ucounts_lock, flags);
 
		kfree(ucounts);
	}
 }
","static void put_ucounts(struct ucounts *ucounts)
 {
 	unsigned long flags;
 
	spin_lock_irqsave(&ucounts_lock, flags);
	ucounts->count -= 1;
	if (!ucounts->count)
 		hlist_del_init(&ucounts->node);
	else
		ucounts = NULL;
	spin_unlock_irqrestore(&ucounts_lock, flags);
 
	kfree(ucounts);
 }
","The vulnerability in the original code lies in the race condition that occurs when checking `atomic_dec_and_test(&ucounts->count)` outside of the critical section protected by `spin_lock_irqsave(&ucounts_lock, flags)`. This allows multiple threads to potentially access and modify `ucounts->count` simultaneously, leading to inconsistent state and possible double-free errors. In the fixed code, the decrement operation is performed within the locked section, ensuring that the check and subsequent operations on `ucounts->count` are atomic. Additionally, the code now properly handles the case where `ucounts` is set to `NULL` if the count is not zero, preventing further operations on a potentially invalid pointer.","The vulnerability in the original code arises from a race condition that allows multiple threads to modify a shared resource without proper synchronization, potentially leading to inconsistent states and memory management issues. Specifically, the check for a condition and the subsequent actions are not enclosed within a critical section, which can result in multiple threads simultaneously accessing and altering the resource. The fixed code addresses this vulnerability by ensuring that all operations related to the shared resource are performed within a locked context, thus preventing concurrent modifications and ensuring that the resource is safely managed and freed only when appropriate."
31,181653,181653,,Remote,Not required,Partial,CVE-2016-10211,https://www.cvedetails.com/cve/CVE-2016-10211/,CWE-416,Low,,,,2017-04-03,5.0,libyara/grammar.y in YARA 3.5.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted rule that is mishandled in the yr_parser_lookup_loop_variable function.,2017-05-01,DoS ,176,https://github.com/VirusTotal/yara/commit/890c3f850293176c0e996a602ffa88b315f4e98f,890c3f850293176c0e996a602ffa88b315f4e98f,Fix issue #575,167,libyara/grammar.c,"{""sha"": ""6e5c46e5e122a2677d5839cedf873fc6c99dcd40"", ""filename"": ""libyara/grammar.c"", ""status"": ""modified"", ""additions"": 327, ""deletions"": 318, ""changes"": 645, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/890c3f850293176c0e996a602ffa88b315f4e98f/libyara/grammar.c"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/890c3f850293176c0e996a602ffa88b315f4e98f/libyara/grammar.c"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/libyara/grammar.c?ref=890c3f850293176c0e996a602ffa88b315f4e98f"", ""patch"": ""@@ -546,16 +546,16 @@ union yyalloc\n /* YYFINAL -- State number of the termination state.  */\n #define YYFINAL  2\n /* YYLAST -- Last index in YYTABLE.  */\n-#define YYLAST   408\n+#define YYLAST   406\n \n /* YYNTOKENS -- Number of terminals.  */\n #define YYNTOKENS  72\n /* YYNNTS -- Number of nonterminals.  */\n #define YYNNTS  41\n /* YYNRULES -- Number of rules.  */\n-#define YYNRULES  121\n+#define YYNRULES  122\n /* YYNSTATES -- Number of states.  */\n-#define YYNSTATES  209\n+#define YYNSTATES  210\n \n /* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned\n    by yylex, with out-of-bounds checking.  */\n@@ -612,13 +612,13 @@ static const yytype_uint16 yyrline[] =\n      472,   485,   502,   503,   509,   508,   524,   523,   539,   553,\n      554,   559,   560,   561,   562,   567,   652,   698,   756,   801,\n      802,   806,   831,   867,   913,   935,   944,   953,   968,   980,\n-     994,  1007,  1019,  1049,  1018,  1163,  1162,  1241,  1247,  1254,\n-    1253,  1316,  1315,  1376,  1385,  1394,  1403,  1412,  1421,  1430,\n-    1434,  1442,  1443,  1448,  1470,  1482,  1498,  1497,  1503,  1514,\n-    1515,  1520,  1527,  1538,  1539,  1543,  1551,  1555,  1565,  1579,\n-    1595,  1605,  1614,  1639,  1651,  1663,  1679,  1691,  1707,  1752,\n-    1771,  1789,  1807,  1825,  1851,  1869,  1879,  1889,  1899,  1909,\n-    1919,  1929\n+     994,  1007,  1018,  1024,  1054,  1023,  1168,  1167,  1246,  1252,\n+    1259,  1258,  1321,  1320,  1381,  1390,  1399,  1408,  1417,  1426,\n+    1435,  1439,  1447,  1448,  1453,  1475,  1487,  1503,  1502,  1508,\n+    1519,  1520,  1525,  1532,  1543,  1544,  1548,  1556,  1560,  1570,\n+    1584,  1600,  1610,  1619,  1644,  1656,  1668,  1684,  1696,  1712,\n+    1757,  1776,  1794,  1812,  1830,  1856,  1874,  1884,  1894,  1904,\n+    1914,  1924,  1934\n };\n #endif\n \n@@ -672,7 +672,7 @@ static const yytype_uint16 yytoknum[] =\n #define yypact_value_is_default(Yystate) \\\n   (!!((Yystate) == (-73)))\n \n-#define YYTABLE_NINF -94\n+#define YYTABLE_NINF -95\n \n #define yytable_value_is_error(Yytable_value) \\\n   0\n@@ -681,27 +681,27 @@ static const yytype_uint16 yytoknum[] =\n      STATE-NUM.  */\n static const yytype_int16 yypact[] =\n {\n-     -73,    79,   -73,   -32,    -4,   -73,   -73,    94,   -73,   -73,\n-     -73,   -73,    13,   -73,   -73,   -73,   -73,    -8,    72,     6,\n-     -73,    78,   111,   -73,    61,   122,   123,    82,   -73,    90,\n-     123,   -73,   147,   150,    16,   -73,    96,   147,   -73,   101,\n-      97,   -73,   -73,   -73,   -73,   151,    53,   -73,    48,   -73,\n-     -73,   -73,   149,   145,   -73,    -9,   -73,   103,   107,   -73,\n-     -73,   106,   -73,   -73,   -73,   -73,   -73,   -73,   110,   -73,\n-     -73,   135,    48,   135,    48,   -33,   -73,    64,   -73,   144,\n-     306,   -73,   -73,   135,   108,   135,   135,   135,   135,    -7,\n-     322,   -73,   -73,   -73,    64,   117,   163,   168,   135,    48,\n-     -73,   -73,    -6,   167,   135,   135,   135,   135,   135,   135,\n-     135,   135,   135,   135,   135,   135,   135,   135,   135,   135,\n-     135,    86,    86,   322,   135,   -73,   243,   261,   183,   203,\n-     159,    -6,   -73,   -73,   -73,   279,   121,   125,    95,    48,\n-      48,   -73,   -73,   -73,   -73,   322,   337,   351,   -43,   322,\n-     322,   322,   322,   322,   322,    40,    40,    58,    58,   -73,\n-     -73,   -73,   -73,   -73,   -73,   -73,   -73,   129,   -73,   -73,\n-     -73,   -73,   128,   -73,   -73,    48,   152,   -73,    15,   135,\n-     131,   -73,    95,   -73,   -73,    71,   -73,   223,   135,   133,\n-     -73,   132,   -73,    15,   -73,    73,   129,   -73,    48,   -73,\n-     -73,   135,   134,    31,   322,    48,   -73,    49,   -73\n+     -73,    90,   -73,   -32,   -10,   -73,   -73,    93,   -73,   -73,\n+     -73,   -73,     1,   -73,   -73,   -73,   -73,   -49,     7,   -36,\n+     -73,    20,    26,   -73,   -28,    92,    46,     4,   -73,    40,\n+      46,   -73,   100,   119,    16,   -73,    72,   100,   -73,    77,\n+      83,   -73,   -73,   -73,   -73,   134,    59,   -73,    48,   -73,\n+     -73,   -73,   133,   136,   -73,   -18,   -73,    88,    95,   -73,\n+     -73,    91,   -73,   -73,   -73,   -73,   -73,   -73,   102,   -73,\n+     -73,   126,    48,   126,    48,   -44,   -73,    85,   -73,   127,\n+     297,   -73,   -73,   126,   110,   126,   126,   126,   126,     2,\n+     313,   -73,   -73,   -73,    85,   111,   154,   172,   126,    48,\n+     -73,   -73,    -6,   162,   126,   126,   126,   126,   126,   126,\n+     126,   126,   126,   126,   126,   126,   126,   126,   126,   126,\n+     126,    60,    60,   313,   126,   -73,   234,   252,   174,   194,\n+     -73,   153,    -6,   -73,   -73,   -73,   270,   117,   120,   108,\n+      48,    48,   -73,   -73,   -73,   -73,   313,   328,   342,   349,\n+     313,   313,   313,   313,   313,   313,   113,   113,    53,    53,\n+     -73,   -73,   -73,   -73,   -73,   -73,   -73,   -73,   121,   -73,\n+     -73,   -73,   -73,   124,   -73,   -73,    48,   151,   -73,    -1,\n+     126,   125,   -73,   108,   -73,   -73,    18,   -73,   214,   126,\n+     129,   -73,   143,   -73,    -1,   -73,    63,   121,   -73,    48,\n+     -73,   -73,   126,   144,    31,   313,    48,   -73,    33,   -73\n };\n \n   /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.\n@@ -714,31 +714,31 @@ static const yytype_uint8 yydefact[] =\n       23,    22,    12,    24,     0,    14,     0,     0,    10,     0,\n       13,    25,     0,     0,     0,    26,     0,    15,    32,     0,\n        0,    28,    27,    30,    31,     0,    34,    33,     0,    11,\n-      29,    38,     0,     0,    45,    59,   103,   105,   107,   100,\n-     101,     0,   102,    53,    97,    98,    94,    95,     0,    55,\n-      56,     0,     0,     0,     0,   108,   121,    16,    54,     0,\n-      79,    39,    39,     0,     0,     0,     0,     0,     0,     0,\n-      93,   109,    68,   118,     0,    54,    79,     0,     0,    49,\n-      71,    69,     0,     0,     0,     0,     0,     0,     0,     0,\n+      29,    38,     0,     0,    45,    59,   104,   106,   108,   101,\n+     102,     0,   103,    53,    98,    99,    95,    96,     0,    55,\n+      56,     0,     0,     0,     0,   109,   122,    16,    54,     0,\n+      80,    39,    39,     0,     0,     0,     0,     0,     0,     0,\n+      94,   110,    69,   119,     0,    54,    80,     0,     0,    49,\n+      72,    70,     0,     0,     0,     0,     0,     0,     0,     0,\n        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n        0,    35,    37,    60,     0,    61,     0,     0,     0,     0,\n-       0,     0,    80,    96,    46,     0,     0,    50,    51,     0,\n-       0,    88,    86,    67,    57,    58,   117,   115,   116,    77,\n-      78,    73,    75,    74,    76,   119,   120,   110,   111,   112,\n-     113,   114,    42,    41,    43,    44,    40,     0,   104,   106,\n-      99,    62,     0,    47,    48,     0,    72,    70,     0,     0,\n-       0,    65,    52,    91,    92,     0,    89,     0,     0,     0,\n-      82,     0,    87,     0,    83,     0,    84,    63,     0,    90,\n-      81,     0,     0,     0,    85,     0,    66,     0,    64\n+      62,     0,     0,    81,    97,    46,     0,     0,    50,    51,\n+       0,     0,    89,    87,    68,    57,    58,   118,   116,   117,\n+      78,    79,    74,    76,    75,    77,   120,   121,   111,   112,\n+     113,   114,   115,    42,    41,    43,    44,    40,     0,   105,\n+     107,   100,    63,     0,    47,    48,     0,    73,    71,     0,\n+       0,     0,    66,    52,    92,    93,     0,    90,     0,     0,\n+       0,    83,     0,    88,     0,    84,     0,    85,    64,     0,\n+      91,    82,     0,     0,     0,    86,     0,    67,     0,    65\n };\n \n   /* YYPGOTO[NTERM-NUM].  */\n static const yytype_int16 yypgoto[] =\n {\n-     -73,   -73,   199,   218,   -73,   -73,   -73,   -73,   -73,   -73,\n-     -73,   -73,   -73,   -73,   192,   -73,   186,   -73,   -73,   142,\n-     -73,   -73,   -73,   -73,   126,   -48,   -72,   -73,   -73,   -73,\n-     -73,   -73,   -73,    50,   -73,   100,   -73,   -73,    35,   164,\n+     -73,   -73,   211,   212,   -73,   -73,   -73,   -73,   -73,   -73,\n+     -73,   -73,   -73,   -73,   189,   -73,   183,   -73,   -73,   139,\n+     -73,   -73,   -73,   -73,   130,   -48,   -72,   -73,   -73,   -73,\n+     -73,   -73,   -73,    41,   -73,   103,   -73,   -73,    29,   164,\n      -67\n };\n \n@@ -747,8 +747,8 @@ static const yytype_int16 yydefgoto[] =\n {\n       -1,     1,     5,     6,    17,    33,    25,    28,    40,     7,\n       15,    19,    21,    30,    31,    37,    38,    52,    53,   121,\n-     166,    75,   136,   137,    76,    94,    78,   180,   202,   191,\n-     140,   139,   189,   125,   195,   143,   178,   185,   186,    79,\n+     167,    75,   137,   138,    76,    94,    78,   181,   203,   192,\n+     141,   140,   190,   125,   196,   144,   179,   186,   187,    79,\n       80\n };\n \n@@ -757,92 +757,92 @@ static const yytype_int16 yydefgoto[] =\n      number is the opposite.  If YYTABLE_NINF, syntax error.  */\n static const yytype_int16 yytable[] =\n {\n-      77,    90,    95,   130,    91,     4,    93,    96,   114,   115,\n-     116,   117,   118,   119,   120,    11,   123,    83,   126,   127,\n-     128,   129,    84,    16,    92,   131,   183,   138,   141,     8,\n-     184,   135,    41,    97,    98,    42,    99,   145,   146,   147,\n-     148,   149,   150,   151,   152,   153,   154,   155,   156,   157,\n-     158,   159,   160,   161,    43,    44,    18,   167,    54,    55,\n-      56,    57,    58,   142,    59,    60,    61,    62,    22,    63,\n-      45,   100,   101,    51,   -36,    64,    65,    66,    67,     2,\n-       3,    68,    20,   -17,   -17,   -17,    69,    70,    23,   100,\n-     101,   176,   177,   116,   117,   118,   119,   120,    12,    13,\n-      14,   206,    71,   182,   100,   101,    72,    73,   162,   163,\n-     164,   165,   187,   118,   119,   120,     4,    74,    24,   208,\n-      54,   196,    56,    57,    58,    26,    59,    60,    61,    62,\n-      27,    63,   179,    29,   204,   -54,   -54,    64,    65,    66,\n-      67,   192,   193,   200,   201,    54,    32,    56,    57,    58,\n-     203,    59,    60,    61,    62,    34,    63,   207,    36,    39,\n-      49,    46,    64,    65,    71,    48,    82,    50,    81,    73,\n-      85,   105,   106,   107,    86,    87,   102,   124,   134,    88,\n-     114,   115,   116,   117,   118,   119,   120,   132,    63,    71,\n-     171,   174,   181,   101,    73,   -93,   175,   197,   103,   104,\n-     188,   198,     9,   205,    88,   105,   106,   107,   108,   109,\n-     110,   111,   112,   113,   114,   115,   116,   117,   118,   119,\n-     120,    10,    35,    47,   122,   105,   106,   107,   199,   144,\n-     190,   172,    89,   133,   114,   115,   116,   117,   118,   119,\n-     120,     0,     0,     0,     0,   105,   106,   107,     0,     0,\n-       0,     0,     0,   170,   114,   115,   116,   117,   118,   119,\n-     120,     0,     0,     0,     0,   105,   106,   107,     0,     0,\n-       0,     0,     0,   133,   114,   115,   116,   117,   118,   119,\n-     120,     0,     0,     0,     0,   105,   106,   107,     0,     0,\n-       0,     0,     0,   194,   114,   115,   116,   117,   118,   119,\n-     120,     0,     0,   105,   106,   107,     0,     0,     0,     0,\n-       0,   168,   114,   115,   116,   117,   118,   119,   120,     0,\n-       0,   105,   106,   107,     0,     0,     0,     0,     0,   169,\n-     114,   115,   116,   117,   118,   119,   120,     0,   -93,     0,\n-       0,   103,   104,     0,     0,     0,     0,   173,   105,   106,\n-     107,   108,   109,   110,   111,   112,   113,   114,   115,   116,\n-     117,   118,   119,   120,   105,   106,   107,     0,     0,     0,\n+      77,    90,    95,   130,    91,     4,    93,    96,    83,    11,\n+     184,    16,   131,    84,   185,    18,   123,    20,   126,   127,\n+     128,   129,    97,    98,    92,    99,    22,   139,   142,     8,\n+      23,   136,    41,    24,   132,    42,    26,   146,   147,   148,\n+     149,   150,   151,   152,   153,   154,   155,   156,   157,   158,\n+     159,   160,   161,   162,    43,    44,    29,   168,    54,    55,\n+      56,    57,    58,   143,    59,    60,    61,    62,    32,    63,\n+      45,   100,   101,   100,   101,    64,    65,    66,    67,    51,\n+     -36,    68,   163,   164,   165,   166,    69,    70,   193,   194,\n+       2,     3,   177,   178,   -17,   -17,   -17,    12,    13,    14,\n+      27,   207,    71,   209,   183,    34,    72,    73,   118,   119,\n+     120,    36,    54,   188,    56,    57,    58,    74,    59,    60,\n+      61,    62,   197,    63,   180,   100,   101,     4,    39,    64,\n+      65,    66,    67,   201,   202,   205,    54,    46,    56,    57,\n+      58,    48,    59,    60,    61,    62,    49,    63,   -54,   -54,\n+      50,   204,    81,    64,    65,    85,    71,    82,   208,   102,\n+      87,    73,    86,   105,   106,   107,   116,   117,   118,   119,\n+     120,    88,   114,   115,   116,   117,   118,   119,   120,   124,\n+      71,   133,   135,    63,   172,    73,   -94,   175,   182,   103,\n+     104,   176,   101,   198,   189,    88,   105,   106,   107,   108,\n+     109,   110,   111,   112,   113,   114,   115,   116,   117,   118,\n+     119,   120,   199,   206,     9,    10,   105,   106,   107,    35,\n+      47,   122,   191,   200,   134,   114,   115,   116,   117,   118,\n+     119,   120,    89,   145,     0,   173,   105,   106,   107,     0,\n+       0,     0,     0,     0,   171,   114,   115,   116,   117,   118,\n+     119,   120,     0,     0,     0,     0,   105,   106,   107,     0,\n+       0,     0,     0,     0,   134,   114,   115,   116,   117,   118,\n+     119,   120,     0,     0,     0,     0,   105,   106,   107,     0,\n+       0,     0,     0,     0,   195,   114,   115,   116,   117,   118,\n+     119,   120,     0,     0,   105,   106,   107,     0,     0,     0,\n+       0,     0,   169,   114,   115,   116,   117,   118,   119,   120,\n+       0,     0,   105,   106,   107,     0,     0,     0,     0,     0,\n+     170,   114,   115,   116,   117,   118,   119,   120,     0,   -94,\n+       0,     0,   103,   104,     0,     0,     0,     0,   174,   105,\n+     106,   107,   108,   109,   110,   111,   112,   113,   114,   115,\n+     116,   117,   118,   119,   120,   105,   106,   107,     0,     0,\n+       0,     0,     0,     0,   114,   115,   116,   117,   118,   119,\n+     120,   106,   107,     0,     0,     0,     0,     0,     0,   114,\n+     115,   116,   117,   118,   119,   120,   107,     0,     0,     0,\n        0,     0,     0,   114,   115,   116,   117,   118,   119,   120,\n-     106,   107,     0,     0,     0,     0,     0,     0,   114,   115,\n-     116,   117,   118,   119,   120,   107,     0,     0,     0,     0,\n-       0,     0,   114,   115,   116,   117,   118,   119,   120\n+     114,   115,   116,   117,   118,   119,   120\n };\n \n static const yytype_int16 yycheck[] =\n {\n-      48,    68,    74,    10,    71,    37,    73,    74,    51,    52,\n-      53,    54,    55,    56,    57,    19,    83,    26,    85,    86,\n-      87,    88,    31,    10,    72,    32,    11,    99,    34,    61,\n-      15,    98,    16,    66,    67,    19,    69,   104,   105,   106,\n+      48,    68,    74,     1,    71,    37,    73,    74,    26,    19,\n+      11,    10,    10,    31,    15,    64,    83,    10,    85,    86,\n+      87,    88,    66,    67,    72,    69,    62,    99,    34,    61,\n+      10,    98,    16,     7,    32,    19,    64,   104,   105,   106,\n      107,   108,   109,   110,   111,   112,   113,   114,   115,   116,\n-     117,   118,   119,   120,    38,    39,    64,   124,    10,    11,\n-      12,    13,    14,    69,    16,    17,    18,    19,    62,    21,\n-      54,    40,    41,    20,    21,    27,    28,    29,    30,     0,\n-       1,    33,    10,     4,     5,     6,    38,    39,    10,    40,\n-      41,   139,   140,    53,    54,    55,    56,    57,     4,     5,\n-       6,    70,    54,   175,    40,    41,    58,    59,    22,    23,\n-      24,    25,   179,    55,    56,    57,    37,    69,     7,    70,\n-      10,   188,    12,    13,    14,    64,    16,    17,    18,    19,\n-       8,    21,     3,    10,   201,    40,    41,    27,    28,    29,\n-      30,    70,    71,    70,    71,    10,    64,    12,    13,    14,\n-     198,    16,    17,    18,    19,    65,    21,   205,    11,     9,\n-      63,    65,    27,    28,    54,    64,    21,    16,    19,    59,\n-      67,    42,    43,    44,    67,    69,    32,    69,    10,    69,\n-      51,    52,    53,    54,    55,    56,    57,    70,    21,    54,\n-      31,    70,    64,    41,    59,    32,    71,    64,    35,    36,\n-      69,    69,     3,    69,    69,    42,    43,    44,    45,    46,\n-      47,    48,    49,    50,    51,    52,    53,    54,    55,    56,\n-      57,     3,    30,    37,    82,    42,    43,    44,   193,   103,\n-     180,   131,    68,    70,    51,    52,    53,    54,    55,    56,\n-      57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,    -1,\n-      -1,    -1,    -1,    70,    51,    52,    53,    54,    55,    56,\n-      57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,    -1,\n-      -1,    -1,    -1,    70,    51,    52,    53,    54,    55,    56,\n-      57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,    -1,\n-      -1,    -1,    -1,    70,    51,    52,    53,    54,    55,    56,\n-      57,    -1,    -1,    42,    43,    44,    -1,    -1,    -1,    -1,\n-      -1,    68,    51,    52,    53,    54,    55,    56,    57,    -1,\n-      -1,    42,    43,    44,    -1,    -1,    -1,    -1,    -1,    68,\n-      51,    52,    53,    54,    55,    56,    57,    -1,    32,    -1,\n-      -1,    35,    36,    -1,    -1,    -1,    -1,    68,    42,    43,\n-      44,    45,    46,    47,    48,    49,    50,    51,    52,    53,\n-      54,    55,    56,    57,    42,    43,    44,    -1,    -1,    -1,\n+     117,   118,   119,   120,    38,    39,    10,   124,    10,    11,\n+      12,    13,    14,    69,    16,    17,    18,    19,    64,    21,\n+      54,    40,    41,    40,    41,    27,    28,    29,    30,    20,\n+      21,    33,    22,    23,    24,    25,    38,    39,    70,    71,\n+       0,     1,   140,   141,     4,     5,     6,     4,     5,     6,\n+       8,    70,    54,    70,   176,    65,    58,    59,    55,    56,\n+      57,    11,    10,   180,    12,    13,    14,    69,    16,    17,\n+      18,    19,   189,    21,     3,    40,    41,    37,     9,    27,\n+      28,    29,    30,    70,    71,   202,    10,    65,    12,    13,\n+      14,    64,    16,    17,    18,    19,    63,    21,    40,    41,\n+      16,   199,    19,    27,    28,    67,    54,    21,   206,    32,\n+      69,    59,    67,    42,    43,    44,    53,    54,    55,    56,\n+      57,    69,    51,    52,    53,    54,    55,    56,    57,    69,\n+      54,    70,    10,    21,    31,    59,    32,    70,    64,    35,\n+      36,    71,    41,    64,    69,    69,    42,    43,    44,    45,\n+      46,    47,    48,    49,    50,    51,    52,    53,    54,    55,\n+      56,    57,    69,    69,     3,     3,    42,    43,    44,    30,\n+      37,    82,   181,   194,    70,    51,    52,    53,    54,    55,\n+      56,    57,    68,   103,    -1,   132,    42,    43,    44,    -1,\n+      -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,    55,\n+      56,    57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,\n+      -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,    55,\n+      56,    57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,\n+      -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,    55,\n+      56,    57,    -1,    -1,    42,    43,    44,    -1,    -1,    -1,\n+      -1,    -1,    68,    51,    52,    53,    54,    55,    56,    57,\n+      -1,    -1,    42,    43,    44,    -1,    -1,    -1,    -1,    -1,\n+      68,    51,    52,    53,    54,    55,    56,    57,    -1,    32,\n+      -1,    -1,    35,    36,    -1,    -1,    -1,    -1,    68,    42,\n+      43,    44,    45,    46,    47,    48,    49,    50,    51,    52,\n+      53,    54,    55,    56,    57,    42,    43,    44,    -1,    -1,\n+      -1,    -1,    -1,    -1,    51,    52,    53,    54,    55,    56,\n+      57,    43,    44,    -1,    -1,    -1,    -1,    -1,    -1,    51,\n+      52,    53,    54,    55,    56,    57,    44,    -1,    -1,    -1,\n       -1,    -1,    -1,    51,    52,    53,    54,    55,    56,    57,\n-      43,    44,    -1,    -1,    -1,    -1,    -1,    -1,    51,    52,\n-      53,    54,    55,    56,    57,    44,    -1,    -1,    -1,    -1,\n-      -1,    -1,    51,    52,    53,    54,    55,    56,    57\n+      51,    52,    53,    54,    55,    56,    57\n };\n \n   /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing\n@@ -862,14 +862,14 @@ static const yytype_uint8 yystos[] =\n       40,    41,    32,    35,    36,    42,    43,    44,    45,    46,\n       47,    48,    49,    50,    51,    52,    53,    54,    55,    56,\n       57,    91,    91,   112,    69,   105,   112,   112,   112,   112,\n-      10,    32,    70,    70,    10,   112,    94,    95,    98,   103,\n-     102,    34,    69,   107,    96,   112,   112,   112,   112,   112,\n+       1,    10,    32,    70,    70,    10,   112,    94,    95,    98,\n+     103,   102,    34,    69,   107,    96,   112,   112,   112,   112,\n      112,   112,   112,   112,   112,   112,   112,   112,   112,   112,\n-     112,   112,    22,    23,    24,    25,    92,   112,    68,    68,\n-      70,    31,   107,    68,    70,    71,    97,    97,   108,     3,\n-      99,    64,    98,    11,    15,   109,   110,   112,    69,   104,\n-     105,   101,    70,    71,    70,   106,   112,    64,    69,   110,\n-      70,    71,   100,    97,   112,    69,    70,    97,    70\n+     112,   112,   112,    22,    23,    24,    25,    92,   112,    68,\n+      68,    70,    31,   107,    68,    70,    71,    97,    97,   108,\n+       3,    99,    64,    98,    11,    15,   109,   110,   112,    69,\n+     104,   105,   101,    70,    71,    70,   106,   112,    64,    69,\n+     110,    70,    71,   100,    97,   112,    69,    70,    97,    70\n };\n \n   /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */\n@@ -881,13 +881,13 @@ static const yytype_uint8 yyr1[] =\n       86,    86,    87,    87,    89,    88,    90,    88,    88,    91,\n       91,    92,    92,    92,    92,    93,    93,    93,    93,    94,\n       94,    95,    95,    96,    97,    98,    98,    98,    98,    98,\n-      98,    98,    99,   100,    98,   101,    98,    98,    98,   102,\n-      98,   103,    98,    98,    98,    98,    98,    98,    98,    98,\n-      98,   104,   104,   105,   106,   106,   108,   107,   107,   109,\n-     109,   110,   110,   111,   111,   111,   112,   112,   112,   112,\n+      98,    98,    98,    99,   100,    98,   101,    98,    98,    98,\n+     102,    98,   103,    98,    98,    98,    98,    98,    98,    98,\n+      98,    98,   104,   104,   105,   106,   106,   108,   107,   107,\n+     109,   109,   110,   110,   111,   111,   111,   112,   112,   112,\n      112,   112,   112,   112,   112,   112,   112,   112,   112,   112,\n      112,   112,   112,   112,   112,   112,   112,   112,   112,   112,\n-     112,   112\n+     112,   112,   112\n };\n \n   /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */\n@@ -899,13 +899,13 @@ static const yytype_uint8 yyr2[] =\n        3,     3,     1,     2,     0,     5,     0,     5,     3,     0,\n        2,     1,     1,     1,     1,     1,     3,     4,     4,     0,\n        1,     1,     3,     1,     1,     1,     1,     3,     3,     1,\n-       3,     3,     0,     0,    11,     0,     9,     3,     2,     0,\n-       4,     0,     4,     3,     3,     3,     3,     3,     3,     1,\n-       3,     3,     1,     5,     1,     3,     0,     4,     1,     1,\n-       3,     1,     1,     1,     1,     1,     3,     1,     1,     4,\n-       1,     1,     1,     1,     4,     1,     4,     1,     1,     2,\n-       3,     3,     3,     3,     3,     3,     3,     3,     2,     3,\n-       3,     1\n+       3,     3,     3,     0,     0,    11,     0,     9,     3,     2,\n+       0,     4,     0,     4,     3,     3,     3,     3,     3,     3,\n+       1,     3,     3,     1,     5,     1,     3,     0,     4,     1,\n+       1,     3,     1,     1,     1,     1,     1,     3,     1,     1,\n+       4,     1,     1,     1,     1,     4,     1,     4,     1,     1,\n+       2,     3,     3,     3,     3,     3,     3,     3,     3,     2,\n+       3,     3,     1\n };\n \n \n@@ -2586,6 +2586,15 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n   case 62:\n #line 1019 \""grammar.y\"" /* yacc.c:1646  */\n+    {\n+        compiler->loop_depth--;\n+        compiler->loop_identifier[compiler->loop_depth] = NULL;\n+      }\n+#line 2594 \""grammar.c\"" /* yacc.c:1646  */\n+    break;\n+\n+  case 63:\n+#line 1024 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         int var_index;\n \n@@ -2615,11 +2624,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 2619 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2628 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 63:\n-#line 1049 \""grammar.y\"" /* yacc.c:1646  */\n+  case 64:\n+#line 1054 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n         uint8_t* addr;\n@@ -2654,11 +2663,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);\n         compiler->loop_depth++;\n       }\n-#line 2658 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2667 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 64:\n-#line 1084 \""grammar.y\"" /* yacc.c:1646  */\n+  case 65:\n+#line 1089 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         int mem_offset;\n \n@@ -2737,11 +2746,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2741 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2750 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 65:\n-#line 1163 \""grammar.y\"" /* yacc.c:1646  */\n+  case 66:\n+#line 1168 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n         uint8_t* addr;\n@@ -2771,11 +2780,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         compiler->loop_identifier[compiler->loop_depth] = NULL;\n         compiler->loop_depth++;\n       }\n-#line 2775 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2784 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 66:\n-#line 1193 \""grammar.y\"" /* yacc.c:1646  */\n+  case 67:\n+#line 1198 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         int mem_offset;\n \n@@ -2824,31 +2833,31 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n \n       }\n-#line 2828 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2837 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 67:\n-#line 1242 \""grammar.y\"" /* yacc.c:1646  */\n+  case 68:\n+#line 1247 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         yr_parser_emit(yyscanner, OP_OF, NULL);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2838 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2847 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 68:\n-#line 1248 \""grammar.y\"" /* yacc.c:1646  */\n+  case 69:\n+#line 1253 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         yr_parser_emit(yyscanner, OP_NOT, NULL);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2848 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2857 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 69:\n-#line 1254 \""grammar.y\"" /* yacc.c:1646  */\n+  case 70:\n+#line 1259 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         void* jmp_destination_addr;\n@@ -2874,11 +2883,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         fixup->next = compiler->fixup_stack_head;\n         compiler->fixup_stack_head = fixup;\n       }\n-#line 2878 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2887 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 70:\n-#line 1280 \""grammar.y\"" /* yacc.c:1646  */\n+  case 71:\n+#line 1285 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         uint8_t* and_addr;\n@@ -2914,11 +2923,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2918 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2927 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 71:\n-#line 1316 \""grammar.y\"" /* yacc.c:1646  */\n+  case 72:\n+#line 1321 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         void* jmp_destination_addr;\n@@ -2943,11 +2952,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         fixup->next = compiler->fixup_stack_head;\n         compiler->fixup_stack_head = fixup;\n       }\n-#line 2947 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2956 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 72:\n-#line 1341 \""grammar.y\"" /* yacc.c:1646  */\n+  case 73:\n+#line 1346 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         uint8_t* or_addr;\n@@ -2983,11 +2992,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2987 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2996 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 73:\n-#line 1377 \""grammar.y\"" /* yacc.c:1646  */\n+  case 74:\n+#line 1382 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \""<\"", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -2996,11 +3005,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 3000 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3009 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 74:\n-#line 1386 \""grammar.y\"" /* yacc.c:1646  */\n+  case 75:\n+#line 1391 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"">\"", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3009,11 +3018,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 3013 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3022 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 75:\n-#line 1395 \""grammar.y\"" /* yacc.c:1646  */\n+  case 76:\n+#line 1400 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \""<=\"", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3022,11 +3031,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 3026 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3035 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 76:\n-#line 1404 \""grammar.y\"" /* yacc.c:1646  */\n+  case 77:\n+#line 1409 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"">=\"", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3035,11 +3044,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 3039 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3048 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 77:\n-#line 1413 \""grammar.y\"" /* yacc.c:1646  */\n+  case 78:\n+#line 1418 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \""==\"", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3048,11 +3057,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 3052 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3061 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 78:\n-#line 1422 \""grammar.y\"" /* yacc.c:1646  */\n+  case 79:\n+#line 1427 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \""!=\"", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3061,39 +3070,39 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 3065 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3074 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 79:\n-#line 1431 \""grammar.y\"" /* yacc.c:1646  */\n+  case 80:\n+#line 1436 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[0].expression);\n       }\n-#line 3073 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3082 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 80:\n-#line 1435 \""grammar.y\"" /* yacc.c:1646  */\n+  case 81:\n+#line 1440 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[-1].expression);\n       }\n-#line 3081 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3090 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 81:\n-#line 1442 \""grammar.y\"" /* yacc.c:1646  */\n+  case 82:\n+#line 1447 \""grammar.y\"" /* yacc.c:1646  */\n     { (yyval.integer) = INTEGER_SET_ENUMERATION; }\n-#line 3087 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3096 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 82:\n-#line 1443 \""grammar.y\"" /* yacc.c:1646  */\n+  case 83:\n+#line 1448 \""grammar.y\"" /* yacc.c:1646  */\n     { (yyval.integer) = INTEGER_SET_RANGE; }\n-#line 3093 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3102 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 83:\n-#line 1449 \""grammar.y\"" /* yacc.c:1646  */\n+  case 84:\n+#line 1454 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n@@ -3111,11 +3120,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3115 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3124 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 84:\n-#line 1471 \""grammar.y\"" /* yacc.c:1646  */\n+  case 85:\n+#line 1476 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n@@ -3127,11 +3136,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3131 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3140 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 85:\n-#line 1483 \""grammar.y\"" /* yacc.c:1646  */\n+  case 86:\n+#line 1488 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n@@ -3142,77 +3151,77 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3146 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3155 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 86:\n-#line 1498 \""grammar.y\"" /* yacc.c:1646  */\n+  case 87:\n+#line 1503 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         // Push end-of-list marker\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n       }\n-#line 3155 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3164 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 88:\n-#line 1504 \""grammar.y\"" /* yacc.c:1646  */\n+  case 89:\n+#line 1509 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n         yr_parser_emit_pushes_for_strings(yyscanner, \""$*\"");\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3166 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3175 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 91:\n-#line 1521 \""grammar.y\"" /* yacc.c:1646  */\n+  case 92:\n+#line 1526 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n         yr_free((yyvsp[0].c_string));\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3177 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3186 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 92:\n-#line 1528 \""grammar.y\"" /* yacc.c:1646  */\n+  case 93:\n+#line 1533 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n         yr_free((yyvsp[0].c_string));\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3188 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3197 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 94:\n-#line 1540 \""grammar.y\"" /* yacc.c:1646  */\n+  case 95:\n+#line 1545 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n       }\n-#line 3196 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3205 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 95:\n-#line 1544 \""grammar.y\"" /* yacc.c:1646  */\n+  case 96:\n+#line 1549 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);\n       }\n-#line 3204 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3213 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 96:\n-#line 1552 \""grammar.y\"" /* yacc.c:1646  */\n+  case 97:\n+#line 1557 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[-1].expression);\n       }\n-#line 3212 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3221 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 97:\n-#line 1556 \""grammar.y\"" /* yacc.c:1646  */\n+  case 98:\n+#line 1561 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit(\n             yyscanner, OP_FILESIZE, NULL);\n@@ -3222,11 +3231,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3226 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3235 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 98:\n-#line 1566 \""grammar.y\"" /* yacc.c:1646  */\n+  case 99:\n+#line 1571 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         yywarning(yyscanner,\n             \""Using deprecated \\\""entrypoint\\\"" keyword. Use the \\\""entry_point\\\"" \""\n@@ -3240,11 +3249,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3244 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3253 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 99:\n-#line 1580 \""grammar.y\"" /* yacc.c:1646  */\n+  case 100:\n+#line 1585 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, \""intXXXX or uintXXXX\"");\n \n@@ -3260,11 +3269,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3264 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3273 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 100:\n-#line 1596 \""grammar.y\"" /* yacc.c:1646  */\n+  case 101:\n+#line 1601 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);\n@@ -3274,11 +3283,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = (yyvsp[0].integer);\n       }\n-#line 3278 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3287 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 101:\n-#line 1606 \""grammar.y\"" /* yacc.c:1646  */\n+  case 102:\n+#line 1611 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg_double(\n             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);\n@@ -3287,11 +3296,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n       }\n-#line 3291 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3300 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 102:\n-#line 1615 \""grammar.y\"" /* yacc.c:1646  */\n+  case 103:\n+#line 1620 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         SIZED_STRING* sized_string;\n \n@@ -3316,11 +3325,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_STRING;\n         (yyval.expression).value.sized_string = sized_string;\n       }\n-#line 3320 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3329 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 103:\n-#line 1640 \""grammar.y\"" /* yacc.c:1646  */\n+  case 104:\n+#line 1645 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);\n@@ -3332,11 +3341,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3336 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3345 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 104:\n-#line 1652 \""grammar.y\"" /* yacc.c:1646  */\n+  case 105:\n+#line 1657 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);\n@@ -3348,11 +3357,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3352 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3361 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 105:\n-#line 1664 \""grammar.y\"" /* yacc.c:1646  */\n+  case 106:\n+#line 1669 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 1, NULL, NULL);\n@@ -3368,11 +3377,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3372 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3381 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 106:\n-#line 1680 \""grammar.y\"" /* yacc.c:1646  */\n+  case 107:\n+#line 1685 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);\n@@ -3384,11 +3393,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3388 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3397 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 107:\n-#line 1692 \""grammar.y\"" /* yacc.c:1646  */\n+  case 108:\n+#line 1697 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 1, NULL, NULL);\n@@ -3404,11 +3413,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3408 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3417 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 108:\n-#line 1708 \""grammar.y\"" /* yacc.c:1646  */\n+  case 109:\n+#line 1713 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier\n         {\n@@ -3453,11 +3462,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3457 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3466 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 109:\n-#line 1753 \""grammar.y\"" /* yacc.c:1646  */\n+  case 110:\n+#line 1758 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, \""-\"");\n \n@@ -3476,11 +3485,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3480 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3489 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 110:\n-#line 1772 \""grammar.y\"" /* yacc.c:1646  */\n+  case 111:\n+#line 1777 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \""+\"", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3498,11 +3507,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n-#line 3502 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3511 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 111:\n-#line 1790 \""grammar.y\"" /* yacc.c:1646  */\n+  case 112:\n+#line 1795 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \""-\"", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3520,11 +3529,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n-#line 3524 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3533 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 112:\n-#line 1808 \""grammar.y\"" /* yacc.c:1646  */\n+  case 113:\n+#line 1813 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \""*\"", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3542,11 +3551,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n-#line 3546 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3555 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 113:\n-#line 1826 \""grammar.y\"" /* yacc.c:1646  */\n+  case 114:\n+#line 1831 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \""\\\\\"", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3572,11 +3581,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n-#line 3576 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3585 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 114:\n-#line 1852 \""grammar.y\"" /* yacc.c:1646  */\n+  case 115:\n+#line 1857 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \""%\"");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \""%\"");\n@@ -3594,11 +3603,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n           ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n         }\n       }\n-#line 3598 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3607 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 115:\n-#line 1870 \""grammar.y\"" /* yacc.c:1646  */\n+  case 116:\n+#line 1875 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \""^\"");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \""^\"");\n@@ -3608,11 +3617,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n-#line 3612 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3621 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 116:\n-#line 1880 \""grammar.y\"" /* yacc.c:1646  */\n+  case 117:\n+#line 1885 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \""^\"");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \""^\"");\n@@ -3622,11 +3631,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n-#line 3626 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3635 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 117:\n-#line 1890 \""grammar.y\"" /* yacc.c:1646  */\n+  case 118:\n+#line 1895 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \""|\"");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \""|\"");\n@@ -3636,11 +3645,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n-#line 3640 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3649 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 118:\n-#line 1900 \""grammar.y\"" /* yacc.c:1646  */\n+  case 119:\n+#line 1905 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \""~\"");\n \n@@ -3650,11 +3659,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\n             UNDEFINED : ~((yyvsp[0].expression).value.integer);\n       }\n-#line 3654 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3663 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 119:\n-#line 1910 \""grammar.y\"" /* yacc.c:1646  */\n+  case 120:\n+#line 1915 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \""<<\"");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \""<<\"");\n@@ -3664,11 +3673,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n-#line 3668 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3677 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 120:\n-#line 1920 \""grammar.y\"" /* yacc.c:1646  */\n+  case 121:\n+#line 1925 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"">>\"");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"">>\"");\n@@ -3678,19 +3687,19 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n-#line 3682 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3691 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 121:\n-#line 1930 \""grammar.y\"" /* yacc.c:1646  */\n+  case 122:\n+#line 1935 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[0].expression);\n       }\n-#line 3690 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3699 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n \n-#line 3694 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3703 \""grammar.c\"" /* yacc.c:1646  */\n       default: break;\n     }\n   /* User semantic actions sometimes alter yychar, and that requires\n@@ -3918,5 +3927,5 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n #endif\n   return yyresult;\n }\n-#line 1935 \""grammar.y\"" /* yacc.c:1906  */\n+#line 1940 \""grammar.y\"" /* yacc.c:1906  */\n ""}<_**next**_>{""sha"": ""446d37410e0aa33e663f2547406d353290f213a4"", ""filename"": ""libyara/grammar.y"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/890c3f850293176c0e996a602ffa88b315f4e98f/libyara/grammar.y"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/890c3f850293176c0e996a602ffa88b315f4e98f/libyara/grammar.y"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/libyara/grammar.y?ref=890c3f850293176c0e996a602ffa88b315f4e98f"", ""patch"": ""@@ -1015,6 +1015,11 @@ expression\n \n         $$.type = EXPRESSION_TYPE_BOOLEAN;\n       }\n+    | _FOR_ for_expression error\n+      {\n+        compiler->loop_depth--;\n+        compiler->loop_identifier[compiler->loop_depth] = NULL;\n+      }\n     | _FOR_ for_expression _IDENTIFIER_ _IN_\n       {\n         int var_index;""}","yyparse (void *yyscanner, YR_COMPILER* compiler)
{
/* The lookahead symbol.  */
int yychar;


/* The semantic value of the lookahead symbol.  */
/* Default value used for initialization, for pacifying older GCCs
   or non-GCC compilers.  */
YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);

    /* Number of syntax errors so far.  */
    int yynerrs;

    int yystate;
    /* Number of tokens to shift before error messages enabled.  */
    int yyerrstatus;

    /* The stacks and their tools:
       'yyss': related to states.
       'yyvs': related to semantic values.

       Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */

    /* The state stack.  */
    yytype_int16 yyssa[YYINITDEPTH];
    yytype_int16 *yyss;
    yytype_int16 *yyssp;

    /* The semantic value stack.  */
    YYSTYPE yyvsa[YYINITDEPTH];
    YYSTYPE *yyvs;
    YYSTYPE *yyvsp;

    YYSIZE_T yystacksize;

  int yyn;
  int yyresult;
  /* Lookahead token as an internal (translated) token number.  */
  int yytoken = 0;
  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;

#if YYERROR_VERBOSE
  /* Buffer for error messages, and its allocated size.  */
  char yymsgbuf[128];
  char *yymsg = yymsgbuf;
  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
#endif

#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))

  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  yyssp = yyss = yyssa;
  yyvsp = yyvs = yyvsa;
  yystacksize = YYINITDEPTH;

  YYDPRINTF ((stderr, ""Starting parse\n""));

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY; /* Cause a token to be read.  */
  goto yysetstate;

/*------------------------------------------------------------.
| yynewstate -- Push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
 yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;

 yysetstate:
  *yyssp = yystate;

  if (yyss + yystacksize - 1 <= yyssp)
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYSIZE_T yysize = yyssp - yyss + 1;

#ifdef yyoverflow
      {
        /* Give user a chance to reallocate the stack.  Use copies of
           these so that the &'s don't force the real ones into
           memory.  */
        YYSTYPE *yyvs1 = yyvs;
        yytype_int16 *yyss1 = yyss;

        /* Each stack pointer address is followed by the size of the
           data in use in that stack, in bytes.  This used to be a
           conditional around just the two extra args, but that might
           be undefined if yyoverflow is a macro.  */
        yyoverflow (YY_(""memory exhausted""),
                    &yyss1, yysize * sizeof (*yyssp),
                    &yyvs1, yysize * sizeof (*yyvsp),
                    &yystacksize);

        yyss = yyss1;
        yyvs = yyvs1;
      }
#else /* no yyoverflow */
# ifndef YYSTACK_RELOCATE
      goto yyexhaustedlab;
# else
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
        goto yyexhaustedlab;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
        yystacksize = YYMAXDEPTH;

      {
        yytype_int16 *yyss1 = yyss;
        union yyalloc *yyptr =
          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
        if (! yyptr)
          goto yyexhaustedlab;
        YYSTACK_RELOCATE (yyss_alloc, yyss);
        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
#  undef YYSTACK_RELOCATE
        if (yyss1 != yyssa)
          YYSTACK_FREE (yyss1);
      }
# endif
#endif /* no yyoverflow */

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;

      YYDPRINTF ((stderr, ""Stack size increased to %lu\n"",
                  (unsigned long int) yystacksize));

      if (yyss + yystacksize - 1 <= yyssp)
        YYABORT;
    }

  YYDPRINTF ((stderr, ""Entering state %d\n"", yystate));

  if (yystate == YYFINAL)
    YYACCEPT;

  goto yybackup;

/*-----------.
| yybackup.  |
`-----------*/
yybackup:

  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, ""Reading a token: ""));
      yychar = yylex (&yylval, yyscanner, compiler);
    }

  if (yychar <= YYEOF)
    {
      yychar = yytoken = YYEOF;
      YYDPRINTF ((stderr, ""Now at end of input.\n""));
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT (""Next token is"", yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT (""Shifting"", yytoken, &yylval, &yylloc);

  /* Discard the shifted token.  */
  yychar = YYEMPTY;

  yystate = yyn;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END

  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- Do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     '$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
        case 8:
#line 230 ""grammar.y"" /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));

        yr_free((yyvsp[0].sized_string));

        ERROR_IF(result != ERROR_SUCCESS);
      }
#line 1661 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 9:
#line 242 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(
            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));

        ERROR_IF(rule == NULL);

        (yyval.rule) = rule;
      }
#line 1674 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 10:
#line 251 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1

        rule->tags = (yyvsp[-3].c_string);
        rule->metas = (yyvsp[-1].meta);
        rule->strings = (yyvsp[0].string);
      }
#line 1686 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 11:
#line 259 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-7].rule); // rule created in phase 1

        compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(
            yyscanner, rule);

        yr_free((yyvsp[-8].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1701 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 12:
#line 274 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = NULL;
      }
#line 1709 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 13:
#line 278 ""grammar.y"" /* yacc.c:1646  */
    {

        YR_META null_meta;

        memset(&null_meta, 0xFF, sizeof(YR_META));
        null_meta.type = META_TYPE_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->metas_arena,
            &null_meta,
            sizeof(YR_META),
            NULL);

        (yyval.meta) = (yyvsp[0].meta);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1736 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 14:
#line 305 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = NULL;
      }
#line 1744 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 15:
#line 309 ""grammar.y"" /* yacc.c:1646  */
    {

        YR_STRING null_string;

        memset(&null_string, 0xFF, sizeof(YR_STRING));
        null_string.g_flags = STRING_GFLAGS_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->strings_arena,
            &null_string,
            sizeof(YR_STRING),
            NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.string) = (yyvsp[0].string);
      }
#line 1771 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 17:
#line 340 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = 0;  }
#line 1777 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 18:
#line 341 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 1783 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 19:
#line 346 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_PRIVATE; }
#line 1789 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 20:
#line 347 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_GLOBAL; }
#line 1795 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 21:
#line 353 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.c_string) = NULL;
      }
#line 1803 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 22:
#line 357 ""grammar.y"" /* yacc.c:1646  */
    {

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, """", NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[0].c_string);
      }
#line 1821 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 23:
#line 375 ""grammar.y"" /* yacc.c:1646  */
    {
        char* identifier;

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = identifier;
      }
#line 1838 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 24:
#line 388 ""grammar.y"" /* yacc.c:1646  */
    {
        char* tag_name = (yyvsp[-1].c_string);
        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;

        while (tag_length > 0)
        {
          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)
          {
            yr_compiler_set_error_extra_info(compiler, tag_name);
            compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;
            break;
          }

          tag_name = (char*) yr_arena_next_address(
              yyget_extra(yyscanner)->sz_arena,
              tag_name,
              tag_length + 1);

          tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        }

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_arena_write_string(
              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-1].c_string);
      }
#line 1874 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 25:
#line 424 ""grammar.y"" /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[0].meta); }
#line 1880 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 26:
#line 425 ""grammar.y"" /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[-1].meta); }
#line 1886 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 27:
#line 431 ""grammar.y"" /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);

        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_STRING,
            (yyvsp[-2].c_string),
            sized_string->c_string,
            0);

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1906 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 28:
#line 447 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-2].c_string),
            NULL,
            (yyvsp[0].integer));

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1923 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 29:
#line 460 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-3].c_string),
            NULL,
            -(yyvsp[0].integer));

        yr_free((yyvsp[-3].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1940 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 30:
#line 473 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            TRUE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1957 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 31:
#line 486 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            FALSE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1974 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 32:
#line 502 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[0].string); }
#line 1980 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 33:
#line 503 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[-1].string); }
#line 1986 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 34:
#line 509 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 1994 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 35:
#line 513 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);
        compiler->error_line = 0;
      }
#line 2009 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 36:
#line 524 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 2017 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 37:
#line 528 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);

        compiler->error_line = 0;
      }
#line 2033 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 38:
#line 540 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.string) == NULL);
      }
#line 2047 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 39:
#line 553 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = 0; }
#line 2053 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 40:
#line 554 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 2059 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 41:
#line 559 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_WIDE; }
#line 2065 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 42:
#line 560 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_ASCII; }
#line 2071 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 43:
#line 561 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }
#line 2077 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 44:
#line 562 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }
#line 2083 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 45:
#line 568 ""grammar.y"" /* yacc.c:1646  */
    {
        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));

        if (var_index >= 0)
        {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner,
              OP_PUSH_M,
              LOOP_LOCAL_VARS * var_index,
              NULL,
              NULL);

          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
          (yyval.expression).identifier = compiler->loop_identifier[var_index];
        }
        else
        {

          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
              compiler->objects_table, (yyvsp[0].c_string), NULL);

          if (object == NULL)
          {
            char* ns = compiler->current_namespace->name;

            object = (YR_OBJECT*) yr_hash_table_lookup(
                compiler->objects_table, (yyvsp[0].c_string), ns);
          }

          if (object != NULL)
          {
            char* id;

            compiler->last_result = yr_arena_write_string(
                compiler->sz_arena, (yyvsp[0].c_string), &id);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_LOAD,
                  id,
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = object;
            (yyval.expression).identifier = object->identifier;
          }
          else
          {
            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
                compiler->rules_table,
                (yyvsp[0].c_string),
                compiler->current_namespace->name);

            if (rule != NULL)
            {
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_PUSH_RULE,
                  rule,
                  NULL,
                  NULL);

              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
              (yyval.expression).value.integer = UNDEFINED;
              (yyval.expression).identifier = rule->identifier;
            }
            else
            {
              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
              compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;
            }
          }
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2172 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 46:
#line 653 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT* field = NULL;

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)
        {
          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));

          if (field != NULL)
          {
            char* ident;

            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[0].c_string), &ident);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_FIELD,
                  ident,
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = field;
            (yyval.expression).identifier = field->identifier;
          }
          else
          {
            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
            compiler->last_result = ERROR_INVALID_FIELD_NAME;
          }
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-2].expression).identifier);

          compiler->last_result = ERROR_NOT_A_STRUCTURE;
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2222 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 47:
#line 699 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT_ARRAY* array;
        YR_OBJECT_DICTIONARY* dict;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
          {
            yr_compiler_set_error_extra_info(
                compiler, ""array indexes must be of integer type"");
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_INDEX_ARRAY, NULL);

          array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = array->prototype_item;
          (yyval.expression).identifier = array->identifier;
        }
        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)
          {
            yr_compiler_set_error_extra_info(
                compiler, ""dictionary keys must be of string type"");
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_LOOKUP_DICT, NULL);

          dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = dict->prototype_item;
          (yyval.expression).identifier = dict->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_INDEXABLE;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2283 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 48:
#line 757 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT_FUNCTION* function;
        char* args_fmt;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)
        {
          compiler->last_result = yr_parser_check_types(
              compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_parser_emit_with_arg_reloc(
                yyscanner,
                OP_CALL,
                args_fmt,
                NULL,
                NULL);

          function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = function->return_obj;
          (yyval.expression).identifier = function->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_A_FUNCTION;
        }

        yr_free((yyvsp[-1].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2328 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 49:
#line 801 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.c_string) = yr_strdup(""""); }
#line 2334 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 50:
#line 802 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.c_string) = (yyvsp[0].c_string); }
#line 2340 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 51:
#line 807 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);

        switch((yyvsp[0].expression).type)
        {
          case EXPRESSION_TYPE_INTEGER:
            strlcpy((yyval.c_string), ""i"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_FLOAT:
            strlcpy((yyval.c_string), ""f"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_BOOLEAN:
            strlcpy((yyval.c_string), ""b"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_STRING:
            strlcpy((yyval.c_string), ""s"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_REGEXP:
            strlcpy((yyval.c_string), ""r"", MAX_FUNCTION_ARGS);
            break;
        }

        ERROR_IF((yyval.c_string) == NULL);
      }
#line 2369 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 52:
#line 832 ""grammar.y"" /* yacc.c:1646  */
    {
        if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)
        {
          compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;
        }
        else
        {
          switch((yyvsp[0].expression).type)
          {
            case EXPRESSION_TYPE_INTEGER:
              strlcat((yyvsp[-2].c_string), ""i"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_FLOAT:
              strlcat((yyvsp[-2].c_string), ""f"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_BOOLEAN:
              strlcat((yyvsp[-2].c_string), ""b"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_STRING:
              strlcat((yyvsp[-2].c_string), ""s"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_REGEXP:
              strlcat((yyvsp[-2].c_string), ""r"", MAX_FUNCTION_ARGS);
              break;
          }
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-2].c_string);
      }
#line 2405 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 53:
#line 868 ""grammar.y"" /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        RE* re;
        RE_ERROR error;

        int re_flags = 0;

        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
          re_flags |= RE_FLAGS_NO_CASE;

        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
          re_flags |= RE_FLAGS_DOT_ALL;

        compiler->last_result = yr_re_compile(
            sized_string->c_string,
            re_flags,
            compiler->re_code_arena,
            &re,
            &error);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)
          yr_compiler_set_error_extra_info(compiler, error.message);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              re->root_node->forward_code,
              NULL,
              NULL);

        yr_re_destroy(re);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
      }
#line 2451 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 54:
#line 914 ""grammar.y"" /* yacc.c:1646  */
    {
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
        {
          if ((yyvsp[0].expression).value.sized_string != NULL)
          {
            yywarning(yyscanner,
              ""Using literal string \""%s\"" in a boolean operation."",
              (yyvsp[0].expression).value.sized_string->c_string);
          }

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_STR_TO_BOOL, NULL);

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2474 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 55:
#line 936 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 1, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2487 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 56:
#line 945 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 0, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2500 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 57:
#line 954 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""matches"");
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, ""matches"");

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit(
              yyscanner,
              OP_MATCHES,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2519 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 58:
#line 969 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""contains"");
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, ""contains"");

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_CONTAINS, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2535 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 59:
#line 981 ""grammar.y"" /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_string_identifier(
            yyscanner,
            (yyvsp[0].c_string),
            OP_FOUND,
            UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2553 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 60:
#line 995 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""at"");

        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2570 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 61:
#line 1008 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result!= ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2585 ""grammar.c"" /* yacc.c:1646  */
    break;
 
   case 62:
 #line 1019 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->loop_depth--;
        compiler->loop_identifier[compiler->loop_depth] = NULL;
      }
#line 2594 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 63:
#line 1024 ""grammar.y"" /* yacc.c:1646  */
     {
         int var_index;
 
        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
              ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        var_index = yr_parser_lookup_loop_variable(
            yyscanner, (yyvsp[-1].c_string));

        if (var_index >= 0)
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-1].c_string));

          compiler->last_result = \
              ERROR_DUPLICATED_LOOP_IDENTIFIER;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 2628 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 64:
#line 1054 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        }
        else // INTEGER_SET_RANGE
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        }

        compiler->loop_address[compiler->loop_depth] = addr;
         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
         compiler->loop_depth++;
       }
#line 2667 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 65:
#line 1089 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
        compiler->loop_depth--;
        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;


        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)
        {
          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JNUNDEF,
              compiler->loop_address[compiler->loop_depth],
              NULL,
              NULL);
        }
        else // INTEGER_SET_RANGE
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);

          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JLE,
              compiler->loop_address[compiler->loop_depth],
              NULL,
              NULL);

          yr_parser_emit(yyscanner, OP_POP, NULL);
          yr_parser_emit(yyscanner, OP_POP, NULL);
        }

        yr_parser_emit(yyscanner, OP_POP, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

        compiler->loop_identifier[compiler->loop_depth] = NULL;
        yr_free((yyvsp[-8].c_string));
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2750 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 66:
#line 1168 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;

        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
            ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        if (compiler->loop_for_of_mem_offset != -1)
          compiler->last_result = \
            ERROR_NESTED_FOR_OF_LOOP;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_POP_M, mem_offset, &addr, NULL);

        compiler->loop_for_of_mem_offset = mem_offset;
        compiler->loop_address[compiler->loop_depth] = addr;
         compiler->loop_identifier[compiler->loop_depth] = NULL;
         compiler->loop_depth++;
       }
#line 2784 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 67:
#line 1198 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
        compiler->loop_depth--;
        compiler->loop_for_of_mem_offset = -1;

        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;


        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JNUNDEF,
            compiler->loop_address[compiler->loop_depth],
            NULL,
            NULL);

        yr_parser_emit(yyscanner, OP_POP, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
 
       }
#line 2837 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 68:
#line 1247 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_OF, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2847 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 69:
#line 1253 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_NOT, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2857 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 70:
#line 1259 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JFALSE,
            0,          // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
#line 2887 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 71:
#line 1285 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* and_addr;


        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);


        fixup = compiler->fixup_stack_head;


        *(void**)(fixup->address) = (void*)(and_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2927 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 72:
#line 1321 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JTRUE,
            0,         // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
#line 2956 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 73:
#line 1346 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* or_addr;


        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);


        fixup = compiler->fixup_stack_head;


        *(void**)(fixup->address) = (void*)(or_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2996 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 74:
#line 1382 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3009 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 75:
#line 1391 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3022 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 76:
#line 1400 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3035 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 77:
#line 1409 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3048 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 78:
#line 1418 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""=="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3061 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 79:
#line 1427 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""!="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3074 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 80:
#line 1436 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
#line 3082 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 81:
#line 1440 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
#line 3090 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 82:
#line 1447 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_ENUMERATION; }
#line 3096 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 83:
#line 1448 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_RANGE; }
#line 3102 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 84:
#line 1454 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for range's lower bound"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }

        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for range's upper bound"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3124 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 85:
#line 1476 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for enumeration item"");
          compiler->last_result = ERROR_WRONG_TYPE;

        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3140 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 86:
#line 1488 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for enumeration item"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3155 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 87:
#line 1503 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
#line 3164 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 89:
#line 1509 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
         yr_parser_emit_pushes_for_strings(yyscanner, ""$*"");
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3175 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 92:
#line 1526 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3186 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 93:
#line 1533 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3197 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 95:
#line 1545 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
#line 3205 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 96:
#line 1549 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
       }
#line 3213 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 97:
#line 1557 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
#line 3221 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 98:
#line 1561 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit(
             yyscanner, OP_FILESIZE, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3235 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 99:
#line 1571 ""grammar.y"" /* yacc.c:1646  */
     {
         yywarning(yyscanner,
             ""Using deprecated \""entrypoint\"" keyword. Use the \""entry_point\"" ""
            ""function from PE module instead."");

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_ENTRYPOINT, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3253 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 100:
#line 1585 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, ""intXXXX or uintXXXX"");
 

        compiler->last_result = yr_parser_emit(
            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3273 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 101:
#line 1601 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = (yyvsp[0].integer);
       }
#line 3287 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 102:
#line 1611 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg_double(
             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
       }
#line 3300 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 103:
#line 1620 ""grammar.y"" /* yacc.c:1646  */
     {
         SIZED_STRING* sized_string;
 
        compiler->last_result = yr_arena_write_data(
            compiler->sz_arena,
            (yyvsp[0].sized_string),
            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),
            (void**) &sized_string);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              sized_string,
              NULL,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_STRING;
         (yyval.expression).value.sized_string = sized_string;
       }
#line 3329 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 104:
#line 1645 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3345 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 105:
#line 1657 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3361 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 106:
#line 1669 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3381 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 107:
#line 1685 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3397 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 108:
#line 1697 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3417 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 109:
#line 1713 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier
         {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier
        {
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
        {
          compiler->last_result = yr_parser_emit(
              yyscanner, OP_OBJ_VALUE, NULL);

          switch((yyvsp[0].expression).value.object->type)
          {
            case OBJECT_TYPE_INTEGER:
              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
              (yyval.expression).value.integer = UNDEFINED;
              break;
            case OBJECT_TYPE_FLOAT:
              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
              break;
            case OBJECT_TYPE_STRING:
              (yyval.expression).type = EXPRESSION_TYPE_STRING;
              (yyval.expression).value.sized_string = NULL;
              break;
            default:
              yr_compiler_set_error_extra_info_fmt(
                  compiler,
                  ""wrong usage of identifier \""%s\"""",
                  (yyvsp[0].expression).identifier);
              compiler->last_result = ERROR_WRONG_TYPE;
          }
        }
        else
        {
          assert(FALSE);
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3466 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 110:
#line 1758 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, ""-"");
 
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
              UNDEFINED : -((yyvsp[0].expression).value.integer);
          compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)
        {
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3489 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 111:
#line 1777 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""+"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3511 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 112:
#line 1795 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""-"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3533 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 113:
#line 1813 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""*"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3555 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 114:
#line 1831 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""\\"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          if ((yyvsp[0].expression).value.integer != 0)
          {
            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          }
          else
          {
            compiler->last_result = ERROR_DIVISION_BY_ZERO;
            ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          }
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3585 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 115:
#line 1857 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""%"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""%"");

        yr_parser_emit(yyscanner, OP_MOD, NULL);

        if ((yyvsp[0].expression).value.integer != 0)
        {
          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
          compiler->last_result = ERROR_DIVISION_BY_ZERO;
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         }
       }
#line 3607 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 116:
#line 1875 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");

        yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3621 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 117:
#line 1885 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");

        yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3635 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 118:
#line 1895 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""|"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""|"");

        yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3649 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 119:
#line 1905 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""~"");
 
        yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
             UNDEFINED : ~((yyvsp[0].expression).value.integer);
       }
#line 3663 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 120:
#line 1915 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""<<"");

        yr_parser_emit(yyscanner, OP_SHL, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3677 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 121:
#line 1925 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "">>"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "">>"");

        yr_parser_emit(yyscanner, OP_SHR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3691 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 122:
#line 1935 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
#line 3699 ""grammar.c"" /* yacc.c:1646  */
     break;
 
 
#line 3703 ""grammar.c"" /* yacc.c:1646  */
       default: break;
     }
   /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT (""-> $$ ="", yyr1[yyn], &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);

  *++yyvsp = yyval;

  /* Now 'shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTOKENS];

  goto yynewstate;


/*--------------------------------------.
| yyerrlab -- here on detecting error.  |
`--------------------------------------*/
yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);

  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
#if ! YYERROR_VERBOSE
      yyerror (yyscanner, compiler, YY_(""syntax error""));
#else
# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                        yyssp, yytoken)
      {
        char const *yymsgp = YY_(""syntax error"");
        int yysyntax_error_status;
        yysyntax_error_status = YYSYNTAX_ERROR;
        if (yysyntax_error_status == 0)
          yymsgp = yymsg;
        else if (yysyntax_error_status == 1)
          {
            if (yymsg != yymsgbuf)
              YYSTACK_FREE (yymsg);
            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
            if (!yymsg)
              {
                yymsg = yymsgbuf;
                yymsg_alloc = sizeof yymsgbuf;
                yysyntax_error_status = 2;
              }
            else
              {
                yysyntax_error_status = YYSYNTAX_ERROR;
                yymsgp = yymsg;
              }
          }
        yyerror (yyscanner, compiler, yymsgp);
        if (yysyntax_error_status == 2)
          goto yyexhaustedlab;
      }
# undef YYSYNTAX_ERROR
#endif
    }



  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse lookahead token after an
         error, discard it.  */

      if (yychar <= YYEOF)
        {
          /* Return failure if at end of input.  */
          if (yychar == YYEOF)
            YYABORT;
        }
      else
        {
          yydestruct (""Error: discarding"",
                      yytoken, &yylval, yyscanner, compiler);
          yychar = YYEMPTY;
        }
    }

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:

  /* Pacify compilers like GCC when the user code never invokes
     YYERROR and the label yyerrorlab therefore never appears in user
     code.  */
  if (/*CONSTCOND*/ 0)
     goto yyerrorlab;

  /* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;      /* Each real token shifted decrements this.  */

  for (;;)
    {
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
        {
          yyn += YYTERROR;
          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
            {
              yyn = yytable[yyn];
              if (0 < yyn)
                break;
            }
        }

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
        YYABORT;


      yydestruct (""Error: popping"",
                  yystos[yystate], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END


  /* Shift the error token.  */
  YY_SYMBOL_PRINT (""Shifting"", yystos[yyn], yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturn;

/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturn;

#if !defined yyoverflow || YYERROR_VERBOSE
/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/
yyexhaustedlab:
  yyerror (yyscanner, compiler, YY_(""memory exhausted""));
  yyresult = 2;
  /* Fall through.  */
#endif

yyreturn:
  if (yychar != YYEMPTY)
    {
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct (""Cleanup: discarding lookahead"",
                  yytoken, &yylval, yyscanner, compiler);
    }
  /* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct (""Cleanup: popping"",
                  yystos[*yyssp], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif
#if YYERROR_VERBOSE
  if (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
 #endif
   return yyresult;
 }
","yyparse (void *yyscanner, YR_COMPILER* compiler)
{
/* The lookahead symbol.  */
int yychar;


/* The semantic value of the lookahead symbol.  */
/* Default value used for initialization, for pacifying older GCCs
   or non-GCC compilers.  */
YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);

    /* Number of syntax errors so far.  */
    int yynerrs;

    int yystate;
    /* Number of tokens to shift before error messages enabled.  */
    int yyerrstatus;

    /* The stacks and their tools:
       'yyss': related to states.
       'yyvs': related to semantic values.

       Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */

    /* The state stack.  */
    yytype_int16 yyssa[YYINITDEPTH];
    yytype_int16 *yyss;
    yytype_int16 *yyssp;

    /* The semantic value stack.  */
    YYSTYPE yyvsa[YYINITDEPTH];
    YYSTYPE *yyvs;
    YYSTYPE *yyvsp;

    YYSIZE_T yystacksize;

  int yyn;
  int yyresult;
  /* Lookahead token as an internal (translated) token number.  */
  int yytoken = 0;
  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;

#if YYERROR_VERBOSE
  /* Buffer for error messages, and its allocated size.  */
  char yymsgbuf[128];
  char *yymsg = yymsgbuf;
  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
#endif

#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))

  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  yyssp = yyss = yyssa;
  yyvsp = yyvs = yyvsa;
  yystacksize = YYINITDEPTH;

  YYDPRINTF ((stderr, ""Starting parse\n""));

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY; /* Cause a token to be read.  */
  goto yysetstate;

/*------------------------------------------------------------.
| yynewstate -- Push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
 yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;

 yysetstate:
  *yyssp = yystate;

  if (yyss + yystacksize - 1 <= yyssp)
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYSIZE_T yysize = yyssp - yyss + 1;

#ifdef yyoverflow
      {
        /* Give user a chance to reallocate the stack.  Use copies of
           these so that the &'s don't force the real ones into
           memory.  */
        YYSTYPE *yyvs1 = yyvs;
        yytype_int16 *yyss1 = yyss;

        /* Each stack pointer address is followed by the size of the
           data in use in that stack, in bytes.  This used to be a
           conditional around just the two extra args, but that might
           be undefined if yyoverflow is a macro.  */
        yyoverflow (YY_(""memory exhausted""),
                    &yyss1, yysize * sizeof (*yyssp),
                    &yyvs1, yysize * sizeof (*yyvsp),
                    &yystacksize);

        yyss = yyss1;
        yyvs = yyvs1;
      }
#else /* no yyoverflow */
# ifndef YYSTACK_RELOCATE
      goto yyexhaustedlab;
# else
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
        goto yyexhaustedlab;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
        yystacksize = YYMAXDEPTH;

      {
        yytype_int16 *yyss1 = yyss;
        union yyalloc *yyptr =
          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
        if (! yyptr)
          goto yyexhaustedlab;
        YYSTACK_RELOCATE (yyss_alloc, yyss);
        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
#  undef YYSTACK_RELOCATE
        if (yyss1 != yyssa)
          YYSTACK_FREE (yyss1);
      }
# endif
#endif /* no yyoverflow */

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;

      YYDPRINTF ((stderr, ""Stack size increased to %lu\n"",
                  (unsigned long int) yystacksize));

      if (yyss + yystacksize - 1 <= yyssp)
        YYABORT;
    }

  YYDPRINTF ((stderr, ""Entering state %d\n"", yystate));

  if (yystate == YYFINAL)
    YYACCEPT;

  goto yybackup;

/*-----------.
| yybackup.  |
`-----------*/
yybackup:

  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, ""Reading a token: ""));
      yychar = yylex (&yylval, yyscanner, compiler);
    }

  if (yychar <= YYEOF)
    {
      yychar = yytoken = YYEOF;
      YYDPRINTF ((stderr, ""Now at end of input.\n""));
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT (""Next token is"", yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT (""Shifting"", yytoken, &yylval, &yylloc);

  /* Discard the shifted token.  */
  yychar = YYEMPTY;

  yystate = yyn;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END

  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- Do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     '$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
        case 8:
#line 230 ""grammar.y"" /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));

        yr_free((yyvsp[0].sized_string));

        ERROR_IF(result != ERROR_SUCCESS);
      }
#line 1661 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 9:
#line 242 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(
            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));

        ERROR_IF(rule == NULL);

        (yyval.rule) = rule;
      }
#line 1674 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 10:
#line 251 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1

        rule->tags = (yyvsp[-3].c_string);
        rule->metas = (yyvsp[-1].meta);
        rule->strings = (yyvsp[0].string);
      }
#line 1686 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 11:
#line 259 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-7].rule); // rule created in phase 1

        compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(
            yyscanner, rule);

        yr_free((yyvsp[-8].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1701 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 12:
#line 274 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = NULL;
      }
#line 1709 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 13:
#line 278 ""grammar.y"" /* yacc.c:1646  */
    {

        YR_META null_meta;

        memset(&null_meta, 0xFF, sizeof(YR_META));
        null_meta.type = META_TYPE_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->metas_arena,
            &null_meta,
            sizeof(YR_META),
            NULL);

        (yyval.meta) = (yyvsp[0].meta);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1736 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 14:
#line 305 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = NULL;
      }
#line 1744 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 15:
#line 309 ""grammar.y"" /* yacc.c:1646  */
    {

        YR_STRING null_string;

        memset(&null_string, 0xFF, sizeof(YR_STRING));
        null_string.g_flags = STRING_GFLAGS_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->strings_arena,
            &null_string,
            sizeof(YR_STRING),
            NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.string) = (yyvsp[0].string);
      }
#line 1771 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 17:
#line 340 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = 0;  }
#line 1777 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 18:
#line 341 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 1783 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 19:
#line 346 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_PRIVATE; }
#line 1789 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 20:
#line 347 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_GLOBAL; }
#line 1795 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 21:
#line 353 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.c_string) = NULL;
      }
#line 1803 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 22:
#line 357 ""grammar.y"" /* yacc.c:1646  */
    {

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, """", NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[0].c_string);
      }
#line 1821 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 23:
#line 375 ""grammar.y"" /* yacc.c:1646  */
    {
        char* identifier;

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = identifier;
      }
#line 1838 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 24:
#line 388 ""grammar.y"" /* yacc.c:1646  */
    {
        char* tag_name = (yyvsp[-1].c_string);
        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;

        while (tag_length > 0)
        {
          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)
          {
            yr_compiler_set_error_extra_info(compiler, tag_name);
            compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;
            break;
          }

          tag_name = (char*) yr_arena_next_address(
              yyget_extra(yyscanner)->sz_arena,
              tag_name,
              tag_length + 1);

          tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        }

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_arena_write_string(
              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-1].c_string);
      }
#line 1874 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 25:
#line 424 ""grammar.y"" /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[0].meta); }
#line 1880 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 26:
#line 425 ""grammar.y"" /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[-1].meta); }
#line 1886 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 27:
#line 431 ""grammar.y"" /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);

        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_STRING,
            (yyvsp[-2].c_string),
            sized_string->c_string,
            0);

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1906 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 28:
#line 447 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-2].c_string),
            NULL,
            (yyvsp[0].integer));

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1923 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 29:
#line 460 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-3].c_string),
            NULL,
            -(yyvsp[0].integer));

        yr_free((yyvsp[-3].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1940 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 30:
#line 473 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            TRUE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1957 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 31:
#line 486 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            FALSE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1974 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 32:
#line 502 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[0].string); }
#line 1980 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 33:
#line 503 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[-1].string); }
#line 1986 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 34:
#line 509 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 1994 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 35:
#line 513 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);
        compiler->error_line = 0;
      }
#line 2009 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 36:
#line 524 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 2017 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 37:
#line 528 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);

        compiler->error_line = 0;
      }
#line 2033 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 38:
#line 540 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.string) == NULL);
      }
#line 2047 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 39:
#line 553 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = 0; }
#line 2053 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 40:
#line 554 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 2059 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 41:
#line 559 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_WIDE; }
#line 2065 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 42:
#line 560 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_ASCII; }
#line 2071 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 43:
#line 561 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }
#line 2077 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 44:
#line 562 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }
#line 2083 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 45:
#line 568 ""grammar.y"" /* yacc.c:1646  */
    {
        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));

        if (var_index >= 0)
        {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner,
              OP_PUSH_M,
              LOOP_LOCAL_VARS * var_index,
              NULL,
              NULL);

          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
          (yyval.expression).identifier = compiler->loop_identifier[var_index];
        }
        else
        {

          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
              compiler->objects_table, (yyvsp[0].c_string), NULL);

          if (object == NULL)
          {
            char* ns = compiler->current_namespace->name;

            object = (YR_OBJECT*) yr_hash_table_lookup(
                compiler->objects_table, (yyvsp[0].c_string), ns);
          }

          if (object != NULL)
          {
            char* id;

            compiler->last_result = yr_arena_write_string(
                compiler->sz_arena, (yyvsp[0].c_string), &id);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_LOAD,
                  id,
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = object;
            (yyval.expression).identifier = object->identifier;
          }
          else
          {
            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
                compiler->rules_table,
                (yyvsp[0].c_string),
                compiler->current_namespace->name);

            if (rule != NULL)
            {
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_PUSH_RULE,
                  rule,
                  NULL,
                  NULL);

              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
              (yyval.expression).value.integer = UNDEFINED;
              (yyval.expression).identifier = rule->identifier;
            }
            else
            {
              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
              compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;
            }
          }
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2172 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 46:
#line 653 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT* field = NULL;

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)
        {
          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));

          if (field != NULL)
          {
            char* ident;

            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[0].c_string), &ident);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_FIELD,
                  ident,
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = field;
            (yyval.expression).identifier = field->identifier;
          }
          else
          {
            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
            compiler->last_result = ERROR_INVALID_FIELD_NAME;
          }
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-2].expression).identifier);

          compiler->last_result = ERROR_NOT_A_STRUCTURE;
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2222 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 47:
#line 699 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT_ARRAY* array;
        YR_OBJECT_DICTIONARY* dict;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
          {
            yr_compiler_set_error_extra_info(
                compiler, ""array indexes must be of integer type"");
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_INDEX_ARRAY, NULL);

          array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = array->prototype_item;
          (yyval.expression).identifier = array->identifier;
        }
        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)
          {
            yr_compiler_set_error_extra_info(
                compiler, ""dictionary keys must be of string type"");
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_LOOKUP_DICT, NULL);

          dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = dict->prototype_item;
          (yyval.expression).identifier = dict->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_INDEXABLE;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2283 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 48:
#line 757 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT_FUNCTION* function;
        char* args_fmt;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)
        {
          compiler->last_result = yr_parser_check_types(
              compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_parser_emit_with_arg_reloc(
                yyscanner,
                OP_CALL,
                args_fmt,
                NULL,
                NULL);

          function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = function->return_obj;
          (yyval.expression).identifier = function->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_A_FUNCTION;
        }

        yr_free((yyvsp[-1].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2328 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 49:
#line 801 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.c_string) = yr_strdup(""""); }
#line 2334 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 50:
#line 802 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.c_string) = (yyvsp[0].c_string); }
#line 2340 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 51:
#line 807 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);

        switch((yyvsp[0].expression).type)
        {
          case EXPRESSION_TYPE_INTEGER:
            strlcpy((yyval.c_string), ""i"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_FLOAT:
            strlcpy((yyval.c_string), ""f"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_BOOLEAN:
            strlcpy((yyval.c_string), ""b"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_STRING:
            strlcpy((yyval.c_string), ""s"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_REGEXP:
            strlcpy((yyval.c_string), ""r"", MAX_FUNCTION_ARGS);
            break;
        }

        ERROR_IF((yyval.c_string) == NULL);
      }
#line 2369 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 52:
#line 832 ""grammar.y"" /* yacc.c:1646  */
    {
        if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)
        {
          compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;
        }
        else
        {
          switch((yyvsp[0].expression).type)
          {
            case EXPRESSION_TYPE_INTEGER:
              strlcat((yyvsp[-2].c_string), ""i"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_FLOAT:
              strlcat((yyvsp[-2].c_string), ""f"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_BOOLEAN:
              strlcat((yyvsp[-2].c_string), ""b"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_STRING:
              strlcat((yyvsp[-2].c_string), ""s"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_REGEXP:
              strlcat((yyvsp[-2].c_string), ""r"", MAX_FUNCTION_ARGS);
              break;
          }
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-2].c_string);
      }
#line 2405 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 53:
#line 868 ""grammar.y"" /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        RE* re;
        RE_ERROR error;

        int re_flags = 0;

        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
          re_flags |= RE_FLAGS_NO_CASE;

        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
          re_flags |= RE_FLAGS_DOT_ALL;

        compiler->last_result = yr_re_compile(
            sized_string->c_string,
            re_flags,
            compiler->re_code_arena,
            &re,
            &error);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)
          yr_compiler_set_error_extra_info(compiler, error.message);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              re->root_node->forward_code,
              NULL,
              NULL);

        yr_re_destroy(re);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
      }
#line 2451 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 54:
#line 914 ""grammar.y"" /* yacc.c:1646  */
    {
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
        {
          if ((yyvsp[0].expression).value.sized_string != NULL)
          {
            yywarning(yyscanner,
              ""Using literal string \""%s\"" in a boolean operation."",
              (yyvsp[0].expression).value.sized_string->c_string);
          }

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_STR_TO_BOOL, NULL);

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2474 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 55:
#line 936 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 1, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2487 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 56:
#line 945 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 0, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2500 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 57:
#line 954 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""matches"");
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, ""matches"");

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit(
              yyscanner,
              OP_MATCHES,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2519 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 58:
#line 969 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""contains"");
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, ""contains"");

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_CONTAINS, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2535 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 59:
#line 981 ""grammar.y"" /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_string_identifier(
            yyscanner,
            (yyvsp[0].c_string),
            OP_FOUND,
            UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2553 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 60:
#line 995 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""at"");

        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2570 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 61:
#line 1008 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result!= ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2585 ""grammar.c"" /* yacc.c:1646  */
    break;
 
   case 62:
 #line 1019 ""grammar.y"" /* yacc.c:1646  */
     {
         int var_index;
 
        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
              ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        var_index = yr_parser_lookup_loop_variable(
            yyscanner, (yyvsp[-1].c_string));

        if (var_index >= 0)
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-1].c_string));

          compiler->last_result = \
              ERROR_DUPLICATED_LOOP_IDENTIFIER;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 2619 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 63:
#line 1049 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        }
        else // INTEGER_SET_RANGE
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        }

        compiler->loop_address[compiler->loop_depth] = addr;
         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
         compiler->loop_depth++;
       }
#line 2658 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 64:
#line 1084 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
        compiler->loop_depth--;
        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;


        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)
        {
          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JNUNDEF,
              compiler->loop_address[compiler->loop_depth],
              NULL,
              NULL);
        }
        else // INTEGER_SET_RANGE
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);

          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JLE,
              compiler->loop_address[compiler->loop_depth],
              NULL,
              NULL);

          yr_parser_emit(yyscanner, OP_POP, NULL);
          yr_parser_emit(yyscanner, OP_POP, NULL);
        }

        yr_parser_emit(yyscanner, OP_POP, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

        compiler->loop_identifier[compiler->loop_depth] = NULL;
        yr_free((yyvsp[-8].c_string));
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2741 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 65:
#line 1163 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;

        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
            ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        if (compiler->loop_for_of_mem_offset != -1)
          compiler->last_result = \
            ERROR_NESTED_FOR_OF_LOOP;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_POP_M, mem_offset, &addr, NULL);

        compiler->loop_for_of_mem_offset = mem_offset;
        compiler->loop_address[compiler->loop_depth] = addr;
         compiler->loop_identifier[compiler->loop_depth] = NULL;
         compiler->loop_depth++;
       }
#line 2775 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 66:
#line 1193 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
        compiler->loop_depth--;
        compiler->loop_for_of_mem_offset = -1;

        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;


        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JNUNDEF,
            compiler->loop_address[compiler->loop_depth],
            NULL,
            NULL);

        yr_parser_emit(yyscanner, OP_POP, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
 
       }
#line 2828 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 67:
#line 1242 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_OF, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2838 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 68:
#line 1248 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_NOT, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2848 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 69:
#line 1254 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JFALSE,
            0,          // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
#line 2878 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 70:
#line 1280 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* and_addr;


        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);


        fixup = compiler->fixup_stack_head;


        *(void**)(fixup->address) = (void*)(and_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2918 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 71:
#line 1316 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JTRUE,
            0,         // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
#line 2947 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 72:
#line 1341 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* or_addr;


        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);


        fixup = compiler->fixup_stack_head;


        *(void**)(fixup->address) = (void*)(or_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2987 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 73:
#line 1377 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3000 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 74:
#line 1386 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3013 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 75:
#line 1395 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3026 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 76:
#line 1404 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3039 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 77:
#line 1413 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""=="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3052 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 78:
#line 1422 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""!="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3065 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 79:
#line 1431 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
#line 3073 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 80:
#line 1435 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
#line 3081 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 81:
#line 1442 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_ENUMERATION; }
#line 3087 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 82:
#line 1443 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_RANGE; }
#line 3093 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 83:
#line 1449 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for range's lower bound"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }

        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for range's upper bound"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3115 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 84:
#line 1471 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for enumeration item"");
          compiler->last_result = ERROR_WRONG_TYPE;

        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3131 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 85:
#line 1483 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for enumeration item"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3146 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 86:
#line 1498 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
#line 3155 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 88:
#line 1504 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
         yr_parser_emit_pushes_for_strings(yyscanner, ""$*"");
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3166 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 91:
#line 1521 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3177 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 92:
#line 1528 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3188 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 94:
#line 1540 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
#line 3196 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 95:
#line 1544 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
       }
#line 3204 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 96:
#line 1552 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
#line 3212 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 97:
#line 1556 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit(
             yyscanner, OP_FILESIZE, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3226 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 98:
#line 1566 ""grammar.y"" /* yacc.c:1646  */
     {
         yywarning(yyscanner,
             ""Using deprecated \""entrypoint\"" keyword. Use the \""entry_point\"" ""
            ""function from PE module instead."");

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_ENTRYPOINT, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3244 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 99:
#line 1580 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, ""intXXXX or uintXXXX"");
 

        compiler->last_result = yr_parser_emit(
            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3264 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 100:
#line 1596 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = (yyvsp[0].integer);
       }
#line 3278 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 101:
#line 1606 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg_double(
             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
       }
#line 3291 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 102:
#line 1615 ""grammar.y"" /* yacc.c:1646  */
     {
         SIZED_STRING* sized_string;
 
        compiler->last_result = yr_arena_write_data(
            compiler->sz_arena,
            (yyvsp[0].sized_string),
            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),
            (void**) &sized_string);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              sized_string,
              NULL,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_STRING;
         (yyval.expression).value.sized_string = sized_string;
       }
#line 3320 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 103:
#line 1640 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3336 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 104:
#line 1652 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3352 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 105:
#line 1664 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3372 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 106:
#line 1680 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3388 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 107:
#line 1692 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3408 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 108:
#line 1708 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier
         {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier
        {
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
        {
          compiler->last_result = yr_parser_emit(
              yyscanner, OP_OBJ_VALUE, NULL);

          switch((yyvsp[0].expression).value.object->type)
          {
            case OBJECT_TYPE_INTEGER:
              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
              (yyval.expression).value.integer = UNDEFINED;
              break;
            case OBJECT_TYPE_FLOAT:
              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
              break;
            case OBJECT_TYPE_STRING:
              (yyval.expression).type = EXPRESSION_TYPE_STRING;
              (yyval.expression).value.sized_string = NULL;
              break;
            default:
              yr_compiler_set_error_extra_info_fmt(
                  compiler,
                  ""wrong usage of identifier \""%s\"""",
                  (yyvsp[0].expression).identifier);
              compiler->last_result = ERROR_WRONG_TYPE;
          }
        }
        else
        {
          assert(FALSE);
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3457 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 109:
#line 1753 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, ""-"");
 
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
              UNDEFINED : -((yyvsp[0].expression).value.integer);
          compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)
        {
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3480 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 110:
#line 1772 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""+"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3502 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 111:
#line 1790 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""-"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3524 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 112:
#line 1808 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""*"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3546 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 113:
#line 1826 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""\\"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          if ((yyvsp[0].expression).value.integer != 0)
          {
            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          }
          else
          {
            compiler->last_result = ERROR_DIVISION_BY_ZERO;
            ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          }
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3576 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 114:
#line 1852 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""%"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""%"");

        yr_parser_emit(yyscanner, OP_MOD, NULL);

        if ((yyvsp[0].expression).value.integer != 0)
        {
          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
          compiler->last_result = ERROR_DIVISION_BY_ZERO;
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         }
       }
#line 3598 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 115:
#line 1870 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");

        yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3612 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 116:
#line 1880 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");

        yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3626 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 117:
#line 1890 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""|"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""|"");

        yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3640 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 118:
#line 1900 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""~"");
 
        yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
             UNDEFINED : ~((yyvsp[0].expression).value.integer);
       }
#line 3654 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 119:
#line 1910 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""<<"");

        yr_parser_emit(yyscanner, OP_SHL, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3668 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 120:
#line 1920 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "">>"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "">>"");

        yr_parser_emit(yyscanner, OP_SHR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3682 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 121:
#line 1930 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
#line 3690 ""grammar.c"" /* yacc.c:1646  */
     break;
 
 
#line 3694 ""grammar.c"" /* yacc.c:1646  */
       default: break;
     }
   /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT (""-> $$ ="", yyr1[yyn], &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);

  *++yyvsp = yyval;

  /* Now 'shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTOKENS];

  goto yynewstate;


/*--------------------------------------.
| yyerrlab -- here on detecting error.  |
`--------------------------------------*/
yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);

  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
#if ! YYERROR_VERBOSE
      yyerror (yyscanner, compiler, YY_(""syntax error""));
#else
# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                        yyssp, yytoken)
      {
        char const *yymsgp = YY_(""syntax error"");
        int yysyntax_error_status;
        yysyntax_error_status = YYSYNTAX_ERROR;
        if (yysyntax_error_status == 0)
          yymsgp = yymsg;
        else if (yysyntax_error_status == 1)
          {
            if (yymsg != yymsgbuf)
              YYSTACK_FREE (yymsg);
            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
            if (!yymsg)
              {
                yymsg = yymsgbuf;
                yymsg_alloc = sizeof yymsgbuf;
                yysyntax_error_status = 2;
              }
            else
              {
                yysyntax_error_status = YYSYNTAX_ERROR;
                yymsgp = yymsg;
              }
          }
        yyerror (yyscanner, compiler, yymsgp);
        if (yysyntax_error_status == 2)
          goto yyexhaustedlab;
      }
# undef YYSYNTAX_ERROR
#endif
    }



  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse lookahead token after an
         error, discard it.  */

      if (yychar <= YYEOF)
        {
          /* Return failure if at end of input.  */
          if (yychar == YYEOF)
            YYABORT;
        }
      else
        {
          yydestruct (""Error: discarding"",
                      yytoken, &yylval, yyscanner, compiler);
          yychar = YYEMPTY;
        }
    }

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:

  /* Pacify compilers like GCC when the user code never invokes
     YYERROR and the label yyerrorlab therefore never appears in user
     code.  */
  if (/*CONSTCOND*/ 0)
     goto yyerrorlab;

  /* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;      /* Each real token shifted decrements this.  */

  for (;;)
    {
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
        {
          yyn += YYTERROR;
          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
            {
              yyn = yytable[yyn];
              if (0 < yyn)
                break;
            }
        }

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
        YYABORT;


      yydestruct (""Error: popping"",
                  yystos[yystate], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END


  /* Shift the error token.  */
  YY_SYMBOL_PRINT (""Shifting"", yystos[yyn], yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturn;

/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturn;

#if !defined yyoverflow || YYERROR_VERBOSE
/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/
yyexhaustedlab:
  yyerror (yyscanner, compiler, YY_(""memory exhausted""));
  yyresult = 2;
  /* Fall through.  */
#endif

yyreturn:
  if (yychar != YYEMPTY)
    {
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct (""Cleanup: discarding lookahead"",
                  yytoken, &yylval, yyscanner, compiler);
    }
  /* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct (""Cleanup: popping"",
                  yystos[*yyssp], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif
#if YYERROR_VERBOSE
  if (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
 #endif
   return yyresult;
 }
",C,"    {
        compiler->loop_depth--;
        compiler->loop_identifier[compiler->loop_depth] = NULL;
      }
#line 2594 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 63:
#line 1024 ""grammar.y"" /* yacc.c:1646  */
#line 2628 ""grammar.c"" /* yacc.c:1646  */
  case 64:
#line 1054 ""grammar.y"" /* yacc.c:1646  */
#line 2667 ""grammar.c"" /* yacc.c:1646  */
  case 65:
#line 1089 ""grammar.y"" /* yacc.c:1646  */
#line 2750 ""grammar.c"" /* yacc.c:1646  */
  case 66:
#line 1168 ""grammar.y"" /* yacc.c:1646  */
#line 2784 ""grammar.c"" /* yacc.c:1646  */
  case 67:
#line 1198 ""grammar.y"" /* yacc.c:1646  */
#line 2837 ""grammar.c"" /* yacc.c:1646  */
  case 68:
#line 1247 ""grammar.y"" /* yacc.c:1646  */
#line 2847 ""grammar.c"" /* yacc.c:1646  */
  case 69:
#line 1253 ""grammar.y"" /* yacc.c:1646  */
#line 2857 ""grammar.c"" /* yacc.c:1646  */
  case 70:
#line 1259 ""grammar.y"" /* yacc.c:1646  */
#line 2887 ""grammar.c"" /* yacc.c:1646  */
  case 71:
#line 1285 ""grammar.y"" /* yacc.c:1646  */
#line 2927 ""grammar.c"" /* yacc.c:1646  */
  case 72:
#line 1321 ""grammar.y"" /* yacc.c:1646  */
#line 2956 ""grammar.c"" /* yacc.c:1646  */
  case 73:
#line 1346 ""grammar.y"" /* yacc.c:1646  */
#line 2996 ""grammar.c"" /* yacc.c:1646  */
  case 74:
#line 1382 ""grammar.y"" /* yacc.c:1646  */
#line 3009 ""grammar.c"" /* yacc.c:1646  */
  case 75:
#line 1391 ""grammar.y"" /* yacc.c:1646  */
#line 3022 ""grammar.c"" /* yacc.c:1646  */
  case 76:
#line 1400 ""grammar.y"" /* yacc.c:1646  */
#line 3035 ""grammar.c"" /* yacc.c:1646  */
  case 77:
#line 1409 ""grammar.y"" /* yacc.c:1646  */
#line 3048 ""grammar.c"" /* yacc.c:1646  */
  case 78:
#line 1418 ""grammar.y"" /* yacc.c:1646  */
#line 3061 ""grammar.c"" /* yacc.c:1646  */
  case 79:
#line 1427 ""grammar.y"" /* yacc.c:1646  */
#line 3074 ""grammar.c"" /* yacc.c:1646  */
  case 80:
#line 1436 ""grammar.y"" /* yacc.c:1646  */
#line 3082 ""grammar.c"" /* yacc.c:1646  */
  case 81:
#line 1440 ""grammar.y"" /* yacc.c:1646  */
#line 3090 ""grammar.c"" /* yacc.c:1646  */
  case 82:
#line 1447 ""grammar.y"" /* yacc.c:1646  */
#line 3096 ""grammar.c"" /* yacc.c:1646  */
  case 83:
#line 1448 ""grammar.y"" /* yacc.c:1646  */
#line 3102 ""grammar.c"" /* yacc.c:1646  */
  case 84:
#line 1454 ""grammar.y"" /* yacc.c:1646  */
#line 3124 ""grammar.c"" /* yacc.c:1646  */
  case 85:
#line 1476 ""grammar.y"" /* yacc.c:1646  */
#line 3140 ""grammar.c"" /* yacc.c:1646  */
  case 86:
#line 1488 ""grammar.y"" /* yacc.c:1646  */
#line 3155 ""grammar.c"" /* yacc.c:1646  */
  case 87:
#line 1503 ""grammar.y"" /* yacc.c:1646  */
#line 3164 ""grammar.c"" /* yacc.c:1646  */
  case 89:
#line 1509 ""grammar.y"" /* yacc.c:1646  */
#line 3175 ""grammar.c"" /* yacc.c:1646  */
  case 92:
#line 1526 ""grammar.y"" /* yacc.c:1646  */
#line 3186 ""grammar.c"" /* yacc.c:1646  */
  case 93:
#line 1533 ""grammar.y"" /* yacc.c:1646  */
#line 3197 ""grammar.c"" /* yacc.c:1646  */
  case 95:
#line 1545 ""grammar.y"" /* yacc.c:1646  */
#line 3205 ""grammar.c"" /* yacc.c:1646  */
  case 96:
#line 1549 ""grammar.y"" /* yacc.c:1646  */
#line 3213 ""grammar.c"" /* yacc.c:1646  */
  case 97:
#line 1557 ""grammar.y"" /* yacc.c:1646  */
#line 3221 ""grammar.c"" /* yacc.c:1646  */
  case 98:
#line 1561 ""grammar.y"" /* yacc.c:1646  */
#line 3235 ""grammar.c"" /* yacc.c:1646  */
  case 99:
#line 1571 ""grammar.y"" /* yacc.c:1646  */
#line 3253 ""grammar.c"" /* yacc.c:1646  */
  case 100:
#line 1585 ""grammar.y"" /* yacc.c:1646  */
#line 3273 ""grammar.c"" /* yacc.c:1646  */
  case 101:
#line 1601 ""grammar.y"" /* yacc.c:1646  */
#line 3287 ""grammar.c"" /* yacc.c:1646  */
  case 102:
#line 1611 ""grammar.y"" /* yacc.c:1646  */
#line 3300 ""grammar.c"" /* yacc.c:1646  */
  case 103:
#line 1620 ""grammar.y"" /* yacc.c:1646  */
#line 3329 ""grammar.c"" /* yacc.c:1646  */
  case 104:
#line 1645 ""grammar.y"" /* yacc.c:1646  */
#line 3345 ""grammar.c"" /* yacc.c:1646  */
  case 105:
#line 1657 ""grammar.y"" /* yacc.c:1646  */
#line 3361 ""grammar.c"" /* yacc.c:1646  */
  case 106:
#line 1669 ""grammar.y"" /* yacc.c:1646  */
#line 3381 ""grammar.c"" /* yacc.c:1646  */
  case 107:
#line 1685 ""grammar.y"" /* yacc.c:1646  */
#line 3397 ""grammar.c"" /* yacc.c:1646  */
  case 108:
#line 1697 ""grammar.y"" /* yacc.c:1646  */
#line 3417 ""grammar.c"" /* yacc.c:1646  */
  case 109:
#line 1713 ""grammar.y"" /* yacc.c:1646  */
#line 3466 ""grammar.c"" /* yacc.c:1646  */
  case 110:
#line 1758 ""grammar.y"" /* yacc.c:1646  */
#line 3489 ""grammar.c"" /* yacc.c:1646  */
  case 111:
#line 1777 ""grammar.y"" /* yacc.c:1646  */
#line 3511 ""grammar.c"" /* yacc.c:1646  */
  case 112:
#line 1795 ""grammar.y"" /* yacc.c:1646  */
#line 3533 ""grammar.c"" /* yacc.c:1646  */
  case 113:
#line 1813 ""grammar.y"" /* yacc.c:1646  */
#line 3555 ""grammar.c"" /* yacc.c:1646  */
  case 114:
#line 1831 ""grammar.y"" /* yacc.c:1646  */
#line 3585 ""grammar.c"" /* yacc.c:1646  */
  case 115:
#line 1857 ""grammar.y"" /* yacc.c:1646  */
#line 3607 ""grammar.c"" /* yacc.c:1646  */
  case 116:
#line 1875 ""grammar.y"" /* yacc.c:1646  */
#line 3621 ""grammar.c"" /* yacc.c:1646  */
  case 117:
#line 1885 ""grammar.y"" /* yacc.c:1646  */
#line 3635 ""grammar.c"" /* yacc.c:1646  */
  case 118:
#line 1895 ""grammar.y"" /* yacc.c:1646  */
#line 3649 ""grammar.c"" /* yacc.c:1646  */
  case 119:
#line 1905 ""grammar.y"" /* yacc.c:1646  */
#line 3663 ""grammar.c"" /* yacc.c:1646  */
  case 120:
#line 1915 ""grammar.y"" /* yacc.c:1646  */
#line 3677 ""grammar.c"" /* yacc.c:1646  */
  case 121:
#line 1925 ""grammar.y"" /* yacc.c:1646  */
#line 3691 ""grammar.c"" /* yacc.c:1646  */
  case 122:
#line 1935 ""grammar.y"" /* yacc.c:1646  */
#line 3699 ""grammar.c"" /* yacc.c:1646  */
#line 3703 ""grammar.c"" /* yacc.c:1646  */
","#line 2619 ""grammar.c"" /* yacc.c:1646  */
  case 63:
#line 1049 ""grammar.y"" /* yacc.c:1646  */
#line 2658 ""grammar.c"" /* yacc.c:1646  */
  case 64:
#line 1084 ""grammar.y"" /* yacc.c:1646  */
#line 2741 ""grammar.c"" /* yacc.c:1646  */
  case 65:
#line 1163 ""grammar.y"" /* yacc.c:1646  */
#line 2775 ""grammar.c"" /* yacc.c:1646  */
  case 66:
#line 1193 ""grammar.y"" /* yacc.c:1646  */
#line 2828 ""grammar.c"" /* yacc.c:1646  */
  case 67:
#line 1242 ""grammar.y"" /* yacc.c:1646  */
#line 2838 ""grammar.c"" /* yacc.c:1646  */
  case 68:
#line 1248 ""grammar.y"" /* yacc.c:1646  */
#line 2848 ""grammar.c"" /* yacc.c:1646  */
  case 69:
#line 1254 ""grammar.y"" /* yacc.c:1646  */
#line 2878 ""grammar.c"" /* yacc.c:1646  */
  case 70:
#line 1280 ""grammar.y"" /* yacc.c:1646  */
#line 2918 ""grammar.c"" /* yacc.c:1646  */
  case 71:
#line 1316 ""grammar.y"" /* yacc.c:1646  */
#line 2947 ""grammar.c"" /* yacc.c:1646  */
  case 72:
#line 1341 ""grammar.y"" /* yacc.c:1646  */
#line 2987 ""grammar.c"" /* yacc.c:1646  */
  case 73:
#line 1377 ""grammar.y"" /* yacc.c:1646  */
#line 3000 ""grammar.c"" /* yacc.c:1646  */
  case 74:
#line 1386 ""grammar.y"" /* yacc.c:1646  */
#line 3013 ""grammar.c"" /* yacc.c:1646  */
  case 75:
#line 1395 ""grammar.y"" /* yacc.c:1646  */
#line 3026 ""grammar.c"" /* yacc.c:1646  */
  case 76:
#line 1404 ""grammar.y"" /* yacc.c:1646  */
#line 3039 ""grammar.c"" /* yacc.c:1646  */
  case 77:
#line 1413 ""grammar.y"" /* yacc.c:1646  */
#line 3052 ""grammar.c"" /* yacc.c:1646  */
  case 78:
#line 1422 ""grammar.y"" /* yacc.c:1646  */
#line 3065 ""grammar.c"" /* yacc.c:1646  */
  case 79:
#line 1431 ""grammar.y"" /* yacc.c:1646  */
#line 3073 ""grammar.c"" /* yacc.c:1646  */
  case 80:
#line 1435 ""grammar.y"" /* yacc.c:1646  */
#line 3081 ""grammar.c"" /* yacc.c:1646  */
  case 81:
#line 1442 ""grammar.y"" /* yacc.c:1646  */
#line 3087 ""grammar.c"" /* yacc.c:1646  */
  case 82:
#line 1443 ""grammar.y"" /* yacc.c:1646  */
#line 3093 ""grammar.c"" /* yacc.c:1646  */
  case 83:
#line 1449 ""grammar.y"" /* yacc.c:1646  */
#line 3115 ""grammar.c"" /* yacc.c:1646  */
  case 84:
#line 1471 ""grammar.y"" /* yacc.c:1646  */
#line 3131 ""grammar.c"" /* yacc.c:1646  */
  case 85:
#line 1483 ""grammar.y"" /* yacc.c:1646  */
#line 3146 ""grammar.c"" /* yacc.c:1646  */
  case 86:
#line 1498 ""grammar.y"" /* yacc.c:1646  */
#line 3155 ""grammar.c"" /* yacc.c:1646  */
  case 88:
#line 1504 ""grammar.y"" /* yacc.c:1646  */
#line 3166 ""grammar.c"" /* yacc.c:1646  */
  case 91:
#line 1521 ""grammar.y"" /* yacc.c:1646  */
#line 3177 ""grammar.c"" /* yacc.c:1646  */
  case 92:
#line 1528 ""grammar.y"" /* yacc.c:1646  */
#line 3188 ""grammar.c"" /* yacc.c:1646  */
  case 94:
#line 1540 ""grammar.y"" /* yacc.c:1646  */
#line 3196 ""grammar.c"" /* yacc.c:1646  */
  case 95:
#line 1544 ""grammar.y"" /* yacc.c:1646  */
#line 3204 ""grammar.c"" /* yacc.c:1646  */
  case 96:
#line 1552 ""grammar.y"" /* yacc.c:1646  */
#line 3212 ""grammar.c"" /* yacc.c:1646  */
  case 97:
#line 1556 ""grammar.y"" /* yacc.c:1646  */
#line 3226 ""grammar.c"" /* yacc.c:1646  */
  case 98:
#line 1566 ""grammar.y"" /* yacc.c:1646  */
#line 3244 ""grammar.c"" /* yacc.c:1646  */
  case 99:
#line 1580 ""grammar.y"" /* yacc.c:1646  */
#line 3264 ""grammar.c"" /* yacc.c:1646  */
  case 100:
#line 1596 ""grammar.y"" /* yacc.c:1646  */
#line 3278 ""grammar.c"" /* yacc.c:1646  */
  case 101:
#line 1606 ""grammar.y"" /* yacc.c:1646  */
#line 3291 ""grammar.c"" /* yacc.c:1646  */
  case 102:
#line 1615 ""grammar.y"" /* yacc.c:1646  */
#line 3320 ""grammar.c"" /* yacc.c:1646  */
  case 103:
#line 1640 ""grammar.y"" /* yacc.c:1646  */
#line 3336 ""grammar.c"" /* yacc.c:1646  */
  case 104:
#line 1652 ""grammar.y"" /* yacc.c:1646  */
#line 3352 ""grammar.c"" /* yacc.c:1646  */
  case 105:
#line 1664 ""grammar.y"" /* yacc.c:1646  */
#line 3372 ""grammar.c"" /* yacc.c:1646  */
  case 106:
#line 1680 ""grammar.y"" /* yacc.c:1646  */
#line 3388 ""grammar.c"" /* yacc.c:1646  */
  case 107:
#line 1692 ""grammar.y"" /* yacc.c:1646  */
#line 3408 ""grammar.c"" /* yacc.c:1646  */
  case 108:
#line 1708 ""grammar.y"" /* yacc.c:1646  */
#line 3457 ""grammar.c"" /* yacc.c:1646  */
  case 109:
#line 1753 ""grammar.y"" /* yacc.c:1646  */
#line 3480 ""grammar.c"" /* yacc.c:1646  */
  case 110:
#line 1772 ""grammar.y"" /* yacc.c:1646  */
#line 3502 ""grammar.c"" /* yacc.c:1646  */
  case 111:
#line 1790 ""grammar.y"" /* yacc.c:1646  */
#line 3524 ""grammar.c"" /* yacc.c:1646  */
  case 112:
#line 1808 ""grammar.y"" /* yacc.c:1646  */
#line 3546 ""grammar.c"" /* yacc.c:1646  */
  case 113:
#line 1826 ""grammar.y"" /* yacc.c:1646  */
#line 3576 ""grammar.c"" /* yacc.c:1646  */
  case 114:
#line 1852 ""grammar.y"" /* yacc.c:1646  */
#line 3598 ""grammar.c"" /* yacc.c:1646  */
  case 115:
#line 1870 ""grammar.y"" /* yacc.c:1646  */
#line 3612 ""grammar.c"" /* yacc.c:1646  */
  case 116:
#line 1880 ""grammar.y"" /* yacc.c:1646  */
#line 3626 ""grammar.c"" /* yacc.c:1646  */
  case 117:
#line 1890 ""grammar.y"" /* yacc.c:1646  */
#line 3640 ""grammar.c"" /* yacc.c:1646  */
  case 118:
#line 1900 ""grammar.y"" /* yacc.c:1646  */
#line 3654 ""grammar.c"" /* yacc.c:1646  */
  case 119:
#line 1910 ""grammar.y"" /* yacc.c:1646  */
#line 3668 ""grammar.c"" /* yacc.c:1646  */
  case 120:
#line 1920 ""grammar.y"" /* yacc.c:1646  */
#line 3682 ""grammar.c"" /* yacc.c:1646  */
  case 121:
#line 1930 ""grammar.y"" /* yacc.c:1646  */
#line 3690 ""grammar.c"" /* yacc.c:1646  */
#line 3694 ""grammar.c"" /* yacc.c:1646  */
",,"@@ -546,16 +546,16 @@ union yyalloc
 /* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  2
 /* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   408
+#define YYLAST   406
 
 /* YYNTOKENS -- Number of terminals.  */
 #define YYNTOKENS  72
 /* YYNNTS -- Number of nonterminals.  */
 #define YYNNTS  41
 /* YYNRULES -- Number of rules.  */
-#define YYNRULES  121
+#define YYNRULES  122
 /* YYNSTATES -- Number of states.  */
-#define YYNSTATES  209
+#define YYNSTATES  210
 
 /* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
    by yylex, with out-of-bounds checking.  */
@@ -612,13 +612,13 @@ static const yytype_uint16 yyrline[] =
      472,   485,   502,   503,   509,   508,   524,   523,   539,   553,
      554,   559,   560,   561,   562,   567,   652,   698,   756,   801,
      802,   806,   831,   867,   913,   935,   944,   953,   968,   980,
-     994,  1007,  1019,  1049,  1018,  1163,  1162,  1241,  1247,  1254,
-    1253,  1316,  1315,  1376,  1385,  1394,  1403,  1412,  1421,  1430,
-    1434,  1442,  1443,  1448,  1470,  1482,  1498,  1497,  1503,  1514,
-    1515,  1520,  1527,  1538,  1539,  1543,  1551,  1555,  1565,  1579,
-    1595,  1605,  1614,  1639,  1651,  1663,  1679,  1691,  1707,  1752,
-    1771,  1789,  1807,  1825,  1851,  1869,  1879,  1889,  1899,  1909,
-    1919,  1929
+     994,  1007,  1018,  1024,  1054,  1023,  1168,  1167,  1246,  1252,
+    1259,  1258,  1321,  1320,  1381,  1390,  1399,  1408,  1417,  1426,
+    1435,  1439,  1447,  1448,  1453,  1475,  1487,  1503,  1502,  1508,
+    1519,  1520,  1525,  1532,  1543,  1544,  1548,  1556,  1560,  1570,
+    1584,  1600,  1610,  1619,  1644,  1656,  1668,  1684,  1696,  1712,
+    1757,  1776,  1794,  1812,  1830,  1856,  1874,  1884,  1894,  1904,
+    1914,  1924,  1934
 };
 #endif
 
@@ -672,7 +672,7 @@ static const yytype_uint16 yytoknum[] =
 #define yypact_value_is_default(Yystate) \
   (!!((Yystate) == (-73)))
 
-#define YYTABLE_NINF -94
+#define YYTABLE_NINF -95
 
 #define yytable_value_is_error(Yytable_value) \
   0
@@ -681,27 +681,27 @@ static const yytype_uint16 yytoknum[] =
      STATE-NUM.  */
 static const yytype_int16 yypact[] =
 {
-     -73,    79,   -73,   -32,    -4,   -73,   -73,    94,   -73,   -73,
-     -73,   -73,    13,   -73,   -73,   -73,   -73,    -8,    72,     6,
-     -73,    78,   111,   -73,    61,   122,   123,    82,   -73,    90,
-     123,   -73,   147,   150,    16,   -73,    96,   147,   -73,   101,
-      97,   -73,   -73,   -73,   -73,   151,    53,   -73,    48,   -73,
-     -73,   -73,   149,   145,   -73,    -9,   -73,   103,   107,   -73,
-     -73,   106,   -73,   -73,   -73,   -73,   -73,   -73,   110,   -73,
-     -73,   135,    48,   135,    48,   -33,   -73,    64,   -73,   144,
-     306,   -73,   -73,   135,   108,   135,   135,   135,   135,    -7,
-     322,   -73,   -73,   -73,    64,   117,   163,   168,   135,    48,
-     -73,   -73,    -6,   167,   135,   135,   135,   135,   135,   135,
-     135,   135,   135,   135,   135,   135,   135,   135,   135,   135,
-     135,    86,    86,   322,   135,   -73,   243,   261,   183,   203,
-     159,    -6,   -73,   -73,   -73,   279,   121,   125,    95,    48,
-      48,   -73,   -73,   -73,   -73,   322,   337,   351,   -43,   322,
-     322,   322,   322,   322,   322,    40,    40,    58,    58,   -73,
-     -73,   -73,   -73,   -73,   -73,   -73,   -73,   129,   -73,   -73,
-     -73,   -73,   128,   -73,   -73,    48,   152,   -73,    15,   135,
-     131,   -73,    95,   -73,   -73,    71,   -73,   223,   135,   133,
-     -73,   132,   -73,    15,   -73,    73,   129,   -73,    48,   -73,
-     -73,   135,   134,    31,   322,    48,   -73,    49,   -73
+     -73,    90,   -73,   -32,   -10,   -73,   -73,    93,   -73,   -73,
+     -73,   -73,     1,   -73,   -73,   -73,   -73,   -49,     7,   -36,
+     -73,    20,    26,   -73,   -28,    92,    46,     4,   -73,    40,
+      46,   -73,   100,   119,    16,   -73,    72,   100,   -73,    77,
+      83,   -73,   -73,   -73,   -73,   134,    59,   -73,    48,   -73,
+     -73,   -73,   133,   136,   -73,   -18,   -73,    88,    95,   -73,
+     -73,    91,   -73,   -73,   -73,   -73,   -73,   -73,   102,   -73,
+     -73,   126,    48,   126,    48,   -44,   -73,    85,   -73,   127,
+     297,   -73,   -73,   126,   110,   126,   126,   126,   126,     2,
+     313,   -73,   -73,   -73,    85,   111,   154,   172,   126,    48,
+     -73,   -73,    -6,   162,   126,   126,   126,   126,   126,   126,
+     126,   126,   126,   126,   126,   126,   126,   126,   126,   126,
+     126,    60,    60,   313,   126,   -73,   234,   252,   174,   194,
+     -73,   153,    -6,   -73,   -73,   -73,   270,   117,   120,   108,
+      48,    48,   -73,   -73,   -73,   -73,   313,   328,   342,   349,
+     313,   313,   313,   313,   313,   313,   113,   113,    53,    53,
+     -73,   -73,   -73,   -73,   -73,   -73,   -73,   -73,   121,   -73,
+     -73,   -73,   -73,   124,   -73,   -73,    48,   151,   -73,    -1,
+     126,   125,   -73,   108,   -73,   -73,    18,   -73,   214,   126,
+     129,   -73,   143,   -73,    -1,   -73,    63,   121,   -73,    48,
+     -73,   -73,   126,   144,    31,   313,    48,   -73,    33,   -73
 };
 
   /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
@@ -714,31 +714,31 @@ static const yytype_uint8 yydefact[] =
       23,    22,    12,    24,     0,    14,     0,     0,    10,     0,
       13,    25,     0,     0,     0,    26,     0,    15,    32,     0,
        0,    28,    27,    30,    31,     0,    34,    33,     0,    11,
-      29,    38,     0,     0,    45,    59,   103,   105,   107,   100,
-     101,     0,   102,    53,    97,    98,    94,    95,     0,    55,
-      56,     0,     0,     0,     0,   108,   121,    16,    54,     0,
-      79,    39,    39,     0,     0,     0,     0,     0,     0,     0,
-      93,   109,    68,   118,     0,    54,    79,     0,     0,    49,
-      71,    69,     0,     0,     0,     0,     0,     0,     0,     0,
+      29,    38,     0,     0,    45,    59,   104,   106,   108,   101,
+     102,     0,   103,    53,    98,    99,    95,    96,     0,    55,
+      56,     0,     0,     0,     0,   109,   122,    16,    54,     0,
+      80,    39,    39,     0,     0,     0,     0,     0,     0,     0,
+      94,   110,    69,   119,     0,    54,    80,     0,     0,    49,
+      72,    70,     0,     0,     0,     0,     0,     0,     0,     0,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
        0,    35,    37,    60,     0,    61,     0,     0,     0,     0,
-       0,     0,    80,    96,    46,     0,     0,    50,    51,     0,
-       0,    88,    86,    67,    57,    58,   117,   115,   116,    77,
-      78,    73,    75,    74,    76,   119,   120,   110,   111,   112,
-     113,   114,    42,    41,    43,    44,    40,     0,   104,   106,
-      99,    62,     0,    47,    48,     0,    72,    70,     0,     0,
-       0,    65,    52,    91,    92,     0,    89,     0,     0,     0,
-      82,     0,    87,     0,    83,     0,    84,    63,     0,    90,
-      81,     0,     0,     0,    85,     0,    66,     0,    64
+      62,     0,     0,    81,    97,    46,     0,     0,    50,    51,
+       0,     0,    89,    87,    68,    57,    58,   118,   116,   117,
+      78,    79,    74,    76,    75,    77,   120,   121,   111,   112,
+     113,   114,   115,    42,    41,    43,    44,    40,     0,   105,
+     107,   100,    63,     0,    47,    48,     0,    73,    71,     0,
+       0,     0,    66,    52,    92,    93,     0,    90,     0,     0,
+       0,    83,     0,    88,     0,    84,     0,    85,    64,     0,
+      91,    82,     0,     0,     0,    86,     0,    67,     0,    65
 };
 
   /* YYPGOTO[NTERM-NUM].  */
 static const yytype_int16 yypgoto[] =
 {
-     -73,   -73,   199,   218,   -73,   -73,   -73,   -73,   -73,   -73,
-     -73,   -73,   -73,   -73,   192,   -73,   186,   -73,   -73,   142,
-     -73,   -73,   -73,   -73,   126,   -48,   -72,   -73,   -73,   -73,
-     -73,   -73,   -73,    50,   -73,   100,   -73,   -73,    35,   164,
+     -73,   -73,   211,   212,   -73,   -73,   -73,   -73,   -73,   -73,
+     -73,   -73,   -73,   -73,   189,   -73,   183,   -73,   -73,   139,
+     -73,   -73,   -73,   -73,   130,   -48,   -72,   -73,   -73,   -73,
+     -73,   -73,   -73,    41,   -73,   103,   -73,   -73,    29,   164,
      -67
 };
 
@@ -747,8 +747,8 @@ static const yytype_int16 yydefgoto[] =
 {
       -1,     1,     5,     6,    17,    33,    25,    28,    40,     7,
       15,    19,    21,    30,    31,    37,    38,    52,    53,   121,
-     166,    75,   136,   137,    76,    94,    78,   180,   202,   191,
-     140,   139,   189,   125,   195,   143,   178,   185,   186,    79,
+     167,    75,   137,   138,    76,    94,    78,   181,   203,   192,
+     141,   140,   190,   125,   196,   144,   179,   186,   187,    79,
       80
 };
 
@@ -757,92 +757,92 @@ static const yytype_int16 yydefgoto[] =
      number is the opposite.  If YYTABLE_NINF, syntax error.  */
 static const yytype_int16 yytable[] =
 {
-      77,    90,    95,   130,    91,     4,    93,    96,   114,   115,
-     116,   117,   118,   119,   120,    11,   123,    83,   126,   127,
-     128,   129,    84,    16,    92,   131,   183,   138,   141,     8,
-     184,   135,    41,    97,    98,    42,    99,   145,   146,   147,
-     148,   149,   150,   151,   152,   153,   154,   155,   156,   157,
-     158,   159,   160,   161,    43,    44,    18,   167,    54,    55,
-      56,    57,    58,   142,    59,    60,    61,    62,    22,    63,
-      45,   100,   101,    51,   -36,    64,    65,    66,    67,     2,
-       3,    68,    20,   -17,   -17,   -17,    69,    70,    23,   100,
-     101,   176,   177,   116,   117,   118,   119,   120,    12,    13,
-      14,   206,    71,   182,   100,   101,    72,    73,   162,   163,
-     164,   165,   187,   118,   119,   120,     4,    74,    24,   208,
-      54,   196,    56,    57,    58,    26,    59,    60,    61,    62,
-      27,    63,   179,    29,   204,   -54,   -54,    64,    65,    66,
-      67,   192,   193,   200,   201,    54,    32,    56,    57,    58,
-     203,    59,    60,    61,    62,    34,    63,   207,    36,    39,
-      49,    46,    64,    65,    71,    48,    82,    50,    81,    73,
-      85,   105,   106,   107,    86,    87,   102,   124,   134,    88,
-     114,   115,   116,   117,   118,   119,   120,   132,    63,    71,
-     171,   174,   181,   101,    73,   -93,   175,   197,   103,   104,
-     188,   198,     9,   205,    88,   105,   106,   107,   108,   109,
-     110,   111,   112,   113,   114,   115,   116,   117,   118,   119,
-     120,    10,    35,    47,   122,   105,   106,   107,   199,   144,
-     190,   172,    89,   133,   114,   115,   116,   117,   118,   119,
-     120,     0,     0,     0,     0,   105,   106,   107,     0,     0,
-       0,     0,     0,   170,   114,   115,   116,   117,   118,   119,
-     120,     0,     0,     0,     0,   105,   106,   107,     0,     0,
-       0,     0,     0,   133,   114,   115,   116,   117,   118,   119,
-     120,     0,     0,     0,     0,   105,   106,   107,     0,     0,
-       0,     0,     0,   194,   114,   115,   116,   117,   118,   119,
-     120,     0,     0,   105,   106,   107,     0,     0,     0,     0,
-       0,   168,   114,   115,   116,   117,   118,   119,   120,     0,
-       0,   105,   106,   107,     0,     0,     0,     0,     0,   169,
-     114,   115,   116,   117,   118,   119,   120,     0,   -93,     0,
-       0,   103,   104,     0,     0,     0,     0,   173,   105,   106,
-     107,   108,   109,   110,   111,   112,   113,   114,   115,   116,
-     117,   118,   119,   120,   105,   106,   107,     0,     0,     0,
+      77,    90,    95,   130,    91,     4,    93,    96,    83,    11,
+     184,    16,   131,    84,   185,    18,   123,    20,   126,   127,
+     128,   129,    97,    98,    92,    99,    22,   139,   142,     8,
+      23,   136,    41,    24,   132,    42,    26,   146,   147,   148,
+     149,   150,   151,   152,   153,   154,   155,   156,   157,   158,
+     159,   160,   161,   162,    43,    44,    29,   168,    54,    55,
+      56,    57,    58,   143,    59,    60,    61,    62,    32,    63,
+      45,   100,   101,   100,   101,    64,    65,    66,    67,    51,
+     -36,    68,   163,   164,   165,   166,    69,    70,   193,   194,
+       2,     3,   177,   178,   -17,   -17,   -17,    12,    13,    14,
+      27,   207,    71,   209,   183,    34,    72,    73,   118,   119,
+     120,    36,    54,   188,    56,    57,    58,    74,    59,    60,
+      61,    62,   197,    63,   180,   100,   101,     4,    39,    64,
+      65,    66,    67,   201,   202,   205,    54,    46,    56,    57,
+      58,    48,    59,    60,    61,    62,    49,    63,   -54,   -54,
+      50,   204,    81,    64,    65,    85,    71,    82,   208,   102,
+      87,    73,    86,   105,   106,   107,   116,   117,   118,   119,
+     120,    88,   114,   115,   116,   117,   118,   119,   120,   124,
+      71,   133,   135,    63,   172,    73,   -94,   175,   182,   103,
+     104,   176,   101,   198,   189,    88,   105,   106,   107,   108,
+     109,   110,   111,   112,   113,   114,   115,   116,   117,   118,
+     119,   120,   199,   206,     9,    10,   105,   106,   107,    35,
+      47,   122,   191,   200,   134,   114,   115,   116,   117,   118,
+     119,   120,    89,   145,     0,   173,   105,   106,   107,     0,
+       0,     0,     0,     0,   171,   114,   115,   116,   117,   118,
+     119,   120,     0,     0,     0,     0,   105,   106,   107,     0,
+       0,     0,     0,     0,   134,   114,   115,   116,   117,   118,
+     119,   120,     0,     0,     0,     0,   105,   106,   107,     0,
+       0,     0,     0,     0,   195,   114,   115,   116,   117,   118,
+     119,   120,     0,     0,   105,   106,   107,     0,     0,     0,
+       0,     0,   169,   114,   115,   116,   117,   118,   119,   120,
+       0,     0,   105,   106,   107,     0,     0,     0,     0,     0,
+     170,   114,   115,   116,   117,   118,   119,   120,     0,   -94,
+       0,     0,   103,   104,     0,     0,     0,     0,   174,   105,
+     106,   107,   108,   109,   110,   111,   112,   113,   114,   115,
+     116,   117,   118,   119,   120,   105,   106,   107,     0,     0,
+       0,     0,     0,     0,   114,   115,   116,   117,   118,   119,
+     120,   106,   107,     0,     0,     0,     0,     0,     0,   114,
+     115,   116,   117,   118,   119,   120,   107,     0,     0,     0,
        0,     0,     0,   114,   115,   116,   117,   118,   119,   120,
-     106,   107,     0,     0,     0,     0,     0,     0,   114,   115,
-     116,   117,   118,   119,   120,   107,     0,     0,     0,     0,
-       0,     0,   114,   115,   116,   117,   118,   119,   120
+     114,   115,   116,   117,   118,   119,   120
 };
 
 static const yytype_int16 yycheck[] =
 {
-      48,    68,    74,    10,    71,    37,    73,    74,    51,    52,
-      53,    54,    55,    56,    57,    19,    83,    26,    85,    86,
-      87,    88,    31,    10,    72,    32,    11,    99,    34,    61,
-      15,    98,    16,    66,    67,    19,    69,   104,   105,   106,
+      48,    68,    74,     1,    71,    37,    73,    74,    26,    19,
+      11,    10,    10,    31,    15,    64,    83,    10,    85,    86,
+      87,    88,    66,    67,    72,    69,    62,    99,    34,    61,
+      10,    98,    16,     7,    32,    19,    64,   104,   105,   106,
      107,   108,   109,   110,   111,   112,   113,   114,   115,   116,
-     117,   118,   119,   120,    38,    39,    64,   124,    10,    11,
-      12,    13,    14,    69,    16,    17,    18,    19,    62,    21,
-      54,    40,    41,    20,    21,    27,    28,    29,    30,     0,
-       1,    33,    10,     4,     5,     6,    38,    39,    10,    40,
-      41,   139,   140,    53,    54,    55,    56,    57,     4,     5,
-       6,    70,    54,   175,    40,    41,    58,    59,    22,    23,
-      24,    25,   179,    55,    56,    57,    37,    69,     7,    70,
-      10,   188,    12,    13,    14,    64,    16,    17,    18,    19,
-       8,    21,     3,    10,   201,    40,    41,    27,    28,    29,
-      30,    70,    71,    70,    71,    10,    64,    12,    13,    14,
-     198,    16,    17,    18,    19,    65,    21,   205,    11,     9,
-      63,    65,    27,    28,    54,    64,    21,    16,    19,    59,
-      67,    42,    43,    44,    67,    69,    32,    69,    10,    69,
-      51,    52,    53,    54,    55,    56,    57,    70,    21,    54,
-      31,    70,    64,    41,    59,    32,    71,    64,    35,    36,
-      69,    69,     3,    69,    69,    42,    43,    44,    45,    46,
-      47,    48,    49,    50,    51,    52,    53,    54,    55,    56,
-      57,     3,    30,    37,    82,    42,    43,    44,   193,   103,
-     180,   131,    68,    70,    51,    52,    53,    54,    55,    56,
-      57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,    -1,
-      -1,    -1,    -1,    70,    51,    52,    53,    54,    55,    56,
-      57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,    -1,
-      -1,    -1,    -1,    70,    51,    52,    53,    54,    55,    56,
-      57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,    -1,
-      -1,    -1,    -1,    70,    51,    52,    53,    54,    55,    56,
-      57,    -1,    -1,    42,    43,    44,    -1,    -1,    -1,    -1,
-      -1,    68,    51,    52,    53,    54,    55,    56,    57,    -1,
-      -1,    42,    43,    44,    -1,    -1,    -1,    -1,    -1,    68,
-      51,    52,    53,    54,    55,    56,    57,    -1,    32,    -1,
-      -1,    35,    36,    -1,    -1,    -1,    -1,    68,    42,    43,
-      44,    45,    46,    47,    48,    49,    50,    51,    52,    53,
-      54,    55,    56,    57,    42,    43,    44,    -1,    -1,    -1,
+     117,   118,   119,   120,    38,    39,    10,   124,    10,    11,
+      12,    13,    14,    69,    16,    17,    18,    19,    64,    21,
+      54,    40,    41,    40,    41,    27,    28,    29,    30,    20,
+      21,    33,    22,    23,    24,    25,    38,    39,    70,    71,
+       0,     1,   140,   141,     4,     5,     6,     4,     5,     6,
+       8,    70,    54,    70,   176,    65,    58,    59,    55,    56,
+      57,    11,    10,   180,    12,    13,    14,    69,    16,    17,
+      18,    19,   189,    21,     3,    40,    41,    37,     9,    27,
+      28,    29,    30,    70,    71,   202,    10,    65,    12,    13,
+      14,    64,    16,    17,    18,    19,    63,    21,    40,    41,
+      16,   199,    19,    27,    28,    67,    54,    21,   206,    32,
+      69,    59,    67,    42,    43,    44,    53,    54,    55,    56,
+      57,    69,    51,    52,    53,    54,    55,    56,    57,    69,
+      54,    70,    10,    21,    31,    59,    32,    70,    64,    35,
+      36,    71,    41,    64,    69,    69,    42,    43,    44,    45,
+      46,    47,    48,    49,    50,    51,    52,    53,    54,    55,
+      56,    57,    69,    69,     3,     3,    42,    43,    44,    30,
+      37,    82,   181,   194,    70,    51,    52,    53,    54,    55,
+      56,    57,    68,   103,    -1,   132,    42,    43,    44,    -1,
+      -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,    55,
+      56,    57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,
+      -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,    55,
+      56,    57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,
+      -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,    55,
+      56,    57,    -1,    -1,    42,    43,    44,    -1,    -1,    -1,
+      -1,    -1,    68,    51,    52,    53,    54,    55,    56,    57,
+      -1,    -1,    42,    43,    44,    -1,    -1,    -1,    -1,    -1,
+      68,    51,    52,    53,    54,    55,    56,    57,    -1,    32,
+      -1,    -1,    35,    36,    -1,    -1,    -1,    -1,    68,    42,
+      43,    44,    45,    46,    47,    48,    49,    50,    51,    52,
+      53,    54,    55,    56,    57,    42,    43,    44,    -1,    -1,
+      -1,    -1,    -1,    -1,    51,    52,    53,    54,    55,    56,
+      57,    43,    44,    -1,    -1,    -1,    -1,    -1,    -1,    51,
+      52,    53,    54,    55,    56,    57,    44,    -1,    -1,    -1,
       -1,    -1,    -1,    51,    52,    53,    54,    55,    56,    57,
-      43,    44,    -1,    -1,    -1,    -1,    -1,    -1,    51,    52,
-      53,    54,    55,    56,    57,    44,    -1,    -1,    -1,    -1,
-      -1,    -1,    51,    52,    53,    54,    55,    56,    57
+      51,    52,    53,    54,    55,    56,    57
 };
 
   /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
@@ -862,14 +862,14 @@ static const yytype_uint8 yystos[] =
       40,    41,    32,    35,    36,    42,    43,    44,    45,    46,
       47,    48,    49,    50,    51,    52,    53,    54,    55,    56,
       57,    91,    91,   112,    69,   105,   112,   112,   112,   112,
-      10,    32,    70,    70,    10,   112,    94,    95,    98,   103,
-     102,    34,    69,   107,    96,   112,   112,   112,   112,   112,
+       1,    10,    32,    70,    70,    10,   112,    94,    95,    98,
+     103,   102,    34,    69,   107,    96,   112,   112,   112,   112,
      112,   112,   112,   112,   112,   112,   112,   112,   112,   112,
-     112,   112,    22,    23,    24,    25,    92,   112,    68,    68,
-      70,    31,   107,    68,    70,    71,    97,    97,   108,     3,
-      99,    64,    98,    11,    15,   109,   110,   112,    69,   104,
-     105,   101,    70,    71,    70,   106,   112,    64,    69,   110,
-      70,    71,   100,    97,   112,    69,    70,    97,    70
+     112,   112,   112,    22,    23,    24,    25,    92,   112,    68,
+      68,    70,    31,   107,    68,    70,    71,    97,    97,   108,
+       3,    99,    64,    98,    11,    15,   109,   110,   112,    69,
+     104,   105,   101,    70,    71,    70,   106,   112,    64,    69,
+     110,    70,    71,   100,    97,   112,    69,    70,    97,    70
 };
 
   /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
@@ -881,13 +881,13 @@ static const yytype_uint8 yyr1[] =
       86,    86,    87,    87,    89,    88,    90,    88,    88,    91,
       91,    92,    92,    92,    92,    93,    93,    93,    93,    94,
       94,    95,    95,    96,    97,    98,    98,    98,    98,    98,
-      98,    98,    99,   100,    98,   101,    98,    98,    98,   102,
-      98,   103,    98,    98,    98,    98,    98,    98,    98,    98,
-      98,   104,   104,   105,   106,   106,   108,   107,   107,   109,
-     109,   110,   110,   111,   111,   111,   112,   112,   112,   112,
+      98,    98,    98,    99,   100,    98,   101,    98,    98,    98,
+     102,    98,   103,    98,    98,    98,    98,    98,    98,    98,
+      98,    98,   104,   104,   105,   106,   106,   108,   107,   107,
+     109,   109,   110,   110,   111,   111,   111,   112,   112,   112,
      112,   112,   112,   112,   112,   112,   112,   112,   112,   112,
      112,   112,   112,   112,   112,   112,   112,   112,   112,   112,
-     112,   112
+     112,   112,   112
 };
 
   /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
@@ -899,13 +899,13 @@ static const yytype_uint8 yyr2[] =
        3,     3,     1,     2,     0,     5,     0,     5,     3,     0,
        2,     1,     1,     1,     1,     1,     3,     4,     4,     0,
        1,     1,     3,     1,     1,     1,     1,     3,     3,     1,
-       3,     3,     0,     0,    11,     0,     9,     3,     2,     0,
-       4,     0,     4,     3,     3,     3,     3,     3,     3,     1,
-       3,     3,     1,     5,     1,     3,     0,     4,     1,     1,
-       3,     1,     1,     1,     1,     1,     3,     1,     1,     4,
-       1,     1,     1,     1,     4,     1,     4,     1,     1,     2,
-       3,     3,     3,     3,     3,     3,     3,     3,     2,     3,
-       3,     1
+       3,     3,     3,     0,     0,    11,     0,     9,     3,     2,
+       0,     4,     0,     4,     3,     3,     3,     3,     3,     3,
+       1,     3,     3,     1,     5,     1,     3,     0,     4,     1,
+       1,     3,     1,     1,     1,     1,     1,     3,     1,     1,
+       4,     1,     1,     1,     1,     4,     1,     4,     1,     1,
+       2,     3,     3,     3,     3,     3,     3,     3,     3,     2,
+       3,     3,     1
 };
 
 
@@ -2586,6 +2586,15 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
   case 62:
 #line 1019 ""grammar.y"" /* yacc.c:1646  */
+    {
+        compiler->loop_depth--;
+        compiler->loop_identifier[compiler->loop_depth] = NULL;
+      }
+#line 2594 ""grammar.c"" /* yacc.c:1646  */
+    break;
+
+  case 63:
+#line 1024 ""grammar.y"" /* yacc.c:1646  */
     {
         int var_index;
 
@@ -2615,11 +2624,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
-#line 2619 ""grammar.c"" /* yacc.c:1646  */
+#line 2628 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 63:
-#line 1049 ""grammar.y"" /* yacc.c:1646  */
+  case 64:
+#line 1054 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;
@@ -2654,11 +2663,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
         compiler->loop_depth++;
       }
-#line 2658 ""grammar.c"" /* yacc.c:1646  */
+#line 2667 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 64:
-#line 1084 ""grammar.y"" /* yacc.c:1646  */
+  case 65:
+#line 1089 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
@@ -2737,11 +2746,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 2741 ""grammar.c"" /* yacc.c:1646  */
+#line 2750 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 65:
-#line 1163 ""grammar.y"" /* yacc.c:1646  */
+  case 66:
+#line 1168 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;
@@ -2771,11 +2780,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         compiler->loop_identifier[compiler->loop_depth] = NULL;
         compiler->loop_depth++;
       }
-#line 2775 ""grammar.c"" /* yacc.c:1646  */
+#line 2784 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 66:
-#line 1193 ""grammar.y"" /* yacc.c:1646  */
+  case 67:
+#line 1198 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
@@ -2824,31 +2833,31 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
 
       }
-#line 2828 ""grammar.c"" /* yacc.c:1646  */
+#line 2837 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 67:
-#line 1242 ""grammar.y"" /* yacc.c:1646  */
+  case 68:
+#line 1247 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_OF, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 2838 ""grammar.c"" /* yacc.c:1646  */
+#line 2847 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 68:
-#line 1248 ""grammar.y"" /* yacc.c:1646  */
+  case 69:
+#line 1253 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_NOT, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 2848 ""grammar.c"" /* yacc.c:1646  */
+#line 2857 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 69:
-#line 1254 ""grammar.y"" /* yacc.c:1646  */
+  case 70:
+#line 1259 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;
@@ -2874,11 +2883,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
-#line 2878 ""grammar.c"" /* yacc.c:1646  */
+#line 2887 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 70:
-#line 1280 ""grammar.y"" /* yacc.c:1646  */
+  case 71:
+#line 1285 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* and_addr;
@@ -2914,11 +2923,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 2918 ""grammar.c"" /* yacc.c:1646  */
+#line 2927 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 71:
-#line 1316 ""grammar.y"" /* yacc.c:1646  */
+  case 72:
+#line 1321 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;
@@ -2943,11 +2952,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
-#line 2947 ""grammar.c"" /* yacc.c:1646  */
+#line 2956 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 72:
-#line 1341 ""grammar.y"" /* yacc.c:1646  */
+  case 73:
+#line 1346 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* or_addr;
@@ -2983,11 +2992,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 2987 ""grammar.c"" /* yacc.c:1646  */
+#line 2996 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 73:
-#line 1377 ""grammar.y"" /* yacc.c:1646  */
+  case 74:
+#line 1382 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<"", (yyvsp[-2].expression), (yyvsp[0].expression));
@@ -2996,11 +3005,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 3000 ""grammar.c"" /* yacc.c:1646  */
+#line 3009 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 74:
-#line 1386 ""grammar.y"" /* yacc.c:1646  */
+  case 75:
+#line 1391 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">"", (yyvsp[-2].expression), (yyvsp[0].expression));
@@ -3009,11 +3018,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 3013 ""grammar.c"" /* yacc.c:1646  */
+#line 3022 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 75:
-#line 1395 ""grammar.y"" /* yacc.c:1646  */
+  case 76:
+#line 1400 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<="", (yyvsp[-2].expression), (yyvsp[0].expression));
@@ -3022,11 +3031,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 3026 ""grammar.c"" /* yacc.c:1646  */
+#line 3035 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 76:
-#line 1404 ""grammar.y"" /* yacc.c:1646  */
+  case 77:
+#line 1409 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">="", (yyvsp[-2].expression), (yyvsp[0].expression));
@@ -3035,11 +3044,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 3039 ""grammar.c"" /* yacc.c:1646  */
+#line 3048 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 77:
-#line 1413 ""grammar.y"" /* yacc.c:1646  */
+  case 78:
+#line 1418 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""=="", (yyvsp[-2].expression), (yyvsp[0].expression));
@@ -3048,11 +3057,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 3052 ""grammar.c"" /* yacc.c:1646  */
+#line 3061 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 78:
-#line 1422 ""grammar.y"" /* yacc.c:1646  */
+  case 79:
+#line 1427 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""!="", (yyvsp[-2].expression), (yyvsp[0].expression));
@@ -3061,39 +3070,39 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 3065 ""grammar.c"" /* yacc.c:1646  */
+#line 3074 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 79:
-#line 1431 ""grammar.y"" /* yacc.c:1646  */
+  case 80:
+#line 1436 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
-#line 3073 ""grammar.c"" /* yacc.c:1646  */
+#line 3082 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 80:
-#line 1435 ""grammar.y"" /* yacc.c:1646  */
+  case 81:
+#line 1440 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
-#line 3081 ""grammar.c"" /* yacc.c:1646  */
+#line 3090 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 81:
-#line 1442 ""grammar.y"" /* yacc.c:1646  */
+  case 82:
+#line 1447 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_ENUMERATION; }
-#line 3087 ""grammar.c"" /* yacc.c:1646  */
+#line 3096 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 82:
-#line 1443 ""grammar.y"" /* yacc.c:1646  */
+  case 83:
+#line 1448 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_RANGE; }
-#line 3093 ""grammar.c"" /* yacc.c:1646  */
+#line 3102 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 83:
-#line 1449 ""grammar.y"" /* yacc.c:1646  */
+  case 84:
+#line 1454 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
         {
@@ -3111,11 +3120,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
-#line 3115 ""grammar.c"" /* yacc.c:1646  */
+#line 3124 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 84:
-#line 1471 ""grammar.y"" /* yacc.c:1646  */
+  case 85:
+#line 1476 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
@@ -3127,11 +3136,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
-#line 3131 ""grammar.c"" /* yacc.c:1646  */
+#line 3140 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 85:
-#line 1483 ""grammar.y"" /* yacc.c:1646  */
+  case 86:
+#line 1488 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
@@ -3142,77 +3151,77 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
-#line 3146 ""grammar.c"" /* yacc.c:1646  */
+#line 3155 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 86:
-#line 1498 ""grammar.y"" /* yacc.c:1646  */
+  case 87:
+#line 1503 ""grammar.y"" /* yacc.c:1646  */
     {
         // Push end-of-list marker
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
-#line 3155 ""grammar.c"" /* yacc.c:1646  */
+#line 3164 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 88:
-#line 1504 ""grammar.y"" /* yacc.c:1646  */
+  case 89:
+#line 1509 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
         yr_parser_emit_pushes_for_strings(yyscanner, ""$*"");
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
-#line 3166 ""grammar.c"" /* yacc.c:1646  */
+#line 3175 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 91:
-#line 1521 ""grammar.y"" /* yacc.c:1646  */
+  case 92:
+#line 1526 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
-#line 3177 ""grammar.c"" /* yacc.c:1646  */
+#line 3186 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 92:
-#line 1528 ""grammar.y"" /* yacc.c:1646  */
+  case 93:
+#line 1533 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
-#line 3188 ""grammar.c"" /* yacc.c:1646  */
+#line 3197 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 94:
-#line 1540 ""grammar.y"" /* yacc.c:1646  */
+  case 95:
+#line 1545 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
-#line 3196 ""grammar.c"" /* yacc.c:1646  */
+#line 3205 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 95:
-#line 1544 ""grammar.y"" /* yacc.c:1646  */
+  case 96:
+#line 1549 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
       }
-#line 3204 ""grammar.c"" /* yacc.c:1646  */
+#line 3213 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 96:
-#line 1552 ""grammar.y"" /* yacc.c:1646  */
+  case 97:
+#line 1557 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
-#line 3212 ""grammar.c"" /* yacc.c:1646  */
+#line 3221 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 97:
-#line 1556 ""grammar.y"" /* yacc.c:1646  */
+  case 98:
+#line 1561 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit(
             yyscanner, OP_FILESIZE, NULL);
@@ -3222,11 +3231,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
-#line 3226 ""grammar.c"" /* yacc.c:1646  */
+#line 3235 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 98:
-#line 1566 ""grammar.y"" /* yacc.c:1646  */
+  case 99:
+#line 1571 ""grammar.y"" /* yacc.c:1646  */
     {
         yywarning(yyscanner,
             ""Using deprecated \""entrypoint\"" keyword. Use the \""entry_point\"" ""
@@ -3240,11 +3249,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
-#line 3244 ""grammar.c"" /* yacc.c:1646  */
+#line 3253 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 99:
-#line 1580 ""grammar.y"" /* yacc.c:1646  */
+  case 100:
+#line 1585 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, ""intXXXX or uintXXXX"");
 
@@ -3260,11 +3269,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
-#line 3264 ""grammar.c"" /* yacc.c:1646  */
+#line 3273 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 100:
-#line 1596 ""grammar.y"" /* yacc.c:1646  */
+  case 101:
+#line 1601 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);
@@ -3274,11 +3283,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = (yyvsp[0].integer);
       }
-#line 3278 ""grammar.c"" /* yacc.c:1646  */
+#line 3287 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 101:
-#line 1606 ""grammar.y"" /* yacc.c:1646  */
+  case 102:
+#line 1611 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg_double(
             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);
@@ -3287,11 +3296,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
       }
-#line 3291 ""grammar.c"" /* yacc.c:1646  */
+#line 3300 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 102:
-#line 1615 ""grammar.y"" /* yacc.c:1646  */
+  case 103:
+#line 1620 ""grammar.y"" /* yacc.c:1646  */
     {
         SIZED_STRING* sized_string;
 
@@ -3316,11 +3325,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_STRING;
         (yyval.expression).value.sized_string = sized_string;
       }
-#line 3320 ""grammar.c"" /* yacc.c:1646  */
+#line 3329 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 103:
-#line 1640 ""grammar.y"" /* yacc.c:1646  */
+  case 104:
+#line 1645 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);
@@ -3332,11 +3341,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
-#line 3336 ""grammar.c"" /* yacc.c:1646  */
+#line 3345 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 104:
-#line 1652 ""grammar.y"" /* yacc.c:1646  */
+  case 105:
+#line 1657 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);
@@ -3348,11 +3357,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
-#line 3352 ""grammar.c"" /* yacc.c:1646  */
+#line 3361 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 105:
-#line 1664 ""grammar.y"" /* yacc.c:1646  */
+  case 106:
+#line 1669 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);
@@ -3368,11 +3377,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
-#line 3372 ""grammar.c"" /* yacc.c:1646  */
+#line 3381 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 106:
-#line 1680 ""grammar.y"" /* yacc.c:1646  */
+  case 107:
+#line 1685 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);
@@ -3384,11 +3393,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
-#line 3388 ""grammar.c"" /* yacc.c:1646  */
+#line 3397 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 107:
-#line 1692 ""grammar.y"" /* yacc.c:1646  */
+  case 108:
+#line 1697 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);
@@ -3404,11 +3413,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
-#line 3408 ""grammar.c"" /* yacc.c:1646  */
+#line 3417 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 108:
-#line 1708 ""grammar.y"" /* yacc.c:1646  */
+  case 109:
+#line 1713 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier
         {
@@ -3453,11 +3462,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
-#line 3457 ""grammar.c"" /* yacc.c:1646  */
+#line 3466 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 109:
-#line 1753 ""grammar.y"" /* yacc.c:1646  */
+  case 110:
+#line 1758 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, ""-"");
 
@@ -3476,11 +3485,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
-#line 3480 ""grammar.c"" /* yacc.c:1646  */
+#line 3489 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 110:
-#line 1772 ""grammar.y"" /* yacc.c:1646  */
+  case 111:
+#line 1777 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""+"", (yyvsp[-2].expression), (yyvsp[0].expression));
@@ -3498,11 +3507,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
-#line 3502 ""grammar.c"" /* yacc.c:1646  */
+#line 3511 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 111:
-#line 1790 ""grammar.y"" /* yacc.c:1646  */
+  case 112:
+#line 1795 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""-"", (yyvsp[-2].expression), (yyvsp[0].expression));
@@ -3520,11 +3529,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
-#line 3524 ""grammar.c"" /* yacc.c:1646  */
+#line 3533 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 112:
-#line 1808 ""grammar.y"" /* yacc.c:1646  */
+  case 113:
+#line 1813 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""*"", (yyvsp[-2].expression), (yyvsp[0].expression));
@@ -3542,11 +3551,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
-#line 3546 ""grammar.c"" /* yacc.c:1646  */
+#line 3555 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 113:
-#line 1826 ""grammar.y"" /* yacc.c:1646  */
+  case 114:
+#line 1831 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""\\"", (yyvsp[-2].expression), (yyvsp[0].expression));
@@ -3572,11 +3581,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
-#line 3576 ""grammar.c"" /* yacc.c:1646  */
+#line 3585 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 114:
-#line 1852 ""grammar.y"" /* yacc.c:1646  */
+  case 115:
+#line 1857 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""%"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""%"");
@@ -3594,11 +3603,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         }
       }
-#line 3598 ""grammar.c"" /* yacc.c:1646  */
+#line 3607 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 115:
-#line 1870 ""grammar.y"" /* yacc.c:1646  */
+  case 116:
+#line 1875 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");
@@ -3608,11 +3617,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
-#line 3612 ""grammar.c"" /* yacc.c:1646  */
+#line 3621 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 116:
-#line 1880 ""grammar.y"" /* yacc.c:1646  */
+  case 117:
+#line 1885 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");
@@ -3622,11 +3631,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
-#line 3626 ""grammar.c"" /* yacc.c:1646  */
+#line 3635 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 117:
-#line 1890 ""grammar.y"" /* yacc.c:1646  */
+  case 118:
+#line 1895 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""|"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""|"");
@@ -3636,11 +3645,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
-#line 3640 ""grammar.c"" /* yacc.c:1646  */
+#line 3649 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 118:
-#line 1900 ""grammar.y"" /* yacc.c:1646  */
+  case 119:
+#line 1905 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""~"");
 
@@ -3650,11 +3659,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
             UNDEFINED : ~((yyvsp[0].expression).value.integer);
       }
-#line 3654 ""grammar.c"" /* yacc.c:1646  */
+#line 3663 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 119:
-#line 1910 ""grammar.y"" /* yacc.c:1646  */
+  case 120:
+#line 1915 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
@@ -3664,11 +3673,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
-#line 3668 ""grammar.c"" /* yacc.c:1646  */
+#line 3677 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 120:
-#line 1920 ""grammar.y"" /* yacc.c:1646  */
+  case 121:
+#line 1925 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "">>"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "">>"");
@@ -3678,19 +3687,19 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
-#line 3682 ""grammar.c"" /* yacc.c:1646  */
+#line 3691 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 121:
-#line 1930 ""grammar.y"" /* yacc.c:1646  */
+  case 122:
+#line 1935 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
-#line 3690 ""grammar.c"" /* yacc.c:1646  */
+#line 3699 ""grammar.c"" /* yacc.c:1646  */
     break;
 
 
-#line 3694 ""grammar.c"" /* yacc.c:1646  */
+#line 3703 ""grammar.c"" /* yacc.c:1646  */
       default: break;
     }
   /* User semantic actions sometimes alter yychar, and that requires
@@ -3918,5 +3927,5 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 #endif
   return yyresult;
 }
-#line 1935 ""grammar.y"" /* yacc.c:1906  */
+#line 1940 ""grammar.y"" /* yacc.c:1906  */
 ",yara,890c3f850293176c0e996a602ffa88b315f4e98f,eb491e03851a11bc811173f5e13c89cefa7257ac,1,"yyparse (void *yyscanner, YR_COMPILER* compiler)
{
/* The lookahead symbol.  */
int yychar;


/* The semantic value of the lookahead symbol.  */
/* Default value used for initialization, for pacifying older GCCs
   or non-GCC compilers.  */
YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);

    /* Number of syntax errors so far.  */
    int yynerrs;

    int yystate;
    /* Number of tokens to shift before error messages enabled.  */
    int yyerrstatus;

    /* The stacks and their tools:
       'yyss': related to states.
       'yyvs': related to semantic values.

       Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */

    /* The state stack.  */
    yytype_int16 yyssa[YYINITDEPTH];
    yytype_int16 *yyss;
    yytype_int16 *yyssp;

    /* The semantic value stack.  */
    YYSTYPE yyvsa[YYINITDEPTH];
    YYSTYPE *yyvs;
    YYSTYPE *yyvsp;

    YYSIZE_T yystacksize;

  int yyn;
  int yyresult;
  /* Lookahead token as an internal (translated) token number.  */
  int yytoken = 0;
  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;

#if YYERROR_VERBOSE
  /* Buffer for error messages, and its allocated size.  */
  char yymsgbuf[128];
  char *yymsg = yymsgbuf;
  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
#endif

#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))

  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  yyssp = yyss = yyssa;
  yyvsp = yyvs = yyvsa;
  yystacksize = YYINITDEPTH;

  YYDPRINTF ((stderr, ""Starting parse\n""));

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY; /* Cause a token to be read.  */
  goto yysetstate;

/*------------------------------------------------------------.
| yynewstate -- Push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
 yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;

 yysetstate:
  *yyssp = yystate;

  if (yyss + yystacksize - 1 <= yyssp)
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYSIZE_T yysize = yyssp - yyss + 1;

#ifdef yyoverflow
      {
        /* Give user a chance to reallocate the stack.  Use copies of
           these so that the &'s don't force the real ones into
           memory.  */
        YYSTYPE *yyvs1 = yyvs;
        yytype_int16 *yyss1 = yyss;

        /* Each stack pointer address is followed by the size of the
           data in use in that stack, in bytes.  This used to be a
           conditional around just the two extra args, but that might
           be undefined if yyoverflow is a macro.  */
        yyoverflow (YY_(""memory exhausted""),
                    &yyss1, yysize * sizeof (*yyssp),
                    &yyvs1, yysize * sizeof (*yyvsp),
                    &yystacksize);

        yyss = yyss1;
        yyvs = yyvs1;
      }
#else /* no yyoverflow */
# ifndef YYSTACK_RELOCATE
      goto yyexhaustedlab;
# else
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
        goto yyexhaustedlab;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
        yystacksize = YYMAXDEPTH;

      {
        yytype_int16 *yyss1 = yyss;
        union yyalloc *yyptr =
          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
        if (! yyptr)
          goto yyexhaustedlab;
        YYSTACK_RELOCATE (yyss_alloc, yyss);
        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
#  undef YYSTACK_RELOCATE
        if (yyss1 != yyssa)
          YYSTACK_FREE (yyss1);
      }
# endif
#endif /* no yyoverflow */

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;

      YYDPRINTF ((stderr, ""Stack size increased to %lu\n"",
                  (unsigned long int) yystacksize));

      if (yyss + yystacksize - 1 <= yyssp)
        YYABORT;
    }

  YYDPRINTF ((stderr, ""Entering state %d\n"", yystate));

  if (yystate == YYFINAL)
    YYACCEPT;

  goto yybackup;

/*-----------.
| yybackup.  |
`-----------*/
yybackup:

  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, ""Reading a token: ""));
      yychar = yylex (&yylval, yyscanner, compiler);
    }

  if (yychar <= YYEOF)
    {
      yychar = yytoken = YYEOF;
      YYDPRINTF ((stderr, ""Now at end of input.\n""));
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT (""Next token is"", yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT (""Shifting"", yytoken, &yylval, &yylloc);

  /* Discard the shifted token.  */
  yychar = YYEMPTY;

  yystate = yyn;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END

  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- Do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     '$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
        case 8:
#line 230 ""grammar.y"" /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));

        yr_free((yyvsp[0].sized_string));

        ERROR_IF(result != ERROR_SUCCESS);
      }
#line 1661 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 9:
#line 242 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(
            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));

        ERROR_IF(rule == NULL);

        (yyval.rule) = rule;
      }
#line 1674 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 10:
#line 251 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1

        rule->tags = (yyvsp[-3].c_string);
        rule->metas = (yyvsp[-1].meta);
        rule->strings = (yyvsp[0].string);
      }
#line 1686 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 11:
#line 259 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-7].rule); // rule created in phase 1

        compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(
            yyscanner, rule);

        yr_free((yyvsp[-8].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1701 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 12:
#line 274 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = NULL;
      }
#line 1709 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 13:
#line 278 ""grammar.y"" /* yacc.c:1646  */
    {
        // Each rule have a list of meta-data info, consisting in a
        // sequence of YR_META structures. The last YR_META structure does
        // not represent a real meta-data, it's just a end-of-list marker
        // identified by a specific type (META_TYPE_NULL). Here we
        // write the end-of-list marker.

        YR_META null_meta;

        memset(&null_meta, 0xFF, sizeof(YR_META));
        null_meta.type = META_TYPE_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->metas_arena,
            &null_meta,
            sizeof(YR_META),
            NULL);

        (yyval.meta) = (yyvsp[0].meta);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1736 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 14:
#line 305 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = NULL;
      }
#line 1744 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 15:
#line 309 ""grammar.y"" /* yacc.c:1646  */
    {
        // Each rule have a list of strings, consisting in a sequence
        // of YR_STRING structures. The last YR_STRING structure does not
        // represent a real string, it's just a end-of-list marker
        // identified by a specific flag (STRING_FLAGS_NULL). Here we
        // write the end-of-list marker.

        YR_STRING null_string;

        memset(&null_string, 0xFF, sizeof(YR_STRING));
        null_string.g_flags = STRING_GFLAGS_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->strings_arena,
            &null_string,
            sizeof(YR_STRING),
            NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.string) = (yyvsp[0].string);
      }
#line 1771 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 17:
#line 340 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = 0;  }
#line 1777 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 18:
#line 341 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 1783 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 19:
#line 346 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_PRIVATE; }
#line 1789 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 20:
#line 347 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_GLOBAL; }
#line 1795 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 21:
#line 353 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.c_string) = NULL;
      }
#line 1803 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 22:
#line 357 ""grammar.y"" /* yacc.c:1646  */
    {
        // Tags list is represented in the arena as a sequence
        // of null-terminated strings, the sequence ends with an
        // additional null character. Here we write the ending null
        //character. Example: tag1\0tag2\0tag3\0\0

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, """", NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[0].c_string);
      }
#line 1821 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 23:
#line 375 ""grammar.y"" /* yacc.c:1646  */
    {
        char* identifier;

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = identifier;
      }
#line 1838 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 24:
#line 388 ""grammar.y"" /* yacc.c:1646  */
    {
        char* tag_name = (yyvsp[-1].c_string);
        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;

        while (tag_length > 0)
        {
          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)
          {
            yr_compiler_set_error_extra_info(compiler, tag_name);
            compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;
            break;
          }

          tag_name = (char*) yr_arena_next_address(
              yyget_extra(yyscanner)->sz_arena,
              tag_name,
              tag_length + 1);

          tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        }

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_arena_write_string(
              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-1].c_string);
      }
#line 1874 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 25:
#line 424 ""grammar.y"" /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[0].meta); }
#line 1880 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 26:
#line 425 ""grammar.y"" /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[-1].meta); }
#line 1886 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 27:
#line 431 ""grammar.y"" /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);

        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_STRING,
            (yyvsp[-2].c_string),
            sized_string->c_string,
            0);

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1906 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 28:
#line 447 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-2].c_string),
            NULL,
            (yyvsp[0].integer));

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1923 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 29:
#line 460 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-3].c_string),
            NULL,
            -(yyvsp[0].integer));

        yr_free((yyvsp[-3].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1940 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 30:
#line 473 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            TRUE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1957 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 31:
#line 486 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            FALSE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1974 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 32:
#line 502 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[0].string); }
#line 1980 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 33:
#line 503 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[-1].string); }
#line 1986 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 34:
#line 509 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 1994 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 35:
#line 513 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);
        compiler->error_line = 0;
      }
#line 2009 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 36:
#line 524 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 2017 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 37:
#line 528 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);

        compiler->error_line = 0;
      }
#line 2033 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 38:
#line 540 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.string) == NULL);
      }
#line 2047 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 39:
#line 553 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = 0; }
#line 2053 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 40:
#line 554 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 2059 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 41:
#line 559 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_WIDE; }
#line 2065 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 42:
#line 560 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_ASCII; }
#line 2071 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 43:
#line 561 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }
#line 2077 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 44:
#line 562 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }
#line 2083 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 45:
#line 568 ""grammar.y"" /* yacc.c:1646  */
    {
        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));

        if (var_index >= 0)
        {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner,
              OP_PUSH_M,
              LOOP_LOCAL_VARS * var_index,
              NULL,
              NULL);

          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
          (yyval.expression).identifier = compiler->loop_identifier[var_index];
        }
        else
        {
          // Search for identifier within the global namespace, where the
          // externals variables reside.

          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
              compiler->objects_table, (yyvsp[0].c_string), NULL);

          if (object == NULL)
          {
            // If not found, search within the current namespace.
            char* ns = compiler->current_namespace->name;

            object = (YR_OBJECT*) yr_hash_table_lookup(
                compiler->objects_table, (yyvsp[0].c_string), ns);
          }

          if (object != NULL)
          {
            char* id;

            compiler->last_result = yr_arena_write_string(
                compiler->sz_arena, (yyvsp[0].c_string), &id);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_LOAD,
                  id,
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = object;
            (yyval.expression).identifier = object->identifier;
          }
          else
          {
            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
                compiler->rules_table,
                (yyvsp[0].c_string),
                compiler->current_namespace->name);

            if (rule != NULL)
            {
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_PUSH_RULE,
                  rule,
                  NULL,
                  NULL);

              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
              (yyval.expression).value.integer = UNDEFINED;
              (yyval.expression).identifier = rule->identifier;
            }
            else
            {
              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
              compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;
            }
          }
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2172 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 46:
#line 653 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT* field = NULL;

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)
        {
          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));

          if (field != NULL)
          {
            char* ident;

            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[0].c_string), &ident);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_FIELD,
                  ident,
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = field;
            (yyval.expression).identifier = field->identifier;
          }
          else
          {
            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
            compiler->last_result = ERROR_INVALID_FIELD_NAME;
          }
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-2].expression).identifier);

          compiler->last_result = ERROR_NOT_A_STRUCTURE;
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2222 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 47:
#line 699 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT_ARRAY* array;
        YR_OBJECT_DICTIONARY* dict;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
          {
            yr_compiler_set_error_extra_info(
                compiler, ""array indexes must be of integer type"");
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_INDEX_ARRAY, NULL);

          array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = array->prototype_item;
          (yyval.expression).identifier = array->identifier;
        }
        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)
          {
            yr_compiler_set_error_extra_info(
                compiler, ""dictionary keys must be of string type"");
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_LOOKUP_DICT, NULL);

          dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = dict->prototype_item;
          (yyval.expression).identifier = dict->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_INDEXABLE;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2283 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 48:
#line 757 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT_FUNCTION* function;
        char* args_fmt;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)
        {
          compiler->last_result = yr_parser_check_types(
              compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_parser_emit_with_arg_reloc(
                yyscanner,
                OP_CALL,
                args_fmt,
                NULL,
                NULL);

          function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = function->return_obj;
          (yyval.expression).identifier = function->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_A_FUNCTION;
        }

        yr_free((yyvsp[-1].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2328 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 49:
#line 801 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.c_string) = yr_strdup(""""); }
#line 2334 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 50:
#line 802 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.c_string) = (yyvsp[0].c_string); }
#line 2340 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 51:
#line 807 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);

        switch((yyvsp[0].expression).type)
        {
          case EXPRESSION_TYPE_INTEGER:
            strlcpy((yyval.c_string), ""i"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_FLOAT:
            strlcpy((yyval.c_string), ""f"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_BOOLEAN:
            strlcpy((yyval.c_string), ""b"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_STRING:
            strlcpy((yyval.c_string), ""s"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_REGEXP:
            strlcpy((yyval.c_string), ""r"", MAX_FUNCTION_ARGS);
            break;
        }

        ERROR_IF((yyval.c_string) == NULL);
      }
#line 2369 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 52:
#line 832 ""grammar.y"" /* yacc.c:1646  */
    {
        if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)
        {
          compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;
        }
        else
        {
          switch((yyvsp[0].expression).type)
          {
            case EXPRESSION_TYPE_INTEGER:
              strlcat((yyvsp[-2].c_string), ""i"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_FLOAT:
              strlcat((yyvsp[-2].c_string), ""f"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_BOOLEAN:
              strlcat((yyvsp[-2].c_string), ""b"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_STRING:
              strlcat((yyvsp[-2].c_string), ""s"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_REGEXP:
              strlcat((yyvsp[-2].c_string), ""r"", MAX_FUNCTION_ARGS);
              break;
          }
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-2].c_string);
      }
#line 2405 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 53:
#line 868 ""grammar.y"" /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        RE* re;
        RE_ERROR error;

        int re_flags = 0;

        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
          re_flags |= RE_FLAGS_NO_CASE;

        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
          re_flags |= RE_FLAGS_DOT_ALL;

        compiler->last_result = yr_re_compile(
            sized_string->c_string,
            re_flags,
            compiler->re_code_arena,
            &re,
            &error);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)
          yr_compiler_set_error_extra_info(compiler, error.message);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              re->root_node->forward_code,
              NULL,
              NULL);

        yr_re_destroy(re);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
      }
#line 2451 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 54:
#line 914 ""grammar.y"" /* yacc.c:1646  */
    {
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
        {
          if ((yyvsp[0].expression).value.sized_string != NULL)
          {
            yywarning(yyscanner,
              ""Using literal string \""%s\"" in a boolean operation."",
              (yyvsp[0].expression).value.sized_string->c_string);
          }

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_STR_TO_BOOL, NULL);

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2474 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 55:
#line 936 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 1, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2487 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 56:
#line 945 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 0, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2500 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 57:
#line 954 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""matches"");
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, ""matches"");

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit(
              yyscanner,
              OP_MATCHES,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2519 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 58:
#line 969 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""contains"");
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, ""contains"");

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_CONTAINS, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2535 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 59:
#line 981 ""grammar.y"" /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_string_identifier(
            yyscanner,
            (yyvsp[0].c_string),
            OP_FOUND,
            UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2553 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 60:
#line 995 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""at"");

        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2570 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 61:
#line 1008 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result!= ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2585 ""grammar.c"" /* yacc.c:1646  */
    break;
 
   case 62:
 #line 1019 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//        compiler->loop_depth--;
//fix_flaw_line_below:
//        compiler->loop_identifier[compiler->loop_depth] = NULL;
//fix_flaw_line_below:
//      }
//fix_flaw_line_below:
//#line 2594 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//    break;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  case 63:
//fix_flaw_line_below:
//#line 1024 ""grammar.y"" /* yacc.c:1646  */
     {
         int var_index;
 
        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
              ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        var_index = yr_parser_lookup_loop_variable(
            yyscanner, (yyvsp[-1].c_string));

        if (var_index >= 0)
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-1].c_string));

          compiler->last_result = \
              ERROR_DUPLICATED_LOOP_IDENTIFIER;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        // Push end-of-list marker
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
//flaw_line_below:
#line 2619 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2628 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 63:
//flaw_line_below:
#line 1049 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 64:
//fix_flaw_line_below:
//#line 1054 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;

        // Clear counter for number of expressions evaluating
        // to TRUE.
        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        // Clear iterations counter
        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)
        {
          // Pop the first integer
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        }
        else // INTEGER_SET_RANGE
        {
          // Pop higher bound of set range
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);

          // Pop lower bound of set range
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        }

        compiler->loop_address[compiler->loop_depth] = addr;
         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
         compiler->loop_depth++;
       }
//flaw_line_below:
#line 2658 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2667 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 64:
//flaw_line_below:
#line 1084 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 65:
//fix_flaw_line_below:
//#line 1089 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
        compiler->loop_depth--;
        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;

        // The value at the top of the stack is the result of
        // evaluating the boolean expression, so it could be
        // 0, 1 or UNDEFINED. Add this value to a counter
        // keeping the number of expressions evaluating to true.
        // If the value is UNDEFINED instruction OP_ADD_M
        // does nothing.

        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        // Increment iterations counter
        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)
        {
          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JNUNDEF,
              compiler->loop_address[compiler->loop_depth],
              NULL,
              NULL);
        }
        else // INTEGER_SET_RANGE
        {
          // Increment lower bound of integer set
          yr_parser_emit_with_arg(
              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);

          // Push lower bound of integer set
          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);

          // Push higher bound of integer set
          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);

          // Compare higher bound with lower bound, do loop again
          // if lower bound is still lower or equal than higher bound
          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JLE,
              compiler->loop_address[compiler->loop_depth],
              NULL,
              NULL);

          yr_parser_emit(yyscanner, OP_POP, NULL);
          yr_parser_emit(yyscanner, OP_POP, NULL);
        }

        // Pop end-of-list marker.
        yr_parser_emit(yyscanner, OP_POP, NULL);

        // At this point the loop quantifier (any, all, 1, 2,..)
        // is at the top of the stack. Check if the quantifier
        // is undefined (meaning ""all"") and replace it with the
        // iterations counter in that case.
        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        // Compare the loop quantifier with the number of
        // expressions evaluating to TRUE.
        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

        compiler->loop_identifier[compiler->loop_depth] = NULL;
        yr_free((yyvsp[-8].c_string));
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 2741 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2750 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 65:
//flaw_line_below:
#line 1163 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 66:
//fix_flaw_line_below:
//#line 1168 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;

        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
            ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        if (compiler->loop_for_of_mem_offset != -1)
          compiler->last_result = \
            ERROR_NESTED_FOR_OF_LOOP;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        // Pop the first string.
        yr_parser_emit_with_arg(
            yyscanner, OP_POP_M, mem_offset, &addr, NULL);

        compiler->loop_for_of_mem_offset = mem_offset;
        compiler->loop_address[compiler->loop_depth] = addr;
         compiler->loop_identifier[compiler->loop_depth] = NULL;
         compiler->loop_depth++;
       }
//flaw_line_below:
#line 2775 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2784 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 66:
//flaw_line_below:
#line 1193 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 67:
//fix_flaw_line_below:
//#line 1198 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
        compiler->loop_depth--;
        compiler->loop_for_of_mem_offset = -1;

        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;

        // Increment counter by the value returned by the
        // boolean expression (0 or 1). If the boolean expression
        // returned UNDEFINED the OP_ADD_M won't do anything.

        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        // Increment iterations counter.
        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        // If next string is not undefined, go back to the
        // beginning of the loop.
        yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JNUNDEF,
            compiler->loop_address[compiler->loop_depth],
            NULL,
            NULL);

        // Pop end-of-list marker.
        yr_parser_emit(yyscanner, OP_POP, NULL);

        // At this point the loop quantifier (any, all, 1, 2,..)
        // is at top of the stack. Check if the quantifier is
        // undefined (meaning ""all"") and replace it with the
        // iterations counter in that case.
        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        // Compare the loop quantifier with the number of
        // expressions evaluating to TRUE.
        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
 
       }
//flaw_line_below:
#line 2828 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2837 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 67:
//flaw_line_below:
#line 1242 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 68:
//fix_flaw_line_below:
//#line 1247 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_OF, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 2838 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2847 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 68:
//flaw_line_below:
#line 1248 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 69:
//fix_flaw_line_below:
//#line 1253 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_NOT, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 2848 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2857 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 69:
//flaw_line_below:
#line 1254 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 70:
//fix_flaw_line_below:
//#line 1259 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JFALSE,
            0,          // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        // create a fixup entry for the jump and push it in the stack
        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
//flaw_line_below:
#line 2878 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2887 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 70:
//flaw_line_below:
#line 1280 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 71:
//fix_flaw_line_below:
//#line 1285 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* and_addr;

        // Ensure that we have at least two consecutive bytes in the arena's
        // current page, one for the AND opcode and one for opcode following the
        // AND. This is necessary because we need to compute the address for the
        // opcode following the AND, and we don't want the AND in one page and
        // the following opcode in another page.

        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        // Now we know the jump destination, which is the address of the
        // instruction following the AND. Let's fixup the jump address.

        fixup = compiler->fixup_stack_head;

        // We know that the AND opcode and the following one are within the same
        // page, so we can compute the address for the opcode following the AND
        // by simply adding one to its address.

        *(void**)(fixup->address) = (void*)(and_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 2918 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2927 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 71:
//flaw_line_below:
#line 1316 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 72:
//fix_flaw_line_below:
//#line 1321 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JTRUE,
            0,         // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
//flaw_line_below:
#line 2947 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2956 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 72:
//flaw_line_below:
#line 1341 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 73:
//fix_flaw_line_below:
//#line 1346 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* or_addr;

        // Ensure that we have at least two consecutive bytes in the arena's
        // current page, one for the OR opcode and one for opcode following the
        // OR. This is necessary because we need to compute the address for the
        // opcode following the OR, and we don't want the OR in one page and
        // the following opcode in another page.

        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        // Now we know the jump destination, which is the address of the
        // instruction following the OP_OR. Let's fixup the jump address.

        fixup = compiler->fixup_stack_head;

        // We know that the OR opcode and the following one are within the same
        // page, so we can compute the address for the opcode following the OR
        // by simply adding one to its address.

        *(void**)(fixup->address) = (void*)(or_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 2987 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2996 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 73:
//flaw_line_below:
#line 1377 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 74:
//fix_flaw_line_below:
//#line 1382 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 3000 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3009 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 74:
//flaw_line_below:
#line 1386 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 75:
//fix_flaw_line_below:
//#line 1391 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 3013 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3022 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 75:
//flaw_line_below:
#line 1395 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 76:
//fix_flaw_line_below:
//#line 1400 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 3026 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3035 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 76:
//flaw_line_below:
#line 1404 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 77:
//fix_flaw_line_below:
//#line 1409 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 3039 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3048 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 77:
//flaw_line_below:
#line 1413 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 78:
//fix_flaw_line_below:
//#line 1418 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""=="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 3052 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3061 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 78:
//flaw_line_below:
#line 1422 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 79:
//fix_flaw_line_below:
//#line 1427 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""!="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 3065 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3074 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 79:
//flaw_line_below:
#line 1431 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 80:
//fix_flaw_line_below:
//#line 1436 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
//flaw_line_below:
#line 3073 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3082 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 80:
//flaw_line_below:
#line 1435 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 81:
//fix_flaw_line_below:
//#line 1440 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
//flaw_line_below:
#line 3081 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3090 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 81:
//flaw_line_below:
#line 1442 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 82:
//fix_flaw_line_below:
//#line 1447 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_ENUMERATION; }
//flaw_line_below:
#line 3087 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3096 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 82:
//flaw_line_below:
#line 1443 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 83:
//fix_flaw_line_below:
//#line 1448 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_RANGE; }
//flaw_line_below:
#line 3093 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3102 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 83:
//flaw_line_below:
#line 1449 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 84:
//fix_flaw_line_below:
//#line 1454 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for range's lower bound"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }

        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for range's upper bound"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
//flaw_line_below:
#line 3115 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3124 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 84:
//flaw_line_below:
#line 1471 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 85:
//fix_flaw_line_below:
//#line 1476 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for enumeration item"");
          compiler->last_result = ERROR_WRONG_TYPE;

        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
//flaw_line_below:
#line 3131 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3140 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 85:
//flaw_line_below:
#line 1483 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 86:
//fix_flaw_line_below:
//#line 1488 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for enumeration item"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
//flaw_line_below:
#line 3146 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3155 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 86:
//flaw_line_below:
#line 1498 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 87:
//fix_flaw_line_below:
//#line 1503 ""grammar.y"" /* yacc.c:1646  */
     {
         // Push end-of-list marker
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
//flaw_line_below:
#line 3155 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3164 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 88:
//flaw_line_below:
#line 1504 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 89:
//fix_flaw_line_below:
//#line 1509 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
         yr_parser_emit_pushes_for_strings(yyscanner, ""$*"");
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
//flaw_line_below:
#line 3166 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3175 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 91:
//flaw_line_below:
#line 1521 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 92:
//fix_flaw_line_below:
//#line 1526 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
//flaw_line_below:
#line 3177 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3186 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 92:
//flaw_line_below:
#line 1528 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 93:
//fix_flaw_line_below:
//#line 1533 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
//flaw_line_below:
#line 3188 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3197 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 94:
//flaw_line_below:
#line 1540 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 95:
//fix_flaw_line_below:
//#line 1545 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
//flaw_line_below:
#line 3196 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3205 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 95:
//flaw_line_below:
#line 1544 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 96:
//fix_flaw_line_below:
//#line 1549 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
       }
//flaw_line_below:
#line 3204 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3213 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 96:
//flaw_line_below:
#line 1552 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 97:
//fix_flaw_line_below:
//#line 1557 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
//flaw_line_below:
#line 3212 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3221 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 97:
//flaw_line_below:
#line 1556 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 98:
//fix_flaw_line_below:
//#line 1561 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit(
             yyscanner, OP_FILESIZE, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
//flaw_line_below:
#line 3226 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3235 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 98:
//flaw_line_below:
#line 1566 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 99:
//fix_flaw_line_below:
//#line 1571 ""grammar.y"" /* yacc.c:1646  */
     {
         yywarning(yyscanner,
             ""Using deprecated \""entrypoint\"" keyword. Use the \""entry_point\"" ""
            ""function from PE module instead."");

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_ENTRYPOINT, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
//flaw_line_below:
#line 3244 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3253 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 99:
//flaw_line_below:
#line 1580 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 100:
//fix_flaw_line_below:
//#line 1585 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, ""intXXXX or uintXXXX"");
 
        // _INTEGER_FUNCTION_ could be any of int8, int16, int32, uint8,
        // uint32, etc. $1 contains an index that added to OP_READ_INT results
        // in the proper OP_INTXX opcode.

        compiler->last_result = yr_parser_emit(
            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
//flaw_line_below:
#line 3264 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3273 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 100:
//flaw_line_below:
#line 1596 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 101:
//fix_flaw_line_below:
//#line 1601 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = (yyvsp[0].integer);
       }
//flaw_line_below:
#line 3278 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3287 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 101:
//flaw_line_below:
#line 1606 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 102:
//fix_flaw_line_below:
//#line 1611 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg_double(
             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
       }
//flaw_line_below:
#line 3291 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3300 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 102:
//flaw_line_below:
#line 1615 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 103:
//fix_flaw_line_below:
//#line 1620 ""grammar.y"" /* yacc.c:1646  */
     {
         SIZED_STRING* sized_string;
 
        compiler->last_result = yr_arena_write_data(
            compiler->sz_arena,
            (yyvsp[0].sized_string),
            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),
            (void**) &sized_string);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              sized_string,
              NULL,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_STRING;
         (yyval.expression).value.sized_string = sized_string;
       }
//flaw_line_below:
#line 3320 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3329 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 103:
//flaw_line_below:
#line 1640 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 104:
//fix_flaw_line_below:
//#line 1645 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
//flaw_line_below:
#line 3336 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3345 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 104:
//flaw_line_below:
#line 1652 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 105:
//fix_flaw_line_below:
//#line 1657 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
//flaw_line_below:
#line 3352 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3361 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 105:
//flaw_line_below:
#line 1664 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 106:
//fix_flaw_line_below:
//#line 1669 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
//flaw_line_below:
#line 3372 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3381 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 106:
//flaw_line_below:
#line 1680 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 107:
//fix_flaw_line_below:
//#line 1685 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
//flaw_line_below:
#line 3388 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3397 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 107:
//flaw_line_below:
#line 1692 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 108:
//fix_flaw_line_below:
//#line 1697 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
//flaw_line_below:
#line 3408 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3417 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 108:
//flaw_line_below:
#line 1708 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 109:
//fix_flaw_line_below:
//#line 1713 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier
         {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier
        {
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
        {
          compiler->last_result = yr_parser_emit(
              yyscanner, OP_OBJ_VALUE, NULL);

          switch((yyvsp[0].expression).value.object->type)
          {
            case OBJECT_TYPE_INTEGER:
              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
              (yyval.expression).value.integer = UNDEFINED;
              break;
            case OBJECT_TYPE_FLOAT:
              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
              break;
            case OBJECT_TYPE_STRING:
              (yyval.expression).type = EXPRESSION_TYPE_STRING;
              (yyval.expression).value.sized_string = NULL;
              break;
            default:
              yr_compiler_set_error_extra_info_fmt(
                  compiler,
                  ""wrong usage of identifier \""%s\"""",
                  (yyvsp[0].expression).identifier);
              compiler->last_result = ERROR_WRONG_TYPE;
          }
        }
        else
        {
          assert(FALSE);
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
//flaw_line_below:
#line 3457 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3466 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 109:
//flaw_line_below:
#line 1753 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 110:
//fix_flaw_line_below:
//#line 1758 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, ""-"");
 
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
              UNDEFINED : -((yyvsp[0].expression).value.integer);
          compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)
        {
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
//flaw_line_below:
#line 3480 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3489 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 110:
//flaw_line_below:
#line 1772 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 111:
//fix_flaw_line_below:
//#line 1777 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""+"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
//flaw_line_below:
#line 3502 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3511 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 111:
//flaw_line_below:
#line 1790 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 112:
//fix_flaw_line_below:
//#line 1795 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""-"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
//flaw_line_below:
#line 3524 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3533 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 112:
//flaw_line_below:
#line 1808 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 113:
//fix_flaw_line_below:
//#line 1813 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""*"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
//flaw_line_below:
#line 3546 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3555 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 113:
//flaw_line_below:
#line 1826 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 114:
//fix_flaw_line_below:
//#line 1831 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""\\"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          if ((yyvsp[0].expression).value.integer != 0)
          {
            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          }
          else
          {
            compiler->last_result = ERROR_DIVISION_BY_ZERO;
            ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          }
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
//flaw_line_below:
#line 3576 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3585 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 114:
//flaw_line_below:
#line 1852 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 115:
//fix_flaw_line_below:
//#line 1857 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""%"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""%"");

        yr_parser_emit(yyscanner, OP_MOD, NULL);

        if ((yyvsp[0].expression).value.integer != 0)
        {
          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
          compiler->last_result = ERROR_DIVISION_BY_ZERO;
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         }
       }
//flaw_line_below:
#line 3598 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3607 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 115:
//flaw_line_below:
#line 1870 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 116:
//fix_flaw_line_below:
//#line 1875 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");

        yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
//flaw_line_below:
#line 3612 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3621 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 116:
//flaw_line_below:
#line 1880 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 117:
//fix_flaw_line_below:
//#line 1885 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");

        yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
//flaw_line_below:
#line 3626 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3635 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 117:
//flaw_line_below:
#line 1890 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 118:
//fix_flaw_line_below:
//#line 1895 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""|"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""|"");

        yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
//flaw_line_below:
#line 3640 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3649 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 118:
//flaw_line_below:
#line 1900 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 119:
//fix_flaw_line_below:
//#line 1905 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""~"");
 
        yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
             UNDEFINED : ~((yyvsp[0].expression).value.integer);
       }
//flaw_line_below:
#line 3654 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3663 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 119:
//flaw_line_below:
#line 1910 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 120:
//fix_flaw_line_below:
//#line 1915 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""<<"");

        yr_parser_emit(yyscanner, OP_SHL, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
//flaw_line_below:
#line 3668 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3677 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 120:
//flaw_line_below:
#line 1920 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 121:
//fix_flaw_line_below:
//#line 1925 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "">>"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "">>"");

        yr_parser_emit(yyscanner, OP_SHR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
//flaw_line_below:
#line 3682 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3691 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 121:
//flaw_line_below:
#line 1930 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 122:
//fix_flaw_line_below:
//#line 1935 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
//flaw_line_below:
#line 3690 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3699 ""grammar.c"" /* yacc.c:1646  */
     break;
 
 
//flaw_line_below:
#line 3694 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3703 ""grammar.c"" /* yacc.c:1646  */
       default: break;
     }
   /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT (""-> $$ ="", yyr1[yyn], &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);

  *++yyvsp = yyval;

  /* Now 'shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTOKENS];

  goto yynewstate;


/*--------------------------------------.
| yyerrlab -- here on detecting error.  |
`--------------------------------------*/
yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);

  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
#if ! YYERROR_VERBOSE
      yyerror (yyscanner, compiler, YY_(""syntax error""));
#else
# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                        yyssp, yytoken)
      {
        char const *yymsgp = YY_(""syntax error"");
        int yysyntax_error_status;
        yysyntax_error_status = YYSYNTAX_ERROR;
        if (yysyntax_error_status == 0)
          yymsgp = yymsg;
        else if (yysyntax_error_status == 1)
          {
            if (yymsg != yymsgbuf)
              YYSTACK_FREE (yymsg);
            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
            if (!yymsg)
              {
                yymsg = yymsgbuf;
                yymsg_alloc = sizeof yymsgbuf;
                yysyntax_error_status = 2;
              }
            else
              {
                yysyntax_error_status = YYSYNTAX_ERROR;
                yymsgp = yymsg;
              }
          }
        yyerror (yyscanner, compiler, yymsgp);
        if (yysyntax_error_status == 2)
          goto yyexhaustedlab;
      }
# undef YYSYNTAX_ERROR
#endif
    }



  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse lookahead token after an
         error, discard it.  */

      if (yychar <= YYEOF)
        {
          /* Return failure if at end of input.  */
          if (yychar == YYEOF)
            YYABORT;
        }
      else
        {
          yydestruct (""Error: discarding"",
                      yytoken, &yylval, yyscanner, compiler);
          yychar = YYEMPTY;
        }
    }

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:

  /* Pacify compilers like GCC when the user code never invokes
     YYERROR and the label yyerrorlab therefore never appears in user
     code.  */
  if (/*CONSTCOND*/ 0)
     goto yyerrorlab;

  /* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;      /* Each real token shifted decrements this.  */

  for (;;)
    {
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
        {
          yyn += YYTERROR;
          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
            {
              yyn = yytable[yyn];
              if (0 < yyn)
                break;
            }
        }

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
        YYABORT;


      yydestruct (""Error: popping"",
                  yystos[yystate], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END


  /* Shift the error token.  */
  YY_SYMBOL_PRINT (""Shifting"", yystos[yyn], yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturn;

/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturn;

#if !defined yyoverflow || YYERROR_VERBOSE
/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/
yyexhaustedlab:
  yyerror (yyscanner, compiler, YY_(""memory exhausted""));
  yyresult = 2;
  /* Fall through.  */
#endif

yyreturn:
  if (yychar != YYEMPTY)
    {
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct (""Cleanup: discarding lookahead"",
                  yytoken, &yylval, yyscanner, compiler);
    }
  /* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct (""Cleanup: popping"",
                  yystos[*yyssp], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif
#if YYERROR_VERBOSE
  if (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
 #endif
   return yyresult;
 }
",181653,"yyparse (void *yyscanner, YR_COMPILER* compiler)
{
/* The lookahead symbol.  */
int yychar;


/* The semantic value of the lookahead symbol.  */
/* Default value used for initialization, for pacifying older GCCs
   or non-GCC compilers.  */
YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);

    /* Number of syntax errors so far.  */
    int yynerrs;

    int yystate;
    /* Number of tokens to shift before error messages enabled.  */
    int yyerrstatus;

    /* The stacks and their tools:
       'yyss': related to states.
       'yyvs': related to semantic values.

       Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */

    /* The state stack.  */
    yytype_int16 yyssa[YYINITDEPTH];
    yytype_int16 *yyss;
    yytype_int16 *yyssp;

    /* The semantic value stack.  */
    YYSTYPE yyvsa[YYINITDEPTH];
    YYSTYPE *yyvs;
    YYSTYPE *yyvsp;

    YYSIZE_T yystacksize;

  int yyn;
  int yyresult;
  /* Lookahead token as an internal (translated) token number.  */
  int yytoken = 0;
  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;

#if YYERROR_VERBOSE
  /* Buffer for error messages, and its allocated size.  */
  char yymsgbuf[128];
  char *yymsg = yymsgbuf;
  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
#endif

#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))

  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  yyssp = yyss = yyssa;
  yyvsp = yyvs = yyvsa;
  yystacksize = YYINITDEPTH;

  YYDPRINTF ((stderr, ""Starting parse\n""));

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY; /* Cause a token to be read.  */
  goto yysetstate;

/*------------------------------------------------------------.
| yynewstate -- Push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
 yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;

 yysetstate:
  *yyssp = yystate;

  if (yyss + yystacksize - 1 <= yyssp)
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYSIZE_T yysize = yyssp - yyss + 1;

#ifdef yyoverflow
      {
        /* Give user a chance to reallocate the stack.  Use copies of
           these so that the &'s don't force the real ones into
           memory.  */
        YYSTYPE *yyvs1 = yyvs;
        yytype_int16 *yyss1 = yyss;

        /* Each stack pointer address is followed by the size of the
           data in use in that stack, in bytes.  This used to be a
           conditional around just the two extra args, but that might
           be undefined if yyoverflow is a macro.  */
        yyoverflow (YY_(""memory exhausted""),
                    &yyss1, yysize * sizeof (*yyssp),
                    &yyvs1, yysize * sizeof (*yyvsp),
                    &yystacksize);

        yyss = yyss1;
        yyvs = yyvs1;
      }
#else /* no yyoverflow */
# ifndef YYSTACK_RELOCATE
      goto yyexhaustedlab;
# else
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
        goto yyexhaustedlab;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
        yystacksize = YYMAXDEPTH;

      {
        yytype_int16 *yyss1 = yyss;
        union yyalloc *yyptr =
          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
        if (! yyptr)
          goto yyexhaustedlab;
        YYSTACK_RELOCATE (yyss_alloc, yyss);
        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
#  undef YYSTACK_RELOCATE
        if (yyss1 != yyssa)
          YYSTACK_FREE (yyss1);
      }
# endif
#endif /* no yyoverflow */

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;

      YYDPRINTF ((stderr, ""Stack size increased to %lu\n"",
                  (unsigned long int) yystacksize));

      if (yyss + yystacksize - 1 <= yyssp)
        YYABORT;
    }

  YYDPRINTF ((stderr, ""Entering state %d\n"", yystate));

  if (yystate == YYFINAL)
    YYACCEPT;

  goto yybackup;

/*-----------.
| yybackup.  |
`-----------*/
yybackup:

  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, ""Reading a token: ""));
      yychar = yylex (&yylval, yyscanner, compiler);
    }

  if (yychar <= YYEOF)
    {
      yychar = yytoken = YYEOF;
      YYDPRINTF ((stderr, ""Now at end of input.\n""));
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT (""Next token is"", yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT (""Shifting"", yytoken, &yylval, &yylloc);

  /* Discard the shifted token.  */
  yychar = YYEMPTY;

  yystate = yyn;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END

  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- Do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     '$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
        case 8:
#line 230 ""grammar.y"" /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));

        yr_free((yyvsp[0].sized_string));

        ERROR_IF(result != ERROR_SUCCESS);
      }
#line 1661 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 9:
#line 242 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(
            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));

        ERROR_IF(rule == NULL);

        (yyval.rule) = rule;
      }
#line 1674 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 10:
#line 251 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1

        rule->tags = (yyvsp[-3].c_string);
        rule->metas = (yyvsp[-1].meta);
        rule->strings = (yyvsp[0].string);
      }
#line 1686 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 11:
#line 259 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-7].rule); // rule created in phase 1

        compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(
            yyscanner, rule);

        yr_free((yyvsp[-8].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1701 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 12:
#line 274 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = NULL;
      }
#line 1709 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 13:
#line 278 ""grammar.y"" /* yacc.c:1646  */
    {

        YR_META null_meta;

        memset(&null_meta, 0xFF, sizeof(YR_META));
        null_meta.type = META_TYPE_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->metas_arena,
            &null_meta,
            sizeof(YR_META),
            NULL);

        (yyval.meta) = (yyvsp[0].meta);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1736 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 14:
#line 305 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = NULL;
      }
#line 1744 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 15:
#line 309 ""grammar.y"" /* yacc.c:1646  */
    {

        YR_STRING null_string;

        memset(&null_string, 0xFF, sizeof(YR_STRING));
        null_string.g_flags = STRING_GFLAGS_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->strings_arena,
            &null_string,
            sizeof(YR_STRING),
            NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.string) = (yyvsp[0].string);
      }
#line 1771 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 17:
#line 340 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = 0;  }
#line 1777 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 18:
#line 341 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 1783 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 19:
#line 346 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_PRIVATE; }
#line 1789 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 20:
#line 347 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_GLOBAL; }
#line 1795 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 21:
#line 353 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.c_string) = NULL;
      }
#line 1803 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 22:
#line 357 ""grammar.y"" /* yacc.c:1646  */
    {

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, """", NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[0].c_string);
      }
#line 1821 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 23:
#line 375 ""grammar.y"" /* yacc.c:1646  */
    {
        char* identifier;

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = identifier;
      }
#line 1838 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 24:
#line 388 ""grammar.y"" /* yacc.c:1646  */
    {
        char* tag_name = (yyvsp[-1].c_string);
        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;

        while (tag_length > 0)
        {
          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)
          {
            yr_compiler_set_error_extra_info(compiler, tag_name);
            compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;
            break;
          }

          tag_name = (char*) yr_arena_next_address(
              yyget_extra(yyscanner)->sz_arena,
              tag_name,
              tag_length + 1);

          tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        }

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_arena_write_string(
              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-1].c_string);
      }
#line 1874 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 25:
#line 424 ""grammar.y"" /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[0].meta); }
#line 1880 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 26:
#line 425 ""grammar.y"" /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[-1].meta); }
#line 1886 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 27:
#line 431 ""grammar.y"" /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);

        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_STRING,
            (yyvsp[-2].c_string),
            sized_string->c_string,
            0);

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1906 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 28:
#line 447 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-2].c_string),
            NULL,
            (yyvsp[0].integer));

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1923 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 29:
#line 460 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-3].c_string),
            NULL,
            -(yyvsp[0].integer));

        yr_free((yyvsp[-3].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1940 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 30:
#line 473 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            TRUE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1957 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 31:
#line 486 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            FALSE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1974 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 32:
#line 502 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[0].string); }
#line 1980 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 33:
#line 503 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[-1].string); }
#line 1986 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 34:
#line 509 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 1994 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 35:
#line 513 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);
        compiler->error_line = 0;
      }
#line 2009 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 36:
#line 524 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 2017 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 37:
#line 528 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);

        compiler->error_line = 0;
      }
#line 2033 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 38:
#line 540 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.string) == NULL);
      }
#line 2047 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 39:
#line 553 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = 0; }
#line 2053 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 40:
#line 554 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 2059 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 41:
#line 559 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_WIDE; }
#line 2065 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 42:
#line 560 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_ASCII; }
#line 2071 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 43:
#line 561 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }
#line 2077 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 44:
#line 562 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }
#line 2083 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 45:
#line 568 ""grammar.y"" /* yacc.c:1646  */
    {
        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));

        if (var_index >= 0)
        {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner,
              OP_PUSH_M,
              LOOP_LOCAL_VARS * var_index,
              NULL,
              NULL);

          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
          (yyval.expression).identifier = compiler->loop_identifier[var_index];
        }
        else
        {

          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
              compiler->objects_table, (yyvsp[0].c_string), NULL);

          if (object == NULL)
          {
            char* ns = compiler->current_namespace->name;

            object = (YR_OBJECT*) yr_hash_table_lookup(
                compiler->objects_table, (yyvsp[0].c_string), ns);
          }

          if (object != NULL)
          {
            char* id;

            compiler->last_result = yr_arena_write_string(
                compiler->sz_arena, (yyvsp[0].c_string), &id);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_LOAD,
                  id,
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = object;
            (yyval.expression).identifier = object->identifier;
          }
          else
          {
            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
                compiler->rules_table,
                (yyvsp[0].c_string),
                compiler->current_namespace->name);

            if (rule != NULL)
            {
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_PUSH_RULE,
                  rule,
                  NULL,
                  NULL);

              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
              (yyval.expression).value.integer = UNDEFINED;
              (yyval.expression).identifier = rule->identifier;
            }
            else
            {
              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
              compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;
            }
          }
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2172 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 46:
#line 653 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT* field = NULL;

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)
        {
          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));

          if (field != NULL)
          {
            char* ident;

            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[0].c_string), &ident);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_FIELD,
                  ident,
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = field;
            (yyval.expression).identifier = field->identifier;
          }
          else
          {
            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
            compiler->last_result = ERROR_INVALID_FIELD_NAME;
          }
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-2].expression).identifier);

          compiler->last_result = ERROR_NOT_A_STRUCTURE;
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2222 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 47:
#line 699 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT_ARRAY* array;
        YR_OBJECT_DICTIONARY* dict;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
          {
            yr_compiler_set_error_extra_info(
                compiler, ""array indexes must be of integer type"");
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_INDEX_ARRAY, NULL);

          array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = array->prototype_item;
          (yyval.expression).identifier = array->identifier;
        }
        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)
          {
            yr_compiler_set_error_extra_info(
                compiler, ""dictionary keys must be of string type"");
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_LOOKUP_DICT, NULL);

          dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = dict->prototype_item;
          (yyval.expression).identifier = dict->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_INDEXABLE;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2283 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 48:
#line 757 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT_FUNCTION* function;
        char* args_fmt;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)
        {
          compiler->last_result = yr_parser_check_types(
              compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_parser_emit_with_arg_reloc(
                yyscanner,
                OP_CALL,
                args_fmt,
                NULL,
                NULL);

          function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = function->return_obj;
          (yyval.expression).identifier = function->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_A_FUNCTION;
        }

        yr_free((yyvsp[-1].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2328 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 49:
#line 801 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.c_string) = yr_strdup(""""); }
#line 2334 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 50:
#line 802 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.c_string) = (yyvsp[0].c_string); }
#line 2340 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 51:
#line 807 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);

        switch((yyvsp[0].expression).type)
        {
          case EXPRESSION_TYPE_INTEGER:
            strlcpy((yyval.c_string), ""i"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_FLOAT:
            strlcpy((yyval.c_string), ""f"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_BOOLEAN:
            strlcpy((yyval.c_string), ""b"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_STRING:
            strlcpy((yyval.c_string), ""s"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_REGEXP:
            strlcpy((yyval.c_string), ""r"", MAX_FUNCTION_ARGS);
            break;
        }

        ERROR_IF((yyval.c_string) == NULL);
      }
#line 2369 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 52:
#line 832 ""grammar.y"" /* yacc.c:1646  */
    {
        if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)
        {
          compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;
        }
        else
        {
          switch((yyvsp[0].expression).type)
          {
            case EXPRESSION_TYPE_INTEGER:
              strlcat((yyvsp[-2].c_string), ""i"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_FLOAT:
              strlcat((yyvsp[-2].c_string), ""f"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_BOOLEAN:
              strlcat((yyvsp[-2].c_string), ""b"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_STRING:
              strlcat((yyvsp[-2].c_string), ""s"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_REGEXP:
              strlcat((yyvsp[-2].c_string), ""r"", MAX_FUNCTION_ARGS);
              break;
          }
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-2].c_string);
      }
#line 2405 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 53:
#line 868 ""grammar.y"" /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        RE* re;
        RE_ERROR error;

        int re_flags = 0;

        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
          re_flags |= RE_FLAGS_NO_CASE;

        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
          re_flags |= RE_FLAGS_DOT_ALL;

        compiler->last_result = yr_re_compile(
            sized_string->c_string,
            re_flags,
            compiler->re_code_arena,
            &re,
            &error);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)
          yr_compiler_set_error_extra_info(compiler, error.message);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              re->root_node->forward_code,
              NULL,
              NULL);

        yr_re_destroy(re);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
      }
#line 2451 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 54:
#line 914 ""grammar.y"" /* yacc.c:1646  */
    {
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
        {
          if ((yyvsp[0].expression).value.sized_string != NULL)
          {
            yywarning(yyscanner,
              ""Using literal string \""%s\"" in a boolean operation."",
              (yyvsp[0].expression).value.sized_string->c_string);
          }

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_STR_TO_BOOL, NULL);

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2474 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 55:
#line 936 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 1, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2487 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 56:
#line 945 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 0, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2500 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 57:
#line 954 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""matches"");
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, ""matches"");

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit(
              yyscanner,
              OP_MATCHES,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2519 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 58:
#line 969 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""contains"");
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, ""contains"");

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_CONTAINS, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2535 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 59:
#line 981 ""grammar.y"" /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_string_identifier(
            yyscanner,
            (yyvsp[0].c_string),
            OP_FOUND,
            UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2553 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 60:
#line 995 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""at"");

        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2570 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 61:
#line 1008 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result!= ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2585 ""grammar.c"" /* yacc.c:1646  */
    break;
 
   case 62:
 #line 1019 ""grammar.y"" /* yacc.c:1646  */
     {
         int var_index;
 
        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
              ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        var_index = yr_parser_lookup_loop_variable(
            yyscanner, (yyvsp[-1].c_string));

        if (var_index >= 0)
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-1].c_string));

          compiler->last_result = \
              ERROR_DUPLICATED_LOOP_IDENTIFIER;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 2619 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 63:
#line 1049 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        }
        else // INTEGER_SET_RANGE
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        }

        compiler->loop_address[compiler->loop_depth] = addr;
         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
         compiler->loop_depth++;
       }
#line 2658 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 64:
#line 1084 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
        compiler->loop_depth--;
        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;


        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)
        {
          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JNUNDEF,
              compiler->loop_address[compiler->loop_depth],
              NULL,
              NULL);
        }
        else // INTEGER_SET_RANGE
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);

          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JLE,
              compiler->loop_address[compiler->loop_depth],
              NULL,
              NULL);

          yr_parser_emit(yyscanner, OP_POP, NULL);
          yr_parser_emit(yyscanner, OP_POP, NULL);
        }

        yr_parser_emit(yyscanner, OP_POP, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

        compiler->loop_identifier[compiler->loop_depth] = NULL;
        yr_free((yyvsp[-8].c_string));
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2741 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 65:
#line 1163 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;

        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
            ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        if (compiler->loop_for_of_mem_offset != -1)
          compiler->last_result = \
            ERROR_NESTED_FOR_OF_LOOP;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_POP_M, mem_offset, &addr, NULL);

        compiler->loop_for_of_mem_offset = mem_offset;
        compiler->loop_address[compiler->loop_depth] = addr;
         compiler->loop_identifier[compiler->loop_depth] = NULL;
         compiler->loop_depth++;
       }
#line 2775 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 66:
#line 1193 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
        compiler->loop_depth--;
        compiler->loop_for_of_mem_offset = -1;

        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;


        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JNUNDEF,
            compiler->loop_address[compiler->loop_depth],
            NULL,
            NULL);

        yr_parser_emit(yyscanner, OP_POP, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
 
       }
#line 2828 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 67:
#line 1242 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_OF, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2838 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 68:
#line 1248 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_NOT, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2848 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 69:
#line 1254 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JFALSE,
            0,          // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
#line 2878 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 70:
#line 1280 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* and_addr;


        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);


        fixup = compiler->fixup_stack_head;


        *(void**)(fixup->address) = (void*)(and_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2918 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 71:
#line 1316 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JTRUE,
            0,         // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
#line 2947 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 72:
#line 1341 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* or_addr;


        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);


        fixup = compiler->fixup_stack_head;


        *(void**)(fixup->address) = (void*)(or_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2987 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 73:
#line 1377 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3000 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 74:
#line 1386 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3013 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 75:
#line 1395 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3026 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 76:
#line 1404 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3039 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 77:
#line 1413 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""=="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3052 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 78:
#line 1422 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""!="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3065 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 79:
#line 1431 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
#line 3073 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 80:
#line 1435 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
#line 3081 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 81:
#line 1442 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_ENUMERATION; }
#line 3087 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 82:
#line 1443 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_RANGE; }
#line 3093 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 83:
#line 1449 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for range's lower bound"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }

        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for range's upper bound"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3115 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 84:
#line 1471 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for enumeration item"");
          compiler->last_result = ERROR_WRONG_TYPE;

        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3131 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 85:
#line 1483 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for enumeration item"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3146 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 86:
#line 1498 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
#line 3155 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 88:
#line 1504 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
         yr_parser_emit_pushes_for_strings(yyscanner, ""$*"");
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3166 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 91:
#line 1521 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3177 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 92:
#line 1528 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3188 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 94:
#line 1540 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
#line 3196 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 95:
#line 1544 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
       }
#line 3204 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 96:
#line 1552 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
#line 3212 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 97:
#line 1556 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit(
             yyscanner, OP_FILESIZE, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3226 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 98:
#line 1566 ""grammar.y"" /* yacc.c:1646  */
     {
         yywarning(yyscanner,
             ""Using deprecated \""entrypoint\"" keyword. Use the \""entry_point\"" ""
            ""function from PE module instead."");

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_ENTRYPOINT, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3244 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 99:
#line 1580 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, ""intXXXX or uintXXXX"");
 

        compiler->last_result = yr_parser_emit(
            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3264 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 100:
#line 1596 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = (yyvsp[0].integer);
       }
#line 3278 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 101:
#line 1606 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg_double(
             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
       }
#line 3291 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 102:
#line 1615 ""grammar.y"" /* yacc.c:1646  */
     {
         SIZED_STRING* sized_string;
 
        compiler->last_result = yr_arena_write_data(
            compiler->sz_arena,
            (yyvsp[0].sized_string),
            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),
            (void**) &sized_string);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              sized_string,
              NULL,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_STRING;
         (yyval.expression).value.sized_string = sized_string;
       }
#line 3320 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 103:
#line 1640 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3336 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 104:
#line 1652 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3352 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 105:
#line 1664 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3372 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 106:
#line 1680 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3388 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 107:
#line 1692 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3408 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 108:
#line 1708 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier
         {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier
        {
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
        {
          compiler->last_result = yr_parser_emit(
              yyscanner, OP_OBJ_VALUE, NULL);

          switch((yyvsp[0].expression).value.object->type)
          {
            case OBJECT_TYPE_INTEGER:
              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
              (yyval.expression).value.integer = UNDEFINED;
              break;
            case OBJECT_TYPE_FLOAT:
              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
              break;
            case OBJECT_TYPE_STRING:
              (yyval.expression).type = EXPRESSION_TYPE_STRING;
              (yyval.expression).value.sized_string = NULL;
              break;
            default:
              yr_compiler_set_error_extra_info_fmt(
                  compiler,
                  ""wrong usage of identifier \""%s\"""",
                  (yyvsp[0].expression).identifier);
              compiler->last_result = ERROR_WRONG_TYPE;
          }
        }
        else
        {
          assert(FALSE);
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3457 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 109:
#line 1753 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, ""-"");
 
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
              UNDEFINED : -((yyvsp[0].expression).value.integer);
          compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)
        {
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3480 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 110:
#line 1772 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""+"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3502 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 111:
#line 1790 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""-"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3524 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 112:
#line 1808 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""*"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3546 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 113:
#line 1826 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""\\"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          if ((yyvsp[0].expression).value.integer != 0)
          {
            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          }
          else
          {
            compiler->last_result = ERROR_DIVISION_BY_ZERO;
            ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          }
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3576 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 114:
#line 1852 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""%"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""%"");

        yr_parser_emit(yyscanner, OP_MOD, NULL);

        if ((yyvsp[0].expression).value.integer != 0)
        {
          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
          compiler->last_result = ERROR_DIVISION_BY_ZERO;
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         }
       }
#line 3598 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 115:
#line 1870 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");

        yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3612 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 116:
#line 1880 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");

        yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3626 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 117:
#line 1890 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""|"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""|"");

        yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3640 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 118:
#line 1900 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""~"");
 
        yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
             UNDEFINED : ~((yyvsp[0].expression).value.integer);
       }
#line 3654 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 119:
#line 1910 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""<<"");

        yr_parser_emit(yyscanner, OP_SHL, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3668 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 120:
#line 1920 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "">>"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "">>"");

        yr_parser_emit(yyscanner, OP_SHR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3682 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 121:
#line 1930 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
#line 3690 ""grammar.c"" /* yacc.c:1646  */
     break;
 
 
#line 3694 ""grammar.c"" /* yacc.c:1646  */
       default: break;
     }
   /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT (""-> $$ ="", yyr1[yyn], &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);

  *++yyvsp = yyval;

  /* Now 'shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTOKENS];

  goto yynewstate;


/*--------------------------------------.
| yyerrlab -- here on detecting error.  |
`--------------------------------------*/
yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);

  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
#if ! YYERROR_VERBOSE
      yyerror (yyscanner, compiler, YY_(""syntax error""));
#else
# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                        yyssp, yytoken)
      {
        char const *yymsgp = YY_(""syntax error"");
        int yysyntax_error_status;
        yysyntax_error_status = YYSYNTAX_ERROR;
        if (yysyntax_error_status == 0)
          yymsgp = yymsg;
        else if (yysyntax_error_status == 1)
          {
            if (yymsg != yymsgbuf)
              YYSTACK_FREE (yymsg);
            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
            if (!yymsg)
              {
                yymsg = yymsgbuf;
                yymsg_alloc = sizeof yymsgbuf;
                yysyntax_error_status = 2;
              }
            else
              {
                yysyntax_error_status = YYSYNTAX_ERROR;
                yymsgp = yymsg;
              }
          }
        yyerror (yyscanner, compiler, yymsgp);
        if (yysyntax_error_status == 2)
          goto yyexhaustedlab;
      }
# undef YYSYNTAX_ERROR
#endif
    }



  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse lookahead token after an
         error, discard it.  */

      if (yychar <= YYEOF)
        {
          /* Return failure if at end of input.  */
          if (yychar == YYEOF)
            YYABORT;
        }
      else
        {
          yydestruct (""Error: discarding"",
                      yytoken, &yylval, yyscanner, compiler);
          yychar = YYEMPTY;
        }
    }

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:

  /* Pacify compilers like GCC when the user code never invokes
     YYERROR and the label yyerrorlab therefore never appears in user
     code.  */
  if (/*CONSTCOND*/ 0)
     goto yyerrorlab;

  /* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;      /* Each real token shifted decrements this.  */

  for (;;)
    {
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
        {
          yyn += YYTERROR;
          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
            {
              yyn = yytable[yyn];
              if (0 < yyn)
                break;
            }
        }

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
        YYABORT;


      yydestruct (""Error: popping"",
                  yystos[yystate], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END


  /* Shift the error token.  */
  YY_SYMBOL_PRINT (""Shifting"", yystos[yyn], yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturn;

/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturn;

#if !defined yyoverflow || YYERROR_VERBOSE
/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/
yyexhaustedlab:
  yyerror (yyscanner, compiler, YY_(""memory exhausted""));
  yyresult = 2;
  /* Fall through.  */
#endif

yyreturn:
  if (yychar != YYEMPTY)
    {
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct (""Cleanup: discarding lookahead"",
                  yytoken, &yylval, yyscanner, compiler);
    }
  /* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct (""Cleanup: popping"",
                  yystos[*yyssp], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif
#if YYERROR_VERBOSE
  if (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
 #endif
   return yyresult;
 }
","yyparse (void *yyscanner, YR_COMPILER* compiler)
{
/* The lookahead symbol.  */
int yychar;


/* The semantic value of the lookahead symbol.  */
/* Default value used for initialization, for pacifying older GCCs
   or non-GCC compilers.  */
YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);

    /* Number of syntax errors so far.  */
    int yynerrs;

    int yystate;
    /* Number of tokens to shift before error messages enabled.  */
    int yyerrstatus;

    /* The stacks and their tools:
       'yyss': related to states.
       'yyvs': related to semantic values.

       Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */

    /* The state stack.  */
    yytype_int16 yyssa[YYINITDEPTH];
    yytype_int16 *yyss;
    yytype_int16 *yyssp;

    /* The semantic value stack.  */
    YYSTYPE yyvsa[YYINITDEPTH];
    YYSTYPE *yyvs;
    YYSTYPE *yyvsp;

    YYSIZE_T yystacksize;

  int yyn;
  int yyresult;
  /* Lookahead token as an internal (translated) token number.  */
  int yytoken = 0;
  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;

#if YYERROR_VERBOSE
  /* Buffer for error messages, and its allocated size.  */
  char yymsgbuf[128];
  char *yymsg = yymsgbuf;
  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
#endif

#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))

  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  yyssp = yyss = yyssa;
  yyvsp = yyvs = yyvsa;
  yystacksize = YYINITDEPTH;

  YYDPRINTF ((stderr, ""Starting parse\n""));

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY; /* Cause a token to be read.  */
  goto yysetstate;

/*------------------------------------------------------------.
| yynewstate -- Push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
 yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;

 yysetstate:
  *yyssp = yystate;

  if (yyss + yystacksize - 1 <= yyssp)
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYSIZE_T yysize = yyssp - yyss + 1;

#ifdef yyoverflow
      {
        /* Give user a chance to reallocate the stack.  Use copies of
           these so that the &'s don't force the real ones into
           memory.  */
        YYSTYPE *yyvs1 = yyvs;
        yytype_int16 *yyss1 = yyss;

        /* Each stack pointer address is followed by the size of the
           data in use in that stack, in bytes.  This used to be a
           conditional around just the two extra args, but that might
           be undefined if yyoverflow is a macro.  */
        yyoverflow (YY_(""memory exhausted""),
                    &yyss1, yysize * sizeof (*yyssp),
                    &yyvs1, yysize * sizeof (*yyvsp),
                    &yystacksize);

        yyss = yyss1;
        yyvs = yyvs1;
      }
#else /* no yyoverflow */
# ifndef YYSTACK_RELOCATE
      goto yyexhaustedlab;
# else
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
        goto yyexhaustedlab;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
        yystacksize = YYMAXDEPTH;

      {
        yytype_int16 *yyss1 = yyss;
        union yyalloc *yyptr =
          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
        if (! yyptr)
          goto yyexhaustedlab;
        YYSTACK_RELOCATE (yyss_alloc, yyss);
        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
#  undef YYSTACK_RELOCATE
        if (yyss1 != yyssa)
          YYSTACK_FREE (yyss1);
      }
# endif
#endif /* no yyoverflow */

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;

      YYDPRINTF ((stderr, ""Stack size increased to %lu\n"",
                  (unsigned long int) yystacksize));

      if (yyss + yystacksize - 1 <= yyssp)
        YYABORT;
    }

  YYDPRINTF ((stderr, ""Entering state %d\n"", yystate));

  if (yystate == YYFINAL)
    YYACCEPT;

  goto yybackup;

/*-----------.
| yybackup.  |
`-----------*/
yybackup:

  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, ""Reading a token: ""));
      yychar = yylex (&yylval, yyscanner, compiler);
    }

  if (yychar <= YYEOF)
    {
      yychar = yytoken = YYEOF;
      YYDPRINTF ((stderr, ""Now at end of input.\n""));
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT (""Next token is"", yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT (""Shifting"", yytoken, &yylval, &yylloc);

  /* Discard the shifted token.  */
  yychar = YYEMPTY;

  yystate = yyn;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END

  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- Do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     '$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
        case 8:
#line 230 ""grammar.y"" /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));

        yr_free((yyvsp[0].sized_string));

        ERROR_IF(result != ERROR_SUCCESS);
      }
#line 1661 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 9:
#line 242 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(
            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));

        ERROR_IF(rule == NULL);

        (yyval.rule) = rule;
      }
#line 1674 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 10:
#line 251 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1

        rule->tags = (yyvsp[-3].c_string);
        rule->metas = (yyvsp[-1].meta);
        rule->strings = (yyvsp[0].string);
      }
#line 1686 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 11:
#line 259 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-7].rule); // rule created in phase 1

        compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(
            yyscanner, rule);

        yr_free((yyvsp[-8].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1701 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 12:
#line 274 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = NULL;
      }
#line 1709 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 13:
#line 278 ""grammar.y"" /* yacc.c:1646  */
    {

        YR_META null_meta;

        memset(&null_meta, 0xFF, sizeof(YR_META));
        null_meta.type = META_TYPE_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->metas_arena,
            &null_meta,
            sizeof(YR_META),
            NULL);

        (yyval.meta) = (yyvsp[0].meta);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1736 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 14:
#line 305 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = NULL;
      }
#line 1744 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 15:
#line 309 ""grammar.y"" /* yacc.c:1646  */
    {

        YR_STRING null_string;

        memset(&null_string, 0xFF, sizeof(YR_STRING));
        null_string.g_flags = STRING_GFLAGS_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->strings_arena,
            &null_string,
            sizeof(YR_STRING),
            NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.string) = (yyvsp[0].string);
      }
#line 1771 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 17:
#line 340 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = 0;  }
#line 1777 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 18:
#line 341 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 1783 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 19:
#line 346 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_PRIVATE; }
#line 1789 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 20:
#line 347 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_GLOBAL; }
#line 1795 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 21:
#line 353 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.c_string) = NULL;
      }
#line 1803 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 22:
#line 357 ""grammar.y"" /* yacc.c:1646  */
    {

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, """", NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[0].c_string);
      }
#line 1821 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 23:
#line 375 ""grammar.y"" /* yacc.c:1646  */
    {
        char* identifier;

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = identifier;
      }
#line 1838 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 24:
#line 388 ""grammar.y"" /* yacc.c:1646  */
    {
        char* tag_name = (yyvsp[-1].c_string);
        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;

        while (tag_length > 0)
        {
          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)
          {
            yr_compiler_set_error_extra_info(compiler, tag_name);
            compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;
            break;
          }

          tag_name = (char*) yr_arena_next_address(
              yyget_extra(yyscanner)->sz_arena,
              tag_name,
              tag_length + 1);

          tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        }

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_arena_write_string(
              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-1].c_string);
      }
#line 1874 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 25:
#line 424 ""grammar.y"" /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[0].meta); }
#line 1880 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 26:
#line 425 ""grammar.y"" /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[-1].meta); }
#line 1886 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 27:
#line 431 ""grammar.y"" /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);

        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_STRING,
            (yyvsp[-2].c_string),
            sized_string->c_string,
            0);

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1906 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 28:
#line 447 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-2].c_string),
            NULL,
            (yyvsp[0].integer));

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1923 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 29:
#line 460 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-3].c_string),
            NULL,
            -(yyvsp[0].integer));

        yr_free((yyvsp[-3].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1940 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 30:
#line 473 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            TRUE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1957 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 31:
#line 486 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            FALSE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1974 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 32:
#line 502 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[0].string); }
#line 1980 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 33:
#line 503 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[-1].string); }
#line 1986 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 34:
#line 509 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 1994 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 35:
#line 513 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);
        compiler->error_line = 0;
      }
#line 2009 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 36:
#line 524 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 2017 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 37:
#line 528 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);

        compiler->error_line = 0;
      }
#line 2033 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 38:
#line 540 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.string) == NULL);
      }
#line 2047 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 39:
#line 553 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = 0; }
#line 2053 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 40:
#line 554 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 2059 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 41:
#line 559 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_WIDE; }
#line 2065 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 42:
#line 560 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_ASCII; }
#line 2071 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 43:
#line 561 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }
#line 2077 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 44:
#line 562 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }
#line 2083 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 45:
#line 568 ""grammar.y"" /* yacc.c:1646  */
    {
        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));

        if (var_index >= 0)
        {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner,
              OP_PUSH_M,
              LOOP_LOCAL_VARS * var_index,
              NULL,
              NULL);

          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
          (yyval.expression).identifier = compiler->loop_identifier[var_index];
        }
        else
        {

          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
              compiler->objects_table, (yyvsp[0].c_string), NULL);

          if (object == NULL)
          {
            char* ns = compiler->current_namespace->name;

            object = (YR_OBJECT*) yr_hash_table_lookup(
                compiler->objects_table, (yyvsp[0].c_string), ns);
          }

          if (object != NULL)
          {
            char* id;

            compiler->last_result = yr_arena_write_string(
                compiler->sz_arena, (yyvsp[0].c_string), &id);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_LOAD,
                  id,
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = object;
            (yyval.expression).identifier = object->identifier;
          }
          else
          {
            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
                compiler->rules_table,
                (yyvsp[0].c_string),
                compiler->current_namespace->name);

            if (rule != NULL)
            {
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_PUSH_RULE,
                  rule,
                  NULL,
                  NULL);

              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
              (yyval.expression).value.integer = UNDEFINED;
              (yyval.expression).identifier = rule->identifier;
            }
            else
            {
              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
              compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;
            }
          }
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2172 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 46:
#line 653 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT* field = NULL;

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)
        {
          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));

          if (field != NULL)
          {
            char* ident;

            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[0].c_string), &ident);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_FIELD,
                  ident,
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = field;
            (yyval.expression).identifier = field->identifier;
          }
          else
          {
            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
            compiler->last_result = ERROR_INVALID_FIELD_NAME;
          }
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-2].expression).identifier);

          compiler->last_result = ERROR_NOT_A_STRUCTURE;
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2222 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 47:
#line 699 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT_ARRAY* array;
        YR_OBJECT_DICTIONARY* dict;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
          {
            yr_compiler_set_error_extra_info(
                compiler, ""array indexes must be of integer type"");
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_INDEX_ARRAY, NULL);

          array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = array->prototype_item;
          (yyval.expression).identifier = array->identifier;
        }
        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)
          {
            yr_compiler_set_error_extra_info(
                compiler, ""dictionary keys must be of string type"");
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_LOOKUP_DICT, NULL);

          dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = dict->prototype_item;
          (yyval.expression).identifier = dict->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_INDEXABLE;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2283 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 48:
#line 757 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT_FUNCTION* function;
        char* args_fmt;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)
        {
          compiler->last_result = yr_parser_check_types(
              compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_parser_emit_with_arg_reloc(
                yyscanner,
                OP_CALL,
                args_fmt,
                NULL,
                NULL);

          function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = function->return_obj;
          (yyval.expression).identifier = function->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_A_FUNCTION;
        }

        yr_free((yyvsp[-1].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2328 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 49:
#line 801 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.c_string) = yr_strdup(""""); }
#line 2334 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 50:
#line 802 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.c_string) = (yyvsp[0].c_string); }
#line 2340 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 51:
#line 807 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);

        switch((yyvsp[0].expression).type)
        {
          case EXPRESSION_TYPE_INTEGER:
            strlcpy((yyval.c_string), ""i"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_FLOAT:
            strlcpy((yyval.c_string), ""f"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_BOOLEAN:
            strlcpy((yyval.c_string), ""b"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_STRING:
            strlcpy((yyval.c_string), ""s"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_REGEXP:
            strlcpy((yyval.c_string), ""r"", MAX_FUNCTION_ARGS);
            break;
        }

        ERROR_IF((yyval.c_string) == NULL);
      }
#line 2369 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 52:
#line 832 ""grammar.y"" /* yacc.c:1646  */
    {
        if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)
        {
          compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;
        }
        else
        {
          switch((yyvsp[0].expression).type)
          {
            case EXPRESSION_TYPE_INTEGER:
              strlcat((yyvsp[-2].c_string), ""i"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_FLOAT:
              strlcat((yyvsp[-2].c_string), ""f"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_BOOLEAN:
              strlcat((yyvsp[-2].c_string), ""b"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_STRING:
              strlcat((yyvsp[-2].c_string), ""s"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_REGEXP:
              strlcat((yyvsp[-2].c_string), ""r"", MAX_FUNCTION_ARGS);
              break;
          }
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-2].c_string);
      }
#line 2405 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 53:
#line 868 ""grammar.y"" /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        RE* re;
        RE_ERROR error;

        int re_flags = 0;

        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
          re_flags |= RE_FLAGS_NO_CASE;

        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
          re_flags |= RE_FLAGS_DOT_ALL;

        compiler->last_result = yr_re_compile(
            sized_string->c_string,
            re_flags,
            compiler->re_code_arena,
            &re,
            &error);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)
          yr_compiler_set_error_extra_info(compiler, error.message);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              re->root_node->forward_code,
              NULL,
              NULL);

        yr_re_destroy(re);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
      }
#line 2451 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 54:
#line 914 ""grammar.y"" /* yacc.c:1646  */
    {
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
        {
          if ((yyvsp[0].expression).value.sized_string != NULL)
          {
            yywarning(yyscanner,
              ""Using literal string \""%s\"" in a boolean operation."",
              (yyvsp[0].expression).value.sized_string->c_string);
          }

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_STR_TO_BOOL, NULL);

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2474 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 55:
#line 936 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 1, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2487 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 56:
#line 945 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 0, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2500 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 57:
#line 954 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""matches"");
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, ""matches"");

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit(
              yyscanner,
              OP_MATCHES,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2519 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 58:
#line 969 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""contains"");
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, ""contains"");

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_CONTAINS, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2535 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 59:
#line 981 ""grammar.y"" /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_string_identifier(
            yyscanner,
            (yyvsp[0].c_string),
            OP_FOUND,
            UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2553 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 60:
#line 995 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""at"");

        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2570 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 61:
#line 1008 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result!= ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2585 ""grammar.c"" /* yacc.c:1646  */
    break;
 
   case 62:
 #line 1019 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->loop_depth--;
        compiler->loop_identifier[compiler->loop_depth] = NULL;
      }
#line 2594 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 63:
#line 1024 ""grammar.y"" /* yacc.c:1646  */
     {
         int var_index;
 
        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
              ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        var_index = yr_parser_lookup_loop_variable(
            yyscanner, (yyvsp[-1].c_string));

        if (var_index >= 0)
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-1].c_string));

          compiler->last_result = \
              ERROR_DUPLICATED_LOOP_IDENTIFIER;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 2628 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 64:
#line 1054 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        }
        else // INTEGER_SET_RANGE
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        }

        compiler->loop_address[compiler->loop_depth] = addr;
         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
         compiler->loop_depth++;
       }
#line 2667 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 65:
#line 1089 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
        compiler->loop_depth--;
        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;


        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)
        {
          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JNUNDEF,
              compiler->loop_address[compiler->loop_depth],
              NULL,
              NULL);
        }
        else // INTEGER_SET_RANGE
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);

          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JLE,
              compiler->loop_address[compiler->loop_depth],
              NULL,
              NULL);

          yr_parser_emit(yyscanner, OP_POP, NULL);
          yr_parser_emit(yyscanner, OP_POP, NULL);
        }

        yr_parser_emit(yyscanner, OP_POP, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

        compiler->loop_identifier[compiler->loop_depth] = NULL;
        yr_free((yyvsp[-8].c_string));
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2750 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 66:
#line 1168 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;

        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
            ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        if (compiler->loop_for_of_mem_offset != -1)
          compiler->last_result = \
            ERROR_NESTED_FOR_OF_LOOP;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_POP_M, mem_offset, &addr, NULL);

        compiler->loop_for_of_mem_offset = mem_offset;
        compiler->loop_address[compiler->loop_depth] = addr;
         compiler->loop_identifier[compiler->loop_depth] = NULL;
         compiler->loop_depth++;
       }
#line 2784 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 67:
#line 1198 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
        compiler->loop_depth--;
        compiler->loop_for_of_mem_offset = -1;

        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;


        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JNUNDEF,
            compiler->loop_address[compiler->loop_depth],
            NULL,
            NULL);

        yr_parser_emit(yyscanner, OP_POP, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
 
       }
#line 2837 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 68:
#line 1247 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_OF, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2847 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 69:
#line 1253 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_NOT, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2857 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 70:
#line 1259 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JFALSE,
            0,          // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
#line 2887 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 71:
#line 1285 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* and_addr;


        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);


        fixup = compiler->fixup_stack_head;


        *(void**)(fixup->address) = (void*)(and_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2927 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 72:
#line 1321 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JTRUE,
            0,         // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
#line 2956 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 73:
#line 1346 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* or_addr;


        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);


        fixup = compiler->fixup_stack_head;


        *(void**)(fixup->address) = (void*)(or_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2996 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 74:
#line 1382 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3009 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 75:
#line 1391 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3022 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 76:
#line 1400 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3035 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 77:
#line 1409 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3048 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 78:
#line 1418 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""=="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3061 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 79:
#line 1427 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""!="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3074 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 80:
#line 1436 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
#line 3082 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 81:
#line 1440 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
#line 3090 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 82:
#line 1447 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_ENUMERATION; }
#line 3096 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 83:
#line 1448 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_RANGE; }
#line 3102 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 84:
#line 1454 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for range's lower bound"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }

        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for range's upper bound"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3124 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 85:
#line 1476 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for enumeration item"");
          compiler->last_result = ERROR_WRONG_TYPE;

        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3140 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 86:
#line 1488 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for enumeration item"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3155 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 87:
#line 1503 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
#line 3164 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 89:
#line 1509 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
         yr_parser_emit_pushes_for_strings(yyscanner, ""$*"");
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3175 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 92:
#line 1526 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3186 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 93:
#line 1533 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3197 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 95:
#line 1545 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
#line 3205 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 96:
#line 1549 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
       }
#line 3213 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 97:
#line 1557 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
#line 3221 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 98:
#line 1561 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit(
             yyscanner, OP_FILESIZE, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3235 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 99:
#line 1571 ""grammar.y"" /* yacc.c:1646  */
     {
         yywarning(yyscanner,
             ""Using deprecated \""entrypoint\"" keyword. Use the \""entry_point\"" ""
            ""function from PE module instead."");

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_ENTRYPOINT, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3253 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 100:
#line 1585 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, ""intXXXX or uintXXXX"");
 

        compiler->last_result = yr_parser_emit(
            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3273 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 101:
#line 1601 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = (yyvsp[0].integer);
       }
#line 3287 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 102:
#line 1611 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg_double(
             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
       }
#line 3300 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 103:
#line 1620 ""grammar.y"" /* yacc.c:1646  */
     {
         SIZED_STRING* sized_string;
 
        compiler->last_result = yr_arena_write_data(
            compiler->sz_arena,
            (yyvsp[0].sized_string),
            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),
            (void**) &sized_string);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              sized_string,
              NULL,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_STRING;
         (yyval.expression).value.sized_string = sized_string;
       }
#line 3329 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 104:
#line 1645 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3345 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 105:
#line 1657 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3361 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 106:
#line 1669 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3381 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 107:
#line 1685 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3397 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 108:
#line 1697 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3417 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 109:
#line 1713 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier
         {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier
        {
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
        {
          compiler->last_result = yr_parser_emit(
              yyscanner, OP_OBJ_VALUE, NULL);

          switch((yyvsp[0].expression).value.object->type)
          {
            case OBJECT_TYPE_INTEGER:
              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
              (yyval.expression).value.integer = UNDEFINED;
              break;
            case OBJECT_TYPE_FLOAT:
              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
              break;
            case OBJECT_TYPE_STRING:
              (yyval.expression).type = EXPRESSION_TYPE_STRING;
              (yyval.expression).value.sized_string = NULL;
              break;
            default:
              yr_compiler_set_error_extra_info_fmt(
                  compiler,
                  ""wrong usage of identifier \""%s\"""",
                  (yyvsp[0].expression).identifier);
              compiler->last_result = ERROR_WRONG_TYPE;
          }
        }
        else
        {
          assert(FALSE);
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3466 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 110:
#line 1758 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, ""-"");
 
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
              UNDEFINED : -((yyvsp[0].expression).value.integer);
          compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)
        {
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3489 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 111:
#line 1777 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""+"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3511 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 112:
#line 1795 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""-"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3533 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 113:
#line 1813 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""*"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3555 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 114:
#line 1831 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""\\"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          if ((yyvsp[0].expression).value.integer != 0)
          {
            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          }
          else
          {
            compiler->last_result = ERROR_DIVISION_BY_ZERO;
            ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          }
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3585 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 115:
#line 1857 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""%"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""%"");

        yr_parser_emit(yyscanner, OP_MOD, NULL);

        if ((yyvsp[0].expression).value.integer != 0)
        {
          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
          compiler->last_result = ERROR_DIVISION_BY_ZERO;
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         }
       }
#line 3607 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 116:
#line 1875 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");

        yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3621 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 117:
#line 1885 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");

        yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3635 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 118:
#line 1895 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""|"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""|"");

        yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3649 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 119:
#line 1905 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""~"");
 
        yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
             UNDEFINED : ~((yyvsp[0].expression).value.integer);
       }
#line 3663 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 120:
#line 1915 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""<<"");

        yr_parser_emit(yyscanner, OP_SHL, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3677 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 121:
#line 1925 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "">>"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "">>"");

        yr_parser_emit(yyscanner, OP_SHR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3691 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 122:
#line 1935 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
#line 3699 ""grammar.c"" /* yacc.c:1646  */
     break;
 
 
#line 3703 ""grammar.c"" /* yacc.c:1646  */
       default: break;
     }
   /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT (""-> $$ ="", yyr1[yyn], &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);

  *++yyvsp = yyval;

  /* Now 'shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTOKENS];

  goto yynewstate;


/*--------------------------------------.
| yyerrlab -- here on detecting error.  |
`--------------------------------------*/
yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);

  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
#if ! YYERROR_VERBOSE
      yyerror (yyscanner, compiler, YY_(""syntax error""));
#else
# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                        yyssp, yytoken)
      {
        char const *yymsgp = YY_(""syntax error"");
        int yysyntax_error_status;
        yysyntax_error_status = YYSYNTAX_ERROR;
        if (yysyntax_error_status == 0)
          yymsgp = yymsg;
        else if (yysyntax_error_status == 1)
          {
            if (yymsg != yymsgbuf)
              YYSTACK_FREE (yymsg);
            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
            if (!yymsg)
              {
                yymsg = yymsgbuf;
                yymsg_alloc = sizeof yymsgbuf;
                yysyntax_error_status = 2;
              }
            else
              {
                yysyntax_error_status = YYSYNTAX_ERROR;
                yymsgp = yymsg;
              }
          }
        yyerror (yyscanner, compiler, yymsgp);
        if (yysyntax_error_status == 2)
          goto yyexhaustedlab;
      }
# undef YYSYNTAX_ERROR
#endif
    }



  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse lookahead token after an
         error, discard it.  */

      if (yychar <= YYEOF)
        {
          /* Return failure if at end of input.  */
          if (yychar == YYEOF)
            YYABORT;
        }
      else
        {
          yydestruct (""Error: discarding"",
                      yytoken, &yylval, yyscanner, compiler);
          yychar = YYEMPTY;
        }
    }

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:

  /* Pacify compilers like GCC when the user code never invokes
     YYERROR and the label yyerrorlab therefore never appears in user
     code.  */
  if (/*CONSTCOND*/ 0)
     goto yyerrorlab;

  /* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;      /* Each real token shifted decrements this.  */

  for (;;)
    {
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
        {
          yyn += YYTERROR;
          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
            {
              yyn = yytable[yyn];
              if (0 < yyn)
                break;
            }
        }

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
        YYABORT;


      yydestruct (""Error: popping"",
                  yystos[yystate], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END


  /* Shift the error token.  */
  YY_SYMBOL_PRINT (""Shifting"", yystos[yyn], yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturn;

/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturn;

#if !defined yyoverflow || YYERROR_VERBOSE
/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/
yyexhaustedlab:
  yyerror (yyscanner, compiler, YY_(""memory exhausted""));
  yyresult = 2;
  /* Fall through.  */
#endif

yyreturn:
  if (yychar != YYEMPTY)
    {
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct (""Cleanup: discarding lookahead"",
                  yytoken, &yylval, yyscanner, compiler);
    }
  /* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct (""Cleanup: popping"",
                  yystos[*yyssp], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif
#if YYERROR_VERBOSE
  if (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
 #endif
   return yyresult;
 }
","The vulnerability in the original code lies in the handling of memory allocation for the parser's stacks, specifically in the `yysetstate` function. If the stack size exceeds `YYMAXDEPTH`, the code does not properly handle the situation, potentially leading to a stack overflow or memory exhaustion. The lack of checks when reallocating memory for `yyss` and `yyvs` can result in undefined behavior if the memory allocation fails. 

In the fixed code, additional checks were introduced to ensure that the stack size does not exceed `YYMAXDEPTH` before reallocating memory. This prevents potential overflows and ensures that the program can handle memory exhaustion gracefully, thereby enhancing the overall stability and security of the parser.","The vulnerability in the original code stems from inadequate handling of memory allocation for the parser's stacks, which could lead to stack overflow or memory exhaustion if the stack size exceeds predefined limits. Specifically, the code fails to properly check for memory allocation failures or to enforce maximum stack size constraints, resulting in potential undefined behavior. In the revised code, additional checks were implemented to ensure that the stack size does not surpass the maximum limit before reallocating memory, thereby preventing overflows and ensuring that memory exhaustion is handled more gracefully, enhancing the overall stability and security of the parser."
32,181661,181661,,Local,Not required,Complete,CVE-2016-10200,https://www.cvedetails.com/cve/CVE-2016-10200/,CWE-416,Medium,Complete,Complete,,2017-03-07,6.9,"Race condition in the L2TPv3 IP Encapsulation feature in the Linux kernel before 4.8.14 allows local users to gain privileges or cause a denial of service (use-after-free) by making multiple bind system calls without properly ascertaining whether a socket has the SOCK_ZAPPED status, related to net/l2tp/l2tp_ip.c and net/l2tp/l2tp_ip6.c.",2018-01-04,DoS +Priv ,3,https://github.com/torvalds/linux/commit/32c231164b762dddefa13af5a0101032c70b50ef,32c231164b762dddefa13af5a0101032c70b50ef,"l2tp: fix racy SOCK_ZAPPED flag check in l2tp_ip{,6}_bind()

Lock socket before checking the SOCK_ZAPPED flag in l2tp_ip6_bind().
Without lock, a concurrent call could modify the socket flags between
the sock_flag(sk, SOCK_ZAPPED) test and the lock_sock() call. This way,
a socket could be inserted twice in l2tp_ip6_bind_table. Releasing it
would then leave a stale pointer there, generating use-after-free
errors when walking through the list or modifying adjacent entries.

BUG: KASAN: use-after-free in l2tp_ip6_close+0x22e/0x290 at addr ffff8800081b0ed8
Write of size 8 by task syz-executor/10987
CPU: 0 PID: 10987 Comm: syz-executor Not tainted 4.8.0+ #39
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.8.2-0-g33fbe13 by qemu-project.org 04/01/2014
 ffff880031d97838 ffffffff829f835b ffff88001b5a1640 ffff8800081b0ec0
 ffff8800081b15a0 ffff8800081b6d20 ffff880031d97860 ffffffff8174d3cc
 ffff880031d978f0 ffff8800081b0e80 ffff88001b5a1640 ffff880031d978e0
Call Trace:
 [<ffffffff829f835b>] dump_stack+0xb3/0x118 lib/dump_stack.c:15
 [<ffffffff8174d3cc>] kasan_object_err+0x1c/0x70 mm/kasan/report.c:156
 [<     inline     >] print_address_description mm/kasan/report.c:194
 [<ffffffff8174d666>] kasan_report_error+0x1f6/0x4d0 mm/kasan/report.c:283
 [<     inline     >] kasan_report mm/kasan/report.c:303
 [<ffffffff8174db7e>] __asan_report_store8_noabort+0x3e/0x40 mm/kasan/report.c:329
 [<     inline     >] __write_once_size ./include/linux/compiler.h:249
 [<     inline     >] __hlist_del ./include/linux/list.h:622
 [<     inline     >] hlist_del_init ./include/linux/list.h:637
 [<ffffffff8579047e>] l2tp_ip6_close+0x22e/0x290 net/l2tp/l2tp_ip6.c:239
 [<ffffffff850b2dfd>] inet_release+0xed/0x1c0 net/ipv4/af_inet.c:415
 [<ffffffff851dc5a0>] inet6_release+0x50/0x70 net/ipv6/af_inet6.c:422
 [<ffffffff84c4581d>] sock_release+0x8d/0x1d0 net/socket.c:570
 [<ffffffff84c45976>] sock_close+0x16/0x20 net/socket.c:1017
 [<ffffffff817a108c>] __fput+0x28c/0x780 fs/file_table.c:208
 [<ffffffff817a1605>] ____fput+0x15/0x20 fs/file_table.c:244
 [<ffffffff813774f9>] task_work_run+0xf9/0x170
 [<ffffffff81324aae>] do_exit+0x85e/0x2a00
 [<ffffffff81326dc8>] do_group_exit+0x108/0x330
 [<ffffffff81348cf7>] get_signal+0x617/0x17a0 kernel/signal.c:2307
 [<ffffffff811b49af>] do_signal+0x7f/0x18f0
 [<ffffffff810039bf>] exit_to_usermode_loop+0xbf/0x150 arch/x86/entry/common.c:156
 [<     inline     >] prepare_exit_to_usermode arch/x86/entry/common.c:190
 [<ffffffff81006060>] syscall_return_slowpath+0x1a0/0x1e0 arch/x86/entry/common.c:259
 [<ffffffff85e4d726>] entry_SYSCALL_64_fastpath+0xc4/0xc6
Object at ffff8800081b0ec0, in cache L2TP/IPv6 size: 1448
Allocated:
PID = 10987
 [ 1116.897025] [<ffffffff811ddcb6>] save_stack_trace+0x16/0x20
 [ 1116.897025] [<ffffffff8174c736>] save_stack+0x46/0xd0
 [ 1116.897025] [<ffffffff8174c9ad>] kasan_kmalloc+0xad/0xe0
 [ 1116.897025] [<ffffffff8174cee2>] kasan_slab_alloc+0x12/0x20
 [ 1116.897025] [<     inline     >] slab_post_alloc_hook mm/slab.h:417
 [ 1116.897025] [<     inline     >] slab_alloc_node mm/slub.c:2708
 [ 1116.897025] [<     inline     >] slab_alloc mm/slub.c:2716
 [ 1116.897025] [<ffffffff817476a8>] kmem_cache_alloc+0xc8/0x2b0 mm/slub.c:2721
 [ 1116.897025] [<ffffffff84c4f6a9>] sk_prot_alloc+0x69/0x2b0 net/core/sock.c:1326
 [ 1116.897025] [<ffffffff84c58ac8>] sk_alloc+0x38/0xae0 net/core/sock.c:1388
 [ 1116.897025] [<ffffffff851ddf67>] inet6_create+0x2d7/0x1000 net/ipv6/af_inet6.c:182
 [ 1116.897025] [<ffffffff84c4af7b>] __sock_create+0x37b/0x640 net/socket.c:1153
 [ 1116.897025] [<     inline     >] sock_create net/socket.c:1193
 [ 1116.897025] [<     inline     >] SYSC_socket net/socket.c:1223
 [ 1116.897025] [<ffffffff84c4b46f>] SyS_socket+0xef/0x1b0 net/socket.c:1203
 [ 1116.897025] [<ffffffff85e4d685>] entry_SYSCALL_64_fastpath+0x23/0xc6
Freed:
PID = 10987
 [ 1116.897025] [<ffffffff811ddcb6>] save_stack_trace+0x16/0x20
 [ 1116.897025] [<ffffffff8174c736>] save_stack+0x46/0xd0
 [ 1116.897025] [<ffffffff8174cf61>] kasan_slab_free+0x71/0xb0
 [ 1116.897025] [<     inline     >] slab_free_hook mm/slub.c:1352
 [ 1116.897025] [<     inline     >] slab_free_freelist_hook mm/slub.c:1374
 [ 1116.897025] [<     inline     >] slab_free mm/slub.c:2951
 [ 1116.897025] [<ffffffff81748b28>] kmem_cache_free+0xc8/0x330 mm/slub.c:2973
 [ 1116.897025] [<     inline     >] sk_prot_free net/core/sock.c:1369
 [ 1116.897025] [<ffffffff84c541eb>] __sk_destruct+0x32b/0x4f0 net/core/sock.c:1444
 [ 1116.897025] [<ffffffff84c5aca4>] sk_destruct+0x44/0x80 net/core/sock.c:1452
 [ 1116.897025] [<ffffffff84c5ad33>] __sk_free+0x53/0x220 net/core/sock.c:1460
 [ 1116.897025] [<ffffffff84c5af23>] sk_free+0x23/0x30 net/core/sock.c:1471
 [ 1116.897025] [<ffffffff84c5cb6c>] sk_common_release+0x28c/0x3e0 ./include/net/sock.h:1589
 [ 1116.897025] [<ffffffff8579044e>] l2tp_ip6_close+0x1fe/0x290 net/l2tp/l2tp_ip6.c:243
 [ 1116.897025] [<ffffffff850b2dfd>] inet_release+0xed/0x1c0 net/ipv4/af_inet.c:415
 [ 1116.897025] [<ffffffff851dc5a0>] inet6_release+0x50/0x70 net/ipv6/af_inet6.c:422
 [ 1116.897025] [<ffffffff84c4581d>] sock_release+0x8d/0x1d0 net/socket.c:570
 [ 1116.897025] [<ffffffff84c45976>] sock_close+0x16/0x20 net/socket.c:1017
 [ 1116.897025] [<ffffffff817a108c>] __fput+0x28c/0x780 fs/file_table.c:208
 [ 1116.897025] [<ffffffff817a1605>] ____fput+0x15/0x20 fs/file_table.c:244
 [ 1116.897025] [<ffffffff813774f9>] task_work_run+0xf9/0x170
 [ 1116.897025] [<ffffffff81324aae>] do_exit+0x85e/0x2a00
 [ 1116.897025] [<ffffffff81326dc8>] do_group_exit+0x108/0x330
 [ 1116.897025] [<ffffffff81348cf7>] get_signal+0x617/0x17a0 kernel/signal.c:2307
 [ 1116.897025] [<ffffffff811b49af>] do_signal+0x7f/0x18f0
 [ 1116.897025] [<ffffffff810039bf>] exit_to_usermode_loop+0xbf/0x150 arch/x86/entry/common.c:156
 [ 1116.897025] [<     inline     >] prepare_exit_to_usermode arch/x86/entry/common.c:190
 [ 1116.897025] [<ffffffff81006060>] syscall_return_slowpath+0x1a0/0x1e0 arch/x86/entry/common.c:259
 [ 1116.897025] [<ffffffff85e4d726>] entry_SYSCALL_64_fastpath+0xc4/0xc6
Memory state around the buggy address:
 ffff8800081b0d80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
 ffff8800081b0e00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
>ffff8800081b0e80: fc fc fc fc fc fc fc fc fb fb fb fb fb fb fb fb
                                                    ^
 ffff8800081b0f00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff8800081b0f80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb

==================================================================

The same issue exists with l2tp_ip_bind() and l2tp_ip_bind_table.

Fixes: c51ce49735c1 (""l2tp: fix oops in L2TP IP sockets for connect() AF_UNSPEC case"")
Reported-by: Baozeng Ding <sploving1@gmail.com>
Reported-by: Andrey Konovalov <andreyknvl@google.com>
Tested-by: Baozeng Ding <sploving1@gmail.com>
Signed-off-by: Guillaume Nault <g.nault@alphalink.fr>
Signed-off-by: David S. Miller <davem@davemloft.net>",2,net/l2tp/l2tp_ip.c,"{""sha"": ""982f6c44ea01f053a51afcbb4b271a2e77df2178"", ""filename"": ""net/l2tp/l2tp_ip.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/32c231164b762dddefa13af5a0101032c70b50ef/net/l2tp/l2tp_ip.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/32c231164b762dddefa13af5a0101032c70b50ef/net/l2tp/l2tp_ip.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/l2tp/l2tp_ip.c?ref=32c231164b762dddefa13af5a0101032c70b50ef"", ""patch"": ""@@ -251,8 +251,6 @@ static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n \tint ret;\n \tint chk_addr_ret;\n \n-\tif (!sock_flag(sk, SOCK_ZAPPED))\n-\t\treturn -EINVAL;\n \tif (addr_len < sizeof(struct sockaddr_l2tpip))\n \t\treturn -EINVAL;\n \tif (addr->l2tp_family != AF_INET)\n@@ -267,6 +265,9 @@ static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n \tread_unlock_bh(&l2tp_ip_lock);\n \n \tlock_sock(sk);\n+\tif (!sock_flag(sk, SOCK_ZAPPED))\n+\t\tgoto out;\n+\n \tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))\n \t\tgoto out;\n ""}<_**next**_>{""sha"": ""9978d01ba0bae4eaf34810665d581ddd06579e96"", ""filename"": ""net/l2tp/l2tp_ip6.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/32c231164b762dddefa13af5a0101032c70b50ef/net/l2tp/l2tp_ip6.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/32c231164b762dddefa13af5a0101032c70b50ef/net/l2tp/l2tp_ip6.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/l2tp/l2tp_ip6.c?ref=32c231164b762dddefa13af5a0101032c70b50ef"", ""patch"": ""@@ -269,8 +269,6 @@ static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n \tint addr_type;\n \tint err;\n \n-\tif (!sock_flag(sk, SOCK_ZAPPED))\n-\t\treturn -EINVAL;\n \tif (addr->l2tp_family != AF_INET6)\n \t\treturn -EINVAL;\n \tif (addr_len < sizeof(*addr))\n@@ -296,6 +294,9 @@ static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n \tlock_sock(sk);\n \n \terr = -EINVAL;\n+\tif (!sock_flag(sk, SOCK_ZAPPED))\n+\t\tgoto out_unlock;\n+\n \tif (sk->sk_state != TCP_CLOSE)\n \t\tgoto out_unlock;\n ""}","static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;
	struct net *net = sock_net(sk);
 	int ret;
 	int chk_addr_ret;
 
 	if (addr_len < sizeof(struct sockaddr_l2tpip))
 		return -EINVAL;
 	if (addr->l2tp_family != AF_INET)
		return -EINVAL;

	ret = -EADDRINUSE;
	read_lock_bh(&l2tp_ip_lock);
	if (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,
				  sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;

 	read_unlock_bh(&l2tp_ip_lock);
 
 	lock_sock(sk);
	if (!sock_flag(sk, SOCK_ZAPPED))
		goto out;

 	if (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))
 		goto out;
 
	chk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);
	ret = -EADDRNOTAVAIL;
	if (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&
	    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)
		goto out;

	if (addr->l2tp_addr.s_addr)
		inet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;
	if (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)
		inet->inet_saddr = 0;  /* Use device */
	sk_dst_reset(sk);

	l2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip_lock);
	sk_add_bind_node(sk, &l2tp_ip_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip_lock);
	ret = 0;
	sock_reset_flag(sk, SOCK_ZAPPED);

out:
	release_sock(sk);

	return ret;

out_in_use:
	read_unlock_bh(&l2tp_ip_lock);

	return ret;
}
","static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;
	struct net *net = sock_net(sk);
 	int ret;
 	int chk_addr_ret;
 
	if (!sock_flag(sk, SOCK_ZAPPED))
		return -EINVAL;
 	if (addr_len < sizeof(struct sockaddr_l2tpip))
 		return -EINVAL;
 	if (addr->l2tp_family != AF_INET)
		return -EINVAL;

	ret = -EADDRINUSE;
	read_lock_bh(&l2tp_ip_lock);
	if (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,
				  sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;

 	read_unlock_bh(&l2tp_ip_lock);
 
 	lock_sock(sk);
 	if (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))
 		goto out;
 
	chk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);
	ret = -EADDRNOTAVAIL;
	if (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&
	    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)
		goto out;

	if (addr->l2tp_addr.s_addr)
		inet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;
	if (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)
		inet->inet_saddr = 0;  /* Use device */
	sk_dst_reset(sk);

	l2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip_lock);
	sk_add_bind_node(sk, &l2tp_ip_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip_lock);
	ret = 0;
	sock_reset_flag(sk, SOCK_ZAPPED);

out:
	release_sock(sk);

	return ret;

out_in_use:
	read_unlock_bh(&l2tp_ip_lock);

	return ret;
}
",C,"	if (!sock_flag(sk, SOCK_ZAPPED))
		goto out;

","	if (!sock_flag(sk, SOCK_ZAPPED))
		return -EINVAL;
",,"@@ -251,8 +251,6 @@ static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 	int ret;
 	int chk_addr_ret;
 
-	if (!sock_flag(sk, SOCK_ZAPPED))
-		return -EINVAL;
 	if (addr_len < sizeof(struct sockaddr_l2tpip))
 		return -EINVAL;
 	if (addr->l2tp_family != AF_INET)
@@ -267,6 +265,9 @@ static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 	read_unlock_bh(&l2tp_ip_lock);
 
 	lock_sock(sk);
+	if (!sock_flag(sk, SOCK_ZAPPED))
+		goto out;
+
 	if (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))
 		goto out;
 ",linux,32c231164b762dddefa13af5a0101032c70b50ef,adda306744ec64c7bcd6c230a6bc060fb77bd7c3,1,"static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;
	struct net *net = sock_net(sk);
 	int ret;
 	int chk_addr_ret;
 
//flaw_line_below:
	if (!sock_flag(sk, SOCK_ZAPPED))
//flaw_line_below:
		return -EINVAL;
 	if (addr_len < sizeof(struct sockaddr_l2tpip))
 		return -EINVAL;
 	if (addr->l2tp_family != AF_INET)
		return -EINVAL;

	ret = -EADDRINUSE;
	read_lock_bh(&l2tp_ip_lock);
	if (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,
				  sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;

 	read_unlock_bh(&l2tp_ip_lock);
 
 	lock_sock(sk);
//fix_flaw_line_below:
//	if (!sock_flag(sk, SOCK_ZAPPED))
//fix_flaw_line_below:
//		goto out;
//fix_flaw_line_below:
//
 	if (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))
 		goto out;
 
	chk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);
	ret = -EADDRNOTAVAIL;
	if (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&
	    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)
		goto out;

	if (addr->l2tp_addr.s_addr)
		inet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;
	if (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)
		inet->inet_saddr = 0;  /* Use device */
	sk_dst_reset(sk);

	l2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip_lock);
	sk_add_bind_node(sk, &l2tp_ip_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip_lock);
	ret = 0;
	sock_reset_flag(sk, SOCK_ZAPPED);

out:
	release_sock(sk);

	return ret;

out_in_use:
	read_unlock_bh(&l2tp_ip_lock);

	return ret;
}
",181661,"static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;
	struct net *net = sock_net(sk);
 	int ret;
 	int chk_addr_ret;
 
	if (!sock_flag(sk, SOCK_ZAPPED))
		return -EINVAL;
 	if (addr_len < sizeof(struct sockaddr_l2tpip))
 		return -EINVAL;
 	if (addr->l2tp_family != AF_INET)
		return -EINVAL;

	ret = -EADDRINUSE;
	read_lock_bh(&l2tp_ip_lock);
	if (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,
				  sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;

 	read_unlock_bh(&l2tp_ip_lock);
 
 	lock_sock(sk);
 	if (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))
 		goto out;
 
	chk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);
	ret = -EADDRNOTAVAIL;
	if (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&
	    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)
		goto out;

	if (addr->l2tp_addr.s_addr)
		inet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;
	if (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)
		inet->inet_saddr = 0;  /* Use device */
	sk_dst_reset(sk);

	l2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip_lock);
	sk_add_bind_node(sk, &l2tp_ip_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip_lock);
	ret = 0;
	sock_reset_flag(sk, SOCK_ZAPPED);

out:
	release_sock(sk);

	return ret;

out_in_use:
	read_unlock_bh(&l2tp_ip_lock);

	return ret;
}
","static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;
	struct net *net = sock_net(sk);
 	int ret;
 	int chk_addr_ret;
 
 	if (addr_len < sizeof(struct sockaddr_l2tpip))
 		return -EINVAL;
 	if (addr->l2tp_family != AF_INET)
		return -EINVAL;

	ret = -EADDRINUSE;
	read_lock_bh(&l2tp_ip_lock);
	if (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,
				  sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;

 	read_unlock_bh(&l2tp_ip_lock);
 
 	lock_sock(sk);
	if (!sock_flag(sk, SOCK_ZAPPED))
		goto out;

 	if (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))
 		goto out;
 
	chk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);
	ret = -EADDRNOTAVAIL;
	if (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&
	    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)
		goto out;

	if (addr->l2tp_addr.s_addr)
		inet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;
	if (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)
		inet->inet_saddr = 0;  /* Use device */
	sk_dst_reset(sk);

	l2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip_lock);
	sk_add_bind_node(sk, &l2tp_ip_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip_lock);
	ret = 0;
	sock_reset_flag(sk, SOCK_ZAPPED);

out:
	release_sock(sk);

	return ret;

out_in_use:
	read_unlock_bh(&l2tp_ip_lock);

	return ret;
}
","The vulnerability in the original code lies in the order of checks for the `SOCK_ZAPPED` flag. The check for `sock_flag(sk, SOCK_ZAPPED)` occurs after other conditions, allowing the function to proceed with potentially invalid socket states, which could lead to undefined behavior or resource leaks. In the fixed code, this check is moved up to immediately after acquiring the socket lock, ensuring that the function exits early if the socket is not in a valid state. This change prevents further processing of the socket when it is not properly initialized, enhancing the overall robustness of the function.","The vulnerability in the original code arises from the improper ordering of checks, allowing the function to proceed with operations on a socket that may not be in a valid state. Specifically, the function could continue executing even if the socket was marked as ""zapped,"" leading to potential resource leaks or undefined behavior. In the revised code, the check for the socket's state is prioritized, ensuring that the function exits early if the socket is not properly initialized. This adjustment enhances the function's reliability by preventing further processing of an invalid socket, thereby improving overall stability and security."
33,181662,181662,,Local,Not required,Complete,CVE-2016-10200,https://www.cvedetails.com/cve/CVE-2016-10200/,CWE-416,Medium,Complete,Complete,,2017-03-07,6.9,"Race condition in the L2TPv3 IP Encapsulation feature in the Linux kernel before 4.8.14 allows local users to gain privileges or cause a denial of service (use-after-free) by making multiple bind system calls without properly ascertaining whether a socket has the SOCK_ZAPPED status, related to net/l2tp/l2tp_ip.c and net/l2tp/l2tp_ip6.c.",2018-01-04,DoS +Priv ,3,https://github.com/torvalds/linux/commit/32c231164b762dddefa13af5a0101032c70b50ef,32c231164b762dddefa13af5a0101032c70b50ef,"l2tp: fix racy SOCK_ZAPPED flag check in l2tp_ip{,6}_bind()

Lock socket before checking the SOCK_ZAPPED flag in l2tp_ip6_bind().
Without lock, a concurrent call could modify the socket flags between
the sock_flag(sk, SOCK_ZAPPED) test and the lock_sock() call. This way,
a socket could be inserted twice in l2tp_ip6_bind_table. Releasing it
would then leave a stale pointer there, generating use-after-free
errors when walking through the list or modifying adjacent entries.

BUG: KASAN: use-after-free in l2tp_ip6_close+0x22e/0x290 at addr ffff8800081b0ed8
Write of size 8 by task syz-executor/10987
CPU: 0 PID: 10987 Comm: syz-executor Not tainted 4.8.0+ #39
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.8.2-0-g33fbe13 by qemu-project.org 04/01/2014
 ffff880031d97838 ffffffff829f835b ffff88001b5a1640 ffff8800081b0ec0
 ffff8800081b15a0 ffff8800081b6d20 ffff880031d97860 ffffffff8174d3cc
 ffff880031d978f0 ffff8800081b0e80 ffff88001b5a1640 ffff880031d978e0
Call Trace:
 [<ffffffff829f835b>] dump_stack+0xb3/0x118 lib/dump_stack.c:15
 [<ffffffff8174d3cc>] kasan_object_err+0x1c/0x70 mm/kasan/report.c:156
 [<     inline     >] print_address_description mm/kasan/report.c:194
 [<ffffffff8174d666>] kasan_report_error+0x1f6/0x4d0 mm/kasan/report.c:283
 [<     inline     >] kasan_report mm/kasan/report.c:303
 [<ffffffff8174db7e>] __asan_report_store8_noabort+0x3e/0x40 mm/kasan/report.c:329
 [<     inline     >] __write_once_size ./include/linux/compiler.h:249
 [<     inline     >] __hlist_del ./include/linux/list.h:622
 [<     inline     >] hlist_del_init ./include/linux/list.h:637
 [<ffffffff8579047e>] l2tp_ip6_close+0x22e/0x290 net/l2tp/l2tp_ip6.c:239
 [<ffffffff850b2dfd>] inet_release+0xed/0x1c0 net/ipv4/af_inet.c:415
 [<ffffffff851dc5a0>] inet6_release+0x50/0x70 net/ipv6/af_inet6.c:422
 [<ffffffff84c4581d>] sock_release+0x8d/0x1d0 net/socket.c:570
 [<ffffffff84c45976>] sock_close+0x16/0x20 net/socket.c:1017
 [<ffffffff817a108c>] __fput+0x28c/0x780 fs/file_table.c:208
 [<ffffffff817a1605>] ____fput+0x15/0x20 fs/file_table.c:244
 [<ffffffff813774f9>] task_work_run+0xf9/0x170
 [<ffffffff81324aae>] do_exit+0x85e/0x2a00
 [<ffffffff81326dc8>] do_group_exit+0x108/0x330
 [<ffffffff81348cf7>] get_signal+0x617/0x17a0 kernel/signal.c:2307
 [<ffffffff811b49af>] do_signal+0x7f/0x18f0
 [<ffffffff810039bf>] exit_to_usermode_loop+0xbf/0x150 arch/x86/entry/common.c:156
 [<     inline     >] prepare_exit_to_usermode arch/x86/entry/common.c:190
 [<ffffffff81006060>] syscall_return_slowpath+0x1a0/0x1e0 arch/x86/entry/common.c:259
 [<ffffffff85e4d726>] entry_SYSCALL_64_fastpath+0xc4/0xc6
Object at ffff8800081b0ec0, in cache L2TP/IPv6 size: 1448
Allocated:
PID = 10987
 [ 1116.897025] [<ffffffff811ddcb6>] save_stack_trace+0x16/0x20
 [ 1116.897025] [<ffffffff8174c736>] save_stack+0x46/0xd0
 [ 1116.897025] [<ffffffff8174c9ad>] kasan_kmalloc+0xad/0xe0
 [ 1116.897025] [<ffffffff8174cee2>] kasan_slab_alloc+0x12/0x20
 [ 1116.897025] [<     inline     >] slab_post_alloc_hook mm/slab.h:417
 [ 1116.897025] [<     inline     >] slab_alloc_node mm/slub.c:2708
 [ 1116.897025] [<     inline     >] slab_alloc mm/slub.c:2716
 [ 1116.897025] [<ffffffff817476a8>] kmem_cache_alloc+0xc8/0x2b0 mm/slub.c:2721
 [ 1116.897025] [<ffffffff84c4f6a9>] sk_prot_alloc+0x69/0x2b0 net/core/sock.c:1326
 [ 1116.897025] [<ffffffff84c58ac8>] sk_alloc+0x38/0xae0 net/core/sock.c:1388
 [ 1116.897025] [<ffffffff851ddf67>] inet6_create+0x2d7/0x1000 net/ipv6/af_inet6.c:182
 [ 1116.897025] [<ffffffff84c4af7b>] __sock_create+0x37b/0x640 net/socket.c:1153
 [ 1116.897025] [<     inline     >] sock_create net/socket.c:1193
 [ 1116.897025] [<     inline     >] SYSC_socket net/socket.c:1223
 [ 1116.897025] [<ffffffff84c4b46f>] SyS_socket+0xef/0x1b0 net/socket.c:1203
 [ 1116.897025] [<ffffffff85e4d685>] entry_SYSCALL_64_fastpath+0x23/0xc6
Freed:
PID = 10987
 [ 1116.897025] [<ffffffff811ddcb6>] save_stack_trace+0x16/0x20
 [ 1116.897025] [<ffffffff8174c736>] save_stack+0x46/0xd0
 [ 1116.897025] [<ffffffff8174cf61>] kasan_slab_free+0x71/0xb0
 [ 1116.897025] [<     inline     >] slab_free_hook mm/slub.c:1352
 [ 1116.897025] [<     inline     >] slab_free_freelist_hook mm/slub.c:1374
 [ 1116.897025] [<     inline     >] slab_free mm/slub.c:2951
 [ 1116.897025] [<ffffffff81748b28>] kmem_cache_free+0xc8/0x330 mm/slub.c:2973
 [ 1116.897025] [<     inline     >] sk_prot_free net/core/sock.c:1369
 [ 1116.897025] [<ffffffff84c541eb>] __sk_destruct+0x32b/0x4f0 net/core/sock.c:1444
 [ 1116.897025] [<ffffffff84c5aca4>] sk_destruct+0x44/0x80 net/core/sock.c:1452
 [ 1116.897025] [<ffffffff84c5ad33>] __sk_free+0x53/0x220 net/core/sock.c:1460
 [ 1116.897025] [<ffffffff84c5af23>] sk_free+0x23/0x30 net/core/sock.c:1471
 [ 1116.897025] [<ffffffff84c5cb6c>] sk_common_release+0x28c/0x3e0 ./include/net/sock.h:1589
 [ 1116.897025] [<ffffffff8579044e>] l2tp_ip6_close+0x1fe/0x290 net/l2tp/l2tp_ip6.c:243
 [ 1116.897025] [<ffffffff850b2dfd>] inet_release+0xed/0x1c0 net/ipv4/af_inet.c:415
 [ 1116.897025] [<ffffffff851dc5a0>] inet6_release+0x50/0x70 net/ipv6/af_inet6.c:422
 [ 1116.897025] [<ffffffff84c4581d>] sock_release+0x8d/0x1d0 net/socket.c:570
 [ 1116.897025] [<ffffffff84c45976>] sock_close+0x16/0x20 net/socket.c:1017
 [ 1116.897025] [<ffffffff817a108c>] __fput+0x28c/0x780 fs/file_table.c:208
 [ 1116.897025] [<ffffffff817a1605>] ____fput+0x15/0x20 fs/file_table.c:244
 [ 1116.897025] [<ffffffff813774f9>] task_work_run+0xf9/0x170
 [ 1116.897025] [<ffffffff81324aae>] do_exit+0x85e/0x2a00
 [ 1116.897025] [<ffffffff81326dc8>] do_group_exit+0x108/0x330
 [ 1116.897025] [<ffffffff81348cf7>] get_signal+0x617/0x17a0 kernel/signal.c:2307
 [ 1116.897025] [<ffffffff811b49af>] do_signal+0x7f/0x18f0
 [ 1116.897025] [<ffffffff810039bf>] exit_to_usermode_loop+0xbf/0x150 arch/x86/entry/common.c:156
 [ 1116.897025] [<     inline     >] prepare_exit_to_usermode arch/x86/entry/common.c:190
 [ 1116.897025] [<ffffffff81006060>] syscall_return_slowpath+0x1a0/0x1e0 arch/x86/entry/common.c:259
 [ 1116.897025] [<ffffffff85e4d726>] entry_SYSCALL_64_fastpath+0xc4/0xc6
Memory state around the buggy address:
 ffff8800081b0d80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
 ffff8800081b0e00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
>ffff8800081b0e80: fc fc fc fc fc fc fc fc fb fb fb fb fb fb fb fb
                                                    ^
 ffff8800081b0f00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff8800081b0f80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb

==================================================================

The same issue exists with l2tp_ip_bind() and l2tp_ip_bind_table.

Fixes: c51ce49735c1 (""l2tp: fix oops in L2TP IP sockets for connect() AF_UNSPEC case"")
Reported-by: Baozeng Ding <sploving1@gmail.com>
Reported-by: Andrey Konovalov <andreyknvl@google.com>
Tested-by: Baozeng Ding <sploving1@gmail.com>
Signed-off-by: Guillaume Nault <g.nault@alphalink.fr>
Signed-off-by: David S. Miller <davem@davemloft.net>",2,net/l2tp/l2tp_ip6.c,"{""sha"": ""982f6c44ea01f053a51afcbb4b271a2e77df2178"", ""filename"": ""net/l2tp/l2tp_ip.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/32c231164b762dddefa13af5a0101032c70b50ef/net/l2tp/l2tp_ip.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/32c231164b762dddefa13af5a0101032c70b50ef/net/l2tp/l2tp_ip.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/l2tp/l2tp_ip.c?ref=32c231164b762dddefa13af5a0101032c70b50ef"", ""patch"": ""@@ -251,8 +251,6 @@ static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n \tint ret;\n \tint chk_addr_ret;\n \n-\tif (!sock_flag(sk, SOCK_ZAPPED))\n-\t\treturn -EINVAL;\n \tif (addr_len < sizeof(struct sockaddr_l2tpip))\n \t\treturn -EINVAL;\n \tif (addr->l2tp_family != AF_INET)\n@@ -267,6 +265,9 @@ static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n \tread_unlock_bh(&l2tp_ip_lock);\n \n \tlock_sock(sk);\n+\tif (!sock_flag(sk, SOCK_ZAPPED))\n+\t\tgoto out;\n+\n \tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))\n \t\tgoto out;\n ""}<_**next**_>{""sha"": ""9978d01ba0bae4eaf34810665d581ddd06579e96"", ""filename"": ""net/l2tp/l2tp_ip6.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/32c231164b762dddefa13af5a0101032c70b50ef/net/l2tp/l2tp_ip6.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/32c231164b762dddefa13af5a0101032c70b50ef/net/l2tp/l2tp_ip6.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/l2tp/l2tp_ip6.c?ref=32c231164b762dddefa13af5a0101032c70b50ef"", ""patch"": ""@@ -269,8 +269,6 @@ static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n \tint addr_type;\n \tint err;\n \n-\tif (!sock_flag(sk, SOCK_ZAPPED))\n-\t\treturn -EINVAL;\n \tif (addr->l2tp_family != AF_INET6)\n \t\treturn -EINVAL;\n \tif (addr_len < sizeof(*addr))\n@@ -296,6 +294,9 @@ static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n \tlock_sock(sk);\n \n \terr = -EINVAL;\n+\tif (!sock_flag(sk, SOCK_ZAPPED))\n+\t\tgoto out_unlock;\n+\n \tif (sk->sk_state != TCP_CLOSE)\n \t\tgoto out_unlock;\n ""}","static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;
	struct net *net = sock_net(sk);
	__be32 v4addr = 0;
 	int addr_type;
 	int err;
 
 	if (addr->l2tp_family != AF_INET6)
 		return -EINVAL;
 	if (addr_len < sizeof(*addr))
		return -EINVAL;

	addr_type = ipv6_addr_type(&addr->l2tp_addr);

	/* l2tp_ip6 sockets are IPv6 only */
	if (addr_type == IPV6_ADDR_MAPPED)
		return -EADDRNOTAVAIL;

	/* L2TP is point-point, not multicast */
	if (addr_type & IPV6_ADDR_MULTICAST)
		return -EADDRNOTAVAIL;

	err = -EADDRINUSE;
	read_lock_bh(&l2tp_ip6_lock);
	if (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,
				   sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;
	read_unlock_bh(&l2tp_ip6_lock);

 	lock_sock(sk);
 
 	err = -EINVAL;
	if (!sock_flag(sk, SOCK_ZAPPED))
		goto out_unlock;

 	if (sk->sk_state != TCP_CLOSE)
 		goto out_unlock;
 
	/* Check if the address belongs to the host. */
	rcu_read_lock();
	if (addr_type != IPV6_ADDR_ANY) {
		struct net_device *dev = NULL;

		if (addr_type & IPV6_ADDR_LINKLOCAL) {
			if (addr_len >= sizeof(struct sockaddr_in6) &&
			    addr->l2tp_scope_id) {
				/* Override any existing binding, if another
				 * one is supplied by user.
				 */
				sk->sk_bound_dev_if = addr->l2tp_scope_id;
			}

			/* Binding to link-local address requires an
			   interface */
			if (!sk->sk_bound_dev_if)
				goto out_unlock_rcu;

			err = -ENODEV;
			dev = dev_get_by_index_rcu(sock_net(sk),
						   sk->sk_bound_dev_if);
			if (!dev)
				goto out_unlock_rcu;
		}

		/* ipv4 addr of the socket is invalid.  Only the
		 * unspecified and mapped address have a v4 equivalent.
		 */
		v4addr = LOOPBACK4_IPV6;
		err = -EADDRNOTAVAIL;
		if (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))
			goto out_unlock_rcu;
	}
	rcu_read_unlock();

	inet->inet_rcv_saddr = inet->inet_saddr = v4addr;
	sk->sk_v6_rcv_saddr = addr->l2tp_addr;
	np->saddr = addr->l2tp_addr;

	l2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip6_lock);
	sk_add_bind_node(sk, &l2tp_ip6_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip6_lock);

	sock_reset_flag(sk, SOCK_ZAPPED);
	release_sock(sk);
	return 0;

out_unlock_rcu:
	rcu_read_unlock();
out_unlock:
	release_sock(sk);
	return err;

out_in_use:
	read_unlock_bh(&l2tp_ip6_lock);
	return err;
}
","static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;
	struct net *net = sock_net(sk);
	__be32 v4addr = 0;
 	int addr_type;
 	int err;
 
	if (!sock_flag(sk, SOCK_ZAPPED))
		return -EINVAL;
 	if (addr->l2tp_family != AF_INET6)
 		return -EINVAL;
 	if (addr_len < sizeof(*addr))
		return -EINVAL;

	addr_type = ipv6_addr_type(&addr->l2tp_addr);

	/* l2tp_ip6 sockets are IPv6 only */
	if (addr_type == IPV6_ADDR_MAPPED)
		return -EADDRNOTAVAIL;

	/* L2TP is point-point, not multicast */
	if (addr_type & IPV6_ADDR_MULTICAST)
		return -EADDRNOTAVAIL;

	err = -EADDRINUSE;
	read_lock_bh(&l2tp_ip6_lock);
	if (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,
				   sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;
	read_unlock_bh(&l2tp_ip6_lock);

 	lock_sock(sk);
 
 	err = -EINVAL;
 	if (sk->sk_state != TCP_CLOSE)
 		goto out_unlock;
 
	/* Check if the address belongs to the host. */
	rcu_read_lock();
	if (addr_type != IPV6_ADDR_ANY) {
		struct net_device *dev = NULL;

		if (addr_type & IPV6_ADDR_LINKLOCAL) {
			if (addr_len >= sizeof(struct sockaddr_in6) &&
			    addr->l2tp_scope_id) {
				/* Override any existing binding, if another
				 * one is supplied by user.
				 */
				sk->sk_bound_dev_if = addr->l2tp_scope_id;
			}

			/* Binding to link-local address requires an
			   interface */
			if (!sk->sk_bound_dev_if)
				goto out_unlock_rcu;

			err = -ENODEV;
			dev = dev_get_by_index_rcu(sock_net(sk),
						   sk->sk_bound_dev_if);
			if (!dev)
				goto out_unlock_rcu;
		}

		/* ipv4 addr of the socket is invalid.  Only the
		 * unspecified and mapped address have a v4 equivalent.
		 */
		v4addr = LOOPBACK4_IPV6;
		err = -EADDRNOTAVAIL;
		if (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))
			goto out_unlock_rcu;
	}
	rcu_read_unlock();

	inet->inet_rcv_saddr = inet->inet_saddr = v4addr;
	sk->sk_v6_rcv_saddr = addr->l2tp_addr;
	np->saddr = addr->l2tp_addr;

	l2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip6_lock);
	sk_add_bind_node(sk, &l2tp_ip6_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip6_lock);

	sock_reset_flag(sk, SOCK_ZAPPED);
	release_sock(sk);
	return 0;

out_unlock_rcu:
	rcu_read_unlock();
out_unlock:
	release_sock(sk);
	return err;

out_in_use:
	read_unlock_bh(&l2tp_ip6_lock);
	return err;
}
",C,"	if (!sock_flag(sk, SOCK_ZAPPED))
		goto out_unlock;

","	if (!sock_flag(sk, SOCK_ZAPPED))
		return -EINVAL;
",,"@@ -269,8 +269,6 @@ static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 	int addr_type;
 	int err;
 
-	if (!sock_flag(sk, SOCK_ZAPPED))
-		return -EINVAL;
 	if (addr->l2tp_family != AF_INET6)
 		return -EINVAL;
 	if (addr_len < sizeof(*addr))
@@ -296,6 +294,9 @@ static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 	lock_sock(sk);
 
 	err = -EINVAL;
+	if (!sock_flag(sk, SOCK_ZAPPED))
+		goto out_unlock;
+
 	if (sk->sk_state != TCP_CLOSE)
 		goto out_unlock;
 ",linux,32c231164b762dddefa13af5a0101032c70b50ef,adda306744ec64c7bcd6c230a6bc060fb77bd7c3,1,"static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;
	struct net *net = sock_net(sk);
	__be32 v4addr = 0;
 	int addr_type;
 	int err;
 
//flaw_line_below:
	if (!sock_flag(sk, SOCK_ZAPPED))
//flaw_line_below:
		return -EINVAL;
 	if (addr->l2tp_family != AF_INET6)
 		return -EINVAL;
 	if (addr_len < sizeof(*addr))
		return -EINVAL;

	addr_type = ipv6_addr_type(&addr->l2tp_addr);

	/* l2tp_ip6 sockets are IPv6 only */
	if (addr_type == IPV6_ADDR_MAPPED)
		return -EADDRNOTAVAIL;

	/* L2TP is point-point, not multicast */
	if (addr_type & IPV6_ADDR_MULTICAST)
		return -EADDRNOTAVAIL;

	err = -EADDRINUSE;
	read_lock_bh(&l2tp_ip6_lock);
	if (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,
				   sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;
	read_unlock_bh(&l2tp_ip6_lock);

 	lock_sock(sk);
 
 	err = -EINVAL;
//fix_flaw_line_below:
//	if (!sock_flag(sk, SOCK_ZAPPED))
//fix_flaw_line_below:
//		goto out_unlock;
//fix_flaw_line_below:
//
 	if (sk->sk_state != TCP_CLOSE)
 		goto out_unlock;
 
	/* Check if the address belongs to the host. */
	rcu_read_lock();
	if (addr_type != IPV6_ADDR_ANY) {
		struct net_device *dev = NULL;

		if (addr_type & IPV6_ADDR_LINKLOCAL) {
			if (addr_len >= sizeof(struct sockaddr_in6) &&
			    addr->l2tp_scope_id) {
				/* Override any existing binding, if another
				 * one is supplied by user.
				 */
				sk->sk_bound_dev_if = addr->l2tp_scope_id;
			}

			/* Binding to link-local address requires an
			   interface */
			if (!sk->sk_bound_dev_if)
				goto out_unlock_rcu;

			err = -ENODEV;
			dev = dev_get_by_index_rcu(sock_net(sk),
						   sk->sk_bound_dev_if);
			if (!dev)
				goto out_unlock_rcu;
		}

		/* ipv4 addr of the socket is invalid.  Only the
		 * unspecified and mapped address have a v4 equivalent.
		 */
		v4addr = LOOPBACK4_IPV6;
		err = -EADDRNOTAVAIL;
		if (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))
			goto out_unlock_rcu;
	}
	rcu_read_unlock();

	inet->inet_rcv_saddr = inet->inet_saddr = v4addr;
	sk->sk_v6_rcv_saddr = addr->l2tp_addr;
	np->saddr = addr->l2tp_addr;

	l2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip6_lock);
	sk_add_bind_node(sk, &l2tp_ip6_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip6_lock);

	sock_reset_flag(sk, SOCK_ZAPPED);
	release_sock(sk);
	return 0;

out_unlock_rcu:
	rcu_read_unlock();
out_unlock:
	release_sock(sk);
	return err;

out_in_use:
	read_unlock_bh(&l2tp_ip6_lock);
	return err;
}
",181662,"static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;
	struct net *net = sock_net(sk);
	__be32 v4addr = 0;
 	int addr_type;
 	int err;
 
	if (!sock_flag(sk, SOCK_ZAPPED))
		return -EINVAL;
 	if (addr->l2tp_family != AF_INET6)
 		return -EINVAL;
 	if (addr_len < sizeof(*addr))
		return -EINVAL;

	addr_type = ipv6_addr_type(&addr->l2tp_addr);

	/* l2tp_ip6 sockets are IPv6 only */
	if (addr_type == IPV6_ADDR_MAPPED)
		return -EADDRNOTAVAIL;

	/* L2TP is point-point, not multicast */
	if (addr_type & IPV6_ADDR_MULTICAST)
		return -EADDRNOTAVAIL;

	err = -EADDRINUSE;
	read_lock_bh(&l2tp_ip6_lock);
	if (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,
				   sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;
	read_unlock_bh(&l2tp_ip6_lock);

 	lock_sock(sk);
 
 	err = -EINVAL;
 	if (sk->sk_state != TCP_CLOSE)
 		goto out_unlock;
 
	/* Check if the address belongs to the host. */
	rcu_read_lock();
	if (addr_type != IPV6_ADDR_ANY) {
		struct net_device *dev = NULL;

		if (addr_type & IPV6_ADDR_LINKLOCAL) {
			if (addr_len >= sizeof(struct sockaddr_in6) &&
			    addr->l2tp_scope_id) {
				/* Override any existing binding, if another
				 * one is supplied by user.
				 */
				sk->sk_bound_dev_if = addr->l2tp_scope_id;
			}

			/* Binding to link-local address requires an
			   interface */
			if (!sk->sk_bound_dev_if)
				goto out_unlock_rcu;

			err = -ENODEV;
			dev = dev_get_by_index_rcu(sock_net(sk),
						   sk->sk_bound_dev_if);
			if (!dev)
				goto out_unlock_rcu;
		}

		/* ipv4 addr of the socket is invalid.  Only the
		 * unspecified and mapped address have a v4 equivalent.
		 */
		v4addr = LOOPBACK4_IPV6;
		err = -EADDRNOTAVAIL;
		if (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))
			goto out_unlock_rcu;
	}
	rcu_read_unlock();

	inet->inet_rcv_saddr = inet->inet_saddr = v4addr;
	sk->sk_v6_rcv_saddr = addr->l2tp_addr;
	np->saddr = addr->l2tp_addr;

	l2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip6_lock);
	sk_add_bind_node(sk, &l2tp_ip6_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip6_lock);

	sock_reset_flag(sk, SOCK_ZAPPED);
	release_sock(sk);
	return 0;

out_unlock_rcu:
	rcu_read_unlock();
out_unlock:
	release_sock(sk);
	return err;

out_in_use:
	read_unlock_bh(&l2tp_ip6_lock);
	return err;
}
","static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;
	struct net *net = sock_net(sk);
	__be32 v4addr = 0;
 	int addr_type;
 	int err;
 
 	if (addr->l2tp_family != AF_INET6)
 		return -EINVAL;
 	if (addr_len < sizeof(*addr))
		return -EINVAL;

	addr_type = ipv6_addr_type(&addr->l2tp_addr);

	/* l2tp_ip6 sockets are IPv6 only */
	if (addr_type == IPV6_ADDR_MAPPED)
		return -EADDRNOTAVAIL;

	/* L2TP is point-point, not multicast */
	if (addr_type & IPV6_ADDR_MULTICAST)
		return -EADDRNOTAVAIL;

	err = -EADDRINUSE;
	read_lock_bh(&l2tp_ip6_lock);
	if (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,
				   sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;
	read_unlock_bh(&l2tp_ip6_lock);

 	lock_sock(sk);
 
 	err = -EINVAL;
	if (!sock_flag(sk, SOCK_ZAPPED))
		goto out_unlock;

 	if (sk->sk_state != TCP_CLOSE)
 		goto out_unlock;
 
	/* Check if the address belongs to the host. */
	rcu_read_lock();
	if (addr_type != IPV6_ADDR_ANY) {
		struct net_device *dev = NULL;

		if (addr_type & IPV6_ADDR_LINKLOCAL) {
			if (addr_len >= sizeof(struct sockaddr_in6) &&
			    addr->l2tp_scope_id) {
				/* Override any existing binding, if another
				 * one is supplied by user.
				 */
				sk->sk_bound_dev_if = addr->l2tp_scope_id;
			}

			/* Binding to link-local address requires an
			   interface */
			if (!sk->sk_bound_dev_if)
				goto out_unlock_rcu;

			err = -ENODEV;
			dev = dev_get_by_index_rcu(sock_net(sk),
						   sk->sk_bound_dev_if);
			if (!dev)
				goto out_unlock_rcu;
		}

		/* ipv4 addr of the socket is invalid.  Only the
		 * unspecified and mapped address have a v4 equivalent.
		 */
		v4addr = LOOPBACK4_IPV6;
		err = -EADDRNOTAVAIL;
		if (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))
			goto out_unlock_rcu;
	}
	rcu_read_unlock();

	inet->inet_rcv_saddr = inet->inet_saddr = v4addr;
	sk->sk_v6_rcv_saddr = addr->l2tp_addr;
	np->saddr = addr->l2tp_addr;

	l2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip6_lock);
	sk_add_bind_node(sk, &l2tp_ip6_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip6_lock);

	sock_reset_flag(sk, SOCK_ZAPPED);
	release_sock(sk);
	return 0;

out_unlock_rcu:
	rcu_read_unlock();
out_unlock:
	release_sock(sk);
	return err;

out_in_use:
	read_unlock_bh(&l2tp_ip6_lock);
	return err;
}
","The vulnerability in the original code lies in the order of checks for the socket's state and the SOCK_ZAPPED flag. Specifically, the check for `sock_flag(sk, SOCK_ZAPPED)` was placed after the socket state check (`sk->sk_state != TCP_CLOSE`), allowing a socket to be bound even if it was not properly initialized, potentially leading to undefined behavior. The fix was implemented by moving the `if (!sock_flag(sk, SOCK_ZAPPED))` check before the state check, ensuring that the socket is only processed if it has been correctly initialized, thus preventing misuse of uninitialized sockets and enhancing overall stability.","The vulnerability in the original code stemmed from the improper order of validation checks, allowing a socket to be bound even if it was not properly initialized. Specifically, the check for a specific flag was placed after verifying the socket's state, which could lead to undefined behavior if the socket was in an invalid state. The fix involved rearranging the checks so that the initialization flag was verified before the state check. This change ensures that only properly initialized sockets can proceed with the binding process, thereby enhancing the stability and security of the code."
34,181811,181811,,Remote,Not required,Partial,CVE-2016-10051,https://www.cvedetails.com/cve/CVE-2016-10051/,CWE-416,Medium,Partial,Partial,,2017-03-23,6.8,Use-after-free vulnerability in the ReadPWPImage function in coders/pwp.c in ImageMagick 6.9.5-5 allows remote attackers to cause a denial of service (application crash) or have other unspecified impact via a crafted file.,2018-10-30,DoS ,0,https://github.com/ImageMagick/ImageMagick/commit/ecc03a2518c2b7dd375fde3a040fdae0bdf6a521,ecc03a2518c2b7dd375fde3a040fdae0bdf6a521,Prevent memory use after free,2,coders/pwp.c,"{""sha"": ""8199991cc4e8896474339ed5752dfb863fb71f74"", ""filename"": ""ChangeLog"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/ecc03a2518c2b7dd375fde3a040fdae0bdf6a521/ChangeLog"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/ecc03a2518c2b7dd375fde3a040fdae0bdf6a521/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/ChangeLog?ref=ecc03a2518c2b7dd375fde3a040fdae0bdf6a521"", ""patch"": ""@@ -1,5 +1,7 @@\n 2016-08-03  6.9.5-5 Cristy  <quetzlzacatenango@image...>\n   * Prevent buffer overflow (bug report from Max Thrane).\n+  * Prevent memory use after free (reference\n+    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30245).\n \n 2016-07-30  6.9.5-4 Cristy  <quetzlzacatenango@image...>\n   * Release ImageMagick version 6.9.5-4, GIT revision 10973:a00fa93:20160729.""}<_**next**_>{""sha"": ""9432daad6308c533c4882bc405947eabedd14b1d"", ""filename"": ""coders/pwp.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/ecc03a2518c2b7dd375fde3a040fdae0bdf6a521/coders/pwp.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/ecc03a2518c2b7dd375fde3a040fdae0bdf6a521/coders/pwp.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/pwp.c?ref=ecc03a2518c2b7dd375fde3a040fdae0bdf6a521"", ""patch"": ""@@ -248,8 +248,6 @@ static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     (void) close(unique_file);\n   (void) RelinquishUniqueFileResource(read_info->filename);\n   read_info=DestroyImageInfo(read_info);\n-  (void) CloseBlob(pwp_image);\n-  pwp_image=DestroyImage(pwp_image);\n   if (EOFBlob(image) != MagickFalse)\n     {\n       char""}","static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  FILE
    *file;

  Image
    *image,
    *next_image,
    *pwp_image;

  ImageInfo
    *read_info;

  int
    c,
    unique_file;

  MagickBooleanType
    status;

  register Image
    *p;

  register ssize_t
    i;

  size_t
    filesize,
    length;

  ssize_t
    count;

  unsigned char
    magick[MaxTextExtent];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  pwp_image=AcquireImage(image_info);
  image=pwp_image;
  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    return((Image *) NULL);
  count=ReadBlob(pwp_image,5,magick);
  if ((count != 5) || (LocaleNCompare((char *) magick,""SFW95"",5) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  read_info=CloneImageInfo(image_info);
  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,
    (void *) NULL);
  SetImageInfoBlob(read_info,(void *) NULL,0);
  unique_file=AcquireUniqueFileResource(read_info->filename);
  for ( ; ; )
  {
    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))
    {
      for (i=0; i < 17; i++)
        magick[i]=magick[i+1];
      magick[17]=(unsigned char) c;
      if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) == 0)
        break;
    }
    if (c == EOF)
      break;
    if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) != 0)
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      }
    /*
      Dump SFW image to a temporary file.
    */
    file=(FILE *) NULL;
    if (unique_file != -1)
      file=fdopen(unique_file,""wb"");
    if ((unique_file == -1) || (file == (FILE *) NULL))
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowFileException(exception,FileOpenError,""UnableToWriteFile"",
          image->filename);
        image=DestroyImageList(image);
        return((Image *) NULL);
      }
    length=fwrite(""SFW94A"",1,6,file);
    (void) length;
    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];
    for (i=0; i < (ssize_t) filesize; i++)
    {
      c=ReadBlobByte(pwp_image);
      (void) fputc(c,file);
    }
    (void) fclose(file);
    next_image=ReadImage(read_info,exception);
    if (next_image == (Image *) NULL)
      break;
    (void) FormatLocaleString(next_image->filename,MaxTextExtent,
      ""slide_%02ld.sfw"",(long) next_image->scene);
    if (image == (Image *) NULL)
      image=next_image;
    else
      {
        /*
          Link image into image list.
        */
        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;
        next_image->previous=p;
        next_image->scene=p->scene+1;
        p->next=next_image;
      }
    if (image_info->number_scenes != 0)
      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),
      GetBlobSize(pwp_image));
    if (status == MagickFalse)
      break;
  }
  if (unique_file != -1)
     (void) close(unique_file);
   (void) RelinquishUniqueFileResource(read_info->filename);
   read_info=DestroyImageInfo(read_info);
   if (EOFBlob(image) != MagickFalse)
     {
       char
        *message;

      message=GetExceptionMessage(errno);
      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,
        ""UnexpectedEndOfFile"",""`%s': %s"",image->filename,message);
      message=DestroyString(message);
    }
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  FILE
    *file;

  Image
    *image,
    *next_image,
    *pwp_image;

  ImageInfo
    *read_info;

  int
    c,
    unique_file;

  MagickBooleanType
    status;

  register Image
    *p;

  register ssize_t
    i;

  size_t
    filesize,
    length;

  ssize_t
    count;

  unsigned char
    magick[MaxTextExtent];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  pwp_image=AcquireImage(image_info);
  image=pwp_image;
  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    return((Image *) NULL);
  count=ReadBlob(pwp_image,5,magick);
  if ((count != 5) || (LocaleNCompare((char *) magick,""SFW95"",5) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  read_info=CloneImageInfo(image_info);
  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,
    (void *) NULL);
  SetImageInfoBlob(read_info,(void *) NULL,0);
  unique_file=AcquireUniqueFileResource(read_info->filename);
  for ( ; ; )
  {
    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))
    {
      for (i=0; i < 17; i++)
        magick[i]=magick[i+1];
      magick[17]=(unsigned char) c;
      if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) == 0)
        break;
    }
    if (c == EOF)
      break;
    if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) != 0)
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      }
    /*
      Dump SFW image to a temporary file.
    */
    file=(FILE *) NULL;
    if (unique_file != -1)
      file=fdopen(unique_file,""wb"");
    if ((unique_file == -1) || (file == (FILE *) NULL))
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowFileException(exception,FileOpenError,""UnableToWriteFile"",
          image->filename);
        image=DestroyImageList(image);
        return((Image *) NULL);
      }
    length=fwrite(""SFW94A"",1,6,file);
    (void) length;
    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];
    for (i=0; i < (ssize_t) filesize; i++)
    {
      c=ReadBlobByte(pwp_image);
      (void) fputc(c,file);
    }
    (void) fclose(file);
    next_image=ReadImage(read_info,exception);
    if (next_image == (Image *) NULL)
      break;
    (void) FormatLocaleString(next_image->filename,MaxTextExtent,
      ""slide_%02ld.sfw"",(long) next_image->scene);
    if (image == (Image *) NULL)
      image=next_image;
    else
      {
        /*
          Link image into image list.
        */
        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;
        next_image->previous=p;
        next_image->scene=p->scene+1;
        p->next=next_image;
      }
    if (image_info->number_scenes != 0)
      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),
      GetBlobSize(pwp_image));
    if (status == MagickFalse)
      break;
  }
  if (unique_file != -1)
     (void) close(unique_file);
   (void) RelinquishUniqueFileResource(read_info->filename);
   read_info=DestroyImageInfo(read_info);
  (void) CloseBlob(pwp_image);
  pwp_image=DestroyImage(pwp_image);
   if (EOFBlob(image) != MagickFalse)
     {
       char
        *message;

      message=GetExceptionMessage(errno);
      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,
        ""UnexpectedEndOfFile"",""`%s': %s"",image->filename,message);
      message=DestroyString(message);
    }
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",C,,"  (void) CloseBlob(pwp_image);
  pwp_image=DestroyImage(pwp_image);
",,"@@ -248,8 +248,6 @@ static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)
     (void) close(unique_file);
   (void) RelinquishUniqueFileResource(read_info->filename);
   read_info=DestroyImageInfo(read_info);
-  (void) CloseBlob(pwp_image);
-  pwp_image=DestroyImage(pwp_image);
   if (EOFBlob(image) != MagickFalse)
     {
       char",ImageMagick,ecc03a2518c2b7dd375fde3a040fdae0bdf6a521,989f9f88ea6db09b99d25586e912c921c0da8d3f,1,"static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  FILE
    *file;

  Image
    *image,
    *next_image,
    *pwp_image;

  ImageInfo
    *read_info;

  int
    c,
    unique_file;

  MagickBooleanType
    status;

  register Image
    *p;

  register ssize_t
    i;

  size_t
    filesize,
    length;

  ssize_t
    count;

  unsigned char
    magick[MaxTextExtent];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  pwp_image=AcquireImage(image_info);
  image=pwp_image;
  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    return((Image *) NULL);
  count=ReadBlob(pwp_image,5,magick);
  if ((count != 5) || (LocaleNCompare((char *) magick,""SFW95"",5) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  read_info=CloneImageInfo(image_info);
  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,
    (void *) NULL);
  SetImageInfoBlob(read_info,(void *) NULL,0);
  unique_file=AcquireUniqueFileResource(read_info->filename);
  for ( ; ; )
  {
    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))
    {
      for (i=0; i < 17; i++)
        magick[i]=magick[i+1];
      magick[17]=(unsigned char) c;
      if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) == 0)
        break;
    }
    if (c == EOF)
      break;
    if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) != 0)
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      }
    /*
      Dump SFW image to a temporary file.
    */
    file=(FILE *) NULL;
    if (unique_file != -1)
      file=fdopen(unique_file,""wb"");
    if ((unique_file == -1) || (file == (FILE *) NULL))
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowFileException(exception,FileOpenError,""UnableToWriteFile"",
          image->filename);
        image=DestroyImageList(image);
        return((Image *) NULL);
      }
    length=fwrite(""SFW94A"",1,6,file);
    (void) length;
    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];
    for (i=0; i < (ssize_t) filesize; i++)
    {
      c=ReadBlobByte(pwp_image);
      (void) fputc(c,file);
    }
    (void) fclose(file);
    next_image=ReadImage(read_info,exception);
    if (next_image == (Image *) NULL)
      break;
    (void) FormatLocaleString(next_image->filename,MaxTextExtent,
      ""slide_%02ld.sfw"",(long) next_image->scene);
    if (image == (Image *) NULL)
      image=next_image;
    else
      {
        /*
          Link image into image list.
        */
        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;
        next_image->previous=p;
        next_image->scene=p->scene+1;
        p->next=next_image;
      }
    if (image_info->number_scenes != 0)
      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),
      GetBlobSize(pwp_image));
    if (status == MagickFalse)
      break;
  }
  if (unique_file != -1)
     (void) close(unique_file);
   (void) RelinquishUniqueFileResource(read_info->filename);
   read_info=DestroyImageInfo(read_info);
//flaw_line_below:
  (void) CloseBlob(pwp_image);
//flaw_line_below:
  pwp_image=DestroyImage(pwp_image);
   if (EOFBlob(image) != MagickFalse)
     {
       char
        *message;

      message=GetExceptionMessage(errno);
      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,
        ""UnexpectedEndOfFile"",""`%s': %s"",image->filename,message);
      message=DestroyString(message);
    }
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",181811,"static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  FILE
    *file;

  Image
    *image,
    *next_image,
    *pwp_image;

  ImageInfo
    *read_info;

  int
    c,
    unique_file;

  MagickBooleanType
    status;

  register Image
    *p;

  register ssize_t
    i;

  size_t
    filesize,
    length;

  ssize_t
    count;

  unsigned char
    magick[MaxTextExtent];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  pwp_image=AcquireImage(image_info);
  image=pwp_image;
  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    return((Image *) NULL);
  count=ReadBlob(pwp_image,5,magick);
  if ((count != 5) || (LocaleNCompare((char *) magick,""SFW95"",5) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  read_info=CloneImageInfo(image_info);
  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,
    (void *) NULL);
  SetImageInfoBlob(read_info,(void *) NULL,0);
  unique_file=AcquireUniqueFileResource(read_info->filename);
  for ( ; ; )
  {
    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))
    {
      for (i=0; i < 17; i++)
        magick[i]=magick[i+1];
      magick[17]=(unsigned char) c;
      if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) == 0)
        break;
    }
    if (c == EOF)
      break;
    if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) != 0)
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      }
    /*
      Dump SFW image to a temporary file.
    */
    file=(FILE *) NULL;
    if (unique_file != -1)
      file=fdopen(unique_file,""wb"");
    if ((unique_file == -1) || (file == (FILE *) NULL))
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowFileException(exception,FileOpenError,""UnableToWriteFile"",
          image->filename);
        image=DestroyImageList(image);
        return((Image *) NULL);
      }
    length=fwrite(""SFW94A"",1,6,file);
    (void) length;
    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];
    for (i=0; i < (ssize_t) filesize; i++)
    {
      c=ReadBlobByte(pwp_image);
      (void) fputc(c,file);
    }
    (void) fclose(file);
    next_image=ReadImage(read_info,exception);
    if (next_image == (Image *) NULL)
      break;
    (void) FormatLocaleString(next_image->filename,MaxTextExtent,
      ""slide_%02ld.sfw"",(long) next_image->scene);
    if (image == (Image *) NULL)
      image=next_image;
    else
      {
        /*
          Link image into image list.
        */
        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;
        next_image->previous=p;
        next_image->scene=p->scene+1;
        p->next=next_image;
      }
    if (image_info->number_scenes != 0)
      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),
      GetBlobSize(pwp_image));
    if (status == MagickFalse)
      break;
  }
  if (unique_file != -1)
     (void) close(unique_file);
   (void) RelinquishUniqueFileResource(read_info->filename);
   read_info=DestroyImageInfo(read_info);
  (void) CloseBlob(pwp_image);
  pwp_image=DestroyImage(pwp_image);
   if (EOFBlob(image) != MagickFalse)
     {
       char
        *message;

      message=GetExceptionMessage(errno);
      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,
        ""UnexpectedEndOfFile"",""`%s': %s"",image->filename,message);
      message=DestroyString(message);
    }
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  FILE
    *file;

  Image
    *image,
    *next_image,
    *pwp_image;

  ImageInfo
    *read_info;

  int
    c,
    unique_file;

  MagickBooleanType
    status;

  register Image
    *p;

  register ssize_t
    i;

  size_t
    filesize,
    length;

  ssize_t
    count;

  unsigned char
    magick[MaxTextExtent];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  pwp_image=AcquireImage(image_info);
  image=pwp_image;
  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    return((Image *) NULL);
  count=ReadBlob(pwp_image,5,magick);
  if ((count != 5) || (LocaleNCompare((char *) magick,""SFW95"",5) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  read_info=CloneImageInfo(image_info);
  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,
    (void *) NULL);
  SetImageInfoBlob(read_info,(void *) NULL,0);
  unique_file=AcquireUniqueFileResource(read_info->filename);
  for ( ; ; )
  {
    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))
    {
      for (i=0; i < 17; i++)
        magick[i]=magick[i+1];
      magick[17]=(unsigned char) c;
      if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) == 0)
        break;
    }
    if (c == EOF)
      break;
    if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) != 0)
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      }
    /*
      Dump SFW image to a temporary file.
    */
    file=(FILE *) NULL;
    if (unique_file != -1)
      file=fdopen(unique_file,""wb"");
    if ((unique_file == -1) || (file == (FILE *) NULL))
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowFileException(exception,FileOpenError,""UnableToWriteFile"",
          image->filename);
        image=DestroyImageList(image);
        return((Image *) NULL);
      }
    length=fwrite(""SFW94A"",1,6,file);
    (void) length;
    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];
    for (i=0; i < (ssize_t) filesize; i++)
    {
      c=ReadBlobByte(pwp_image);
      (void) fputc(c,file);
    }
    (void) fclose(file);
    next_image=ReadImage(read_info,exception);
    if (next_image == (Image *) NULL)
      break;
    (void) FormatLocaleString(next_image->filename,MaxTextExtent,
      ""slide_%02ld.sfw"",(long) next_image->scene);
    if (image == (Image *) NULL)
      image=next_image;
    else
      {
        /*
          Link image into image list.
        */
        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;
        next_image->previous=p;
        next_image->scene=p->scene+1;
        p->next=next_image;
      }
    if (image_info->number_scenes != 0)
      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),
      GetBlobSize(pwp_image));
    if (status == MagickFalse)
      break;
  }
  if (unique_file != -1)
     (void) close(unique_file);
   (void) RelinquishUniqueFileResource(read_info->filename);
   read_info=DestroyImageInfo(read_info);
   if (EOFBlob(image) != MagickFalse)
     {
       char
        *message;

      message=GetExceptionMessage(errno);
      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,
        ""UnexpectedEndOfFile"",""`%s': %s"",image->filename,message);
      message=DestroyString(message);
    }
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","The vulnerability in the original code lies in the handling of the `unique_file` resource, which could lead to a resource leak if the file descriptor is not properly closed in certain error conditions. Specifically, if `fdopen` fails, the code does not ensure that `unique_file` is closed before returning, potentially causing a file descriptor leak. In the fixed code, the logic remains largely the same, but it ensures that the file descriptor is closed properly in all error paths, particularly by checking `unique_file` before closing it, thus preventing resource leaks and ensuring better resource management.","The vulnerability in the original code stems from inadequate error handling related to resource management, specifically concerning file descriptors. If an error occurs during file operations, such as failing to open a file, the code does not consistently ensure that resources are released, leading to potential leaks. This could result in exhausting system resources over time. The fixed code addresses this issue by implementing more robust checks and ensuring that resources are properly closed in all error scenarios, thereby enhancing resource management and preventing leaks, which improves the overall stability and reliability of the application."
35,181838,181838,,Remote,Not required,Partial,CVE-2016-9936,https://www.cvedetails.com/cve/CVE-2016-9936/,CWE-416,Low,Partial,Partial,,2017-01-04,7.5,The unserialize implementation in ext/standard/var.c in PHP 7.x before 7.0.14 allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted serialized data.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-6834.,2018-05-03,DoS ,5,https://github.com/php/php-src/commit/b2af4e8868726a040234de113436c6e4f6372d17,b2af4e8868726a040234de113436c6e4f6372d17,Complete the fix of bug #70172 for PHP 7,5,ext/standard/var.c,"{""sha"": ""2b12a78edb5be332c0fbef46a76402a58125dbcf"", ""filename"": ""ext/standard/tests/serialize/bug70172_2.phpt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/php/php-src/blob/b2af4e8868726a040234de113436c6e4f6372d17/ext/standard/tests/serialize/bug70172_2.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/b2af4e8868726a040234de113436c6e4f6372d17/ext/standard/tests/serialize/bug70172_2.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/standard/tests/serialize/bug70172_2.phpt?ref=b2af4e8868726a040234de113436c6e4f6372d17"", ""patch"": ""@@ -1,7 +1,5 @@\n --TEST--\n Bug #70172 - Use After Free Vulnerability in unserialize()\n---XFAIL--\n-Unfinished merge, needs fix.\n --FILE--\n <?php\n class obj implements Serializable {\n@@ -61,10 +59,10 @@ array(2) {\n     [0]=>\n     array(1) {\n       [0]=>\n-      &object(obj2)#%d (1) {\n+      object(obj2)#%d (1) {\n         [\""ryat\""]=>\n         int(1)\n       }\n     }\n   }\n-}\n\\ No newline at end of file\n+}""}<_**next**_>{""sha"": ""88719ccb64dcdb8f19723775a63f079debe6261f"", ""filename"": ""ext/standard/var.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/php/php-src/blob/b2af4e8868726a040234de113436c6e4f6372d17/ext/standard/var.c"", ""raw_url"": ""https://github.com/php/php-src/raw/b2af4e8868726a040234de113436c6e4f6372d17/ext/standard/var.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/standard/var.c?ref=b2af4e8868726a040234de113436c6e4f6372d17"", ""patch"": ""@@ -1036,6 +1036,7 @@ PHP_FUNCTION(unserialize)\n \tconst unsigned char *p;\n \tphp_unserialize_data_t var_hash;\n \tzval *options = NULL, *classes = NULL;\n+\tzval *retval;\n \tHashTable *class_hash = NULL;\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS(), \""s|a\"", &buf, &buf_len, &options) == FAILURE) {\n@@ -1067,22 +1068,21 @@ PHP_FUNCTION(unserialize)\n \t\t}\n \t}\n \n-\tif (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {\n+\tretval = var_tmp_var(&var_hash);\n+\tif (!php_var_unserialize_ex(retval, &p, p + buf_len, &var_hash, class_hash)) {\n \t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n \t\tif (class_hash) {\n \t\t\tzend_hash_destroy(class_hash);\n \t\t\tFREE_HASHTABLE(class_hash);\n \t\t}\n-\t\tzval_ptr_dtor(return_value);\n \t\tif (!EG(exception)) {\n \t\t\tphp_error_docref(NULL, E_NOTICE, \""Error at offset \"" ZEND_LONG_FMT \"" of %zd bytes\"",\n \t\t\t\t(zend_long)((char*)p - buf), buf_len);\n \t\t}\n \t\tRETURN_FALSE;\n \t}\n-\t/* We should keep an reference to return_value to prevent it from being dtor\n-\t   in case nesting calls to unserialize */\n-\tvar_push_dtor(&var_hash, return_value);\n+\n+\tZVAL_COPY(return_value, retval);\n \n \tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n \tif (class_hash) {""}","PHP_FUNCTION(unserialize)
{
	char *buf = NULL;
	size_t buf_len;
 	const unsigned char *p;
 	php_unserialize_data_t var_hash;
 	zval *options = NULL, *classes = NULL;
	zval *retval;
 	HashTable *class_hash = NULL;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s|a"", &buf, &buf_len, &options) == FAILURE) {
		RETURN_FALSE;
	}

	if (buf_len == 0) {
		RETURN_FALSE;
	}

	p = (const unsigned char*) buf;
	PHP_VAR_UNSERIALIZE_INIT(var_hash);
	if(options != NULL) {
		classes = zend_hash_str_find(Z_ARRVAL_P(options), ""allowed_classes"", sizeof(""allowed_classes"")-1);
		if(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {
			ALLOC_HASHTABLE(class_hash);
			zend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);
		}
		if(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {
			zval *entry;
			zend_string *lcname;

			ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {
				convert_to_string_ex(entry);
				lcname = zend_string_tolower(Z_STR_P(entry));
				zend_hash_add_empty_element(class_hash, lcname);
		        zend_string_release(lcname);
			} ZEND_HASH_FOREACH_END();
 		}
 	}
 
	retval = var_tmp_var(&var_hash);
	if (!php_var_unserialize_ex(retval, &p, p + buf_len, &var_hash, class_hash)) {
 		PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 		if (class_hash) {
 			zend_hash_destroy(class_hash);
 			FREE_HASHTABLE(class_hash);
 		}
 		if (!EG(exception)) {
 			php_error_docref(NULL, E_NOTICE, ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"",
 				(zend_long)((char*)p - buf), buf_len);
 		}
 		RETURN_FALSE;
 	}

	ZVAL_COPY(return_value, retval);
 
 	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 	if (class_hash) {
		zend_hash_destroy(class_hash);
		FREE_HASHTABLE(class_hash);
	}
}
","PHP_FUNCTION(unserialize)
{
	char *buf = NULL;
	size_t buf_len;
 	const unsigned char *p;
 	php_unserialize_data_t var_hash;
 	zval *options = NULL, *classes = NULL;
 	HashTable *class_hash = NULL;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s|a"", &buf, &buf_len, &options) == FAILURE) {
		RETURN_FALSE;
	}

	if (buf_len == 0) {
		RETURN_FALSE;
	}

	p = (const unsigned char*) buf;
	PHP_VAR_UNSERIALIZE_INIT(var_hash);
	if(options != NULL) {
		classes = zend_hash_str_find(Z_ARRVAL_P(options), ""allowed_classes"", sizeof(""allowed_classes"")-1);
		if(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {
			ALLOC_HASHTABLE(class_hash);
			zend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);
		}
		if(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {
			zval *entry;
			zend_string *lcname;

			ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {
				convert_to_string_ex(entry);
				lcname = zend_string_tolower(Z_STR_P(entry));
				zend_hash_add_empty_element(class_hash, lcname);
		        zend_string_release(lcname);
			} ZEND_HASH_FOREACH_END();
 		}
 	}
 
	if (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {
 		PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 		if (class_hash) {
 			zend_hash_destroy(class_hash);
 			FREE_HASHTABLE(class_hash);
 		}
		zval_ptr_dtor(return_value);
 		if (!EG(exception)) {
 			php_error_docref(NULL, E_NOTICE, ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"",
 				(zend_long)((char*)p - buf), buf_len);
 		}
 		RETURN_FALSE;
 	}
	/* We should keep an reference to return_value to prevent it from being dtor
	   in case nesting calls to unserialize */
	var_push_dtor(&var_hash, return_value);
 
 	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 	if (class_hash) {
		zend_hash_destroy(class_hash);
		FREE_HASHTABLE(class_hash);
	}
}
",C,"	zval *retval;
	retval = var_tmp_var(&var_hash);
	if (!php_var_unserialize_ex(retval, &p, p + buf_len, &var_hash, class_hash)) {

	ZVAL_COPY(return_value, retval);
","	if (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {
		zval_ptr_dtor(return_value);
	/* We should keep an reference to return_value to prevent it from being dtor
	   in case nesting calls to unserialize */
	var_push_dtor(&var_hash, return_value);
",,"@@ -1036,6 +1036,7 @@ PHP_FUNCTION(unserialize)
 	const unsigned char *p;
 	php_unserialize_data_t var_hash;
 	zval *options = NULL, *classes = NULL;
+	zval *retval;
 	HashTable *class_hash = NULL;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s|a"", &buf, &buf_len, &options) == FAILURE) {
@@ -1067,22 +1068,21 @@ PHP_FUNCTION(unserialize)
 		}
 	}
 
-	if (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {
+	retval = var_tmp_var(&var_hash);
+	if (!php_var_unserialize_ex(retval, &p, p + buf_len, &var_hash, class_hash)) {
 		PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 		if (class_hash) {
 			zend_hash_destroy(class_hash);
 			FREE_HASHTABLE(class_hash);
 		}
-		zval_ptr_dtor(return_value);
 		if (!EG(exception)) {
 			php_error_docref(NULL, E_NOTICE, ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"",
 				(zend_long)((char*)p - buf), buf_len);
 		}
 		RETURN_FALSE;
 	}
-	/* We should keep an reference to return_value to prevent it from being dtor
-	   in case nesting calls to unserialize */
-	var_push_dtor(&var_hash, return_value);
+
+	ZVAL_COPY(return_value, retval);
 
 	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 	if (class_hash) {",php-src,b2af4e8868726a040234de113436c6e4f6372d17,3d73f718b2715c65be088ef6cb038d30e5d4bb86,1,"PHP_FUNCTION(unserialize)
{
	char *buf = NULL;
	size_t buf_len;
 	const unsigned char *p;
 	php_unserialize_data_t var_hash;
 	zval *options = NULL, *classes = NULL;
//fix_flaw_line_below:
//	zval *retval;
 	HashTable *class_hash = NULL;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s|a"", &buf, &buf_len, &options) == FAILURE) {
		RETURN_FALSE;
	}

	if (buf_len == 0) {
		RETURN_FALSE;
	}

	p = (const unsigned char*) buf;
	PHP_VAR_UNSERIALIZE_INIT(var_hash);
	if(options != NULL) {
		classes = zend_hash_str_find(Z_ARRVAL_P(options), ""allowed_classes"", sizeof(""allowed_classes"")-1);
		if(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {
			ALLOC_HASHTABLE(class_hash);
			zend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);
		}
		if(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {
			zval *entry;
			zend_string *lcname;

			ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {
				convert_to_string_ex(entry);
				lcname = zend_string_tolower(Z_STR_P(entry));
				zend_hash_add_empty_element(class_hash, lcname);
		        zend_string_release(lcname);
			} ZEND_HASH_FOREACH_END();
 		}
 	}
 
//flaw_line_below:
	if (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {
//fix_flaw_line_below:
//	retval = var_tmp_var(&var_hash);
//fix_flaw_line_below:
//	if (!php_var_unserialize_ex(retval, &p, p + buf_len, &var_hash, class_hash)) {
 		PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 		if (class_hash) {
 			zend_hash_destroy(class_hash);
 			FREE_HASHTABLE(class_hash);
 		}
//flaw_line_below:
		zval_ptr_dtor(return_value);
 		if (!EG(exception)) {
 			php_error_docref(NULL, E_NOTICE, ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"",
 				(zend_long)((char*)p - buf), buf_len);
 		}
 		RETURN_FALSE;
 	}
//flaw_line_below:
	/* We should keep an reference to return_value to prevent it from being dtor
//flaw_line_below:
	   in case nesting calls to unserialize */
//flaw_line_below:
	var_push_dtor(&var_hash, return_value);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	ZVAL_COPY(return_value, retval);
 
 	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 	if (class_hash) {
		zend_hash_destroy(class_hash);
		FREE_HASHTABLE(class_hash);
	}
}
",181838,"PHP_FUNCTION(unserialize)
{
	char *buf = NULL;
	size_t buf_len;
 	const unsigned char *p;
 	php_unserialize_data_t var_hash;
 	zval *options = NULL, *classes = NULL;
 	HashTable *class_hash = NULL;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s|a"", &buf, &buf_len, &options) == FAILURE) {
		RETURN_FALSE;
	}

	if (buf_len == 0) {
		RETURN_FALSE;
	}

	p = (const unsigned char*) buf;
	PHP_VAR_UNSERIALIZE_INIT(var_hash);
	if(options != NULL) {
		classes = zend_hash_str_find(Z_ARRVAL_P(options), ""allowed_classes"", sizeof(""allowed_classes"")-1);
		if(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {
			ALLOC_HASHTABLE(class_hash);
			zend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);
		}
		if(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {
			zval *entry;
			zend_string *lcname;

			ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {
				convert_to_string_ex(entry);
				lcname = zend_string_tolower(Z_STR_P(entry));
				zend_hash_add_empty_element(class_hash, lcname);
		        zend_string_release(lcname);
			} ZEND_HASH_FOREACH_END();
 		}
 	}
 
	if (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {
 		PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 		if (class_hash) {
 			zend_hash_destroy(class_hash);
 			FREE_HASHTABLE(class_hash);
 		}
		zval_ptr_dtor(return_value);
 		if (!EG(exception)) {
 			php_error_docref(NULL, E_NOTICE, ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"",
 				(zend_long)((char*)p - buf), buf_len);
 		}
 		RETURN_FALSE;
 	}
	/* We should keep an reference to return_value to prevent it from being dtor
	   in case nesting calls to unserialize */
	var_push_dtor(&var_hash, return_value);
 
 	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 	if (class_hash) {
		zend_hash_destroy(class_hash);
		FREE_HASHTABLE(class_hash);
	}
}
","PHP_FUNCTION(unserialize)
{
	char *buf = NULL;
	size_t buf_len;
 	const unsigned char *p;
 	php_unserialize_data_t var_hash;
 	zval *options = NULL, *classes = NULL;
	zval *retval;
 	HashTable *class_hash = NULL;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s|a"", &buf, &buf_len, &options) == FAILURE) {
		RETURN_FALSE;
	}

	if (buf_len == 0) {
		RETURN_FALSE;
	}

	p = (const unsigned char*) buf;
	PHP_VAR_UNSERIALIZE_INIT(var_hash);
	if(options != NULL) {
		classes = zend_hash_str_find(Z_ARRVAL_P(options), ""allowed_classes"", sizeof(""allowed_classes"")-1);
		if(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {
			ALLOC_HASHTABLE(class_hash);
			zend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);
		}
		if(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {
			zval *entry;
			zend_string *lcname;

			ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {
				convert_to_string_ex(entry);
				lcname = zend_string_tolower(Z_STR_P(entry));
				zend_hash_add_empty_element(class_hash, lcname);
		        zend_string_release(lcname);
			} ZEND_HASH_FOREACH_END();
 		}
 	}
 
	retval = var_tmp_var(&var_hash);
	if (!php_var_unserialize_ex(retval, &p, p + buf_len, &var_hash, class_hash)) {
 		PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 		if (class_hash) {
 			zend_hash_destroy(class_hash);
 			FREE_HASHTABLE(class_hash);
 		}
 		if (!EG(exception)) {
 			php_error_docref(NULL, E_NOTICE, ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"",
 				(zend_long)((char*)p - buf), buf_len);
 		}
 		RETURN_FALSE;
 	}

	ZVAL_COPY(return_value, retval);
 
 	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 	if (class_hash) {
		zend_hash_destroy(class_hash);
		FREE_HASHTABLE(class_hash);
	}
}
","The vulnerability in the original `unserialize` function stemmed from the potential for a memory corruption or use-after-free error when handling the `return_value`. If `php_var_unserialize_ex` failed, the function would attempt to destruct `return_value` without ensuring it was properly initialized, leading to undefined behavior. In the fixed code, this issue was addressed by introducing a temporary variable `retval` using `var_tmp_var(&var_hash)`, which safely holds the unserialized value. The final result is then copied to `return_value` with `ZVAL_COPY`, ensuring that `return_value` is correctly managed and preventing potential memory issues.","The vulnerability in the original code arose from improper handling of memory and potential use-after-free errors when processing the return value. If the unserialization process failed, the code would destruct the return value without ensuring it was properly initialized, leading to undefined behavior and possible memory corruption. The fixed code addresses this issue by introducing a temporary variable to safely hold the unserialized data. This change ensures that the return value is correctly managed and copied only after successful unserialization, thereby preventing memory-related vulnerabilities and enhancing overall stability."
36,181948,181948,,Remote,Not required,Partial,CVE-2016-7906,https://www.cvedetails.com/cve/CVE-2016-7906/,CWE-416,Medium,,,,2017-01-18,4.3,magick/attribute.c in ImageMagick 7.0.3-2 allows remote attackers to cause a denial of service (use-after-free) via a crafted file.,2017-11-03,DoS ,1,https://github.com/ImageMagick/ImageMagick/commit/d63a3c5729df59f183e9e110d5d8385d17caaad0,d63a3c5729df59f183e9e110d5d8385d17caaad0,https://github.com/ImageMagick/ImageMagick/issues/281,1,magick/attribute.c,"{""sha"": ""53d270692f7ed6633cd34414d3aad52452ae2ab9"", ""filename"": ""magick/attribute.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/d63a3c5729df59f183e9e110d5d8385d17caaad0/magick/attribute.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/d63a3c5729df59f183e9e110d5d8385d17caaad0/magick/attribute.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/magick/attribute.c?ref=d63a3c5729df59f183e9e110d5d8385d17caaad0"", ""patch"": ""@@ -1296,7 +1296,7 @@ MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type)\n           status=QuantizeImage(quantize_info,image);\n           quantize_info=DestroyQuantizeInfo(quantize_info);\n         }\n-      image->colors=2;\n+      status=AcquireImageColormap(image,2);\n       image->matte=MagickFalse;\n       break;\n     }""}","MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type)
{
  const char
    *artifact;

  ImageInfo
    *image_info;

  MagickBooleanType
    status;

  QuantizeInfo
    *quantize_info;

  assert(image != (Image *) NULL);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->signature == MagickSignature);
  status=MagickTrue;
  image_info=AcquireImageInfo();
  image_info->dither=image->dither;
  artifact=GetImageArtifact(image,""dither"");
  if (artifact != (const char *) NULL)
    (void) SetImageOption(image_info,""dither"",artifact);
  switch (type)
  {
    case BilevelType:
    {
      if (SetImageMonochrome(image,&image->exception) == MagickFalse)
        {
          status=TransformImageColorspace(image,GRAYColorspace);
          (void) NormalizeImage(image);
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=2;
          quantize_info->colorspace=GRAYColorspace;
           status=QuantizeImage(quantize_info,image);
           quantize_info=DestroyQuantizeInfo(quantize_info);
         }
      status=AcquireImageColormap(image,2);
       image->matte=MagickFalse;
       break;
     }
    case GrayscaleType:
    {
      if (SetImageGray(image,&image->exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace);
      image->matte=MagickFalse;
      break;
    }
    case GrayscaleMatteType:
    {
      if (SetImageGray(image,&image->exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case PaletteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if ((image->storage_class == DirectClass) || (image->colors > 256))
        {
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=256;
          status=QuantizeImage(quantize_info,image);
          quantize_info=DestroyQuantizeInfo(quantize_info);
        }
      image->matte=MagickFalse;
      break;
    }
    case PaletteBilevelMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      (void) BilevelImageChannel(image,AlphaChannel,(double) QuantumRange/2.0);
      quantize_info=AcquireQuantizeInfo(image_info);
      status=QuantizeImage(quantize_info,image);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case PaletteMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      quantize_info=AcquireQuantizeInfo(image_info);
      quantize_info->colorspace=TransparentColorspace;
      status=QuantizeImage(quantize_info,image);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case TrueColorType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      image->matte=MagickFalse;
      break;
    }
    case TrueColorMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case ColorSeparationType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            (void) TransformImageColorspace(image,sRGBColorspace);
          status=TransformImageColorspace(image,CMYKColorspace);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      image->matte=MagickFalse;
      break;
    }
    case ColorSeparationMatteType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            (void) TransformImageColorspace(image,sRGBColorspace);
          status=TransformImageColorspace(image,CMYKColorspace);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case OptimizeType:
    case UndefinedType:
      break;
  }
  image_info=DestroyImageInfo(image_info);
  if (status == MagickFalse)
    return(MagickFalse);
  image->type=type;
  return(MagickTrue);
}
","MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type)
{
  const char
    *artifact;

  ImageInfo
    *image_info;

  MagickBooleanType
    status;

  QuantizeInfo
    *quantize_info;

  assert(image != (Image *) NULL);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->signature == MagickSignature);
  status=MagickTrue;
  image_info=AcquireImageInfo();
  image_info->dither=image->dither;
  artifact=GetImageArtifact(image,""dither"");
  if (artifact != (const char *) NULL)
    (void) SetImageOption(image_info,""dither"",artifact);
  switch (type)
  {
    case BilevelType:
    {
      if (SetImageMonochrome(image,&image->exception) == MagickFalse)
        {
          status=TransformImageColorspace(image,GRAYColorspace);
          (void) NormalizeImage(image);
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=2;
          quantize_info->colorspace=GRAYColorspace;
           status=QuantizeImage(quantize_info,image);
           quantize_info=DestroyQuantizeInfo(quantize_info);
         }
      image->colors=2;
       image->matte=MagickFalse;
       break;
     }
    case GrayscaleType:
    {
      if (SetImageGray(image,&image->exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace);
      image->matte=MagickFalse;
      break;
    }
    case GrayscaleMatteType:
    {
      if (SetImageGray(image,&image->exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case PaletteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if ((image->storage_class == DirectClass) || (image->colors > 256))
        {
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=256;
          status=QuantizeImage(quantize_info,image);
          quantize_info=DestroyQuantizeInfo(quantize_info);
        }
      image->matte=MagickFalse;
      break;
    }
    case PaletteBilevelMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      (void) BilevelImageChannel(image,AlphaChannel,(double) QuantumRange/2.0);
      quantize_info=AcquireQuantizeInfo(image_info);
      status=QuantizeImage(quantize_info,image);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case PaletteMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      quantize_info=AcquireQuantizeInfo(image_info);
      quantize_info->colorspace=TransparentColorspace;
      status=QuantizeImage(quantize_info,image);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case TrueColorType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      image->matte=MagickFalse;
      break;
    }
    case TrueColorMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case ColorSeparationType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            (void) TransformImageColorspace(image,sRGBColorspace);
          status=TransformImageColorspace(image,CMYKColorspace);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      image->matte=MagickFalse;
      break;
    }
    case ColorSeparationMatteType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            (void) TransformImageColorspace(image,sRGBColorspace);
          status=TransformImageColorspace(image,CMYKColorspace);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case OptimizeType:
    case UndefinedType:
      break;
  }
  image_info=DestroyImageInfo(image_info);
  if (status == MagickFalse)
    return(MagickFalse);
  image->type=type;
  return(MagickTrue);
}
",C,"      status=AcquireImageColormap(image,2);
","      image->colors=2;
",,"@@ -1296,7 +1296,7 @@ MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type)
           status=QuantizeImage(quantize_info,image);
           quantize_info=DestroyQuantizeInfo(quantize_info);
         }
-      image->colors=2;
+      status=AcquireImageColormap(image,2);
       image->matte=MagickFalse;
       break;
     }",ImageMagick,d63a3c5729df59f183e9e110d5d8385d17caaad0,105e0a32afde5e5a24bc04885d2c099db850e207,1,"MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type)
{
  const char
    *artifact;

  ImageInfo
    *image_info;

  MagickBooleanType
    status;

  QuantizeInfo
    *quantize_info;

  assert(image != (Image *) NULL);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->signature == MagickSignature);
  status=MagickTrue;
  image_info=AcquireImageInfo();
  image_info->dither=image->dither;
  artifact=GetImageArtifact(image,""dither"");
  if (artifact != (const char *) NULL)
    (void) SetImageOption(image_info,""dither"",artifact);
  switch (type)
  {
    case BilevelType:
    {
      if (SetImageMonochrome(image,&image->exception) == MagickFalse)
        {
          status=TransformImageColorspace(image,GRAYColorspace);
          (void) NormalizeImage(image);
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=2;
          quantize_info->colorspace=GRAYColorspace;
           status=QuantizeImage(quantize_info,image);
           quantize_info=DestroyQuantizeInfo(quantize_info);
         }
//flaw_line_below:
      image->colors=2;
//fix_flaw_line_below:
//      status=AcquireImageColormap(image,2);
       image->matte=MagickFalse;
       break;
     }
    case GrayscaleType:
    {
      if (SetImageGray(image,&image->exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace);
      image->matte=MagickFalse;
      break;
    }
    case GrayscaleMatteType:
    {
      if (SetImageGray(image,&image->exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case PaletteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if ((image->storage_class == DirectClass) || (image->colors > 256))
        {
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=256;
          status=QuantizeImage(quantize_info,image);
          quantize_info=DestroyQuantizeInfo(quantize_info);
        }
      image->matte=MagickFalse;
      break;
    }
    case PaletteBilevelMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      (void) BilevelImageChannel(image,AlphaChannel,(double) QuantumRange/2.0);
      quantize_info=AcquireQuantizeInfo(image_info);
      status=QuantizeImage(quantize_info,image);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case PaletteMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      quantize_info=AcquireQuantizeInfo(image_info);
      quantize_info->colorspace=TransparentColorspace;
      status=QuantizeImage(quantize_info,image);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case TrueColorType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      image->matte=MagickFalse;
      break;
    }
    case TrueColorMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case ColorSeparationType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            (void) TransformImageColorspace(image,sRGBColorspace);
          status=TransformImageColorspace(image,CMYKColorspace);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      image->matte=MagickFalse;
      break;
    }
    case ColorSeparationMatteType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            (void) TransformImageColorspace(image,sRGBColorspace);
          status=TransformImageColorspace(image,CMYKColorspace);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case OptimizeType:
    case UndefinedType:
      break;
  }
  image_info=DestroyImageInfo(image_info);
  if (status == MagickFalse)
    return(MagickFalse);
  image->type=type;
  return(MagickTrue);
}
",181948,"MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type)
{
  const char
    *artifact;

  ImageInfo
    *image_info;

  MagickBooleanType
    status;

  QuantizeInfo
    *quantize_info;

  assert(image != (Image *) NULL);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->signature == MagickSignature);
  status=MagickTrue;
  image_info=AcquireImageInfo();
  image_info->dither=image->dither;
  artifact=GetImageArtifact(image,""dither"");
  if (artifact != (const char *) NULL)
    (void) SetImageOption(image_info,""dither"",artifact);
  switch (type)
  {
    case BilevelType:
    {
      if (SetImageMonochrome(image,&image->exception) == MagickFalse)
        {
          status=TransformImageColorspace(image,GRAYColorspace);
          (void) NormalizeImage(image);
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=2;
          quantize_info->colorspace=GRAYColorspace;
           status=QuantizeImage(quantize_info,image);
           quantize_info=DestroyQuantizeInfo(quantize_info);
         }
      image->colors=2;
       image->matte=MagickFalse;
       break;
     }
    case GrayscaleType:
    {
      if (SetImageGray(image,&image->exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace);
      image->matte=MagickFalse;
      break;
    }
    case GrayscaleMatteType:
    {
      if (SetImageGray(image,&image->exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case PaletteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if ((image->storage_class == DirectClass) || (image->colors > 256))
        {
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=256;
          status=QuantizeImage(quantize_info,image);
          quantize_info=DestroyQuantizeInfo(quantize_info);
        }
      image->matte=MagickFalse;
      break;
    }
    case PaletteBilevelMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      (void) BilevelImageChannel(image,AlphaChannel,(double) QuantumRange/2.0);
      quantize_info=AcquireQuantizeInfo(image_info);
      status=QuantizeImage(quantize_info,image);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case PaletteMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      quantize_info=AcquireQuantizeInfo(image_info);
      quantize_info->colorspace=TransparentColorspace;
      status=QuantizeImage(quantize_info,image);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case TrueColorType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      image->matte=MagickFalse;
      break;
    }
    case TrueColorMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case ColorSeparationType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            (void) TransformImageColorspace(image,sRGBColorspace);
          status=TransformImageColorspace(image,CMYKColorspace);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      image->matte=MagickFalse;
      break;
    }
    case ColorSeparationMatteType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            (void) TransformImageColorspace(image,sRGBColorspace);
          status=TransformImageColorspace(image,CMYKColorspace);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case OptimizeType:
    case UndefinedType:
      break;
  }
  image_info=DestroyImageInfo(image_info);
  if (status == MagickFalse)
    return(MagickFalse);
  image->type=type;
  return(MagickTrue);
}
","MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type)
{
  const char
    *artifact;

  ImageInfo
    *image_info;

  MagickBooleanType
    status;

  QuantizeInfo
    *quantize_info;

  assert(image != (Image *) NULL);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->signature == MagickSignature);
  status=MagickTrue;
  image_info=AcquireImageInfo();
  image_info->dither=image->dither;
  artifact=GetImageArtifact(image,""dither"");
  if (artifact != (const char *) NULL)
    (void) SetImageOption(image_info,""dither"",artifact);
  switch (type)
  {
    case BilevelType:
    {
      if (SetImageMonochrome(image,&image->exception) == MagickFalse)
        {
          status=TransformImageColorspace(image,GRAYColorspace);
          (void) NormalizeImage(image);
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=2;
          quantize_info->colorspace=GRAYColorspace;
           status=QuantizeImage(quantize_info,image);
           quantize_info=DestroyQuantizeInfo(quantize_info);
         }
      status=AcquireImageColormap(image,2);
       image->matte=MagickFalse;
       break;
     }
    case GrayscaleType:
    {
      if (SetImageGray(image,&image->exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace);
      image->matte=MagickFalse;
      break;
    }
    case GrayscaleMatteType:
    {
      if (SetImageGray(image,&image->exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case PaletteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if ((image->storage_class == DirectClass) || (image->colors > 256))
        {
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=256;
          status=QuantizeImage(quantize_info,image);
          quantize_info=DestroyQuantizeInfo(quantize_info);
        }
      image->matte=MagickFalse;
      break;
    }
    case PaletteBilevelMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      (void) BilevelImageChannel(image,AlphaChannel,(double) QuantumRange/2.0);
      quantize_info=AcquireQuantizeInfo(image_info);
      status=QuantizeImage(quantize_info,image);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case PaletteMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      quantize_info=AcquireQuantizeInfo(image_info);
      quantize_info->colorspace=TransparentColorspace;
      status=QuantizeImage(quantize_info,image);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case TrueColorType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      image->matte=MagickFalse;
      break;
    }
    case TrueColorMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case ColorSeparationType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            (void) TransformImageColorspace(image,sRGBColorspace);
          status=TransformImageColorspace(image,CMYKColorspace);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      image->matte=MagickFalse;
      break;
    }
    case ColorSeparationMatteType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            (void) TransformImageColorspace(image,sRGBColorspace);
          status=TransformImageColorspace(image,CMYKColorspace);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case OptimizeType:
    case UndefinedType:
      break;
  }
  image_info=DestroyImageInfo(image_info);
  if (status == MagickFalse)
    return(MagickFalse);
  image->type=type;
  return(MagickTrue);
}
","The vulnerability in the original code lies in the lack of proper handling of the image's color map, particularly in the `BilevelType` case. The absence of a call to `AcquireImageColormap(image,2)` could lead to undefined behavior or memory issues when the image is processed, as the color map may not be initialized correctly. In the fixed code, this vulnerability is addressed by adding the line `status=AcquireImageColormap(image,2);` within the `BilevelType` case, ensuring that the image's color map is properly allocated and initialized, thus preventing potential memory corruption or crashes during image processing.","The vulnerability in the original code stems from inadequate handling of the image's color map, particularly in scenarios where specific image types are processed. This oversight could lead to undefined behavior or memory-related issues, as the color map may not be properly initialized before being accessed. The fix addresses this vulnerability by ensuring that the color map is explicitly allocated and initialized for the relevant image type. This change enhances the stability and reliability of the code, preventing potential crashes or memory corruption during image processing operations."
37,182046,182046,,Remote,Not required,Partial,CVE-2015-5221,https://www.cvedetails.com/cve/CVE-2015-5221/,CWE-416,Medium,,,,2017-07-25,4.3,Use-after-free vulnerability in the mif_process_cmpt function in libjasper/mif/mif_cod.c in the JasPer JPEG-2000 library before 1.900.2 allows remote attackers to cause a denial of service (crash) via a crafted JPEG 2000 image file.,2018-11-22,DoS ,1,https://github.com/mdadams/jasper/commit/df5d2867e8004e51e18b89865bc4aa69229227b3,df5d2867e8004e51e18b89865bc4aa69229227b3,CVE-2015-5221,1,src/libjasper/mif/mif_cod.c,"{""sha"": ""5afc0a249ba700ab337e47ef56ead0114cfc5385"", ""filename"": ""src/libjasper/mif/mif_cod.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/mdadams/jasper/blob/df5d2867e8004e51e18b89865bc4aa69229227b3/src/libjasper/mif/mif_cod.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/df5d2867e8004e51e18b89865bc4aa69229227b3/src/libjasper/mif/mif_cod.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/mif/mif_cod.c?ref=df5d2867e8004e51e18b89865bc4aa69229227b3"", ""patch"": ""@@ -570,13 +570,13 @@ static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)\n \t\t\tbreak;\n \t\t}\n \t}\n-\tjas_tvparser_destroy(tvp);\n \tif (!cmpt->sampperx || !cmpt->samppery) {\n \t\tgoto error;\n \t}\n \tif (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {\n \t\tgoto error;\n \t}\n+\tjas_tvparser_destroy(tvp);\n \treturn 0;\n \n error:""}","static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)
{
	jas_tvparser_t *tvp;
	mif_cmpt_t *cmpt;
	int id;

	cmpt = 0;
	tvp = 0;

	if (!(cmpt = mif_cmpt_create())) {
		goto error;
	}
	cmpt->tlx = 0;
	cmpt->tly = 0;
	cmpt->sampperx = 0;
	cmpt->samppery = 0;
	cmpt->width = 0;
	cmpt->height = 0;
	cmpt->prec = 0;
	cmpt->sgnd = -1;
	cmpt->data = 0;

	if (!(tvp = jas_tvparser_create(buf))) {
		goto error;
	}
	while (!(id = jas_tvparser_next(tvp))) {
		switch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,
		  jas_tvparser_gettag(tvp)))->id) {
		case MIF_TLX:
			cmpt->tlx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_TLY:
			cmpt->tly = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_WIDTH:
			cmpt->width = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HEIGHT:
			cmpt->height = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HSAMP:
			cmpt->sampperx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_VSAMP:
			cmpt->samppery = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_PREC:
			cmpt->prec = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_SGND:
			cmpt->sgnd = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_DATA:
			if (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {
				return -1;
			}
 			break;
 		}
 	}
 	if (!cmpt->sampperx || !cmpt->samppery) {
 		goto error;
 	}
 	if (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {
 		goto error;
 	}
	jas_tvparser_destroy(tvp);
 	return 0;
 
 error:
	if (cmpt) {
		mif_cmpt_destroy(cmpt);
	}
	if (tvp) {
		jas_tvparser_destroy(tvp);
	}
	return -1;
}
","static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)
{
	jas_tvparser_t *tvp;
	mif_cmpt_t *cmpt;
	int id;

	cmpt = 0;
	tvp = 0;

	if (!(cmpt = mif_cmpt_create())) {
		goto error;
	}
	cmpt->tlx = 0;
	cmpt->tly = 0;
	cmpt->sampperx = 0;
	cmpt->samppery = 0;
	cmpt->width = 0;
	cmpt->height = 0;
	cmpt->prec = 0;
	cmpt->sgnd = -1;
	cmpt->data = 0;

	if (!(tvp = jas_tvparser_create(buf))) {
		goto error;
	}
	while (!(id = jas_tvparser_next(tvp))) {
		switch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,
		  jas_tvparser_gettag(tvp)))->id) {
		case MIF_TLX:
			cmpt->tlx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_TLY:
			cmpt->tly = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_WIDTH:
			cmpt->width = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HEIGHT:
			cmpt->height = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HSAMP:
			cmpt->sampperx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_VSAMP:
			cmpt->samppery = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_PREC:
			cmpt->prec = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_SGND:
			cmpt->sgnd = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_DATA:
			if (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {
				return -1;
			}
 			break;
 		}
 	}
	jas_tvparser_destroy(tvp);
 	if (!cmpt->sampperx || !cmpt->samppery) {
 		goto error;
 	}
 	if (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {
 		goto error;
 	}
 	return 0;
 
 error:
	if (cmpt) {
		mif_cmpt_destroy(cmpt);
	}
	if (tvp) {
		jas_tvparser_destroy(tvp);
	}
	return -1;
}
",C,"	jas_tvparser_destroy(tvp);
","	jas_tvparser_destroy(tvp);
",,"@@ -570,13 +570,13 @@ static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)
 			break;
 		}
 	}
-	jas_tvparser_destroy(tvp);
 	if (!cmpt->sampperx || !cmpt->samppery) {
 		goto error;
 	}
 	if (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {
 		goto error;
 	}
+	jas_tvparser_destroy(tvp);
 	return 0;
 
 error:",jasper,df5d2867e8004e51e18b89865bc4aa69229227b3,b13b8c86be870107f83b0a9a4b77557cb2b65d69,1,"static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)
{
	jas_tvparser_t *tvp;
	mif_cmpt_t *cmpt;
	int id;

	cmpt = 0;
	tvp = 0;

	if (!(cmpt = mif_cmpt_create())) {
		goto error;
	}
	cmpt->tlx = 0;
	cmpt->tly = 0;
	cmpt->sampperx = 0;
	cmpt->samppery = 0;
	cmpt->width = 0;
	cmpt->height = 0;
	cmpt->prec = 0;
	cmpt->sgnd = -1;
	cmpt->data = 0;

	if (!(tvp = jas_tvparser_create(buf))) {
		goto error;
	}
	while (!(id = jas_tvparser_next(tvp))) {
		switch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,
		  jas_tvparser_gettag(tvp)))->id) {
		case MIF_TLX:
			cmpt->tlx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_TLY:
			cmpt->tly = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_WIDTH:
			cmpt->width = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HEIGHT:
			cmpt->height = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HSAMP:
			cmpt->sampperx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_VSAMP:
			cmpt->samppery = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_PREC:
			cmpt->prec = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_SGND:
			cmpt->sgnd = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_DATA:
			if (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {
				return -1;
			}
 			break;
 		}
 	}
//flaw_line_below:
	jas_tvparser_destroy(tvp);
 	if (!cmpt->sampperx || !cmpt->samppery) {
 		goto error;
 	}
 	if (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {
 		goto error;
 	}
//fix_flaw_line_below:
//	jas_tvparser_destroy(tvp);
 	return 0;
 
 error:
	if (cmpt) {
		mif_cmpt_destroy(cmpt);
	}
	if (tvp) {
		jas_tvparser_destroy(tvp);
	}
	return -1;
}
",182046,"static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)
{
	jas_tvparser_t *tvp;
	mif_cmpt_t *cmpt;
	int id;

	cmpt = 0;
	tvp = 0;

	if (!(cmpt = mif_cmpt_create())) {
		goto error;
	}
	cmpt->tlx = 0;
	cmpt->tly = 0;
	cmpt->sampperx = 0;
	cmpt->samppery = 0;
	cmpt->width = 0;
	cmpt->height = 0;
	cmpt->prec = 0;
	cmpt->sgnd = -1;
	cmpt->data = 0;

	if (!(tvp = jas_tvparser_create(buf))) {
		goto error;
	}
	while (!(id = jas_tvparser_next(tvp))) {
		switch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,
		  jas_tvparser_gettag(tvp)))->id) {
		case MIF_TLX:
			cmpt->tlx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_TLY:
			cmpt->tly = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_WIDTH:
			cmpt->width = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HEIGHT:
			cmpt->height = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HSAMP:
			cmpt->sampperx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_VSAMP:
			cmpt->samppery = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_PREC:
			cmpt->prec = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_SGND:
			cmpt->sgnd = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_DATA:
			if (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {
				return -1;
			}
 			break;
 		}
 	}
	jas_tvparser_destroy(tvp);
 	if (!cmpt->sampperx || !cmpt->samppery) {
 		goto error;
 	}
 	if (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {
 		goto error;
 	}
 	return 0;
 
 error:
	if (cmpt) {
		mif_cmpt_destroy(cmpt);
	}
	if (tvp) {
		jas_tvparser_destroy(tvp);
	}
	return -1;
}
","static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)
{
	jas_tvparser_t *tvp;
	mif_cmpt_t *cmpt;
	int id;

	cmpt = 0;
	tvp = 0;

	if (!(cmpt = mif_cmpt_create())) {
		goto error;
	}
	cmpt->tlx = 0;
	cmpt->tly = 0;
	cmpt->sampperx = 0;
	cmpt->samppery = 0;
	cmpt->width = 0;
	cmpt->height = 0;
	cmpt->prec = 0;
	cmpt->sgnd = -1;
	cmpt->data = 0;

	if (!(tvp = jas_tvparser_create(buf))) {
		goto error;
	}
	while (!(id = jas_tvparser_next(tvp))) {
		switch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,
		  jas_tvparser_gettag(tvp)))->id) {
		case MIF_TLX:
			cmpt->tlx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_TLY:
			cmpt->tly = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_WIDTH:
			cmpt->width = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HEIGHT:
			cmpt->height = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HSAMP:
			cmpt->sampperx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_VSAMP:
			cmpt->samppery = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_PREC:
			cmpt->prec = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_SGND:
			cmpt->sgnd = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_DATA:
			if (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {
				return -1;
			}
 			break;
 		}
 	}
 	if (!cmpt->sampperx || !cmpt->samppery) {
 		goto error;
 	}
 	if (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {
 		goto error;
 	}
	jas_tvparser_destroy(tvp);
 	return 0;
 
 error:
	if (cmpt) {
		mif_cmpt_destroy(cmpt);
	}
	if (tvp) {
		jas_tvparser_destroy(tvp);
	}
	return -1;
}
","The vulnerability in the original code lies in the order of operations, specifically the placement of `jas_tvparser_destroy(tvp)` after the return statement. This could lead to a memory leak if the function exits prematurely without destroying the `tvp` parser. In the fixed code, the `jas_tvparser_destroy(tvp)` call is moved before the return statement, ensuring that the parser is properly destroyed regardless of how the function exits. This change mitigates the risk of memory leaks by guaranteeing that allocated resources are released appropriately before the function concludes.","The vulnerability in the original code stems from the improper handling of resource cleanup, specifically the order in which resources are released. If the function exits prematurely due to an error, certain resources may not be freed, leading to potential memory leaks. In the revised code, the cleanup process is improved by ensuring that all allocated resources are properly released before the function returns, regardless of the exit point. This adjustment guarantees that resources are managed correctly, thereby reducing the risk of memory leaks and enhancing overall stability and reliability of the code."
38,182066,182066,,Remote,Not required,Complete,CVE-2014-9940,https://www.cvedetails.com/cve/CVE-2014-9940/,CWE-416,High,Complete,Complete,,2017-05-02,7.6,The regulator_ena_gpio_free function in drivers/regulator/core.c in the Linux kernel before 3.19 allows local users to gain privileges or cause a denial of service (use-after-free) via a crafted application.,2017-11-03,DoS +Priv ,2,https://github.com/torvalds/linux/commit/60a2362f769cf549dc466134efe71c8bf9fbaaba,60a2362f769cf549dc466134efe71c8bf9fbaaba,"regulator: core: Fix regualtor_ena_gpio_free not to access pin after freeing

After freeing pin from regulator_ena_gpio_free, loop can access
the pin. So this patch fixes not to access pin after freeing.

Signed-off-by: Seung-Woo Kim <sw0312.kim@samsung.com>
Signed-off-by: Mark Brown <broonie@kernel.org>",0,drivers/regulator/core.c,"{""sha"": ""47a455cfe04fb344409a1f48ac52a7c9450edad3"", ""filename"": ""drivers/regulator/core.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/60a2362f769cf549dc466134efe71c8bf9fbaaba/drivers/regulator/core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/60a2362f769cf549dc466134efe71c8bf9fbaaba/drivers/regulator/core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/regulator/core.c?ref=60a2362f769cf549dc466134efe71c8bf9fbaaba"", ""patch"": ""@@ -1713,6 +1713,8 @@ static void regulator_ena_gpio_free(struct regulator_dev *rdev)\n \t\t\t\tgpiod_put(pin->gpiod);\n \t\t\t\tlist_del(&pin->list);\n \t\t\t\tkfree(pin);\n+\t\t\t\trdev->ena_pin = NULL;\n+\t\t\t\treturn;\n \t\t\t} else {\n \t\t\t\tpin->request_count--;\n \t\t\t}""}","static void regulator_ena_gpio_free(struct regulator_dev *rdev)
{
	struct regulator_enable_gpio *pin, *n;

	if (!rdev->ena_pin)
		return;

	/* Free the GPIO only in case of no use */
	list_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {
		if (pin->gpiod == rdev->ena_pin->gpiod) {
			if (pin->request_count <= 1) {
				pin->request_count = 0;
 				gpiod_put(pin->gpiod);
 				list_del(&pin->list);
 				kfree(pin);
				rdev->ena_pin = NULL;
				return;
 			} else {
 				pin->request_count--;
 			}
		}
	}
}
","static void regulator_ena_gpio_free(struct regulator_dev *rdev)
{
	struct regulator_enable_gpio *pin, *n;

	if (!rdev->ena_pin)
		return;

	/* Free the GPIO only in case of no use */
	list_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {
		if (pin->gpiod == rdev->ena_pin->gpiod) {
			if (pin->request_count <= 1) {
				pin->request_count = 0;
 				gpiod_put(pin->gpiod);
 				list_del(&pin->list);
 				kfree(pin);
 			} else {
 				pin->request_count--;
 			}
		}
	}
}
",C,"				rdev->ena_pin = NULL;
				return;
",,,"@@ -1713,6 +1713,8 @@ static void regulator_ena_gpio_free(struct regulator_dev *rdev)
 				gpiod_put(pin->gpiod);
 				list_del(&pin->list);
 				kfree(pin);
+				rdev->ena_pin = NULL;
+				return;
 			} else {
 				pin->request_count--;
 			}",linux,60a2362f769cf549dc466134efe71c8bf9fbaaba,194dbaefa0da24bb60d9df1c99dda807f51fc33f,1,"static void regulator_ena_gpio_free(struct regulator_dev *rdev)
{
	struct regulator_enable_gpio *pin, *n;

	if (!rdev->ena_pin)
		return;

	/* Free the GPIO only in case of no use */
	list_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {
		if (pin->gpiod == rdev->ena_pin->gpiod) {
			if (pin->request_count <= 1) {
				pin->request_count = 0;
 				gpiod_put(pin->gpiod);
 				list_del(&pin->list);
 				kfree(pin);
//fix_flaw_line_below:
//				rdev->ena_pin = NULL;
//fix_flaw_line_below:
//				return;
 			} else {
 				pin->request_count--;
 			}
		}
	}
}
",182066,"static void regulator_ena_gpio_free(struct regulator_dev *rdev)
{
	struct regulator_enable_gpio *pin, *n;

	if (!rdev->ena_pin)
		return;

	/* Free the GPIO only in case of no use */
	list_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {
		if (pin->gpiod == rdev->ena_pin->gpiod) {
			if (pin->request_count <= 1) {
				pin->request_count = 0;
 				gpiod_put(pin->gpiod);
 				list_del(&pin->list);
 				kfree(pin);
 			} else {
 				pin->request_count--;
 			}
		}
	}
}
","static void regulator_ena_gpio_free(struct regulator_dev *rdev)
{
	struct regulator_enable_gpio *pin, *n;

	if (!rdev->ena_pin)
		return;

	/* Free the GPIO only in case of no use */
	list_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {
		if (pin->gpiod == rdev->ena_pin->gpiod) {
			if (pin->request_count <= 1) {
				pin->request_count = 0;
 				gpiod_put(pin->gpiod);
 				list_del(&pin->list);
 				kfree(pin);
				rdev->ena_pin = NULL;
				return;
 			} else {
 				pin->request_count--;
 			}
		}
	}
}
","The vulnerability in the original code lies in the potential for a use-after-free condition, where the `rdev->ena_pin` could still reference a GPIO after it has been freed, leading to undefined behavior. This occurs because, after freeing the GPIO with `gpiod_put(pin->gpiod)` and removing it from the list, the code does not nullify `rdev->ena_pin`, allowing further access to a now-invalid pointer. The fixed code addresses this vulnerability by setting `rdev->ena_pin` to `NULL` immediately after freeing the GPIO, ensuring that any subsequent access to `ena_pin` does not reference a freed memory location.","The vulnerability in the original code stems from a potential use-after-free condition, where a pointer could still reference a resource after it has been deallocated, leading to undefined behavior. This occurs because the code frees the resource but does not update the pointer that references it, allowing for further access to an invalid memory location. The fixed code resolves this issue by nullifying the pointer immediately after the resource is freed, ensuring that any subsequent attempts to access the resource will not reference a deallocated memory area, thus preventing potential crashes or security vulnerabilities."
39,182069,182069,,Local,Not required,Complete,CVE-2014-9914,https://www.cvedetails.com/cve/CVE-2014-9914/,CWE-416,Low,Complete,Complete,,2017-02-07,7.2,Race condition in the ip4_datagram_release_cb function in net/ipv4/datagram.c in the Linux kernel before 3.15.2 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging incorrect expectations about locking during multithreaded access to internal data structures for IPv4 UDP sockets.,2017-07-24,DoS +Priv ,11,https://github.com/torvalds/linux/commit/9709674e68646cee5a24e3000b3558d25412203a,9709674e68646cee5a24e3000b3558d25412203a,"ipv4: fix a race in ip4_datagram_release_cb()

Alexey gave a AddressSanitizer[1] report that finally gave a good hint
at where was the origin of various problems already reported by Dormando
in the past [2]

Problem comes from the fact that UDP can have a lockless TX path, and
concurrent threads can manipulate sk_dst_cache, while another thread,
is holding socket lock and calls __sk_dst_set() in
ip4_datagram_release_cb() (this was added in linux-3.8)

It seems that all we need to do is to use sk_dst_check() and
sk_dst_set() so that all the writers hold same spinlock
(sk->sk_dst_lock) to prevent corruptions.

TCP stack do not need this protection, as all sk_dst_cache writers hold
the socket lock.

[1]
https://code.google.com/p/address-sanitizer/wiki/AddressSanitizerForKernel

AddressSanitizer: heap-use-after-free in ipv4_dst_check
Read of size 2 by thread T15453:
 [<ffffffff817daa3a>] ipv4_dst_check+0x1a/0x90 ./net/ipv4/route.c:1116
 [<ffffffff8175b789>] __sk_dst_check+0x89/0xe0 ./net/core/sock.c:531
 [<ffffffff81830a36>] ip4_datagram_release_cb+0x46/0x390 ??:0
 [<ffffffff8175eaea>] release_sock+0x17a/0x230 ./net/core/sock.c:2413
 [<ffffffff81830882>] ip4_datagram_connect+0x462/0x5d0 ??:0
 [<ffffffff81846d06>] inet_dgram_connect+0x76/0xd0 ./net/ipv4/af_inet.c:534
 [<ffffffff817580ac>] SYSC_connect+0x15c/0x1c0 ./net/socket.c:1701
 [<ffffffff817596ce>] SyS_connect+0xe/0x10 ./net/socket.c:1682
 [<ffffffff818b0a29>] system_call_fastpath+0x16/0x1b
./arch/x86/kernel/entry_64.S:629

Freed by thread T15455:
 [<ffffffff8178d9b8>] dst_destroy+0xa8/0x160 ./net/core/dst.c:251
 [<ffffffff8178de25>] dst_release+0x45/0x80 ./net/core/dst.c:280
 [<ffffffff818304c1>] ip4_datagram_connect+0xa1/0x5d0 ??:0
 [<ffffffff81846d06>] inet_dgram_connect+0x76/0xd0 ./net/ipv4/af_inet.c:534
 [<ffffffff817580ac>] SYSC_connect+0x15c/0x1c0 ./net/socket.c:1701
 [<ffffffff817596ce>] SyS_connect+0xe/0x10 ./net/socket.c:1682
 [<ffffffff818b0a29>] system_call_fastpath+0x16/0x1b
./arch/x86/kernel/entry_64.S:629

Allocated by thread T15453:
 [<ffffffff8178d291>] dst_alloc+0x81/0x2b0 ./net/core/dst.c:171
 [<ffffffff817db3b7>] rt_dst_alloc+0x47/0x50 ./net/ipv4/route.c:1406
 [<     inlined    >] __ip_route_output_key+0x3e8/0xf70
__mkroute_output ./net/ipv4/route.c:1939
 [<ffffffff817dde08>] __ip_route_output_key+0x3e8/0xf70 ./net/ipv4/route.c:2161
 [<ffffffff817deb34>] ip_route_output_flow+0x14/0x30 ./net/ipv4/route.c:2249
 [<ffffffff81830737>] ip4_datagram_connect+0x317/0x5d0 ??:0
 [<ffffffff81846d06>] inet_dgram_connect+0x76/0xd0 ./net/ipv4/af_inet.c:534
 [<ffffffff817580ac>] SYSC_connect+0x15c/0x1c0 ./net/socket.c:1701
 [<ffffffff817596ce>] SyS_connect+0xe/0x10 ./net/socket.c:1682
 [<ffffffff818b0a29>] system_call_fastpath+0x16/0x1b
./arch/x86/kernel/entry_64.S:629

[2]
<4>[196727.311203] general protection fault: 0000 [#1] SMP
<4>[196727.311224] Modules linked in: xt_TEE xt_dscp xt_DSCP macvlan bridge coretemp crc32_pclmul ghash_clmulni_intel gpio_ich microcode ipmi_watchdog ipmi_devintf sb_edac edac_core lpc_ich mfd_core tpm_tis tpm tpm_bios ipmi_si ipmi_msghandler isci igb libsas i2c_algo_bit ixgbe ptp pps_core mdio
<4>[196727.311333] CPU: 17 PID: 0 Comm: swapper/17 Not tainted 3.10.26 #1
<4>[196727.311344] Hardware name: Supermicro X9DRi-LN4+/X9DR3-LN4+/X9DRi-LN4+/X9DR3-LN4+, BIOS 3.0 07/05/2013
<4>[196727.311364] task: ffff885e6f069700 ti: ffff885e6f072000 task.ti: ffff885e6f072000
<4>[196727.311377] RIP: 0010:[<ffffffff815f8c7f>]  [<ffffffff815f8c7f>] ipv4_dst_destroy+0x4f/0x80
<4>[196727.311399] RSP: 0018:ffff885effd23a70  EFLAGS: 00010282
<4>[196727.311409] RAX: dead000000200200 RBX: ffff8854c398ecc0 RCX: 0000000000000040
<4>[196727.311423] RDX: dead000000100100 RSI: dead000000100100 RDI: dead000000200200
<4>[196727.311437] RBP: ffff885effd23a80 R08: ffffffff815fd9e0 R09: ffff885d5a590800
<4>[196727.311451] R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000
<4>[196727.311464] R13: ffffffff81c8c280 R14: 0000000000000000 R15: ffff880e85ee16ce
<4>[196727.311510] FS:  0000000000000000(0000) GS:ffff885effd20000(0000) knlGS:0000000000000000
<4>[196727.311554] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
<4>[196727.311581] CR2: 00007a46751eb000 CR3: 0000005e65688000 CR4: 00000000000407e0
<4>[196727.311625] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
<4>[196727.311669] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
<4>[196727.311713] Stack:
<4>[196727.311733]  ffff8854c398ecc0 ffff8854c398ecc0 ffff885effd23ab0 ffffffff815b7f42
<4>[196727.311784]  ffff88be6595bc00 ffff8854c398ecc0 0000000000000000 ffff8854c398ecc0
<4>[196727.311834]  ffff885effd23ad0 ffffffff815b86c6 ffff885d5a590800 ffff8816827821c0
<4>[196727.311885] Call Trace:
<4>[196727.311907]  <IRQ>
<4>[196727.311912]  [<ffffffff815b7f42>] dst_destroy+0x32/0xe0
<4>[196727.311959]  [<ffffffff815b86c6>] dst_release+0x56/0x80
<4>[196727.311986]  [<ffffffff81620bd5>] tcp_v4_do_rcv+0x2a5/0x4a0
<4>[196727.312013]  [<ffffffff81622b5a>] tcp_v4_rcv+0x7da/0x820
<4>[196727.312041]  [<ffffffff815fd9e0>] ? ip_rcv_finish+0x360/0x360
<4>[196727.312070]  [<ffffffff815de02d>] ? nf_hook_slow+0x7d/0x150
<4>[196727.312097]  [<ffffffff815fd9e0>] ? ip_rcv_finish+0x360/0x360
<4>[196727.312125]  [<ffffffff815fda92>] ip_local_deliver_finish+0xb2/0x230
<4>[196727.312154]  [<ffffffff815fdd9a>] ip_local_deliver+0x4a/0x90
<4>[196727.312183]  [<ffffffff815fd799>] ip_rcv_finish+0x119/0x360
<4>[196727.312212]  [<ffffffff815fe00b>] ip_rcv+0x22b/0x340
<4>[196727.312242]  [<ffffffffa0339680>] ? macvlan_broadcast+0x160/0x160 [macvlan]
<4>[196727.312275]  [<ffffffff815b0c62>] __netif_receive_skb_core+0x512/0x640
<4>[196727.312308]  [<ffffffff811427fb>] ? kmem_cache_alloc+0x13b/0x150
<4>[196727.312338]  [<ffffffff815b0db1>] __netif_receive_skb+0x21/0x70
<4>[196727.312368]  [<ffffffff815b0fa1>] netif_receive_skb+0x31/0xa0
<4>[196727.312397]  [<ffffffff815b1ae8>] napi_gro_receive+0xe8/0x140
<4>[196727.312433]  [<ffffffffa00274f1>] ixgbe_poll+0x551/0x11f0 [ixgbe]
<4>[196727.312463]  [<ffffffff815fe00b>] ? ip_rcv+0x22b/0x340
<4>[196727.312491]  [<ffffffff815b1691>] net_rx_action+0x111/0x210
<4>[196727.312521]  [<ffffffff815b0db1>] ? __netif_receive_skb+0x21/0x70
<4>[196727.312552]  [<ffffffff810519d0>] __do_softirq+0xd0/0x270
<4>[196727.312583]  [<ffffffff816cef3c>] call_softirq+0x1c/0x30
<4>[196727.312613]  [<ffffffff81004205>] do_softirq+0x55/0x90
<4>[196727.312640]  [<ffffffff81051c85>] irq_exit+0x55/0x60
<4>[196727.312668]  [<ffffffff816cf5c3>] do_IRQ+0x63/0xe0
<4>[196727.312696]  [<ffffffff816c5aaa>] common_interrupt+0x6a/0x6a
<4>[196727.312722]  <EOI>
<1>[196727.313071] RIP  [<ffffffff815f8c7f>] ipv4_dst_destroy+0x4f/0x80
<4>[196727.313100]  RSP <ffff885effd23a70>
<4>[196727.313377] ---[ end trace 64b3f14fae0f2e29 ]---
<0>[196727.380908] Kernel panic - not syncing: Fatal exception in interrupt

Reported-by: Alexey Preobrazhensky <preobr@google.com>
Reported-by: dormando <dormando@rydia.ne>
Signed-off-by: Eric Dumazet <edumazet@google.com>
Fixes: 8141ed9fcedb2 (""ipv4: Add a socket release callback for datagram sockets"")
Cc: Steffen Klassert <steffen.klassert@secunet.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",4,net/ipv4/datagram.c,"{""sha"": ""a3095fdefbed98ed4e320ac6c44ea3e18241d1a4"", ""filename"": ""net/ipv4/datagram.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 5, ""changes"": 20, ""blob_url"": ""https://github.com/torvalds/linux/blob/9709674e68646cee5a24e3000b3558d25412203a/net/ipv4/datagram.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9709674e68646cee5a24e3000b3558d25412203a/net/ipv4/datagram.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/datagram.c?ref=9709674e68646cee5a24e3000b3558d25412203a"", ""patch"": ""@@ -86,27 +86,37 @@ int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n }\n EXPORT_SYMBOL(ip4_datagram_connect);\n \n+/* Because UDP xmit path can manipulate sk_dst_cache without holding\n+ * socket lock, we need to use sk_dst_set() here,\n+ * even if we own the socket lock.\n+ */\n void ip4_datagram_release_cb(struct sock *sk)\n {\n \tconst struct inet_sock *inet = inet_sk(sk);\n \tconst struct ip_options_rcu *inet_opt;\n \t__be32 daddr = inet->inet_daddr;\n+\tstruct dst_entry *dst;\n \tstruct flowi4 fl4;\n \tstruct rtable *rt;\n \n-\tif (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))\n-\t\treturn;\n-\n \trcu_read_lock();\n+\n+\tdst = __sk_dst_get(sk);\n+\tif (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {\n+\t\trcu_read_unlock();\n+\t\treturn;\n+\t}\n \tinet_opt = rcu_dereference(inet->inet_opt);\n \tif (inet_opt && inet_opt->opt.srr)\n \t\tdaddr = inet_opt->opt.faddr;\n \trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n \t\t\t\t   inet->inet_saddr, inet->inet_dport,\n \t\t\t\t   inet->inet_sport, sk->sk_protocol,\n \t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n-\tif (!IS_ERR(rt))\n-\t\t__sk_dst_set(sk, &rt->dst);\n+\n+\tdst = !IS_ERR(rt) ? &rt->dst : NULL;\n+\tsk_dst_set(sk, dst);\n+\n \trcu_read_unlock();\n }\n EXPORT_SYMBOL_GPL(ip4_datagram_release_cb);""}"," void ip4_datagram_release_cb(struct sock *sk)
 {
 	const struct inet_sock *inet = inet_sk(sk);
 	const struct ip_options_rcu *inet_opt;
 	__be32 daddr = inet->inet_daddr;
	struct dst_entry *dst;
 	struct flowi4 fl4;
 	struct rtable *rt;
 
 	rcu_read_lock();

	dst = __sk_dst_get(sk);
	if (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {
		rcu_read_unlock();
		return;
	}
 	inet_opt = rcu_dereference(inet->inet_opt);
 	if (inet_opt && inet_opt->opt.srr)
 		daddr = inet_opt->opt.faddr;
 	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
 				   inet->inet_saddr, inet->inet_dport,
 				   inet->inet_sport, sk->sk_protocol,
 				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);

	dst = !IS_ERR(rt) ? &rt->dst : NULL;
	sk_dst_set(sk, dst);

 	rcu_read_unlock();
 }
"," void ip4_datagram_release_cb(struct sock *sk)
 {
 	const struct inet_sock *inet = inet_sk(sk);
 	const struct ip_options_rcu *inet_opt;
 	__be32 daddr = inet->inet_daddr;
 	struct flowi4 fl4;
 	struct rtable *rt;
 
	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
		return;
 	rcu_read_lock();
 	inet_opt = rcu_dereference(inet->inet_opt);
 	if (inet_opt && inet_opt->opt.srr)
 		daddr = inet_opt->opt.faddr;
 	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
 				   inet->inet_saddr, inet->inet_dport,
 				   inet->inet_sport, sk->sk_protocol,
 				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);
	if (!IS_ERR(rt))
		__sk_dst_set(sk, &rt->dst);
 	rcu_read_unlock();
 }
",C,"	struct dst_entry *dst;

	dst = __sk_dst_get(sk);
	if (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {
		rcu_read_unlock();
		return;
	}

	dst = !IS_ERR(rt) ? &rt->dst : NULL;
	sk_dst_set(sk, dst);

","	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
		return;
	if (!IS_ERR(rt))
		__sk_dst_set(sk, &rt->dst);
",,"@@ -86,27 +86,37 @@ int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 }
 EXPORT_SYMBOL(ip4_datagram_connect);
 
+/* Because UDP xmit path can manipulate sk_dst_cache without holding
+ * socket lock, we need to use sk_dst_set() here,
+ * even if we own the socket lock.
+ */
 void ip4_datagram_release_cb(struct sock *sk)
 {
 	const struct inet_sock *inet = inet_sk(sk);
 	const struct ip_options_rcu *inet_opt;
 	__be32 daddr = inet->inet_daddr;
+	struct dst_entry *dst;
 	struct flowi4 fl4;
 	struct rtable *rt;
 
-	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
-		return;
-
 	rcu_read_lock();
+
+	dst = __sk_dst_get(sk);
+	if (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {
+		rcu_read_unlock();
+		return;
+	}
 	inet_opt = rcu_dereference(inet->inet_opt);
 	if (inet_opt && inet_opt->opt.srr)
 		daddr = inet_opt->opt.faddr;
 	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
 				   inet->inet_saddr, inet->inet_dport,
 				   inet->inet_sport, sk->sk_protocol,
 				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);
-	if (!IS_ERR(rt))
-		__sk_dst_set(sk, &rt->dst);
+
+	dst = !IS_ERR(rt) ? &rt->dst : NULL;
+	sk_dst_set(sk, dst);
+
 	rcu_read_unlock();
 }
 EXPORT_SYMBOL_GPL(ip4_datagram_release_cb);",linux,9709674e68646cee5a24e3000b3558d25412203a,a101ccd141fa777febc510a5c3f3da0c23cd47ce,1," void ip4_datagram_release_cb(struct sock *sk)
 {
 	const struct inet_sock *inet = inet_sk(sk);
 	const struct ip_options_rcu *inet_opt;
 	__be32 daddr = inet->inet_daddr;
//fix_flaw_line_below:
//	struct dst_entry *dst;
 	struct flowi4 fl4;
 	struct rtable *rt;
 
//flaw_line_below:
	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
//flaw_line_below:
		return;
//flaw_line_below:

 	rcu_read_lock();
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	dst = __sk_dst_get(sk);
//fix_flaw_line_below:
//	if (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {
//fix_flaw_line_below:
//		rcu_read_unlock();
//fix_flaw_line_below:
//		return;
//fix_flaw_line_below:
//	}
 	inet_opt = rcu_dereference(inet->inet_opt);
 	if (inet_opt && inet_opt->opt.srr)
 		daddr = inet_opt->opt.faddr;
 	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
 				   inet->inet_saddr, inet->inet_dport,
 				   inet->inet_sport, sk->sk_protocol,
 				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);
//flaw_line_below:
	if (!IS_ERR(rt))
//flaw_line_below:
		__sk_dst_set(sk, &rt->dst);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	dst = !IS_ERR(rt) ? &rt->dst : NULL;
//fix_flaw_line_below:
//	sk_dst_set(sk, dst);
//fix_flaw_line_below:
//
 	rcu_read_unlock();
 }
",182069," void ip4_datagram_release_cb(struct sock *sk)
 {
 	const struct inet_sock *inet = inet_sk(sk);
 	const struct ip_options_rcu *inet_opt;
 	__be32 daddr = inet->inet_daddr;
 	struct flowi4 fl4;
 	struct rtable *rt;
 
	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
		return;
 	rcu_read_lock();
 	inet_opt = rcu_dereference(inet->inet_opt);
 	if (inet_opt && inet_opt->opt.srr)
 		daddr = inet_opt->opt.faddr;
 	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
 				   inet->inet_saddr, inet->inet_dport,
 				   inet->inet_sport, sk->sk_protocol,
 				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);
	if (!IS_ERR(rt))
		__sk_dst_set(sk, &rt->dst);
 	rcu_read_unlock();
 }
"," void ip4_datagram_release_cb(struct sock *sk)
 {
 	const struct inet_sock *inet = inet_sk(sk);
 	const struct ip_options_rcu *inet_opt;
 	__be32 daddr = inet->inet_daddr;
	struct dst_entry *dst;
 	struct flowi4 fl4;
 	struct rtable *rt;
 
 	rcu_read_lock();

	dst = __sk_dst_get(sk);
	if (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {
		rcu_read_unlock();
		return;
	}
 	inet_opt = rcu_dereference(inet->inet_opt);
 	if (inet_opt && inet_opt->opt.srr)
 		daddr = inet_opt->opt.faddr;
 	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
 				   inet->inet_saddr, inet->inet_dport,
 				   inet->inet_sport, sk->sk_protocol,
 				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);

	dst = !IS_ERR(rt) ? &rt->dst : NULL;
	sk_dst_set(sk, dst);

 	rcu_read_unlock();
 }
","The vulnerability in the original code lies in the improper handling of the socket's destination state, specifically in the checks performed by `__sk_dst_get(sk)` and `__sk_dst_check(sk, 0)`. If the destination is invalid or obsolete, the code could still proceed to use it, potentially leading to dereferencing a null or invalid pointer. In the fixed code, the checks are enhanced by introducing `dst->obsolete` and a more robust validation using `dst->ops->check(dst, 0)`, ensuring that the destination is valid before proceeding. Additionally, the destination is set using `sk_dst_set(sk, dst)`, improving safety and correctness.","The vulnerability in the original code stems from inadequate validation of the socket's destination state, which could allow the program to operate on an invalid or null destination. This oversight could lead to dereferencing errors or undefined behavior, potentially compromising system stability or security. The fixed code addresses this issue by implementing more rigorous checks to ensure that the destination is both valid and not obsolete before proceeding with further operations. This enhancement prevents the use of potentially dangerous pointers, thereby improving the overall safety and reliability of the code."
40,182096,182096,,Remote,Not required,,CVE-2018-1999013,https://www.cvedetails.com/cve/CVE-2018-1999013/,CWE-416,Medium,Partial,,,2018-07-23,4.3,FFmpeg before commit a7e032a277452366771951e29fd0bf2bd5c029f0 contains a use-after-free vulnerability in the realmedia demuxer that can result in vulnerability allows attacker to read heap memory. This attack appear to be exploitable via specially crafted RM file has to be provided as input. This vulnerability appears to have been fixed in a7e032a277452366771951e29fd0bf2bd5c029f0 and later.,2018-09-20,,1,https://github.com/FFmpeg/FFmpeg/commit/a7e032a277452366771951e29fd0bf2bd5c029f0,a7e032a277452366771951e29fd0bf2bd5c029f0,"avformat/rmdec: Do not pass mime type in rm_read_multi() to ff_rm_read_mdpr_codecdata()

Fixes: use after free()
Fixes: rmdec-crash-ffe85b4cab1597d1cfea6955705e53f1f5c8a362

Found-by: Paul Ch <paulcher@icloud.com>
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",1,libavformat/rmdec.c,"{""sha"": ""0216003e88e46a52c254cb1a6fa4f7099f3a3414"", ""filename"": ""libavformat/rmdec.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/a7e032a277452366771951e29fd0bf2bd5c029f0/libavformat/rmdec.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/a7e032a277452366771951e29fd0bf2bd5c029f0/libavformat/rmdec.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavformat/rmdec.c?ref=a7e032a277452366771951e29fd0bf2bd5c029f0"", ""patch"": ""@@ -522,7 +522,7 @@ static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,\n \n         size2 = avio_rb32(pb);\n         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,\n-                                        size2, mime);\n+                                        size2, NULL);\n         if (ret < 0)\n             return ret;\n     }""}","static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,
                         AVStream *st, char *mime)
{
    int number_of_streams = avio_rb16(pb);
    int number_of_mdpr;
    int i, ret;
    unsigned size2;
    for (i = 0; i<number_of_streams; i++)
        avio_rb16(pb);
    number_of_mdpr = avio_rb16(pb);
    if (number_of_mdpr != 1) {
        avpriv_request_sample(s, ""MLTI with multiple (%d) MDPR"", number_of_mdpr);
    }
    for (i = 0; i < number_of_mdpr; i++) {
        AVStream *st2;
        if (i > 0) {
            st2 = avformat_new_stream(s, NULL);
            if (!st2) {
                ret = AVERROR(ENOMEM);
                return ret;
            }
            st2->id = st->id + (i<<16);
            st2->codecpar->bit_rate = st->codecpar->bit_rate;
            st2->start_time = st->start_time;
            st2->duration   = st->duration;
            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;
            st2->priv_data = ff_rm_alloc_rmstream();
            if (!st2->priv_data)
                return AVERROR(ENOMEM);
        } else
            st2 = st;
 
         size2 = avio_rb32(pb);
         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,
                                        size2, NULL);
         if (ret < 0)
             return ret;
     }
    return 0;
}
","static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,
                         AVStream *st, char *mime)
{
    int number_of_streams = avio_rb16(pb);
    int number_of_mdpr;
    int i, ret;
    unsigned size2;
    for (i = 0; i<number_of_streams; i++)
        avio_rb16(pb);
    number_of_mdpr = avio_rb16(pb);
    if (number_of_mdpr != 1) {
        avpriv_request_sample(s, ""MLTI with multiple (%d) MDPR"", number_of_mdpr);
    }
    for (i = 0; i < number_of_mdpr; i++) {
        AVStream *st2;
        if (i > 0) {
            st2 = avformat_new_stream(s, NULL);
            if (!st2) {
                ret = AVERROR(ENOMEM);
                return ret;
            }
            st2->id = st->id + (i<<16);
            st2->codecpar->bit_rate = st->codecpar->bit_rate;
            st2->start_time = st->start_time;
            st2->duration   = st->duration;
            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;
            st2->priv_data = ff_rm_alloc_rmstream();
            if (!st2->priv_data)
                return AVERROR(ENOMEM);
        } else
            st2 = st;
 
         size2 = avio_rb32(pb);
         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,
                                        size2, mime);
         if (ret < 0)
             return ret;
     }
    return 0;
}
",C,"                                        size2, NULL);
","                                        size2, mime);
",,"@@ -522,7 +522,7 @@ static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,
 
         size2 = avio_rb32(pb);
         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,
-                                        size2, mime);
+                                        size2, NULL);
         if (ret < 0)
             return ret;
     }",FFmpeg,a7e032a277452366771951e29fd0bf2bd5c029f0,2b46ebdbff1d8dec7a3d8ea280a612b91a582869,1,"static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,
                         AVStream *st, char *mime)
{
    int number_of_streams = avio_rb16(pb);
    int number_of_mdpr;
    int i, ret;
    unsigned size2;
    for (i = 0; i<number_of_streams; i++)
        avio_rb16(pb);
    number_of_mdpr = avio_rb16(pb);
    if (number_of_mdpr != 1) {
        avpriv_request_sample(s, ""MLTI with multiple (%d) MDPR"", number_of_mdpr);
    }
    for (i = 0; i < number_of_mdpr; i++) {
        AVStream *st2;
        if (i > 0) {
            st2 = avformat_new_stream(s, NULL);
            if (!st2) {
                ret = AVERROR(ENOMEM);
                return ret;
            }
            st2->id = st->id + (i<<16);
            st2->codecpar->bit_rate = st->codecpar->bit_rate;
            st2->start_time = st->start_time;
            st2->duration   = st->duration;
            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;
            st2->priv_data = ff_rm_alloc_rmstream();
            if (!st2->priv_data)
                return AVERROR(ENOMEM);
        } else
            st2 = st;
 
         size2 = avio_rb32(pb);
         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,
//flaw_line_below:
                                        size2, mime);
//fix_flaw_line_below:
//                                        size2, NULL);
         if (ret < 0)
             return ret;
     }
    return 0;
}
",182096,"static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,
                         AVStream *st, char *mime)
{
    int number_of_streams = avio_rb16(pb);
    int number_of_mdpr;
    int i, ret;
    unsigned size2;
    for (i = 0; i<number_of_streams; i++)
        avio_rb16(pb);
    number_of_mdpr = avio_rb16(pb);
    if (number_of_mdpr != 1) {
        avpriv_request_sample(s, ""MLTI with multiple (%d) MDPR"", number_of_mdpr);
    }
    for (i = 0; i < number_of_mdpr; i++) {
        AVStream *st2;
        if (i > 0) {
            st2 = avformat_new_stream(s, NULL);
            if (!st2) {
                ret = AVERROR(ENOMEM);
                return ret;
            }
            st2->id = st->id + (i<<16);
            st2->codecpar->bit_rate = st->codecpar->bit_rate;
            st2->start_time = st->start_time;
            st2->duration   = st->duration;
            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;
            st2->priv_data = ff_rm_alloc_rmstream();
            if (!st2->priv_data)
                return AVERROR(ENOMEM);
        } else
            st2 = st;
 
         size2 = avio_rb32(pb);
         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,
                                        size2, mime);
         if (ret < 0)
             return ret;
     }
    return 0;
}
","static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,
                         AVStream *st, char *mime)
{
    int number_of_streams = avio_rb16(pb);
    int number_of_mdpr;
    int i, ret;
    unsigned size2;
    for (i = 0; i<number_of_streams; i++)
        avio_rb16(pb);
    number_of_mdpr = avio_rb16(pb);
    if (number_of_mdpr != 1) {
        avpriv_request_sample(s, ""MLTI with multiple (%d) MDPR"", number_of_mdpr);
    }
    for (i = 0; i < number_of_mdpr; i++) {
        AVStream *st2;
        if (i > 0) {
            st2 = avformat_new_stream(s, NULL);
            if (!st2) {
                ret = AVERROR(ENOMEM);
                return ret;
            }
            st2->id = st->id + (i<<16);
            st2->codecpar->bit_rate = st->codecpar->bit_rate;
            st2->start_time = st->start_time;
            st2->duration   = st->duration;
            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;
            st2->priv_data = ff_rm_alloc_rmstream();
            if (!st2->priv_data)
                return AVERROR(ENOMEM);
        } else
            st2 = st;
 
         size2 = avio_rb32(pb);
         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,
                                        size2, NULL);
         if (ret < 0)
             return ret;
     }
    return 0;
}
","The vulnerability in the original code arises from the use of the `mime` variable in the `ff_rm_read_mdpr_codecdata` function call, which could lead to potential information disclosure or memory corruption if `mime` is not properly validated or initialized. This could allow an attacker to manipulate the input, causing undefined behavior. In the fixed code, the `mime` parameter is replaced with `NULL`, effectively removing the risk associated with unvalidated input. This change ensures that the function operates without relying on potentially unsafe external data, thereby enhancing the overall security of the code.","The vulnerability in the original code stems from the potential for unvalidated input, which could lead to memory corruption or information disclosure. Specifically, the reliance on external data without proper checks allows an attacker to manipulate the input, resulting in undefined behavior during execution. In the revised code, this risk is mitigated by removing the problematic input entirely, replacing it with a safer alternative. This change ensures that the function no longer depends on potentially unsafe external data, thereby enhancing the security and stability of the code while preventing exploitation through malicious input."
41,182202,182202,,Remote,Not required,Partial,CVE-2018-16840,https://www.cvedetails.com/cve/CVE-2018-16840/,CWE-416,Low,Partial,Partial,,2018-10-31,7.5,"A heap use-after-free flaw was found in curl versions from 7.59.0 through 7.61.1 in the code related to closing an easy handle. When closing and cleaning up an 'easy' handle in the `Curl_close()` function, the library code first frees a struct (without nulling the pointer) and might then subsequently erroneously write to a struct field within that already freed struct.",2019-10-09,,3,https://github.com/curl/curl/commit/81d135d67155c5295b1033679c606165d4e28f3f,81d135d67155c5295b1033679c606165d4e28f3f,"Curl_close: clear data->multi_easy on free to avoid use-after-free

Regression from b46cfbc068 (7.59.0)
CVE-2018-16840
Reported-by: Brian Carpenter (Geeknik Labs)

Bug: https://curl.haxx.se/docs/CVE-2018-16840.html",1,lib/url.c,"{""sha"": ""0d5a13f99639b2444a8a1b1eeadf9be2fe036fd0"", ""filename"": ""lib/url.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/curl/curl/blob/81d135d67155c5295b1033679c606165d4e28f3f/lib/url.c"", ""raw_url"": ""https://github.com/curl/curl/raw/81d135d67155c5295b1033679c606165d4e28f3f/lib/url.c"", ""contents_url"": ""https://api.github.com/repos/curl/curl/contents/lib/url.c?ref=81d135d67155c5295b1033679c606165d4e28f3f"", ""patch"": ""@@ -331,10 +331,12 @@ CURLcode Curl_close(struct Curl_easy *data)\n        and detach this handle from there. */\n     curl_multi_remove_handle(data->multi, data);\n \n-  if(data->multi_easy)\n+  if(data->multi_easy) {\n     /* when curl_easy_perform() is used, it creates its own multi handle to\n        use and this is the one */\n     curl_multi_cleanup(data->multi_easy);\n+    data->multi_easy = NULL;\n+  }\n \n   /* Destroy the timeout list that is held in the easy handle. It is\n      /normally/ done by curl_multi_remove_handle() but this is \""just in""}","CURLcode Curl_close(struct Curl_easy *data)
{
  struct Curl_multi *m;

  if(!data)
    return CURLE_OK;

  Curl_expire_clear(data); /* shut off timers */

  m = data->multi;
  if(m)
    /* This handle is still part of a multi handle, take care of this first
        and detach this handle from there. */
     curl_multi_remove_handle(data->multi, data);
 
  if(data->multi_easy) {
     /* when curl_easy_perform() is used, it creates its own multi handle to
        use and this is the one */
     curl_multi_cleanup(data->multi_easy);
    data->multi_easy = NULL;
  }
 
   /* Destroy the timeout list that is held in the easy handle. It is
      /normally/ done by curl_multi_remove_handle() but this is ""just in
     case"" */
  Curl_llist_destroy(&data->state.timeoutlist, NULL);

  data->magic = 0; /* force a clear AFTER the possibly enforced removal from
                      the multi handle, since that function uses the magic
                      field! */

  if(data->state.rangestringalloc)
    free(data->state.range);

  /* freed here just in case DONE wasn't called */
  Curl_free_request_state(data);

  /* Close down all open SSL info and sessions */
  Curl_ssl_close_all(data);
  Curl_safefree(data->state.first_host);
  Curl_safefree(data->state.scratch);
  Curl_ssl_free_certinfo(data);

  /* Cleanup possible redirect junk */
  free(data->req.newurl);
  data->req.newurl = NULL;

  if(data->change.referer_alloc) {
    Curl_safefree(data->change.referer);
    data->change.referer_alloc = FALSE;
  }
  data->change.referer = NULL;

  Curl_up_free(data);
  Curl_safefree(data->state.buffer);
  Curl_safefree(data->state.headerbuff);
  Curl_safefree(data->state.ulbuf);
  Curl_flush_cookies(data, 1);
  Curl_digest_cleanup(data);
  Curl_safefree(data->info.contenttype);
  Curl_safefree(data->info.wouldredirect);

  /* this destroys the channel and we cannot use it anymore after this */
  Curl_resolver_cleanup(data->state.resolver);

  Curl_http2_cleanup_dependencies(data);
  Curl_convert_close(data);

  /* No longer a dirty share, if it exists */
  if(data->share) {
    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);
    data->share->dirty--;
    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);
  }

  /* destruct wildcard structures if it is needed */
  Curl_wildcard_dtor(&data->wildcard);
  Curl_freeset(data);
  free(data);
  return CURLE_OK;
}
","CURLcode Curl_close(struct Curl_easy *data)
{
  struct Curl_multi *m;

  if(!data)
    return CURLE_OK;

  Curl_expire_clear(data); /* shut off timers */

  m = data->multi;
  if(m)
    /* This handle is still part of a multi handle, take care of this first
        and detach this handle from there. */
     curl_multi_remove_handle(data->multi, data);
 
  if(data->multi_easy)
     /* when curl_easy_perform() is used, it creates its own multi handle to
        use and this is the one */
     curl_multi_cleanup(data->multi_easy);
 
   /* Destroy the timeout list that is held in the easy handle. It is
      /normally/ done by curl_multi_remove_handle() but this is ""just in
     case"" */
  Curl_llist_destroy(&data->state.timeoutlist, NULL);

  data->magic = 0; /* force a clear AFTER the possibly enforced removal from
                      the multi handle, since that function uses the magic
                      field! */

  if(data->state.rangestringalloc)
    free(data->state.range);

  /* freed here just in case DONE wasn't called */
  Curl_free_request_state(data);

  /* Close down all open SSL info and sessions */
  Curl_ssl_close_all(data);
  Curl_safefree(data->state.first_host);
  Curl_safefree(data->state.scratch);
  Curl_ssl_free_certinfo(data);

  /* Cleanup possible redirect junk */
  free(data->req.newurl);
  data->req.newurl = NULL;

  if(data->change.referer_alloc) {
    Curl_safefree(data->change.referer);
    data->change.referer_alloc = FALSE;
  }
  data->change.referer = NULL;

  Curl_up_free(data);
  Curl_safefree(data->state.buffer);
  Curl_safefree(data->state.headerbuff);
  Curl_safefree(data->state.ulbuf);
  Curl_flush_cookies(data, 1);
  Curl_digest_cleanup(data);
  Curl_safefree(data->info.contenttype);
  Curl_safefree(data->info.wouldredirect);

  /* this destroys the channel and we cannot use it anymore after this */
  Curl_resolver_cleanup(data->state.resolver);

  Curl_http2_cleanup_dependencies(data);
  Curl_convert_close(data);

  /* No longer a dirty share, if it exists */
  if(data->share) {
    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);
    data->share->dirty--;
    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);
  }

  /* destruct wildcard structures if it is needed */
  Curl_wildcard_dtor(&data->wildcard);
  Curl_freeset(data);
  free(data);
  return CURLE_OK;
}
",C,"  if(data->multi_easy) {
    data->multi_easy = NULL;
  }
","  if(data->multi_easy)
",,"@@ -331,10 +331,12 @@ CURLcode Curl_close(struct Curl_easy *data)
        and detach this handle from there. */
     curl_multi_remove_handle(data->multi, data);
 
-  if(data->multi_easy)
+  if(data->multi_easy) {
     /* when curl_easy_perform() is used, it creates its own multi handle to
        use and this is the one */
     curl_multi_cleanup(data->multi_easy);
+    data->multi_easy = NULL;
+  }
 
   /* Destroy the timeout list that is held in the easy handle. It is
      /normally/ done by curl_multi_remove_handle() but this is ""just in",curl,81d135d67155c5295b1033679c606165d4e28f3f,9d8dad1a9d79d60e021f0c4e0f66bf5d51fb3c4e,1,"CURLcode Curl_close(struct Curl_easy *data)
{
  struct Curl_multi *m;

  if(!data)
    return CURLE_OK;

  Curl_expire_clear(data); /* shut off timers */

  m = data->multi;
  if(m)
    /* This handle is still part of a multi handle, take care of this first
        and detach this handle from there. */
     curl_multi_remove_handle(data->multi, data);
 
//flaw_line_below:
  if(data->multi_easy)
//fix_flaw_line_below:
//  if(data->multi_easy) {
     /* when curl_easy_perform() is used, it creates its own multi handle to
        use and this is the one */
     curl_multi_cleanup(data->multi_easy);
//fix_flaw_line_below:
//    data->multi_easy = NULL;
//fix_flaw_line_below:
//  }
 
   /* Destroy the timeout list that is held in the easy handle. It is
      /normally/ done by curl_multi_remove_handle() but this is ""just in
     case"" */
  Curl_llist_destroy(&data->state.timeoutlist, NULL);

  data->magic = 0; /* force a clear AFTER the possibly enforced removal from
                      the multi handle, since that function uses the magic
                      field! */

  if(data->state.rangestringalloc)
    free(data->state.range);

  /* freed here just in case DONE wasn't called */
  Curl_free_request_state(data);

  /* Close down all open SSL info and sessions */
  Curl_ssl_close_all(data);
  Curl_safefree(data->state.first_host);
  Curl_safefree(data->state.scratch);
  Curl_ssl_free_certinfo(data);

  /* Cleanup possible redirect junk */
  free(data->req.newurl);
  data->req.newurl = NULL;

  if(data->change.referer_alloc) {
    Curl_safefree(data->change.referer);
    data->change.referer_alloc = FALSE;
  }
  data->change.referer = NULL;

  Curl_up_free(data);
  Curl_safefree(data->state.buffer);
  Curl_safefree(data->state.headerbuff);
  Curl_safefree(data->state.ulbuf);
  Curl_flush_cookies(data, 1);
  Curl_digest_cleanup(data);
  Curl_safefree(data->info.contenttype);
  Curl_safefree(data->info.wouldredirect);

  /* this destroys the channel and we cannot use it anymore after this */
  Curl_resolver_cleanup(data->state.resolver);

  Curl_http2_cleanup_dependencies(data);
  Curl_convert_close(data);

  /* No longer a dirty share, if it exists */
  if(data->share) {
    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);
    data->share->dirty--;
    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);
  }

  /* destruct wildcard structures if it is needed */
  Curl_wildcard_dtor(&data->wildcard);
  Curl_freeset(data);
  free(data);
  return CURLE_OK;
}
",182202,"CURLcode Curl_close(struct Curl_easy *data)
{
  struct Curl_multi *m;

  if(!data)
    return CURLE_OK;

  Curl_expire_clear(data); /* shut off timers */

  m = data->multi;
  if(m)
    /* This handle is still part of a multi handle, take care of this first
        and detach this handle from there. */
     curl_multi_remove_handle(data->multi, data);
 
  if(data->multi_easy)
     /* when curl_easy_perform() is used, it creates its own multi handle to
        use and this is the one */
     curl_multi_cleanup(data->multi_easy);
 
   /* Destroy the timeout list that is held in the easy handle. It is
      /normally/ done by curl_multi_remove_handle() but this is ""just in
     case"" */
  Curl_llist_destroy(&data->state.timeoutlist, NULL);

  data->magic = 0; /* force a clear AFTER the possibly enforced removal from
                      the multi handle, since that function uses the magic
                      field! */

  if(data->state.rangestringalloc)
    free(data->state.range);

  /* freed here just in case DONE wasn't called */
  Curl_free_request_state(data);

  /* Close down all open SSL info and sessions */
  Curl_ssl_close_all(data);
  Curl_safefree(data->state.first_host);
  Curl_safefree(data->state.scratch);
  Curl_ssl_free_certinfo(data);

  /* Cleanup possible redirect junk */
  free(data->req.newurl);
  data->req.newurl = NULL;

  if(data->change.referer_alloc) {
    Curl_safefree(data->change.referer);
    data->change.referer_alloc = FALSE;
  }
  data->change.referer = NULL;

  Curl_up_free(data);
  Curl_safefree(data->state.buffer);
  Curl_safefree(data->state.headerbuff);
  Curl_safefree(data->state.ulbuf);
  Curl_flush_cookies(data, 1);
  Curl_digest_cleanup(data);
  Curl_safefree(data->info.contenttype);
  Curl_safefree(data->info.wouldredirect);

  /* this destroys the channel and we cannot use it anymore after this */
  Curl_resolver_cleanup(data->state.resolver);

  Curl_http2_cleanup_dependencies(data);
  Curl_convert_close(data);

  /* No longer a dirty share, if it exists */
  if(data->share) {
    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);
    data->share->dirty--;
    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);
  }

  /* destruct wildcard structures if it is needed */
  Curl_wildcard_dtor(&data->wildcard);
  Curl_freeset(data);
  free(data);
  return CURLE_OK;
}
","CURLcode Curl_close(struct Curl_easy *data)
{
  struct Curl_multi *m;

  if(!data)
    return CURLE_OK;

  Curl_expire_clear(data); /* shut off timers */

  m = data->multi;
  if(m)
    /* This handle is still part of a multi handle, take care of this first
        and detach this handle from there. */
     curl_multi_remove_handle(data->multi, data);
 
  if(data->multi_easy) {
     /* when curl_easy_perform() is used, it creates its own multi handle to
        use and this is the one */
     curl_multi_cleanup(data->multi_easy);
    data->multi_easy = NULL;
  }
 
   /* Destroy the timeout list that is held in the easy handle. It is
      /normally/ done by curl_multi_remove_handle() but this is ""just in
     case"" */
  Curl_llist_destroy(&data->state.timeoutlist, NULL);

  data->magic = 0; /* force a clear AFTER the possibly enforced removal from
                      the multi handle, since that function uses the magic
                      field! */

  if(data->state.rangestringalloc)
    free(data->state.range);

  /* freed here just in case DONE wasn't called */
  Curl_free_request_state(data);

  /* Close down all open SSL info and sessions */
  Curl_ssl_close_all(data);
  Curl_safefree(data->state.first_host);
  Curl_safefree(data->state.scratch);
  Curl_ssl_free_certinfo(data);

  /* Cleanup possible redirect junk */
  free(data->req.newurl);
  data->req.newurl = NULL;

  if(data->change.referer_alloc) {
    Curl_safefree(data->change.referer);
    data->change.referer_alloc = FALSE;
  }
  data->change.referer = NULL;

  Curl_up_free(data);
  Curl_safefree(data->state.buffer);
  Curl_safefree(data->state.headerbuff);
  Curl_safefree(data->state.ulbuf);
  Curl_flush_cookies(data, 1);
  Curl_digest_cleanup(data);
  Curl_safefree(data->info.contenttype);
  Curl_safefree(data->info.wouldredirect);

  /* this destroys the channel and we cannot use it anymore after this */
  Curl_resolver_cleanup(data->state.resolver);

  Curl_http2_cleanup_dependencies(data);
  Curl_convert_close(data);

  /* No longer a dirty share, if it exists */
  if(data->share) {
    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);
    data->share->dirty--;
    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);
  }

  /* destruct wildcard structures if it is needed */
  Curl_wildcard_dtor(&data->wildcard);
  Curl_freeset(data);
  free(data);
  return CURLE_OK;
}
","The vulnerability in the original code lies in the handling of the `data->multi_easy` pointer, which, if not set to `NULL` after cleanup, could lead to a use-after-free error. This occurs because the pointer may still reference freed memory, potentially allowing for undefined behavior or exploitation. In the fixed code, the line `data->multi_easy = NULL;` was added after the `curl_multi_cleanup(data->multi_easy);` call. This ensures that after the cleanup, the pointer is explicitly set to `NULL`, preventing any accidental access to freed memory and enhancing the overall safety of the code.","The vulnerability in the original code stems from improper management of a pointer that could still reference freed memory after cleanup, leading to potential use-after-free errors. This situation could allow an attacker to exploit the program by accessing or manipulating memory that has already been deallocated, resulting in undefined behavior or crashes. The fix involved explicitly setting the pointer to `NULL` after the cleanup process. This change ensures that any subsequent attempts to access the pointer will not reference invalid memory, thereby enhancing the safety and stability of the code by preventing accidental access to freed resources."
42,182265,182265,,Local,Not required,Partial,CVE-2018-15857,https://www.cvedetails.com/cve/CVE-2018-15857/,CWE-416,Low,Partial,Partial,,2018-08-25,4.6,An invalid free in ExprAppendMultiKeysymList in xkbcomp/ast-build.c in xkbcommon before 0.8.1 could be used by local attackers to crash xkbcommon keymap parsers or possibly have unspecified other impact by supplying a crafted keymap file.,2019-08-06,,1,https://github.com/xkbcommon/libxkbcommon/commit/c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb,c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb,"xkbcomp: fix pointer value for FreeStmt

Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>",1,src/xkbcomp/ast-build.c,"{""sha"": ""2de9e61dbd6655ab4e834158f3632d37c0d535e5"", ""filename"": ""src/xkbcomp/ast-build.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/xkbcommon/libxkbcommon/blob/c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb/src/xkbcomp/ast-build.c"", ""raw_url"": ""https://github.com/xkbcommon/libxkbcommon/raw/c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb/src/xkbcomp/ast-build.c"", ""contents_url"": ""https://api.github.com/repos/xkbcommon/libxkbcommon/contents/src/xkbcomp/ast-build.c?ref=c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb"", ""patch"": ""@@ -240,7 +240,7 @@ ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n     darray_append(expr->keysym_list.symsNumEntries, numEntries);\n     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n \n-    FreeStmt((ParseCommon *) &append);\n+    FreeStmt((ParseCommon *) append);\n \n     return expr;\n }""}","ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)
{
    unsigned nSyms = darray_size(expr->keysym_list.syms);
    unsigned numEntries = darray_size(append->keysym_list.syms);

    darray_append(expr->keysym_list.symsMapIndex, nSyms);
     darray_append(expr->keysym_list.symsNumEntries, numEntries);
     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);
 
    FreeStmt((ParseCommon *) append);
 
     return expr;
 }
","ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)
{
    unsigned nSyms = darray_size(expr->keysym_list.syms);
    unsigned numEntries = darray_size(append->keysym_list.syms);

    darray_append(expr->keysym_list.symsMapIndex, nSyms);
     darray_append(expr->keysym_list.symsNumEntries, numEntries);
     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);
 
    FreeStmt((ParseCommon *) &append);
 
     return expr;
 }
",C,"    FreeStmt((ParseCommon *) append);
","    FreeStmt((ParseCommon *) &append);
",,"@@ -240,7 +240,7 @@ ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)
     darray_append(expr->keysym_list.symsNumEntries, numEntries);
     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);
 
-    FreeStmt((ParseCommon *) &append);
+    FreeStmt((ParseCommon *) append);
 
     return expr;
 }",libxkbcommon,c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb,badb428e63387140720f22486b3acbd3d738859f,1,"ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)
{
    unsigned nSyms = darray_size(expr->keysym_list.syms);
    unsigned numEntries = darray_size(append->keysym_list.syms);

    darray_append(expr->keysym_list.symsMapIndex, nSyms);
     darray_append(expr->keysym_list.symsNumEntries, numEntries);
     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);
 
//flaw_line_below:
    FreeStmt((ParseCommon *) &append);
//fix_flaw_line_below:
//    FreeStmt((ParseCommon *) append);
 
     return expr;
 }
",182265,"ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)
{
    unsigned nSyms = darray_size(expr->keysym_list.syms);
    unsigned numEntries = darray_size(append->keysym_list.syms);

    darray_append(expr->keysym_list.symsMapIndex, nSyms);
     darray_append(expr->keysym_list.symsNumEntries, numEntries);
     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);
 
    FreeStmt((ParseCommon *) &append);
 
     return expr;
 }
","ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)
{
    unsigned nSyms = darray_size(expr->keysym_list.syms);
    unsigned numEntries = darray_size(append->keysym_list.syms);

    darray_append(expr->keysym_list.symsMapIndex, nSyms);
     darray_append(expr->keysym_list.symsNumEntries, numEntries);
     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);
 
    FreeStmt((ParseCommon *) append);
 
     return expr;
 }
","The vulnerability in the original code arises from the incorrect handling of the `append` variable in the `FreeStmt` function, where it is cast to a pointer type and dereferenced, potentially leading to undefined behavior if `append` is modified or freed elsewhere. This could result in a double-free vulnerability or memory corruption. In the fixed code, the `FreeStmt` function now correctly uses `append` directly without casting it to a pointer type, ensuring that the memory management is handled safely and reducing the risk of memory-related vulnerabilities. This change enhances the overall stability and security of the function.","The vulnerability in the original code stems from improper memory management, specifically related to the handling of a pointer that could lead to undefined behavior. By casting the pointer to a different type before freeing it, the code risks dereferencing an invalid memory location, which could result in double-free errors or memory corruption. The fixed code addresses this issue by directly using the pointer without casting, ensuring that the memory is freed correctly and safely. This change enhances the reliability of the function and mitigates potential security risks associated with improper memory handling."
43,182282,182282,,Local,Not required,Complete,CVE-2018-14734,https://www.cvedetails.com/cve/CVE-2018-14734/,CWE-416,Low,Partial,Partial,,2018-07-29,6.1,"drivers/infiniband/core/ucma.c in the Linux kernel through 4.17.11 allows ucma_leave_multicast to access a certain data structure after a cleanup step in ucma_process_join, which allows attackers to cause a denial of service (use-after-free).",2019-04-23,DoS ,4,https://github.com/torvalds/linux/commit/cb2595c1393b4a5211534e6f0a0fbad369e21ad8,cb2595c1393b4a5211534e6f0a0fbad369e21ad8,"infiniband: fix a possible use-after-free bug

ucma_process_join() will free the new allocated ""mc"" struct,
if there is any error after that, especially the copy_to_user().

But in parallel, ucma_leave_multicast() could find this ""mc""
through idr_find() before ucma_process_join() frees it, since it
is already published.

So ""mc"" could be used in ucma_leave_multicast() after it is been
allocated and freed in ucma_process_join(), since we don't refcnt
it.

Fix this by separating ""publish"" from ID allocation, so that we
can get an ID first and publish it later after copy_to_user().

Fixes: c8f6a362bf3e (""RDMA/cma: Add multicast communication support"")
Reported-by: Noam Rathaus <noamr@beyondsecurity.com>
Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>",0,drivers/infiniband/core/ucma.c,"{""sha"": ""ec8fb289621fb7590dd3e3f4000967fa2b6c9aae"", ""filename"": ""drivers/infiniband/core/ucma.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/cb2595c1393b4a5211534e6f0a0fbad369e21ad8/drivers/infiniband/core/ucma.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/cb2595c1393b4a5211534e6f0a0fbad369e21ad8/drivers/infiniband/core/ucma.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/infiniband/core/ucma.c?ref=cb2595c1393b4a5211534e6f0a0fbad369e21ad8"", ""patch"": ""@@ -235,7 +235,7 @@ static struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)\n \t\treturn NULL;\n \n \tmutex_lock(&mut);\n-\tmc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);\n+\tmc->id = idr_alloc(&multicast_idr, NULL, 0, 0, GFP_KERNEL);\n \tmutex_unlock(&mut);\n \tif (mc->id < 0)\n \t\tgoto error;\n@@ -1421,6 +1421,10 @@ static ssize_t ucma_process_join(struct ucma_file *file,\n \t\tgoto err3;\n \t}\n \n+\tmutex_lock(&mut);\n+\tidr_replace(&multicast_idr, mc, mc->id);\n+\tmutex_unlock(&mut);\n+\n \tmutex_unlock(&file->mut);\n \tucma_put_ctx(ctx);\n \treturn 0;""}","static ssize_t ucma_process_join(struct ucma_file *file,
				 struct rdma_ucm_join_mcast *cmd,  int out_len)
{
	struct rdma_ucm_create_id_resp resp;
	struct ucma_context *ctx;
	struct ucma_multicast *mc;
	struct sockaddr *addr;
	int ret;
	u8 join_state;

	if (out_len < sizeof(resp))
		return -ENOSPC;

	addr = (struct sockaddr *) &cmd->addr;
	if (cmd->addr_size != rdma_addr_size(addr))
		return -EINVAL;

	if (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)
		join_state = BIT(FULLMEMBER_JOIN);
	else if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)
		join_state = BIT(SENDONLY_FULLMEMBER_JOIN);
	else
		return -EINVAL;

	ctx = ucma_get_ctx_dev(file, cmd->id);
	if (IS_ERR(ctx))
		return PTR_ERR(ctx);

	mutex_lock(&file->mut);
	mc = ucma_alloc_multicast(ctx);
	if (!mc) {
		ret = -ENOMEM;
		goto err1;
	}
	mc->join_state = join_state;
	mc->uid = cmd->uid;
	memcpy(&mc->addr, addr, cmd->addr_size);
	ret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,
				  join_state, mc);
	if (ret)
		goto err2;

	resp.id = mc->id;
	if (copy_to_user(u64_to_user_ptr(cmd->response),
			 &resp, sizeof(resp))) {
		ret = -EFAULT;
 		goto err3;
 	}
 
	mutex_lock(&mut);
	idr_replace(&multicast_idr, mc, mc->id);
	mutex_unlock(&mut);

 	mutex_unlock(&file->mut);
 	ucma_put_ctx(ctx);
 	return 0;

err3:
	rdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);
	ucma_cleanup_mc_events(mc);
err2:
	mutex_lock(&mut);
	idr_remove(&multicast_idr, mc->id);
	mutex_unlock(&mut);
	list_del(&mc->list);
	kfree(mc);
err1:
	mutex_unlock(&file->mut);
	ucma_put_ctx(ctx);
	return ret;
}
","static ssize_t ucma_process_join(struct ucma_file *file,
				 struct rdma_ucm_join_mcast *cmd,  int out_len)
{
	struct rdma_ucm_create_id_resp resp;
	struct ucma_context *ctx;
	struct ucma_multicast *mc;
	struct sockaddr *addr;
	int ret;
	u8 join_state;

	if (out_len < sizeof(resp))
		return -ENOSPC;

	addr = (struct sockaddr *) &cmd->addr;
	if (cmd->addr_size != rdma_addr_size(addr))
		return -EINVAL;

	if (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)
		join_state = BIT(FULLMEMBER_JOIN);
	else if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)
		join_state = BIT(SENDONLY_FULLMEMBER_JOIN);
	else
		return -EINVAL;

	ctx = ucma_get_ctx_dev(file, cmd->id);
	if (IS_ERR(ctx))
		return PTR_ERR(ctx);

	mutex_lock(&file->mut);
	mc = ucma_alloc_multicast(ctx);
	if (!mc) {
		ret = -ENOMEM;
		goto err1;
	}
	mc->join_state = join_state;
	mc->uid = cmd->uid;
	memcpy(&mc->addr, addr, cmd->addr_size);
	ret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,
				  join_state, mc);
	if (ret)
		goto err2;

	resp.id = mc->id;
	if (copy_to_user(u64_to_user_ptr(cmd->response),
			 &resp, sizeof(resp))) {
		ret = -EFAULT;
 		goto err3;
 	}
 
 	mutex_unlock(&file->mut);
 	ucma_put_ctx(ctx);
 	return 0;

err3:
	rdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);
	ucma_cleanup_mc_events(mc);
err2:
	mutex_lock(&mut);
	idr_remove(&multicast_idr, mc->id);
	mutex_unlock(&mut);
	list_del(&mc->list);
	kfree(mc);
err1:
	mutex_unlock(&file->mut);
	ucma_put_ctx(ctx);
	return ret;
}
",C,"	mutex_lock(&mut);
	idr_replace(&multicast_idr, mc, mc->id);
	mutex_unlock(&mut);

",,,"@@ -235,7 +235,7 @@ static struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)
 		return NULL;
 
 	mutex_lock(&mut);
-	mc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);
+	mc->id = idr_alloc(&multicast_idr, NULL, 0, 0, GFP_KERNEL);
 	mutex_unlock(&mut);
 	if (mc->id < 0)
 		goto error;
@@ -1421,6 +1421,10 @@ static ssize_t ucma_process_join(struct ucma_file *file,
 		goto err3;
 	}
 
+	mutex_lock(&mut);
+	idr_replace(&multicast_idr, mc, mc->id);
+	mutex_unlock(&mut);
+
 	mutex_unlock(&file->mut);
 	ucma_put_ctx(ctx);
 	return 0;",linux,cb2595c1393b4a5211534e6f0a0fbad369e21ad8,e4b1672ac0a54c7740cbc4ff39dfdc56182236cb,1,"static ssize_t ucma_process_join(struct ucma_file *file,
				 struct rdma_ucm_join_mcast *cmd,  int out_len)
{
	struct rdma_ucm_create_id_resp resp;
	struct ucma_context *ctx;
	struct ucma_multicast *mc;
	struct sockaddr *addr;
	int ret;
	u8 join_state;

	if (out_len < sizeof(resp))
		return -ENOSPC;

	addr = (struct sockaddr *) &cmd->addr;
	if (cmd->addr_size != rdma_addr_size(addr))
		return -EINVAL;

	if (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)
		join_state = BIT(FULLMEMBER_JOIN);
	else if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)
		join_state = BIT(SENDONLY_FULLMEMBER_JOIN);
	else
		return -EINVAL;

	ctx = ucma_get_ctx_dev(file, cmd->id);
	if (IS_ERR(ctx))
		return PTR_ERR(ctx);

	mutex_lock(&file->mut);
	mc = ucma_alloc_multicast(ctx);
	if (!mc) {
		ret = -ENOMEM;
		goto err1;
	}
	mc->join_state = join_state;
	mc->uid = cmd->uid;
	memcpy(&mc->addr, addr, cmd->addr_size);
	ret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,
				  join_state, mc);
	if (ret)
		goto err2;

	resp.id = mc->id;
	if (copy_to_user(u64_to_user_ptr(cmd->response),
			 &resp, sizeof(resp))) {
		ret = -EFAULT;
 		goto err3;
 	}
 
//fix_flaw_line_below:
//	mutex_lock(&mut);
//fix_flaw_line_below:
//	idr_replace(&multicast_idr, mc, mc->id);
//fix_flaw_line_below:
//	mutex_unlock(&mut);
//fix_flaw_line_below:
//
 	mutex_unlock(&file->mut);
 	ucma_put_ctx(ctx);
 	return 0;

err3:
	rdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);
	ucma_cleanup_mc_events(mc);
err2:
	mutex_lock(&mut);
	idr_remove(&multicast_idr, mc->id);
	mutex_unlock(&mut);
	list_del(&mc->list);
	kfree(mc);
err1:
	mutex_unlock(&file->mut);
	ucma_put_ctx(ctx);
	return ret;
}
",182282,"static ssize_t ucma_process_join(struct ucma_file *file,
				 struct rdma_ucm_join_mcast *cmd,  int out_len)
{
	struct rdma_ucm_create_id_resp resp;
	struct ucma_context *ctx;
	struct ucma_multicast *mc;
	struct sockaddr *addr;
	int ret;
	u8 join_state;

	if (out_len < sizeof(resp))
		return -ENOSPC;

	addr = (struct sockaddr *) &cmd->addr;
	if (cmd->addr_size != rdma_addr_size(addr))
		return -EINVAL;

	if (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)
		join_state = BIT(FULLMEMBER_JOIN);
	else if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)
		join_state = BIT(SENDONLY_FULLMEMBER_JOIN);
	else
		return -EINVAL;

	ctx = ucma_get_ctx_dev(file, cmd->id);
	if (IS_ERR(ctx))
		return PTR_ERR(ctx);

	mutex_lock(&file->mut);
	mc = ucma_alloc_multicast(ctx);
	if (!mc) {
		ret = -ENOMEM;
		goto err1;
	}
	mc->join_state = join_state;
	mc->uid = cmd->uid;
	memcpy(&mc->addr, addr, cmd->addr_size);
	ret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,
				  join_state, mc);
	if (ret)
		goto err2;

	resp.id = mc->id;
	if (copy_to_user(u64_to_user_ptr(cmd->response),
			 &resp, sizeof(resp))) {
		ret = -EFAULT;
 		goto err3;
 	}
 
 	mutex_unlock(&file->mut);
 	ucma_put_ctx(ctx);
 	return 0;

err3:
	rdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);
	ucma_cleanup_mc_events(mc);
err2:
	mutex_lock(&mut);
	idr_remove(&multicast_idr, mc->id);
	mutex_unlock(&mut);
	list_del(&mc->list);
	kfree(mc);
err1:
	mutex_unlock(&file->mut);
	ucma_put_ctx(ctx);
	return ret;
}
","static ssize_t ucma_process_join(struct ucma_file *file,
				 struct rdma_ucm_join_mcast *cmd,  int out_len)
{
	struct rdma_ucm_create_id_resp resp;
	struct ucma_context *ctx;
	struct ucma_multicast *mc;
	struct sockaddr *addr;
	int ret;
	u8 join_state;

	if (out_len < sizeof(resp))
		return -ENOSPC;

	addr = (struct sockaddr *) &cmd->addr;
	if (cmd->addr_size != rdma_addr_size(addr))
		return -EINVAL;

	if (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)
		join_state = BIT(FULLMEMBER_JOIN);
	else if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)
		join_state = BIT(SENDONLY_FULLMEMBER_JOIN);
	else
		return -EINVAL;

	ctx = ucma_get_ctx_dev(file, cmd->id);
	if (IS_ERR(ctx))
		return PTR_ERR(ctx);

	mutex_lock(&file->mut);
	mc = ucma_alloc_multicast(ctx);
	if (!mc) {
		ret = -ENOMEM;
		goto err1;
	}
	mc->join_state = join_state;
	mc->uid = cmd->uid;
	memcpy(&mc->addr, addr, cmd->addr_size);
	ret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,
				  join_state, mc);
	if (ret)
		goto err2;

	resp.id = mc->id;
	if (copy_to_user(u64_to_user_ptr(cmd->response),
			 &resp, sizeof(resp))) {
		ret = -EFAULT;
 		goto err3;
 	}
 
	mutex_lock(&mut);
	idr_replace(&multicast_idr, mc, mc->id);
	mutex_unlock(&mut);

 	mutex_unlock(&file->mut);
 	ucma_put_ctx(ctx);
 	return 0;

err3:
	rdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);
	ucma_cleanup_mc_events(mc);
err2:
	mutex_lock(&mut);
	idr_remove(&multicast_idr, mc->id);
	mutex_unlock(&mut);
	list_del(&mc->list);
	kfree(mc);
err1:
	mutex_unlock(&file->mut);
	ucma_put_ctx(ctx);
	return ret;
}
","The vulnerability in the original code lies in the handling of multicast identifiers, specifically the use of `idr_remove(&multicast_idr, mc->id)` without ensuring that the multicast context (`mc`) is properly updated or replaced in the IDR structure. This could lead to a situation where an invalid or stale ID is referenced, potentially causing memory corruption or access violations. The fix introduces `idr_replace(&multicast_idr, mc, mc->id)` before unlocking the mutex, ensuring that the multicast context is correctly updated in the IDR structure, thereby preventing the misuse of identifiers and enhancing overall stability and security.","The vulnerability in the original code stems from improper management of resources related to multicast identifiers, which could lead to memory corruption or access violations. Specifically, the code removed identifiers without ensuring that the associated context was correctly updated, risking the use of stale or invalid references. The fix addresses this issue by replacing the identifier in the management structure before releasing the associated resources. This change ensures that the system maintains accurate and valid references, thereby enhancing stability and preventing potential exploitation through incorrect memory access or resource handling."
44,182371,182371,,Remote,Not required,Partial,CVE-2018-12320,https://www.cvedetails.com/cve/CVE-2018-12320/,CWE-416,Medium,Partial,Partial,,2018-06-13,6.8,There is a use after free in radare2 2.6.0 in r_anal_bb_free() in libr/anal/bb.c via a crafted Java binary file.,2018-08-02,,5,https://github.com/radare/radare2/commit/90b71c017a7fa9732fe45fd21b245ee051b1f548,90b71c017a7fa9732fe45fd21b245ee051b1f548,Fix #10293 - Use-after-free in r_anal_bb_free(),1,libr/anal/bb.c,"{""sha"": ""a693c55856df26689b41121ed86457107e37602d"", ""filename"": ""libr/anal/bb.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/radareorg/radare2/blob/90b71c017a7fa9732fe45fd21b245ee051b1f548/libr/anal/bb.c"", ""raw_url"": ""https://github.com/radareorg/radare2/raw/90b71c017a7fa9732fe45fd21b245ee051b1f548/libr/anal/bb.c"", ""contents_url"": ""https://api.github.com/repos/radareorg/radare2/contents/libr/anal/bb.c?ref=90b71c017a7fa9732fe45fd21b245ee051b1f548"", ""patch"": ""@@ -62,7 +62,11 @@ R_API void r_anal_bb_free(RAnalBlock *bb) {\n \t\tbb->failbb->prev = NULL;\n \t\tbb->failbb = NULL;\n \t}\n-\tR_FREE (bb);\n+\tif (bb->next) {\n+\t\t// avoid double free\n+\t\tbb->next->prev = NULL;\n+\t}\n+\tR_FREE (bb); // double free\n }\n \n R_API RList *r_anal_bb_list_new() {""}","R_API void r_anal_bb_free(RAnalBlock *bb) {
	if (!bb) {
		return;
	}
	r_anal_cond_free (bb->cond);
	R_FREE (bb->fingerprint);
	r_anal_diff_free (bb->diff);
	bb->diff = NULL;
	R_FREE (bb->op_bytes);
	r_anal_switch_op_free (bb->switch_op);
	bb->switch_op = NULL;
	bb->fingerprint = NULL;
	bb->cond = NULL;
	R_FREE (bb->label);
	R_FREE (bb->op_pos);
	R_FREE (bb->parent_reg_arena);
	if (bb->prev) {
		if (bb->prev->jumpbb == bb) {
			bb->prev->jumpbb = NULL;
		}
		if (bb->prev->failbb == bb) {
			bb->prev->failbb = NULL;
		}
		bb->prev = NULL;
	}
	if (bb->jumpbb) {
		bb->jumpbb->prev = NULL;
		bb->jumpbb = NULL;
	}
	if (bb->failbb) {
 		bb->failbb->prev = NULL;
 		bb->failbb = NULL;
 	}
	if (bb->next) {
		// avoid double free
		bb->next->prev = NULL;
	}
	R_FREE (bb); // double free
 }
","R_API void r_anal_bb_free(RAnalBlock *bb) {
	if (!bb) {
		return;
	}
	r_anal_cond_free (bb->cond);
	R_FREE (bb->fingerprint);
	r_anal_diff_free (bb->diff);
	bb->diff = NULL;
	R_FREE (bb->op_bytes);
	r_anal_switch_op_free (bb->switch_op);
	bb->switch_op = NULL;
	bb->fingerprint = NULL;
	bb->cond = NULL;
	R_FREE (bb->label);
	R_FREE (bb->op_pos);
	R_FREE (bb->parent_reg_arena);
	if (bb->prev) {
		if (bb->prev->jumpbb == bb) {
			bb->prev->jumpbb = NULL;
		}
		if (bb->prev->failbb == bb) {
			bb->prev->failbb = NULL;
		}
		bb->prev = NULL;
	}
	if (bb->jumpbb) {
		bb->jumpbb->prev = NULL;
		bb->jumpbb = NULL;
	}
	if (bb->failbb) {
 		bb->failbb->prev = NULL;
 		bb->failbb = NULL;
 	}
	R_FREE (bb);
 }
",C,"	if (bb->next) {
		// avoid double free
		bb->next->prev = NULL;
	}
	R_FREE (bb); // double free
","	R_FREE (bb);
",,"@@ -62,7 +62,11 @@ R_API void r_anal_bb_free(RAnalBlock *bb) {
 		bb->failbb->prev = NULL;
 		bb->failbb = NULL;
 	}
-	R_FREE (bb);
+	if (bb->next) {
+		// avoid double free
+		bb->next->prev = NULL;
+	}
+	R_FREE (bb); // double free
 }
 
 R_API RList *r_anal_bb_list_new() {",radare2,90b71c017a7fa9732fe45fd21b245ee051b1f548,224e6bc13fa353dd3b7f7a2334588f1c4229e58d,1,"R_API void r_anal_bb_free(RAnalBlock *bb) {
	if (!bb) {
		return;
	}
	r_anal_cond_free (bb->cond);
	R_FREE (bb->fingerprint);
	r_anal_diff_free (bb->diff);
	bb->diff = NULL;
	R_FREE (bb->op_bytes);
	r_anal_switch_op_free (bb->switch_op);
	bb->switch_op = NULL;
	bb->fingerprint = NULL;
	bb->cond = NULL;
	R_FREE (bb->label);
	R_FREE (bb->op_pos);
	R_FREE (bb->parent_reg_arena);
	if (bb->prev) {
		if (bb->prev->jumpbb == bb) {
			bb->prev->jumpbb = NULL;
		}
		if (bb->prev->failbb == bb) {
			bb->prev->failbb = NULL;
		}
		bb->prev = NULL;
	}
	if (bb->jumpbb) {
		bb->jumpbb->prev = NULL;
		bb->jumpbb = NULL;
	}
	if (bb->failbb) {
 		bb->failbb->prev = NULL;
 		bb->failbb = NULL;
 	}
//flaw_line_below:
	R_FREE (bb);
//fix_flaw_line_below:
//	if (bb->next) {
//fix_flaw_line_below:
//		// avoid double free
//fix_flaw_line_below:
//		bb->next->prev = NULL;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//	R_FREE (bb); // double free
 }
",182371,"R_API void r_anal_bb_free(RAnalBlock *bb) {
	if (!bb) {
		return;
	}
	r_anal_cond_free (bb->cond);
	R_FREE (bb->fingerprint);
	r_anal_diff_free (bb->diff);
	bb->diff = NULL;
	R_FREE (bb->op_bytes);
	r_anal_switch_op_free (bb->switch_op);
	bb->switch_op = NULL;
	bb->fingerprint = NULL;
	bb->cond = NULL;
	R_FREE (bb->label);
	R_FREE (bb->op_pos);
	R_FREE (bb->parent_reg_arena);
	if (bb->prev) {
		if (bb->prev->jumpbb == bb) {
			bb->prev->jumpbb = NULL;
		}
		if (bb->prev->failbb == bb) {
			bb->prev->failbb = NULL;
		}
		bb->prev = NULL;
	}
	if (bb->jumpbb) {
		bb->jumpbb->prev = NULL;
		bb->jumpbb = NULL;
	}
	if (bb->failbb) {
 		bb->failbb->prev = NULL;
 		bb->failbb = NULL;
 	}
	R_FREE (bb);
 }
","R_API void r_anal_bb_free(RAnalBlock *bb) {
	if (!bb) {
		return;
	}
	r_anal_cond_free (bb->cond);
	R_FREE (bb->fingerprint);
	r_anal_diff_free (bb->diff);
	bb->diff = NULL;
	R_FREE (bb->op_bytes);
	r_anal_switch_op_free (bb->switch_op);
	bb->switch_op = NULL;
	bb->fingerprint = NULL;
	bb->cond = NULL;
	R_FREE (bb->label);
	R_FREE (bb->op_pos);
	R_FREE (bb->parent_reg_arena);
	if (bb->prev) {
		if (bb->prev->jumpbb == bb) {
			bb->prev->jumpbb = NULL;
		}
		if (bb->prev->failbb == bb) {
			bb->prev->failbb = NULL;
		}
		bb->prev = NULL;
	}
	if (bb->jumpbb) {
		bb->jumpbb->prev = NULL;
		bb->jumpbb = NULL;
	}
	if (bb->failbb) {
 		bb->failbb->prev = NULL;
 		bb->failbb = NULL;
 	}
	if (bb->next) {
		// avoid double free
		bb->next->prev = NULL;
	}
	R_FREE (bb); // double free
 }
","The vulnerability in the original code lies in the potential for a double free error when freeing the `RAnalBlock` structure. Specifically, if the `bb` block has a `next` pointer that references another block, the code does not handle this case, which could lead to freeing the same memory twice if both blocks are freed. In the fixed code, an additional check for `bb->next` was introduced, ensuring that if `bb->next` exists, its `prev` pointer is set to `NULL`, thus preventing any double free scenario and ensuring safer memory management.","The vulnerability in the original code stems from the risk of double freeing memory, which can occur if multiple references to the same memory block exist. Specifically, if a block has a pointer to another block that also points back, freeing one could inadvertently lead to the other being freed again, resulting in undefined behavior or crashes. The fixed code addresses this issue by adding a check for the existence of the next block before attempting to modify its pointers. This ensures that the memory management is handled correctly, preventing any potential double free scenarios and enhancing overall stability."
45,182420,182420,,Local,Not required,Complete,CVE-2018-10675,https://www.cvedetails.com/cve/CVE-2018-10675/,CWE-416,Low,Complete,Complete,,2018-05-02,7.2,The do_get_mempolicy function in mm/mempolicy.c in the Linux kernel before 4.12.9 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted system calls.,2019-04-16,DoS ,0,https://github.com/torvalds/linux/commit/73223e4e2e3867ebf033a5a8eb2e5df0158ccc99,73223e4e2e3867ebf033a5a8eb2e5df0158ccc99,"mm/mempolicy: fix use after free when calling get_mempolicy

I hit a use after free issue when executing trinity and repoduced it
with KASAN enabled.  The related call trace is as follows.

  BUG: KASan: use after free in SyS_get_mempolicy+0x3c8/0x960 at addr ffff8801f582d766
  Read of size 2 by task syz-executor1/798

  INFO: Allocated in mpol_new.part.2+0x74/0x160 age=3 cpu=1 pid=799
     __slab_alloc+0x768/0x970
     kmem_cache_alloc+0x2e7/0x450
     mpol_new.part.2+0x74/0x160
     mpol_new+0x66/0x80
     SyS_mbind+0x267/0x9f0
     system_call_fastpath+0x16/0x1b
  INFO: Freed in __mpol_put+0x2b/0x40 age=4 cpu=1 pid=799
     __slab_free+0x495/0x8e0
     kmem_cache_free+0x2f3/0x4c0
     __mpol_put+0x2b/0x40
     SyS_mbind+0x383/0x9f0
     system_call_fastpath+0x16/0x1b
  INFO: Slab 0xffffea0009cb8dc0 objects=23 used=8 fp=0xffff8801f582de40 flags=0x200000000004080
  INFO: Object 0xffff8801f582d760 @offset=5984 fp=0xffff8801f582d600

  Bytes b4 ffff8801f582d750: ae 01 ff ff 00 00 00 00 5a 5a 5a 5a 5a 5a 5a 5a  ........ZZZZZZZZ
  Object ffff8801f582d760: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk
  Object ffff8801f582d770: 6b 6b 6b 6b 6b 6b 6b a5                          kkkkkkk.
  Redzone ffff8801f582d778: bb bb bb bb bb bb bb bb                          ........
  Padding ffff8801f582d8b8: 5a 5a 5a 5a 5a 5a 5a 5a                          ZZZZZZZZ
  Memory state around the buggy address:
  ffff8801f582d600: fb fb fb fc fc fc fc fc fc fc fc fc fc fc fc fc
  ffff8801f582d680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
  >ffff8801f582d700: fc fc fc fc fc fc fc fc fc fc fc fc fb fb fb fc

!shared memory policy is not protected against parallel removal by other
thread which is normally protected by the mmap_sem.  do_get_mempolicy,
however, drops the lock midway while we can still access it later.

Early premature up_read is a historical artifact from times when
put_user was called in this path see https://lwn.net/Articles/124754/
but that is gone since 8bccd85ffbaf (""[PATCH] Implement sys_* do_*
layering in the memory policy layer."").  but when we have the the
current mempolicy ref count model.  The issue was introduced
accordingly.

Fix the issue by removing the premature release.

Link: http://lkml.kernel.org/r/1502950924-27521-1-git-send-email-zhongjiang@huawei.com
Signed-off-by: zhong jiang <zhongjiang@huawei.com>
Acked-by: Michal Hocko <mhocko@suse.com>
Cc: Minchan Kim <minchan@kernel.org>
Cc: Vlastimil Babka <vbabka@suse.cz>
Cc: David Rientjes <rientjes@google.com>
Cc: Mel Gorman <mgorman@techsingularity.net>
Cc: <stable@vger.kernel.org>	[2.6+]
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",4,mm/mempolicy.c,"{""sha"": ""618ab125228baec0810146a0638ce80ce4d50284"", ""filename"": ""mm/mempolicy.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/73223e4e2e3867ebf033a5a8eb2e5df0158ccc99/mm/mempolicy.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/73223e4e2e3867ebf033a5a8eb2e5df0158ccc99/mm/mempolicy.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/mempolicy.c?ref=73223e4e2e3867ebf033a5a8eb2e5df0158ccc99"", ""patch"": ""@@ -861,11 +861,6 @@ static long do_get_mempolicy(int *policy, nodemask_t *nmask,\n \t\t*policy |= (pol->flags & MPOL_MODE_FLAGS);\n \t}\n \n-\tif (vma) {\n-\t\tup_read(&current->mm->mmap_sem);\n-\t\tvma = NULL;\n-\t}\n-\n \terr = 0;\n \tif (nmask) {\n \t\tif (mpol_store_user_nodemask(pol)) {""}","static long do_get_mempolicy(int *policy, nodemask_t *nmask,
			     unsigned long addr, unsigned long flags)
{
	int err;
	struct mm_struct *mm = current->mm;
	struct vm_area_struct *vma = NULL;
	struct mempolicy *pol = current->mempolicy;

	if (flags &
		~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))
		return -EINVAL;

	if (flags & MPOL_F_MEMS_ALLOWED) {
		if (flags & (MPOL_F_NODE|MPOL_F_ADDR))
			return -EINVAL;
		*policy = 0;	/* just so it's initialized */
		task_lock(current);
		*nmask  = cpuset_current_mems_allowed;
		task_unlock(current);
		return 0;
	}

	if (flags & MPOL_F_ADDR) {
		/*
		 * Do NOT fall back to task policy if the
		 * vma/shared policy at addr is NULL.  We
		 * want to return MPOL_DEFAULT in this case.
		 */
		down_read(&mm->mmap_sem);
		vma = find_vma_intersection(mm, addr, addr+1);
		if (!vma) {
			up_read(&mm->mmap_sem);
			return -EFAULT;
		}
		if (vma->vm_ops && vma->vm_ops->get_policy)
			pol = vma->vm_ops->get_policy(vma, addr);
		else
			pol = vma->vm_policy;
	} else if (addr)
		return -EINVAL;

	if (!pol)
		pol = &default_policy;	/* indicates default behavior */

	if (flags & MPOL_F_NODE) {
		if (flags & MPOL_F_ADDR) {
			err = lookup_node(addr);
			if (err < 0)
				goto out;
			*policy = err;
		} else if (pol == current->mempolicy &&
				pol->mode == MPOL_INTERLEAVE) {
			*policy = next_node_in(current->il_prev, pol->v.nodes);
		} else {
			err = -EINVAL;
			goto out;
		}
	} else {
		*policy = pol == &default_policy ? MPOL_DEFAULT :
						pol->mode;
		/*
		 * Internal mempolicy flags must be masked off before exposing
		 * the policy to userspace.
		 */
 		*policy |= (pol->flags & MPOL_MODE_FLAGS);
 	}
 
 	err = 0;
 	if (nmask) {
 		if (mpol_store_user_nodemask(pol)) {
			*nmask = pol->w.user_nodemask;
		} else {
			task_lock(current);
			get_policy_nodemask(pol, nmask);
			task_unlock(current);
		}
	}

 out:
	mpol_cond_put(pol);
	if (vma)
		up_read(&current->mm->mmap_sem);
	return err;
}
","static long do_get_mempolicy(int *policy, nodemask_t *nmask,
			     unsigned long addr, unsigned long flags)
{
	int err;
	struct mm_struct *mm = current->mm;
	struct vm_area_struct *vma = NULL;
	struct mempolicy *pol = current->mempolicy;

	if (flags &
		~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))
		return -EINVAL;

	if (flags & MPOL_F_MEMS_ALLOWED) {
		if (flags & (MPOL_F_NODE|MPOL_F_ADDR))
			return -EINVAL;
		*policy = 0;	/* just so it's initialized */
		task_lock(current);
		*nmask  = cpuset_current_mems_allowed;
		task_unlock(current);
		return 0;
	}

	if (flags & MPOL_F_ADDR) {
		/*
		 * Do NOT fall back to task policy if the
		 * vma/shared policy at addr is NULL.  We
		 * want to return MPOL_DEFAULT in this case.
		 */
		down_read(&mm->mmap_sem);
		vma = find_vma_intersection(mm, addr, addr+1);
		if (!vma) {
			up_read(&mm->mmap_sem);
			return -EFAULT;
		}
		if (vma->vm_ops && vma->vm_ops->get_policy)
			pol = vma->vm_ops->get_policy(vma, addr);
		else
			pol = vma->vm_policy;
	} else if (addr)
		return -EINVAL;

	if (!pol)
		pol = &default_policy;	/* indicates default behavior */

	if (flags & MPOL_F_NODE) {
		if (flags & MPOL_F_ADDR) {
			err = lookup_node(addr);
			if (err < 0)
				goto out;
			*policy = err;
		} else if (pol == current->mempolicy &&
				pol->mode == MPOL_INTERLEAVE) {
			*policy = next_node_in(current->il_prev, pol->v.nodes);
		} else {
			err = -EINVAL;
			goto out;
		}
	} else {
		*policy = pol == &default_policy ? MPOL_DEFAULT :
						pol->mode;
		/*
		 * Internal mempolicy flags must be masked off before exposing
		 * the policy to userspace.
		 */
 		*policy |= (pol->flags & MPOL_MODE_FLAGS);
 	}
 
	if (vma) {
		up_read(&current->mm->mmap_sem);
		vma = NULL;
	}
 	err = 0;
 	if (nmask) {
 		if (mpol_store_user_nodemask(pol)) {
			*nmask = pol->w.user_nodemask;
		} else {
			task_lock(current);
			get_policy_nodemask(pol, nmask);
			task_unlock(current);
		}
	}

 out:
	mpol_cond_put(pol);
	if (vma)
		up_read(&current->mm->mmap_sem);
	return err;
}
",C,,"	if (vma) {
		up_read(&current->mm->mmap_sem);
		vma = NULL;
	}
",,"@@ -861,11 +861,6 @@ static long do_get_mempolicy(int *policy, nodemask_t *nmask,
 		*policy |= (pol->flags & MPOL_MODE_FLAGS);
 	}
 
-	if (vma) {
-		up_read(&current->mm->mmap_sem);
-		vma = NULL;
-	}
-
 	err = 0;
 	if (nmask) {
 		if (mpol_store_user_nodemask(pol)) {",linux,73223e4e2e3867ebf033a5a8eb2e5df0158ccc99,da094e42848e3c36feaa3b5271e53983fd45424f,1,"static long do_get_mempolicy(int *policy, nodemask_t *nmask,
			     unsigned long addr, unsigned long flags)
{
	int err;
	struct mm_struct *mm = current->mm;
	struct vm_area_struct *vma = NULL;
	struct mempolicy *pol = current->mempolicy;

	if (flags &
		~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))
		return -EINVAL;

	if (flags & MPOL_F_MEMS_ALLOWED) {
		if (flags & (MPOL_F_NODE|MPOL_F_ADDR))
			return -EINVAL;
		*policy = 0;	/* just so it's initialized */
		task_lock(current);
		*nmask  = cpuset_current_mems_allowed;
		task_unlock(current);
		return 0;
	}

	if (flags & MPOL_F_ADDR) {
		/*
		 * Do NOT fall back to task policy if the
		 * vma/shared policy at addr is NULL.  We
		 * want to return MPOL_DEFAULT in this case.
		 */
		down_read(&mm->mmap_sem);
		vma = find_vma_intersection(mm, addr, addr+1);
		if (!vma) {
			up_read(&mm->mmap_sem);
			return -EFAULT;
		}
		if (vma->vm_ops && vma->vm_ops->get_policy)
			pol = vma->vm_ops->get_policy(vma, addr);
		else
			pol = vma->vm_policy;
	} else if (addr)
		return -EINVAL;

	if (!pol)
		pol = &default_policy;	/* indicates default behavior */

	if (flags & MPOL_F_NODE) {
		if (flags & MPOL_F_ADDR) {
			err = lookup_node(addr);
			if (err < 0)
				goto out;
			*policy = err;
		} else if (pol == current->mempolicy &&
				pol->mode == MPOL_INTERLEAVE) {
			*policy = next_node_in(current->il_prev, pol->v.nodes);
		} else {
			err = -EINVAL;
			goto out;
		}
	} else {
		*policy = pol == &default_policy ? MPOL_DEFAULT :
						pol->mode;
		/*
		 * Internal mempolicy flags must be masked off before exposing
		 * the policy to userspace.
		 */
 		*policy |= (pol->flags & MPOL_MODE_FLAGS);
 	}
 
//flaw_line_below:
	if (vma) {
//flaw_line_below:
		up_read(&current->mm->mmap_sem);
//flaw_line_below:
		vma = NULL;
//flaw_line_below:
	}
//flaw_line_below:

 	err = 0;
 	if (nmask) {
 		if (mpol_store_user_nodemask(pol)) {
			*nmask = pol->w.user_nodemask;
		} else {
			task_lock(current);
			get_policy_nodemask(pol, nmask);
			task_unlock(current);
		}
	}

 out:
	mpol_cond_put(pol);
	if (vma)
		up_read(&current->mm->mmap_sem);
	return err;
}
",182420,"static long do_get_mempolicy(int *policy, nodemask_t *nmask,
			     unsigned long addr, unsigned long flags)
{
	int err;
	struct mm_struct *mm = current->mm;
	struct vm_area_struct *vma = NULL;
	struct mempolicy *pol = current->mempolicy;

	if (flags &
		~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))
		return -EINVAL;

	if (flags & MPOL_F_MEMS_ALLOWED) {
		if (flags & (MPOL_F_NODE|MPOL_F_ADDR))
			return -EINVAL;
		*policy = 0;	/* just so it's initialized */
		task_lock(current);
		*nmask  = cpuset_current_mems_allowed;
		task_unlock(current);
		return 0;
	}

	if (flags & MPOL_F_ADDR) {
		/*
		 * Do NOT fall back to task policy if the
		 * vma/shared policy at addr is NULL.  We
		 * want to return MPOL_DEFAULT in this case.
		 */
		down_read(&mm->mmap_sem);
		vma = find_vma_intersection(mm, addr, addr+1);
		if (!vma) {
			up_read(&mm->mmap_sem);
			return -EFAULT;
		}
		if (vma->vm_ops && vma->vm_ops->get_policy)
			pol = vma->vm_ops->get_policy(vma, addr);
		else
			pol = vma->vm_policy;
	} else if (addr)
		return -EINVAL;

	if (!pol)
		pol = &default_policy;	/* indicates default behavior */

	if (flags & MPOL_F_NODE) {
		if (flags & MPOL_F_ADDR) {
			err = lookup_node(addr);
			if (err < 0)
				goto out;
			*policy = err;
		} else if (pol == current->mempolicy &&
				pol->mode == MPOL_INTERLEAVE) {
			*policy = next_node_in(current->il_prev, pol->v.nodes);
		} else {
			err = -EINVAL;
			goto out;
		}
	} else {
		*policy = pol == &default_policy ? MPOL_DEFAULT :
						pol->mode;
		/*
		 * Internal mempolicy flags must be masked off before exposing
		 * the policy to userspace.
		 */
 		*policy |= (pol->flags & MPOL_MODE_FLAGS);
 	}
 
	if (vma) {
		up_read(&current->mm->mmap_sem);
		vma = NULL;
	}
 	err = 0;
 	if (nmask) {
 		if (mpol_store_user_nodemask(pol)) {
			*nmask = pol->w.user_nodemask;
		} else {
			task_lock(current);
			get_policy_nodemask(pol, nmask);
			task_unlock(current);
		}
	}

 out:
	mpol_cond_put(pol);
	if (vma)
		up_read(&current->mm->mmap_sem);
	return err;
}
","static long do_get_mempolicy(int *policy, nodemask_t *nmask,
			     unsigned long addr, unsigned long flags)
{
	int err;
	struct mm_struct *mm = current->mm;
	struct vm_area_struct *vma = NULL;
	struct mempolicy *pol = current->mempolicy;

	if (flags &
		~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))
		return -EINVAL;

	if (flags & MPOL_F_MEMS_ALLOWED) {
		if (flags & (MPOL_F_NODE|MPOL_F_ADDR))
			return -EINVAL;
		*policy = 0;	/* just so it's initialized */
		task_lock(current);
		*nmask  = cpuset_current_mems_allowed;
		task_unlock(current);
		return 0;
	}

	if (flags & MPOL_F_ADDR) {
		/*
		 * Do NOT fall back to task policy if the
		 * vma/shared policy at addr is NULL.  We
		 * want to return MPOL_DEFAULT in this case.
		 */
		down_read(&mm->mmap_sem);
		vma = find_vma_intersection(mm, addr, addr+1);
		if (!vma) {
			up_read(&mm->mmap_sem);
			return -EFAULT;
		}
		if (vma->vm_ops && vma->vm_ops->get_policy)
			pol = vma->vm_ops->get_policy(vma, addr);
		else
			pol = vma->vm_policy;
	} else if (addr)
		return -EINVAL;

	if (!pol)
		pol = &default_policy;	/* indicates default behavior */

	if (flags & MPOL_F_NODE) {
		if (flags & MPOL_F_ADDR) {
			err = lookup_node(addr);
			if (err < 0)
				goto out;
			*policy = err;
		} else if (pol == current->mempolicy &&
				pol->mode == MPOL_INTERLEAVE) {
			*policy = next_node_in(current->il_prev, pol->v.nodes);
		} else {
			err = -EINVAL;
			goto out;
		}
	} else {
		*policy = pol == &default_policy ? MPOL_DEFAULT :
						pol->mode;
		/*
		 * Internal mempolicy flags must be masked off before exposing
		 * the policy to userspace.
		 */
 		*policy |= (pol->flags & MPOL_MODE_FLAGS);
 	}
 
 	err = 0;
 	if (nmask) {
 		if (mpol_store_user_nodemask(pol)) {
			*nmask = pol->w.user_nodemask;
		} else {
			task_lock(current);
			get_policy_nodemask(pol, nmask);
			task_unlock(current);
		}
	}

 out:
	mpol_cond_put(pol);
	if (vma)
		up_read(&current->mm->mmap_sem);
	return err;
}
","The vulnerability in the original code lies in the handling of the `vma` (virtual memory area) and its associated policy. Specifically, if `vma` is NULL, the code incorrectly attempts to access `vma->vm_ops->get_policy`, which could lead to a null pointer dereference, resulting in a crash or undefined behavior. The fix maintains the same logic but ensures that the code does not attempt to access `vma->vm_ops` if `vma` is NULL, thus preventing potential crashes. The check for `vma` remains intact, ensuring safer access to memory policies.","The vulnerability in the original code arises from the potential for a null pointer dereference when accessing memory policies associated with a virtual memory area. If the area is not found, the code attempts to access its properties without verifying its existence, which can lead to crashes or undefined behavior. The fix addresses this issue by ensuring that the code does not attempt to access properties of a null pointer, thereby preventing the dereference. This change enhances the robustness of the code by ensuring that all necessary checks are in place before accessing potentially invalid memory references."
46,182427,182427,,Remote,Not required,Partial,CVE-2018-10199,https://www.cvedetails.com/cve/CVE-2018-10199/,CWE-416,Low,Partial,Partial,,2018-04-18,7.5,"In versions of mruby up to and including 1.4.0, a use-after-free vulnerability exists in src/io.c::File#initilialize_copy(). An attacker that can cause Ruby code to be run can possibly use this to execute arbitrary code.",2018-05-22,Exec Code ,1,https://github.com/mruby/mruby/commit/b51b21fc63c9805862322551387d9036f2b63433,b51b21fc63c9805862322551387d9036f2b63433,"Fix `use after free in File#initilialize_copy`; fix #4001

The bug and the fix were reported by https://hackerone.com/pnoltof",1,mrbgems/mruby-io/src/io.c,"{""sha"": ""6ace9e1673d1c919219dcb83f853a956227a9598"", ""filename"": ""mrbgems/mruby-io/src/io.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/mruby/mruby/blob/b51b21fc63c9805862322551387d9036f2b63433/mrbgems/mruby-io/src/io.c"", ""raw_url"": ""https://github.com/mruby/mruby/raw/b51b21fc63c9805862322551387d9036f2b63433/mrbgems/mruby-io/src/io.c"", ""contents_url"": ""https://api.github.com/repos/mruby/mruby/contents/mrbgems/mruby-io/src/io.c?ref=b51b21fc63c9805862322551387d9036f2b63433"", ""patch"": ""@@ -561,13 +561,13 @@ mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)\n   mrb_bool failed = TRUE;\n \n   mrb_get_args(mrb, \""o\"", &orig);\n+  fptr_orig = io_get_open_fptr(mrb, orig);\n   fptr_copy = (struct mrb_io *)DATA_PTR(copy);\n   if (fptr_copy != NULL) {\n     fptr_finalize(mrb, fptr_copy, FALSE);\n     mrb_free(mrb, fptr_copy);\n   }\n   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);\n-  fptr_orig = io_get_open_fptr(mrb, orig);\n \n   DATA_TYPE(copy) = &mrb_io_type;\n   DATA_PTR(copy) = fptr_copy;""}","mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)
{
  mrb_value orig;
  mrb_value buf;
  struct mrb_io *fptr_copy;
  struct mrb_io *fptr_orig;
   mrb_bool failed = TRUE;
 
   mrb_get_args(mrb, ""o"", &orig);
  fptr_orig = io_get_open_fptr(mrb, orig);
   fptr_copy = (struct mrb_io *)DATA_PTR(copy);
   if (fptr_copy != NULL) {
     fptr_finalize(mrb, fptr_copy, FALSE);
     mrb_free(mrb, fptr_copy);
   }
   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);
 
   DATA_TYPE(copy) = &mrb_io_type;
   DATA_PTR(copy) = fptr_copy;

  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, ""@buf""));
  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, ""@buf""), buf);

  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);
  if (failed) {
    mrb_sys_fail(mrb, 0);
  }
  mrb_fd_cloexec(mrb, fptr_copy->fd);

  if (fptr_orig->fd2 != -1) {
    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);
    if (failed) {
      close(fptr_copy->fd);
      mrb_sys_fail(mrb, 0);
    }
    mrb_fd_cloexec(mrb, fptr_copy->fd2);
  }

  fptr_copy->pid = fptr_orig->pid;
  fptr_copy->readable = fptr_orig->readable;
  fptr_copy->writable = fptr_orig->writable;
  fptr_copy->sync = fptr_orig->sync;
  fptr_copy->is_socket = fptr_orig->is_socket;

  return copy;
}
","mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)
{
  mrb_value orig;
  mrb_value buf;
  struct mrb_io *fptr_copy;
  struct mrb_io *fptr_orig;
   mrb_bool failed = TRUE;
 
   mrb_get_args(mrb, ""o"", &orig);
   fptr_copy = (struct mrb_io *)DATA_PTR(copy);
   if (fptr_copy != NULL) {
     fptr_finalize(mrb, fptr_copy, FALSE);
     mrb_free(mrb, fptr_copy);
   }
   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);
  fptr_orig = io_get_open_fptr(mrb, orig);
 
   DATA_TYPE(copy) = &mrb_io_type;
   DATA_PTR(copy) = fptr_copy;

  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, ""@buf""));
  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, ""@buf""), buf);

  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);
  if (failed) {
    mrb_sys_fail(mrb, 0);
  }
  mrb_fd_cloexec(mrb, fptr_copy->fd);

  if (fptr_orig->fd2 != -1) {
    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);
    if (failed) {
      close(fptr_copy->fd);
      mrb_sys_fail(mrb, 0);
    }
    mrb_fd_cloexec(mrb, fptr_copy->fd2);
  }

  fptr_copy->pid = fptr_orig->pid;
  fptr_copy->readable = fptr_orig->readable;
  fptr_copy->writable = fptr_orig->writable;
  fptr_copy->sync = fptr_orig->sync;
  fptr_copy->is_socket = fptr_orig->is_socket;

  return copy;
}
",C,"  fptr_orig = io_get_open_fptr(mrb, orig);
","  fptr_orig = io_get_open_fptr(mrb, orig);
",,"@@ -561,13 +561,13 @@ mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)
   mrb_bool failed = TRUE;
 
   mrb_get_args(mrb, ""o"", &orig);
+  fptr_orig = io_get_open_fptr(mrb, orig);
   fptr_copy = (struct mrb_io *)DATA_PTR(copy);
   if (fptr_copy != NULL) {
     fptr_finalize(mrb, fptr_copy, FALSE);
     mrb_free(mrb, fptr_copy);
   }
   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);
-  fptr_orig = io_get_open_fptr(mrb, orig);
 
   DATA_TYPE(copy) = &mrb_io_type;
   DATA_PTR(copy) = fptr_copy;",mruby,b51b21fc63c9805862322551387d9036f2b63433,fabc460880fbabd18369a7ef8715538c83ebffc9,1,"mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)
{
  mrb_value orig;
  mrb_value buf;
  struct mrb_io *fptr_copy;
  struct mrb_io *fptr_orig;
   mrb_bool failed = TRUE;
 
   mrb_get_args(mrb, ""o"", &orig);
//fix_flaw_line_below:
//  fptr_orig = io_get_open_fptr(mrb, orig);
   fptr_copy = (struct mrb_io *)DATA_PTR(copy);
   if (fptr_copy != NULL) {
     fptr_finalize(mrb, fptr_copy, FALSE);
     mrb_free(mrb, fptr_copy);
   }
   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);
//flaw_line_below:
  fptr_orig = io_get_open_fptr(mrb, orig);
 
   DATA_TYPE(copy) = &mrb_io_type;
   DATA_PTR(copy) = fptr_copy;

  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, ""@buf""));
  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, ""@buf""), buf);

  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);
  if (failed) {
    mrb_sys_fail(mrb, 0);
  }
  mrb_fd_cloexec(mrb, fptr_copy->fd);

  if (fptr_orig->fd2 != -1) {
    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);
    if (failed) {
      close(fptr_copy->fd);
      mrb_sys_fail(mrb, 0);
    }
    mrb_fd_cloexec(mrb, fptr_copy->fd2);
  }

  fptr_copy->pid = fptr_orig->pid;
  fptr_copy->readable = fptr_orig->readable;
  fptr_copy->writable = fptr_orig->writable;
  fptr_copy->sync = fptr_orig->sync;
  fptr_copy->is_socket = fptr_orig->is_socket;

  return copy;
}
",182427,"mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)
{
  mrb_value orig;
  mrb_value buf;
  struct mrb_io *fptr_copy;
  struct mrb_io *fptr_orig;
   mrb_bool failed = TRUE;
 
   mrb_get_args(mrb, ""o"", &orig);
   fptr_copy = (struct mrb_io *)DATA_PTR(copy);
   if (fptr_copy != NULL) {
     fptr_finalize(mrb, fptr_copy, FALSE);
     mrb_free(mrb, fptr_copy);
   }
   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);
  fptr_orig = io_get_open_fptr(mrb, orig);
 
   DATA_TYPE(copy) = &mrb_io_type;
   DATA_PTR(copy) = fptr_copy;

  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, ""@buf""));
  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, ""@buf""), buf);

  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);
  if (failed) {
    mrb_sys_fail(mrb, 0);
  }
  mrb_fd_cloexec(mrb, fptr_copy->fd);

  if (fptr_orig->fd2 != -1) {
    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);
    if (failed) {
      close(fptr_copy->fd);
      mrb_sys_fail(mrb, 0);
    }
    mrb_fd_cloexec(mrb, fptr_copy->fd2);
  }

  fptr_copy->pid = fptr_orig->pid;
  fptr_copy->readable = fptr_orig->readable;
  fptr_copy->writable = fptr_orig->writable;
  fptr_copy->sync = fptr_orig->sync;
  fptr_copy->is_socket = fptr_orig->is_socket;

  return copy;
}
","mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)
{
  mrb_value orig;
  mrb_value buf;
  struct mrb_io *fptr_copy;
  struct mrb_io *fptr_orig;
   mrb_bool failed = TRUE;
 
   mrb_get_args(mrb, ""o"", &orig);
  fptr_orig = io_get_open_fptr(mrb, orig);
   fptr_copy = (struct mrb_io *)DATA_PTR(copy);
   if (fptr_copy != NULL) {
     fptr_finalize(mrb, fptr_copy, FALSE);
     mrb_free(mrb, fptr_copy);
   }
   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);
 
   DATA_TYPE(copy) = &mrb_io_type;
   DATA_PTR(copy) = fptr_copy;

  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, ""@buf""));
  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, ""@buf""), buf);

  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);
  if (failed) {
    mrb_sys_fail(mrb, 0);
  }
  mrb_fd_cloexec(mrb, fptr_copy->fd);

  if (fptr_orig->fd2 != -1) {
    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);
    if (failed) {
      close(fptr_copy->fd);
      mrb_sys_fail(mrb, 0);
    }
    mrb_fd_cloexec(mrb, fptr_copy->fd2);
  }

  fptr_copy->pid = fptr_orig->pid;
  fptr_copy->readable = fptr_orig->readable;
  fptr_copy->writable = fptr_orig->writable;
  fptr_copy->sync = fptr_orig->sync;
  fptr_copy->is_socket = fptr_orig->is_socket;

  return copy;
}
","The vulnerability in the original code arises from the order of operations, specifically the retrieval of `fptr_orig` after the `mrb_get_args` call. This could lead to a situation where `fptr_copy` is initialized without a valid reference to `fptr_orig`, potentially causing undefined behavior or memory corruption when accessing `fptr_orig->fd`. In the fixed code, the order is corrected by moving the line `fptr_orig = io_get_open_fptr(mrb, orig);` immediately after `mrb_get_args`, ensuring that `fptr_orig` is properly initialized before any operations that depend on it, thus mitigating the risk of accessing uninitialized memory.","The vulnerability in the original code stems from the improper sequence of operations, which could lead to accessing uninitialized or invalid memory. Specifically, the code attempts to initialize a copy without first ensuring that the original object is correctly referenced, potentially resulting in undefined behavior or memory corruption. In the revised code, this issue is addressed by rearranging the order of operations to ensure that the original object is properly retrieved and validated before any dependent actions are taken. This change effectively prevents the risk of operating on uninitialized data, enhancing the overall stability and security of the code."
47,182521,182521,,Local,Not required,Complete,CVE-2018-5873,https://www.cvedetails.com/cve/CVE-2018-5873/,CWE-416,Medium,Complete,Complete,,2018-07-06,6.9,"An issue was discovered in the __ns_get_path function in fs/nsfs.c in the Linux kernel before 4.11. Due to a race condition when accessing files, a Use After Free condition can occur. This also affects all Android releases from CAF using the Linux kernel (Android for MSM, Firefox OS for MSM, QRD Android) before security patch level 2018-07-05.",2018-08-29,,1,https://github.com/torvalds/linux/commit/073c516ff73557a8f7315066856c04b50383ac34,073c516ff73557a8f7315066856c04b50383ac34,"nsfs: mark dentry with DCACHE_RCUACCESS

Andrey reported a use-after-free in __ns_get_path():

  spin_lock include/linux/spinlock.h:299 [inline]
  lockref_get_not_dead+0x19/0x80 lib/lockref.c:179
  __ns_get_path+0x197/0x860 fs/nsfs.c:66
  open_related_ns+0xda/0x200 fs/nsfs.c:143
  sock_ioctl+0x39d/0x440 net/socket.c:1001
  vfs_ioctl fs/ioctl.c:45 [inline]
  do_vfs_ioctl+0x1bf/0x1780 fs/ioctl.c:685
  SYSC_ioctl fs/ioctl.c:700 [inline]
  SyS_ioctl+0x8f/0xc0 fs/ioctl.c:691

We are under rcu read lock protection at that point:

        rcu_read_lock();
        d = atomic_long_read(&ns->stashed);
        if (!d)
                goto slow;
        dentry = (struct dentry *)d;
        if (!lockref_get_not_dead(&dentry->d_lockref))
                goto slow;
        rcu_read_unlock();

but don't use a proper RCU API on the free path, therefore a parallel
__d_free() could free it at the same time.  We need to mark the stashed
dentry with DCACHE_RCUACCESS so that __d_free() will be called after all
readers leave RCU.

Fixes: e149ed2b805f (""take the targets of /proc/*/ns/* symlinks to separate fs"")
Cc: Alexander Viro <viro@zeniv.linux.org.uk>
Cc: Andrew Morton <akpm@linux-foundation.org>
Reported-by: Andrey Konovalov <andreyknvl@google.com>
Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,fs/nsfs.c,"{""sha"": ""323f492e0822dd3286365d5cdbe56c59ec2d5463"", ""filename"": ""fs/nsfs.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/073c516ff73557a8f7315066856c04b50383ac34/fs/nsfs.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073c516ff73557a8f7315066856c04b50383ac34/fs/nsfs.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nsfs.c?ref=073c516ff73557a8f7315066856c04b50383ac34"", ""patch"": ""@@ -91,6 +91,7 @@ static void *__ns_get_path(struct path *path, struct ns_common *ns)\n \t\treturn ERR_PTR(-ENOMEM);\n \t}\n \td_instantiate(dentry, inode);\n+\tdentry->d_flags |= DCACHE_RCUACCESS;\n \tdentry->d_fsdata = (void *)ns->ops;\n \td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n \tif (d) {""}","static void *__ns_get_path(struct path *path, struct ns_common *ns)
{
	struct vfsmount *mnt = nsfs_mnt;
	struct qstr qname = { .name = """", };
	struct dentry *dentry;
	struct inode *inode;
	unsigned long d;

	rcu_read_lock();
	d = atomic_long_read(&ns->stashed);
	if (!d)
		goto slow;
	dentry = (struct dentry *)d;
	if (!lockref_get_not_dead(&dentry->d_lockref))
		goto slow;
	rcu_read_unlock();
	ns->ops->put(ns);
got_it:
	path->mnt = mntget(mnt);
	path->dentry = dentry;
	return NULL;
slow:
	rcu_read_unlock();
	inode = new_inode_pseudo(mnt->mnt_sb);
	if (!inode) {
		ns->ops->put(ns);
		return ERR_PTR(-ENOMEM);
	}
	inode->i_ino = ns->inum;
	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
	inode->i_flags |= S_IMMUTABLE;
	inode->i_mode = S_IFREG | S_IRUGO;
	inode->i_fop = &ns_file_operations;
	inode->i_private = ns;

	dentry = d_alloc_pseudo(mnt->mnt_sb, &qname);
	if (!dentry) {
		iput(inode);
 		return ERR_PTR(-ENOMEM);
 	}
 	d_instantiate(dentry, inode);
	dentry->d_flags |= DCACHE_RCUACCESS;
 	dentry->d_fsdata = (void *)ns->ops;
 	d = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);
 	if (d) {
		d_delete(dentry);	/* make sure ->d_prune() does nothing */
		dput(dentry);
		cpu_relax();
		return ERR_PTR(-EAGAIN);
	}
	goto got_it;
}
","static void *__ns_get_path(struct path *path, struct ns_common *ns)
{
	struct vfsmount *mnt = nsfs_mnt;
	struct qstr qname = { .name = """", };
	struct dentry *dentry;
	struct inode *inode;
	unsigned long d;

	rcu_read_lock();
	d = atomic_long_read(&ns->stashed);
	if (!d)
		goto slow;
	dentry = (struct dentry *)d;
	if (!lockref_get_not_dead(&dentry->d_lockref))
		goto slow;
	rcu_read_unlock();
	ns->ops->put(ns);
got_it:
	path->mnt = mntget(mnt);
	path->dentry = dentry;
	return NULL;
slow:
	rcu_read_unlock();
	inode = new_inode_pseudo(mnt->mnt_sb);
	if (!inode) {
		ns->ops->put(ns);
		return ERR_PTR(-ENOMEM);
	}
	inode->i_ino = ns->inum;
	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
	inode->i_flags |= S_IMMUTABLE;
	inode->i_mode = S_IFREG | S_IRUGO;
	inode->i_fop = &ns_file_operations;
	inode->i_private = ns;

	dentry = d_alloc_pseudo(mnt->mnt_sb, &qname);
	if (!dentry) {
		iput(inode);
 		return ERR_PTR(-ENOMEM);
 	}
 	d_instantiate(dentry, inode);
 	dentry->d_fsdata = (void *)ns->ops;
 	d = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);
 	if (d) {
		d_delete(dentry);	/* make sure ->d_prune() does nothing */
		dput(dentry);
		cpu_relax();
		return ERR_PTR(-EAGAIN);
	}
	goto got_it;
}
",C,"	dentry->d_flags |= DCACHE_RCUACCESS;
",,,"@@ -91,6 +91,7 @@ static void *__ns_get_path(struct path *path, struct ns_common *ns)
 		return ERR_PTR(-ENOMEM);
 	}
 	d_instantiate(dentry, inode);
+	dentry->d_flags |= DCACHE_RCUACCESS;
 	dentry->d_fsdata = (void *)ns->ops;
 	d = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);
 	if (d) {",linux,073c516ff73557a8f7315066856c04b50383ac34,80d136e138f59de35aafb0440e8ab2f51c40ccd5,1,"static void *__ns_get_path(struct path *path, struct ns_common *ns)
{
	struct vfsmount *mnt = nsfs_mnt;
	struct qstr qname = { .name = """", };
	struct dentry *dentry;
	struct inode *inode;
	unsigned long d;

	rcu_read_lock();
	d = atomic_long_read(&ns->stashed);
	if (!d)
		goto slow;
	dentry = (struct dentry *)d;
	if (!lockref_get_not_dead(&dentry->d_lockref))
		goto slow;
	rcu_read_unlock();
	ns->ops->put(ns);
got_it:
	path->mnt = mntget(mnt);
	path->dentry = dentry;
	return NULL;
slow:
	rcu_read_unlock();
	inode = new_inode_pseudo(mnt->mnt_sb);
	if (!inode) {
		ns->ops->put(ns);
		return ERR_PTR(-ENOMEM);
	}
	inode->i_ino = ns->inum;
	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
	inode->i_flags |= S_IMMUTABLE;
	inode->i_mode = S_IFREG | S_IRUGO;
	inode->i_fop = &ns_file_operations;
	inode->i_private = ns;

	dentry = d_alloc_pseudo(mnt->mnt_sb, &qname);
	if (!dentry) {
		iput(inode);
 		return ERR_PTR(-ENOMEM);
 	}
 	d_instantiate(dentry, inode);
//fix_flaw_line_below:
//	dentry->d_flags |= DCACHE_RCUACCESS;
 	dentry->d_fsdata = (void *)ns->ops;
 	d = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);
 	if (d) {
		d_delete(dentry);	/* make sure ->d_prune() does nothing */
		dput(dentry);
		cpu_relax();
		return ERR_PTR(-EAGAIN);
	}
	goto got_it;
}
",182521,"static void *__ns_get_path(struct path *path, struct ns_common *ns)
{
	struct vfsmount *mnt = nsfs_mnt;
	struct qstr qname = { .name = """", };
	struct dentry *dentry;
	struct inode *inode;
	unsigned long d;

	rcu_read_lock();
	d = atomic_long_read(&ns->stashed);
	if (!d)
		goto slow;
	dentry = (struct dentry *)d;
	if (!lockref_get_not_dead(&dentry->d_lockref))
		goto slow;
	rcu_read_unlock();
	ns->ops->put(ns);
got_it:
	path->mnt = mntget(mnt);
	path->dentry = dentry;
	return NULL;
slow:
	rcu_read_unlock();
	inode = new_inode_pseudo(mnt->mnt_sb);
	if (!inode) {
		ns->ops->put(ns);
		return ERR_PTR(-ENOMEM);
	}
	inode->i_ino = ns->inum;
	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
	inode->i_flags |= S_IMMUTABLE;
	inode->i_mode = S_IFREG | S_IRUGO;
	inode->i_fop = &ns_file_operations;
	inode->i_private = ns;

	dentry = d_alloc_pseudo(mnt->mnt_sb, &qname);
	if (!dentry) {
		iput(inode);
 		return ERR_PTR(-ENOMEM);
 	}
 	d_instantiate(dentry, inode);
 	dentry->d_fsdata = (void *)ns->ops;
 	d = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);
 	if (d) {
		d_delete(dentry);	/* make sure ->d_prune() does nothing */
		dput(dentry);
		cpu_relax();
		return ERR_PTR(-EAGAIN);
	}
	goto got_it;
}
","static void *__ns_get_path(struct path *path, struct ns_common *ns)
{
	struct vfsmount *mnt = nsfs_mnt;
	struct qstr qname = { .name = """", };
	struct dentry *dentry;
	struct inode *inode;
	unsigned long d;

	rcu_read_lock();
	d = atomic_long_read(&ns->stashed);
	if (!d)
		goto slow;
	dentry = (struct dentry *)d;
	if (!lockref_get_not_dead(&dentry->d_lockref))
		goto slow;
	rcu_read_unlock();
	ns->ops->put(ns);
got_it:
	path->mnt = mntget(mnt);
	path->dentry = dentry;
	return NULL;
slow:
	rcu_read_unlock();
	inode = new_inode_pseudo(mnt->mnt_sb);
	if (!inode) {
		ns->ops->put(ns);
		return ERR_PTR(-ENOMEM);
	}
	inode->i_ino = ns->inum;
	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
	inode->i_flags |= S_IMMUTABLE;
	inode->i_mode = S_IFREG | S_IRUGO;
	inode->i_fop = &ns_file_operations;
	inode->i_private = ns;

	dentry = d_alloc_pseudo(mnt->mnt_sb, &qname);
	if (!dentry) {
		iput(inode);
 		return ERR_PTR(-ENOMEM);
 	}
 	d_instantiate(dentry, inode);
	dentry->d_flags |= DCACHE_RCUACCESS;
 	dentry->d_fsdata = (void *)ns->ops;
 	d = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);
 	if (d) {
		d_delete(dentry);	/* make sure ->d_prune() does nothing */
		dput(dentry);
		cpu_relax();
		return ERR_PTR(-EAGAIN);
	}
	goto got_it;
}
","The vulnerability in the original code lies in the handling of the `dentry` structure, specifically the lack of proper flags to manage concurrent access. The absence of the `DCACHE_RCUACCESS` flag could lead to race conditions, where multiple threads might access or modify the `dentry` simultaneously, potentially causing data corruption or crashes. In the fixed code, the addition of `dentry->d_flags |= DCACHE_RCUACCESS;` ensures that the `dentry` is marked for safe concurrent access, thereby mitigating the risk of race conditions and enhancing the overall stability and safety of the code.","The vulnerability in the original code stems from inadequate handling of concurrent access to a shared resource, which could lead to race conditions. Specifically, the absence of proper flags to manage the state of the resource allowed multiple threads to potentially read or modify it simultaneously, risking data corruption or crashes. The fixed code addresses this issue by introducing a flag that ensures safe concurrent access, thereby preventing race conditions. This enhancement improves the stability and reliability of the code, ensuring that shared resources are accessed in a controlled manner."
48,182524,182524,,Local,Not required,Partial,CVE-2018-5344,https://www.cvedetails.com/cve/CVE-2018-5344/,CWE-416,Low,Partial,Partial,,2018-01-12,4.6,"In the Linux kernel through 4.14.13, drivers/block/loop.c mishandles lo_release serialization, which allows attackers to cause a denial of service (__lock_acquire use-after-free) or possibly have unspecified other impact.",2018-10-31,DoS ,1,https://github.com/torvalds/linux/commit/ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5,ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5,"loop: fix concurrent lo_open/lo_release

 reports that KASAN can report a use-after-free in __lock_acquire.
The reason is due to insufficient serialization in lo_release(), which
will continue to use the loop device even after it has decremented the
lo_refcnt to zero.

In the meantime, another process can come in, open the loop device
again as it is being shut down. Confusion ensues.

Reported-by:  <long7573@126.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Jens Axboe <axboe@kernel.dk>",1,drivers/block/loop.c,"{""sha"": ""d5fe720cf14940b668f8764de2bad6cf95549528"", ""filename"": ""drivers/block/loop.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 2, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5/drivers/block/loop.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5/drivers/block/loop.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/block/loop.c?ref=ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5"", ""patch"": ""@@ -1581,9 +1581,8 @@ static int lo_open(struct block_device *bdev, fmode_t mode)\n \treturn err;\n }\n \n-static void lo_release(struct gendisk *disk, fmode_t mode)\n+static void __lo_release(struct loop_device *lo)\n {\n-\tstruct loop_device *lo = disk->private_data;\n \tint err;\n \n \tif (atomic_dec_return(&lo->lo_refcnt))\n@@ -1610,6 +1609,13 @@ static void lo_release(struct gendisk *disk, fmode_t mode)\n \tmutex_unlock(&lo->lo_ctl_mutex);\n }\n \n+static void lo_release(struct gendisk *disk, fmode_t mode)\n+{\n+\tmutex_lock(&loop_index_mutex);\n+\t__lo_release(disk->private_data);\n+\tmutex_unlock(&loop_index_mutex);\n+}\n+\n static const struct block_device_operations lo_fops = {\n \t.owner =\tTHIS_MODULE,\n \t.open =\t\tlo_open,""}","static void lo_release(struct gendisk *disk, fmode_t mode)
static void __lo_release(struct loop_device *lo)
 {
 	int err;
 
 	if (atomic_dec_return(&lo->lo_refcnt))
		return;

	mutex_lock(&lo->lo_ctl_mutex);
	if (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {
		/*
		 * In autoclear mode, stop the loop thread
		 * and remove configuration after last close.
		 */
		err = loop_clr_fd(lo);
		if (!err)
			return;
	} else if (lo->lo_state == Lo_bound) {
		/*
		 * Otherwise keep thread (if running) and config,
		 * but flush possible ongoing bios in thread.
		 */
		blk_mq_freeze_queue(lo->lo_queue);
		blk_mq_unfreeze_queue(lo->lo_queue);
	}

 	mutex_unlock(&lo->lo_ctl_mutex);
 }
","static void lo_release(struct gendisk *disk, fmode_t mode)
 {
	struct loop_device *lo = disk->private_data;
 	int err;
 
 	if (atomic_dec_return(&lo->lo_refcnt))
		return;

	mutex_lock(&lo->lo_ctl_mutex);
	if (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {
		/*
		 * In autoclear mode, stop the loop thread
		 * and remove configuration after last close.
		 */
		err = loop_clr_fd(lo);
		if (!err)
			return;
	} else if (lo->lo_state == Lo_bound) {
		/*
		 * Otherwise keep thread (if running) and config,
		 * but flush possible ongoing bios in thread.
		 */
		blk_mq_freeze_queue(lo->lo_queue);
		blk_mq_unfreeze_queue(lo->lo_queue);
	}

 	mutex_unlock(&lo->lo_ctl_mutex);
 }
",C,"static void __lo_release(struct loop_device *lo)
","	struct loop_device *lo = disk->private_data;
",,"@@ -1581,9 +1581,8 @@ static int lo_open(struct block_device *bdev, fmode_t mode)
 	return err;
 }
 
-static void lo_release(struct gendisk *disk, fmode_t mode)
+static void __lo_release(struct loop_device *lo)
 {
-	struct loop_device *lo = disk->private_data;
 	int err;
 
 	if (atomic_dec_return(&lo->lo_refcnt))
@@ -1610,6 +1609,13 @@ static void lo_release(struct gendisk *disk, fmode_t mode)
 	mutex_unlock(&lo->lo_ctl_mutex);
 }
 
+static void lo_release(struct gendisk *disk, fmode_t mode)
+{
+	mutex_lock(&loop_index_mutex);
+	__lo_release(disk->private_data);
+	mutex_unlock(&loop_index_mutex);
+}
+
 static const struct block_device_operations lo_fops = {
 	.owner =	THIS_MODULE,
 	.open =		lo_open,",linux,ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5,cbf3a95924d515c1883aec2322fec277e4726134,1,"static void lo_release(struct gendisk *disk, fmode_t mode)
//fix_flaw_line_below:
//static void __lo_release(struct loop_device *lo)
 {
//flaw_line_below:
	struct loop_device *lo = disk->private_data;
 	int err;
 
 	if (atomic_dec_return(&lo->lo_refcnt))
		return;

	mutex_lock(&lo->lo_ctl_mutex);
	if (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {
		/*
		 * In autoclear mode, stop the loop thread
		 * and remove configuration after last close.
		 */
		err = loop_clr_fd(lo);
		if (!err)
			return;
	} else if (lo->lo_state == Lo_bound) {
		/*
		 * Otherwise keep thread (if running) and config,
		 * but flush possible ongoing bios in thread.
		 */
		blk_mq_freeze_queue(lo->lo_queue);
		blk_mq_unfreeze_queue(lo->lo_queue);
	}

 	mutex_unlock(&lo->lo_ctl_mutex);
 }
",182524,"static void lo_release(struct gendisk *disk, fmode_t mode)
 {
	struct loop_device *lo = disk->private_data;
 	int err;
 
 	if (atomic_dec_return(&lo->lo_refcnt))
		return;

	mutex_lock(&lo->lo_ctl_mutex);
	if (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {
		/*
		 * In autoclear mode, stop the loop thread
		 * and remove configuration after last close.
		 */
		err = loop_clr_fd(lo);
		if (!err)
			return;
	} else if (lo->lo_state == Lo_bound) {
		/*
		 * Otherwise keep thread (if running) and config,
		 * but flush possible ongoing bios in thread.
		 */
		blk_mq_freeze_queue(lo->lo_queue);
		blk_mq_unfreeze_queue(lo->lo_queue);
	}

 	mutex_unlock(&lo->lo_ctl_mutex);
 }
","static void lo_release(struct gendisk *disk, fmode_t mode)
static void __lo_release(struct loop_device *lo)
 {
 	int err;
 
 	if (atomic_dec_return(&lo->lo_refcnt))
		return;

	mutex_lock(&lo->lo_ctl_mutex);
	if (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {
		/*
		 * In autoclear mode, stop the loop thread
		 * and remove configuration after last close.
		 */
		err = loop_clr_fd(lo);
		if (!err)
			return;
	} else if (lo->lo_state == Lo_bound) {
		/*
		 * Otherwise keep thread (if running) and config,
		 * but flush possible ongoing bios in thread.
		 */
		blk_mq_freeze_queue(lo->lo_queue);
		blk_mq_unfreeze_queue(lo->lo_queue);
	}

 	mutex_unlock(&lo->lo_ctl_mutex);
 }
","The vulnerability in the original code lies in the direct manipulation of the `struct loop_device *lo` pointer derived from `disk->private_data` without proper validation, which could lead to potential race conditions or use-after-free issues if the `gendisk` structure is modified concurrently. This could allow unauthorized access or manipulation of the loop device. The fixed code addresses this by introducing a new function `__lo_release(struct loop_device *lo)`, which encapsulates the logic for releasing the loop device, ensuring that the `lo` pointer is handled more safely and reducing the risk of concurrent access issues.","The vulnerability in the original code stems from the potential for race conditions and improper access to shared resources, as it directly manipulates a pointer derived from a structure without adequate validation or synchronization. This could lead to scenarios where the resource is modified concurrently, resulting in undefined behavior or security issues. The fixed code mitigates this vulnerability by restructuring the logic into a separate function that encapsulates the release process, thereby improving the handling of the resource and ensuring that access is more controlled and less prone to concurrent modification issues."
49,182575,182575,,Local,Not required,Complete,CVE-2017-18218,https://www.cvedetails.com/cve/CVE-2017-18218/,CWE-416,Low,Complete,Complete,,2018-03-05,7.2,"In drivers/net/ethernet/hisilicon/hns/hns_enet.c in the Linux kernel before 4.13, local users can cause a denial of service (use-after-free and BUG) or possibly have unspecified other impact by leveraging differences in skb handling between hns_nic_net_xmit_hw and hns_nic_net_xmit.",2018-05-02,DoS ,3,https://github.com/torvalds/linux/commit/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2,27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2,"net: hns: Fix a skb used after free bug

skb maybe freed in hns_nic_net_xmit_hw() and return NETDEV_TX_OK,
which cause hns_nic_net_xmit to use a freed skb.

BUG: KASAN: use-after-free in hns_nic_net_xmit_hw+0x62c/0x940...
	[17659.112635]      alloc_debug_processing+0x18c/0x1a0
	[17659.117208]      __slab_alloc+0x52c/0x560
	[17659.120909]      kmem_cache_alloc_node+0xac/0x2c0
	[17659.125309]      __alloc_skb+0x6c/0x260
	[17659.128837]      tcp_send_ack+0x8c/0x280
	[17659.132449]      __tcp_ack_snd_check+0x9c/0xf0
	[17659.136587]      tcp_rcv_established+0x5a4/0xa70
	[17659.140899]      tcp_v4_do_rcv+0x27c/0x620
	[17659.144687]      tcp_prequeue_process+0x108/0x170
	[17659.149085]      tcp_recvmsg+0x940/0x1020
	[17659.152787]      inet_recvmsg+0x124/0x180
	[17659.156488]      sock_recvmsg+0x64/0x80
	[17659.160012]      SyS_recvfrom+0xd8/0x180
	[17659.163626]      __sys_trace_return+0x0/0x4
	[17659.167506] INFO: Freed in kfree_skbmem+0xa0/0xb0 age=23 cpu=1 pid=13
	[17659.174000]      free_debug_processing+0x1d4/0x2c0
	[17659.178486]      __slab_free+0x240/0x390
	[17659.182100]      kmem_cache_free+0x24c/0x270
	[17659.186062]      kfree_skbmem+0xa0/0xb0
	[17659.189587]      __kfree_skb+0x28/0x40
	[17659.193025]      napi_gro_receive+0x168/0x1c0
	[17659.197074]      hns_nic_rx_up_pro+0x58/0x90
	[17659.201038]      hns_nic_rx_poll_one+0x518/0xbc0
	[17659.205352]      hns_nic_common_poll+0x94/0x140
	[17659.209576]      net_rx_action+0x458/0x5e0
	[17659.213363]      __do_softirq+0x1b8/0x480
	[17659.217062]      run_ksoftirqd+0x64/0x80
	[17659.220679]      smpboot_thread_fn+0x224/0x310
	[17659.224821]      kthread+0x150/0x170
	[17659.228084]      ret_from_fork+0x10/0x40

	BUG: KASAN: use-after-free in hns_nic_net_xmit+0x8c/0xc0...
	[17751.080490]      __slab_alloc+0x52c/0x560
	[17751.084188]      kmem_cache_alloc+0x244/0x280
	[17751.088238]      __build_skb+0x40/0x150
	[17751.091764]      build_skb+0x28/0x100
	[17751.095115]      __alloc_rx_skb+0x94/0x150
	[17751.098900]      __napi_alloc_skb+0x34/0x90
	[17751.102776]      hns_nic_rx_poll_one+0x180/0xbc0
	[17751.107097]      hns_nic_common_poll+0x94/0x140
	[17751.111333]      net_rx_action+0x458/0x5e0
	[17751.115123]      __do_softirq+0x1b8/0x480
	[17751.118823]      run_ksoftirqd+0x64/0x80
	[17751.122437]      smpboot_thread_fn+0x224/0x310
	[17751.126575]      kthread+0x150/0x170
	[17751.129838]      ret_from_fork+0x10/0x40
	[17751.133454] INFO: Freed in kfree_skbmem+0xa0/0xb0 age=19 cpu=7 pid=43
	[17751.139951]      free_debug_processing+0x1d4/0x2c0
	[17751.144436]      __slab_free+0x240/0x390
	[17751.148051]      kmem_cache_free+0x24c/0x270
	[17751.152014]      kfree_skbmem+0xa0/0xb0
	[17751.155543]      __kfree_skb+0x28/0x40
	[17751.159022]      napi_gro_receive+0x168/0x1c0
	[17751.163074]      hns_nic_rx_up_pro+0x58/0x90
	[17751.167041]      hns_nic_rx_poll_one+0x518/0xbc0
	[17751.171358]      hns_nic_common_poll+0x94/0x140
	[17751.175585]      net_rx_action+0x458/0x5e0
	[17751.179373]      __do_softirq+0x1b8/0x480
	[17751.183076]      run_ksoftirqd+0x64/0x80
	[17751.186691]      smpboot_thread_fn+0x224/0x310
	[17751.190826]      kthread+0x150/0x170
	[17751.194093]      ret_from_fork+0x10/0x40

Fixes: 13ac695e7ea1 (""net:hns: Add support of Hip06 SoC to the Hislicon Network Subsystem"")
Signed-off-by: Yunsheng Lin <linyunsheng@huawei.com>
Signed-off-by: lipeng <lipeng321@huawei.com>
Reported-by: Jun He <hjat2005@huawei.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",9,drivers/net/ethernet/hisilicon/hns/hns_enet.c,"{""sha"": ""fe166e0f678101bb8b0eee7dfab32380e0a0f3a7"", ""filename"": ""drivers/net/ethernet/hisilicon/hns/hns_enet.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 12, ""changes"": 22, ""blob_url"": ""https://github.com/torvalds/linux/blob/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2/drivers/net/ethernet/hisilicon/hns/hns_enet.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2/drivers/net/ethernet/hisilicon/hns/hns_enet.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ethernet/hisilicon/hns/hns_enet.c?ref=27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2"", ""patch"": ""@@ -300,9 +300,9 @@ static void fill_tso_desc(struct hnae_ring *ring, void *priv,\n \t\t\t     mtu);\n }\n \n-int hns_nic_net_xmit_hw(struct net_device *ndev,\n-\t\t\tstruct sk_buff *skb,\n-\t\t\tstruct hns_nic_ring_data *ring_data)\n+netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,\n+\t\t\t\tstruct sk_buff *skb,\n+\t\t\t\tstruct hns_nic_ring_data *ring_data)\n {\n \tstruct hns_nic_priv *priv = netdev_priv(ndev);\n \tstruct hnae_ring *ring = ring_data->ring;\n@@ -361,6 +361,10 @@ int hns_nic_net_xmit_hw(struct net_device *ndev,\n \tdev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);\n \tnetdev_tx_sent_queue(dev_queue, skb->len);\n \n+\tnetif_trans_update(ndev);\n+\tndev->stats.tx_bytes += skb->len;\n+\tndev->stats.tx_packets++;\n+\n \twmb(); /* commit all data before submit */\n \tassert(skb->queue_mapping < priv->ae_handle->q_num);\n \thnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);\n@@ -1469,17 +1473,11 @@ static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n \t\t\t\t    struct net_device *ndev)\n {\n \tstruct hns_nic_priv *priv = netdev_priv(ndev);\n-\tint ret;\n \n \tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n-\tret = hns_nic_net_xmit_hw(ndev, skb,\n-\t\t\t\t  &tx_ring_data(priv, skb->queue_mapping));\n-\tif (ret == NETDEV_TX_OK) {\n-\t\tnetif_trans_update(ndev);\n-\t\tndev->stats.tx_bytes += skb->len;\n-\t\tndev->stats.tx_packets++;\n-\t}\n-\treturn (netdev_tx_t)ret;\n+\n+\treturn hns_nic_net_xmit_hw(ndev, skb,\n+\t\t\t\t   &tx_ring_data(priv, skb->queue_mapping));\n }\n \n static void hns_nic_drop_rx_fetch(struct hns_nic_ring_data *ring_data,""}<_**next**_>{""sha"": ""9cb4c7884201e1eb4c1c160a85517f62f397646a"", ""filename"": ""drivers/net/ethernet/hisilicon/hns/hns_enet.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2/drivers/net/ethernet/hisilicon/hns/hns_enet.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2/drivers/net/ethernet/hisilicon/hns/hns_enet.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ethernet/hisilicon/hns/hns_enet.h?ref=27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2"", ""patch"": ""@@ -92,8 +92,8 @@ void hns_ethtool_set_ops(struct net_device *ndev);\n void hns_nic_net_reset(struct net_device *ndev);\n void hns_nic_net_reinit(struct net_device *netdev);\n int hns_nic_init_phy(struct net_device *ndev, struct hnae_handle *h);\n-int hns_nic_net_xmit_hw(struct net_device *ndev,\n-\t\t\tstruct sk_buff *skb,\n-\t\t\tstruct hns_nic_ring_data *ring_data);\n+netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,\n+\t\t\t\tstruct sk_buff *skb,\n+\t\t\t\tstruct hns_nic_ring_data *ring_data);\n \n #endif\t/**__HNS_ENET_H */""}","static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
 
 	assert(skb->queue_mapping < ndev->ae_handle->q_num);

	return hns_nic_net_xmit_hw(ndev, skb,
				   &tx_ring_data(priv, skb->queue_mapping));
 }
","static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
	int ret;
 
 	assert(skb->queue_mapping < ndev->ae_handle->q_num);
	ret = hns_nic_net_xmit_hw(ndev, skb,
				  &tx_ring_data(priv, skb->queue_mapping));
	if (ret == NETDEV_TX_OK) {
		netif_trans_update(ndev);
		ndev->stats.tx_bytes += skb->len;
		ndev->stats.tx_packets++;
	}
	return (netdev_tx_t)ret;
 }
",C,"
	return hns_nic_net_xmit_hw(ndev, skb,
				   &tx_ring_data(priv, skb->queue_mapping));
","	int ret;
	ret = hns_nic_net_xmit_hw(ndev, skb,
				  &tx_ring_data(priv, skb->queue_mapping));
	if (ret == NETDEV_TX_OK) {
		netif_trans_update(ndev);
		ndev->stats.tx_bytes += skb->len;
		ndev->stats.tx_packets++;
	}
	return (netdev_tx_t)ret;
",,"@@ -300,9 +300,9 @@ static void fill_tso_desc(struct hnae_ring *ring, void *priv,
 			     mtu);
 }
 
-int hns_nic_net_xmit_hw(struct net_device *ndev,
-			struct sk_buff *skb,
-			struct hns_nic_ring_data *ring_data)
+netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,
+				struct sk_buff *skb,
+				struct hns_nic_ring_data *ring_data)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
 	struct hnae_ring *ring = ring_data->ring;
@@ -361,6 +361,10 @@ int hns_nic_net_xmit_hw(struct net_device *ndev,
 	dev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);
 	netdev_tx_sent_queue(dev_queue, skb->len);
 
+	netif_trans_update(ndev);
+	ndev->stats.tx_bytes += skb->len;
+	ndev->stats.tx_packets++;
+
 	wmb(); /* commit all data before submit */
 	assert(skb->queue_mapping < priv->ae_handle->q_num);
 	hnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);
@@ -1469,17 +1473,11 @@ static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
-	int ret;
 
 	assert(skb->queue_mapping < ndev->ae_handle->q_num);
-	ret = hns_nic_net_xmit_hw(ndev, skb,
-				  &tx_ring_data(priv, skb->queue_mapping));
-	if (ret == NETDEV_TX_OK) {
-		netif_trans_update(ndev);
-		ndev->stats.tx_bytes += skb->len;
-		ndev->stats.tx_packets++;
-	}
-	return (netdev_tx_t)ret;
+
+	return hns_nic_net_xmit_hw(ndev, skb,
+				   &tx_ring_data(priv, skb->queue_mapping));
 }
 
 static void hns_nic_drop_rx_fetch(struct hns_nic_ring_data *ring_data,",linux,27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2,ebe8d359c90d6e237527f4d0544b62bdcc0ff286,1,"static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
//flaw_line_below:
	int ret;
 
 	assert(skb->queue_mapping < ndev->ae_handle->q_num);
//flaw_line_below:
	ret = hns_nic_net_xmit_hw(ndev, skb,
//flaw_line_below:
				  &tx_ring_data(priv, skb->queue_mapping));
//flaw_line_below:
	if (ret == NETDEV_TX_OK) {
//flaw_line_below:
		netif_trans_update(ndev);
//flaw_line_below:
		ndev->stats.tx_bytes += skb->len;
//flaw_line_below:
		ndev->stats.tx_packets++;
//flaw_line_below:
	}
//flaw_line_below:
	return (netdev_tx_t)ret;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	return hns_nic_net_xmit_hw(ndev, skb,
//fix_flaw_line_below:
//				   &tx_ring_data(priv, skb->queue_mapping));
 }
",182575,"static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
	int ret;
 
 	assert(skb->queue_mapping < ndev->ae_handle->q_num);
	ret = hns_nic_net_xmit_hw(ndev, skb,
				  &tx_ring_data(priv, skb->queue_mapping));
	if (ret == NETDEV_TX_OK) {
		netif_trans_update(ndev);
		ndev->stats.tx_bytes += skb->len;
		ndev->stats.tx_packets++;
	}
	return (netdev_tx_t)ret;
 }
","static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
 
 	assert(skb->queue_mapping < ndev->ae_handle->q_num);

	return hns_nic_net_xmit_hw(ndev, skb,
				   &tx_ring_data(priv, skb->queue_mapping));
 }
","The vulnerability in the original code lies in the lack of proper error handling after the call to `hns_nic_net_xmit_hw`. If `hns_nic_net_xmit_hw` returns an error code, the function still proceeds to update the network device statistics (`ndev->stats.tx_bytes` and `ndev->stats.tx_packets`), which could lead to incorrect statistics being reported. In the fixed code, the error handling is removed, and the function directly returns the result of `hns_nic_net_xmit_hw`, ensuring that no statistics are updated unless the transmission is successful, thus preventing potential misuse of the statistics in case of transmission errors.","The vulnerability in the original code stems from inadequate error handling after a transmission attempt. If the transmission fails, the code still updates the statistics, which can lead to inaccurate reporting of transmitted bytes and packets. This could misrepresent the actual performance and state of the network device. In the revised code, the error handling is improved by directly returning the result of the transmission attempt without modifying the statistics. This change ensures that statistics are only updated when the transmission is successful, thereby maintaining the integrity of the reported data."
50,182576,182576,,Local,Not required,Complete,CVE-2017-18218,https://www.cvedetails.com/cve/CVE-2017-18218/,CWE-416,Low,Complete,Complete,,2018-03-05,7.2,"In drivers/net/ethernet/hisilicon/hns/hns_enet.c in the Linux kernel before 4.13, local users can cause a denial of service (use-after-free and BUG) or possibly have unspecified other impact by leveraging differences in skb handling between hns_nic_net_xmit_hw and hns_nic_net_xmit.",2018-05-02,DoS ,7,https://github.com/torvalds/linux/commit/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2,27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2,"net: hns: Fix a skb used after free bug

skb maybe freed in hns_nic_net_xmit_hw() and return NETDEV_TX_OK,
which cause hns_nic_net_xmit to use a freed skb.

BUG: KASAN: use-after-free in hns_nic_net_xmit_hw+0x62c/0x940...
	[17659.112635]      alloc_debug_processing+0x18c/0x1a0
	[17659.117208]      __slab_alloc+0x52c/0x560
	[17659.120909]      kmem_cache_alloc_node+0xac/0x2c0
	[17659.125309]      __alloc_skb+0x6c/0x260
	[17659.128837]      tcp_send_ack+0x8c/0x280
	[17659.132449]      __tcp_ack_snd_check+0x9c/0xf0
	[17659.136587]      tcp_rcv_established+0x5a4/0xa70
	[17659.140899]      tcp_v4_do_rcv+0x27c/0x620
	[17659.144687]      tcp_prequeue_process+0x108/0x170
	[17659.149085]      tcp_recvmsg+0x940/0x1020
	[17659.152787]      inet_recvmsg+0x124/0x180
	[17659.156488]      sock_recvmsg+0x64/0x80
	[17659.160012]      SyS_recvfrom+0xd8/0x180
	[17659.163626]      __sys_trace_return+0x0/0x4
	[17659.167506] INFO: Freed in kfree_skbmem+0xa0/0xb0 age=23 cpu=1 pid=13
	[17659.174000]      free_debug_processing+0x1d4/0x2c0
	[17659.178486]      __slab_free+0x240/0x390
	[17659.182100]      kmem_cache_free+0x24c/0x270
	[17659.186062]      kfree_skbmem+0xa0/0xb0
	[17659.189587]      __kfree_skb+0x28/0x40
	[17659.193025]      napi_gro_receive+0x168/0x1c0
	[17659.197074]      hns_nic_rx_up_pro+0x58/0x90
	[17659.201038]      hns_nic_rx_poll_one+0x518/0xbc0
	[17659.205352]      hns_nic_common_poll+0x94/0x140
	[17659.209576]      net_rx_action+0x458/0x5e0
	[17659.213363]      __do_softirq+0x1b8/0x480
	[17659.217062]      run_ksoftirqd+0x64/0x80
	[17659.220679]      smpboot_thread_fn+0x224/0x310
	[17659.224821]      kthread+0x150/0x170
	[17659.228084]      ret_from_fork+0x10/0x40

	BUG: KASAN: use-after-free in hns_nic_net_xmit+0x8c/0xc0...
	[17751.080490]      __slab_alloc+0x52c/0x560
	[17751.084188]      kmem_cache_alloc+0x244/0x280
	[17751.088238]      __build_skb+0x40/0x150
	[17751.091764]      build_skb+0x28/0x100
	[17751.095115]      __alloc_rx_skb+0x94/0x150
	[17751.098900]      __napi_alloc_skb+0x34/0x90
	[17751.102776]      hns_nic_rx_poll_one+0x180/0xbc0
	[17751.107097]      hns_nic_common_poll+0x94/0x140
	[17751.111333]      net_rx_action+0x458/0x5e0
	[17751.115123]      __do_softirq+0x1b8/0x480
	[17751.118823]      run_ksoftirqd+0x64/0x80
	[17751.122437]      smpboot_thread_fn+0x224/0x310
	[17751.126575]      kthread+0x150/0x170
	[17751.129838]      ret_from_fork+0x10/0x40
	[17751.133454] INFO: Freed in kfree_skbmem+0xa0/0xb0 age=19 cpu=7 pid=43
	[17751.139951]      free_debug_processing+0x1d4/0x2c0
	[17751.144436]      __slab_free+0x240/0x390
	[17751.148051]      kmem_cache_free+0x24c/0x270
	[17751.152014]      kfree_skbmem+0xa0/0xb0
	[17751.155543]      __kfree_skb+0x28/0x40
	[17751.159022]      napi_gro_receive+0x168/0x1c0
	[17751.163074]      hns_nic_rx_up_pro+0x58/0x90
	[17751.167041]      hns_nic_rx_poll_one+0x518/0xbc0
	[17751.171358]      hns_nic_common_poll+0x94/0x140
	[17751.175585]      net_rx_action+0x458/0x5e0
	[17751.179373]      __do_softirq+0x1b8/0x480
	[17751.183076]      run_ksoftirqd+0x64/0x80
	[17751.186691]      smpboot_thread_fn+0x224/0x310
	[17751.190826]      kthread+0x150/0x170
	[17751.194093]      ret_from_fork+0x10/0x40

Fixes: 13ac695e7ea1 (""net:hns: Add support of Hip06 SoC to the Hislicon Network Subsystem"")
Signed-off-by: Yunsheng Lin <linyunsheng@huawei.com>
Signed-off-by: lipeng <lipeng321@huawei.com>
Reported-by: Jun He <hjat2005@huawei.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",2,drivers/net/ethernet/hisilicon/hns/hns_enet.c,"{""sha"": ""fe166e0f678101bb8b0eee7dfab32380e0a0f3a7"", ""filename"": ""drivers/net/ethernet/hisilicon/hns/hns_enet.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 12, ""changes"": 22, ""blob_url"": ""https://github.com/torvalds/linux/blob/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2/drivers/net/ethernet/hisilicon/hns/hns_enet.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2/drivers/net/ethernet/hisilicon/hns/hns_enet.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ethernet/hisilicon/hns/hns_enet.c?ref=27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2"", ""patch"": ""@@ -300,9 +300,9 @@ static void fill_tso_desc(struct hnae_ring *ring, void *priv,\n \t\t\t     mtu);\n }\n \n-int hns_nic_net_xmit_hw(struct net_device *ndev,\n-\t\t\tstruct sk_buff *skb,\n-\t\t\tstruct hns_nic_ring_data *ring_data)\n+netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,\n+\t\t\t\tstruct sk_buff *skb,\n+\t\t\t\tstruct hns_nic_ring_data *ring_data)\n {\n \tstruct hns_nic_priv *priv = netdev_priv(ndev);\n \tstruct hnae_ring *ring = ring_data->ring;\n@@ -361,6 +361,10 @@ int hns_nic_net_xmit_hw(struct net_device *ndev,\n \tdev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);\n \tnetdev_tx_sent_queue(dev_queue, skb->len);\n \n+\tnetif_trans_update(ndev);\n+\tndev->stats.tx_bytes += skb->len;\n+\tndev->stats.tx_packets++;\n+\n \twmb(); /* commit all data before submit */\n \tassert(skb->queue_mapping < priv->ae_handle->q_num);\n \thnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);\n@@ -1469,17 +1473,11 @@ static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n \t\t\t\t    struct net_device *ndev)\n {\n \tstruct hns_nic_priv *priv = netdev_priv(ndev);\n-\tint ret;\n \n \tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n-\tret = hns_nic_net_xmit_hw(ndev, skb,\n-\t\t\t\t  &tx_ring_data(priv, skb->queue_mapping));\n-\tif (ret == NETDEV_TX_OK) {\n-\t\tnetif_trans_update(ndev);\n-\t\tndev->stats.tx_bytes += skb->len;\n-\t\tndev->stats.tx_packets++;\n-\t}\n-\treturn (netdev_tx_t)ret;\n+\n+\treturn hns_nic_net_xmit_hw(ndev, skb,\n+\t\t\t\t   &tx_ring_data(priv, skb->queue_mapping));\n }\n \n static void hns_nic_drop_rx_fetch(struct hns_nic_ring_data *ring_data,""}<_**next**_>{""sha"": ""9cb4c7884201e1eb4c1c160a85517f62f397646a"", ""filename"": ""drivers/net/ethernet/hisilicon/hns/hns_enet.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2/drivers/net/ethernet/hisilicon/hns/hns_enet.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2/drivers/net/ethernet/hisilicon/hns/hns_enet.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ethernet/hisilicon/hns/hns_enet.h?ref=27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2"", ""patch"": ""@@ -92,8 +92,8 @@ void hns_ethtool_set_ops(struct net_device *ndev);\n void hns_nic_net_reset(struct net_device *ndev);\n void hns_nic_net_reinit(struct net_device *netdev);\n int hns_nic_init_phy(struct net_device *ndev, struct hnae_handle *h);\n-int hns_nic_net_xmit_hw(struct net_device *ndev,\n-\t\t\tstruct sk_buff *skb,\n-\t\t\tstruct hns_nic_ring_data *ring_data);\n+netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,\n+\t\t\t\tstruct sk_buff *skb,\n+\t\t\t\tstruct hns_nic_ring_data *ring_data);\n \n #endif\t/**__HNS_ENET_H */""}","int hns_nic_net_xmit_hw(struct net_device *ndev,
netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,
				struct sk_buff *skb,
				struct hns_nic_ring_data *ring_data)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
 	struct hnae_ring *ring = ring_data->ring;
	struct device *dev = ring_to_dev(ring);
	struct netdev_queue *dev_queue;
	struct skb_frag_struct *frag;
	int buf_num;
	int seg_num;
	dma_addr_t dma;
	int size, next_to_use;
	int i;

	switch (priv->ops.maybe_stop_tx(&skb, &buf_num, ring)) {
	case -EBUSY:
		ring->stats.tx_busy++;
		goto out_net_tx_busy;
	case -ENOMEM:
		ring->stats.sw_err_cnt++;
		netdev_err(ndev, ""no memory to xmit!\n"");
		goto out_err_tx_ok;
	default:
		break;
	}

	/* no. of segments (plus a header) */
	seg_num = skb_shinfo(skb)->nr_frags + 1;
	next_to_use = ring->next_to_use;

	/* fill the first part */
	size = skb_headlen(skb);
	dma = dma_map_single(dev, skb->data, size, DMA_TO_DEVICE);
	if (dma_mapping_error(dev, dma)) {
		netdev_err(ndev, ""TX head DMA map failed\n"");
		ring->stats.sw_err_cnt++;
		goto out_err_tx_ok;
	}
	priv->ops.fill_desc(ring, skb, size, dma, seg_num == 1 ? 1 : 0,
			    buf_num, DESC_TYPE_SKB, ndev->mtu);

	/* fill the fragments */
	for (i = 1; i < seg_num; i++) {
		frag = &skb_shinfo(skb)->frags[i - 1];
		size = skb_frag_size(frag);
		dma = skb_frag_dma_map(dev, frag, 0, size, DMA_TO_DEVICE);
		if (dma_mapping_error(dev, dma)) {
			netdev_err(ndev, ""TX frag(%d) DMA map failed\n"", i);
			ring->stats.sw_err_cnt++;
			goto out_map_frag_fail;
		}
		priv->ops.fill_desc(ring, skb_frag_page(frag), size, dma,
				    seg_num - 1 == i ? 1 : 0, buf_num,
				    DESC_TYPE_PAGE, ndev->mtu);
	}

	/*complete translate all packets*/
 	dev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);
 	netdev_tx_sent_queue(dev_queue, skb->len);
 
	netif_trans_update(ndev);
	ndev->stats.tx_bytes += skb->len;
	ndev->stats.tx_packets++;

 	wmb(); /* commit all data before submit */
 	assert(skb->queue_mapping < priv->ae_handle->q_num);
 	hnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);
	ring->stats.tx_pkts++;
	ring->stats.tx_bytes += skb->len;

	return NETDEV_TX_OK;

out_map_frag_fail:

	while (ring->next_to_use != next_to_use) {
		unfill_desc(ring);
		if (ring->next_to_use != next_to_use)
			dma_unmap_page(dev,
				       ring->desc_cb[ring->next_to_use].dma,
				       ring->desc_cb[ring->next_to_use].length,
				       DMA_TO_DEVICE);
		else
			dma_unmap_single(dev,
					 ring->desc_cb[next_to_use].dma,
					 ring->desc_cb[next_to_use].length,
					 DMA_TO_DEVICE);
	}

out_err_tx_ok:

	dev_kfree_skb_any(skb);
	return NETDEV_TX_OK;

out_net_tx_busy:

	netif_stop_subqueue(ndev, skb->queue_mapping);

	/* Herbert's original patch had:
	 *  smp_mb__after_netif_stop_queue();
	 * but since that doesn't exist yet, just open code it.
	 */
	smp_mb();
	return NETDEV_TX_BUSY;
}
","int hns_nic_net_xmit_hw(struct net_device *ndev,
			struct sk_buff *skb,
			struct hns_nic_ring_data *ring_data)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
 	struct hnae_ring *ring = ring_data->ring;
	struct device *dev = ring_to_dev(ring);
	struct netdev_queue *dev_queue;
	struct skb_frag_struct *frag;
	int buf_num;
	int seg_num;
	dma_addr_t dma;
	int size, next_to_use;
	int i;

	switch (priv->ops.maybe_stop_tx(&skb, &buf_num, ring)) {
	case -EBUSY:
		ring->stats.tx_busy++;
		goto out_net_tx_busy;
	case -ENOMEM:
		ring->stats.sw_err_cnt++;
		netdev_err(ndev, ""no memory to xmit!\n"");
		goto out_err_tx_ok;
	default:
		break;
	}

	/* no. of segments (plus a header) */
	seg_num = skb_shinfo(skb)->nr_frags + 1;
	next_to_use = ring->next_to_use;

	/* fill the first part */
	size = skb_headlen(skb);
	dma = dma_map_single(dev, skb->data, size, DMA_TO_DEVICE);
	if (dma_mapping_error(dev, dma)) {
		netdev_err(ndev, ""TX head DMA map failed\n"");
		ring->stats.sw_err_cnt++;
		goto out_err_tx_ok;
	}
	priv->ops.fill_desc(ring, skb, size, dma, seg_num == 1 ? 1 : 0,
			    buf_num, DESC_TYPE_SKB, ndev->mtu);

	/* fill the fragments */
	for (i = 1; i < seg_num; i++) {
		frag = &skb_shinfo(skb)->frags[i - 1];
		size = skb_frag_size(frag);
		dma = skb_frag_dma_map(dev, frag, 0, size, DMA_TO_DEVICE);
		if (dma_mapping_error(dev, dma)) {
			netdev_err(ndev, ""TX frag(%d) DMA map failed\n"", i);
			ring->stats.sw_err_cnt++;
			goto out_map_frag_fail;
		}
		priv->ops.fill_desc(ring, skb_frag_page(frag), size, dma,
				    seg_num - 1 == i ? 1 : 0, buf_num,
				    DESC_TYPE_PAGE, ndev->mtu);
	}

	/*complete translate all packets*/
 	dev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);
 	netdev_tx_sent_queue(dev_queue, skb->len);
 
 	wmb(); /* commit all data before submit */
 	assert(skb->queue_mapping < priv->ae_handle->q_num);
 	hnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);
	ring->stats.tx_pkts++;
	ring->stats.tx_bytes += skb->len;

	return NETDEV_TX_OK;

out_map_frag_fail:

	while (ring->next_to_use != next_to_use) {
		unfill_desc(ring);
		if (ring->next_to_use != next_to_use)
			dma_unmap_page(dev,
				       ring->desc_cb[ring->next_to_use].dma,
				       ring->desc_cb[ring->next_to_use].length,
				       DMA_TO_DEVICE);
		else
			dma_unmap_single(dev,
					 ring->desc_cb[next_to_use].dma,
					 ring->desc_cb[next_to_use].length,
					 DMA_TO_DEVICE);
	}

out_err_tx_ok:

	dev_kfree_skb_any(skb);
	return NETDEV_TX_OK;

out_net_tx_busy:

	netif_stop_subqueue(ndev, skb->queue_mapping);

	/* Herbert's original patch had:
	 *  smp_mb__after_netif_stop_queue();
	 * but since that doesn't exist yet, just open code it.
	 */
	smp_mb();
	return NETDEV_TX_BUSY;
}
",C,"netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,
				struct sk_buff *skb,
				struct hns_nic_ring_data *ring_data)
	netif_trans_update(ndev);
	ndev->stats.tx_bytes += skb->len;
	ndev->stats.tx_packets++;

","			struct sk_buff *skb,
			struct hns_nic_ring_data *ring_data)
",,"@@ -300,9 +300,9 @@ static void fill_tso_desc(struct hnae_ring *ring, void *priv,
 			     mtu);
 }
 
-int hns_nic_net_xmit_hw(struct net_device *ndev,
-			struct sk_buff *skb,
-			struct hns_nic_ring_data *ring_data)
+netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,
+				struct sk_buff *skb,
+				struct hns_nic_ring_data *ring_data)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
 	struct hnae_ring *ring = ring_data->ring;
@@ -361,6 +361,10 @@ int hns_nic_net_xmit_hw(struct net_device *ndev,
 	dev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);
 	netdev_tx_sent_queue(dev_queue, skb->len);
 
+	netif_trans_update(ndev);
+	ndev->stats.tx_bytes += skb->len;
+	ndev->stats.tx_packets++;
+
 	wmb(); /* commit all data before submit */
 	assert(skb->queue_mapping < priv->ae_handle->q_num);
 	hnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);
@@ -1469,17 +1473,11 @@ static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
-	int ret;
 
 	assert(skb->queue_mapping < ndev->ae_handle->q_num);
-	ret = hns_nic_net_xmit_hw(ndev, skb,
-				  &tx_ring_data(priv, skb->queue_mapping));
-	if (ret == NETDEV_TX_OK) {
-		netif_trans_update(ndev);
-		ndev->stats.tx_bytes += skb->len;
-		ndev->stats.tx_packets++;
-	}
-	return (netdev_tx_t)ret;
+
+	return hns_nic_net_xmit_hw(ndev, skb,
+				   &tx_ring_data(priv, skb->queue_mapping));
 }
 
 static void hns_nic_drop_rx_fetch(struct hns_nic_ring_data *ring_data,",linux,27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2,ebe8d359c90d6e237527f4d0544b62bdcc0ff286,1,"int hns_nic_net_xmit_hw(struct net_device *ndev,
//flaw_line_below:
			struct sk_buff *skb,
//flaw_line_below:
			struct hns_nic_ring_data *ring_data)
//fix_flaw_line_below:
//netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,
//fix_flaw_line_below:
//				struct sk_buff *skb,
//fix_flaw_line_below:
//				struct hns_nic_ring_data *ring_data)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
 	struct hnae_ring *ring = ring_data->ring;
	struct device *dev = ring_to_dev(ring);
	struct netdev_queue *dev_queue;
	struct skb_frag_struct *frag;
	int buf_num;
	int seg_num;
	dma_addr_t dma;
	int size, next_to_use;
	int i;

	switch (priv->ops.maybe_stop_tx(&skb, &buf_num, ring)) {
	case -EBUSY:
		ring->stats.tx_busy++;
		goto out_net_tx_busy;
	case -ENOMEM:
		ring->stats.sw_err_cnt++;
		netdev_err(ndev, ""no memory to xmit!\n"");
		goto out_err_tx_ok;
	default:
		break;
	}

	/* no. of segments (plus a header) */
	seg_num = skb_shinfo(skb)->nr_frags + 1;
	next_to_use = ring->next_to_use;

	/* fill the first part */
	size = skb_headlen(skb);
	dma = dma_map_single(dev, skb->data, size, DMA_TO_DEVICE);
	if (dma_mapping_error(dev, dma)) {
		netdev_err(ndev, ""TX head DMA map failed\n"");
		ring->stats.sw_err_cnt++;
		goto out_err_tx_ok;
	}
	priv->ops.fill_desc(ring, skb, size, dma, seg_num == 1 ? 1 : 0,
			    buf_num, DESC_TYPE_SKB, ndev->mtu);

	/* fill the fragments */
	for (i = 1; i < seg_num; i++) {
		frag = &skb_shinfo(skb)->frags[i - 1];
		size = skb_frag_size(frag);
		dma = skb_frag_dma_map(dev, frag, 0, size, DMA_TO_DEVICE);
		if (dma_mapping_error(dev, dma)) {
			netdev_err(ndev, ""TX frag(%d) DMA map failed\n"", i);
			ring->stats.sw_err_cnt++;
			goto out_map_frag_fail;
		}
		priv->ops.fill_desc(ring, skb_frag_page(frag), size, dma,
				    seg_num - 1 == i ? 1 : 0, buf_num,
				    DESC_TYPE_PAGE, ndev->mtu);
	}

	/*complete translate all packets*/
 	dev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);
 	netdev_tx_sent_queue(dev_queue, skb->len);
 
//fix_flaw_line_below:
//	netif_trans_update(ndev);
//fix_flaw_line_below:
//	ndev->stats.tx_bytes += skb->len;
//fix_flaw_line_below:
//	ndev->stats.tx_packets++;
//fix_flaw_line_below:
//
 	wmb(); /* commit all data before submit */
 	assert(skb->queue_mapping < priv->ae_handle->q_num);
 	hnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);
	ring->stats.tx_pkts++;
	ring->stats.tx_bytes += skb->len;

	return NETDEV_TX_OK;

out_map_frag_fail:

	while (ring->next_to_use != next_to_use) {
		unfill_desc(ring);
		if (ring->next_to_use != next_to_use)
			dma_unmap_page(dev,
				       ring->desc_cb[ring->next_to_use].dma,
				       ring->desc_cb[ring->next_to_use].length,
				       DMA_TO_DEVICE);
		else
			dma_unmap_single(dev,
					 ring->desc_cb[next_to_use].dma,
					 ring->desc_cb[next_to_use].length,
					 DMA_TO_DEVICE);
	}

out_err_tx_ok:

	dev_kfree_skb_any(skb);
	return NETDEV_TX_OK;

out_net_tx_busy:

	netif_stop_subqueue(ndev, skb->queue_mapping);

	/* Herbert's original patch had:
	 *  smp_mb__after_netif_stop_queue();
	 * but since that doesn't exist yet, just open code it.
	 */
	smp_mb();
	return NETDEV_TX_BUSY;
}
",182576,"int hns_nic_net_xmit_hw(struct net_device *ndev,
			struct sk_buff *skb,
			struct hns_nic_ring_data *ring_data)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
 	struct hnae_ring *ring = ring_data->ring;
	struct device *dev = ring_to_dev(ring);
	struct netdev_queue *dev_queue;
	struct skb_frag_struct *frag;
	int buf_num;
	int seg_num;
	dma_addr_t dma;
	int size, next_to_use;
	int i;

	switch (priv->ops.maybe_stop_tx(&skb, &buf_num, ring)) {
	case -EBUSY:
		ring->stats.tx_busy++;
		goto out_net_tx_busy;
	case -ENOMEM:
		ring->stats.sw_err_cnt++;
		netdev_err(ndev, ""no memory to xmit!\n"");
		goto out_err_tx_ok;
	default:
		break;
	}

	/* no. of segments (plus a header) */
	seg_num = skb_shinfo(skb)->nr_frags + 1;
	next_to_use = ring->next_to_use;

	/* fill the first part */
	size = skb_headlen(skb);
	dma = dma_map_single(dev, skb->data, size, DMA_TO_DEVICE);
	if (dma_mapping_error(dev, dma)) {
		netdev_err(ndev, ""TX head DMA map failed\n"");
		ring->stats.sw_err_cnt++;
		goto out_err_tx_ok;
	}
	priv->ops.fill_desc(ring, skb, size, dma, seg_num == 1 ? 1 : 0,
			    buf_num, DESC_TYPE_SKB, ndev->mtu);

	/* fill the fragments */
	for (i = 1; i < seg_num; i++) {
		frag = &skb_shinfo(skb)->frags[i - 1];
		size = skb_frag_size(frag);
		dma = skb_frag_dma_map(dev, frag, 0, size, DMA_TO_DEVICE);
		if (dma_mapping_error(dev, dma)) {
			netdev_err(ndev, ""TX frag(%d) DMA map failed\n"", i);
			ring->stats.sw_err_cnt++;
			goto out_map_frag_fail;
		}
		priv->ops.fill_desc(ring, skb_frag_page(frag), size, dma,
				    seg_num - 1 == i ? 1 : 0, buf_num,
				    DESC_TYPE_PAGE, ndev->mtu);
	}

	/*complete translate all packets*/
 	dev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);
 	netdev_tx_sent_queue(dev_queue, skb->len);
 
 	wmb(); /* commit all data before submit */
 	assert(skb->queue_mapping < priv->ae_handle->q_num);
 	hnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);
	ring->stats.tx_pkts++;
	ring->stats.tx_bytes += skb->len;

	return NETDEV_TX_OK;

out_map_frag_fail:

	while (ring->next_to_use != next_to_use) {
		unfill_desc(ring);
		if (ring->next_to_use != next_to_use)
			dma_unmap_page(dev,
				       ring->desc_cb[ring->next_to_use].dma,
				       ring->desc_cb[ring->next_to_use].length,
				       DMA_TO_DEVICE);
		else
			dma_unmap_single(dev,
					 ring->desc_cb[next_to_use].dma,
					 ring->desc_cb[next_to_use].length,
					 DMA_TO_DEVICE);
	}

out_err_tx_ok:

	dev_kfree_skb_any(skb);
	return NETDEV_TX_OK;

out_net_tx_busy:

	netif_stop_subqueue(ndev, skb->queue_mapping);

	/* Herbert's original patch had:
	 *  smp_mb__after_netif_stop_queue();
	 * but since that doesn't exist yet, just open code it.
	 */
	smp_mb();
	return NETDEV_TX_BUSY;
}
","int hns_nic_net_xmit_hw(struct net_device *ndev,
netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,
				struct sk_buff *skb,
				struct hns_nic_ring_data *ring_data)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
 	struct hnae_ring *ring = ring_data->ring;
	struct device *dev = ring_to_dev(ring);
	struct netdev_queue *dev_queue;
	struct skb_frag_struct *frag;
	int buf_num;
	int seg_num;
	dma_addr_t dma;
	int size, next_to_use;
	int i;

	switch (priv->ops.maybe_stop_tx(&skb, &buf_num, ring)) {
	case -EBUSY:
		ring->stats.tx_busy++;
		goto out_net_tx_busy;
	case -ENOMEM:
		ring->stats.sw_err_cnt++;
		netdev_err(ndev, ""no memory to xmit!\n"");
		goto out_err_tx_ok;
	default:
		break;
	}

	/* no. of segments (plus a header) */
	seg_num = skb_shinfo(skb)->nr_frags + 1;
	next_to_use = ring->next_to_use;

	/* fill the first part */
	size = skb_headlen(skb);
	dma = dma_map_single(dev, skb->data, size, DMA_TO_DEVICE);
	if (dma_mapping_error(dev, dma)) {
		netdev_err(ndev, ""TX head DMA map failed\n"");
		ring->stats.sw_err_cnt++;
		goto out_err_tx_ok;
	}
	priv->ops.fill_desc(ring, skb, size, dma, seg_num == 1 ? 1 : 0,
			    buf_num, DESC_TYPE_SKB, ndev->mtu);

	/* fill the fragments */
	for (i = 1; i < seg_num; i++) {
		frag = &skb_shinfo(skb)->frags[i - 1];
		size = skb_frag_size(frag);
		dma = skb_frag_dma_map(dev, frag, 0, size, DMA_TO_DEVICE);
		if (dma_mapping_error(dev, dma)) {
			netdev_err(ndev, ""TX frag(%d) DMA map failed\n"", i);
			ring->stats.sw_err_cnt++;
			goto out_map_frag_fail;
		}
		priv->ops.fill_desc(ring, skb_frag_page(frag), size, dma,
				    seg_num - 1 == i ? 1 : 0, buf_num,
				    DESC_TYPE_PAGE, ndev->mtu);
	}

	/*complete translate all packets*/
 	dev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);
 	netdev_tx_sent_queue(dev_queue, skb->len);
 
	netif_trans_update(ndev);
	ndev->stats.tx_bytes += skb->len;
	ndev->stats.tx_packets++;

 	wmb(); /* commit all data before submit */
 	assert(skb->queue_mapping < priv->ae_handle->q_num);
 	hnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);
	ring->stats.tx_pkts++;
	ring->stats.tx_bytes += skb->len;

	return NETDEV_TX_OK;

out_map_frag_fail:

	while (ring->next_to_use != next_to_use) {
		unfill_desc(ring);
		if (ring->next_to_use != next_to_use)
			dma_unmap_page(dev,
				       ring->desc_cb[ring->next_to_use].dma,
				       ring->desc_cb[ring->next_to_use].length,
				       DMA_TO_DEVICE);
		else
			dma_unmap_single(dev,
					 ring->desc_cb[next_to_use].dma,
					 ring->desc_cb[next_to_use].length,
					 DMA_TO_DEVICE);
	}

out_err_tx_ok:

	dev_kfree_skb_any(skb);
	return NETDEV_TX_OK;

out_net_tx_busy:

	netif_stop_subqueue(ndev, skb->queue_mapping);

	/* Herbert's original patch had:
	 *  smp_mb__after_netif_stop_queue();
	 * but since that doesn't exist yet, just open code it.
	 */
	smp_mb();
	return NETDEV_TX_BUSY;
}
","The vulnerability in the original code lies in the lack of proper updates to the `ndev->stats` structure, which tracks the number of transmitted packets and bytes. This omission could lead to inaccurate statistics, potentially affecting network performance monitoring and debugging. In the fixed code, the addition of `ndev->stats.tx_bytes += skb->len;` and `ndev->stats.tx_packets++;` ensures that the transmitted bytes and packet counts are correctly updated after a successful transmission. This change enhances the reliability of the network device's statistics, addressing the vulnerability related to incorrect state reporting.","The vulnerability in the original code stems from the failure to update the statistics related to transmitted packets and bytes, which could lead to inaccurate reporting and monitoring of network performance. This oversight might hinder effective debugging and performance analysis, as the system would not reflect the actual transmission activity. In the revised code, the issue is addressed by explicitly updating the statistics after a successful transmission, ensuring that the counts for transmitted packets and bytes are accurately maintained. This fix enhances the reliability of the network device's performance metrics, mitigating the risk of misleading information."
51,182584,182584,,Local,Not required,Complete,CVE-2017-18202,https://www.cvedetails.com/cve/CVE-2017-18202/,CWE-416,Medium,Complete,Complete,,2018-02-27,6.9,"The __oom_reap_task_mm function in mm/oom_kill.c in the Linux kernel before 4.14.4 mishandles gather operations, which allows attackers to cause a denial of service (TLB entry leak or use-after-free) or possibly have unspecified other impact by triggering a copy_to_user call within a certain time window.",2018-09-26,DoS ,4,https://github.com/torvalds/linux/commit/687cb0884a714ff484d038e9190edc874edcf146,687cb0884a714ff484d038e9190edc874edcf146,"mm, oom_reaper: gather each vma to prevent leaking TLB entry

tlb_gather_mmu(&tlb, mm, 0, -1) means gathering the whole virtual memory
space.  In this case, tlb->fullmm is true.  Some archs like arm64
doesn't flush TLB when tlb->fullmm is true:

  commit 5a7862e83000 (""arm64: tlbflush: avoid flushing when fullmm == 1"").

Which causes leaking of tlb entries.

Will clarifies his patch:
 ""Basically, we tag each address space with an ASID (PCID on x86) which
  is resident in the TLB. This means we can elide TLB invalidation when
  pulling down a full mm because we won't ever assign that ASID to
  another mm without doing TLB invalidation elsewhere (which actually
  just nukes the whole TLB).

  I think that means that we could potentially not fault on a kernel
  uaccess, because we could hit in the TLB""

There could be a window between complete_signal() sending IPI to other
cores and all threads sharing this mm are really kicked off from cores.
In this window, the oom reaper may calls tlb_flush_mmu_tlbonly() to
flush TLB then frees pages.  However, due to the above problem, the TLB
entries are not really flushed on arm64.  Other threads are possible to
access these pages through TLB entries.  Moreover, a copy_to_user() can
also write to these pages without generating page fault, causes
use-after-free bugs.

This patch gathers each vma instead of gathering full vm space.  In this
case tlb->fullmm is not true.  The behavior of oom reaper become similar
to munmapping before do_exit, which should be safe for all archs.

Link: http://lkml.kernel.org/r/20171107095453.179940-1-wangnan0@huawei.com
Fixes: aac453635549 (""mm, oom: introduce oom reaper"")
Signed-off-by: Wang Nan <wangnan0@huawei.com>
Acked-by: Michal Hocko <mhocko@suse.com>
Acked-by: David Rientjes <rientjes@google.com>
Cc: Minchan Kim <minchan@kernel.org>
Cc: Will Deacon <will.deacon@arm.com>
Cc: Bob Liu <liubo95@huawei.com>
Cc: Ingo Molnar <mingo@kernel.org>
Cc: Roman Gushchin <guro@fb.com>
Cc: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
Cc: Andrea Arcangeli <aarcange@redhat.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",3,mm/oom_kill.c,"{""sha"": ""c957be32b27a9e7a17a6e33e69a31b1b6fa8e820"", ""filename"": ""mm/oom_kill.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/687cb0884a714ff484d038e9190edc874edcf146/mm/oom_kill.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/687cb0884a714ff484d038e9190edc874edcf146/mm/oom_kill.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/oom_kill.c?ref=687cb0884a714ff484d038e9190edc874edcf146"", ""patch"": ""@@ -550,7 +550,6 @@ static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n \t */\n \tset_bit(MMF_UNSTABLE, &mm->flags);\n \n-\ttlb_gather_mmu(&tlb, mm, 0, -1);\n \tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n \t\tif (!can_madv_dontneed_vma(vma))\n \t\t\tcontinue;\n@@ -565,11 +564,13 @@ static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n \t\t * we do not want to block exit_mmap by keeping mm ref\n \t\t * count elevated without a good reason.\n \t\t */\n-\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))\n+\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {\n+\t\t\ttlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);\n \t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\n \t\t\t\t\t NULL);\n+\t\t\ttlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);\n+\t\t}\n \t}\n-\ttlb_finish_mmu(&tlb, 0, -1);\n \tpr_info(\""oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\"",\n \t\t\ttask_pid_nr(tsk), tsk->comm,\n \t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),""}","static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
{
	struct mmu_gather tlb;
	struct vm_area_struct *vma;
	bool ret = true;

	/*
	 * We have to make sure to not race with the victim exit path
	 * and cause premature new oom victim selection:
	 * __oom_reap_task_mm		exit_mm
	 *   mmget_not_zero
	 *				  mmput
	 *				    atomic_dec_and_test
	 *				  exit_oom_victim
	 *				[...]
	 *				out_of_memory
	 *				  select_bad_process
	 *				    # no TIF_MEMDIE task selects new victim
	 *  unmap_page_range # frees some memory
	 */
	mutex_lock(&oom_lock);

	if (!down_read_trylock(&mm->mmap_sem)) {
		ret = false;
		trace_skip_task_reaping(tsk->pid);
		goto unlock_oom;
	}

	/*
	 * If the mm has notifiers then we would need to invalidate them around
	 * unmap_page_range and that is risky because notifiers can sleep and
	 * what they do is basically undeterministic.  So let's have a short
	 * sleep to give the oom victim some more time.
	 * TODO: we really want to get rid of this ugly hack and make sure that
	 * notifiers cannot block for unbounded amount of time and add
	 * mmu_notifier_invalidate_range_{start,end} around unmap_page_range
	 */
	if (mm_has_notifiers(mm)) {
		up_read(&mm->mmap_sem);
		schedule_timeout_idle(HZ);
		goto unlock_oom;
	}

	/*
	 * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't
	 * work on the mm anymore. The check for MMF_OOM_SKIP must run
	 * under mmap_sem for reading because it serializes against the
	 * down_write();up_write() cycle in exit_mmap().
	 */
	if (test_bit(MMF_OOM_SKIP, &mm->flags)) {
		up_read(&mm->mmap_sem);
		trace_skip_task_reaping(tsk->pid);
		goto unlock_oom;
	}

	trace_start_task_reaping(tsk->pid);

	/*
	 * Tell all users of get_user/copy_from_user etc... that the content
	 * is no longer stable. No barriers really needed because unmapping
	 * should imply barriers already and the reader would hit a page fault
	 * if it stumbled over a reaped memory.
 	 */
 	set_bit(MMF_UNSTABLE, &mm->flags);
 
 	for (vma = mm->mmap ; vma; vma = vma->vm_next) {
 		if (!can_madv_dontneed_vma(vma))
 			continue;

		/*
		 * Only anonymous pages have a good chance to be dropped
		 * without additional steps which we cannot afford as we
		 * are OOM already.
		 *
		 * We do not even care about fs backed pages because all
		 * which are reclaimable have already been reclaimed and
 		 * we do not want to block exit_mmap by keeping mm ref
 		 * count elevated without a good reason.
 		 */
		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {
			tlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);
 			unmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,
 					 NULL);
			tlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);
		}
 	}
 	pr_info(""oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n"",
 			task_pid_nr(tsk), tsk->comm,
 			K(get_mm_counter(mm, MM_ANONPAGES)),
			K(get_mm_counter(mm, MM_FILEPAGES)),
			K(get_mm_counter(mm, MM_SHMEMPAGES)));
	up_read(&mm->mmap_sem);

	trace_finish_task_reaping(tsk->pid);
unlock_oom:
	mutex_unlock(&oom_lock);
	return ret;
}
","static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
{
	struct mmu_gather tlb;
	struct vm_area_struct *vma;
	bool ret = true;

	/*
	 * We have to make sure to not race with the victim exit path
	 * and cause premature new oom victim selection:
	 * __oom_reap_task_mm		exit_mm
	 *   mmget_not_zero
	 *				  mmput
	 *				    atomic_dec_and_test
	 *				  exit_oom_victim
	 *				[...]
	 *				out_of_memory
	 *				  select_bad_process
	 *				    # no TIF_MEMDIE task selects new victim
	 *  unmap_page_range # frees some memory
	 */
	mutex_lock(&oom_lock);

	if (!down_read_trylock(&mm->mmap_sem)) {
		ret = false;
		trace_skip_task_reaping(tsk->pid);
		goto unlock_oom;
	}

	/*
	 * If the mm has notifiers then we would need to invalidate them around
	 * unmap_page_range and that is risky because notifiers can sleep and
	 * what they do is basically undeterministic.  So let's have a short
	 * sleep to give the oom victim some more time.
	 * TODO: we really want to get rid of this ugly hack and make sure that
	 * notifiers cannot block for unbounded amount of time and add
	 * mmu_notifier_invalidate_range_{start,end} around unmap_page_range
	 */
	if (mm_has_notifiers(mm)) {
		up_read(&mm->mmap_sem);
		schedule_timeout_idle(HZ);
		goto unlock_oom;
	}

	/*
	 * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't
	 * work on the mm anymore. The check for MMF_OOM_SKIP must run
	 * under mmap_sem for reading because it serializes against the
	 * down_write();up_write() cycle in exit_mmap().
	 */
	if (test_bit(MMF_OOM_SKIP, &mm->flags)) {
		up_read(&mm->mmap_sem);
		trace_skip_task_reaping(tsk->pid);
		goto unlock_oom;
	}

	trace_start_task_reaping(tsk->pid);

	/*
	 * Tell all users of get_user/copy_from_user etc... that the content
	 * is no longer stable. No barriers really needed because unmapping
	 * should imply barriers already and the reader would hit a page fault
	 * if it stumbled over a reaped memory.
 	 */
 	set_bit(MMF_UNSTABLE, &mm->flags);
 
	tlb_gather_mmu(&tlb, mm, 0, -1);
 	for (vma = mm->mmap ; vma; vma = vma->vm_next) {
 		if (!can_madv_dontneed_vma(vma))
 			continue;

		/*
		 * Only anonymous pages have a good chance to be dropped
		 * without additional steps which we cannot afford as we
		 * are OOM already.
		 *
		 * We do not even care about fs backed pages because all
		 * which are reclaimable have already been reclaimed and
 		 * we do not want to block exit_mmap by keeping mm ref
 		 * count elevated without a good reason.
 		 */
		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))
 			unmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,
 					 NULL);
 	}
	tlb_finish_mmu(&tlb, 0, -1);
 	pr_info(""oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n"",
 			task_pid_nr(tsk), tsk->comm,
 			K(get_mm_counter(mm, MM_ANONPAGES)),
			K(get_mm_counter(mm, MM_FILEPAGES)),
			K(get_mm_counter(mm, MM_SHMEMPAGES)));
	up_read(&mm->mmap_sem);

	trace_finish_task_reaping(tsk->pid);
unlock_oom:
	mutex_unlock(&oom_lock);
	return ret;
}
",C,"		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {
			tlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);
			tlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);
		}
","	tlb_gather_mmu(&tlb, mm, 0, -1);
		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))
	tlb_finish_mmu(&tlb, 0, -1);
",,"@@ -550,7 +550,6 @@ static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
 	 */
 	set_bit(MMF_UNSTABLE, &mm->flags);
 
-	tlb_gather_mmu(&tlb, mm, 0, -1);
 	for (vma = mm->mmap ; vma; vma = vma->vm_next) {
 		if (!can_madv_dontneed_vma(vma))
 			continue;
@@ -565,11 +564,13 @@ static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
 		 * we do not want to block exit_mmap by keeping mm ref
 		 * count elevated without a good reason.
 		 */
-		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))
+		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {
+			tlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);
 			unmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,
 					 NULL);
+			tlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);
+		}
 	}
-	tlb_finish_mmu(&tlb, 0, -1);
 	pr_info(""oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n"",
 			task_pid_nr(tsk), tsk->comm,
 			K(get_mm_counter(mm, MM_ANONPAGES)),",linux,687cb0884a714ff484d038e9190edc874edcf146,4b81cb2ff69c8a8e297a147d2eb4d9b5e8d7c435,1,"static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
{
	struct mmu_gather tlb;
	struct vm_area_struct *vma;
	bool ret = true;

	/*
	 * We have to make sure to not race with the victim exit path
	 * and cause premature new oom victim selection:
	 * __oom_reap_task_mm		exit_mm
	 *   mmget_not_zero
	 *				  mmput
	 *				    atomic_dec_and_test
	 *				  exit_oom_victim
	 *				[...]
	 *				out_of_memory
	 *				  select_bad_process
	 *				    # no TIF_MEMDIE task selects new victim
	 *  unmap_page_range # frees some memory
	 */
	mutex_lock(&oom_lock);

	if (!down_read_trylock(&mm->mmap_sem)) {
		ret = false;
		trace_skip_task_reaping(tsk->pid);
		goto unlock_oom;
	}

	/*
	 * If the mm has notifiers then we would need to invalidate them around
	 * unmap_page_range and that is risky because notifiers can sleep and
	 * what they do is basically undeterministic.  So let's have a short
	 * sleep to give the oom victim some more time.
	 * TODO: we really want to get rid of this ugly hack and make sure that
	 * notifiers cannot block for unbounded amount of time and add
	 * mmu_notifier_invalidate_range_{start,end} around unmap_page_range
	 */
	if (mm_has_notifiers(mm)) {
		up_read(&mm->mmap_sem);
		schedule_timeout_idle(HZ);
		goto unlock_oom;
	}

	/*
	 * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't
	 * work on the mm anymore. The check for MMF_OOM_SKIP must run
	 * under mmap_sem for reading because it serializes against the
	 * down_write();up_write() cycle in exit_mmap().
	 */
	if (test_bit(MMF_OOM_SKIP, &mm->flags)) {
		up_read(&mm->mmap_sem);
		trace_skip_task_reaping(tsk->pid);
		goto unlock_oom;
	}

	trace_start_task_reaping(tsk->pid);

	/*
	 * Tell all users of get_user/copy_from_user etc... that the content
	 * is no longer stable. No barriers really needed because unmapping
	 * should imply barriers already and the reader would hit a page fault
	 * if it stumbled over a reaped memory.
 	 */
 	set_bit(MMF_UNSTABLE, &mm->flags);
 
//flaw_line_below:
	tlb_gather_mmu(&tlb, mm, 0, -1);
 	for (vma = mm->mmap ; vma; vma = vma->vm_next) {
 		if (!can_madv_dontneed_vma(vma))
 			continue;

		/*
		 * Only anonymous pages have a good chance to be dropped
		 * without additional steps which we cannot afford as we
		 * are OOM already.
		 *
		 * We do not even care about fs backed pages because all
		 * which are reclaimable have already been reclaimed and
 		 * we do not want to block exit_mmap by keeping mm ref
 		 * count elevated without a good reason.
 		 */
//flaw_line_below:
		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))
//fix_flaw_line_below:
//		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {
//fix_flaw_line_below:
//			tlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);
 			unmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,
 					 NULL);
//fix_flaw_line_below:
//			tlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);
//fix_flaw_line_below:
//		}
 	}
//flaw_line_below:
	tlb_finish_mmu(&tlb, 0, -1);
 	pr_info(""oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n"",
 			task_pid_nr(tsk), tsk->comm,
 			K(get_mm_counter(mm, MM_ANONPAGES)),
			K(get_mm_counter(mm, MM_FILEPAGES)),
			K(get_mm_counter(mm, MM_SHMEMPAGES)));
	up_read(&mm->mmap_sem);

	trace_finish_task_reaping(tsk->pid);
unlock_oom:
	mutex_unlock(&oom_lock);
	return ret;
}
",182584,"static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
{
	struct mmu_gather tlb;
	struct vm_area_struct *vma;
	bool ret = true;

	/*
	 * We have to make sure to not race with the victim exit path
	 * and cause premature new oom victim selection:
	 * __oom_reap_task_mm		exit_mm
	 *   mmget_not_zero
	 *				  mmput
	 *				    atomic_dec_and_test
	 *				  exit_oom_victim
	 *				[...]
	 *				out_of_memory
	 *				  select_bad_process
	 *				    # no TIF_MEMDIE task selects new victim
	 *  unmap_page_range # frees some memory
	 */
	mutex_lock(&oom_lock);

	if (!down_read_trylock(&mm->mmap_sem)) {
		ret = false;
		trace_skip_task_reaping(tsk->pid);
		goto unlock_oom;
	}

	/*
	 * If the mm has notifiers then we would need to invalidate them around
	 * unmap_page_range and that is risky because notifiers can sleep and
	 * what they do is basically undeterministic.  So let's have a short
	 * sleep to give the oom victim some more time.
	 * TODO: we really want to get rid of this ugly hack and make sure that
	 * notifiers cannot block for unbounded amount of time and add
	 * mmu_notifier_invalidate_range_{start,end} around unmap_page_range
	 */
	if (mm_has_notifiers(mm)) {
		up_read(&mm->mmap_sem);
		schedule_timeout_idle(HZ);
		goto unlock_oom;
	}

	/*
	 * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't
	 * work on the mm anymore. The check for MMF_OOM_SKIP must run
	 * under mmap_sem for reading because it serializes against the
	 * down_write();up_write() cycle in exit_mmap().
	 */
	if (test_bit(MMF_OOM_SKIP, &mm->flags)) {
		up_read(&mm->mmap_sem);
		trace_skip_task_reaping(tsk->pid);
		goto unlock_oom;
	}

	trace_start_task_reaping(tsk->pid);

	/*
	 * Tell all users of get_user/copy_from_user etc... that the content
	 * is no longer stable. No barriers really needed because unmapping
	 * should imply barriers already and the reader would hit a page fault
	 * if it stumbled over a reaped memory.
 	 */
 	set_bit(MMF_UNSTABLE, &mm->flags);
 
	tlb_gather_mmu(&tlb, mm, 0, -1);
 	for (vma = mm->mmap ; vma; vma = vma->vm_next) {
 		if (!can_madv_dontneed_vma(vma))
 			continue;

		/*
		 * Only anonymous pages have a good chance to be dropped
		 * without additional steps which we cannot afford as we
		 * are OOM already.
		 *
		 * We do not even care about fs backed pages because all
		 * which are reclaimable have already been reclaimed and
 		 * we do not want to block exit_mmap by keeping mm ref
 		 * count elevated without a good reason.
 		 */
		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))
 			unmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,
 					 NULL);
 	}
	tlb_finish_mmu(&tlb, 0, -1);
 	pr_info(""oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n"",
 			task_pid_nr(tsk), tsk->comm,
 			K(get_mm_counter(mm, MM_ANONPAGES)),
			K(get_mm_counter(mm, MM_FILEPAGES)),
			K(get_mm_counter(mm, MM_SHMEMPAGES)));
	up_read(&mm->mmap_sem);

	trace_finish_task_reaping(tsk->pid);
unlock_oom:
	mutex_unlock(&oom_lock);
	return ret;
}
","static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
{
	struct mmu_gather tlb;
	struct vm_area_struct *vma;
	bool ret = true;

	/*
	 * We have to make sure to not race with the victim exit path
	 * and cause premature new oom victim selection:
	 * __oom_reap_task_mm		exit_mm
	 *   mmget_not_zero
	 *				  mmput
	 *				    atomic_dec_and_test
	 *				  exit_oom_victim
	 *				[...]
	 *				out_of_memory
	 *				  select_bad_process
	 *				    # no TIF_MEMDIE task selects new victim
	 *  unmap_page_range # frees some memory
	 */
	mutex_lock(&oom_lock);

	if (!down_read_trylock(&mm->mmap_sem)) {
		ret = false;
		trace_skip_task_reaping(tsk->pid);
		goto unlock_oom;
	}

	/*
	 * If the mm has notifiers then we would need to invalidate them around
	 * unmap_page_range and that is risky because notifiers can sleep and
	 * what they do is basically undeterministic.  So let's have a short
	 * sleep to give the oom victim some more time.
	 * TODO: we really want to get rid of this ugly hack and make sure that
	 * notifiers cannot block for unbounded amount of time and add
	 * mmu_notifier_invalidate_range_{start,end} around unmap_page_range
	 */
	if (mm_has_notifiers(mm)) {
		up_read(&mm->mmap_sem);
		schedule_timeout_idle(HZ);
		goto unlock_oom;
	}

	/*
	 * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't
	 * work on the mm anymore. The check for MMF_OOM_SKIP must run
	 * under mmap_sem for reading because it serializes against the
	 * down_write();up_write() cycle in exit_mmap().
	 */
	if (test_bit(MMF_OOM_SKIP, &mm->flags)) {
		up_read(&mm->mmap_sem);
		trace_skip_task_reaping(tsk->pid);
		goto unlock_oom;
	}

	trace_start_task_reaping(tsk->pid);

	/*
	 * Tell all users of get_user/copy_from_user etc... that the content
	 * is no longer stable. No barriers really needed because unmapping
	 * should imply barriers already and the reader would hit a page fault
	 * if it stumbled over a reaped memory.
 	 */
 	set_bit(MMF_UNSTABLE, &mm->flags);
 
 	for (vma = mm->mmap ; vma; vma = vma->vm_next) {
 		if (!can_madv_dontneed_vma(vma))
 			continue;

		/*
		 * Only anonymous pages have a good chance to be dropped
		 * without additional steps which we cannot afford as we
		 * are OOM already.
		 *
		 * We do not even care about fs backed pages because all
		 * which are reclaimable have already been reclaimed and
 		 * we do not want to block exit_mmap by keeping mm ref
 		 * count elevated without a good reason.
 		 */
		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {
			tlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);
 			unmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,
 					 NULL);
			tlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);
		}
 	}
 	pr_info(""oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n"",
 			task_pid_nr(tsk), tsk->comm,
 			K(get_mm_counter(mm, MM_ANONPAGES)),
			K(get_mm_counter(mm, MM_FILEPAGES)),
			K(get_mm_counter(mm, MM_SHMEMPAGES)));
	up_read(&mm->mmap_sem);

	trace_finish_task_reaping(tsk->pid);
unlock_oom:
	mutex_unlock(&oom_lock);
	return ret;
}
","The vulnerability in the original code lies in the handling of memory management notifiers, which could potentially block during the OOM (Out of Memory) reaping process, leading to a race condition with the victim's exit path. Specifically, the use of `unmap_page_range` without proper synchronization could result in inconsistent memory states. The fix addresses this by ensuring that `tlb_gather_mmu` and `tlb_finish_mmu` are called around `unmap_page_range`, providing necessary synchronization and preventing the OOM reaper from being interrupted by blocking notifiers, thus enhancing the stability and reliability of memory management during OOM conditions.","The vulnerability in the original code stems from the potential for blocking operations during the Out of Memory (OOM) reaping process, which could lead to race conditions with the victim's exit path. This situation arises when memory management notifiers are involved, as they can introduce unpredictable delays, risking inconsistent memory states. The fix addresses this issue by ensuring that critical operations are properly synchronized, preventing interruptions during the reaping process. This change enhances the overall stability and reliability of memory management, ensuring that the OOM reaper can operate without being affected by blocking notifiers."
52,182598,182598,,Remote,Not required,Complete,CVE-2017-18017,https://www.cvedetails.com/cve/CVE-2017-18017/,CWE-416,Low,Complete,Complete,,2018-01-03,10.0,"The tcpmss_mangle_packet function in net/netfilter/xt_TCPMSS.c in the Linux kernel before 4.11, and 4.9.x before 4.9.36, allows remote attackers to cause a denial of service (use-after-free and memory corruption) or possibly have unspecified other impact by leveraging the presence of xt_TCPMSS in an iptables action.",2018-11-30,DoS Mem. Corr. ,5,https://github.com/torvalds/linux/commit/2638fd0f92d4397884fd991d8f4925cb3f081901,2638fd0f92d4397884fd991d8f4925cb3f081901,"netfilter: xt_TCPMSS: add more sanity tests on tcph->doff

Denys provided an awesome KASAN report pointing to an use
after free in xt_TCPMSS

I have provided three patches to fix this issue, either in xt_TCPMSS or
in xt_tcpudp.c. It seems xt_TCPMSS patch has the smallest possible
impact.

Signed-off-by: Eric Dumazet <edumazet@google.com>
Reported-by: Denys Fedoryshchenko <nuclearcat@nuclearcat.com>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",1,net/netfilter/xt_TCPMSS.c,"{""sha"": ""c64aca611ac5c5f81ad7c925652bbb90554763ac"", ""filename"": ""net/netfilter/xt_TCPMSS.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/2638fd0f92d4397884fd991d8f4925cb3f081901/net/netfilter/xt_TCPMSS.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/2638fd0f92d4397884fd991d8f4925cb3f081901/net/netfilter/xt_TCPMSS.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/netfilter/xt_TCPMSS.c?ref=2638fd0f92d4397884fd991d8f4925cb3f081901"", ""patch"": ""@@ -104,7 +104,7 @@ tcpmss_mangle_packet(struct sk_buff *skb,\n \ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n \ttcp_hdrlen = tcph->doff * 4;\n \n-\tif (len < tcp_hdrlen)\n+\tif (len < tcp_hdrlen || tcp_hdrlen < sizeof(struct tcphdr))\n \t\treturn -1;\n \n \tif (info->mss == XT_TCPMSS_CLAMP_PMTU) {\n@@ -152,6 +152,10 @@ tcpmss_mangle_packet(struct sk_buff *skb,\n \tif (len > tcp_hdrlen)\n \t\treturn 0;\n \n+\t/* tcph->doff has 4 bits, do not wrap it to 0 */\n+\tif (tcp_hdrlen >= 15 * 4)\n+\t\treturn 0;\n+\n \t/*\n \t * MSS Option not found ?! add it..\n \t */""}","tcpmss_mangle_packet(struct sk_buff *skb,
		     const struct xt_action_param *par,
		     unsigned int family,
		     unsigned int tcphoff,
		     unsigned int minlen)
{
	const struct xt_tcpmss_info *info = par->targinfo;
	struct tcphdr *tcph;
	int len, tcp_hdrlen;
	unsigned int i;
	__be16 oldval;
	u16 newmss;
	u8 *opt;

	/* This is a fragment, no TCP header is available */
	if (par->fragoff != 0)
		return 0;

	if (!skb_make_writable(skb, skb->len))
		return -1;

	len = skb->len - tcphoff;
	if (len < (int)sizeof(struct tcphdr))
		return -1;

 	tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
 	tcp_hdrlen = tcph->doff * 4;
 
	if (len < tcp_hdrlen || tcp_hdrlen < sizeof(struct tcphdr))
 		return -1;
 
 	if (info->mss == XT_TCPMSS_CLAMP_PMTU) {
		struct net *net = xt_net(par);
		unsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);
		unsigned int min_mtu = min(dst_mtu(skb_dst(skb)), in_mtu);

		if (min_mtu <= minlen) {
			net_err_ratelimited(""unknown or invalid path-MTU (%u)\n"",
					    min_mtu);
			return -1;
		}
		newmss = min_mtu - minlen;
	} else
		newmss = info->mss;

	opt = (u_int8_t *)tcph;
	for (i = sizeof(struct tcphdr); i <= tcp_hdrlen - TCPOLEN_MSS; i += optlen(opt, i)) {
		if (opt[i] == TCPOPT_MSS && opt[i+1] == TCPOLEN_MSS) {
			u_int16_t oldmss;

			oldmss = (opt[i+2] << 8) | opt[i+3];

			/* Never increase MSS, even when setting it, as
			 * doing so results in problems for hosts that rely
			 * on MSS being set correctly.
			 */
			if (oldmss <= newmss)
				return 0;

			opt[i+2] = (newmss & 0xff00) >> 8;
			opt[i+3] = newmss & 0x00ff;

			inet_proto_csum_replace2(&tcph->check, skb,
						 htons(oldmss), htons(newmss),
						 false);
			return 0;
		}
	}

	/* There is data after the header so the option can't be added
	 * without moving it, and doing so may make the SYN packet
	 * itself too large. Accept the packet unmodified instead.
	 */
 	if (len > tcp_hdrlen)
 		return 0;
 
	/* tcph->doff has 4 bits, do not wrap it to 0 */
	if (tcp_hdrlen >= 15 * 4)
		return 0;

 	/*
 	 * MSS Option not found ?! add it..
 	 */
	if (skb_tailroom(skb) < TCPOLEN_MSS) {
		if (pskb_expand_head(skb, 0,
				     TCPOLEN_MSS - skb_tailroom(skb),
				     GFP_ATOMIC))
			return -1;
		tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
	}

	skb_put(skb, TCPOLEN_MSS);

	/*
	 * IPv4: RFC 1122 states ""If an MSS option is not received at
	 * connection setup, TCP MUST assume a default send MSS of 536"".
	 * IPv6: RFC 2460 states IPv6 has a minimum MTU of 1280 and a minimum
	 * length IPv6 header of 60, ergo the default MSS value is 1220
	 * Since no MSS was provided, we must use the default values
	 */
	if (xt_family(par) == NFPROTO_IPV4)
		newmss = min(newmss, (u16)536);
	else
		newmss = min(newmss, (u16)1220);

	opt = (u_int8_t *)tcph + sizeof(struct tcphdr);
	memmove(opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr));

	inet_proto_csum_replace2(&tcph->check, skb,
				 htons(len), htons(len + TCPOLEN_MSS), true);
	opt[0] = TCPOPT_MSS;
	opt[1] = TCPOLEN_MSS;
	opt[2] = (newmss & 0xff00) >> 8;
	opt[3] = newmss & 0x00ff;

	inet_proto_csum_replace4(&tcph->check, skb, 0, *((__be32 *)opt), false);

	oldval = ((__be16 *)tcph)[6];
	tcph->doff += TCPOLEN_MSS/4;
	inet_proto_csum_replace2(&tcph->check, skb,
				 oldval, ((__be16 *)tcph)[6], false);
	return TCPOLEN_MSS;
}
","tcpmss_mangle_packet(struct sk_buff *skb,
		     const struct xt_action_param *par,
		     unsigned int family,
		     unsigned int tcphoff,
		     unsigned int minlen)
{
	const struct xt_tcpmss_info *info = par->targinfo;
	struct tcphdr *tcph;
	int len, tcp_hdrlen;
	unsigned int i;
	__be16 oldval;
	u16 newmss;
	u8 *opt;

	/* This is a fragment, no TCP header is available */
	if (par->fragoff != 0)
		return 0;

	if (!skb_make_writable(skb, skb->len))
		return -1;

	len = skb->len - tcphoff;
	if (len < (int)sizeof(struct tcphdr))
		return -1;

 	tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
 	tcp_hdrlen = tcph->doff * 4;
 
	if (len < tcp_hdrlen)
 		return -1;
 
 	if (info->mss == XT_TCPMSS_CLAMP_PMTU) {
		struct net *net = xt_net(par);
		unsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);
		unsigned int min_mtu = min(dst_mtu(skb_dst(skb)), in_mtu);

		if (min_mtu <= minlen) {
			net_err_ratelimited(""unknown or invalid path-MTU (%u)\n"",
					    min_mtu);
			return -1;
		}
		newmss = min_mtu - minlen;
	} else
		newmss = info->mss;

	opt = (u_int8_t *)tcph;
	for (i = sizeof(struct tcphdr); i <= tcp_hdrlen - TCPOLEN_MSS; i += optlen(opt, i)) {
		if (opt[i] == TCPOPT_MSS && opt[i+1] == TCPOLEN_MSS) {
			u_int16_t oldmss;

			oldmss = (opt[i+2] << 8) | opt[i+3];

			/* Never increase MSS, even when setting it, as
			 * doing so results in problems for hosts that rely
			 * on MSS being set correctly.
			 */
			if (oldmss <= newmss)
				return 0;

			opt[i+2] = (newmss & 0xff00) >> 8;
			opt[i+3] = newmss & 0x00ff;

			inet_proto_csum_replace2(&tcph->check, skb,
						 htons(oldmss), htons(newmss),
						 false);
			return 0;
		}
	}

	/* There is data after the header so the option can't be added
	 * without moving it, and doing so may make the SYN packet
	 * itself too large. Accept the packet unmodified instead.
	 */
 	if (len > tcp_hdrlen)
 		return 0;
 
 	/*
 	 * MSS Option not found ?! add it..
 	 */
	if (skb_tailroom(skb) < TCPOLEN_MSS) {
		if (pskb_expand_head(skb, 0,
				     TCPOLEN_MSS - skb_tailroom(skb),
				     GFP_ATOMIC))
			return -1;
		tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
	}

	skb_put(skb, TCPOLEN_MSS);

	/*
	 * IPv4: RFC 1122 states ""If an MSS option is not received at
	 * connection setup, TCP MUST assume a default send MSS of 536"".
	 * IPv6: RFC 2460 states IPv6 has a minimum MTU of 1280 and a minimum
	 * length IPv6 header of 60, ergo the default MSS value is 1220
	 * Since no MSS was provided, we must use the default values
	 */
	if (xt_family(par) == NFPROTO_IPV4)
		newmss = min(newmss, (u16)536);
	else
		newmss = min(newmss, (u16)1220);

	opt = (u_int8_t *)tcph + sizeof(struct tcphdr);
	memmove(opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr));

	inet_proto_csum_replace2(&tcph->check, skb,
				 htons(len), htons(len + TCPOLEN_MSS), true);
	opt[0] = TCPOPT_MSS;
	opt[1] = TCPOLEN_MSS;
	opt[2] = (newmss & 0xff00) >> 8;
	opt[3] = newmss & 0x00ff;

	inet_proto_csum_replace4(&tcph->check, skb, 0, *((__be32 *)opt), false);

	oldval = ((__be16 *)tcph)[6];
	tcph->doff += TCPOLEN_MSS/4;
	inet_proto_csum_replace2(&tcph->check, skb,
				 oldval, ((__be16 *)tcph)[6], false);
	return TCPOLEN_MSS;
}
",C,"	if (len < tcp_hdrlen || tcp_hdrlen < sizeof(struct tcphdr))
	/* tcph->doff has 4 bits, do not wrap it to 0 */
	if (tcp_hdrlen >= 15 * 4)
		return 0;

","	if (len < tcp_hdrlen)
",,"@@ -104,7 +104,7 @@ tcpmss_mangle_packet(struct sk_buff *skb,
 	tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
 	tcp_hdrlen = tcph->doff * 4;
 
-	if (len < tcp_hdrlen)
+	if (len < tcp_hdrlen || tcp_hdrlen < sizeof(struct tcphdr))
 		return -1;
 
 	if (info->mss == XT_TCPMSS_CLAMP_PMTU) {
@@ -152,6 +152,10 @@ tcpmss_mangle_packet(struct sk_buff *skb,
 	if (len > tcp_hdrlen)
 		return 0;
 
+	/* tcph->doff has 4 bits, do not wrap it to 0 */
+	if (tcp_hdrlen >= 15 * 4)
+		return 0;
+
 	/*
 	 * MSS Option not found ?! add it..
 	 */",linux,2638fd0f92d4397884fd991d8f4925cb3f081901,0b9aefea860063bb39e36bd7fe6c7087fed0ba87,1,"tcpmss_mangle_packet(struct sk_buff *skb,
		     const struct xt_action_param *par,
		     unsigned int family,
		     unsigned int tcphoff,
		     unsigned int minlen)
{
	const struct xt_tcpmss_info *info = par->targinfo;
	struct tcphdr *tcph;
	int len, tcp_hdrlen;
	unsigned int i;
	__be16 oldval;
	u16 newmss;
	u8 *opt;

	/* This is a fragment, no TCP header is available */
	if (par->fragoff != 0)
		return 0;

	if (!skb_make_writable(skb, skb->len))
		return -1;

	len = skb->len - tcphoff;
	if (len < (int)sizeof(struct tcphdr))
		return -1;

 	tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
 	tcp_hdrlen = tcph->doff * 4;
 
//flaw_line_below:
	if (len < tcp_hdrlen)
//fix_flaw_line_below:
//	if (len < tcp_hdrlen || tcp_hdrlen < sizeof(struct tcphdr))
 		return -1;
 
 	if (info->mss == XT_TCPMSS_CLAMP_PMTU) {
		struct net *net = xt_net(par);
		unsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);
		unsigned int min_mtu = min(dst_mtu(skb_dst(skb)), in_mtu);

		if (min_mtu <= minlen) {
			net_err_ratelimited(""unknown or invalid path-MTU (%u)\n"",
					    min_mtu);
			return -1;
		}
		newmss = min_mtu - minlen;
	} else
		newmss = info->mss;

	opt = (u_int8_t *)tcph;
	for (i = sizeof(struct tcphdr); i <= tcp_hdrlen - TCPOLEN_MSS; i += optlen(opt, i)) {
		if (opt[i] == TCPOPT_MSS && opt[i+1] == TCPOLEN_MSS) {
			u_int16_t oldmss;

			oldmss = (opt[i+2] << 8) | opt[i+3];

			/* Never increase MSS, even when setting it, as
			 * doing so results in problems for hosts that rely
			 * on MSS being set correctly.
			 */
			if (oldmss <= newmss)
				return 0;

			opt[i+2] = (newmss & 0xff00) >> 8;
			opt[i+3] = newmss & 0x00ff;

			inet_proto_csum_replace2(&tcph->check, skb,
						 htons(oldmss), htons(newmss),
						 false);
			return 0;
		}
	}

	/* There is data after the header so the option can't be added
	 * without moving it, and doing so may make the SYN packet
	 * itself too large. Accept the packet unmodified instead.
	 */
 	if (len > tcp_hdrlen)
 		return 0;
 
//fix_flaw_line_below:
//	/* tcph->doff has 4 bits, do not wrap it to 0 */
//fix_flaw_line_below:
//	if (tcp_hdrlen >= 15 * 4)
//fix_flaw_line_below:
//		return 0;
//fix_flaw_line_below:
//
 	/*
 	 * MSS Option not found ?! add it..
 	 */
	if (skb_tailroom(skb) < TCPOLEN_MSS) {
		if (pskb_expand_head(skb, 0,
				     TCPOLEN_MSS - skb_tailroom(skb),
				     GFP_ATOMIC))
			return -1;
		tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
	}

	skb_put(skb, TCPOLEN_MSS);

	/*
	 * IPv4: RFC 1122 states ""If an MSS option is not received at
	 * connection setup, TCP MUST assume a default send MSS of 536"".
	 * IPv6: RFC 2460 states IPv6 has a minimum MTU of 1280 and a minimum
	 * length IPv6 header of 60, ergo the default MSS value is 1220
	 * Since no MSS was provided, we must use the default values
	 */
	if (xt_family(par) == NFPROTO_IPV4)
		newmss = min(newmss, (u16)536);
	else
		newmss = min(newmss, (u16)1220);

	opt = (u_int8_t *)tcph + sizeof(struct tcphdr);
	memmove(opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr));

	inet_proto_csum_replace2(&tcph->check, skb,
				 htons(len), htons(len + TCPOLEN_MSS), true);
	opt[0] = TCPOPT_MSS;
	opt[1] = TCPOLEN_MSS;
	opt[2] = (newmss & 0xff00) >> 8;
	opt[3] = newmss & 0x00ff;

	inet_proto_csum_replace4(&tcph->check, skb, 0, *((__be32 *)opt), false);

	oldval = ((__be16 *)tcph)[6];
	tcph->doff += TCPOLEN_MSS/4;
	inet_proto_csum_replace2(&tcph->check, skb,
				 oldval, ((__be16 *)tcph)[6], false);
	return TCPOLEN_MSS;
}
",182598,"tcpmss_mangle_packet(struct sk_buff *skb,
		     const struct xt_action_param *par,
		     unsigned int family,
		     unsigned int tcphoff,
		     unsigned int minlen)
{
	const struct xt_tcpmss_info *info = par->targinfo;
	struct tcphdr *tcph;
	int len, tcp_hdrlen;
	unsigned int i;
	__be16 oldval;
	u16 newmss;
	u8 *opt;

	/* This is a fragment, no TCP header is available */
	if (par->fragoff != 0)
		return 0;

	if (!skb_make_writable(skb, skb->len))
		return -1;

	len = skb->len - tcphoff;
	if (len < (int)sizeof(struct tcphdr))
		return -1;

 	tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
 	tcp_hdrlen = tcph->doff * 4;
 
	if (len < tcp_hdrlen)
 		return -1;
 
 	if (info->mss == XT_TCPMSS_CLAMP_PMTU) {
		struct net *net = xt_net(par);
		unsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);
		unsigned int min_mtu = min(dst_mtu(skb_dst(skb)), in_mtu);

		if (min_mtu <= minlen) {
			net_err_ratelimited(""unknown or invalid path-MTU (%u)\n"",
					    min_mtu);
			return -1;
		}
		newmss = min_mtu - minlen;
	} else
		newmss = info->mss;

	opt = (u_int8_t *)tcph;
	for (i = sizeof(struct tcphdr); i <= tcp_hdrlen - TCPOLEN_MSS; i += optlen(opt, i)) {
		if (opt[i] == TCPOPT_MSS && opt[i+1] == TCPOLEN_MSS) {
			u_int16_t oldmss;

			oldmss = (opt[i+2] << 8) | opt[i+3];

			/* Never increase MSS, even when setting it, as
			 * doing so results in problems for hosts that rely
			 * on MSS being set correctly.
			 */
			if (oldmss <= newmss)
				return 0;

			opt[i+2] = (newmss & 0xff00) >> 8;
			opt[i+3] = newmss & 0x00ff;

			inet_proto_csum_replace2(&tcph->check, skb,
						 htons(oldmss), htons(newmss),
						 false);
			return 0;
		}
	}

	/* There is data after the header so the option can't be added
	 * without moving it, and doing so may make the SYN packet
	 * itself too large. Accept the packet unmodified instead.
	 */
 	if (len > tcp_hdrlen)
 		return 0;
 
 	/*
 	 * MSS Option not found ?! add it..
 	 */
	if (skb_tailroom(skb) < TCPOLEN_MSS) {
		if (pskb_expand_head(skb, 0,
				     TCPOLEN_MSS - skb_tailroom(skb),
				     GFP_ATOMIC))
			return -1;
		tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
	}

	skb_put(skb, TCPOLEN_MSS);

	/*
	 * IPv4: RFC 1122 states ""If an MSS option is not received at
	 * connection setup, TCP MUST assume a default send MSS of 536"".
	 * IPv6: RFC 2460 states IPv6 has a minimum MTU of 1280 and a minimum
	 * length IPv6 header of 60, ergo the default MSS value is 1220
	 * Since no MSS was provided, we must use the default values
	 */
	if (xt_family(par) == NFPROTO_IPV4)
		newmss = min(newmss, (u16)536);
	else
		newmss = min(newmss, (u16)1220);

	opt = (u_int8_t *)tcph + sizeof(struct tcphdr);
	memmove(opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr));

	inet_proto_csum_replace2(&tcph->check, skb,
				 htons(len), htons(len + TCPOLEN_MSS), true);
	opt[0] = TCPOPT_MSS;
	opt[1] = TCPOLEN_MSS;
	opt[2] = (newmss & 0xff00) >> 8;
	opt[3] = newmss & 0x00ff;

	inet_proto_csum_replace4(&tcph->check, skb, 0, *((__be32 *)opt), false);

	oldval = ((__be16 *)tcph)[6];
	tcph->doff += TCPOLEN_MSS/4;
	inet_proto_csum_replace2(&tcph->check, skb,
				 oldval, ((__be16 *)tcph)[6], false);
	return TCPOLEN_MSS;
}
","tcpmss_mangle_packet(struct sk_buff *skb,
		     const struct xt_action_param *par,
		     unsigned int family,
		     unsigned int tcphoff,
		     unsigned int minlen)
{
	const struct xt_tcpmss_info *info = par->targinfo;
	struct tcphdr *tcph;
	int len, tcp_hdrlen;
	unsigned int i;
	__be16 oldval;
	u16 newmss;
	u8 *opt;

	/* This is a fragment, no TCP header is available */
	if (par->fragoff != 0)
		return 0;

	if (!skb_make_writable(skb, skb->len))
		return -1;

	len = skb->len - tcphoff;
	if (len < (int)sizeof(struct tcphdr))
		return -1;

 	tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
 	tcp_hdrlen = tcph->doff * 4;
 
	if (len < tcp_hdrlen || tcp_hdrlen < sizeof(struct tcphdr))
 		return -1;
 
 	if (info->mss == XT_TCPMSS_CLAMP_PMTU) {
		struct net *net = xt_net(par);
		unsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);
		unsigned int min_mtu = min(dst_mtu(skb_dst(skb)), in_mtu);

		if (min_mtu <= minlen) {
			net_err_ratelimited(""unknown or invalid path-MTU (%u)\n"",
					    min_mtu);
			return -1;
		}
		newmss = min_mtu - minlen;
	} else
		newmss = info->mss;

	opt = (u_int8_t *)tcph;
	for (i = sizeof(struct tcphdr); i <= tcp_hdrlen - TCPOLEN_MSS; i += optlen(opt, i)) {
		if (opt[i] == TCPOPT_MSS && opt[i+1] == TCPOLEN_MSS) {
			u_int16_t oldmss;

			oldmss = (opt[i+2] << 8) | opt[i+3];

			/* Never increase MSS, even when setting it, as
			 * doing so results in problems for hosts that rely
			 * on MSS being set correctly.
			 */
			if (oldmss <= newmss)
				return 0;

			opt[i+2] = (newmss & 0xff00) >> 8;
			opt[i+3] = newmss & 0x00ff;

			inet_proto_csum_replace2(&tcph->check, skb,
						 htons(oldmss), htons(newmss),
						 false);
			return 0;
		}
	}

	/* There is data after the header so the option can't be added
	 * without moving it, and doing so may make the SYN packet
	 * itself too large. Accept the packet unmodified instead.
	 */
 	if (len > tcp_hdrlen)
 		return 0;
 
	/* tcph->doff has 4 bits, do not wrap it to 0 */
	if (tcp_hdrlen >= 15 * 4)
		return 0;

 	/*
 	 * MSS Option not found ?! add it..
 	 */
	if (skb_tailroom(skb) < TCPOLEN_MSS) {
		if (pskb_expand_head(skb, 0,
				     TCPOLEN_MSS - skb_tailroom(skb),
				     GFP_ATOMIC))
			return -1;
		tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
	}

	skb_put(skb, TCPOLEN_MSS);

	/*
	 * IPv4: RFC 1122 states ""If an MSS option is not received at
	 * connection setup, TCP MUST assume a default send MSS of 536"".
	 * IPv6: RFC 2460 states IPv6 has a minimum MTU of 1280 and a minimum
	 * length IPv6 header of 60, ergo the default MSS value is 1220
	 * Since no MSS was provided, we must use the default values
	 */
	if (xt_family(par) == NFPROTO_IPV4)
		newmss = min(newmss, (u16)536);
	else
		newmss = min(newmss, (u16)1220);

	opt = (u_int8_t *)tcph + sizeof(struct tcphdr);
	memmove(opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr));

	inet_proto_csum_replace2(&tcph->check, skb,
				 htons(len), htons(len + TCPOLEN_MSS), true);
	opt[0] = TCPOPT_MSS;
	opt[1] = TCPOLEN_MSS;
	opt[2] = (newmss & 0xff00) >> 8;
	opt[3] = newmss & 0x00ff;

	inet_proto_csum_replace4(&tcph->check, skb, 0, *((__be32 *)opt), false);

	oldval = ((__be16 *)tcph)[6];
	tcph->doff += TCPOLEN_MSS/4;
	inet_proto_csum_replace2(&tcph->check, skb,
				 oldval, ((__be16 *)tcph)[6], false);
	return TCPOLEN_MSS;
}
","The vulnerability in the original code lies in the lack of validation for the TCP header length, specifically in the condition `if (len < tcp_hdrlen)`, which could allow a malformed packet to be processed, potentially leading to memory corruption or crashes. The fixed code addresses this by adding an additional check: `tcp_hdrlen < sizeof(struct tcphdr)`, ensuring that the TCP header length is valid and preventing the function from proceeding with an invalid header. This change enhances the robustness of the function by ensuring that only properly formatted packets are processed, mitigating the risk of exploitation.","The vulnerability in the original code stems from inadequate validation of the TCP header length, which could allow the processing of malformed packets. This oversight could lead to memory corruption or crashes, as the function might attempt to access or manipulate data beyond the allocated memory for the TCP header. The fixed code addresses this issue by introducing an additional check to ensure that the TCP header length is not only valid but also within acceptable limits. This enhancement prevents the function from processing invalid packets, thereby improving the overall security and stability of the code."
53,182599,182599,,Local,Not required,Complete,CVE-2017-15129,https://www.cvedetails.com/cve/CVE-2017-15129/,CWE-416,Low,,,,2018-01-09,4.9,"A use-after-free vulnerability was found in network namespaces code affecting the Linux kernel before 4.14.11. The function get_net_ns_by_id() in net/core/net_namespace.c does not check for the net::count value after it has found a peer network in netns_ids idr, which could lead to double free and memory corruption. This vulnerability could allow an unprivileged local user to induce kernel memory corruption on the system, leading to a crash. Due to the nature of the flaw, privilege escalation cannot be fully ruled out, although it is thought to be unlikely.",2018-05-03,Mem. Corr. ,1,https://github.com/torvalds/linux/commit/21b5944350052d2583e82dd59b19a9ba94a007f0,21b5944350052d2583e82dd59b19a9ba94a007f0,"net: Fix double free and memory corruption in get_net_ns_by_id()

(I can trivially verify that that idr_remove in cleanup_net happens
 after the network namespace count has dropped to zero --EWB)

Function get_net_ns_by_id() does not check for net::count
after it has found a peer in netns_ids idr.

It may dereference a peer, after its count has already been
finaly decremented. This leads to double free and memory
corruption:

put_net(peer)                                   rtnl_lock()
atomic_dec_and_test(&peer->count) [count=0]     ...
__put_net(peer)                                 get_net_ns_by_id(net, id)
  spin_lock(&cleanup_list_lock)
  list_add(&net->cleanup_list, &cleanup_list)
  spin_unlock(&cleanup_list_lock)
queue_work()                                      peer = idr_find(&net->netns_ids, id)
  |                                               get_net(peer) [count=1]
  |                                               ...
  |                                               (use after final put)
  v                                               ...
  cleanup_net()                                   ...
    spin_lock(&cleanup_list_lock)                 ...
    list_replace_init(&cleanup_list, ..)          ...
    spin_unlock(&cleanup_list_lock)               ...
    ...                                           ...
    ...                                           put_net(peer)
    ...                                             atomic_dec_and_test(&peer->count) [count=0]
    ...                                               spin_lock(&cleanup_list_lock)
    ...                                               list_add(&net->cleanup_list, &cleanup_list)
    ...                                               spin_unlock(&cleanup_list_lock)
    ...                                             queue_work()
    ...                                           rtnl_unlock()
    rtnl_lock()                                   ...
    for_each_net(tmp) {                           ...
      id = __peernet2id(tmp, peer)                ...
      spin_lock_irq(&tmp->nsid_lock)              ...
      idr_remove(&tmp->netns_ids, id)             ...
      ...                                         ...
      net_drop_ns()                               ...
	net_free(peer)                            ...
    }                                             ...
  |
  v
  cleanup_net()
    ...
    (Second free of peer)

Also, put_net() on the right cpu may reorder with left's cpu
list_replace_init(&cleanup_list, ..), and then cleanup_list
will be corrupted.

Since cleanup_net() is executed in worker thread, while
put_net(peer) can happen everywhere, there should be
enough time for concurrent get_net_ns_by_id() to pick
the peer up, and the race does not seem to be unlikely.
The patch fixes the problem in standard way.

(Also, there is possible problem in peernet2id_alloc(), which requires
check for net::count under nsid_lock and maybe_get_net(peer), but
in current stable kernel it's used under rtnl_lock() and it has to be
safe. Openswitch begun to use peernet2id_alloc(), and possibly it should
be fixed too. While this is not in stable kernel yet, so I'll send
a separate message to netdev@ later).

Cc: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Signed-off-by: Kirill Tkhai <ktkhai@virtuozzo.com>
Fixes: 0c7aecd4bde4 ""netns: add rtnl cmd to add and get peer netns ids""
Reviewed-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
Reviewed-by: ""Eric W. Biederman"" <ebiederm@xmission.com>
Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Acked-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/core/net_namespace.c,"{""sha"": ""60a71be75aea063b418a48ade2a1e1c7804ab35c"", ""filename"": ""net/core/net_namespace.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/21b5944350052d2583e82dd59b19a9ba94a007f0/net/core/net_namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/21b5944350052d2583e82dd59b19a9ba94a007f0/net/core/net_namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/core/net_namespace.c?ref=21b5944350052d2583e82dd59b19a9ba94a007f0"", ""patch"": ""@@ -267,7 +267,7 @@ struct net *get_net_ns_by_id(struct net *net, int id)\n \tspin_lock_bh(&net->nsid_lock);\n \tpeer = idr_find(&net->netns_ids, id);\n \tif (peer)\n-\t\tget_net(peer);\n+\t\tpeer = maybe_get_net(peer);\n \tspin_unlock_bh(&net->nsid_lock);\n \trcu_read_unlock();\n ""}","struct net *get_net_ns_by_id(struct net *net, int id)
{
	struct net *peer;

	if (id < 0)
		return NULL;

	rcu_read_lock();
 	spin_lock_bh(&net->nsid_lock);
 	peer = idr_find(&net->netns_ids, id);
 	if (peer)
		peer = maybe_get_net(peer);
 	spin_unlock_bh(&net->nsid_lock);
 	rcu_read_unlock();
 
	return peer;
}
","struct net *get_net_ns_by_id(struct net *net, int id)
{
	struct net *peer;

	if (id < 0)
		return NULL;

	rcu_read_lock();
 	spin_lock_bh(&net->nsid_lock);
 	peer = idr_find(&net->netns_ids, id);
 	if (peer)
		get_net(peer);
 	spin_unlock_bh(&net->nsid_lock);
 	rcu_read_unlock();
 
	return peer;
}
",C,"		peer = maybe_get_net(peer);
","		get_net(peer);
",,"@@ -267,7 +267,7 @@ struct net *get_net_ns_by_id(struct net *net, int id)
 	spin_lock_bh(&net->nsid_lock);
 	peer = idr_find(&net->netns_ids, id);
 	if (peer)
-		get_net(peer);
+		peer = maybe_get_net(peer);
 	spin_unlock_bh(&net->nsid_lock);
 	rcu_read_unlock();
 ",linux,21b5944350052d2583e82dd59b19a9ba94a007f0,eda9873e19d83c68d0c477f6bc13718fee7a7b3c,1,"struct net *get_net_ns_by_id(struct net *net, int id)
{
	struct net *peer;

	if (id < 0)
		return NULL;

	rcu_read_lock();
 	spin_lock_bh(&net->nsid_lock);
 	peer = idr_find(&net->netns_ids, id);
 	if (peer)
//flaw_line_below:
		get_net(peer);
//fix_flaw_line_below:
//		peer = maybe_get_net(peer);
 	spin_unlock_bh(&net->nsid_lock);
 	rcu_read_unlock();
 
	return peer;
}
",182599,"struct net *get_net_ns_by_id(struct net *net, int id)
{
	struct net *peer;

	if (id < 0)
		return NULL;

	rcu_read_lock();
 	spin_lock_bh(&net->nsid_lock);
 	peer = idr_find(&net->netns_ids, id);
 	if (peer)
		get_net(peer);
 	spin_unlock_bh(&net->nsid_lock);
 	rcu_read_unlock();
 
	return peer;
}
","struct net *get_net_ns_by_id(struct net *net, int id)
{
	struct net *peer;

	if (id < 0)
		return NULL;

	rcu_read_lock();
 	spin_lock_bh(&net->nsid_lock);
 	peer = idr_find(&net->netns_ids, id);
 	if (peer)
		peer = maybe_get_net(peer);
 	spin_unlock_bh(&net->nsid_lock);
 	rcu_read_unlock();
 
	return peer;
}
","The vulnerability in the original code lies in the use of `get_net(peer)`, which increments the reference count of the `peer` object without ensuring that it is valid for use after the lock is released. This can lead to a use-after-free condition if the `peer` is freed elsewhere while the lock is held. In the fixed code, the function `maybe_get_net(peer)` is used instead, which likely includes additional checks to ensure that the `peer` is still valid before incrementing its reference count. This change mitigates the risk of dereferencing a potentially freed object, enhancing the overall safety of the code.","The vulnerability in the original code arises from the improper handling of object reference counting, which can lead to a use-after-free condition. Specifically, the code increments the reference count of an object without verifying its validity after releasing the associated lock. This oversight allows the possibility of accessing a freed object, resulting in undefined behavior or crashes. The fixed code addresses this issue by implementing a safer reference counting mechanism that includes necessary checks before incrementing the count. This change ensures that the object remains valid for use, thereby enhancing the stability and security of the code."
54,182700,182700,,Local,Not required,Complete,CVE-2019-15917,https://www.cvedetails.com/cve/CVE-2019-15917/,CWE-416,Low,Complete,Complete,,2019-09-04,7.2,An issue was discovered in the Linux kernel before 5.0.5. There is a use-after-free issue when hci_uart_register_dev() fails in hci_uart_set_proto() in drivers/bluetooth/hci_ldisc.c.,2019-09-24,,1,https://github.com/torvalds/linux/commit/56897b217a1d0a91c9920cb418d6b3fe922f590a,56897b217a1d0a91c9920cb418d6b3fe922f590a,"Bluetooth: hci_ldisc: Postpone HCI_UART_PROTO_READY bit set in hci_uart_set_proto()

task A:                                task B:
hci_uart_set_proto                     flush_to_ldisc
 - p->open(hu) -> h5_open  //alloc h5  - receive_buf
 - set_bit HCI_UART_PROTO_READY         - tty_port_default_receive_buf
 - hci_uart_register_dev                 - tty_ldisc_receive_buf
                                          - hci_uart_tty_receive
				           - test_bit HCI_UART_PROTO_READY
				            - h5_recv
 - clear_bit HCI_UART_PROTO_READY             while() {
 - p->open(hu) -> h5_close //free h5
				              - h5_rx_3wire_hdr
				               - h5_reset()  //use-after-free
                                              }

It could use ioctl to set hci uart proto, but there is
a use-after-free issue when hci_uart_register_dev() fail in
hci_uart_set_proto(), see stack above, fix this by setting
HCI_UART_PROTO_READY bit only when hci_uart_register_dev()
return success.

Reported-by: syzbot+899a33dc0fa0dbaf06a6@syzkaller.appspotmail.com
Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
Reviewed-by: Jeremy Cline <jcline@redhat.com>
Signed-off-by: Marcel Holtmann <marcel@holtmann.org>",2,drivers/bluetooth/hci_ldisc.c,"{""sha"": ""9562e72c1ae5792092361cf22bca9a1d96782549"", ""filename"": ""drivers/bluetooth/hci_ldisc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/56897b217a1d0a91c9920cb418d6b3fe922f590a/drivers/bluetooth/hci_ldisc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/56897b217a1d0a91c9920cb418d6b3fe922f590a/drivers/bluetooth/hci_ldisc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/bluetooth/hci_ldisc.c?ref=56897b217a1d0a91c9920cb418d6b3fe922f590a"", ""patch"": ""@@ -696,14 +696,13 @@ static int hci_uart_set_proto(struct hci_uart *hu, int id)\n \t\treturn -EPROTONOSUPPORT;\n \n \thu->proto = p;\n-\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n \n \terr = hci_uart_register_dev(hu);\n \tif (err) {\n-\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n \t\treturn err;\n \t}\n \n+\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n \treturn 0;\n }\n ""}","static int hci_uart_set_proto(struct hci_uart *hu, int id)
{
	const struct hci_uart_proto *p;
	int err;

	p = hci_uart_get_proto(id);
	if (!p)
 		return -EPROTONOSUPPORT;
 
 	hu->proto = p;
 
 	err = hci_uart_register_dev(hu);
 	if (err) {
 		return err;
 	}
 
	set_bit(HCI_UART_PROTO_READY, &hu->flags);
 	return 0;
 }
","static int hci_uart_set_proto(struct hci_uart *hu, int id)
{
	const struct hci_uart_proto *p;
	int err;

	p = hci_uart_get_proto(id);
	if (!p)
 		return -EPROTONOSUPPORT;
 
 	hu->proto = p;
	set_bit(HCI_UART_PROTO_READY, &hu->flags);
 
 	err = hci_uart_register_dev(hu);
 	if (err) {
		clear_bit(HCI_UART_PROTO_READY, &hu->flags);
 		return err;
 	}
 
 	return 0;
 }
",C,"	set_bit(HCI_UART_PROTO_READY, &hu->flags);
","	set_bit(HCI_UART_PROTO_READY, &hu->flags);
		clear_bit(HCI_UART_PROTO_READY, &hu->flags);
",,"@@ -696,14 +696,13 @@ static int hci_uart_set_proto(struct hci_uart *hu, int id)
 		return -EPROTONOSUPPORT;
 
 	hu->proto = p;
-	set_bit(HCI_UART_PROTO_READY, &hu->flags);
 
 	err = hci_uart_register_dev(hu);
 	if (err) {
-		clear_bit(HCI_UART_PROTO_READY, &hu->flags);
 		return err;
 	}
 
+	set_bit(HCI_UART_PROTO_READY, &hu->flags);
 	return 0;
 }
 ",linux,56897b217a1d0a91c9920cb418d6b3fe922f590a,4a67e5d4adbf3b419f17924322f468ac5cb8c14f,1,"static int hci_uart_set_proto(struct hci_uart *hu, int id)
{
	const struct hci_uart_proto *p;
	int err;

	p = hci_uart_get_proto(id);
	if (!p)
 		return -EPROTONOSUPPORT;
 
 	hu->proto = p;
//flaw_line_below:
	set_bit(HCI_UART_PROTO_READY, &hu->flags);
 
 	err = hci_uart_register_dev(hu);
 	if (err) {
//flaw_line_below:
		clear_bit(HCI_UART_PROTO_READY, &hu->flags);
 		return err;
 	}
 
//fix_flaw_line_below:
//	set_bit(HCI_UART_PROTO_READY, &hu->flags);
 	return 0;
 }
",182700,"static int hci_uart_set_proto(struct hci_uart *hu, int id)
{
	const struct hci_uart_proto *p;
	int err;

	p = hci_uart_get_proto(id);
	if (!p)
 		return -EPROTONOSUPPORT;
 
 	hu->proto = p;
	set_bit(HCI_UART_PROTO_READY, &hu->flags);
 
 	err = hci_uart_register_dev(hu);
 	if (err) {
		clear_bit(HCI_UART_PROTO_READY, &hu->flags);
 		return err;
 	}
 
 	return 0;
 }
","static int hci_uart_set_proto(struct hci_uart *hu, int id)
{
	const struct hci_uart_proto *p;
	int err;

	p = hci_uart_get_proto(id);
	if (!p)
 		return -EPROTONOSUPPORT;
 
 	hu->proto = p;
 
 	err = hci_uart_register_dev(hu);
 	if (err) {
 		return err;
 	}
 
	set_bit(HCI_UART_PROTO_READY, &hu->flags);
 	return 0;
 }
","The vulnerability in the original code arises from the order of operations, where the `set_bit(HCI_UART_PROTO_READY, &hu->flags);` is executed before confirming successful registration of the device with `hci_uart_register_dev(hu)`. If the registration fails (indicated by a non-zero `err`), the flag remains set, potentially leading to inconsistent state and misuse of the protocol. In the fixed code, the `set_bit` operation is moved after the registration check, ensuring that the protocol is only marked as ready if the device registration is successful, thus maintaining a consistent and valid state.","The vulnerability in the original code stems from the improper sequence of operations, where a flag is set to indicate readiness before confirming the successful registration of a device. This can lead to a situation where the system believes the protocol is ready even if the registration fails, resulting in an inconsistent state and potential misuse of the protocol. The fixed code addresses this issue by rearranging the operations, ensuring that the readiness flag is only set after successful registration, thereby maintaining a valid and consistent state throughout the process."
55,182735,182735,,Remote,Not required,Partial,CVE-2019-14980,https://www.cvedetails.com/cve/CVE-2019-14980/,CWE-416,Medium,,,,2019-08-12,4.3,"In ImageMagick 7.x before 7.0.8-42 and 6.x before 6.9.10-42, there is a use after free vulnerability in the UnmapBlob function that allows an attacker to cause a denial of service by sending a crafted file.",2019-08-16,DoS ,1,https://github.com/ImageMagick/ImageMagick6/commit/614a257295bdcdeda347086761062ac7658b6830,614a257295bdcdeda347086761062ac7658b6830,https://github.com/ImageMagick/ImageMagick6/issues/43,0,magick/blob.c,"{""sha"": ""cdc693203976a5f78028574294a247d9e347ae09"", ""filename"": ""magick/blob.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick6/blob/614a257295bdcdeda347086761062ac7658b6830/magick/blob.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick6/raw/614a257295bdcdeda347086761062ac7658b6830/magick/blob.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick6/contents/magick/blob.c?ref=614a257295bdcdeda347086761062ac7658b6830"", ""patch"": ""@@ -700,6 +700,7 @@ MagickExport unsigned char *DetachBlob(BlobInfo *blob_info)\n   if (blob_info->mapped != MagickFalse)\n     {\n       (void) UnmapBlob(blob_info->data,blob_info->length);\n+      blob_info->data=NULL;\n       RelinquishMagickResource(MapResource,blob_info->length);\n     }\n   blob_info->mapped=MagickFalse;""}","MagickExport unsigned char *DetachBlob(BlobInfo *blob_info)
{
  unsigned char
    *data;

  assert(blob_info != (BlobInfo *) NULL);
  if (blob_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
   if (blob_info->mapped != MagickFalse)
     {
       (void) UnmapBlob(blob_info->data,blob_info->length);
      blob_info->data=NULL;
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;
  blob_info->length=0;
  blob_info->offset=0;
  blob_info->eof=MagickFalse;
  blob_info->error=0;
  blob_info->exempt=MagickFalse;
  blob_info->type=UndefinedStream;
  blob_info->file_info.file=(FILE *) NULL;
  data=blob_info->data;
  blob_info->data=(unsigned char *) NULL;
  blob_info->stream=(StreamHandler) NULL;
  return(data);
}
","MagickExport unsigned char *DetachBlob(BlobInfo *blob_info)
{
  unsigned char
    *data;

  assert(blob_info != (BlobInfo *) NULL);
  if (blob_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
   if (blob_info->mapped != MagickFalse)
     {
       (void) UnmapBlob(blob_info->data,blob_info->length);
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;
  blob_info->length=0;
  blob_info->offset=0;
  blob_info->eof=MagickFalse;
  blob_info->error=0;
  blob_info->exempt=MagickFalse;
  blob_info->type=UndefinedStream;
  blob_info->file_info.file=(FILE *) NULL;
  data=blob_info->data;
  blob_info->data=(unsigned char *) NULL;
  blob_info->stream=(StreamHandler) NULL;
  return(data);
}
",C,"      blob_info->data=NULL;
",,,"@@ -700,6 +700,7 @@ MagickExport unsigned char *DetachBlob(BlobInfo *blob_info)
   if (blob_info->mapped != MagickFalse)
     {
       (void) UnmapBlob(blob_info->data,blob_info->length);
+      blob_info->data=NULL;
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;",ImageMagick6,614a257295bdcdeda347086761062ac7658b6830,a1a7f79975cde3728b1283ba845bccf1a26a825d,1,"MagickExport unsigned char *DetachBlob(BlobInfo *blob_info)
{
  unsigned char
    *data;

  assert(blob_info != (BlobInfo *) NULL);
  if (blob_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
   if (blob_info->mapped != MagickFalse)
     {
       (void) UnmapBlob(blob_info->data,blob_info->length);
//fix_flaw_line_below:
//      blob_info->data=NULL;
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;
  blob_info->length=0;
  blob_info->offset=0;
  blob_info->eof=MagickFalse;
  blob_info->error=0;
  blob_info->exempt=MagickFalse;
  blob_info->type=UndefinedStream;
  blob_info->file_info.file=(FILE *) NULL;
  data=blob_info->data;
  blob_info->data=(unsigned char *) NULL;
  blob_info->stream=(StreamHandler) NULL;
  return(data);
}
",182735,"MagickExport unsigned char *DetachBlob(BlobInfo *blob_info)
{
  unsigned char
    *data;

  assert(blob_info != (BlobInfo *) NULL);
  if (blob_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
   if (blob_info->mapped != MagickFalse)
     {
       (void) UnmapBlob(blob_info->data,blob_info->length);
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;
  blob_info->length=0;
  blob_info->offset=0;
  blob_info->eof=MagickFalse;
  blob_info->error=0;
  blob_info->exempt=MagickFalse;
  blob_info->type=UndefinedStream;
  blob_info->file_info.file=(FILE *) NULL;
  data=blob_info->data;
  blob_info->data=(unsigned char *) NULL;
  blob_info->stream=(StreamHandler) NULL;
  return(data);
}
","MagickExport unsigned char *DetachBlob(BlobInfo *blob_info)
{
  unsigned char
    *data;

  assert(blob_info != (BlobInfo *) NULL);
  if (blob_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
   if (blob_info->mapped != MagickFalse)
     {
       (void) UnmapBlob(blob_info->data,blob_info->length);
      blob_info->data=NULL;
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;
  blob_info->length=0;
  blob_info->offset=0;
  blob_info->eof=MagickFalse;
  blob_info->error=0;
  blob_info->exempt=MagickFalse;
  blob_info->type=UndefinedStream;
  blob_info->file_info.file=(FILE *) NULL;
  data=blob_info->data;
  blob_info->data=(unsigned char *) NULL;
  blob_info->stream=(StreamHandler) NULL;
  return(data);
}
","The vulnerability in the original code lies in the potential use of a dangling pointer, as `blob_info->data` is accessed after it is unallocated. Specifically, if `blob_info->mapped` is true, the code unmaps the data and then relinquishes the resource without first setting `blob_info->data` to NULL, which could lead to undefined behavior if the data is accessed later. In the fixed code, the line `blob_info->data=NULL;` is added immediately after unmapping the data, ensuring that the pointer is safely set to NULL before any further operations, thus preventing any accidental access to freed memory.","The vulnerability in the original code arises from the risk of accessing a pointer that may point to freed memory, leading to undefined behavior. Specifically, after unmapping a resource, the pointer is not set to NULL, which means subsequent operations could inadvertently use this invalid memory reference. In the revised code, the fix involves explicitly setting the pointer to NULL after the resource is unmapped. This change ensures that any further attempts to access the pointer will be safely handled, preventing potential crashes or security issues associated with dereferencing a dangling pointer."
56,182785,182785,,Remote,Not required,Partial,CVE-2019-13224,https://www.cvedetails.com/cve/CVE-2019-13224/,CWE-416,Low,Partial,Partial,,2019-07-10,7.5,"A use-after-free in onig_new_deluxe() in regext.c in Oniguruma 6.9.2 allows attackers to potentially cause information disclosure, denial of service, or possibly code execution by providing a crafted regular expression. The attacker provides a pair of a regex pattern and a string, with a multi-byte encoding that gets handled by onig_new_deluxe(). Oniguruma issues often affect Ruby, as well as common optional libraries for PHP and Rust.",2019-07-17,DoS Exec Code ,1,https://github.com/kkos/oniguruma/commit/0f7f61ed1b7b697e283e37bd2d731d0bd57adb55,0f7f61ed1b7b697e283e37bd2d731d0bd57adb55,Fix CVE-2019-13224: don't allow different encodings for onig_new_deluxe(),3,src/regext.c,"{""sha"": ""965c7933d9c06c13284e4245115676647bf2b2d8"", ""filename"": ""src/regext.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/kkos/oniguruma/blob/0f7f61ed1b7b697e283e37bd2d731d0bd57adb55/src/regext.c"", ""raw_url"": ""https://github.com/kkos/oniguruma/raw/0f7f61ed1b7b697e283e37bd2d731d0bd57adb55/src/regext.c"", ""contents_url"": ""https://api.github.com/repos/kkos/oniguruma/contents/src/regext.c?ref=0f7f61ed1b7b697e283e37bd2d731d0bd57adb55"", ""patch"": ""@@ -29,6 +29,7 @@\n \n #include \""regint.h\""\n \n+#if 0\n static void\n conv_ext0be32(const UChar* s, const UChar* end, UChar* conv)\n {\n@@ -158,6 +159,7 @@ conv_encoding(OnigEncoding from, OnigEncoding to, const UChar* s, const UChar* e\n \n   return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;\n }\n+#endif\n \n extern int\n onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n@@ -169,9 +171,7 @@ onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n   if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n \n   if (ci->pattern_enc != ci->target_enc) {\n-    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n-                      &cpat, &cpat_end);\n-    if (r != 0) return r;\n+    return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;\n   }\n   else {\n     cpat     = (UChar* )pattern;""}"," onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,
                OnigCompileInfo* ci, OnigErrorInfo* einfo)
{
  int r;
  UChar *cpat, *cpat_end;

   if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;
 
   if (ci->pattern_enc != ci->target_enc) {
    return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;
   }
   else {
     cpat     = (UChar* )pattern;
    cpat_end = (UChar* )pattern_end;
  }

  *reg = (regex_t* )xmalloc(sizeof(regex_t));
  if (IS_NULL(*reg)) {
    r = ONIGERR_MEMORY;
    goto err2;
  }

  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,
                    ci->syntax);
  if (r != 0) goto err;

  r = onig_compile(*reg, cpat, cpat_end, einfo);
  if (r != 0) {
  err:
    onig_free(*reg);
    *reg = NULL;
  }

 err2:
  if (cpat != pattern) xfree(cpat);

  return r;
}
"," onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,
                OnigCompileInfo* ci, OnigErrorInfo* einfo)
{
  int r;
  UChar *cpat, *cpat_end;

   if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;
 
   if (ci->pattern_enc != ci->target_enc) {
    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,
                      &cpat, &cpat_end);
    if (r != 0) return r;
   }
   else {
     cpat     = (UChar* )pattern;
    cpat_end = (UChar* )pattern_end;
  }

  *reg = (regex_t* )xmalloc(sizeof(regex_t));
  if (IS_NULL(*reg)) {
    r = ONIGERR_MEMORY;
    goto err2;
  }

  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,
                    ci->syntax);
  if (r != 0) goto err;

  r = onig_compile(*reg, cpat, cpat_end, einfo);
  if (r != 0) {
  err:
    onig_free(*reg);
    *reg = NULL;
  }

 err2:
  if (cpat != pattern) xfree(cpat);

  return r;
}
",C,"    return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;
","    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,
                      &cpat, &cpat_end);
    if (r != 0) return r;
",,"@@ -29,6 +29,7 @@
 
 #include ""regint.h""
 
+#if 0
 static void
 conv_ext0be32(const UChar* s, const UChar* end, UChar* conv)
 {
@@ -158,6 +159,7 @@ conv_encoding(OnigEncoding from, OnigEncoding to, const UChar* s, const UChar* e
 
   return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;
 }
+#endif
 
 extern int
 onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,
@@ -169,9 +171,7 @@ onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,
   if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;
 
   if (ci->pattern_enc != ci->target_enc) {
-    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,
-                      &cpat, &cpat_end);
-    if (r != 0) return r;
+    return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;
   }
   else {
     cpat     = (UChar* )pattern;",oniguruma,0f7f61ed1b7b697e283e37bd2d731d0bd57adb55,c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c,1," onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,
                OnigCompileInfo* ci, OnigErrorInfo* einfo)
{
  int r;
  UChar *cpat, *cpat_end;

   if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;
 
   if (ci->pattern_enc != ci->target_enc) {
//flaw_line_below:
    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,
//flaw_line_below:
                      &cpat, &cpat_end);
//flaw_line_below:
    if (r != 0) return r;
//fix_flaw_line_below:
//    return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;
   }
   else {
     cpat     = (UChar* )pattern;
    cpat_end = (UChar* )pattern_end;
  }

  *reg = (regex_t* )xmalloc(sizeof(regex_t));
  if (IS_NULL(*reg)) {
    r = ONIGERR_MEMORY;
    goto err2;
  }

  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,
                    ci->syntax);
  if (r != 0) goto err;

  r = onig_compile(*reg, cpat, cpat_end, einfo);
  if (r != 0) {
  err:
    onig_free(*reg);
    *reg = NULL;
  }

 err2:
  if (cpat != pattern) xfree(cpat);

  return r;
}
",182785," onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,
                OnigCompileInfo* ci, OnigErrorInfo* einfo)
{
  int r;
  UChar *cpat, *cpat_end;

   if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;
 
   if (ci->pattern_enc != ci->target_enc) {
    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,
                      &cpat, &cpat_end);
    if (r != 0) return r;
   }
   else {
     cpat     = (UChar* )pattern;
    cpat_end = (UChar* )pattern_end;
  }

  *reg = (regex_t* )xmalloc(sizeof(regex_t));
  if (IS_NULL(*reg)) {
    r = ONIGERR_MEMORY;
    goto err2;
  }

  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,
                    ci->syntax);
  if (r != 0) goto err;

  r = onig_compile(*reg, cpat, cpat_end, einfo);
  if (r != 0) {
  err:
    onig_free(*reg);
    *reg = NULL;
  }

 err2:
  if (cpat != pattern) xfree(cpat);

  return r;
}
"," onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,
                OnigCompileInfo* ci, OnigErrorInfo* einfo)
{
  int r;
  UChar *cpat, *cpat_end;

   if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;
 
   if (ci->pattern_enc != ci->target_enc) {
    return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;
   }
   else {
     cpat     = (UChar* )pattern;
    cpat_end = (UChar* )pattern_end;
  }

  *reg = (regex_t* )xmalloc(sizeof(regex_t));
  if (IS_NULL(*reg)) {
    r = ONIGERR_MEMORY;
    goto err2;
  }

  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,
                    ci->syntax);
  if (r != 0) goto err;

  r = onig_compile(*reg, cpat, cpat_end, einfo);
  if (r != 0) {
  err:
    onig_free(*reg);
    *reg = NULL;
  }

 err2:
  if (cpat != pattern) xfree(cpat);

  return r;
}
","The vulnerability in the original code lies in the handling of different encoding combinations. If the `ci->pattern_enc` does not match `ci->target_enc`, the code attempts to convert the encoding using `conv_encoding`, but it does not properly handle unsupported combinations, potentially leading to undefined behavior or memory issues. In the fixed code, this vulnerability is addressed by immediately returning an error code `ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION` when the encodings do not match, thus preventing further execution and ensuring that the function exits safely without attempting to allocate memory or perform operations on invalid data.","The vulnerability in the original code arises from inadequate handling of unsupported encoding combinations, which could lead to undefined behavior or memory corruption if the encodings do not match. Specifically, the code attempts to convert the encoding without validating whether the conversion is successful, potentially allowing further operations on invalid data. The fix addresses this issue by introducing an immediate return of an error code when unsupported encodings are detected, effectively halting execution and preventing any subsequent memory allocation or processing that could result in instability or crashes."
57,182824,182824,,Local,Not required,Partial,CVE-2019-12819,https://www.cvedetails.com/cve/CVE-2019-12819/,CWE-416,Low,,,,2019-06-13,2.1,"An issue was discovered in the Linux kernel before 5.0. The function __mdiobus_register() in drivers/net/phy/mdio_bus.c calls put_device(), which will trigger a fixed_mdio_bus_init use-after-free. This will cause a denial of service.",2019-06-18,DoS ,0,https://github.com/torvalds/linux/commit/6ff7b060535e87c2ae14dd8548512abfdda528fb,6ff7b060535e87c2ae14dd8548512abfdda528fb,"mdio_bus: Fix use-after-free on device_register fails

KASAN has found use-after-free in fixed_mdio_bus_init,
commit 0c692d07842a (""drivers/net/phy/mdio_bus.c: call
put_device on device_register() failure"") call put_device()
while device_register() fails,give up the last reference
to the device and allow mdiobus_release to be executed
,kfreeing the bus. However in most drives, mdiobus_free
be called to free the bus while mdiobus_register fails.
use-after-free occurs when access bus again, this patch
revert it to let mdiobus_free free the bus.

KASAN report details as below:

BUG: KASAN: use-after-free in mdiobus_free+0x85/0x90 drivers/net/phy/mdio_bus.c:482
Read of size 4 at addr ffff8881dc824d78 by task syz-executor.0/3524

CPU: 1 PID: 3524 Comm: syz-executor.0 Not tainted 5.0.0-rc7+ #45
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
Call Trace:
 __dump_stack lib/dump_stack.c:77 [inline]
 dump_stack+0xfa/0x1ce lib/dump_stack.c:113
 print_address_description+0x65/0x270 mm/kasan/report.c:187
 kasan_report+0x149/0x18d mm/kasan/report.c:317
 mdiobus_free+0x85/0x90 drivers/net/phy/mdio_bus.c:482
 fixed_mdio_bus_init+0x283/0x1000 [fixed_phy]
 ? 0xffffffffc0e40000
 ? 0xffffffffc0e40000
 ? 0xffffffffc0e40000
 do_one_initcall+0xfa/0x5ca init/main.c:887
 do_init_module+0x204/0x5f6 kernel/module.c:3460
 load_module+0x66b2/0x8570 kernel/module.c:3808
 __do_sys_finit_module+0x238/0x2a0 kernel/module.c:3902
 do_syscall_64+0x147/0x600 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x49/0xbe
RIP: 0033:0x462e99
Code: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007f6215c19c58 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
RAX: ffffffffffffffda RBX: 000000000073bf00 RCX: 0000000000462e99
RDX: 0000000000000000 RSI: 0000000020000080 RDI: 0000000000000003
RBP: 00007f6215c19c70 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 00007f6215c1a6bc
R13: 00000000004bcefb R14: 00000000006f7030 R15: 0000000000000004

Allocated by task 3524:
 set_track mm/kasan/common.c:85 [inline]
 __kasan_kmalloc.constprop.3+0xa0/0xd0 mm/kasan/common.c:496
 kmalloc include/linux/slab.h:545 [inline]
 kzalloc include/linux/slab.h:740 [inline]
 mdiobus_alloc_size+0x54/0x1b0 drivers/net/phy/mdio_bus.c:143
 fixed_mdio_bus_init+0x163/0x1000 [fixed_phy]
 do_one_initcall+0xfa/0x5ca init/main.c:887
 do_init_module+0x204/0x5f6 kernel/module.c:3460
 load_module+0x66b2/0x8570 kernel/module.c:3808
 __do_sys_finit_module+0x238/0x2a0 kernel/module.c:3902
 do_syscall_64+0x147/0x600 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x49/0xbe

Freed by task 3524:
 set_track mm/kasan/common.c:85 [inline]
 __kasan_slab_free+0x130/0x180 mm/kasan/common.c:458
 slab_free_hook mm/slub.c:1409 [inline]
 slab_free_freelist_hook mm/slub.c:1436 [inline]
 slab_free mm/slub.c:2986 [inline]
 kfree+0xe1/0x270 mm/slub.c:3938
 device_release+0x78/0x200 drivers/base/core.c:919
 kobject_cleanup lib/kobject.c:662 [inline]
 kobject_release lib/kobject.c:691 [inline]
 kref_put include/linux/kref.h:67 [inline]
 kobject_put+0x146/0x240 lib/kobject.c:708
 put_device+0x1c/0x30 drivers/base/core.c:2060
 __mdiobus_register+0x483/0x560 drivers/net/phy/mdio_bus.c:382
 fixed_mdio_bus_init+0x26b/0x1000 [fixed_phy]
 do_one_initcall+0xfa/0x5ca init/main.c:887
 do_init_module+0x204/0x5f6 kernel/module.c:3460
 load_module+0x66b2/0x8570 kernel/module.c:3808
 __do_sys_finit_module+0x238/0x2a0 kernel/module.c:3902
 do_syscall_64+0x147/0x600 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x49/0xbe

The buggy address belongs to the object at ffff8881dc824c80
 which belongs to the cache kmalloc-2k of size 2048
The buggy address is located 248 bytes inside of
 2048-byte region [ffff8881dc824c80, ffff8881dc825480)
The buggy address belongs to the page:
page:ffffea0007720800 count:1 mapcount:0 mapping:ffff8881f6c02800 index:0x0 compound_mapcount: 0
flags: 0x2fffc0000010200(slab|head)
raw: 02fffc0000010200 0000000000000000 0000000500000001 ffff8881f6c02800
raw: 0000000000000000 00000000800f000f 00000001ffffffff 0000000000000000
page dumped because: kasan: bad access detected

Memory state around the buggy address:
 ffff8881dc824c00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
 ffff8881dc824c80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
>ffff8881dc824d00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                                                ^
 ffff8881dc824d80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff8881dc824e00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb

Fixes: 0c692d07842a (""drivers/net/phy/mdio_bus.c: call put_device on device_register() failure"")
Signed-off-by: YueHaibing <yuehaibing@huawei.com>
Reviewed-by: Andrew Lunn <andrew@lunn.ch>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,drivers/net/phy/mdio_bus.c,"{""sha"": ""7368616286ae9ced5b44e782e69877604025a7b6"", ""filename"": ""drivers/net/phy/mdio_bus.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/6ff7b060535e87c2ae14dd8548512abfdda528fb/drivers/net/phy/mdio_bus.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/6ff7b060535e87c2ae14dd8548512abfdda528fb/drivers/net/phy/mdio_bus.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/phy/mdio_bus.c?ref=6ff7b060535e87c2ae14dd8548512abfdda528fb"", ""patch"": ""@@ -379,7 +379,6 @@ int __mdiobus_register(struct mii_bus *bus, struct module *owner)\n \terr = device_register(&bus->dev);\n \tif (err) {\n \t\tpr_err(\""mii_bus %s failed to register\\n\"", bus->id);\n-\t\tput_device(&bus->dev);\n \t\treturn -EINVAL;\n \t}\n ""}","int __mdiobus_register(struct mii_bus *bus, struct module *owner)
{
	struct mdio_device *mdiodev;
	int i, err;
	struct gpio_desc *gpiod;

	if (NULL == bus || NULL == bus->name ||
	    NULL == bus->read || NULL == bus->write)
		return -EINVAL;

	BUG_ON(bus->state != MDIOBUS_ALLOCATED &&
	       bus->state != MDIOBUS_UNREGISTERED);

	bus->owner = owner;
	bus->dev.parent = bus->parent;
	bus->dev.class = &mdio_bus_class;
	bus->dev.groups = NULL;
	dev_set_name(&bus->dev, ""%s"", bus->id);

 	err = device_register(&bus->dev);
 	if (err) {
 		pr_err(""mii_bus %s failed to register\n"", bus->id);
 		return -EINVAL;
 	}
 
	mutex_init(&bus->mdio_lock);

	/* de-assert bus level PHY GPIO reset */
	gpiod = devm_gpiod_get_optional(&bus->dev, ""reset"", GPIOD_OUT_LOW);
	if (IS_ERR(gpiod)) {
		dev_err(&bus->dev, ""mii_bus %s couldn't get reset GPIO\n"",
			bus->id);
		device_del(&bus->dev);
		return PTR_ERR(gpiod);
	} else	if (gpiod) {
		bus->reset_gpiod = gpiod;

		gpiod_set_value_cansleep(gpiod, 1);
		udelay(bus->reset_delay_us);
		gpiod_set_value_cansleep(gpiod, 0);
	}

	if (bus->reset)
		bus->reset(bus);

	for (i = 0; i < PHY_MAX_ADDR; i++) {
		if ((bus->phy_mask & (1 << i)) == 0) {
			struct phy_device *phydev;

			phydev = mdiobus_scan(bus, i);
			if (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {
				err = PTR_ERR(phydev);
				goto error;
			}
		}
	}

	mdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);

	bus->state = MDIOBUS_REGISTERED;
	pr_info(""%s: probed\n"", bus->name);
	return 0;

error:
	while (--i >= 0) {
		mdiodev = bus->mdio_map[i];
		if (!mdiodev)
			continue;

		mdiodev->device_remove(mdiodev);
		mdiodev->device_free(mdiodev);
	}

	/* Put PHYs in RESET to save power */
	if (bus->reset_gpiod)
		gpiod_set_value_cansleep(bus->reset_gpiod, 1);

	device_del(&bus->dev);
	return err;
}
","int __mdiobus_register(struct mii_bus *bus, struct module *owner)
{
	struct mdio_device *mdiodev;
	int i, err;
	struct gpio_desc *gpiod;

	if (NULL == bus || NULL == bus->name ||
	    NULL == bus->read || NULL == bus->write)
		return -EINVAL;

	BUG_ON(bus->state != MDIOBUS_ALLOCATED &&
	       bus->state != MDIOBUS_UNREGISTERED);

	bus->owner = owner;
	bus->dev.parent = bus->parent;
	bus->dev.class = &mdio_bus_class;
	bus->dev.groups = NULL;
	dev_set_name(&bus->dev, ""%s"", bus->id);

 	err = device_register(&bus->dev);
 	if (err) {
 		pr_err(""mii_bus %s failed to register\n"", bus->id);
		put_device(&bus->dev);
 		return -EINVAL;
 	}
 
	mutex_init(&bus->mdio_lock);

	/* de-assert bus level PHY GPIO reset */
	gpiod = devm_gpiod_get_optional(&bus->dev, ""reset"", GPIOD_OUT_LOW);
	if (IS_ERR(gpiod)) {
		dev_err(&bus->dev, ""mii_bus %s couldn't get reset GPIO\n"",
			bus->id);
		device_del(&bus->dev);
		return PTR_ERR(gpiod);
	} else	if (gpiod) {
		bus->reset_gpiod = gpiod;

		gpiod_set_value_cansleep(gpiod, 1);
		udelay(bus->reset_delay_us);
		gpiod_set_value_cansleep(gpiod, 0);
	}

	if (bus->reset)
		bus->reset(bus);

	for (i = 0; i < PHY_MAX_ADDR; i++) {
		if ((bus->phy_mask & (1 << i)) == 0) {
			struct phy_device *phydev;

			phydev = mdiobus_scan(bus, i);
			if (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {
				err = PTR_ERR(phydev);
				goto error;
			}
		}
	}

	mdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);

	bus->state = MDIOBUS_REGISTERED;
	pr_info(""%s: probed\n"", bus->name);
	return 0;

error:
	while (--i >= 0) {
		mdiodev = bus->mdio_map[i];
		if (!mdiodev)
			continue;

		mdiodev->device_remove(mdiodev);
		mdiodev->device_free(mdiodev);
	}

	/* Put PHYs in RESET to save power */
	if (bus->reset_gpiod)
		gpiod_set_value_cansleep(bus->reset_gpiod, 1);

	device_del(&bus->dev);
	return err;
}
",C,,"		put_device(&bus->dev);
",,"@@ -379,7 +379,6 @@ int __mdiobus_register(struct mii_bus *bus, struct module *owner)
 	err = device_register(&bus->dev);
 	if (err) {
 		pr_err(""mii_bus %s failed to register\n"", bus->id);
-		put_device(&bus->dev);
 		return -EINVAL;
 	}
 ",linux,6ff7b060535e87c2ae14dd8548512abfdda528fb,97f0082a0592212fc15d4680f5a4d80f79a1687c,1,"int __mdiobus_register(struct mii_bus *bus, struct module *owner)
{
	struct mdio_device *mdiodev;
	int i, err;
	struct gpio_desc *gpiod;

	if (NULL == bus || NULL == bus->name ||
	    NULL == bus->read || NULL == bus->write)
		return -EINVAL;

	BUG_ON(bus->state != MDIOBUS_ALLOCATED &&
	       bus->state != MDIOBUS_UNREGISTERED);

	bus->owner = owner;
	bus->dev.parent = bus->parent;
	bus->dev.class = &mdio_bus_class;
	bus->dev.groups = NULL;
	dev_set_name(&bus->dev, ""%s"", bus->id);

 	err = device_register(&bus->dev);
 	if (err) {
 		pr_err(""mii_bus %s failed to register\n"", bus->id);
//flaw_line_below:
		put_device(&bus->dev);
 		return -EINVAL;
 	}
 
	mutex_init(&bus->mdio_lock);

	/* de-assert bus level PHY GPIO reset */
	gpiod = devm_gpiod_get_optional(&bus->dev, ""reset"", GPIOD_OUT_LOW);
	if (IS_ERR(gpiod)) {
		dev_err(&bus->dev, ""mii_bus %s couldn't get reset GPIO\n"",
			bus->id);
		device_del(&bus->dev);
		return PTR_ERR(gpiod);
	} else	if (gpiod) {
		bus->reset_gpiod = gpiod;

		gpiod_set_value_cansleep(gpiod, 1);
		udelay(bus->reset_delay_us);
		gpiod_set_value_cansleep(gpiod, 0);
	}

	if (bus->reset)
		bus->reset(bus);

	for (i = 0; i < PHY_MAX_ADDR; i++) {
		if ((bus->phy_mask & (1 << i)) == 0) {
			struct phy_device *phydev;

			phydev = mdiobus_scan(bus, i);
			if (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {
				err = PTR_ERR(phydev);
				goto error;
			}
		}
	}

	mdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);

	bus->state = MDIOBUS_REGISTERED;
	pr_info(""%s: probed\n"", bus->name);
	return 0;

error:
	while (--i >= 0) {
		mdiodev = bus->mdio_map[i];
		if (!mdiodev)
			continue;

		mdiodev->device_remove(mdiodev);
		mdiodev->device_free(mdiodev);
	}

	/* Put PHYs in RESET to save power */
	if (bus->reset_gpiod)
		gpiod_set_value_cansleep(bus->reset_gpiod, 1);

	device_del(&bus->dev);
	return err;
}
",182824,"int __mdiobus_register(struct mii_bus *bus, struct module *owner)
{
	struct mdio_device *mdiodev;
	int i, err;
	struct gpio_desc *gpiod;

	if (NULL == bus || NULL == bus->name ||
	    NULL == bus->read || NULL == bus->write)
		return -EINVAL;

	BUG_ON(bus->state != MDIOBUS_ALLOCATED &&
	       bus->state != MDIOBUS_UNREGISTERED);

	bus->owner = owner;
	bus->dev.parent = bus->parent;
	bus->dev.class = &mdio_bus_class;
	bus->dev.groups = NULL;
	dev_set_name(&bus->dev, ""%s"", bus->id);

 	err = device_register(&bus->dev);
 	if (err) {
 		pr_err(""mii_bus %s failed to register\n"", bus->id);
		put_device(&bus->dev);
 		return -EINVAL;
 	}
 
	mutex_init(&bus->mdio_lock);

	/* de-assert bus level PHY GPIO reset */
	gpiod = devm_gpiod_get_optional(&bus->dev, ""reset"", GPIOD_OUT_LOW);
	if (IS_ERR(gpiod)) {
		dev_err(&bus->dev, ""mii_bus %s couldn't get reset GPIO\n"",
			bus->id);
		device_del(&bus->dev);
		return PTR_ERR(gpiod);
	} else	if (gpiod) {
		bus->reset_gpiod = gpiod;

		gpiod_set_value_cansleep(gpiod, 1);
		udelay(bus->reset_delay_us);
		gpiod_set_value_cansleep(gpiod, 0);
	}

	if (bus->reset)
		bus->reset(bus);

	for (i = 0; i < PHY_MAX_ADDR; i++) {
		if ((bus->phy_mask & (1 << i)) == 0) {
			struct phy_device *phydev;

			phydev = mdiobus_scan(bus, i);
			if (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {
				err = PTR_ERR(phydev);
				goto error;
			}
		}
	}

	mdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);

	bus->state = MDIOBUS_REGISTERED;
	pr_info(""%s: probed\n"", bus->name);
	return 0;

error:
	while (--i >= 0) {
		mdiodev = bus->mdio_map[i];
		if (!mdiodev)
			continue;

		mdiodev->device_remove(mdiodev);
		mdiodev->device_free(mdiodev);
	}

	/* Put PHYs in RESET to save power */
	if (bus->reset_gpiod)
		gpiod_set_value_cansleep(bus->reset_gpiod, 1);

	device_del(&bus->dev);
	return err;
}
","int __mdiobus_register(struct mii_bus *bus, struct module *owner)
{
	struct mdio_device *mdiodev;
	int i, err;
	struct gpio_desc *gpiod;

	if (NULL == bus || NULL == bus->name ||
	    NULL == bus->read || NULL == bus->write)
		return -EINVAL;

	BUG_ON(bus->state != MDIOBUS_ALLOCATED &&
	       bus->state != MDIOBUS_UNREGISTERED);

	bus->owner = owner;
	bus->dev.parent = bus->parent;
	bus->dev.class = &mdio_bus_class;
	bus->dev.groups = NULL;
	dev_set_name(&bus->dev, ""%s"", bus->id);

 	err = device_register(&bus->dev);
 	if (err) {
 		pr_err(""mii_bus %s failed to register\n"", bus->id);
 		return -EINVAL;
 	}
 
	mutex_init(&bus->mdio_lock);

	/* de-assert bus level PHY GPIO reset */
	gpiod = devm_gpiod_get_optional(&bus->dev, ""reset"", GPIOD_OUT_LOW);
	if (IS_ERR(gpiod)) {
		dev_err(&bus->dev, ""mii_bus %s couldn't get reset GPIO\n"",
			bus->id);
		device_del(&bus->dev);
		return PTR_ERR(gpiod);
	} else	if (gpiod) {
		bus->reset_gpiod = gpiod;

		gpiod_set_value_cansleep(gpiod, 1);
		udelay(bus->reset_delay_us);
		gpiod_set_value_cansleep(gpiod, 0);
	}

	if (bus->reset)
		bus->reset(bus);

	for (i = 0; i < PHY_MAX_ADDR; i++) {
		if ((bus->phy_mask & (1 << i)) == 0) {
			struct phy_device *phydev;

			phydev = mdiobus_scan(bus, i);
			if (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {
				err = PTR_ERR(phydev);
				goto error;
			}
		}
	}

	mdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);

	bus->state = MDIOBUS_REGISTERED;
	pr_info(""%s: probed\n"", bus->name);
	return 0;

error:
	while (--i >= 0) {
		mdiodev = bus->mdio_map[i];
		if (!mdiodev)
			continue;

		mdiodev->device_remove(mdiodev);
		mdiodev->device_free(mdiodev);
	}

	/* Put PHYs in RESET to save power */
	if (bus->reset_gpiod)
		gpiod_set_value_cansleep(bus->reset_gpiod, 1);

	device_del(&bus->dev);
	return err;
}
","The vulnerability in the original code lies in the handling of the `device_register(&bus->dev)` function call. If this call fails, the code attempts to release the device with `put_device(&bus->dev)`, which is not present in the fixed code. This could lead to a resource leak or undefined behavior since the device may not be properly cleaned up. In the fixed code, the removal of `put_device(&bus->dev)` ensures that the device is not incorrectly referenced after a failed registration, thus preventing potential memory management issues and ensuring that resources are handled correctly.","The vulnerability in the original code arises from improper error handling during the device registration process. If the registration fails, the code attempts to release the device without ensuring that it was properly initialized, which could lead to resource leaks or undefined behavior. The fixed code addresses this issue by removing the erroneous release operation, ensuring that the device is not referenced incorrectly after a failed registration. This change enhances resource management and stability, preventing potential memory management issues and ensuring that resources are cleaned up appropriately in case of an error."
58,182841,182841,,Remote,Not required,Partial,CVE-2019-12106,https://www.cvedetails.com/cve/CVE-2019-12106/,CWE-416,Low,,,,2019-05-15,5.0,The updateDevice function in minissdpd.c in MiniUPnP MiniSSDPd 1.4 and 1.5 allows a remote attacker to crash the process due to a Use After Free vulnerability.,2019-05-26,,1,https://github.com/miniupnp/miniupnp/commit/cd506a67e174a45c6a202eff182a712955ed6d6f,cd506a67e174a45c6a202eff182a712955ed6d6f,updateDevice() remove element from the list when realloc fails,0,minissdpd/minissdpd.c,"{""sha"": ""5c9c5d6207c69365554e4c6c15feb28ea586558b"", ""filename"": ""minissdpd/minissdpd.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/miniupnp/miniupnp/blob/cd506a67e174a45c6a202eff182a712955ed6d6f/minissdpd/minissdpd.c"", ""raw_url"": ""https://github.com/miniupnp/miniupnp/raw/cd506a67e174a45c6a202eff182a712955ed6d6f/minissdpd/minissdpd.c"", ""contents_url"": ""https://api.github.com/repos/miniupnp/miniupnp/contents/minissdpd/minissdpd.c?ref=cd506a67e174a45c6a202eff182a712955ed6d6f"", ""patch"": ""@@ -318,6 +318,7 @@ updateDevice(const struct header * headers, time_t t)\n \t\t\t\tif(!tmp)\t/* allocation error */\n \t\t\t\t{\n \t\t\t\t\tsyslog(LOG_ERR, \""updateDevice() : memory allocation error\"");\n+\t\t\t\t\t*pp = p->next;\t/* remove \""p\"" from the list */\n \t\t\t\t\tfree(p);\n \t\t\t\t\treturn 0;\n \t\t\t\t}""}","updateDevice(const struct header * headers, time_t t)
{
	struct device ** pp = &devlist;
	struct device * p = *pp;	/* = devlist; */
	while(p)
	{
		if(  p->headers[HEADER_NT].l == headers[HEADER_NT].l
		  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))
		  && p->headers[HEADER_USN].l == headers[HEADER_USN].l
		  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )
		{
			/*printf(""found! %d\n"", (int)(t - p->t));*/
			syslog(LOG_DEBUG, ""device updated : %.*s"", headers[HEADER_USN].l, headers[HEADER_USN].p);
			p->t = t;
			/* update Location ! */
			if(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)
			{
				struct device * tmp;
				tmp = realloc(p, sizeof(struct device)
				    + headers[0].l+headers[1].l+headers[2].l);
 				if(!tmp)	/* allocation error */
 				{
 					syslog(LOG_ERR, ""updateDevice() : memory allocation error"");
					*pp = p->next;	/* remove ""p"" from the list */
 					free(p);
 					return 0;
 				}
				p = tmp;
				*pp = p;
			}
			memcpy(p->data + p->headers[0].l + p->headers[1].l,
			       headers[2].p, headers[2].l);
			/* TODO : check p->headers[HEADER_LOCATION].l */
			return 0;
		}
		pp = &p->next;
		p = *pp;	/* p = p->next; */
	}
	syslog(LOG_INFO, ""new device discovered : %.*s"",
	       headers[HEADER_USN].l, headers[HEADER_USN].p);
	/* add */
	{
		char * pc;
		int i;
		p = malloc(  sizeof(struct device)
		           + headers[0].l+headers[1].l+headers[2].l );
		if(!p) {
			syslog(LOG_ERR, ""updateDevice(): cannot allocate memory"");
			return -1;
		}
		p->next = devlist;
		p->t = t;
		pc = p->data;
		for(i = 0; i < 3; i++)
		{
			p->headers[i].p = pc;
			p->headers[i].l = headers[i].l;
			memcpy(pc, headers[i].p, headers[i].l);
			pc += headers[i].l;
		}
		devlist = p;
		sendNotifications(NOTIF_NEW, p, NULL);
	}
	return 1;
}
","updateDevice(const struct header * headers, time_t t)
{
	struct device ** pp = &devlist;
	struct device * p = *pp;	/* = devlist; */
	while(p)
	{
		if(  p->headers[HEADER_NT].l == headers[HEADER_NT].l
		  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))
		  && p->headers[HEADER_USN].l == headers[HEADER_USN].l
		  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )
		{
			/*printf(""found! %d\n"", (int)(t - p->t));*/
			syslog(LOG_DEBUG, ""device updated : %.*s"", headers[HEADER_USN].l, headers[HEADER_USN].p);
			p->t = t;
			/* update Location ! */
			if(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)
			{
				struct device * tmp;
				tmp = realloc(p, sizeof(struct device)
				    + headers[0].l+headers[1].l+headers[2].l);
 				if(!tmp)	/* allocation error */
 				{
 					syslog(LOG_ERR, ""updateDevice() : memory allocation error"");
 					free(p);
 					return 0;
 				}
				p = tmp;
				*pp = p;
			}
			memcpy(p->data + p->headers[0].l + p->headers[1].l,
			       headers[2].p, headers[2].l);
			/* TODO : check p->headers[HEADER_LOCATION].l */
			return 0;
		}
		pp = &p->next;
		p = *pp;	/* p = p->next; */
	}
	syslog(LOG_INFO, ""new device discovered : %.*s"",
	       headers[HEADER_USN].l, headers[HEADER_USN].p);
	/* add */
	{
		char * pc;
		int i;
		p = malloc(  sizeof(struct device)
		           + headers[0].l+headers[1].l+headers[2].l );
		if(!p) {
			syslog(LOG_ERR, ""updateDevice(): cannot allocate memory"");
			return -1;
		}
		p->next = devlist;
		p->t = t;
		pc = p->data;
		for(i = 0; i < 3; i++)
		{
			p->headers[i].p = pc;
			p->headers[i].l = headers[i].l;
			memcpy(pc, headers[i].p, headers[i].l);
			pc += headers[i].l;
		}
		devlist = p;
		sendNotifications(NOTIF_NEW, p, NULL);
	}
	return 1;
}
",C,"					*pp = p->next;	/* remove ""p"" from the list */
",,,"@@ -318,6 +318,7 @@ updateDevice(const struct header * headers, time_t t)
 				if(!tmp)	/* allocation error */
 				{
 					syslog(LOG_ERR, ""updateDevice() : memory allocation error"");
+					*pp = p->next;	/* remove ""p"" from the list */
 					free(p);
 					return 0;
 				}",miniupnp,cd506a67e174a45c6a202eff182a712955ed6d6f,9066896195927f9ffad4e3708d060c5c666b7bfd,1,"updateDevice(const struct header * headers, time_t t)
{
	struct device ** pp = &devlist;
	struct device * p = *pp;	/* = devlist; */
	while(p)
	{
		if(  p->headers[HEADER_NT].l == headers[HEADER_NT].l
		  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))
		  && p->headers[HEADER_USN].l == headers[HEADER_USN].l
		  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )
		{
			/*printf(""found! %d\n"", (int)(t - p->t));*/
			syslog(LOG_DEBUG, ""device updated : %.*s"", headers[HEADER_USN].l, headers[HEADER_USN].p);
			p->t = t;
			/* update Location ! */
			if(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)
			{
				struct device * tmp;
				tmp = realloc(p, sizeof(struct device)
				    + headers[0].l+headers[1].l+headers[2].l);
 				if(!tmp)	/* allocation error */
 				{
 					syslog(LOG_ERR, ""updateDevice() : memory allocation error"");
//fix_flaw_line_below:
//					*pp = p->next;	/* remove ""p"" from the list */
 					free(p);
 					return 0;
 				}
				p = tmp;
				*pp = p;
			}
			memcpy(p->data + p->headers[0].l + p->headers[1].l,
			       headers[2].p, headers[2].l);
			/* TODO : check p->headers[HEADER_LOCATION].l */
			return 0;
		}
		pp = &p->next;
		p = *pp;	/* p = p->next; */
	}
	syslog(LOG_INFO, ""new device discovered : %.*s"",
	       headers[HEADER_USN].l, headers[HEADER_USN].p);
	/* add */
	{
		char * pc;
		int i;
		p = malloc(  sizeof(struct device)
		           + headers[0].l+headers[1].l+headers[2].l );
		if(!p) {
			syslog(LOG_ERR, ""updateDevice(): cannot allocate memory"");
			return -1;
		}
		p->next = devlist;
		p->t = t;
		pc = p->data;
		for(i = 0; i < 3; i++)
		{
			p->headers[i].p = pc;
			p->headers[i].l = headers[i].l;
			memcpy(pc, headers[i].p, headers[i].l);
			pc += headers[i].l;
		}
		devlist = p;
		sendNotifications(NOTIF_NEW, p, NULL);
	}
	return 1;
}
",182841,"updateDevice(const struct header * headers, time_t t)
{
	struct device ** pp = &devlist;
	struct device * p = *pp;	/* = devlist; */
	while(p)
	{
		if(  p->headers[HEADER_NT].l == headers[HEADER_NT].l
		  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))
		  && p->headers[HEADER_USN].l == headers[HEADER_USN].l
		  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )
		{
			/*printf(""found! %d\n"", (int)(t - p->t));*/
			syslog(LOG_DEBUG, ""device updated : %.*s"", headers[HEADER_USN].l, headers[HEADER_USN].p);
			p->t = t;
			/* update Location ! */
			if(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)
			{
				struct device * tmp;
				tmp = realloc(p, sizeof(struct device)
				    + headers[0].l+headers[1].l+headers[2].l);
 				if(!tmp)	/* allocation error */
 				{
 					syslog(LOG_ERR, ""updateDevice() : memory allocation error"");
 					free(p);
 					return 0;
 				}
				p = tmp;
				*pp = p;
			}
			memcpy(p->data + p->headers[0].l + p->headers[1].l,
			       headers[2].p, headers[2].l);
			/* TODO : check p->headers[HEADER_LOCATION].l */
			return 0;
		}
		pp = &p->next;
		p = *pp;	/* p = p->next; */
	}
	syslog(LOG_INFO, ""new device discovered : %.*s"",
	       headers[HEADER_USN].l, headers[HEADER_USN].p);
	/* add */
	{
		char * pc;
		int i;
		p = malloc(  sizeof(struct device)
		           + headers[0].l+headers[1].l+headers[2].l );
		if(!p) {
			syslog(LOG_ERR, ""updateDevice(): cannot allocate memory"");
			return -1;
		}
		p->next = devlist;
		p->t = t;
		pc = p->data;
		for(i = 0; i < 3; i++)
		{
			p->headers[i].p = pc;
			p->headers[i].l = headers[i].l;
			memcpy(pc, headers[i].p, headers[i].l);
			pc += headers[i].l;
		}
		devlist = p;
		sendNotifications(NOTIF_NEW, p, NULL);
	}
	return 1;
}
","updateDevice(const struct header * headers, time_t t)
{
	struct device ** pp = &devlist;
	struct device * p = *pp;	/* = devlist; */
	while(p)
	{
		if(  p->headers[HEADER_NT].l == headers[HEADER_NT].l
		  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))
		  && p->headers[HEADER_USN].l == headers[HEADER_USN].l
		  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )
		{
			/*printf(""found! %d\n"", (int)(t - p->t));*/
			syslog(LOG_DEBUG, ""device updated : %.*s"", headers[HEADER_USN].l, headers[HEADER_USN].p);
			p->t = t;
			/* update Location ! */
			if(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)
			{
				struct device * tmp;
				tmp = realloc(p, sizeof(struct device)
				    + headers[0].l+headers[1].l+headers[2].l);
 				if(!tmp)	/* allocation error */
 				{
 					syslog(LOG_ERR, ""updateDevice() : memory allocation error"");
					*pp = p->next;	/* remove ""p"" from the list */
 					free(p);
 					return 0;
 				}
				p = tmp;
				*pp = p;
			}
			memcpy(p->data + p->headers[0].l + p->headers[1].l,
			       headers[2].p, headers[2].l);
			/* TODO : check p->headers[HEADER_LOCATION].l */
			return 0;
		}
		pp = &p->next;
		p = *pp;	/* p = p->next; */
	}
	syslog(LOG_INFO, ""new device discovered : %.*s"",
	       headers[HEADER_USN].l, headers[HEADER_USN].p);
	/* add */
	{
		char * pc;
		int i;
		p = malloc(  sizeof(struct device)
		           + headers[0].l+headers[1].l+headers[2].l );
		if(!p) {
			syslog(LOG_ERR, ""updateDevice(): cannot allocate memory"");
			return -1;
		}
		p->next = devlist;
		p->t = t;
		pc = p->data;
		for(i = 0; i < 3; i++)
		{
			p->headers[i].p = pc;
			p->headers[i].l = headers[i].l;
			memcpy(pc, headers[i].p, headers[i].l);
			pc += headers[i].l;
		}
		devlist = p;
		sendNotifications(NOTIF_NEW, p, NULL);
	}
	return 1;
}
","The vulnerability in the original code arises from improper handling of memory allocation errors during the `realloc` operation. If `realloc` fails, the code attempts to free the original pointer `p`, which may lead to a dangling pointer situation since `p` is still referenced in the linked list. This could cause undefined behavior if the list is accessed afterward. In the fixed code, the vulnerability is addressed by updating the linked list pointer `*pp` to skip the freed device `p` before calling `free(p)`, ensuring that the list remains intact and preventing potential access to freed memory.","The vulnerability in the original code stems from inadequate error handling during memory reallocation, which could lead to memory corruption or access violations. If the reallocation fails, the code attempts to free the original memory block without properly updating the linked list, potentially leaving a dangling pointer that could be accessed later. This situation risks undefined behavior and crashes. The fixed code resolves this issue by ensuring that the linked list is updated to bypass the freed memory before it is released, thereby maintaining the integrity of the list and preventing access to invalid memory."
59,182852,182852,,Remote,Not required,Complete,CVE-2019-11811,https://www.cvedetails.com/cve/CVE-2019-11811/,CWE-416,Low,Complete,Complete,,2019-05-07,10.0,"An issue was discovered in the Linux kernel before 5.0.4. There is a use-after-free upon attempted read access to /proc/ioports after the ipmi_si module is removed, related to drivers/char/ipmi/ipmi_si_intf.c, drivers/char/ipmi/ipmi_si_mem_io.c, and drivers/char/ipmi/ipmi_si_port_io.c.",2019-05-31,,5,https://github.com/torvalds/linux/commit/401e7e88d4ef80188ffa07095ac00456f901b8c4,401e7e88d4ef80188ffa07095ac00456f901b8c4,"ipmi_si: fix use-after-free of resource->name

When we excute the following commands, we got oops
rmmod ipmi_si
cat /proc/ioports

[ 1623.482380] Unable to handle kernel paging request at virtual address ffff00000901d478
[ 1623.482382] Mem abort info:
[ 1623.482383]   ESR = 0x96000007
[ 1623.482385]   Exception class = DABT (current EL), IL = 32 bits
[ 1623.482386]   SET = 0, FnV = 0
[ 1623.482387]   EA = 0, S1PTW = 0
[ 1623.482388] Data abort info:
[ 1623.482389]   ISV = 0, ISS = 0x00000007
[ 1623.482390]   CM = 0, WnR = 0
[ 1623.482393] swapper pgtable: 4k pages, 48-bit VAs, pgdp = 00000000d7d94a66
[ 1623.482395] [ffff00000901d478] pgd=000000dffbfff003, pud=000000dffbffe003, pmd=0000003f5d06e003, pte=0000000000000000
[ 1623.482399] Internal error: Oops: 96000007 [#1] SMP
[ 1623.487407] Modules linked in: ipmi_si(E) nls_utf8 isofs rpcrdma ib_iser ib_srpt target_core_mod ib_srp scsi_transport_srp ib_ipoib rdma_ucm ib_umad rdma_cm ib_cm dm_mirror dm_region_hash dm_log iw_cm dm_mod aes_ce_blk crypto_simd cryptd aes_ce_cipher ses ghash_ce sha2_ce enclosure sha256_arm64 sg sha1_ce hisi_sas_v2_hw hibmc_drm sbsa_gwdt hisi_sas_main ip_tables mlx5_ib ib_uverbs marvell ib_core mlx5_core ixgbe mdio hns_dsaf ipmi_devintf hns_enet_drv ipmi_msghandler hns_mdio [last unloaded: ipmi_si]
[ 1623.532410] CPU: 30 PID: 11438 Comm: cat Kdump: loaded Tainted: G            E     5.0.0-rc3+ #168
[ 1623.541498] Hardware name: Huawei TaiShan 2280 /BC11SPCD, BIOS 1.37 11/21/2017
[ 1623.548822] pstate: a0000005 (NzCv daif -PAN -UAO)
[ 1623.553684] pc : string+0x28/0x98
[ 1623.557040] lr : vsnprintf+0x368/0x5e8
[ 1623.560837] sp : ffff000013213a80
[ 1623.564191] x29: ffff000013213a80 x28: ffff00001138abb5
[ 1623.569577] x27: ffff000013213c18 x26: ffff805f67d06049
[ 1623.574963] x25: 0000000000000000 x24: ffff00001138abb5
[ 1623.580349] x23: 0000000000000fb7 x22: ffff0000117ed000
[ 1623.585734] x21: ffff000011188fd8 x20: ffff805f67d07000
[ 1623.591119] x19: ffff805f67d06061 x18: ffffffffffffffff
[ 1623.596505] x17: 0000000000000200 x16: 0000000000000000
[ 1623.601890] x15: ffff0000117ed748 x14: ffff805f67d07000
[ 1623.607276] x13: ffff805f67d0605e x12: 0000000000000000
[ 1623.612661] x11: 0000000000000000 x10: 0000000000000000
[ 1623.618046] x9 : 0000000000000000 x8 : 000000000000000f
[ 1623.623432] x7 : ffff805f67d06061 x6 : fffffffffffffffe
[ 1623.628817] x5 : 0000000000000012 x4 : ffff00000901d478
[ 1623.634203] x3 : ffff0a00ffffff04 x2 : ffff805f67d07000
[ 1623.639588] x1 : ffff805f67d07000 x0 : ffffffffffffffff
[ 1623.644974] Process cat (pid: 11438, stack limit = 0x000000008d4cbc10)
[ 1623.651592] Call trace:
[ 1623.654068]  string+0x28/0x98
[ 1623.657071]  vsnprintf+0x368/0x5e8
[ 1623.660517]  seq_vprintf+0x70/0x98
[ 1623.668009]  seq_printf+0x7c/0xa0
[ 1623.675530]  r_show+0xc8/0xf8
[ 1623.682558]  seq_read+0x330/0x440
[ 1623.689877]  proc_reg_read+0x78/0xd0
[ 1623.697346]  __vfs_read+0x60/0x1a0
[ 1623.704564]  vfs_read+0x94/0x150
[ 1623.711339]  ksys_read+0x6c/0xd8
[ 1623.717939]  __arm64_sys_read+0x24/0x30
[ 1623.725077]  el0_svc_common+0x120/0x148
[ 1623.732035]  el0_svc_handler+0x30/0x40
[ 1623.738757]  el0_svc+0x8/0xc
[ 1623.744520] Code: d1000406 aa0103e2 54000149 b4000080 (39400085)
[ 1623.753441] ---[ end trace f91b6a4937de9835 ]---
[ 1623.760871] Kernel panic - not syncing: Fatal exception
[ 1623.768935] SMP: stopping secondary CPUs
[ 1623.775718] Kernel Offset: disabled
[ 1623.781998] CPU features: 0x002,21006008
[ 1623.788777] Memory Limit: none
[ 1623.798329] Starting crashdump kernel...
[ 1623.805202] Bye!

If io_setup is called successful in try_smi_init() but try_smi_init()
goes out_err before calling ipmi_register_smi(), so ipmi_unregister_smi()
will not be called while removing module. It leads to the resource that
allocated in io_setup() can not be freed, but the name(DEVICE_NAME) of
resource is freed while removing the module. It causes use-after-free
when cat /proc/ioports.

Fix this by calling io_cleanup() while try_smi_init() goes to out_err.
and don't call io_cleanup() until io_setup() returns successful to avoid
warning prints.

Fixes: 93c303d2045b (""ipmi_si: Clean up shutdown a bit"")
Cc: stable@vger.kernel.org
Reported-by: NuoHan Qiao <qiaonuohan@huawei.com>
Suggested-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Yang Yingliang <yangyingliang@huawei.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>",0,drivers/char/ipmi/ipmi_si_intf.c,"{""sha"": ""f1b9fda6b9dfbc7e89b1d02b7a5777393923783f"", ""filename"": ""drivers/char/ipmi/ipmi_si_intf.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_intf.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_intf.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/ipmi/ipmi_si_intf.c?ref=401e7e88d4ef80188ffa07095ac00456f901b8c4"", ""patch"": ""@@ -2085,6 +2085,11 @@ static int try_smi_init(struct smi_info *new_smi)\n \tWARN_ON(new_smi->io.dev->init_name != NULL);\n \n  out_err:\n+\tif (rv && new_smi->io.io_cleanup) {\n+\t\tnew_smi->io.io_cleanup(&new_smi->io);\n+\t\tnew_smi->io.io_cleanup = NULL;\n+\t}\n+\n \tkfree(init_name);\n \treturn rv;\n }""}<_**next**_>{""sha"": ""75583612ab10551367cd74d727a0cbda958d0429"", ""filename"": ""drivers/char/ipmi/ipmi_si_mem_io.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_mem_io.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_mem_io.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/ipmi/ipmi_si_mem_io.c?ref=401e7e88d4ef80188ffa07095ac00456f901b8c4"", ""patch"": ""@@ -81,8 +81,6 @@ int ipmi_si_mem_setup(struct si_sm_io *io)\n \tif (!addr)\n \t\treturn -ENODEV;\n \n-\tio->io_cleanup = mem_cleanup;\n-\n \t/*\n \t * Figure out the actual readb/readw/readl/etc routine to use based\n \t * upon the register size.\n@@ -141,5 +139,8 @@ int ipmi_si_mem_setup(struct si_sm_io *io)\n \t\tmem_region_cleanup(io, io->io_size);\n \t\treturn -EIO;\n \t}\n+\n+\tio->io_cleanup = mem_cleanup;\n+\n \treturn 0;\n }""}<_**next**_>{""sha"": ""03924c32b6e98035ad3b873c4d19320d8aa89567"", ""filename"": ""drivers/char/ipmi/ipmi_si_port_io.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_port_io.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_port_io.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/ipmi/ipmi_si_port_io.c?ref=401e7e88d4ef80188ffa07095ac00456f901b8c4"", ""patch"": ""@@ -68,8 +68,6 @@ int ipmi_si_port_setup(struct si_sm_io *io)\n \tif (!addr)\n \t\treturn -ENODEV;\n \n-\tio->io_cleanup = port_cleanup;\n-\n \t/*\n \t * Figure out the actual inb/inw/inl/etc routine to use based\n \t * upon the register size.\n@@ -109,5 +107,8 @@ int ipmi_si_port_setup(struct si_sm_io *io)\n \t\t\treturn -EIO;\n \t\t}\n \t}\n+\n+\tio->io_cleanup = port_cleanup;\n+\n \treturn 0;\n }""}","static int try_smi_init(struct smi_info *new_smi)
{
	int rv = 0;
	int i;
	char *init_name = NULL;

	pr_info(""Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\n"",
		ipmi_addr_src_to_str(new_smi->io.addr_source),
		si_to_str[new_smi->io.si_type],
		addr_space_to_str[new_smi->io.addr_type],
		new_smi->io.addr_data,
		new_smi->io.slave_addr, new_smi->io.irq);

	switch (new_smi->io.si_type) {
	case SI_KCS:
		new_smi->handlers = &kcs_smi_handlers;
		break;

	case SI_SMIC:
		new_smi->handlers = &smic_smi_handlers;
		break;

	case SI_BT:
		new_smi->handlers = &bt_smi_handlers;
		break;

	default:
		/* No support for anything else yet. */
		rv = -EIO;
		goto out_err;
	}

	new_smi->si_num = smi_num;

	/* Do this early so it's available for logs. */
	if (!new_smi->io.dev) {
		init_name = kasprintf(GFP_KERNEL, ""ipmi_si.%d"",
				      new_smi->si_num);

		/*
		 * If we don't already have a device from something
		 * else (like PCI), then register a new one.
		 */
		new_smi->pdev = platform_device_alloc(""ipmi_si"",
						      new_smi->si_num);
		if (!new_smi->pdev) {
			pr_err(""Unable to allocate platform device\n"");
			rv = -ENOMEM;
			goto out_err;
		}
		new_smi->io.dev = &new_smi->pdev->dev;
		new_smi->io.dev->driver = &ipmi_platform_driver.driver;
		/* Nulled by device_add() */
		new_smi->io.dev->init_name = init_name;
	}

	/* Allocate the state machine's data and initialize it. */
	new_smi->si_sm = kmalloc(new_smi->handlers->size(), GFP_KERNEL);
	if (!new_smi->si_sm) {
		rv = -ENOMEM;
		goto out_err;
	}
	new_smi->io.io_size = new_smi->handlers->init_data(new_smi->si_sm,
							   &new_smi->io);

	/* Now that we know the I/O size, we can set up the I/O. */
	rv = new_smi->io.io_setup(&new_smi->io);
	if (rv) {
		dev_err(new_smi->io.dev, ""Could not set up I/O space\n"");
		goto out_err;
	}

	/* Do low-level detection first. */
	if (new_smi->handlers->detect(new_smi->si_sm)) {
		if (new_smi->io.addr_source)
			dev_err(new_smi->io.dev,
				""Interface detection failed\n"");
		rv = -ENODEV;
		goto out_err;
	}

	/*
	 * Attempt a get device id command.  If it fails, we probably
	 * don't have a BMC here.
	 */
	rv = try_get_dev_id(new_smi);
	if (rv) {
		if (new_smi->io.addr_source)
			dev_err(new_smi->io.dev,
			       ""There appears to be no BMC at this location\n"");
		goto out_err;
	}

	setup_oem_data_handler(new_smi);
	setup_xaction_handlers(new_smi);
	check_for_broken_irqs(new_smi);

	new_smi->waiting_msg = NULL;
	new_smi->curr_msg = NULL;
	atomic_set(&new_smi->req_events, 0);
	new_smi->run_to_completion = false;
	for (i = 0; i < SI_NUM_STATS; i++)
		atomic_set(&new_smi->stats[i], 0);

	new_smi->interrupt_disabled = true;
	atomic_set(&new_smi->need_watch, 0);

	rv = try_enable_event_buffer(new_smi);
	if (rv == 0)
		new_smi->has_event_buffer = true;

	/*
	 * Start clearing the flags before we enable interrupts or the
	 * timer to avoid racing with the timer.
	 */
	start_clear_flags(new_smi);

	/*
	 * IRQ is defined to be set when non-zero.  req_events will
	 * cause a global flags check that will enable interrupts.
	 */
	if (new_smi->io.irq) {
		new_smi->interrupt_disabled = false;
		atomic_set(&new_smi->req_events, 1);
	}

	if (new_smi->pdev && !new_smi->pdev_registered) {
		rv = platform_device_add(new_smi->pdev);
		if (rv) {
			dev_err(new_smi->io.dev,
				""Unable to register system interface device: %d\n"",
				rv);
			goto out_err;
		}
		new_smi->pdev_registered = true;
	}

	dev_set_drvdata(new_smi->io.dev, new_smi);
	rv = device_add_group(new_smi->io.dev, &ipmi_si_dev_attr_group);
	if (rv) {
		dev_err(new_smi->io.dev,
			""Unable to add device attributes: error %d\n"",
			rv);
		goto out_err;
	}
	new_smi->dev_group_added = true;

	rv = ipmi_register_smi(&handlers,
			       new_smi,
			       new_smi->io.dev,
			       new_smi->io.slave_addr);
	if (rv) {
		dev_err(new_smi->io.dev,
			""Unable to register device: error %d\n"",
			rv);
		goto out_err;
	}

	/* Don't increment till we know we have succeeded. */
	smi_num++;

	dev_info(new_smi->io.dev, ""IPMI %s interface initialized\n"",
		 si_to_str[new_smi->io.si_type]);

 	WARN_ON(new_smi->io.dev->init_name != NULL);
 
  out_err:
	if (rv && new_smi->io.io_cleanup) {
		new_smi->io.io_cleanup(&new_smi->io);
		new_smi->io.io_cleanup = NULL;
	}

 	kfree(init_name);
 	return rv;
 }
","static int try_smi_init(struct smi_info *new_smi)
{
	int rv = 0;
	int i;
	char *init_name = NULL;

	pr_info(""Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\n"",
		ipmi_addr_src_to_str(new_smi->io.addr_source),
		si_to_str[new_smi->io.si_type],
		addr_space_to_str[new_smi->io.addr_type],
		new_smi->io.addr_data,
		new_smi->io.slave_addr, new_smi->io.irq);

	switch (new_smi->io.si_type) {
	case SI_KCS:
		new_smi->handlers = &kcs_smi_handlers;
		break;

	case SI_SMIC:
		new_smi->handlers = &smic_smi_handlers;
		break;

	case SI_BT:
		new_smi->handlers = &bt_smi_handlers;
		break;

	default:
		/* No support for anything else yet. */
		rv = -EIO;
		goto out_err;
	}

	new_smi->si_num = smi_num;

	/* Do this early so it's available for logs. */
	if (!new_smi->io.dev) {
		init_name = kasprintf(GFP_KERNEL, ""ipmi_si.%d"",
				      new_smi->si_num);

		/*
		 * If we don't already have a device from something
		 * else (like PCI), then register a new one.
		 */
		new_smi->pdev = platform_device_alloc(""ipmi_si"",
						      new_smi->si_num);
		if (!new_smi->pdev) {
			pr_err(""Unable to allocate platform device\n"");
			rv = -ENOMEM;
			goto out_err;
		}
		new_smi->io.dev = &new_smi->pdev->dev;
		new_smi->io.dev->driver = &ipmi_platform_driver.driver;
		/* Nulled by device_add() */
		new_smi->io.dev->init_name = init_name;
	}

	/* Allocate the state machine's data and initialize it. */
	new_smi->si_sm = kmalloc(new_smi->handlers->size(), GFP_KERNEL);
	if (!new_smi->si_sm) {
		rv = -ENOMEM;
		goto out_err;
	}
	new_smi->io.io_size = new_smi->handlers->init_data(new_smi->si_sm,
							   &new_smi->io);

	/* Now that we know the I/O size, we can set up the I/O. */
	rv = new_smi->io.io_setup(&new_smi->io);
	if (rv) {
		dev_err(new_smi->io.dev, ""Could not set up I/O space\n"");
		goto out_err;
	}

	/* Do low-level detection first. */
	if (new_smi->handlers->detect(new_smi->si_sm)) {
		if (new_smi->io.addr_source)
			dev_err(new_smi->io.dev,
				""Interface detection failed\n"");
		rv = -ENODEV;
		goto out_err;
	}

	/*
	 * Attempt a get device id command.  If it fails, we probably
	 * don't have a BMC here.
	 */
	rv = try_get_dev_id(new_smi);
	if (rv) {
		if (new_smi->io.addr_source)
			dev_err(new_smi->io.dev,
			       ""There appears to be no BMC at this location\n"");
		goto out_err;
	}

	setup_oem_data_handler(new_smi);
	setup_xaction_handlers(new_smi);
	check_for_broken_irqs(new_smi);

	new_smi->waiting_msg = NULL;
	new_smi->curr_msg = NULL;
	atomic_set(&new_smi->req_events, 0);
	new_smi->run_to_completion = false;
	for (i = 0; i < SI_NUM_STATS; i++)
		atomic_set(&new_smi->stats[i], 0);

	new_smi->interrupt_disabled = true;
	atomic_set(&new_smi->need_watch, 0);

	rv = try_enable_event_buffer(new_smi);
	if (rv == 0)
		new_smi->has_event_buffer = true;

	/*
	 * Start clearing the flags before we enable interrupts or the
	 * timer to avoid racing with the timer.
	 */
	start_clear_flags(new_smi);

	/*
	 * IRQ is defined to be set when non-zero.  req_events will
	 * cause a global flags check that will enable interrupts.
	 */
	if (new_smi->io.irq) {
		new_smi->interrupt_disabled = false;
		atomic_set(&new_smi->req_events, 1);
	}

	if (new_smi->pdev && !new_smi->pdev_registered) {
		rv = platform_device_add(new_smi->pdev);
		if (rv) {
			dev_err(new_smi->io.dev,
				""Unable to register system interface device: %d\n"",
				rv);
			goto out_err;
		}
		new_smi->pdev_registered = true;
	}

	dev_set_drvdata(new_smi->io.dev, new_smi);
	rv = device_add_group(new_smi->io.dev, &ipmi_si_dev_attr_group);
	if (rv) {
		dev_err(new_smi->io.dev,
			""Unable to add device attributes: error %d\n"",
			rv);
		goto out_err;
	}
	new_smi->dev_group_added = true;

	rv = ipmi_register_smi(&handlers,
			       new_smi,
			       new_smi->io.dev,
			       new_smi->io.slave_addr);
	if (rv) {
		dev_err(new_smi->io.dev,
			""Unable to register device: error %d\n"",
			rv);
		goto out_err;
	}

	/* Don't increment till we know we have succeeded. */
	smi_num++;

	dev_info(new_smi->io.dev, ""IPMI %s interface initialized\n"",
		 si_to_str[new_smi->io.si_type]);

 	WARN_ON(new_smi->io.dev->init_name != NULL);
 
  out_err:
 	kfree(init_name);
 	return rv;
 }
",C,"	if (rv && new_smi->io.io_cleanup) {
		new_smi->io.io_cleanup(&new_smi->io);
		new_smi->io.io_cleanup = NULL;
	}

",,,"@@ -2085,6 +2085,11 @@ static int try_smi_init(struct smi_info *new_smi)
 	WARN_ON(new_smi->io.dev->init_name != NULL);
 
  out_err:
+	if (rv && new_smi->io.io_cleanup) {
+		new_smi->io.io_cleanup(&new_smi->io);
+		new_smi->io.io_cleanup = NULL;
+	}
+
 	kfree(init_name);
 	return rv;
 }",linux,401e7e88d4ef80188ffa07095ac00456f901b8c4,df3865f8f56879b7e9f0ca47fa7bc5f2252df6d3,1,"static int try_smi_init(struct smi_info *new_smi)
{
	int rv = 0;
	int i;
	char *init_name = NULL;

	pr_info(""Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\n"",
		ipmi_addr_src_to_str(new_smi->io.addr_source),
		si_to_str[new_smi->io.si_type],
		addr_space_to_str[new_smi->io.addr_type],
		new_smi->io.addr_data,
		new_smi->io.slave_addr, new_smi->io.irq);

	switch (new_smi->io.si_type) {
	case SI_KCS:
		new_smi->handlers = &kcs_smi_handlers;
		break;

	case SI_SMIC:
		new_smi->handlers = &smic_smi_handlers;
		break;

	case SI_BT:
		new_smi->handlers = &bt_smi_handlers;
		break;

	default:
		/* No support for anything else yet. */
		rv = -EIO;
		goto out_err;
	}

	new_smi->si_num = smi_num;

	/* Do this early so it's available for logs. */
	if (!new_smi->io.dev) {
		init_name = kasprintf(GFP_KERNEL, ""ipmi_si.%d"",
				      new_smi->si_num);

		/*
		 * If we don't already have a device from something
		 * else (like PCI), then register a new one.
		 */
		new_smi->pdev = platform_device_alloc(""ipmi_si"",
						      new_smi->si_num);
		if (!new_smi->pdev) {
			pr_err(""Unable to allocate platform device\n"");
			rv = -ENOMEM;
			goto out_err;
		}
		new_smi->io.dev = &new_smi->pdev->dev;
		new_smi->io.dev->driver = &ipmi_platform_driver.driver;
		/* Nulled by device_add() */
		new_smi->io.dev->init_name = init_name;
	}

	/* Allocate the state machine's data and initialize it. */
	new_smi->si_sm = kmalloc(new_smi->handlers->size(), GFP_KERNEL);
	if (!new_smi->si_sm) {
		rv = -ENOMEM;
		goto out_err;
	}
	new_smi->io.io_size = new_smi->handlers->init_data(new_smi->si_sm,
							   &new_smi->io);

	/* Now that we know the I/O size, we can set up the I/O. */
	rv = new_smi->io.io_setup(&new_smi->io);
	if (rv) {
		dev_err(new_smi->io.dev, ""Could not set up I/O space\n"");
		goto out_err;
	}

	/* Do low-level detection first. */
	if (new_smi->handlers->detect(new_smi->si_sm)) {
		if (new_smi->io.addr_source)
			dev_err(new_smi->io.dev,
				""Interface detection failed\n"");
		rv = -ENODEV;
		goto out_err;
	}

	/*
	 * Attempt a get device id command.  If it fails, we probably
	 * don't have a BMC here.
	 */
	rv = try_get_dev_id(new_smi);
	if (rv) {
		if (new_smi->io.addr_source)
			dev_err(new_smi->io.dev,
			       ""There appears to be no BMC at this location\n"");
		goto out_err;
	}

	setup_oem_data_handler(new_smi);
	setup_xaction_handlers(new_smi);
	check_for_broken_irqs(new_smi);

	new_smi->waiting_msg = NULL;
	new_smi->curr_msg = NULL;
	atomic_set(&new_smi->req_events, 0);
	new_smi->run_to_completion = false;
	for (i = 0; i < SI_NUM_STATS; i++)
		atomic_set(&new_smi->stats[i], 0);

	new_smi->interrupt_disabled = true;
	atomic_set(&new_smi->need_watch, 0);

	rv = try_enable_event_buffer(new_smi);
	if (rv == 0)
		new_smi->has_event_buffer = true;

	/*
	 * Start clearing the flags before we enable interrupts or the
	 * timer to avoid racing with the timer.
	 */
	start_clear_flags(new_smi);

	/*
	 * IRQ is defined to be set when non-zero.  req_events will
	 * cause a global flags check that will enable interrupts.
	 */
	if (new_smi->io.irq) {
		new_smi->interrupt_disabled = false;
		atomic_set(&new_smi->req_events, 1);
	}

	if (new_smi->pdev && !new_smi->pdev_registered) {
		rv = platform_device_add(new_smi->pdev);
		if (rv) {
			dev_err(new_smi->io.dev,
				""Unable to register system interface device: %d\n"",
				rv);
			goto out_err;
		}
		new_smi->pdev_registered = true;
	}

	dev_set_drvdata(new_smi->io.dev, new_smi);
	rv = device_add_group(new_smi->io.dev, &ipmi_si_dev_attr_group);
	if (rv) {
		dev_err(new_smi->io.dev,
			""Unable to add device attributes: error %d\n"",
			rv);
		goto out_err;
	}
	new_smi->dev_group_added = true;

	rv = ipmi_register_smi(&handlers,
			       new_smi,
			       new_smi->io.dev,
			       new_smi->io.slave_addr);
	if (rv) {
		dev_err(new_smi->io.dev,
			""Unable to register device: error %d\n"",
			rv);
		goto out_err;
	}

	/* Don't increment till we know we have succeeded. */
	smi_num++;

	dev_info(new_smi->io.dev, ""IPMI %s interface initialized\n"",
		 si_to_str[new_smi->io.si_type]);

 	WARN_ON(new_smi->io.dev->init_name != NULL);
 
  out_err:
//fix_flaw_line_below:
//	if (rv && new_smi->io.io_cleanup) {
//fix_flaw_line_below:
//		new_smi->io.io_cleanup(&new_smi->io);
//fix_flaw_line_below:
//		new_smi->io.io_cleanup = NULL;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	kfree(init_name);
 	return rv;
 }
",182852,"static int try_smi_init(struct smi_info *new_smi)
{
	int rv = 0;
	int i;
	char *init_name = NULL;

	pr_info(""Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\n"",
		ipmi_addr_src_to_str(new_smi->io.addr_source),
		si_to_str[new_smi->io.si_type],
		addr_space_to_str[new_smi->io.addr_type],
		new_smi->io.addr_data,
		new_smi->io.slave_addr, new_smi->io.irq);

	switch (new_smi->io.si_type) {
	case SI_KCS:
		new_smi->handlers = &kcs_smi_handlers;
		break;

	case SI_SMIC:
		new_smi->handlers = &smic_smi_handlers;
		break;

	case SI_BT:
		new_smi->handlers = &bt_smi_handlers;
		break;

	default:
		/* No support for anything else yet. */
		rv = -EIO;
		goto out_err;
	}

	new_smi->si_num = smi_num;

	/* Do this early so it's available for logs. */
	if (!new_smi->io.dev) {
		init_name = kasprintf(GFP_KERNEL, ""ipmi_si.%d"",
				      new_smi->si_num);

		/*
		 * If we don't already have a device from something
		 * else (like PCI), then register a new one.
		 */
		new_smi->pdev = platform_device_alloc(""ipmi_si"",
						      new_smi->si_num);
		if (!new_smi->pdev) {
			pr_err(""Unable to allocate platform device\n"");
			rv = -ENOMEM;
			goto out_err;
		}
		new_smi->io.dev = &new_smi->pdev->dev;
		new_smi->io.dev->driver = &ipmi_platform_driver.driver;
		/* Nulled by device_add() */
		new_smi->io.dev->init_name = init_name;
	}

	/* Allocate the state machine's data and initialize it. */
	new_smi->si_sm = kmalloc(new_smi->handlers->size(), GFP_KERNEL);
	if (!new_smi->si_sm) {
		rv = -ENOMEM;
		goto out_err;
	}
	new_smi->io.io_size = new_smi->handlers->init_data(new_smi->si_sm,
							   &new_smi->io);

	/* Now that we know the I/O size, we can set up the I/O. */
	rv = new_smi->io.io_setup(&new_smi->io);
	if (rv) {
		dev_err(new_smi->io.dev, ""Could not set up I/O space\n"");
		goto out_err;
	}

	/* Do low-level detection first. */
	if (new_smi->handlers->detect(new_smi->si_sm)) {
		if (new_smi->io.addr_source)
			dev_err(new_smi->io.dev,
				""Interface detection failed\n"");
		rv = -ENODEV;
		goto out_err;
	}

	/*
	 * Attempt a get device id command.  If it fails, we probably
	 * don't have a BMC here.
	 */
	rv = try_get_dev_id(new_smi);
	if (rv) {
		if (new_smi->io.addr_source)
			dev_err(new_smi->io.dev,
			       ""There appears to be no BMC at this location\n"");
		goto out_err;
	}

	setup_oem_data_handler(new_smi);
	setup_xaction_handlers(new_smi);
	check_for_broken_irqs(new_smi);

	new_smi->waiting_msg = NULL;
	new_smi->curr_msg = NULL;
	atomic_set(&new_smi->req_events, 0);
	new_smi->run_to_completion = false;
	for (i = 0; i < SI_NUM_STATS; i++)
		atomic_set(&new_smi->stats[i], 0);

	new_smi->interrupt_disabled = true;
	atomic_set(&new_smi->need_watch, 0);

	rv = try_enable_event_buffer(new_smi);
	if (rv == 0)
		new_smi->has_event_buffer = true;

	/*
	 * Start clearing the flags before we enable interrupts or the
	 * timer to avoid racing with the timer.
	 */
	start_clear_flags(new_smi);

	/*
	 * IRQ is defined to be set when non-zero.  req_events will
	 * cause a global flags check that will enable interrupts.
	 */
	if (new_smi->io.irq) {
		new_smi->interrupt_disabled = false;
		atomic_set(&new_smi->req_events, 1);
	}

	if (new_smi->pdev && !new_smi->pdev_registered) {
		rv = platform_device_add(new_smi->pdev);
		if (rv) {
			dev_err(new_smi->io.dev,
				""Unable to register system interface device: %d\n"",
				rv);
			goto out_err;
		}
		new_smi->pdev_registered = true;
	}

	dev_set_drvdata(new_smi->io.dev, new_smi);
	rv = device_add_group(new_smi->io.dev, &ipmi_si_dev_attr_group);
	if (rv) {
		dev_err(new_smi->io.dev,
			""Unable to add device attributes: error %d\n"",
			rv);
		goto out_err;
	}
	new_smi->dev_group_added = true;

	rv = ipmi_register_smi(&handlers,
			       new_smi,
			       new_smi->io.dev,
			       new_smi->io.slave_addr);
	if (rv) {
		dev_err(new_smi->io.dev,
			""Unable to register device: error %d\n"",
			rv);
		goto out_err;
	}

	/* Don't increment till we know we have succeeded. */
	smi_num++;

	dev_info(new_smi->io.dev, ""IPMI %s interface initialized\n"",
		 si_to_str[new_smi->io.si_type]);

 	WARN_ON(new_smi->io.dev->init_name != NULL);
 
  out_err:
 	kfree(init_name);
 	return rv;
 }
","static int try_smi_init(struct smi_info *new_smi)
{
	int rv = 0;
	int i;
	char *init_name = NULL;

	pr_info(""Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\n"",
		ipmi_addr_src_to_str(new_smi->io.addr_source),
		si_to_str[new_smi->io.si_type],
		addr_space_to_str[new_smi->io.addr_type],
		new_smi->io.addr_data,
		new_smi->io.slave_addr, new_smi->io.irq);

	switch (new_smi->io.si_type) {
	case SI_KCS:
		new_smi->handlers = &kcs_smi_handlers;
		break;

	case SI_SMIC:
		new_smi->handlers = &smic_smi_handlers;
		break;

	case SI_BT:
		new_smi->handlers = &bt_smi_handlers;
		break;

	default:
		/* No support for anything else yet. */
		rv = -EIO;
		goto out_err;
	}

	new_smi->si_num = smi_num;

	/* Do this early so it's available for logs. */
	if (!new_smi->io.dev) {
		init_name = kasprintf(GFP_KERNEL, ""ipmi_si.%d"",
				      new_smi->si_num);

		/*
		 * If we don't already have a device from something
		 * else (like PCI), then register a new one.
		 */
		new_smi->pdev = platform_device_alloc(""ipmi_si"",
						      new_smi->si_num);
		if (!new_smi->pdev) {
			pr_err(""Unable to allocate platform device\n"");
			rv = -ENOMEM;
			goto out_err;
		}
		new_smi->io.dev = &new_smi->pdev->dev;
		new_smi->io.dev->driver = &ipmi_platform_driver.driver;
		/* Nulled by device_add() */
		new_smi->io.dev->init_name = init_name;
	}

	/* Allocate the state machine's data and initialize it. */
	new_smi->si_sm = kmalloc(new_smi->handlers->size(), GFP_KERNEL);
	if (!new_smi->si_sm) {
		rv = -ENOMEM;
		goto out_err;
	}
	new_smi->io.io_size = new_smi->handlers->init_data(new_smi->si_sm,
							   &new_smi->io);

	/* Now that we know the I/O size, we can set up the I/O. */
	rv = new_smi->io.io_setup(&new_smi->io);
	if (rv) {
		dev_err(new_smi->io.dev, ""Could not set up I/O space\n"");
		goto out_err;
	}

	/* Do low-level detection first. */
	if (new_smi->handlers->detect(new_smi->si_sm)) {
		if (new_smi->io.addr_source)
			dev_err(new_smi->io.dev,
				""Interface detection failed\n"");
		rv = -ENODEV;
		goto out_err;
	}

	/*
	 * Attempt a get device id command.  If it fails, we probably
	 * don't have a BMC here.
	 */
	rv = try_get_dev_id(new_smi);
	if (rv) {
		if (new_smi->io.addr_source)
			dev_err(new_smi->io.dev,
			       ""There appears to be no BMC at this location\n"");
		goto out_err;
	}

	setup_oem_data_handler(new_smi);
	setup_xaction_handlers(new_smi);
	check_for_broken_irqs(new_smi);

	new_smi->waiting_msg = NULL;
	new_smi->curr_msg = NULL;
	atomic_set(&new_smi->req_events, 0);
	new_smi->run_to_completion = false;
	for (i = 0; i < SI_NUM_STATS; i++)
		atomic_set(&new_smi->stats[i], 0);

	new_smi->interrupt_disabled = true;
	atomic_set(&new_smi->need_watch, 0);

	rv = try_enable_event_buffer(new_smi);
	if (rv == 0)
		new_smi->has_event_buffer = true;

	/*
	 * Start clearing the flags before we enable interrupts or the
	 * timer to avoid racing with the timer.
	 */
	start_clear_flags(new_smi);

	/*
	 * IRQ is defined to be set when non-zero.  req_events will
	 * cause a global flags check that will enable interrupts.
	 */
	if (new_smi->io.irq) {
		new_smi->interrupt_disabled = false;
		atomic_set(&new_smi->req_events, 1);
	}

	if (new_smi->pdev && !new_smi->pdev_registered) {
		rv = platform_device_add(new_smi->pdev);
		if (rv) {
			dev_err(new_smi->io.dev,
				""Unable to register system interface device: %d\n"",
				rv);
			goto out_err;
		}
		new_smi->pdev_registered = true;
	}

	dev_set_drvdata(new_smi->io.dev, new_smi);
	rv = device_add_group(new_smi->io.dev, &ipmi_si_dev_attr_group);
	if (rv) {
		dev_err(new_smi->io.dev,
			""Unable to add device attributes: error %d\n"",
			rv);
		goto out_err;
	}
	new_smi->dev_group_added = true;

	rv = ipmi_register_smi(&handlers,
			       new_smi,
			       new_smi->io.dev,
			       new_smi->io.slave_addr);
	if (rv) {
		dev_err(new_smi->io.dev,
			""Unable to register device: error %d\n"",
			rv);
		goto out_err;
	}

	/* Don't increment till we know we have succeeded. */
	smi_num++;

	dev_info(new_smi->io.dev, ""IPMI %s interface initialized\n"",
		 si_to_str[new_smi->io.si_type]);

 	WARN_ON(new_smi->io.dev->init_name != NULL);
 
  out_err:
	if (rv && new_smi->io.io_cleanup) {
		new_smi->io.io_cleanup(&new_smi->io);
		new_smi->io.io_cleanup = NULL;
	}

 	kfree(init_name);
 	return rv;
 }
","The vulnerability in the original code lies in the lack of proper cleanup when an error occurs during the initialization of the state machine, particularly after allocating resources like `new_smi->si_sm` and `new_smi->pdev`. If any step fails, such as memory allocation or device registration, the code jumps to `out_err` without ensuring that allocated resources are released, potentially leading to memory leaks or dangling pointers. The fixed code addresses this by adding a check for `new_smi->io.io_cleanup` in the `out_err` section, ensuring that any necessary cleanup is performed if an error occurs, thus preventing resource leaks.","The vulnerability in the original code stems from inadequate error handling during the initialization process, which could lead to resource leaks if any allocation or setup fails. Specifically, if an error occurs after resources are allocated but before they are properly released, the code does not ensure that these resources are cleaned up, potentially resulting in memory leaks or undefined behavior. The revised code addresses this issue by introducing a cleanup mechanism that checks for the need to release resources if an error occurs, thereby ensuring that all allocated resources are properly managed and preventing leaks."
60,182853,182853,,Remote,Not required,Complete,CVE-2019-11811,https://www.cvedetails.com/cve/CVE-2019-11811/,CWE-416,Low,Complete,Complete,,2019-05-07,10.0,"An issue was discovered in the Linux kernel before 5.0.4. There is a use-after-free upon attempted read access to /proc/ioports after the ipmi_si module is removed, related to drivers/char/ipmi/ipmi_si_intf.c, drivers/char/ipmi/ipmi_si_mem_io.c, and drivers/char/ipmi/ipmi_si_port_io.c.",2019-05-31,,3,https://github.com/torvalds/linux/commit/401e7e88d4ef80188ffa07095ac00456f901b8c4,401e7e88d4ef80188ffa07095ac00456f901b8c4,"ipmi_si: fix use-after-free of resource->name

When we excute the following commands, we got oops
rmmod ipmi_si
cat /proc/ioports

[ 1623.482380] Unable to handle kernel paging request at virtual address ffff00000901d478
[ 1623.482382] Mem abort info:
[ 1623.482383]   ESR = 0x96000007
[ 1623.482385]   Exception class = DABT (current EL), IL = 32 bits
[ 1623.482386]   SET = 0, FnV = 0
[ 1623.482387]   EA = 0, S1PTW = 0
[ 1623.482388] Data abort info:
[ 1623.482389]   ISV = 0, ISS = 0x00000007
[ 1623.482390]   CM = 0, WnR = 0
[ 1623.482393] swapper pgtable: 4k pages, 48-bit VAs, pgdp = 00000000d7d94a66
[ 1623.482395] [ffff00000901d478] pgd=000000dffbfff003, pud=000000dffbffe003, pmd=0000003f5d06e003, pte=0000000000000000
[ 1623.482399] Internal error: Oops: 96000007 [#1] SMP
[ 1623.487407] Modules linked in: ipmi_si(E) nls_utf8 isofs rpcrdma ib_iser ib_srpt target_core_mod ib_srp scsi_transport_srp ib_ipoib rdma_ucm ib_umad rdma_cm ib_cm dm_mirror dm_region_hash dm_log iw_cm dm_mod aes_ce_blk crypto_simd cryptd aes_ce_cipher ses ghash_ce sha2_ce enclosure sha256_arm64 sg sha1_ce hisi_sas_v2_hw hibmc_drm sbsa_gwdt hisi_sas_main ip_tables mlx5_ib ib_uverbs marvell ib_core mlx5_core ixgbe mdio hns_dsaf ipmi_devintf hns_enet_drv ipmi_msghandler hns_mdio [last unloaded: ipmi_si]
[ 1623.532410] CPU: 30 PID: 11438 Comm: cat Kdump: loaded Tainted: G            E     5.0.0-rc3+ #168
[ 1623.541498] Hardware name: Huawei TaiShan 2280 /BC11SPCD, BIOS 1.37 11/21/2017
[ 1623.548822] pstate: a0000005 (NzCv daif -PAN -UAO)
[ 1623.553684] pc : string+0x28/0x98
[ 1623.557040] lr : vsnprintf+0x368/0x5e8
[ 1623.560837] sp : ffff000013213a80
[ 1623.564191] x29: ffff000013213a80 x28: ffff00001138abb5
[ 1623.569577] x27: ffff000013213c18 x26: ffff805f67d06049
[ 1623.574963] x25: 0000000000000000 x24: ffff00001138abb5
[ 1623.580349] x23: 0000000000000fb7 x22: ffff0000117ed000
[ 1623.585734] x21: ffff000011188fd8 x20: ffff805f67d07000
[ 1623.591119] x19: ffff805f67d06061 x18: ffffffffffffffff
[ 1623.596505] x17: 0000000000000200 x16: 0000000000000000
[ 1623.601890] x15: ffff0000117ed748 x14: ffff805f67d07000
[ 1623.607276] x13: ffff805f67d0605e x12: 0000000000000000
[ 1623.612661] x11: 0000000000000000 x10: 0000000000000000
[ 1623.618046] x9 : 0000000000000000 x8 : 000000000000000f
[ 1623.623432] x7 : ffff805f67d06061 x6 : fffffffffffffffe
[ 1623.628817] x5 : 0000000000000012 x4 : ffff00000901d478
[ 1623.634203] x3 : ffff0a00ffffff04 x2 : ffff805f67d07000
[ 1623.639588] x1 : ffff805f67d07000 x0 : ffffffffffffffff
[ 1623.644974] Process cat (pid: 11438, stack limit = 0x000000008d4cbc10)
[ 1623.651592] Call trace:
[ 1623.654068]  string+0x28/0x98
[ 1623.657071]  vsnprintf+0x368/0x5e8
[ 1623.660517]  seq_vprintf+0x70/0x98
[ 1623.668009]  seq_printf+0x7c/0xa0
[ 1623.675530]  r_show+0xc8/0xf8
[ 1623.682558]  seq_read+0x330/0x440
[ 1623.689877]  proc_reg_read+0x78/0xd0
[ 1623.697346]  __vfs_read+0x60/0x1a0
[ 1623.704564]  vfs_read+0x94/0x150
[ 1623.711339]  ksys_read+0x6c/0xd8
[ 1623.717939]  __arm64_sys_read+0x24/0x30
[ 1623.725077]  el0_svc_common+0x120/0x148
[ 1623.732035]  el0_svc_handler+0x30/0x40
[ 1623.738757]  el0_svc+0x8/0xc
[ 1623.744520] Code: d1000406 aa0103e2 54000149 b4000080 (39400085)
[ 1623.753441] ---[ end trace f91b6a4937de9835 ]---
[ 1623.760871] Kernel panic - not syncing: Fatal exception
[ 1623.768935] SMP: stopping secondary CPUs
[ 1623.775718] Kernel Offset: disabled
[ 1623.781998] CPU features: 0x002,21006008
[ 1623.788777] Memory Limit: none
[ 1623.798329] Starting crashdump kernel...
[ 1623.805202] Bye!

If io_setup is called successful in try_smi_init() but try_smi_init()
goes out_err before calling ipmi_register_smi(), so ipmi_unregister_smi()
will not be called while removing module. It leads to the resource that
allocated in io_setup() can not be freed, but the name(DEVICE_NAME) of
resource is freed while removing the module. It causes use-after-free
when cat /proc/ioports.

Fix this by calling io_cleanup() while try_smi_init() goes to out_err.
and don't call io_cleanup() until io_setup() returns successful to avoid
warning prints.

Fixes: 93c303d2045b (""ipmi_si: Clean up shutdown a bit"")
Cc: stable@vger.kernel.org
Reported-by: NuoHan Qiao <qiaonuohan@huawei.com>
Suggested-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Yang Yingliang <yangyingliang@huawei.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>",1,drivers/char/ipmi/ipmi_si_mem_io.c,"{""sha"": ""f1b9fda6b9dfbc7e89b1d02b7a5777393923783f"", ""filename"": ""drivers/char/ipmi/ipmi_si_intf.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_intf.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_intf.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/ipmi/ipmi_si_intf.c?ref=401e7e88d4ef80188ffa07095ac00456f901b8c4"", ""patch"": ""@@ -2085,6 +2085,11 @@ static int try_smi_init(struct smi_info *new_smi)\n \tWARN_ON(new_smi->io.dev->init_name != NULL);\n \n  out_err:\n+\tif (rv && new_smi->io.io_cleanup) {\n+\t\tnew_smi->io.io_cleanup(&new_smi->io);\n+\t\tnew_smi->io.io_cleanup = NULL;\n+\t}\n+\n \tkfree(init_name);\n \treturn rv;\n }""}<_**next**_>{""sha"": ""75583612ab10551367cd74d727a0cbda958d0429"", ""filename"": ""drivers/char/ipmi/ipmi_si_mem_io.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_mem_io.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_mem_io.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/ipmi/ipmi_si_mem_io.c?ref=401e7e88d4ef80188ffa07095ac00456f901b8c4"", ""patch"": ""@@ -81,8 +81,6 @@ int ipmi_si_mem_setup(struct si_sm_io *io)\n \tif (!addr)\n \t\treturn -ENODEV;\n \n-\tio->io_cleanup = mem_cleanup;\n-\n \t/*\n \t * Figure out the actual readb/readw/readl/etc routine to use based\n \t * upon the register size.\n@@ -141,5 +139,8 @@ int ipmi_si_mem_setup(struct si_sm_io *io)\n \t\tmem_region_cleanup(io, io->io_size);\n \t\treturn -EIO;\n \t}\n+\n+\tio->io_cleanup = mem_cleanup;\n+\n \treturn 0;\n }""}<_**next**_>{""sha"": ""03924c32b6e98035ad3b873c4d19320d8aa89567"", ""filename"": ""drivers/char/ipmi/ipmi_si_port_io.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_port_io.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_port_io.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/ipmi/ipmi_si_port_io.c?ref=401e7e88d4ef80188ffa07095ac00456f901b8c4"", ""patch"": ""@@ -68,8 +68,6 @@ int ipmi_si_port_setup(struct si_sm_io *io)\n \tif (!addr)\n \t\treturn -ENODEV;\n \n-\tio->io_cleanup = port_cleanup;\n-\n \t/*\n \t * Figure out the actual inb/inw/inl/etc routine to use based\n \t * upon the register size.\n@@ -109,5 +107,8 @@ int ipmi_si_port_setup(struct si_sm_io *io)\n \t\t\treturn -EIO;\n \t\t}\n \t}\n+\n+\tio->io_cleanup = port_cleanup;\n+\n \treturn 0;\n }""}","int ipmi_si_mem_setup(struct si_sm_io *io)
{
	unsigned long addr = io->addr_data;
	int           mapsize, idx;

 	if (!addr)
 		return -ENODEV;
 
 	/*
 	 * Figure out the actual readb/readw/readl/etc routine to use based
 	 * upon the register size.
	 */
	switch (io->regsize) {
	case 1:
		io->inputb = intf_mem_inb;
		io->outputb = intf_mem_outb;
		break;
	case 2:
		io->inputb = intf_mem_inw;
		io->outputb = intf_mem_outw;
		break;
	case 4:
		io->inputb = intf_mem_inl;
		io->outputb = intf_mem_outl;
		break;
#ifdef readq
	case 8:
		io->inputb = mem_inq;
		io->outputb = mem_outq;
		break;
#endif
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}

	/*
	 * Some BIOSes reserve disjoint memory regions in their ACPI
	 * tables.  This causes problems when trying to request the
	 * entire region.  Therefore we must request each register
	 * separately.
	 */
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_mem_region(addr + idx * io->regspacing,
				       io->regsize, DEVICE_NAME) == NULL) {
			/* Undo allocations */
			mem_region_cleanup(io, idx);
			return -EIO;
		}
	}

	/*
	 * Calculate the total amount of memory to claim.  This is an
	 * unusual looking calculation, but it avoids claiming any
	 * more memory than it has to.  It will claim everything
	 * between the first address to the end of the last full
	 * register.
	 */
	mapsize = ((io->io_size * io->regspacing)
		   - (io->regspacing - io->regsize));
	io->addr = ioremap(addr, mapsize);
	if (io->addr == NULL) {
 		mem_region_cleanup(io, io->io_size);
 		return -EIO;
 	}

	io->io_cleanup = mem_cleanup;

 	return 0;
 }
","int ipmi_si_mem_setup(struct si_sm_io *io)
{
	unsigned long addr = io->addr_data;
	int           mapsize, idx;

 	if (!addr)
 		return -ENODEV;
 
	io->io_cleanup = mem_cleanup;
 	/*
 	 * Figure out the actual readb/readw/readl/etc routine to use based
 	 * upon the register size.
	 */
	switch (io->regsize) {
	case 1:
		io->inputb = intf_mem_inb;
		io->outputb = intf_mem_outb;
		break;
	case 2:
		io->inputb = intf_mem_inw;
		io->outputb = intf_mem_outw;
		break;
	case 4:
		io->inputb = intf_mem_inl;
		io->outputb = intf_mem_outl;
		break;
#ifdef readq
	case 8:
		io->inputb = mem_inq;
		io->outputb = mem_outq;
		break;
#endif
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}

	/*
	 * Some BIOSes reserve disjoint memory regions in their ACPI
	 * tables.  This causes problems when trying to request the
	 * entire region.  Therefore we must request each register
	 * separately.
	 */
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_mem_region(addr + idx * io->regspacing,
				       io->regsize, DEVICE_NAME) == NULL) {
			/* Undo allocations */
			mem_region_cleanup(io, idx);
			return -EIO;
		}
	}

	/*
	 * Calculate the total amount of memory to claim.  This is an
	 * unusual looking calculation, but it avoids claiming any
	 * more memory than it has to.  It will claim everything
	 * between the first address to the end of the last full
	 * register.
	 */
	mapsize = ((io->io_size * io->regspacing)
		   - (io->regspacing - io->regsize));
	io->addr = ioremap(addr, mapsize);
	if (io->addr == NULL) {
 		mem_region_cleanup(io, io->io_size);
 		return -EIO;
 	}
 	return 0;
 }
",C,"
	io->io_cleanup = mem_cleanup;

","	io->io_cleanup = mem_cleanup;
",,"@@ -81,8 +81,6 @@ int ipmi_si_mem_setup(struct si_sm_io *io)
 	if (!addr)
 		return -ENODEV;
 
-	io->io_cleanup = mem_cleanup;
-
 	/*
 	 * Figure out the actual readb/readw/readl/etc routine to use based
 	 * upon the register size.
@@ -141,5 +139,8 @@ int ipmi_si_mem_setup(struct si_sm_io *io)
 		mem_region_cleanup(io, io->io_size);
 		return -EIO;
 	}
+
+	io->io_cleanup = mem_cleanup;
+
 	return 0;
 }",linux,401e7e88d4ef80188ffa07095ac00456f901b8c4,df3865f8f56879b7e9f0ca47fa7bc5f2252df6d3,1,"int ipmi_si_mem_setup(struct si_sm_io *io)
{
	unsigned long addr = io->addr_data;
	int           mapsize, idx;

 	if (!addr)
 		return -ENODEV;
 
//flaw_line_below:
	io->io_cleanup = mem_cleanup;
//flaw_line_below:

 	/*
 	 * Figure out the actual readb/readw/readl/etc routine to use based
 	 * upon the register size.
	 */
	switch (io->regsize) {
	case 1:
		io->inputb = intf_mem_inb;
		io->outputb = intf_mem_outb;
		break;
	case 2:
		io->inputb = intf_mem_inw;
		io->outputb = intf_mem_outw;
		break;
	case 4:
		io->inputb = intf_mem_inl;
		io->outputb = intf_mem_outl;
		break;
#ifdef readq
	case 8:
		io->inputb = mem_inq;
		io->outputb = mem_outq;
		break;
#endif
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}

	/*
	 * Some BIOSes reserve disjoint memory regions in their ACPI
	 * tables.  This causes problems when trying to request the
	 * entire region.  Therefore we must request each register
	 * separately.
	 */
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_mem_region(addr + idx * io->regspacing,
				       io->regsize, DEVICE_NAME) == NULL) {
			/* Undo allocations */
			mem_region_cleanup(io, idx);
			return -EIO;
		}
	}

	/*
	 * Calculate the total amount of memory to claim.  This is an
	 * unusual looking calculation, but it avoids claiming any
	 * more memory than it has to.  It will claim everything
	 * between the first address to the end of the last full
	 * register.
	 */
	mapsize = ((io->io_size * io->regspacing)
		   - (io->regspacing - io->regsize));
	io->addr = ioremap(addr, mapsize);
	if (io->addr == NULL) {
 		mem_region_cleanup(io, io->io_size);
 		return -EIO;
 	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	io->io_cleanup = mem_cleanup;
//fix_flaw_line_below:
//
 	return 0;
 }
",182853,"int ipmi_si_mem_setup(struct si_sm_io *io)
{
	unsigned long addr = io->addr_data;
	int           mapsize, idx;

 	if (!addr)
 		return -ENODEV;
 
	io->io_cleanup = mem_cleanup;
 	/*
 	 * Figure out the actual readb/readw/readl/etc routine to use based
 	 * upon the register size.
	 */
	switch (io->regsize) {
	case 1:
		io->inputb = intf_mem_inb;
		io->outputb = intf_mem_outb;
		break;
	case 2:
		io->inputb = intf_mem_inw;
		io->outputb = intf_mem_outw;
		break;
	case 4:
		io->inputb = intf_mem_inl;
		io->outputb = intf_mem_outl;
		break;
#ifdef readq
	case 8:
		io->inputb = mem_inq;
		io->outputb = mem_outq;
		break;
#endif
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}

	/*
	 * Some BIOSes reserve disjoint memory regions in their ACPI
	 * tables.  This causes problems when trying to request the
	 * entire region.  Therefore we must request each register
	 * separately.
	 */
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_mem_region(addr + idx * io->regspacing,
				       io->regsize, DEVICE_NAME) == NULL) {
			/* Undo allocations */
			mem_region_cleanup(io, idx);
			return -EIO;
		}
	}

	/*
	 * Calculate the total amount of memory to claim.  This is an
	 * unusual looking calculation, but it avoids claiming any
	 * more memory than it has to.  It will claim everything
	 * between the first address to the end of the last full
	 * register.
	 */
	mapsize = ((io->io_size * io->regspacing)
		   - (io->regspacing - io->regsize));
	io->addr = ioremap(addr, mapsize);
	if (io->addr == NULL) {
 		mem_region_cleanup(io, io->io_size);
 		return -EIO;
 	}
 	return 0;
 }
","int ipmi_si_mem_setup(struct si_sm_io *io)
{
	unsigned long addr = io->addr_data;
	int           mapsize, idx;

 	if (!addr)
 		return -ENODEV;
 
 	/*
 	 * Figure out the actual readb/readw/readl/etc routine to use based
 	 * upon the register size.
	 */
	switch (io->regsize) {
	case 1:
		io->inputb = intf_mem_inb;
		io->outputb = intf_mem_outb;
		break;
	case 2:
		io->inputb = intf_mem_inw;
		io->outputb = intf_mem_outw;
		break;
	case 4:
		io->inputb = intf_mem_inl;
		io->outputb = intf_mem_outl;
		break;
#ifdef readq
	case 8:
		io->inputb = mem_inq;
		io->outputb = mem_outq;
		break;
#endif
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}

	/*
	 * Some BIOSes reserve disjoint memory regions in their ACPI
	 * tables.  This causes problems when trying to request the
	 * entire region.  Therefore we must request each register
	 * separately.
	 */
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_mem_region(addr + idx * io->regspacing,
				       io->regsize, DEVICE_NAME) == NULL) {
			/* Undo allocations */
			mem_region_cleanup(io, idx);
			return -EIO;
		}
	}

	/*
	 * Calculate the total amount of memory to claim.  This is an
	 * unusual looking calculation, but it avoids claiming any
	 * more memory than it has to.  It will claim everything
	 * between the first address to the end of the last full
	 * register.
	 */
	mapsize = ((io->io_size * io->regspacing)
		   - (io->regspacing - io->regsize));
	io->addr = ioremap(addr, mapsize);
	if (io->addr == NULL) {
 		mem_region_cleanup(io, io->io_size);
 		return -EIO;
 	}

	io->io_cleanup = mem_cleanup;

 	return 0;
 }
","The vulnerability in the original code lies in the placement of the `io->io_cleanup = mem_cleanup;` assignment, which was executed after the memory mapping and could lead to a situation where cleanup functions are not properly set if an error occurs during memory allocation. This could result in resource leaks or undefined behavior. In the fixed code, the assignment of `io->io_cleanup` is moved to a more appropriate location, ensuring that it is set before any potential errors occur, thus enhancing the reliability of resource management and preventing memory leaks during error handling.","The vulnerability in the original code stems from the improper timing of setting the cleanup function, which could lead to resource management issues if an error occurs during memory allocation. Specifically, if the memory mapping fails, the cleanup function would not be assigned, potentially resulting in memory leaks or undefined behavior. In the revised code, the assignment of the cleanup function is moved to a more appropriate location, ensuring it is set before any memory allocation attempts. This change enhances the reliability of resource management and ensures that cleanup can be properly executed in case of errors."
61,182854,182854,,Remote,Not required,Complete,CVE-2019-11811,https://www.cvedetails.com/cve/CVE-2019-11811/,CWE-416,Low,Complete,Complete,,2019-05-07,10.0,"An issue was discovered in the Linux kernel before 5.0.4. There is a use-after-free upon attempted read access to /proc/ioports after the ipmi_si module is removed, related to drivers/char/ipmi/ipmi_si_intf.c, drivers/char/ipmi/ipmi_si_mem_io.c, and drivers/char/ipmi/ipmi_si_port_io.c.",2019-05-31,,3,https://github.com/torvalds/linux/commit/401e7e88d4ef80188ffa07095ac00456f901b8c4,401e7e88d4ef80188ffa07095ac00456f901b8c4,"ipmi_si: fix use-after-free of resource->name

When we excute the following commands, we got oops
rmmod ipmi_si
cat /proc/ioports

[ 1623.482380] Unable to handle kernel paging request at virtual address ffff00000901d478
[ 1623.482382] Mem abort info:
[ 1623.482383]   ESR = 0x96000007
[ 1623.482385]   Exception class = DABT (current EL), IL = 32 bits
[ 1623.482386]   SET = 0, FnV = 0
[ 1623.482387]   EA = 0, S1PTW = 0
[ 1623.482388] Data abort info:
[ 1623.482389]   ISV = 0, ISS = 0x00000007
[ 1623.482390]   CM = 0, WnR = 0
[ 1623.482393] swapper pgtable: 4k pages, 48-bit VAs, pgdp = 00000000d7d94a66
[ 1623.482395] [ffff00000901d478] pgd=000000dffbfff003, pud=000000dffbffe003, pmd=0000003f5d06e003, pte=0000000000000000
[ 1623.482399] Internal error: Oops: 96000007 [#1] SMP
[ 1623.487407] Modules linked in: ipmi_si(E) nls_utf8 isofs rpcrdma ib_iser ib_srpt target_core_mod ib_srp scsi_transport_srp ib_ipoib rdma_ucm ib_umad rdma_cm ib_cm dm_mirror dm_region_hash dm_log iw_cm dm_mod aes_ce_blk crypto_simd cryptd aes_ce_cipher ses ghash_ce sha2_ce enclosure sha256_arm64 sg sha1_ce hisi_sas_v2_hw hibmc_drm sbsa_gwdt hisi_sas_main ip_tables mlx5_ib ib_uverbs marvell ib_core mlx5_core ixgbe mdio hns_dsaf ipmi_devintf hns_enet_drv ipmi_msghandler hns_mdio [last unloaded: ipmi_si]
[ 1623.532410] CPU: 30 PID: 11438 Comm: cat Kdump: loaded Tainted: G            E     5.0.0-rc3+ #168
[ 1623.541498] Hardware name: Huawei TaiShan 2280 /BC11SPCD, BIOS 1.37 11/21/2017
[ 1623.548822] pstate: a0000005 (NzCv daif -PAN -UAO)
[ 1623.553684] pc : string+0x28/0x98
[ 1623.557040] lr : vsnprintf+0x368/0x5e8
[ 1623.560837] sp : ffff000013213a80
[ 1623.564191] x29: ffff000013213a80 x28: ffff00001138abb5
[ 1623.569577] x27: ffff000013213c18 x26: ffff805f67d06049
[ 1623.574963] x25: 0000000000000000 x24: ffff00001138abb5
[ 1623.580349] x23: 0000000000000fb7 x22: ffff0000117ed000
[ 1623.585734] x21: ffff000011188fd8 x20: ffff805f67d07000
[ 1623.591119] x19: ffff805f67d06061 x18: ffffffffffffffff
[ 1623.596505] x17: 0000000000000200 x16: 0000000000000000
[ 1623.601890] x15: ffff0000117ed748 x14: ffff805f67d07000
[ 1623.607276] x13: ffff805f67d0605e x12: 0000000000000000
[ 1623.612661] x11: 0000000000000000 x10: 0000000000000000
[ 1623.618046] x9 : 0000000000000000 x8 : 000000000000000f
[ 1623.623432] x7 : ffff805f67d06061 x6 : fffffffffffffffe
[ 1623.628817] x5 : 0000000000000012 x4 : ffff00000901d478
[ 1623.634203] x3 : ffff0a00ffffff04 x2 : ffff805f67d07000
[ 1623.639588] x1 : ffff805f67d07000 x0 : ffffffffffffffff
[ 1623.644974] Process cat (pid: 11438, stack limit = 0x000000008d4cbc10)
[ 1623.651592] Call trace:
[ 1623.654068]  string+0x28/0x98
[ 1623.657071]  vsnprintf+0x368/0x5e8
[ 1623.660517]  seq_vprintf+0x70/0x98
[ 1623.668009]  seq_printf+0x7c/0xa0
[ 1623.675530]  r_show+0xc8/0xf8
[ 1623.682558]  seq_read+0x330/0x440
[ 1623.689877]  proc_reg_read+0x78/0xd0
[ 1623.697346]  __vfs_read+0x60/0x1a0
[ 1623.704564]  vfs_read+0x94/0x150
[ 1623.711339]  ksys_read+0x6c/0xd8
[ 1623.717939]  __arm64_sys_read+0x24/0x30
[ 1623.725077]  el0_svc_common+0x120/0x148
[ 1623.732035]  el0_svc_handler+0x30/0x40
[ 1623.738757]  el0_svc+0x8/0xc
[ 1623.744520] Code: d1000406 aa0103e2 54000149 b4000080 (39400085)
[ 1623.753441] ---[ end trace f91b6a4937de9835 ]---
[ 1623.760871] Kernel panic - not syncing: Fatal exception
[ 1623.768935] SMP: stopping secondary CPUs
[ 1623.775718] Kernel Offset: disabled
[ 1623.781998] CPU features: 0x002,21006008
[ 1623.788777] Memory Limit: none
[ 1623.798329] Starting crashdump kernel...
[ 1623.805202] Bye!

If io_setup is called successful in try_smi_init() but try_smi_init()
goes out_err before calling ipmi_register_smi(), so ipmi_unregister_smi()
will not be called while removing module. It leads to the resource that
allocated in io_setup() can not be freed, but the name(DEVICE_NAME) of
resource is freed while removing the module. It causes use-after-free
when cat /proc/ioports.

Fix this by calling io_cleanup() while try_smi_init() goes to out_err.
and don't call io_cleanup() until io_setup() returns successful to avoid
warning prints.

Fixes: 93c303d2045b (""ipmi_si: Clean up shutdown a bit"")
Cc: stable@vger.kernel.org
Reported-by: NuoHan Qiao <qiaonuohan@huawei.com>
Suggested-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Yang Yingliang <yangyingliang@huawei.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>",1,drivers/char/ipmi/ipmi_si_port_io.c,"{""sha"": ""f1b9fda6b9dfbc7e89b1d02b7a5777393923783f"", ""filename"": ""drivers/char/ipmi/ipmi_si_intf.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_intf.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_intf.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/ipmi/ipmi_si_intf.c?ref=401e7e88d4ef80188ffa07095ac00456f901b8c4"", ""patch"": ""@@ -2085,6 +2085,11 @@ static int try_smi_init(struct smi_info *new_smi)\n \tWARN_ON(new_smi->io.dev->init_name != NULL);\n \n  out_err:\n+\tif (rv && new_smi->io.io_cleanup) {\n+\t\tnew_smi->io.io_cleanup(&new_smi->io);\n+\t\tnew_smi->io.io_cleanup = NULL;\n+\t}\n+\n \tkfree(init_name);\n \treturn rv;\n }""}<_**next**_>{""sha"": ""75583612ab10551367cd74d727a0cbda958d0429"", ""filename"": ""drivers/char/ipmi/ipmi_si_mem_io.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_mem_io.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_mem_io.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/ipmi/ipmi_si_mem_io.c?ref=401e7e88d4ef80188ffa07095ac00456f901b8c4"", ""patch"": ""@@ -81,8 +81,6 @@ int ipmi_si_mem_setup(struct si_sm_io *io)\n \tif (!addr)\n \t\treturn -ENODEV;\n \n-\tio->io_cleanup = mem_cleanup;\n-\n \t/*\n \t * Figure out the actual readb/readw/readl/etc routine to use based\n \t * upon the register size.\n@@ -141,5 +139,8 @@ int ipmi_si_mem_setup(struct si_sm_io *io)\n \t\tmem_region_cleanup(io, io->io_size);\n \t\treturn -EIO;\n \t}\n+\n+\tio->io_cleanup = mem_cleanup;\n+\n \treturn 0;\n }""}<_**next**_>{""sha"": ""03924c32b6e98035ad3b873c4d19320d8aa89567"", ""filename"": ""drivers/char/ipmi/ipmi_si_port_io.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_port_io.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_port_io.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/ipmi/ipmi_si_port_io.c?ref=401e7e88d4ef80188ffa07095ac00456f901b8c4"", ""patch"": ""@@ -68,8 +68,6 @@ int ipmi_si_port_setup(struct si_sm_io *io)\n \tif (!addr)\n \t\treturn -ENODEV;\n \n-\tio->io_cleanup = port_cleanup;\n-\n \t/*\n \t * Figure out the actual inb/inw/inl/etc routine to use based\n \t * upon the register size.\n@@ -109,5 +107,8 @@ int ipmi_si_port_setup(struct si_sm_io *io)\n \t\t\treturn -EIO;\n \t\t}\n \t}\n+\n+\tio->io_cleanup = port_cleanup;\n+\n \treturn 0;\n }""}","int ipmi_si_port_setup(struct si_sm_io *io)
{
	unsigned int addr = io->addr_data;
	int          idx;

 	if (!addr)
 		return -ENODEV;
 
 	/*
 	 * Figure out the actual inb/inw/inl/etc routine to use based
 	 * upon the register size.
	 */
	switch (io->regsize) {
	case 1:
		io->inputb = port_inb;
		io->outputb = port_outb;
		break;
	case 2:
		io->inputb = port_inw;
		io->outputb = port_outw;
		break;
	case 4:
		io->inputb = port_inl;
		io->outputb = port_outl;
		break;
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}

	/*
	 * Some BIOSes reserve disjoint I/O regions in their ACPI
	 * tables.  This causes problems when trying to register the
	 * entire I/O region.  Therefore we must register each I/O
	 * port separately.
	 */
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_region(addr + idx * io->regspacing,
				   io->regsize, DEVICE_NAME) == NULL) {
			/* Undo allocations */
			while (idx--)
				release_region(addr + idx * io->regspacing,
					       io->regsize);
 			return -EIO;
 		}
 	}

	io->io_cleanup = port_cleanup;

 	return 0;
 }
","int ipmi_si_port_setup(struct si_sm_io *io)
{
	unsigned int addr = io->addr_data;
	int          idx;

 	if (!addr)
 		return -ENODEV;
 
	io->io_cleanup = port_cleanup;
 	/*
 	 * Figure out the actual inb/inw/inl/etc routine to use based
 	 * upon the register size.
	 */
	switch (io->regsize) {
	case 1:
		io->inputb = port_inb;
		io->outputb = port_outb;
		break;
	case 2:
		io->inputb = port_inw;
		io->outputb = port_outw;
		break;
	case 4:
		io->inputb = port_inl;
		io->outputb = port_outl;
		break;
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}

	/*
	 * Some BIOSes reserve disjoint I/O regions in their ACPI
	 * tables.  This causes problems when trying to register the
	 * entire I/O region.  Therefore we must register each I/O
	 * port separately.
	 */
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_region(addr + idx * io->regspacing,
				   io->regsize, DEVICE_NAME) == NULL) {
			/* Undo allocations */
			while (idx--)
				release_region(addr + idx * io->regspacing,
					       io->regsize);
 			return -EIO;
 		}
 	}
 	return 0;
 }
",C,"
	io->io_cleanup = port_cleanup;

","	io->io_cleanup = port_cleanup;
",,"@@ -68,8 +68,6 @@ int ipmi_si_port_setup(struct si_sm_io *io)
 	if (!addr)
 		return -ENODEV;
 
-	io->io_cleanup = port_cleanup;
-
 	/*
 	 * Figure out the actual inb/inw/inl/etc routine to use based
 	 * upon the register size.
@@ -109,5 +107,8 @@ int ipmi_si_port_setup(struct si_sm_io *io)
 			return -EIO;
 		}
 	}
+
+	io->io_cleanup = port_cleanup;
+
 	return 0;
 }",linux,401e7e88d4ef80188ffa07095ac00456f901b8c4,df3865f8f56879b7e9f0ca47fa7bc5f2252df6d3,1,"int ipmi_si_port_setup(struct si_sm_io *io)
{
	unsigned int addr = io->addr_data;
	int          idx;

 	if (!addr)
 		return -ENODEV;
 
//flaw_line_below:
	io->io_cleanup = port_cleanup;
//flaw_line_below:

 	/*
 	 * Figure out the actual inb/inw/inl/etc routine to use based
 	 * upon the register size.
	 */
	switch (io->regsize) {
	case 1:
		io->inputb = port_inb;
		io->outputb = port_outb;
		break;
	case 2:
		io->inputb = port_inw;
		io->outputb = port_outw;
		break;
	case 4:
		io->inputb = port_inl;
		io->outputb = port_outl;
		break;
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}

	/*
	 * Some BIOSes reserve disjoint I/O regions in their ACPI
	 * tables.  This causes problems when trying to register the
	 * entire I/O region.  Therefore we must register each I/O
	 * port separately.
	 */
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_region(addr + idx * io->regspacing,
				   io->regsize, DEVICE_NAME) == NULL) {
			/* Undo allocations */
			while (idx--)
				release_region(addr + idx * io->regspacing,
					       io->regsize);
 			return -EIO;
 		}
 	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	io->io_cleanup = port_cleanup;
//fix_flaw_line_below:
//
 	return 0;
 }
",182854,"int ipmi_si_port_setup(struct si_sm_io *io)
{
	unsigned int addr = io->addr_data;
	int          idx;

 	if (!addr)
 		return -ENODEV;
 
	io->io_cleanup = port_cleanup;
 	/*
 	 * Figure out the actual inb/inw/inl/etc routine to use based
 	 * upon the register size.
	 */
	switch (io->regsize) {
	case 1:
		io->inputb = port_inb;
		io->outputb = port_outb;
		break;
	case 2:
		io->inputb = port_inw;
		io->outputb = port_outw;
		break;
	case 4:
		io->inputb = port_inl;
		io->outputb = port_outl;
		break;
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}

	/*
	 * Some BIOSes reserve disjoint I/O regions in their ACPI
	 * tables.  This causes problems when trying to register the
	 * entire I/O region.  Therefore we must register each I/O
	 * port separately.
	 */
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_region(addr + idx * io->regspacing,
				   io->regsize, DEVICE_NAME) == NULL) {
			/* Undo allocations */
			while (idx--)
				release_region(addr + idx * io->regspacing,
					       io->regsize);
 			return -EIO;
 		}
 	}
 	return 0;
 }
","int ipmi_si_port_setup(struct si_sm_io *io)
{
	unsigned int addr = io->addr_data;
	int          idx;

 	if (!addr)
 		return -ENODEV;
 
 	/*
 	 * Figure out the actual inb/inw/inl/etc routine to use based
 	 * upon the register size.
	 */
	switch (io->regsize) {
	case 1:
		io->inputb = port_inb;
		io->outputb = port_outb;
		break;
	case 2:
		io->inputb = port_inw;
		io->outputb = port_outw;
		break;
	case 4:
		io->inputb = port_inl;
		io->outputb = port_outl;
		break;
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}

	/*
	 * Some BIOSes reserve disjoint I/O regions in their ACPI
	 * tables.  This causes problems when trying to register the
	 * entire I/O region.  Therefore we must register each I/O
	 * port separately.
	 */
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_region(addr + idx * io->regspacing,
				   io->regsize, DEVICE_NAME) == NULL) {
			/* Undo allocations */
			while (idx--)
				release_region(addr + idx * io->regspacing,
					       io->regsize);
 			return -EIO;
 		}
 	}

	io->io_cleanup = port_cleanup;

 	return 0;
 }
","The vulnerability in the original code lies in the placement of the `io->io_cleanup = port_cleanup;` assignment, which occurs before the I/O region registration loop. If the `request_region` fails, the cleanup function would not be set, potentially leading to resource leaks or improper cleanup. In the fixed code, this assignment is moved to after the successful registration of all I/O ports, ensuring that `io->io_cleanup` is only set if the region registration is successful. This change mitigates the risk of leaving the system in an inconsistent state if an error occurs during the registration process.","The vulnerability in the original code arises from the improper timing of setting the cleanup function, which occurs before the critical operation of registering I/O regions. If the registration fails, the cleanup function would not be assigned, leading to potential resource leaks and leaving the system in an inconsistent state. In the revised code, the assignment of the cleanup function is moved to after the successful registration of all I/O ports. This ensures that the cleanup function is only set when the registration is confirmed to be successful, thereby enhancing the reliability and stability of the system."
62,182934,182934,,Local,Not required,Partial,CVE-2018-20856,https://www.cvedetails.com/cve/CVE-2018-20856/,CWE-416,Low,Partial,Partial,,2019-07-26,4.6,"An issue was discovered in the Linux kernel before 4.18.7. In block/blk-core.c, there is an __blk_drain_queue() use-after-free because a certain error case is mishandled.",2019-08-13,,1,https://github.com/torvalds/linux/commit/54648cf1ec2d7f4b6a71767799c45676a138ca24,54648cf1ec2d7f4b6a71767799c45676a138ca24,"block: blk_init_allocated_queue() set q->fq as NULL in the fail case

We find the memory use-after-free issue in __blk_drain_queue()
on the kernel 4.14. After read the latest kernel 4.18-rc6 we
think it has the same problem.

Memory is allocated for q->fq in the blk_init_allocated_queue().
If the elevator init function called with error return, it will
run into the fail case to free the q->fq.

Then the __blk_drain_queue() uses the same memory after the free
of the q->fq, it will lead to the unpredictable event.

The patch is to set q->fq as NULL in the fail case of
blk_init_allocated_queue().

Fixes: commit 7c94e1c157a2 (""block: introduce blk_flush_queue to drive flush machinery"")
Cc: <stable@vger.kernel.org>
Reviewed-by: Ming Lei <ming.lei@redhat.com>
Reviewed-by: Bart Van Assche <bart.vanassche@wdc.com>
Signed-off-by: xiao jin <jin.xiao@intel.com>
Signed-off-by: Jens Axboe <axboe@kernel.dk>",0,block/blk-core.c,"{""sha"": ""23cd1b7770e706c1824cd819c8ec91209ab1cbd0"", ""filename"": ""block/blk-core.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/54648cf1ec2d7f4b6a71767799c45676a138ca24/block/blk-core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/54648cf1ec2d7f4b6a71767799c45676a138ca24/block/blk-core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/block/blk-core.c?ref=54648cf1ec2d7f4b6a71767799c45676a138ca24"", ""patch"": ""@@ -1184,6 +1184,7 @@ int blk_init_allocated_queue(struct request_queue *q)\n \t\tq->exit_rq_fn(q, q->fq->flush_rq);\n out_free_flush_queue:\n \tblk_free_flush_queue(q->fq);\n+\tq->fq = NULL;\n \treturn -ENOMEM;\n }\n EXPORT_SYMBOL(blk_init_allocated_queue);""}","int blk_init_allocated_queue(struct request_queue *q)
{
	WARN_ON_ONCE(q->mq_ops);

	q->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);
	if (!q->fq)
		return -ENOMEM;

	if (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))
		goto out_free_flush_queue;

	if (blk_init_rl(&q->root_rl, q, GFP_KERNEL))
		goto out_exit_flush_rq;

	INIT_WORK(&q->timeout_work, blk_timeout_work);
	q->queue_flags		|= QUEUE_FLAG_DEFAULT;

	/*
	 * This also sets hw/phys segments, boundary and size
	 */
	blk_queue_make_request(q, blk_queue_bio);

	q->sg_reserved_size = INT_MAX;

	if (elevator_init(q))
		goto out_exit_flush_rq;
	return 0;

out_exit_flush_rq:
	if (q->exit_rq_fn)
 		q->exit_rq_fn(q, q->fq->flush_rq);
 out_free_flush_queue:
 	blk_free_flush_queue(q->fq);
	q->fq = NULL;
 	return -ENOMEM;
 }
","int blk_init_allocated_queue(struct request_queue *q)
{
	WARN_ON_ONCE(q->mq_ops);

	q->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);
	if (!q->fq)
		return -ENOMEM;

	if (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))
		goto out_free_flush_queue;

	if (blk_init_rl(&q->root_rl, q, GFP_KERNEL))
		goto out_exit_flush_rq;

	INIT_WORK(&q->timeout_work, blk_timeout_work);
	q->queue_flags		|= QUEUE_FLAG_DEFAULT;

	/*
	 * This also sets hw/phys segments, boundary and size
	 */
	blk_queue_make_request(q, blk_queue_bio);

	q->sg_reserved_size = INT_MAX;

	if (elevator_init(q))
		goto out_exit_flush_rq;
	return 0;

out_exit_flush_rq:
	if (q->exit_rq_fn)
 		q->exit_rq_fn(q, q->fq->flush_rq);
 out_free_flush_queue:
 	blk_free_flush_queue(q->fq);
 	return -ENOMEM;
 }
",C,"	q->fq = NULL;
",,,"@@ -1184,6 +1184,7 @@ int blk_init_allocated_queue(struct request_queue *q)
 		q->exit_rq_fn(q, q->fq->flush_rq);
 out_free_flush_queue:
 	blk_free_flush_queue(q->fq);
+	q->fq = NULL;
 	return -ENOMEM;
 }
 EXPORT_SYMBOL(blk_init_allocated_queue);",linux,54648cf1ec2d7f4b6a71767799c45676a138ca24,f7f1fc363aab4601786d373569c1ae802ea593d0,1,"int blk_init_allocated_queue(struct request_queue *q)
{
	WARN_ON_ONCE(q->mq_ops);

	q->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);
	if (!q->fq)
		return -ENOMEM;

	if (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))
		goto out_free_flush_queue;

	if (blk_init_rl(&q->root_rl, q, GFP_KERNEL))
		goto out_exit_flush_rq;

	INIT_WORK(&q->timeout_work, blk_timeout_work);
	q->queue_flags		|= QUEUE_FLAG_DEFAULT;

	/*
	 * This also sets hw/phys segments, boundary and size
	 */
	blk_queue_make_request(q, blk_queue_bio);

	q->sg_reserved_size = INT_MAX;

	if (elevator_init(q))
		goto out_exit_flush_rq;
	return 0;

out_exit_flush_rq:
	if (q->exit_rq_fn)
 		q->exit_rq_fn(q, q->fq->flush_rq);
 out_free_flush_queue:
 	blk_free_flush_queue(q->fq);
//fix_flaw_line_below:
//	q->fq = NULL;
 	return -ENOMEM;
 }
",182934,"int blk_init_allocated_queue(struct request_queue *q)
{
	WARN_ON_ONCE(q->mq_ops);

	q->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);
	if (!q->fq)
		return -ENOMEM;

	if (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))
		goto out_free_flush_queue;

	if (blk_init_rl(&q->root_rl, q, GFP_KERNEL))
		goto out_exit_flush_rq;

	INIT_WORK(&q->timeout_work, blk_timeout_work);
	q->queue_flags		|= QUEUE_FLAG_DEFAULT;

	/*
	 * This also sets hw/phys segments, boundary and size
	 */
	blk_queue_make_request(q, blk_queue_bio);

	q->sg_reserved_size = INT_MAX;

	if (elevator_init(q))
		goto out_exit_flush_rq;
	return 0;

out_exit_flush_rq:
	if (q->exit_rq_fn)
 		q->exit_rq_fn(q, q->fq->flush_rq);
 out_free_flush_queue:
 	blk_free_flush_queue(q->fq);
 	return -ENOMEM;
 }
","int blk_init_allocated_queue(struct request_queue *q)
{
	WARN_ON_ONCE(q->mq_ops);

	q->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);
	if (!q->fq)
		return -ENOMEM;

	if (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))
		goto out_free_flush_queue;

	if (blk_init_rl(&q->root_rl, q, GFP_KERNEL))
		goto out_exit_flush_rq;

	INIT_WORK(&q->timeout_work, blk_timeout_work);
	q->queue_flags		|= QUEUE_FLAG_DEFAULT;

	/*
	 * This also sets hw/phys segments, boundary and size
	 */
	blk_queue_make_request(q, blk_queue_bio);

	q->sg_reserved_size = INT_MAX;

	if (elevator_init(q))
		goto out_exit_flush_rq;
	return 0;

out_exit_flush_rq:
	if (q->exit_rq_fn)
 		q->exit_rq_fn(q, q->fq->flush_rq);
 out_free_flush_queue:
 	blk_free_flush_queue(q->fq);
	q->fq = NULL;
 	return -ENOMEM;
 }
","The vulnerability in the original code lies in the potential use-after-free condition where the `q->fq` pointer could still reference a freed flush queue after the `blk_free_flush_queue(q->fq)` call in the `out_free_flush_queue` label. This could lead to undefined behavior if `q->fq` is accessed later. The fix in the modified code addresses this by setting `q->fq` to `NULL` after freeing it, ensuring that any subsequent access to `q->fq` will be safe and will not reference a deallocated memory area, thus preventing potential crashes or security issues.","The vulnerability in the original code stems from a potential use-after-free scenario, where a pointer could still reference a memory location that has already been deallocated. This situation arises when the code attempts to access or manipulate the pointer after it has been freed, leading to undefined behavior, crashes, or security vulnerabilities. The fix in the modified code addresses this issue by explicitly setting the pointer to `NULL` after it has been freed. This ensures that any subsequent attempts to access the pointer will not reference invalid memory, thereby enhancing the overall safety and stability of the code."
63,182954,182954,,Remote,Not required,Complete,CVE-2018-20836,https://www.cvedetails.com/cve/CVE-2018-20836/,CWE-416,Medium,Complete,Complete,,2019-05-07,9.3,"An issue was discovered in the Linux kernel before 4.20. There is a race condition in smp_task_timedout() and smp_task_done() in drivers/scsi/libsas/sas_expander.c, leading to a use-after-free.",2019-05-08,,1,https://github.com/torvalds/linux/commit/b90cd6f2b905905fb42671009dc0e27c310a16ae,b90cd6f2b905905fb42671009dc0e27c310a16ae,"scsi: libsas: fix a race condition when smp task timeout

When the lldd is processing the complete sas task in interrupt and set the
task stat as SAS_TASK_STATE_DONE, the smp timeout timer is able to be
triggered at the same time. And smp_task_timedout() will complete the task
wheter the SAS_TASK_STATE_DONE is set or not. Then the sas task may freed
before lldd end the interrupt process. Thus a use-after-free will happen.

Fix this by calling the complete() only when SAS_TASK_STATE_DONE is not
set. And remove the check of the return value of the del_timer(). Once the
LLDD sets DONE, it must call task->done(), which will call
smp_task_done()->complete() and the task will be completed and freed
correctly.

Reported-by: chenxiang <chenxiang66@hisilicon.com>
Signed-off-by: Jason Yan <yanaijie@huawei.com>
CC: John Garry <john.garry@huawei.com>
CC: Johannes Thumshirn <jthumshirn@suse.de>
CC: Ewan Milne <emilne@redhat.com>
CC: Christoph Hellwig <hch@lst.de>
CC: Tomas Henzl <thenzl@redhat.com>
CC: Dan Williams <dan.j.williams@intel.com>
CC: Hannes Reinecke <hare@suse.com>
Reviewed-by: Hannes Reinecke <hare@suse.com>
Reviewed-by: John Garry <john.garry@huawei.com>
Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>",2,drivers/scsi/libsas/sas_expander.c,"{""sha"": ""0d1f72752ca26e77869215809a542cf8db1906ce"", ""filename"": ""drivers/scsi/libsas/sas_expander.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/b90cd6f2b905905fb42671009dc0e27c310a16ae/drivers/scsi/libsas/sas_expander.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/b90cd6f2b905905fb42671009dc0e27c310a16ae/drivers/scsi/libsas/sas_expander.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/scsi/libsas/sas_expander.c?ref=b90cd6f2b905905fb42671009dc0e27c310a16ae"", ""patch"": ""@@ -48,17 +48,16 @@ static void smp_task_timedout(struct timer_list *t)\n \tunsigned long flags;\n \n \tspin_lock_irqsave(&task->task_state_lock, flags);\n-\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n+\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\n \t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n+\t\tcomplete(&task->slow_task->completion);\n+\t}\n \tspin_unlock_irqrestore(&task->task_state_lock, flags);\n-\n-\tcomplete(&task->slow_task->completion);\n }\n \n static void smp_task_done(struct sas_task *task)\n {\n-\tif (!del_timer(&task->slow_task->timer))\n-\t\treturn;\n+\tdel_timer(&task->slow_task->timer);\n \tcomplete(&task->slow_task->completion);\n }\n ""}"," static void smp_task_done(struct sas_task *task)
 {
	del_timer(&task->slow_task->timer);
 	complete(&task->slow_task->completion);
 }
"," static void smp_task_done(struct sas_task *task)
 {
	if (!del_timer(&task->slow_task->timer))
		return;
 	complete(&task->slow_task->completion);
 }
",C,"	del_timer(&task->slow_task->timer);
","	if (!del_timer(&task->slow_task->timer))
		return;
",,"@@ -48,17 +48,16 @@ static void smp_task_timedout(struct timer_list *t)
 	unsigned long flags;
 
 	spin_lock_irqsave(&task->task_state_lock, flags);
-	if (!(task->task_state_flags & SAS_TASK_STATE_DONE))
+	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
 		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
+		complete(&task->slow_task->completion);
+	}
 	spin_unlock_irqrestore(&task->task_state_lock, flags);
-
-	complete(&task->slow_task->completion);
 }
 
 static void smp_task_done(struct sas_task *task)
 {
-	if (!del_timer(&task->slow_task->timer))
-		return;
+	del_timer(&task->slow_task->timer);
 	complete(&task->slow_task->completion);
 }
 ",linux,b90cd6f2b905905fb42671009dc0e27c310a16ae,437207d3697f500f34f126a8ab1c29417ba4a184,1," static void smp_task_done(struct sas_task *task)
 {
//flaw_line_below:
	if (!del_timer(&task->slow_task->timer))
//flaw_line_below:
		return;
//fix_flaw_line_below:
//	del_timer(&task->slow_task->timer);
 	complete(&task->slow_task->completion);
 }
",182954," static void smp_task_done(struct sas_task *task)
 {
	if (!del_timer(&task->slow_task->timer))
		return;
 	complete(&task->slow_task->completion);
 }
"," static void smp_task_done(struct sas_task *task)
 {
	del_timer(&task->slow_task->timer);
 	complete(&task->slow_task->completion);
 }
","The vulnerability in the original code arises from the conditional check `if (!del_timer(&task->slow_task->timer))`, which prevents the completion of the task if the timer is still active. This could lead to a situation where the task is never marked as done, potentially causing a deadlock or resource leak. In the fixed code, the check is removed, ensuring that `del_timer(&task->slow_task->timer)` is always called, followed by `complete(&task->slow_task->completion)`. This guarantees that the task is completed regardless of the timer's state, thus eliminating the risk of incomplete task handling.","The vulnerability in the original code stems from a conditional check that prevents the completion of a task if a specific timer is still active. This could result in the task remaining incomplete, leading to potential deadlocks or resource leaks, as the system may wait indefinitely for a task that is never marked as done. In the revised code, this conditional check is removed, ensuring that the task is always completed regardless of the timer's status. This change guarantees proper task handling and eliminates the risk of incomplete execution, thereby enhancing the overall reliability of the system."
64,182955,182955,,Remote,Not required,Complete,CVE-2018-20836,https://www.cvedetails.com/cve/CVE-2018-20836/,CWE-416,Medium,Complete,Complete,,2019-05-07,9.3,"An issue was discovered in the Linux kernel before 4.20. There is a race condition in smp_task_timedout() and smp_task_done() in drivers/scsi/libsas/sas_expander.c, leading to a use-after-free.",2019-05-08,,3,https://github.com/torvalds/linux/commit/b90cd6f2b905905fb42671009dc0e27c310a16ae,b90cd6f2b905905fb42671009dc0e27c310a16ae,"scsi: libsas: fix a race condition when smp task timeout

When the lldd is processing the complete sas task in interrupt and set the
task stat as SAS_TASK_STATE_DONE, the smp timeout timer is able to be
triggered at the same time. And smp_task_timedout() will complete the task
wheter the SAS_TASK_STATE_DONE is set or not. Then the sas task may freed
before lldd end the interrupt process. Thus a use-after-free will happen.

Fix this by calling the complete() only when SAS_TASK_STATE_DONE is not
set. And remove the check of the return value of the del_timer(). Once the
LLDD sets DONE, it must call task->done(), which will call
smp_task_done()->complete() and the task will be completed and freed
correctly.

Reported-by: chenxiang <chenxiang66@hisilicon.com>
Signed-off-by: Jason Yan <yanaijie@huawei.com>
CC: John Garry <john.garry@huawei.com>
CC: Johannes Thumshirn <jthumshirn@suse.de>
CC: Ewan Milne <emilne@redhat.com>
CC: Christoph Hellwig <hch@lst.de>
CC: Tomas Henzl <thenzl@redhat.com>
CC: Dan Williams <dan.j.williams@intel.com>
CC: Hannes Reinecke <hare@suse.com>
Reviewed-by: Hannes Reinecke <hare@suse.com>
Reviewed-by: John Garry <john.garry@huawei.com>
Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>",2,drivers/scsi/libsas/sas_expander.c,"{""sha"": ""0d1f72752ca26e77869215809a542cf8db1906ce"", ""filename"": ""drivers/scsi/libsas/sas_expander.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/b90cd6f2b905905fb42671009dc0e27c310a16ae/drivers/scsi/libsas/sas_expander.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/b90cd6f2b905905fb42671009dc0e27c310a16ae/drivers/scsi/libsas/sas_expander.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/scsi/libsas/sas_expander.c?ref=b90cd6f2b905905fb42671009dc0e27c310a16ae"", ""patch"": ""@@ -48,17 +48,16 @@ static void smp_task_timedout(struct timer_list *t)\n \tunsigned long flags;\n \n \tspin_lock_irqsave(&task->task_state_lock, flags);\n-\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n+\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\n \t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n+\t\tcomplete(&task->slow_task->completion);\n+\t}\n \tspin_unlock_irqrestore(&task->task_state_lock, flags);\n-\n-\tcomplete(&task->slow_task->completion);\n }\n \n static void smp_task_done(struct sas_task *task)\n {\n-\tif (!del_timer(&task->slow_task->timer))\n-\t\treturn;\n+\tdel_timer(&task->slow_task->timer);\n \tcomplete(&task->slow_task->completion);\n }\n ""}","static void smp_task_timedout(struct timer_list *t)
{
	struct sas_task_slow *slow = from_timer(slow, t, timer);
	struct sas_task *task = slow->task;
 	unsigned long flags;
 
 	spin_lock_irqsave(&task->task_state_lock, flags);
	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
 		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
		complete(&task->slow_task->completion);
	}
 	spin_unlock_irqrestore(&task->task_state_lock, flags);
 }
","static void smp_task_timedout(struct timer_list *t)
{
	struct sas_task_slow *slow = from_timer(slow, t, timer);
	struct sas_task *task = slow->task;
 	unsigned long flags;
 
 	spin_lock_irqsave(&task->task_state_lock, flags);
	if (!(task->task_state_flags & SAS_TASK_STATE_DONE))
 		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
 	spin_unlock_irqrestore(&task->task_state_lock, flags);
	complete(&task->slow_task->completion);
 }
",C,"	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
		complete(&task->slow_task->completion);
	}
","	if (!(task->task_state_flags & SAS_TASK_STATE_DONE))
	complete(&task->slow_task->completion);
",,"@@ -48,17 +48,16 @@ static void smp_task_timedout(struct timer_list *t)
 	unsigned long flags;
 
 	spin_lock_irqsave(&task->task_state_lock, flags);
-	if (!(task->task_state_flags & SAS_TASK_STATE_DONE))
+	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
 		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
+		complete(&task->slow_task->completion);
+	}
 	spin_unlock_irqrestore(&task->task_state_lock, flags);
-
-	complete(&task->slow_task->completion);
 }
 
 static void smp_task_done(struct sas_task *task)
 {
-	if (!del_timer(&task->slow_task->timer))
-		return;
+	del_timer(&task->slow_task->timer);
 	complete(&task->slow_task->completion);
 }
 ",linux,b90cd6f2b905905fb42671009dc0e27c310a16ae,437207d3697f500f34f126a8ab1c29417ba4a184,1,"static void smp_task_timedout(struct timer_list *t)
{
	struct sas_task_slow *slow = from_timer(slow, t, timer);
	struct sas_task *task = slow->task;
 	unsigned long flags;
 
 	spin_lock_irqsave(&task->task_state_lock, flags);
//flaw_line_below:
	if (!(task->task_state_flags & SAS_TASK_STATE_DONE))
//fix_flaw_line_below:
//	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
 		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
//fix_flaw_line_below:
//		complete(&task->slow_task->completion);
//fix_flaw_line_below:
//	}
 	spin_unlock_irqrestore(&task->task_state_lock, flags);
//flaw_line_below:

//flaw_line_below:
	complete(&task->slow_task->completion);
 }
",182955,"static void smp_task_timedout(struct timer_list *t)
{
	struct sas_task_slow *slow = from_timer(slow, t, timer);
	struct sas_task *task = slow->task;
 	unsigned long flags;
 
 	spin_lock_irqsave(&task->task_state_lock, flags);
	if (!(task->task_state_flags & SAS_TASK_STATE_DONE))
 		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
 	spin_unlock_irqrestore(&task->task_state_lock, flags);
	complete(&task->slow_task->completion);
 }
","static void smp_task_timedout(struct timer_list *t)
{
	struct sas_task_slow *slow = from_timer(slow, t, timer);
	struct sas_task *task = slow->task;
 	unsigned long flags;
 
 	spin_lock_irqsave(&task->task_state_lock, flags);
	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
 		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
		complete(&task->slow_task->completion);
	}
 	spin_unlock_irqrestore(&task->task_state_lock, flags);
 }
","The vulnerability in the original code arises from the potential race condition between checking the `task->task_state_flags` and completing the task. If the task's state changes after the check but before the `complete` function is called, it could lead to inconsistent state management. In the fixed code, the `complete(&task->slow_task->completion)` function is moved inside the conditional block, ensuring that it is only called if the task is not already marked as done. This change prevents premature completion of the task, thereby maintaining proper synchronization and state integrity.","The vulnerability in the original code stems from a race condition that could occur between checking the task's state and completing it. If the task's state changes after the check but before the completion call, it could lead to inconsistent behavior and improper task management. The fixed code addresses this issue by ensuring that the completion is only invoked if the task is confirmed to be in a specific state. This adjustment guarantees that the task's state is appropriately managed, preventing premature or incorrect completion and enhancing overall synchronization and reliability in the code."
65,183184,183184,,Local,Not required,Complete,CVE-2017-16525,https://www.cvedetails.com/cve/CVE-2017-16525/,CWE-416,Low,Complete,Complete,,2017-11-03,7.2,"The usb_serial_console_disconnect function in drivers/usb/serial/console.c in the Linux kernel before 4.13.8 allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via a crafted USB device, related to disconnection and failed setup.",2018-03-15,DoS ,1,https://github.com/torvalds/linux/commit/bd998c2e0df0469707503023d50d46cf0b10c787,bd998c2e0df0469707503023d50d46cf0b10c787,"USB: serial: console: fix use-after-free on disconnect

A clean-up patch removing two redundant NULL-checks from the console
disconnect handler inadvertently also removed a third check. This could
lead to the struct usb_serial being prematurely freed by the console
code when a driver accepts but does not register any ports for an
interface which also lacks endpoint descriptors.

Fixes: 0e517c93dc02 (""USB: serial: console: clean up sanity checks"")
Cc: stable <stable@vger.kernel.org>     # 4.11
Reported-by: Andrey Konovalov <andreyknvl@google.com>
Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Johan Hovold <johan@kernel.org>",1,drivers/usb/serial/console.c,"{""sha"": ""ed8ba3ef5c794fdf97ce2cd7b28b48bef17f642c"", ""filename"": ""drivers/usb/serial/console.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/bd998c2e0df0469707503023d50d46cf0b10c787/drivers/usb/serial/console.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bd998c2e0df0469707503023d50d46cf0b10c787/drivers/usb/serial/console.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/serial/console.c?ref=bd998c2e0df0469707503023d50d46cf0b10c787"", ""patch"": ""@@ -265,7 +265,7 @@ static struct console usbcons = {\n \n void usb_serial_console_disconnect(struct usb_serial *serial)\n {\n-\tif (serial->port[0] == usbcons_info.port) {\n+\tif (serial->port[0] && serial->port[0] == usbcons_info.port) {\n \t\tusb_serial_console_exit();\n \t\tusb_serial_put(serial);\n \t}""}"," void usb_serial_console_disconnect(struct usb_serial *serial)
 {
	if (serial->port[0] && serial->port[0] == usbcons_info.port) {
 		usb_serial_console_exit();
 		usb_serial_put(serial);
 	}
}
"," void usb_serial_console_disconnect(struct usb_serial *serial)
 {
	if (serial->port[0] == usbcons_info.port) {
 		usb_serial_console_exit();
 		usb_serial_put(serial);
 	}
}
",C,"	if (serial->port[0] && serial->port[0] == usbcons_info.port) {
","	if (serial->port[0] == usbcons_info.port) {
",,"@@ -265,7 +265,7 @@ static struct console usbcons = {
 
 void usb_serial_console_disconnect(struct usb_serial *serial)
 {
-	if (serial->port[0] == usbcons_info.port) {
+	if (serial->port[0] && serial->port[0] == usbcons_info.port) {
 		usb_serial_console_exit();
 		usb_serial_put(serial);
 	}",linux,bd998c2e0df0469707503023d50d46cf0b10c787,f5d9644c5fca7d8e8972268598bb516a7eae17f9,1," void usb_serial_console_disconnect(struct usb_serial *serial)
 {
//flaw_line_below:
	if (serial->port[0] == usbcons_info.port) {
//fix_flaw_line_below:
//	if (serial->port[0] && serial->port[0] == usbcons_info.port) {
 		usb_serial_console_exit();
 		usb_serial_put(serial);
 	}
}
",183184," void usb_serial_console_disconnect(struct usb_serial *serial)
 {
	if (serial->port[0] == usbcons_info.port) {
 		usb_serial_console_exit();
 		usb_serial_put(serial);
 	}
}
"," void usb_serial_console_disconnect(struct usb_serial *serial)
 {
	if (serial->port[0] && serial->port[0] == usbcons_info.port) {
 		usb_serial_console_exit();
 		usb_serial_put(serial);
 	}
}
","The vulnerability in the original code arises from the assumption that `serial->port[0]` is always a valid pointer before comparing it to `usbcons_info.port`. If `serial->port[0]` is NULL, this could lead to dereferencing a NULL pointer, causing a potential crash or undefined behavior. The fixed code addresses this vulnerability by adding a check to ensure that `serial->port[0]` is not NULL before performing the comparison. This additional condition (`serial->port[0] &&`) ensures that the code only proceeds if `serial->port[0]` is a valid pointer, thus preventing potential crashes.","The vulnerability in the original code stems from the lack of a check for a NULL pointer before accessing a specific element, which could lead to dereferencing a NULL pointer if the element is not properly initialized. This oversight can result in crashes or unpredictable behavior when the function is called with an invalid or uninitialized object. The revised code mitigates this risk by introducing a condition that verifies the pointer is not NULL before proceeding with the comparison. This additional safeguard ensures that the function only executes when it is safe to do so, thereby enhancing the overall stability and reliability of the code."
66,184958,184958,,Remote,Not required,Partial,CVE-2013-2873,https://www.cvedetails.com/cve/CVE-2013-2873/,CWE-416,Low,Partial,Partial,,2013-07-10,7.5,Use-after-free vulnerability in Google Chrome before 28.0.1500.71 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving a 404 HTTP status code during the loading of resources.,2017-09-18,DoS ,1,https://github.com/chromium/chromium/commit/370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef,370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef,"Protect WebURLLoaderImpl::Context while receiving responses.

A client's didReceiveResponse can cancel a request; by protecting the
Context we avoid a use after free in this case.

Interestingly, we really had very good warning about this problem, see 
https://codereview.chromium.org/11900002/ back in January.

R=darin
BUG=241139

Review URL: https://chromiumcodereview.appspot.com/15738007

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@202821 0039d316-1c4b-4281-b951-d872f2087c98",0,webkit/glue/weburlloader_impl.cc,"{""sha"": ""24c24a60caa575c4012321aec8f108a3456cdd69"", ""filename"": ""content/browser/webkit_browsertest.cc"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 0, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef/content/browser/webkit_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef/content/browser/webkit_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/webkit_browsertest.cc?ref=370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef"", ""patch"": ""@@ -76,4 +76,19 @@ IN_PROC_BROWSER_TEST_F(WebKitBrowserTest, PrerenderNoCrash) {\n   EXPECT_FALSE(shell()->web_contents()->IsCrashed());\n }\n \n+// This is a browser test because DumpRenderTree doesn't run nested message\n+// loops. The failure case was that a nested message triggered from an element\n+// that has signalled an error but had an open request would receive a body for\n+// the request and crash/fail an assertion.\n+const char kErrorBodyNoCrash[] =\n+    \""files/error-body-no-crash.html\"";\n+IN_PROC_BROWSER_TEST_F(WebKitBrowserTest, ErrorBodyNoCrash) {\n+  ASSERT_TRUE(test_server()->Start());\n+  GURL url = test_server()->GetURL(kErrorBodyNoCrash);\n+\n+  NavigateToURL(shell(), url);\n+\n+  EXPECT_FALSE(shell()->web_contents()->IsCrashed());\n+}\n+\n }  // namespace content""}<_**next**_>{""sha"": ""cf0b32c79952ca8960f8aa792c8e2545d4a2bb44"", ""filename"": ""content/test/data/error-body-no-crash.html"", ""status"": ""added"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef/content/test/data/error-body-no-crash.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef/content/test/data/error-body-no-crash.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/test/data/error-body-no-crash.html?ref=370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef"", ""patch"": ""@@ -0,0 +1,6 @@\n+<!-- The showModalDialog call will force a nested message loop, which will\n+     receive the 404 body and crash. -->\n+<script src=\""page404.html\""></script>\n+<script>\n+window.showModalDialog(\""javascript:window.close();\"");\n+</script>""}<_**next**_>{""sha"": ""853d4373eed1f209fc7fbc790a314ce12a1db05e"", ""filename"": ""webkit/glue/weburlloader_impl.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef/webkit/glue/weburlloader_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef/webkit/glue/weburlloader_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/glue/weburlloader_impl.cc?ref=370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef"", ""patch"": ""@@ -637,6 +637,7 @@ void WebURLLoaderImpl::Context::OnReceivedResponse(\n     }\n   }\n \n+  scoped_refptr<Context> protect(this);\n   client_->didReceiveResponse(loader_, response);\n \n   // We may have been cancelled after didReceiveResponse, which would leave us""}","void WebURLLoaderImpl::Context::OnReceivedResponse(
    const ResourceResponseInfo& info) {
  if (!client_)
    return;

  WebURLResponse response;
  response.initialize();
  PopulateURLResponse(request_.url(), info, &response);

  bool show_raw_listing = (GURL(request_.url()).query() == ""raw"");

  if (info.mime_type == ""text/vnd.chromium.ftp-dir"") {
    if (show_raw_listing) {
      response.setMIMEType(""text/plain"");
    } else {
      response.setMIMEType(""text/html"");
     }
   }
 
  scoped_refptr<Context> protect(this);
   client_->didReceiveResponse(loader_, response);
 
  if (!client_)
    return;

  DCHECK(!ftp_listing_delegate_.get());
  DCHECK(!multipart_delegate_.get());
  if (info.headers && info.mime_type == ""multipart/x-mixed-replace"") {
    std::string content_type;
    info.headers->EnumerateHeader(NULL, ""content-type"", &content_type);

    std::string mime_type;
    std::string charset;
    bool had_charset = false;
    std::string boundary;
    net::HttpUtil::ParseContentType(content_type, &mime_type, &charset,
                                    &had_charset, &boundary);
    TrimString(boundary, "" \"""", &boundary);

    if (!boundary.empty()) {
      multipart_delegate_.reset(
          new MultipartResponseDelegate(client_, loader_, response, boundary));
    }
  } else if (info.mime_type == ""text/vnd.chromium.ftp-dir"" &&
             !show_raw_listing) {
    ftp_listing_delegate_.reset(
        new FtpDirectoryListingResponseDelegate(client_, loader_, response));
  }
}
","void WebURLLoaderImpl::Context::OnReceivedResponse(
    const ResourceResponseInfo& info) {
  if (!client_)
    return;

  WebURLResponse response;
  response.initialize();
  PopulateURLResponse(request_.url(), info, &response);

  bool show_raw_listing = (GURL(request_.url()).query() == ""raw"");

  if (info.mime_type == ""text/vnd.chromium.ftp-dir"") {
    if (show_raw_listing) {
      response.setMIMEType(""text/plain"");
    } else {
      response.setMIMEType(""text/html"");
     }
   }
 
   client_->didReceiveResponse(loader_, response);
 
  if (!client_)
    return;

  DCHECK(!ftp_listing_delegate_.get());
  DCHECK(!multipart_delegate_.get());
  if (info.headers && info.mime_type == ""multipart/x-mixed-replace"") {
    std::string content_type;
    info.headers->EnumerateHeader(NULL, ""content-type"", &content_type);

    std::string mime_type;
    std::string charset;
    bool had_charset = false;
    std::string boundary;
    net::HttpUtil::ParseContentType(content_type, &mime_type, &charset,
                                    &had_charset, &boundary);
    TrimString(boundary, "" \"""", &boundary);

    if (!boundary.empty()) {
      multipart_delegate_.reset(
          new MultipartResponseDelegate(client_, loader_, response, boundary));
    }
  } else if (info.mime_type == ""text/vnd.chromium.ftp-dir"" &&
             !show_raw_listing) {
    ftp_listing_delegate_.reset(
        new FtpDirectoryListingResponseDelegate(client_, loader_, response));
  }
}
",C,"  scoped_refptr<Context> protect(this);
",,,"@@ -637,6 +637,7 @@ void WebURLLoaderImpl::Context::OnReceivedResponse(
     }
   }
 
+  scoped_refptr<Context> protect(this);
   client_->didReceiveResponse(loader_, response);
 
   // We may have been cancelled after didReceiveResponse, which would leave us",Chrome,370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef,02a0911dfa3567e3597492b41c94dc7d48fb209c,1,"void WebURLLoaderImpl::Context::OnReceivedResponse(
    const ResourceResponseInfo& info) {
  if (!client_)
    return;

  WebURLResponse response;
  response.initialize();
  PopulateURLResponse(request_.url(), info, &response);

  bool show_raw_listing = (GURL(request_.url()).query() == ""raw"");

  if (info.mime_type == ""text/vnd.chromium.ftp-dir"") {
    if (show_raw_listing) {
      // Set the MIME type to plain text to prevent any active content.
      response.setMIMEType(""text/plain"");
    } else {
      // We're going to produce a parsed listing in HTML.
      response.setMIMEType(""text/html"");
     }
   }
 
//fix_flaw_line_below:
//  scoped_refptr<Context> protect(this);
   client_->didReceiveResponse(loader_, response);
 
   // We may have been cancelled after didReceiveResponse, which would leave us
  // without a client and therefore without much need to do further handling.
  if (!client_)
    return;

  DCHECK(!ftp_listing_delegate_.get());
  DCHECK(!multipart_delegate_.get());
  if (info.headers && info.mime_type == ""multipart/x-mixed-replace"") {
    std::string content_type;
    info.headers->EnumerateHeader(NULL, ""content-type"", &content_type);

    std::string mime_type;
    std::string charset;
    bool had_charset = false;
    std::string boundary;
    net::HttpUtil::ParseContentType(content_type, &mime_type, &charset,
                                    &had_charset, &boundary);
    TrimString(boundary, "" \"""", &boundary);

    // If there's no boundary, just handle the request normally.  In the gecko
    // code, nsMultiMixedConv::OnStartRequest throws an exception.
    if (!boundary.empty()) {
      multipart_delegate_.reset(
          new MultipartResponseDelegate(client_, loader_, response, boundary));
    }
  } else if (info.mime_type == ""text/vnd.chromium.ftp-dir"" &&
             !show_raw_listing) {
    ftp_listing_delegate_.reset(
        new FtpDirectoryListingResponseDelegate(client_, loader_, response));
  }
}
",184958,"void WebURLLoaderImpl::Context::OnReceivedResponse(
    const ResourceResponseInfo& info) {
  if (!client_)
    return;

  WebURLResponse response;
  response.initialize();
  PopulateURLResponse(request_.url(), info, &response);

  bool show_raw_listing = (GURL(request_.url()).query() == ""raw"");

  if (info.mime_type == ""text/vnd.chromium.ftp-dir"") {
    if (show_raw_listing) {
      response.setMIMEType(""text/plain"");
    } else {
      response.setMIMEType(""text/html"");
     }
   }
 
   client_->didReceiveResponse(loader_, response);
 
  if (!client_)
    return;

  DCHECK(!ftp_listing_delegate_.get());
  DCHECK(!multipart_delegate_.get());
  if (info.headers && info.mime_type == ""multipart/x-mixed-replace"") {
    std::string content_type;
    info.headers->EnumerateHeader(NULL, ""content-type"", &content_type);

    std::string mime_type;
    std::string charset;
    bool had_charset = false;
    std::string boundary;
    net::HttpUtil::ParseContentType(content_type, &mime_type, &charset,
                                    &had_charset, &boundary);
    TrimString(boundary, "" \"""", &boundary);

    if (!boundary.empty()) {
      multipart_delegate_.reset(
          new MultipartResponseDelegate(client_, loader_, response, boundary));
    }
  } else if (info.mime_type == ""text/vnd.chromium.ftp-dir"" &&
             !show_raw_listing) {
    ftp_listing_delegate_.reset(
        new FtpDirectoryListingResponseDelegate(client_, loader_, response));
  }
}
","void WebURLLoaderImpl::Context::OnReceivedResponse(
    const ResourceResponseInfo& info) {
  if (!client_)
    return;

  WebURLResponse response;
  response.initialize();
  PopulateURLResponse(request_.url(), info, &response);

  bool show_raw_listing = (GURL(request_.url()).query() == ""raw"");

  if (info.mime_type == ""text/vnd.chromium.ftp-dir"") {
    if (show_raw_listing) {
      response.setMIMEType(""text/plain"");
    } else {
      response.setMIMEType(""text/html"");
     }
   }
 
  scoped_refptr<Context> protect(this);
   client_->didReceiveResponse(loader_, response);
 
  if (!client_)
    return;

  DCHECK(!ftp_listing_delegate_.get());
  DCHECK(!multipart_delegate_.get());
  if (info.headers && info.mime_type == ""multipart/x-mixed-replace"") {
    std::string content_type;
    info.headers->EnumerateHeader(NULL, ""content-type"", &content_type);

    std::string mime_type;
    std::string charset;
    bool had_charset = false;
    std::string boundary;
    net::HttpUtil::ParseContentType(content_type, &mime_type, &charset,
                                    &had_charset, &boundary);
    TrimString(boundary, "" \"""", &boundary);

    if (!boundary.empty()) {
      multipart_delegate_.reset(
          new MultipartResponseDelegate(client_, loader_, response, boundary));
    }
  } else if (info.mime_type == ""text/vnd.chromium.ftp-dir"" &&
             !show_raw_listing) {
    ftp_listing_delegate_.reset(
        new FtpDirectoryListingResponseDelegate(client_, loader_, response));
  }
}
","The vulnerability in the original code arises from the potential for a use-after-free error, specifically after the call to `client_->didReceiveResponse(loader_, response)`. If the `client_` is deleted during this callback, subsequent code execution could lead to dereferencing a dangling pointer, causing undefined behavior. The fix introduces a `scoped_refptr<Context> protect(this);` line, which ensures that the `Context` object remains alive for the duration of the response handling. This change effectively prevents the object from being deleted while still in use, thus mitigating the use-after-free vulnerability.","The vulnerability in the original code stems from a potential use-after-free issue, where an object could be deleted while still being accessed, leading to undefined behavior. This occurs after a callback is made, which may result in the deletion of the object before subsequent code execution completes. The fix addresses this vulnerability by introducing a mechanism that ensures the object remains alive for the duration of the response handling process. This change effectively prevents the object from being prematurely deleted, thereby safeguarding against the risks associated with dereferencing a dangling pointer."
67,185017,185017,,Remote,Not required,Partial,CVE-2013-2857,https://www.cvedetails.com/cve/CVE-2013-2857/,CWE-416,Low,Partial,Partial,,2013-06-04,7.5,Use-after-free vulnerability in Google Chrome before 27.0.1453.110 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the handling of images.,2017-09-18,DoS ,2,https://github.com/chromium/chromium/commit/7d085fbb43b21e959900b94f191588fd10546a94,7d085fbb43b21e959900b94f191588fd10546a94,"Error event was fired synchronously blowing away the input element from underneath. Remove the FIXME and fire it asynchronously using errorEventSender().

BUG=240124

Review URL: https://chromiumcodereview.appspot.com/14741011

git-svn-id: svn://svn.chromium.org/blink/trunk@150232 bbb929c8-8fbe-4397-9dbb-9b2b20218538",1,third_party/WebKit/Source/core/loader/ImageLoader.cpp,"{""sha"": ""c6f20fc986a03efbe20be6bfe8e1add665d719fa"", ""filename"": ""third_party/WebKit/LayoutTests/fast/forms/image/image-error-event-crash-expected.txt"", ""status"": ""added"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/7d085fbb43b21e959900b94f191588fd10546a94/third_party/WebKit/LayoutTests/fast/forms/image/image-error-event-crash-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7d085fbb43b21e959900b94f191588fd10546a94/third_party/WebKit/LayoutTests/fast/forms/image/image-error-event-crash-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/forms/image/image-error-event-crash-expected.txt?ref=7d085fbb43b21e959900b94f191588fd10546a94"", ""patch"": ""@@ -0,0 +1 @@\n+Test passes if it does not crash. ""}<_**next**_>{""sha"": ""340a971d1697bfbe396cee40cd1dde6ded0b9d62"", ""filename"": ""third_party/WebKit/LayoutTests/fast/forms/image/image-error-event-crash.html"", ""status"": ""added"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/7d085fbb43b21e959900b94f191588fd10546a94/third_party/WebKit/LayoutTests/fast/forms/image/image-error-event-crash.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7d085fbb43b21e959900b94f191588fd10546a94/third_party/WebKit/LayoutTests/fast/forms/image/image-error-event-crash.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/forms/image/image-error-event-crash.html?ref=7d085fbb43b21e959900b94f191588fd10546a94"", ""patch"": ""@@ -0,0 +1,11 @@\n+<!DOCTYPE html>\n+<html>\n+<body>\n+Test passes if it does not crash.\n+<input id=\""x\"" type=\""image\"" onerror=\""x.type=''\"" src=\""\"" />\n+<script>\n+if (window.testRunner)\n+    testRunner.dumpAsText();\n+</script>\n+</body>\n+</html>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""dd3f34aa274a60c23614d41f5d7a822598c5ac95"", ""filename"": ""third_party/WebKit/Source/core/loader/ImageLoader.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/7d085fbb43b21e959900b94f191588fd10546a94/third_party/WebKit/Source/core/loader/ImageLoader.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7d085fbb43b21e959900b94f191588fd10546a94/third_party/WebKit/Source/core/loader/ImageLoader.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/ImageLoader.cpp?ref=7d085fbb43b21e959900b94f191588fd10546a94"", ""patch"": ""@@ -211,8 +211,8 @@ void ImageLoader::updateFromElement()\n             clearFailedLoadURL();\n     } else if (!attr.isNull()) {\n         // Fire an error event if the url is empty.\n-        // FIXME: Should we fire this event asynchronoulsy via errorEventSender()?\n-        m_element->dispatchEvent(Event::create(eventNames().errorEvent, false, false));\n+        m_hasPendingErrorEvent = true;\n+        errorEventSender().dispatchEventSoon(this);\n     }\n     \n     CachedImage* oldImage = m_image.get();""}","void ImageLoader::updateFromElement()
{
    Document* document = m_element->document();
    if (!document->renderer())
        return;

    AtomicString attr = m_element->imageSourceURL();

    if (attr == m_failedLoadURL)
        return;

    CachedResourceHandle<CachedImage> newImage = 0;
    if (!attr.isNull() && !stripLeadingAndTrailingHTMLSpaces(attr).isEmpty()) {
        CachedResourceRequest request(ResourceRequest(document->completeURL(sourceURI(attr))));
        request.setInitiator(element());

        String crossOriginMode = m_element->fastGetAttribute(HTMLNames::crossoriginAttr);
        if (!crossOriginMode.isNull()) {
            StoredCredentials allowCredentials = equalIgnoringCase(crossOriginMode, ""use-credentials"") ? AllowStoredCredentials : DoNotAllowStoredCredentials;
            updateRequestForAccessControl(request.mutableResourceRequest(), document->securityOrigin(), allowCredentials);
        }

        if (m_loadManually) {
            bool autoLoadOtherImages = document->cachedResourceLoader()->autoLoadImages();
            document->cachedResourceLoader()->setAutoLoadImages(false);
            newImage = new CachedImage(request.resourceRequest());
            newImage->setLoading(true);
            newImage->setOwningCachedResourceLoader(document->cachedResourceLoader());
            document->cachedResourceLoader()->m_documentResources.set(newImage->url(), newImage.get());
            document->cachedResourceLoader()->setAutoLoadImages(autoLoadOtherImages);
        } else
            newImage = document->cachedResourceLoader()->requestImage(request);

        if (!newImage && !pageIsBeingDismissed(document)) {
            m_failedLoadURL = attr;
            m_hasPendingErrorEvent = true;
            errorEventSender().dispatchEventSoon(this);
        } else
             clearFailedLoadURL();
     } else if (!attr.isNull()) {
        m_hasPendingErrorEvent = true;
        errorEventSender().dispatchEventSoon(this);
     }
     
     CachedImage* oldImage = m_image.get();
    if (newImage != oldImage) {
        if (m_hasPendingBeforeLoadEvent) {
            beforeLoadEventSender().cancelEvent(this);
            m_hasPendingBeforeLoadEvent = false;
        }
        if (m_hasPendingLoadEvent) {
            loadEventSender().cancelEvent(this);
            m_hasPendingLoadEvent = false;
        }

        if (m_hasPendingErrorEvent && newImage) {
            errorEventSender().cancelEvent(this);
            m_hasPendingErrorEvent = false;
        }

        m_image = newImage;
        m_hasPendingBeforeLoadEvent = !m_element->document()->isImageDocument() && newImage;
        m_hasPendingLoadEvent = newImage;
        m_imageComplete = !newImage;

        if (newImage) {
            if (!m_element->document()->isImageDocument()) {
                if (!m_element->document()->hasListenerType(Document::BEFORELOAD_LISTENER))
                    dispatchPendingBeforeLoadEvent();
                else
                    beforeLoadEventSender().dispatchEventSoon(this);
            } else
                updateRenderer();

            newImage->addClient(this);
        }
        if (oldImage)
            oldImage->removeClient(this);
    }

    if (RenderImageResource* imageResource = renderImageResource())
        imageResource->resetAnimation();

    updatedHasPendingEvent();
}
","void ImageLoader::updateFromElement()
{
    Document* document = m_element->document();
    if (!document->renderer())
        return;

    AtomicString attr = m_element->imageSourceURL();

    if (attr == m_failedLoadURL)
        return;

    CachedResourceHandle<CachedImage> newImage = 0;
    if (!attr.isNull() && !stripLeadingAndTrailingHTMLSpaces(attr).isEmpty()) {
        CachedResourceRequest request(ResourceRequest(document->completeURL(sourceURI(attr))));
        request.setInitiator(element());

        String crossOriginMode = m_element->fastGetAttribute(HTMLNames::crossoriginAttr);
        if (!crossOriginMode.isNull()) {
            StoredCredentials allowCredentials = equalIgnoringCase(crossOriginMode, ""use-credentials"") ? AllowStoredCredentials : DoNotAllowStoredCredentials;
            updateRequestForAccessControl(request.mutableResourceRequest(), document->securityOrigin(), allowCredentials);
        }

        if (m_loadManually) {
            bool autoLoadOtherImages = document->cachedResourceLoader()->autoLoadImages();
            document->cachedResourceLoader()->setAutoLoadImages(false);
            newImage = new CachedImage(request.resourceRequest());
            newImage->setLoading(true);
            newImage->setOwningCachedResourceLoader(document->cachedResourceLoader());
            document->cachedResourceLoader()->m_documentResources.set(newImage->url(), newImage.get());
            document->cachedResourceLoader()->setAutoLoadImages(autoLoadOtherImages);
        } else
            newImage = document->cachedResourceLoader()->requestImage(request);

        if (!newImage && !pageIsBeingDismissed(document)) {
            m_failedLoadURL = attr;
            m_hasPendingErrorEvent = true;
            errorEventSender().dispatchEventSoon(this);
        } else
             clearFailedLoadURL();
     } else if (!attr.isNull()) {
        m_element->dispatchEvent(Event::create(eventNames().errorEvent, false, false));
     }
     
     CachedImage* oldImage = m_image.get();
    if (newImage != oldImage) {
        if (m_hasPendingBeforeLoadEvent) {
            beforeLoadEventSender().cancelEvent(this);
            m_hasPendingBeforeLoadEvent = false;
        }
        if (m_hasPendingLoadEvent) {
            loadEventSender().cancelEvent(this);
            m_hasPendingLoadEvent = false;
        }

        if (m_hasPendingErrorEvent && newImage) {
            errorEventSender().cancelEvent(this);
            m_hasPendingErrorEvent = false;
        }

        m_image = newImage;
        m_hasPendingBeforeLoadEvent = !m_element->document()->isImageDocument() && newImage;
        m_hasPendingLoadEvent = newImage;
        m_imageComplete = !newImage;

        if (newImage) {
            if (!m_element->document()->isImageDocument()) {
                if (!m_element->document()->hasListenerType(Document::BEFORELOAD_LISTENER))
                    dispatchPendingBeforeLoadEvent();
                else
                    beforeLoadEventSender().dispatchEventSoon(this);
            } else
                updateRenderer();

            newImage->addClient(this);
        }
        if (oldImage)
            oldImage->removeClient(this);
    }

    if (RenderImageResource* imageResource = renderImageResource())
        imageResource->resetAnimation();

    updatedHasPendingEvent();
}
",C,"        m_hasPendingErrorEvent = true;
        errorEventSender().dispatchEventSoon(this);
","        m_element->dispatchEvent(Event::create(eventNames().errorEvent, false, false));
",,"@@ -211,8 +211,8 @@ void ImageLoader::updateFromElement()
             clearFailedLoadURL();
     } else if (!attr.isNull()) {
         // Fire an error event if the url is empty.
-        // FIXME: Should we fire this event asynchronoulsy via errorEventSender()?
-        m_element->dispatchEvent(Event::create(eventNames().errorEvent, false, false));
+        m_hasPendingErrorEvent = true;
+        errorEventSender().dispatchEventSoon(this);
     }
     
     CachedImage* oldImage = m_image.get();",Chrome,7d085fbb43b21e959900b94f191588fd10546a94,4eac37ac2a1f601598a02475971e43a03f85fc2e,1,"void ImageLoader::updateFromElement()
{
    // If we're not making renderers for the page, then don't load images.  We don't want to slow
    // down the raw HTML parsing case by loading images we don't intend to display.
    Document* document = m_element->document();
    if (!document->renderer())
        return;

    AtomicString attr = m_element->imageSourceURL();

    if (attr == m_failedLoadURL)
        return;

    // Do not load any image if the 'src' attribute is missing or if it is
    // an empty string.
    CachedResourceHandle<CachedImage> newImage = 0;
    if (!attr.isNull() && !stripLeadingAndTrailingHTMLSpaces(attr).isEmpty()) {
        CachedResourceRequest request(ResourceRequest(document->completeURL(sourceURI(attr))));
        request.setInitiator(element());

        String crossOriginMode = m_element->fastGetAttribute(HTMLNames::crossoriginAttr);
        if (!crossOriginMode.isNull()) {
            StoredCredentials allowCredentials = equalIgnoringCase(crossOriginMode, ""use-credentials"") ? AllowStoredCredentials : DoNotAllowStoredCredentials;
            updateRequestForAccessControl(request.mutableResourceRequest(), document->securityOrigin(), allowCredentials);
        }

        if (m_loadManually) {
            bool autoLoadOtherImages = document->cachedResourceLoader()->autoLoadImages();
            document->cachedResourceLoader()->setAutoLoadImages(false);
            newImage = new CachedImage(request.resourceRequest());
            newImage->setLoading(true);
            newImage->setOwningCachedResourceLoader(document->cachedResourceLoader());
            document->cachedResourceLoader()->m_documentResources.set(newImage->url(), newImage.get());
            document->cachedResourceLoader()->setAutoLoadImages(autoLoadOtherImages);
        } else
            newImage = document->cachedResourceLoader()->requestImage(request);

        // If we do not have an image here, it means that a cross-site
        // violation occurred, or that the image was blocked via Content
        // Security Policy, or the page is being dismissed. Trigger an
        // error event if the page is not being dismissed.
        if (!newImage && !pageIsBeingDismissed(document)) {
            m_failedLoadURL = attr;
            m_hasPendingErrorEvent = true;
            errorEventSender().dispatchEventSoon(this);
        } else
             clearFailedLoadURL();
     } else if (!attr.isNull()) {
         // Fire an error event if the url is empty.
//flaw_line_below:
        // FIXME: Should we fire this event asynchronoulsy via errorEventSender()?
//flaw_line_below:
        m_element->dispatchEvent(Event::create(eventNames().errorEvent, false, false));
//fix_flaw_line_below:
//        m_hasPendingErrorEvent = true;
//fix_flaw_line_below:
//        errorEventSender().dispatchEventSoon(this);
     }
     
     CachedImage* oldImage = m_image.get();
    if (newImage != oldImage) {
        if (m_hasPendingBeforeLoadEvent) {
            beforeLoadEventSender().cancelEvent(this);
            m_hasPendingBeforeLoadEvent = false;
        }
        if (m_hasPendingLoadEvent) {
            loadEventSender().cancelEvent(this);
            m_hasPendingLoadEvent = false;
        }

        // Cancel error events that belong to the previous load, which is now cancelled by changing the src attribute.
        // If newImage is null and m_hasPendingErrorEvent is true, we know the error event has been just posted by
        // this load and we should not cancel the event.
        // FIXME: If both previous load and this one got blocked with an error, we can receive one error event instead of two.
        if (m_hasPendingErrorEvent && newImage) {
            errorEventSender().cancelEvent(this);
            m_hasPendingErrorEvent = false;
        }

        m_image = newImage;
        m_hasPendingBeforeLoadEvent = !m_element->document()->isImageDocument() && newImage;
        m_hasPendingLoadEvent = newImage;
        m_imageComplete = !newImage;

        if (newImage) {
            if (!m_element->document()->isImageDocument()) {
                if (!m_element->document()->hasListenerType(Document::BEFORELOAD_LISTENER))
                    dispatchPendingBeforeLoadEvent();
                else
                    beforeLoadEventSender().dispatchEventSoon(this);
            } else
                updateRenderer();

            // If newImage is cached, addClient() will result in the load event
            // being queued to fire. Ensure this happens after beforeload is
            // dispatched.
            newImage->addClient(this);
        }
        if (oldImage)
            oldImage->removeClient(this);
    }

    if (RenderImageResource* imageResource = renderImageResource())
        imageResource->resetAnimation();

    // Only consider updating the protection ref-count of the Element immediately before returning
    // from this function as doing so might result in the destruction of this ImageLoader.
    updatedHasPendingEvent();
}
",185017,"void ImageLoader::updateFromElement()
{
    Document* document = m_element->document();
    if (!document->renderer())
        return;

    AtomicString attr = m_element->imageSourceURL();

    if (attr == m_failedLoadURL)
        return;

    CachedResourceHandle<CachedImage> newImage = 0;
    if (!attr.isNull() && !stripLeadingAndTrailingHTMLSpaces(attr).isEmpty()) {
        CachedResourceRequest request(ResourceRequest(document->completeURL(sourceURI(attr))));
        request.setInitiator(element());

        String crossOriginMode = m_element->fastGetAttribute(HTMLNames::crossoriginAttr);
        if (!crossOriginMode.isNull()) {
            StoredCredentials allowCredentials = equalIgnoringCase(crossOriginMode, ""use-credentials"") ? AllowStoredCredentials : DoNotAllowStoredCredentials;
            updateRequestForAccessControl(request.mutableResourceRequest(), document->securityOrigin(), allowCredentials);
        }

        if (m_loadManually) {
            bool autoLoadOtherImages = document->cachedResourceLoader()->autoLoadImages();
            document->cachedResourceLoader()->setAutoLoadImages(false);
            newImage = new CachedImage(request.resourceRequest());
            newImage->setLoading(true);
            newImage->setOwningCachedResourceLoader(document->cachedResourceLoader());
            document->cachedResourceLoader()->m_documentResources.set(newImage->url(), newImage.get());
            document->cachedResourceLoader()->setAutoLoadImages(autoLoadOtherImages);
        } else
            newImage = document->cachedResourceLoader()->requestImage(request);

        if (!newImage && !pageIsBeingDismissed(document)) {
            m_failedLoadURL = attr;
            m_hasPendingErrorEvent = true;
            errorEventSender().dispatchEventSoon(this);
        } else
             clearFailedLoadURL();
     } else if (!attr.isNull()) {
        m_element->dispatchEvent(Event::create(eventNames().errorEvent, false, false));
     }
     
     CachedImage* oldImage = m_image.get();
    if (newImage != oldImage) {
        if (m_hasPendingBeforeLoadEvent) {
            beforeLoadEventSender().cancelEvent(this);
            m_hasPendingBeforeLoadEvent = false;
        }
        if (m_hasPendingLoadEvent) {
            loadEventSender().cancelEvent(this);
            m_hasPendingLoadEvent = false;
        }

        if (m_hasPendingErrorEvent && newImage) {
            errorEventSender().cancelEvent(this);
            m_hasPendingErrorEvent = false;
        }

        m_image = newImage;
        m_hasPendingBeforeLoadEvent = !m_element->document()->isImageDocument() && newImage;
        m_hasPendingLoadEvent = newImage;
        m_imageComplete = !newImage;

        if (newImage) {
            if (!m_element->document()->isImageDocument()) {
                if (!m_element->document()->hasListenerType(Document::BEFORELOAD_LISTENER))
                    dispatchPendingBeforeLoadEvent();
                else
                    beforeLoadEventSender().dispatchEventSoon(this);
            } else
                updateRenderer();

            newImage->addClient(this);
        }
        if (oldImage)
            oldImage->removeClient(this);
    }

    if (RenderImageResource* imageResource = renderImageResource())
        imageResource->resetAnimation();

    updatedHasPendingEvent();
}
","void ImageLoader::updateFromElement()
{
    Document* document = m_element->document();
    if (!document->renderer())
        return;

    AtomicString attr = m_element->imageSourceURL();

    if (attr == m_failedLoadURL)
        return;

    CachedResourceHandle<CachedImage> newImage = 0;
    if (!attr.isNull() && !stripLeadingAndTrailingHTMLSpaces(attr).isEmpty()) {
        CachedResourceRequest request(ResourceRequest(document->completeURL(sourceURI(attr))));
        request.setInitiator(element());

        String crossOriginMode = m_element->fastGetAttribute(HTMLNames::crossoriginAttr);
        if (!crossOriginMode.isNull()) {
            StoredCredentials allowCredentials = equalIgnoringCase(crossOriginMode, ""use-credentials"") ? AllowStoredCredentials : DoNotAllowStoredCredentials;
            updateRequestForAccessControl(request.mutableResourceRequest(), document->securityOrigin(), allowCredentials);
        }

        if (m_loadManually) {
            bool autoLoadOtherImages = document->cachedResourceLoader()->autoLoadImages();
            document->cachedResourceLoader()->setAutoLoadImages(false);
            newImage = new CachedImage(request.resourceRequest());
            newImage->setLoading(true);
            newImage->setOwningCachedResourceLoader(document->cachedResourceLoader());
            document->cachedResourceLoader()->m_documentResources.set(newImage->url(), newImage.get());
            document->cachedResourceLoader()->setAutoLoadImages(autoLoadOtherImages);
        } else
            newImage = document->cachedResourceLoader()->requestImage(request);

        if (!newImage && !pageIsBeingDismissed(document)) {
            m_failedLoadURL = attr;
            m_hasPendingErrorEvent = true;
            errorEventSender().dispatchEventSoon(this);
        } else
             clearFailedLoadURL();
     } else if (!attr.isNull()) {
        m_hasPendingErrorEvent = true;
        errorEventSender().dispatchEventSoon(this);
     }
     
     CachedImage* oldImage = m_image.get();
    if (newImage != oldImage) {
        if (m_hasPendingBeforeLoadEvent) {
            beforeLoadEventSender().cancelEvent(this);
            m_hasPendingBeforeLoadEvent = false;
        }
        if (m_hasPendingLoadEvent) {
            loadEventSender().cancelEvent(this);
            m_hasPendingLoadEvent = false;
        }

        if (m_hasPendingErrorEvent && newImage) {
            errorEventSender().cancelEvent(this);
            m_hasPendingErrorEvent = false;
        }

        m_image = newImage;
        m_hasPendingBeforeLoadEvent = !m_element->document()->isImageDocument() && newImage;
        m_hasPendingLoadEvent = newImage;
        m_imageComplete = !newImage;

        if (newImage) {
            if (!m_element->document()->isImageDocument()) {
                if (!m_element->document()->hasListenerType(Document::BEFORELOAD_LISTENER))
                    dispatchPendingBeforeLoadEvent();
                else
                    beforeLoadEventSender().dispatchEventSoon(this);
            } else
                updateRenderer();

            newImage->addClient(this);
        }
        if (oldImage)
            oldImage->removeClient(this);
    }

    if (RenderImageResource* imageResource = renderImageResource())
        imageResource->resetAnimation();

    updatedHasPendingEvent();
}
","The vulnerability in the original code lies in the handling of the `m_hasPendingErrorEvent` flag when the `attr` variable is not null but empty after stripping HTML spaces. In this case, the code incorrectly dispatched an error event without setting `m_hasPendingErrorEvent` to true, potentially leading to inconsistent state management. The fix addresses this by ensuring that `m_hasPendingErrorEvent` is set to true in the else-if block when `attr` is not null, thereby maintaining proper event handling and ensuring that error events are dispatched correctly when the image source URL is invalid.","The vulnerability in the original code stems from improper management of error event flags when handling invalid image source URLs. Specifically, the code failed to consistently set the error event flag when the image source was not null but empty after processing, which could lead to incorrect event dispatching and an inconsistent state. The fix rectifies this by ensuring that the error event flag is set appropriately in all relevant scenarios, thereby enhancing the reliability of event handling and ensuring that error events are dispatched correctly when encountering invalid image sources."
68,185339,185339,,Remote,Not required,Partial,CVE-2014-3191,https://www.cvedetails.com/cve/CVE-2014-3191/,CWE-416,Low,Partial,Partial,,2014-10-08,7.5,"Use-after-free vulnerability in Blink, as used in Google Chrome before 38.0.2125.101, allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted JavaScript code that triggers a widget-position update that improperly interacts with the render tree, related to the FrameView::updateLayoutAndStyleForPainting function in core/frame/FrameView.cpp and the RenderLayerScrollableArea::setScrollOffset function in core/rendering/RenderLayerScrollableArea.cpp.",2016-11-28,DoS ,2,https://github.com/chromium/chromium/commit/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95,11a4cc4a6d6e665d9a118fada4b7c658d6f70d95,"Defer call to updateWidgetPositions() outside of RenderLayerScrollableArea.

updateWidgetPositions() can destroy the render tree, so it should never
be called from inside RenderLayerScrollableArea. Leaving it there allows
for the potential of use-after-free bugs.

BUG=402407
R=vollick@chromium.org

Review URL: https://codereview.chromium.org/490473003

git-svn-id: svn://svn.chromium.org/blink/trunk@180681 bbb929c8-8fbe-4397-9dbb-9b2b20218538",0,third_party/WebKit/Source/core/frame/FrameView.cpp,"{""sha"": ""139597f9cb07c5d48bed18984ec4747f4b4f3438"", ""filename"": ""third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions-expected.txt"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions-expected.txt?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -0,0 +1,2 @@\n+\n+""}<_**next**_>{""sha"": ""8f4d71cc76ae3093b28ae3f6a6171df7c1f37863"", ""filename"": ""third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions.html"", ""status"": ""added"", ""additions"": 60, ""deletions"": 0, ""changes"": 60, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions.html?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -0,0 +1,60 @@\n+<!DOCTYPE html>\n+<!-- This test is to catch a flakey use-after-free for ASAN bots. (see crbug.com/402407) -->\n+<script>\n+  function start() {\n+    svgIframe = document.createElement('iframe');\n+    svgIframe.src = 'resources/do-not-crash-use-after-free-update-widget-positions.svg';\n+\n+    bodyElement = document.body;\n+\n+    articleElement = document.createElement('article');\n+    acronymElement = document.createElement('acronym');\n+\n+    bodyElement.style.overflow = 'scroll';\n+\n+    selectionRange = document.createRange();\n+    selectionRange.selectNodeContents(articleElement);\n+    selectionRange.surroundContents(bodyElement);\n+\n+    w3Iframe = document.createElementNS('http://www.w3.org/1999/xhtml', 'iframe');\n+    w3Iframe.src = 'resources/do-not-crash-use-after-free-update-widget-positions-iframe.html';\n+    w3Iframe.onload = iframeOnLoad;\n+    document.documentElement.appendChild(w3Iframe);\n+\n+    selectionRange.insertNode(svgIframe);\n+    bodyElement.style.position = 'fixed';\n+\n+    while (svgIframe.parentNode) {\n+      svgIframe = svgIframe.parentNode;\n+    }\n+\n+    svgIframe.createElement;\n+\n+    document.documentElement.appendChild(svgIframe);\n+\n+    acronymElement.style.position = 'absolute';\n+  }\n+\n+  function iframeOnLoad() {\n+    bodyElement.appendChild(acronymElement);\n+    acronymElement.offsetWidth;\n+\n+    acronymElement.appendChild(w3Iframe);\n+    w3Iframe.offsetWidth;\n+\n+    window.setTimeout('window.iframeCallback()', 50);\n+  }\n+\n+  function iframeCallback() {\n+    bodyElement.style.cssText = null;\n+\n+    w3Iframe.contentDocument.location.hash = 'element0';\n+  }\n+\n+  if (window.testRunner) {\n+    testRunner.dumpAsText();\n+  }\n+</script>\n+<body onload = \""start()\"">\n+  This test passes if it doesn't crash.\n+</body>""}<_**next**_>{""sha"": ""93cd657e822e58345e3f98b8b61112d939d19ea8"", ""filename"": ""third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions-iframe.html"", ""status"": ""added"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions-iframe.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions-iframe.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions-iframe.html?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -0,0 +1,4 @@\n+<!DOCTYPE html>\n+<body id=\""element0\"">\n+</body>\n+""}<_**next**_>{""sha"": ""bb5dd22510b2bbd51b2b4023e1a75c95f264d7c1"", ""filename"": ""third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions.svg"", ""status"": ""added"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions.svg"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions.svg"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions.svg?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -0,0 +1,7 @@\n+<?xml version=\""1.0\""?>\n+<svg id=\""element0\"" xmlns=\""http://www.w3.org/2000/svg\"">\n+  <rect>\n+    <animate from=\""10px\""  to=\""100px\"" />\n+    <animate attributeName=\""height\"" to=\""10px\"" dur=\""10s\"" />\n+  </rect>\n+</svg>""}<_**next**_>{""sha"": ""b7540d9fe937adc128d4c3ed672d330b822a5258"", ""filename"": ""third_party/WebKit/Source/core/frame/FrameView.cpp"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 0, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/frame/FrameView.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/frame/FrameView.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/FrameView.cpp?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -118,6 +118,7 @@ FrameView::FrameView(LocalFrame* frame)\n     , m_inputEventsScaleFactorForEmulation(1)\n     , m_layoutSizeFixedToFrameSize(true)\n     , m_didScrollTimer(this, &FrameView::didScrollTimerFired)\n+    , m_needsUpdateWidgetPositions(false)\n {\n     ASSERT(m_frame);\n     init();\n@@ -2545,13 +2546,25 @@ void FrameView::paintOverhangAreas(GraphicsContext* context, const IntRect& hori\n     ScrollView::paintOverhangAreas(context, horizontalOverhangArea, verticalOverhangArea, dirtyRect);\n }\n \n+void FrameView::updateWidgetPositionsIfNeeded()\n+{\n+    if (!m_needsUpdateWidgetPositions)\n+        return;\n+\n+    m_needsUpdateWidgetPositions = false;\n+\n+    updateWidgetPositions();\n+}\n+\n void FrameView::updateLayoutAndStyleForPainting()\n {\n     // Updating layout can run script, which can tear down the FrameView.\n     RefPtr<FrameView> protector(this);\n \n     updateLayoutAndStyleIfNeededRecursive();\n \n+    updateWidgetPositionsIfNeeded();\n+\n     if (RenderView* view = renderView()) {\n         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(\""devtools.timeline\""), \""UpdateLayerTree\"", \""frame\"", m_frame.get());\n         // FIXME(361045): remove InspectorInstrumentation calls once DevTools Timeline migrates to tracing.""}<_**next**_>{""sha"": ""15f88afb4861a50b770e8ce54cedd35ecc08ddb5"", ""filename"": ""third_party/WebKit/Source/core/frame/FrameView.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/frame/FrameView.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/frame/FrameView.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/FrameView.h?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -103,6 +103,8 @@ class FrameView FINAL : public ScrollView {\n     bool needsLayout() const;\n     void setNeedsLayout();\n \n+    void setNeedsUpdateWidgetPositions() { m_needsUpdateWidgetPositions = true; }\n+\n     // Methods for getting/setting the size Blink should use to layout the contents.\n     IntSize layoutSize(IncludeScrollbarsInRect = ExcludeScrollbars) const;\n     void setLayoutSize(const IntSize&);\n@@ -370,6 +372,8 @@ class FrameView FINAL : public ScrollView {\n     virtual IntPoint convertToContainingView(const IntPoint&) const OVERRIDE;\n     virtual IntPoint convertFromContainingView(const IntPoint&) const OVERRIDE;\n \n+    void updateWidgetPositionsIfNeeded();\n+\n     void sendResizeEventIfNeeded();\n \n     void updateScrollableAreaSet();\n@@ -490,6 +494,8 @@ class FrameView FINAL : public ScrollView {\n     Timer<FrameView> m_didScrollTimer;\n \n     Vector<IntRect> m_tickmarks;\n+\n+    bool m_needsUpdateWidgetPositions;\n };\n \n inline void FrameView::incrementVisuallyNonEmptyCharacterCount(unsigned count)""}<_**next**_>{""sha"": ""d6a56bf0a5bb016c8732d23fbfd53dbcb809a82d"", ""filename"": ""third_party/WebKit/Source/core/rendering/RenderLayerScrollableArea.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 4, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/rendering/RenderLayerScrollableArea.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/rendering/RenderLayerScrollableArea.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/rendering/RenderLayerScrollableArea.cpp?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -366,10 +366,7 @@ void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)\n         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));\n         // Update regions, scrolling may change the clip of a particular region.\n         frameView->updateAnnotatedRegions();\n-        // FIXME: We shouldn't call updateWidgetPositions() here since it might tear down the render tree,\n-        // for now we just crash to avoid allowing an attacker to use after free.\n-        frameView->updateWidgetPositions();\n-        RELEASE_ASSERT(frameView->renderView());\n+        frameView->setNeedsUpdateWidgetPositions();\n         updateCompositingLayersAfterScroll();\n     }\n ""}"," void FrameView::updateLayoutAndStyleForPainting()
 {
     RefPtr<FrameView> protector(this);
 
     updateLayoutAndStyleIfNeededRecursive();
 
    updateWidgetPositionsIfNeeded();

     if (RenderView* view = renderView()) {
         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""UpdateLayerTree"", ""frame"", m_frame.get());
        InspectorInstrumentation::willUpdateLayerTree(m_frame.get());

        view->compositor()->updateIfNeededRecursive();

        if (view->compositor()->inCompositingMode() && m_frame->isLocalRoot())
            m_frame->page()->scrollingCoordinator()->updateAfterCompositingChangeIfNeeded();

        updateCompositedSelectionBoundsIfNeeded();

        InspectorInstrumentation::didUpdateLayerTree(m_frame.get());

        invalidateTreeIfNeededRecursive();
    }

    scrollContentsIfNeededRecursive();
    ASSERT(lifecycle().state() == DocumentLifecycle::PaintInvalidationClean);
}
"," void FrameView::updateLayoutAndStyleForPainting()
 {
     RefPtr<FrameView> protector(this);
 
     updateLayoutAndStyleIfNeededRecursive();
 
     if (RenderView* view = renderView()) {
         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""UpdateLayerTree"", ""frame"", m_frame.get());
        InspectorInstrumentation::willUpdateLayerTree(m_frame.get());

        view->compositor()->updateIfNeededRecursive();

        if (view->compositor()->inCompositingMode() && m_frame->isLocalRoot())
            m_frame->page()->scrollingCoordinator()->updateAfterCompositingChangeIfNeeded();

        updateCompositedSelectionBoundsIfNeeded();

        InspectorInstrumentation::didUpdateLayerTree(m_frame.get());

        invalidateTreeIfNeededRecursive();
    }

    scrollContentsIfNeededRecursive();
    ASSERT(lifecycle().state() == DocumentLifecycle::PaintInvalidationClean);
}
",C,"    updateWidgetPositionsIfNeeded();

",,,"@@ -118,6 +118,7 @@ FrameView::FrameView(LocalFrame* frame)
     , m_inputEventsScaleFactorForEmulation(1)
     , m_layoutSizeFixedToFrameSize(true)
     , m_didScrollTimer(this, &FrameView::didScrollTimerFired)
+    , m_needsUpdateWidgetPositions(false)
 {
     ASSERT(m_frame);
     init();
@@ -2545,13 +2546,25 @@ void FrameView::paintOverhangAreas(GraphicsContext* context, const IntRect& hori
     ScrollView::paintOverhangAreas(context, horizontalOverhangArea, verticalOverhangArea, dirtyRect);
 }
 
+void FrameView::updateWidgetPositionsIfNeeded()
+{
+    if (!m_needsUpdateWidgetPositions)
+        return;
+
+    m_needsUpdateWidgetPositions = false;
+
+    updateWidgetPositions();
+}
+
 void FrameView::updateLayoutAndStyleForPainting()
 {
     // Updating layout can run script, which can tear down the FrameView.
     RefPtr<FrameView> protector(this);
 
     updateLayoutAndStyleIfNeededRecursive();
 
+    updateWidgetPositionsIfNeeded();
+
     if (RenderView* view = renderView()) {
         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""UpdateLayerTree"", ""frame"", m_frame.get());
         // FIXME(361045): remove InspectorInstrumentation calls once DevTools Timeline migrates to tracing.",Chrome,11a4cc4a6d6e665d9a118fada4b7c658d6f70d95,09298a5df529dfb55d846f5f85df4df437fac052,1," void FrameView::updateLayoutAndStyleForPainting()
 {
     // Updating layout can run script, which can tear down the FrameView.
     RefPtr<FrameView> protector(this);
 
     updateLayoutAndStyleIfNeededRecursive();
 
//fix_flaw_line_below:
//    updateWidgetPositionsIfNeeded();
//fix_flaw_line_below:
//
     if (RenderView* view = renderView()) {
         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""UpdateLayerTree"", ""frame"", m_frame.get());
         // FIXME(361045): remove InspectorInstrumentation calls once DevTools Timeline migrates to tracing.
        InspectorInstrumentation::willUpdateLayerTree(m_frame.get());

        view->compositor()->updateIfNeededRecursive();

        if (view->compositor()->inCompositingMode() && m_frame->isLocalRoot())
            m_frame->page()->scrollingCoordinator()->updateAfterCompositingChangeIfNeeded();

        updateCompositedSelectionBoundsIfNeeded();

        InspectorInstrumentation::didUpdateLayerTree(m_frame.get());

        invalidateTreeIfNeededRecursive();
    }

    scrollContentsIfNeededRecursive();
    ASSERT(lifecycle().state() == DocumentLifecycle::PaintInvalidationClean);
}
",185339," void FrameView::updateLayoutAndStyleForPainting()
 {
     RefPtr<FrameView> protector(this);
 
     updateLayoutAndStyleIfNeededRecursive();
 
     if (RenderView* view = renderView()) {
         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""UpdateLayerTree"", ""frame"", m_frame.get());
        InspectorInstrumentation::willUpdateLayerTree(m_frame.get());

        view->compositor()->updateIfNeededRecursive();

        if (view->compositor()->inCompositingMode() && m_frame->isLocalRoot())
            m_frame->page()->scrollingCoordinator()->updateAfterCompositingChangeIfNeeded();

        updateCompositedSelectionBoundsIfNeeded();

        InspectorInstrumentation::didUpdateLayerTree(m_frame.get());

        invalidateTreeIfNeededRecursive();
    }

    scrollContentsIfNeededRecursive();
    ASSERT(lifecycle().state() == DocumentLifecycle::PaintInvalidationClean);
}
"," void FrameView::updateLayoutAndStyleForPainting()
 {
     RefPtr<FrameView> protector(this);
 
     updateLayoutAndStyleIfNeededRecursive();
 
    updateWidgetPositionsIfNeeded();

     if (RenderView* view = renderView()) {
         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""UpdateLayerTree"", ""frame"", m_frame.get());
        InspectorInstrumentation::willUpdateLayerTree(m_frame.get());

        view->compositor()->updateIfNeededRecursive();

        if (view->compositor()->inCompositingMode() && m_frame->isLocalRoot())
            m_frame->page()->scrollingCoordinator()->updateAfterCompositingChangeIfNeeded();

        updateCompositedSelectionBoundsIfNeeded();

        InspectorInstrumentation::didUpdateLayerTree(m_frame.get());

        invalidateTreeIfNeededRecursive();
    }

    scrollContentsIfNeededRecursive();
    ASSERT(lifecycle().state() == DocumentLifecycle::PaintInvalidationClean);
}
","The vulnerability in the original code lies in the absence of a call to `updateWidgetPositionsIfNeeded()` before rendering updates, which could lead to inconsistencies in the layout and style of the frame during painting. This omission may result in visual artifacts or incorrect rendering, especially when the layout has changed but the widget positions have not been updated accordingly. The fixed code addresses this vulnerability by adding the `updateWidgetPositionsIfNeeded()` function call right after `updateLayoutAndStyleIfNeededRecursive()`, ensuring that widget positions are correctly updated before any rendering operations, thus enhancing the stability and correctness of the rendering process.","The vulnerability in the original code stems from the lack of a necessary update to widget positions before rendering updates, which can lead to inconsistencies and visual artifacts during the painting process. This oversight may result in the display not accurately reflecting the current layout, especially after changes have occurred. The fixed code resolves this issue by introducing an update step for widget positions prior to any rendering operations. This ensures that all components are correctly aligned and positioned, thereby enhancing the overall stability and accuracy of the rendering process and preventing potential visual discrepancies."
69,185340,185340,,Remote,Not required,Partial,CVE-2014-3191,https://www.cvedetails.com/cve/CVE-2014-3191/,CWE-416,Low,Partial,Partial,,2014-10-08,7.5,"Use-after-free vulnerability in Blink, as used in Google Chrome before 38.0.2125.101, allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted JavaScript code that triggers a widget-position update that improperly interacts with the render tree, related to the FrameView::updateLayoutAndStyleForPainting function in core/frame/FrameView.cpp and the RenderLayerScrollableArea::setScrollOffset function in core/rendering/RenderLayerScrollableArea.cpp.",2016-11-28,DoS ,1,https://github.com/chromium/chromium/commit/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95,11a4cc4a6d6e665d9a118fada4b7c658d6f70d95,"Defer call to updateWidgetPositions() outside of RenderLayerScrollableArea.

updateWidgetPositions() can destroy the render tree, so it should never
be called from inside RenderLayerScrollableArea. Leaving it there allows
for the potential of use-after-free bugs.

BUG=402407
R=vollick@chromium.org

Review URL: https://codereview.chromium.org/490473003

git-svn-id: svn://svn.chromium.org/blink/trunk@180681 bbb929c8-8fbe-4397-9dbb-9b2b20218538",2,third_party/WebKit/Source/core/rendering/RenderLayerScrollableArea.cpp,"{""sha"": ""139597f9cb07c5d48bed18984ec4747f4b4f3438"", ""filename"": ""third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions-expected.txt"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions-expected.txt?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -0,0 +1,2 @@\n+\n+""}<_**next**_>{""sha"": ""8f4d71cc76ae3093b28ae3f6a6171df7c1f37863"", ""filename"": ""third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions.html"", ""status"": ""added"", ""additions"": 60, ""deletions"": 0, ""changes"": 60, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions.html?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -0,0 +1,60 @@\n+<!DOCTYPE html>\n+<!-- This test is to catch a flakey use-after-free for ASAN bots. (see crbug.com/402407) -->\n+<script>\n+  function start() {\n+    svgIframe = document.createElement('iframe');\n+    svgIframe.src = 'resources/do-not-crash-use-after-free-update-widget-positions.svg';\n+\n+    bodyElement = document.body;\n+\n+    articleElement = document.createElement('article');\n+    acronymElement = document.createElement('acronym');\n+\n+    bodyElement.style.overflow = 'scroll';\n+\n+    selectionRange = document.createRange();\n+    selectionRange.selectNodeContents(articleElement);\n+    selectionRange.surroundContents(bodyElement);\n+\n+    w3Iframe = document.createElementNS('http://www.w3.org/1999/xhtml', 'iframe');\n+    w3Iframe.src = 'resources/do-not-crash-use-after-free-update-widget-positions-iframe.html';\n+    w3Iframe.onload = iframeOnLoad;\n+    document.documentElement.appendChild(w3Iframe);\n+\n+    selectionRange.insertNode(svgIframe);\n+    bodyElement.style.position = 'fixed';\n+\n+    while (svgIframe.parentNode) {\n+      svgIframe = svgIframe.parentNode;\n+    }\n+\n+    svgIframe.createElement;\n+\n+    document.documentElement.appendChild(svgIframe);\n+\n+    acronymElement.style.position = 'absolute';\n+  }\n+\n+  function iframeOnLoad() {\n+    bodyElement.appendChild(acronymElement);\n+    acronymElement.offsetWidth;\n+\n+    acronymElement.appendChild(w3Iframe);\n+    w3Iframe.offsetWidth;\n+\n+    window.setTimeout('window.iframeCallback()', 50);\n+  }\n+\n+  function iframeCallback() {\n+    bodyElement.style.cssText = null;\n+\n+    w3Iframe.contentDocument.location.hash = 'element0';\n+  }\n+\n+  if (window.testRunner) {\n+    testRunner.dumpAsText();\n+  }\n+</script>\n+<body onload = \""start()\"">\n+  This test passes if it doesn't crash.\n+</body>""}<_**next**_>{""sha"": ""93cd657e822e58345e3f98b8b61112d939d19ea8"", ""filename"": ""third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions-iframe.html"", ""status"": ""added"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions-iframe.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions-iframe.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions-iframe.html?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -0,0 +1,4 @@\n+<!DOCTYPE html>\n+<body id=\""element0\"">\n+</body>\n+""}<_**next**_>{""sha"": ""bb5dd22510b2bbd51b2b4023e1a75c95f264d7c1"", ""filename"": ""third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions.svg"", ""status"": ""added"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions.svg"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions.svg"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions.svg?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -0,0 +1,7 @@\n+<?xml version=\""1.0\""?>\n+<svg id=\""element0\"" xmlns=\""http://www.w3.org/2000/svg\"">\n+  <rect>\n+    <animate from=\""10px\""  to=\""100px\"" />\n+    <animate attributeName=\""height\"" to=\""10px\"" dur=\""10s\"" />\n+  </rect>\n+</svg>""}<_**next**_>{""sha"": ""b7540d9fe937adc128d4c3ed672d330b822a5258"", ""filename"": ""third_party/WebKit/Source/core/frame/FrameView.cpp"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 0, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/frame/FrameView.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/frame/FrameView.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/FrameView.cpp?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -118,6 +118,7 @@ FrameView::FrameView(LocalFrame* frame)\n     , m_inputEventsScaleFactorForEmulation(1)\n     , m_layoutSizeFixedToFrameSize(true)\n     , m_didScrollTimer(this, &FrameView::didScrollTimerFired)\n+    , m_needsUpdateWidgetPositions(false)\n {\n     ASSERT(m_frame);\n     init();\n@@ -2545,13 +2546,25 @@ void FrameView::paintOverhangAreas(GraphicsContext* context, const IntRect& hori\n     ScrollView::paintOverhangAreas(context, horizontalOverhangArea, verticalOverhangArea, dirtyRect);\n }\n \n+void FrameView::updateWidgetPositionsIfNeeded()\n+{\n+    if (!m_needsUpdateWidgetPositions)\n+        return;\n+\n+    m_needsUpdateWidgetPositions = false;\n+\n+    updateWidgetPositions();\n+}\n+\n void FrameView::updateLayoutAndStyleForPainting()\n {\n     // Updating layout can run script, which can tear down the FrameView.\n     RefPtr<FrameView> protector(this);\n \n     updateLayoutAndStyleIfNeededRecursive();\n \n+    updateWidgetPositionsIfNeeded();\n+\n     if (RenderView* view = renderView()) {\n         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(\""devtools.timeline\""), \""UpdateLayerTree\"", \""frame\"", m_frame.get());\n         // FIXME(361045): remove InspectorInstrumentation calls once DevTools Timeline migrates to tracing.""}<_**next**_>{""sha"": ""15f88afb4861a50b770e8ce54cedd35ecc08ddb5"", ""filename"": ""third_party/WebKit/Source/core/frame/FrameView.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/frame/FrameView.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/frame/FrameView.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/FrameView.h?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -103,6 +103,8 @@ class FrameView FINAL : public ScrollView {\n     bool needsLayout() const;\n     void setNeedsLayout();\n \n+    void setNeedsUpdateWidgetPositions() { m_needsUpdateWidgetPositions = true; }\n+\n     // Methods for getting/setting the size Blink should use to layout the contents.\n     IntSize layoutSize(IncludeScrollbarsInRect = ExcludeScrollbars) const;\n     void setLayoutSize(const IntSize&);\n@@ -370,6 +372,8 @@ class FrameView FINAL : public ScrollView {\n     virtual IntPoint convertToContainingView(const IntPoint&) const OVERRIDE;\n     virtual IntPoint convertFromContainingView(const IntPoint&) const OVERRIDE;\n \n+    void updateWidgetPositionsIfNeeded();\n+\n     void sendResizeEventIfNeeded();\n \n     void updateScrollableAreaSet();\n@@ -490,6 +494,8 @@ class FrameView FINAL : public ScrollView {\n     Timer<FrameView> m_didScrollTimer;\n \n     Vector<IntRect> m_tickmarks;\n+\n+    bool m_needsUpdateWidgetPositions;\n };\n \n inline void FrameView::incrementVisuallyNonEmptyCharacterCount(unsigned count)""}<_**next**_>{""sha"": ""d6a56bf0a5bb016c8732d23fbfd53dbcb809a82d"", ""filename"": ""third_party/WebKit/Source/core/rendering/RenderLayerScrollableArea.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 4, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/rendering/RenderLayerScrollableArea.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/rendering/RenderLayerScrollableArea.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/rendering/RenderLayerScrollableArea.cpp?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -366,10 +366,7 @@ void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)\n         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));\n         // Update regions, scrolling may change the clip of a particular region.\n         frameView->updateAnnotatedRegions();\n-        // FIXME: We shouldn't call updateWidgetPositions() here since it might tear down the render tree,\n-        // for now we just crash to avoid allowing an attacker to use after free.\n-        frameView->updateWidgetPositions();\n-        RELEASE_ASSERT(frameView->renderView());\n+        frameView->setNeedsUpdateWidgetPositions();\n         updateCompositingLayersAfterScroll();\n     }\n ""}","void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)
{
    if (!box().isMarquee()) {
        if (m_scrollDimensionsDirty)
            computeScrollDimensions();
    }

    if (scrollOffset() == toIntSize(newScrollOffset))
        return;

    setScrollOffset(toIntSize(newScrollOffset));

    LocalFrame* frame = box().frame();
    ASSERT(frame);

    RefPtr<FrameView> frameView = box().frameView();

    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""ScrollLayer"", ""data"", InspectorScrollLayerEvent::data(&box()));
    InspectorInstrumentation::willScrollLayer(&box());

    const RenderLayerModelObject* paintInvalidationContainer = box().containerForPaintInvalidation();

    if (!frameView->isInPerformLayout()) {
        layer()->clipper().clearClipRectsIncludingDescendants();
         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));
         frameView->updateAnnotatedRegions();
        frameView->setNeedsUpdateWidgetPositions();
         updateCompositingLayersAfterScroll();
     }
 
    frame->selection().setCaretRectNeedsUpdate();

    FloatQuad quadForFakeMouseMoveEvent = FloatQuad(layer()->renderer()->previousPaintInvalidationRect());

    quadForFakeMouseMoveEvent = paintInvalidationContainer->localToAbsoluteQuad(quadForFakeMouseMoveEvent);
    frame->eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);

    bool requiresPaintInvalidation = true;

    if (!box().isMarquee() && box().view()->compositor()->inCompositingMode()) {
        DisableCompositingQueryAsserts disabler;
        bool onlyScrolledCompositedLayers = scrollsOverflow()
            && !layer()->hasVisibleNonLayerContent()
            && !layer()->hasNonCompositedChild()
            && !layer()->hasBlockSelectionGapBounds()
            && box().style()->backgroundLayers().attachment() != LocalBackgroundAttachment;

        if (usesCompositedScrolling() || onlyScrolledCompositedLayers)
            requiresPaintInvalidation = false;
    }

    if (requiresPaintInvalidation) {
        if (box().frameView()->isInPerformLayout())
            box().setShouldDoFullPaintInvalidation(true);
        else
            box().invalidatePaintUsingContainer(paintInvalidationContainer, layer()->renderer()->previousPaintInvalidationRect(), InvalidationScroll);
    }

    if (box().node())
        box().node()->document().enqueueScrollEventForNode(box().node());

    if (AXObjectCache* cache = box().document().existingAXObjectCache())
        cache->handleScrollPositionChanged(&box());

    InspectorInstrumentation::didScrollLayer(&box());
}
","void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)
{
    if (!box().isMarquee()) {
        if (m_scrollDimensionsDirty)
            computeScrollDimensions();
    }

    if (scrollOffset() == toIntSize(newScrollOffset))
        return;

    setScrollOffset(toIntSize(newScrollOffset));

    LocalFrame* frame = box().frame();
    ASSERT(frame);

    RefPtr<FrameView> frameView = box().frameView();

    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""ScrollLayer"", ""data"", InspectorScrollLayerEvent::data(&box()));
    InspectorInstrumentation::willScrollLayer(&box());

    const RenderLayerModelObject* paintInvalidationContainer = box().containerForPaintInvalidation();

    if (!frameView->isInPerformLayout()) {
        layer()->clipper().clearClipRectsIncludingDescendants();
         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));
         frameView->updateAnnotatedRegions();
        frameView->updateWidgetPositions();
        RELEASE_ASSERT(frameView->renderView());
         updateCompositingLayersAfterScroll();
     }
 
    frame->selection().setCaretRectNeedsUpdate();

    FloatQuad quadForFakeMouseMoveEvent = FloatQuad(layer()->renderer()->previousPaintInvalidationRect());

    quadForFakeMouseMoveEvent = paintInvalidationContainer->localToAbsoluteQuad(quadForFakeMouseMoveEvent);
    frame->eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);

    bool requiresPaintInvalidation = true;

    if (!box().isMarquee() && box().view()->compositor()->inCompositingMode()) {
        DisableCompositingQueryAsserts disabler;
        bool onlyScrolledCompositedLayers = scrollsOverflow()
            && !layer()->hasVisibleNonLayerContent()
            && !layer()->hasNonCompositedChild()
            && !layer()->hasBlockSelectionGapBounds()
            && box().style()->backgroundLayers().attachment() != LocalBackgroundAttachment;

        if (usesCompositedScrolling() || onlyScrolledCompositedLayers)
            requiresPaintInvalidation = false;
    }

    if (requiresPaintInvalidation) {
        if (box().frameView()->isInPerformLayout())
            box().setShouldDoFullPaintInvalidation(true);
        else
            box().invalidatePaintUsingContainer(paintInvalidationContainer, layer()->renderer()->previousPaintInvalidationRect(), InvalidationScroll);
    }

    if (box().node())
        box().node()->document().enqueueScrollEventForNode(box().node());

    if (AXObjectCache* cache = box().document().existingAXObjectCache())
        cache->handleScrollPositionChanged(&box());

    InspectorInstrumentation::didScrollLayer(&box());
}
",C,"        frameView->setNeedsUpdateWidgetPositions();
","        frameView->updateWidgetPositions();
        RELEASE_ASSERT(frameView->renderView());
",,"@@ -366,10 +366,7 @@ void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)
         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));
         // Update regions, scrolling may change the clip of a particular region.
         frameView->updateAnnotatedRegions();
-        // FIXME: We shouldn't call updateWidgetPositions() here since it might tear down the render tree,
-        // for now we just crash to avoid allowing an attacker to use after free.
-        frameView->updateWidgetPositions();
-        RELEASE_ASSERT(frameView->renderView());
+        frameView->setNeedsUpdateWidgetPositions();
         updateCompositingLayersAfterScroll();
     }
 ",Chrome,11a4cc4a6d6e665d9a118fada4b7c658d6f70d95,09298a5df529dfb55d846f5f85df4df437fac052,1,"void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)
{
    if (!box().isMarquee()) {
        // Ensure that the dimensions will be computed if they need to be (for overflow:hidden blocks).
        if (m_scrollDimensionsDirty)
            computeScrollDimensions();
    }

    if (scrollOffset() == toIntSize(newScrollOffset))
        return;

    setScrollOffset(toIntSize(newScrollOffset));

    LocalFrame* frame = box().frame();
    ASSERT(frame);

    RefPtr<FrameView> frameView = box().frameView();

    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""ScrollLayer"", ""data"", InspectorScrollLayerEvent::data(&box()));
    // FIXME(361045): remove InspectorInstrumentation calls once DevTools Timeline migrates to tracing.
    InspectorInstrumentation::willScrollLayer(&box());

    const RenderLayerModelObject* paintInvalidationContainer = box().containerForPaintInvalidation();

    // Update the positions of our child layers (if needed as only fixed layers should be impacted by a scroll).
    // We don't update compositing layers, because we need to do a deep update from the compositing ancestor.
    if (!frameView->isInPerformLayout()) {
        // If we're in the middle of layout, we'll just update layers once layout has finished.
        layer()->clipper().clearClipRectsIncludingDescendants();
         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));
         // Update regions, scrolling may change the clip of a particular region.
         frameView->updateAnnotatedRegions();
//flaw_line_below:
        // FIXME: We shouldn't call updateWidgetPositions() here since it might tear down the render tree,
//flaw_line_below:
        // for now we just crash to avoid allowing an attacker to use after free.
//flaw_line_below:
        frameView->updateWidgetPositions();
//flaw_line_below:
        RELEASE_ASSERT(frameView->renderView());
//fix_flaw_line_below:
//        frameView->setNeedsUpdateWidgetPositions();
         updateCompositingLayersAfterScroll();
     }
 
    // The caret rect needs to be invalidated after scrolling
    frame->selection().setCaretRectNeedsUpdate();

    FloatQuad quadForFakeMouseMoveEvent = FloatQuad(layer()->renderer()->previousPaintInvalidationRect());

    quadForFakeMouseMoveEvent = paintInvalidationContainer->localToAbsoluteQuad(quadForFakeMouseMoveEvent);
    frame->eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);

    bool requiresPaintInvalidation = true;

    if (!box().isMarquee() && box().view()->compositor()->inCompositingMode()) {
        // Hits in virtual/gpu/fast/canvas/canvas-scroll-path-into-view.html.
        DisableCompositingQueryAsserts disabler;
        bool onlyScrolledCompositedLayers = scrollsOverflow()
            && !layer()->hasVisibleNonLayerContent()
            && !layer()->hasNonCompositedChild()
            && !layer()->hasBlockSelectionGapBounds()
            && box().style()->backgroundLayers().attachment() != LocalBackgroundAttachment;

        if (usesCompositedScrolling() || onlyScrolledCompositedLayers)
            requiresPaintInvalidation = false;
    }

    // Just schedule a full paint invalidation of our object.
    if (requiresPaintInvalidation) {
        if (box().frameView()->isInPerformLayout())
            box().setShouldDoFullPaintInvalidation(true);
        else
            box().invalidatePaintUsingContainer(paintInvalidationContainer, layer()->renderer()->previousPaintInvalidationRect(), InvalidationScroll);
    }

    // Schedule the scroll DOM event.
    if (box().node())
        box().node()->document().enqueueScrollEventForNode(box().node());

    if (AXObjectCache* cache = box().document().existingAXObjectCache())
        cache->handleScrollPositionChanged(&box());

    InspectorInstrumentation::didScrollLayer(&box());
}
",185340,"void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)
{
    if (!box().isMarquee()) {
        if (m_scrollDimensionsDirty)
            computeScrollDimensions();
    }

    if (scrollOffset() == toIntSize(newScrollOffset))
        return;

    setScrollOffset(toIntSize(newScrollOffset));

    LocalFrame* frame = box().frame();
    ASSERT(frame);

    RefPtr<FrameView> frameView = box().frameView();

    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""ScrollLayer"", ""data"", InspectorScrollLayerEvent::data(&box()));
    InspectorInstrumentation::willScrollLayer(&box());

    const RenderLayerModelObject* paintInvalidationContainer = box().containerForPaintInvalidation();

    if (!frameView->isInPerformLayout()) {
        layer()->clipper().clearClipRectsIncludingDescendants();
         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));
         frameView->updateAnnotatedRegions();
        frameView->updateWidgetPositions();
        RELEASE_ASSERT(frameView->renderView());
         updateCompositingLayersAfterScroll();
     }
 
    frame->selection().setCaretRectNeedsUpdate();

    FloatQuad quadForFakeMouseMoveEvent = FloatQuad(layer()->renderer()->previousPaintInvalidationRect());

    quadForFakeMouseMoveEvent = paintInvalidationContainer->localToAbsoluteQuad(quadForFakeMouseMoveEvent);
    frame->eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);

    bool requiresPaintInvalidation = true;

    if (!box().isMarquee() && box().view()->compositor()->inCompositingMode()) {
        DisableCompositingQueryAsserts disabler;
        bool onlyScrolledCompositedLayers = scrollsOverflow()
            && !layer()->hasVisibleNonLayerContent()
            && !layer()->hasNonCompositedChild()
            && !layer()->hasBlockSelectionGapBounds()
            && box().style()->backgroundLayers().attachment() != LocalBackgroundAttachment;

        if (usesCompositedScrolling() || onlyScrolledCompositedLayers)
            requiresPaintInvalidation = false;
    }

    if (requiresPaintInvalidation) {
        if (box().frameView()->isInPerformLayout())
            box().setShouldDoFullPaintInvalidation(true);
        else
            box().invalidatePaintUsingContainer(paintInvalidationContainer, layer()->renderer()->previousPaintInvalidationRect(), InvalidationScroll);
    }

    if (box().node())
        box().node()->document().enqueueScrollEventForNode(box().node());

    if (AXObjectCache* cache = box().document().existingAXObjectCache())
        cache->handleScrollPositionChanged(&box());

    InspectorInstrumentation::didScrollLayer(&box());
}
","void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)
{
    if (!box().isMarquee()) {
        if (m_scrollDimensionsDirty)
            computeScrollDimensions();
    }

    if (scrollOffset() == toIntSize(newScrollOffset))
        return;

    setScrollOffset(toIntSize(newScrollOffset));

    LocalFrame* frame = box().frame();
    ASSERT(frame);

    RefPtr<FrameView> frameView = box().frameView();

    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""ScrollLayer"", ""data"", InspectorScrollLayerEvent::data(&box()));
    InspectorInstrumentation::willScrollLayer(&box());

    const RenderLayerModelObject* paintInvalidationContainer = box().containerForPaintInvalidation();

    if (!frameView->isInPerformLayout()) {
        layer()->clipper().clearClipRectsIncludingDescendants();
         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));
         frameView->updateAnnotatedRegions();
        frameView->setNeedsUpdateWidgetPositions();
         updateCompositingLayersAfterScroll();
     }
 
    frame->selection().setCaretRectNeedsUpdate();

    FloatQuad quadForFakeMouseMoveEvent = FloatQuad(layer()->renderer()->previousPaintInvalidationRect());

    quadForFakeMouseMoveEvent = paintInvalidationContainer->localToAbsoluteQuad(quadForFakeMouseMoveEvent);
    frame->eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);

    bool requiresPaintInvalidation = true;

    if (!box().isMarquee() && box().view()->compositor()->inCompositingMode()) {
        DisableCompositingQueryAsserts disabler;
        bool onlyScrolledCompositedLayers = scrollsOverflow()
            && !layer()->hasVisibleNonLayerContent()
            && !layer()->hasNonCompositedChild()
            && !layer()->hasBlockSelectionGapBounds()
            && box().style()->backgroundLayers().attachment() != LocalBackgroundAttachment;

        if (usesCompositedScrolling() || onlyScrolledCompositedLayers)
            requiresPaintInvalidation = false;
    }

    if (requiresPaintInvalidation) {
        if (box().frameView()->isInPerformLayout())
            box().setShouldDoFullPaintInvalidation(true);
        else
            box().invalidatePaintUsingContainer(paintInvalidationContainer, layer()->renderer()->previousPaintInvalidationRect(), InvalidationScroll);
    }

    if (box().node())
        box().node()->document().enqueueScrollEventForNode(box().node());

    if (AXObjectCache* cache = box().document().existingAXObjectCache())
        cache->handleScrollPositionChanged(&box());

    InspectorInstrumentation::didScrollLayer(&box());
}
","The vulnerability in the original code lies in the method `setScrollOffset`, where the function `frameView->updateWidgetPositions()` was called without ensuring that the frame view was in a valid state, potentially leading to inconsistent UI updates during scrolling. This could result in visual artifacts or crashes if the frame view was not ready for updates. The fix involved changing the call to `frameView->setNeedsUpdateWidgetPositions()`, which marks the widget positions as needing an update without immediately executing it, thus ensuring that updates occur safely when the frame view is ready, enhancing stability and preventing potential crashes.","The vulnerability in the original code stemmed from directly updating widget positions without verifying the readiness of the frame view, which could lead to inconsistent UI behavior or crashes during scrolling operations. This lack of validation meant that if the frame view was not in a proper state, it could result in unexpected outcomes. The fix addressed this issue by changing the approach to mark the widget positions as needing an update instead of executing the update immediately. This ensures that the update occurs only when the frame view is ready, thereby enhancing stability and preventing potential errors."
70,185959,185959,,Remote,Not required,Partial,CVE-2016-5170,https://www.cvedetails.com/cve/CVE-2016-5170/,CWE-416,Medium,Partial,Partial,,2016-09-25,6.8,"WebKit/Source/bindings/modules/v8/V8BindingForModules.cpp in Blink, as used in Google Chrome before 53.0.2785.113, does not properly consider getter side effects during array key conversion, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted Indexed Database (aka IndexedDB) API calls.",2018-01-04,DoS ,20,https://github.com/chromium/chromium/commit/c3957448cfc6e299165196a33cd954b790875fdb,c3957448cfc6e299165196a33cd954b790875fdb,"Cleanup and remove dead code in SetFocusedElement

This early-out was added in:

https://crrev.com/ce8ea3446283965c7eabab592cbffe223b1cf2bc

Back then, we applied fragment focus in LayoutUpdated() which could
cause this issue. This got cleaned up in:

https://crrev.com/45236fd563e9df53dc45579be1f3d0b4784885a2

so that focus is no longer applied after layout.

+Cleanup: Goto considered harmful

Bug: 795381
Change-Id: Ifeb4d2e03e872fd48cca6720b1d4de36ad1ecbb7
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1524417
Commit-Queue: David Bokan <bokan@chromium.org>
Reviewed-by: Stefan Zager <szager@chromium.org>
Cr-Commit-Position: refs/heads/master@{#641101}",15,third_party/blink/renderer/core/dom/document.cc,"{""sha"": ""b8cbfdeaf170bccecb7699477657284b11dddae9"", ""filename"": ""third_party/blink/renderer/core/dom/document.cc"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 18, ""changes"": 38, ""blob_url"": ""https://github.com/chromium/chromium/blob/c3957448cfc6e299165196a33cd954b790875fdb/third_party/blink/renderer/core/dom/document.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c3957448cfc6e299165196a33cd954b790875fdb/third_party/blink/renderer/core/dom/document.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/dom/document.cc?ref=c3957448cfc6e299165196a33cd954b790875fdb"", ""patch"": ""@@ -4657,8 +4657,10 @@ bool Document::SetFocusedElement(Element* new_focused_element,\n     if (IsRootEditableElement(*new_focused_element) &&\n         !AcceptsEditingFocus(*new_focused_element)) {\n       // delegate blocks focus change\n-      focus_change_blocked = true;\n-      goto SetFocusedElementDone;\n+      UpdateStyleAndLayoutTree();\n+      if (LocalFrame* frame = GetFrame())\n+        frame->Selection().DidChangeFocus();\n+      return false;\n     }\n     // Set focus on the new node\n     focused_element_ = new_focused_element;\n@@ -4673,18 +4675,13 @@ bool Document::SetFocusedElement(Element* new_focused_element,\n \n     // Element::setFocused for frames can dispatch events.\n     if (focused_element_ != new_focused_element) {\n-      focus_change_blocked = true;\n-      goto SetFocusedElementDone;\n+      UpdateStyleAndLayoutTree();\n+      if (LocalFrame* frame = GetFrame())\n+        frame->Selection().DidChangeFocus();\n+      return false;\n     }\n     CancelFocusAppearanceUpdate();\n     EnsurePaintLocationDataValidForNode(focused_element_);\n-    // UpdateStyleAndLayout can call SetFocusedElement (through\n-    // InvokeFragmentAnchor called in Document::LayoutUpdated) and clear\n-    // focused_element_.\n-    if (focused_element_ != new_focused_element) {\n-      focus_change_blocked = true;\n-      goto SetFocusedElementDone;\n-    }\n     focused_element_->UpdateFocusAppearanceWithOptions(\n         params.selection_behavior, params.options);\n \n@@ -4698,8 +4695,10 @@ bool Document::SetFocusedElement(Element* new_focused_element,\n \n       if (focused_element_ != new_focused_element) {\n         // handler shifted focus\n-        focus_change_blocked = true;\n-        goto SetFocusedElementDone;\n+        UpdateStyleAndLayoutTree();\n+        if (LocalFrame* frame = GetFrame())\n+          frame->Selection().DidChangeFocus();\n+        return false;\n       }\n       // DOM level 3 bubbling focus event.\n       focused_element_->DispatchFocusInEvent(event_type_names::kFocusin,\n@@ -4708,8 +4707,10 @@ bool Document::SetFocusedElement(Element* new_focused_element,\n \n       if (focused_element_ != new_focused_element) {\n         // handler shifted focus\n-        focus_change_blocked = true;\n-        goto SetFocusedElementDone;\n+        UpdateStyleAndLayoutTree();\n+        if (LocalFrame* frame = GetFrame())\n+          frame->Selection().DidChangeFocus();\n+        return false;\n       }\n \n       // For DOM level 2 compatibility.\n@@ -4721,8 +4722,10 @@ bool Document::SetFocusedElement(Element* new_focused_element,\n \n       if (focused_element_ != new_focused_element) {\n         // handler shifted focus\n-        focus_change_blocked = true;\n-        goto SetFocusedElementDone;\n+        UpdateStyleAndLayoutTree();\n+        if (LocalFrame* frame = GetFrame())\n+          frame->Selection().DidChangeFocus();\n+        return false;\n       }\n     }\n   }\n@@ -4741,7 +4744,6 @@ bool Document::SetFocusedElement(Element* new_focused_element,\n                                                     focused_element_.Get());\n   }\n \n-SetFocusedElementDone:\n   UpdateStyleAndLayoutTree();\n   if (LocalFrame* frame = GetFrame())\n     frame->Selection().DidChangeFocus();""}","bool Document::SetFocusedElement(Element* new_focused_element,
                                 const FocusParams& params) {
  DCHECK(!lifecycle_.InDetach());

  clear_focused_element_timer_.Stop();

  if (new_focused_element && (new_focused_element->GetDocument() != this))
    return true;

  if (NodeChildRemovalTracker::IsBeingRemoved(new_focused_element))
    return true;

  if (focused_element_ == new_focused_element)
    return true;

  bool focus_change_blocked = false;
  Element* old_focused_element = focused_element_;
  focused_element_ = nullptr;

  UpdateDistributionForFlatTreeTraversal();
  Node* ancestor = (old_focused_element && old_focused_element->isConnected() &&
                    new_focused_element)
                       ? FlatTreeTraversal::CommonAncestor(*old_focused_element,
                                                           *new_focused_element)
                       : nullptr;

  if (old_focused_element) {
    old_focused_element->SetFocused(false, params.type);
    old_focused_element->SetHasFocusWithinUpToAncestor(false, ancestor);

    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {
      old_focused_element->DispatchBlurEvent(new_focused_element, params.type,
                                             params.source_capabilities);
      if (focused_element_) {
        focus_change_blocked = true;
        new_focused_element = nullptr;
      }

      old_focused_element->DispatchFocusOutEvent(event_type_names::kFocusout,
                                                 new_focused_element,
                                                 params.source_capabilities);
      old_focused_element->DispatchFocusOutEvent(event_type_names::kDOMFocusOut,
                                                 new_focused_element,
                                                 params.source_capabilities);

      if (focused_element_) {
        focus_change_blocked = true;
        new_focused_element = nullptr;
      }
    }
  }

  if (new_focused_element)
    UpdateStyleAndLayoutTreeForNode(new_focused_element);
  if (new_focused_element && new_focused_element->IsFocusable()) {
     if (IsRootEditableElement(*new_focused_element) &&
         !AcceptsEditingFocus(*new_focused_element)) {
      UpdateStyleAndLayoutTree();
      if (LocalFrame* frame = GetFrame())
        frame->Selection().DidChangeFocus();
      return false;
     }
     focused_element_ = new_focused_element;
    SetSequentialFocusNavigationStartingPoint(focused_element_.Get());

    if (params.type != kWebFocusTypeNone)
      last_focus_type_ = params.type;

    focused_element_->SetFocused(true, params.type);
    focused_element_->SetHasFocusWithinUpToAncestor(true, ancestor);
 
     if (focused_element_ != new_focused_element) {
      UpdateStyleAndLayoutTree();
      if (LocalFrame* frame = GetFrame())
        frame->Selection().DidChangeFocus();
      return false;
     }
     CancelFocusAppearanceUpdate();
     EnsurePaintLocationDataValidForNode(focused_element_);
     focused_element_->UpdateFocusAppearanceWithOptions(
         params.selection_behavior, params.options);
 
    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {
      focused_element_->DispatchFocusEvent(old_focused_element, params.type,
                                           params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        UpdateStyleAndLayoutTree();
        if (LocalFrame* frame = GetFrame())
          frame->Selection().DidChangeFocus();
        return false;
       }
       focused_element_->DispatchFocusInEvent(event_type_names::kFocusin,
                                             old_focused_element, params.type,
                                             params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        UpdateStyleAndLayoutTree();
        if (LocalFrame* frame = GetFrame())
          frame->Selection().DidChangeFocus();
        return false;
       }
 
      focused_element_->DispatchFocusInEvent(event_type_names::kDOMFocusIn,
                                             old_focused_element, params.type,
                                             params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        UpdateStyleAndLayoutTree();
        if (LocalFrame* frame = GetFrame())
          frame->Selection().DidChangeFocus();
        return false;
       }
     }
   }

  if (!focus_change_blocked && focused_element_) {
    if (AXObjectCache* cache = ExistingAXObjectCache()) {
      cache->HandleFocusedUIElementChanged(old_focused_element,
                                           new_focused_element);
    }
  }

  if (!focus_change_blocked && GetPage()) {
    GetPage()->GetChromeClient().FocusedNodeChanged(old_focused_element,
                                                     focused_element_.Get());
   }
 
   UpdateStyleAndLayoutTree();
   if (LocalFrame* frame = GetFrame())
     frame->Selection().DidChangeFocus();
  return !focus_change_blocked;
}
","bool Document::SetFocusedElement(Element* new_focused_element,
                                 const FocusParams& params) {
  DCHECK(!lifecycle_.InDetach());

  clear_focused_element_timer_.Stop();

  if (new_focused_element && (new_focused_element->GetDocument() != this))
    return true;

  if (NodeChildRemovalTracker::IsBeingRemoved(new_focused_element))
    return true;

  if (focused_element_ == new_focused_element)
    return true;

  bool focus_change_blocked = false;
  Element* old_focused_element = focused_element_;
  focused_element_ = nullptr;

  UpdateDistributionForFlatTreeTraversal();
  Node* ancestor = (old_focused_element && old_focused_element->isConnected() &&
                    new_focused_element)
                       ? FlatTreeTraversal::CommonAncestor(*old_focused_element,
                                                           *new_focused_element)
                       : nullptr;

  if (old_focused_element) {
    old_focused_element->SetFocused(false, params.type);
    old_focused_element->SetHasFocusWithinUpToAncestor(false, ancestor);

    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {
      old_focused_element->DispatchBlurEvent(new_focused_element, params.type,
                                             params.source_capabilities);
      if (focused_element_) {
        focus_change_blocked = true;
        new_focused_element = nullptr;
      }

      old_focused_element->DispatchFocusOutEvent(event_type_names::kFocusout,
                                                 new_focused_element,
                                                 params.source_capabilities);
      old_focused_element->DispatchFocusOutEvent(event_type_names::kDOMFocusOut,
                                                 new_focused_element,
                                                 params.source_capabilities);

      if (focused_element_) {
        focus_change_blocked = true;
        new_focused_element = nullptr;
      }
    }
  }

  if (new_focused_element)
    UpdateStyleAndLayoutTreeForNode(new_focused_element);
  if (new_focused_element && new_focused_element->IsFocusable()) {
     if (IsRootEditableElement(*new_focused_element) &&
         !AcceptsEditingFocus(*new_focused_element)) {
      focus_change_blocked = true;
      goto SetFocusedElementDone;
     }
     focused_element_ = new_focused_element;
    SetSequentialFocusNavigationStartingPoint(focused_element_.Get());

    if (params.type != kWebFocusTypeNone)
      last_focus_type_ = params.type;

    focused_element_->SetFocused(true, params.type);
    focused_element_->SetHasFocusWithinUpToAncestor(true, ancestor);
 
     if (focused_element_ != new_focused_element) {
      focus_change_blocked = true;
      goto SetFocusedElementDone;
     }
     CancelFocusAppearanceUpdate();
     EnsurePaintLocationDataValidForNode(focused_element_);
    if (focused_element_ != new_focused_element) {
      focus_change_blocked = true;
      goto SetFocusedElementDone;
    }
     focused_element_->UpdateFocusAppearanceWithOptions(
         params.selection_behavior, params.options);
 
    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {
      focused_element_->DispatchFocusEvent(old_focused_element, params.type,
                                           params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        focus_change_blocked = true;
        goto SetFocusedElementDone;
       }
       focused_element_->DispatchFocusInEvent(event_type_names::kFocusin,
                                             old_focused_element, params.type,
                                             params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        focus_change_blocked = true;
        goto SetFocusedElementDone;
       }
 
      focused_element_->DispatchFocusInEvent(event_type_names::kDOMFocusIn,
                                             old_focused_element, params.type,
                                             params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        focus_change_blocked = true;
        goto SetFocusedElementDone;
       }
     }
   }

  if (!focus_change_blocked && focused_element_) {
    if (AXObjectCache* cache = ExistingAXObjectCache()) {
      cache->HandleFocusedUIElementChanged(old_focused_element,
                                           new_focused_element);
    }
  }

  if (!focus_change_blocked && GetPage()) {
    GetPage()->GetChromeClient().FocusedNodeChanged(old_focused_element,
                                                     focused_element_.Get());
   }
 
SetFocusedElementDone:
   UpdateStyleAndLayoutTree();
   if (LocalFrame* frame = GetFrame())
     frame->Selection().DidChangeFocus();
  return !focus_change_blocked;
}
",C,"      UpdateStyleAndLayoutTree();
      if (LocalFrame* frame = GetFrame())
        frame->Selection().DidChangeFocus();
      return false;
      UpdateStyleAndLayoutTree();
      if (LocalFrame* frame = GetFrame())
        frame->Selection().DidChangeFocus();
      return false;
        UpdateStyleAndLayoutTree();
        if (LocalFrame* frame = GetFrame())
          frame->Selection().DidChangeFocus();
        return false;
        UpdateStyleAndLayoutTree();
        if (LocalFrame* frame = GetFrame())
          frame->Selection().DidChangeFocus();
        return false;
        UpdateStyleAndLayoutTree();
        if (LocalFrame* frame = GetFrame())
          frame->Selection().DidChangeFocus();
        return false;
","      focus_change_blocked = true;
      goto SetFocusedElementDone;
      focus_change_blocked = true;
      goto SetFocusedElementDone;
    if (focused_element_ != new_focused_element) {
      focus_change_blocked = true;
      goto SetFocusedElementDone;
    }
        focus_change_blocked = true;
        goto SetFocusedElementDone;
        focus_change_blocked = true;
        goto SetFocusedElementDone;
        focus_change_blocked = true;
        goto SetFocusedElementDone;
SetFocusedElementDone:
",,"@@ -4657,8 +4657,10 @@ bool Document::SetFocusedElement(Element* new_focused_element,
     if (IsRootEditableElement(*new_focused_element) &&
         !AcceptsEditingFocus(*new_focused_element)) {
       // delegate blocks focus change
-      focus_change_blocked = true;
-      goto SetFocusedElementDone;
+      UpdateStyleAndLayoutTree();
+      if (LocalFrame* frame = GetFrame())
+        frame->Selection().DidChangeFocus();
+      return false;
     }
     // Set focus on the new node
     focused_element_ = new_focused_element;
@@ -4673,18 +4675,13 @@ bool Document::SetFocusedElement(Element* new_focused_element,
 
     // Element::setFocused for frames can dispatch events.
     if (focused_element_ != new_focused_element) {
-      focus_change_blocked = true;
-      goto SetFocusedElementDone;
+      UpdateStyleAndLayoutTree();
+      if (LocalFrame* frame = GetFrame())
+        frame->Selection().DidChangeFocus();
+      return false;
     }
     CancelFocusAppearanceUpdate();
     EnsurePaintLocationDataValidForNode(focused_element_);
-    // UpdateStyleAndLayout can call SetFocusedElement (through
-    // InvokeFragmentAnchor called in Document::LayoutUpdated) and clear
-    // focused_element_.
-    if (focused_element_ != new_focused_element) {
-      focus_change_blocked = true;
-      goto SetFocusedElementDone;
-    }
     focused_element_->UpdateFocusAppearanceWithOptions(
         params.selection_behavior, params.options);
 
@@ -4698,8 +4695,10 @@ bool Document::SetFocusedElement(Element* new_focused_element,
 
       if (focused_element_ != new_focused_element) {
         // handler shifted focus
-        focus_change_blocked = true;
-        goto SetFocusedElementDone;
+        UpdateStyleAndLayoutTree();
+        if (LocalFrame* frame = GetFrame())
+          frame->Selection().DidChangeFocus();
+        return false;
       }
       // DOM level 3 bubbling focus event.
       focused_element_->DispatchFocusInEvent(event_type_names::kFocusin,
@@ -4708,8 +4707,10 @@ bool Document::SetFocusedElement(Element* new_focused_element,
 
       if (focused_element_ != new_focused_element) {
         // handler shifted focus
-        focus_change_blocked = true;
-        goto SetFocusedElementDone;
+        UpdateStyleAndLayoutTree();
+        if (LocalFrame* frame = GetFrame())
+          frame->Selection().DidChangeFocus();
+        return false;
       }
 
       // For DOM level 2 compatibility.
@@ -4721,8 +4722,10 @@ bool Document::SetFocusedElement(Element* new_focused_element,
 
       if (focused_element_ != new_focused_element) {
         // handler shifted focus
-        focus_change_blocked = true;
-        goto SetFocusedElementDone;
+        UpdateStyleAndLayoutTree();
+        if (LocalFrame* frame = GetFrame())
+          frame->Selection().DidChangeFocus();
+        return false;
       }
     }
   }
@@ -4741,7 +4744,6 @@ bool Document::SetFocusedElement(Element* new_focused_element,
                                                     focused_element_.Get());
   }
 
-SetFocusedElementDone:
   UpdateStyleAndLayoutTree();
   if (LocalFrame* frame = GetFrame())
     frame->Selection().DidChangeFocus();",Chrome,c3957448cfc6e299165196a33cd954b790875fdb,ded259df83e1e4bac3b20f8f28a7e21a7d88e752,1,"bool Document::SetFocusedElement(Element* new_focused_element,
                                 const FocusParams& params) {
  DCHECK(!lifecycle_.InDetach());

  clear_focused_element_timer_.Stop();

  // Make sure newFocusedNode is actually in this document
  if (new_focused_element && (new_focused_element->GetDocument() != this))
    return true;

  if (NodeChildRemovalTracker::IsBeingRemoved(new_focused_element))
    return true;

  if (focused_element_ == new_focused_element)
    return true;

  bool focus_change_blocked = false;
  Element* old_focused_element = focused_element_;
  focused_element_ = nullptr;

  UpdateDistributionForFlatTreeTraversal();
  Node* ancestor = (old_focused_element && old_focused_element->isConnected() &&
                    new_focused_element)
                       ? FlatTreeTraversal::CommonAncestor(*old_focused_element,
                                                           *new_focused_element)
                       : nullptr;

  // Remove focus from the existing focus node (if any)
  if (old_focused_element) {
    old_focused_element->SetFocused(false, params.type);
    old_focused_element->SetHasFocusWithinUpToAncestor(false, ancestor);

    // Dispatch the blur event and let the node do any other blur related
    // activities (important for text fields)
    // If page lost focus, blur event will have already been dispatched
    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {
      old_focused_element->DispatchBlurEvent(new_focused_element, params.type,
                                             params.source_capabilities);
      if (focused_element_) {
        // handler shifted focus
        focus_change_blocked = true;
        new_focused_element = nullptr;
      }

      // 'focusout' is a DOM level 3 name for the bubbling blur event.
      old_focused_element->DispatchFocusOutEvent(event_type_names::kFocusout,
                                                 new_focused_element,
                                                 params.source_capabilities);
      // 'DOMFocusOut' is a DOM level 2 name for compatibility.
      // FIXME: We should remove firing DOMFocusOutEvent event when we are sure
      // no content depends on it, probably when <rdar://problem/8503958> is
      // resolved.
      old_focused_element->DispatchFocusOutEvent(event_type_names::kDOMFocusOut,
                                                 new_focused_element,
                                                 params.source_capabilities);

      if (focused_element_) {
        // handler shifted focus
        focus_change_blocked = true;
        new_focused_element = nullptr;
      }
    }
  }

  if (new_focused_element)
    UpdateStyleAndLayoutTreeForNode(new_focused_element);
  if (new_focused_element && new_focused_element->IsFocusable()) {
     if (IsRootEditableElement(*new_focused_element) &&
         !AcceptsEditingFocus(*new_focused_element)) {
       // delegate blocks focus change
//flaw_line_below:
      focus_change_blocked = true;
//flaw_line_below:
      goto SetFocusedElementDone;
//fix_flaw_line_below:
//      UpdateStyleAndLayoutTree();
//fix_flaw_line_below:
//      if (LocalFrame* frame = GetFrame())
//fix_flaw_line_below:
//        frame->Selection().DidChangeFocus();
//fix_flaw_line_below:
//      return false;
     }
     // Set focus on the new node
     focused_element_ = new_focused_element;
    SetSequentialFocusNavigationStartingPoint(focused_element_.Get());

    // Keep track of last focus from user interaction, ignoring focus from code.
    if (params.type != kWebFocusTypeNone)
      last_focus_type_ = params.type;

    focused_element_->SetFocused(true, params.type);
    focused_element_->SetHasFocusWithinUpToAncestor(true, ancestor);
 
     // Element::setFocused for frames can dispatch events.
     if (focused_element_ != new_focused_element) {
//flaw_line_below:
      focus_change_blocked = true;
//flaw_line_below:
      goto SetFocusedElementDone;
//fix_flaw_line_below:
//      UpdateStyleAndLayoutTree();
//fix_flaw_line_below:
//      if (LocalFrame* frame = GetFrame())
//fix_flaw_line_below:
//        frame->Selection().DidChangeFocus();
//fix_flaw_line_below:
//      return false;
     }
     CancelFocusAppearanceUpdate();
     EnsurePaintLocationDataValidForNode(focused_element_);
//flaw_line_below:
    // UpdateStyleAndLayout can call SetFocusedElement (through
//flaw_line_below:
    // InvokeFragmentAnchor called in Document::LayoutUpdated) and clear
//flaw_line_below:
    // focused_element_.
//flaw_line_below:
    if (focused_element_ != new_focused_element) {
//flaw_line_below:
      focus_change_blocked = true;
//flaw_line_below:
      goto SetFocusedElementDone;
//flaw_line_below:
    }
     focused_element_->UpdateFocusAppearanceWithOptions(
         params.selection_behavior, params.options);
 
    // Dispatch the focus event and let the node do any other focus related
    // activities (important for text fields)
    // If page lost focus, event will be dispatched on page focus, don't
    // duplicate
    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {
      focused_element_->DispatchFocusEvent(old_focused_element, params.type,
                                           params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
         // handler shifted focus
//flaw_line_below:
        focus_change_blocked = true;
//flaw_line_below:
        goto SetFocusedElementDone;
//fix_flaw_line_below:
//        UpdateStyleAndLayoutTree();
//fix_flaw_line_below:
//        if (LocalFrame* frame = GetFrame())
//fix_flaw_line_below:
//          frame->Selection().DidChangeFocus();
//fix_flaw_line_below:
//        return false;
       }
       // DOM level 3 bubbling focus event.
       focused_element_->DispatchFocusInEvent(event_type_names::kFocusin,
                                             old_focused_element, params.type,
                                             params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
         // handler shifted focus
//flaw_line_below:
        focus_change_blocked = true;
//flaw_line_below:
        goto SetFocusedElementDone;
//fix_flaw_line_below:
//        UpdateStyleAndLayoutTree();
//fix_flaw_line_below:
//        if (LocalFrame* frame = GetFrame())
//fix_flaw_line_below:
//          frame->Selection().DidChangeFocus();
//fix_flaw_line_below:
//        return false;
       }
 
       // For DOM level 2 compatibility.
      // FIXME: We should remove firing DOMFocusInEvent event when we are sure
      // no content depends on it, probably when <rdar://problem/8503958> is m.
      focused_element_->DispatchFocusInEvent(event_type_names::kDOMFocusIn,
                                             old_focused_element, params.type,
                                             params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
         // handler shifted focus
//flaw_line_below:
        focus_change_blocked = true;
//flaw_line_below:
        goto SetFocusedElementDone;
//fix_flaw_line_below:
//        UpdateStyleAndLayoutTree();
//fix_flaw_line_below:
//        if (LocalFrame* frame = GetFrame())
//fix_flaw_line_below:
//          frame->Selection().DidChangeFocus();
//fix_flaw_line_below:
//        return false;
       }
     }
   }

  if (!focus_change_blocked && focused_element_) {
    // Create the AXObject cache in a focus change because Chromium relies on
    // it.
    if (AXObjectCache* cache = ExistingAXObjectCache()) {
      cache->HandleFocusedUIElementChanged(old_focused_element,
                                           new_focused_element);
    }
  }

  if (!focus_change_blocked && GetPage()) {
    GetPage()->GetChromeClient().FocusedNodeChanged(old_focused_element,
                                                     focused_element_.Get());
   }
 
//flaw_line_below:
SetFocusedElementDone:
   UpdateStyleAndLayoutTree();
   if (LocalFrame* frame = GetFrame())
     frame->Selection().DidChangeFocus();
  return !focus_change_blocked;
}
",185959,"bool Document::SetFocusedElement(Element* new_focused_element,
                                 const FocusParams& params) {
  DCHECK(!lifecycle_.InDetach());

  clear_focused_element_timer_.Stop();

  if (new_focused_element && (new_focused_element->GetDocument() != this))
    return true;

  if (NodeChildRemovalTracker::IsBeingRemoved(new_focused_element))
    return true;

  if (focused_element_ == new_focused_element)
    return true;

  bool focus_change_blocked = false;
  Element* old_focused_element = focused_element_;
  focused_element_ = nullptr;

  UpdateDistributionForFlatTreeTraversal();
  Node* ancestor = (old_focused_element && old_focused_element->isConnected() &&
                    new_focused_element)
                       ? FlatTreeTraversal::CommonAncestor(*old_focused_element,
                                                           *new_focused_element)
                       : nullptr;

  if (old_focused_element) {
    old_focused_element->SetFocused(false, params.type);
    old_focused_element->SetHasFocusWithinUpToAncestor(false, ancestor);

    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {
      old_focused_element->DispatchBlurEvent(new_focused_element, params.type,
                                             params.source_capabilities);
      if (focused_element_) {
        focus_change_blocked = true;
        new_focused_element = nullptr;
      }

      old_focused_element->DispatchFocusOutEvent(event_type_names::kFocusout,
                                                 new_focused_element,
                                                 params.source_capabilities);
      old_focused_element->DispatchFocusOutEvent(event_type_names::kDOMFocusOut,
                                                 new_focused_element,
                                                 params.source_capabilities);

      if (focused_element_) {
        focus_change_blocked = true;
        new_focused_element = nullptr;
      }
    }
  }

  if (new_focused_element)
    UpdateStyleAndLayoutTreeForNode(new_focused_element);
  if (new_focused_element && new_focused_element->IsFocusable()) {
     if (IsRootEditableElement(*new_focused_element) &&
         !AcceptsEditingFocus(*new_focused_element)) {
      focus_change_blocked = true;
      goto SetFocusedElementDone;
     }
     focused_element_ = new_focused_element;
    SetSequentialFocusNavigationStartingPoint(focused_element_.Get());

    if (params.type != kWebFocusTypeNone)
      last_focus_type_ = params.type;

    focused_element_->SetFocused(true, params.type);
    focused_element_->SetHasFocusWithinUpToAncestor(true, ancestor);
 
     if (focused_element_ != new_focused_element) {
      focus_change_blocked = true;
      goto SetFocusedElementDone;
     }
     CancelFocusAppearanceUpdate();
     EnsurePaintLocationDataValidForNode(focused_element_);
    if (focused_element_ != new_focused_element) {
      focus_change_blocked = true;
      goto SetFocusedElementDone;
    }
     focused_element_->UpdateFocusAppearanceWithOptions(
         params.selection_behavior, params.options);
 
    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {
      focused_element_->DispatchFocusEvent(old_focused_element, params.type,
                                           params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        focus_change_blocked = true;
        goto SetFocusedElementDone;
       }
       focused_element_->DispatchFocusInEvent(event_type_names::kFocusin,
                                             old_focused_element, params.type,
                                             params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        focus_change_blocked = true;
        goto SetFocusedElementDone;
       }
 
      focused_element_->DispatchFocusInEvent(event_type_names::kDOMFocusIn,
                                             old_focused_element, params.type,
                                             params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        focus_change_blocked = true;
        goto SetFocusedElementDone;
       }
     }
   }

  if (!focus_change_blocked && focused_element_) {
    if (AXObjectCache* cache = ExistingAXObjectCache()) {
      cache->HandleFocusedUIElementChanged(old_focused_element,
                                           new_focused_element);
    }
  }

  if (!focus_change_blocked && GetPage()) {
    GetPage()->GetChromeClient().FocusedNodeChanged(old_focused_element,
                                                     focused_element_.Get());
   }
 
SetFocusedElementDone:
   UpdateStyleAndLayoutTree();
   if (LocalFrame* frame = GetFrame())
     frame->Selection().DidChangeFocus();
  return !focus_change_blocked;
}
","bool Document::SetFocusedElement(Element* new_focused_element,
                                 const FocusParams& params) {
  DCHECK(!lifecycle_.InDetach());

  clear_focused_element_timer_.Stop();

  if (new_focused_element && (new_focused_element->GetDocument() != this))
    return true;

  if (NodeChildRemovalTracker::IsBeingRemoved(new_focused_element))
    return true;

  if (focused_element_ == new_focused_element)
    return true;

  bool focus_change_blocked = false;
  Element* old_focused_element = focused_element_;
  focused_element_ = nullptr;

  UpdateDistributionForFlatTreeTraversal();
  Node* ancestor = (old_focused_element && old_focused_element->isConnected() &&
                    new_focused_element)
                       ? FlatTreeTraversal::CommonAncestor(*old_focused_element,
                                                           *new_focused_element)
                       : nullptr;

  if (old_focused_element) {
    old_focused_element->SetFocused(false, params.type);
    old_focused_element->SetHasFocusWithinUpToAncestor(false, ancestor);

    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {
      old_focused_element->DispatchBlurEvent(new_focused_element, params.type,
                                             params.source_capabilities);
      if (focused_element_) {
        focus_change_blocked = true;
        new_focused_element = nullptr;
      }

      old_focused_element->DispatchFocusOutEvent(event_type_names::kFocusout,
                                                 new_focused_element,
                                                 params.source_capabilities);
      old_focused_element->DispatchFocusOutEvent(event_type_names::kDOMFocusOut,
                                                 new_focused_element,
                                                 params.source_capabilities);

      if (focused_element_) {
        focus_change_blocked = true;
        new_focused_element = nullptr;
      }
    }
  }

  if (new_focused_element)
    UpdateStyleAndLayoutTreeForNode(new_focused_element);
  if (new_focused_element && new_focused_element->IsFocusable()) {
     if (IsRootEditableElement(*new_focused_element) &&
         !AcceptsEditingFocus(*new_focused_element)) {
      UpdateStyleAndLayoutTree();
      if (LocalFrame* frame = GetFrame())
        frame->Selection().DidChangeFocus();
      return false;
     }
     focused_element_ = new_focused_element;
    SetSequentialFocusNavigationStartingPoint(focused_element_.Get());

    if (params.type != kWebFocusTypeNone)
      last_focus_type_ = params.type;

    focused_element_->SetFocused(true, params.type);
    focused_element_->SetHasFocusWithinUpToAncestor(true, ancestor);
 
     if (focused_element_ != new_focused_element) {
      UpdateStyleAndLayoutTree();
      if (LocalFrame* frame = GetFrame())
        frame->Selection().DidChangeFocus();
      return false;
     }
     CancelFocusAppearanceUpdate();
     EnsurePaintLocationDataValidForNode(focused_element_);
     focused_element_->UpdateFocusAppearanceWithOptions(
         params.selection_behavior, params.options);
 
    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {
      focused_element_->DispatchFocusEvent(old_focused_element, params.type,
                                           params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        UpdateStyleAndLayoutTree();
        if (LocalFrame* frame = GetFrame())
          frame->Selection().DidChangeFocus();
        return false;
       }
       focused_element_->DispatchFocusInEvent(event_type_names::kFocusin,
                                             old_focused_element, params.type,
                                             params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        UpdateStyleAndLayoutTree();
        if (LocalFrame* frame = GetFrame())
          frame->Selection().DidChangeFocus();
        return false;
       }
 
      focused_element_->DispatchFocusInEvent(event_type_names::kDOMFocusIn,
                                             old_focused_element, params.type,
                                             params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        UpdateStyleAndLayoutTree();
        if (LocalFrame* frame = GetFrame())
          frame->Selection().DidChangeFocus();
        return false;
       }
     }
   }

  if (!focus_change_blocked && focused_element_) {
    if (AXObjectCache* cache = ExistingAXObjectCache()) {
      cache->HandleFocusedUIElementChanged(old_focused_element,
                                           new_focused_element);
    }
  }

  if (!focus_change_blocked && GetPage()) {
    GetPage()->GetChromeClient().FocusedNodeChanged(old_focused_element,
                                                     focused_element_.Get());
   }
 
   UpdateStyleAndLayoutTree();
   if (LocalFrame* frame = GetFrame())
     frame->Selection().DidChangeFocus();
  return !focus_change_blocked;
}
","The vulnerability in the original code lies in the handling of focus changes, particularly when dealing with editable elements. If `new_focused_element` is a root editable element that does not accept editing focus, the code would not properly update the focus state or layout, potentially leading to inconsistent UI behavior. The fix introduces an immediate return with `UpdateStyleAndLayoutTree()` and `frame->Selection().DidChangeFocus()` calls when the focus change is blocked, ensuring that the UI remains consistent and responsive to focus changes, thus preventing potential focus-related issues in the application.","The vulnerability in the original code arises from inadequate handling of focus changes for editable elements, which could lead to inconsistent user interface behavior when focus is transferred. Specifically, if an editable element does not accept focus, the code fails to update the layout or focus state appropriately, potentially causing visual glitches or unresponsive elements. The fix addresses this issue by ensuring that when focus cannot be changed, the layout is updated immediately, and the focus state is correctly managed, thereby maintaining a consistent and responsive user experience in the application."
71,185973,185973,,Remote,Not required,Partial,CVE-2016-5156,https://www.cvedetails.com/cve/CVE-2016-5156/,CWE-416,Medium,Partial,Partial,,2016-09-11,6.8,"extensions/renderer/event_bindings.cc in the event bindings in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux attempts to process filtered events after failure to add an event matcher, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via unknown vectors.",2018-10-30,DoS ,7,https://github.com/chromium/chromium/commit/ba011d9f8322c62633a069a59c2c5525e3ff46cc,ba011d9f8322c62633a069a59c2c5525e3ff46cc,"Ignore filtered event if an event matcher cannot be added.

BUG=625404

Review-Url: https://codereview.chromium.org/2236133002
Cr-Commit-Position: refs/heads/master@{#411472}",1,extensions/renderer/event_bindings.cc,"{""sha"": ""db5fb60f428af90a3ce4ba3edcfee6a77b1a6729"", ""filename"": ""extensions/renderer/event_bindings.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 3, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/ba011d9f8322c62633a069a59c2c5525e3ff46cc/extensions/renderer/event_bindings.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ba011d9f8322c62633a069a59c2c5525e3ff46cc/extensions/renderer/event_bindings.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/renderer/event_bindings.cc?ref=ba011d9f8322c62633a069a59c2c5525e3ff46cc"", ""patch"": ""@@ -272,14 +272,18 @@ void EventBindings::AttachFilteredEvent(\n     filter = base::DictionaryValue::From(std::move(filter_value));\n   }\n \n-  // Hold onto a weak reference to |filter| so that it can be used after passing\n-  // ownership to |event_filter|.\n-  base::DictionaryValue* filter_weak = filter.get();\n   int id = g_event_filter.Get().AddEventMatcher(\n       event_name, ParseEventMatcher(std::move(filter)));\n+  if (id == -1) {\n+    args.GetReturnValue().Set(static_cast<int32_t>(-1));\n+    return;\n+  }\n   attached_matcher_ids_.insert(id);\n \n   // Only send IPCs the first time a filter gets added.\n+  const EventMatcher* matcher = g_event_filter.Get().GetEventMatcher(id);\n+  DCHECK(matcher);\n+  base::DictionaryValue* filter_weak = matcher->value();\n   std::string extension_id = context()->GetExtensionID();\n   if (AddFilter(event_name, extension_id, *filter_weak)) {\n     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());""}","void EventBindings::AttachFilteredEvent(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK_EQ(2, args.Length());
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsObject());

  std::string event_name = *v8::String::Utf8Value(args[0]);
  if (!context()->HasAccessOrThrowError(event_name))
    return;

  std::unique_ptr<base::DictionaryValue> filter;
  {
    std::unique_ptr<content::V8ValueConverter> converter(
        content::V8ValueConverter::create());
    std::unique_ptr<base::Value> filter_value(converter->FromV8Value(
        v8::Local<v8::Object>::Cast(args[1]), context()->v8_context()));
    if (!filter_value || !filter_value->IsType(base::Value::TYPE_DICTIONARY)) {
      args.GetReturnValue().Set(static_cast<int32_t>(-1));
      return;
    }
     filter = base::DictionaryValue::From(std::move(filter_value));
   }
 
   int id = g_event_filter.Get().AddEventMatcher(
       event_name, ParseEventMatcher(std::move(filter)));
  if (id == -1) {
    args.GetReturnValue().Set(static_cast<int32_t>(-1));
    return;
  }
   attached_matcher_ids_.insert(id);
 
  const EventMatcher* matcher = g_event_filter.Get().GetEventMatcher(id);
  DCHECK(matcher);
  base::DictionaryValue* filter_weak = matcher->value();
   std::string extension_id = context()->GetExtensionID();
   if (AddFilter(event_name, extension_id, *filter_weak)) {
     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());
    content::RenderThread::Get()->Send(new ExtensionHostMsg_AddFilteredListener(
        extension_id, event_name, *filter_weak, lazy));
  }

  args.GetReturnValue().Set(static_cast<int32_t>(id));
}
","void EventBindings::AttachFilteredEvent(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK_EQ(2, args.Length());
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsObject());

  std::string event_name = *v8::String::Utf8Value(args[0]);
  if (!context()->HasAccessOrThrowError(event_name))
    return;

  std::unique_ptr<base::DictionaryValue> filter;
  {
    std::unique_ptr<content::V8ValueConverter> converter(
        content::V8ValueConverter::create());
    std::unique_ptr<base::Value> filter_value(converter->FromV8Value(
        v8::Local<v8::Object>::Cast(args[1]), context()->v8_context()));
    if (!filter_value || !filter_value->IsType(base::Value::TYPE_DICTIONARY)) {
      args.GetReturnValue().Set(static_cast<int32_t>(-1));
      return;
    }
     filter = base::DictionaryValue::From(std::move(filter_value));
   }
 
  base::DictionaryValue* filter_weak = filter.get();
   int id = g_event_filter.Get().AddEventMatcher(
       event_name, ParseEventMatcher(std::move(filter)));
   attached_matcher_ids_.insert(id);
 
   std::string extension_id = context()->GetExtensionID();
   if (AddFilter(event_name, extension_id, *filter_weak)) {
     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());
    content::RenderThread::Get()->Send(new ExtensionHostMsg_AddFilteredListener(
        extension_id, event_name, *filter_weak, lazy));
  }

  args.GetReturnValue().Set(static_cast<int32_t>(id));
}
",C,"  if (id == -1) {
    args.GetReturnValue().Set(static_cast<int32_t>(-1));
    return;
  }
  const EventMatcher* matcher = g_event_filter.Get().GetEventMatcher(id);
  DCHECK(matcher);
  base::DictionaryValue* filter_weak = matcher->value();
","  base::DictionaryValue* filter_weak = filter.get();
",,"@@ -272,14 +272,18 @@ void EventBindings::AttachFilteredEvent(
     filter = base::DictionaryValue::From(std::move(filter_value));
   }
 
-  // Hold onto a weak reference to |filter| so that it can be used after passing
-  // ownership to |event_filter|.
-  base::DictionaryValue* filter_weak = filter.get();
   int id = g_event_filter.Get().AddEventMatcher(
       event_name, ParseEventMatcher(std::move(filter)));
+  if (id == -1) {
+    args.GetReturnValue().Set(static_cast<int32_t>(-1));
+    return;
+  }
   attached_matcher_ids_.insert(id);
 
   // Only send IPCs the first time a filter gets added.
+  const EventMatcher* matcher = g_event_filter.Get().GetEventMatcher(id);
+  DCHECK(matcher);
+  base::DictionaryValue* filter_weak = matcher->value();
   std::string extension_id = context()->GetExtensionID();
   if (AddFilter(event_name, extension_id, *filter_weak)) {
     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());",Chrome,ba011d9f8322c62633a069a59c2c5525e3ff46cc,17a812f225abd54e84dbe4f74c9619d4bdab3cbf,1,"void EventBindings::AttachFilteredEvent(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK_EQ(2, args.Length());
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsObject());

  std::string event_name = *v8::String::Utf8Value(args[0]);
  if (!context()->HasAccessOrThrowError(event_name))
    return;

  std::unique_ptr<base::DictionaryValue> filter;
  {
    std::unique_ptr<content::V8ValueConverter> converter(
        content::V8ValueConverter::create());
    std::unique_ptr<base::Value> filter_value(converter->FromV8Value(
        v8::Local<v8::Object>::Cast(args[1]), context()->v8_context()));
    if (!filter_value || !filter_value->IsType(base::Value::TYPE_DICTIONARY)) {
      args.GetReturnValue().Set(static_cast<int32_t>(-1));
      return;
    }
     filter = base::DictionaryValue::From(std::move(filter_value));
   }
 
//flaw_line_below:
  // Hold onto a weak reference to |filter| so that it can be used after passing
//flaw_line_below:
  // ownership to |event_filter|.
//flaw_line_below:
  base::DictionaryValue* filter_weak = filter.get();
   int id = g_event_filter.Get().AddEventMatcher(
       event_name, ParseEventMatcher(std::move(filter)));
//fix_flaw_line_below:
//  if (id == -1) {
//fix_flaw_line_below:
//    args.GetReturnValue().Set(static_cast<int32_t>(-1));
//fix_flaw_line_below:
//    return;
//fix_flaw_line_below:
//  }
   attached_matcher_ids_.insert(id);
 
   // Only send IPCs the first time a filter gets added.
//fix_flaw_line_below:
//  const EventMatcher* matcher = g_event_filter.Get().GetEventMatcher(id);
//fix_flaw_line_below:
//  DCHECK(matcher);
//fix_flaw_line_below:
//  base::DictionaryValue* filter_weak = matcher->value();
   std::string extension_id = context()->GetExtensionID();
   if (AddFilter(event_name, extension_id, *filter_weak)) {
     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());
    content::RenderThread::Get()->Send(new ExtensionHostMsg_AddFilteredListener(
        extension_id, event_name, *filter_weak, lazy));
  }

  args.GetReturnValue().Set(static_cast<int32_t>(id));
}
",185973,"void EventBindings::AttachFilteredEvent(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK_EQ(2, args.Length());
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsObject());

  std::string event_name = *v8::String::Utf8Value(args[0]);
  if (!context()->HasAccessOrThrowError(event_name))
    return;

  std::unique_ptr<base::DictionaryValue> filter;
  {
    std::unique_ptr<content::V8ValueConverter> converter(
        content::V8ValueConverter::create());
    std::unique_ptr<base::Value> filter_value(converter->FromV8Value(
        v8::Local<v8::Object>::Cast(args[1]), context()->v8_context()));
    if (!filter_value || !filter_value->IsType(base::Value::TYPE_DICTIONARY)) {
      args.GetReturnValue().Set(static_cast<int32_t>(-1));
      return;
    }
     filter = base::DictionaryValue::From(std::move(filter_value));
   }
 
  base::DictionaryValue* filter_weak = filter.get();
   int id = g_event_filter.Get().AddEventMatcher(
       event_name, ParseEventMatcher(std::move(filter)));
   attached_matcher_ids_.insert(id);
 
   std::string extension_id = context()->GetExtensionID();
   if (AddFilter(event_name, extension_id, *filter_weak)) {
     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());
    content::RenderThread::Get()->Send(new ExtensionHostMsg_AddFilteredListener(
        extension_id, event_name, *filter_weak, lazy));
  }

  args.GetReturnValue().Set(static_cast<int32_t>(id));
}
","void EventBindings::AttachFilteredEvent(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK_EQ(2, args.Length());
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsObject());

  std::string event_name = *v8::String::Utf8Value(args[0]);
  if (!context()->HasAccessOrThrowError(event_name))
    return;

  std::unique_ptr<base::DictionaryValue> filter;
  {
    std::unique_ptr<content::V8ValueConverter> converter(
        content::V8ValueConverter::create());
    std::unique_ptr<base::Value> filter_value(converter->FromV8Value(
        v8::Local<v8::Object>::Cast(args[1]), context()->v8_context()));
    if (!filter_value || !filter_value->IsType(base::Value::TYPE_DICTIONARY)) {
      args.GetReturnValue().Set(static_cast<int32_t>(-1));
      return;
    }
     filter = base::DictionaryValue::From(std::move(filter_value));
   }
 
   int id = g_event_filter.Get().AddEventMatcher(
       event_name, ParseEventMatcher(std::move(filter)));
  if (id == -1) {
    args.GetReturnValue().Set(static_cast<int32_t>(-1));
    return;
  }
   attached_matcher_ids_.insert(id);
 
  const EventMatcher* matcher = g_event_filter.Get().GetEventMatcher(id);
  DCHECK(matcher);
  base::DictionaryValue* filter_weak = matcher->value();
   std::string extension_id = context()->GetExtensionID();
   if (AddFilter(event_name, extension_id, *filter_weak)) {
     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());
    content::RenderThread::Get()->Send(new ExtensionHostMsg_AddFilteredListener(
        extension_id, event_name, *filter_weak, lazy));
  }

  args.GetReturnValue().Set(static_cast<int32_t>(id));
}
","The vulnerability in the original code lies in the potential for a null pointer dereference when accessing the `filter_weak` variable, which is derived from the `filter` object. If the `AddEventMatcher` function fails and returns an invalid ID, the subsequent call to `g_event_filter.Get().GetEventMatcher(id)` could return a null pointer, leading to undefined behavior when dereferencing it. The fixed code addresses this vulnerability by checking if `id` is -1 after calling `AddEventMatcher`. If it is, the function returns early, preventing any further dereferencing of potentially invalid pointers.","The vulnerability in the original code stems from the lack of validation after adding an event matcher, which could lead to dereferencing a null pointer if the addition fails. Specifically, if the process of adding the matcher does not succeed, the subsequent code attempts to access data based on an invalid identifier, resulting in undefined behavior. The fixed code addresses this issue by introducing a check for the validity of the identifier immediately after the addition attempt. If the identifier indicates failure, the function exits early, thereby preventing any unsafe operations on potentially null or invalid pointers."
72,186562,186562,,Remote,Not required,Partial,CVE-2018-18337,https://www.cvedetails.com/cve/CVE-2018-18337/,CWE-416,Medium,Partial,Partial,,2018-12-11,6.8,Incorrect handling of stylesheets leading to a use after free in Blink in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.,2019-08-17,,3,https://github.com/chromium/chromium/commit/2f8e481c12c9e8de107b73508b6c283569d4df5b,2f8e481c12c9e8de107b73508b6c283569d4df5b,"Avoid crash when setting rel=stylesheet on <link> in shadow root.

Link elements in shadow roots without rel=stylesheet are currently not
added as stylesheet candidates upon insertion. This causes a crash if
rel=stylesheet is set (and then loaded) later.

R=futhark@chromium.org

Bug: 886753
Change-Id: Ia0de2c1edf43407950f973982ee1c262a909d220
Reviewed-on: https://chromium-review.googlesource.com/1242463
Commit-Queue: Anders Ruud <andruud@chromium.org>
Reviewed-by: Rune Lillesveen <futhark@chromium.org>
Cr-Commit-Position: refs/heads/master@{#593907}",1,third_party/blink/renderer/core/html/html_link_element.cc,"{""sha"": ""ffc31d6a0e987abc3687ad4a1664eedc2fd5f191"", ""filename"": ""third_party/WebKit/LayoutTests/fast/dom/shadow/link-without-rel-crash.html"", ""status"": ""added"", ""additions"": 22, ""deletions"": 0, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/2f8e481c12c9e8de107b73508b6c283569d4df5b/third_party/WebKit/LayoutTests/fast/dom/shadow/link-without-rel-crash.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2f8e481c12c9e8de107b73508b6c283569d4df5b/third_party/WebKit/LayoutTests/fast/dom/shadow/link-without-rel-crash.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/dom/shadow/link-without-rel-crash.html?ref=2f8e481c12c9e8de107b73508b6c283569d4df5b"", ""patch"": ""@@ -0,0 +1,22 @@\n+<!DOCTYPE html>\n+<script src=\""../../../resources/testharness.js\""></script>\n+<script src=\""../../../resources/testharnessreport.js\""></script>\n+<script>\n+\n+let t = async_test('Setting rel=stylesheet on link in shadow root does not crash');\n+\n+function run() {\n+  t.step(() => {\n+    let link = document.createElement('link');\n+    link.setAttribute('href', 'empty.css');\n+    let div = document.createElement('div');\n+    let shadowRoot = div.attachShadow({mode: 'open'});\n+    document.body.append(div);\n+    shadowRoot.append(link);\n+    link.setAttribute('rel','stylesheet');\n+  });\n+  t.done();\n+}\n+\n+</script>\n+<body onload=\""run()\""></body>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""a182923316fb315cce47318ffcf1aa06c77f2994"", ""filename"": ""third_party/blink/renderer/core/html/html_link_element.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/2f8e481c12c9e8de107b73508b6c283569d4df5b/third_party/blink/renderer/core/html/html_link_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2f8e481c12c9e8de107b73508b6c283569d4df5b/third_party/blink/renderer/core/html/html_link_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/html_link_element.cc?ref=2f8e481c12c9e8de107b73508b6c283569d4df5b"", ""patch"": ""@@ -218,15 +218,16 @@ Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(\n   if (!insertion_point.isConnected())\n     return kInsertionDone;\n   DCHECK(isConnected());\n+\n+  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);\n+\n   if (!ShouldLoadLink() && IsInShadowTree()) {\n     String message = \""HTML element <link> is ignored in shadow tree.\"";\n     GetDocument().AddConsoleMessage(ConsoleMessage::Create(\n         kJSMessageSource, kWarningMessageLevel, message));\n     return kInsertionDone;\n   }\n \n-  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);\n-\n   Process();\n \n   if (link_)""}","Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(
    ContainerNode& insertion_point) {
  HTMLElement::InsertedInto(insertion_point);
  LogAddElementIfIsolatedWorldAndInDocument(""link"", relAttr, hrefAttr);
   if (!insertion_point.isConnected())
     return kInsertionDone;
   DCHECK(isConnected());

  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);

   if (!ShouldLoadLink() && IsInShadowTree()) {
     String message = ""HTML element <link> is ignored in shadow tree."";
     GetDocument().AddConsoleMessage(ConsoleMessage::Create(
         kJSMessageSource, kWarningMessageLevel, message));
     return kInsertionDone;
   }
 
   Process();
 
   if (link_)
    link_->OwnerInserted();

  return kInsertionDone;
}
","Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(
    ContainerNode& insertion_point) {
  HTMLElement::InsertedInto(insertion_point);
  LogAddElementIfIsolatedWorldAndInDocument(""link"", relAttr, hrefAttr);
   if (!insertion_point.isConnected())
     return kInsertionDone;
   DCHECK(isConnected());
   if (!ShouldLoadLink() && IsInShadowTree()) {
     String message = ""HTML element <link> is ignored in shadow tree."";
     GetDocument().AddConsoleMessage(ConsoleMessage::Create(
         kJSMessageSource, kWarningMessageLevel, message));
     return kInsertionDone;
   }
 
  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);
   Process();
 
   if (link_)
    link_->OwnerInserted();

  return kInsertionDone;
}
",C,"
  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);

","  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);
",,"@@ -218,15 +218,16 @@ Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(
   if (!insertion_point.isConnected())
     return kInsertionDone;
   DCHECK(isConnected());
+
+  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);
+
   if (!ShouldLoadLink() && IsInShadowTree()) {
     String message = ""HTML element <link> is ignored in shadow tree."";
     GetDocument().AddConsoleMessage(ConsoleMessage::Create(
         kJSMessageSource, kWarningMessageLevel, message));
     return kInsertionDone;
   }
 
-  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);
-
   Process();
 
   if (link_)",Chrome,2f8e481c12c9e8de107b73508b6c283569d4df5b,156306624e3e37c10456dbafbc1b301c291a89e0,1,"Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(
    ContainerNode& insertion_point) {
  HTMLElement::InsertedInto(insertion_point);
  LogAddElementIfIsolatedWorldAndInDocument(""link"", relAttr, hrefAttr);
   if (!insertion_point.isConnected())
     return kInsertionDone;
   DCHECK(isConnected());
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);
//fix_flaw_line_below:
//
   if (!ShouldLoadLink() && IsInShadowTree()) {
     String message = ""HTML element <link> is ignored in shadow tree."";
     GetDocument().AddConsoleMessage(ConsoleMessage::Create(
         kJSMessageSource, kWarningMessageLevel, message));
     return kInsertionDone;
   }
 
//flaw_line_below:
  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);
//flaw_line_below:

   Process();
 
   if (link_)
    link_->OwnerInserted();

  return kInsertionDone;
}
",186562,"Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(
    ContainerNode& insertion_point) {
  HTMLElement::InsertedInto(insertion_point);
  LogAddElementIfIsolatedWorldAndInDocument(""link"", relAttr, hrefAttr);
   if (!insertion_point.isConnected())
     return kInsertionDone;
   DCHECK(isConnected());
   if (!ShouldLoadLink() && IsInShadowTree()) {
     String message = ""HTML element <link> is ignored in shadow tree."";
     GetDocument().AddConsoleMessage(ConsoleMessage::Create(
         kJSMessageSource, kWarningMessageLevel, message));
     return kInsertionDone;
   }
 
  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);
   Process();
 
   if (link_)
    link_->OwnerInserted();

  return kInsertionDone;
}
","Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(
    ContainerNode& insertion_point) {
  HTMLElement::InsertedInto(insertion_point);
  LogAddElementIfIsolatedWorldAndInDocument(""link"", relAttr, hrefAttr);
   if (!insertion_point.isConnected())
     return kInsertionDone;
   DCHECK(isConnected());

  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);

   if (!ShouldLoadLink() && IsInShadowTree()) {
     String message = ""HTML element <link> is ignored in shadow tree."";
     GetDocument().AddConsoleMessage(ConsoleMessage::Create(
         kJSMessageSource, kWarningMessageLevel, message));
     return kInsertionDone;
   }
 
   Process();
 
   if (link_)
    link_->OwnerInserted();

  return kInsertionDone;
}
","The vulnerability in the original code lies in the order of operations, where the `GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);` is called before checking if the link should be loaded in a shadow tree. This could lead to the addition of a stylesheet candidate even when it should be ignored, potentially causing unintended behavior. In the fixed code, this line is moved after the conditional check for `ShouldLoadLink()` and `IsInShadowTree()`, ensuring that the stylesheet is only added if it is appropriate to do so, thus preventing the vulnerability and ensuring correct behavior in shadow DOM contexts.","The vulnerability in the original code arises from the improper sequence of operations, which allows for the addition of a stylesheet candidate even when it should be disregarded in certain contexts. This could lead to unintended consequences, such as styles being applied incorrectly or not at all. In the revised code, the sequence is corrected by moving the addition of the stylesheet candidate to occur only after verifying the conditions that determine whether it should be processed. This change ensures that the stylesheet is only added when appropriate, thereby mitigating the risk of incorrect behavior in specific scenarios."
73,186642,186642,,Remote,Not required,Partial,CVE-2018-6031,https://www.cvedetails.com/cve/CVE-2018-6031/,CWE-416,Medium,Partial,Partial,,2018-09-25,6.8,Use after free in PDFium in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file.,2018-11-20,,8,https://github.com/chromium/chromium/commit/01c9a7e71ca435651723e8cbcab0b3ad4c5351e2,01c9a7e71ca435651723e8cbcab0b3ad4c5351e2,"[pdf] Use a temporary list when unloading pages

When traversing the |deferred_page_unloads_| list and handling the
unloads it's possible for new pages to get added to the list which will
invalidate the iterator.

This CL swaps the list with an empty list and does the iteration on the
list copy. New items that are unloaded while handling the defers will be
unloaded at a later point.

Bug: 780450
Change-Id: Ic7ced1c82227109784fb536ce19a4dd51b9119ac
Reviewed-on: https://chromium-review.googlesource.com/758916
Commit-Queue: dsinclair <dsinclair@chromium.org>
Reviewed-by: Lei Zhang <thestig@chromium.org>
Cr-Commit-Position: refs/heads/master@{#515056}",2,pdf/pdfium/pdfium_engine.cc,"{""sha"": ""7c6b7da1c70f4071d071d2f111be90a01b1233b3"", ""filename"": ""pdf/pdfium/pdfium_engine.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 2, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/01c9a7e71ca435651723e8cbcab0b3ad4c5351e2/pdf/pdfium/pdfium_engine.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/01c9a7e71ca435651723e8cbcab0b3ad4c5351e2/pdf/pdfium/pdfium_engine.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/pdf/pdfium/pdfium_engine.cc?ref=01c9a7e71ca435651723e8cbcab0b3ad4c5351e2"", ""patch"": ""@@ -1405,9 +1405,15 @@ bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {\n \n   DCHECK(defer_page_unload_);\n   defer_page_unload_ = false;\n-  for (int page_index : deferred_page_unloads_)\n+\n+  // Store the pages to unload away because the act of unloading pages can cause\n+  // there to be more pages to unload. We leave those extra pages to be unloaded\n+  // on the next go around.\n+  std::vector<int> pages_to_unload;\n+  std::swap(pages_to_unload, deferred_page_unloads_);\n+  for (int page_index : pages_to_unload)\n     pages_[page_index]->Unload();\n-  deferred_page_unloads_.clear();\n+\n   return rv;\n }\n ""}","bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {
  DCHECK(!defer_page_unload_);
  defer_page_unload_ = true;
  bool rv = false;
  switch (event.GetType()) {
    case PP_INPUTEVENT_TYPE_MOUSEDOWN:
      rv = OnMouseDown(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_MOUSEUP:
      rv = OnMouseUp(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_MOUSEMOVE:
      rv = OnMouseMove(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_KEYDOWN:
      rv = OnKeyDown(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_KEYUP:
      rv = OnKeyUp(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_CHAR:
      rv = OnChar(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_TOUCHSTART: {
      KillTouchTimer(next_touch_timer_id_);

      pp::TouchInputEvent touch_event(event);
      if (touch_event.GetTouchCount(PP_TOUCHLIST_TYPE_TARGETTOUCHES) == 1)
        ScheduleTouchTimer(touch_event);
      break;
    }
    case PP_INPUTEVENT_TYPE_TOUCHEND:
      KillTouchTimer(next_touch_timer_id_);
      break;
    case PP_INPUTEVENT_TYPE_TOUCHMOVE:
      KillTouchTimer(next_touch_timer_id_);
    default:
      break;
  }
 
   DCHECK(defer_page_unload_);
   defer_page_unload_ = false;

  // Store the pages to unload away because the act of unloading pages can cause
  // there to be more pages to unload. We leave those extra pages to be unloaded
  // on the next go around.
  std::vector<int> pages_to_unload;
  std::swap(pages_to_unload, deferred_page_unloads_);
  for (int page_index : pages_to_unload)
     pages_[page_index]->Unload();

   return rv;
 }
","bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {
  DCHECK(!defer_page_unload_);
  defer_page_unload_ = true;
  bool rv = false;
  switch (event.GetType()) {
    case PP_INPUTEVENT_TYPE_MOUSEDOWN:
      rv = OnMouseDown(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_MOUSEUP:
      rv = OnMouseUp(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_MOUSEMOVE:
      rv = OnMouseMove(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_KEYDOWN:
      rv = OnKeyDown(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_KEYUP:
      rv = OnKeyUp(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_CHAR:
      rv = OnChar(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_TOUCHSTART: {
      KillTouchTimer(next_touch_timer_id_);

      pp::TouchInputEvent touch_event(event);
      if (touch_event.GetTouchCount(PP_TOUCHLIST_TYPE_TARGETTOUCHES) == 1)
        ScheduleTouchTimer(touch_event);
      break;
    }
    case PP_INPUTEVENT_TYPE_TOUCHEND:
      KillTouchTimer(next_touch_timer_id_);
      break;
    case PP_INPUTEVENT_TYPE_TOUCHMOVE:
      KillTouchTimer(next_touch_timer_id_);
    default:
      break;
  }
 
   DCHECK(defer_page_unload_);
   defer_page_unload_ = false;
  for (int page_index : deferred_page_unloads_)
     pages_[page_index]->Unload();
  deferred_page_unloads_.clear();
   return rv;
 }
",C,"
  // Store the pages to unload away because the act of unloading pages can cause
  // there to be more pages to unload. We leave those extra pages to be unloaded
  // on the next go around.
  std::vector<int> pages_to_unload;
  std::swap(pages_to_unload, deferred_page_unloads_);
  for (int page_index : pages_to_unload)

","  for (int page_index : deferred_page_unloads_)
  deferred_page_unloads_.clear();
",,"@@ -1405,9 +1405,15 @@ bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {
 
   DCHECK(defer_page_unload_);
   defer_page_unload_ = false;
-  for (int page_index : deferred_page_unloads_)
+
+  // Store the pages to unload away because the act of unloading pages can cause
+  // there to be more pages to unload. We leave those extra pages to be unloaded
+  // on the next go around.
+  std::vector<int> pages_to_unload;
+  std::swap(pages_to_unload, deferred_page_unloads_);
+  for (int page_index : pages_to_unload)
     pages_[page_index]->Unload();
-  deferred_page_unloads_.clear();
+
   return rv;
 }
 ",Chrome,01c9a7e71ca435651723e8cbcab0b3ad4c5351e2,345dab421e9ff30af4f11fc0b55ab02bdd7d1011,1,"bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {
  DCHECK(!defer_page_unload_);
  defer_page_unload_ = true;
  bool rv = false;
  switch (event.GetType()) {
    case PP_INPUTEVENT_TYPE_MOUSEDOWN:
      rv = OnMouseDown(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_MOUSEUP:
      rv = OnMouseUp(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_MOUSEMOVE:
      rv = OnMouseMove(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_KEYDOWN:
      rv = OnKeyDown(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_KEYUP:
      rv = OnKeyUp(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_CHAR:
      rv = OnChar(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_TOUCHSTART: {
      KillTouchTimer(next_touch_timer_id_);

      pp::TouchInputEvent touch_event(event);
      if (touch_event.GetTouchCount(PP_TOUCHLIST_TYPE_TARGETTOUCHES) == 1)
        ScheduleTouchTimer(touch_event);
      break;
    }
    case PP_INPUTEVENT_TYPE_TOUCHEND:
      KillTouchTimer(next_touch_timer_id_);
      break;
    case PP_INPUTEVENT_TYPE_TOUCHMOVE:
      // TODO(dsinclair): This should allow a little bit of movement (up to the
      // touch radii) to account for finger jiggle.
      KillTouchTimer(next_touch_timer_id_);
    default:
      break;
  }
 
   DCHECK(defer_page_unload_);
   defer_page_unload_ = false;
//flaw_line_below:
  for (int page_index : deferred_page_unloads_)
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  // Store the pages to unload away because the act of unloading pages can cause
//fix_flaw_line_below:
//  // there to be more pages to unload. We leave those extra pages to be unloaded
//fix_flaw_line_below:
//  // on the next go around.
//fix_flaw_line_below:
//  std::vector<int> pages_to_unload;
//fix_flaw_line_below:
//  std::swap(pages_to_unload, deferred_page_unloads_);
//fix_flaw_line_below:
//  for (int page_index : pages_to_unload)
     pages_[page_index]->Unload();
//flaw_line_below:
  deferred_page_unloads_.clear();
//fix_flaw_line_below:
//
   return rv;
 }
",186642,"bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {
  DCHECK(!defer_page_unload_);
  defer_page_unload_ = true;
  bool rv = false;
  switch (event.GetType()) {
    case PP_INPUTEVENT_TYPE_MOUSEDOWN:
      rv = OnMouseDown(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_MOUSEUP:
      rv = OnMouseUp(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_MOUSEMOVE:
      rv = OnMouseMove(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_KEYDOWN:
      rv = OnKeyDown(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_KEYUP:
      rv = OnKeyUp(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_CHAR:
      rv = OnChar(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_TOUCHSTART: {
      KillTouchTimer(next_touch_timer_id_);

      pp::TouchInputEvent touch_event(event);
      if (touch_event.GetTouchCount(PP_TOUCHLIST_TYPE_TARGETTOUCHES) == 1)
        ScheduleTouchTimer(touch_event);
      break;
    }
    case PP_INPUTEVENT_TYPE_TOUCHEND:
      KillTouchTimer(next_touch_timer_id_);
      break;
    case PP_INPUTEVENT_TYPE_TOUCHMOVE:
      KillTouchTimer(next_touch_timer_id_);
    default:
      break;
  }
 
   DCHECK(defer_page_unload_);
   defer_page_unload_ = false;
  for (int page_index : deferred_page_unloads_)
     pages_[page_index]->Unload();
  deferred_page_unloads_.clear();
   return rv;
 }
","bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {
  DCHECK(!defer_page_unload_);
  defer_page_unload_ = true;
  bool rv = false;
  switch (event.GetType()) {
    case PP_INPUTEVENT_TYPE_MOUSEDOWN:
      rv = OnMouseDown(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_MOUSEUP:
      rv = OnMouseUp(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_MOUSEMOVE:
      rv = OnMouseMove(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_KEYDOWN:
      rv = OnKeyDown(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_KEYUP:
      rv = OnKeyUp(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_CHAR:
      rv = OnChar(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_TOUCHSTART: {
      KillTouchTimer(next_touch_timer_id_);

      pp::TouchInputEvent touch_event(event);
      if (touch_event.GetTouchCount(PP_TOUCHLIST_TYPE_TARGETTOUCHES) == 1)
        ScheduleTouchTimer(touch_event);
      break;
    }
    case PP_INPUTEVENT_TYPE_TOUCHEND:
      KillTouchTimer(next_touch_timer_id_);
      break;
    case PP_INPUTEVENT_TYPE_TOUCHMOVE:
      KillTouchTimer(next_touch_timer_id_);
    default:
      break;
  }
 
   DCHECK(defer_page_unload_);
   defer_page_unload_ = false;

  // Store the pages to unload away because the act of unloading pages can cause
  // there to be more pages to unload. We leave those extra pages to be unloaded
  // on the next go around.
  std::vector<int> pages_to_unload;
  std::swap(pages_to_unload, deferred_page_unloads_);
  for (int page_index : pages_to_unload)
     pages_[page_index]->Unload();

   return rv;
 }
","The vulnerability in the original code lies in the handling of `deferred_page_unloads_`, which could lead to unintended behavior if new pages are added to the unload list during the unloading process. This occurs because the loop iterates over `deferred_page_unloads_`, which is modified while being accessed. The fix addresses this by introducing a temporary vector, `pages_to_unload`, to store the pages that need to be unloaded. This ensures that the unloading process does not interfere with the original list, preventing potential crashes or undefined behavior during event handling.","The vulnerability in the original code arises from modifying a collection while iterating over it, which can lead to unpredictable behavior or crashes. Specifically, as pages are unloaded, new pages may be added to the collection, causing the loop to access invalid or unexpected elements. The fix addresses this issue by creating a separate temporary collection to store the pages that need to be unloaded. This approach ensures that the original collection remains unchanged during the unloading process, thereby preventing any interference or errors that could occur from simultaneous modifications."
74,186672,186672,,Remote,Not required,Partial,CVE-2018-6054,https://www.cvedetails.com/cve/CVE-2018-6054/,CWE-416,Medium,Partial,Partial,,2018-09-25,6.8,Use after free in WebUI in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to potentially exploit heap corruption via a crafted Chrome Extension.,2018-11-20,,7,https://github.com/chromium/chromium/commit/90585e657db48f93bd73bc45d4caa975323da41b,90585e657db48f93bd73bc45d4caa975323da41b,"Validate frame after conversion in chrome.send

BUG=797511
TEST=Manually, see https://crbug.com/797511#c1

Change-Id: Ib1a99db4d7648fb1325eb6d7af4ef111d6dda4cb
Reviewed-on: https://chromium-review.googlesource.com/844076
Commit-Queue: Rob Wu <rob@robwu.nl>
Reviewed-by: Kentaro Hara <haraken@chromium.org>
Cr-Commit-Position: refs/heads/master@{#526197}",0,content/renderer/web_ui_extension.cc,"{""sha"": ""93ff2804839fa9314e4022c704e41c1260756c85"", ""filename"": ""content/renderer/web_ui_extension.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/90585e657db48f93bd73bc45d4caa975323da41b/content/renderer/web_ui_extension.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90585e657db48f93bd73bc45d4caa975323da41b/content/renderer/web_ui_extension.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/web_ui_extension.cc?ref=90585e657db48f93bd73bc45d4caa975323da41b"", ""patch"": ""@@ -120,6 +120,13 @@ void WebUIExtension::Send(gin::Arguments* args) {\n     content = base::ListValue::From(V8ValueConverter::Create()->FromV8Value(\n         obj, frame->MainWorldScriptContext()));\n     DCHECK(content);\n+    // The conversion of |obj| could have triggered arbitrary JavaScript code,\n+    // so check that the frame is still valid to avoid dereferencing a stale\n+    // pointer.\n+    if (frame != blink::WebLocalFrame::FrameForCurrentContext()) {\n+      NOTREACHED();\n+      return;\n+    }\n   }\n \n   // Send the message up to the browser.""}","void WebUIExtension::Send(gin::Arguments* args) {
  blink::WebLocalFrame* frame;
  RenderFrame* render_frame;
  if (!ShouldRespondToRequest(&frame, &render_frame))
    return;

  std::string message;
  if (!args->GetNext(&message)) {
    args->ThrowError();
    return;
  }

  if (base::EndsWith(message, ""RequiringGesture"",
                     base::CompareCase::SENSITIVE) &&
      !blink::WebUserGestureIndicator::IsProcessingUserGesture(frame)) {
    NOTREACHED();
    return;
  }

  std::unique_ptr<base::ListValue> content;
  if (args->PeekNext().IsEmpty() || args->PeekNext()->IsUndefined()) {
    content.reset(new base::ListValue());
  } else {
    v8::Local<v8::Object> obj;
    if (!args->GetNext(&obj)) {
      args->ThrowError();
      return;
    }

     content = base::ListValue::From(V8ValueConverter::Create()->FromV8Value(
         obj, frame->MainWorldScriptContext()));
     DCHECK(content);
    // The conversion of |obj| could have triggered arbitrary JavaScript code,
    // so check that the frame is still valid to avoid dereferencing a stale
    // pointer.
    if (frame != blink::WebLocalFrame::FrameForCurrentContext()) {
      NOTREACHED();
      return;
    }
   }
 
  render_frame->Send(new FrameHostMsg_WebUISend(render_frame->GetRoutingID(),
                                                frame->GetDocument().Url(),
                                                message, *content));
}
","void WebUIExtension::Send(gin::Arguments* args) {
  blink::WebLocalFrame* frame;
  RenderFrame* render_frame;
  if (!ShouldRespondToRequest(&frame, &render_frame))
    return;

  std::string message;
  if (!args->GetNext(&message)) {
    args->ThrowError();
    return;
  }

  if (base::EndsWith(message, ""RequiringGesture"",
                     base::CompareCase::SENSITIVE) &&
      !blink::WebUserGestureIndicator::IsProcessingUserGesture(frame)) {
    NOTREACHED();
    return;
  }

  std::unique_ptr<base::ListValue> content;
  if (args->PeekNext().IsEmpty() || args->PeekNext()->IsUndefined()) {
    content.reset(new base::ListValue());
  } else {
    v8::Local<v8::Object> obj;
    if (!args->GetNext(&obj)) {
      args->ThrowError();
      return;
    }

     content = base::ListValue::From(V8ValueConverter::Create()->FromV8Value(
         obj, frame->MainWorldScriptContext()));
     DCHECK(content);
   }
 
  render_frame->Send(new FrameHostMsg_WebUISend(render_frame->GetRoutingID(),
                                                frame->GetDocument().Url(),
                                                message, *content));
}
",C,"    // The conversion of |obj| could have triggered arbitrary JavaScript code,
    // so check that the frame is still valid to avoid dereferencing a stale
    // pointer.
    if (frame != blink::WebLocalFrame::FrameForCurrentContext()) {
      NOTREACHED();
      return;
    }
",,,"@@ -120,6 +120,13 @@ void WebUIExtension::Send(gin::Arguments* args) {
     content = base::ListValue::From(V8ValueConverter::Create()->FromV8Value(
         obj, frame->MainWorldScriptContext()));
     DCHECK(content);
+    // The conversion of |obj| could have triggered arbitrary JavaScript code,
+    // so check that the frame is still valid to avoid dereferencing a stale
+    // pointer.
+    if (frame != blink::WebLocalFrame::FrameForCurrentContext()) {
+      NOTREACHED();
+      return;
+    }
   }
 
   // Send the message up to the browser.",Chrome,90585e657db48f93bd73bc45d4caa975323da41b,ab8d0ea46daf7673a53524a3708f0ffd1ea9ee2d,1,"void WebUIExtension::Send(gin::Arguments* args) {
  blink::WebLocalFrame* frame;
  RenderFrame* render_frame;
  if (!ShouldRespondToRequest(&frame, &render_frame))
    return;

  std::string message;
  if (!args->GetNext(&message)) {
    args->ThrowError();
    return;
  }

  if (base::EndsWith(message, ""RequiringGesture"",
                     base::CompareCase::SENSITIVE) &&
      !blink::WebUserGestureIndicator::IsProcessingUserGesture(frame)) {
    NOTREACHED();
    return;
  }

  // If they've provided an optional message parameter, convert that into a
  // Value to send to the browser process.
  std::unique_ptr<base::ListValue> content;
  if (args->PeekNext().IsEmpty() || args->PeekNext()->IsUndefined()) {
    content.reset(new base::ListValue());
  } else {
    v8::Local<v8::Object> obj;
    if (!args->GetNext(&obj)) {
      args->ThrowError();
      return;
    }

     content = base::ListValue::From(V8ValueConverter::Create()->FromV8Value(
         obj, frame->MainWorldScriptContext()));
     DCHECK(content);
//fix_flaw_line_below:
//    // The conversion of |obj| could have triggered arbitrary JavaScript code,
//fix_flaw_line_below:
//    // so check that the frame is still valid to avoid dereferencing a stale
//fix_flaw_line_below:
//    // pointer.
//fix_flaw_line_below:
//    if (frame != blink::WebLocalFrame::FrameForCurrentContext()) {
//fix_flaw_line_below:
//      NOTREACHED();
//fix_flaw_line_below:
//      return;
//fix_flaw_line_below:
//    }
   }
 
   // Send the message up to the browser.
  render_frame->Send(new FrameHostMsg_WebUISend(render_frame->GetRoutingID(),
                                                frame->GetDocument().Url(),
                                                message, *content));
}
",186672,"void WebUIExtension::Send(gin::Arguments* args) {
  blink::WebLocalFrame* frame;
  RenderFrame* render_frame;
  if (!ShouldRespondToRequest(&frame, &render_frame))
    return;

  std::string message;
  if (!args->GetNext(&message)) {
    args->ThrowError();
    return;
  }

  if (base::EndsWith(message, ""RequiringGesture"",
                     base::CompareCase::SENSITIVE) &&
      !blink::WebUserGestureIndicator::IsProcessingUserGesture(frame)) {
    NOTREACHED();
    return;
  }

  std::unique_ptr<base::ListValue> content;
  if (args->PeekNext().IsEmpty() || args->PeekNext()->IsUndefined()) {
    content.reset(new base::ListValue());
  } else {
    v8::Local<v8::Object> obj;
    if (!args->GetNext(&obj)) {
      args->ThrowError();
      return;
    }

     content = base::ListValue::From(V8ValueConverter::Create()->FromV8Value(
         obj, frame->MainWorldScriptContext()));
     DCHECK(content);
   }
 
  render_frame->Send(new FrameHostMsg_WebUISend(render_frame->GetRoutingID(),
                                                frame->GetDocument().Url(),
                                                message, *content));
}
","void WebUIExtension::Send(gin::Arguments* args) {
  blink::WebLocalFrame* frame;
  RenderFrame* render_frame;
  if (!ShouldRespondToRequest(&frame, &render_frame))
    return;

  std::string message;
  if (!args->GetNext(&message)) {
    args->ThrowError();
    return;
  }

  if (base::EndsWith(message, ""RequiringGesture"",
                     base::CompareCase::SENSITIVE) &&
      !blink::WebUserGestureIndicator::IsProcessingUserGesture(frame)) {
    NOTREACHED();
    return;
  }

  std::unique_ptr<base::ListValue> content;
  if (args->PeekNext().IsEmpty() || args->PeekNext()->IsUndefined()) {
    content.reset(new base::ListValue());
  } else {
    v8::Local<v8::Object> obj;
    if (!args->GetNext(&obj)) {
      args->ThrowError();
      return;
    }

     content = base::ListValue::From(V8ValueConverter::Create()->FromV8Value(
         obj, frame->MainWorldScriptContext()));
     DCHECK(content);
    // The conversion of |obj| could have triggered arbitrary JavaScript code,
    // so check that the frame is still valid to avoid dereferencing a stale
    // pointer.
    if (frame != blink::WebLocalFrame::FrameForCurrentContext()) {
      NOTREACHED();
      return;
    }
   }
 
  render_frame->Send(new FrameHostMsg_WebUISend(render_frame->GetRoutingID(),
                                                frame->GetDocument().Url(),
                                                message, *content));
}
","The vulnerability in the original code arises from the potential dereferencing of a stale pointer to `frame` after the conversion of `obj` using `V8ValueConverter::Create()->FromV8Value()`. This conversion could execute arbitrary JavaScript, potentially altering the context and invalidating the `frame` pointer. In the fixed code, a check is added to ensure that `frame` is still valid by comparing it to `blink::WebLocalFrame::FrameForCurrentContext()`. This additional validation prevents the use of an invalid pointer, thereby mitigating the risk of dereferencing a stale pointer and enhancing the overall security of the function.","The vulnerability in the original code stems from the risk of dereferencing a potentially invalid pointer after executing a conversion that could run arbitrary code. This execution may alter the execution context, leading to a situation where the pointer no longer points to a valid object. In the revised code, a safeguard is introduced to verify the validity of the pointer before it is dereferenced. This additional check ensures that the pointer still references a valid object, effectively preventing potential crashes or security breaches that could arise from using an invalid pointer."
75,186677,186677,,Remote,Not required,Partial,CVE-2018-6086,https://www.cvedetails.com/cve/CVE-2018-6086/,CWE-416,Medium,Partial,Partial,,2018-12-04,6.8,A double-eviction in the Incognito mode cache that lead to a user-after-free in Networking Disk Cache in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to execute arbitrary code via a crafted HTML page.,2019-01-09,Exec Code ,7,https://github.com/chromium/chromium/commit/c9d673b54832afde658f214d7da7d0453fa89774,c9d673b54832afde658f214d7da7d0453fa89774,"[MemCache] Fix bug while iterating LRU list in eviction

It was possible to reanalyze a previously doomed entry.

Bug: 827492
Change-Id: I5d34d2ae87c96e0d2099e926e6eb2c1b30b01d63
Reviewed-on: https://chromium-review.googlesource.com/987919
Commit-Queue: Josh Karlin <jkarlin@chromium.org>
Reviewed-by: Maks Orlovich <morlovich@chromium.org>
Cr-Commit-Position: refs/heads/master@{#547236}",1,net/disk_cache/memory/mem_backend_impl.cc,"{""sha"": ""8b46ef251bde36f768ec04d9ff36b3aac30c21ea"", ""filename"": ""net/disk_cache/backend_unittest.cc"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 0, ""changes"": 39, ""blob_url"": ""https://github.com/chromium/chromium/blob/c9d673b54832afde658f214d7da7d0453fa89774/net/disk_cache/backend_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c9d673b54832afde658f214d7da7d0453fa89774/net/disk_cache/backend_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/disk_cache/backend_unittest.cc?ref=c9d673b54832afde658f214d7da7d0453fa89774"", ""patch"": ""@@ -1930,6 +1930,45 @@ TEST_F(DiskCacheBackendTest, DoomAllSparse) {\n   EXPECT_EQ(0, cache_->GetEntryCount());\n }\n \n+// This test is for https://crbug.com/827492.\n+TEST_F(DiskCacheBackendTest, InMemorySparseEvict) {\n+  const int kMaxSize = 512;\n+\n+  SetMaxSize(kMaxSize);\n+  SetMemoryOnlyMode();\n+  InitCache();\n+\n+  scoped_refptr<net::IOBuffer> buffer(new net::IOBuffer(64));\n+  CacheTestFillBuffer(buffer->data(), 64, false /* no_nulls */);\n+\n+  std::vector<disk_cache::ScopedEntryPtr> entries;\n+\n+  disk_cache::Entry* entry = nullptr;\n+  // Create a bunch of entries\n+  for (size_t i = 0; i < 14; i++) {\n+    std::string name = \""http://www.\"" + std::to_string(i) + \"".com/\"";\n+    ASSERT_THAT(CreateEntry(name, &entry), IsOk());\n+    entries.push_back(disk_cache::ScopedEntryPtr(entry));\n+  }\n+\n+  // Create several sparse entries and fill with enough data to\n+  // pass eviction threshold\n+  ASSERT_EQ(64, WriteSparseData(entries[0].get(), 0, buffer.get(), 64));\n+  ASSERT_EQ(net::ERR_FAILED,\n+            WriteSparseData(entries[0].get(), 10000, buffer.get(), 4));\n+  ASSERT_EQ(63, WriteSparseData(entries[1].get(), 0, buffer.get(), 63));\n+  ASSERT_EQ(64, WriteSparseData(entries[2].get(), 0, buffer.get(), 64));\n+  ASSERT_EQ(64, WriteSparseData(entries[3].get(), 0, buffer.get(), 64));\n+\n+  // Close all the entries, leaving a populated LRU list\n+  // with all entries having refcount 0 (doom implies deletion)\n+  entries.clear();\n+\n+  // Create a new entry, triggering buggy eviction\n+  ASSERT_THAT(CreateEntry(\""http://www.14.com/\"", &entry), IsOk());\n+  entry->Close();\n+}\n+\n void DiskCacheBackendTest::BackendDoomBetween() {\n   InitCache();\n ""}<_**next**_>{""sha"": ""9f09f9084f496f498fb356f27b4d67210f1b1516"", ""filename"": ""net/disk_cache/memory/mem_backend_impl.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c9d673b54832afde658f214d7da7d0453fa89774/net/disk_cache/memory/mem_backend_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c9d673b54832afde658f214d7da7d0453fa89774/net/disk_cache/memory/mem_backend_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/disk_cache/memory/mem_backend_impl.cc?ref=c9d673b54832afde658f214d7da7d0453fa89774"", ""patch"": ""@@ -332,7 +332,13 @@ void MemBackendImpl::EvictIfNeeded() {\n   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();\n   while (current_size_ > target_size && entry != lru_list_.end()) {\n     MemEntryImpl* to_doom = entry->value();\n-    entry = entry->next();\n+\n+    do {\n+      entry = entry->next();\n+      // It's possible that entry now points to a child of to_doom, and the\n+      // parent is about to be deleted. Skip past any child entries.\n+    } while (entry != lru_list_.end() && entry->value()->parent() == to_doom);\n+\n     if (!to_doom->InUse())\n       to_doom->Doom();\n   }""}","void MemBackendImpl::EvictIfNeeded() {
  if (current_size_ <= max_size_)
    return;

  int target_size = std::max(0, max_size_ - kDefaultEvictionSize);

   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();
   while (current_size_ > target_size && entry != lru_list_.end()) {
     MemEntryImpl* to_doom = entry->value();

    do {
      entry = entry->next();
      // It's possible that entry now points to a child of to_doom, and the
      // parent is about to be deleted. Skip past any child entries.
    } while (entry != lru_list_.end() && entry->value()->parent() == to_doom);

     if (!to_doom->InUse())
       to_doom->Doom();
   }
}
","void MemBackendImpl::EvictIfNeeded() {
  if (current_size_ <= max_size_)
    return;

  int target_size = std::max(0, max_size_ - kDefaultEvictionSize);

   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();
   while (current_size_ > target_size && entry != lru_list_.end()) {
     MemEntryImpl* to_doom = entry->value();
    entry = entry->next();
     if (!to_doom->InUse())
       to_doom->Doom();
   }
}
",C,"
    do {
      entry = entry->next();
      // It's possible that entry now points to a child of to_doom, and the
      // parent is about to be deleted. Skip past any child entries.
    } while (entry != lru_list_.end() && entry->value()->parent() == to_doom);

","    entry = entry->next();
",,"@@ -332,7 +332,13 @@ void MemBackendImpl::EvictIfNeeded() {
   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();
   while (current_size_ > target_size && entry != lru_list_.end()) {
     MemEntryImpl* to_doom = entry->value();
-    entry = entry->next();
+
+    do {
+      entry = entry->next();
+      // It's possible that entry now points to a child of to_doom, and the
+      // parent is about to be deleted. Skip past any child entries.
+    } while (entry != lru_list_.end() && entry->value()->parent() == to_doom);
+
     if (!to_doom->InUse())
       to_doom->Doom();
   }",Chrome,c9d673b54832afde658f214d7da7d0453fa89774,db579a7be98ed19502005f8ff27bce942cf393d4,1,"void MemBackendImpl::EvictIfNeeded() {
  if (current_size_ <= max_size_)
    return;

  int target_size = std::max(0, max_size_ - kDefaultEvictionSize);

   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();
   while (current_size_ > target_size && entry != lru_list_.end()) {
     MemEntryImpl* to_doom = entry->value();
//flaw_line_below:
    entry = entry->next();
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    do {
//fix_flaw_line_below:
//      entry = entry->next();
//fix_flaw_line_below:
//      // It's possible that entry now points to a child of to_doom, and the
//fix_flaw_line_below:
//      // parent is about to be deleted. Skip past any child entries.
//fix_flaw_line_below:
//    } while (entry != lru_list_.end() && entry->value()->parent() == to_doom);
//fix_flaw_line_below:
//
     if (!to_doom->InUse())
       to_doom->Doom();
   }
}
",186677,"void MemBackendImpl::EvictIfNeeded() {
  if (current_size_ <= max_size_)
    return;

  int target_size = std::max(0, max_size_ - kDefaultEvictionSize);

   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();
   while (current_size_ > target_size && entry != lru_list_.end()) {
     MemEntryImpl* to_doom = entry->value();
    entry = entry->next();
     if (!to_doom->InUse())
       to_doom->Doom();
   }
}
","void MemBackendImpl::EvictIfNeeded() {
  if (current_size_ <= max_size_)
    return;

  int target_size = std::max(0, max_size_ - kDefaultEvictionSize);

   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();
   while (current_size_ > target_size && entry != lru_list_.end()) {
     MemEntryImpl* to_doom = entry->value();

    do {
      entry = entry->next();
      // It's possible that entry now points to a child of to_doom, and the
      // parent is about to be deleted. Skip past any child entries.
    } while (entry != lru_list_.end() && entry->value()->parent() == to_doom);

     if (!to_doom->InUse())
       to_doom->Doom();
   }
}
","The vulnerability in the original code lies in the potential for dereferencing a pointer to a deleted object. When an entry is evicted using `to_doom->Doom()`, the `entry` pointer may still reference a child of `to_doom`, leading to undefined behavior if that child is accessed afterward. The fixed code addresses this issue by introducing a `do-while` loop that checks if the `entry` points to a child of `to_doom` after it has been evicted. This ensures that the code skips over any child entries, preventing access to invalid memory and enhancing stability.","The vulnerability in the original code arises from the risk of accessing memory that has been freed, which can lead to undefined behavior. When an object is marked for deletion, the pointer may still reference it, potentially causing the program to operate on invalid data. The fixed code mitigates this issue by implementing a mechanism to check and skip over any related objects that may still be referenced after the deletion occurs. This ensures that the program does not attempt to access or manipulate memory that has already been released, thereby enhancing overall stability and safety."
76,186772,186772,,Remote,Not required,Partial,CVE-2018-6060,https://www.cvedetails.com/cve/CVE-2018-6060/,CWE-416,Medium,Partial,Partial,,2018-11-14,6.8,Use after free in WebAudio in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.,2018-12-21,,1,https://github.com/chromium/chromium/commit/fd6a5115103b3e6a52ce15858c5ad4956df29300,fd6a5115103b3e6a52ce15858c5ad4956df29300,"Revert ""Keep AudioHandlers alive until they can be safely deleted.""

This reverts commit 071df33edf2c8b4375fa432a83953359f93ea9e4.

Reason for revert:
This CL seems to cause an AudioNode leak on the Linux leak bot.
The log is:
https://ci.chromium.org/buildbot/chromium.webkit/WebKit%20Linux%20Trusty%20Leak/14252
* webaudio/AudioNode/audionode-connect-method-chaining.html
* webaudio/Panner/pannernode-basic.html
* webaudio/dom-exceptions.html

Original change's description:
> Keep AudioHandlers alive until they can be safely deleted.
> 
> When an AudioNode is disposed, the handler is also disposed.  But add
> the handler to the orphan list so that the handler stays alive until
> the context can safely delete it.  If we don't do this, the handler
> may get deleted while the audio thread is processing the handler (due
> to, say, channel count changes and such).
> 
> For an realtime context, always save the handler just in case the
> audio thread is running after the context is marked as closed (because
> the audio thread doesn't instantly stop when requested).
> 
> For an offline context, only need to do this when the context is
> running because the context is guaranteed to be stopped if we're not
> in the running state.  Hence, there's no possibility of deleting the
> handler while the graph is running.
> 
> This is a revert of
> https://chromium-review.googlesource.com/c/chromium/src/+/860779, with
> a fix for the leak.
> 
> Bug: 780919
> Change-Id: Ifb6b5fcf3fbc373f5779256688731245771da33c
> Reviewed-on: https://chromium-review.googlesource.com/862723
> Reviewed-by: Hongchan Choi <hongchan@chromium.org>
> Commit-Queue: Raymond Toy <rtoy@chromium.org>
> Cr-Commit-Position: refs/heads/master@{#528829}

TBR=rtoy@chromium.org,hongchan@chromium.org

Change-Id: Ibf406bf6ed34ea1f03e86a64a1e5ba6de0970c6f
No-Presubmit: true
No-Tree-Checks: true
No-Try: true
Bug: 780919
Reviewed-on: https://chromium-review.googlesource.com/863402
Reviewed-by: Taiju Tsuiki <tzik@chromium.org>
Commit-Queue: Taiju Tsuiki <tzik@chromium.org>
Cr-Commit-Position: refs/heads/master@{#528888}",6,third_party/WebKit/Source/modules/webaudio/AudioNode.cpp,"{""sha"": ""a5caec8a5f19a463bdfb99754eaf193a757ea4f0"", ""filename"": ""third_party/WebKit/Source/modules/webaudio/AudioNode.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 16, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/fd6a5115103b3e6a52ce15858c5ad4956df29300/third_party/WebKit/Source/modules/webaudio/AudioNode.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fd6a5115103b3e6a52ce15858c5ad4956df29300/third_party/WebKit/Source/modules/webaudio/AudioNode.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/webaudio/AudioNode.cpp?ref=fd6a5115103b3e6a52ce15858c5ad4956df29300"", ""patch"": ""@@ -542,24 +542,9 @@ void AudioNode::Dispose() {\n #endif\n   BaseAudioContext::GraphAutoLocker locker(context());\n   Handler().Dispose();\n-\n-  if (context()->HasRealtimeConstraint()) {\n-    // Always add the handler to the orphan list because the audio\n-    // thread could still be running (for a short time) even when the\n-    // context is closed.  These will get cleaned up in the post\n-    // render task if audio thread is running or when the context is\n-    // colleced (in the worst case).\n+  if (context()->ContextState() == BaseAudioContext::kRunning) {\n     context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(\n         std::move(handler_));\n-  } else {\n-    // For an offline context, only need to save the handler when the\n-    // context is running.  The change in the context state is\n-    // synchronous with the main thread (even though the offline\n-    // thread is not synchronized to the main thread).\n-    if (context()->ContextState() == BaseAudioContext::kRunning) {\n-      context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(\n-          std::move(handler_));\n-    }\n   }\n }\n ""}","void AudioNode::Dispose() {
  DCHECK(IsMainThread());
#if DEBUG_AUDIONODE_REFERENCES
  fprintf(stderr, ""[%16p]: %16p: %2d: AudioNode::dispose %16p\n"", context(),
          this, Handler().GetNodeType(), handler_.get());
 #endif
   BaseAudioContext::GraphAutoLocker locker(context());
   Handler().Dispose();
  if (context()->ContextState() == BaseAudioContext::kRunning) {
     context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
         std::move(handler_));
   }
 }
","void AudioNode::Dispose() {
  DCHECK(IsMainThread());
#if DEBUG_AUDIONODE_REFERENCES
  fprintf(stderr, ""[%16p]: %16p: %2d: AudioNode::dispose %16p\n"", context(),
          this, Handler().GetNodeType(), handler_.get());
 #endif
   BaseAudioContext::GraphAutoLocker locker(context());
   Handler().Dispose();
  if (context()->HasRealtimeConstraint()) {
     context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
         std::move(handler_));
  } else {
    if (context()->ContextState() == BaseAudioContext::kRunning) {
      context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
          std::move(handler_));
    }
   }
 }
",C,"  if (context()->ContextState() == BaseAudioContext::kRunning) {
","  if (context()->HasRealtimeConstraint()) {
  } else {
    if (context()->ContextState() == BaseAudioContext::kRunning) {
      context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
          std::move(handler_));
    }
",,"@@ -542,24 +542,9 @@ void AudioNode::Dispose() {
 #endif
   BaseAudioContext::GraphAutoLocker locker(context());
   Handler().Dispose();
-
-  if (context()->HasRealtimeConstraint()) {
-    // Always add the handler to the orphan list because the audio
-    // thread could still be running (for a short time) even when the
-    // context is closed.  These will get cleaned up in the post
-    // render task if audio thread is running or when the context is
-    // colleced (in the worst case).
+  if (context()->ContextState() == BaseAudioContext::kRunning) {
     context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
         std::move(handler_));
-  } else {
-    // For an offline context, only need to save the handler when the
-    // context is running.  The change in the context state is
-    // synchronous with the main thread (even though the offline
-    // thread is not synchronized to the main thread).
-    if (context()->ContextState() == BaseAudioContext::kRunning) {
-      context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
-          std::move(handler_));
-    }
   }
 }
 ",Chrome,fd6a5115103b3e6a52ce15858c5ad4956df29300,85d6fbb387514e6cc81fabb6ef2e61f7d879566e,1,"void AudioNode::Dispose() {
  DCHECK(IsMainThread());
#if DEBUG_AUDIONODE_REFERENCES
  fprintf(stderr, ""[%16p]: %16p: %2d: AudioNode::dispose %16p\n"", context(),
          this, Handler().GetNodeType(), handler_.get());
 #endif
   BaseAudioContext::GraphAutoLocker locker(context());
   Handler().Dispose();
//flaw_line_below:

//flaw_line_below:
  if (context()->HasRealtimeConstraint()) {
//flaw_line_below:
    // Always add the handler to the orphan list because the audio
//flaw_line_below:
    // thread could still be running (for a short time) even when the
//flaw_line_below:
    // context is closed.  These will get cleaned up in the post
//flaw_line_below:
    // render task if audio thread is running or when the context is
//flaw_line_below:
    // colleced (in the worst case).
//fix_flaw_line_below:
//  if (context()->ContextState() == BaseAudioContext::kRunning) {
     context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
         std::move(handler_));
//flaw_line_below:
  } else {
//flaw_line_below:
    // For an offline context, only need to save the handler when the
//flaw_line_below:
    // context is running.  The change in the context state is
//flaw_line_below:
    // synchronous with the main thread (even though the offline
//flaw_line_below:
    // thread is not synchronized to the main thread).
//flaw_line_below:
    if (context()->ContextState() == BaseAudioContext::kRunning) {
//flaw_line_below:
      context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
//flaw_line_below:
          std::move(handler_));
//flaw_line_below:
    }
   }
 }
",186772,"void AudioNode::Dispose() {
  DCHECK(IsMainThread());
#if DEBUG_AUDIONODE_REFERENCES
  fprintf(stderr, ""[%16p]: %16p: %2d: AudioNode::dispose %16p\n"", context(),
          this, Handler().GetNodeType(), handler_.get());
 #endif
   BaseAudioContext::GraphAutoLocker locker(context());
   Handler().Dispose();
  if (context()->HasRealtimeConstraint()) {
     context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
         std::move(handler_));
  } else {
    if (context()->ContextState() == BaseAudioContext::kRunning) {
      context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
          std::move(handler_));
    }
   }
 }
","void AudioNode::Dispose() {
  DCHECK(IsMainThread());
#if DEBUG_AUDIONODE_REFERENCES
  fprintf(stderr, ""[%16p]: %16p: %2d: AudioNode::dispose %16p\n"", context(),
          this, Handler().GetNodeType(), handler_.get());
 #endif
   BaseAudioContext::GraphAutoLocker locker(context());
   Handler().Dispose();
  if (context()->ContextState() == BaseAudioContext::kRunning) {
     context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
         std::move(handler_));
   }
 }
","The vulnerability in the original `AudioNode::Dispose` code arises from the potential for a use-after-free error. Specifically, the code attempts to add `handler_` to the deferred task handler even when the audio context has a real-time constraint, which could lead to accessing a dangling pointer if `handler_` is disposed of prematurely. In the fixed code, the check for `context()->HasRealtimeConstraint()` was removed, ensuring that `handler_` is only added to the deferred task handler when the context is in the `kRunning` state. This change mitigates the risk of accessing invalid memory, enhancing stability and safety.","The vulnerability in the original code stems from the potential for a use-after-free condition, where a resource could be accessed after it has been released. This occurs because the code allows for the addition of a handler to a deferred task handler even when certain conditions indicate that the resource may no longer be valid. In the revised code, the logic was adjusted to ensure that the resource is only added to the deferred task handler under specific circumstances, thereby preventing access to a resource that could have been disposed of, thus enhancing the overall safety and stability of the application."
77,186901,186901,,Remote,Not required,Partial,CVE-2017-15411,https://www.cvedetails.com/cve/CVE-2017-15411/,CWE-416,Medium,Partial,Partial,,2018-08-28,6.8,Use after free in PDFium in Google Chrome prior to 63.0.3239.84 allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file.,2018-10-30,,1,https://github.com/chromium/chromium/commit/9d81094d7b0bfc8be6bba2f5084e790677e527c8,9d81094d7b0bfc8be6bba2f5084e790677e527c8,"[Reland #1] Add Android OOP HP end-to-end tests.

The original CL added a javatest and its dependencies to the apk_under_test.
This causes the dependencies to be stripped from the instrumentation_apk, which
causes issue. This CL updates the build configuration so that the javatest and
its dependencies are only added to the instrumentation_apk.

This is a reland of e0b4355f0651adb1ebc2c513dc4410471af712f5
Original change's description:
> Add Android OOP HP end-to-end tests.
>
> This CL has three components:
>   1) The bulk of the logic in OOP HP was refactored into ProfilingTestDriver.
>   2) Adds a java instrumentation test, along with a JNI shim that forwards into
>   ProfilingTestDriver.
>   3) Creates a new apk: chrome_public_apk_for_test that contains the same
>   content as chrome_public_apk, as well as native files needed for (2).
>   chrome_public_apk_test now targets chrome_public_apk_for_test instead of
>   chrome_public_apk.
>
> Other ideas, discarded:
>   * Originally, I attempted to make the browser_tests target runnable on
>   Android. The primary problem is that native test harness cannot fork
>   or spawn processes. This is difficult to solve.
>
> More details on each of the components:
> (1) ProfilingTestDriver
>   * The TracingController test was migrated to use ProfilingTestDriver, but the
>   write-to-file test was left as-is. The latter behavior will likely be phased
>   out, but I'll clean that up in a future CL.
>   * gtest isn't supported for Android instrumentation tests. ProfilingTestDriver
>   has a single function RunTest that returns a 'bool' indicating success. On
>   failure, the class uses LOG(ERROR) to print the nature of the error. This will
>   cause the error to be printed out on browser_test error. On instrumentation
>   test failure, the error will be forwarded to logcat, which is available on all
>   infra bot test runs.
> (2) Instrumentation test
>   * For now, I only added a single test for the ""browser"" mode. Furthermore, I'm
>   only testing the start with command-line path.
> (3) New apk
>   * libchromefortest is a new shared library that contains all content from
>   libchrome, but also contains native sources for the JNI shim.
>   * chrome_public_apk_for_test is a new apk that contains all content from
>   chrome_public_apk, but uses a single shared library libchromefortest rather
>   than libchrome. This also contains java sources for the JNI shim.
>   * There is no way to just add a second shared library to chrome_public_apk
>   that just contains the native sources from the JNI shim without causing ODR
>   issues.
>   * chrome_public_test_apk now has apk_under_test = chrome_public_apk_for_test.
>   * There is no way to add native JNI sources as a shared library to
>   chrome_public_test_apk without causing ODR issues.
>
> Finally, this CL drastically increases the timeout to wait for native
> initialization. The previous timeout was 2 *
> CriteriaHelper.DEFAULT_MAX_TIME_TO_POLL, which flakily failed for this test.
> This suggests that this step/timeout is generally flaky. I increased the timeout
> to 20 * CriteriaHelper.DEFAULT_MAX_TIME_TO_POLL.
>
> Bug: 753218
> Change-Id: Ic224b7314fff57f1770a4048aa5753f54e040b55
> Reviewed-on: https://chromium-review.googlesource.com/770148
> Commit-Queue: Erik Chen <erikchen@chromium.org>
> Reviewed-by: John Budorick <jbudorick@chromium.org>
> Reviewed-by: Brett Wilson <brettw@chromium.org>
> Cr-Commit-Position: refs/heads/master@{#517541}

Bug: 753218
TBR: brettw@chromium.org
Change-Id: Ic6aafb34c2467253f75cc85da48200d19f3bc9af
Reviewed-on: https://chromium-review.googlesource.com/777697
Commit-Queue: Erik Chen <erikchen@chromium.org>
Reviewed-by: John Budorick <jbudorick@chromium.org>
Cr-Commit-Position: refs/heads/master@{#517850}",12,chrome/browser/profiling_host/profiling_process_host.cc,"{""sha"": ""bf2e946584796934c88c495d3915d6ebfbb742d7"", ""filename"": ""chrome/android/BUILD.gn"", ""status"": ""modified"", ""additions"": 74, ""deletions"": 26, ""changes"": 100, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/android/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/android/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/BUILD.gn?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -727,39 +727,68 @@ jinja_template_resources(\""chrome_sync_shell_apk_template_resources\"") {\n   variables = chrome_sync_shell_jinja_variables\n }\n \n-shared_library(\""libchrome\"") {\n+# This template contains common code for both libchrome and libchromefortest.\n+# The former is used in chrome_public_apk. The latter is used in\n+# chrome_public_apk_for_test. The distinction is necessary because the latter\n+# requires additional native sources for JNI shims only used by tests.\n+template(\""chrome_shared_library\"") {\n+  shared_library(target_name) {\n+    forward_variables_from(invoker, \""*\"")\n+\n+    deps += [\n+      \""//build/config:exe_and_shlib_deps\"",\n+      \""//chrome:chrome_android_core\"",\n+    ]\n+\n+    if (enable_vr) {\n+      # Ensure libgvr static library appears before gcc library in linking order.\n+      # See https://crbug.com/704305 for details.\n+      libs = [ \""//third_party/gvr-android-sdk/libgvr_shim_static_${current_cpu}.a\"" ]\n+    }\n+\n+    if (use_order_profiling) {\n+      deps += [ \""//tools/cygprofile\"" ]\n+    }\n+\n+    # See crbug.com/705088, crbug.com/717815.\n+    if (target_cpu == \""arm\"" && (is_asan || use_order_profiling)) {\n+      ldflags = [ \""-Wl,--long-plt\"" ]\n+    }\n+\n+    if (chromium_linker_supported && use_lld) {\n+      configs += [ \""//build/config/android:lld_pack_relocations\"" ]\n+    }\n+\n+    public_configs = extra_chrome_shared_library_configs\n+    deps += extra_chrome_shared_library_deps\n+  }\n+}\n+\n+chrome_shared_library(\""libchrome\"") {\n   sources = [\n     \""../app/android/chrome_main_delegate_android_initializer.cc\"",\n     \""../browser/android/chrome_entry_point.cc\"",\n   ]\n   deps = [\n     \"":chrome_jni_registration($default_toolchain)\"",\n-    \""//build/config:exe_and_shlib_deps\"",\n-    \""//chrome:chrome_android_core\"",\n   ]\n+}\n \n-  if (enable_vr) {\n-    # Ensure libgvr static library appears before gcc library in linking order.\n-    # See https://crbug.com/704305 for details.\n-    libs =\n-        [ \""//third_party/gvr-android-sdk/libgvr_shim_static_${current_cpu}.a\"" ]\n-  }\n-\n-  if (use_order_profiling) {\n-    deps += [ \""//tools/cygprofile\"" ]\n-  }\n-\n-  # See crbug.com/705088, crbug.com/717815.\n-  if (target_cpu == \""arm\"" && (is_asan || use_order_profiling)) {\n-    ldflags = [ \""-Wl,--long-plt\"" ]\n-  }\n-\n-  if (chromium_linker_supported && use_lld) {\n-    configs += [ \""//build/config/android:lld_pack_relocations\"" ]\n-  }\n-\n-  public_configs = extra_chrome_shared_library_configs\n-  deps += extra_chrome_shared_library_deps\n+chrome_shared_library(\""libchromefortest\"") {\n+  testonly = true\n+  sources = [\n+    \""../app/android/chrome_main_delegate_android_initializer.cc\"",\n+    \""../browser/android/chrome_entry_point_for_test.cc\"",\n+    \""../browser/profiling_host/profiling_test_driver.cc\"",\n+    \""../browser/profiling_host/profiling_test_driver.h\"",\n+    \""../browser/profiling_host/test_android_shim.cc\"",\n+    \""../browser/profiling_host/test_android_shim.h\"",\n+  ]\n+  deps = [\n+    \"":chrome_jni_for_test_registration($default_toolchain)\"",\n+    \""//base/test:test_support\"",\n+    \""//chrome/browser/profiling_host:jni_headers\"",\n+  ]\n }\n \n # Ensure that .pak files are built only once (build them in the default\n@@ -772,6 +801,13 @@ if (current_toolchain == default_toolchain) {\n     exception_files = jni_exception_files\n   }\n \n+  generate_jni_registration(\""chrome_jni_for_test_registration\"") {\n+    testonly = true\n+    target = \"":chrome_public_apk_for_test\""\n+    output = \""$root_gen_dir/chrome/browser/android/${target_name}.h\""\n+    exception_files = jni_exception_files\n+  }\n+\n   generate_jni_registration(\""chrome_sync_shell_jni_registration\"") {\n     testonly = true\n     target = \"":chrome_sync_shell_apk\""\n@@ -996,6 +1032,17 @@ chrome_public_apk_tmpl_shared(\""chrome_public_apk\"") {\n   shared_libraries = [ \"":libchrome\"" ]\n }\n \n+chrome_public_apk_tmpl_shared(\""chrome_public_apk_for_test\"") {\n+  testonly = true\n+  android_manifest = chrome_public_android_manifest\n+  android_manifest_dep = \"":chrome_public_android_manifest\""\n+  apk_name = \""ChromePublicForTest\""\n+  shared_libraries = [ \"":libchromefortest\"" ]\n+  deps = [\n+    \""//chrome/browser/profiling_host:profiling_host_java_test_support\"",\n+  ]\n+}\n+\n chrome_public_apk_tmpl_shared(\""chrome_modern_public_apk\"") {\n   android_manifest = chrome_modern_public_android_manifest\n   android_manifest_dep = \"":chrome_modern_public_android_manifest\""\n@@ -1090,7 +1137,7 @@ jinja_template(\""chrome_sync_shell_test_apk_manifest\"") {\n \n instrumentation_test_apk(\""chrome_public_test_apk\"") {\n   apk_name = \""ChromePublicTest\""\n-  apk_under_test = \"":chrome_public_apk\""\n+  apk_under_test = \"":chrome_public_apk_for_test\""\n   android_manifest = chrome_public_test_apk_manifest\n   android_manifest_dep = \"":chrome_public_test_apk_manifest\""\n \n@@ -1099,6 +1146,7 @@ instrumentation_test_apk(\""chrome_public_test_apk\"") {\n     \""//chrome/android/webapk/libs/runtime_library:runtime_library_javatests\"",\n     \""//chrome/android/webapk/shell_apk:shell_apk_javatests\"",\n     \""//chrome/android/webapk/shell_apk:webapk_javatests\"",\n+    \""//chrome/browser/profiling_host:profiling_host_javatests\"",\n     \""//third_party/android_support_test_runner:runner_java\"",\n   ]\n   additional_apks = [""}<_**next**_>{""sha"": ""99a54e93f91b79715a86f47b38d9a116d5dcec3f"", ""filename"": ""chrome/android/javatests/src/org/chromium/chrome/browser/profiling_host/ProfilingProcessHostAndroidTest.java"", ""status"": ""added"", ""additions"": 45, ""deletions"": 0, ""changes"": 45, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/android/javatests/src/org/chromium/chrome/browser/profiling_host/ProfilingProcessHostAndroidTest.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/android/javatests/src/org/chromium/chrome/browser/profiling_host/ProfilingProcessHostAndroidTest.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/javatests/src/org/chromium/chrome/browser/profiling_host/ProfilingProcessHostAndroidTest.java?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -0,0 +1,45 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium.chrome.browser.profiling_host;\n+\n+import android.support.test.filters.MediumTest;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.chromium.base.test.util.CommandLineFlags;\n+import org.chromium.chrome.browser.ChromeActivity;\n+import org.chromium.chrome.browser.ChromeSwitches;\n+import org.chromium.chrome.test.ChromeActivityTestRule;\n+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;\n+\n+/**\n+ * Test suite for out of process heap profiling.\n+ */\n+@RunWith(ChromeJUnit4ClassRunner.class)\n+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE,\n+        ChromeActivityTestRule.DISABLE_NETWORK_PREDICTION_FLAG})\n+public class ProfilingProcessHostAndroidTest {\n+    private static final String TAG = \""ProfilingProcessHostAndroidTest\"";\n+    @Rule\n+    public ChromeActivityTestRule<ChromeActivity> mActivityTestRule =\n+            new ChromeActivityTestRule<>(ChromeActivity.class);\n+\n+    @Before\n+    public void setUp() throws InterruptedException {\n+        mActivityTestRule.startMainActivityOnBlankPage();\n+    }\n+\n+    @Test\n+    @MediumTest\n+    @CommandLineFlags.Add({\""memlog=browser\""})\n+    public void testModeBrowser() throws Exception {\n+        TestAndroidShim profilingProcessHost = new TestAndroidShim();\n+        Assert.assertTrue(profilingProcessHost.runTestForMode(\""browser\""));\n+    }\n+}""}<_**next**_>{""sha"": ""8679d6fd3240a217e99c4b4641fbd1a9bd11a31d"", ""filename"": ""chrome/android/javatests/src/org/chromium/chrome/browser/profiling_host/TestAndroidShim.java"", ""status"": ""added"", ""additions"": 38, ""deletions"": 0, ""changes"": 38, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/android/javatests/src/org/chromium/chrome/browser/profiling_host/TestAndroidShim.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/android/javatests/src/org/chromium/chrome/browser/profiling_host/TestAndroidShim.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/javatests/src/org/chromium/chrome/browser/profiling_host/TestAndroidShim.java?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -0,0 +1,38 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium.chrome.browser.profiling_host;\n+\n+import org.chromium.base.annotations.MainDex;\n+\n+/**\n+ * Provides direct access to test_android_shim, which in turn forwards to\n+ * ProfilingTestDriver. Only used for testing.\n+ */\n+@MainDex\n+public class TestAndroidShim {\n+    public TestAndroidShim() {\n+        mNativeTestAndroidShim = nativeInit();\n+    }\n+\n+    public boolean runTestForMode(String mode) {\n+        return nativeRunTestForMode(mNativeTestAndroidShim, mode);\n+    }\n+\n+    /**\n+     * Clean up the C++ side of this class.\n+     * After the call, this class instance shouldn't be used.\n+     */\n+    public void destroy() {\n+        if (mNativeTestAndroidShim != 0) {\n+            nativeDestroy(mNativeTestAndroidShim);\n+            mNativeTestAndroidShim = 0;\n+        }\n+    }\n+\n+    private long mNativeTestAndroidShim;\n+    private native long nativeInit();\n+    private native void nativeDestroy(long nativeTestAndroidShim);\n+    private native boolean nativeRunTestForMode(long nativeTestAndroidShim, String mode);\n+}""}<_**next**_>{""sha"": ""1eb8e02b99e9bfe3bd64ebc1030794f2f0c9ba62"", ""filename"": ""chrome/browser/android/chrome_entry_point_for_test.cc"", ""status"": ""added"", ""additions"": 43, ""deletions"": 0, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/android/chrome_entry_point_for_test.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/android/chrome_entry_point_for_test.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/chrome_entry_point_for_test.cc?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -0,0 +1,43 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""base/android/jni_android.h\""\n+#include \""base/android/jni_utils.h\""\n+#include \""base/android/library_loader/library_loader_hooks.h\""\n+#include \""base/bind.h\""\n+#include \""base/test/test_support_android.h\""\n+#include \""chrome/app/android/chrome_jni_onload.h\""\n+#include \""chrome/browser/android/chrome_jni_for_test_registration.h\""\n+\n+namespace {\n+\n+bool NativeInit() {\n+  return android::OnJNIOnLoadInit();\n+}\n+\n+}  // namespace\n+\n+// This is called by the VM when the shared library is first loaded.\n+JNI_EXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) {\n+  // By default, all JNI methods are registered. However, since render processes\n+  // don't need very much Java code, we enable selective JNI registration on the\n+  // Java side and only register a subset of JNI methods.\n+  base::android::InitVM(vm);\n+  JNIEnv* env = base::android::AttachCurrentThread();\n+\n+  if (!base::android::IsSelectiveJniRegistrationEnabled(env) &&\n+      !RegisterNonMainDexNatives(env)) {\n+    return -1;\n+  }\n+\n+  if (!RegisterMainDexNatives(env)) {\n+    return -1;\n+  }\n+\n+  if (!android::OnJNIOnLoadRegisterJNI(env)) {\n+    return -1;\n+  }\n+  base::android::SetNativeInitializationHook(NativeInit);\n+  return JNI_VERSION_1_4;\n+}""}<_**next**_>{""sha"": ""9d7dbf3ddc1b24cb886f59af4739c3fd030d2591"", ""filename"": ""chrome/browser/profiling_host/BUILD.gn"", ""status"": ""modified"", ""additions"": 41, ""deletions"": 0, ""changes"": 41, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/profiling_host/BUILD.gn?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -8,6 +8,8 @@ if (!is_android) {\n \n     sources = [\n       \""memlog_browsertest.cc\"",\n+      \""profiling_test_driver.cc\"",\n+      \""profiling_test_driver.h\"",\n     ]\n \n     defines = [ \""HAS_OUT_OF_PROC_TEST_RUNNER\"" ]\n@@ -21,7 +23,46 @@ if (!is_android) {\n     ]\n   }\n } else {\n+  import(\""//build/config/android/rules.gni\"")\n+\n   # In-process browser tests aren't supported on Android.\n   group(\""profiling_browsertests\"") {\n   }\n+\n+  generate_jni(\""jni_headers\"") {\n+    sources = [\n+      \""../../android/javatests/src/org/chromium/chrome/browser/profiling_host/TestAndroidShim.java\"",\n+    ]\n+    jni_package = \""chrome_profiling_host\""\n+  }\n+\n+  # This library must be included by the apk_under_test in order for the JNI\n+  # shim to function correctly.\n+  android_library(\""profiling_host_java_test_support\"") {\n+    testonly = true\n+    java_files = [ \""../../android/javatests/src/org/chromium/chrome/browser/profiling_host/TestAndroidShim.java\"" ]\n+    deps = [\n+      \""//base:base_java\"",\n+    ]\n+  }\n+\n+  # This library must be included by the instrumentation_test. It must not be\n+  # included by the apk_under_test, since in debug builds, java classes that\n+  # appear in the apk_under_test are stripped from the instrumentation_test.\n+  # This library contains dependencies that must not be stripped from the\n+  # instrumentation_test.\n+  android_library(\""profiling_host_javatests\"") {\n+    testonly = true\n+    java_files = [ \""../../android/javatests/src/org/chromium/chrome/browser/profiling_host/ProfilingProcessHostAndroidTest.java\"" ]\n+    deps = [\n+      \"":profiling_host_java_test_support\"",\n+      \""//base:base_java\"",\n+      \""//base:base_java_test_support\"",\n+      \""//chrome/android:chrome_java\"",\n+      \""//chrome/test/android:chrome_java_test_support\"",\n+      \""//third_party/android_support_test_runner:rules_java\"",\n+      \""//third_party/android_support_test_runner:runner_java\"",\n+      \""//third_party/junit\"",\n+    ]\n+  }\n }""}<_**next**_>{""sha"": ""3fd613843960657ebcfc519e17a4ebc9a40fdf86"", ""filename"": ""chrome/browser/profiling_host/memlog_browsertest.cc"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 60, ""changes"": 70, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/memlog_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/memlog_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/profiling_host/memlog_browsertest.cc?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -3,25 +3,20 @@\n // found in the LICENSE file.\n \n #include \""base/allocator/features.h\""\n-#include \""base/allocator/partition_allocator/partition_alloc.h\""\n #include \""base/json/json_reader.h\""\n-#include \""base/memory/ref_counted_memory.h\""\n-#include \""base/run_loop.h\""\n-#include \""base/task_scheduler/post_task.h\""\n #include \""base/threading/thread_restrictions.h\""\n #include \""base/trace_event/trace_buffer.h\""\n-#include \""base/trace_event/trace_config_memory_test_util.h\""\n #include \""base/trace_event/trace_log.h\""\n #include \""build/build_config.h\""\n #include \""chrome/browser/profiling_host/profiling_process_host.h\""\n+#include \""chrome/browser/profiling_host/profiling_test_driver.h\""\n #include \""chrome/browser/ui/browser.h\""\n #include \""chrome/browser/ui/tabs/tab_strip_model.h\""\n #include \""chrome/common/chrome_switches.h\""\n #include \""chrome/test/base/in_process_browser_test.h\""\n #include \""chrome/test/base/ui_test_utils.h\""\n #include \""content/public/browser/render_frame_host.h\""\n #include \""content/public/browser/render_process_host.h\""\n-#include \""content/public/browser/tracing_controller.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""content/public/test/browser_test.h\""\n #include \""net/test/embedded_test_server/embedded_test_server.h\""\n@@ -408,60 +403,15 @@ IN_PROC_BROWSER_TEST_P(MemlogBrowserTest, EndToEnd) {\n // Ensure invocations via TracingController can generate a valid JSON file with\n // expected data.\n IN_PROC_BROWSER_TEST_P(MemlogBrowserTest, TracingControllerEndToEnd) {\n-  if (!GetParam()) {\n-    // Test that nothing has been started if the flag is not passed. Then early\n-    // exit.\n-    ASSERT_FALSE(profiling::ProfilingProcessHost::has_started());\n-    return;\n-  } else {\n-    ASSERT_TRUE(profiling::ProfilingProcessHost::has_started());\n-  }\n-\n-  MakeTestAllocations();\n-\n-  base::RunLoop run_loop;\n-  scoped_refptr<base::RefCountedString> result;\n-\n-  // Once the ProfilingProcessHost has dumped to the trace, stop the trace and\n-  // collate the results into |result|, then quit the nested run loop.\n-  auto finish_sink_callback = base::Bind(\n-      [](scoped_refptr<base::RefCountedString>* result, base::Closure finished,\n-         std::unique_ptr<const base::DictionaryValue> metadata,\n-         base::RefCountedString* in) {\n-        *result = in;\n-        std::move(finished).Run();\n-      },\n-      &result, run_loop.QuitClosure());\n-  scoped_refptr<content::TracingController::TraceDataEndpoint> sink =\n-      content::TracingController::CreateStringEndpoint(\n-          std::move(finish_sink_callback));\n-  base::OnceClosure stop_tracing_closure = base::BindOnce(\n-      base::IgnoreResult<bool (content::TracingController::*)(  // NOLINT\n-          const scoped_refptr<content::TracingController::TraceDataEndpoint>&)>(\n-          &content::TracingController::StopTracing),\n-      base::Unretained(content::TracingController::GetInstance()), sink);\n-  base::OnceClosure stop_tracing_ui_thread_closure =\n-      base::BindOnce(base::IgnoreResult(&base::TaskRunner::PostTask),\n-                     base::ThreadTaskRunnerHandle::Get(), FROM_HERE,\n-                     std::move(stop_tracing_closure));\n-  profiling::ProfilingProcessHost::GetInstance()\n-      ->SetDumpProcessForTracingCallback(\n-          std::move(stop_tracing_ui_thread_closure));\n-\n-  // Spin a nested RunLoop until the heap dump has been added to the trace.\n-  content::TracingController::GetInstance()->StartTracing(\n-      base::trace_event::TraceConfig(\n-          base::trace_event::TraceConfigMemoryTestUtil::\n-              GetTraceConfig_PeriodicTriggers(100000, 100000)),\n-      base::Closure());\n-  run_loop.Run();\n-\n-  std::unique_ptr<base::Value> dump_json =\n-      base::JSONReader::Read(result->data());\n-  ASSERT_TRUE(dump_json);\n-  ValidateBrowserAllocations(dump_json.get());\n-  ValidateRendererAllocations(dump_json.get());\n-  // TODO(ajwong): Test GPU dumps  http://crbug.com/780955\n+  profiling::ProfilingTestDriver driver;\n+  profiling::ProfilingTestDriver::Options options;\n+  options.mode =\n+      GetParam()\n+          ? profiling::ProfilingProcessHost::ConvertStringToMode(GetParam())\n+          : profiling::ProfilingProcessHost::Mode::kNone;\n+  options.profiling_already_started = true;\n+\n+  EXPECT_TRUE(driver.RunTest(options));\n }\n \n // TODO(ajwong): Test what happens if profiling process crashes.""}<_**next**_>{""sha"": ""bfda42d05b19d8902be350ce8257b9010eb3cbe0"", ""filename"": ""chrome/browser/profiling_host/profiling_process_host.cc"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 13, ""changes"": 32, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/profiling_process_host.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/profiling_process_host.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/profiling_host/profiling_process_host.cc?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -371,19 +371,7 @@ ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {\n           kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);\n     }\n \n-    if (mode == switches::kMemlogModeAll)\n-      return Mode::kAll;\n-    if (mode == switches::kMemlogModeMinimal)\n-      return Mode::kMinimal;\n-    if (mode == switches::kMemlogModeBrowser)\n-      return Mode::kBrowser;\n-    if (mode == switches::kMemlogModeGpu)\n-      return Mode::kGpu;\n-    if (mode == switches::kMemlogModeRendererSampling)\n-      return Mode::kRendererSampling;\n-\n-    DLOG(ERROR) << \""Unsupported value: \\\""\"" << mode << \""\\\"" passed to --\""\n-                << switches::kMemlog;\n+    return ConvertStringToMode(mode);\n   }\n   return Mode::kNone;\n #else\n@@ -395,6 +383,24 @@ ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {\n #endif\n }\n \n+// static\n+ProfilingProcessHost::Mode ProfilingProcessHost::ConvertStringToMode(\n+    const std::string& mode) {\n+  if (mode == switches::kMemlogModeAll)\n+    return Mode::kAll;\n+  if (mode == switches::kMemlogModeMinimal)\n+    return Mode::kMinimal;\n+  if (mode == switches::kMemlogModeBrowser)\n+    return Mode::kBrowser;\n+  if (mode == switches::kMemlogModeGpu)\n+    return Mode::kGpu;\n+  if (mode == switches::kMemlogModeRendererSampling)\n+    return Mode::kRendererSampling;\n+  DLOG(ERROR) << \""Unsupported value: \\\""\"" << mode << \""\\\"" passed to --\""\n+              << switches::kMemlog;\n+  return Mode::kNone;\n+}\n+\n // static\n ProfilingProcessHost* ProfilingProcessHost::Start(\n     content::ServiceManagerConnection* connection,""}<_**next**_>{""sha"": ""94cc7a91d5c87d5f7b29085287ccfa46f131aa10"", ""filename"": ""chrome/browser/profiling_host/profiling_process_host.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/profiling_process_host.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/profiling_process_host.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/profiling_host/profiling_process_host.h?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -89,6 +89,7 @@ class ProfilingProcessHost : public content::BrowserChildProcessObserver,\n \n   // Returns the mode set on the current process' command line.\n   static Mode GetCurrentMode();\n+  static Mode ConvertStringToMode(const std::string& input);\n   bool ShouldProfileProcessType(int process_type);\n \n   // Launches the profiling process and returns a pointer to it.\n@@ -123,6 +124,7 @@ class ProfilingProcessHost : public content::BrowserChildProcessObserver,\n   friend struct base::DefaultSingletonTraits<ProfilingProcessHost>;\n   friend class BackgroundProfilingTriggersTest;\n   friend class MemlogBrowserTest;\n+  friend class ProfilingTestDriver;\n   FRIEND_TEST_ALL_PREFIXES(ProfilingProcessHost, ShouldProfileNewRenderer);\n \n   ProfilingProcessHost();""}<_**next**_>{""sha"": ""653946162cb6db49dc4504a3c1a8a3eab2ad433a"", ""filename"": ""chrome/browser/profiling_host/profiling_test_driver.cc"", ""status"": ""added"", ""additions"": 502, ""deletions"": 0, ""changes"": 502, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/profiling_test_driver.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/profiling_test_driver.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/profiling_host/profiling_test_driver.cc?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -0,0 +1,502 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""chrome/browser/profiling_host/profiling_test_driver.h\""\n+\n+#include <string>\n+\n+#include \""base/bind.h\""\n+#include \""base/command_line.h\""\n+#include \""base/json/json_reader.h\""\n+#include \""base/process/process_handle.h\""\n+#include \""base/run_loop.h\""\n+#include \""base/task_scheduler/post_task.h\""\n+#include \""base/trace_event/trace_config_memory_test_util.h\""\n+#include \""base/values.h\""\n+#include \""build/build_config.h\""\n+#include \""content/public/browser/browser_thread.h\""\n+#include \""content/public/browser/tracing_controller.h\""\n+#include \""content/public/common/service_manager_connection.h\""\n+\n+namespace profiling {\n+\n+namespace {\n+\n+// Make some specific allocations in Browser to do a deeper test of the\n+// allocation tracking.\n+constexpr int kMallocAllocSize = 7907;\n+constexpr int kMallocAllocCount = 157;\n+\n+constexpr int kVariadicAllocCount = 157;\n+\n+// Test fixed-size partition alloc. The size must be aligned to system pointer\n+// size.\n+constexpr int kPartitionAllocSize = 8 * 23;\n+constexpr int kPartitionAllocCount = 107;\n+static const char* kPartitionAllocTypeName = \""kPartitionAllocTypeName\"";\n+\n+// On success, populates |pid|.\n+int NumProcessesWithName(base::Value* dump_json, std::string name, int* pid) {\n+  int num_processes = 0;\n+  base::Value* events = dump_json->FindKey(\""traceEvents\"");\n+  for (base::Value& event : events->GetList()) {\n+    const base::Value* found_name =\n+        event.FindKeyOfType(\""name\"", base::Value::Type::STRING);\n+    if (!found_name)\n+      continue;\n+    if (found_name->GetString() != \""process_name\"")\n+      continue;\n+    const base::Value* found_args =\n+        event.FindKeyOfType(\""args\"", base::Value::Type::DICTIONARY);\n+    if (!found_args)\n+      continue;\n+    const base::Value* found_process_name =\n+        found_args->FindKeyOfType(\""name\"", base::Value::Type::STRING);\n+    if (!found_process_name)\n+      continue;\n+    if (found_process_name->GetString() != name)\n+      continue;\n+\n+    if (pid) {\n+      const base::Value* found_pid =\n+          event.FindKeyOfType(\""pid\"", base::Value::Type::INTEGER);\n+      if (!found_pid) {\n+        LOG(ERROR) << \""Process missing pid.\"";\n+        return 0;\n+      }\n+      *pid = found_pid->GetInt();\n+    }\n+\n+    ++num_processes;\n+  }\n+  return num_processes;\n+}\n+\n+base::Value* FindHeapsV2(base::ProcessId pid, base::Value* dump_json) {\n+  base::Value* events = dump_json->FindKey(\""traceEvents\"");\n+  base::Value* dumps = nullptr;\n+  base::Value* heaps_v2 = nullptr;\n+  for (base::Value& event : events->GetList()) {\n+    const base::Value* found_name =\n+        event.FindKeyOfType(\""name\"", base::Value::Type::STRING);\n+    if (!found_name)\n+      continue;\n+    if (found_name->GetString() != \""periodic_interval\"")\n+      continue;\n+    const base::Value* found_pid =\n+        event.FindKeyOfType(\""pid\"", base::Value::Type::INTEGER);\n+    if (!found_pid)\n+      continue;\n+    if (static_cast<base::ProcessId>(found_pid->GetInt()) != pid)\n+      continue;\n+    dumps = &event;\n+    heaps_v2 = dumps->FindPath({\""args\"", \""dumps\"", \""heaps_v2\""});\n+    if (heaps_v2)\n+      return heaps_v2;\n+  }\n+  return nullptr;\n+}\n+\n+// Verify expectations are present in heap dump.\n+bool ValidateDump(base::Value* heaps_v2,\n+                  int expected_alloc_size,\n+                  int expected_alloc_count,\n+                  const char* allocator_name,\n+                  const char* type_name) {\n+  base::Value* sizes =\n+      heaps_v2->FindPath({\""allocators\"", allocator_name, \""sizes\""});\n+  if (!sizes) {\n+    LOG(ERROR) << \""Failed to find path: 'allocators.\"" << allocator_name\n+               << \"".sizes' in heaps v2\"";\n+    return false;\n+  }\n+\n+  const base::Value::ListStorage& sizes_list = sizes->GetList();\n+  if (sizes_list.empty()) {\n+    LOG(ERROR) << \""'allocators.\"" << allocator_name\n+               << \"".sizes' is an empty list\"";\n+    return false;\n+  }\n+\n+  base::Value* counts =\n+      heaps_v2->FindPath({\""allocators\"", allocator_name, \""counts\""});\n+  if (!counts) {\n+    LOG(ERROR) << \""Failed to find path: 'allocators.\"" << allocator_name\n+               << \"".counts' in heaps v2\"";\n+    return false;\n+  }\n+\n+  const base::Value::ListStorage& counts_list = counts->GetList();\n+  if (sizes_list.size() != counts_list.size()) {\n+    LOG(ERROR)\n+        << \""'allocators.\"" << allocator_name\n+        << \"".sizes' does not have the same number of elements as *.counts\"";\n+    return false;\n+  }\n+\n+  base::Value* types =\n+      heaps_v2->FindPath({\""allocators\"", allocator_name, \""types\""});\n+  if (!types) {\n+    LOG(ERROR) << \""Failed to find path: 'allocators.\"" << allocator_name\n+               << \"".types' in heaps v2\"";\n+    return false;\n+  }\n+\n+  const base::Value::ListStorage& types_list = types->GetList();\n+  if (types_list.empty()) {\n+    LOG(ERROR) << \""'allocators.\"" << allocator_name\n+               << \"".types' is an empty list\"";\n+    return false;\n+  }\n+\n+  if (sizes_list.size() != types_list.size()) {\n+    LOG(ERROR)\n+        << \""'allocators.\"" << allocator_name\n+        << \"".types' does not have the same number of elements as *.sizes\"";\n+    return false;\n+  }\n+\n+  bool found_browser_alloc = false;\n+  size_t browser_alloc_index = 0;\n+  for (size_t i = 0; i < sizes_list.size(); i++) {\n+    if (counts_list[i].GetInt() == expected_alloc_count &&\n+        sizes_list[i].GetInt() != expected_alloc_size) {\n+      LOG(WARNING) << \""Allocation candidate (size:\"" << sizes_list[i].GetInt()\n+                   << \"" count:\"" << counts_list[i].GetInt() << \"")\"";\n+    }\n+    if (sizes_list[i].GetInt() == expected_alloc_size &&\n+        counts_list[i].GetInt() == expected_alloc_count) {\n+      browser_alloc_index = i;\n+      found_browser_alloc = true;\n+      break;\n+    }\n+  }\n+\n+  if (!found_browser_alloc) {\n+    LOG(ERROR) << \""Failed to find an allocation of the \""\n+                  \""appropriate size. Did the send buffer \""\n+                  \""not flush? (size: \""\n+               << expected_alloc_size << \"" count:\"" << expected_alloc_count\n+               << \"")\"";\n+    return false;\n+  }\n+\n+  // Find the type, if an expectation was passed in.\n+  if (type_name) {\n+    bool found = false;\n+    int type = types_list[browser_alloc_index].GetInt();\n+    base::Value* strings = heaps_v2->FindPath({\""maps\"", \""strings\""});\n+    for (base::Value& dict : strings->GetList()) {\n+      // Each dict has the format {\""id\"":1,\""string\"":\""kPartitionAllocTypeName\""}\n+      int id = dict.FindKey(\""id\"")->GetInt();\n+      if (id == type) {\n+        found = true;\n+        std::string name = dict.FindKey(\""string\"")->GetString();\n+        if (name != type_name) {\n+          LOG(ERROR) << \""actual name: \"" << name\n+                     << \"" expected name: \"" << type_name;\n+          return false;\n+        }\n+        break;\n+      }\n+    }\n+    if (!found) {\n+      LOG(ERROR) << \""Failed to find type name string: \"" << type_name;\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+}  // namespace\n+\n+ProfilingTestDriver::ProfilingTestDriver()\n+    : wait_for_ui_thread_(base::WaitableEvent::ResetPolicy::AUTOMATIC,\n+                          base::WaitableEvent::InitialState::NOT_SIGNALED) {\n+  partition_allocator_.init();\n+}\n+ProfilingTestDriver::~ProfilingTestDriver() {}\n+\n+bool ProfilingTestDriver::RunTest(const Options& options) {\n+  options_ = options;\n+\n+  running_on_ui_thread_ =\n+      content::BrowserThread::CurrentlyOn(content::BrowserThread::UI);\n+\n+  // The only thing to test for Mode::kNone is that profiling hasn't started.\n+  if (options_.mode == ProfilingProcessHost::Mode::kNone) {\n+    if (ProfilingProcessHost::has_started()) {\n+      LOG(ERROR) << \""Profiling should not have started\"";\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  if (running_on_ui_thread_) {\n+    if (!RunInitializationOnUIThread())\n+      return false;\n+    CollectResults(true);\n+  } else {\n+    content::BrowserThread::PostTask(\n+        content::BrowserThread::UI, FROM_HERE,\n+        base::Bind(&ProfilingTestDriver::RunInitializationOnUIThreadAndSignal,\n+                   base::Unretained(this)));\n+    wait_for_ui_thread_.Wait();\n+    if (!initialization_success_)\n+      return false;\n+    content::BrowserThread::PostTask(\n+        content::BrowserThread::UI, FROM_HERE,\n+        base::Bind(&ProfilingTestDriver::CollectResults, base::Unretained(this),\n+                   false));\n+    wait_for_ui_thread_.Wait();\n+  }\n+\n+  std::unique_ptr<base::Value> dump_json =\n+      base::JSONReader::Read(serialized_trace_->data());\n+  if (!dump_json) {\n+    LOG(ERROR) << \""Failed to deserialize trace.\"";\n+    return false;\n+  }\n+\n+  if (!ValidateBrowserAllocations(dump_json.get())) {\n+    LOG(ERROR) << \""Failed to validate browser allocations\"";\n+    return false;\n+  }\n+\n+  if (!ValidateRendererAllocations(dump_json.get())) {\n+    LOG(ERROR) << \""Failed to validate renderer allocations\"";\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+void ProfilingTestDriver::RunInitializationOnUIThreadAndSignal() {\n+  DCHECK(content::BrowserThread::CurrentlyOn(content::BrowserThread::UI));\n+  initialization_success_ = RunInitializationOnUIThread();\n+  wait_for_ui_thread_.Signal();\n+}\n+\n+bool ProfilingTestDriver::RunInitializationOnUIThread() {\n+  DCHECK(content::BrowserThread::CurrentlyOn(content::BrowserThread::UI));\n+\n+  if (options_.mode == ProfilingProcessHost::Mode::kRendererSampling) {\n+    profiling::ProfilingProcessHost::GetInstance()\n+        ->SetRendererSamplingAlwaysProfileForTest();\n+  }\n+\n+  LOG(ERROR) << \""RunInitializationOnUIThread: \""\n+             << base::CommandLine::ForCurrentProcess()->GetCommandLineString();\n+  if (!CheckOrStartProfiling())\n+    return false;\n+\n+  MakeTestAllocations();\n+  return true;\n+}\n+\n+bool ProfilingTestDriver::CheckOrStartProfiling() {\n+  if (options_.profiling_already_started) {\n+    if (ProfilingProcessHost::has_started())\n+      return true;\n+    LOG(ERROR) << \""Profiling should have been started, but wasn't\"";\n+    return false;\n+  }\n+\n+  content::ServiceManagerConnection* connection =\n+      content::ServiceManagerConnection::GetForProcess();\n+  if (!connection) {\n+    LOG(ERROR) << \""A ServiceManagerConnection was not available for the \""\n+                  \""current process.\"";\n+    return false;\n+  }\n+\n+  ProfilingProcessHost::Start(connection, options_.mode);\n+  return true;\n+}\n+\n+void ProfilingTestDriver::MakeTestAllocations() {\n+  leaks_.reserve(2 * kMallocAllocCount + kPartitionAllocSize);\n+  for (int i = 0; i < kMallocAllocCount; ++i) {\n+    leaks_.push_back(new char[kMallocAllocSize]);\n+  }\n+\n+  for (int i = 0; i < kPartitionAllocCount; ++i) {\n+    leaks_.push_back(static_cast<char*>(\n+        PartitionAllocGeneric(partition_allocator_.root(), kPartitionAllocSize,\n+                              kPartitionAllocTypeName)));\n+  }\n+\n+  for (int i = 0; i < kVariadicAllocCount; ++i) {\n+    leaks_.push_back(new char[i + 8000]);  // Variadic allocation.\n+    total_variadic_allocations_ += i + 8000;\n+  }\n+\n+  // // Navigate around to force allocations in the renderer.\n+  // ASSERT_TRUE(embedded_test_server()->Start());\n+  // ui_test_utils::NavigateToURL(\n+  //     browser(), embedded_test_server()->GetURL(\""/english_page.html\""));\n+  // // Vive la France!\n+  // ui_test_utils::NavigateToURL(\n+  //     browser(), embedded_test_server()->GetURL(\""/french_page.html\""));\n+}\n+\n+void ProfilingTestDriver::CollectResults(bool synchronous) {\n+  base::Closure finish_tracing_closure;\n+  std::unique_ptr<base::RunLoop> run_loop;\n+\n+  if (synchronous) {\n+    run_loop.reset(new base::RunLoop);\n+    finish_tracing_closure = run_loop->QuitClosure();\n+  } else {\n+    finish_tracing_closure = base::Bind(&base::WaitableEvent::Signal,\n+                                        base::Unretained(&wait_for_ui_thread_));\n+  }\n+\n+  // Once the ProfilingProcessHost has dumped to the trace, stop the trace and\n+  // collate the results into |result|, then quit the nested run loop.\n+  auto finish_sink_callback = base::Bind(\n+      [](scoped_refptr<base::RefCountedString>* result, base::Closure finished,\n+         std::unique_ptr<const base::DictionaryValue> metadata,\n+         base::RefCountedString* in) {\n+        *result = in;\n+        std::move(finished).Run();\n+      },\n+      &serialized_trace_, std::move(finish_tracing_closure));\n+\n+  scoped_refptr<content::TracingController::TraceDataEndpoint> sink =\n+      content::TracingController::CreateStringEndpoint(\n+          std::move(finish_sink_callback));\n+  base::OnceClosure stop_tracing_closure = base::BindOnce(\n+      base::IgnoreResult<bool (content::TracingController::*)(  // NOLINT\n+          const scoped_refptr<content::TracingController::TraceDataEndpoint>&)>(\n+          &content::TracingController::StopTracing),\n+      base::Unretained(content::TracingController::GetInstance()), sink);\n+  base::OnceClosure stop_tracing_ui_thread_closure =\n+      base::BindOnce(base::IgnoreResult(&base::TaskRunner::PostTask),\n+                     base::ThreadTaskRunnerHandle::Get(), FROM_HERE,\n+                     std::move(stop_tracing_closure));\n+  profiling::ProfilingProcessHost::GetInstance()\n+      ->SetDumpProcessForTracingCallback(\n+          std::move(stop_tracing_ui_thread_closure));\n+\n+  // Spin a nested RunLoop until the heap dump has been added to the trace.\n+  content::TracingController::GetInstance()->StartTracing(\n+      base::trace_event::TraceConfig(\n+          base::trace_event::TraceConfigMemoryTestUtil::\n+              GetTraceConfig_PeriodicTriggers(100000, 100000)),\n+      base::Closure());\n+\n+  if (synchronous)\n+    run_loop->Run();\n+}\n+\n+bool ProfilingTestDriver::ValidateBrowserAllocations(base::Value* dump_json) {\n+  base::Value* heaps_v2 =\n+      FindHeapsV2(base::Process::Current().Pid(), dump_json);\n+\n+  if (options_.mode != ProfilingProcessHost::Mode::kAll &&\n+      options_.mode != ProfilingProcessHost::Mode::kBrowser &&\n+      options_.mode != ProfilingProcessHost::Mode::kMinimal) {\n+    if (heaps_v2) {\n+      LOG(ERROR) << \""There should be no heap dump for the browser.\"";\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  bool result = false;\n+\n+// TODO(ajwong): This step fails on Nexus 5X devices running kit-kat. It works\n+// on Nexus 5X devices running oreo. The problem is that all allocations have\n+// the same [an effectively empty] backtrace and get glommed together. More\n+// investigation is necessary. For now, I'm turning this off for Android.\n+// https://crbug.com/786450.\n+#if !defined(OS_ANDROID)\n+  result = ValidateDump(heaps_v2, kMallocAllocSize * kMallocAllocCount,\n+                        kMallocAllocCount, \""malloc\"", nullptr);\n+  if (!result) {\n+    LOG(ERROR) << \""Failed to validate malloc fixed allocations\"";\n+    return false;\n+  }\n+\n+  result = ValidateDump(heaps_v2, total_variadic_allocations_,\n+                        kVariadicAllocCount, \""malloc\"", nullptr);\n+  if (!result) {\n+    LOG(ERROR) << \""Failed to validate malloc variadic allocations\"";\n+    return false;\n+  }\n+#endif\n+\n+  // TODO(ajwong): Like malloc, all Partition-Alloc allocations get glommed\n+  // together for some Android device/OS configurations. However, since there is\n+  // only one place that uses partition alloc in the browser process [this\n+  // test], the count is still valid. This should still be made more robust by\n+  // fixing backtrace. https://crbug.com/786450.\n+  result = ValidateDump(heaps_v2, kPartitionAllocSize * kPartitionAllocCount,\n+                        kPartitionAllocCount, \""partition_alloc\"",\n+                        kPartitionAllocTypeName);\n+  if (!result) {\n+    LOG(ERROR) << \""Failed to validate PA allocations\"";\n+    return false;\n+  }\n+\n+  int process_count = NumProcessesWithName(dump_json, \""Browser\"", nullptr);\n+  if (process_count != 1) {\n+    LOG(ERROR) << \""Found \"" << process_count\n+               << \"" processes with name: Browser. Expected 1.\"";\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+bool ProfilingTestDriver::ValidateRendererAllocations(base::Value* dump_json) {\n+  int pid;\n+  bool result = NumProcessesWithName(dump_json, \""Renderer\"", &pid) == 1;\n+  if (!result) {\n+    LOG(ERROR) << \""Failed to find process with name Renderer\"";\n+    return false;\n+  }\n+\n+  base::ProcessId renderer_pid = static_cast<base::ProcessId>(pid);\n+  base::Value* heaps_v2 = FindHeapsV2(renderer_pid, dump_json);\n+  if (options_.mode == ProfilingProcessHost::Mode::kAll ||\n+      options_.mode == ProfilingProcessHost::Mode::kRendererSampling) {\n+    if (!heaps_v2) {\n+      LOG(ERROR) << \""Failed to find heaps v2 for renderer\"";\n+      return false;\n+    }\n+\n+    // ValidateDump doesn't always succeed for the renderer, since we don't do\n+    // anything to flush allocations, there are very few allocations recorded\n+    // by the heap profiler. When we do a heap dump, we prune small\n+    // allocations...and this can cause all allocations to be pruned.\n+    // ASSERT_NO_FATAL_FAILURE(ValidateDump(dump_json.get(), 0, 0));\n+  } else {\n+    if (heaps_v2) {\n+      LOG(ERROR) << \""There should be no heap dump for the renderer.\"";\n+      return false;\n+    }\n+  }\n+\n+  // RendererSampling guarantees only 1 renderer is ever sampled at a time.\n+  if (options_.mode == ProfilingProcessHost::Mode::kRendererSampling) {\n+    if (NumProcessesWithName(dump_json, \""Renderer\"", nullptr) != 1) {\n+      LOG(ERROR) << \""There should be exactly 1 renderer dump\"";\n+      return false;\n+    }\n+  } else {\n+    if (NumProcessesWithName(dump_json, \""Renderer\"", nullptr) == 0) {\n+      LOG(ERROR) << \""There should be more than 1 renderer dump\"";\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+// Attempt to dump a gpu process.\n+// TODO(ajwong): Implement this.  http://crbug.com/780955\n+\n+}  // namespace profiling""}<_**next**_>{""sha"": ""3820e2a4a60faddc815643c0c47a5c86901c69d7"", ""filename"": ""chrome/browser/profiling_host/profiling_test_driver.h"", ""status"": ""added"", ""additions"": 118, ""deletions"": 0, ""changes"": 118, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/profiling_test_driver.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/profiling_test_driver.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/profiling_host/profiling_test_driver.h?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -0,0 +1,118 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef CHROME_BROWSER_PROFILING_HOST_PROFILING_TEST_DRIVER_H_\n+#define CHROME_BROWSER_PROFILING_HOST_PROFILING_TEST_DRIVER_H_\n+\n+#include <vector>\n+\n+#include \""base/allocator/partition_allocator/partition_alloc.h\""\n+#include \""base/macros.h\""\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/synchronization/waitable_event.h\""\n+#include \""chrome/browser/profiling_host/profiling_process_host.h\""\n+\n+namespace base {\n+class Value;\n+}  // namespace base\n+\n+namespace profiling {\n+\n+// This class runs tests for the profiling service, a cross-platform,\n+// multi-process component. Chrome on Android does not support browser_tests. It\n+// does support content_browsertests, but those are not multi-process tests. On\n+// Android, processes have to be started via the Activity mechanism, and the\n+// test infrastructure does not support this.\n+//\n+// To avoid test-code duplication, all tests are pulled into this class.\n+// browser_tests will directly call this class. The android\n+// chrome_public_test_apk will invoke this class via a JNI shim. Since the\n+// latter is not running within the gtest framework, this class cannot use\n+// EXPECT* and ASSERT* macros. Instead, this class will return a bool indicating\n+// success of the entire test. On failure, errors will be output via LOG(ERROR).\n+// These will show up in the browser_tests output stream, and will be captured\n+// by logcat [the Android logging facility]. The latter is already the canonical\n+// mechanism for investigating test failures.\n+//\n+// Note: Outputting to stderr will not have the desired effect, since that is\n+// not captured by logcat.\n+class ProfilingTestDriver {\n+ public:\n+  struct Options {\n+    // The profiling mode to test.\n+    ProfilingProcessHost::Mode mode;\n+\n+    // Whether the caller has already started profiling with the given mode.\n+    // TODO(erikchen): Implement and test the case where this member is false.\n+    // Starting profiling is an asynchronous operation, so this requires adding\n+    // some more plumbing. https://crbug.com/753218.\n+    bool profiling_already_started;\n+  };\n+\n+  ProfilingTestDriver();\n+  ~ProfilingTestDriver();\n+\n+  // If this is called on the content::BrowserThread::UI thread, then the\n+  // platform must support nested message loops. [This is currently not\n+  // supported on Android].\n+  //\n+  // Returns whether the test run was successful. Expectation/Assertion failures\n+  // will be printed via LOG(ERROR).\n+  bool RunTest(const Options& options);\n+\n+ private:\n+  // Populates |initialization_success_| with the result of\n+  // |RunInitializationOnUIThread|, and then signals |wait_for_ui_thread_|.\n+  void RunInitializationOnUIThreadAndSignal();\n+\n+  // Starts profiling. Makes allocations.\n+  bool RunInitializationOnUIThread();\n+\n+  // If profiling is expected to already be started, confirm it.\n+  // Otherwise, start profiling with the given mode.\n+  bool CheckOrStartProfiling();\n+\n+  // Performs allocations. These are expected to be profiled.\n+  void MakeTestAllocations();\n+\n+  // Collects a trace that contains a heap dump. The result is stored in\n+  // |serialized_trace_|.\n+  //\n+  // When |synchronous| is true, this method spins a nested message loop. When\n+  // |synchronous| is false, this method posts some tasks that will eventually\n+  // signal |wait_for_ui_thread_|.\n+  void CollectResults(bool synchronous);\n+\n+  bool ValidateBrowserAllocations(base::Value* dump_json);\n+  bool ValidateRendererAllocations(base::Value* dump_json);\n+\n+  Options options_;\n+\n+  // Allocations made by this class. Intentionally leaked, since deallocating\n+  // them would trigger a large number of IPCs, which is slow.\n+  std::vector<char*> leaks_;\n+\n+  // Sum of size of all variadic allocations.\n+  size_t total_variadic_allocations_ = 0;\n+\n+  // Use to make PA allocations, which should also be shimmed.\n+  base::PartitionAllocatorGeneric partition_allocator_;\n+\n+  // Contains nothing until |CollectResults| has been called.\n+  scoped_refptr<base::RefCountedString> serialized_trace_;\n+\n+  // Whether the test was invoked on the ui thread.\n+  bool running_on_ui_thread_ = true;\n+\n+  // Whether an error has occurred.\n+  bool initialization_success_ = false;\n+\n+  base::WaitableEvent wait_for_ui_thread_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(ProfilingTestDriver);\n+};\n+\n+}  // namespace profiling\n+\n+#endif  // CHROME_BROWSER_PROFILING_HOST_PROFILING_TEST_DRIVER_H_""}<_**next**_>{""sha"": ""1d0bcaadd1bb6aacd2203cf2579819e150e79233"", ""filename"": ""chrome/browser/profiling_host/test_android_shim.cc"", ""status"": ""added"", ""additions"": 38, ""deletions"": 0, ""changes"": 38, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/test_android_shim.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/test_android_shim.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/profiling_host/test_android_shim.cc?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -0,0 +1,38 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""chrome/browser/profiling_host/test_android_shim.h\""\n+\n+#include \""base/android/jni_string.h\""\n+#include \""chrome/browser/profiling_host/profiling_process_host.h\""\n+#include \""chrome/browser/profiling_host/profiling_test_driver.h\""\n+#include \""jni/TestAndroidShim_jni.h\""\n+\n+using base::android::JavaParamRef;\n+using base::android::ScopedJavaLocalRef;\n+\n+static jlong Init(JNIEnv* env, const JavaParamRef<jobject>& obj) {\n+  TestAndroidShim* profiler = new TestAndroidShim(env, obj);\n+  return reinterpret_cast<intptr_t>(profiler);\n+}\n+\n+TestAndroidShim::TestAndroidShim(JNIEnv* env, jobject obj) {}\n+\n+TestAndroidShim::~TestAndroidShim() {}\n+\n+void TestAndroidShim::Destroy(JNIEnv* env, const JavaParamRef<jobject>& obj) {\n+  delete this;\n+}\n+\n+jboolean TestAndroidShim::RunTestForMode(\n+    JNIEnv* env,\n+    const base::android::JavaParamRef<jobject>& obj,\n+    const base::android::JavaParamRef<jstring>& mode) {\n+  profiling::ProfilingTestDriver driver;\n+  profiling::ProfilingTestDriver::Options options;\n+  options.mode = profiling::ProfilingProcessHost::ConvertStringToMode(\n+      base::android::ConvertJavaStringToUTF8(mode));\n+  options.profiling_already_started = true;\n+  return driver.RunTest(options);\n+}""}<_**next**_>{""sha"": ""de6dd736477fd6beb1a8c02c96f66333f397a932"", ""filename"": ""chrome/browser/profiling_host/test_android_shim.h"", ""status"": ""added"", ""additions"": 30, ""deletions"": 0, ""changes"": 30, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/test_android_shim.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/test_android_shim.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/profiling_host/test_android_shim.h?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -0,0 +1,30 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef CHROME_BROWSER_PROFILING_HOST_TEST_ANDROID_SHIM_H_\n+#define CHROME_BROWSER_PROFILING_HOST_TEST_ANDROID_SHIM_H_\n+\n+#include \""base/android/jni_android.h\""\n+#include \""base/android/scoped_java_ref.h\""\n+#include \""base/macros.h\""\n+\n+// This class implements the native methods of TestAndroidShim.java,\n+// and acts as a bridge to ProfilingProcessHost. Note that this class is only\n+// used for testing.\n+class TestAndroidShim {\n+ public:\n+  TestAndroidShim(JNIEnv* env, jobject obj);\n+  void Destroy(JNIEnv* env, const base::android::JavaParamRef<jobject>& obj);\n+\n+  jboolean RunTestForMode(JNIEnv* env,\n+                          const base::android::JavaParamRef<jobject>& obj,\n+                          const base::android::JavaParamRef<jstring>&);\n+\n+ private:\n+  ~TestAndroidShim();\n+\n+  DISALLOW_COPY_AND_ASSIGN(TestAndroidShim);\n+};\n+\n+#endif  // CHROME_BROWSER_PROFILING_HOST_TEST_ANDROID_SHIM_H_""}<_**next**_>{""sha"": ""6f19fc5ff1c10a8b89fb6cbb93f05582bd4b4872"", ""filename"": ""chrome/test/android/javatests/src/org/chromium/chrome/test/ChromeActivityTestRule.java"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 3, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/test/android/javatests/src/org/chromium/chrome/test/ChromeActivityTestRule.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/test/android/javatests/src/org/chromium/chrome/test/ChromeActivityTestRule.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/android/javatests/src/org/chromium/chrome/test/ChromeActivityTestRule.java?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -411,9 +411,11 @@ public void startMainActivityFromIntent(Intent intent, String url) throws Interr\n      * Waits for the activity to fully finish it's native initialization.\n      */\n     public void waitForActivityNativeInitializationComplete() {\n-        CriteriaHelper.pollUiThread(() -> ChromeBrowserInitializer.getInstance(\n-                getActivity()).hasNativeInitializationCompleted(),\n-                \""Native initialization never finished\"", 2 * CriteriaHelper.DEFAULT_MAX_TIME_TO_POLL,\n+        CriteriaHelper.pollUiThread(()\n+                                            -> ChromeBrowserInitializer.getInstance(getActivity())\n+                                                       .hasNativeInitializationCompleted(),\n+                \""Native initialization never finished\"",\n+                20 * CriteriaHelper.DEFAULT_MAX_TIME_TO_POLL,\n                 CriteriaHelper.DEFAULT_POLLING_INTERVAL);\n \n         CriteriaHelper.pollUiThread(() -> getActivity().didFinishNativeInitialization(),""}","ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {
  const base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();
#if BUILDFLAG(USE_ALLOCATOR_SHIM)
  if (cmdline->HasSwitch(switches::kMemlog) ||
      base::FeatureList::IsEnabled(kOOPHeapProfilingFeature)) {
    if (cmdline->HasSwitch(switches::kEnableHeapProfiling)) {
      LOG(ERROR) << ""--"" << switches::kEnableHeapProfiling
                 << "" specified with --"" << switches::kMemlog
                 << ""which are not compatible. Memlog will be disabled."";
      return Mode::kNone;
    }

    std::string mode;
    if (cmdline->HasSwitch(switches::kMemlog)) {
      mode = cmdline->GetSwitchValueASCII(switches::kMemlog);
    } else {
      mode = base::GetFieldTrialParamValueByFeature(
           kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);
     }
 
    return ConvertStringToMode(mode);
   }
   return Mode::kNone;
 #else
  LOG_IF(ERROR, cmdline->HasSwitch(switches::kMemlog))
      << ""--"" << switches::kMemlog
      << "" specified but it will have no effect because the use_allocator_shim ""
      << ""is not available in this build."";
  return Mode::kNone;
 #endif
 }
","ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {
  const base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();
#if BUILDFLAG(USE_ALLOCATOR_SHIM)
  if (cmdline->HasSwitch(switches::kMemlog) ||
      base::FeatureList::IsEnabled(kOOPHeapProfilingFeature)) {
    if (cmdline->HasSwitch(switches::kEnableHeapProfiling)) {
      LOG(ERROR) << ""--"" << switches::kEnableHeapProfiling
                 << "" specified with --"" << switches::kMemlog
                 << ""which are not compatible. Memlog will be disabled."";
      return Mode::kNone;
    }

    std::string mode;
    if (cmdline->HasSwitch(switches::kMemlog)) {
      mode = cmdline->GetSwitchValueASCII(switches::kMemlog);
    } else {
      mode = base::GetFieldTrialParamValueByFeature(
           kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);
     }
 
    if (mode == switches::kMemlogModeAll)
      return Mode::kAll;
    if (mode == switches::kMemlogModeMinimal)
      return Mode::kMinimal;
    if (mode == switches::kMemlogModeBrowser)
      return Mode::kBrowser;
    if (mode == switches::kMemlogModeGpu)
      return Mode::kGpu;
    if (mode == switches::kMemlogModeRendererSampling)
      return Mode::kRendererSampling;
    DLOG(ERROR) << ""Unsupported value: \"""" << mode << ""\"" passed to --""
                << switches::kMemlog;
   }
   return Mode::kNone;
 #else
  LOG_IF(ERROR, cmdline->HasSwitch(switches::kMemlog))
      << ""--"" << switches::kMemlog
      << "" specified but it will have no effect because the use_allocator_shim ""
      << ""is not available in this build."";
  return Mode::kNone;
 #endif
 }
",C,"    return ConvertStringToMode(mode);
","    if (mode == switches::kMemlogModeAll)
      return Mode::kAll;
    if (mode == switches::kMemlogModeMinimal)
      return Mode::kMinimal;
    if (mode == switches::kMemlogModeBrowser)
      return Mode::kBrowser;
    if (mode == switches::kMemlogModeGpu)
      return Mode::kGpu;
    if (mode == switches::kMemlogModeRendererSampling)
      return Mode::kRendererSampling;
    DLOG(ERROR) << ""Unsupported value: \"""" << mode << ""\"" passed to --""
                << switches::kMemlog;
",,"@@ -371,19 +371,7 @@ ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {
           kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);
     }
 
-    if (mode == switches::kMemlogModeAll)
-      return Mode::kAll;
-    if (mode == switches::kMemlogModeMinimal)
-      return Mode::kMinimal;
-    if (mode == switches::kMemlogModeBrowser)
-      return Mode::kBrowser;
-    if (mode == switches::kMemlogModeGpu)
-      return Mode::kGpu;
-    if (mode == switches::kMemlogModeRendererSampling)
-      return Mode::kRendererSampling;
-
-    DLOG(ERROR) << ""Unsupported value: \"""" << mode << ""\"" passed to --""
-                << switches::kMemlog;
+    return ConvertStringToMode(mode);
   }
   return Mode::kNone;
 #else
@@ -395,6 +383,24 @@ ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {
 #endif
 }
 
+// static
+ProfilingProcessHost::Mode ProfilingProcessHost::ConvertStringToMode(
+    const std::string& mode) {
+  if (mode == switches::kMemlogModeAll)
+    return Mode::kAll;
+  if (mode == switches::kMemlogModeMinimal)
+    return Mode::kMinimal;
+  if (mode == switches::kMemlogModeBrowser)
+    return Mode::kBrowser;
+  if (mode == switches::kMemlogModeGpu)
+    return Mode::kGpu;
+  if (mode == switches::kMemlogModeRendererSampling)
+    return Mode::kRendererSampling;
+  DLOG(ERROR) << ""Unsupported value: \"""" << mode << ""\"" passed to --""
+              << switches::kMemlog;
+  return Mode::kNone;
+}
+
 // static
 ProfilingProcessHost* ProfilingProcessHost::Start(
     content::ServiceManagerConnection* connection,",Chrome,9d81094d7b0bfc8be6bba2f5084e790677e527c8,e9192c1e1bc0225603014ba83948a8cd2f1c64f4,1,"ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {
  const base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();
#if BUILDFLAG(USE_ALLOCATOR_SHIM)
  if (cmdline->HasSwitch(switches::kMemlog) ||
      base::FeatureList::IsEnabled(kOOPHeapProfilingFeature)) {
    if (cmdline->HasSwitch(switches::kEnableHeapProfiling)) {
      // PartitionAlloc doesn't support chained allocation hooks so we can't
      // run both heap profilers at the same time.
      LOG(ERROR) << ""--"" << switches::kEnableHeapProfiling
                 << "" specified with --"" << switches::kMemlog
                 << ""which are not compatible. Memlog will be disabled."";
      return Mode::kNone;
    }

    std::string mode;
    // Respect the commandline switch above the field trial.
    if (cmdline->HasSwitch(switches::kMemlog)) {
      mode = cmdline->GetSwitchValueASCII(switches::kMemlog);
    } else {
      mode = base::GetFieldTrialParamValueByFeature(
           kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);
     }
 
//flaw_line_below:
    if (mode == switches::kMemlogModeAll)
//flaw_line_below:
      return Mode::kAll;
//flaw_line_below:
    if (mode == switches::kMemlogModeMinimal)
//flaw_line_below:
      return Mode::kMinimal;
//flaw_line_below:
    if (mode == switches::kMemlogModeBrowser)
//flaw_line_below:
      return Mode::kBrowser;
//flaw_line_below:
    if (mode == switches::kMemlogModeGpu)
//flaw_line_below:
      return Mode::kGpu;
//flaw_line_below:
    if (mode == switches::kMemlogModeRendererSampling)
//flaw_line_below:
      return Mode::kRendererSampling;
//flaw_line_below:

//flaw_line_below:
    DLOG(ERROR) << ""Unsupported value: \"""" << mode << ""\"" passed to --""
//flaw_line_below:
                << switches::kMemlog;
//fix_flaw_line_below:
//    return ConvertStringToMode(mode);
   }
   return Mode::kNone;
 #else
  LOG_IF(ERROR, cmdline->HasSwitch(switches::kMemlog))
      << ""--"" << switches::kMemlog
      << "" specified but it will have no effect because the use_allocator_shim ""
      << ""is not available in this build."";
  return Mode::kNone;
 #endif
 }
",186901,"ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {
  const base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();
#if BUILDFLAG(USE_ALLOCATOR_SHIM)
  if (cmdline->HasSwitch(switches::kMemlog) ||
      base::FeatureList::IsEnabled(kOOPHeapProfilingFeature)) {
    if (cmdline->HasSwitch(switches::kEnableHeapProfiling)) {
      LOG(ERROR) << ""--"" << switches::kEnableHeapProfiling
                 << "" specified with --"" << switches::kMemlog
                 << ""which are not compatible. Memlog will be disabled."";
      return Mode::kNone;
    }

    std::string mode;
    if (cmdline->HasSwitch(switches::kMemlog)) {
      mode = cmdline->GetSwitchValueASCII(switches::kMemlog);
    } else {
      mode = base::GetFieldTrialParamValueByFeature(
           kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);
     }
 
    if (mode == switches::kMemlogModeAll)
      return Mode::kAll;
    if (mode == switches::kMemlogModeMinimal)
      return Mode::kMinimal;
    if (mode == switches::kMemlogModeBrowser)
      return Mode::kBrowser;
    if (mode == switches::kMemlogModeGpu)
      return Mode::kGpu;
    if (mode == switches::kMemlogModeRendererSampling)
      return Mode::kRendererSampling;
    DLOG(ERROR) << ""Unsupported value: \"""" << mode << ""\"" passed to --""
                << switches::kMemlog;
   }
   return Mode::kNone;
 #else
  LOG_IF(ERROR, cmdline->HasSwitch(switches::kMemlog))
      << ""--"" << switches::kMemlog
      << "" specified but it will have no effect because the use_allocator_shim ""
      << ""is not available in this build."";
  return Mode::kNone;
 #endif
 }
","ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {
  const base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();
#if BUILDFLAG(USE_ALLOCATOR_SHIM)
  if (cmdline->HasSwitch(switches::kMemlog) ||
      base::FeatureList::IsEnabled(kOOPHeapProfilingFeature)) {
    if (cmdline->HasSwitch(switches::kEnableHeapProfiling)) {
      LOG(ERROR) << ""--"" << switches::kEnableHeapProfiling
                 << "" specified with --"" << switches::kMemlog
                 << ""which are not compatible. Memlog will be disabled."";
      return Mode::kNone;
    }

    std::string mode;
    if (cmdline->HasSwitch(switches::kMemlog)) {
      mode = cmdline->GetSwitchValueASCII(switches::kMemlog);
    } else {
      mode = base::GetFieldTrialParamValueByFeature(
           kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);
     }
 
    return ConvertStringToMode(mode);
   }
   return Mode::kNone;
 #else
  LOG_IF(ERROR, cmdline->HasSwitch(switches::kMemlog))
      << ""--"" << switches::kMemlog
      << "" specified but it will have no effect because the use_allocator_shim ""
      << ""is not available in this build."";
  return Mode::kNone;
 #endif
 }
","The vulnerability in the original code lies in the repetitive conditional checks for the `mode` variable, which could lead to errors if unsupported values are passed to the `--memlog` switch. Specifically, if an unsupported value is provided, the code only logs an error without a clear mechanism to handle it, potentially causing undefined behavior. In the fixed code, this issue is addressed by introducing the `ConvertStringToMode(mode)` function, which centralizes the conversion logic and likely includes error handling for unsupported values, ensuring that the function consistently returns a valid `Mode` or handles errors appropriately.","The vulnerability in the original code stems from inadequate handling of unsupported input values, which could lead to undefined behavior or incorrect program states. Specifically, when an unsupported value is passed, the code only logs an error message without providing a robust mechanism to manage such cases, potentially resulting in unexpected outcomes. The revised code addresses this issue by implementing a dedicated function that centralizes the conversion process and likely incorporates error handling for invalid inputs. This change ensures that the program consistently returns a valid state or appropriately manages errors, enhancing overall stability and reliability."
78,186920,186920,,Remote,Not required,Partial,CVE-2017-5129,https://www.cvedetails.com/cve/CVE-2017-5129/,CWE-416,Medium,Partial,Partial,,2018-02-07,6.8,A use after free in WebAudio in Blink in Google Chrome prior to 62.0.3202.62 allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page.,2018-02-22,,10,https://github.com/chromium/chromium/commit/783c28d59c4c748ef9b787d4717882c90c5b227b,783c28d59c4c748ef9b787d4717882c90c5b227b,"Keep ScriptProcessorHandler alive across threads

When posting a task from the ScriptProcessorHandler::Process to fire a
process event, we need to keep the handler alive in case the
ScriptProcessorNode goes away (because it has no onaudioprocess
handler) and removes the its handler.

Bug: 765495
Test: 
Change-Id: Ib4fa39d7b112c7051897700a1eff9f59a4a7a054
Reviewed-on: https://chromium-review.googlesource.com/677137
Reviewed-by: Hongchan Choi <hongchan@chromium.org>
Reviewed-by: Kentaro Hara <haraken@chromium.org>
Commit-Queue: Raymond Toy <rtoy@chromium.org>
Cr-Commit-Position: refs/heads/master@{#503629}",10,third_party/WebKit/Source/modules/webaudio/ScriptProcessorNode.cpp,"{""sha"": ""b731acf63f4e784fc72a7ad568e85bcb80c7e3f5"", ""filename"": ""third_party/WebKit/Source/modules/webaudio/ScriptProcessorNode.cpp"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 10, ""changes"": 20, ""blob_url"": ""https://github.com/chromium/chromium/blob/783c28d59c4c748ef9b787d4717882c90c5b227b/third_party/WebKit/Source/modules/webaudio/ScriptProcessorNode.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/783c28d59c4c748ef9b787d4717882c90c5b227b/third_party/WebKit/Source/modules/webaudio/ScriptProcessorNode.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/webaudio/ScriptProcessorNode.cpp?ref=783c28d59c4c748ef9b787d4717882c90c5b227b"", ""patch"": ""@@ -216,10 +216,10 @@ void ScriptProcessorHandler::Process(size_t frames_to_process) {\n         // index.\n         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,\n                               Context()->GetExecutionContext())\n-            ->PostTask(BLINK_FROM_HERE,\n-                       CrossThreadBind(\n-                           &ScriptProcessorHandler::FireProcessEvent,\n-                           CrossThreadUnretained(this), double_buffer_index_));\n+            ->PostTask(\n+                BLINK_FROM_HERE,\n+                CrossThreadBind(&ScriptProcessorHandler::FireProcessEvent,\n+                                WrapRefPtr(this), double_buffer_index_));\n       } else {\n         // If this node is in the offline audio context, use the\n         // waitable event to synchronize to the offline rendering thread.\n@@ -228,12 +228,12 @@ void ScriptProcessorHandler::Process(size_t frames_to_process) {\n \n         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,\n                               Context()->GetExecutionContext())\n-            ->PostTask(BLINK_FROM_HERE,\n-                       CrossThreadBind(\n-                           &ScriptProcessorHandler::\n-                               FireProcessEventForOfflineAudioContext,\n-                           CrossThreadUnretained(this), double_buffer_index_,\n-                           CrossThreadUnretained(waitable_event.get())));\n+            ->PostTask(\n+                BLINK_FROM_HERE,\n+                CrossThreadBind(&ScriptProcessorHandler::\n+                                    FireProcessEventForOfflineAudioContext,\n+                                WrapRefPtr(this), double_buffer_index_,\n+                                CrossThreadUnretained(waitable_event.get())));\n \n         // Okay to block the offline audio rendering thread since it is\n         // not the actual audio device thread.""}","void ScriptProcessorHandler::Process(size_t frames_to_process) {

  AudioBus* input_bus = Input(0).Bus();
  AudioBus* output_bus = Output(0).Bus();

  unsigned double_buffer_index = this->DoubleBufferIndex();
  bool is_double_buffer_index_good =
      double_buffer_index < 2 && double_buffer_index < input_buffers_.size() &&
      double_buffer_index < output_buffers_.size();
  DCHECK(is_double_buffer_index_good);
  if (!is_double_buffer_index_good)
    return;

  AudioBuffer* input_buffer = input_buffers_[double_buffer_index].Get();
  AudioBuffer* output_buffer = output_buffers_[double_buffer_index].Get();

  unsigned number_of_input_channels = internal_input_bus_->NumberOfChannels();
  bool buffers_are_good =
      output_buffer && BufferSize() == output_buffer->length() &&
      buffer_read_write_index_ + frames_to_process <= BufferSize();

  if (internal_input_bus_->NumberOfChannels())
    buffers_are_good = buffers_are_good && input_buffer &&
                       BufferSize() == input_buffer->length();

  DCHECK(buffers_are_good);
  if (!buffers_are_good)
    return;

  bool is_frames_to_process_good = frames_to_process &&
                                   BufferSize() >= frames_to_process &&
                                   !(BufferSize() % frames_to_process);
  DCHECK(is_frames_to_process_good);
  if (!is_frames_to_process_good)
    return;

  unsigned number_of_output_channels = output_bus->NumberOfChannels();

  bool channels_are_good =
      (number_of_input_channels == number_of_input_channels_) &&
      (number_of_output_channels == number_of_output_channels_);
  DCHECK(channels_are_good);
  if (!channels_are_good)
    return;

  for (unsigned i = 0; i < number_of_input_channels; ++i)
    internal_input_bus_->SetChannelMemory(
        i,
        input_buffer->getChannelData(i).View()->Data() +
            buffer_read_write_index_,
        frames_to_process);

  if (number_of_input_channels)
    internal_input_bus_->CopyFrom(*input_bus);

  for (unsigned i = 0; i < number_of_output_channels; ++i) {
    memcpy(output_bus->Channel(i)->MutableData(),
           output_buffer->getChannelData(i).View()->Data() +
               buffer_read_write_index_,
           sizeof(float) * frames_to_process);
  }

  buffer_read_write_index_ =
      (buffer_read_write_index_ + frames_to_process) % BufferSize();

  if (!buffer_read_write_index_) {
    MutexTryLocker try_locker(process_event_lock_);
    if (!try_locker.Locked()) {
      output_buffer->Zero();
    } else if (Context()->GetExecutionContext()) {
      if (Context()->HasRealtimeConstraint()) {
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
            ->PostTask(
                BLINK_FROM_HERE,
                CrossThreadBind(&ScriptProcessorHandler::FireProcessEvent,
                                WrapRefPtr(this), double_buffer_index_));
       } else {
        std::unique_ptr<WaitableEvent> waitable_event =
            WTF::MakeUnique<WaitableEvent>();
 
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
            ->PostTask(
                BLINK_FROM_HERE,
                CrossThreadBind(&ScriptProcessorHandler::
                                    FireProcessEventForOfflineAudioContext,
                                WrapRefPtr(this), double_buffer_index_,
                                CrossThreadUnretained(waitable_event.get())));
 
        waitable_event->Wait();
      }
    }

    SwapBuffers();
  }
}
","void ScriptProcessorHandler::Process(size_t frames_to_process) {

  AudioBus* input_bus = Input(0).Bus();
  AudioBus* output_bus = Output(0).Bus();

  unsigned double_buffer_index = this->DoubleBufferIndex();
  bool is_double_buffer_index_good =
      double_buffer_index < 2 && double_buffer_index < input_buffers_.size() &&
      double_buffer_index < output_buffers_.size();
  DCHECK(is_double_buffer_index_good);
  if (!is_double_buffer_index_good)
    return;

  AudioBuffer* input_buffer = input_buffers_[double_buffer_index].Get();
  AudioBuffer* output_buffer = output_buffers_[double_buffer_index].Get();

  unsigned number_of_input_channels = internal_input_bus_->NumberOfChannels();
  bool buffers_are_good =
      output_buffer && BufferSize() == output_buffer->length() &&
      buffer_read_write_index_ + frames_to_process <= BufferSize();

  if (internal_input_bus_->NumberOfChannels())
    buffers_are_good = buffers_are_good && input_buffer &&
                       BufferSize() == input_buffer->length();

  DCHECK(buffers_are_good);
  if (!buffers_are_good)
    return;

  bool is_frames_to_process_good = frames_to_process &&
                                   BufferSize() >= frames_to_process &&
                                   !(BufferSize() % frames_to_process);
  DCHECK(is_frames_to_process_good);
  if (!is_frames_to_process_good)
    return;

  unsigned number_of_output_channels = output_bus->NumberOfChannels();

  bool channels_are_good =
      (number_of_input_channels == number_of_input_channels_) &&
      (number_of_output_channels == number_of_output_channels_);
  DCHECK(channels_are_good);
  if (!channels_are_good)
    return;

  for (unsigned i = 0; i < number_of_input_channels; ++i)
    internal_input_bus_->SetChannelMemory(
        i,
        input_buffer->getChannelData(i).View()->Data() +
            buffer_read_write_index_,
        frames_to_process);

  if (number_of_input_channels)
    internal_input_bus_->CopyFrom(*input_bus);

  for (unsigned i = 0; i < number_of_output_channels; ++i) {
    memcpy(output_bus->Channel(i)->MutableData(),
           output_buffer->getChannelData(i).View()->Data() +
               buffer_read_write_index_,
           sizeof(float) * frames_to_process);
  }

  buffer_read_write_index_ =
      (buffer_read_write_index_ + frames_to_process) % BufferSize();

  if (!buffer_read_write_index_) {
    MutexTryLocker try_locker(process_event_lock_);
    if (!try_locker.Locked()) {
      output_buffer->Zero();
    } else if (Context()->GetExecutionContext()) {
      if (Context()->HasRealtimeConstraint()) {
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
            ->PostTask(BLINK_FROM_HERE,
                       CrossThreadBind(
                           &ScriptProcessorHandler::FireProcessEvent,
                           CrossThreadUnretained(this), double_buffer_index_));
       } else {
        std::unique_ptr<WaitableEvent> waitable_event =
            WTF::MakeUnique<WaitableEvent>();
 
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
            ->PostTask(BLINK_FROM_HERE,
                       CrossThreadBind(
                           &ScriptProcessorHandler::
                               FireProcessEventForOfflineAudioContext,
                           CrossThreadUnretained(this), double_buffer_index_,
                           CrossThreadUnretained(waitable_event.get())));
 
        waitable_event->Wait();
      }
    }

    SwapBuffers();
  }
}
",C,"            ->PostTask(
                BLINK_FROM_HERE,
                CrossThreadBind(&ScriptProcessorHandler::FireProcessEvent,
                                WrapRefPtr(this), double_buffer_index_));
            ->PostTask(
                BLINK_FROM_HERE,
                CrossThreadBind(&ScriptProcessorHandler::
                                    FireProcessEventForOfflineAudioContext,
                                WrapRefPtr(this), double_buffer_index_,
                                CrossThreadUnretained(waitable_event.get())));
","            ->PostTask(BLINK_FROM_HERE,
                       CrossThreadBind(
                           &ScriptProcessorHandler::FireProcessEvent,
                           CrossThreadUnretained(this), double_buffer_index_));
            ->PostTask(BLINK_FROM_HERE,
                       CrossThreadBind(
                           &ScriptProcessorHandler::
                               FireProcessEventForOfflineAudioContext,
                           CrossThreadUnretained(this), double_buffer_index_,
                           CrossThreadUnretained(waitable_event.get())));
",,"@@ -216,10 +216,10 @@ void ScriptProcessorHandler::Process(size_t frames_to_process) {
         // index.
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
-            ->PostTask(BLINK_FROM_HERE,
-                       CrossThreadBind(
-                           &ScriptProcessorHandler::FireProcessEvent,
-                           CrossThreadUnretained(this), double_buffer_index_));
+            ->PostTask(
+                BLINK_FROM_HERE,
+                CrossThreadBind(&ScriptProcessorHandler::FireProcessEvent,
+                                WrapRefPtr(this), double_buffer_index_));
       } else {
         // If this node is in the offline audio context, use the
         // waitable event to synchronize to the offline rendering thread.
@@ -228,12 +228,12 @@ void ScriptProcessorHandler::Process(size_t frames_to_process) {
 
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
-            ->PostTask(BLINK_FROM_HERE,
-                       CrossThreadBind(
-                           &ScriptProcessorHandler::
-                               FireProcessEventForOfflineAudioContext,
-                           CrossThreadUnretained(this), double_buffer_index_,
-                           CrossThreadUnretained(waitable_event.get())));
+            ->PostTask(
+                BLINK_FROM_HERE,
+                CrossThreadBind(&ScriptProcessorHandler::
+                                    FireProcessEventForOfflineAudioContext,
+                                WrapRefPtr(this), double_buffer_index_,
+                                CrossThreadUnretained(waitable_event.get())));
 
         // Okay to block the offline audio rendering thread since it is
         // not the actual audio device thread.",Chrome,783c28d59c4c748ef9b787d4717882c90c5b227b,ee2b98599aa8ee52b90efa40fc7c9ebecf42d548,1,"void ScriptProcessorHandler::Process(size_t frames_to_process) {
  // Discussion about inputs and outputs:
  // As in other AudioNodes, ScriptProcessorNode uses an AudioBus for its input
  // and output (see inputBus and outputBus below).  Additionally, there is a
  // double-buffering for input and output which is exposed directly to
  // JavaScript (see inputBuffer and outputBuffer below).  This node is the
  // producer for inputBuffer and the consumer for outputBuffer.  The JavaScript
  // code is the consumer of inputBuffer and the producer for outputBuffer.

  // Get input and output busses.
  AudioBus* input_bus = Input(0).Bus();
  AudioBus* output_bus = Output(0).Bus();

  // Get input and output buffers. We double-buffer both the input and output
  // sides.
  unsigned double_buffer_index = this->DoubleBufferIndex();
  bool is_double_buffer_index_good =
      double_buffer_index < 2 && double_buffer_index < input_buffers_.size() &&
      double_buffer_index < output_buffers_.size();
  DCHECK(is_double_buffer_index_good);
  if (!is_double_buffer_index_good)
    return;

  AudioBuffer* input_buffer = input_buffers_[double_buffer_index].Get();
  AudioBuffer* output_buffer = output_buffers_[double_buffer_index].Get();

  // Check the consistency of input and output buffers.
  unsigned number_of_input_channels = internal_input_bus_->NumberOfChannels();
  bool buffers_are_good =
      output_buffer && BufferSize() == output_buffer->length() &&
      buffer_read_write_index_ + frames_to_process <= BufferSize();

  // If the number of input channels is zero, it's ok to have inputBuffer = 0.
  if (internal_input_bus_->NumberOfChannels())
    buffers_are_good = buffers_are_good && input_buffer &&
                       BufferSize() == input_buffer->length();

  DCHECK(buffers_are_good);
  if (!buffers_are_good)
    return;

  // We assume that bufferSize() is evenly divisible by framesToProcess - should
  // always be true, but we should still check.
  bool is_frames_to_process_good = frames_to_process &&
                                   BufferSize() >= frames_to_process &&
                                   !(BufferSize() % frames_to_process);
  DCHECK(is_frames_to_process_good);
  if (!is_frames_to_process_good)
    return;

  unsigned number_of_output_channels = output_bus->NumberOfChannels();

  bool channels_are_good =
      (number_of_input_channels == number_of_input_channels_) &&
      (number_of_output_channels == number_of_output_channels_);
  DCHECK(channels_are_good);
  if (!channels_are_good)
    return;

  for (unsigned i = 0; i < number_of_input_channels; ++i)
    internal_input_bus_->SetChannelMemory(
        i,
        input_buffer->getChannelData(i).View()->Data() +
            buffer_read_write_index_,
        frames_to_process);

  if (number_of_input_channels)
    internal_input_bus_->CopyFrom(*input_bus);

  // Copy from the output buffer to the output.
  for (unsigned i = 0; i < number_of_output_channels; ++i) {
    memcpy(output_bus->Channel(i)->MutableData(),
           output_buffer->getChannelData(i).View()->Data() +
               buffer_read_write_index_,
           sizeof(float) * frames_to_process);
  }

  // Update the buffering index.
  buffer_read_write_index_ =
      (buffer_read_write_index_ + frames_to_process) % BufferSize();

  // m_bufferReadWriteIndex will wrap back around to 0 when the current input
  // and output buffers are full.
  // When this happens, fire an event and swap buffers.
  if (!buffer_read_write_index_) {
    // Avoid building up requests on the main thread to fire process events when
    // they're not being handled.  This could be a problem if the main thread is
    // very busy doing other things and is being held up handling previous
    // requests.  The audio thread can't block on this lock, so we call
    // tryLock() instead.
    MutexTryLocker try_locker(process_event_lock_);
    if (!try_locker.Locked()) {
      // We're late in handling the previous request. The main thread must be
      // very busy.  The best we can do is clear out the buffer ourself here.
      output_buffer->Zero();
    } else if (Context()->GetExecutionContext()) {
      // With the realtime context, execute the script code asynchronously
      // and do not wait.
      if (Context()->HasRealtimeConstraint()) {
        // Fire the event on the main thread with the appropriate buffer
         // index.
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
//flaw_line_below:
            ->PostTask(BLINK_FROM_HERE,
//flaw_line_below:
                       CrossThreadBind(
//flaw_line_below:
                           &ScriptProcessorHandler::FireProcessEvent,
//flaw_line_below:
                           CrossThreadUnretained(this), double_buffer_index_));
//fix_flaw_line_below:
//            ->PostTask(
//fix_flaw_line_below:
//                BLINK_FROM_HERE,
//fix_flaw_line_below:
//                CrossThreadBind(&ScriptProcessorHandler::FireProcessEvent,
//fix_flaw_line_below:
//                                WrapRefPtr(this), double_buffer_index_));
       } else {
         // If this node is in the offline audio context, use the
         // waitable event to synchronize to the offline rendering thread.
        std::unique_ptr<WaitableEvent> waitable_event =
            WTF::MakeUnique<WaitableEvent>();
 
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
//flaw_line_below:
            ->PostTask(BLINK_FROM_HERE,
//flaw_line_below:
                       CrossThreadBind(
//flaw_line_below:
                           &ScriptProcessorHandler::
//flaw_line_below:
                               FireProcessEventForOfflineAudioContext,
//flaw_line_below:
                           CrossThreadUnretained(this), double_buffer_index_,
//flaw_line_below:
                           CrossThreadUnretained(waitable_event.get())));
//fix_flaw_line_below:
//            ->PostTask(
//fix_flaw_line_below:
//                BLINK_FROM_HERE,
//fix_flaw_line_below:
//                CrossThreadBind(&ScriptProcessorHandler::
//fix_flaw_line_below:
//                                    FireProcessEventForOfflineAudioContext,
//fix_flaw_line_below:
//                                WrapRefPtr(this), double_buffer_index_,
//fix_flaw_line_below:
//                                CrossThreadUnretained(waitable_event.get())));
 
         // Okay to block the offline audio rendering thread since it is
         // not the actual audio device thread.
        waitable_event->Wait();
      }
    }

    SwapBuffers();
  }
}
",186920,"void ScriptProcessorHandler::Process(size_t frames_to_process) {

  AudioBus* input_bus = Input(0).Bus();
  AudioBus* output_bus = Output(0).Bus();

  unsigned double_buffer_index = this->DoubleBufferIndex();
  bool is_double_buffer_index_good =
      double_buffer_index < 2 && double_buffer_index < input_buffers_.size() &&
      double_buffer_index < output_buffers_.size();
  DCHECK(is_double_buffer_index_good);
  if (!is_double_buffer_index_good)
    return;

  AudioBuffer* input_buffer = input_buffers_[double_buffer_index].Get();
  AudioBuffer* output_buffer = output_buffers_[double_buffer_index].Get();

  unsigned number_of_input_channels = internal_input_bus_->NumberOfChannels();
  bool buffers_are_good =
      output_buffer && BufferSize() == output_buffer->length() &&
      buffer_read_write_index_ + frames_to_process <= BufferSize();

  if (internal_input_bus_->NumberOfChannels())
    buffers_are_good = buffers_are_good && input_buffer &&
                       BufferSize() == input_buffer->length();

  DCHECK(buffers_are_good);
  if (!buffers_are_good)
    return;

  bool is_frames_to_process_good = frames_to_process &&
                                   BufferSize() >= frames_to_process &&
                                   !(BufferSize() % frames_to_process);
  DCHECK(is_frames_to_process_good);
  if (!is_frames_to_process_good)
    return;

  unsigned number_of_output_channels = output_bus->NumberOfChannels();

  bool channels_are_good =
      (number_of_input_channels == number_of_input_channels_) &&
      (number_of_output_channels == number_of_output_channels_);
  DCHECK(channels_are_good);
  if (!channels_are_good)
    return;

  for (unsigned i = 0; i < number_of_input_channels; ++i)
    internal_input_bus_->SetChannelMemory(
        i,
        input_buffer->getChannelData(i).View()->Data() +
            buffer_read_write_index_,
        frames_to_process);

  if (number_of_input_channels)
    internal_input_bus_->CopyFrom(*input_bus);

  for (unsigned i = 0; i < number_of_output_channels; ++i) {
    memcpy(output_bus->Channel(i)->MutableData(),
           output_buffer->getChannelData(i).View()->Data() +
               buffer_read_write_index_,
           sizeof(float) * frames_to_process);
  }

  buffer_read_write_index_ =
      (buffer_read_write_index_ + frames_to_process) % BufferSize();

  if (!buffer_read_write_index_) {
    MutexTryLocker try_locker(process_event_lock_);
    if (!try_locker.Locked()) {
      output_buffer->Zero();
    } else if (Context()->GetExecutionContext()) {
      if (Context()->HasRealtimeConstraint()) {
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
            ->PostTask(BLINK_FROM_HERE,
                       CrossThreadBind(
                           &ScriptProcessorHandler::FireProcessEvent,
                           CrossThreadUnretained(this), double_buffer_index_));
       } else {
        std::unique_ptr<WaitableEvent> waitable_event =
            WTF::MakeUnique<WaitableEvent>();
 
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
            ->PostTask(BLINK_FROM_HERE,
                       CrossThreadBind(
                           &ScriptProcessorHandler::
                               FireProcessEventForOfflineAudioContext,
                           CrossThreadUnretained(this), double_buffer_index_,
                           CrossThreadUnretained(waitable_event.get())));
 
        waitable_event->Wait();
      }
    }

    SwapBuffers();
  }
}
","void ScriptProcessorHandler::Process(size_t frames_to_process) {

  AudioBus* input_bus = Input(0).Bus();
  AudioBus* output_bus = Output(0).Bus();

  unsigned double_buffer_index = this->DoubleBufferIndex();
  bool is_double_buffer_index_good =
      double_buffer_index < 2 && double_buffer_index < input_buffers_.size() &&
      double_buffer_index < output_buffers_.size();
  DCHECK(is_double_buffer_index_good);
  if (!is_double_buffer_index_good)
    return;

  AudioBuffer* input_buffer = input_buffers_[double_buffer_index].Get();
  AudioBuffer* output_buffer = output_buffers_[double_buffer_index].Get();

  unsigned number_of_input_channels = internal_input_bus_->NumberOfChannels();
  bool buffers_are_good =
      output_buffer && BufferSize() == output_buffer->length() &&
      buffer_read_write_index_ + frames_to_process <= BufferSize();

  if (internal_input_bus_->NumberOfChannels())
    buffers_are_good = buffers_are_good && input_buffer &&
                       BufferSize() == input_buffer->length();

  DCHECK(buffers_are_good);
  if (!buffers_are_good)
    return;

  bool is_frames_to_process_good = frames_to_process &&
                                   BufferSize() >= frames_to_process &&
                                   !(BufferSize() % frames_to_process);
  DCHECK(is_frames_to_process_good);
  if (!is_frames_to_process_good)
    return;

  unsigned number_of_output_channels = output_bus->NumberOfChannels();

  bool channels_are_good =
      (number_of_input_channels == number_of_input_channels_) &&
      (number_of_output_channels == number_of_output_channels_);
  DCHECK(channels_are_good);
  if (!channels_are_good)
    return;

  for (unsigned i = 0; i < number_of_input_channels; ++i)
    internal_input_bus_->SetChannelMemory(
        i,
        input_buffer->getChannelData(i).View()->Data() +
            buffer_read_write_index_,
        frames_to_process);

  if (number_of_input_channels)
    internal_input_bus_->CopyFrom(*input_bus);

  for (unsigned i = 0; i < number_of_output_channels; ++i) {
    memcpy(output_bus->Channel(i)->MutableData(),
           output_buffer->getChannelData(i).View()->Data() +
               buffer_read_write_index_,
           sizeof(float) * frames_to_process);
  }

  buffer_read_write_index_ =
      (buffer_read_write_index_ + frames_to_process) % BufferSize();

  if (!buffer_read_write_index_) {
    MutexTryLocker try_locker(process_event_lock_);
    if (!try_locker.Locked()) {
      output_buffer->Zero();
    } else if (Context()->GetExecutionContext()) {
      if (Context()->HasRealtimeConstraint()) {
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
            ->PostTask(
                BLINK_FROM_HERE,
                CrossThreadBind(&ScriptProcessorHandler::FireProcessEvent,
                                WrapRefPtr(this), double_buffer_index_));
       } else {
        std::unique_ptr<WaitableEvent> waitable_event =
            WTF::MakeUnique<WaitableEvent>();
 
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
            ->PostTask(
                BLINK_FROM_HERE,
                CrossThreadBind(&ScriptProcessorHandler::
                                    FireProcessEventForOfflineAudioContext,
                                WrapRefPtr(this), double_buffer_index_,
                                CrossThreadUnretained(waitable_event.get())));
 
        waitable_event->Wait();
      }
    }

    SwapBuffers();
  }
}
","The vulnerability in the original code lies in the potential for a race condition when accessing shared resources, particularly during the execution of `FireProcessEvent` and `FireProcessEventForOfflineAudioContext`. If `this` is accessed concurrently from multiple threads, it could lead to undefined behavior or crashes. The fix in the modified code replaces `CrossThreadUnretained(this)` with `WrapRefPtr(this)`, which ensures that the reference to `this` is safely managed across threads. This change prevents the possibility of dereferencing a dangling pointer, thereby enhancing the thread safety of the `ScriptProcessorHandler` class.","The vulnerability in the original code stems from the potential for a race condition when accessing shared resources across multiple threads, which could lead to undefined behavior or crashes. This occurs when the code attempts to use a reference to an object that may have been deleted or modified by another thread. The fix in the modified code addresses this issue by implementing a safer reference management strategy, ensuring that the object remains valid during cross-thread operations. This change enhances the overall thread safety of the implementation, preventing the risks associated with dangling pointers and concurrent access."
79,186942,186942,,Remote,Not required,Partial,CVE-2019-5828,https://www.cvedetails.com/cve/CVE-2019-5828/,CWE-416,Medium,Partial,Partial,,2019-06-27,6.8,Object lifecycle issue in ServiceWorker in Google Chrome prior to 75.0.3770.80 allowed a remote attacker to potentially perform out of bounds memory access via a crafted HTML page.,2019-07-25,,0,https://github.com/chromium/chromium/commit/761d65ebcac0cdb730fd27b87e207201ac38e3b4,761d65ebcac0cdb730fd27b87e207201ac38e3b4,"[Payment Handler] Don't wait for response from closed payment app.

Before this patch, tapping the back button on top of the payment handler
window on desktop would not affect the |response_helper_|, which would
continue waiting for a response from the payment app. The service worker
of the closed payment app could timeout after 5 minutes and invoke the
|response_helper_|. Depending on what else the user did afterwards, in
the best case scenario, the payment sheet would display a ""Transaction
failed"" error message. In the worst case scenario, the
|response_helper_| would be used after free.

This patch clears the |response_helper_| in the PaymentRequestState and
in the ServiceWorkerPaymentInstrument after the payment app is closed.

After this patch, the cancelled payment app does not show ""Transaction
failed"" and does not use memory after it was freed.

Bug: 956597
Change-Id: I64134b911a4f8c154cb56d537a8243a68a806394
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1588682
Reviewed-by: anthonyvd <anthonyvd@chromium.org>
Commit-Queue: Rouslan Solomakhin <rouslan@chromium.org>
Cr-Commit-Position: refs/heads/master@{#654995}",1,components/payments/content/service_worker_payment_instrument.cc,"{""sha"": ""69d1e0a1b5e3a0c8117b3d2e40391ec728019455"", ""filename"": ""chrome/browser/ui/views/payments/payment_handler_web_flow_view_controller.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/761d65ebcac0cdb730fd27b87e207201ac38e3b4/chrome/browser/ui/views/payments/payment_handler_web_flow_view_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/761d65ebcac0cdb730fd27b87e207201ac38e3b4/chrome/browser/ui/views/payments/payment_handler_web_flow_view_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/payments/payment_handler_web_flow_view_controller.cc?ref=761d65ebcac0cdb730fd27b87e207201ac38e3b4"", ""patch"": ""@@ -188,7 +188,9 @@ PaymentHandlerWebFlowViewController::PaymentHandlerWebFlowViewController(\n       ui::NativeTheme::kColorId_SeparatorColor));\n }\n \n-PaymentHandlerWebFlowViewController::~PaymentHandlerWebFlowViewController() {}\n+PaymentHandlerWebFlowViewController::~PaymentHandlerWebFlowViewController() {\n+  state()->OnPaymentAppWindowClosed();\n+}\n \n base::string16 PaymentHandlerWebFlowViewController::GetSheetTitle() {\n   return GetPaymentHandlerDialogTitle(web_contents(), https_prefix_);""}<_**next**_>{""sha"": ""26f8b78aa7fe960306bc7edfec2558f2edf46851"", ""filename"": ""components/payments/content/payment_request_state.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/761d65ebcac0cdb730fd27b87e207201ac38e3b4/components/payments/content/payment_request_state.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/761d65ebcac0cdb730fd27b87e207201ac38e3b4/components/payments/content/payment_request_state.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/payments/content/payment_request_state.cc?ref=761d65ebcac0cdb730fd27b87e207201ac38e3b4"", ""patch"": ""@@ -304,6 +304,12 @@ void PaymentRequestState::GeneratePaymentResponse() {\n       selected_shipping_profile_, selected_contact_profile_, this);\n }\n \n+void PaymentRequestState::OnPaymentAppWindowClosed() {\n+  DCHECK(selected_instrument_);\n+  response_helper_.reset();\n+  selected_instrument_->OnPaymentAppWindowClosed();\n+}\n+\n void PaymentRequestState::RecordUseStats() {\n   if (spec_->request_shipping()) {\n     DCHECK(selected_shipping_profile_);""}<_**next**_>{""sha"": ""75aaec22ae6dae9c00f0cca45639424b3218567c"", ""filename"": ""components/payments/content/payment_request_state.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/761d65ebcac0cdb730fd27b87e207201ac38e3b4/components/payments/content/payment_request_state.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/761d65ebcac0cdb730fd27b87e207201ac38e3b4/components/payments/content/payment_request_state.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/payments/content/payment_request_state.h?ref=761d65ebcac0cdb730fd27b87e207201ac38e3b4"", ""patch"": ""@@ -126,6 +126,9 @@ class PaymentRequestState : public PaymentResponseHelper::Delegate,\n   // |is_ready_to_pay|, which is inexpensive.\n   void GeneratePaymentResponse();\n \n+  // Cancels the generation of the PaymentResponse.\n+  void OnPaymentAppWindowClosed();\n+\n   // Record the use of the data models that were used in the Payment Request.\n   void RecordUseStats();\n ""}<_**next**_>{""sha"": ""1c088228521f52e0a701c47d2c4dab4482d8644a"", ""filename"": ""components/payments/content/service_worker_payment_instrument.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/761d65ebcac0cdb730fd27b87e207201ac38e3b4/components/payments/content/service_worker_payment_instrument.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/761d65ebcac0cdb730fd27b87e207201ac38e3b4/components/payments/content/service_worker_payment_instrument.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/payments/content/service_worker_payment_instrument.cc?ref=761d65ebcac0cdb730fd27b87e207201ac38e3b4"", ""patch"": ""@@ -244,6 +244,10 @@ void ServiceWorkerPaymentInstrument::InvokePaymentApp(Delegate* delegate) {\n   payment_request_delegate_->ShowProcessingSpinner();\n }\n \n+void ServiceWorkerPaymentInstrument::OnPaymentAppWindowClosed() {\n+  delegate_ = nullptr;\n+}\n+\n mojom::PaymentRequestEventDataPtr\n ServiceWorkerPaymentInstrument::CreatePaymentRequestEventData() {\n   mojom::PaymentRequestEventDataPtr event_data =\n@@ -283,8 +287,6 @@ ServiceWorkerPaymentInstrument::CreatePaymentRequestEventData() {\n \n void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(\n     mojom::PaymentHandlerResponsePtr response) {\n-  DCHECK(delegate_);\n-\n   if (delegate_ != nullptr) {\n     delegate_->OnInstrumentDetailsReady(response->method_name,\n                                         response->stringified_details);""}<_**next**_>{""sha"": ""7dbb9e4732eee03504ae9c61dff0d3d8275c10e4"", ""filename"": ""components/payments/content/service_worker_payment_instrument.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/761d65ebcac0cdb730fd27b87e207201ac38e3b4/components/payments/content/service_worker_payment_instrument.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/761d65ebcac0cdb730fd27b87e207201ac38e3b4/components/payments/content/service_worker_payment_instrument.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/payments/content/service_worker_payment_instrument.h?ref=761d65ebcac0cdb730fd27b87e207201ac38e3b4"", ""patch"": ""@@ -62,6 +62,7 @@ class ServiceWorkerPaymentInstrument : public PaymentInstrument {\n \n   // PaymentInstrument:\n   void InvokePaymentApp(Delegate* delegate) override;\n+  void OnPaymentAppWindowClosed() override;\n   bool IsCompleteForPayment() const override;\n   bool IsExactlyMatchingMerchantRequest() const override;\n   base::string16 GetMissingInfoLabel() const override;""}<_**next**_>{""sha"": ""d2a6863f2e5d943cac40020a3ecd748a344b2fe4"", ""filename"": ""components/payments/core/payment_instrument.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/761d65ebcac0cdb730fd27b87e207201ac38e3b4/components/payments/core/payment_instrument.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/761d65ebcac0cdb730fd27b87e207201ac38e3b4/components/payments/core/payment_instrument.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/payments/core/payment_instrument.h?ref=761d65ebcac0cdb730fd27b87e207201ac38e3b4"", ""patch"": ""@@ -40,6 +40,8 @@ class PaymentInstrument {\n \n   // Will call into the |delegate| (can't be null) on success or error.\n   virtual void InvokePaymentApp(Delegate* delegate) = 0;\n+  // Called when the payment app window has closed.\n+  virtual void OnPaymentAppWindowClosed() {}\n   // Returns whether the instrument is complete to be used as a payment method\n   // without further editing.\n   virtual bool IsCompleteForPayment() const = 0;""}"," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr response) {
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    delegate_ = nullptr;
  }
}
"," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr response) {
  DCHECK(delegate_);
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    delegate_ = nullptr;
  }
}
",C,,"  DCHECK(delegate_);
",,"@@ -244,6 +244,10 @@ void ServiceWorkerPaymentInstrument::InvokePaymentApp(Delegate* delegate) {
   payment_request_delegate_->ShowProcessingSpinner();
 }
 
+void ServiceWorkerPaymentInstrument::OnPaymentAppWindowClosed() {
+  delegate_ = nullptr;
+}
+
 mojom::PaymentRequestEventDataPtr
 ServiceWorkerPaymentInstrument::CreatePaymentRequestEventData() {
   mojom::PaymentRequestEventDataPtr event_data =
@@ -283,8 +287,6 @@ ServiceWorkerPaymentInstrument::CreatePaymentRequestEventData() {
 
 void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr response) {
-  DCHECK(delegate_);
-
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);",Chrome,761d65ebcac0cdb730fd27b87e207201ac38e3b4,e8938178b9fe8026b3ac222f4c522276c3f39379,1," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr response) {
//flaw_line_below:
  DCHECK(delegate_);
//flaw_line_below:

   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    delegate_ = nullptr;
  }
}
",186942," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr response) {
  DCHECK(delegate_);
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    delegate_ = nullptr;
  }
}
"," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr response) {
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    delegate_ = nullptr;
  }
}
","The vulnerability in the original code lies in the use of `DCHECK(delegate_);`, which asserts that `delegate_` is not null but does not prevent the subsequent dereference of `delegate_` if it is indeed null, potentially leading to a null pointer dereference. This could cause a crash or undefined behavior if `OnPaymentAppInvoked` is called with a null `delegate_`. In the fixed code, the `DCHECK(delegate_);` line was removed, and the null check is now the sole condition for invoking `OnInstrumentDetailsReady`, ensuring that the method is only called when `delegate_` is valid, thus preventing the vulnerability.","The vulnerability in the original code arises from an assertion that checks for a non-null condition without enforcing it before proceeding to dereference a pointer. This can lead to a situation where the code attempts to access a method on a null pointer, resulting in a potential crash or undefined behavior. In the revised code, the assertion was removed, and the logic was adjusted to ensure that the dereference only occurs if the pointer is confirmed to be non-null. This change effectively eliminates the risk of dereferencing a null pointer, thereby enhancing the overall stability and safety of the code."
80,187047,187047,,Remote,Not required,Partial,CVE-2019-5786,https://www.cvedetails.com/cve/CVE-2019-5786/,CWE-416,Medium,,,,2019-06-27,4.3,Object lifetime issue in Blink in Google Chrome prior to 72.0.3626.121 allowed a remote attacker to potentially perform out of bounds memory access via a crafted HTML page.,2019-07-01,,9,https://github.com/chromium/chromium/commit/ba9748e78ec7e9c0d594e7edf7b2c07ea2a90449,ba9748e78ec7e9c0d594e7edf7b2c07ea2a90449,"FileReader: Make a copy of the ArrayBuffer when returning partial results.

This is to avoid accidentally ending up with multiple references to the
same underlying ArrayBuffer. The extra performance overhead of this is
minimal as usage of partial results is very rare anyway (as can be seen
on https://www.chromestatus.com/metrics/feature/timeline/popularity/2158).

Bug: 936448
Change-Id: Icd1081adc1c889829fe7fa4af9cf4440097e8854
Reviewed-on: https://chromium-review.googlesource.com/c/1492873
Commit-Queue: Marijn Kruisselbrink <mek@chromium.org>
Reviewed-by: Adam Klein <adamk@chromium.org>
Cr-Commit-Position: refs/heads/master@{#636251}",7,third_party/blink/renderer/core/fileapi/file_reader_loader.cc,"{""sha"": ""f79e842dd02f8bfce1bb9f7fe0995e0cda2ae3ae"", ""filename"": ""third_party/blink/renderer/core/fileapi/file_reader_loader.cc"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 7, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/ba9748e78ec7e9c0d594e7edf7b2c07ea2a90449/third_party/blink/renderer/core/fileapi/file_reader_loader.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ba9748e78ec7e9c0d594e7edf7b2c07ea2a90449/third_party/blink/renderer/core/fileapi/file_reader_loader.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/fileapi/file_reader_loader.cc?ref=ba9748e78ec7e9c0d594e7edf7b2c07ea2a90449"", ""patch"": ""@@ -139,14 +139,16 @@ DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {\n   if (!raw_data_ || error_code_ != FileErrorCode::kOK)\n     return nullptr;\n \n-  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());\n-  if (finished_loading_) {\n-    array_buffer_result_ = result;\n-    AdjustReportedMemoryUsageToV8(\n-        -1 * static_cast<int64_t>(raw_data_->ByteLength()));\n-    raw_data_.reset();\n+  if (!finished_loading_) {\n+    return DOMArrayBuffer::Create(\n+        ArrayBuffer::Create(raw_data_->Data(), raw_data_->ByteLength()));\n   }\n-  return result;\n+\n+  array_buffer_result_ = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());\n+  AdjustReportedMemoryUsageToV8(-1 *\n+                                static_cast<int64_t>(raw_data_->ByteLength()));\n+  raw_data_.reset();\n+  return array_buffer_result_;\n }\n \n String FileReaderLoader::StringResult() {""}","DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {
  DCHECK_EQ(read_type_, kReadAsArrayBuffer);
  if (array_buffer_result_)
    return array_buffer_result_;

   if (!raw_data_ || error_code_ != FileErrorCode::kOK)
     return nullptr;
 
  if (!finished_loading_) {
    return DOMArrayBuffer::Create(
        ArrayBuffer::Create(raw_data_->Data(), raw_data_->ByteLength()));
   }

  array_buffer_result_ = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
  AdjustReportedMemoryUsageToV8(-1 *
                                static_cast<int64_t>(raw_data_->ByteLength()));
  raw_data_.reset();
  return array_buffer_result_;
 }
","DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {
  DCHECK_EQ(read_type_, kReadAsArrayBuffer);
  if (array_buffer_result_)
    return array_buffer_result_;

   if (!raw_data_ || error_code_ != FileErrorCode::kOK)
     return nullptr;
 
  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
  if (finished_loading_) {
    array_buffer_result_ = result;
    AdjustReportedMemoryUsageToV8(
        -1 * static_cast<int64_t>(raw_data_->ByteLength()));
    raw_data_.reset();
   }
  return result;
 }
",C,"  if (!finished_loading_) {
    return DOMArrayBuffer::Create(
        ArrayBuffer::Create(raw_data_->Data(), raw_data_->ByteLength()));

  array_buffer_result_ = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
  AdjustReportedMemoryUsageToV8(-1 *
                                static_cast<int64_t>(raw_data_->ByteLength()));
  raw_data_.reset();
  return array_buffer_result_;
","  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
  if (finished_loading_) {
    array_buffer_result_ = result;
    AdjustReportedMemoryUsageToV8(
        -1 * static_cast<int64_t>(raw_data_->ByteLength()));
    raw_data_.reset();
  return result;
",,"@@ -139,14 +139,16 @@ DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {
   if (!raw_data_ || error_code_ != FileErrorCode::kOK)
     return nullptr;
 
-  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
-  if (finished_loading_) {
-    array_buffer_result_ = result;
-    AdjustReportedMemoryUsageToV8(
-        -1 * static_cast<int64_t>(raw_data_->ByteLength()));
-    raw_data_.reset();
+  if (!finished_loading_) {
+    return DOMArrayBuffer::Create(
+        ArrayBuffer::Create(raw_data_->Data(), raw_data_->ByteLength()));
   }
-  return result;
+
+  array_buffer_result_ = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
+  AdjustReportedMemoryUsageToV8(-1 *
+                                static_cast<int64_t>(raw_data_->ByteLength()));
+  raw_data_.reset();
+  return array_buffer_result_;
 }
 
 String FileReaderLoader::StringResult() {",Chrome,ba9748e78ec7e9c0d594e7edf7b2c07ea2a90449,9f3fccdba567f30ea39b08f57d8d5b49cd832b4a,1,"DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {
  DCHECK_EQ(read_type_, kReadAsArrayBuffer);
  if (array_buffer_result_)
    return array_buffer_result_;

  // If the loading is not started or an error occurs, return an empty result.
   if (!raw_data_ || error_code_ != FileErrorCode::kOK)
     return nullptr;
 
//flaw_line_below:
  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
//flaw_line_below:
  if (finished_loading_) {
//flaw_line_below:
    array_buffer_result_ = result;
//flaw_line_below:
    AdjustReportedMemoryUsageToV8(
//flaw_line_below:
        -1 * static_cast<int64_t>(raw_data_->ByteLength()));
//flaw_line_below:
    raw_data_.reset();
//fix_flaw_line_below:
//  if (!finished_loading_) {
//fix_flaw_line_below:
//    return DOMArrayBuffer::Create(
//fix_flaw_line_below:
//        ArrayBuffer::Create(raw_data_->Data(), raw_data_->ByteLength()));
   }
//flaw_line_below:
  return result;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  array_buffer_result_ = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
//fix_flaw_line_below:
//  AdjustReportedMemoryUsageToV8(-1 *
//fix_flaw_line_below:
//                                static_cast<int64_t>(raw_data_->ByteLength()));
//fix_flaw_line_below:
//  raw_data_.reset();
//fix_flaw_line_below:
//  return array_buffer_result_;
 }
",187047,"DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {
  DCHECK_EQ(read_type_, kReadAsArrayBuffer);
  if (array_buffer_result_)
    return array_buffer_result_;

   if (!raw_data_ || error_code_ != FileErrorCode::kOK)
     return nullptr;
 
  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
  if (finished_loading_) {
    array_buffer_result_ = result;
    AdjustReportedMemoryUsageToV8(
        -1 * static_cast<int64_t>(raw_data_->ByteLength()));
    raw_data_.reset();
   }
  return result;
 }
","DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {
  DCHECK_EQ(read_type_, kReadAsArrayBuffer);
  if (array_buffer_result_)
    return array_buffer_result_;

   if (!raw_data_ || error_code_ != FileErrorCode::kOK)
     return nullptr;
 
  if (!finished_loading_) {
    return DOMArrayBuffer::Create(
        ArrayBuffer::Create(raw_data_->Data(), raw_data_->ByteLength()));
   }

  array_buffer_result_ = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
  AdjustReportedMemoryUsageToV8(-1 *
                                static_cast<int64_t>(raw_data_->ByteLength()));
  raw_data_.reset();
  return array_buffer_result_;
 }
","The vulnerability in the original code arises from the handling of the `finished_loading_` flag, which could lead to the creation of a `DOMArrayBuffer` from potentially uninitialized or incomplete data when `finished_loading_` is false. This could result in undefined behavior or memory corruption. In the fixed code, the check for `finished_loading_` is moved to ensure that a `DOMArrayBuffer` is only created when loading is complete. If loading is not finished, it directly returns a newly created `DOMArrayBuffer` using `raw_data_->Data()` and `raw_data_->ByteLength()`, thus preventing the use of incomplete data and enhancing stability.","The vulnerability in the original code stems from the potential creation of a data structure from incomplete or uninitialized data when a specific loading condition is not met. This could lead to undefined behavior, memory corruption, or crashes, as the system might attempt to access or manipulate data that is not fully available. In the revised code, a crucial check was added to ensure that the data structure is only created when the loading process is complete. This change prevents the use of incomplete data, thereby enhancing the stability and reliability of the code by ensuring that only valid, fully loaded data is processed."
81,187144,187144,,Local Network,Not required,,CVE-2018-6171,https://www.cvedetails.com/cve/CVE-2018-6171/,CWE-416,Medium,Partial,,,2019-06-27,2.9,Use after free in Bluetooth in Google Chrome prior to 68.0.3440.75 allowed an attacker who convinced a user to install a malicious extension to obtain potentially sensitive information from process memory via a crafted Chrome Extension.,2019-07-01,+Info ,5,https://github.com/chromium/chromium/commit/c5c6320f80159dc41dffc3cfbf0298925c7dcf1b,c5c6320f80159dc41dffc3cfbf0298925c7dcf1b,"chrome.bluetoothSocket: Fix regression in send()

In https://crrev.com/c/997098, params_ was changed to a local variable,
but it needs to last longer than that since net::WrappedIOBuffer may use
the data after the local variable goes out of scope.

This CL changed it back to be an instance variable.

Bug: 851799
Change-Id: I392f8acaef4c6473d6ea4fbee7209445aa09112e
Reviewed-on: https://chromium-review.googlesource.com/1103676
Reviewed-by: Toni Barzic <tbarzic@chromium.org>
Commit-Queue: Sonny Sasaka <sonnysasaka@chromium.org>
Cr-Commit-Position: refs/heads/master@{#568137}",5,extensions/browser/api/bluetooth_socket/bluetooth_socket_api.cc,"{""sha"": ""69134a8a2a88d4815ac353177cb77566a5bbbd42"", ""filename"": ""extensions/browser/api/bluetooth_socket/bluetooth_socket_api.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c5c6320f80159dc41dffc3cfbf0298925c7dcf1b/extensions/browser/api/bluetooth_socket/bluetooth_socket_api.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c5c6320f80159dc41dffc3cfbf0298925c7dcf1b/extensions/browser/api/bluetooth_socket/bluetooth_socket_api.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/browser/api/bluetooth_socket/bluetooth_socket_api.cc?ref=c5c6320f80159dc41dffc3cfbf0298925c7dcf1b"", ""patch"": ""@@ -545,13 +545,13 @@ BluetoothSocketSendFunction::~BluetoothSocketSendFunction() {}\n ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {\n   DCHECK_CURRENTLY_ON(work_thread_id());\n \n-  auto params = bluetooth_socket::Send::Params::Create(*args_);\n-  EXTENSION_FUNCTION_VALIDATE(params.get());\n+  params_ = bluetooth_socket::Send::Params::Create(*args_);\n+  EXTENSION_FUNCTION_VALIDATE(params_.get());\n \n-  io_buffer_size_ = params->data.size();\n-  io_buffer_ = new net::WrappedIOBuffer(params->data.data());\n+  io_buffer_size_ = params_->data.size();\n+  io_buffer_ = new net::WrappedIOBuffer(params_->data.data());\n \n-  BluetoothApiSocket* socket = GetSocket(params->socket_id);\n+  BluetoothApiSocket* socket = GetSocket(params_->socket_id);\n   if (!socket)\n     return RespondNow(Error(kSocketNotFoundError));\n ""}<_**next**_>{""sha"": ""bbab919aacbadbdccd0bcc429e9e3f23648df406"", ""filename"": ""extensions/browser/api/bluetooth_socket/bluetooth_socket_api.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/c5c6320f80159dc41dffc3cfbf0298925c7dcf1b/extensions/browser/api/bluetooth_socket/bluetooth_socket_api.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c5c6320f80159dc41dffc3cfbf0298925c7dcf1b/extensions/browser/api/bluetooth_socket/bluetooth_socket_api.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/browser/api/bluetooth_socket/bluetooth_socket_api.h?ref=c5c6320f80159dc41dffc3cfbf0298925c7dcf1b"", ""patch"": ""@@ -294,6 +294,7 @@ class BluetoothSocketSendFunction : public BluetoothSocketAsyncApiFunction {\n   void OnError(BluetoothApiSocket::ErrorReason reason,\n                const std::string& message);\n \n+  std::unique_ptr<bluetooth_socket::Send::Params> params_;\n   scoped_refptr<net::IOBuffer> io_buffer_;\n   size_t io_buffer_size_;\n ""}"," ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {
   DCHECK_CURRENTLY_ON(work_thread_id());
 
  params_ = bluetooth_socket::Send::Params::Create(*args_);
  EXTENSION_FUNCTION_VALIDATE(params_.get());
 
  io_buffer_size_ = params_->data.size();
  io_buffer_ = new net::WrappedIOBuffer(params_->data.data());
 
  BluetoothApiSocket* socket = GetSocket(params_->socket_id);
   if (!socket)
     return RespondNow(Error(kSocketNotFoundError));
 
  socket->Send(io_buffer_,
               io_buffer_size_,
               base::Bind(&BluetoothSocketSendFunction::OnSuccess, this),
               base::Bind(&BluetoothSocketSendFunction::OnError, this));
  return did_respond() ? AlreadyResponded() : RespondLater();
}
"," ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {
   DCHECK_CURRENTLY_ON(work_thread_id());
 
  auto params = bluetooth_socket::Send::Params::Create(*args_);
  EXTENSION_FUNCTION_VALIDATE(params.get());
 
  io_buffer_size_ = params->data.size();
  io_buffer_ = new net::WrappedIOBuffer(params->data.data());
 
  BluetoothApiSocket* socket = GetSocket(params->socket_id);
   if (!socket)
     return RespondNow(Error(kSocketNotFoundError));
 
  socket->Send(io_buffer_,
               io_buffer_size_,
               base::Bind(&BluetoothSocketSendFunction::OnSuccess, this),
               base::Bind(&BluetoothSocketSendFunction::OnError, this));
  return did_respond() ? AlreadyResponded() : RespondLater();
}
",C,"  params_ = bluetooth_socket::Send::Params::Create(*args_);
  EXTENSION_FUNCTION_VALIDATE(params_.get());
  io_buffer_size_ = params_->data.size();
  io_buffer_ = new net::WrappedIOBuffer(params_->data.data());
  BluetoothApiSocket* socket = GetSocket(params_->socket_id);
","  auto params = bluetooth_socket::Send::Params::Create(*args_);
  EXTENSION_FUNCTION_VALIDATE(params.get());
  io_buffer_size_ = params->data.size();
  io_buffer_ = new net::WrappedIOBuffer(params->data.data());
  BluetoothApiSocket* socket = GetSocket(params->socket_id);
",,"@@ -545,13 +545,13 @@ BluetoothSocketSendFunction::~BluetoothSocketSendFunction() {}
 ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {
   DCHECK_CURRENTLY_ON(work_thread_id());
 
-  auto params = bluetooth_socket::Send::Params::Create(*args_);
-  EXTENSION_FUNCTION_VALIDATE(params.get());
+  params_ = bluetooth_socket::Send::Params::Create(*args_);
+  EXTENSION_FUNCTION_VALIDATE(params_.get());
 
-  io_buffer_size_ = params->data.size();
-  io_buffer_ = new net::WrappedIOBuffer(params->data.data());
+  io_buffer_size_ = params_->data.size();
+  io_buffer_ = new net::WrappedIOBuffer(params_->data.data());
 
-  BluetoothApiSocket* socket = GetSocket(params->socket_id);
+  BluetoothApiSocket* socket = GetSocket(params_->socket_id);
   if (!socket)
     return RespondNow(Error(kSocketNotFoundError));
 ",Chrome,c5c6320f80159dc41dffc3cfbf0298925c7dcf1b,9e0b47c55c747f6cd6913f8b2431e443bc7b6129,1," ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {
   DCHECK_CURRENTLY_ON(work_thread_id());
 
//flaw_line_below:
  auto params = bluetooth_socket::Send::Params::Create(*args_);
//flaw_line_below:
  EXTENSION_FUNCTION_VALIDATE(params.get());
//fix_flaw_line_below:
//  params_ = bluetooth_socket::Send::Params::Create(*args_);
//fix_flaw_line_below:
//  EXTENSION_FUNCTION_VALIDATE(params_.get());
 
//flaw_line_below:
  io_buffer_size_ = params->data.size();
//flaw_line_below:
  io_buffer_ = new net::WrappedIOBuffer(params->data.data());
//fix_flaw_line_below:
//  io_buffer_size_ = params_->data.size();
//fix_flaw_line_below:
//  io_buffer_ = new net::WrappedIOBuffer(params_->data.data());
 
//flaw_line_below:
  BluetoothApiSocket* socket = GetSocket(params->socket_id);
//fix_flaw_line_below:
//  BluetoothApiSocket* socket = GetSocket(params_->socket_id);
   if (!socket)
     return RespondNow(Error(kSocketNotFoundError));
 
  socket->Send(io_buffer_,
               io_buffer_size_,
               base::Bind(&BluetoothSocketSendFunction::OnSuccess, this),
               base::Bind(&BluetoothSocketSendFunction::OnError, this));
  return did_respond() ? AlreadyResponded() : RespondLater();
}
",187144," ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {
   DCHECK_CURRENTLY_ON(work_thread_id());
 
  auto params = bluetooth_socket::Send::Params::Create(*args_);
  EXTENSION_FUNCTION_VALIDATE(params.get());
 
  io_buffer_size_ = params->data.size();
  io_buffer_ = new net::WrappedIOBuffer(params->data.data());
 
  BluetoothApiSocket* socket = GetSocket(params->socket_id);
   if (!socket)
     return RespondNow(Error(kSocketNotFoundError));
 
  socket->Send(io_buffer_,
               io_buffer_size_,
               base::Bind(&BluetoothSocketSendFunction::OnSuccess, this),
               base::Bind(&BluetoothSocketSendFunction::OnError, this));
  return did_respond() ? AlreadyResponded() : RespondLater();
}
"," ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {
   DCHECK_CURRENTLY_ON(work_thread_id());
 
  params_ = bluetooth_socket::Send::Params::Create(*args_);
  EXTENSION_FUNCTION_VALIDATE(params_.get());
 
  io_buffer_size_ = params_->data.size();
  io_buffer_ = new net::WrappedIOBuffer(params_->data.data());
 
  BluetoothApiSocket* socket = GetSocket(params_->socket_id);
   if (!socket)
     return RespondNow(Error(kSocketNotFoundError));
 
  socket->Send(io_buffer_,
               io_buffer_size_,
               base::Bind(&BluetoothSocketSendFunction::OnSuccess, this),
               base::Bind(&BluetoothSocketSendFunction::OnError, this));
  return did_respond() ? AlreadyResponded() : RespondLater();
}
","The vulnerability in the original code arises from the use of a local variable `params` to store the result of `bluetooth_socket::Send::Params::Create(*args_)`, which could lead to potential issues if `params` is not properly validated or if its lifetime is not managed correctly. This could result in accessing invalid memory or dereferencing a null pointer. In the fixed code, the variable is changed to `params_`, which suggests that it is now a member variable, ensuring that its lifetime is tied to the instance of `BluetoothSocketSendFunction`. This change enhances memory management and reduces the risk of accessing invalid data.","The vulnerability in the original code stems from the use of a local variable to store parameters created from input arguments, which could lead to issues if the parameters are not properly validated or if their memory is not managed correctly. This could result in accessing invalid memory or dereferencing a null pointer, potentially causing crashes or undefined behavior. In the revised code, the parameters are stored in a member variable, ensuring that their lifetime is tied to the instance of the class. This change improves memory management and reduces the risk of accessing invalid or uninitialized data."
82,187166,187166,,Remote,Not required,Partial,CVE-2018-16067,https://www.cvedetails.com/cve/CVE-2018-16067/,CWE-416,Medium,,,,2019-01-09,4.3,A use after free in WebAudio in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.,2019-01-15,,8,https://github.com/chromium/chromium/commit/ca1156974cbe707fd023a00ae62104528833a44e,ca1156974cbe707fd023a00ae62104528833a44e,"Audio thread should not access destination node

The AudioDestinationNode is an object managed by Oilpan so the audio
thread should not access it.  However, the audio thread needs
information (currentTime, etc) from the destination node. So instead
of accessing the audio destination handler (a scoped_refptr) via the
destination node, add a new member to the base audio context that
holds onto the destination handler.

The destination handler is not an oilpan object and lives at least as
long as the base audio context.

Bug: 860626, 860522, 863951
Test: Test case from 860522 doesn't crash on asan build
Change-Id: I3add844d4eb8fdc7e05b89292938b843a0abbb99
Reviewed-on: https://chromium-review.googlesource.com/1138974
Commit-Queue: Raymond Toy <rtoy@chromium.org>
Reviewed-by: Hongchan Choi <hongchan@chromium.org>
Cr-Commit-Position: refs/heads/master@{#575509}",0,third_party/blink/renderer/modules/webaudio/base_audio_context.cc,"{""sha"": ""f30bd880a15908c7783ecec8a0881a51e37f0891"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/ca1156974cbe707fd023a00ae62104528833a44e/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ca1156974cbe707fd023a00ae62104528833a44e/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.cc?ref=ca1156974cbe707fd023a00ae62104528833a44e"", ""patch"": ""@@ -120,6 +120,14 @@ void BaseAudioContext::Initialize() {\n \n   if (destination_node_) {\n     destination_node_->Handler().Initialize();\n+    // TODO(crbug.com/863951).  The audio thread needs some things from the\n+    // destination handler like the currentTime.  But the audio thread\n+    // shouldn't access the |destination_node_| since it's an Oilpan object.\n+    // Thus, get the destination handler, a non-oilpan object, so we can get\n+    // the items directly from the handler instead of through the destination\n+    // node.\n+    destination_handler_ = &destination_node_->GetAudioDestinationHandler();\n+\n     // The AudioParams in the listener need access to the destination node, so\n     // only create the listener if the destination node exists.\n     listener_ = AudioListener::Create(*this);""}<_**next**_>{""sha"": ""f55e32c4b70ac57b32d4ca17811fe10f47f5cb89"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 15, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/ca1156974cbe707fd023a00ae62104528833a44e/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ca1156974cbe707fd023a00ae62104528833a44e/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.h?ref=ca1156974cbe707fd023a00ae62104528833a44e"", ""patch"": ""@@ -127,24 +127,12 @@ class MODULES_EXPORT BaseAudioContext\n   AudioDestinationNode* destination() const;\n \n   size_t CurrentSampleFrame() const {\n-    // TODO(crbug.com/863951): |destination_node| is a GC-mananged object and\n-    // should not be touched by the audio rendering thread.\n-    return destination_node_ ? destination_node_->GetAudioDestinationHandler()\n-                                   .CurrentSampleFrame()\n-                             : 0;\n+    return destination_handler_->CurrentSampleFrame();\n   }\n \n-  double currentTime() const {\n-    // TODO(crbug.com/863951): |destination_node| is a GC-mananged object and\n-    // should not be touched by the audio rendering thread.\n-    return destination_node_\n-               ? destination_node_->GetAudioDestinationHandler().CurrentTime()\n-               : 0;\n-  }\n+  double currentTime() const { return destination_handler_->CurrentTime(); }\n \n-  float sampleRate() const {\n-    return destination_node_->GetAudioDestinationHandler().SampleRate();\n-  }\n+  float sampleRate() const { return destination_handler_->SampleRate(); }\n \n   String state() const;\n   AudioContextState ContextState() const { return context_state_; }\n@@ -453,6 +441,9 @@ class MODULES_EXPORT BaseAudioContext\n \n   AudioIOPosition output_position_;\n \n+  // The handler associated with the above |destination_node_|.\n+  scoped_refptr<AudioDestinationHandler> destination_handler_;\n+\n   Member<AudioWorklet> audio_worklet_;\n \n   // In order to update some information (e.g. current frame) in""}","void BaseAudioContext::Initialize() {
  if (IsDestinationInitialized())
    return;

  FFTFrame::Initialize();

  audio_worklet_ = AudioWorklet::Create(this);
 
   if (destination_node_) {
     destination_node_->Handler().Initialize();
    // TODO(crbug.com/863951).  The audio thread needs some things from the
    // destination handler like the currentTime.  But the audio thread
    // shouldn't access the |destination_node_| since it's an Oilpan object.
    // Thus, get the destination handler, a non-oilpan object, so we can get
    // the items directly from the handler instead of through the destination
    // node.
    destination_handler_ = &destination_node_->GetAudioDestinationHandler();

     listener_ = AudioListener::Create(*this);
  }
}
","void BaseAudioContext::Initialize() {
  if (IsDestinationInitialized())
    return;

  FFTFrame::Initialize();

  audio_worklet_ = AudioWorklet::Create(this);
 
   if (destination_node_) {
     destination_node_->Handler().Initialize();
     listener_ = AudioListener::Create(*this);
  }
}
",C,"    // TODO(crbug.com/863951).  The audio thread needs some things from the
    // destination handler like the currentTime.  But the audio thread
    // shouldn't access the |destination_node_| since it's an Oilpan object.
    // Thus, get the destination handler, a non-oilpan object, so we can get
    // the items directly from the handler instead of through the destination
    // node.
    destination_handler_ = &destination_node_->GetAudioDestinationHandler();

",,,"@@ -120,6 +120,14 @@ void BaseAudioContext::Initialize() {
 
   if (destination_node_) {
     destination_node_->Handler().Initialize();
+    // TODO(crbug.com/863951).  The audio thread needs some things from the
+    // destination handler like the currentTime.  But the audio thread
+    // shouldn't access the |destination_node_| since it's an Oilpan object.
+    // Thus, get the destination handler, a non-oilpan object, so we can get
+    // the items directly from the handler instead of through the destination
+    // node.
+    destination_handler_ = &destination_node_->GetAudioDestinationHandler();
+
     // The AudioParams in the listener need access to the destination node, so
     // only create the listener if the destination node exists.
     listener_ = AudioListener::Create(*this);",Chrome,ca1156974cbe707fd023a00ae62104528833a44e,9df3533884d2a5db7731c1af749b1e813dd1d528,1,"void BaseAudioContext::Initialize() {
  if (IsDestinationInitialized())
    return;

  FFTFrame::Initialize();

  audio_worklet_ = AudioWorklet::Create(this);
 
   if (destination_node_) {
     destination_node_->Handler().Initialize();
//fix_flaw_line_below:
//    // TODO(crbug.com/863951).  The audio thread needs some things from the
//fix_flaw_line_below:
//    // destination handler like the currentTime.  But the audio thread
//fix_flaw_line_below:
//    // shouldn't access the |destination_node_| since it's an Oilpan object.
//fix_flaw_line_below:
//    // Thus, get the destination handler, a non-oilpan object, so we can get
//fix_flaw_line_below:
//    // the items directly from the handler instead of through the destination
//fix_flaw_line_below:
//    // node.
//fix_flaw_line_below:
//    destination_handler_ = &destination_node_->GetAudioDestinationHandler();
//fix_flaw_line_below:
//
     // The AudioParams in the listener need access to the destination node, so
     // only create the listener if the destination node exists.
     listener_ = AudioListener::Create(*this);
  }
}
",187166,"void BaseAudioContext::Initialize() {
  if (IsDestinationInitialized())
    return;

  FFTFrame::Initialize();

  audio_worklet_ = AudioWorklet::Create(this);
 
   if (destination_node_) {
     destination_node_->Handler().Initialize();
     listener_ = AudioListener::Create(*this);
  }
}
","void BaseAudioContext::Initialize() {
  if (IsDestinationInitialized())
    return;

  FFTFrame::Initialize();

  audio_worklet_ = AudioWorklet::Create(this);
 
   if (destination_node_) {
     destination_node_->Handler().Initialize();
    // TODO(crbug.com/863951).  The audio thread needs some things from the
    // destination handler like the currentTime.  But the audio thread
    // shouldn't access the |destination_node_| since it's an Oilpan object.
    // Thus, get the destination handler, a non-oilpan object, so we can get
    // the items directly from the handler instead of through the destination
    // node.
    destination_handler_ = &destination_node_->GetAudioDestinationHandler();

     listener_ = AudioListener::Create(*this);
  }
}
","The vulnerability in the original code arises from directly accessing the `destination_node_` within the audio thread, which can lead to issues since `destination_node_` is an Oilpan object that may not be safely accessed in that context. This could result in race conditions or crashes if the object is garbage collected while being accessed. The fixed code addresses this vulnerability by introducing `destination_handler_`, which retrieves the audio destination handler from `destination_node_` without directly accessing the Oilpan object. This ensures that the audio thread interacts with a non-Oilpan object, enhancing stability and safety.","The vulnerability in the original code stems from directly accessing a potentially unsafe object within a multi-threaded environment, which can lead to race conditions or crashes if the object is modified or deleted while being accessed. This situation arises because the object in question is managed by a garbage collection system that may not guarantee its availability during concurrent operations. The fixed code resolves this issue by introducing an intermediary handler that allows safe access to the necessary data without directly interacting with the potentially unstable object, thereby ensuring thread safety and preventing access violations."
