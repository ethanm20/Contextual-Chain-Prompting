,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic
0,79483,79483,,Remote,Not required,,CVE-2018-14363,https://www.cvedetails.com/cve/CVE-2018-14363/,CWE-22,Low,,Partial,,2018-07-17,5.0,An issue was discovered in NeoMutt before 2018-07-16. newsrc.c does not properly restrict '/' characters that may have unsafe interaction with cache pathnames.,2019-10-02,Dir. Trav. ,0,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,9bfab35522301794483f8f9ed60820bdec9be59e,"sanitise cache paths

Co-authored-by: JerikoOne <jeriko.one@gmx.us>",0,pop.c,"{""sha"": ""c9dfdba23c03a5608841c4a703f0df61b10d89af"", ""filename"": ""newsrc.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 1, ""changes"": 13, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/9bfab35522301794483f8f9ed60820bdec9be59e/newsrc.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/9bfab35522301794483f8f9ed60820bdec9be59e/newsrc.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/newsrc.c?ref=9bfab35522301794483f8f9ed60820bdec9be59e"", ""patch"": ""@@ -715,7 +715,18 @@ int nntp_active_save_cache(struct NntpServer *nserv)\n  */\n static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n {\n-  return snprintf(dest, destlen, \""%s.hcache\"", path);\n+  int count = snprintf(dest, destlen, \""%s.hcache\"", path);\n+\n+  /* Strip out any directories in the path */\n+  char *first = strchr(dest, '/');\n+  char *last = strrchr(dest, '/');\n+  if (first && last && (last > first))\n+  {\n+    memmove(first, last, strlen(last) + 1);\n+    count -= (last - first);\n+  }\n+\n+  return count;\n }\n \n /**""}<_**next**_>{""sha"": ""4f3a592a8d562aec7dfe3c80bec8e010cd879c97"", ""filename"": ""pop.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 6, ""changes"": 29, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/9bfab35522301794483f8f9ed60820bdec9be59e/pop.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/9bfab35522301794483f8f9ed60820bdec9be59e/pop.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/pop.c?ref=9bfab35522301794483f8f9ed60820bdec9be59e"", ""patch"": ""@@ -63,6 +63,23 @@\n #define HC_FEXT \""hcache\""   /* extension for hcache as POP lacks paths */\n #endif\n \n+/**\n+ * cache_id - Make a message-cache-compatible id\n+ * @param id POP message id\n+ * @retval ptr Sanitised string\n+ *\n+ * The POP message id may contain '/' and other awkward characters.\n+ *\n+ * @note This function returns a pointer to a static buffer.\n+ */\n+static const char *cache_id(const char *id)\n+{\n+  static char clean[SHORT_STRING];\n+  mutt_str_strfcpy(clean, id, sizeof(clean));\n+  mutt_file_sanitize_filename(clean, true);\n+  return clean;\n+}\n+\n /**\n  * fetch_message - write line to file\n  * @param line String to write\n@@ -242,7 +259,7 @@ static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)\n   /* message not found in context -> remove it from cache\n    * return the result of bcache, so we stop upon its first error\n    */\n-  return mutt_bcache_del(bcache, id);\n+  return mutt_bcache_del(bcache, cache_id(id));\n }\n \n #ifdef USE_HCACHE\n@@ -407,7 +424,7 @@ static int pop_fetch_headers(struct Context *ctx)\n        *        - if we don't have a body: new\n        */\n       const bool bcached =\n-          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);\n+          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);\n       ctx->hdrs[i]->old = false;\n       ctx->hdrs[i]->read = false;\n       if (hcached)\n@@ -597,7 +614,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n   unsigned short bcache = 1;\n \n   /* see if we already have the message in body cache */\n-  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);\n+  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));\n   if (msg->fp)\n     return 0;\n \n@@ -644,7 +661,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n                        NetInc, h->content->length + h->content->offset - 1);\n \n     /* see if we can put in body cache; use our cache as fallback */\n-    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);\n+    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));\n     if (!msg->fp)\n     {\n       /* no */\n@@ -689,7 +706,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n    * portion of the headers, those required for the main display.\n    */\n   if (bcache)\n-    mutt_bcache_commit(pop_data->bcache, h->data);\n+    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));\n   else\n   {\n     cache->index = h->index;\n@@ -783,7 +800,7 @@ static int pop_sync_mailbox(struct Context *ctx, int *index_hint)\n         ret = pop_query(pop_data, buf, sizeof(buf));\n         if (ret == 0)\n         {\n-          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);\n+          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));\n #ifdef USE_HCACHE\n           mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n #endif""}","static int pop_hcache_namer(const char *path, char *dest, size_t destlen)
{
  return snprintf(dest, destlen, ""%s."" HC_FEXT, path);
}
","static int pop_hcache_namer(const char *path, char *dest, size_t destlen)
{
  return snprintf(dest, destlen, ""%s."" HC_FEXT, path);
}
",C,,,,"@@ -63,6 +63,23 @@
 #define HC_FEXT ""hcache""   /* extension for hcache as POP lacks paths */
 #endif
 
+/**
+ * cache_id - Make a message-cache-compatible id
+ * @param id POP message id
+ * @retval ptr Sanitised string
+ *
+ * The POP message id may contain '/' and other awkward characters.
+ *
+ * @note This function returns a pointer to a static buffer.
+ */
+static const char *cache_id(const char *id)
+{
+  static char clean[SHORT_STRING];
+  mutt_str_strfcpy(clean, id, sizeof(clean));
+  mutt_file_sanitize_filename(clean, true);
+  return clean;
+}
+
 /**
  * fetch_message - write line to file
  * @param line String to write
@@ -242,7 +259,7 @@ static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)
   /* message not found in context -> remove it from cache
    * return the result of bcache, so we stop upon its first error
    */
-  return mutt_bcache_del(bcache, id);
+  return mutt_bcache_del(bcache, cache_id(id));
 }
 
 #ifdef USE_HCACHE
@@ -407,7 +424,7 @@ static int pop_fetch_headers(struct Context *ctx)
        *        - if we don't have a body: new
        */
       const bool bcached =
-          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);
+          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);
       ctx->hdrs[i]->old = false;
       ctx->hdrs[i]->read = false;
       if (hcached)
@@ -597,7 +614,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno
   unsigned short bcache = 1;
 
   /* see if we already have the message in body cache */
-  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);
+  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));
   if (msg->fp)
     return 0;
 
@@ -644,7 +661,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno
                        NetInc, h->content->length + h->content->offset - 1);
 
     /* see if we can put in body cache; use our cache as fallback */
-    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);
+    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));
     if (!msg->fp)
     {
       /* no */
@@ -689,7 +706,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno
    * portion of the headers, those required for the main display.
    */
   if (bcache)
-    mutt_bcache_commit(pop_data->bcache, h->data);
+    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));
   else
   {
     cache->index = h->index;
@@ -783,7 +800,7 @@ static int pop_sync_mailbox(struct Context *ctx, int *index_hint)
         ret = pop_query(pop_data, buf, sizeof(buf));
         if (ret == 0)
         {
-          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);
+          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));
 #ifdef USE_HCACHE
           mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));
 #endif",neomutt,9bfab35522301794483f8f9ed60820bdec9be59e,98aad9c3f1fb281e35a966d4a9b01b60db402e7a,0,"static int pop_hcache_namer(const char *path, char *dest, size_t destlen)
{
  return snprintf(dest, destlen, ""%s."" HC_FEXT, path);
}
",79483," static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)
 {
  return snprintf(dest, destlen, ""%s.hcache"", path);
 }
","static int pop_hcache_namer(const char *path, char *dest, size_t destlen)
{
  return snprintf(dest, destlen, ""%s."" HC_FEXT, path);
}
","The vulnerability in the original `nntp_hcache_namer` function arises from the potential for a buffer overflow when the `path` string is longer than `destlen`, as it does not validate the length of the resulting string. This could lead to memory corruption or security issues. In the fixed code, the function was renamed to `pop_hcache_namer`, and it now appends a defined file extension `HC_FEXT` instead of a hardcoded "".hcache"". This change not only improves code clarity but also allows for better control over the output format, reducing the risk of buffer overflow by ensuring that the extension is consistently managed.","The vulnerability in the original code stems from the lack of validation for the length of the input string, which can lead to a buffer overflow if the combined length of the input exceeds the allocated space for the output. This can result in memory corruption and potential security risks. The fixed code addresses this issue by changing the output format to include a defined file extension, ensuring that the output remains consistent and manageable. This modification not only enhances clarity but also mitigates the risk of overflow by controlling the length of the resulting string more effectively."
1,177931,177931,,Remote,Single system,,CVE-2018-14036,https://www.cvedetails.com/cve/CVE-2018-14036/,CWE-22,Low,Partial,,,2018-07-13,4.0,Directory Traversal with ../ sequences occurs in AccountsService before 0.6.50 because of an insufficient path check in user_change_icon_file_authorized_cb() in user.c.,2018-09-06,Dir. Trav.,8,https://cgit.freedesktop.org/accountsservice/commit/?id=f9abd359f71a5bce421b9ae23432f539a067847a,f9abd359f71a5bce421b9ae23432f539a067847a,,0,,,"user_change_icon_file_authorized_cb (Daemon                *daemon,
                                     User                  *user,
                                     GDBusMethodInvocation *context,
                                     gpointer               data)

{
        g_autofree gchar *filename = NULL;
        g_autoptr(GFile) file = NULL;
        g_autoptr(GFileInfo) info = NULL;
        guint32 mode;
        GFileType type;
        guint64 size;

        filename = g_strdup (data);

        if (filename == NULL ||
            *filename == '\0') {
                g_autofree gchar *dest_path = NULL;
                g_autoptr(GFile) dest = NULL;
                g_autoptr(GError) error = NULL;

                g_clear_pointer (&filename, g_free);

                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);
                dest = g_file_new_for_path (dest_path);

                if (!g_file_delete (dest, NULL, &error) &&
                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
                        throw_error (context, ERROR_FAILED, ""failed to remove user icon, %s"", error->message);
                        return;
                }
                goto icon_saved;
         }
 
         file = g_file_new_for_path (filename);
        g_clear_pointer (&filename, g_free);

        /* Canonicalize path so we can call g_str_has_prefix on it
         * below without concern for ../ path components moving outside
         * the prefix
         */
        filename = g_file_get_path (file);

         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,
                return;
        }
","user_change_icon_file_authorized_cb (Daemon                *daemon,
                                     User                  *user,
                                     GDBusMethodInvocation *context,
                                     gpointer               data)

{
        g_autofree gchar *filename = NULL;
        g_autoptr(GFile) file = NULL;
        g_autoptr(GFileInfo) info = NULL;
        guint32 mode;
        GFileType type;
        guint64 size;

        filename = g_strdup (data);

        if (filename == NULL ||
            *filename == '\0') {
                g_autofree gchar *dest_path = NULL;
                g_autoptr(GFile) dest = NULL;
                g_autoptr(GError) error = NULL;

                g_clear_pointer (&filename, g_free);

                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);
                dest = g_file_new_for_path (dest_path);

                if (!g_file_delete (dest, NULL, &error) &&
                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
                        throw_error (context, ERROR_FAILED, ""failed to remove user icon, %s"", error->message);
                        return;
                }
                goto icon_saved;
         }
 
         file = g_file_new_for_path (filename);
         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,
                return;
        }
",C,"        g_clear_pointer (&filename, g_free);

        /* Canonicalize path so we can call g_str_has_prefix on it
         * below without concern for ../ path components moving outside
         * the prefix
         */
        filename = g_file_get_path (file);

",,34bedecf7da81a8b42382254e3f9a32398c1ca5d,"@@ -1334,6 +1334,14 @@ user_change_icon_file_authorized_cb (Daemon                *daemon,
         }
 
         file = g_file_new_for_path (filename);
+        g_clear_pointer (&filename, g_free);
+
+        /* Canonicalize path so we can call g_str_has_prefix on it
+         * below without concern for ../ path components moving outside
+         * the prefix
+         */
+        filename = g_file_get_path (file);
+
         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,",accountsservice,https://cgit.freedesktop.org/accountsservice/tree/src/user.c?id=f9abd359f71a5bce421b9ae23432f539a067847a,https://cgit.freedesktop.org/accountsservice/tree/src/user.c?id=34bedecf7da81a8b42382254e3f9a32398c1ca5d,1,"user_change_icon_file_authorized_cb (Daemon                *daemon,
                                     User                  *user,
                                     GDBusMethodInvocation *context,
                                     gpointer               data)

{
        g_autofree gchar *filename = NULL;
        g_autoptr(GFile) file = NULL;
        g_autoptr(GFileInfo) info = NULL;
        guint32 mode;
        GFileType type;
        guint64 size;

        filename = g_strdup (data);

        if (filename == NULL ||
            *filename == '\0') {
                g_autofree gchar *dest_path = NULL;
                g_autoptr(GFile) dest = NULL;
                g_autoptr(GError) error = NULL;

                g_clear_pointer (&filename, g_free);

                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);
                dest = g_file_new_for_path (dest_path);

                if (!g_file_delete (dest, NULL, &error) &&
                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
                        throw_error (context, ERROR_FAILED, ""failed to remove user icon, %s"", error->message);
                        return;
                }
                goto icon_saved;
         }
 
         file = g_file_new_for_path (filename);
//fix_flaw_line_below:
//        g_clear_pointer (&filename, g_free);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        /* Canonicalize path so we can call g_str_has_prefix on it
//fix_flaw_line_below:
//         * below without concern for ../ path components moving outside
//fix_flaw_line_below:
//         * the prefix
//fix_flaw_line_below:
//         */
//fix_flaw_line_below:
//        filename = g_file_get_path (file);
//fix_flaw_line_below:
//
         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,
                return;
        }
",177931,"user_change_icon_file_authorized_cb (Daemon                *daemon,
                                     User                  *user,
                                     GDBusMethodInvocation *context,
                                     gpointer               data)

{
        g_autofree gchar *filename = NULL;
        g_autoptr(GFile) file = NULL;
        g_autoptr(GFileInfo) info = NULL;
        guint32 mode;
        GFileType type;
        guint64 size;

        filename = g_strdup (data);

        if (filename == NULL ||
            *filename == '\0') {
                g_autofree gchar *dest_path = NULL;
                g_autoptr(GFile) dest = NULL;
                g_autoptr(GError) error = NULL;

                g_clear_pointer (&filename, g_free);

                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);
                dest = g_file_new_for_path (dest_path);

                if (!g_file_delete (dest, NULL, &error) &&
                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
                        throw_error (context, ERROR_FAILED, ""failed to remove user icon, %s"", error->message);
                        return;
                }
                goto icon_saved;
         }
 
         file = g_file_new_for_path (filename);
         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,
                return;
        }
","user_change_icon_file_authorized_cb (Daemon                *daemon,
                                     User                  *user,
                                     GDBusMethodInvocation *context,
                                     gpointer               data)

{
        g_autofree gchar *filename = NULL;
        g_autoptr(GFile) file = NULL;
        g_autoptr(GFileInfo) info = NULL;
        guint32 mode;
        GFileType type;
        guint64 size;

        filename = g_strdup (data);

        if (filename == NULL ||
            *filename == '\0') {
                g_autofree gchar *dest_path = NULL;
                g_autoptr(GFile) dest = NULL;
                g_autoptr(GError) error = NULL;

                g_clear_pointer (&filename, g_free);

                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);
                dest = g_file_new_for_path (dest_path);

                if (!g_file_delete (dest, NULL, &error) &&
                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
                        throw_error (context, ERROR_FAILED, ""failed to remove user icon, %s"", error->message);
                        return;
                }
                goto icon_saved;
         }
 
         file = g_file_new_for_path (filename);
        g_clear_pointer (&filename, g_free);

        /* Canonicalize path so we can call g_str_has_prefix on it
         * below without concern for ../ path components moving outside
         * the prefix
         */
        filename = g_file_get_path (file);

         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,
                return;
        }
","The vulnerability in the original code arises from the lack of path canonicalization for the `filename` variable, which is derived from user input (`data`). This oversight allows for potential directory traversal attacks, where an attacker could manipulate the input to access unauthorized files. In the fixed code, the vulnerability is addressed by adding the line `filename = g_file_get_path(file);`, which canonicalizes the path of the `file` object. This ensures that any `../` components are resolved, preventing unauthorized access and enhancing the security of the file handling process.","The vulnerability in the original code stems from the handling of user input, which could allow for directory traversal attacks. Specifically, the code does not validate or sanitize the input, enabling an attacker to manipulate the path and potentially access unauthorized files on the system. In the revised code, this vulnerability is mitigated by implementing a path canonicalization step that resolves any relative path components. This ensures that the input is transformed into a secure, absolute path, effectively preventing unauthorized access and enhancing the overall security of the file handling process."
2,178681,178681,,Remote,Not required,,CVE-2014-10073,https://www.cvedetails.com/cve/CVE-2014-10073/,CWE-22,Low,Partial,,,2018-04-20,5.0,The create_response function in server/server.c in Psensor before 1.1.4 allows Directory Traversal because it lacks a check for whether a file is under the webserver directory.,2019-10-03,Dir. Trav.,12,http://git.wpitchoune.net/gitweb/?p=psensor.git;a=commit;h=8b10426dcc0246c1712a99460dd470dcb1cc4d9c,8b10426dcc0246c1712a99460dd470dcb1cc4d9c,,2,,," create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
       char *page, *fpath, *rpath;
        struct MHD_Response *resp = NULL;
       int n;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
               rpath = realpath(fpath, NULL);
               if (rpath) {
                       n = strlen(server_data.www_dir);
                       if (!strncmp(server_data.www_dir, rpath, n))
                               resp = create_response_file(nurl,
                                                           method,
                                                           rp_code,
                                                           fpath);
                       free(rpath);
               }
 
                free(fpath);
        }
}
"," create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
       char *page, *fpath;
        struct MHD_Response *resp = NULL;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
               resp = create_response_file(nurl, method, rp_code, fpath);
 
                free(fpath);
        }
}
",C,"       char *page, *fpath, *rpath;
       int n;
               rpath = realpath(fpath, NULL);
               if (rpath) {
                       n = strlen(server_data.www_dir);
                       if (!strncmp(server_data.www_dir, rpath, n))
                               resp = create_response_file(nurl,
                                                           method,
                                                           rp_code,
                                                           fpath);
                       free(rpath);
               }
","       char *page, *fpath;
               resp = create_response_file(nurl, method, rp_code, fpath);
",30280f0093e8aea4bc8af8a46c2e529e8ec61ac9,"@@ -23,6 +23,7 @@
 #include <libintl.h>
 #define _(str) gettext(str)
 
+#include <limits.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -245,15 +246,25 @@ static struct MHD_Response *create_response_file(const char *nurl,
 static struct MHD_Response *
 create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
-       char *page, *fpath;
+       char *page, *fpath, *rpath;
        struct MHD_Response *resp = NULL;
+       int n;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
-               resp = create_response_file(nurl, method, rp_code, fpath);
+               rpath = realpath(fpath, NULL);
+               if (rpath) {
+                       n = strlen(server_data.www_dir);
+                       if (!strncmp(server_data.www_dir, rpath, n))
+                               resp = create_response_file(nurl,
+                                                           method,
+                                                           rp_code,
+                                                           fpath);
+                       free(rpath);
+               }
 
                free(fpath);
        }
@@ -349,7 +360,7 @@ int main(int argc, char *argv[])
                switch (optc) {
                case 'w':
                        if (optarg)
-                               server_data.www_dir = strdup(optarg);
+                               server_data.www_dir = realpath(optarg, NULL);
                        break;
                case 'p':
                        if (optarg)
@@ -388,8 +399,14 @@ int main(int argc, char *argv[])
                exit(EXIT_FAILURE);
        }
 
-       if (!server_data.www_dir)
-               server_data.www_dir = strdup(DEFAULT_WWW_DIR);
+       if (!server_data.www_dir) {
+               server_data.www_dir = realpath(DEFAULT_WWW_DIR, NULL);
+               if (!server_data.www_dir) {
+                       fprintf(stderr,
+                               _(""Webserver directory does not exist.\n""));
+                       exit(EXIT_FAILURE);
+               }
+       }
 
        if (!log_file)
                log_file = strdup(DEFAULT_LOG_FILE);",wpitchoune,http://git.wpitchoune.net/gitweb/?p=psensor.git;a=blob;f=src/server/server.c;h=95998c8deb916813798042df837170f2600170c4;hb=95998c8deb916813798042df837170f2600170c4,http://git.wpitchoune.net/gitweb/?p=psensor.git;a=blob;f=src/server/server.c;h=3db6828760f47e0d0a081a519b3b79d3158c5b08;hb=3db6828760f47e0d0a081a519b3b79d3158c5b08,1," create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
//flaw_line_below:
       char *page, *fpath;
//fix_flaw_line_below:
//       char *page, *fpath, *rpath;
        struct MHD_Response *resp = NULL;
//fix_flaw_line_below:
//       int n;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
//flaw_line_below:
               resp = create_response_file(nurl, method, rp_code, fpath);
//fix_flaw_line_below:
//               rpath = realpath(fpath, NULL);
//fix_flaw_line_below:
//               if (rpath) {
//fix_flaw_line_below:
//                       n = strlen(server_data.www_dir);
//fix_flaw_line_below:
//                       if (!strncmp(server_data.www_dir, rpath, n))
//fix_flaw_line_below:
//                               resp = create_response_file(nurl,
//fix_flaw_line_below:
//                                                           method,
//fix_flaw_line_below:
//                                                           rp_code,
//fix_flaw_line_below:
//                                                           fpath);
//fix_flaw_line_below:
//                       free(rpath);
//fix_flaw_line_below:
//               }
 
                free(fpath);
        }
}
",178681," create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
       char *page, *fpath;
        struct MHD_Response *resp = NULL;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
               resp = create_response_file(nurl, method, rp_code, fpath);
 
                free(fpath);
        }
}
"," create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
       char *page, *fpath, *rpath;
        struct MHD_Response *resp = NULL;
       int n;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
               rpath = realpath(fpath, NULL);
               if (rpath) {
                       n = strlen(server_data.www_dir);
                       if (!strncmp(server_data.www_dir, rpath, n))
                               resp = create_response_file(nurl,
                                                           method,
                                                           rp_code,
                                                           fpath);
                       free(rpath);
               }
 
                free(fpath);
        }
}
","The vulnerability in the original code lies in the lack of validation for the file path generated by `get_path(nurl, server_data.www_dir)`, which could allow an attacker to exploit directory traversal and access unauthorized files. In the fixed code, the addition of `realpath(fpath, NULL)` ensures that the resolved absolute path is checked against `server_data.www_dir`. This validation prevents the creation of a response for paths outside the intended directory, thereby mitigating the risk of unauthorized file access. The use of `strncmp` further ensures that only paths starting with the expected directory are processed.","The vulnerability in the original code stems from inadequate validation of user-supplied input, allowing potential directory traversal attacks. An attacker could manipulate the input to access sensitive files outside the intended directory, compromising the system's security. The fixed code addresses this issue by implementing a mechanism to resolve the absolute path of the requested file and ensuring it is confined within the designated directory. This added validation step effectively restricts access to only authorized files, thereby mitigating the risk of unauthorized file access and enhancing the overall security of the application."
3,179722,179722,,Remote,Not required,Partial,CVE-2011-3602,https://www.cvedetails.com/cve/CVE-2011-3602/,CWE-22,Low,,Partial,,2014-04-27,6.4,"Directory traversal vulnerability in device-linux.c in the router advertisement daemon (radvd) before 1.8.2 allows local users to overwrite arbitrary files, and remote attackers to overwrite certain files, via a .. (dot dot) in an interface name.  NOTE: this can be leveraged with a symlink to overwrite arbitrary files.",2014-04-28,Dir. Trav. ,4,https://github.com/reubenhwk/radvd/commit/92e22ca23e52066da2258df8c76a2dca8a428bcc,92e22ca23e52066da2258df8c76a2dca8a428bcc,"set_interface_var() doesn't check interface name and blindly does
fopen(path ""/"" ifname, ""w"") on it.  As ""ifname"" is an untrusted input, it
should be checked for "".."" and/or ""/"" in it.  Otherwise, an infected
unprivileged daemon may overwrite contents of file named ""mtu"",
""hoplimit"", etc. in arbitrary location with arbitrary 32-bit value in
decimal representation (""%d"").  If an attacker has a local account or
may create arbitrary symlinks with these names in any location (e.g.
/tmp), any file may be overwritten with a decimal value.",0,device-linux.c,"{""sha"": ""709eebc630e69faa8f5300a45f39c70742fa5add"", ""filename"": ""device-linux.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/reubenhwk/radvd/blob/92e22ca23e52066da2258df8c76a2dca8a428bcc/device-linux.c"", ""raw_url"": ""https://github.com/reubenhwk/radvd/raw/92e22ca23e52066da2258df8c76a2dca8a428bcc/device-linux.c"", ""contents_url"": ""https://api.github.com/repos/reubenhwk/radvd/contents/device-linux.c?ref=92e22ca23e52066da2258df8c76a2dca8a428bcc"", ""patch"": ""@@ -243,6 +243,10 @@ set_interface_var(const char *iface,\n \tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n \t\treturn -1;\n \n+\t/* No path traversal */\n+\tif (strstr(name, \""..\"") || strchr(name, '/'))\n+\t\treturn -1;\n+\n \tif (access(spath, F_OK) != 0)\n \t\treturn -1;\n ""}","set_interface_var(const char *iface,
		  const char *var, const char *name,
		  uint32_t val)
{
	FILE *fp;
	char spath[64+IFNAMSIZ];	/* XXX: magic constant */
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
	/* No path traversal */
	if (strstr(name, "".."") || strchr(name, '/'))
		return -1;

 	if (access(spath, F_OK) != 0)
 		return -1;
 
	fp = fopen(spath, ""w"");
	if (!fp) {
		if (name)
			flog(LOG_ERR, ""failed to set %s (%u) for %s: %s"",
			     name, val, iface, strerror(errno));
		return -1;
	}
	fprintf(fp, ""%u"", val);
	fclose(fp);

	return 0;
}
","set_interface_var(const char *iface,
		  const char *var, const char *name,
		  uint32_t val)
{
	FILE *fp;
	char spath[64+IFNAMSIZ];	/* XXX: magic constant */
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
 	if (access(spath, F_OK) != 0)
 		return -1;
 
	fp = fopen(spath, ""w"");
	if (!fp) {
		if (name)
			flog(LOG_ERR, ""failed to set %s (%u) for %s: %s"",
			     name, val, iface, strerror(errno));
		return -1;
	}
	fprintf(fp, ""%u"", val);
	fclose(fp);

	return 0;
}
",C,"	/* No path traversal */
	if (strstr(name, "".."") || strchr(name, '/'))
		return -1;

",,,"@@ -243,6 +243,10 @@ set_interface_var(const char *iface,
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
+	/* No path traversal */
+	if (strstr(name, "".."") || strchr(name, '/'))
+		return -1;
+
 	if (access(spath, F_OK) != 0)
 		return -1;
 ",radvd,92e22ca23e52066da2258df8c76a2dca8a428bcc,9dfaaaf740ce784541e76e68de4ae04dce2c0921,1,"set_interface_var(const char *iface,
		  const char *var, const char *name,
		  uint32_t val)
{
	FILE *fp;
	char spath[64+IFNAMSIZ];	/* XXX: magic constant */
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
//fix_flaw_line_below:
//	/* No path traversal */
//fix_flaw_line_below:
//	if (strstr(name, "".."") || strchr(name, '/'))
//fix_flaw_line_below:
//		return -1;
//fix_flaw_line_below:
//
 	if (access(spath, F_OK) != 0)
 		return -1;
 
	fp = fopen(spath, ""w"");
	if (!fp) {
		if (name)
			flog(LOG_ERR, ""failed to set %s (%u) for %s: %s"",
			     name, val, iface, strerror(errno));
		return -1;
	}
	fprintf(fp, ""%u"", val);
	fclose(fp);

	return 0;
}
",179722,"set_interface_var(const char *iface,
		  const char *var, const char *name,
		  uint32_t val)
{
	FILE *fp;
	char spath[64+IFNAMSIZ];	/* XXX: magic constant */
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
 	if (access(spath, F_OK) != 0)
 		return -1;
 
	fp = fopen(spath, ""w"");
	if (!fp) {
		if (name)
			flog(LOG_ERR, ""failed to set %s (%u) for %s: %s"",
			     name, val, iface, strerror(errno));
		return -1;
	}
	fprintf(fp, ""%u"", val);
	fclose(fp);

	return 0;
}
","set_interface_var(const char *iface,
		  const char *var, const char *name,
		  uint32_t val)
{
	FILE *fp;
	char spath[64+IFNAMSIZ];	/* XXX: magic constant */
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
	/* No path traversal */
	if (strstr(name, "".."") || strchr(name, '/'))
		return -1;

 	if (access(spath, F_OK) != 0)
 		return -1;
 
	fp = fopen(spath, ""w"");
	if (!fp) {
		if (name)
			flog(LOG_ERR, ""failed to set %s (%u) for %s: %s"",
			     name, val, iface, strerror(errno));
		return -1;
	}
	fprintf(fp, ""%u"", val);
	fclose(fp);

	return 0;
}
","The vulnerability in the original code lies in the lack of validation for the `name` parameter, which could allow for path traversal attacks. Specifically, an attacker could manipulate the `name` variable to include sequences like ""../"" or ""/"" to access unauthorized file paths, potentially leading to arbitrary file writes. In the fixed code, this vulnerability is addressed by adding a check that disallows any occurrence of "".."" or ""/"" in the `name` variable using `strstr(name, "".."")` and `strchr(name, '/')`. This ensures that only valid file paths are processed, enhancing the security of the function.","The vulnerability in the original code stems from inadequate validation of user input, specifically allowing for path traversal attacks. An attacker could exploit this by manipulating input to access or modify files outside the intended directory, potentially leading to unauthorized file writes or data exposure. The fixed code addresses this issue by implementing checks that prevent the inclusion of certain patterns in the user input, effectively blocking attempts to traverse directories or access restricted paths. This enhancement significantly improves the security of the function by ensuring that only safe and intended file paths are processed."
4,179899,179899,,Remote,Not required,,CVE-2015-1191,https://www.cvedetails.com/cve/CVE-2015-1191/,CWE-22,Low,,Partial,,2015-01-21,5.0,Multiple directory traversal vulnerabilities in pigz 2.3.1 allow remote attackers to write to arbitrary files via a (1) full pathname or (2) .. (dot dot) in an archive.,2016-12-02,Dir. Trav. ,23,https://github.com/madler/pigz/commit/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,"When decompressing with -N or -NT, strip any path from header name.

This uses the path of the compressed file combined with the name
from the header as the name of the decompressed output file.  Any
path information in the header name is stripped.  This avoids a
possible vulnerability where absolute or descending paths are put
in the gzip header.",12,pigz.c,"{""sha"": ""38c0d4fec22f33537cc3b26a5e13946a3514c4f1"", ""filename"": ""pigz.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 14, ""changes"": 37, ""blob_url"": ""https://github.com/madler/pigz/blob/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f/pigz.c"", ""raw_url"": ""https://github.com/madler/pigz/raw/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f/pigz.c"", ""contents_url"": ""https://api.github.com/repos/madler/pigz/contents/pigz.c?ref=fdad1406b3ec809f4954ff7cdf9e99eb18c2458f"", ""patch"": ""@@ -3520,26 +3520,35 @@ local void process(char *path)\n                  \"" (use -f to force)\"");\n     }\n     else {\n-        char *to, *repl;\n-\n-        /* use header name for output when decompressing with -N */\n-        to = g.inf;\n-        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {\n-            to = g.hname;\n-            len = strlen(g.hname);\n+        char *to = g.inf, *sufx = \""\"";\n+        size_t pre = 0;\n+\n+        /* select parts of the output file name */\n+        if (g.decode) {\n+            /* for -dN or -dNT, use the path from the input file and the name\n+               from the header, stripping any path in the header name */\n+            if ((g.headis & 1) != 0 && g.hname != NULL) {\n+                pre = justname(g.inf) - g.inf;\n+                to = justname(g.hname);\n+                len = strlen(to);\n+            }\n+            /* for -d or -dNn, replace abbreviated suffixes */\n+            else if (strcmp(to + len, \"".tgz\"") == 0)\n+                sufx = \"".tar\"";\n         }\n-\n-        /* replace .tgz with .tar when decoding */\n-        repl = g.decode && strcmp(to + len, \"".tgz\"") ? \""\"" : \"".tar\"";\n+        else\n+            /* add appropriate suffix when compressing */\n+            sufx = g.sufx;\n \n         /* create output file and open to write */\n-        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);\n+        g.outf = MALLOC(pre + len + strlen(sufx) + 1);\n         if (g.outf == NULL)\n             bail(\""not enough memory\"", \""\"");\n-        memcpy(g.outf, to, len);\n-        strcpy(g.outf + len, g.decode ? repl : g.sufx);\n+        memcpy(g.outf, g.inf, pre);\n+        memcpy(g.outf + pre, to, len);\n+        strcpy(g.outf + pre + len, sufx);\n         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |\n-                             (g.force ? 0 : O_EXCL), 0600);\n+                              (g.force ? 0 : O_EXCL), 0600);\n \n         /* if exists and not -f, give user a chance to overwrite */\n         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {""}","local void process(char *path)
{
    int method = -1;                /* get_header() return value */
    size_t len;                     /* length of base name (minus suffix) */
    struct stat st;                 /* to get file type and mod time */
    /* all compressed suffixes for decoding search, in length order */
    static char *sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"",
                           "".zip"", "".ZIP"", "".tgz"", NULL};

    /* open input file with name in, descriptor ind -- set name and mtime */
    if (path == NULL) {
        strcpy(g.inf, ""<stdin>"");
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ?
                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
        len = 0;
    }
    else {
        /* set input file name (already set if recursed here) */
        if (path != g.inf) {
            strncpy(g.inf, path, sizeof(g.inf));
            if (g.inf[sizeof(g.inf) - 1])
                bail(""name too long: "", path);
        }
        len = strlen(g.inf);

        /* try to stat input file -- if not there and decoding, look for that
           name with compressed suffixes */
        if (lstat(g.inf, &st)) {
            if (errno == ENOENT && (g.list || g.decode)) {
                char **try = sufs;
                do {
                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))
                        break;
                    strcpy(g.inf + len, *try++);
                    errno = 0;
                } while (lstat(g.inf, &st) && errno == ENOENT);
            }
#ifdef EOVERFLOW
            if (errno == EOVERFLOW || errno == EFBIG)
                bail(g.inf,
                    "" too large -- not compiled with large file support"");
#endif
            if (errno) {
                g.inf[len] = 0;
                complain(""%s does not exist -- skipping"", g.inf);
                return;
            }
            len = strlen(g.inf);
        }

        /* only process regular files, but allow symbolic links if -f,
           recurse into directory if -r */
        if ((st.st_mode & S_IFMT) != S_IFREG &&
            (st.st_mode & S_IFMT) != S_IFLNK &&
            (st.st_mode & S_IFMT) != S_IFDIR) {
            complain(""%s is a special file or device -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
            complain(""%s is a symbolic link -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
            complain(""%s is a directory -- skipping"", g.inf);
            return;
        }

        /* recurse into directory (assumes Unix) */
        if ((st.st_mode & S_IFMT) == S_IFDIR) {
            char *roll, *item, *cut, *base, *bigger;
            size_t len, hold;
            DIR *here;
            struct dirent *next;

            /* accumulate list of entries (need to do this, since readdir()
               behavior not defined if directory modified between calls) */
            here = opendir(g.inf);
            if (here == NULL)
                return;
            hold = 512;
            roll = MALLOC(hold);
            if (roll == NULL)
                bail(""not enough memory"", """");
            *roll = 0;
            item = roll;
            while ((next = readdir(here)) != NULL) {
                if (next->d_name[0] == 0 ||
                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                     (next->d_name[1] == '.' && next->d_name[2] == 0))))
                    continue;
                len = strlen(next->d_name) + 1;
                if (item + len + 1 > roll + hold) {
                    do {                    /* make roll bigger */
                        hold <<= 1;
                    } while (item + len + 1 > roll + hold);
                    bigger = REALLOC(roll, hold);
                    if (bigger == NULL) {
                        FREE(roll);
                        bail(""not enough memory"", """");
                    }
                    item = bigger + (item - roll);
                    roll = bigger;
                }
                strcpy(item, next->d_name);
                item += len;
                *item = 0;
            }
            closedir(here);

            /* run process() for each entry in the directory */
            cut = base = g.inf + strlen(g.inf);
            if (base > g.inf && base[-1] != (unsigned char)'/') {
                if ((size_t)(base - g.inf) >= sizeof(g.inf))
                    bail(""path too long"", g.inf);
                *base++ = '/';
            }
            item = roll;
            while (*item) {
                strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                if (g.inf[sizeof(g.inf) - 1]) {
                    strcpy(g.inf + (sizeof(g.inf) - 4), ""..."");
                    bail(""path too long: "", g.inf);
                }
                process(g.inf);
                item += strlen(item) + 1;
            }
            *cut = 0;

            /* release list of entries */
            FREE(roll);
            return;
        }

        /* don't compress .gz (or provided suffix) files, unless -f */
        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&
                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
            complain(""%s ends with %s -- skipping"", g.inf, g.sufx);
            return;
        }

        /* create output file only if input file has compressed suffix */
        if (g.decode == 1 && !g.pipeout && !g.list) {
            int suf = compressed_suffix(g.inf);
            if (suf == 0) {
                complain(""%s does not have compressed suffix -- skipping"",
                         g.inf);
                return;
            }
            len -= suf;
        }

        /* open input file */
        g.ind = open(g.inf, O_RDONLY, 0);
        if (g.ind < 0)
            bail(""read error on "", g.inf);

        /* prepare gzip header information for compression */
        g.name = g.headis & 1 ? justname(g.inf) : NULL;
        g.mtime = g.headis & 2 ? st.st_mtime : 0;
    }
    SET_BINARY_MODE(g.ind);

    /* if decoding or testing, try to read gzip header */
    g.hname = NULL;
    if (g.decode) {
        in_init();
        method = get_header(1);
        if (method != 8 && method != 257 &&
                /* gzip -cdf acts like cat on uncompressed input */
                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&
                  !g.list)) {
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            if (method != -1)
                complain(method < 0 ? ""%s is not compressed -- skipping"" :
                         ""%s has unknown compression method -- skipping"",
                         g.inf);
            return;
        }

        /* if requested, test input file (possibly a special list) */
        if (g.decode == 2) {
            if (method == 8)
                infchk();
            else {
                unlzw();
                if (g.list) {
                    g.in_tot -= 3;
                    show_info(method, 0, g.out_tot, 0);
                }
            }
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }
    }

    /* if requested, just list information about input file */
    if (g.list) {
        list_info();
        RELEASE(g.hname);
        if (g.ind != 0)
            close(g.ind);
        return;
    }

    /* create output file out, descriptor outd */
    if (path == NULL || g.pipeout) {
        /* write to stdout */
        g.outf = MALLOC(strlen(""<stdout>"") + 1);
        if (g.outf == NULL)
            bail(""not enough memory"", """");
        strcpy(g.outf, ""<stdout>"");
        g.outd = 1;
        if (!g.decode && !g.force && isatty(g.outd))
            bail(""trying to write compressed data to a terminal"",
                  "" (use -f to force)"");
     }
     else {
        char *to = g.inf, *sufx = """";
        size_t pre = 0;

        /* select parts of the output file name */
        if (g.decode) {
            /* for -dN or -dNT, use the path from the input file and the name
               from the header, stripping any path in the header name */
            if ((g.headis & 1) != 0 && g.hname != NULL) {
                pre = justname(g.inf) - g.inf;
                to = justname(g.hname);
                len = strlen(to);
            }
            /* for -d or -dNn, replace abbreviated suffixes */
            else if (strcmp(to + len, "".tgz"") == 0)
                sufx = "".tar"";
         }
        else
            /* add appropriate suffix when compressing */
            sufx = g.sufx;
 
         /* create output file and open to write */
        g.outf = MALLOC(pre + len + strlen(sufx) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
        memcpy(g.outf, g.inf, pre);
        memcpy(g.outf + pre, to, len);
        strcpy(g.outf + pre + len, sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
                              (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
            int ch, reply;

            fprintf(stderr, ""%s exists -- overwrite (y/n)? "", g.outf);
            fflush(stderr);
            reply = -1;
            do {
                ch = getchar();
                if (reply < 0 && ch != ' ' && ch != '\t')
                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;
            } while (ch != EOF && ch != '\n' && ch != '\r');
            if (reply == 1)
                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                              0600);
        }

        /* if exists and no overwrite, report and go on to next */
        if (g.outd < 0 && errno == EEXIST) {
            complain(""%s exists -- skipping"", g.outf);
            RELEASE(g.outf);
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }

        /* if some other error, give up */
        if (g.outd < 0)
            bail(""write error on "", g.outf);
    }
    SET_BINARY_MODE(g.outd);
    RELEASE(g.hname);

    /* process ind to outd */
    if (g.verbosity > 1)
        fprintf(stderr, ""%s to %s "", g.inf, g.outf);
    if (g.decode) {
        if (method == 8)
            infchk();
        else if (method == 257)
            unlzw();
        else
            cat();
    }
#ifndef NOTHREAD
    else if (g.procs > 1)
        parallel_compress();
#endif
    else
        single_compress(0);
    if (g.verbosity > 1) {
        putc('\n', stderr);
        fflush(stderr);
    }

    /* finish up, copy attributes, set times, delete original */
    if (g.ind != 0)
        close(g.ind);
    if (g.outd != 1) {
        if (close(g.outd))
            bail(""write error on "", g.outf);
        g.outd = -1;            /* now prevent deletion on interrupt */
        if (g.ind != 0) {
            copymeta(g.inf, g.outf);
            if (!g.keep)
                unlink(g.inf);
        }
        if (g.decode && (g.headis & 2) != 0 && g.stamp)
            touch(g.outf, g.stamp);
    }
    RELEASE(g.outf);
}
","local void process(char *path)
{
    int method = -1;                /* get_header() return value */
    size_t len;                     /* length of base name (minus suffix) */
    struct stat st;                 /* to get file type and mod time */
    /* all compressed suffixes for decoding search, in length order */
    static char *sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"",
                           "".zip"", "".ZIP"", "".tgz"", NULL};

    /* open input file with name in, descriptor ind -- set name and mtime */
    if (path == NULL) {
        strcpy(g.inf, ""<stdin>"");
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ?
                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
        len = 0;
    }
    else {
        /* set input file name (already set if recursed here) */
        if (path != g.inf) {
            strncpy(g.inf, path, sizeof(g.inf));
            if (g.inf[sizeof(g.inf) - 1])
                bail(""name too long: "", path);
        }
        len = strlen(g.inf);

        /* try to stat input file -- if not there and decoding, look for that
           name with compressed suffixes */
        if (lstat(g.inf, &st)) {
            if (errno == ENOENT && (g.list || g.decode)) {
                char **try = sufs;
                do {
                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))
                        break;
                    strcpy(g.inf + len, *try++);
                    errno = 0;
                } while (lstat(g.inf, &st) && errno == ENOENT);
            }
#ifdef EOVERFLOW
            if (errno == EOVERFLOW || errno == EFBIG)
                bail(g.inf,
                    "" too large -- not compiled with large file support"");
#endif
            if (errno) {
                g.inf[len] = 0;
                complain(""%s does not exist -- skipping"", g.inf);
                return;
            }
            len = strlen(g.inf);
        }

        /* only process regular files, but allow symbolic links if -f,
           recurse into directory if -r */
        if ((st.st_mode & S_IFMT) != S_IFREG &&
            (st.st_mode & S_IFMT) != S_IFLNK &&
            (st.st_mode & S_IFMT) != S_IFDIR) {
            complain(""%s is a special file or device -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
            complain(""%s is a symbolic link -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
            complain(""%s is a directory -- skipping"", g.inf);
            return;
        }

        /* recurse into directory (assumes Unix) */
        if ((st.st_mode & S_IFMT) == S_IFDIR) {
            char *roll, *item, *cut, *base, *bigger;
            size_t len, hold;
            DIR *here;
            struct dirent *next;

            /* accumulate list of entries (need to do this, since readdir()
               behavior not defined if directory modified between calls) */
            here = opendir(g.inf);
            if (here == NULL)
                return;
            hold = 512;
            roll = MALLOC(hold);
            if (roll == NULL)
                bail(""not enough memory"", """");
            *roll = 0;
            item = roll;
            while ((next = readdir(here)) != NULL) {
                if (next->d_name[0] == 0 ||
                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                     (next->d_name[1] == '.' && next->d_name[2] == 0))))
                    continue;
                len = strlen(next->d_name) + 1;
                if (item + len + 1 > roll + hold) {
                    do {                    /* make roll bigger */
                        hold <<= 1;
                    } while (item + len + 1 > roll + hold);
                    bigger = REALLOC(roll, hold);
                    if (bigger == NULL) {
                        FREE(roll);
                        bail(""not enough memory"", """");
                    }
                    item = bigger + (item - roll);
                    roll = bigger;
                }
                strcpy(item, next->d_name);
                item += len;
                *item = 0;
            }
            closedir(here);

            /* run process() for each entry in the directory */
            cut = base = g.inf + strlen(g.inf);
            if (base > g.inf && base[-1] != (unsigned char)'/') {
                if ((size_t)(base - g.inf) >= sizeof(g.inf))
                    bail(""path too long"", g.inf);
                *base++ = '/';
            }
            item = roll;
            while (*item) {
                strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                if (g.inf[sizeof(g.inf) - 1]) {
                    strcpy(g.inf + (sizeof(g.inf) - 4), ""..."");
                    bail(""path too long: "", g.inf);
                }
                process(g.inf);
                item += strlen(item) + 1;
            }
            *cut = 0;

            /* release list of entries */
            FREE(roll);
            return;
        }

        /* don't compress .gz (or provided suffix) files, unless -f */
        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&
                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
            complain(""%s ends with %s -- skipping"", g.inf, g.sufx);
            return;
        }

        /* create output file only if input file has compressed suffix */
        if (g.decode == 1 && !g.pipeout && !g.list) {
            int suf = compressed_suffix(g.inf);
            if (suf == 0) {
                complain(""%s does not have compressed suffix -- skipping"",
                         g.inf);
                return;
            }
            len -= suf;
        }

        /* open input file */
        g.ind = open(g.inf, O_RDONLY, 0);
        if (g.ind < 0)
            bail(""read error on "", g.inf);

        /* prepare gzip header information for compression */
        g.name = g.headis & 1 ? justname(g.inf) : NULL;
        g.mtime = g.headis & 2 ? st.st_mtime : 0;
    }
    SET_BINARY_MODE(g.ind);

    /* if decoding or testing, try to read gzip header */
    g.hname = NULL;
    if (g.decode) {
        in_init();
        method = get_header(1);
        if (method != 8 && method != 257 &&
                /* gzip -cdf acts like cat on uncompressed input */
                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&
                  !g.list)) {
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            if (method != -1)
                complain(method < 0 ? ""%s is not compressed -- skipping"" :
                         ""%s has unknown compression method -- skipping"",
                         g.inf);
            return;
        }

        /* if requested, test input file (possibly a special list) */
        if (g.decode == 2) {
            if (method == 8)
                infchk();
            else {
                unlzw();
                if (g.list) {
                    g.in_tot -= 3;
                    show_info(method, 0, g.out_tot, 0);
                }
            }
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }
    }

    /* if requested, just list information about input file */
    if (g.list) {
        list_info();
        RELEASE(g.hname);
        if (g.ind != 0)
            close(g.ind);
        return;
    }

    /* create output file out, descriptor outd */
    if (path == NULL || g.pipeout) {
        /* write to stdout */
        g.outf = MALLOC(strlen(""<stdout>"") + 1);
        if (g.outf == NULL)
            bail(""not enough memory"", """");
        strcpy(g.outf, ""<stdout>"");
        g.outd = 1;
        if (!g.decode && !g.force && isatty(g.outd))
            bail(""trying to write compressed data to a terminal"",
                  "" (use -f to force)"");
     }
     else {
        char *to, *repl;
        /* use header name for output when decompressing with -N */
        to = g.inf;
        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
            to = g.hname;
            len = strlen(g.hname);
         }
        /* replace .tgz with .tar when decoding */
        repl = g.decode && strcmp(to + len, "".tgz"") ? """" : "".tar"";
 
         /* create output file and open to write */
        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
        memcpy(g.outf, to, len);
        strcpy(g.outf + len, g.decode ? repl : g.sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
                             (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
            int ch, reply;

            fprintf(stderr, ""%s exists -- overwrite (y/n)? "", g.outf);
            fflush(stderr);
            reply = -1;
            do {
                ch = getchar();
                if (reply < 0 && ch != ' ' && ch != '\t')
                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;
            } while (ch != EOF && ch != '\n' && ch != '\r');
            if (reply == 1)
                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                              0600);
        }

        /* if exists and no overwrite, report and go on to next */
        if (g.outd < 0 && errno == EEXIST) {
            complain(""%s exists -- skipping"", g.outf);
            RELEASE(g.outf);
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }

        /* if some other error, give up */
        if (g.outd < 0)
            bail(""write error on "", g.outf);
    }
    SET_BINARY_MODE(g.outd);
    RELEASE(g.hname);

    /* process ind to outd */
    if (g.verbosity > 1)
        fprintf(stderr, ""%s to %s "", g.inf, g.outf);
    if (g.decode) {
        if (method == 8)
            infchk();
        else if (method == 257)
            unlzw();
        else
            cat();
    }
#ifndef NOTHREAD
    else if (g.procs > 1)
        parallel_compress();
#endif
    else
        single_compress(0);
    if (g.verbosity > 1) {
        putc('\n', stderr);
        fflush(stderr);
    }

    /* finish up, copy attributes, set times, delete original */
    if (g.ind != 0)
        close(g.ind);
    if (g.outd != 1) {
        if (close(g.outd))
            bail(""write error on "", g.outf);
        g.outd = -1;            /* now prevent deletion on interrupt */
        if (g.ind != 0) {
            copymeta(g.inf, g.outf);
            if (!g.keep)
                unlink(g.inf);
        }
        if (g.decode && (g.headis & 2) != 0 && g.stamp)
            touch(g.outf, g.stamp);
    }
    RELEASE(g.outf);
}
",C,"        char *to = g.inf, *sufx = """";
        size_t pre = 0;

        /* select parts of the output file name */
        if (g.decode) {
            /* for -dN or -dNT, use the path from the input file and the name
               from the header, stripping any path in the header name */
            if ((g.headis & 1) != 0 && g.hname != NULL) {
                pre = justname(g.inf) - g.inf;
                to = justname(g.hname);
                len = strlen(to);
            }
            /* for -d or -dNn, replace abbreviated suffixes */
            else if (strcmp(to + len, "".tgz"") == 0)
                sufx = "".tar"";
        else
            /* add appropriate suffix when compressing */
            sufx = g.sufx;
        g.outf = MALLOC(pre + len + strlen(sufx) + 1);
        memcpy(g.outf, g.inf, pre);
        memcpy(g.outf + pre, to, len);
        strcpy(g.outf + pre + len, sufx);
                              (g.force ? 0 : O_EXCL), 0600);
","        char *to, *repl;
        /* use header name for output when decompressing with -N */
        to = g.inf;
        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
            to = g.hname;
            len = strlen(g.hname);
        /* replace .tgz with .tar when decoding */
        repl = g.decode && strcmp(to + len, "".tgz"") ? """" : "".tar"";
        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
        memcpy(g.outf, to, len);
        strcpy(g.outf + len, g.decode ? repl : g.sufx);
                             (g.force ? 0 : O_EXCL), 0600);
",,"@@ -3520,26 +3520,35 @@ local void process(char *path)
                  "" (use -f to force)"");
     }
     else {
-        char *to, *repl;
-
-        /* use header name for output when decompressing with -N */
-        to = g.inf;
-        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
-            to = g.hname;
-            len = strlen(g.hname);
+        char *to = g.inf, *sufx = """";
+        size_t pre = 0;
+
+        /* select parts of the output file name */
+        if (g.decode) {
+            /* for -dN or -dNT, use the path from the input file and the name
+               from the header, stripping any path in the header name */
+            if ((g.headis & 1) != 0 && g.hname != NULL) {
+                pre = justname(g.inf) - g.inf;
+                to = justname(g.hname);
+                len = strlen(to);
+            }
+            /* for -d or -dNn, replace abbreviated suffixes */
+            else if (strcmp(to + len, "".tgz"") == 0)
+                sufx = "".tar"";
         }
-
-        /* replace .tgz with .tar when decoding */
-        repl = g.decode && strcmp(to + len, "".tgz"") ? """" : "".tar"";
+        else
+            /* add appropriate suffix when compressing */
+            sufx = g.sufx;
 
         /* create output file and open to write */
-        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
+        g.outf = MALLOC(pre + len + strlen(sufx) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
-        memcpy(g.outf, to, len);
-        strcpy(g.outf + len, g.decode ? repl : g.sufx);
+        memcpy(g.outf, g.inf, pre);
+        memcpy(g.outf + pre, to, len);
+        strcpy(g.outf + pre + len, sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
-                             (g.force ? 0 : O_EXCL), 0600);
+                              (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {",pigz,fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,e5318b2cd88f1cb74c0bbce8a618c2b72ec263fb,1,"local void process(char *path)
{
    int method = -1;                /* get_header() return value */
    size_t len;                     /* length of base name (minus suffix) */
    struct stat st;                 /* to get file type and mod time */
    /* all compressed suffixes for decoding search, in length order */
    static char *sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"",
                           "".zip"", "".ZIP"", "".tgz"", NULL};

    /* open input file with name in, descriptor ind -- set name and mtime */
    if (path == NULL) {
        strcpy(g.inf, ""<stdin>"");
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ?
                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
        len = 0;
    }
    else {
        /* set input file name (already set if recursed here) */
        if (path != g.inf) {
            strncpy(g.inf, path, sizeof(g.inf));
            if (g.inf[sizeof(g.inf) - 1])
                bail(""name too long: "", path);
        }
        len = strlen(g.inf);

        /* try to stat input file -- if not there and decoding, look for that
           name with compressed suffixes */
        if (lstat(g.inf, &st)) {
            if (errno == ENOENT && (g.list || g.decode)) {
                char **try = sufs;
                do {
                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))
                        break;
                    strcpy(g.inf + len, *try++);
                    errno = 0;
                } while (lstat(g.inf, &st) && errno == ENOENT);
            }
#ifdef EOVERFLOW
            if (errno == EOVERFLOW || errno == EFBIG)
                bail(g.inf,
                    "" too large -- not compiled with large file support"");
#endif
            if (errno) {
                g.inf[len] = 0;
                complain(""%s does not exist -- skipping"", g.inf);
                return;
            }
            len = strlen(g.inf);
        }

        /* only process regular files, but allow symbolic links if -f,
           recurse into directory if -r */
        if ((st.st_mode & S_IFMT) != S_IFREG &&
            (st.st_mode & S_IFMT) != S_IFLNK &&
            (st.st_mode & S_IFMT) != S_IFDIR) {
            complain(""%s is a special file or device -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
            complain(""%s is a symbolic link -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
            complain(""%s is a directory -- skipping"", g.inf);
            return;
        }

        /* recurse into directory (assumes Unix) */
        if ((st.st_mode & S_IFMT) == S_IFDIR) {
            char *roll, *item, *cut, *base, *bigger;
            size_t len, hold;
            DIR *here;
            struct dirent *next;

            /* accumulate list of entries (need to do this, since readdir()
               behavior not defined if directory modified between calls) */
            here = opendir(g.inf);
            if (here == NULL)
                return;
            hold = 512;
            roll = MALLOC(hold);
            if (roll == NULL)
                bail(""not enough memory"", """");
            *roll = 0;
            item = roll;
            while ((next = readdir(here)) != NULL) {
                if (next->d_name[0] == 0 ||
                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                     (next->d_name[1] == '.' && next->d_name[2] == 0))))
                    continue;
                len = strlen(next->d_name) + 1;
                if (item + len + 1 > roll + hold) {
                    do {                    /* make roll bigger */
                        hold <<= 1;
                    } while (item + len + 1 > roll + hold);
                    bigger = REALLOC(roll, hold);
                    if (bigger == NULL) {
                        FREE(roll);
                        bail(""not enough memory"", """");
                    }
                    item = bigger + (item - roll);
                    roll = bigger;
                }
                strcpy(item, next->d_name);
                item += len;
                *item = 0;
            }
            closedir(here);

            /* run process() for each entry in the directory */
            cut = base = g.inf + strlen(g.inf);
            if (base > g.inf && base[-1] != (unsigned char)'/') {
                if ((size_t)(base - g.inf) >= sizeof(g.inf))
                    bail(""path too long"", g.inf);
                *base++ = '/';
            }
            item = roll;
            while (*item) {
                strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                if (g.inf[sizeof(g.inf) - 1]) {
                    strcpy(g.inf + (sizeof(g.inf) - 4), ""..."");
                    bail(""path too long: "", g.inf);
                }
                process(g.inf);
                item += strlen(item) + 1;
            }
            *cut = 0;

            /* release list of entries */
            FREE(roll);
            return;
        }

        /* don't compress .gz (or provided suffix) files, unless -f */
        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&
                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
            complain(""%s ends with %s -- skipping"", g.inf, g.sufx);
            return;
        }

        /* create output file only if input file has compressed suffix */
        if (g.decode == 1 && !g.pipeout && !g.list) {
            int suf = compressed_suffix(g.inf);
            if (suf == 0) {
                complain(""%s does not have compressed suffix -- skipping"",
                         g.inf);
                return;
            }
            len -= suf;
        }

        /* open input file */
        g.ind = open(g.inf, O_RDONLY, 0);
        if (g.ind < 0)
            bail(""read error on "", g.inf);

        /* prepare gzip header information for compression */
        g.name = g.headis & 1 ? justname(g.inf) : NULL;
        g.mtime = g.headis & 2 ? st.st_mtime : 0;
    }
    SET_BINARY_MODE(g.ind);

    /* if decoding or testing, try to read gzip header */
    g.hname = NULL;
    if (g.decode) {
        in_init();
        method = get_header(1);
        if (method != 8 && method != 257 &&
                /* gzip -cdf acts like cat on uncompressed input */
                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&
                  !g.list)) {
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            if (method != -1)
                complain(method < 0 ? ""%s is not compressed -- skipping"" :
                         ""%s has unknown compression method -- skipping"",
                         g.inf);
            return;
        }

        /* if requested, test input file (possibly a special list) */
        if (g.decode == 2) {
            if (method == 8)
                infchk();
            else {
                unlzw();
                if (g.list) {
                    g.in_tot -= 3;
                    show_info(method, 0, g.out_tot, 0);
                }
            }
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }
    }

    /* if requested, just list information about input file */
    if (g.list) {
        list_info();
        RELEASE(g.hname);
        if (g.ind != 0)
            close(g.ind);
        return;
    }

    /* create output file out, descriptor outd */
    if (path == NULL || g.pipeout) {
        /* write to stdout */
        g.outf = MALLOC(strlen(""<stdout>"") + 1);
        if (g.outf == NULL)
            bail(""not enough memory"", """");
        strcpy(g.outf, ""<stdout>"");
        g.outd = 1;
        if (!g.decode && !g.force && isatty(g.outd))
            bail(""trying to write compressed data to a terminal"",
                  "" (use -f to force)"");
     }
     else {
//flaw_line_below:
        char *to, *repl;
//flaw_line_below:

//flaw_line_below:
        /* use header name for output when decompressing with -N */
//flaw_line_below:
        to = g.inf;
//flaw_line_below:
        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
//flaw_line_below:
            to = g.hname;
//flaw_line_below:
            len = strlen(g.hname);
//fix_flaw_line_below:
//        char *to = g.inf, *sufx = """";
//fix_flaw_line_below:
//        size_t pre = 0;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        /* select parts of the output file name */
//fix_flaw_line_below:
//        if (g.decode) {
//fix_flaw_line_below:
//            /* for -dN or -dNT, use the path from the input file and the name
//fix_flaw_line_below:
//               from the header, stripping any path in the header name */
//fix_flaw_line_below:
//            if ((g.headis & 1) != 0 && g.hname != NULL) {
//fix_flaw_line_below:
//                pre = justname(g.inf) - g.inf;
//fix_flaw_line_below:
//                to = justname(g.hname);
//fix_flaw_line_below:
//                len = strlen(to);
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//            /* for -d or -dNn, replace abbreviated suffixes */
//fix_flaw_line_below:
//            else if (strcmp(to + len, "".tgz"") == 0)
//fix_flaw_line_below:
//                sufx = "".tar"";
         }
//flaw_line_below:

//flaw_line_below:
        /* replace .tgz with .tar when decoding */
//flaw_line_below:
        repl = g.decode && strcmp(to + len, "".tgz"") ? """" : "".tar"";
//fix_flaw_line_below:
//        else
//fix_flaw_line_below:
//            /* add appropriate suffix when compressing */
//fix_flaw_line_below:
//            sufx = g.sufx;
 
         /* create output file and open to write */
//flaw_line_below:
        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
//fix_flaw_line_below:
//        g.outf = MALLOC(pre + len + strlen(sufx) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
//flaw_line_below:
        memcpy(g.outf, to, len);
//flaw_line_below:
        strcpy(g.outf + len, g.decode ? repl : g.sufx);
//fix_flaw_line_below:
//        memcpy(g.outf, g.inf, pre);
//fix_flaw_line_below:
//        memcpy(g.outf + pre, to, len);
//fix_flaw_line_below:
//        strcpy(g.outf + pre + len, sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
//flaw_line_below:
                             (g.force ? 0 : O_EXCL), 0600);
//fix_flaw_line_below:
//                              (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
            int ch, reply;

            fprintf(stderr, ""%s exists -- overwrite (y/n)? "", g.outf);
            fflush(stderr);
            reply = -1;
            do {
                ch = getchar();
                if (reply < 0 && ch != ' ' && ch != '\t')
                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;
            } while (ch != EOF && ch != '\n' && ch != '\r');
            if (reply == 1)
                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                              0600);
        }

        /* if exists and no overwrite, report and go on to next */
        if (g.outd < 0 && errno == EEXIST) {
            complain(""%s exists -- skipping"", g.outf);
            RELEASE(g.outf);
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }

        /* if some other error, give up */
        if (g.outd < 0)
            bail(""write error on "", g.outf);
    }
    SET_BINARY_MODE(g.outd);
    RELEASE(g.hname);

    /* process ind to outd */
    if (g.verbosity > 1)
        fprintf(stderr, ""%s to %s "", g.inf, g.outf);
    if (g.decode) {
        if (method == 8)
            infchk();
        else if (method == 257)
            unlzw();
        else
            cat();
    }
#ifndef NOTHREAD
    else if (g.procs > 1)
        parallel_compress();
#endif
    else
        single_compress(0);
    if (g.verbosity > 1) {
        putc('\n', stderr);
        fflush(stderr);
    }

    /* finish up, copy attributes, set times, delete original */
    if (g.ind != 0)
        close(g.ind);
    if (g.outd != 1) {
        if (close(g.outd))
            bail(""write error on "", g.outf);
        g.outd = -1;            /* now prevent deletion on interrupt */
        if (g.ind != 0) {
            copymeta(g.inf, g.outf);
            if (!g.keep)
                unlink(g.inf);
        }
        if (g.decode && (g.headis & 2) != 0 && g.stamp)
            touch(g.outf, g.stamp);
    }
    RELEASE(g.outf);
}
",179899,"local void process(char *path)
{
    int method = -1;                /* get_header() return value */
    size_t len;                     /* length of base name (minus suffix) */
    struct stat st;                 /* to get file type and mod time */
    /* all compressed suffixes for decoding search, in length order */
    static char *sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"",
                           "".zip"", "".ZIP"", "".tgz"", NULL};

    /* open input file with name in, descriptor ind -- set name and mtime */
    if (path == NULL) {
        strcpy(g.inf, ""<stdin>"");
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ?
                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
        len = 0;
    }
    else {
        /* set input file name (already set if recursed here) */
        if (path != g.inf) {
            strncpy(g.inf, path, sizeof(g.inf));
            if (g.inf[sizeof(g.inf) - 1])
                bail(""name too long: "", path);
        }
        len = strlen(g.inf);

        /* try to stat input file -- if not there and decoding, look for that
           name with compressed suffixes */
        if (lstat(g.inf, &st)) {
            if (errno == ENOENT && (g.list || g.decode)) {
                char **try = sufs;
                do {
                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))
                        break;
                    strcpy(g.inf + len, *try++);
                    errno = 0;
                } while (lstat(g.inf, &st) && errno == ENOENT);
            }
#ifdef EOVERFLOW
            if (errno == EOVERFLOW || errno == EFBIG)
                bail(g.inf,
                    "" too large -- not compiled with large file support"");
#endif
            if (errno) {
                g.inf[len] = 0;
                complain(""%s does not exist -- skipping"", g.inf);
                return;
            }
            len = strlen(g.inf);
        }

        /* only process regular files, but allow symbolic links if -f,
           recurse into directory if -r */
        if ((st.st_mode & S_IFMT) != S_IFREG &&
            (st.st_mode & S_IFMT) != S_IFLNK &&
            (st.st_mode & S_IFMT) != S_IFDIR) {
            complain(""%s is a special file or device -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
            complain(""%s is a symbolic link -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
            complain(""%s is a directory -- skipping"", g.inf);
            return;
        }

        /* recurse into directory (assumes Unix) */
        if ((st.st_mode & S_IFMT) == S_IFDIR) {
            char *roll, *item, *cut, *base, *bigger;
            size_t len, hold;
            DIR *here;
            struct dirent *next;

            /* accumulate list of entries (need to do this, since readdir()
               behavior not defined if directory modified between calls) */
            here = opendir(g.inf);
            if (here == NULL)
                return;
            hold = 512;
            roll = MALLOC(hold);
            if (roll == NULL)
                bail(""not enough memory"", """");
            *roll = 0;
            item = roll;
            while ((next = readdir(here)) != NULL) {
                if (next->d_name[0] == 0 ||
                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                     (next->d_name[1] == '.' && next->d_name[2] == 0))))
                    continue;
                len = strlen(next->d_name) + 1;
                if (item + len + 1 > roll + hold) {
                    do {                    /* make roll bigger */
                        hold <<= 1;
                    } while (item + len + 1 > roll + hold);
                    bigger = REALLOC(roll, hold);
                    if (bigger == NULL) {
                        FREE(roll);
                        bail(""not enough memory"", """");
                    }
                    item = bigger + (item - roll);
                    roll = bigger;
                }
                strcpy(item, next->d_name);
                item += len;
                *item = 0;
            }
            closedir(here);

            /* run process() for each entry in the directory */
            cut = base = g.inf + strlen(g.inf);
            if (base > g.inf && base[-1] != (unsigned char)'/') {
                if ((size_t)(base - g.inf) >= sizeof(g.inf))
                    bail(""path too long"", g.inf);
                *base++ = '/';
            }
            item = roll;
            while (*item) {
                strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                if (g.inf[sizeof(g.inf) - 1]) {
                    strcpy(g.inf + (sizeof(g.inf) - 4), ""..."");
                    bail(""path too long: "", g.inf);
                }
                process(g.inf);
                item += strlen(item) + 1;
            }
            *cut = 0;

            /* release list of entries */
            FREE(roll);
            return;
        }

        /* don't compress .gz (or provided suffix) files, unless -f */
        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&
                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
            complain(""%s ends with %s -- skipping"", g.inf, g.sufx);
            return;
        }

        /* create output file only if input file has compressed suffix */
        if (g.decode == 1 && !g.pipeout && !g.list) {
            int suf = compressed_suffix(g.inf);
            if (suf == 0) {
                complain(""%s does not have compressed suffix -- skipping"",
                         g.inf);
                return;
            }
            len -= suf;
        }

        /* open input file */
        g.ind = open(g.inf, O_RDONLY, 0);
        if (g.ind < 0)
            bail(""read error on "", g.inf);

        /* prepare gzip header information for compression */
        g.name = g.headis & 1 ? justname(g.inf) : NULL;
        g.mtime = g.headis & 2 ? st.st_mtime : 0;
    }
    SET_BINARY_MODE(g.ind);

    /* if decoding or testing, try to read gzip header */
    g.hname = NULL;
    if (g.decode) {
        in_init();
        method = get_header(1);
        if (method != 8 && method != 257 &&
                /* gzip -cdf acts like cat on uncompressed input */
                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&
                  !g.list)) {
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            if (method != -1)
                complain(method < 0 ? ""%s is not compressed -- skipping"" :
                         ""%s has unknown compression method -- skipping"",
                         g.inf);
            return;
        }

        /* if requested, test input file (possibly a special list) */
        if (g.decode == 2) {
            if (method == 8)
                infchk();
            else {
                unlzw();
                if (g.list) {
                    g.in_tot -= 3;
                    show_info(method, 0, g.out_tot, 0);
                }
            }
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }
    }

    /* if requested, just list information about input file */
    if (g.list) {
        list_info();
        RELEASE(g.hname);
        if (g.ind != 0)
            close(g.ind);
        return;
    }

    /* create output file out, descriptor outd */
    if (path == NULL || g.pipeout) {
        /* write to stdout */
        g.outf = MALLOC(strlen(""<stdout>"") + 1);
        if (g.outf == NULL)
            bail(""not enough memory"", """");
        strcpy(g.outf, ""<stdout>"");
        g.outd = 1;
        if (!g.decode && !g.force && isatty(g.outd))
            bail(""trying to write compressed data to a terminal"",
                  "" (use -f to force)"");
     }
     else {
        char *to, *repl;
        /* use header name for output when decompressing with -N */
        to = g.inf;
        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
            to = g.hname;
            len = strlen(g.hname);
         }
        /* replace .tgz with .tar when decoding */
        repl = g.decode && strcmp(to + len, "".tgz"") ? """" : "".tar"";
 
         /* create output file and open to write */
        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
        memcpy(g.outf, to, len);
        strcpy(g.outf + len, g.decode ? repl : g.sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
                             (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
            int ch, reply;

            fprintf(stderr, ""%s exists -- overwrite (y/n)? "", g.outf);
            fflush(stderr);
            reply = -1;
            do {
                ch = getchar();
                if (reply < 0 && ch != ' ' && ch != '\t')
                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;
            } while (ch != EOF && ch != '\n' && ch != '\r');
            if (reply == 1)
                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                              0600);
        }

        /* if exists and no overwrite, report and go on to next */
        if (g.outd < 0 && errno == EEXIST) {
            complain(""%s exists -- skipping"", g.outf);
            RELEASE(g.outf);
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }

        /* if some other error, give up */
        if (g.outd < 0)
            bail(""write error on "", g.outf);
    }
    SET_BINARY_MODE(g.outd);
    RELEASE(g.hname);

    /* process ind to outd */
    if (g.verbosity > 1)
        fprintf(stderr, ""%s to %s "", g.inf, g.outf);
    if (g.decode) {
        if (method == 8)
            infchk();
        else if (method == 257)
            unlzw();
        else
            cat();
    }
#ifndef NOTHREAD
    else if (g.procs > 1)
        parallel_compress();
#endif
    else
        single_compress(0);
    if (g.verbosity > 1) {
        putc('\n', stderr);
        fflush(stderr);
    }

    /* finish up, copy attributes, set times, delete original */
    if (g.ind != 0)
        close(g.ind);
    if (g.outd != 1) {
        if (close(g.outd))
            bail(""write error on "", g.outf);
        g.outd = -1;            /* now prevent deletion on interrupt */
        if (g.ind != 0) {
            copymeta(g.inf, g.outf);
            if (!g.keep)
                unlink(g.inf);
        }
        if (g.decode && (g.headis & 2) != 0 && g.stamp)
            touch(g.outf, g.stamp);
    }
    RELEASE(g.outf);
}
","local void process(char *path)
{
    int method = -1;                /* get_header() return value */
    size_t len;                     /* length of base name (minus suffix) */
    struct stat st;                 /* to get file type and mod time */
    /* all compressed suffixes for decoding search, in length order */
    static char *sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"",
                           "".zip"", "".ZIP"", "".tgz"", NULL};

    /* open input file with name in, descriptor ind -- set name and mtime */
    if (path == NULL) {
        strcpy(g.inf, ""<stdin>"");
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ?
                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
        len = 0;
    }
    else {
        /* set input file name (already set if recursed here) */
        if (path != g.inf) {
            strncpy(g.inf, path, sizeof(g.inf));
            if (g.inf[sizeof(g.inf) - 1])
                bail(""name too long: "", path);
        }
        len = strlen(g.inf);

        /* try to stat input file -- if not there and decoding, look for that
           name with compressed suffixes */
        if (lstat(g.inf, &st)) {
            if (errno == ENOENT && (g.list || g.decode)) {
                char **try = sufs;
                do {
                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))
                        break;
                    strcpy(g.inf + len, *try++);
                    errno = 0;
                } while (lstat(g.inf, &st) && errno == ENOENT);
            }
#ifdef EOVERFLOW
            if (errno == EOVERFLOW || errno == EFBIG)
                bail(g.inf,
                    "" too large -- not compiled with large file support"");
#endif
            if (errno) {
                g.inf[len] = 0;
                complain(""%s does not exist -- skipping"", g.inf);
                return;
            }
            len = strlen(g.inf);
        }

        /* only process regular files, but allow symbolic links if -f,
           recurse into directory if -r */
        if ((st.st_mode & S_IFMT) != S_IFREG &&
            (st.st_mode & S_IFMT) != S_IFLNK &&
            (st.st_mode & S_IFMT) != S_IFDIR) {
            complain(""%s is a special file or device -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
            complain(""%s is a symbolic link -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
            complain(""%s is a directory -- skipping"", g.inf);
            return;
        }

        /* recurse into directory (assumes Unix) */
        if ((st.st_mode & S_IFMT) == S_IFDIR) {
            char *roll, *item, *cut, *base, *bigger;
            size_t len, hold;
            DIR *here;
            struct dirent *next;

            /* accumulate list of entries (need to do this, since readdir()
               behavior not defined if directory modified between calls) */
            here = opendir(g.inf);
            if (here == NULL)
                return;
            hold = 512;
            roll = MALLOC(hold);
            if (roll == NULL)
                bail(""not enough memory"", """");
            *roll = 0;
            item = roll;
            while ((next = readdir(here)) != NULL) {
                if (next->d_name[0] == 0 ||
                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                     (next->d_name[1] == '.' && next->d_name[2] == 0))))
                    continue;
                len = strlen(next->d_name) + 1;
                if (item + len + 1 > roll + hold) {
                    do {                    /* make roll bigger */
                        hold <<= 1;
                    } while (item + len + 1 > roll + hold);
                    bigger = REALLOC(roll, hold);
                    if (bigger == NULL) {
                        FREE(roll);
                        bail(""not enough memory"", """");
                    }
                    item = bigger + (item - roll);
                    roll = bigger;
                }
                strcpy(item, next->d_name);
                item += len;
                *item = 0;
            }
            closedir(here);

            /* run process() for each entry in the directory */
            cut = base = g.inf + strlen(g.inf);
            if (base > g.inf && base[-1] != (unsigned char)'/') {
                if ((size_t)(base - g.inf) >= sizeof(g.inf))
                    bail(""path too long"", g.inf);
                *base++ = '/';
            }
            item = roll;
            while (*item) {
                strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                if (g.inf[sizeof(g.inf) - 1]) {
                    strcpy(g.inf + (sizeof(g.inf) - 4), ""..."");
                    bail(""path too long: "", g.inf);
                }
                process(g.inf);
                item += strlen(item) + 1;
            }
            *cut = 0;

            /* release list of entries */
            FREE(roll);
            return;
        }

        /* don't compress .gz (or provided suffix) files, unless -f */
        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&
                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
            complain(""%s ends with %s -- skipping"", g.inf, g.sufx);
            return;
        }

        /* create output file only if input file has compressed suffix */
        if (g.decode == 1 && !g.pipeout && !g.list) {
            int suf = compressed_suffix(g.inf);
            if (suf == 0) {
                complain(""%s does not have compressed suffix -- skipping"",
                         g.inf);
                return;
            }
            len -= suf;
        }

        /* open input file */
        g.ind = open(g.inf, O_RDONLY, 0);
        if (g.ind < 0)
            bail(""read error on "", g.inf);

        /* prepare gzip header information for compression */
        g.name = g.headis & 1 ? justname(g.inf) : NULL;
        g.mtime = g.headis & 2 ? st.st_mtime : 0;
    }
    SET_BINARY_MODE(g.ind);

    /* if decoding or testing, try to read gzip header */
    g.hname = NULL;
    if (g.decode) {
        in_init();
        method = get_header(1);
        if (method != 8 && method != 257 &&
                /* gzip -cdf acts like cat on uncompressed input */
                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&
                  !g.list)) {
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            if (method != -1)
                complain(method < 0 ? ""%s is not compressed -- skipping"" :
                         ""%s has unknown compression method -- skipping"",
                         g.inf);
            return;
        }

        /* if requested, test input file (possibly a special list) */
        if (g.decode == 2) {
            if (method == 8)
                infchk();
            else {
                unlzw();
                if (g.list) {
                    g.in_tot -= 3;
                    show_info(method, 0, g.out_tot, 0);
                }
            }
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }
    }

    /* if requested, just list information about input file */
    if (g.list) {
        list_info();
        RELEASE(g.hname);
        if (g.ind != 0)
            close(g.ind);
        return;
    }

    /* create output file out, descriptor outd */
    if (path == NULL || g.pipeout) {
        /* write to stdout */
        g.outf = MALLOC(strlen(""<stdout>"") + 1);
        if (g.outf == NULL)
            bail(""not enough memory"", """");
        strcpy(g.outf, ""<stdout>"");
        g.outd = 1;
        if (!g.decode && !g.force && isatty(g.outd))
            bail(""trying to write compressed data to a terminal"",
                  "" (use -f to force)"");
     }
     else {
        char *to = g.inf, *sufx = """";
        size_t pre = 0;

        /* select parts of the output file name */
        if (g.decode) {
            /* for -dN or -dNT, use the path from the input file and the name
               from the header, stripping any path in the header name */
            if ((g.headis & 1) != 0 && g.hname != NULL) {
                pre = justname(g.inf) - g.inf;
                to = justname(g.hname);
                len = strlen(to);
            }
            /* for -d or -dNn, replace abbreviated suffixes */
            else if (strcmp(to + len, "".tgz"") == 0)
                sufx = "".tar"";
         }
        else
            /* add appropriate suffix when compressing */
            sufx = g.sufx;
 
         /* create output file and open to write */
        g.outf = MALLOC(pre + len + strlen(sufx) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
        memcpy(g.outf, g.inf, pre);
        memcpy(g.outf + pre, to, len);
        strcpy(g.outf + pre + len, sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
                              (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
            int ch, reply;

            fprintf(stderr, ""%s exists -- overwrite (y/n)? "", g.outf);
            fflush(stderr);
            reply = -1;
            do {
                ch = getchar();
                if (reply < 0 && ch != ' ' && ch != '\t')
                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;
            } while (ch != EOF && ch != '\n' && ch != '\r');
            if (reply == 1)
                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                              0600);
        }

        /* if exists and no overwrite, report and go on to next */
        if (g.outd < 0 && errno == EEXIST) {
            complain(""%s exists -- skipping"", g.outf);
            RELEASE(g.outf);
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }

        /* if some other error, give up */
        if (g.outd < 0)
            bail(""write error on "", g.outf);
    }
    SET_BINARY_MODE(g.outd);
    RELEASE(g.hname);

    /* process ind to outd */
    if (g.verbosity > 1)
        fprintf(stderr, ""%s to %s "", g.inf, g.outf);
    if (g.decode) {
        if (method == 8)
            infchk();
        else if (method == 257)
            unlzw();
        else
            cat();
    }
#ifndef NOTHREAD
    else if (g.procs > 1)
        parallel_compress();
#endif
    else
        single_compress(0);
    if (g.verbosity > 1) {
        putc('\n', stderr);
        fflush(stderr);
    }

    /* finish up, copy attributes, set times, delete original */
    if (g.ind != 0)
        close(g.ind);
    if (g.outd != 1) {
        if (close(g.outd))
            bail(""write error on "", g.outf);
        g.outd = -1;            /* now prevent deletion on interrupt */
        if (g.ind != 0) {
            copymeta(g.inf, g.outf);
            if (!g.keep)
                unlink(g.inf);
        }
        if (g.decode && (g.headis & 2) != 0 && g.stamp)
            touch(g.outf, g.stamp);
    }
    RELEASE(g.outf);
}
","The vulnerability in the original code lies in the handling of file paths, particularly when constructing output file names. The code uses `strncpy` and `strcpy` without proper bounds checking, which can lead to buffer overflows if the input path exceeds the size of `g.inf`. This could allow an attacker to manipulate the input to overwrite memory, potentially leading to arbitrary code execution. The fixed code addresses this by ensuring that the output file name is constructed safely, using `memcpy` and calculating the required lengths, thus preventing buffer overflows and enhancing overall security.","The vulnerability in the original code stems from inadequate handling of file paths, particularly in the construction of output file names, which can lead to buffer overflows. This occurs when the code does not properly check the lengths of input paths before copying them into fixed-size buffers, allowing for potential memory corruption and exploitation. The revised code mitigates this risk by implementing safer memory management practices, ensuring that the output file name is constructed with careful length calculations and appropriate memory allocation, thereby preventing buffer overflows and enhancing the overall security of the application."
5,181815,181815,,Remote,Not required,,CVE-2016-10048,https://www.cvedetails.com/cve/CVE-2016-10048/,CWE-22,Low,,Partial,,2017-03-23,5.0,Directory traversal vulnerability in magick/module.c in ImageMagick 6.9.4-7 allows remote attackers to load arbitrary modules via unspecified vectors.,2017-03-24,Dir. Trav. ,4,https://github.com/ImageMagick/ImageMagick/commit/fc6080f1321fd21e86ef916195cc110b05d9effb,fc6080f1321fd21e86ef916195cc110b05d9effb,"Coder path traversal is not authorized, bug report provided by Masaaki Chida",1,magick/xml-tree.c,"{""sha"": ""0a6aefdf34546cdf939c6f37398cd48153cc4727"", ""filename"": ""ChangeLog"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/fc6080f1321fd21e86ef916195cc110b05d9effb/ChangeLog"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/fc6080f1321fd21e86ef916195cc110b05d9effb/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/ChangeLog?ref=fc6080f1321fd21e86ef916195cc110b05d9effb"", ""patch"": ""@@ -1,3 +1,8 @@\n+2016-06-02  6.9.4-7 Cristy  <quetzlzacatenango@image...>\n+  * Fix small memory leak (patch provided by \u0410\u043d\u0434\u0440\u0435\u0439 \u0427\u0435\u0440\u043d\u044b\u0439).\n+  * Coder path traversal is not authorized (bug report provided by\n+    Masaaki Chida).\n+\n 2016-05-31  6.9.4-6 Cristy  <quetzlzacatenango@image...>\n   * Release ImageMagick version 6.9.4-6, GIT revision 18334:97775b5:20160531.\n ""}<_**next**_>{""sha"": ""a00b76d64018ebcaaac7c4728e9e10cd94a7d650"", ""filename"": ""magick/module.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/fc6080f1321fd21e86ef916195cc110b05d9effb/magick/module.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/fc6080f1321fd21e86ef916195cc110b05d9effb/magick/module.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/magick/module.c?ref=fc6080f1321fd21e86ef916195cc110b05d9effb"", ""patch"": ""@@ -547,6 +547,15 @@ static MagickBooleanType GetMagickModulePath(const char *filename,\n   assert(path != (char *) NULL);\n   assert(exception != (ExceptionInfo *) NULL);\n   (void) CopyMagickString(path,filename,MaxTextExtent);\n+#if defined(MAGICKCORE_INSTALLED_SUPPORT)\n+  if (strstr(path,\""../\"") != (char *) NULL)\n+    {\n+      errno=EPERM;\n+      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n+        \""NotAuthorized\"",\""`%s'\"",path);\n+      return(MagickFalse);\n+    }\n+#endif\n   module_path=(char *) NULL;\n   switch (module_type)\n   {""}<_**next**_>{""sha"": ""efe48065ed5e94de9c280e64e6ec0d8d6904c23b"", ""filename"": ""magick/xml-tree.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/fc6080f1321fd21e86ef916195cc110b05d9effb/magick/xml-tree.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/fc6080f1321fd21e86ef916195cc110b05d9effb/magick/xml-tree.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/magick/xml-tree.c?ref=fc6080f1321fd21e86ef916195cc110b05d9effb"", ""patch"": ""@@ -2140,7 +2140,10 @@ MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)\n                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))\n                   ParseOpenTag(root,tag,attributes);\n                 else\n-                  ignore_depth++;\n+                  {\n+                    ignore_depth++;\n+                    (void) DestroyXMLTreeAttributes(attributes);\n+                  }\n                 *p=c;\n               }\n             else""}","MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
{
  char
    **attribute,
    **attributes,
    *tag,
    *utf8;

  int
    c,
    terminal;

  MagickBooleanType
    status;

  register char
    *p;

  register ssize_t
    i;

  size_t
    ignore_depth,
    length;

  ssize_t
    j,
    l;

  XMLTreeRoot
    *root;

  /*
    Convert xml-string to UTF8.
  */
  if ((xml == (const char *) NULL) || (strlen(xml) == 0))
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return((XMLTreeInfo *) NULL);
    }
  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);
  length=strlen(xml);
  utf8=ConvertUTF16ToUTF8(xml,&length);
  if (utf8 == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""UTF16 to UTF8 failed"");
      return((XMLTreeInfo *) NULL);
    }
  terminal=utf8[length-1];
  utf8[length-1]='\0';
  p=utf8;
  while ((*p != '\0') && (*p != '<'))
    p++;
  if (*p == '\0')
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      utf8=DestroyString(utf8);
      return((XMLTreeInfo *) NULL);
    }
  attribute=(char **) NULL;
  l=0;
  ignore_depth=0;
  for (p++; ; p++)
  {
    attributes=(char **) sentinel;
    tag=p;
    c=(*p);
    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||
        (*p == ':') || (c < '\0'))
      {
        /*
          Tag.
        */
        if (root->node == (XMLTreeInfo *) NULL)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,""ParseError"",""root tag missing"");
            utf8=DestroyString(utf8);
            return(&root->root);
          }
        p+=strcspn(p,XMLWhitespace ""/>"");
        while (isspace((int) ((unsigned char) *p)) != 0)
          *p++='\0';
        if (ignore_depth == 0)
          {
            if ((*p != '\0') && (*p != '/') && (*p != '>'))
              {
                /*
                  Find tag in default attributes list.
                */
                i=0;
                while ((root->attributes[i] != (char **) NULL) &&
                       (strcmp(root->attributes[i][0],tag) != 0))
                  i++;
                attribute=root->attributes[i];
              }
            for (l=0; (*p != '\0') && (*p != '/') && (*p != '>'); l+=2)
            {
              /*
                Attribute.
              */
              if (l == 0)
                attributes=(char **) AcquireQuantumMemory(4,
                  sizeof(*attributes));
              else
                attributes=(char **) ResizeQuantumMemory(attributes,
                  (size_t) (l+4),sizeof(*attributes));
              if (attributes == (char **) NULL)
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
              attributes[l+2]=(char *) NULL;
              attributes[l+1]=(char *) NULL;
              attributes[l]=p;
              p+=strcspn(p,XMLWhitespace ""=/>"");
              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))
                attributes[l]=ConstantString("""");
              else
                {
                  *p++='\0';
                  p+=strspn(p,XMLWhitespace ""="");
                  c=(*p);
                  if ((c == '""') || (c == '\''))
                    {
                      /*
                        Attributes value.
                      */
                      p++;
                      attributes[l+1]=p;
                      while ((*p != '\0') && (*p != c))
                        p++;
                      if (*p != '\0')
                        *p++='\0';
                      else
                        {
                          attributes[l]=ConstantString("""");
                          attributes[l+1]=ConstantString("""");
                          (void) DestroyXMLTreeAttributes(attributes);
                          (void) ThrowMagickException(exception,
                            GetMagickModule(),OptionWarning,""ParseError"",
                            ""missing %c"",c);
                          utf8=DestroyString(utf8);
                          return(&root->root);
                        }
                      j=1;
                      while ((attribute != (char **) NULL) &&
                             (attribute[j] != (char *) NULL) &&
                             (strcmp(attribute[j],attributes[l]) != 0))
                        j+=3;
                      attributes[l+1]=ParseEntities(attributes[l+1],
                        root->entities,(attribute != (char **) NULL) &&
                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :
                        ' ');
                    }
                  attributes[l]=ConstantString(attributes[l]);
                }
              while (isspace((int) ((unsigned char) *p)) != 0)
                p++;
            }
          }
        else
          {
            while((*p != '\0') && (*p != '/') && (*p != '>'))
              p++;
          }
        if (*p == '/')
          {
            /*
              Self closing tag.
            */
            *p++='\0';
            if (((*p != '\0') && (*p != '>')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
              {
                ParseOpenTag(root,tag,attributes);
                (void) ParseCloseTag(root,tag,exception);
              }
          }
        else
          {
            c=(*p);
            if ((*p == '>') || ((*p == '\0') && (terminal == '>')))
              {
                *p='\0';
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
                  {
                    ignore_depth++;
                    (void) DestroyXMLTreeAttributes(attributes);
                  }
                 *p=c;
               }
             else
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
      }
    else
      if (*p == '/')
        {
          /*
            Close tag.
          */
          tag=p+1;
          p+=strcspn(tag,XMLWhitespace "">"")+1;
          c=(*p);
          if ((c == '\0') && (terminal != '>'))
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,""ParseError"",""missing >"");
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          *p='\0';
          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=
              (XMLTreeInfo *) NULL)
            {
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          if (ignore_depth > 0)
            ignore_depth--;
          *p=c;
          if (isspace((int) ((unsigned char) *p)) != 0)
            p+=strspn(p,XMLWhitespace);
        }
      else
        if (strncmp(p,""!--"",3) == 0)
          {
            /*
              Comment.
            */
            p=strstr(p+3,""--"");
            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\0')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""unclosed <!--"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
        else
          if (strncmp(p,""![CDATA["",8) == 0)
            {
              /*
                Cdata.
              */
              p=strstr(p,""]]>"");
              if (p != (char *) NULL)
                {
                  p+=2;
                  if (ignore_depth == 0)
                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unclosed <![CDATA["");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
            }
          else
            if (strncmp(p,""!DOCTYPE"",8) == 0)
              {
                /*
                  DTD.
                */
                for (l=0; (*p != '\0') && (((l == 0) && (*p != '>')) ||
                     ((l != 0) && ((*p != ']') ||
                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));
                  l=(ssize_t) ((*p == '[') ? 1 : l))
                p+=strcspn(p+1,""[]>"")+1;
                if ((*p == '\0') && (terminal != '>'))
                  {
                    (void) ThrowMagickException(exception,GetMagickModule(),
                      OptionWarning,""ParseError"",""unclosed <!DOCTYPE"");
                    utf8=DestroyString(utf8);
                    return(&root->root);
                  }
                if (l != 0)
                  tag=strchr(tag,'[')+1;
                if (l != 0)
                  {
                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),
                      exception);
                    if (status == MagickFalse)
                      {
                        utf8=DestroyString(utf8);
                        return(&root->root);
                      }
                    p++;
                  }
              }
            else
              if (*p == '?')
                {
                  /*
                    Processing instructions.
                  */
                  do
                  {
                    p=strchr(p,'?');
                    if (p == (char *) NULL)
                      break;
                    p++;
                  } while ((*p != '\0') && (*p != '>'));
                  if ((p == (char *) NULL) || ((*p == '\0') &&
                      (terminal != '>')))
                    {
                      (void) ThrowMagickException(exception,GetMagickModule(),
                        OptionWarning,""ParseError"",""unclosed <?"");
                      utf8=DestroyString(utf8);
                      return(&root->root);
                    }
                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unexpected <"");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
     if ((p == (char *) NULL) || (*p == '\0'))
       break;
     *p++='\0';
     tag=p;
     if ((*p != '\0') && (*p != '<'))
       {
        /*
          Tag character content.
        */
        while ((*p != '\0') && (*p != '<'))
          p++;
        if (*p == '\0')
          break;
        if (ignore_depth == 0)
          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');
      }
    else
      if (*p == '\0')
        break;
  }
  utf8=DestroyString(utf8);
  if (root->node == (XMLTreeInfo *) NULL)
    return(&root->root);
  if (root->node->tag == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return(&root->root);
    }
  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
    ""ParseError"",""unclosed tag: `%s'"",root->node->tag);
  return(&root->root);
}
","MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
{
  char
    **attribute,
    **attributes,
    *tag,
    *utf8;

  int
    c,
    terminal;

  MagickBooleanType
    status;

  register char
    *p;

  register ssize_t
    i;

  size_t
    ignore_depth,
    length;

  ssize_t
    j,
    l;

  XMLTreeRoot
    *root;

  /*
    Convert xml-string to UTF8.
  */
  if ((xml == (const char *) NULL) || (strlen(xml) == 0))
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return((XMLTreeInfo *) NULL);
    }
  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);
  length=strlen(xml);
  utf8=ConvertUTF16ToUTF8(xml,&length);
  if (utf8 == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""UTF16 to UTF8 failed"");
      return((XMLTreeInfo *) NULL);
    }
  terminal=utf8[length-1];
  utf8[length-1]='\0';
  p=utf8;
  while ((*p != '\0') && (*p != '<'))
    p++;
  if (*p == '\0')
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      utf8=DestroyString(utf8);
      return((XMLTreeInfo *) NULL);
    }
  attribute=(char **) NULL;
  l=0;
  ignore_depth=0;
  for (p++; ; p++)
  {
    attributes=(char **) sentinel;
    tag=p;
    c=(*p);
    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||
        (*p == ':') || (c < '\0'))
      {
        /*
          Tag.
        */
        if (root->node == (XMLTreeInfo *) NULL)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,""ParseError"",""root tag missing"");
            utf8=DestroyString(utf8);
            return(&root->root);
          }
        p+=strcspn(p,XMLWhitespace ""/>"");
        while (isspace((int) ((unsigned char) *p)) != 0)
          *p++='\0';
        if (ignore_depth == 0)
          {
            if ((*p != '\0') && (*p != '/') && (*p != '>'))
              {
                /*
                  Find tag in default attributes list.
                */
                i=0;
                while ((root->attributes[i] != (char **) NULL) &&
                       (strcmp(root->attributes[i][0],tag) != 0))
                  i++;
                attribute=root->attributes[i];
              }
            for (l=0; (*p != '\0') && (*p != '/') && (*p != '>'); l+=2)
            {
              /*
                Attribute.
              */
              if (l == 0)
                attributes=(char **) AcquireQuantumMemory(4,
                  sizeof(*attributes));
              else
                attributes=(char **) ResizeQuantumMemory(attributes,
                  (size_t) (l+4),sizeof(*attributes));
              if (attributes == (char **) NULL)
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
              attributes[l+2]=(char *) NULL;
              attributes[l+1]=(char *) NULL;
              attributes[l]=p;
              p+=strcspn(p,XMLWhitespace ""=/>"");
              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))
                attributes[l]=ConstantString("""");
              else
                {
                  *p++='\0';
                  p+=strspn(p,XMLWhitespace ""="");
                  c=(*p);
                  if ((c == '""') || (c == '\''))
                    {
                      /*
                        Attributes value.
                      */
                      p++;
                      attributes[l+1]=p;
                      while ((*p != '\0') && (*p != c))
                        p++;
                      if (*p != '\0')
                        *p++='\0';
                      else
                        {
                          attributes[l]=ConstantString("""");
                          attributes[l+1]=ConstantString("""");
                          (void) DestroyXMLTreeAttributes(attributes);
                          (void) ThrowMagickException(exception,
                            GetMagickModule(),OptionWarning,""ParseError"",
                            ""missing %c"",c);
                          utf8=DestroyString(utf8);
                          return(&root->root);
                        }
                      j=1;
                      while ((attribute != (char **) NULL) &&
                             (attribute[j] != (char *) NULL) &&
                             (strcmp(attribute[j],attributes[l]) != 0))
                        j+=3;
                      attributes[l+1]=ParseEntities(attributes[l+1],
                        root->entities,(attribute != (char **) NULL) &&
                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :
                        ' ');
                    }
                  attributes[l]=ConstantString(attributes[l]);
                }
              while (isspace((int) ((unsigned char) *p)) != 0)
                p++;
            }
          }
        else
          {
            while((*p != '\0') && (*p != '/') && (*p != '>'))
              p++;
          }
        if (*p == '/')
          {
            /*
              Self closing tag.
            */
            *p++='\0';
            if (((*p != '\0') && (*p != '>')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
              {
                ParseOpenTag(root,tag,attributes);
                (void) ParseCloseTag(root,tag,exception);
              }
          }
        else
          {
            c=(*p);
            if ((*p == '>') || ((*p == '\0') && (terminal == '>')))
              {
                *p='\0';
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
                  ignore_depth++;
                 *p=c;
               }
             else
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
      }
    else
      if (*p == '/')
        {
          /*
            Close tag.
          */
          tag=p+1;
          p+=strcspn(tag,XMLWhitespace "">"")+1;
          c=(*p);
          if ((c == '\0') && (terminal != '>'))
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,""ParseError"",""missing >"");
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          *p='\0';
          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=
              (XMLTreeInfo *) NULL)
            {
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          if (ignore_depth > 0)
            ignore_depth--;
          *p=c;
          if (isspace((int) ((unsigned char) *p)) != 0)
            p+=strspn(p,XMLWhitespace);
        }
      else
        if (strncmp(p,""!--"",3) == 0)
          {
            /*
              Comment.
            */
            p=strstr(p+3,""--"");
            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\0')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""unclosed <!--"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
        else
          if (strncmp(p,""![CDATA["",8) == 0)
            {
              /*
                Cdata.
              */
              p=strstr(p,""]]>"");
              if (p != (char *) NULL)
                {
                  p+=2;
                  if (ignore_depth == 0)
                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unclosed <![CDATA["");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
            }
          else
            if (strncmp(p,""!DOCTYPE"",8) == 0)
              {
                /*
                  DTD.
                */
                for (l=0; (*p != '\0') && (((l == 0) && (*p != '>')) ||
                     ((l != 0) && ((*p != ']') ||
                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));
                  l=(ssize_t) ((*p == '[') ? 1 : l))
                p+=strcspn(p+1,""[]>"")+1;
                if ((*p == '\0') && (terminal != '>'))
                  {
                    (void) ThrowMagickException(exception,GetMagickModule(),
                      OptionWarning,""ParseError"",""unclosed <!DOCTYPE"");
                    utf8=DestroyString(utf8);
                    return(&root->root);
                  }
                if (l != 0)
                  tag=strchr(tag,'[')+1;
                if (l != 0)
                  {
                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),
                      exception);
                    if (status == MagickFalse)
                      {
                        utf8=DestroyString(utf8);
                        return(&root->root);
                      }
                    p++;
                  }
              }
            else
              if (*p == '?')
                {
                  /*
                    Processing instructions.
                  */
                  do
                  {
                    p=strchr(p,'?');
                    if (p == (char *) NULL)
                      break;
                    p++;
                  } while ((*p != '\0') && (*p != '>'));
                  if ((p == (char *) NULL) || ((*p == '\0') &&
                      (terminal != '>')))
                    {
                      (void) ThrowMagickException(exception,GetMagickModule(),
                        OptionWarning,""ParseError"",""unclosed <?"");
                      utf8=DestroyString(utf8);
                      return(&root->root);
                    }
                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unexpected <"");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
     if ((p == (char *) NULL) || (*p == '\0'))
       break;
     *p++='\0';
     tag=p;
     if ((*p != '\0') && (*p != '<'))
       {
        /*
          Tag character content.
        */
        while ((*p != '\0') && (*p != '<'))
          p++;
        if (*p == '\0')
          break;
        if (ignore_depth == 0)
          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');
      }
    else
      if (*p == '\0')
        break;
  }
  utf8=DestroyString(utf8);
  if (root->node == (XMLTreeInfo *) NULL)
    return(&root->root);
  if (root->node->tag == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return(&root->root);
    }
  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
    ""ParseError"",""unclosed tag: `%s'"",root->node->tag);
  return(&root->root);
}
",C,"                  {
                    ignore_depth++;
                    (void) DestroyXMLTreeAttributes(attributes);
                  }
","                  ignore_depth++;
",,"@@ -2140,7 +2140,10 @@ MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
-                  ignore_depth++;
+                  {
+                    ignore_depth++;
+                    (void) DestroyXMLTreeAttributes(attributes);
+                  }
                 *p=c;
               }
             else",ImageMagick,fc6080f1321fd21e86ef916195cc110b05d9effb,96b300c1bf3b213e8e7331ba54de1836b665cef3,1,"MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
{
  char
    **attribute,
    **attributes,
    *tag,
    *utf8;

  int
    c,
    terminal;

  MagickBooleanType
    status;

  register char
    *p;

  register ssize_t
    i;

  size_t
    ignore_depth,
    length;

  ssize_t
    j,
    l;

  XMLTreeRoot
    *root;

  /*
    Convert xml-string to UTF8.
  */
  if ((xml == (const char *) NULL) || (strlen(xml) == 0))
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return((XMLTreeInfo *) NULL);
    }
  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);
  length=strlen(xml);
  utf8=ConvertUTF16ToUTF8(xml,&length);
  if (utf8 == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""UTF16 to UTF8 failed"");
      return((XMLTreeInfo *) NULL);
    }
  terminal=utf8[length-1];
  utf8[length-1]='\0';
  p=utf8;
  while ((*p != '\0') && (*p != '<'))
    p++;
  if (*p == '\0')
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      utf8=DestroyString(utf8);
      return((XMLTreeInfo *) NULL);
    }
  attribute=(char **) NULL;
  l=0;
  ignore_depth=0;
  for (p++; ; p++)
  {
    attributes=(char **) sentinel;
    tag=p;
    c=(*p);
    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||
        (*p == ':') || (c < '\0'))
      {
        /*
          Tag.
        */
        if (root->node == (XMLTreeInfo *) NULL)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,""ParseError"",""root tag missing"");
            utf8=DestroyString(utf8);
            return(&root->root);
          }
        p+=strcspn(p,XMLWhitespace ""/>"");
        while (isspace((int) ((unsigned char) *p)) != 0)
          *p++='\0';
        if (ignore_depth == 0)
          {
            if ((*p != '\0') && (*p != '/') && (*p != '>'))
              {
                /*
                  Find tag in default attributes list.
                */
                i=0;
                while ((root->attributes[i] != (char **) NULL) &&
                       (strcmp(root->attributes[i][0],tag) != 0))
                  i++;
                attribute=root->attributes[i];
              }
            for (l=0; (*p != '\0') && (*p != '/') && (*p != '>'); l+=2)
            {
              /*
                Attribute.
              */
              if (l == 0)
                attributes=(char **) AcquireQuantumMemory(4,
                  sizeof(*attributes));
              else
                attributes=(char **) ResizeQuantumMemory(attributes,
                  (size_t) (l+4),sizeof(*attributes));
              if (attributes == (char **) NULL)
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
              attributes[l+2]=(char *) NULL;
              attributes[l+1]=(char *) NULL;
              attributes[l]=p;
              p+=strcspn(p,XMLWhitespace ""=/>"");
              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))
                attributes[l]=ConstantString("""");
              else
                {
                  *p++='\0';
                  p+=strspn(p,XMLWhitespace ""="");
                  c=(*p);
                  if ((c == '""') || (c == '\''))
                    {
                      /*
                        Attributes value.
                      */
                      p++;
                      attributes[l+1]=p;
                      while ((*p != '\0') && (*p != c))
                        p++;
                      if (*p != '\0')
                        *p++='\0';
                      else
                        {
                          attributes[l]=ConstantString("""");
                          attributes[l+1]=ConstantString("""");
                          (void) DestroyXMLTreeAttributes(attributes);
                          (void) ThrowMagickException(exception,
                            GetMagickModule(),OptionWarning,""ParseError"",
                            ""missing %c"",c);
                          utf8=DestroyString(utf8);
                          return(&root->root);
                        }
                      j=1;
                      while ((attribute != (char **) NULL) &&
                             (attribute[j] != (char *) NULL) &&
                             (strcmp(attribute[j],attributes[l]) != 0))
                        j+=3;
                      attributes[l+1]=ParseEntities(attributes[l+1],
                        root->entities,(attribute != (char **) NULL) &&
                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :
                        ' ');
                    }
                  attributes[l]=ConstantString(attributes[l]);
                }
              while (isspace((int) ((unsigned char) *p)) != 0)
                p++;
            }
          }
        else
          {
            while((*p != '\0') && (*p != '/') && (*p != '>'))
              p++;
          }
        if (*p == '/')
          {
            /*
              Self closing tag.
            */
            *p++='\0';
            if (((*p != '\0') && (*p != '>')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
              {
                ParseOpenTag(root,tag,attributes);
                (void) ParseCloseTag(root,tag,exception);
              }
          }
        else
          {
            c=(*p);
            if ((*p == '>') || ((*p == '\0') && (terminal == '>')))
              {
                *p='\0';
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
//flaw_line_below:
                  ignore_depth++;
//fix_flaw_line_below:
//                  {
//fix_flaw_line_below:
//                    ignore_depth++;
//fix_flaw_line_below:
//                    (void) DestroyXMLTreeAttributes(attributes);
//fix_flaw_line_below:
//                  }
                 *p=c;
               }
             else
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
      }
    else
      if (*p == '/')
        {
          /*
            Close tag.
          */
          tag=p+1;
          p+=strcspn(tag,XMLWhitespace "">"")+1;
          c=(*p);
          if ((c == '\0') && (terminal != '>'))
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,""ParseError"",""missing >"");
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          *p='\0';
          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=
              (XMLTreeInfo *) NULL)
            {
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          if (ignore_depth > 0)
            ignore_depth--;
          *p=c;
          if (isspace((int) ((unsigned char) *p)) != 0)
            p+=strspn(p,XMLWhitespace);
        }
      else
        if (strncmp(p,""!--"",3) == 0)
          {
            /*
              Comment.
            */
            p=strstr(p+3,""--"");
            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\0')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""unclosed <!--"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
        else
          if (strncmp(p,""![CDATA["",8) == 0)
            {
              /*
                Cdata.
              */
              p=strstr(p,""]]>"");
              if (p != (char *) NULL)
                {
                  p+=2;
                  if (ignore_depth == 0)
                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unclosed <![CDATA["");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
            }
          else
            if (strncmp(p,""!DOCTYPE"",8) == 0)
              {
                /*
                  DTD.
                */
                for (l=0; (*p != '\0') && (((l == 0) && (*p != '>')) ||
                     ((l != 0) && ((*p != ']') ||
                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));
                  l=(ssize_t) ((*p == '[') ? 1 : l))
                p+=strcspn(p+1,""[]>"")+1;
                if ((*p == '\0') && (terminal != '>'))
                  {
                    (void) ThrowMagickException(exception,GetMagickModule(),
                      OptionWarning,""ParseError"",""unclosed <!DOCTYPE"");
                    utf8=DestroyString(utf8);
                    return(&root->root);
                  }
                if (l != 0)
                  tag=strchr(tag,'[')+1;
                if (l != 0)
                  {
                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),
                      exception);
                    if (status == MagickFalse)
                      {
                        utf8=DestroyString(utf8);
                        return(&root->root);
                      }
                    p++;
                  }
              }
            else
              if (*p == '?')
                {
                  /*
                    Processing instructions.
                  */
                  do
                  {
                    p=strchr(p,'?');
                    if (p == (char *) NULL)
                      break;
                    p++;
                  } while ((*p != '\0') && (*p != '>'));
                  if ((p == (char *) NULL) || ((*p == '\0') &&
                      (terminal != '>')))
                    {
                      (void) ThrowMagickException(exception,GetMagickModule(),
                        OptionWarning,""ParseError"",""unclosed <?"");
                      utf8=DestroyString(utf8);
                      return(&root->root);
                    }
                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unexpected <"");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
     if ((p == (char *) NULL) || (*p == '\0'))
       break;
     *p++='\0';
     tag=p;
     if ((*p != '\0') && (*p != '<'))
       {
        /*
          Tag character content.
        */
        while ((*p != '\0') && (*p != '<'))
          p++;
        if (*p == '\0')
          break;
        if (ignore_depth == 0)
          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');
      }
    else
      if (*p == '\0')
        break;
  }
  utf8=DestroyString(utf8);
  if (root->node == (XMLTreeInfo *) NULL)
    return(&root->root);
  if (root->node->tag == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return(&root->root);
    }
  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
    ""ParseError"",""unclosed tag: `%s'"",root->node->tag);
  return(&root->root);
}
",181815,"MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
{
  char
    **attribute,
    **attributes,
    *tag,
    *utf8;

  int
    c,
    terminal;

  MagickBooleanType
    status;

  register char
    *p;

  register ssize_t
    i;

  size_t
    ignore_depth,
    length;

  ssize_t
    j,
    l;

  XMLTreeRoot
    *root;

  /*
    Convert xml-string to UTF8.
  */
  if ((xml == (const char *) NULL) || (strlen(xml) == 0))
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return((XMLTreeInfo *) NULL);
    }
  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);
  length=strlen(xml);
  utf8=ConvertUTF16ToUTF8(xml,&length);
  if (utf8 == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""UTF16 to UTF8 failed"");
      return((XMLTreeInfo *) NULL);
    }
  terminal=utf8[length-1];
  utf8[length-1]='\0';
  p=utf8;
  while ((*p != '\0') && (*p != '<'))
    p++;
  if (*p == '\0')
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      utf8=DestroyString(utf8);
      return((XMLTreeInfo *) NULL);
    }
  attribute=(char **) NULL;
  l=0;
  ignore_depth=0;
  for (p++; ; p++)
  {
    attributes=(char **) sentinel;
    tag=p;
    c=(*p);
    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||
        (*p == ':') || (c < '\0'))
      {
        /*
          Tag.
        */
        if (root->node == (XMLTreeInfo *) NULL)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,""ParseError"",""root tag missing"");
            utf8=DestroyString(utf8);
            return(&root->root);
          }
        p+=strcspn(p,XMLWhitespace ""/>"");
        while (isspace((int) ((unsigned char) *p)) != 0)
          *p++='\0';
        if (ignore_depth == 0)
          {
            if ((*p != '\0') && (*p != '/') && (*p != '>'))
              {
                /*
                  Find tag in default attributes list.
                */
                i=0;
                while ((root->attributes[i] != (char **) NULL) &&
                       (strcmp(root->attributes[i][0],tag) != 0))
                  i++;
                attribute=root->attributes[i];
              }
            for (l=0; (*p != '\0') && (*p != '/') && (*p != '>'); l+=2)
            {
              /*
                Attribute.
              */
              if (l == 0)
                attributes=(char **) AcquireQuantumMemory(4,
                  sizeof(*attributes));
              else
                attributes=(char **) ResizeQuantumMemory(attributes,
                  (size_t) (l+4),sizeof(*attributes));
              if (attributes == (char **) NULL)
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
              attributes[l+2]=(char *) NULL;
              attributes[l+1]=(char *) NULL;
              attributes[l]=p;
              p+=strcspn(p,XMLWhitespace ""=/>"");
              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))
                attributes[l]=ConstantString("""");
              else
                {
                  *p++='\0';
                  p+=strspn(p,XMLWhitespace ""="");
                  c=(*p);
                  if ((c == '""') || (c == '\''))
                    {
                      /*
                        Attributes value.
                      */
                      p++;
                      attributes[l+1]=p;
                      while ((*p != '\0') && (*p != c))
                        p++;
                      if (*p != '\0')
                        *p++='\0';
                      else
                        {
                          attributes[l]=ConstantString("""");
                          attributes[l+1]=ConstantString("""");
                          (void) DestroyXMLTreeAttributes(attributes);
                          (void) ThrowMagickException(exception,
                            GetMagickModule(),OptionWarning,""ParseError"",
                            ""missing %c"",c);
                          utf8=DestroyString(utf8);
                          return(&root->root);
                        }
                      j=1;
                      while ((attribute != (char **) NULL) &&
                             (attribute[j] != (char *) NULL) &&
                             (strcmp(attribute[j],attributes[l]) != 0))
                        j+=3;
                      attributes[l+1]=ParseEntities(attributes[l+1],
                        root->entities,(attribute != (char **) NULL) &&
                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :
                        ' ');
                    }
                  attributes[l]=ConstantString(attributes[l]);
                }
              while (isspace((int) ((unsigned char) *p)) != 0)
                p++;
            }
          }
        else
          {
            while((*p != '\0') && (*p != '/') && (*p != '>'))
              p++;
          }
        if (*p == '/')
          {
            /*
              Self closing tag.
            */
            *p++='\0';
            if (((*p != '\0') && (*p != '>')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
              {
                ParseOpenTag(root,tag,attributes);
                (void) ParseCloseTag(root,tag,exception);
              }
          }
        else
          {
            c=(*p);
            if ((*p == '>') || ((*p == '\0') && (terminal == '>')))
              {
                *p='\0';
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
                  ignore_depth++;
                 *p=c;
               }
             else
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
      }
    else
      if (*p == '/')
        {
          /*
            Close tag.
          */
          tag=p+1;
          p+=strcspn(tag,XMLWhitespace "">"")+1;
          c=(*p);
          if ((c == '\0') && (terminal != '>'))
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,""ParseError"",""missing >"");
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          *p='\0';
          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=
              (XMLTreeInfo *) NULL)
            {
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          if (ignore_depth > 0)
            ignore_depth--;
          *p=c;
          if (isspace((int) ((unsigned char) *p)) != 0)
            p+=strspn(p,XMLWhitespace);
        }
      else
        if (strncmp(p,""!--"",3) == 0)
          {
            /*
              Comment.
            */
            p=strstr(p+3,""--"");
            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\0')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""unclosed <!--"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
        else
          if (strncmp(p,""![CDATA["",8) == 0)
            {
              /*
                Cdata.
              */
              p=strstr(p,""]]>"");
              if (p != (char *) NULL)
                {
                  p+=2;
                  if (ignore_depth == 0)
                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unclosed <![CDATA["");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
            }
          else
            if (strncmp(p,""!DOCTYPE"",8) == 0)
              {
                /*
                  DTD.
                */
                for (l=0; (*p != '\0') && (((l == 0) && (*p != '>')) ||
                     ((l != 0) && ((*p != ']') ||
                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));
                  l=(ssize_t) ((*p == '[') ? 1 : l))
                p+=strcspn(p+1,""[]>"")+1;
                if ((*p == '\0') && (terminal != '>'))
                  {
                    (void) ThrowMagickException(exception,GetMagickModule(),
                      OptionWarning,""ParseError"",""unclosed <!DOCTYPE"");
                    utf8=DestroyString(utf8);
                    return(&root->root);
                  }
                if (l != 0)
                  tag=strchr(tag,'[')+1;
                if (l != 0)
                  {
                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),
                      exception);
                    if (status == MagickFalse)
                      {
                        utf8=DestroyString(utf8);
                        return(&root->root);
                      }
                    p++;
                  }
              }
            else
              if (*p == '?')
                {
                  /*
                    Processing instructions.
                  */
                  do
                  {
                    p=strchr(p,'?');
                    if (p == (char *) NULL)
                      break;
                    p++;
                  } while ((*p != '\0') && (*p != '>'));
                  if ((p == (char *) NULL) || ((*p == '\0') &&
                      (terminal != '>')))
                    {
                      (void) ThrowMagickException(exception,GetMagickModule(),
                        OptionWarning,""ParseError"",""unclosed <?"");
                      utf8=DestroyString(utf8);
                      return(&root->root);
                    }
                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unexpected <"");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
     if ((p == (char *) NULL) || (*p == '\0'))
       break;
     *p++='\0';
     tag=p;
     if ((*p != '\0') && (*p != '<'))
       {
        /*
          Tag character content.
        */
        while ((*p != '\0') && (*p != '<'))
          p++;
        if (*p == '\0')
          break;
        if (ignore_depth == 0)
          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');
      }
    else
      if (*p == '\0')
        break;
  }
  utf8=DestroyString(utf8);
  if (root->node == (XMLTreeInfo *) NULL)
    return(&root->root);
  if (root->node->tag == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return(&root->root);
    }
  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
    ""ParseError"",""unclosed tag: `%s'"",root->node->tag);
  return(&root->root);
}
","MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
{
  char
    **attribute,
    **attributes,
    *tag,
    *utf8;

  int
    c,
    terminal;

  MagickBooleanType
    status;

  register char
    *p;

  register ssize_t
    i;

  size_t
    ignore_depth,
    length;

  ssize_t
    j,
    l;

  XMLTreeRoot
    *root;

  /*
    Convert xml-string to UTF8.
  */
  if ((xml == (const char *) NULL) || (strlen(xml) == 0))
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return((XMLTreeInfo *) NULL);
    }
  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);
  length=strlen(xml);
  utf8=ConvertUTF16ToUTF8(xml,&length);
  if (utf8 == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""UTF16 to UTF8 failed"");
      return((XMLTreeInfo *) NULL);
    }
  terminal=utf8[length-1];
  utf8[length-1]='\0';
  p=utf8;
  while ((*p != '\0') && (*p != '<'))
    p++;
  if (*p == '\0')
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      utf8=DestroyString(utf8);
      return((XMLTreeInfo *) NULL);
    }
  attribute=(char **) NULL;
  l=0;
  ignore_depth=0;
  for (p++; ; p++)
  {
    attributes=(char **) sentinel;
    tag=p;
    c=(*p);
    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||
        (*p == ':') || (c < '\0'))
      {
        /*
          Tag.
        */
        if (root->node == (XMLTreeInfo *) NULL)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,""ParseError"",""root tag missing"");
            utf8=DestroyString(utf8);
            return(&root->root);
          }
        p+=strcspn(p,XMLWhitespace ""/>"");
        while (isspace((int) ((unsigned char) *p)) != 0)
          *p++='\0';
        if (ignore_depth == 0)
          {
            if ((*p != '\0') && (*p != '/') && (*p != '>'))
              {
                /*
                  Find tag in default attributes list.
                */
                i=0;
                while ((root->attributes[i] != (char **) NULL) &&
                       (strcmp(root->attributes[i][0],tag) != 0))
                  i++;
                attribute=root->attributes[i];
              }
            for (l=0; (*p != '\0') && (*p != '/') && (*p != '>'); l+=2)
            {
              /*
                Attribute.
              */
              if (l == 0)
                attributes=(char **) AcquireQuantumMemory(4,
                  sizeof(*attributes));
              else
                attributes=(char **) ResizeQuantumMemory(attributes,
                  (size_t) (l+4),sizeof(*attributes));
              if (attributes == (char **) NULL)
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
              attributes[l+2]=(char *) NULL;
              attributes[l+1]=(char *) NULL;
              attributes[l]=p;
              p+=strcspn(p,XMLWhitespace ""=/>"");
              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))
                attributes[l]=ConstantString("""");
              else
                {
                  *p++='\0';
                  p+=strspn(p,XMLWhitespace ""="");
                  c=(*p);
                  if ((c == '""') || (c == '\''))
                    {
                      /*
                        Attributes value.
                      */
                      p++;
                      attributes[l+1]=p;
                      while ((*p != '\0') && (*p != c))
                        p++;
                      if (*p != '\0')
                        *p++='\0';
                      else
                        {
                          attributes[l]=ConstantString("""");
                          attributes[l+1]=ConstantString("""");
                          (void) DestroyXMLTreeAttributes(attributes);
                          (void) ThrowMagickException(exception,
                            GetMagickModule(),OptionWarning,""ParseError"",
                            ""missing %c"",c);
                          utf8=DestroyString(utf8);
                          return(&root->root);
                        }
                      j=1;
                      while ((attribute != (char **) NULL) &&
                             (attribute[j] != (char *) NULL) &&
                             (strcmp(attribute[j],attributes[l]) != 0))
                        j+=3;
                      attributes[l+1]=ParseEntities(attributes[l+1],
                        root->entities,(attribute != (char **) NULL) &&
                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :
                        ' ');
                    }
                  attributes[l]=ConstantString(attributes[l]);
                }
              while (isspace((int) ((unsigned char) *p)) != 0)
                p++;
            }
          }
        else
          {
            while((*p != '\0') && (*p != '/') && (*p != '>'))
              p++;
          }
        if (*p == '/')
          {
            /*
              Self closing tag.
            */
            *p++='\0';
            if (((*p != '\0') && (*p != '>')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
              {
                ParseOpenTag(root,tag,attributes);
                (void) ParseCloseTag(root,tag,exception);
              }
          }
        else
          {
            c=(*p);
            if ((*p == '>') || ((*p == '\0') && (terminal == '>')))
              {
                *p='\0';
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
                  {
                    ignore_depth++;
                    (void) DestroyXMLTreeAttributes(attributes);
                  }
                 *p=c;
               }
             else
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
      }
    else
      if (*p == '/')
        {
          /*
            Close tag.
          */
          tag=p+1;
          p+=strcspn(tag,XMLWhitespace "">"")+1;
          c=(*p);
          if ((c == '\0') && (terminal != '>'))
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,""ParseError"",""missing >"");
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          *p='\0';
          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=
              (XMLTreeInfo *) NULL)
            {
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          if (ignore_depth > 0)
            ignore_depth--;
          *p=c;
          if (isspace((int) ((unsigned char) *p)) != 0)
            p+=strspn(p,XMLWhitespace);
        }
      else
        if (strncmp(p,""!--"",3) == 0)
          {
            /*
              Comment.
            */
            p=strstr(p+3,""--"");
            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\0')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""unclosed <!--"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
        else
          if (strncmp(p,""![CDATA["",8) == 0)
            {
              /*
                Cdata.
              */
              p=strstr(p,""]]>"");
              if (p != (char *) NULL)
                {
                  p+=2;
                  if (ignore_depth == 0)
                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unclosed <![CDATA["");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
            }
          else
            if (strncmp(p,""!DOCTYPE"",8) == 0)
              {
                /*
                  DTD.
                */
                for (l=0; (*p != '\0') && (((l == 0) && (*p != '>')) ||
                     ((l != 0) && ((*p != ']') ||
                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));
                  l=(ssize_t) ((*p == '[') ? 1 : l))
                p+=strcspn(p+1,""[]>"")+1;
                if ((*p == '\0') && (terminal != '>'))
                  {
                    (void) ThrowMagickException(exception,GetMagickModule(),
                      OptionWarning,""ParseError"",""unclosed <!DOCTYPE"");
                    utf8=DestroyString(utf8);
                    return(&root->root);
                  }
                if (l != 0)
                  tag=strchr(tag,'[')+1;
                if (l != 0)
                  {
                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),
                      exception);
                    if (status == MagickFalse)
                      {
                        utf8=DestroyString(utf8);
                        return(&root->root);
                      }
                    p++;
                  }
              }
            else
              if (*p == '?')
                {
                  /*
                    Processing instructions.
                  */
                  do
                  {
                    p=strchr(p,'?');
                    if (p == (char *) NULL)
                      break;
                    p++;
                  } while ((*p != '\0') && (*p != '>'));
                  if ((p == (char *) NULL) || ((*p == '\0') &&
                      (terminal != '>')))
                    {
                      (void) ThrowMagickException(exception,GetMagickModule(),
                        OptionWarning,""ParseError"",""unclosed <?"");
                      utf8=DestroyString(utf8);
                      return(&root->root);
                    }
                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unexpected <"");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
     if ((p == (char *) NULL) || (*p == '\0'))
       break;
     *p++='\0';
     tag=p;
     if ((*p != '\0') && (*p != '<'))
       {
        /*
          Tag character content.
        */
        while ((*p != '\0') && (*p != '<'))
          p++;
        if (*p == '\0')
          break;
        if (ignore_depth == 0)
          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');
      }
    else
      if (*p == '\0')
        break;
  }
  utf8=DestroyString(utf8);
  if (root->node == (XMLTreeInfo *) NULL)
    return(&root->root);
  if (root->node->tag == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return(&root->root);
    }
  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
    ""ParseError"",""unclosed tag: `%s'"",root->node->tag);
  return(&root->root);
}
","The vulnerability in the original code lies in the handling of XML parsing, particularly in the management of the `ignore_depth` variable and the potential for unclosed tags. If an opening tag is not properly closed, the code could continue processing, leading to undefined behavior or memory corruption. Specifically, the check for `ignore_depth` was not adequately enforced, allowing for improper handling of nested tags. In the fixed code, the handling of `ignore_depth` is improved by ensuring that when a tag is opened but not closed, the attributes are destroyed, and the function properly throws an exception, preventing further processing and potential vulnerabilities.","The vulnerability in the original code stems from inadequate handling of XML parsing, particularly regarding unclosed tags and improper management of nested structures. This could lead to undefined behavior, memory corruption, or resource leaks if the parser encounters an opening tag without a corresponding closing tag. The fixed code addresses this issue by ensuring that when an opening tag is detected without closure, the parser properly cleans up resources and throws an exception, effectively halting further processing. This change enhances the robustness of the XML parsing logic and mitigates potential security risks associated with malformed XML input."
6,184888,184888,,Remote,Not required,Partial,CVE-2013-2900,https://www.cvedetails.com/cve/CVE-2013-2900/,CWE-22,Low,Partial,Partial,,2013-08-21,7.5,"The FilePath::ReferencesParent function in files/file_path.cc in Google Chrome before 29.0.1547.57 on Windows does not properly handle pathname components composed entirely of . (dot) and whitespace characters, which allows remote attackers to conduct directory traversal attacks via a crafted directory name.",2017-09-18,Dir. Trav. ,3,https://github.com/chromium/chromium/commit/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337,bd3392a1f8b95bf0b0ee3821bc3245d743fb1337,"AX: Calendar Picker: Add AX labels to MonthPopupButton and CalendarNavigationButtons.

This CL adds no new tests. Will add tests after a Chromium change for
string resource.

BUG=123896

Review URL: https://codereview.chromium.org/552163002

git-svn-id: svn://svn.chromium.org/blink/trunk@181617 bbb929c8-8fbe-4397-9dbb-9b2b20218538",0,third_party/WebKit/Source/web/DateTimeChooserImpl.cpp,"{""sha"": ""12cccdfa59676411125945dcd7aa13898fc408e2"", ""filename"": ""third_party/WebKit/ManualTests/forms/calendar-picker.html"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/ManualTests/forms/calendar-picker.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/ManualTests/forms/calendar-picker.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/ManualTests/forms/calendar-picker.html?ref=bd3392a1f8b95bf0b0ee3821bc3245d743fb1337"", ""patch"": ""@@ -269,7 +269,11 @@ <h2>Config</h2>\n         min: config.min,\n         step: config.step * (config.type === \""month\"" ? 1 : 86400000),\n         stepBase: \""0\"",\n-        currentValue: config.value\n+        currentValue: config.value,\n+        axShowMonthSelector: \""Show month selection panel\"",\n+        axShowNextMonth: \""Show next month\"",\n+        axShowPreviousMonth: \""Show previous month\"",\n+        todayLabel: \""Today\"",\n     }\n };\n ""}<_**next**_>{""sha"": ""1cdb077dea9cd61af7c69ae482e4c0cfe9253113"", ""filename"": ""third_party/WebKit/Source/web/DateTimeChooserImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/Source/web/DateTimeChooserImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/Source/web/DateTimeChooserImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/web/DateTimeChooserImpl.cpp?ref=bd3392a1f8b95bf0b0ee3821bc3245d743fb1337"", ""patch"": ""@@ -138,6 +138,9 @@ void DateTimeChooserImpl::writeDocument(SharedBuffer* data)\n     addProperty(\""todayLabel\"", todayLabelString, data);\n     addProperty(\""clearLabel\"", locale().queryString(WebLocalizedString::CalendarClear), data);\n     addProperty(\""weekLabel\"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);\n+    addProperty(\""axShowMonthSelector\"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);\n+    addProperty(\""axShowNextMonth\"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);\n+    addProperty(\""axShowPreviousMonth\"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);\n     addProperty(\""weekStartDay\"", m_locale->firstDayOfWeek(), data);\n     addProperty(\""shortMonthLabels\"", m_locale->shortMonthLabels(), data);\n     addProperty(\""dayLabels\"", m_locale->weekDayShortLabels(), data);""}<_**next**_>{""sha"": ""2459e401c4237a186e0039c67c54ad271412b12d"", ""filename"": ""third_party/WebKit/Source/web/resources/calendarPicker.js"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/Source/web/resources/calendarPicker.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/Source/web/resources/calendarPicker.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/web/resources/calendarPicker.js?ref=bd3392a1f8b95bf0b0ee3821bc3245d743fb1337"", ""patch"": ""@@ -2763,6 +2763,7 @@ MonthPopupView.prototype.onClick = function(event) {\n  */\n function MonthPopupButton(maxWidth) {\n     View.call(this, createElement(\""button\"", MonthPopupButton.ClassNameMonthPopupButton));\n+    this.element.setAttribute(\""aria-label\"", global.params.axShowMonthSelector);\n \n     /**\n      * @type {!Element}\n@@ -2951,6 +2952,7 @@ function CalendarHeaderView(calendarPicker) {\n     this._previousMonthButton.attachTo(this);\n     this._previousMonthButton.on(CalendarNavigationButton.EventTypeButtonClick, this.onNavigationButtonClick);\n     this._previousMonthButton.on(CalendarNavigationButton.EventTypeRepeatingButtonClick, this.onNavigationButtonClick);\n+    this._previousMonthButton.element.setAttribute(\""aria-label\"", global.params.axShowPreviousMonth);\n \n     /**\n      * @type {!CalendarNavigationButton}\n@@ -2962,6 +2964,7 @@ function CalendarHeaderView(calendarPicker) {\n     this._todayButton.element.classList.add(CalendarHeaderView.ClassNameTodayButton);\n     var monthContainingToday = Month.createFromToday();\n     this._todayButton.setDisabled(monthContainingToday < this.calendarPicker.minimumMonth || monthContainingToday > this.calendarPicker.maximumMonth);\n+    this._todayButton.element.setAttribute(\""aria-label\"", global.params.todayLabel);\n \n     /**\n      * @type {!CalendarNavigationButton}\n@@ -2971,6 +2974,7 @@ function CalendarHeaderView(calendarPicker) {\n     this._nextMonthButton.attachTo(this);\n     this._nextMonthButton.on(CalendarNavigationButton.EventTypeButtonClick, this.onNavigationButtonClick);\n     this._nextMonthButton.on(CalendarNavigationButton.EventTypeRepeatingButtonClick, this.onNavigationButtonClick);\n+    this._nextMonthButton.element.setAttribute(\""aria-label\"", global.params.axShowNextMonth);\n \n     if (global.params.isLocaleRTL) {\n         this._nextMonthButton.element.innerHTML = CalendarHeaderView._BackwardTriangle;""}<_**next**_>{""sha"": ""d2cc50cce3d1f450b6e1e35ca03a41d25518be8c"", ""filename"": ""third_party/WebKit/public/platform/WebLocalizedString.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/public/platform/WebLocalizedString.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/public/platform/WebLocalizedString.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/public/platform/WebLocalizedString.h?ref=bd3392a1f8b95bf0b0ee3821bc3245d743fb1337"", ""patch"": ""@@ -37,6 +37,9 @@ struct WebLocalizedString {\n     enum Name {\n         AXAMPMFieldText,\n         AXButtonActionVerb,\n+        AXCalendarShowMonthSelector,\n+        AXCalendarShowNextMonth,\n+        AXCalendarShowPreviousMonth,\n         AXCheckedCheckBoxActionVerb,\n         AXDateTimeFieldEmptyValueText,\n         AXDayOfMonthFieldText,""}","void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
{
    String stepString = String::number(m_parameters.step);
    String stepBaseString = String::number(m_parameters.stepBase, 11, WTF::TruncateTrailingZeros);
    IntRect anchorRectInScreen = m_chromeClient->rootViewToScreen(m_parameters.anchorRectInRootView);
    String todayLabelString;
    String otherDateLabelString;
    if (m_parameters.type == InputTypeNames::month) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisMonthButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherMonthLabel);
    } else if (m_parameters.type == InputTypeNames::week) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisWeekButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherWeekLabel);
    } else {
        todayLabelString = locale().queryString(WebLocalizedString::CalendarToday);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherDateLabel);
    }

    addString(""<!DOCTYPE html><head><meta charset='UTF-8'><style>\n"", data);
    data->append(Platform::current()->loadResource(""pickerCommon.css""));
    data->append(Platform::current()->loadResource(""pickerButton.css""));
    data->append(Platform::current()->loadResource(""suggestionPicker.css""));
    data->append(Platform::current()->loadResource(""calendarPicker.css""));
    addString(""</style></head><body><div id=main>Loading...</div><script>\n""
        ""window.dialogArguments = {\n"", data);
    addProperty(""anchorRectInScreen"", anchorRectInScreen, data);
    addProperty(""min"", valueToDateTimeString(m_parameters.minimum, m_parameters.type), data);
    addProperty(""max"", valueToDateTimeString(m_parameters.maximum, m_parameters.type), data);
    addProperty(""step"", stepString, data);
    addProperty(""stepBase"", stepBaseString, data);
    addProperty(""required"", m_parameters.required, data);
    addProperty(""currentValue"", valueToDateTimeString(m_parameters.doubleValue, m_parameters.type), data);
    addProperty(""locale"", m_parameters.locale.string(), data);
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
    addProperty(""axShowMonthSelector"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);
    addProperty(""axShowNextMonth"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);
    addProperty(""axShowPreviousMonth"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);
    addProperty(""isLocaleRTL"", m_locale->isRTL(), data);
    addProperty(""isRTL"", m_parameters.isAnchorElementRTL, data);
    addProperty(""mode"", m_parameters.type.string(), data);
    if (m_parameters.suggestions.size()) {
        Vector<String> suggestionValues;
        Vector<String> localizedSuggestionValues;
        Vector<String> suggestionLabels;
        for (unsigned i = 0; i < m_parameters.suggestions.size(); i++) {
            suggestionValues.append(valueToDateTimeString(m_parameters.suggestions[i].value, m_parameters.type));
            localizedSuggestionValues.append(m_parameters.suggestions[i].localizedValue);
            suggestionLabels.append(m_parameters.suggestions[i].label);
        }
        addProperty(""suggestionValues"", suggestionValues, data);
        addProperty(""localizedSuggestionValues"", localizedSuggestionValues, data);
        addProperty(""suggestionLabels"", suggestionLabels, data);
        addProperty(""inputWidth"", static_cast<unsigned>(m_parameters.anchorRectInRootView.width()), data);
        addProperty(""showOtherDateEntry"", RenderTheme::theme().supportsCalendarPicker(m_parameters.type), data);
        addProperty(""otherDateLabel"", otherDateLabelString, data);
        addProperty(""suggestionHighlightColor"", RenderTheme::theme().activeListBoxSelectionBackgroundColor().serialized(), data);
        addProperty(""suggestionHighlightTextColor"", RenderTheme::theme().activeListBoxSelectionForegroundColor().serialized(), data);
    }
    addString(""}\n"", data);

    data->append(Platform::current()->loadResource(""pickerCommon.js""));
    data->append(Platform::current()->loadResource(""suggestionPicker.js""));
    data->append(Platform::current()->loadResource(""calendarPicker.js""));
    addString(""</script></body>\n"", data);
}
","void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
{
    String stepString = String::number(m_parameters.step);
    String stepBaseString = String::number(m_parameters.stepBase, 11, WTF::TruncateTrailingZeros);
    IntRect anchorRectInScreen = m_chromeClient->rootViewToScreen(m_parameters.anchorRectInRootView);
    String todayLabelString;
    String otherDateLabelString;
    if (m_parameters.type == InputTypeNames::month) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisMonthButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherMonthLabel);
    } else if (m_parameters.type == InputTypeNames::week) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisWeekButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherWeekLabel);
    } else {
        todayLabelString = locale().queryString(WebLocalizedString::CalendarToday);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherDateLabel);
    }

    addString(""<!DOCTYPE html><head><meta charset='UTF-8'><style>\n"", data);
    data->append(Platform::current()->loadResource(""pickerCommon.css""));
    data->append(Platform::current()->loadResource(""pickerButton.css""));
    data->append(Platform::current()->loadResource(""suggestionPicker.css""));
    data->append(Platform::current()->loadResource(""calendarPicker.css""));
    addString(""</style></head><body><div id=main>Loading...</div><script>\n""
        ""window.dialogArguments = {\n"", data);
    addProperty(""anchorRectInScreen"", anchorRectInScreen, data);
    addProperty(""min"", valueToDateTimeString(m_parameters.minimum, m_parameters.type), data);
    addProperty(""max"", valueToDateTimeString(m_parameters.maximum, m_parameters.type), data);
    addProperty(""step"", stepString, data);
    addProperty(""stepBase"", stepBaseString, data);
    addProperty(""required"", m_parameters.required, data);
    addProperty(""currentValue"", valueToDateTimeString(m_parameters.doubleValue, m_parameters.type), data);
    addProperty(""locale"", m_parameters.locale.string(), data);
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);
    addProperty(""isLocaleRTL"", m_locale->isRTL(), data);
    addProperty(""isRTL"", m_parameters.isAnchorElementRTL, data);
    addProperty(""mode"", m_parameters.type.string(), data);
    if (m_parameters.suggestions.size()) {
        Vector<String> suggestionValues;
        Vector<String> localizedSuggestionValues;
        Vector<String> suggestionLabels;
        for (unsigned i = 0; i < m_parameters.suggestions.size(); i++) {
            suggestionValues.append(valueToDateTimeString(m_parameters.suggestions[i].value, m_parameters.type));
            localizedSuggestionValues.append(m_parameters.suggestions[i].localizedValue);
            suggestionLabels.append(m_parameters.suggestions[i].label);
        }
        addProperty(""suggestionValues"", suggestionValues, data);
        addProperty(""localizedSuggestionValues"", localizedSuggestionValues, data);
        addProperty(""suggestionLabels"", suggestionLabels, data);
        addProperty(""inputWidth"", static_cast<unsigned>(m_parameters.anchorRectInRootView.width()), data);
        addProperty(""showOtherDateEntry"", RenderTheme::theme().supportsCalendarPicker(m_parameters.type), data);
        addProperty(""otherDateLabel"", otherDateLabelString, data);
        addProperty(""suggestionHighlightColor"", RenderTheme::theme().activeListBoxSelectionBackgroundColor().serialized(), data);
        addProperty(""suggestionHighlightTextColor"", RenderTheme::theme().activeListBoxSelectionForegroundColor().serialized(), data);
    }
    addString(""}\n"", data);

    data->append(Platform::current()->loadResource(""pickerCommon.js""));
    data->append(Platform::current()->loadResource(""suggestionPicker.js""));
    data->append(Platform::current()->loadResource(""calendarPicker.js""));
    addString(""</script></body>\n"", data);
}
",C,"    addProperty(""axShowMonthSelector"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);
    addProperty(""axShowNextMonth"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);
    addProperty(""axShowPreviousMonth"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);
",,,"@@ -138,6 +138,9 @@ void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
+    addProperty(""axShowMonthSelector"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);
+    addProperty(""axShowNextMonth"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);
+    addProperty(""axShowPreviousMonth"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);",Chrome,bd3392a1f8b95bf0b0ee3821bc3245d743fb1337,8a2c034f43ae98cc6a429f91dd1d16fc3fe331c9,1,"void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
{
    String stepString = String::number(m_parameters.step);
    String stepBaseString = String::number(m_parameters.stepBase, 11, WTF::TruncateTrailingZeros);
    IntRect anchorRectInScreen = m_chromeClient->rootViewToScreen(m_parameters.anchorRectInRootView);
    String todayLabelString;
    String otherDateLabelString;
    if (m_parameters.type == InputTypeNames::month) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisMonthButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherMonthLabel);
    } else if (m_parameters.type == InputTypeNames::week) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisWeekButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherWeekLabel);
    } else {
        todayLabelString = locale().queryString(WebLocalizedString::CalendarToday);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherDateLabel);
    }

    addString(""<!DOCTYPE html><head><meta charset='UTF-8'><style>\n"", data);
    data->append(Platform::current()->loadResource(""pickerCommon.css""));
    data->append(Platform::current()->loadResource(""pickerButton.css""));
    data->append(Platform::current()->loadResource(""suggestionPicker.css""));
    data->append(Platform::current()->loadResource(""calendarPicker.css""));
    addString(""</style></head><body><div id=main>Loading...</div><script>\n""
        ""window.dialogArguments = {\n"", data);
    addProperty(""anchorRectInScreen"", anchorRectInScreen, data);
    addProperty(""min"", valueToDateTimeString(m_parameters.minimum, m_parameters.type), data);
    addProperty(""max"", valueToDateTimeString(m_parameters.maximum, m_parameters.type), data);
    addProperty(""step"", stepString, data);
    addProperty(""stepBase"", stepBaseString, data);
    addProperty(""required"", m_parameters.required, data);
    addProperty(""currentValue"", valueToDateTimeString(m_parameters.doubleValue, m_parameters.type), data);
    addProperty(""locale"", m_parameters.locale.string(), data);
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
//fix_flaw_line_below:
//    addProperty(""axShowMonthSelector"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);
//fix_flaw_line_below:
//    addProperty(""axShowNextMonth"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);
//fix_flaw_line_below:
//    addProperty(""axShowPreviousMonth"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);
    addProperty(""isLocaleRTL"", m_locale->isRTL(), data);
    addProperty(""isRTL"", m_parameters.isAnchorElementRTL, data);
    addProperty(""mode"", m_parameters.type.string(), data);
    if (m_parameters.suggestions.size()) {
        Vector<String> suggestionValues;
        Vector<String> localizedSuggestionValues;
        Vector<String> suggestionLabels;
        for (unsigned i = 0; i < m_parameters.suggestions.size(); i++) {
            suggestionValues.append(valueToDateTimeString(m_parameters.suggestions[i].value, m_parameters.type));
            localizedSuggestionValues.append(m_parameters.suggestions[i].localizedValue);
            suggestionLabels.append(m_parameters.suggestions[i].label);
        }
        addProperty(""suggestionValues"", suggestionValues, data);
        addProperty(""localizedSuggestionValues"", localizedSuggestionValues, data);
        addProperty(""suggestionLabels"", suggestionLabels, data);
        addProperty(""inputWidth"", static_cast<unsigned>(m_parameters.anchorRectInRootView.width()), data);
        addProperty(""showOtherDateEntry"", RenderTheme::theme().supportsCalendarPicker(m_parameters.type), data);
        addProperty(""otherDateLabel"", otherDateLabelString, data);
        addProperty(""suggestionHighlightColor"", RenderTheme::theme().activeListBoxSelectionBackgroundColor().serialized(), data);
        addProperty(""suggestionHighlightTextColor"", RenderTheme::theme().activeListBoxSelectionForegroundColor().serialized(), data);
    }
    addString(""}\n"", data);

    data->append(Platform::current()->loadResource(""pickerCommon.js""));
    data->append(Platform::current()->loadResource(""suggestionPicker.js""));
    data->append(Platform::current()->loadResource(""calendarPicker.js""));
    addString(""</script></body>\n"", data);
}
",184888,"void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
{
    String stepString = String::number(m_parameters.step);
    String stepBaseString = String::number(m_parameters.stepBase, 11, WTF::TruncateTrailingZeros);
    IntRect anchorRectInScreen = m_chromeClient->rootViewToScreen(m_parameters.anchorRectInRootView);
    String todayLabelString;
    String otherDateLabelString;
    if (m_parameters.type == InputTypeNames::month) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisMonthButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherMonthLabel);
    } else if (m_parameters.type == InputTypeNames::week) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisWeekButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherWeekLabel);
    } else {
        todayLabelString = locale().queryString(WebLocalizedString::CalendarToday);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherDateLabel);
    }

    addString(""<!DOCTYPE html><head><meta charset='UTF-8'><style>\n"", data);
    data->append(Platform::current()->loadResource(""pickerCommon.css""));
    data->append(Platform::current()->loadResource(""pickerButton.css""));
    data->append(Platform::current()->loadResource(""suggestionPicker.css""));
    data->append(Platform::current()->loadResource(""calendarPicker.css""));
    addString(""</style></head><body><div id=main>Loading...</div><script>\n""
        ""window.dialogArguments = {\n"", data);
    addProperty(""anchorRectInScreen"", anchorRectInScreen, data);
    addProperty(""min"", valueToDateTimeString(m_parameters.minimum, m_parameters.type), data);
    addProperty(""max"", valueToDateTimeString(m_parameters.maximum, m_parameters.type), data);
    addProperty(""step"", stepString, data);
    addProperty(""stepBase"", stepBaseString, data);
    addProperty(""required"", m_parameters.required, data);
    addProperty(""currentValue"", valueToDateTimeString(m_parameters.doubleValue, m_parameters.type), data);
    addProperty(""locale"", m_parameters.locale.string(), data);
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);
    addProperty(""isLocaleRTL"", m_locale->isRTL(), data);
    addProperty(""isRTL"", m_parameters.isAnchorElementRTL, data);
    addProperty(""mode"", m_parameters.type.string(), data);
    if (m_parameters.suggestions.size()) {
        Vector<String> suggestionValues;
        Vector<String> localizedSuggestionValues;
        Vector<String> suggestionLabels;
        for (unsigned i = 0; i < m_parameters.suggestions.size(); i++) {
            suggestionValues.append(valueToDateTimeString(m_parameters.suggestions[i].value, m_parameters.type));
            localizedSuggestionValues.append(m_parameters.suggestions[i].localizedValue);
            suggestionLabels.append(m_parameters.suggestions[i].label);
        }
        addProperty(""suggestionValues"", suggestionValues, data);
        addProperty(""localizedSuggestionValues"", localizedSuggestionValues, data);
        addProperty(""suggestionLabels"", suggestionLabels, data);
        addProperty(""inputWidth"", static_cast<unsigned>(m_parameters.anchorRectInRootView.width()), data);
        addProperty(""showOtherDateEntry"", RenderTheme::theme().supportsCalendarPicker(m_parameters.type), data);
        addProperty(""otherDateLabel"", otherDateLabelString, data);
        addProperty(""suggestionHighlightColor"", RenderTheme::theme().activeListBoxSelectionBackgroundColor().serialized(), data);
        addProperty(""suggestionHighlightTextColor"", RenderTheme::theme().activeListBoxSelectionForegroundColor().serialized(), data);
    }
    addString(""}\n"", data);

    data->append(Platform::current()->loadResource(""pickerCommon.js""));
    data->append(Platform::current()->loadResource(""suggestionPicker.js""));
    data->append(Platform::current()->loadResource(""calendarPicker.js""));
    addString(""</script></body>\n"", data);
}
","void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
{
    String stepString = String::number(m_parameters.step);
    String stepBaseString = String::number(m_parameters.stepBase, 11, WTF::TruncateTrailingZeros);
    IntRect anchorRectInScreen = m_chromeClient->rootViewToScreen(m_parameters.anchorRectInRootView);
    String todayLabelString;
    String otherDateLabelString;
    if (m_parameters.type == InputTypeNames::month) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisMonthButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherMonthLabel);
    } else if (m_parameters.type == InputTypeNames::week) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisWeekButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherWeekLabel);
    } else {
        todayLabelString = locale().queryString(WebLocalizedString::CalendarToday);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherDateLabel);
    }

    addString(""<!DOCTYPE html><head><meta charset='UTF-8'><style>\n"", data);
    data->append(Platform::current()->loadResource(""pickerCommon.css""));
    data->append(Platform::current()->loadResource(""pickerButton.css""));
    data->append(Platform::current()->loadResource(""suggestionPicker.css""));
    data->append(Platform::current()->loadResource(""calendarPicker.css""));
    addString(""</style></head><body><div id=main>Loading...</div><script>\n""
        ""window.dialogArguments = {\n"", data);
    addProperty(""anchorRectInScreen"", anchorRectInScreen, data);
    addProperty(""min"", valueToDateTimeString(m_parameters.minimum, m_parameters.type), data);
    addProperty(""max"", valueToDateTimeString(m_parameters.maximum, m_parameters.type), data);
    addProperty(""step"", stepString, data);
    addProperty(""stepBase"", stepBaseString, data);
    addProperty(""required"", m_parameters.required, data);
    addProperty(""currentValue"", valueToDateTimeString(m_parameters.doubleValue, m_parameters.type), data);
    addProperty(""locale"", m_parameters.locale.string(), data);
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
    addProperty(""axShowMonthSelector"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);
    addProperty(""axShowNextMonth"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);
    addProperty(""axShowPreviousMonth"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);
    addProperty(""isLocaleRTL"", m_locale->isRTL(), data);
    addProperty(""isRTL"", m_parameters.isAnchorElementRTL, data);
    addProperty(""mode"", m_parameters.type.string(), data);
    if (m_parameters.suggestions.size()) {
        Vector<String> suggestionValues;
        Vector<String> localizedSuggestionValues;
        Vector<String> suggestionLabels;
        for (unsigned i = 0; i < m_parameters.suggestions.size(); i++) {
            suggestionValues.append(valueToDateTimeString(m_parameters.suggestions[i].value, m_parameters.type));
            localizedSuggestionValues.append(m_parameters.suggestions[i].localizedValue);
            suggestionLabels.append(m_parameters.suggestions[i].label);
        }
        addProperty(""suggestionValues"", suggestionValues, data);
        addProperty(""localizedSuggestionValues"", localizedSuggestionValues, data);
        addProperty(""suggestionLabels"", suggestionLabels, data);
        addProperty(""inputWidth"", static_cast<unsigned>(m_parameters.anchorRectInRootView.width()), data);
        addProperty(""showOtherDateEntry"", RenderTheme::theme().supportsCalendarPicker(m_parameters.type), data);
        addProperty(""otherDateLabel"", otherDateLabelString, data);
        addProperty(""suggestionHighlightColor"", RenderTheme::theme().activeListBoxSelectionBackgroundColor().serialized(), data);
        addProperty(""suggestionHighlightTextColor"", RenderTheme::theme().activeListBoxSelectionForegroundColor().serialized(), data);
    }
    addString(""}\n"", data);

    data->append(Platform::current()->loadResource(""pickerCommon.js""));
    data->append(Platform::current()->loadResource(""suggestionPicker.js""));
    data->append(Platform::current()->loadResource(""calendarPicker.js""));
    addString(""</script></body>\n"", data);
}
","The vulnerability in the original code lies in the lack of accessibility properties for the date picker, which could hinder users with disabilities from effectively interacting with the interface. Specifically, the absence of properties like ""axShowMonthSelector,"" ""axShowNextMonth,"" and ""axShowPreviousMonth"" means that screen readers may not provide adequate context or navigation options for users relying on assistive technologies. The fixed code addresses this vulnerability by adding these accessibility properties using `addProperty`, ensuring that the date picker is more inclusive and usable for all users, thereby enhancing its overall accessibility.","The vulnerability in the original code stems from the lack of accessibility features, which can impede users with disabilities from effectively navigating and interacting with the date picker interface. Without appropriate properties for assistive technologies, such as screen readers, users may struggle to understand the available options and controls. The revised code addresses this issue by incorporating additional accessibility properties, thereby enhancing the interface's usability for individuals relying on assistive devices. This change ensures a more inclusive experience, allowing all users to engage with the date picker more effectively and efficiently."
7,185107,185107,,Remote,Not required,Partial,CVE-2013-0895,https://www.cvedetails.com/cve/CVE-2013-0895/,CWE-22,Low,Partial,Partial,,2013-02-23,7.5,"Google Chrome before 25.0.1364.97 on Linux, and before 25.0.1364.99 on Mac OS X, does not properly handle pathnames during copy operations, which might make it easier for remote attackers to execute arbitrary programs via unspecified vectors.",2013-09-30,Dir. Trav. ,8,https://github.com/chromium/chromium/commit/23803a58e481e464a787e4b2c461af9e62f03905,23803a58e481e464a787e4b2c461af9e62f03905,"Fix creating target paths in file_util_posix CopyDirectory.

BUG=167840


Review URL: https://chromiumcodereview.appspot.com/11773018

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@176659 0039d316-1c4b-4281-b951-d872f2087c98",5,base/file_util_posix.cc,"{""sha"": ""95ffb42f7dd5a7d66812b84292c84f9cc2dcf35f"", ""filename"": ""base/file_util_posix.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/23803a58e481e464a787e4b2c461af9e62f03905/base/file_util_posix.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/23803a58e481e464a787e4b2c461af9e62f03905/base/file_util_posix.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/file_util_posix.cc?ref=23803a58e481e464a787e4b2c461af9e62f03905"", ""patch"": ""@@ -343,15 +343,15 @@ bool CopyDirectory(const FilePath& from_path,\n   DCHECK(recursive || S_ISDIR(info.stat.st_mode));\n \n   while (success && !current.empty()) {\n-    // current is the source path, including from_path, so paste\n-    // the suffix after from_path onto to_path to create the target_path.\n-    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);\n-    // Strip the leading '/' (if any).\n-    if (!suffix.empty()) {\n-      DCHECK_EQ('/', suffix[0]);\n-      suffix.erase(0, 1);\n+    // current is the source path, including from_path, so append\n+    // the suffix after from_path to to_path to create the target_path.\n+    FilePath target_path(to_path);\n+    if (from_path_base != current) {\n+      if (!from_path_base.AppendRelativePath(current, &target_path)) {\n+        success = false;\n+        break;\n+      }\n     }\n-    const FilePath target_path = to_path.Append(suffix);\n \n     if (S_ISDIR(info.stat.st_mode)) {\n       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&""}<_**next**_>{""sha"": ""c1006e1304c205c52a7e58b38e9d7e8ade80e60d"", ""filename"": ""base/file_util_unittest.cc"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 0, ""changes"": 37, ""blob_url"": ""https://github.com/chromium/chromium/blob/23803a58e481e464a787e4b2c461af9e62f03905/base/file_util_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/23803a58e481e464a787e4b2c461af9e62f03905/base/file_util_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/file_util_unittest.cc?ref=23803a58e481e464a787e4b2c461af9e62f03905"", ""patch"": ""@@ -1466,6 +1466,43 @@ TEST_F(FileUtilTest, CopyFileWithCopyDirectoryRecursiveToExistingDirectory) {\n   EXPECT_TRUE(file_util::PathExists(file_name_to));\n }\n \n+TEST_F(FileUtilTest, CopyDirectoryWithTrailingSeparators) {\n+  // Create a directory.\n+  FilePath dir_name_from =\n+      temp_dir_.path().Append(FILE_PATH_LITERAL(\""Copy_From_Subdir\""));\n+  file_util::CreateDirectory(dir_name_from);\n+  ASSERT_TRUE(file_util::PathExists(dir_name_from));\n+\n+  // Create a file under the directory.\n+  FilePath file_name_from =\n+      dir_name_from.Append(FILE_PATH_LITERAL(\""Copy_Test_File.txt\""));\n+  CreateTextFile(file_name_from, L\""Gooooooooooooooooooooogle\"");\n+  ASSERT_TRUE(file_util::PathExists(file_name_from));\n+\n+  // Copy the directory recursively.\n+  FilePath dir_name_to =\n+      temp_dir_.path().Append(FILE_PATH_LITERAL(\""Destination\""));\n+  FilePath file_name_to =\n+      dir_name_to.Append(FILE_PATH_LITERAL(\""Copy_Test_File.txt\""));\n+\n+  // Create from path with trailing separators.\n+#if defined(OS_WIN)\n+  FilePath from_path =\n+      temp_dir_.path().Append(FILE_PATH_LITERAL(\""Copy_From_Subdir\\\\\\\\\\\\\""));\n+#elif defined(OS_POSIX)\n+  FilePath from_path =\n+      temp_dir_.path().Append(FILE_PATH_LITERAL(\""Copy_From_Subdir///\""));\n+#endif\n+\n+  EXPECT_TRUE(file_util::CopyDirectory(from_path, dir_name_to, true));\n+\n+  // Check everything has been copied.\n+  EXPECT_TRUE(file_util::PathExists(dir_name_from));\n+  EXPECT_TRUE(file_util::PathExists(file_name_from));\n+  EXPECT_TRUE(file_util::PathExists(dir_name_to));\n+  EXPECT_TRUE(file_util::PathExists(file_name_to));\n+}\n+\n TEST_F(FileUtilTest, CopyFile) {\n   // Create a directory\n   FilePath dir_name_from =""}","bool CopyDirectory(const FilePath& from_path,
                   const FilePath& to_path,
                   bool recursive) {
  base::ThreadRestrictions::AssertIOAllowed();
  DCHECK(to_path.value().find('*') == std::string::npos);
  DCHECK(from_path.value().find('*') == std::string::npos);

  char top_dir[PATH_MAX];
  if (base::strlcpy(top_dir, from_path.value().c_str(),
                    arraysize(top_dir)) >= arraysize(top_dir)) {
    return false;
  }

  FilePath real_to_path = to_path;
  if (PathExists(real_to_path)) {
    if (!AbsolutePath(&real_to_path))
      return false;
  } else {
    real_to_path = real_to_path.DirName();
    if (!AbsolutePath(&real_to_path))
      return false;
  }
  FilePath real_from_path = from_path;
  if (!AbsolutePath(&real_from_path))
    return false;
  if (real_to_path.value().size() >= real_from_path.value().size() &&
      real_to_path.value().compare(0, real_from_path.value().size(),
      real_from_path.value()) == 0)
    return false;

  bool success = true;
  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;
  if (recursive)
    traverse_type |= FileEnumerator::DIRECTORIES;
  FileEnumerator traversal(from_path, recursive, traverse_type);

  FileEnumerator::FindInfo info;
  FilePath current = from_path;
  if (stat(from_path.value().c_str(), &info.stat) < 0) {
    DLOG(ERROR) << ""CopyDirectory() couldn't stat source directory: ""
                << from_path.value() << "" errno = "" << errno;
    success = false;
  }
  struct stat to_path_stat;
  FilePath from_path_base = from_path;
  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&
      S_ISDIR(to_path_stat.st_mode)) {
    from_path_base = from_path.DirName();
  }

   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
    // current is the source path, including from_path, so append
    // the suffix after from_path to to_path to create the target_path.
    FilePath target_path(to_path);
    if (from_path_base != current) {
      if (!from_path_base.AppendRelativePath(current, &target_path)) {
        success = false;
        break;
      }
     }
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&
          errno != EEXIST) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create directory: ""
                    << target_path.value() << "" errno = "" << errno;
        success = false;
      }
    } else if (S_ISREG(info.stat.st_mode)) {
      if (!CopyFile(current, target_path)) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create file: ""
                    << target_path.value();
        success = false;
      }
    } else {
      DLOG(WARNING) << ""CopyDirectory() skipping non-regular file: ""
                    << current.value();
    }

    current = traversal.Next();
    traversal.GetFindInfo(&info);
  }

  return success;
}
","bool CopyDirectory(const FilePath& from_path,
                   const FilePath& to_path,
                   bool recursive) {
  base::ThreadRestrictions::AssertIOAllowed();
  DCHECK(to_path.value().find('*') == std::string::npos);
  DCHECK(from_path.value().find('*') == std::string::npos);

  char top_dir[PATH_MAX];
  if (base::strlcpy(top_dir, from_path.value().c_str(),
                    arraysize(top_dir)) >= arraysize(top_dir)) {
    return false;
  }

  FilePath real_to_path = to_path;
  if (PathExists(real_to_path)) {
    if (!AbsolutePath(&real_to_path))
      return false;
  } else {
    real_to_path = real_to_path.DirName();
    if (!AbsolutePath(&real_to_path))
      return false;
  }
  FilePath real_from_path = from_path;
  if (!AbsolutePath(&real_from_path))
    return false;
  if (real_to_path.value().size() >= real_from_path.value().size() &&
      real_to_path.value().compare(0, real_from_path.value().size(),
      real_from_path.value()) == 0)
    return false;

  bool success = true;
  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;
  if (recursive)
    traverse_type |= FileEnumerator::DIRECTORIES;
  FileEnumerator traversal(from_path, recursive, traverse_type);

  FileEnumerator::FindInfo info;
  FilePath current = from_path;
  if (stat(from_path.value().c_str(), &info.stat) < 0) {
    DLOG(ERROR) << ""CopyDirectory() couldn't stat source directory: ""
                << from_path.value() << "" errno = "" << errno;
    success = false;
  }
  struct stat to_path_stat;
  FilePath from_path_base = from_path;
  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&
      S_ISDIR(to_path_stat.st_mode)) {
    from_path_base = from_path.DirName();
  }

   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
    if (!suffix.empty()) {
      DCHECK_EQ('/', suffix[0]);
      suffix.erase(0, 1);
     }
    const FilePath target_path = to_path.Append(suffix);
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&
          errno != EEXIST) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create directory: ""
                    << target_path.value() << "" errno = "" << errno;
        success = false;
      }
    } else if (S_ISREG(info.stat.st_mode)) {
      if (!CopyFile(current, target_path)) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create file: ""
                    << target_path.value();
        success = false;
      }
    } else {
      DLOG(WARNING) << ""CopyDirectory() skipping non-regular file: ""
                    << current.value();
    }

    current = traversal.Next();
    traversal.GetFindInfo(&info);
  }

  return success;
}
",C,"    // current is the source path, including from_path, so append
    // the suffix after from_path to to_path to create the target_path.
    FilePath target_path(to_path);
    if (from_path_base != current) {
      if (!from_path_base.AppendRelativePath(current, &target_path)) {
        success = false;
        break;
      }
","    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
    if (!suffix.empty()) {
      DCHECK_EQ('/', suffix[0]);
      suffix.erase(0, 1);
    const FilePath target_path = to_path.Append(suffix);
",,"@@ -343,15 +343,15 @@ bool CopyDirectory(const FilePath& from_path,
   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
-    // current is the source path, including from_path, so paste
-    // the suffix after from_path onto to_path to create the target_path.
-    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
-    // Strip the leading '/' (if any).
-    if (!suffix.empty()) {
-      DCHECK_EQ('/', suffix[0]);
-      suffix.erase(0, 1);
+    // current is the source path, including from_path, so append
+    // the suffix after from_path to to_path to create the target_path.
+    FilePath target_path(to_path);
+    if (from_path_base != current) {
+      if (!from_path_base.AppendRelativePath(current, &target_path)) {
+        success = false;
+        break;
+      }
     }
-    const FilePath target_path = to_path.Append(suffix);
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&",Chrome,23803a58e481e464a787e4b2c461af9e62f03905,0297467c47dfe10b7b3495f57b2e1515cfcec55d,1,"bool CopyDirectory(const FilePath& from_path,
                   const FilePath& to_path,
                   bool recursive) {
  base::ThreadRestrictions::AssertIOAllowed();
  // Some old callers of CopyDirectory want it to support wildcards.
  // After some discussion, we decided to fix those callers.
  // Break loudly here if anyone tries to do this.
  // TODO(evanm): remove this once we're sure it's ok.
  DCHECK(to_path.value().find('*') == std::string::npos);
  DCHECK(from_path.value().find('*') == std::string::npos);

  char top_dir[PATH_MAX];
  if (base::strlcpy(top_dir, from_path.value().c_str(),
                    arraysize(top_dir)) >= arraysize(top_dir)) {
    return false;
  }

  // This function does not properly handle destinations within the source
  FilePath real_to_path = to_path;
  if (PathExists(real_to_path)) {
    if (!AbsolutePath(&real_to_path))
      return false;
  } else {
    real_to_path = real_to_path.DirName();
    if (!AbsolutePath(&real_to_path))
      return false;
  }
  FilePath real_from_path = from_path;
  if (!AbsolutePath(&real_from_path))
    return false;
  if (real_to_path.value().size() >= real_from_path.value().size() &&
      real_to_path.value().compare(0, real_from_path.value().size(),
      real_from_path.value()) == 0)
    return false;

  bool success = true;
  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;
  if (recursive)
    traverse_type |= FileEnumerator::DIRECTORIES;
  FileEnumerator traversal(from_path, recursive, traverse_type);

  // We have to mimic windows behavior here. |to_path| may not exist yet,
  // start the loop with |to_path|.
  FileEnumerator::FindInfo info;
  FilePath current = from_path;
  if (stat(from_path.value().c_str(), &info.stat) < 0) {
    DLOG(ERROR) << ""CopyDirectory() couldn't stat source directory: ""
                << from_path.value() << "" errno = "" << errno;
    success = false;
  }
  struct stat to_path_stat;
  FilePath from_path_base = from_path;
  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&
      S_ISDIR(to_path_stat.st_mode)) {
    // If the destination already exists and is a directory, then the
    // top level of source needs to be copied.
    from_path_base = from_path.DirName();
  }

  // The Windows version of this function assumes that non-recursive calls
  // will always have a directory for from_path.
   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
//flaw_line_below:
    // current is the source path, including from_path, so paste
//flaw_line_below:
    // the suffix after from_path onto to_path to create the target_path.
//flaw_line_below:
    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
//flaw_line_below:
    // Strip the leading '/' (if any).
//flaw_line_below:
    if (!suffix.empty()) {
//flaw_line_below:
      DCHECK_EQ('/', suffix[0]);
//flaw_line_below:
      suffix.erase(0, 1);
//fix_flaw_line_below:
//    // current is the source path, including from_path, so append
//fix_flaw_line_below:
//    // the suffix after from_path to to_path to create the target_path.
//fix_flaw_line_below:
//    FilePath target_path(to_path);
//fix_flaw_line_below:
//    if (from_path_base != current) {
//fix_flaw_line_below:
//      if (!from_path_base.AppendRelativePath(current, &target_path)) {
//fix_flaw_line_below:
//        success = false;
//fix_flaw_line_below:
//        break;
//fix_flaw_line_below:
//      }
     }
//flaw_line_below:
    const FilePath target_path = to_path.Append(suffix);
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&
          errno != EEXIST) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create directory: ""
                    << target_path.value() << "" errno = "" << errno;
        success = false;
      }
    } else if (S_ISREG(info.stat.st_mode)) {
      if (!CopyFile(current, target_path)) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create file: ""
                    << target_path.value();
        success = false;
      }
    } else {
      DLOG(WARNING) << ""CopyDirectory() skipping non-regular file: ""
                    << current.value();
    }

    current = traversal.Next();
    traversal.GetFindInfo(&info);
  }

  return success;
}
",185107,"bool CopyDirectory(const FilePath& from_path,
                   const FilePath& to_path,
                   bool recursive) {
  base::ThreadRestrictions::AssertIOAllowed();
  DCHECK(to_path.value().find('*') == std::string::npos);
  DCHECK(from_path.value().find('*') == std::string::npos);

  char top_dir[PATH_MAX];
  if (base::strlcpy(top_dir, from_path.value().c_str(),
                    arraysize(top_dir)) >= arraysize(top_dir)) {
    return false;
  }

  FilePath real_to_path = to_path;
  if (PathExists(real_to_path)) {
    if (!AbsolutePath(&real_to_path))
      return false;
  } else {
    real_to_path = real_to_path.DirName();
    if (!AbsolutePath(&real_to_path))
      return false;
  }
  FilePath real_from_path = from_path;
  if (!AbsolutePath(&real_from_path))
    return false;
  if (real_to_path.value().size() >= real_from_path.value().size() &&
      real_to_path.value().compare(0, real_from_path.value().size(),
      real_from_path.value()) == 0)
    return false;

  bool success = true;
  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;
  if (recursive)
    traverse_type |= FileEnumerator::DIRECTORIES;
  FileEnumerator traversal(from_path, recursive, traverse_type);

  FileEnumerator::FindInfo info;
  FilePath current = from_path;
  if (stat(from_path.value().c_str(), &info.stat) < 0) {
    DLOG(ERROR) << ""CopyDirectory() couldn't stat source directory: ""
                << from_path.value() << "" errno = "" << errno;
    success = false;
  }
  struct stat to_path_stat;
  FilePath from_path_base = from_path;
  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&
      S_ISDIR(to_path_stat.st_mode)) {
    from_path_base = from_path.DirName();
  }

   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
    if (!suffix.empty()) {
      DCHECK_EQ('/', suffix[0]);
      suffix.erase(0, 1);
     }
    const FilePath target_path = to_path.Append(suffix);
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&
          errno != EEXIST) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create directory: ""
                    << target_path.value() << "" errno = "" << errno;
        success = false;
      }
    } else if (S_ISREG(info.stat.st_mode)) {
      if (!CopyFile(current, target_path)) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create file: ""
                    << target_path.value();
        success = false;
      }
    } else {
      DLOG(WARNING) << ""CopyDirectory() skipping non-regular file: ""
                    << current.value();
    }

    current = traversal.Next();
    traversal.GetFindInfo(&info);
  }

  return success;
}
","bool CopyDirectory(const FilePath& from_path,
                   const FilePath& to_path,
                   bool recursive) {
  base::ThreadRestrictions::AssertIOAllowed();
  DCHECK(to_path.value().find('*') == std::string::npos);
  DCHECK(from_path.value().find('*') == std::string::npos);

  char top_dir[PATH_MAX];
  if (base::strlcpy(top_dir, from_path.value().c_str(),
                    arraysize(top_dir)) >= arraysize(top_dir)) {
    return false;
  }

  FilePath real_to_path = to_path;
  if (PathExists(real_to_path)) {
    if (!AbsolutePath(&real_to_path))
      return false;
  } else {
    real_to_path = real_to_path.DirName();
    if (!AbsolutePath(&real_to_path))
      return false;
  }
  FilePath real_from_path = from_path;
  if (!AbsolutePath(&real_from_path))
    return false;
  if (real_to_path.value().size() >= real_from_path.value().size() &&
      real_to_path.value().compare(0, real_from_path.value().size(),
      real_from_path.value()) == 0)
    return false;

  bool success = true;
  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;
  if (recursive)
    traverse_type |= FileEnumerator::DIRECTORIES;
  FileEnumerator traversal(from_path, recursive, traverse_type);

  FileEnumerator::FindInfo info;
  FilePath current = from_path;
  if (stat(from_path.value().c_str(), &info.stat) < 0) {
    DLOG(ERROR) << ""CopyDirectory() couldn't stat source directory: ""
                << from_path.value() << "" errno = "" << errno;
    success = false;
  }
  struct stat to_path_stat;
  FilePath from_path_base = from_path;
  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&
      S_ISDIR(to_path_stat.st_mode)) {
    from_path_base = from_path.DirName();
  }

   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
    // current is the source path, including from_path, so append
    // the suffix after from_path to to_path to create the target_path.
    FilePath target_path(to_path);
    if (from_path_base != current) {
      if (!from_path_base.AppendRelativePath(current, &target_path)) {
        success = false;
        break;
      }
     }
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&
          errno != EEXIST) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create directory: ""
                    << target_path.value() << "" errno = "" << errno;
        success = false;
      }
    } else if (S_ISREG(info.stat.st_mode)) {
      if (!CopyFile(current, target_path)) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create file: ""
                    << target_path.value();
        success = false;
      }
    } else {
      DLOG(WARNING) << ""CopyDirectory() skipping non-regular file: ""
                    << current.value();
    }

    current = traversal.Next();
    traversal.GetFindInfo(&info);
  }

  return success;
}
","The vulnerability in the original `CopyDirectory` code arises from the way the `target_path` is constructed, which could lead to directory traversal attacks. Specifically, the code directly appends the `suffix` derived from `current` to `to_path`, potentially allowing an attacker to manipulate the `from_path` to create files in unintended locations. The fix addresses this by using `from_path_base.AppendRelativePath(current, &target_path)`, ensuring that the `target_path` is correctly derived relative to `from_path_base`, thus preventing unauthorized access to directories outside the intended target. This change enhances security by validating the path construction.","The vulnerability in the original code stems from the way it constructs target paths during directory copying, which could allow for directory traversal attacks. By directly appending parts of the source path to the destination path, an attacker could manipulate the source to create files in unintended locations, potentially compromising system security. The fix addresses this issue by ensuring that the target path is derived in a controlled manner, validating the relationship between the source and destination paths. This change effectively prevents unauthorized access to directories outside the intended target, enhancing the overall security of the operation."
